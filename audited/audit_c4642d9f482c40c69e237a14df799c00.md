# Audit Report

## Title
Chain ID Validation Bypass via Man-in-the-Middle Attack Enabling Cross-Network Transaction Signing

## Summary
The Aptos CLI's `chain_id()` function retrieves the blockchain's chain ID from a REST endpoint without validating it against the user's configured network. Combined with a lack of chain ID display in transaction summaries, this allows an attacker performing a man-in-the-middle (MITM) attack to trick users into signing transactions for an unintended network, potentially leading to loss of mainnet funds.

## Finding Description
The vulnerability exists in how the CLI handles chain ID retrieval and validation during transaction construction: [1](#0-0) 

The `chain_id()` function directly uses the chain ID returned from the REST endpoint's `get_ledger_information()` call with no validation. During transaction submission, this chain ID is extracted from the endpoint response and used to construct transactions: [2](#0-1) 

The CLI's `ProfileConfig` stores the user's expected network (Mainnet, Testnet, Devnet, etc.): [3](#0-2) 

However, there is **no validation** that the chain ID returned from the endpoint matches the expected network stored in the profile. Additionally, the `TransactionSummary` displayed to users does not include the chain ID or network: [4](#0-3) 

**Attack Scenario:**

1. A developer has the same private keys controlling accounts on both mainnet (with valuable APT tokens) and testnet (for testing)
2. Developer configures CLI profile for testnet to test a new transaction
3. Attacker performs MITM attack (via compromised DNS, malicious WiFi, corporate proxy with HTTPS interception, or compromised RPC endpoint)
4. When CLI calls `get_ledger_information()`, attacker returns mainnet chain ID (1) instead of testnet (2)
5. Attacker also returns mainnet account state (sequence number, balance, etc.)
6. Developer constructs what they believe is a testnet transaction (e.g., "transfer 100 APT to test address")
7. CLI constructs transaction with mainnet chain ID (no validation, no warning)
8. Developer reviews transaction details and signs (no chain ID displayed in summary)
9. Attacker submits signed transaction to mainnet
10. Developer's mainnet funds are transferred to attacker's address

The on-chain prologue validation cannot prevent this because the transaction has a valid mainnet chain ID and is submitted to mainnet - it will execute successfully.

## Impact Explanation
This vulnerability meets **Critical Severity** criteria per Aptos bug bounty:

- **Loss of Funds**: Users can lose mainnet APT tokens by unknowingly signing mainnet transactions when they believe they are on testnet
- **Realistic Attack Vector**: Developers commonly reuse keys across networks for convenience
- **Silent Failure**: No warnings or validation alerts the user to the chain ID mismatch
- **Defense-in-Depth Violation**: The system relies solely on TLS/HTTPS security without application-layer validation

While TLS certificate validation provides primary protection against MITM, there are realistic scenarios where it fails:
- Corporate environments with HTTPS-intercepting proxies
- Compromised DNS with valid certificates
- Users connecting to malicious custom RPC endpoints with valid HTTPS
- Local development using HTTP endpoints

The impact is fund loss on mainnet, which is the highest severity category in the Aptos bug bounty program.

## Likelihood Explanation
**Likelihood: Medium**

Factors increasing likelihood:
- Developers commonly reuse keys across mainnet/testnet for convenience
- Corporate networks often intercept HTTPS traffic
- Custom/third-party RPC endpoints may be malicious
- DNS hijacking attacks are increasingly common
- Local development often uses HTTP endpoints

Factors decreasing likelihood:
- Requires MITM capability or compromised RPC endpoint
- Official Aptos endpoints use HTTPS with valid certificates
- Users might notice account balance/state discrepancies

The overall likelihood is medium because while TLS provides protection in most cases, there are multiple realistic scenarios where this protection fails or is bypassed.

## Recommendation

Add chain ID validation in the transaction construction flow to verify that the retrieved chain ID matches the user's expected network configuration:

**Location:** `crates/aptos/src/common/types.rs` in the `submit_transaction` method

**Fix:**

```rust
// After line 1976 where chain_id is extracted:
let chain_id = ChainId::new(state.chain_id);

// Add validation:
if let Ok(Some(profile)) = CliConfig::load_profile(
    self.profile_options.profile_name(),
    ConfigSearchMode::CurrentDirAndParents,
) {
    if let Some(expected_network) = profile.network {
        let expected_chain_id = match expected_network {
            Network::Mainnet => ChainId::mainnet(),
            Network::Testnet => ChainId::testnet(),
            Network::Devnet => ChainId::new(NamedChain::DEVNET.id()),
            _ => chain_id, // Custom/Local networks - skip validation
        };
        
        if expected_chain_id != chain_id {
            return Err(CliError::UnexpectedError(format!(
                "Chain ID mismatch! Expected {} (network: {:?}) but got {}. \
                This may indicate a man-in-the-middle attack or misconfigured RPC endpoint.",
                expected_chain_id, expected_network, chain_id
            )));
        }
    }
}
```

Additionally, add chain ID to `TransactionSummary` for user visibility:

```rust
pub struct TransactionSummary {
    pub transaction_hash: HashValue,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub chain_id: Option<u8>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub network: Option<String>,
    // ... existing fields
}
```

## Proof of Concept

**Test Setup:**
```rust
// In crates/aptos/tests/chain_id_validation_test.rs

#[tokio::test]
async fn test_chain_id_mismatch_detection() {
    // 1. Setup: Create profile configured for testnet
    let mut profile = ProfileConfig::default();
    profile.network = Some(Network::Testnet);
    profile.rest_url = Some("http://localhost:8080".to_string()); // Attacker endpoint
    
    // 2. Mock REST endpoint that returns mainnet chain_id
    // (when user expects testnet)
    let mock_server = MockServer::start().await;
    
    Mock::given(method("GET"))
        .and(path("/v1"))
        .respond_with(ResponseTemplate::new(200).set_body_json(json!({
            "chain_id": 1, // Mainnet chain ID
            "ledger_version": "1000",
            "ledger_timestamp": "1234567890"
        })))
        .mount(&mock_server)
        .await;
    
    // 3. Attempt to construct transaction
    let txn_options = TransactionOptions {
        profile_options: ProfileOptions { profile: Some("test".to_string()) },
        rest_options: RestOptions { url: Some(mock_server.uri().parse().unwrap()) },
        // ... other options
    };
    
    // 4. Verify: Should fail with chain ID mismatch error
    let payload = TransactionPayload::EntryFunction(/* some payload */);
    let result = txn_options.submit_transaction(payload).await;
    
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Chain ID mismatch"));
    assert!(result.unwrap_err().to_string().contains("Expected 2"));
    assert!(result.unwrap_err().to_string().contains("but got 1"));
}
```

**Manual Reproduction:**
```bash
# 1. Initialize CLI for testnet
aptos init --network testnet

# 2. Setup malicious proxy that returns mainnet chain_id
#    (returns chain_id: 1 instead of 2)

# 3. Try to send transaction through proxy
aptos account transfer --account 0x123... --amount 1000000000

# Expected: Transaction should fail with chain ID mismatch error
# Actual (vulnerable): Transaction constructs with mainnet chain_id silently
```

**Notes**

This vulnerability represents a violation of the defense-in-depth security principle. While HTTPS/TLS provides the primary layer of protection against MITM attacks, the absence of application-layer chain ID validation creates a single point of failure. The fix is simple, has no performance impact, and significantly improves security posture by protecting users in scenarios where TLS protection is bypassed or compromised.

The vulnerability is particularly concerning for developers who maintain accounts with the same keys on multiple networks (a common practice for testing), as they risk losing real mainnet funds when they believe they are performing test transactions on testnet.

### Citations

**File:** crates/aptos/src/common/utils.rs (L313-320)
```rust
pub async fn chain_id(rest_client: &Client) -> CliTypedResult<ChainId> {
    let state = rest_client
        .get_ledger_information()
        .await
        .map_err(|err| CliError::ApiError(err.to_string()))?
        .into_inner();
    Ok(ChainId::new(state.chain_id))
}
```

**File:** crates/aptos/src/common/types.rs (L270-305)
```rust
#[derive(Debug, Default, Serialize, Deserialize)]
pub struct ProfileConfig {
    /// Name of network being used, if setup from aptos init
    #[serde(skip_serializing_if = "Option::is_none")]
    pub network: Option<Network>,
    /// Private key for commands.
    #[serde(
        skip_serializing_if = "Option::is_none",
        default,
        serialize_with = "serialize_material_with_prefix",
        deserialize_with = "deserialize_material_with_prefix"
    )]
    pub private_key: Option<Ed25519PrivateKey>,
    /// Public key for commands
    #[serde(
        skip_serializing_if = "Option::is_none",
        serialize_with = "serialize_material_with_prefix",
        deserialize_with = "deserialize_material_with_prefix"
    )]
    pub public_key: Option<Ed25519PublicKey>,
    /// Account for commands
    #[serde(
        skip_serializing_if = "Option::is_none",
        deserialize_with = "deserialize_address_str"
    )]
    pub account: Option<AccountAddress>,
    /// URL for the Aptos rest endpoint
    #[serde(skip_serializing_if = "Option::is_none")]
    pub rest_url: Option<String>,
    /// URL for the Faucet endpoint (if applicable)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub faucet_url: Option<String>,
    /// Derivation path index of the account on ledger
    #[serde(skip_serializing_if = "Option::is_none")]
    pub derivation_path: Option<String>,
}
```

**File:** crates/aptos/src/common/types.rs (L1492-1518)
```rust
pub struct TransactionSummary {
    pub transaction_hash: HashValue,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub gas_used: Option<u64>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub gas_unit_price: Option<u64>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub pending: Option<bool>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sender: Option<AccountAddress>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sequence_number: Option<u64>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub replay_protector: Option<ReplayProtector>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub success: Option<bool>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub timestamp_us: Option<u64>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub version: Option<u64>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub vm_status: Option<String>,

    /// The address of the deployed code object. Only present for code object deployment transactions.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub deployed_object_address: Option<AccountAddress>,
}
```

**File:** crates/aptos/src/common/types.rs (L1959-1976)
```rust
        let (account, state) = get_account_with_state(&client, sender_address).await?;
        let sequence_number = account.sequence_number;

        // Retrieve local time, and ensure it's within an expected skew of the blockchain
        let now = SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .map_err(|err| CliError::UnexpectedError(err.to_string()))?
            .as_secs();
        let now_usecs = now * US_IN_SECS;

        // Warn local user that clock is skewed behind the blockchain.
        // There will always be a little lag from real time to blockchain time
        if now_usecs < state.timestamp_usecs - ACCEPTED_CLOCK_SKEW_US {
            eprintln!("Local clock is is skewed from blockchain clock.  Clock is more than {} seconds behind the blockchain {}", ACCEPTED_CLOCK_SKEW_US, state.timestamp_usecs / US_IN_SECS );
        }
        let expiration_time_secs = now + self.gas_options.expiration_secs;

        let chain_id = ChainId::new(state.chain_id);
```
