# Audit Report

## Title
Consensus Observer Timeout Bypass via Minimal Progress Attack

## Summary
A malicious or slow peer can keep a consensus observer subscribed indefinitely by providing minimal incremental progress (e.g., 1 version increase) just before timeout thresholds, preventing the observer from detecting poor performance and switching to better peers. This allows the observer to fall progressively behind the network while remaining subscribed to a suboptimal peer.

## Finding Description

The consensus observer's subscription health check uses two independent timeout mechanisms to detect when a peer is not providing adequate sync progress:

1. **Subscription-level check**: `check_syncing_progress()` monitors if the DB version is increasing [1](#0-0) 

2. **Fallback manager check**: Validates both version progress and block timestamp lag [2](#0-1) 

The vulnerability exists because when the DB version increases by any amount (even just 1 version), the timeout timer is reset to the current time [3](#0-2) 

An attacker exploits this by:
1. Sending blocks with timestamps approximately 14 seconds old (under the 15-second `observer_fallback_sync_lag_threshold_ms`) [4](#0-3) 
2. Sending them every 9 seconds (under the 10-second `observer_fallback_progress_threshold_ms`)
3. Each block causes the version to increase by 1, resetting both timeout timers
4. The observer makes progress of ~6-7 versions per minute (extremely slow compared to normal ~60+ versions per minute)
5. The observer stays perpetually 14 seconds behind the network tip
6. Neither the subscription timeout nor fallback timeout triggers

The system lacks:
- **Rate-based validation**: No check for versions synced per unit time
- **Absolute network comparison**: No validation that the observer is keeping pace with the actual network tip
- **Consistent lag detection**: No detection of sustained near-threshold lag patterns

## Impact Explanation

**Medium Severity** - This vulnerability causes:
- **Performance degradation**: Observer nodes sync at 10% of normal speed
- **Persistent poor peer selection**: Prevents the observer from switching to better peers despite suboptimal performance
- **Cascading lag accumulation**: Over time, observers fall increasingly behind the network

This qualifies as Medium severity per Aptos bug bounty criteria: "State inconsistencies requiring intervention" - affected observer nodes would require manual intervention to detect and resolve the persistent lag issue. The vulnerability doesn't cause fund loss or consensus safety violations, but significantly degrades node operational health.

## Likelihood Explanation

**Likelihood: Medium-to-High**

This attack is feasible because:
1. **Low barrier to execution**: Any peer can become slow or malicious without special privileges
2. **Natural occurrence**: Network latency, resource constraints, or software bugs could unintentionally create this scenario
3. **No detection mechanism**: The observer has no built-in alerting for sustained minimal progress
4. **Peer selection limitations**: If optimal peers are scarce, observers may stay connected to slow peers

The attack requires:
- Ability to control block forwarding timing (achievable by any peer)
- Access to recent blocks from the network (normal peer operation)
- Precise timing control (trivial with basic scheduling)

## Recommendation

Implement rate-based progress validation in addition to timeout-based checks:

```rust
// In ConsensusObserverSubscription
struct ConsensusObserverSubscription {
    // ... existing fields ...
    
    // Track versions synced over a sliding window
    sync_rate_window: VecDeque<(u64, Instant)>, // (version, timestamp) pairs
    min_acceptable_sync_rate: u64, // versions per second
}

fn check_syncing_progress(&mut self) -> Result<(), Error> {
    let time_now = self.time_service.now();
    let current_synced_version = self.db_reader
        .get_latest_ledger_info_version()
        .map_err(|error| {
            Error::UnexpectedError(format!(
                "Failed to read highest synced version: {:?}",
                error
            ))
        })?;

    let (highest_synced_version, highest_version_timestamp) =
        self.highest_synced_version_and_time;
        
    if current_synced_version <= highest_synced_version {
        // Existing timeout check
        let duration_since_highest_seen = time_now.duration_since(highest_version_timestamp);
        let timeout_duration = Duration::from_millis(
            self.consensus_observer_config.max_subscription_sync_timeout_ms,
        );
        if duration_since_highest_seen > timeout_duration {
            return Err(Error::SubscriptionProgressStopped(format!(
                "The DB is not making sync progress! Highest synced version: {}, elapsed: {:?}",
                highest_synced_version, duration_since_highest_seen
            )));
        }
        return Ok(());
    }

    // NEW: Rate-based validation
    self.sync_rate_window.push_back((current_synced_version, time_now));
    
    // Keep only last 60 seconds of data
    while let Some((_, oldest_time)) = self.sync_rate_window.front() {
        if time_now.duration_since(*oldest_time) > Duration::from_secs(60) {
            self.sync_rate_window.pop_front();
        } else {
            break;
        }
    }
    
    // Check sync rate if we have enough data points
    if self.sync_rate_window.len() >= 2 {
        if let Some((first_version, first_time)) = self.sync_rate_window.front() {
            let version_delta = current_synced_version - first_version;
            let time_delta_secs = time_now.duration_since(*first_time).as_secs_f64();
            
            if time_delta_secs > 30.0 { // Only check after 30 seconds of data
                let sync_rate = version_delta as f64 / time_delta_secs;
                
                // Minimum acceptable: 5 versions/second (configurable)
                if sync_rate < self.min_acceptable_sync_rate as f64 {
                    return Err(Error::SubscriptionProgressStopped(format!(
                        "Sync rate too low! Current rate: {:.2} versions/sec, minimum: {} versions/sec",
                        sync_rate, self.min_acceptable_sync_rate
                    )));
                }
            }
        }
    }

    // Update the highest synced version and time
    self.highest_synced_version_and_time = (current_synced_version, time_now);
    Ok(())
}
```

Additional config parameter:
```rust
pub struct ConsensusObserverConfig {
    // ... existing fields ...
    
    /// Minimum acceptable sync rate in versions per second
    pub min_sync_rate_versions_per_sec: u64,
}

impl Default for ConsensusObserverConfig {
    fn default() -> Self {
        Self {
            // ... existing defaults ...
            min_sync_rate_versions_per_sec: 5, // Minimum 5 versions/sec
        }
    }
}
```

## Proof of Concept

```rust
#[tokio::test]
async fn test_minimal_progress_attack() {
    use std::sync::Arc;
    use aptos_config::config::ConsensusObserverConfig;
    use aptos_time_service::TimeService;
    use std::time::Duration;
    
    // Create a consensus observer config with standard timeouts
    let consensus_observer_config = ConsensusObserverConfig {
        max_subscription_sync_timeout_ms: 15_000,  // 15 seconds
        max_subscription_timeout_ms: 100_000_000,  // Large value to isolate sync check
        ..ConsensusObserverConfig::default()
    };

    // Create a mock DB reader that simulates minimal progress
    let mut mock_db_reader = MockDatabaseReader::new();
    let mut version = 0u64;
    
    mock_db_reader
        .expect_get_latest_ledger_info_version()
        .returning(move || {
            version += 1; // Increment by 1 each call
            Ok(version)
        });

    // Create a new observer subscription
    let time_service = TimeService::mock();
    let peer_network_id = PeerNetworkId::random();
    let mut subscription = ConsensusObserverSubscription::new(
        consensus_observer_config,
        Arc::new(mock_db_reader),
        peer_network_id,
        time_service.clone(),
    );

    let mock_time_service = time_service.into_mock();
    
    // Simulate 10 rounds of minimal progress attack
    for round in 0..10 {
        // Wait 14 seconds (just under 15 second timeout)
        mock_time_service.advance(Duration::from_millis(14_000));
        
        // Check syncing progress - should succeed despite minimal progress
        let result = subscription.check_syncing_progress();
        
        println!("Round {}: Version at {}, Progress check: {:?}", 
                 round, round + 1, result);
        
        // The vulnerability: this should fail but succeeds
        assert!(result.is_ok(), 
                "Subscription accepted minimal progress at round {}", round);
    }
    
    // After 10 rounds (140 seconds), only 10 versions synced
    // Normal rate: 140 seconds * 1 block/sec = ~140 versions
    // Attack rate: 10 versions in 140 seconds = 0.07 versions/sec
    // Observer is now 130 versions behind but hasn't detected the issue
    
    println!("Attack successful: Observer accepted only 10 versions in 140 seconds");
    println!("Expected: ~140 versions. Gap: 130 versions (93% behind)");
}
```

**Notes**

This vulnerability affects consensus observer nodes (typically validator full nodes and public full nodes) that rely on peer subscriptions for consensus data. While the fallback manager's sync lag check provides some protection by comparing block timestamps, a sophisticated attacker can exploit the gap between timeout thresholds (10-15 seconds) and maintain consistent near-threshold lag. The lack of rate-based validation allows observers to make technically "valid" progress while falling progressively behind the network, never triggering timeout mechanisms designed to switch to better peers.

### Citations

**File:** consensus/src/consensus_observer/observer/subscription.rs (L185-222)
```rust
    fn check_syncing_progress(&mut self) -> Result<(), Error> {
        // Get the current time and synced version from storage
        let time_now = self.time_service.now();
        let current_synced_version =
            self.db_reader
                .get_latest_ledger_info_version()
                .map_err(|error| {
                    Error::UnexpectedError(format!(
                        "Failed to read highest synced version: {:?}",
                        error
                    ))
                })?;

        // Verify that the synced version is increasing appropriately
        let (highest_synced_version, highest_version_timestamp) =
            self.highest_synced_version_and_time;
        if current_synced_version <= highest_synced_version {
            // The synced version hasn't increased. Check if we should terminate
            // the subscription based on the last time the highest synced version was seen.
            let duration_since_highest_seen = time_now.duration_since(highest_version_timestamp);
            let timeout_duration = Duration::from_millis(
                self.consensus_observer_config
                    .max_subscription_sync_timeout_ms,
            );
            if duration_since_highest_seen > timeout_duration {
                return Err(Error::SubscriptionProgressStopped(format!(
                    "The DB is not making sync progress! Highest synced version: {}, elapsed: {:?}",
                    highest_synced_version, duration_since_highest_seen
                )));
            }
            return Ok(()); // We haven't timed out yet
        }

        // Update the highest synced version and time
        self.highest_synced_version_and_time = (current_synced_version, time_now);

        Ok(())
    }
```

**File:** consensus/src/consensus_observer/observer/fallback_manager.rs (L58-85)
```rust
    pub fn check_syncing_progress(&mut self) -> Result<(), Error> {
        // If we're still within the startup period, we don't need to verify progress
        let time_now = self.time_service.now();
        let startup_period = Duration::from_millis(
            self.consensus_observer_config
                .observer_fallback_startup_period_ms,
        );
        if time_now.duration_since(self.start_time) < startup_period {
            return Ok(()); // We're still in the startup period
        }

        // Fetch the synced ledger info version from storage
        let latest_ledger_info_version =
            self.db_reader
                .get_latest_ledger_info_version()
                .map_err(|error| {
                    Error::UnexpectedError(format!(
                        "Failed to read highest synced version: {:?}",
                        error
                    ))
                })?;

        // Verify that the synced version is increasing appropriately
        self.verify_increasing_sync_versions(latest_ledger_info_version, time_now)?;

        // Verify that the sync lag is within acceptable limits
        self.verify_sync_lag_health(latest_ledger_info_version)
    }
```

**File:** config/src/config/consensus_observer_config.rs (L75-82)
```rust
            max_subscription_sync_timeout_ms: 15_000, // 15 seconds
            max_subscription_timeout_ms: 15_000, // 15 seconds
            subscription_peer_change_interval_ms: 180_000, // 3 minutes
            subscription_refresh_interval_ms: 600_000, // 10 minutes
            observer_fallback_duration_ms: 600_000, // 10 minutes
            observer_fallback_startup_period_ms: 60_000, // 60 seconds
            observer_fallback_progress_threshold_ms: 10_000, // 10 seconds
            observer_fallback_sync_lag_threshold_ms: 15_000, // 15 seconds
```
