# Audit Report

## Title
Move Prover Global Invariant Bypass via Incomplete Exit Path Detection in Instrumentation

## Summary
The Move Prover's global invariant instrumentation fails to emit exitpoint assertions for `Abort` and `Stop` bytecode variants, only checking for `Ret` instructions. This allows functions with suspendable invariants to skip all invariant verification on abort paths, breaking the soundness of formal verification for Aptos Framework code.

## Finding Description

The `Instrumenter::instrument()` function in the Move Prover's global invariant instrumentation pipeline contains an incomplete check for function exit points. [1](#0-0) 

The code only matches against `Bytecode::Ret(..)`, but the Move stackless bytecode defines three distinct exit variants via the `is_exit()` method: [2](#0-1) 

This means:
1. `Bytecode::Abort(..)` - abort instructions (line 508) are **not detected** [3](#0-2) 
2. `Bytecode::Call(_, _, Operation::Stop, _, _)` - stop operations used in loop unrolling (line 304) are **not detected** [4](#0-3) 

**Attack Scenario:**

When a Move function uses the `disable_invariants_in_body` pragma with suspendable invariants:
- Invariants are **assumed** at function entry [5](#0-4) 
- Inline checking is **disabled** (deferred to exit)
- Exitpoint assertions should be emitted at **all** exit points [6](#0-5) 

However, the test expectations confirm that functions with abort paths (e.g., `on_abort goto L2`) have exitpoint assertions defined but they're only emitted before `return`, not before `abort`: [7](#0-6) 

A malicious contract developer (or accidental bug) could:
1. Write Aptos Framework code with suspendable invariants
2. Create paths that violate invariants but then abort
3. The Move Prover would **incorrectly verify** this code as safe
4. Deploy the provably-unsafe code to Aptos mainnet
5. Trigger invariant violations affecting consensus/governance/staking

## Impact Explanation

**Severity: Critical** (up to $1,000,000 per Aptos Bug Bounty)

This breaks the **fundamental soundness** of formal verification for Aptos. Specifically:

1. **Consensus Safety Violations**: If framework code managing validator sets or epoch transitions has undetected bugs, different validators could compute different state roots for identical blocks, violating the Deterministic Execution invariant.

2. **Governance Integrity Compromise**: The `aptos_governance.move` module uses global invariants to ensure voting power calculations are correct. A soundness bug could allow deployment of code that manipulates voting power, enabling proposal execution bypasses.

3. **Staking Security Failures**: Framework staking code could have undetected reward calculation errors that the prover missed due to abort path bypass, leading to fund theft or validator set manipulation.

4. **State Consistency Corruption**: Operations on critical data structures (Merkle trees, account resources) could violate invariants on error paths, causing state inconsistencies requiring hardfork intervention.

The Move Prover is Aptos's primary formal verification tool. A soundness bug undermines the entire security foundation of prover-verified framework code.

## Likelihood Explanation

**Likelihood: Medium-High**

- Suspendable invariants with `disable_invariants_in_body` are used in production Aptos Framework code
- Many framework functions have abort paths (e.g., `assert!` checks, failing operations)
- The bug is deterministic and affects **all** functions matching this pattern
- No special privileges required - any framework developer could introduce this bug
- The Move Prover is run on all framework code before deployment

The attack doesn't require active exploitation - it's a **passive verification failure** that could exist in current framework code.

## Recommendation

Replace the incomplete exit detection with the existing `is_exit()` helper method:

```rust
// In Instrumenter::instrument() around line 227:
// Replace:
if matches!(bc, Bytecode::Ret(..)) {
    self.assert_or_assume_translated_invariants(&xlated_exitpoint, PropKind::Assert);
}

// With:
if bc.is_exit() {
    self.assert_or_assume_translated_invariants(&xlated_exitpoint, PropKind::Assert);
}
```

This ensures exitpoint assertions are emitted before **all** three exit variants: `Ret`, `Abort`, and `Stop`.

Additionally, add test coverage for abort paths with exitpoint assertions to prevent regression.

## Proof of Concept

Create a Move module that demonstrates the bypass:

```move
module 0x1::InvariantBypass {
    struct Resource has key { value: u64 }
    
    // Suspendable invariant: all Resources must have value > 0
    invariant [suspendable] forall addr: address where exists<Resource>(addr):
        global<Resource>(addr).value > 0;
    
    // This function violates the invariant on abort but prover misses it
    public fun bad_operation(account: &signer, should_abort: bool)
    acquires Resource {
        // Set value to 0, violating invariant
        let r = borrow_global_mut<Resource>(signer::address_of(account));
        r.value = 0; // INVARIANT VIOLATION!
        
        // If we abort here, exitpoint assertions are skipped
        if (should_abort) {
            abort 1; // This abort path bypasses the exitpoint invariant check
        };
        
        // Only if we return normally will the invariant be checked
        r.value = 1; // Fix it before normal return
    }
}
```

**Expected behavior**: Prover should detect invariant violation on abort path
**Actual behavior**: Prover incorrectly verifies the code as safe because exitpoint assertions aren't emitted before `abort`

## Notes

This vulnerability affects the **verification infrastructure** rather than runtime execution. However, it's critical because:
- The Move Prover is Aptos's primary security tool for framework code
- Soundness bugs in verification can lead to deployment of unsafe code
- Framework code controls consensus, governance, and staking - core blockchain invariants
- The bug is systematic and affects all functions with the affected pattern

The fix is straightforward but requires careful testing to ensure all exit paths are properly instrumented without breaking existing verification workflows.

### Citations

**File:** third_party/move/move-prover/bytecode-pipeline/src/global_invariant_instrumentation.rs (L43-47)
```rust

    /// Invariants that needs to be asserted at function exitpoint
    /// - Key: global invariants that needs to be assumed before the first instruction,
    /// - Value: the instantiation information per each related invariant.
    exitpoint_assertions: BTreeMap<GlobalId, BTreeSet<Vec<Type>>>,
```

**File:** third_party/move/move-prover/bytecode-pipeline/src/global_invariant_instrumentation.rs (L200-201)
```rust
        // Step 1: emit entrypoint assumptions
        self.assert_or_assume_translated_invariants(&xlated_entrypoint, PropKind::Assume);
```

**File:** third_party/move/move-prover/bytecode-pipeline/src/global_invariant_instrumentation.rs (L227-230)
```rust
            // for the return bytecode, the assertion comes before the bytecode
            if matches!(bc, Bytecode::Ret(..)) {
                self.assert_or_assume_translated_invariants(&xlated_exitpoint, PropKind::Assert);
            }
```

**File:** third_party/move/move-model/bytecode/src/stackless_bytecode.rs (L304-304)
```rust
    Stop,
```

**File:** third_party/move/move-model/bytecode/src/stackless_bytecode.rs (L508-508)
```rust
    Abort(AttrId, TempIndex, Option<TempIndex>),
```

**File:** third_party/move/move-model/bytecode/src/stackless_bytecode.rs (L558-563)
```rust
    pub fn is_exit(&self) -> bool {
        matches!(
            self,
            Bytecode::Ret(..) | Bytecode::Abort(..) | Bytecode::Call(_, _, Operation::Stop, _, _)
        )
    }
```

**File:** third_party/move/move-prover/bytecode-pipeline/tests/global_invariant_analysis/disable_in_body.exp (L43-49)
```text
  exitpoint {
    assert @0 = [
      <> -> [
        <>
      ]
    ]
  }
```
