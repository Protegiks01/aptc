# Audit Report

## Title
Incomplete Aggregator V1 Read Validation in BlockSTMv2 Allows Read-Only Aggregator Bypass

## Summary
The `validate_aggregator_v1_reads()` function in BlockSTMv2 contains an incomplete validation check that only verifies aggregator reads for keys that were also written. This allows aggregator state keys that are read through the resource API (instead of the aggregator API) to bypass validation if they are not written in the same transaction, potentially breaking BlockSTMv2's read-set tracking invariants.

## Finding Description
The vulnerability exists in the validation logic that maintains consistency between `data_reads` and `aggregator_v1_reads` tracking structures. [1](#0-0) 

The function performs two checks:

**Check 1** (lines 975-985): Validates that every key in `aggregator_v1_reads` has a corresponding entry in `data_reads`. This ensures `aggregator_v1_reads ⊆ data_reads`.

**Check 2** (lines 997-1005): Validates that for keys in `aggregator_write_keys`, if they exist in `data_reads`, they must also be in `aggregator_v1_reads`. The comment explicitly states this "protects against the case where aggregator v1 state value read was read by a wrong interface (e.g. via resource API)".

**The Gap:** Check 2 only validates the intersection `(aggregator_write_keys ∩ data_reads)`. Keys that are:
- Read through the resource API (added to `data_reads` only)
- NOT written (not in `aggregator_write_keys`)
- Are NOT validated by Check 2

This breaks the intended invariant that all aggregator state key reads should be tracked in `aggregator_v1_reads`.

**How it breaks system guarantees:**

When `get_aggregator_v1_state_value()` is properly called, it tracks the read in both structures: [2](#0-1) 

However, if an aggregator state key is read through `get_resource_state_value()` directly (bypassing aggregator tracking), it only adds to `data_reads`: [3](#0-2) 

This discrepancy could occur through:
1. Internal code paths that read aggregator storage locations as regular resources
2. Framework code that accesses aggregator state through resource APIs
3. Future code modifications that don't properly use aggregator interfaces

## Impact Explanation
This qualifies as **High Severity** under Aptos bug bounty criteria for "Significant protocol violations":

1. **BlockSTMv2 Invariant Violation**: The tracking invariant that all aggregator reads must be in `aggregator_v1_reads` can be violated for read-only operations.

2. **Incomplete Read-Set Tracking**: Transactions can have incomplete read-sets for aggregator v1 values, affecting BlockSTMv2's conflict detection and validation logic.

3. **Validation Logic Bypass**: The explicit protection against wrong-interface reads (lines 994-996) is incomplete and can be bypassed.

4. **Potential State Consistency Issues**: If different validators or execution paths handle these reads differently, it could lead to deterministic execution violations across the network.

5. **Execution Correctness**: The `validate_aggregator_v1_reads()` is called during commit validation, and bypassing its checks could allow transactions with incorrect aggregator read tracking to commit. [4](#0-3) 

## Likelihood Explanation
**Likelihood: Medium to Low**

While the validation gap exists, exploitability depends on:

1. **Existence of Bypass Path**: There must be a code path that reads aggregator state keys through resource APIs instead of aggregator APIs.

2. **Read-Only Scenario**: The aggregator key must be read but not written in the same transaction.

3. **Framework Control**: Most aggregator access goes through Move native functions which properly use `get_aggregator_v1_state_value()`: [5](#0-4) 

4. **Internal Implementation Risk**: The risk increases with:
   - Future code changes that don't follow aggregator interface conventions
   - Internal system paths that might access aggregator storage directly
   - Framework modifications that bypass proper aggregator APIs

## Recommendation
Extend the validation to check ALL aggregator-related keys in `data_reads`, not just those that were written:

```rust
pub(crate) fn validate_aggregator_v1_reads(
    &self,
    data_map: &VersionedData<T::Key, T::Value>,
    aggregator_write_keys: impl Iterator<Item = T::Key>,
    idx_to_validate: TxnIndex,
) -> Result<bool, PanicError> {
    // Existing Check 1 (lines 974-985) remains the same
    let mut aggregator_v1_iterable = Vec::with_capacity(self.aggregator_v1_reads.len());
    for k in &self.aggregator_v1_reads {
        match self.data_reads.get(k) {
            Some(data_read) => aggregator_v1_iterable.push((k, data_read)),
            None => {
                return Err(code_invariant_error(format!(
                    "Aggregator v1 read {:?} not found among captured data reads",
                    k
                )));
            },
        }
    }

    let ret = self.validate_data_reads_impl(
        aggregator_v1_iterable.into_iter(),
        data_map,
        idx_to_validate,
    );

    if ret {
        // NEW: Collect all aggregator keys (both read and written)
        let all_aggregator_keys: HashSet<T::Key> = aggregator_write_keys.collect();
        
        // Check that ALL aggregator-related keys in data_reads are also tracked
        // This requires maintaining a registry of which keys are aggregators
        // OR checking both reads AND writes
        for key in &all_aggregator_keys {
            if self.data_reads.contains_key(key) && !self.aggregator_v1_reads.contains(key) {
                return Err(code_invariant_error(format!(
                    "Captured read at aggregator key {:?} not found among AggregatorV1 reads",
                    key
                )));
            }
        }
    }

    Ok(ret)
}
```

**Additional Defense:** Add runtime assertions in `get_resource_state_value()` to detect when aggregator state keys are accessed without proper tracking, or maintain a global registry of aggregator state keys for validation.

## Proof of Concept
Since this vulnerability requires demonstrating an internal code path that bypasses proper aggregator tracking, a PoC would need to:

1. Identify or create a code path that calls `get_resource_state_value()` on an aggregator state key
2. Ensure the transaction reads but doesn't write the aggregator
3. Verify that validation passes incorrectly

**Conceptual PoC Structure:**

```rust
// Hypothetical scenario requiring framework-level access
#[test]
fn test_aggregator_read_tracking_bypass() {
    // Setup: Create an aggregator at a known state key
    let aggregator_key = /* aggregator state key */;
    
    // Step 1: Execute transaction that reads aggregator via resource API
    // (This would require modifying framework code or using internal paths)
    let view = LatestView::new(/* ... */);
    
    // Bypass: Call get_resource_state_value directly instead of get_aggregator_v1_state_value
    let value = view.get_resource_state_value(&aggregator_key, None);
    
    // Step 2: Don't write to the aggregator
    // Step 3: Validate - should fail but might pass due to incomplete check
    
    let captured_reads = /* extract from view */;
    assert!(captured_reads.data_reads.contains_key(&aggregator_key));
    assert!(!captured_reads.aggregator_v1_reads.contains(&aggregator_key));
    
    // This should fail validation but might pass if key not in write set
    let result = captured_reads.validate_aggregator_v1_reads(
        data_map,
        std::iter::empty(), // No writes
        txn_idx,
    );
    
    // Vulnerability: validation passes incorrectly
    assert!(result.is_ok());
}
```

**Notes**

This vulnerability represents a logical gap in validation coverage rather than a directly user-exploitable bug. The impact depends on whether actual code paths exist that trigger the bypass condition. The developers were aware of the potential issue (evidenced by the comment and partial fix) but the protection is incomplete for read-only scenarios. A complete fix should validate ALL aggregator reads, not just those accompanied by writes.

### Citations

**File:** aptos-move/block-executor/src/captured_reads.rs (L966-1010)
```rust
    pub(crate) fn validate_aggregator_v1_reads(
        &self,
        data_map: &VersionedData<T::Key, T::Value>,
        aggregator_write_keys: impl Iterator<Item = T::Key>,
        idx_to_validate: TxnIndex,
    ) -> Result<bool, PanicError> {
        // Few aggregator v1 instances exist in the system (and legacy now, deprecated
        // by DelayedFields), hence the efficiency of construction below is not a concern.
        let mut aggregator_v1_iterable = Vec::with_capacity(self.aggregator_v1_reads.len());
        for k in &self.aggregator_v1_reads {
            match self.data_reads.get(k) {
                Some(data_read) => aggregator_v1_iterable.push((k, data_read)),
                None => {
                    return Err(code_invariant_error(format!(
                        "Aggregator v1 read {:?} not found among captured data reads",
                        k
                    )));
                },
            }
        }

        let ret = self.validate_data_reads_impl(
            aggregator_v1_iterable.into_iter(),
            data_map,
            idx_to_validate,
        );

        if ret {
            // Additional invariant check (that AggregatorV1 reads are captured for
            // aggregator write keys). This protects against the case where aggregator v1
            // state value read was read by a wrong interface (e.g. via resource API).
            for key in aggregator_write_keys {
                if self.data_reads.contains_key(&key) && !self.aggregator_v1_reads.contains(&key) {
                    // Not assuming read-before-write here: if there was a read, it must also be
                    // captured as an aggregator_v1 read.
                    return Err(code_invariant_error(format!(
                        "Captured read at aggregator key {:?} not found among AggregatorV1 reads",
                        key
                    )));
                }
            }
        }

        Ok(ret)
    }
```

**File:** aptos-move/block-executor/src/view.rs (L1639-1650)
```rust
    fn get_resource_state_value(
        &self,
        state_key: &Self::Key,
        maybe_layout: Option<&Self::Layout>,
    ) -> PartialVMResult<Option<StateValue>> {
        self.get_resource_state_value_impl(
            state_key,
            UnknownOrLayout::Known(maybe_layout),
            ReadKind::Value,
        )
        .map(|res| res.expect_value())
    }
```

**File:** aptos-move/block-executor/src/view.rs (L1812-1829)
```rust
    fn get_aggregator_v1_state_value(
        &self,
        state_key: &Self::Identifier,
    ) -> PartialVMResult<Option<StateValue>> {
        if let ViewState::Sync(parallel_state) = &self.latest_view {
            parallel_state
                .captured_reads
                .borrow_mut()
                .capture_aggregator_v1_read(state_key.clone());
        }

        // TODO[agg_v1](cleanup):
        // Integrate aggregators V1. That is, we can lift the u128 value
        // from the state item by passing the right layout here. This can
        // be useful for cross-testing the old and the new flows.
        // self.get_resource_state_value(state_key, Some(&MoveTypeLayout::U128))
        self.get_resource_state_value(state_key, None)
    }
```

**File:** aptos-move/block-executor/src/executor.rs (L860-873)
```rust
        if !read_set.validate_delayed_field_reads(versioned_cache.delayed_fields(), txn_idx)?
            || (is_v2
                && !read_set.validate_aggregator_v1_reads(
                    versioned_cache.data(),
                    last_input_output
                        .modified_aggregator_v1_keys(txn_idx)
                        .ok_or_else(|| {
                            code_invariant_error("Modified aggregator v1 keys must be recorded")
                        })?,
                    txn_idx,
                )?)
        {
            return Ok(false);
        }
```

**File:** aptos-move/framework/src/natives/aggregator_natives/aggregator.rs (L56-76)
```rust
fn native_read(
    context: &mut SafeNativeContext,
    _ty_args: &[Type],
    mut args: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    debug_assert_eq!(args.len(), 1);

    context.charge(AGGREGATOR_READ_BASE)?;

    // Extract information from aggregator struct reference.
    let (id, max_value) = aggregator_info(&safely_pop_arg!(args, StructRef))?;

    // Get aggregator.
    let aggregator_context = context.extensions().get::<NativeAggregatorContext>();
    let mut aggregator_data = aggregator_context.aggregator_v1_data.borrow_mut();
    let aggregator = aggregator_data.get_aggregator(id.clone(), max_value)?;

    let value = aggregator.read_and_materialize(aggregator_context.aggregator_v1_resolver, &id)?;

    Ok(smallvec![Value::u128(value)])
}
```
