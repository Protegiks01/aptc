# Audit Report

## Title
Secret Share Aggregation Blocking Task Latency Can Cause Consensus Pipeline Delays Under High Load

## Summary
The `spawn_blocking` call used for cryptographic secret share aggregation in `SecretShareAggregator::try_aggregate` can introduce unbounded latency that delays block processing in the consensus pipeline. Under high throughput or blocking thread pool saturation, this can cause validators to miss consensus timing deadlines, affecting liveness.

## Finding Description
The secret sharing subsystem uses `tokio::task::spawn_blocking` to offload CPU-intensive cryptographic aggregation operations to a separate thread pool. [1](#0-0) 

The aggregation result is sent asynchronously through an unbounded channel to the `SecretShareManager`. [2](#0-1) 

The block's decryption pipeline waits indefinitely for the aggregated key without any timeout mechanism. [3](#0-2) 

The issue manifests when:
1. Multiple blocks with encrypted transactions are being processed concurrently
2. Each triggers a `spawn_blocking` task for secret share aggregation
3. Tokio's blocking thread pool (limited to 64 threads) becomes saturated [4](#0-3) 
4. New aggregation tasks queue and experience significant delays
5. The decryption pipeline blocks waiting for keys that arrive late
6. Blocks are delayed in the `SecretShareManager` queue [5](#0-4) 
7. The execution pipeline cannot proceed until decryption completes

This violates liveness guarantees as blocks may not be processed within expected timeframes, potentially causing validators to timeout or fall behind in consensus participation.

## Impact Explanation
This qualifies as **High Severity** under "Validator node slowdowns" category. While it doesn't compromise consensus safety or cause fund loss, it can significantly degrade validator performance under high load by:
- Stalling the execution pipeline for multiple blocks
- Causing validators to miss round deadlines
- Reducing network throughput during peak usage
- Potentially affecting validator rewards due to delayed participation

## Likelihood Explanation
**Likelihood: Medium to High** under normal high-throughput conditions:
- The blocking thread pool limit (64 threads) is shared across all consensus operations
- Multiple concurrent blocks with encrypted transactions naturally trigger this
- No backpressure or timeout mechanisms exist to mitigate the issue
- The cryptographic aggregation operation (`FPTXWeighted::reconstruct_decryption_key`) is computationally expensive [6](#0-5) 
- Does not require malicious intent - manifests under legitimate high load

## Recommendation
Implement one or more of the following mitigations:

1. **Add timeout with fallback**: Modify `decrypt_encrypted_txns` to use `tokio::time::timeout` on the `secret_shared_key_rx` await, allowing the pipeline to abort or skip decryption if the key doesn't arrive within a deadline.

2. **Use bounded executor**: Replace direct `tokio::task::spawn_blocking` with a `BoundedExecutor` to limit concurrent aggregations and provide backpressure.

3. **Pre-aggregate optimization**: Consider pre-computing aggregations or caching partial results to reduce per-block aggregation latency.

4. **Priority-based scheduling**: Implement priority scheduling for aggregation tasks based on block urgency to prevent newer blocks from starving older ones.

Example fix for approach #1:
```rust
// In decrypt_encrypted_txns
let maybe_decryption_key = tokio::time::timeout(
    Duration::from_secs(5),
    secret_shared_key_rx
).await;

match maybe_decryption_key {
    Ok(Ok(Some(key))) => {
        // Proceed with decryption
    }
    _ => {
        // Handle timeout or missing key - mark txns as failed decryption
        warn!("Decryption key unavailable within timeout");
        // ... fallback logic
    }
}
```

## Proof of Concept
```rust
// Reproduction scenario:
// 1. Start validator node with encrypted transaction support enabled
// 2. Saturate blocking thread pool with other operations (simulate via load testing)
// 3. Propose multiple blocks containing encrypted transactions in quick succession
// 4. Monitor BLOCK_TRACING metrics for delays between:
//    - SECRET_SHARING_ADD_ENOUGH_SHARE (shares collected)
//    - SECRET_SHARING_ADD_DECISION (key delivered to pipeline)
// 5. Observe pipeline stalls when delay exceeds expected bounds (>100ms)
// 6. Verify via consensus metrics that validators timeout or fall behind

// Metric observation:
// Check prometheus metrics:
// - aptos_consensus_block_tracing{stage="ss_add_enough_share"}
// - aptos_consensus_block_tracing{stage="ss_add_decision"}
// Gap between these indicates aggregation latency
```

---

**Notes**

This vulnerability is specific to the encrypted transaction feature and requires blocks with encrypted payloads to trigger. The impact is proportional to the volume of encrypted transactions and concurrent block processing. While validators can eventually catch up once load decreases, sustained high throughput with encrypted transactions can cause persistent performance degradation. The lack of timeout or backpressure mechanisms makes this a reliability concern that should be addressed before encrypted transactions are widely deployed in production.

### Citations

**File:** consensus/src/rand/secret_sharing/secret_share_store.rs (L55-70)
```rust
        tokio::task::spawn_blocking(move || {
            let maybe_key = SecretShare::aggregate(self.shares.values(), &dec_config);
            match maybe_key {
                Ok(key) => {
                    let dec_key = SecretSharedKey::new(metadata, key);
                    let _ = decision_tx.unbounded_send(dec_key);
                },
                Err(e) => {
                    warn!(
                        epoch = metadata.epoch,
                        round = metadata.round,
                        "Aggregation error: {e}"
                    );
                },
            }
        });
```

**File:** consensus/src/rand/secret_sharing/secret_share_manager.rs (L362-363)
```rust
                Some(secret_shared_key) = self.decision_rx.next() => {
                    self.process_aggregated_key(secret_shared_key);
```

**File:** consensus/src/pipeline/decryption_pipeline_builder.rs (L115-119)
```rust
        let maybe_decryption_key = secret_shared_key_rx
            .await
            .expect("decryption key should be available");
        // TODO(ibalajiarun): account for the case where decryption key is not available
        let decryption_key = maybe_decryption_key.expect("decryption key should be available");
```

**File:** crates/aptos-runtimes/src/lib.rs (L27-27)
```rust
    const MAX_BLOCKING_THREADS: usize = 64;
```

**File:** consensus/src/rand/secret_sharing/block_queue.rs (L112-127)
```rust
    pub fn dequeue_ready_prefix(&mut self) -> Vec<OrderedBlocks> {
        let mut ready_prefix = vec![];
        while let Some((_starting_round, item)) = self.queue.first_key_value() {
            if item.is_fully_secret_shared() {
                let (_, item) = self.queue.pop_first().expect("First key must exist");
                for block in item.blocks() {
                    observe_block(block.timestamp_usecs(), BlockStage::SECRET_SHARING_READY);
                }
                let QueueItem { ordered_blocks, .. } = item;
                ready_prefix.push(ordered_blocks);
            } else {
                break;
            }
        }
        ready_prefix
    }
```

**File:** types/src/secret_sharing.rs (L93-97)
```rust
        let decryption_key =
            <FPTXWeighted as BatchThresholdEncryption>::reconstruct_decryption_key(
                &shares,
                &config.config,
            )?;
```
