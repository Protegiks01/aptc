# Audit Report

## Title
Multisig Payload Substitution Attack via ExecuteWithPayload When Feature Flag Disabled

## Summary
A critical vulnerability exists in the multisig account implementation that allows a malicious owner to execute arbitrary payloads different from what was approved by other owners. When the `abort_if_multisig_payload_mismatch_enabled` feature flag is disabled AND a transaction is created with full payload stored on-chain, the validation logic fails to verify that the payload provided during execution matches the approved payload.

## Finding Description

The vulnerability occurs in the multisig transaction execution flow when using `ExecuteWithPayload::execute()`. The attack exploits a gap in the validation logic in the Move framework's `validate_multisig_transaction` function. [1](#0-0) 

When a multisig transaction is created using `create_transaction` (with full payload, not hash), the transaction stores the complete payload on-chain: [2](#0-1) 

During execution validation, there are TWO separate checks: [3](#0-2) 

**The Critical Gap:**
1. The hash validation (lines 1163-1169) only executes if `payload_hash` is Some, but transactions created with `create_transaction` have `payload_hash` as None
2. The payload validation (lines 1173-1182) only executes if the feature flag `abort_if_multisig_payload_mismatch_enabled()` is true

**Attack Flow:**
1. Malicious owner proposes a benign transaction with full payload (e.g., transferring 1 APT)
2. Other owners review and approve this benign transaction
3. Malicious owner calls `ExecuteWithPayload` with DIFFERENT `entry_function_args` (e.g., transferring 1000 APT to attacker's address)
4. The VM converts the provided payload and serializes it: [4](#0-3) 

5. If the feature flag is disabled, the malicious payload bypasses both validation checks and executes

This breaks the fundamental security invariant of multisig accounts: **k-of-n signature approval for transaction execution**.

## Impact Explanation

**Critical Severity** - This vulnerability allows a single malicious owner to bypass the entire multisig approval mechanism and execute arbitrary transactions with the multisig account's authority. Impact includes:

1. **Loss of Funds**: Complete theft of all assets controlled by the multisig account
2. **Governance Attack**: If the multisig controls governance voting power, arbitrary votes can be cast
3. **Consensus Implications**: Breaks deterministic execution invariant if different validators have different feature flag states (though unlikely)
4. **System-wide Impact**: Many DAOs, treasuries, and multi-party agreements rely on multisig accounts

The feature flag was explicitly added as a "fix" for this vulnerability: [5](#0-4) 

This confirms the issue was recognized as a security vulnerability requiring remediation.

## Likelihood Explanation

**Likelihood depends on feature flag state:**
- If feature flag is **enabled** (current mainnet): **Low** - vulnerability is mitigated
- If feature flag is **disabled**: **High** - trivial to exploit for any multisig owner

**Attack Requirements:**
- Attacker must be an owner of the target multisig account
- Transaction must be created with full payload (not hash-only)
- Feature flag must be disabled

The feature's "transient" lifetime indicates it can be toggled, creating a window for exploitation if disabled during upgrades or configuration changes.

## Recommendation

**Immediate Fix:** Ensure the feature flag `ABORT_IF_MULTISIG_PAYLOAD_MISMATCH` (flag #70) remains permanently enabled on all networks.

**Long-term Fix:** Remove the conditional check and enforce payload validation unconditionally:

```move
// In validate_multisig_transaction, replace lines 1173-1182 with:
if (option::is_some(&transaction.payload) && !vector::is_empty(&payload)) {
    let stored_payload = option::borrow(&transaction.payload);
    assert!(
        payload == *stored_payload,
        error::invalid_argument(EPAYLOAD_DOES_NOT_MATCH),
    );
}
```

**Additional Recommendation:** Deprecate `ExecuteWithPayload` for transactions with stored full payloads - it should only be used for hash-only transactions.

## Proof of Concept

```move
#[test(owner1 = @0x100, owner2 = @0x200, attacker = @0x100, victim = @0x999)]
fun test_payload_substitution_attack(
    owner1: &signer, 
    owner2: &signer, 
    victim: &signer
) {
    // Setup: Create 2-of-2 multisig
    multisig_account::create_with_owners(
        owner1,
        vector[@0x200],
        2,
        vector[],
        vector[]
    );
    let multisig_addr = multisig_account::get_next_multisig_account_address(@0x100);
    
    // Fund multisig account with 1000 APT
    coin::transfer<AptosCoin>(victim, multisig_addr, 1000);
    
    // Step 1: Attacker proposes benign transaction (transfer 1 APT to victim)
    let benign_payload = create_entry_function_payload(
        @0x1, b"coin", b"transfer",
        vector[type_info::type_of<AptosCoin>()],
        vector[bcs::to_bytes(&@0x999), bcs::to_bytes(&1u64)]
    );
    multisig_account::create_transaction(
        owner1,
        multisig_addr,
        bcs::to_bytes(&benign_payload)
    );
    
    // Step 2: Owner2 approves the benign transaction
    multisig_account::approve_transaction(owner2, multisig_addr, 1);
    
    // Step 3: Attacker executes with MALICIOUS payload (transfer 1000 APT to attacker)
    // Assuming feature flag is disabled:
    let malicious_payload = create_entry_function_payload(
        @0x1, b"coin", b"transfer",
        vector[type_info::type_of<AptosCoin>()],
        vector[bcs::to_bytes(&@0x100), bcs::to_bytes(&1000u64)] // All funds to attacker!
    );
    
    // This would succeed if feature flag disabled, executing malicious payload
    // despite owner2 only approving 1 APT transfer to victim
    execute_multisig_with_payload(owner1, multisig_addr, malicious_payload);
    
    // Result: Attacker has stolen 1000 APT instead of authorized 1 APT transfer
    assert!(coin::balance<AptosCoin>(@0x100) == 1000, 0);
    assert!(coin::balance<AptosCoin>(@0x999) == 0, 1); // Victim got nothing
}
```

## Notes

This vulnerability represents a **bypassed fix** - the feature flag `ABORT_IF_MULTISIG_PAYLOAD_MISMATCH` was added specifically to remediate this issue. The vulnerability exists in the codebase architecture and would be active if the feature flag is disabled. The conditional nature of the fix creates ongoing risk if governance actions inadvertently disable the flag or if new networks launch with it disabled by default.

### Citations

**File:** crates/aptos/src/account/multisig_account.rs (L332-341)
```rust
    async fn execute(self) -> CliTypedResult<TransactionSummary> {
        self.execute
            .txn_options
            .submit_transaction(TransactionPayload::Multisig(Multisig {
                multisig_address: self.execute.multisig_account.multisig_address,
                transaction_payload: Some(self.entry_function_args.try_into()?),
            }))
            .await
            .map(|inner| inner.into())
    }
```

**File:** aptos-move/framework/aptos-framework/sources/multisig_account.move (L954-973)
```text
    public entry fun create_transaction(
        owner: &signer,
        multisig_account: address,
        payload: vector<u8>,
    ) acquires MultisigAccount {
        assert!(vector::length(&payload) > 0, error::invalid_argument(EPAYLOAD_CANNOT_BE_EMPTY));

        assert_multisig_account_exists(multisig_account);
        assert_is_owner(owner, multisig_account);

        let creator = address_of(owner);
        let transaction = MultisigTransaction {
            payload: option::some(payload),
            payload_hash: option::none<vector<u8>>(),
            votes: simple_map::create<address, bool>(),
            creator,
            creation_time_secs: now_seconds(),
        };
        add_transaction(creator, multisig_account, transaction);
    }
```

**File:** aptos-move/framework/aptos-framework/sources/multisig_account.move (L1163-1182)
```text
        if (option::is_some(&transaction.payload_hash)) {
            let payload_hash = option::borrow(&transaction.payload_hash);
            assert!(
                sha3_256(payload) == *payload_hash,
                error::invalid_argument(EPAYLOAD_DOES_NOT_MATCH_HASH),
            );
        };

        // If the transaction payload is stored on chain and there is a provided payload,
        // verify that the provided payload matches the stored payload.
        if (features::abort_if_multisig_payload_mismatch_enabled()
            && option::is_some(&transaction.payload)
            && !vector::is_empty(&payload)
        ) {
            let stored_payload = option::borrow(&transaction.payload);
            assert!(
                payload == *stored_payload,
                error::invalid_argument(EPAYLOAD_DOES_NOT_MATCH),
            );
        }
```

**File:** aptos-move/aptos-vm/src/transaction_validation.rs (L411-429)
```rust
    let provided_payload = match executable {
        TransactionExecutableRef::EntryFunction(entry_function) => bcs::to_bytes(
            &MultisigTransactionPayload::EntryFunction(entry_function.clone()),
        )
        .map_err(|_| unreachable_error.clone())?,
        TransactionExecutableRef::Empty => {
            if features.is_abort_if_multisig_payload_mismatch_enabled() {
                vec![]
            } else {
                bcs::to_bytes::<Vec<u8>>(&vec![]).map_err(|_| unreachable_error.clone())?
            }
        },
        TransactionExecutableRef::Script(_) => {
            return Err(VMStatus::error(
                StatusCode::FEATURE_UNDER_GATING,
                Some("Script payload not supported for multisig transactions".to_string()),
            ));
        },
    };
```

**File:** aptos-move/framework/move-stdlib/sources/configs/features.move (L577-587)
```text
    /// Whether the multisig v2 fix is enabled. Once enabled, the multisig transaction execution will explicitly
    /// abort if the provided payload does not match the payload stored on-chain.
    ///
    /// Lifetime: transient
    const ABORT_IF_MULTISIG_PAYLOAD_MISMATCH: u64 = 70;

    public fun get_abort_if_multisig_payload_mismatch_feature(): u64 { ABORT_IF_MULTISIG_PAYLOAD_MISMATCH }

    public fun abort_if_multisig_payload_mismatch_enabled(): bool acquires Features {
        is_enabled(ABORT_IF_MULTISIG_PAYLOAD_MISMATCH)
    }
```
