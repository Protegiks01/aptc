# Audit Report

## Title
Protocol ID Injection Vulnerability Enabling Unauthorized Consensus Message Processing

## Summary
The network layer fails to validate that incoming message `protocol_id` fields match the protocols negotiated during connection handshake. This allows malicious peers to send messages with arbitrary protocol_ids, bypassing protocol negotiation security boundaries and potentially causing validator node resource exhaustion through unauthorized message processing.

## Finding Description

During peer connection establishment, nodes perform a handshake that negotiates which protocols will be used over the connection. [1](#0-0) 

The negotiated protocols are stored in `ConnectionMetadata.application_protocols` and should serve as a security boundary - only messages using negotiated protocols should be processed. [2](#0-1) 

However, when processing inbound network messages, the code only checks if an upstream handler exists for the message's `protocol_id`, without validating that this protocol was actually negotiated with the sending peer. [3](#0-2) 

Similarly, RPC requests are routed based solely on their `protocol_id` field without negotiation validation. [4](#0-3) 

**Attack Path:**
1. Attacker establishes connection to validator and negotiates minimal protocols (e.g., only `HealthCheckerRpc`)
2. Attacker sends `DirectSendMsg` or `RpcRequest` with `protocol_id = ConsensusDirectSendBcs` (not negotiated)
3. Victim's `handle_inbound_network_message()` checks if upstream handler exists for `ConsensusDirectSendBcs` (it does)
4. Message is routed to consensus handler without protocol negotiation check
5. Message undergoes deserialization before signature verification [5](#0-4) 
6. This forces victim validator to process unauthorized messages, consuming resources

The `add_peer_to_storage()` test function demonstrates this pattern by allowing arbitrary protocol sets to be assigned to peer metadata, though the function itself is test code only. [6](#0-5) 

## Impact Explanation

This vulnerability qualifies as **High severity** under the Aptos bug bounty program criteria for "Validator node slowdowns" and "significant protocol violations."

**Impact:**
- **Validator Resource Exhaustion**: Attackers can force validators to deserialize and process messages they shouldn't receive based on protocol negotiation, consuming CPU and memory resources
- **Protocol Boundary Bypass**: Circumvents the handshake negotiation security mechanism, allowing access to message handlers that shouldn't be reachable
- **Amplification Attack**: Single malicious peer can send many unauthorized message types to multiple validators
- **Pre-Signature Processing**: Messages are deserialized and undergo initial processing before signature verification, maximizing resource consumption

While signature verification prevents unauthorized consensus participation, the forced deserialization and early message processing can still degrade validator performance and potentially trigger edge cases in message handling code.

## Likelihood Explanation

**Likelihood: High**

- **Low Attack Complexity**: Attacker only needs to establish a network connection and send crafted messages
- **No Special Privileges Required**: Any peer that can connect to the validator network can exploit this
- **Direct Attack Path**: No need for complex state manipulation or timing attacks
- **Wide Attack Surface**: Affects all message types processed through the peer handler
- **Easily Discoverable**: The missing validation is apparent in the code structure

## Recommendation

Add protocol negotiation validation in `handle_inbound_network_message()` to verify incoming message `protocol_id` fields are contained in the peer's negotiated `connection_metadata.application_protocols`:

```rust
fn handle_inbound_network_message(
    &mut self,
    message: NetworkMessage,
) -> Result<(), PeerManagerError> {
    match &message {
        NetworkMessage::DirectSendMsg(direct) => {
            // ADD VALIDATION: Check protocol was negotiated
            if !self.connection_metadata.application_protocols.contains(direct.protocol_id) {
                counters::direct_send_messages(&self.network_context, "unauthorized_protocol").inc();
                return Err(PeerManagerError::UnauthorizedProtocol(direct.protocol_id));
            }
            
            // Existing handler routing logic...
        },
        NetworkMessage::RpcRequest(request) => {
            // ADD VALIDATION: Check protocol was negotiated  
            if !self.connection_metadata.application_protocols.contains(request.protocol_id) {
                counters::rpc_messages(&self.network_context, "unauthorized_protocol").inc();
                return Err(PeerManagerError::UnauthorizedProtocol(request.protocol_id));
            }
            
            // Existing handler routing logic...
        },
        // ... other cases
    }
}
```

Additionally, add monitoring and alerting for unauthorized protocol attempts to detect potential attacks.

## Proof of Concept

```rust
// Create test demonstrating protocol bypass
#[test]
fn test_protocol_id_injection_bypass() {
    use network::peer::Peer;
    use network::protocols::wire::messaging::v1::{DirectSendMsg, NetworkMessage};
    use network::protocols::wire::handshake::v1::{ProtocolId, ProtocolIdSet};
    
    // Setup: Peer negotiates only HealthCheckerRpc during handshake
    let mut conn_meta = ConnectionMetadata::mock(PeerId::random());
    conn_meta.application_protocols = ProtocolIdSet::from_iter([ProtocolId::HealthCheckerRpc]);
    
    // Create peer with this limited protocol set
    let peer = create_test_peer(conn_meta.clone());
    
    // Attack: Send message with ConsensusDirectSendBcs (not negotiated)
    let malicious_msg = NetworkMessage::DirectSendMsg(DirectSendMsg {
        protocol_id: ProtocolId::ConsensusDirectSendBcs,  // NOT in negotiated set!
        priority: 0,
        raw_msg: vec![0xde, 0xad, 0xbe, 0xef].into(),
    });
    
    // Current behavior: Message is processed despite protocol not being negotiated
    // Expected behavior: Message should be rejected with UnauthorizedProtocol error
    let result = peer.handle_inbound_network_message(malicious_msg);
    
    // This test PASSES on vulnerable code (message processed)
    // Should FAIL on fixed code (message rejected)
    assert!(result.is_err(), "Should reject non-negotiated protocol");
}
```

**Notes**

The vulnerability exists in production code within the network peer handler, not in the test file mentioned in the security question. The `add_peer_to_storage()` function is merely a test helper that demonstrates the pattern of setting arbitrary protocols, but the actual security issue is the missing runtime validation of incoming message protocol identifiers against negotiated protocol sets.

### Citations

**File:** network/framework/src/protocols/wire/handshake/v1/mod.rs (L431-465)
```rust
    pub fn perform_handshake(
        &self,
        other: &HandshakeMsg,
    ) -> Result<(MessagingProtocolVersion, ProtocolIdSet), HandshakeError> {
        // verify that both peers are on the same chain
        if self.chain_id != other.chain_id {
            return Err(HandshakeError::InvalidChainId(
                other.chain_id,
                self.chain_id,
            ));
        }

        // verify that both peers are on the same network
        if self.network_id != other.network_id {
            return Err(HandshakeError::InvalidNetworkId(
                other.network_id,
                self.network_id,
            ));
        }

        // find the greatest common MessagingProtocolVersion where we both support
        // at least one common ProtocolId.
        for (our_handshake_version, our_protocols) in self.supported_protocols.iter().rev() {
            if let Some(their_protocols) = other.supported_protocols.get(our_handshake_version) {
                let common_protocols = our_protocols.intersect(their_protocols);

                if !common_protocols.is_empty() {
                    return Ok((*our_handshake_version, common_protocols));
                }
            }
        }

        // no intersection found
        Err(HandshakeError::NoCommonProtocols)
    }
```

**File:** network/framework/src/transport/mod.rs (L38-52)
```rust
mod test;

/// A timeout for the connection to open and complete all of the upgrade steps.
pub const TRANSPORT_TIMEOUT: Duration = Duration::from_secs(30);

/// Currently supported messaging protocol version.
/// TODO: Add ability to support more than one messaging protocol.
pub const SUPPORTED_MESSAGING_PROTOCOL: MessagingProtocolVersion = MessagingProtocolVersion::V1;

/// Global connection-id generator.
static CONNECTION_ID_GENERATOR: ConnectionIdGenerator = ConnectionIdGenerator::new();

/// tcp::Transport with Aptos-specific configuration applied.
pub const APTOS_TCP_TRANSPORT: tcp::TcpTransport = tcp::TcpTransport {
    // Use default options.
```

**File:** network/framework/src/peer/mod.rs (L447-492)
```rust
    fn handle_inbound_network_message(
        &mut self,
        message: NetworkMessage,
    ) -> Result<(), PeerManagerError> {
        match &message {
            NetworkMessage::DirectSendMsg(direct) => {
                let data_len = direct.raw_msg.len();
                network_application_inbound_traffic(
                    self.network_context,
                    direct.protocol_id,
                    data_len as u64,
                );
                match self.upstream_handlers.get(&direct.protocol_id) {
                    None => {
                        counters::direct_send_messages(&self.network_context, UNKNOWN_LABEL).inc();
                        counters::direct_send_bytes(&self.network_context, UNKNOWN_LABEL)
                            .inc_by(data_len as u64);
                    },
                    Some(handler) => {
                        let key = (self.connection_metadata.remote_peer_id, direct.protocol_id);
                        let sender = self.connection_metadata.remote_peer_id;
                        let network_id = self.network_context.network_id();
                        let sender = PeerNetworkId::new(network_id, sender);
                        match handler.push(key, ReceivedMessage::new(message, sender)) {
                            Err(_err) => {
                                // NOTE: aptos_channel never returns other than Ok(()), but we might switch to tokio::sync::mpsc and then this would work
                                counters::direct_send_messages(
                                    &self.network_context,
                                    DECLINED_LABEL,
                                )
                                .inc();
                                counters::direct_send_bytes(&self.network_context, DECLINED_LABEL)
                                    .inc_by(data_len as u64);
                            },
                            Ok(_) => {
                                counters::direct_send_messages(
                                    &self.network_context,
                                    RECEIVED_LABEL,
                                )
                                .inc();
                                counters::direct_send_bytes(&self.network_context, RECEIVED_LABEL)
                                    .inc_by(data_len as u64);
                            },
                        }
                    },
                }
```

**File:** network/framework/src/peer/mod.rs (L505-530)
```rust
            NetworkMessage::RpcRequest(request) => {
                match self.upstream_handlers.get(&request.protocol_id) {
                    None => {
                        counters::direct_send_messages(&self.network_context, UNKNOWN_LABEL).inc();
                        counters::direct_send_bytes(&self.network_context, UNKNOWN_LABEL)
                            .inc_by(request.raw_request.len() as u64);
                    },
                    Some(handler) => {
                        let sender = self.connection_metadata.remote_peer_id;
                        let network_id = self.network_context.network_id();
                        let sender = PeerNetworkId::new(network_id, sender);
                        if let Err(err) = self
                            .inbound_rpcs
                            .handle_inbound_request(handler, ReceivedMessage::new(message, sender))
                        {
                            warn!(
                                NetworkSchema::new(&self.network_context)
                                    .connection_metadata(&self.connection_metadata),
                                error = %err,
                                "{} Error handling inbound rpc request: {}",
                                self.network_context,
                                err
                            );
                        }
                    },
                }
```

**File:** consensus/src/epoch_manager.rs (L1562-1599)
```rust
        let maybe_unverified_event = self.check_epoch(peer_id, consensus_msg).await?;

        if let Some(unverified_event) = maybe_unverified_event {
            // filter out quorum store messages if quorum store has not been enabled
            match self.filter_quorum_store_events(peer_id, &unverified_event) {
                Ok(true) => {},
                Ok(false) => return Ok(()), // This occurs when the quorum store is not enabled, but the recovery mode is enabled. We filter out the messages, but don't raise any error.
                Err(err) => return Err(err),
            }
            // same epoch -> run well-formedness + signature check
            let epoch_state = self
                .epoch_state
                .clone()
                .ok_or_else(|| anyhow::anyhow!("Epoch state is not available"))?;
            let proof_cache = self.proof_cache.clone();
            let quorum_store_enabled = self.quorum_store_enabled;
            let quorum_store_msg_tx = self.quorum_store_msg_tx.clone();
            let buffered_proposal_tx = self.buffered_proposal_tx.clone();
            let round_manager_tx = self.round_manager_tx.clone();
            let my_peer_id = self.author;
            let max_num_batches = self.config.quorum_store.receiver_max_num_batches;
            let max_batch_expiry_gap_usecs =
                self.config.quorum_store.batch_expiry_gap_when_init_usecs;
            let payload_manager = self.payload_manager.clone();
            let pending_blocks = self.pending_blocks.clone();
            self.bounded_executor
                .spawn(async move {
                    match monitor!(
                        "verify_message",
                        unverified_event.clone().verify(
                            peer_id,
                            &epoch_state.verifier,
                            &proof_cache,
                            quorum_store_enabled,
                            peer_id == my_peer_id,
                            max_num_batches,
                            max_batch_expiry_gap_usecs,
                        )
```

**File:** consensus/src/network_tests.rs (L606-617)
```rust
    fn add_peer_to_storage(
        peers_and_metadata: &PeersAndMetadata,
        peer: &PeerId,
        protocols: &[ProtocolId],
    ) {
        let peer_network_id = PeerNetworkId::new(NetworkId::Validator, *peer);
        let mut conn_meta = ConnectionMetadata::mock(*peer);
        conn_meta.application_protocols = ProtocolIdSet::from_iter(protocols);
        peers_and_metadata
            .insert_connection_metadata(peer_network_id, conn_meta)
            .unwrap();
    }
```
