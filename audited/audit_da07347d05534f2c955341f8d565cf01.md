# Audit Report

## Title
Indexer Permanent Desynchronization After Partial Commit Failure

## Summary
If `indexer.index()` fails after ledger metadata has been committed to disk in `commit_ledger`, the system enters an unrecoverable state where the indexer permanently falls behind the ledger. Subsequent commits either skip indexer updates or fail with version mismatch errors, requiring node restart. If the underlying failure is persistent (e.g., indexer database corruption, disk space exhaustion), the node cannot restart, creating a total liveness failure.

## Finding Description
The vulnerability exists in the commit flow where ledger metadata persistence and indexer updates are not atomic: [1](#0-0) 

The `OverallCommitProgress` is written to the ledger database and committed to disk. This operation succeeds and is durable. [2](#0-1) 

Only AFTER the ledger commit succeeds does `post_commit` invoke the indexer: [3](#0-2) 

If `indexer.index()` fails (line 648 or 656), the error propagates back through `post_commit`. At this point:
- Ledger database: `OverallCommitProgress = N` (committed)
- Indexer database: `LatestVersion = N-1` (write failed)
- Indexer in-memory: `next_version = N` (not updated due to failure) [4](#0-3) 

The indexer's `next_version` is only updated AFTER the database write succeeds at line 144. If this write fails, line 145 never executes.

**Recovery Scenario 1: Retry same version** [5](#0-4) 

When the same version is retried, `old_committed_version = N` and `version = N`, so the condition `version > old_committed_version.unwrap()` is FALSE. The entire indexing block (lines 612-658) is skipped, and the indexer remains at version N-1.

**Recovery Scenario 2: Commit next version**

When version N+1 is committed, `first_version = N+1` is passed to the indexer: [6](#0-5) 

The indexer expects `next_version = N` but receives `first_version = N+1`, causing the check at line 102 to fail with error: "Indexer expects to see continuous transaction versions."

**Recovery Scenario 3: Node restart with catch-up** [7](#0-6) 

On restart, the indexer attempts to catch up by indexing the missing versions. If the failure is persistent (database corruption, insufficient disk space), the catch-up fails at line 224, and `open_indexer` returns an error, preventing the node from starting.

## Impact Explanation
This qualifies as **Medium Severity** under the Aptos bug bounty program:

1. **State inconsistencies requiring intervention**: The indexer database becomes permanently desynchronized from the ledger database, breaking the invariant that all database components maintain consistent state.

2. **Potential liveness failure**: If the underlying cause is persistent, the node cannot restart, effectively removing it from the network until manual database repair is performed.

3. **No automatic recovery**: Without restart, the node cannot process new commits successfully. With restart, if the failure persists, the node cannot start.

This could escalate to **High Severity** if multiple nodes experience the failure simultaneously (e.g., network-wide disk space issues), causing validator slowdowns or reduced network capacity.

## Likelihood Explanation
**Moderate likelihood** - This can occur through:

1. **Disk space exhaustion**: Indexer database fills up while ledger database has space
2. **Database corruption**: RocksDB corruption in indexer DB but not ledger DB
3. **I/O errors**: Transient or permanent storage failures affecting only the indexer DB
4. **Permission issues**: File system permissions prevent indexer writes after ledger writes succeed

The failure does not require attacker action but can occur during normal operation under adverse system conditions. Given that blockchain nodes run continuously with high write volumes, storage-related failures are realistic operational concerns.

## Recommendation
Implement atomic commit semantics by deferring the ledger metadata commit until after all dependent operations succeed:

```rust
fn commit_ledger(
    &self,
    version: Version,
    ledger_info_with_sigs: Option<&LedgerInfoWithSignatures>,
    chunk_opt: Option<ChunkToCommit>,
) -> Result<()> {
    let old_committed_ver = self.get_and_check_commit_range(version)?;
    
    let mut ledger_batch = SchemaBatch::new();
    if let Some(li) = ledger_info_with_sigs {
        self.check_and_put_ledger_info(version, li, &mut ledger_batch)?;
    }
    
    // MOVED: Invoke indexer BEFORE committing ledger metadata
    if old_committed_version.is_none() || version > old_committed_version.unwrap() {
        let first_version = old_committed_version.map_or(0, |v| v + 1);
        // ... calculate first_version and write_sets ...
        if let Some(indexer) = &self.indexer {
            indexer.index(self.state_store.clone(), first_version, &write_sets)?;
        }
    }
    
    // Only commit ledger metadata AFTER indexer succeeds
    ledger_batch.put::<DbMetadataSchema>(
        &DbMetadataKey::OverallCommitProgress,
        &DbMetadataValue::Version(version),
    )?;
    self.ledger_db.metadata_db().write_schemas(ledger_batch)?;
    
    // Update in-memory state
    self.post_commit_update_memory(version, ledger_info_with_sigs)?;
    Ok(())
}
```

Alternative: Implement transaction-like rollback where ledger metadata is reverted if indexer fails, though this is more complex.

## Proof of Concept

```rust
#[test]
fn test_indexer_failure_causes_permanent_desync() {
    // Setup: Create AptosDB with indexer enabled
    let tmpdir = TempPath::new();
    let db = AptosDB::open(
        StorageDirPaths::from_path(&tmpdir),
        false,
        NO_OP_STORAGE_PRUNER_CONFIG,
        RocksdbConfigs::default(),
        true, // enable_indexer
        1000,
        1000,
        None,
        HotStateConfig::default(),
    ).unwrap();
    
    // Step 1: Commit version 0 successfully
    let chunk_0 = create_test_chunk(0, 1);
    db.pre_commit_ledger(chunk_0.clone(), false).unwrap();
    db.commit_ledger(0, Some(&test_ledger_info(0)), Some(chunk_0)).unwrap();
    
    // Step 2: Simulate indexer database failure during version 1 commit
    // (In practice, inject disk full error or corrupt indexer DB)
    let chunk_1 = create_test_chunk(1, 1);
    db.pre_commit_ledger(chunk_1.clone(), false).unwrap();
    
    // Force indexer DB to fail (e.g., fill disk, corrupt DB file)
    simulate_indexer_db_failure(&db);
    
    // Attempt commit - ledger succeeds, indexer fails
    let result = db.commit_ledger(1, Some(&test_ledger_info(1)), Some(chunk_1));
    assert!(result.is_err()); // Commit fails due to indexer error
    
    // Step 3: Verify ledger is at version 1, indexer is at version 0
    assert_eq!(db.get_synced_version().unwrap(), Some(1)); // Ledger committed
    assert_eq!(db.indexer.as_ref().unwrap().next_version(), 1); // Indexer stuck at 0
    
    // Step 4: Attempt to commit version 2 - fails with version mismatch
    let chunk_2 = create_test_chunk(2, 1);
    db.pre_commit_ledger(chunk_2.clone(), false).unwrap();
    let result = db.commit_ledger(2, Some(&test_ledger_info(2)), Some(chunk_2));
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Expecting: 1, got: 2"));
    
    // Step 5: Node restart fails if indexer DB corruption persists
    drop(db);
    if indexer_db_still_corrupted() {
        let result = AptosDB::open(/* same params */);
        assert!(result.is_err()); // Cannot restart
    }
}
```

## Notes

The vulnerability fundamentally stems from the lack of atomic commit semantics across multiple database instances (ledger DB and indexer DB). The catch-up mechanism provides recovery for transient failures but cannot protect against persistent failures, which result in total node unavailability. This breaks the **State Consistency** invariant that state transitions must be atomic.

### Citations

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L103-107)
```rust
            ledger_batch.put::<DbMetadataSchema>(
                &DbMetadataKey::OverallCommitProgress,
                &DbMetadataValue::Version(version),
            )?;
            self.ledger_db.metadata_db().write_schemas(ledger_batch)?;
```

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L110-110)
```rust
            self.post_commit(old_committed_ver, version, ledger_info_with_sigs, chunk_opt)
```

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L612-614)
```rust
        if old_committed_version.is_none() || version > old_committed_version.unwrap() {
            let first_version = old_committed_version.map_or(0, |v| v + 1);
            let num_txns = version + 1 - first_version;
```

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L636-658)
```rust
            if let Some(indexer) = &self.indexer {
                let _timer = OTHER_TIMERS_SECONDS.timer_with(&["indexer_index"]);
                // n.b. txns_to_commit can be partial, when the control was handed over from consensus to state sync
                // where state sync won't send the pre-committed part to the DB again.
                if let Some(chunk) = chunk_opt
                    && chunk.len() == num_txns as usize
                {
                    let write_sets = chunk
                        .transaction_outputs
                        .iter()
                        .map(|t| t.write_set())
                        .collect_vec();
                    indexer.index(self.state_store.clone(), first_version, &write_sets)?;
                } else {
                    let write_sets: Vec<_> = self
                        .ledger_db
                        .write_set_db()
                        .get_write_set_iter(first_version, num_txns as usize)?
                        .try_collect()?;
                    let write_set_refs = write_sets.iter().collect_vec();
                    indexer.index(self.state_store.clone(), first_version, &write_set_refs)?;
                };
            }
```

**File:** storage/indexer/src/lib.rs (L101-107)
```rust
        let next_version = self.next_version();
        db_ensure!(
            first_version <= next_version,
            "Indexer expects to see continuous transaction versions. Expecting: {}, got: {}",
            next_version,
            first_version,
        );
```

**File:** storage/indexer/src/lib.rs (L140-145)
```rust
        batch.put::<IndexerMetadataSchema>(
            &MetadataKey::LatestVersion,
            &MetadataValue::Version(end_version - 1),
        )?;
        self.db.write_schemas(batch)?;
        self.next_version.store(end_version, Ordering::Relaxed);
```

**File:** storage/aptosdb/src/db/aptosdb_internal.rs (L207-228)
```rust
        if indexer.next_version() < ledger_next_version {
            use aptos_storage_interface::state_store::state_view::db_state_view::DbStateViewAtVersion;
            let db: Arc<dyn DbReader> = self.state_store.clone();

            let state_view = db.state_view_at_version(Some(ledger_next_version - 1))?;
            let annotator = AptosValueAnnotator::new(&state_view);

            const BATCH_SIZE: Version = 10000;
            let mut next_version = indexer.next_version();
            while next_version < ledger_next_version {
                info!(next_version = next_version, "AptosDB Indexer catching up. ",);
                let end_version = std::cmp::min(ledger_next_version, next_version + BATCH_SIZE);
                let write_sets = self
                    .ledger_db
                    .write_set_db()
                    .get_write_sets(next_version, end_version)?;
                let write_sets_ref: Vec<_> = write_sets.iter().collect();
                indexer.index_with_annotator(&annotator, next_version, &write_sets_ref)?;

                next_version = end_version;
            }
        }
```
