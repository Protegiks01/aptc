# Audit Report

## Title
Git Dependency Cache Collision on Case-Insensitive Filesystems Enables Supply Chain Attacks

## Summary
The Move package manager's git dependency cache path generation does not normalize URL casing, causing different Git repositories with URLs that differ only in case to collide on case-insensitive filesystems (macOS, Windows). This enables attackers to poison the dependency cache and inject malicious code into Move packages during compilation, potentially leading to deployment of backdoored smart contracts on the Aptos blockchain.

## Finding Description

The vulnerability exists in the git dependency resolution mechanism used by the Move package manager. When parsing git dependencies from `Move.toml` manifests, the system generates cache directory paths by sanitizing the git URL and revision name. [1](#0-0) [2](#0-1) 

The `url_to_file_name()` function converts URLs to filesystem-safe names by replacing special characters (`/`, `:`, `.`, `@`) with underscores, but **does not normalize case**. This means:
- `https://github.com/aptos-labs/Framework.git` → `https___github_com_aptos_labs_Framework_git`
- `https://github.com/aptos-labs/framework.git` → `https___github_com_aptos_labs_framework_git`

On case-insensitive filesystems (default on macOS with APFS, Windows with NTFS), these paths are treated as identical, causing a cache collision. [3](#0-2) 

The dependency download logic checks if a cached directory exists using `git_info.download_to.exists()`. On case-insensitive filesystems:

1. **Scenario A - Cache Poisoning via Processing Order**: When resolving dependencies for a package that transitively depends on both `github.com/org/Package` and `github.com/org/package`, the dependency processed first wins due to alphabetical ordering in `BTreeMap`. An attacker can craft package names to ensure their malicious variant is processed first.

2. **Scenario B - Silent Dependency Confusion**: If a legitimate package cached as `github.com/org/Package` exists, and a build process later tries to fetch `github.com/org/package`, the system finds the directory exists and skips cloning, silently using the wrong dependency's code.

**Attack Path:**
1. Attacker identifies a popular Move package dependency: `github.com/aptos-labs/MoveFramework`
2. Attacker creates malicious fork at: `github.com/aptos-labs/moveframework` (lowercase 'm')  
3. Attacker publishes a seemingly useful package that depends on the malicious fork
4. Victim on macOS includes attacker's package (directly or transitively)
5. During dependency resolution, cache collision occurs
6. Due to BTreeMap ordering, attacker's dependency may be processed first if package names are chosen strategically
7. Victim compiles Move modules using attacker's malicious code
8. Victim deploys backdoored smart contract to Aptos blockchain
9. Attacker exploits backdoor to steal funds or manipulate governance

This breaks the fundamental security guarantee that **dependencies resolve to the correct source code** and violates the **Deterministic Execution** invariant at the build level - different developers on different platforms may compile different bytecode from the same `Move.toml` manifest.

## Impact Explanation

This is a **HIGH severity** vulnerability under Aptos bug bounty criteria because:

1. **Supply Chain Attack Vector**: Enables injection of malicious code into Move smart contracts during the build process, which can lead to:
   - Deployment of backdoored contracts on Aptos blockchain
   - Theft of funds from users interacting with compromised contracts
   - Governance manipulation through malicious voting modules
   - Validator stake manipulation through compromised staking modules

2. **Silent Failure**: No warning or error is raised when cache collision occurs, making the attack difficult to detect

3. **Wide Attack Surface**: Affects all macOS and Windows developers (a significant portion of the Aptos developer ecosystem), making it a practical attack vector

4. **Platform-Specific Behavior**: Creates non-deterministic build behavior across platforms, violating the expectation that identical source manifests produce identical builds

While this doesn't directly compromise validator nodes or consensus, it creates a pathway for attackers to inject malicious code into smart contracts that are then deployed to the blockchain, ultimately leading to loss of funds or protocol violations.

## Likelihood Explanation

**Likelihood: MEDIUM to HIGH**

**Factors Increasing Likelihood:**
- **Large Attack Surface**: macOS is widely used by blockchain developers (~30-40% market share)
- **Low Complexity**: Attacker only needs to create a git repository with case-variant URL
- **No Authentication Required**: Anyone can create GitHub repositories with case-different names
- **Transitive Dependencies**: Attacker doesn't need victim to directly depend on malicious package; transitive dependencies suffice
- **Silent Failure**: No warnings make the attack hard to detect

**Factors Decreasing Likelihood:**
- **Platform Specific**: Only affects macOS/Windows, not Linux (though many developers use macOS)
- **Requires Social Engineering**: Attacker must get victim to include their package
- **Code Review**: Sophisticated organizations may catch discrepancies during code review
- **Deterministic Builds**: Some teams use containerized builds on Linux, avoiding the issue

**Realistic Attack Scenario:**
An attacker targeting Aptos DeFi protocols could create malicious forks of popular utility libraries with case-variant names, then publish wrapper packages using these dependencies. When developers on macOS add these packages, cache poisoning occurs silently, and malicious code gets compiled into deployed contracts.

## Recommendation

**Immediate Fix: Normalize URL Case in Cache Path Generation**

Modify the `git_repo_cache_path()` function to normalize URLs to lowercase before generating the cache path:

```rust
pub fn git_repo_cache_path(git_url: &str, rev_name: &str) -> PathBuf {
    let move_home = MOVE_HOME.clone();
    PathBuf::from(move_home).join(format!(
        "{}_{}",
        url_to_file_name(&git_url.to_lowercase()),  // Add .to_lowercase()
        rev_name.replace('/', "__")
    ))
}
```

**Additional Hardening Measures:**

1. **Validate Cache Integrity**: Before using a cached git repository, verify that the `origin` remote URL matches the expected URL (case-insensitive comparison)

2. **Add Warning for Case Variants**: Detect when multiple dependencies differ only in case and emit a warning

3. **Cache Validation**: Store metadata (original URL) alongside cached repositories and validate before use

4. **Documentation**: Document the case-sensitivity behavior and recommend Linux-based CI/CD pipelines for reproducible builds

5. **Lockfile with Full URLs**: Include full git URLs in lock files to enable verification of resolved dependencies

## Proof of Concept

**Setup Steps (macOS or Windows required):**

```bash
# Create two test repositories with case-different URLs
mkdir -p /tmp/test-repos
cd /tmp/test-repos

# Create legitimate package
mkdir LegitPackage && cd LegitPackage
git init
cat > Move.toml << 'EOF'
[package]
name = "LegitPackage"
version = "1.0.0"

[addresses]
std = "0x1"
EOF

mkdir -p sources
cat > sources/counter.move << 'EOF'
module std::counter {
    public fun get_value(): u64 { 42 }
}
EOF

git add . && git commit -m "Legitimate package"
cd ..

# Create malicious package (same structure, different code)
mkdir legitpackage && cd legitpackage  # lowercase 'l'
git init
cat > Move.toml << 'EOF'
[package]
name = "LegitPackage"
version = "1.0.0"

[addresses]
std = "0x1"
EOF

mkdir -p sources
cat > sources/counter.move << 'EOF'
module std::counter {
    // Malicious: returns different value
    public fun get_value(): u64 { 999 }
}
EOF

git add . && git commit -m "Malicious package"
cd ..

# Create consumer package depending on first variant
mkdir consumer && cd consumer
cat > Move.toml << 'EOF'
[package]
name = "Consumer"
version = "1.0.0"

[dependencies]
LegitPackage = { git = "file:///tmp/test-repos/LegitPackage", rev = "main" }

[addresses]
std = "0x1"
EOF

mkdir sources
cat > sources/test.move << 'EOF'
module std::test {
    use std::counter;
    
    public fun test(): u64 {
        counter::get_value()
    }
}
EOF

# Build on macOS - observe which dependency gets cached
aptos move compile --skip-fetch-latest-git-deps

# Now modify to depend on lowercase variant
cat > Move.toml << 'EOF'
[package]
name = "Consumer"
version = "1.0.0"

[dependencies]
LegitPackage = { git = "file:///tmp/test-repos/legitpackage", rev = "main" }

[addresses]
std = "0x1"
EOF

# Build again - on case-insensitive filesystem, it will reuse cached directory
# resulting in compilation of wrong code
aptos move compile --skip-fetch-latest-git-deps

# Verify the compiled bytecode - it should contain code from first dependency
# even though manifest specifies second dependency
```

**Expected Result on macOS/Windows:**
- Both URLs map to same cache directory in `~/.move/`
- Second build uses first dependency's code
- No error or warning raised
- Different bytecode than expected is produced

**Expected Result on Linux:**
- Separate cache directories created
- Each build uses correct dependency
- No collision occurs

This demonstrates the platform-specific vulnerability where cache path collision leads to silent use of incorrect dependency code.

**Notes:**

1. **Platform Impact**: This vulnerability specifically affects developers using macOS (default APFS) or Windows (default NTFS) filesystems. Linux users with default ext4/xfs filesystems are not affected due to case-sensitive filesystems.

2. **Detection Difficulty**: The vulnerability is particularly dangerous because:
   - No compilation errors occur
   - No warnings are emitted
   - Build appears successful
   - Only careful code inspection or behavioral testing would reveal the issue

3. **Aptos Framework Implications**: While the Aptos Framework Move code itself is stored in the repository and not fetched via git dependencies, third-party packages that depend on external git repositories are vulnerable. This includes DeFi protocols, NFT platforms, and other ecosystem projects built on Aptos.

4. **Package Lock Mechanism**: The existing `PackageLock` mechanism [4](#0-3)  prevents race conditions but does not address cache path collisions, as it operates at the process synchronization level, not the path resolution level.

5. **Git Remote Validation**: When the cache directory exists, the update logic [5](#0-4)  attempts to fetch and reset from the existing `origin` remote, which would point to whichever repository was cloned first, further cementing the cache poisoning.

### Citations

**File:** third_party/move/tools/move-package/src/source_package/manifest_parser.rs (L446-451)
```rust
fn url_to_file_name(url: &str) -> String {
    regex::Regex::new(r"/|:|\.|@")
        .unwrap()
        .replace_all(url, "_")
        .to_string()
}
```

**File:** third_party/move/tools/move-package/src/source_package/manifest_parser.rs (L566-573)
```rust
pub fn git_repo_cache_path(git_url: &str, rev_name: &str) -> PathBuf {
    let move_home = MOVE_HOME.clone();
    PathBuf::from(move_home).join(format!(
        "{}_{}",
        url_to_file_name(git_url),
        rev_name.replace('/', "__")
    ))
}
```

**File:** third_party/move/tools/move-package/src/resolution/resolution_graph.rs (L551-576)
```rust
    fn download_and_update_if_remote<W: Write>(
        dep_name: PackageName,
        dep: &Dependency,
        skip_fetch_latest_git_deps: bool,
        writer: &mut W,
    ) -> Result<()> {
        if let Some(git_info) = &dep.git_info {
            let git_url = git_info.git_url.as_str();
            let git_rev = git_info.git_rev.as_str();
            let git_path = &git_info.download_to.display().to_string();

            // If there is no cached dependency, download it
            if !git_info.download_to.exists() {
                writeln!(
                    writer,
                    "{} {}",
                    "FETCHING GIT DEPENDENCY".bold().green(),
                    git_url,
                )?;

                // Confirm git is available.
                git::confirm_git_available()?;

                // If the cached folder does not exist, download and clone accordingly
                git::clone(git_url, git_path, dep_name)?;
                git::checkout(git_path, git_rev, dep_name)?;
```

**File:** third_party/move/tools/move-package/src/resolution/resolution_graph.rs (L577-610)
```rust
            } else if !skip_fetch_latest_git_deps {
                // Confirm git is available.
                git::confirm_git_available()?;

                // Update the git dependency
                // Check first that it isn't a git rev (if it doesn't work, just continue with the fetch)
                if let Ok(parsed_rev) = git::find_rev(git_path, git_rev) {
                    // If it's exactly the same, then it's a git rev
                    if parsed_rev.trim().starts_with(git_rev) {
                        return Ok(());
                    }
                }

                if let Ok(tag) = git::find_tag(git_path, git_rev) {
                    // If it's exactly the same, then it's a git tag, for now tags won't be updated
                    // Tags don't easily update locally and you can't use reset --hard to cleanup
                    // any extra files
                    if tag.trim().starts_with(git_rev) {
                        return Ok(());
                    }
                }

                writeln!(
                    writer,
                    "{} {}",
                    "UPDATING GIT DEPENDENCY".bold().green(),
                    git_url,
                )?;
                // If the current folder exists, do a fetch and reset to ensure that the branch
                // is up to date
                // NOTE: this means that you must run the package system with a working network connection
                git::fetch_origin(git_path, dep_name)?;
                git::reset_hard(git_path, git_rev, dep_name)?;
            }
```

**File:** third_party/move/tools/move-package/src/package_lock.rs (L17-25)
```rust
/// The package lock is a lock held across threads and processes. This lock is held to ensure that
/// the Move package manager has a consistent (read: serial) view of the file system. Without this
/// lock we can easily get into race conditions around caching and overwriting of packages (e.g.,
/// thread 1 and thread 2 compete to build package P in the same location), as well as downloading
/// of git dependencies (thread 1 starts downloading git dependency, meanwhile thread 2 sees the
/// git directory before it has been fully populated but assumes it has been fully downloaded and
/// starts building the package before the git dependency has been fully downloaded by thread 1.
/// This will then lead to file not found errors). These same issues could occur across processes,
/// this is why we grab both a thread lock and process lock.
```
