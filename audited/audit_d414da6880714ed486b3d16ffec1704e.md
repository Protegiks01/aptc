# Audit Report

## Title
State Sync Initialization Hang Causes Permanent Node Startup DoS

## Summary
The Aptos node startup process synchronously blocks waiting for state sync initialization to complete without any timeout mechanism. For non-genesis nodes (or nodes with auto-bootstrapping disabled, which is the default), if bootstrapping cannot complete due to network issues or malicious peers, the node will hang indefinitely during startup and never become operational. [1](#0-0) 

## Finding Description

The vulnerability exists in the node initialization flow where state sync must complete bootstrapping before the node can proceed with startup:

**1. Blocking Initialization:**
The main node startup thread synchronously blocks waiting for state sync initialization: [2](#0-1) 

**2. No Timeout on Bootstrap Notification:**
The `block_until_initialized()` method waits indefinitely for bootstrapping to complete with no timeout: [1](#0-0) 

**3. Bootstrap Notification Flow:**
The driver client sends a notification and waits for a response via a oneshot channel: [3](#0-2) 

**4. Limited Auto-Bootstrapping Protection:**
Auto-bootstrapping only activates under very restrictive conditions - genesis validators (waypoint version == 0) AND when explicitly enabled (disabled by default): [4](#0-3) [5](#0-4) 

**Attack Vector:**

For a non-genesis node or any node with auto-bootstrapping disabled:
1. Node starts up and spawns the state sync driver
2. Main thread calls `block_until_initialized()` which sends a bootstrap notification
3. Bootstrapper attempts to sync data from peers
4. If no honest peers are available (network partition, all peers malicious/unresponsive, or incorrect waypoint configuration), the bootstrapper never completes
5. The oneshot channel never receives a response
6. `block_on(state_sync_client.notify_once_bootstrapped())` hangs forever
7. The node is permanently stuck in initialization and never becomes operational

**Critical Code Paths:**

The bootstrapper attempts to make progress in its drive loop: [6](#0-5) 

But if bootstrapping conditions cannot be met (no peers, verification failures, etc.), it will retry indefinitely without ever calling `bootstrapping_complete()`: [7](#0-6) 

## Impact Explanation

This is a **High Severity** vulnerability that causes complete loss of node availability:

- **Node Startup DoS**: Affected nodes hang indefinitely during startup and never become operational
- **No Recovery**: Without manual intervention (restart with different configuration), the node cannot recover
- **Network Impact**: Multiple nodes experiencing this simultaneously could impact network liveness
- **Validator Impact**: Validators unable to start cannot participate in consensus, potentially affecting the validator set

This meets the **High Severity** criteria per Aptos bug bounty: "Validator node slowdowns" and complete unavailability during initialization. While not a permanent network partition requiring a hardfork, it does cause significant operational disruption.

## Likelihood Explanation

**Likelihood: Medium to High**

This vulnerability can be triggered in several realistic scenarios:

1. **Network Partitions**: Temporary or sustained network issues preventing peer discovery
2. **New Node Deployment**: Nodes deployed in isolated network environments
3. **Misconfigured Waypoints**: Incorrect waypoint configuration making bootstrapping impossible
4. **Malicious Peers**: Coordinated attack where all accessible peers provide invalid data
5. **Default Configuration**: Auto-bootstrapping is **disabled by default**, meaning even genesis validators lack timeout protection unless explicitly configured

The attack requires no privileged access - only the ability to influence network connectivity or peer behavior, which is feasible for:
- Network administrators
- Attackers with network-level access
- During natural network disruptions
- In misconfigured deployments

## Recommendation

**Short-term Fix:**
Add a mandatory timeout to the bootstrap initialization process:

```rust
pub fn block_until_initialized(&self) {
    let state_sync_client = self.state_sync.create_driver_client();
    
    // Add a reasonable timeout (e.g., 5 minutes)
    let timeout_duration = Duration::from_secs(300);
    let bootstrap_future = state_sync_client.notify_once_bootstrapped();
    
    match tokio::time::timeout(timeout_duration, bootstrap_future) {
        Ok(Ok(())) => {
            info!("State sync initialized successfully");
        },
        Ok(Err(error)) => {
            panic!("State sync v2 initialization failure: {:?}", error);
        },
        Err(_) => {
            panic!("State sync v2 initialization timeout after {:?}", timeout_duration);
        }
    }
}
```

**Long-term Fixes:**

1. **Enable Auto-Bootstrapping by Default**: Change the default configuration to enable auto-bootstrapping: [5](#0-4) 

2. **Extend Auto-Bootstrapping**: Allow auto-bootstrapping for non-genesis nodes after a timeout if certain safety conditions are met

3. **Graceful Degradation**: Allow the node to start in a limited mode (e.g., API-only) if state sync cannot initialize, rather than hanging indefinitely

4. **Better Error Reporting**: Add periodic logging during initialization to indicate progress and help diagnose stuck states

## Proof of Concept

**Scenario 1: Network Isolation**
```bash
# Start an Aptos node with firewall rules blocking all peer connections
# and a non-zero waypoint (non-genesis node)

# 1. Configure node with waypoint > 0
# 2. Block all outbound connections to peers using iptables/firewall
# 3. Start the node
# 4. Observe: Node hangs indefinitely at "Waiting until state sync is initialized!"
# 5. Check logs: Driver continues attempting to connect to peers
# 6. Result: Node never completes initialization
```

**Scenario 2: Misconfigured Waypoint**
```bash
# Start node with an incorrect/future waypoint that cannot be satisfied

# 1. Set waypoint to a future version that no peers can provide
# 2. Start node
# 3. Observe: Bootstrapper fails waypoint verification repeatedly
# 4. Result: Node hangs in initialization forever
```

**Rust Reproduction Steps:**
```rust
// In a test environment:
// 1. Create a node with non-genesis waypoint
// 2. Mock the streaming client to return empty data or errors
// 3. Call block_until_initialized()
// 4. Verify the call never returns (use timeout to detect hang)
// 5. This demonstrates the vulnerability
```

## Notes

The vulnerability is particularly severe because:

1. **Default Configuration is Vulnerable**: Auto-bootstrapping is disabled by default, leaving all nodes (including genesis validators) without timeout protection unless explicitly configured

2. **Silent Failure**: The node appears to be running (process is alive) but is actually stuck in initialization, making the issue harder to detect

3. **Widespread Impact Potential**: Any deployment scenario with network issues, misconfiguration, or malicious peers can trigger this condition

4. **No Automatic Recovery**: Once stuck, the node requires manual intervention (restart with different configuration or network fixes) to recover

The issue specifically relates to the initialization flow where synchronous blocking without timeout creates a permanent DoS condition when bootstrapping cannot complete.

### Citations

**File:** state-sync/state-sync-driver/src/driver_factory.rs (L231-235)
```rust
    pub fn block_until_initialized(&self) {
        let state_sync_client = self.state_sync.create_driver_client();
        block_on(state_sync_client.notify_once_bootstrapped())
            .expect("State sync v2 initialization failure");
    }
```

**File:** aptos-node/src/lib.rs (L824-827)
```rust
    // Wait until state sync has been initialized
    debug!("Waiting until state sync is initialized!");
    state_sync_runtimes.block_until_initialized();
    debug!("State sync initialization complete.");
```

**File:** state-sync/state-sync-driver/src/driver_client.rs (L34-44)
```rust
    pub fn notify_once_bootstrapped(&self) -> impl Future<Output = Result<(), Error>> + use<> {
        let mut notification_sender = self.notification_sender.clone();
        let (callback_sender, callback_receiver) = oneshot::channel();

        async move {
            notification_sender
                .send(DriverNotification::NotifyOnceBootstrapped(callback_sender))
                .await?;
            callback_receiver.await?
        }
    }
```

**File:** state-sync/state-sync-driver/src/driver.rs (L636-641)
```rust
    async fn check_auto_bootstrapping(&mut self) {
        if !self.bootstrapper.is_bootstrapped()
            && self.is_consensus_or_observer_enabled()
            && self.driver_configuration.config.enable_auto_bootstrapping
            && self.driver_configuration.waypoint.version() == 0
        {
```

**File:** config/src/config/state_sync_config.rs (L140-140)
```rust
            enable_auto_bootstrapping: false,
```

**File:** state-sync/state-sync-driver/src/bootstrapper.rs (L373-378)
```rust
    pub async fn bootstrapping_complete(&mut self) -> Result<(), Error> {
        info!(LogSchema::new(LogEntry::Bootstrapper)
            .message("The node has successfully bootstrapped!"));
        self.bootstrapped = true;
        self.notify_listeners_if_bootstrapped().await
    }
```

**File:** state-sync/state-sync-driver/src/bootstrapper.rs (L414-441)
```rust
    pub async fn drive_progress(
        &mut self,
        global_data_summary: &GlobalDataSummary,
    ) -> Result<(), Error> {
        if self.is_bootstrapped() {
            return Err(Error::AlreadyBootstrapped(
                "The bootstrapper should not attempt to make progress!".into(),
            ));
        }

        if self.active_data_stream.is_some() {
            // We have an active data stream. Process any notifications!
            self.process_active_stream_notifications().await?;
        } else if self.storage_synchronizer.pending_storage_data() {
            // Wait for any pending data to be processed
            sample!(
                SampleRate::Duration(Duration::from_secs(PENDING_DATA_LOG_FREQ_SECS)),
                info!("Waiting for the storage synchronizer to handle pending data!")
            );
        } else {
            // Fetch a new data stream to start streaming data
            self.initialize_active_data_stream(global_data_summary)
                .await?;
        }

        // Check if we've now bootstrapped
        self.notify_listeners_if_bootstrapped().await
    }
```
