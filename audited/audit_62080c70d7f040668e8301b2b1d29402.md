# Audit Report

## Title
Incomplete Gas Schedule Validation Enables Network Halt via Governance Proposal

## Summary
The `gas_schedule::set_for_next_epoch()` function lacks validation to ensure all required gas parameters are present in `GasScheduleV2`, allowing a governance proposal to apply an incomplete gas schedule that causes total network liveness failure. All transactions fail with `VM_STARTUP_FAILURE` when the VM attempts to load missing gas parameters, requiring emergency intervention or hardfork to recover.

## Finding Description

The Aptos governance system allows updating the gas schedule through the `set_for_next_epoch()` function. However, this function only validates two properties: (1) the blob is non-empty, and (2) the feature version is not decreasing. [1](#0-0) 

The function does **not** validate that all required gas parameters are present. The TODO comments at lines 47, 67, and 75 explicitly acknowledge this validation gap. [2](#0-1) 

When the VM initializes for block execution, it loads gas parameters from on-chain state through `get_gas_parameters()`, which calls `AptosGasParameters::from_on_chain_gas_schedule()`. [3](#0-2) 

The `from_on_chain_gas_schedule()` implementation, generated by the `define_gas_parameters!` macro, attempts to retrieve each required gas parameter from the BTreeMap. When a parameter is missing, it returns an error instead of using a default value or cached old value. [4](#0-3) 

This error propagates to the `AptosEnvironment` which stores it as `Result<AptosGasParameters, String>`. [5](#0-4) 

During transaction execution, when the VM calls `gas_params()`, the `get_or_vm_startup_failure()` function converts the error into `VMStatus::error(StatusCode::VM_STARTUP_FAILURE, Some(msg))`. [6](#0-5) 

The test `missing_gas_parameter.rs` demonstrates this exact failure mode, showing that transactions are discarded with `VM_STARTUP_FAILURE` when a gas parameter is missing. [7](#0-6) 

**Attack Path:**
1. Malicious or mistaken governance proposal crafts a `GasScheduleV2` with only 10 entries instead of the required 100+
2. Proposal passes validation (only checks non-empty blob and feature version)
3. `set_for_next_epoch()` stages the incomplete schedule in `config_buffer`
4. During epoch reconfiguration, `on_new_epoch()` applies the incomplete schedule to on-chain state [8](#0-7) 
5. All validators read the same incomplete schedule from on-chain state (deterministic)
6. When executing any transaction, VM initialization fails when loading missing gas parameters
7. All transactions are discarded with `VM_STARTUP_FAILURE`
8. Network experiences total liveness loss - no transactions can execute

## Impact Explanation

**Critical Severity** - This meets the Aptos bug bounty criteria for "Non-recoverable network partition (requires hardfork)" and "Total loss of liveness/network availability":

- **Total Liveness Loss**: Once the incomplete gas schedule is applied, **no user transactions can execute**. Every transaction fails deterministically at VM initialization when attempting to load missing gas parameters.

- **Deterministic Failure**: All validators fail identically because they all read the same incomplete gas schedule from on-chain state. This prevents consensus divergence but ensures the failure is network-wide.

- **No Self-Recovery**: The chain cannot recover through normal governance because governance transactions also require VM execution with valid gas parameters. Even `WriteSetPayload` transactions would need coordination as they're typically used during network restarts, not during operation.

- **Requires Emergency Intervention**: Recovery requires either:
  - All validators coordinating to stop and restart with a patched state (effective hardfork)
  - Emergency `GenesisTransaction` requiring validator coordination
  - Manual database intervention on all validator nodes

This breaks the liveness invariant of the blockchain and effectively halts all economic activity until manual intervention.

## Likelihood Explanation

**Moderate Likelihood**:

- **Requires Governance Proposal**: An attacker would need to successfully pass a governance proposal, which requires significant voting power or social engineering.

- **Accidental Trigger Possible**: More likely to occur accidentally during legitimate gas schedule updates if developers make errors in generating the new schedule. The lack of validation makes human error likely.

- **No Runtime Detection**: The validation gap is documented in TODO comments but not enforced, meaning the issue persists until explicitly addressed.

- **Known Weakness**: The TODO comments indicate the development team is aware of the validation gap, suggesting it may have been encountered or considered previously.

## Recommendation

Implement comprehensive validation in `set_for_next_epoch()` and `set_for_next_epoch_check_hash()` to verify all required gas parameters are present before staging the update:

```move
public fun set_for_next_epoch(aptos_framework: &signer, gas_schedule_blob: vector<u8>) acquires GasScheduleV2 {
    system_addresses::assert_aptos_framework(aptos_framework);
    assert!(!vector::is_empty(&gas_schedule_blob), error::invalid_argument(EINVALID_GAS_SCHEDULE));
    let new_gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
    
    // NEW: Validate gas schedule completeness
    validate_gas_schedule_completeness(&new_gas_schedule);
    
    if (exists<GasScheduleV2>(@aptos_framework)) {
        let cur_gas_schedule = borrow_global<GasScheduleV2>(@aptos_framework);
        assert!(
            new_gas_schedule.feature_version >= cur_gas_schedule.feature_version,
            error::invalid_argument(EINVALID_GAS_FEATURE_VERSION)
        );
    };
    config_buffer::upsert(new_gas_schedule);
}

// Add helper function to validate required parameters
fun validate_gas_schedule_completeness(gas_schedule: &GasScheduleV2) {
    // Maintain a list of required gas parameter prefixes/names
    // Validate all expected parameters are present for the feature version
    // This can be implemented as native function or by maintaining a checklist
    
    let required_params = get_required_params_for_version(gas_schedule.feature_version);
    let i = 0;
    while (i < vector::length(&required_params)) {
        let required_param = vector::borrow(&required_params, i);
        assert!(
            has_parameter(gas_schedule, required_param),
            error::invalid_argument(EINVALID_GAS_SCHEDULE)
        );
        i = i + 1;
    };
}
```

Alternatively, implement the validation in Rust before serialization during proposal generation, or add a verification pass in the VM that provides better error messages before applying the update.

## Proof of Concept

The existing test demonstrates the vulnerability: [7](#0-6) 

To demonstrate the full attack:

1. Create a governance proposal that calls `gas_schedule::set_for_next_epoch()` with a `GasScheduleV2` containing only 10 entries
2. The proposal validation passes (only checks non-empty and feature version)
3. Wait for epoch reconfiguration
4. Observe all subsequent transactions fail with `VM_STARTUP_FAILURE`
5. Network liveness is lost until manual intervention

The test shows that when the gas schedule is modified to remove the `"instr.add"` parameter, transaction execution results in `TransactionStatus::Discard(StatusCode::VM_STARTUP_FAILURE)`. In production, this would affect all transactions across all validators once the incomplete schedule is applied through governance.

**Notes**

The vulnerability is particularly concerning because:
- The TODO comments indicate awareness but no timeline for fix
- The validation gap exists in multiple functions (`initialize`, `set_gas_schedule`, `set_for_next_epoch`)
- Recovery from this state requires coordinated emergency intervention across all validators
- The deterministic nature prevents consensus divergence but ensures network-wide impact

### Citations

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L47-47)
```text
        // TODO(Gas): check if gas schedule is consistent
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L91-103)
```text
    public fun set_for_next_epoch(aptos_framework: &signer, gas_schedule_blob: vector<u8>) acquires GasScheduleV2 {
        system_addresses::assert_aptos_framework(aptos_framework);
        assert!(!vector::is_empty(&gas_schedule_blob), error::invalid_argument(EINVALID_GAS_SCHEDULE));
        let new_gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
        if (exists<GasScheduleV2>(@aptos_framework)) {
            let cur_gas_schedule = borrow_global<GasScheduleV2>(@aptos_framework);
            assert!(
                new_gas_schedule.feature_version >= cur_gas_schedule.feature_version,
                error::invalid_argument(EINVALID_GAS_FEATURE_VERSION)
            );
        };
        config_buffer::upsert(new_gas_schedule);
    }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L135-145)
```text
    public(friend) fun on_new_epoch(framework: &signer) acquires GasScheduleV2 {
        system_addresses::assert_aptos_framework(framework);
        if (config_buffer::does_exist<GasScheduleV2>()) {
            let new_gas_schedule = config_buffer::extract_v2<GasScheduleV2>();
            if (exists<GasScheduleV2>(@aptos_framework)) {
                *borrow_global_mut<GasScheduleV2>(@aptos_framework) = new_gas_schedule;
            } else {
                move_to(framework, new_gas_schedule);
            }
        }
    }
```

**File:** aptos-move/aptos-vm-environment/src/gas.rs (L23-46)
```rust
fn get_gas_config_from_storage(
    sha3_256: &mut Sha3_256,
    state_view: &impl StateView,
) -> (Result<AptosGasParameters, String>, u64) {
    match GasScheduleV2::fetch_config_and_bytes(state_view) {
        Some((gas_schedule, bytes)) => {
            sha3_256.update(&bytes);
            let feature_version = gas_schedule.feature_version;
            let map = gas_schedule.into_btree_map();
            (
                AptosGasParameters::from_on_chain_gas_schedule(&map, feature_version),
                feature_version,
            )
        },
        None => match GasSchedule::fetch_config_and_bytes(state_view) {
            Some((gas_schedule, bytes)) => {
                sha3_256.update(&bytes);
                let map = gas_schedule.into_btree_map();
                (AptosGasParameters::from_on_chain_gas_schedule(&map, 0), 0)
            },
            None => (Err("Neither gas schedule v2 nor v1 exists.".to_string()), 0),
        },
    }
}
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/macros.rs (L38-41)
```rust
                    if let Some(key) = $crate::gas_schedule::macros::define_gas_parameters_extract_key_at_version!($key_bindings, feature_version) {
                        let name = format!("{}.{}", $prefix, key);
                        params.$name = gas_schedule.get(&name).cloned().ok_or_else(|| format!("Gas parameter {} does not exist. Feature version: {}.", name, feature_version))?.into();
                    }
```

**File:** aptos-move/aptos-vm-environment/src/environment.rs (L183-188)
```rust
    /// Gas parameters used in this environment. Error is stored if gas parameters were not found
    /// on-chain.
    gas_params: Result<AptosGasParameters, String>,
    /// Storage gas parameters used in this environment. Error is stored if gas parameters were not
    /// found on-chain.
    storage_gas_params: Result<StorageGasParameters, String>,
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L273-281)
```rust
pub(crate) fn get_or_vm_startup_failure<'a, T>(
    gas_params: &'a Result<T, String>,
    log_context: &AdapterLogSchema,
) -> Result<&'a T, VMStatus> {
    gas_params.as_ref().map_err(|err| {
        let msg = format!("VM Startup Failed. {}", err);
        speculative_error!(log_context, msg.clone());
        VMStatus::error(StatusCode::VM_STARTUP_FAILURE, Some(msg))
    })
```

**File:** aptos-move/e2e-move-tests/src/tests/missing_gas_parameter.rs (L8-28)
```rust
#[test]
fn missing_gas_parameter() {
    let mut h = MoveHarness::new();

    h.modify_gas_schedule_raw(|gas_schedule| {
        let idx = gas_schedule
            .entries
            .iter()
            .position(|(key, _val)| key == "instr.add")
            .unwrap();
        gas_schedule.entries.remove(idx);
    });

    // Load the code
    let acc = h.new_account_with_balance_at(AccountAddress::from_hex_literal("0xbeef").unwrap(), 0);
    let txn_status = h.publish_package(&acc, &common::test_dir_path("common.data/do_nothing"));
    assert!(matches!(
        txn_status,
        TransactionStatus::Discard(StatusCode::VM_STARTUP_FAILURE)
    ))
}
```
