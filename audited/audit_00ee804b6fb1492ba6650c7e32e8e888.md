# Audit Report

## Title
Block Proposer Can Manipulate On-Chain Timestamp to Extend Keyless Signature Validity

## Summary
Block proposers can manipulate the on-chain `CurrentTimeMicroseconds` value by setting block timestamps to values barely above the parent block's timestamp, causing on-chain time to advance more slowly than wall-clock time. This allows keyless signatures to remain valid for extended periods in wall-clock terms, beyond their intended expiry duration.

## Finding Description

The vulnerability exists in how block timestamps are validated and how they update the on-chain time used for keyless signature expiry checks. [1](#0-0) 

When a validator proposes a block, they set the `timestamp_usecs` field. The only validation constraints are: [2](#0-1) 

A malicious proposer can set the timestamp to `parent_timestamp + 1` microsecond, which passes validation since:
1. It's greater than the parent timestamp (satisfies monotonicity)
2. It's well within the 5-minute future bound

The on-chain time is then updated during block prologue execution: [3](#0-2) [4](#0-3) 

This updated on-chain time is subsequently used for keyless signature expiry validation: [5](#0-4) [6](#0-5) 

**Attack Scenario:**
1. On-chain time is currently 1000 seconds, wall-clock time is also ~1000 seconds
2. A keyless signature has expiry at 1300 seconds (intended to be valid for 300 more wall-clock seconds)
3. Malicious proposer creates block with timestamp = 1000.000001 seconds (parent + 1 microsecond)
4. Honest validators validate and vote (timestamp passes all checks)
5. Block commits, on-chain time updates to 1000.000001 seconds
6. 10 wall-clock seconds pass, another block is proposed
7. If proposer repeats this pattern, on-chain time barely advances while wall-clock time progresses normally
8. The keyless signature remains valid for much longer in wall-clock terms than intended

## Impact Explanation

This vulnerability falls under **Medium Severity** per the Aptos bug bounty criteria: "Limited funds loss or manipulation" and "State inconsistencies requiring intervention."

The impact includes:
- **Extended signature validity**: Keyless signatures can remain valid for hours or days of wall-clock time despite having short on-chain expiry windows
- **Security bypass**: The ephemeral key expiry mechanism intended to limit compromise windows is circumvented
- **Transaction authorization**: Attackers with compromised ephemeral keys can continue using them well beyond the intended time period
- **Unpredictable behavior**: Applications relying on time-based logic receive incorrect timing information

While this doesn't directly cause immediate loss of funds, it enables unauthorized transaction signing and breaks the security model of keyless authentication's time-limited credentials.

## Likelihood Explanation

**Likelihood: Medium to High**

This vulnerability is highly likely to be exploitable because:
- Any validator in the active set can execute this attack when selected as proposer
- No special privileges beyond being a validator are required
- The attack is trivial to execute (simply set timestamp to minimum valid value)
- No coordination with other validators is needed
- The manipulation is within valid consensus rules and won't be rejected

The main limitation is that an individual proposer can only manipulate their own blocks. However:
- With multiple malicious validators or repeated proposals from one validator, the effect compounds
- Even a single block with manipulated timestamp creates inconsistency lasting until other honest proposers correct it
- The 5-minute upper bound means proposers can always keep timestamps arbitrarily low relative to wall-clock time

## Recommendation

Implement a minimum timestamp advancement requirement to prevent proposers from setting timestamps arbitrarily close to the parent block. 

**Suggested fix in `consensus/consensus-types/src/block.rs`:**

Add validation to enforce that block timestamps must advance by at least a minimum amount unless it's a NIL block or reconfiguration suffix:

```rust
// After line 530
const MIN_TIMESTAMP_ADVANCEMENT_USECS: u64 = 100_000; // 100ms minimum

if !self.is_nil_block() && !parent.has_reconfiguration() {
    let timestamp_advancement = self.timestamp_usecs()
        .checked_sub(parent.timestamp_usecs())
        .ok_or_else(|| anyhow!("Timestamp arithmetic overflow"))?;
    
    ensure!(
        timestamp_advancement >= MIN_TIMESTAMP_ADVANCEMENT_USECS,
        "Block timestamp must advance by at least {} microseconds, got {}",
        MIN_TIMESTAMP_ADVANCEMENT_USECS,
        timestamp_advancement
    );
}
```

Additionally, consider validating that block timestamps are reasonably close to current wall-clock time:

```rust
const MAX_TIMESTAMP_LAG_USECS: u64 = 5_000_000; // 5 seconds max lag

ensure!(
    self.timestamp_usecs() + MAX_TIMESTAMP_LAG_USECS >= current_ts.as_micros() as u64,
    "Block timestamp is too far behind current time"
);
```

## Proof of Concept

```rust
// Test demonstrating timestamp manipulation
#[test]
fn test_timestamp_manipulation_extends_keyless_validity() {
    use aptos_types::block_metadata::BlockMetadata;
    use aptos_types::on_chain_config::CurrentTimeMicroseconds;
    use aptos_crypto::HashValue;
    
    // Setup: On-chain time at 1,000,000,000 microseconds (1000 seconds)
    let parent_timestamp = 1_000_000_000u64;
    
    // Keyless signature expires at 1,300,000,000 microseconds (1300 seconds)
    // Intended to be valid for 300 seconds of wall-clock time
    let signature_expiry = 1_300_000_000u64;
    
    // Attack: Malicious proposer sets next block timestamp to parent + 1 microsecond
    let malicious_timestamp = parent_timestamp + 1;
    
    // This passes validation (malicious_timestamp > parent_timestamp)
    assert!(malicious_timestamp > parent_timestamp);
    
    // And is within 5 minute future bound
    let current_wall_clock = 1_010_000_000u64; // 10 seconds later
    let future_bound = current_wall_clock + 300_000_000; // + 5 minutes
    assert!(malicious_timestamp <= future_bound);
    
    // After block commits, on-chain time is malicious_timestamp
    let on_chain_time = malicious_timestamp;
    
    // Signature expiry check: on_chain_time (1000000001) < signature_expiry (1300000000)
    assert!(on_chain_time < signature_expiry); // STILL VALID!
    
    // But 10 seconds of wall-clock time have passed
    // If timestamp advanced normally to current_wall_clock (1010000000),
    // the signature would still have 290 seconds until expiry
    // Instead it still has nearly 300 seconds because on-chain time barely moved
    
    // This can continue: if the malicious proposer keeps this up,
    // on-chain time remains artificially low while wall-clock time progresses
    // The signature meant to expire after 300 wall-clock seconds
    // could remain valid for hours of wall-clock time
}
```

**Notes:**
- Governance cannot directly manipulate `CurrentTimeMicroseconds` as `update_global_time` requires VM privilege
- However, validators (block proposers) can manipulate it within consensus bounds
- The vulnerability exploits the lack of minimum timestamp advancement requirements
- Each malicious proposer can slow on-chain time during their proposal rounds
- Multiple colluding validators or repeated proposals amplify the effect

### Citations

**File:** consensus/consensus-types/src/block_data.rs (L82-97)
```rust
    /// for
    /// * Time-dependent logic in smart contracts (the current time of execution)
    /// * Clients determining if they are relatively up-to-date with respect to the block chain.
    ///
    /// It makes the following guarantees:
    ///   1. Time Monotonicity: Time is monotonically increasing in the block chain.
    ///      (i.e. If H1 < H2, H1.Time < H2.Time).
    ///   2. If a block of transactions B is agreed on with timestamp T, then at least
    ///      f+1 honest validators think that T is in the past. An honest validator will
    ///      only vote on a block when its own clock >= timestamp T.
    ///   3. If a block of transactions B has a QC with timestamp T, an honest validator
    ///      will not serve such a block to other validators until its own clock >= timestamp T.
    ///   4. Current: an honest validator is not issuing blocks with a timestamp in the
    ///       future. Currently we consider a block is malicious if it was issued more
    ///       that 5 minutes in the future.
    timestamp_usecs: u64,
```

**File:** consensus/consensus-types/src/block.rs (L526-540)
```rust
        } else {
            ensure!(
                self.timestamp_usecs() > parent.timestamp_usecs(),
                "Blocks must have strictly increasing timestamps"
            );

            let current_ts = duration_since_epoch();

            // we can say that too far is 5 minutes in the future
            const TIMEBOUND: u64 = 300_000_000;
            ensure!(
                self.timestamp_usecs() <= (current_ts.as_micros() as u64).saturating_add(TIMEBOUND),
                "Blocks must not be too far in the future"
            );
        }
```

**File:** aptos-move/framework/aptos-framework/sources/block.move (L281-281)
```text
        timestamp::update_global_time(vm, new_block_event.proposer, new_block_event.time_microseconds);
```

**File:** aptos-move/framework/aptos-framework/sources/timestamp.move (L32-50)
```text
    public fun update_global_time(
        account: &signer,
        proposer: address,
        timestamp: u64
    ) acquires CurrentTimeMicroseconds {
        // Can only be invoked by AptosVM signer.
        system_addresses::assert_vm(account);

        let global_timer = borrow_global_mut<CurrentTimeMicroseconds>(@aptos_framework);
        let now = global_timer.microseconds;
        if (proposer == @vm_reserved) {
            // NIL block with null address as proposer. Timestamp must be equal.
            assert!(now == timestamp, error::invalid_argument(EINVALID_TIMESTAMP));
        } else {
            // Normal block. Time must advance
            assert!(now < timestamp, error::invalid_argument(EINVALID_TIMESTAMP));
            global_timer.microseconds = timestamp;
        };
    }
```

**File:** aptos-move/aptos-vm/src/keyless_validation.rs (L207-218)
```rust
    let onchain_timestamp_obj = get_current_time_onchain(resolver)?;
    // Check the expiry timestamp on all authenticators first to fail fast
    // This is a redundant check to quickly dismiss expired signatures early and save compute on more computationally costly checks.
    // The actual check is performed in `verify_keyless_signature_without_ephemeral_signature_check`.
    for (_, sig) in authenticators {
        sig.verify_expiry(onchain_timestamp_obj.microseconds)
            .map_err(|_| {
                // println!("[aptos-vm][groth16] ZKP expired");

                invalid_signature!("The ephemeral keypair has expired")
            })?;
    }
```

**File:** types/src/keyless/mod.rs (L202-212)
```rust
    pub fn verify_expiry(&self, current_time_microseconds: u64) -> anyhow::Result<()> {
        let block_time = UNIX_EPOCH.checked_add(Duration::from_micros(current_time_microseconds))
            .ok_or_else(|| anyhow::anyhow!("Overflowed on UNIX_EPOCH + current_time_microseconds when checking exp_date_secs"))?;
        let expiry_time = seconds_from_epoch(self.exp_date_secs)?;

        if block_time > expiry_time {
            bail!("Keyless signature is expired");
        } else {
            Ok(())
        }
    }
```
