# Audit Report

## Title
Missing Low-Order Point Validation in x25519 Public Key Handling for Noise IK Protocol

## Summary
The x25519 public keys extracted from NetworkAddress for the Noise IK handshake lack validation to reject low-order (small subgroup) curve points. While invalid keys do not cause panics, they create a cryptographic weakness where malicious nodes can use low-order points to enable brute-force attacks on session keys.

## Finding Description
When parsing a NetworkAddress in `parse_dial_addr()`, the code extracts a raw x25519::PublicKey from the NoiseIK protocol without any validation: [1](#0-0) 

The x25519::PublicKey type accepts any 32-byte array without checking if it represents a valid curve point or validating against low-order points: [2](#0-1) 

This unvalidated public key is then used in Diffie-Hellman operations during the Noise IK handshake: [3](#0-2) [4](#0-3) 

**Attack Path:**
1. Attacker generates a low-order x25519 point (e.g., order-8 point) and uses it as their network static key
2. Attacker advertises this in their NetworkAddress via discovery
3. When honest nodes dial the attacker's address, they perform Noise IK handshake using the low-order point
4. DH operations `e·rs` and `s·rs` (where `rs` is the attacker's low-order static key) produce outputs from a small set (≤8 values)
5. Attacker brute-forces all possible session keys (at most 8 attempts)
6. Attacker decrypts and potentially forges messages in the session

**Why no panics occur:**
The x25519_dalek library performs scalar multiplication on any 32-byte input without validation, returning a result (possibly weak) rather than panicking.

## Impact Explanation
This constitutes a **Medium severity** cryptographic protocol violation. While it doesn't directly lead to funds loss or consensus breaks, it violates the Noise IK protocol's security guarantees:

- **Confidentiality compromise**: Attacker can decrypt handshake messages and session traffic directed to them
- **Limited scope**: Only affects sessions where honest nodes connect TO the malicious node
- **Network layer weakness**: Could expose validator communication metadata or peer discovery information

The issue does not meet Critical/High severity because:
- No direct funds theft or consensus safety violation
- Attacker cannot forge messages without also controlling the peer
- Limited to specific attack scenarios (malicious node operator)

## Likelihood Explanation  
**Moderate likelihood** of exploitation:
- Requires attacker to operate a network node and control its identity key
- Attacker must successfully advertise malicious public key via discovery
- Other nodes must initiate connections to the attacker
- Detection is possible through monitoring for known low-order points

In Ed25519 implementations within the same codebase, similar validation exists: [5](#0-4) 

## Recommendation
Add validation to reject low-order x25519 public keys when deserializing from NetworkAddress. Implement a check similar to Ed25519's small-order validation:

```rust
// In crates/aptos-crypto/src/x25519.rs
impl std::convert::TryFrom<&[u8]> for PublicKey {
    type Error = traits::CryptoMaterialError;

    fn try_from(public_key_bytes: &[u8]) -> Result<Self, Self::Error> {
        let public_key_bytes: [u8; PUBLIC_KEY_SIZE] = public_key_bytes
            .try_into()
            .map_err(|_| traits::CryptoMaterialError::WrongLengthError)?;
        
        // Validate against known low-order points
        const LOW_ORDER_POINTS: [[u8; 32]; 8] = [
            [0u8; 32], // Identity
            // Add other known low-order points from RFC 7748
        ];
        
        if LOW_ORDER_POINTS.contains(&public_key_bytes) {
            return Err(traits::CryptoMaterialError::SmallSubgroupError);
        }
        
        Ok(Self(public_key_bytes))
    }
}
```

Additionally, validate the DH output is non-zero after each operation in the Noise protocol.

## Proof of Concept
```rust
#[cfg(test)]
mod test {
    use super::*;
    use crate::x25519;
    
    #[test]
    fn test_low_order_point_accepted() {
        // All-zero point (identity, order 1)
        let low_order = [0u8; 32];
        
        // Currently SUCCEEDS - should FAIL
        let pubkey = x25519::PublicKey::try_from(&low_order[..]);
        assert!(pubkey.is_ok()); // Demonstrates the vulnerability
        
        // When used in DH, produces predictable output
        let private = x25519::PrivateKey::generate(&mut rand::thread_rng());
        let shared_secret = private.diffie_hellman(&pubkey.unwrap());
        
        // Shared secret will be all zeros for identity point
        assert_eq!(shared_secret, [0u8; 32]);
    }
}
```

**Notes:**
- The question asks if "invalid keys can cause panics" - they do NOT
- The actual issue is cryptographic weakness from accepting low-order points
- Similar validation exists for Ed25519 but is missing for x25519
- Defense-in-depth measure recommended even though direct consensus impact is limited

### Citations

**File:** network/framework/src/transport/mod.rs (L498-503)
```rust
        match base_transport_suffix {
            [NoiseIK(pubkey), Handshake(version)] => {
                let base_addr = NetworkAddress::try_from(base_transport_protos.to_vec())
                    .expect("base_transport_protos is always non-empty");
                Ok((base_addr, *pubkey, *version))
            },
```

**File:** crates/aptos-crypto/src/x25519.rs (L222-236)
```rust
impl std::convert::From<[u8; PUBLIC_KEY_SIZE]> for PublicKey {
    fn from(public_key_bytes: [u8; PUBLIC_KEY_SIZE]) -> Self {
        Self(public_key_bytes)
    }
}

impl std::convert::TryFrom<&[u8]> for PublicKey {
    type Error = traits::CryptoMaterialError;

    fn try_from(public_key_bytes: &[u8]) -> Result<Self, Self::Error> {
        let public_key_bytes: [u8; PUBLIC_KEY_SIZE] = public_key_bytes
            .try_into()
            .map_err(|_| traits::CryptoMaterialError::WrongLengthError)?;
        Ok(Self(public_key_bytes))
    }
```

**File:** crates/aptos-crypto/src/noise.rs (L309-311)
```rust
        // -> es
        let dh_output = e.diffie_hellman(&rs);
        let k = mix_key(&mut ck, &dh_output)?;
```

**File:** crates/aptos-crypto/src/noise.rs (L326-328)
```rust
        // -> ss
        let dh_output = self.private_key.diffie_hellman(&rs);
        let k = mix_key(&mut ck, &dh_output)?;
```

**File:** aptos-move/framework/src/natives/cryptography/multi_ed25519.rs (L100-107)
```rust
                if CompressedEdwardsY(slice)
                    .decompress()
                    .is_some_and(|point| !point.is_small_order())
                {
                    num_valid += 1;
                } else {
                    break;
                }
```
