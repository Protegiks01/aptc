# Audit Report

## Title
Inspection Service Default Configuration Exposes Sensitive Validator Network Topology to External Networks

## Summary
The Aptos inspection service binds to `0.0.0.0` (all network interfaces) by default and exposes identity and peer information endpoints, allowing external attackers to perform network reconnaissance on validator nodes. This violates secure-by-default principles and enables targeted attacks against the validator network.

## Finding Description

The inspection service configuration has insecure defaults that expose sensitive network topology information to external networks: [1](#0-0) 

The service binds to the configured address without restriction: [2](#0-1) 

The `identity_information` endpoint exposes validator network peer IDs when enabled: [3](#0-2) [4](#0-3) 

The `peer_information` endpoint exposes comprehensive network topology when enabled: [5](#0-4) [6](#0-5) 

**Attack Path:**
1. Attacker scans for exposed port 9101 on validator nodes deployed without Docker port restrictions
2. Accesses `http://validator-ip:9101/identity_information` to retrieve validator network peer IDs
3. Accesses `http://validator-ip:9101/peer_information` to map complete network topology including trusted peers, connection states, and state sync metadata
4. Uses this information to:
   - Identify high-value validator targets
   - Plan eclipse attacks by understanding network connectivity
   - Execute targeted DDoS attacks on critical validators
   - Understand validator set composition and relationships

While Docker Compose deployments mitigate this with localhost-only port mapping: [7](#0-6) 

Operators running bare-metal or VM deployments using the example configuration files are vulnerable, as these files don't configure the inspection service: [8](#0-7) 

## Impact Explanation

**High Severity** - This vulnerability enables information disclosure that facilitates more sophisticated attacks:

1. **Validator Node Slowdowns**: Attackers can use topology information to launch targeted attacks against critical validators, causing performance degradation
2. **Network Reconnaissance**: Complete visibility into validator network structure enables eclipse attacks and network partitioning attempts
3. **Significant Protocol Violations**: While not directly causing consensus failure, the exposed information significantly lowers the barrier for attacks that could affect consensus

The issue qualifies as High Severity per Aptos bug bounty criteria because it enables "Validator node slowdowns" and "Significant protocol violations" by providing attackers with detailed network intelligence.

## Likelihood Explanation

**HIGH LIKELIHOOD** - This vulnerability will affect:
- Any validator deployed using bare-metal/VM installations following the example configurations
- Kubernetes deployments where services are exposed via LoadBalancer or NodePort without proper network policies
- Operators who are unaware that the default binding is to all interfaces

The likelihood is high because:
1. Default configuration is insecure (secure-by-default principle violated)
2. Example configuration files don't address this issue
3. No documentation warns operators about this security risk
4. Many operators may assume the service is internal-only based on its name ("inspection service")

## Recommendation

**Immediate Fix:** Change the default binding address to localhost:

```rust
impl Default for InspectionServiceConfig {
    fn default() -> InspectionServiceConfig {
        InspectionServiceConfig {
            address: "127.0.0.1".to_string(), // Changed from "0.0.0.0"
            port: 9101,
            expose_configuration: false,
            expose_identity_information: false, // Changed from true
            expose_peer_information: false,     // Changed from true
            expose_system_information: true,
        }
    }
}
```

**Additional Recommendations:**
1. Add explicit configuration to example `validator.yaml` files with secure defaults
2. Document that operators needing external access should use reverse proxies with authentication
3. Add startup warning log when service binds to non-localhost addresses
4. Consider adding IP allowlist configuration option for production deployments

## Proof of Concept

**Setup:** Deploy a validator node using default configuration on a VM with public IP:

```bash
# 1. Build aptos-node
cargo build --release -p aptos-node

# 2. Use example validator.yaml (no inspection_service config)
cp docker/compose/aptos-node/validator.yaml /opt/aptos/etc/

# 3. Start node
./target/release/aptos-node -f /opt/aptos/etc/validator.yaml
```

**Exploitation:**

```bash
# From external attacker machine:
# Discover validator's public IP (e.g., via network scanning)
VALIDATOR_IP="<public-ip>"

# Access identity information
curl http://$VALIDATOR_IP:9101/identity_information
# Returns: Validator network peer IDs, fullnode network peer IDs

# Access peer information  
curl http://$VALIDATOR_IP:9101/peer_information
# Returns: Complete network topology including:
# - All connected peers
# - Trusted validators
# - Connection states
# - State sync metadata
# - Priority/regular peer classifications

# Attacker now has complete validator network map for planning attacks
```

## Notes

The vulnerability exists because of the design decision to make the inspection service broadly accessible by default (binding to `0.0.0.0`) rather than following the security principle of least privilege. While Docker Compose deployments have protection, this is insufficient because:

1. It's a deployment-level mitigation, not a secure default in the code
2. Many production deployments don't use Docker Compose
3. Operators may be unaware of the security implications

The ConfigOptimizer only affects which endpoints are enabled on mainnet vs testnet, but doesn't change the binding address: [9](#0-8) 

This is a clear violation of secure-by-default principles where the production configuration should be secure out-of-the-box, requiring explicit opt-in for potentially dangerous configurations rather than opt-out.

### Citations

**File:** config/src/config/inspection_service_config.rs (L26-37)
```rust
impl Default for InspectionServiceConfig {
    fn default() -> InspectionServiceConfig {
        InspectionServiceConfig {
            address: "0.0.0.0".to_string(),
            port: 9101,
            expose_configuration: false,
            expose_identity_information: true,
            expose_peer_information: true,
            expose_system_information: true,
        }
    }
}
```

**File:** config/src/config/inspection_service_config.rs (L71-109)
```rust
impl ConfigOptimizer for InspectionServiceConfig {
    fn optimize(
        node_config: &mut NodeConfig,
        local_config_yaml: &Value,
        _node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<bool, Error> {
        let inspection_service_config = &mut node_config.inspection_service;
        let local_inspection_config_yaml = &local_config_yaml["inspection_service"];

        // Enable all endpoints for non-mainnet nodes (to aid debugging)
        let mut modified_config = false;
        if let Some(chain_id) = chain_id {
            if !chain_id.is_mainnet() {
                if local_inspection_config_yaml["expose_configuration"].is_null() {
                    inspection_service_config.expose_configuration = true;
                    modified_config = true;
                }

                if local_inspection_config_yaml["expose_identity_information"].is_null() {
                    inspection_service_config.expose_identity_information = true;
                    modified_config = true;
                }

                if local_inspection_config_yaml["expose_peer_information"].is_null() {
                    inspection_service_config.expose_peer_information = true;
                    modified_config = true;
                }

                if local_inspection_config_yaml["expose_system_information"].is_null() {
                    inspection_service_config.expose_system_information = true;
                    modified_config = true;
                }
            }
        }

        Ok(modified_config)
    }
}
```

**File:** crates/aptos-inspection-service/src/server/mod.rs (L55-69)
```rust
    // Fetch the service port and address
    let service_port = node_config.inspection_service.port;
    let service_address = node_config.inspection_service.address.clone();

    // Create the inspection service socket address
    let address: SocketAddr = (service_address.as_str(), service_port)
        .to_socket_addrs()
        .unwrap_or_else(|_| {
            panic!(
                "Failed to parse {}:{} as address",
                service_address, service_port
            )
        })
        .next()
        .unwrap();
```

**File:** crates/aptos-inspection-service/src/server/identity_information.rs (L13-26)
```rust
pub fn handle_identity_information_request(node_config: &NodeConfig) -> (StatusCode, Body, String) {
    // Only return identity information if the endpoint is enabled
    let (status_code, body) = if node_config.inspection_service.expose_identity_information {
        let identity_information = get_identity_information(node_config);
        (StatusCode::OK, Body::from(identity_information))
    } else {
        (
            StatusCode::FORBIDDEN,
            Body::from(IDENTITY_INFO_DISABLED_MESSAGE),
        )
    };

    (status_code, body, CONTENT_TYPE_TEXT.into())
}
```

**File:** crates/aptos-inspection-service/src/server/identity_information.rs (L29-51)
```rust
fn get_identity_information(node_config: &NodeConfig) -> String {
    let mut identity_information = Vec::<String>::new();
    identity_information.push("Identity Information:".into());

    // If the validator network is configured, fetch the identity information
    if let Some(validator_network) = &node_config.validator_network {
        identity_information.push(format!(
            "\t- Validator network ({}), peer ID: {}",
            validator_network.network_id,
            validator_network.peer_id()
        ));
    }

    // For each fullnode network, fetch the identity information
    for fullnode_network in &node_config.full_node_networks {
        identity_information.push(format!(
            "\t- Fullnode network ({}), peer ID: {}",
            fullnode_network.network_id,
            fullnode_network.peer_id()
        ));
    }

    identity_information.join("\n") // Separate each entry with a newline to construct the output
```

**File:** crates/aptos-inspection-service/src/server/peer_information.rs (L21-38)
```rust
pub fn handle_peer_information_request(
    node_config: &NodeConfig,
    aptos_data_client: AptosDataClient,
    peers_and_metadata: Arc<PeersAndMetadata>,
) -> (StatusCode, Body, String) {
    // Only return peer information if the endpoint is enabled
    let (status_code, body) = if node_config.inspection_service.expose_peer_information {
        let peer_information = get_peer_information(aptos_data_client, peers_and_metadata);
        (StatusCode::OK, Body::from(peer_information))
    } else {
        (
            StatusCode::FORBIDDEN,
            Body::from(PEER_INFO_DISABLED_MESSAGE),
        )
    };

    (status_code, body, CONTENT_TYPE_TEXT.into())
}
```

**File:** crates/aptos-inspection-service/src/server/peer_information.rs (L273-300)
```rust
/// Displays the entire set of trusted peers
fn display_trusted_peers(
    peer_information_output: &mut Vec<String>,
    registered_networks: Vec<NetworkId>,
    peers_and_metadata: &PeersAndMetadata,
) {
    peer_information_output.push("Trusted peers (validator set & seeds):".into());

    // Fetch and display the trusted peers for each network
    for network in registered_networks {
        peer_information_output.push(format!("\t- Network: {}", network));
        if let Ok(trusted_peers) = peers_and_metadata.get_trusted_peers(&network) {
            // Sort the peers before displaying them
            let mut sorted_trusted_peers = BTreeMap::new();
            for (peer_id, peer_info) in trusted_peers {
                sorted_trusted_peers.insert(peer_id, peer_info);
            }

            // Display the trusted peers
            for (peer_id, peer_info) in sorted_trusted_peers {
                peer_information_output.push(format!(
                    "\t\t- Peer: {:?}, peer information: {:?}",
                    peer_id, peer_info
                ));
            }
        }
    }
}
```

**File:** docker/compose/aptos-node/docker-compose.yaml (L31-33)
```yaml
      # Preface these with 127 to only expose them locally
      - "127.0.0.1:9101:9101"
      - "127.0.0.1:9102:9102"
```

**File:** docker/compose/aptos-node/validator.yaml (L1-46)
```yaml
base:
  role: "validator"
  data_dir: "/opt/aptos/data"
  waypoint:
    from_file: "/opt/aptos/genesis/waypoint.txt"

consensus:
  safety_rules:
    service:
      type: "local"
    backend:
      type: "on_disk_storage"
      path: secure-data.json
      namespace: ~
    initial_safety_rules_config:
      from_file:
        waypoint:
          from_file: /opt/aptos/genesis/waypoint.txt
        identity_blob_path: /opt/aptos/genesis/validator-identity.yaml

execution:
  genesis_file_location: "/opt/aptos/genesis/genesis.blob"

storage:
  rocksdb_configs:
    enable_storage_sharding: true

validator_network:
  discovery_method: "onchain"
  mutual_authentication: true
  identity:
    type: "from_file"
    path: /opt/aptos/genesis/validator-identity.yaml

full_node_networks:
- network_id:
    private: "vfn"
  listen_address: "/ip4/0.0.0.0/tcp/6181"
  identity:
    type: "from_config"
    key: "b0f405a3e75516763c43a2ae1d70423699f34cd68fa9f8c6bb2d67aa87d0af69"
    peer_id: "00000000000000000000000000000000d58bc7bb154b38039bc9096ce04e1237"

api:
  enabled: true
  address: "0.0.0.0:8080"
```
