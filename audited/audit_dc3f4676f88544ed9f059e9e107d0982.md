# Audit Report

## Title
Error Classification Bypass Allows Unthrottled State Value Requests with Invalid Indices

## Summary
The storage service validates state value requests by checking only the version parameter, not the start_index/end_index parameters. When invalid indices are provided, the storage layer fails with `AptosDbError` which gets misclassified as `StorageErrorEncountered` instead of `InvalidRequest`. This bypasses peer rate limiting, allowing malicious peers to spam the server with resource-intensive requests without being throttled.

## Finding Description

The vulnerability exists in the request validation and error handling flow for `GetStateValuesWithProof` requests.

**Validation Gap:**
The `can_service()` method only validates the version parameter, not the indices: [1](#0-0) 

The request structure contains unvalidated `start_index` and `end_index` fields: [2](#0-1) 

**Error Misclassification:**
When invalid indices are provided, the storage layer creates a Jellyfish Merkle iterator. If the start_index exceeds the leaf count, the iterator returns done without errors: [3](#0-2) 

However, when the iterator produces no values, the subsequent call to `get_value_chunk_proof()` fails with an `ensure!` check: [4](#0-3) 

This `AptosDbError` is automatically converted to `StorageErrorEncountered`: [5](#0-4) 

**Rate Limiting Bypass:**
The moderator only increments the invalid request counter when `can_service()` returns false: [6](#0-5) 

Since `StorageErrorEncountered` is not classified as `InvalidRequest`, these malicious requests don't increment the peer's invalid request counter, bypassing the rate limiting mechanism that would otherwise ignore the peer after `max_invalid_requests_per_peer` attempts. [7](#0-6) 

## Impact Explanation

**High Severity** - This meets the criteria for "Validator node slowdowns" and "Significant protocol violations" under the High severity category ($50,000).

The vulnerability allows:
1. **Resource Exhaustion**: Each malicious request still consumes CPU/memory to process storage operations, create iterators, and attempt proof generation
2. **Unthrottled DoS**: Multiple malicious peers can coordinate to overwhelm storage servers without being rate-limited
3. **Logging Pollution**: Fills logs with "storage errors" that are actually malicious requests, hindering legitimate debugging
4. **Monitoring Confusion**: Operators see storage errors and investigate the wrong layer, while the actual attack continues undetected
5. **Availability Impact**: Can degrade storage service responsiveness for legitimate state sync operations

## Likelihood Explanation

**High Likelihood**:
- **Easy to exploit**: Attacker only needs to craft a `StateValuesWithProofRequest` with valid version but `start_index = u64::MAX` or any value greater than the actual state count at that version
- **No special access required**: Any network peer can send storage service requests
- **Difficult to detect**: Logs show "storage errors" rather than invalid requests, masking the attack
- **No cost to attacker**: Failed requests don't increment invalid request counter, allowing unlimited retry

## Recommendation

**Add index validation to the `can_service()` method:**

Before checking if the version is valid, also validate that the indices are reasonable. Add a method to query the approximate state count at a version and ensure `start_index` is within reasonable bounds.

**Alternative: Classify empty result errors as InvalidRequest:**

Modify the storage layer to distinguish between genuine storage errors and empty result errors caused by invalid parameters. When `get_value_chunk_proof()` fails due to empty `state_key_values`, return a different error variant that gets classified as `InvalidRequest` rather than `StorageErrorEncountered`.

**Example fix in error classification:** [8](#0-7) 

Add a check after the iterator completes to detect empty results and return `Error::InvalidRequest` instead of allowing it to propagate as a storage error.

## Proof of Concept

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use aptos_config::config::StorageServiceConfig;
    use aptos_storage_service_types::requests::{DataRequest, StateValuesWithProofRequest, StorageServiceRequest};
    
    #[test]
    fn test_invalid_index_bypass_rate_limiting() {
        // Setup: Create storage service with mock data
        let config = StorageServiceConfig::default();
        let storage = create_mock_db_with_version(100); // Has state at version 100
        
        // Attack: Request with valid version but invalid start_index
        let malicious_request = StorageServiceRequest {
            data_request: DataRequest::GetStateValuesWithProof(
                StateValuesWithProofRequest {
                    version: 100,          // Valid version (passes validation)
                    start_index: u64::MAX, // Invalid index (not validated)
                    end_index: u64::MAX,
                }
            ),
            use_compression: false,
        };
        
        let peer = PeerNetworkId::new(NetworkId::Public, PeerId::random());
        
        // First request - should fail with StorageErrorEncountered
        let result = handler.process_request(&peer, malicious_request.clone(), false);
        assert!(matches!(result, Err(StorageServiceError::InternalError(_))));
        
        // Verify: Invalid request counter was NOT incremented
        let peer_state = moderator.get_unhealthy_peer_states().get(&peer);
        assert_eq!(peer_state.map(|s| s.invalid_request_count).unwrap_or(0), 0);
        
        // Attack continues: Send 100 more malicious requests
        for _ in 0..100 {
            let _ = handler.process_request(&peer, malicious_request.clone(), false);
        }
        
        // Verify: Peer is still NOT ignored (counter never reached max)
        let peer_state = moderator.get_unhealthy_peer_states().get(&peer);
        assert!(!peer_state.map(|s| s.is_ignored()).unwrap_or(false));
        
        // Demonstrate: A genuine invalid request would increment counter
        let truly_invalid_request = StorageServiceRequest {
            data_request: DataRequest::GetStateValuesWithProof(
                StateValuesWithProofRequest {
                    version: 999999, // Version outside available range
                    start_index: 0,
                    end_index: 100,
                }
            ),
            use_compression: false,
        };
        
        let _ = handler.process_request(&peer, truly_invalid_request, false);
        let peer_state = moderator.get_unhealthy_peer_states().get(&peer);
        assert_eq!(peer_state.map(|s| s.invalid_request_count).unwrap_or(0), 1);
    }
}
```

## Notes

This vulnerability specifically affects state value requests because they have a two-level parameter structure (version + indices), where only the first level is validated. Transaction requests validate the entire range, making them not vulnerable to this specific attack vector. The fix should either validate indices during the `can_service()` check or reclassify the empty result error to ensure proper peer rate limiting.

### Citations

**File:** state-sync/storage-service/types/src/responses.rs (L727-742)
```rust
            GetStateValuesWithProof(request) => {
                let proof_version = request.version;

                let can_serve_states = self
                    .states
                    .map(|range| range.contains(request.version))
                    .unwrap_or(false);

                let can_create_proof = self
                    .synced_ledger_info
                    .as_ref()
                    .map(|li| li.ledger_info().version() >= proof_version)
                    .unwrap_or(false);

                can_serve_states && can_create_proof
            },
```

**File:** state-sync/storage-service/types/src/requests.rs (L344-348)
```rust
pub struct StateValuesWithProofRequest {
    pub version: u64,     // The version to fetch the state values at
    pub start_index: u64, // The index to start fetching state values (inclusive)
    pub end_index: u64,   // The index to stop fetching state values (inclusive)
}
```

**File:** storage/jellyfish-merkle/src/iterator/mod.rs (L207-220)
```rust
    pub fn new_by_index(reader: Arc<R>, version: Version, start_idx: usize) -> Result<Self> {
        let mut parent_stack = vec![];

        let mut current_node_key = NodeKey::new_empty_path(version);
        let mut current_node = reader.get_node(&current_node_key)?;
        if start_idx >= current_node.leaf_count() {
            return Ok(Self {
                reader,
                version,
                parent_stack,
                done: true,
                phantom_value: PhantomData,
            });
        }
```

**File:** storage/aptosdb/src/state_store/mod.rs (L1123-1127)
```rust
        ensure!(
            !state_key_values.is_empty(),
            "State chunk starting at {}",
            first_index,
        );
```

**File:** state-sync/storage-service/server/src/error.rs (L43-47)
```rust
impl From<aptos_storage_interface::AptosDbError> for Error {
    fn from(error: aptos_storage_interface::AptosDbError) -> Self {
        Error::StorageErrorEncountered(error.to_string())
    }
}
```

**File:** state-sync/storage-service/server/src/moderator.rs (L47-69)
```rust
    /// Increments the invalid request count for the peer and marks
    /// the peer to be ignored if it has sent too many invalid requests.
    /// Note: we only ignore peers on the public network.
    pub fn increment_invalid_request_count(&mut self, peer_network_id: &PeerNetworkId) {
        // Increment the invalid request count
        self.invalid_request_count += 1;

        // If the peer is a PFN and has sent too many invalid requests, start ignoring it
        if self.ignore_start_time.is_none()
            && peer_network_id.network_id().is_public_network()
            && self.invalid_request_count >= self.max_invalid_requests
        {
            // TODO: at some point we'll want to terminate the connection entirely

            // Start ignoring the peer
            self.ignore_start_time = Some(self.time_service.now());

            // Log the fact that we're now ignoring the peer
            warn!(LogSchema::new(LogEntry::RequestModeratorIgnoredPeer)
                .peer_network_id(peer_network_id)
                .message("Ignoring peer due to too many invalid requests!"));
        }
    }
```

**File:** state-sync/storage-service/server/src/moderator.rs (L154-185)
```rust
            // Verify the request is serviceable using the current storage server summary
            if !storage_server_summary.can_service(
                &self.aptos_data_client_config,
                self.time_service.clone(),
                request,
            ) {
                // Increment the invalid request count for the peer
                let mut unhealthy_peer_state = self
                    .unhealthy_peer_states
                    .entry(*peer_network_id)
                    .or_insert_with(|| {
                        // Create a new unhealthy peer state (this is the first invalid request)
                        let max_invalid_requests =
                            self.storage_service_config.max_invalid_requests_per_peer;
                        let min_time_to_ignore_peers_secs =
                            self.storage_service_config.min_time_to_ignore_peers_secs;
                        let time_service = self.time_service.clone();

                        UnhealthyPeerState::new(
                            max_invalid_requests,
                            min_time_to_ignore_peers_secs,
                            time_service,
                        )
                    });
                unhealthy_peer_state.increment_invalid_request_count(peer_network_id);

                // Return the validation error
                return Err(Error::InvalidRequest(format!(
                    "The given request cannot be satisfied. Request: {:?}, storage summary: {:?}",
                    request, storage_server_summary
                )));
            }
```

**File:** state-sync/storage-service/server/src/storage.rs (L960-973)
```rust
                Some(Err(error)) => {
                    return Err(Error::StorageErrorEncountered(error.to_string()));
                },
                None => {
                    // Log a warning that the iterator did not contain all the expected data
                    warn!(
                        "The state value iterator is missing data! Version: {:?}, \
                        start index: {:?}, end index: {:?}, num state values to fetch: {:?}",
                        version, start_index, end_index, num_state_values_to_fetch
                    );
                    break;
                },
            }
        }
```
