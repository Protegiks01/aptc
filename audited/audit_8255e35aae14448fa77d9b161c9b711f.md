# Audit Report

## Title
Division-by-Zero in Executor Service Sharding Logic Due to Unvalidated `num_shards` Parameter

## Summary
The `num_shards` parameter in the executor service lacks validation to ensure it is greater than zero. When `num_shards` is set to 0 via command-line arguments, multiple division-by-zero panics occur in the sharding logic, causing immediate validator executor process crashes.

## Finding Description

The executor service's command-line argument parser accepts `num_shards` without validation [1](#0-0) . This value flows through multiple components without bounds checking, leading to division-by-zero operations in at least two critical locations:

**Division Location #1: Block Partitioner**
The `get_anchor_shard_id()` function performs a modulo operation that panics when `num_shards` is 0 [2](#0-1) . This function is called during transaction partitioning when building conflict trackers [3](#0-2) .

**Division Location #2: Local Executor Shard Setup**
The `setup_local_executor_shards()` function calculates threads per shard using division, which produces infinity/NaN when `num_shards` is 0 [4](#0-3) .

**Exploitation Path:**
1. Validator operator launches executor service: `./executor-service --num-shards 0 --shard-id 0 --remote-executor-addresses addr1 --coordinator-address coordinator`
2. Service initializes and calls `ProcessExecutorService::new()` [5](#0-4) 
3. When first block arrives for partitioning, `get_anchor_shard_id()` is invoked
4. Modulo operation `% 0` triggers panic: "attempt to calculate the remainder with a divisor of zero"
5. Executor process crashes, shard becomes unavailable

## Impact Explanation

**Severity: High** (Validator node crashes)

This meets the High severity criteria per Aptos bug bounty program: "Validator node slowdowns" and "API crashes". The impact includes:

- **Immediate service unavailability**: The executor shard crashes on first block execution attempt
- **No graceful degradation**: Process terminates with panic, no recovery possible
- **Consensus impact**: If this affects multiple shards, block execution fails entirely
- **Operational disruption**: Requires operator intervention to restart with correct configuration

However, this vulnerability has **limited exploitability** because:
- Requires operator access to set command-line arguments
- Cannot be triggered by external network requests
- Requires insider access or operational error

## Likelihood Explanation

**Likelihood: Medium-Low**

While the vulnerability is deterministic (always crashes with `num_shards=0`), it requires:
- Validator operator error during deployment/configuration
- No automated validation in deployment scripts
- Bypassing any external orchestration systems (Kubernetes, systemd, etc.)

The likelihood increases if:
- Configuration is dynamically generated from templates
- Operators use automation that could introduce zero values
- Documentation doesn't explicitly warn about this constraint

## Recommendation

Add validation in the `Args` struct to enforce invariants before service initialization:

```rust
#[derive(Debug, Parser)]
struct Args {
    #[clap(long, default_value_t = 8)]
    pub num_executor_threads: usize,

    #[clap(long)]
    pub shard_id: usize,

    #[clap(long)]
    pub num_shards: usize,

    #[clap(long, num_args = 1..)]
    pub remote_executor_addresses: Vec<SocketAddr>,

    #[clap(long)]
    pub coordinator_address: SocketAddr,
}

impl Args {
    fn validate(&self) -> Result<(), String> {
        if self.num_shards == 0 {
            return Err("num_shards must be greater than 0".to_string());
        }
        if self.num_shards != self.remote_executor_addresses.len() {
            return Err(format!(
                "num_shards ({}) must equal remote_executor_addresses.len() ({})",
                self.num_shards,
                self.remote_executor_addresses.len()
            ));
        }
        if self.shard_id >= self.num_shards {
            return Err(format!(
                "shard_id ({}) must be less than num_shards ({})",
                self.shard_id, self.num_shards
            ));
        }
        Ok(())
    }
}

fn main() {
    let args = Args::parse();
    
    // Validate arguments before initialization
    if let Err(e) = args.validate() {
        eprintln!("Invalid configuration: {}", e);
        std::process::exit(1);
    }
    
    aptos_logger::Logger::new().init();
    // ... rest of main
}
```

Additionally, add defensive checks in `get_anchor_shard_id()` and `setup_local_executor_shards()`.

## Proof of Concept

```rust
// File: execution/executor-service/src/main.rs (reproduction test)
#[test]
#[should_panic(expected = "attempt to calculate the remainder with a divisor of zero")]
fn test_num_shards_zero_causes_panic() {
    use execution_block_partitioner::get_anchor_shard_id;
    use aptos_types::transaction::analyzed_transaction::StorageLocation;
    use aptos_types::state_store::state_key::StateKey;
    use move_core_types::account_address::AccountAddress;
    
    // Simulate the division-by-zero scenario
    let storage_location = StorageLocation::new(
        StateKey::raw(b"test_key".to_vec()),
        AccountAddress::random(),
        false,
    );
    
    // This will panic with division by zero
    let _ = get_anchor_shard_id(&storage_location, 0);
}

// Alternative: Direct command-line reproduction
// $ cargo build --release --bin executor-service
// $ ./target/release/executor-service \
//     --num-shards 0 \
//     --shard-id 0 \
//     --remote-executor-addresses 127.0.0.1:8080 \
//     --coordinator-address 127.0.0.1:9090
// 
// Expected: Process will panic when attempting to partition first block
```

**Notes:**
- While this is a valid code defect that causes crashes, it requires operator-level access to trigger
- The vulnerability does not violate consensus safety or state consistency guarantees
- External attackers cannot exploit this without infrastructure access
- Primary concern is operational robustness rather than security exploitation

### Citations

**File:** execution/executor-service/src/main.rs (L17-18)
```rust
    #[clap(long)]
    pub num_shards: usize,
```

**File:** execution/executor-service/src/main.rs (L37-43)
```rust
    let _exe_service = ProcessExecutorService::new(
        args.shard_id,
        args.num_shards,
        args.num_executor_threads,
        args.coordinator_address,
        args.remote_executor_addresses,
    );
```

**File:** execution/block-partitioner/src/lib.rs (L39-43)
```rust
fn get_anchor_shard_id(storage_location: &StorageLocation, num_shards: usize) -> ShardId {
    let mut hasher = DefaultHasher::new();
    storage_location.hash(&mut hasher);
    (hasher.finish() % num_shards as u64) as usize
}
```

**File:** execution/block-partitioner/src/v2/init.rs (L45-49)
```rust
                            state.trackers.entry(key_idx).or_insert_with(|| {
                                let anchor_shard_id = get_anchor_shard_id(
                                    storage_location,
                                    state.num_executor_shards,
                                );
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/local_executor_shard.rs (L82-83)
```rust
        let num_threads = num_threads
            .unwrap_or_else(|| (num_cpus::get() as f64 / num_shards as f64).ceil() as usize);
```
