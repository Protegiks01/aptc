# Audit Report

## Title
Fast Sync Mode Incorrectly Re-syncs Node After Crash Due to Missing OverallCommitProgress

## Summary
The `get_synced_version()` function can return `None` when the node has already committed data but crashed before writing `OverallCommitProgress`. This causes the fast sync initialization logic to incorrectly assume the database is empty, leading to unnecessary creation of a secondary database and complete re-syncing of all blockchain data that was already persisted.

## Finding Description

The Aptos storage system uses a multi-stage commit process where different database components are committed in sequence:

1. First, `pre_commit_ledger` commits transactions, state KV, and writes `LedgerCommitProgress` [1](#0-0) 

2. Then, `commit_ledger` writes `OverallCommitProgress` atomically after all components are committed [2](#0-1) 

The design philosophy states that `OverallCommitProgress` is "committed at the last, and used as the source of truth of the commit progress" [3](#0-2) 

If a node crashes between these two steps, the database contains:
- Fully committed transaction data, state KV, state merkle tree data
- `LedgerCommitProgress` marker indicating data was written
- **Missing** `OverallCommitProgress` marker

On restart, when fast sync mode is enabled, the initialization logic checks whether to create a secondary database for fast syncing: [4](#0-3) 

The `get_synced_version()` function reads only `OverallCommitProgress`: [5](#0-4) 

When `OverallCommitProgress` is missing, `get_synced_version()` returns `None`, which is mapped to 0. This causes the fast sync wrapper to incorrectly conclude the database is empty and create a secondary database, triggering a full re-sync of all blockchain state that was already persisted.

Meanwhile, `sync_commit_progress` also fails to detect the inconsistency: [6](#0-5) 

When `overall_commit_progress` is `None`, it simply logs a message and returns without performing any consistency checks or recovery: [7](#0-6) 

## Impact Explanation

This is a **Low Severity** issue per the Aptos bug bounty criteria, qualifying as a "non-critical implementation bug." The impact is:

1. **Operational inefficiency**: The node wastes significant bandwidth and time re-downloading gigabytes of blockchain data it already has
2. **Delayed node availability**: The node remains unavailable longer than necessary while performing redundant synchronization
3. **Resource waste**: Additional storage space consumed by the secondary database during the unnecessary sync

However, this does NOT cause:
- Loss of funds or consensus violations
- Permanent data corruption (the re-sync will eventually complete successfully)
- Network-wide impact (only affects individual nodes that crash during specific timing windows)
- Security vulnerabilities that can be actively exploited by attackers

## Likelihood Explanation

**Moderate likelihood** - This occurs when:
1. A node is configured for fast sync mode (common for new nodes)
2. The node crashes or is killed during the brief window between `pre_commit_ledger` and `commit_ledger` completion
3. The node has committed at least some data (not a fresh genesis node)

While the timing window is narrow (typically milliseconds), crashes during production deployments, unexpected shutdowns, or infrastructure failures make this scenario realistic. Nodes with unstable infrastructure or frequent restarts are particularly susceptible.

## Recommendation

The fast sync initialization should check for actual database emptiness using multiple indicators, not just `OverallCommitProgress`. Specifically, check `LedgerCommitProgress` or use `get_pre_committed_version()` as a fallback:

```rust
// In fast_sync_storage_wrapper.rs, replace lines 71-76:
if config
    .state_sync
    .state_sync_driver
    .bootstrapping_mode
    .is_fast_sync()
    && {
        // Check synced version first
        let synced_version = db_main
            .ledger_db
            .metadata_db()
            .get_synced_version()?
            .map_or(0, |v| v);
        
        // Fallback to ledger commit progress if overall progress is missing
        if synced_version == 0 {
            db_main
                .ledger_db
                .metadata_db()
                .get_ledger_commit_progress()
                .ok()
                .map_or(0, |v| v) == 0
        } else {
            synced_version == 0
        }
    }
```

Additionally, `sync_commit_progress` should handle the missing `OverallCommitProgress` case more gracefully by checking if other progress markers exist and recovering appropriately.

## Proof of Concept

```rust
// Test demonstrating the issue
#[test]
fn test_missing_overall_commit_progress_causes_unnecessary_resync() {
    use tempfile::tempdir;
    
    // Setup: Create a DB and commit some data
    let tmpdir = tempdir().unwrap();
    let mut config = NodeConfig::default();
    config.storage.dir = tmpdir.path().to_path_buf();
    config.state_sync.state_sync_driver.bootstrapping_mode = 
        BootstrappingMode::DownloadLatestStates;
    
    // Commit data with LedgerCommitProgress but without OverallCommitProgress
    let db = AptosDB::open(...);
    let mut batch = SchemaBatch::new();
    batch.put::<DbMetadataSchema>(
        &DbMetadataKey::LedgerCommitProgress,
        &DbMetadataValue::Version(1000)
    ).unwrap();
    // Intentionally omit OverallCommitProgress to simulate crash
    db.ledger_db.metadata_db().write_schemas(batch).unwrap();
    
    // Write some actual transaction data to make DB non-empty
    // ... (commit transactions to DB)
    
    drop(db);
    
    // Reopen with fast sync - should NOT create secondary DB since data exists
    let result = FastSyncStorageWrapper::initialize_dbs(&config, None, None);
    
    // Bug: This incorrectly creates a secondary DB for re-sync
    assert!(matches!(result, Ok(Either::Right(_))), 
        "Should detect existing data despite missing OverallCommitProgress");
}
```

## Notes

This issue specifically affects the fast sync bootstrapping path. The standard state sync path uses `get_pre_committed_version()` which reads from the current state rather than `OverallCommitProgress`, so it's not affected by this issue. The vulnerability is isolated to scenarios where fast sync mode is explicitly enabled and the specific crash timing occurs.

### Citations

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L103-106)
```rust
            ledger_batch.put::<DbMetadataSchema>(
                &DbMetadataKey::OverallCommitProgress,
                &DbMetadataValue::Version(version),
            )?;
```

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L360-365)
```rust
        ledger_metadata_batch
            .put::<DbMetadataSchema>(
                &DbMetadataKey::LedgerCommitProgress,
                &DbMetadataValue::Version(chunk.expect_last_version()),
            )
            .unwrap();
```

**File:** storage/aptosdb/src/state_store/mod.rs (L408-409)
```rust
    // We commit the overall commit progress at the last, and use it as the source of truth of the
    // commit progress.
```

**File:** storage/aptosdb/src/state_store/mod.rs (L417-420)
```rust
        if let Some(overall_commit_progress) = ledger_metadata_db
            .get_synced_version()
            .expect("DB read failed.")
        {
```

**File:** storage/aptosdb/src/state_store/mod.rs (L499-501)
```rust
        } else {
            info!("No overall commit progress was found!");
        }
```

**File:** storage/aptosdb/src/fast_sync_storage_wrapper.rs (L66-76)
```rust
        if config
            .state_sync
            .state_sync_driver
            .bootstrapping_mode
            .is_fast_sync()
            && (db_main
                .ledger_db
                .metadata_db()
                .get_synced_version()?
                .map_or(0, |v| v)
                == 0)
```

**File:** storage/aptosdb/src/ledger_db/ledger_metadata_db.rs (L76-78)
```rust
    pub(crate) fn get_synced_version(&self) -> Result<Option<Version>> {
        get_progress(&self.db, &DbMetadataKey::OverallCommitProgress)
    }
```
