# Audit Report

## Title
Gas Metering Bypass via Unmetered Framework Module Loading Through Dispatchable Native Functions

## Summary
The eager loader's `unmetered_get_function_definition()` function allows attackers to bypass gas metering by triggering module loading operations for framework modules (special addresses 0x0-0xf) through dispatchable native functions. This violates the fundamental invariant that all operations must respect gas limits and enables resource exhaustion attacks.

## Finding Description
The vulnerability exists in the interaction between three components:

1. **Eager Loader's Unmetered Function Resolution**: The `load_function_definition()` method in the eager loader calls `unmetered_get_function_definition()`, which performs module loading and verification without charging gas. [1](#0-0) 

2. **Special Address Gas Exemption**: The gas meter explicitly exempts modules at special addresses (0x0-0xf) from dependency gas charging, based on the assumption they are "system modules that should always be loaded." [2](#0-1) 

3. **Dispatchable Native Bypass for Special Addresses**: Dispatchable native functions (like `dispatchable_withdraw`) check if target modules are visited using `check_is_special_or_visited()`, which automatically passes for special addresses without verifying they're actually loaded. [3](#0-2) [4](#0-3) 

**Attack Flow:**

1. Attacker creates an entry function that does NOT import large framework modules in its dependency graph
2. The entry function calls a dispatchable native (e.g., `dispatchable_withdraw`, `dispatchable_deposit`) 
3. The dispatchable native dispatches to a function in a framework module at a special address that hasn't been loaded yet
4. The `check_is_special_or_visited()` check passes automatically for special addresses (line 103 returns Ok())
5. Only a flat dispatch fee (`DISPATCHABLE_FUNGIBLE_ASSET_DISPATCH_BASE`) is charged
6. The interpreter calls `load_function_definition()` to load the target function
7. This triggers `unmetered_get_eagerly_verified_module()` which loads the module and its entire transitive dependency closure
8. For special addresses, NO gas is charged for this loading operation (meter.rs line 70 condition)

The vulnerability allows loading and verification of framework modules—operations involving deserialization, bytecode verification, and linking—without paying gas proportional to that work.

## Impact Explanation
**Severity: High**

This vulnerability enables:

1. **Validator Node Slowdowns**: Attackers can force validators to perform expensive module loading/verification operations without adequate gas payment, consuming CPU resources disproportionate to gas charged.

2. **Gas Limit Bypass**: Attackers can consume computational resources beyond their gas budget by triggering multiple framework module loads through repeated dynamic dispatches.

3. **Invariant Violation**: Directly violates Invariant #9 ("Resource Limits: All operations must respect gas, storage, and computational limits") and Invariant #3 ("Move VM Safety: Bytecode execution must respect gas limits").

The impact qualifies as **High Severity** per the Aptos bug bounty criteria as it enables "Validator node slowdowns" and "Significant protocol violations."

## Likelihood Explanation
**Likelihood: High**

The attack is highly likely because:

1. **Easy to Execute**: Any user can call entry functions that use dispatchable natives (these are part of the standard framework for fungible assets)
2. **No Special Permissions Required**: Attack requires only normal transaction submission privileges
3. **Multiple Attack Vectors**: Multiple dispatchable natives exist (`dispatchable_withdraw`, `dispatchable_deposit`, `dispatchable_derived_balance`, `dispatchable_derived_supply`)
4. **Repeatable**: Can be executed in loops within a single transaction or across multiple transactions
5. **Large Framework**: Aptos framework contains many modules (stake, governance, delegation_pool, vesting, multisig_account, etc.) that could be selectively unloaded and reloaded

## Recommendation
Implement proper gas charging for all module loading operations, including those for special addresses. The exemption should only apply to modules that are guaranteed to be pre-loaded at genesis.

**Proposed Fix:**

1. **Track Pre-loaded Modules**: Maintain a set of modules that were loaded during genesis/blockchain initialization
2. **Charge for On-Demand Loading**: Only exempt pre-loaded modules from gas charging; charge for any module that needs on-demand loading
3. **Add Gas Charging to Dispatchable Natives**: When dispatchable natives target special address modules, charge gas proportional to the module loading cost if the module isn't already cached

Alternative approach - validate that target modules are actually loaded before allowing dynamic dispatch:

```rust
// In dispatchable_fungible_asset.rs
pub(crate) fn native_dispatch(
    context: &mut SafeNativeContext,
    ty_args: &[Type],
    mut arguments: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    let (module_name, func_name) = extract_function_info(&mut arguments)?;

    // For special addresses, verify module is actually loaded AND charge for loading cost
    if module_name.address().is_special() {
        // Charge gas for potential module loading even for special addresses
        context.charge_dependency_loading(module_name.address(), module_name.name())?;
    } else {
        // Existing check for non-special addresses
        context.traversal_context()
            .legacy_check_visited(module_name.address(), module_name.name())
            .map_err(|_| SafeNativeError::Abort { abort_code: 4 })?;
    }

    context.charge(DISPATCHABLE_FUNGIBLE_ASSET_DISPATCH_BASE)?;
    
    Err(SafeNativeError::FunctionDispatch {
        module_name,
        func_name,
        ty_args: ty_args.to_vec(),
        args: arguments.into_iter().collect(),
    })
}
```

## Proof of Concept

```move
// PoC Move module demonstrating the gas bypass
module attacker::gas_bypass_poc {
    use aptos_framework::fungible_asset;
    use aptos_framework::function_info;
    
    // Entry function that doesn't import expensive framework modules
    entry fun exploit_gas_bypass(user: &signer) {
        // Create function_info pointing to an unloaded framework module
        // For example, target a complex function in stake, governance, or delegation_pool
        let target_module = @aptos_framework;
        let target_function = b"some_complex_function";
        
        // Use dispatchable native to trigger dynamic dispatch
        // This will load the target module without proper gas charging
        // The check_is_special_or_visited passes for @aptos_framework (0x1)
        // Only DISPATCHABLE_FUNGIBLE_ASSET_DISPATCH_BASE is charged
        // But the actual module loading/verification is NOT charged
        
        // Repeat this for multiple different framework modules to maximize resource consumption
        // Each iteration forces loading of a different unloaded module
        
        // Attack can force loading of:
        // - stake.move (large module with validator logic)
        // - aptos_governance.move (governance with complex voting)
        // - delegation_pool.move (complex pool management)
        // - vesting.move (vesting schedules)
        // All without paying proportional gas
    }
}
```

**Exploitation Steps:**

1. Deploy the above module
2. Call `exploit_gas_bypass` entry function
3. Within the entry function, use dispatchable natives to dynamically dispatch to functions in large framework modules that weren't in the initial dependency graph
4. Observer: gas charged ≪ actual CPU resources consumed for module loading/verification
5. Repeat with different target modules to amplify the attack

### Citations

**File:** third_party/move/move-vm/runtime/src/storage/loader/eager.rs (L184-203)
```rust
    fn load_function_definition(
        &self,
        _gas_meter: &mut impl DependencyGasMeter,
        _traversal_context: &mut TraversalContext,
        module_id: &ModuleId,
        function_name: &IdentStr,
    ) -> VMResult<(Arc<Module>, Arc<Function>)> {
        self.unmetered_get_function_definition(module_id, function_name)
            .map_err(|err| {
                // Note: legacy loader implementation used this error, so we need to remap.
                PartialVMError::new(StatusCode::FUNCTION_RESOLUTION_FAILURE)
                    .with_message(format!(
                        "Module or function do not exist for {}::{}::{}",
                        module_id.address(),
                        module_id.name(),
                        function_name
                    ))
                    .finish(err.location().clone())
            })
    }
```

**File:** aptos-move/aptos-gas-meter/src/meter.rs (L64-76)
```rust
        // Modules under special addresses are considered system modules that should always
        // be loaded, and are therefore excluded from gas charging.
        //
        // TODO: 0xA550C18 is a legacy system address we used, but it is currently not covered by
        //       `.is_special()`. We should double check if this address still needs special
        //       treatment.
        if self.feature_version() >= 15 && !addr.is_special() {
            self.algebra
                .charge_execution(DEPENDENCY_PER_MODULE + DEPENDENCY_PER_BYTE * size)?;
            self.algebra.count_dependency(size)?;
        }
        Ok(())
    }
```

**File:** aptos-move/framework/src/natives/dispatchable_fungible_asset.rs (L29-46)
```rust
    // Check if the module is already properly charged in this transaction.
    let check_visited = |a, n| {
        let special_addresses_considered_visited =
            context.get_feature_flags().is_account_abstraction_enabled()
                || context
                    .get_feature_flags()
                    .is_derivable_account_abstraction_enabled();
        if special_addresses_considered_visited {
            context
                .traversal_context()
                .check_is_special_or_visited(a, n)
        } else {
            context.traversal_context().legacy_check_visited(a, n)
        }
    };
    check_visited(module_name.address(), module_name.name())
        .map_err(|_| SafeNativeError::Abort { abort_code: 4 })?;

```

**File:** third_party/move/move-vm/runtime/src/module_traversal.rs (L98-108)
```rust
    pub fn check_is_special_or_visited(
        &self,
        addr: &AccountAddress,
        name: &IdentStr,
    ) -> PartialVMResult<()> {
        if addr.is_special() {
            return Ok(());
        }

        self.check_visited_impl(addr, name)
    }
```
