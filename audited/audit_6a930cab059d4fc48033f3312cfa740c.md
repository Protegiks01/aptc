# Audit Report

## Title
Plaintext Storage of Validator Private Keys in Genesis Identity Files Enables Complete Validator Compromise via Filesystem Access

## Summary
The `PrivateIdentity` struct in `crates/aptos-genesis/src/keys.rs` serializes all validator private keys (account, consensus, and network keys) to plaintext YAML files without encryption or authentication. Files are written with default filesystem permissions, allowing any attacker with filesystem access to extract private keys and completely compromise validator nodes.

## Finding Description

The `PrivateIdentity` struct contains four critical private keys that control validator identity and operations: [1](#0-0) 

These keys are serialized using Serde's standard derive macros with no encryption layer: [2](#0-1) 

The `SerializeKey` derive macro converts private keys to hex-encoded strings for human-readable formats like YAML: [3](#0-2) 

The genesis builder writes these keys to disk in plaintext YAML format without applying encryption or setting restrictive file permissions: [4](#0-3) [5](#0-4) 

The `write_yaml` function uses standard `File::create()` which respects the system umask, typically resulting in world-readable or group-readable file permissions (0644 or 0664), rather than owner-only access (0600).

**Attack Path:**
1. Attacker gains filesystem access via malware, compromised user account, stolen backups, misconfigured cloud storage, or supply chain attack
2. Attacker reads `private-identity.yaml` from validator data directory
3. Attacker extracts hex-encoded private keys from plaintext YAML
4. Attacker uses `account_private_key` to sign transactions and steal validator funds
5. Attacker uses `consensus_private_key` to participate in consensus, creating equivocations and safety violations
6. Attacker uses network keys to impersonate validator and perform man-in-the-middle attacks

The codebase contains a secure alternative (`save_to_file_confidential`) that sets mode 0600, but it is not used for genesis identity files: [6](#0-5) 

## Impact Explanation

This vulnerability achieves **CRITICAL** severity under multiple Aptos bug bounty categories:

1. **Loss of Funds (theft or minting)**: The `account_private_key` allows the attacker to sign arbitrary transactions as the validator, enabling direct theft of staked funds and transaction fees.

2. **Consensus/Safety violations**: The `consensus_private_key` (BLS12-381) allows the attacker to sign consensus messages, creating equivocations (double-voting) that violate AptosBFT safety assumptions and could cause chain splits.

3. **Network Security Compromise**: The `validator_network_private_key` and `full_node_network_private_key` enable the attacker to impersonate the validator, intercept consensus messages, and perform man-in-the-middle attacks on the P2P network.

This breaks the **Consensus Safety** invariant (AptosBFT must prevent double-spending and chain splits under < 1/3 Byzantine) and the **Cryptographic Correctness** invariant (BLS signatures must be secure).

## Likelihood Explanation

**HIGH LIKELIHOOD** - This vulnerability affects every validator node that uses the genesis builder for initialization. The attack requires only filesystem-level access, which can be obtained through:

- **Malware/Ransomware**: Standard malware with file system read access
- **Compromised User Accounts**: SSH key theft, weak passwords, or social engineering
- **Backup Breaches**: Unencrypted backups stored on cloud services or removable media
- **Supply Chain Attacks**: Compromised dependencies or build tools
- **Insider Threats**: System administrators with server access
- **Misconfigured Permissions**: Default umask settings making files world-readable
- **Container Escapes**: In containerized deployments with shared volumes

The files are created during initial validator setup and persist indefinitely. Unlike memory-based attacks, the attacker has unlimited time to locate and extract the plaintext keys.

## Recommendation

**Immediate Fix**: Apply encryption and restrictive file permissions to all validator private key files.

**Implementation**:

1. **Add encrypted serialization** using a key derivation function (KDF) from a user-provided password or hardware security module (HSM):

```rust
// In builder.rs, replace write_yaml for sensitive files
fn write_yaml_confidential<T: Serialize>(path: &Path, object: &T) -> anyhow::Result<()> {
    let yaml = serde_yaml::to_string(object)?;
    
    // Set restrictive permissions (owner read/write only)
    let mut file = OpenOptions::new()
        .write(true)
        .create(true)
        .truncate(true)
        .mode(0o600)  // Unix: owner read/write only
        .open(path)?;
    
    file.write_all(yaml.as_bytes())?;
    Ok(())
}
```

2. **Alternative: Use SecureBackend storage** instead of plaintext files: [7](#0-6) 

Migrate genesis identity storage to use `SecureBackend::OnDiskStorage` with encryption or `SecureBackend::Vault` for production deployments.

3. **Defense in depth**: Add file permission checks on startup to detect overly permissive files and refuse to start if private key files are world-readable.

## Proof of Concept

```rust
// File: poc_plaintext_keys.rs
use std::fs;
use std::path::PathBuf;
use aptos_genesis::builder::Builder;
use aptos_framework::ReleaseBundle;
use tempfile::TempDir;

fn main() -> anyhow::Result<()> {
    // Setup: Create a test validator using genesis builder
    let temp_dir = TempDir::new()?;
    let framework = ReleaseBundle::default();
    let builder = Builder::new(temp_dir.path(), framework)?;
    
    // Build genesis (creates private-identity.yaml)
    let mut rng = rand::thread_rng();
    let (_, _, _, validators) = builder.build(&mut rng)?;
    
    let validator_dir = &validators[0].dir;
    let private_identity_path = validator_dir.join("private-identity.yaml");
    
    // ATTACK: Read plaintext keys from filesystem
    println!("[ATTACKER] Reading private-identity.yaml...");
    let yaml_content = fs::read_to_string(&private_identity_path)?;
    
    println!("[ATTACKER] Successfully extracted plaintext private keys:");
    println!("{}", yaml_content);
    
    // Demonstrate key extraction
    let private_identity: aptos_genesis::keys::PrivateIdentity = 
        serde_yaml::from_str(&yaml_content)?;
    
    println!("\n[ATTACKER] Extracted account_private_key:");
    println!("  Can now sign transactions as validator");
    println!("  Can steal all staked funds");
    
    println!("\n[ATTACKER] Extracted consensus_private_key:");
    println!("  Can participate in consensus");
    println!("  Can create equivocations and safety violations");
    
    println!("\n[ATTACKER] Extracted network keys:");
    println!("  Can impersonate validator on P2P network");
    println!("  Can perform MITM attacks");
    
    // Check file permissions (Unix only)
    #[cfg(unix)]
    {
        use std::os::unix::fs::PermissionsExt;
        let metadata = fs::metadata(&private_identity_path)?;
        let permissions = metadata.permissions();
        println!("\n[VULNERABILITY] File permissions: {:o}", permissions.mode() & 0o777);
        println!("Expected: 0600 (owner read/write only)");
        println!("Actual: Likely 0644 (world-readable) or 0664 (group-readable)");
    }
    
    Ok(())
}
```

**Expected Output:**
```
[ATTACKER] Reading private-identity.yaml...
[ATTACKER] Successfully extracted plaintext private keys:
---
account_address: "0x..."
account_private_key: "0x..." 
consensus_private_key: "0x..."
validator_network_private_key: "0x..."
full_node_network_private_key: "0x..."

[ATTACKER] Extracted account_private_key:
  Can now sign transactions as validator
  Can steal all staked funds

[ATTACKER] Extracted consensus_private_key:
  Can participate in consensus
  Can create equivocations and safety violations

[ATTACKER] Extracted network keys:
  Can impersonate validator on P2P network
  Can perform MITM attacks

[VULNERABILITY] File permissions: 644
Expected: 0600 (owner read/write only)
Actual: Likely 0644 (world-readable) or 0664 (group-readable)
```

## Notes

This vulnerability is particularly severe because:

1. **Complete Validator Compromise**: All four private keys are exposed in a single file, enabling total control over the validator node.

2. **Persistent Exposure**: Keys remain on disk indefinitely, providing attackers with unlimited time to locate and extract them.

3. **No Audit Trail**: File system reads leave minimal traces, making detection difficult.

4. **Wide Attack Surface**: Any vector granting filesystem access (malware, backups, misconfigurations) enables exploitation.

5. **Production Impact**: While this code appears in genesis/builder modules, it is also used by the aptos-release-builder for validation workflows, suggesting production usage.

The existence of `save_to_file_confidential()` with mode 0600 indicates awareness of the security requirement, but it was not applied to these critical identity filesâ€”a clear implementation oversight.

### Citations

**File:** crates/aptos-genesis/src/keys.rs (L14-22)
```rust
/// Type for serializing private keys file
#[derive(Deserialize, Serialize)]
pub struct PrivateIdentity {
    pub account_address: AccountAddress,
    pub account_private_key: Ed25519PrivateKey,
    pub consensus_private_key: bls12381::PrivateKey,
    pub full_node_network_private_key: x25519::PrivateKey,
    pub validator_network_private_key: x25519::PrivateKey,
}
```

**File:** crates/aptos-crypto-derive/src/lib.rs (L185-211)
```rust
#[proc_macro_derive(SerializeKey)]
pub fn serialize_key(source: TokenStream) -> TokenStream {
    let ast: DeriveInput = syn::parse(source).expect("Incorrect macro input");
    let name = &ast.ident;
    let name_string = find_key_name(&ast, name.to_string());
    quote! {
        impl ::serde::Serialize for #name {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: ::serde::Serializer,
            {
                if serializer.is_human_readable() {
                    self.to_encoded_string()
                        .map_err(<S::Error as ::serde::ser::Error>::custom)
                        .and_then(|str| serializer.serialize_str(&str[..]))
                } else {
                    // See comment in deserialize_key.
                    serializer.serialize_newtype_struct(
                        #name_string,
                        serde_bytes::Bytes::new(&ValidCryptoMaterial::to_bytes(self).as_slice()),
                    )
                }
            }
        }
    }
    .into()
}
```

**File:** crates/aptos-genesis/src/builder.rs (L145-148)
```rust
            write_yaml(val_identity_file.as_path(), &validator_identity)?;
            write_yaml(vfn_identity_file.as_path(), &vfn_identity)?;
            write_yaml(private_identity_file.as_path(), &private_identity)?;
            write_yaml(public_identity_file.as_path(), &public_identity)?;
```

**File:** crates/aptos-genesis/src/builder.rs (L418-421)
```rust
fn write_yaml<T: Serialize>(path: &Path, object: &T) -> anyhow::Result<()> {
    File::create(path)?.write_all(serde_yaml::to_string(object)?.as_bytes())?;
    Ok(())
}
```

**File:** crates/aptos/src/common/types.rs (L1083-1089)
```rust
    /// Save to the `output_file` with restricted permissions (mode 0600)
    pub fn save_to_file_confidential(&self, name: &str, bytes: &[u8]) -> CliTypedResult<()> {
        let mut opts = OpenOptions::new();
        #[cfg(unix)]
        opts.mode(0o600);
        write_to_file_with_opts(self.output_file.as_path(), name, bytes, &mut opts)
    }
```

**File:** config/src/config/identity_config.rs (L93-99)
```rust
    pub fn from_storage(key_name: String, peer_id_name: String, backend: SecureBackend) -> Self {
        Identity::FromStorage(IdentityFromStorage {
            backend,
            key_name,
            peer_id_name,
        })
    }
```
