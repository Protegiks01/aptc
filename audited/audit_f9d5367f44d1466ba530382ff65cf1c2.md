# Audit Report

## Title
State Value-Proof Integrity Validation Gap Enabling Undetected Database Inconsistency

## Summary
The `get_state_value_with_proof_by_version_ext` method returns state values and Merkle proofs without validating that the value's hash matches the hash stored in the Merkle tree leaf node. This allows database inconsistencies between the state KV database and Merkle tree to propagate undetected, potentially causing consensus divergence. The mock implementation exacerbates this by returning empty proofs, preventing tests from catching such integrity violations.

## Finding Description

The vulnerability exists in the state value retrieval logic that combines data from two separate databases: the state KV database (storing actual values) and the state Merkle database (storing cryptographic proofs). [1](#0-0) 

When retrieving a state value with proof, the code:
1. Fetches `leaf_data` from the Merkle tree containing `(val_hash, (key, ver))` where `val_hash` is the cryptographic hash of the value stored in the tree
2. Discards `val_hash` (indicated by underscore prefix `_val_hash`)
3. Fetches the actual state value from the KV database using only the key and version
4. Returns the KV database value with the Merkle tree proof **without verifying they match**

This breaks the **State Consistency** invariant: "State transitions must be atomic and verifiable via Merkle proofs." The returned proof cryptographically commits to one value hash, but the actual value returned may hash to something completely different.

The mock implementation compounds this issue: [2](#0-1) 

The mock returns empty proofs (`SparseMerkleProofExt::new(None, vec![])`) alongside actual state values, meaning tests using this mock would never detect if production code returns mismatched value-proof pairs.

**How Database Inconsistency Can Occur:**

1. **Asynchronous Commit Race**: The state KV database is committed synchronously while the Merkle tree is committed asynchronously via `StateMerkleBatchCommitter` running in a background thread. A carefully timed crash or bug could leave them inconsistent. [3](#0-2) 

2. **Insufficient Consistency Checks**: The `check_usage_consistency` only validates leaf counts match, not that value hashes correspond to actual values: [4](#0-3) 

3. **Crash Recovery Limitations**: While `sync_commit_progress` truncates databases to a consistent version, it doesn't validate value-level integrity: [5](#0-4) 

**Impact on Consensus:**

Most state view implementations don't verify proofs: [6](#0-5) 

When proof verification does occur, it happens AFTER returning the mismatched data: [7](#0-6) 

This means:
- **Consensus Divergence**: Different validators with different database corruption states could execute transactions against inconsistent state, producing different state roots
- **Silent Data Corruption**: APIs and state sync could serve incorrect values with "valid" proofs that don't actually match
- **Byzantine Behavior**: A validator with corrupted state would appear Byzantine to peers when state roots don't match

## Impact Explanation

This qualifies as **Critical Severity** per Aptos bug bounty criteria for **Consensus/Safety violations**:

1. **Breaks Deterministic Execution**: Different validators could produce different state roots for identical blocks if their databases are inconsistent
2. **Undetectable in Testing**: The mock prevents integration tests from catching this gap
3. **Propagates Silently**: Most code paths don't verify proofs, allowing corruption to spread
4. **Could Require Hard Fork**: If validators diverge on state due to undetected inconsistency, manual intervention would be needed

While the vulnerability requires an existing database inconsistency (from bugs, crashes, or corruption), the lack of validation at this critical junction means such inconsistencies would propagate silently rather than being caught and rejected immediately.

## Likelihood Explanation

**Medium-to-High Likelihood** that database inconsistency occurs:

1. **Asynchronous Architecture**: KV and Merkle databases commit at different times via separate mechanisms
2. **Complex Crash Recovery**: Multiple progress markers and truncation logic create windows for inconsistency
3. **No Value-Level Validation**: Consistency checks only verify counts and versions, not value integrity
4. **Historical Evidence**: TODO comment suggests awareness of proof verification issues

Once inconsistency exists, **100% Likelihood** it propagates undetected through this code path.

## Recommendation

Add value hash validation in `get_state_value_with_proof_by_version_ext`:

```rust
fn get_state_value_with_proof_by_version_ext(
    &self,
    key_hash: &HashValue,
    version: Version,
    root_depth: usize,
    use_hot_state: bool,
) -> Result<(Option<StateValue>, SparseMerkleProofExt)> {
    let db = if use_hot_state {
        // ... (selection logic)
    } else {
        &self.state_merkle_db
    };
    let (leaf_data, proof) = db.get_with_proof_ext(key_hash, version, root_depth)?;
    Ok((
        match leaf_data {
            Some((val_hash, (key, ver))) => {
                let value = self.expect_value_by_version(&key, ver)?;
                // VALIDATE: Ensure value hash matches Merkle tree leaf
                let actual_hash = value.hash();
                ensure!(
                    actual_hash == val_hash,
                    "State value hash mismatch: expected {:?}, got {:?} for key {:?} at version {}",
                    val_hash,
                    actual_hash,
                    key,
                    ver
                );
                Some(value)
            },
            None => None,
        },
        proof,
    ))
}
```

Additionally, update the mock to fail fast on any usage that would hide such issues:

```rust
fn get_state_proof_by_version_ext(
    &self,
    _key_hash: &HashValue,
    _version: Version,
    _root_depth: usize,
    _use_hot_state: bool,
) -> Result<SparseMerkleProofExt> {
    // Mock should not be used for proof validation tests
    Err(AptosDbError::Other(
        "Mock does not support proof generation - use real DB for proof validation tests".to_string()
    ))
}
```

## Proof of Concept

To demonstrate this vulnerability, one would need to:

1. Create a test environment with real AptosDB (not mock)
2. Commit a state value to both KV and Merkle databases
3. Manually corrupt the KV database to have a different value for the same key/version
4. Call `get_state_value_with_proof_by_version_ext`
5. Observe it returns the corrupted value with a proof that doesn't match
6. Verify the proof verification fails when called with the returned value

```rust
#[test]
fn test_value_proof_mismatch_detection() {
    // Setup AptosDB with real state store
    let db = create_test_aptosdb();
    
    // Commit initial state
    let key = StateKey::raw(b"test_key");
    let value1 = StateValue::from(vec![1, 2, 3]);
    commit_state_update(&db, &key, &value1, 100);
    
    // Simulate database inconsistency by writing different value to KV DB
    let value2 = StateValue::from(vec![4, 5, 6]);
    corrupt_kv_database(&db, &key, &value2, 100);
    
    // Retrieve value with proof
    let (returned_value, proof) = db
        .get_state_value_with_proof_by_version(&key, 100)
        .unwrap();
    
    // The returned value is value2 (from corrupted KV DB)
    assert_eq!(returned_value.unwrap(), value2);
    
    // But the proof is for value1 (from Merkle tree)
    // Proof verification MUST fail
    let root_hash = db.get_state_checkpoint_hash(100).unwrap();
    let verify_result = proof.verify(
        root_hash,
        key.hash(),
        returned_value.as_ref(),
    );
    
    // This should fail, proving the mismatch exists
    assert!(verify_result.is_err(), 
        "Proof verification should fail for mismatched value-proof pair");
}
```

**Notes:**

This vulnerability represents a critical gap in state integrity validation that directly answers the security question posed. While it requires database inconsistency to manifest, the lack of validation at the retrieval point means such inconsistencies would propagate undetected, potentially causing consensus divergence. The mock implementation prevents tests from catching this gap, making it a particularly insidious architectural weakness that could compromise blockchain safety guarantees under adverse conditions (software bugs, crashes, or corruption).

### Citations

**File:** storage/aptosdb/src/state_store/mod.rs (L228-236)
```rust
        let (leaf_data, proof) = db.get_with_proof_ext(key_hash, version, root_depth)?;
        Ok((
            match leaf_data {
                Some((_val_hash, (key, ver))) => Some(self.expect_value_by_version(&key, ver)?),
                None => None,
            },
            proof,
        ))
    }
```

**File:** storage/aptosdb/src/state_store/mod.rs (L410-502)
```rust
    pub fn sync_commit_progress(
        ledger_db: Arc<LedgerDb>,
        state_kv_db: Arc<StateKvDb>,
        state_merkle_db: Arc<StateMerkleDb>,
        crash_if_difference_is_too_large: bool,
    ) {
        let ledger_metadata_db = ledger_db.metadata_db();
        if let Some(overall_commit_progress) = ledger_metadata_db
            .get_synced_version()
            .expect("DB read failed.")
        {
            info!(
                overall_commit_progress = overall_commit_progress,
                "Start syncing databases..."
            );
            let ledger_commit_progress = ledger_metadata_db
                .get_ledger_commit_progress()
                .expect("Failed to read ledger commit progress.");
            assert_ge!(ledger_commit_progress, overall_commit_progress);

            let state_kv_commit_progress = state_kv_db
                .metadata_db()
                .get::<DbMetadataSchema>(&DbMetadataKey::StateKvCommitProgress)
                .expect("Failed to read state K/V commit progress.")
                .expect("State K/V commit progress cannot be None.")
                .expect_version();
            assert_ge!(state_kv_commit_progress, overall_commit_progress);

            // LedgerCommitProgress was not guaranteed to commit after all ledger changes finish,
            // have to attempt truncating every column family.
            info!(
                ledger_commit_progress = ledger_commit_progress,
                "Attempt ledger truncation...",
            );
            let difference = ledger_commit_progress - overall_commit_progress;
            if crash_if_difference_is_too_large {
                assert_le!(difference, MAX_COMMIT_PROGRESS_DIFFERENCE);
            }
            truncate_ledger_db(ledger_db.clone(), overall_commit_progress)
                .expect("Failed to truncate ledger db.");

            // State K/V commit progress isn't (can't be) written atomically with the data,
            // because there are shards, so we have to attempt truncation anyway.
            info!(
                state_kv_commit_progress = state_kv_commit_progress,
                "Start state KV truncation..."
            );
            let difference = state_kv_commit_progress - overall_commit_progress;
            if crash_if_difference_is_too_large {
                assert_le!(difference, MAX_COMMIT_PROGRESS_DIFFERENCE);
            }
            truncate_state_kv_db(
                &state_kv_db,
                state_kv_commit_progress,
                overall_commit_progress,
                std::cmp::max(difference as usize, 1), /* batch_size */
            )
            .expect("Failed to truncate state K/V db.");

            let state_merkle_max_version = get_max_version_in_state_merkle_db(&state_merkle_db)
                .expect("Failed to get state merkle max version.")
                .expect("State merkle max version cannot be None.");
            if state_merkle_max_version > overall_commit_progress {
                let difference = state_merkle_max_version - overall_commit_progress;
                if crash_if_difference_is_too_large {
                    assert_le!(difference, MAX_COMMIT_PROGRESS_DIFFERENCE);
                }
            }
            let state_merkle_target_version = find_tree_root_at_or_before(
                ledger_metadata_db,
                &state_merkle_db,
                overall_commit_progress,
            )
            .expect("DB read failed.")
            .unwrap_or_else(|| {
                panic!(
                    "Could not find a valid root before or at version {}, maybe it was pruned?",
                    overall_commit_progress
                )
            });
            if state_merkle_target_version < state_merkle_max_version {
                info!(
                    state_merkle_max_version = state_merkle_max_version,
                    target_version = state_merkle_target_version,
                    "Start state merkle truncation..."
                );
                truncate_state_merkle_db(&state_merkle_db, state_merkle_target_version)
                    .expect("Failed to truncate state merkle db.");
            }
        } else {
            info!("No overall commit progress was found!");
        }
    }
```

**File:** storage/storage-interface/src/mock.rs (L26-49)
```rust
    fn get_state_proof_by_version_ext(
        &self,
        _key_hash: &HashValue,
        _version: Version,
        _root_depth: usize,
        _use_hot_state: bool,
    ) -> Result<SparseMerkleProofExt> {
        Ok(SparseMerkleProofExt::new(None, vec![]))
    }

    fn get_state_value_by_version(
        &self,
        state_key: &StateKey,
        _: Version,
    ) -> Result<Option<StateValue>> {
        match state_key.inner() {
            StateKeyInner::AccessPath(..) => Ok(None),
            StateKeyInner::Raw(raw_key) => Ok(Some(StateValue::from(raw_key.to_owned()))),
            _ => Err(AptosDbError::Other(format!(
                "Not supported state key type {:?}",
                state_key
            ))),
        }
    }
```

**File:** storage/aptosdb/src/state_store/state_merkle_batch_committer.rs (L52-81)
```rust
    pub fn run(self) {
        while let Ok(msg) = self.state_merkle_batch_receiver.recv() {
            let _timer = OTHER_TIMERS_SECONDS.timer_with(&["batch_committer_work"]);
            match msg {
                CommitMessage::Data(StateMerkleCommit {
                    snapshot,
                    hot_batch,
                    cold_batch,
                }) => {
                    let base_version = self.persisted_state.get_state_summary().version();
                    let current_version = snapshot
                        .version()
                        .expect("Current version should not be None");

                    // commit jellyfish merkle nodes
                    let _timer =
                        OTHER_TIMERS_SECONDS.timer_with(&["commit_jellyfish_merkle_nodes"]);
                    if let Some(hot_state_merkle_batch) = hot_batch {
                        self.commit(
                            self.state_db
                                .hot_state_merkle_db
                                .as_ref()
                                .expect("Hot state merkle db must exist."),
                            current_version,
                            hot_state_merkle_batch,
                        )
                        .expect("Hot state merkle nodes commit failed.");
                    }
                    self.commit(&self.state_db.state_merkle_db, current_version, cold_batch)
                        .expect("State merkle nodes commit failed.");
```

**File:** storage/aptosdb/src/state_store/state_merkle_batch_committer.rs (L136-168)
```rust
    fn check_usage_consistency(&self, state: &State) -> Result<()> {
        let version = state
            .version()
            .ok_or_else(|| anyhow!("Committing without version."))?;

        let usage_from_ledger_db = self.state_db.ledger_db.metadata_db().get_usage(version)?;
        let leaf_count_from_jmt = self
            .state_db
            .state_merkle_db
            .metadata_db()
            .get::<JellyfishMerkleNodeSchema>(&NodeKey::new_empty_path(version))?
            .ok_or_else(|| anyhow!("Root node missing at version {}", version))?
            .leaf_count();

        ensure!(
            usage_from_ledger_db.items() == leaf_count_from_jmt,
            "State item count inconsistent, {} from ledger db and {} from state tree.",
            usage_from_ledger_db.items(),
            leaf_count_from_jmt,
        );

        let usage_from_in_mem_state = state.usage();
        if !usage_from_in_mem_state.is_untracked() {
            ensure!(
                usage_from_in_mem_state == usage_from_ledger_db,
                "State storage usage info inconsistent. from smt: {:?}, from ledger_db: {:?}",
                usage_from_in_mem_state,
                usage_from_ledger_db,
            );
        }

        Ok(())
    }
```

**File:** storage/storage-interface/src/state_store/state_view/db_state_view.rs (L27-46)
```rust
    fn get(&self, key: &StateKey) -> StateViewResult<Option<(Version, StateValue)>> {
        if let Some(version) = self.version {
            if let Some(root_hash) = self.maybe_verify_against_state_root_hash {
                // TODO(aldenhu): sample-verify proof inside DB
                // DB doesn't support returning proofs for buffered state, so only optionally
                // verify proof.
                // TODO: support returning state proof for buffered state.
                if let Ok((value, proof)) =
                    self.db.get_state_value_with_proof_by_version(key, version)
                {
                    proof.verify(root_hash, *key.crypto_hash_ref(), value.as_ref())?;
                }
            }
            Ok(self
                .db
                .get_state_value_with_version_by_version(key, version)?)
        } else {
            Ok(None)
        }
    }
```

**File:** storage/storage-interface/src/state_store/state_view/db_state_view.rs (L82-91)
```rust
    fn latest_state_checkpoint_view(&self) -> StateViewResult<DbStateView> {
        Ok(DbStateView {
            db: self.clone(),
            version: self
                .get_latest_state_checkpoint_version()
                .map_err(Into::<StateViewError>::into)?,
            maybe_verify_against_state_root_hash: None,
        })
    }
}
```
