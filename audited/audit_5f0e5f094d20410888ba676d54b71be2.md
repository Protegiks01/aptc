# Audit Report

## Title
Incomplete Implementation of OptQuorumStorePayload V2 Creates Latent Transaction Filter Bypass

## Summary
The `get_inline_transactions()` helper function returns an empty vector for `OptQuorumStorePayload::V2` payloads, causing `check_denied_inline_transactions()` to skip transaction filtering via early return. However, V2 is currently blocked from being accepted by the network, making this a latent vulnerability rather than an actively exploitable issue.

## Finding Description

The security question asks whether a proposer can craft payloads that bypass transaction filtering. After thorough investigation, I found that:

1. **Current State - V2 is Blocked:**
The `OptQuorumStorePayload::V2` variant is explicitly prevented from being accepted at the verification stage: [1](#0-0) 

This bail statement prevents any V2 payload from passing validation, making the vulnerability non-exploitable in the current codebase.

2. **The Latent Bug:**
If V2 were enabled, the `get_inline_transactions()` function has incomplete handling: [2](#0-1) 

This returns an empty vector for V2, which triggers an early return in the filter check: [3](#0-2) 

3. **V2 Structure Contains Inline Transactions:**
The `OptQuorumStorePayloadV1` struct (used by both V1 and V2) contains an `inline_batches` field that holds actual transactions: [4](#0-3) 

4. **V1 Properly Extracts Inline Transactions:** [5](#0-4) 

5. **Additional Blocks:**
V2 is also blocked in other verification paths: [6](#0-5) 

And V2 has no handling in `get_transactions()`, which would hit `unreachable!()`: [7](#0-6) 

## Impact Explanation

**Current Impact: None** - The vulnerability is not exploitable because V2 payloads are rejected during verification.

**Potential Future Impact (if V2 is enabled without fixing this bug): High Severity**
- Transaction filtering bypass would allow proposers to include transactions that governance has blocked
- Breaks the transaction validation invariant
- Could enable spam, malicious transactions, or governance rule violations
- Qualifies as "Significant protocol violation" under High Severity criteria

## Likelihood Explanation

**Current Likelihood: Zero** - V2 is explicitly blocked from acceptance.

**Future Likelihood (if V2 is enabled): High** - The error message "OptQSPayload V2 is not expected" suggests developers view this as a temporary placeholder. When enabling V2, developers would need to:
1. Remove verification blocks
2. Add V2 handling to `get_transactions()`
3. Fix `get_inline_transactions()` to properly extract V2 inline transactions

There's a risk they might forget step 3, as the error log doesn't clearly indicate this is a security-critical fix.

## Recommendation

Before enabling OptQuorumStorePayload V2, update `get_inline_transactions()` to properly extract inline transactions from V2 payloads:

```rust
Payload::OptQuorumStore(OptQuorumStorePayload::V2(p)) => p.inline_batches().transactions(),
```

This should be done alongside:
- Removing the V2 verification guards
- Adding complete V2 handling in `get_transactions()`
- Adding test coverage for V2 with denied transaction filtering

## Proof of Concept

**Cannot provide working PoC** - Any attempt to create a V2 payload would be rejected at verification: [8](#0-7) 

A PoC can only be created after V2 is enabled, at which point this would become an actively exploitable vulnerability if not fixed.

---

## Notes

**Important Context:**
This finding represents a **code quality issue and latent vulnerability**, not a currently exploitable bug. V2 is comprehensively blocked throughout the codebase, preventing exploitation. However, the incomplete implementation creates technical debt that could become a serious vulnerability when V2 support is added.

The existing test coverage does not include OptQuorumStore payloads with denied transaction filtering: [9](#0-8) 

When V2 is enabled, comprehensive testing should be added to verify that inline transactions in V2 payloads are properly filtered.

### Citations

**File:** consensus/consensus-types/src/common.rs (L609-625)
```rust
            (true, Payload::OptQuorumStore(OptQuorumStorePayload::V2(p))) => {
                if true {
                    bail!("OptQuorumStorePayload::V2 cannot be accepted yet");
                }
                #[allow(unreachable_code)]
                {
                    let proof_with_data = p.proof_with_data();
                    Self::verify_with_cache(&proof_with_data.batch_summary, verifier, proof_cache)?;
                    Self::verify_inline_batches(
                        p.inline_batches()
                            .iter()
                            .map(|batch| (batch.info(), batch.transactions())),
                    )?;
                    Self::verify_opt_batches(verifier, p.opt_batches())?;
                    Ok(())
                }
            },
```

**File:** consensus/src/payload_manager/quorum_store_payload_manager.rs (L318-322)
```rust
        // Get the inline transactions for the block proposal
        let inline_transactions = get_inline_transactions(block);
        if inline_transactions.is_empty() {
            return Ok(());
        }
```

**File:** consensus/src/payload_manager/quorum_store_payload_manager.rs (L542-548)
```rust
            _ => unreachable!(
                "Wrong payload {} epoch {}, round {}, id {}",
                payload,
                block.block_data().epoch(),
                block.block_data().round(),
                block.id()
            ),
```

**File:** consensus/src/payload_manager/quorum_store_payload_manager.rs (L590-590)
```rust
        Payload::OptQuorumStore(OptQuorumStorePayload::V1(p)) => p.inline_batches().transactions(),
```

**File:** consensus/src/payload_manager/quorum_store_payload_manager.rs (L591-594)
```rust
        Payload::OptQuorumStore(OptQuorumStorePayload::V2(_p)) => {
            error!("OptQSPayload V2 is not expected");
            Vec::new()
        },
```

**File:** consensus/consensus-types/src/payload.rs (L290-296)
```rust
#[derive(Serialize, Deserialize, Debug, Clone, PartialEq, Eq)]
pub struct OptQuorumStorePayloadV1<T: TBatchInfo> {
    inline_batches: InlineBatches<T>,
    opt_batches: OptBatches<T>,
    proofs: ProofBatches<T>,
    execution_limits: PayloadExecutionLimit,
}
```

**File:** consensus/src/consensus_observer/network/observer_message.rs (L709-713)
```rust
            Payload::OptQuorumStore(OptQuorumStorePayload::V2(_p)) => {
                return Err(Error::InvalidMessageError(
                    "OptQuorumStorePayload V2 is not supproted".into(),
                ));
            },
```

**File:** consensus/src/round_manager_tests/txn_filter_proposal_test.rs (L234-244)
```rust
fn create_payload(
    transactions: Vec<SignedTransaction>,
    use_quorum_store_payloads: bool,
) -> Payload {
    if use_quorum_store_payloads {
        let inline_batch = (create_batch_info(transactions.len()), transactions);
        Payload::QuorumStoreInlineHybrid(vec![inline_batch], ProofWithData::empty(), None)
    } else {
        Payload::DirectMempool(transactions)
    }
}
```
