# Audit Report

## Title
Faucet Metrics Server Exposes Sensitive Operational Data Enabling Timing and Resource Exhaustion Attacks

## Summary
The `gather_metrics()` function in the Aptos faucet metrics server exposes sensitive operational data through unauthenticated Prometheus metrics, including the exact funder account balance, rejection reason statistics, and outstanding transaction counts. This information disclosure enables attackers to time resource exhaustion attacks and gather intelligence about security control effectiveness. [1](#0-0) 

## Finding Description

The faucet metrics server exposes all registered Prometheus metrics through an unauthenticated `/metrics` endpoint that binds to `0.0.0.0` by default. The `gather_metrics()` function collects all metrics via `aptos_metrics_core::gather()` and returns them without any access controls. [2](#0-1) 

Three critical categories of sensitive data are exposed:

**1. Exact Funder Account Balance**

The faucet exposes the precise balance of its funding account as a gauge metric: [3](#0-2) 

This balance is updated in the health check routine and exposed via Prometheus: [4](#0-3) 

**Attack Scenario**: An attacker can continuously monitor this metric to identify when the faucet has low funds (e.g., just above the minimum threshold), then coordinate multiple simultaneous funding requests to exhaust the remaining balance, causing temporary service disruption.

**2. Rejection Reason Statistics**

The faucet exposes counters for each rejection reason, revealing how many times each security control has triggered: [5](#0-4) 

These rejection codes expose detailed security posture information: [6](#0-5) 

**Attack Scenario**: Attackers can analyze rejection statistics to:
- Identify ineffective security controls (low rejection counts)
- Optimize attack vectors based on which controls are most/least triggered
- Understand rate limiting patterns (UsageLimitExhausted counter growth)
- Detect VPN/cloud detection effectiveness

**3. Request Patterns and System Load**

The metrics expose detailed request patterns with latency histograms labeled by operation_id and status code, plus outstanding transaction counts: [7](#0-6) 

These metrics are populated via middleware that labels each request: [8](#0-7) 

**What is NOT exposed**: User IP addresses are not included in metric labels, so individual user tracking is not possible through these metrics alone.

**Default Configuration Vulnerability**

The metrics server binds to all network interfaces by default with no authentication: [9](#0-8) 

The `/metrics` endpoint is exposed via a CORS-enabled route with no authentication middleware: [10](#0-9) 

## Impact Explanation

This issue qualifies as **High severity** based on the following impacts:

1. **Resource Exhaustion Enablement**: The funder balance disclosure enables precisely timed attacks to drain faucet funds when balance is low, causing temporary service unavailability.

2. **Security Control Intelligence Gathering**: Rejection statistics expose the effectiveness of defensive measures (rate limiting, VPN detection, captcha, blocklists), allowing attackers to optimize their attack strategies.

3. **Load-Based Attack Timing**: Outstanding transaction metrics reveal when the system is under stress, enabling attackers to amplify attacks during high-load periods.

While this affects the faucet service (an auxiliary testnet/devnet component) rather than core consensus, it represents a significant operational security weakness that can lead to service disruption and enable more sophisticated attacks. The information disclosure directly aids "timing or resource exhaustion attacks" as specified in the security question.

## Likelihood Explanation

**Likelihood: High**

- **Attack Complexity**: Trivial - requires only HTTP GET access to the metrics endpoint
- **Authentication Required**: None
- **Privileges Required**: None - any network client can access the metrics
- **Default Configuration**: Vulnerable out-of-the-box (binds to 0.0.0.0)
- **Attacker Cost**: Negligible - simple monitoring script

The vulnerability will be exploited if:
1. The metrics server is not behind a firewall
2. The default configuration is used
3. Attackers discover the metrics endpoint (standard Prometheus port 9101)

## Recommendation

**Immediate Mitigation:**

1. **Restrict Network Binding**: Change default `listen_address` to `127.0.0.1` to prevent external access:

```rust
fn default_listen_address() -> String {
    "127.0.0.1".to_string()
}
```

2. **Add Authentication**: Implement authentication middleware for the metrics endpoint using API keys or mutual TLS.

3. **Sanitize Sensitive Metrics**: Remove or aggregate sensitive metrics:
   - Replace exact balance with a categorical indicator (e.g., "sufficient"/"low"/"critical")
   - Aggregate rejection reasons into broader categories
   - Remove or add noise to precise transaction counts

**Configuration Example:**

```rust
pub struct MetricsServerConfig {
    pub disable: bool,
    pub listen_address: String,
    pub listen_port: u16,
    // Add authentication
    #[serde(default)]
    pub require_api_key: bool,
    pub api_key: Option<String>,
}
```

**Defense in Depth**: Even with these mitigations, deploy the metrics server behind a firewall or reverse proxy with access controls in production environments.

## Proof of Concept

**Step 1: Access Metrics Endpoint**
```bash
# Assuming faucet metrics server is running on default port
curl http://faucet-server:9101/metrics
```

**Step 2: Extract Sensitive Data**
```bash
# Monitor funder balance continuously
while true; do
  curl -s http://faucet-server:9101/metrics | \
    grep aptos_tap_transfer_funder_account_balance | \
    awk '{print $2}'
  sleep 1
done

# Extract rejection reason breakdown
curl -s http://faucet-server:9101/metrics | \
  grep aptos_tap_rejection_reason_count
```

**Step 3: Execute Timing Attack**
```bash
# When balance drops below threshold, coordinate drain attack
BALANCE=$(curl -s http://faucet-server:9101/metrics | \
  grep aptos_tap_transfer_funder_account_balance | \
  awk '{print $2}')

if [ $BALANCE -lt 1000000 ]; then
  # Launch multiple concurrent funding requests
  for i in {1..10}; do
    curl -X POST http://faucet-server:8080/fund \
      -d '{"address":"0x..."}' &
  done
fi
```

**Expected Result**: Attacker can monitor exact funder balance in real-time, observe rejection patterns, and time resource exhaustion attacks when the faucet is most vulnerable.

## Notes

- This vulnerability affects the **faucet service infrastructure**, not core blockchain consensus or validator operations
- User IP addresses are **not exposed** in Prometheus metric labels - the metrics use aggregate counters and histograms without individual user identifiers
- The severity rating depends on whether the faucet is considered within scope of "API crashes" under High severity criteria
- Rate limit **configurations** (e.g., `max_requests_per_day`) are not directly exposed, but **enforcement statistics** are visible through rejection counters
- Mitigation requires changes to both default configuration and deployment practices

### Citations

**File:** crates/aptos-faucet/metrics-server/src/gather_metrics.rs (L15-44)
```rust
pub fn gather_metrics() -> Vec<prometheus::proto::MetricFamily> {
    let metric_families = aptos_metrics_core::gather();
    let mut total: u64 = 0;
    let mut families_over_2000: u64 = 0;

    // Take metrics of metric gathering so we know possible overhead of this process
    for metric_family in &metric_families {
        let family_count = metric_family.get_metric().len();
        if family_count > 2000 {
            families_over_2000 = families_over_2000.saturating_add(1);
            let name = metric_family.get_name();
            warn!(
                count = family_count,
                metric_family = name,
                "Metric Family '{}' over 2000 dimensions '{}'",
                name,
                family_count
            );
        }
        total = total.saturating_add(family_count as u64);
    }

    // These metrics will be reported on the next pull, rather than create a new family
    NUM_METRICS.with_label_values(&["total"]).inc_by(total);
    NUM_METRICS
        .with_label_values(&["families_over_2000"])
        .inc_by(families_over_2000);

    metric_families
}
```

**File:** crates/aptos-faucet/metrics-server/src/server.rs (L15-24)
```rust
pub fn encode_metrics(encoder: impl Encoder) -> Vec<u8> {
    let metric_families = gather_metrics();
    let mut buffer = vec![];
    encoder.encode(&metric_families, &mut buffer).unwrap();

    NUM_METRICS
        .with_label_values(&["total_bytes"])
        .inc_by(buffer.len() as u64);
    buffer
}
```

**File:** crates/aptos-faucet/metrics-server/src/server.rs (L31-40)
```rust
pub fn run_metrics_server(
    config: MetricsServerConfig,
) -> impl Future<Output = Result<(), std::io::Error>> {
    let cors = Cors::new().allow_methods(vec![Method::GET]);
    Server::new(TcpListener::bind((
        config.listen_address.clone(),
        config.listen_port,
    )))
    .run(Route::new().at("/metrics", metrics).with(cors))
}
```

**File:** crates/aptos-faucet/core/src/middleware/metrics.rs (L11-44)
```rust
pub static HISTOGRAM: Lazy<HistogramVec> = Lazy::new(|| {
    register_histogram_vec!(
        "aptos_tap_requests",
        "Tap requests latency grouped by method, operation_id and status.",
        &["method", "operation_id", "status"]
    )
    .unwrap()
});

pub static RESPONSE_STATUS: Lazy<HistogramVec> = Lazy::new(|| {
    register_histogram_vec!(
        "aptos_tap_response_status",
        "Tap requests latency grouped by status code only.",
        &["status"]
    )
    .unwrap()
});

static REJECTION_REASONS: Lazy<IntCounterVec> = Lazy::new(|| {
    register_int_counter_vec!(
        "aptos_tap_rejection_reason_count",
        "Number of times the tap has returned the given rejection reason.",
        &["rejection_reason_code"]
    )
    .unwrap()
});

pub static NUM_OUTSTANDING_TRANSACTIONS: Lazy<IntGauge> = Lazy::new(|| {
    register_int_gauge!(
        "aptos_tap_num_outstanding_transactions",
        "Number of transactions we've submitted but have not been processed by the blockchain.",
    )
    .unwrap()
});
```

**File:** crates/aptos-faucet/core/src/middleware/metrics.rs (L47-53)
```rust
pub static TRANSFER_FUNDER_ACCOUNT_BALANCE: Lazy<IntGauge> = Lazy::new(|| {
    register_int_gauge!(
        "aptos_tap_transfer_funder_account_balance",
        "Balance of the account used by the tap instance. Only populated for the TransferFunder.",
    )
    .unwrap()
});
```

**File:** crates/aptos-faucet/core/src/funder/transfer.rs (L362-365)
```rust
        };

        TRANSFER_FUNDER_ACCOUNT_BALANCE.set(funder_balance as i64);

```

**File:** crates/aptos-faucet/core/src/endpoints/errors.rs (L237-267)
```rust
pub enum RejectionReasonCode {
    /// Intentionally unhelpful reason code.
    Hehe = 1,

    /// Account already has funds.
    AccountAlreadyExists = 100,

    /// Key (IP / Firebase UID) has exhausted its usage limit.
    UsageLimitExhausted = 101,

    /// IP is in the blocklist.
    IpInBlocklist = 102,

    /// The origin of the request is from a VPN.
    RequestFromVpn = 103,

    /// The origin of the request is a cloud.
    RequestFromCloud = 104,

    /// The request did not contain the required magic header.
    MagicHeaderIncorrect = 105,

    /// The captcha was missing or incorrect.
    CaptchaInvalid = 106,

    /// Auth token was not given, is invalid, or is not allowed by the server.
    AuthTokenInvalid = 107,

    /// Referer was in the blocklist.
    RefererBlocklisted = 108,
}
```

**File:** crates/aptos-faucet/core/src/middleware/log.rs (L128-139)
```rust
                RESPONSE_STATUS
                    .with_label_values(&[response_log.response_status.to_string().as_str()])
                    .observe(response_log.elapsed.as_secs_f64());

                // Log response status per-endpoint + method.
                HISTOGRAM
                    .with_label_values(&[
                        self.request_log.method.as_str(),
                        response_log.operation_id,
                        response_log.response_status.to_string().as_str(),
                    ])
                    .observe(response_log.elapsed.as_secs_f64());
```

**File:** crates/aptos-faucet/metrics-server/src/config.rs (L26-32)
```rust
    fn default_listen_address() -> String {
        "0.0.0.0".to_string()
    }

    fn default_listen_port() -> u16 {
        9101
    }
```
