# Audit Report

## Title
Unbounded String Deserialization in Waypoint Configuration Leading to Resource Exhaustion

## Summary
The `Waypoint::deserialize()` function at lines 156-158 in `types/src/waypoint.rs` performs unbounded string deserialization in human-readable mode, allowing malicious configuration files to cause memory exhaustion and node crashes through excessively large waypoint strings. [1](#0-0) 

## Finding Description

When deserializing a `Waypoint` from human-readable formats (YAML/JSON/TOML), the custom deserializer first deserializes an unbounded `String` from the input, then passes it to `Waypoint::from_str()` for parsing. There is no validation of the string length before deserialization or parsing. [2](#0-1) 

The `from_str()` implementation includes the entire input string in error messages when parsing fails, potentially amplifying memory consumption. [2](#0-1) 

**Attack Scenario:**

Aptos fullnodes download waypoint files from remote URLs during initialization: [3](#0-2) 

The default URLs point to official Aptos infrastructure: [4](#0-3) 

If an attacker can compromise these remote endpoints OR social engineer an operator to use a malicious URL, they can serve a configuration file containing:

```yaml
base:
  waypoint:
    from_config: "999:<10GB of hex characters>"
```

When the node loads this configuration:

1. `NodeConfig::load_config()` reads the YAML file using `serde_yaml`
2. The `Waypoint` deserializer is invoked in human-readable mode
3. `<String>::deserialize(deserializer)?` allocates memory for the 10GB string
4. `Waypoint::from_str()` is called with the 10GB string
5. Parsing fails (hash must be exactly 64 hex chars)
6. Node crashes due to memory exhaustion (OOM) or becomes unresponsive

Additionally, waypoint files loaded via `WaypointConfig::FromFile` suffer the same issue: [5](#0-4) 

The `fs::read_to_string()` call reads the entire file into memory with no size limit, and the panic message on parse failure includes the entire content.

## Impact Explanation

**Severity: Medium**

This vulnerability breaks the **Resource Limits** invariant (invariant #9): "All operations must respect gas, storage, and computational limits." While this occurs during node initialization rather than transaction execution, it violates the principle that the node should handle malformed inputs gracefully.

The impact is:
- **Node crash/unavailability**: Fullnodes attempting to load malicious configs will crash or hang due to memory exhaustion
- **Denial of service**: Affects node availability but not consensus or funds
- **Limited scope**: Only affects nodes loading configs from compromised sources

This fits **Medium Severity** per the Aptos bug bounty criteria: while it doesn't cause funds loss or consensus violations, it represents a "state inconsistency requiring intervention" (nodes crash and require manual remediation) and could cascade if official waypoint sources are compromised.

## Likelihood Explanation

**Likelihood: Low to Medium**

The attack requires one of the following:

1. **Compromise of official Aptos infrastructure** (aptoslabs.com or aptos-labs/aptos-networks GitHub repository): Low likelihood but high impact if successful

2. **Social engineering**: Tricking operators to use custom waypoint URLs: Medium likelihood in practice, as operators may test with unofficial sources

3. **Supply chain attack**: Compromising CI/CD pipelines that generate/deploy configs: Medium likelihood given increasing supply chain attacks

While configuration files are typically trusted, the default fullnode deployment pattern of downloading waypoints from remote URLs creates an attack surface. The lack of size validation represents a defense-in-depth failure.

## Recommendation

Add string length validation before parsing:

```rust
impl<'de> Deserialize<'de> for Waypoint {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        if deserializer.is_human_readable() {
            let s = <String>::deserialize(deserializer)?;
            
            // Add maximum reasonable length for waypoint string
            // Format: "<version>:<64-char-hex>" → max ~100 bytes reasonable
            const MAX_WAYPOINT_STRING_LENGTH: usize = 256;
            if s.len() > MAX_WAYPOINT_STRING_LENGTH {
                return Err(D::Error::custom(format!(
                    "Waypoint string exceeds maximum length of {} bytes: got {} bytes",
                    MAX_WAYPOINT_STRING_LENGTH,
                    s.len()
                )));
            }
            
            Waypoint::from_str(&s).map_err(D::Error::custom)
        } else {
            // ... existing binary deserialization
```

Additionally, validate file size before reading:

```rust
WaypointConfig::FromFile(waypoint_path) => {
    // Check file size before reading
    const MAX_WAYPOINT_FILE_SIZE: u64 = 1024; // 1KB is generous
    let metadata = fs::metadata(waypoint_path).unwrap_or_else(|error| {
        panic!("Failed to read waypoint file metadata: {:?}", error)
    });
    
    if metadata.len() > MAX_WAYPOINT_FILE_SIZE {
        panic!(
            "Waypoint file exceeds maximum size of {} bytes: {:?}",
            MAX_WAYPOINT_FILE_SIZE,
            waypoint_path.display()
        );
    }
    
    let content = fs::read_to_string(waypoint_path).unwrap_or_else(|error| {
        // ... rest of existing code
```

## Proof of Concept

Create a malicious waypoint file:
```bash
# Generate a 1GB waypoint file
python3 -c "print('999:' + 'a' * (1024**3))" > malicious_waypoint.txt
```

Create a fullnode config referencing it:
```yaml
base:
  data_dir: "/opt/aptos/data"
  role: full_node
  waypoint:
    from_file: "./malicious_waypoint.txt"
```

Start the fullnode:
```bash
cargo run -p aptos-node -- -f malicious_config.yaml
```

**Expected Result**: Node crashes with OOM or hangs attempting to allocate 1GB+ memory during waypoint parsing.

Alternatively, test YAML inline deserialization:
```yaml
base:
  waypoint:
    from_config: "999:aaaaaaaaaaaaa..." # 1GB of 'a's
```

The node will crash during config deserialization when serde_yaml attempts to allocate memory for the string.

## Notes

This vulnerability exists at two distinct code locations:
1. YAML deserialization path (lines 156-158): serde_yaml → custom deserializer → from_str
2. File reading path (base_config.rs line 84): fs::read_to_string → from_str

Both paths lack size validation and should be addressed. The issue is particularly concerning because fullnodes are designed to download waypoint files from remote URLs, creating a realistic attack surface if those endpoints are compromised or if operators use untrusted sources.

### Citations

**File:** types/src/waypoint.rs (L111-123)
```rust
    fn from_str(s: &str) -> Result<Self> {
        let mut split = s.split(WAYPOINT_DELIMITER);
        let version = split
            .next()
            .ok_or_else(|| format_err!("Failed to parse waypoint string {}", s))?
            .parse::<Version>()?;
        let value = HashValue::from_hex(
            split
                .next()
                .ok_or_else(|| format_err!("Failed to parse waypoint string {}", s))?,
        )?;
        Ok(Self { version, value })
    }
```

**File:** types/src/waypoint.rs (L155-158)
```rust
        if deserializer.is_human_readable() {
            let s = <String>::deserialize(deserializer)?;
            Waypoint::from_str(&s).map_err(D::Error::custom)
        } else {
```

**File:** terraform/helm/fullnode/templates/fullnode.yaml (L127-128)
```yaml
          curl -o /opt/aptos/genesis/waypoint.txt {{ (get .Values.aptos_chains .Values.chain.name).waypoint_txt_url }}
          curl -o /opt/aptos/genesis/genesis.blob {{ (get .Values.aptos_chains .Values.chain.name).genesis_blob_url }}
```

**File:** terraform/helm/fullnode/values.yaml (L21-29)
```yaml
  devnet:
    waypoint_txt_url: https://devnet.aptoslabs.com/waypoint.txt
    genesis_blob_url: https://devnet.aptoslabs.com/genesis.blob
  testnet:
    waypoint_txt_url: https://raw.githubusercontent.com/aptos-labs/aptos-networks/main/testnet/genesis_waypoint.txt
    genesis_blob_url: https://raw.githubusercontent.com/aptos-labs/aptos-networks/main/testnet/genesis.blob
  mainnet:
    waypoint_txt_url: https://raw.githubusercontent.com/aptos-labs/aptos-networks/main/mainnet/waypoint.txt
    genesis_blob_url: https://raw.githubusercontent.com/aptos-labs/aptos-networks/main/mainnet/genesis.blob
```

**File:** config/src/config/base_config.rs (L84-97)
```rust
                let content = fs::read_to_string(waypoint_path).unwrap_or_else(|error| {
                    panic!(
                        "Failed to read waypoint file {:?}. Error: {:?}",
                        waypoint_path.display(),
                        error
                    )
                });
                Some(Waypoint::from_str(content.trim()).unwrap_or_else(|error| {
                    panic!(
                        "Failed to parse waypoint: {:?}. Error: {:?}",
                        content.trim(),
                        error
                    )
                }))
```
