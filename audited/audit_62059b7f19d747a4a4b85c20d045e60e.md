# Audit Report

## Title
Incomplete Validation of Inspection Service Endpoints Allows Information Disclosure on Mainnet Validators

## Summary
The `InspectionServiceConfig` sanitizer only validates that mainnet validators have disabled the `expose_configuration` endpoint, but fails to validate that other sensitive endpoints (`expose_identity_information`, `expose_peer_information`, `expose_system_information`) are also disabled. Since these endpoints are enabled by default, mainnet validators using default configurations inadvertently expose sensitive network topology and identity information to attackers.

## Finding Description

The inspection service configuration sanitizer implements incomplete validation for mainnet validators. [1](#0-0) 

The sanitizer only checks whether `expose_configuration` is enabled for mainnet validators: [2](#0-1) 

However, the default configuration enables three other sensitive endpoints: [3](#0-2) 

These unchecked endpoints expose critical information:

1. **Identity Information endpoint** exposes validator and fullnode peer IDs: [4](#0-3) 

2. **Peer Information endpoint** exposes the entire validator set, trusted peers, connection metadata, and internal client states: [5](#0-4) 

3. **System Information endpoint** exposes build version and system details: [6](#0-5) 

The inspection service starts without runtime validation of these settings: [7](#0-6) 

**Attack Scenario:**
1. Attacker identifies a mainnet validator running with default inspection service configuration
2. Attacker queries `http://<validator-ip>:9101/identity_information` to obtain the validator's peer ID
3. Attacker queries `http://<validator-ip>:9101/peer_information` to obtain the complete validator set, trusted peers, and connection topology
4. Attacker uses this information to launch targeted eclipse attacks, DoS attacks against specific validator connections, or exploit version-specific vulnerabilities revealed by system information

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos bug bounty program criteria for the following reasons:

1. **Significant Protocol Violations**: Exposes validator network topology and identity information that should be protected, violating the security assumption that mainnet validator configurations are hardened against reconnaissance attacks.

2. **Enables Further Attacks**: The exposed information facilitates:
   - **Eclipse attacks**: Knowing the validator's peer connections allows attackers to strategically position malicious nodes
   - **Targeted DoS**: Connection metadata reveals which peers to target for maximum disruption
   - **Version-specific exploits**: Build information enables attackers to identify and exploit known vulnerabilities in specific versions
   - **Privacy violations**: Reveals validator set composition and network structure

3. **Validator Node Impact**: While not directly causing slowdowns, it creates the preconditions for attacks that could degrade validator performance or availability.

## Likelihood Explanation

This vulnerability has **HIGH likelihood** of exploitation:

1. **Default Configuration**: The insecure configuration is the default, meaning any validator operator who doesn't explicitly disable these endpoints is vulnerable
2. **No Warning**: The sanitizer provides no warning or error for mainnet validators with these endpoints enabled
3. **Simple Exploitation**: Requires only HTTP GET requests to publicly accessible ports
4. **No Authentication**: The endpoints require no authentication or authorization
5. **Discovery**: Attackers can easily scan mainnet validators (which have known IP addresses) for open inspection service ports

## Recommendation

Extend the `InspectionServiceConfig` sanitizer to validate all sensitive endpoints for mainnet validators:

```rust
// In config/src/config/inspection_service_config.rs, line 54-65
impl ConfigSanitizer for InspectionServiceConfig {
    fn sanitize(
        node_config: &NodeConfig,
        node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();
        let inspection_service_config = &node_config.inspection_service;

        // Verify that mainnet validators do not expose sensitive endpoints
        if let Some(chain_id) = chain_id {
            if node_type.is_validator() && chain_id.is_mainnet() {
                if inspection_service_config.expose_configuration {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name.clone(),
                        "Mainnet validators should not expose the node configuration!".to_string(),
                    ));
                }
                
                // ADD THESE CHECKS:
                if inspection_service_config.expose_identity_information {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name.clone(),
                        "Mainnet validators should not expose identity information!".to_string(),
                    ));
                }
                
                if inspection_service_config.expose_peer_information {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name.clone(),
                        "Mainnet validators should not expose peer information!".to_string(),
                    ));
                }
                
                if inspection_service_config.expose_system_information {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name,
                        "Mainnet validators should not expose system information!".to_string(),
                    ));
                }
            }
        }

        Ok(())
    }
}
```

Additionally, update the optimizer to disable all these endpoints by default for mainnet nodes.

## Proof of Concept

```rust
#[test]
fn test_sanitize_mainnet_validator_identity_information() {
    // Create a mainnet validator config with identity information exposed
    let node_config = NodeConfig {
        inspection_service: InspectionServiceConfig {
            expose_identity_information: true,
            ..Default::default()
        },
        ..Default::default()
    };

    // Sanitize the config and verify that it should fail (but currently doesn't)
    let result = InspectionServiceConfig::sanitize(
        &node_config,
        NodeType::Validator,
        Some(ChainId::mainnet()),
    );
    
    // Currently this PASSES but should FAIL
    assert!(result.is_ok()); // This is the vulnerability
    
    // After the fix, this should fail:
    // assert!(matches!(result, Err(Error::ConfigSanitizerFailed(_, _))));
}

#[test]
fn test_sanitize_mainnet_validator_peer_information() {
    // Create a mainnet validator config with peer information exposed
    let node_config = NodeConfig {
        inspection_service: InspectionServiceConfig {
            expose_peer_information: true,
            ..Default::default()
        },
        ..Default::default()
    };

    // Sanitize the config and verify that it should fail (but currently doesn't)
    let result = InspectionServiceConfig::sanitize(
        &node_config,
        NodeType::Validator,
        Some(ChainId::mainnet()),
    );
    
    // Currently this PASSES but should FAIL
    assert!(result.is_ok()); // This is the vulnerability
}

#[test]
fn test_sanitize_mainnet_validator_system_information() {
    // Create a mainnet validator config with system information exposed
    let node_config = NodeConfig {
        inspection_service: InspectionServiceConfig {
            expose_system_information: true,
            ..Default::default()
        },
        ..Default::default()
    };

    // Sanitize the config and verify that it should fail (but currently doesn't)
    let result = InspectionServiceConfig::sanitize(
        &node_config,
        NodeType::Validator,
        Some(ChainId::mainnet()),
    );
    
    // Currently this PASSES but should FAIL
    assert!(result.is_ok()); // This is the vulnerability
}
```

**Manual exploitation test:**
```bash
# Query a mainnet validator's inspection service
# (assuming it's running with default config on port 9101)

# Get identity information
curl http://<mainnet-validator-ip>:9101/identity_information

# Get peer information (includes validator set)
curl http://<mainnet-validator-ip>:9101/peer_information

# Get system information
curl http://<mainnet-validator-ip>:9101/system_information
```

## Notes

The vulnerability exists because the sanitizer's scope was too narrow, focusing only on the most obviously sensitive `expose_configuration` endpoint while overlooking that identity, peer, and system information are equally sensitive for mainnet validators. The default-enabled state of these endpoints compounds the issue, as validators must explicitly opt-out rather than opt-in to exposure.

### Citations

**File:** crates/aptos-inspection-service/src/server/mod.rs (L50-101)
```rust
pub fn start_inspection_service(
    node_config: NodeConfig,
    aptos_data_client: AptosDataClient,
    peers_and_metadata: Arc<PeersAndMetadata>,
) {
    // Fetch the service port and address
    let service_port = node_config.inspection_service.port;
    let service_address = node_config.inspection_service.address.clone();

    // Create the inspection service socket address
    let address: SocketAddr = (service_address.as_str(), service_port)
        .to_socket_addrs()
        .unwrap_or_else(|_| {
            panic!(
                "Failed to parse {}:{} as address",
                service_address, service_port
            )
        })
        .next()
        .unwrap();

    // Create a runtime for the inspection service
    let runtime = aptos_runtimes::spawn_named_runtime("inspection".into(), None);

    // Spawn the inspection service
    thread::spawn(move || {
        // Create the service function that handles the endpoint requests
        let make_service = make_service_fn(move |_conn| {
            let node_config = node_config.clone();
            let aptos_data_client = aptos_data_client.clone();
            let peers_and_metadata = peers_and_metadata.clone();
            async move {
                Ok::<_, Infallible>(service_fn(move |request| {
                    serve_requests(
                        request,
                        node_config.clone(),
                        aptos_data_client.clone(),
                        peers_and_metadata.clone(),
                    )
                }))
            }
        });

        // Start and block on the server
        runtime
            .block_on(async {
                let server = Server::bind(&address).serve(make_service);
                server.await
            })
            .unwrap();
    });
}
```

**File:** config/src/config/inspection_service_config.rs (L26-36)
```rust
impl Default for InspectionServiceConfig {
    fn default() -> InspectionServiceConfig {
        InspectionServiceConfig {
            address: "0.0.0.0".to_string(),
            port: 9101,
            expose_configuration: false,
            expose_identity_information: true,
            expose_peer_information: true,
            expose_system_information: true,
        }
    }
```

**File:** config/src/config/inspection_service_config.rs (L54-65)
```rust
        // Verify that mainnet validators do not expose the configuration
        if let Some(chain_id) = chain_id {
            if node_type.is_validator()
                && chain_id.is_mainnet()
                && inspection_service_config.expose_configuration
            {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "Mainnet validators should not expose the node configuration!".to_string(),
                ));
            }
        }
```

**File:** crates/aptos-inspection-service/src/server/identity_information.rs (L29-51)
```rust
fn get_identity_information(node_config: &NodeConfig) -> String {
    let mut identity_information = Vec::<String>::new();
    identity_information.push("Identity Information:".into());

    // If the validator network is configured, fetch the identity information
    if let Some(validator_network) = &node_config.validator_network {
        identity_information.push(format!(
            "\t- Validator network ({}), peer ID: {}",
            validator_network.network_id,
            validator_network.peer_id()
        ));
    }

    // For each fullnode network, fetch the identity information
    for fullnode_network in &node_config.full_node_networks {
        identity_information.push(format!(
            "\t- Fullnode network ({}), peer ID: {}",
            fullnode_network.network_id,
            fullnode_network.peer_id()
        ));
    }

    identity_information.join("\n") // Separate each entry with a newline to construct the output
```

**File:** crates/aptos-inspection-service/src/server/peer_information.rs (L40-106)
```rust
/// Returns a simple text formatted string with peer and network information
fn get_peer_information(
    aptos_data_client: AptosDataClient,
    peers_and_metadata: Arc<PeersAndMetadata>,
) -> String {
    // Get all registered networks
    let registered_networks: Vec<NetworkId> =
        peers_and_metadata.get_registered_networks().collect();

    // Get all peers (sorted by peer ID)
    let mut all_peers = peers_and_metadata.get_all_peers();
    all_peers.sort();

    // Display a summary of all peers and networks
    let mut peer_information_output = Vec::<String>::new();
    display_peer_information_summary(
        &mut peer_information_output,
        &all_peers,
        &registered_networks,
    );
    peer_information_output.push("\n".into());

    // Display connection metadata for each peer
    display_peer_connection_metadata(
        &mut peer_information_output,
        &all_peers,
        peers_and_metadata.deref(),
    );
    peer_information_output.push("\n".into());

    // Display the entire set of trusted peers
    display_trusted_peers(
        &mut peer_information_output,
        registered_networks,
        peers_and_metadata.deref(),
    );
    peer_information_output.push("\n".into());

    // Display basic peer metadata for each peer
    display_peer_monitoring_metadata(
        &mut peer_information_output,
        &all_peers,
        peers_and_metadata.deref(),
    );
    peer_information_output.push("\n".into());

    // Display state sync metadata for each peer
    display_state_sync_metadata(&mut peer_information_output, &all_peers, aptos_data_client);
    peer_information_output.push("\n".into());

    // Display detailed peer metadata for each peer
    display_detailed_monitoring_metadata(
        &mut peer_information_output,
        &all_peers,
        peers_and_metadata.deref(),
    );
    peer_information_output.push("\n".into());

    // Display the internal client state for each peer
    display_internal_client_state(
        &mut peer_information_output,
        &all_peers,
        peers_and_metadata.deref(),
    );

    peer_information_output.join("\n") // Separate each entry with a newline to construct the output
}
```

**File:** crates/aptos-inspection-service/src/server/system_information.rs (L31-42)
```rust
/// Returns a simple JSON formatted string with system information
fn get_system_information_json() -> String {
    // Get the system and build information
    let mut system_information = aptos_telemetry::system_information::get_system_information();
    system_information.extend(build_information!());

    // Return the system information as a JSON string
    match serde_json::to_string(&system_information) {
        Ok(system_information) => system_information,
        Err(error) => format!("Failed to get system information! Error: {}", error),
    }
}
```

**File:** aptos-node/src/services.rs (L212-222)
```rust
pub fn start_node_inspection_service(
    node_config: &NodeConfig,
    aptos_data_client: AptosDataClient,
    peers_and_metadata: Arc<PeersAndMetadata>,
) {
    aptos_inspection_service::start_inspection_service(
        node_config.clone(),
        aptos_data_client,
        peers_and_metadata,
    )
}
```
