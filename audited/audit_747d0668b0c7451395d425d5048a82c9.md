# Audit Report

## Title
Expired Batch Inclusion in Block Proposals Due to Missing Expiration Check in pull_internal()

## Summary
The `pull_internal()` function in `batch_proof_queue.rs` fails to validate batch expiration against the provided `block_timestamp` parameter, allowing expired batches to be included in block proposals. This creates a race condition where batches that have expired relative to the proposal timestamp can be selected, violating consensus determinism invariants.

## Finding Description

The vulnerability exists in the `pull_internal()` function's batch selection logic. [1](#0-0) 

When selecting batches for inclusion in a block proposal, the function checks several conditions including batch age, committed status, and proof existence, but **critically omits any check comparing the batch's expiration timestamp with the block_timestamp parameter**.

The system maintains batch expiration timestamps in microseconds. [2](#0-1) 

The `handle_updated_block_timestamp()` method is responsible for removing expired batches from the queue. [3](#0-2) 

However, `pull_internal()` receives its own `block_timestamp` parameter (as a Duration) which may be newer than `self.latest_block_timestamp`. [4](#0-3) 

The race condition occurs because these operations happen on separate async channels in the ProofManager. [5](#0-4) 

**Exploitation Scenario:**

1. Block N is committed with timestamp T1 = 100,000,000 μs
2. A batch exists with expiration = 105,000,000 μs  
3. `CommitNotification(T1)` is sent but not yet processed by a validator
4. New proposal request arrives with block_timestamp = Duration::from_secs(110) (= 110,000,000 μs)
5. `pull_internal()` is called before `handle_updated_block_timestamp(T1)` processes
6. The batch with expiration 105,000,000 < 110,000,000 is included despite being expired

Different validators may process these messages in different orders, causing non-deterministic batch selection. The system's design intent is clear: `insert_proof()` explicitly rejects expired batches. [6](#0-5) 

## Impact Explanation

This vulnerability is **Critical Severity** because it breaks the fundamental consensus invariant of deterministic execution. Different validators may include different sets of batches in their proposals for the same block timestamp, potentially leading to:

1. **Consensus Safety Violation**: Different validators may produce different state roots for the same logical block
2. **Block Rejection**: Validators may reject proposals containing expired batches during validation
3. **Network Instability**: Inconsistent batch inclusion could cause proposal failures and liveness issues

This qualifies as a Critical finding per Aptos bug bounty criteria: "Consensus/Safety violations" that could cause network partition or state divergence requiring intervention.

## Likelihood Explanation

**Likelihood: High**

This race condition can occur naturally during normal network operation without any malicious actor:
- Commit notifications and proposal requests flow through separate async channels
- Network latency and processing delays create natural timing variations
- The window for the race is the time between receiving a proposal request and processing the corresponding commit notification

A malicious validator could also deliberately exploit this by:
- Delaying commit notification processing
- Timing their proposals to maximize expired batch inclusion
- Causing other validators to reject their proposals or have inconsistent views

## Recommendation

Add an explicit batch expiration check in `pull_internal()` before including batches in the result:

```rust
let batch_iter = batches.iter().rev().filter_map(|(sort_key, info)| {
    if let Some(item) = self.items.get(&sort_key.batch_key) {
        let batch_create_ts_usecs =
            item.info.expiration() - self.batch_expiry_gap_when_init_usecs;

        // ADD THIS CHECK: Ensure batch hasn't expired relative to block_timestamp
        if item.info.expiration() <= block_timestamp.as_micros() as u64 {
            return None;
        }

        // Ensure that the batch was created at least `min_batch_age_usecs` ago to
        // reduce the chance of inline fetches.
        if max_batch_creation_ts_usecs
            .is_some_and(|max_create_ts| batch_create_ts_usecs > max_create_ts)
        {
            return None;
        }

        if item.is_committed() {
            return None;
        }
        if !(batches_without_proofs ^ item.proof.is_none()) {
            return Some((info, item));
        }
    }
    None
});
```

This ensures that `pull_internal()` only includes batches that are valid relative to the `block_timestamp` parameter, regardless of when `handle_updated_block_timestamp()` was last called.

## Proof of Concept

```rust
#[tokio::test]
async fn test_expired_batch_inclusion_race() {
    use aptos_types::PeerId;
    use std::sync::Arc;
    use std::time::Duration;
    
    // Setup
    let peer_id = PeerId::random();
    let batch_store = Arc::new(BatchStore::new(/* ... */));
    let mut queue = BatchProofQueue::new(
        peer_id,
        batch_store,
        5_000_000, // 5 second expiry gap
    );
    
    // 1. Insert a proof with expiration at 105 seconds (105M microseconds)
    let batch_info = create_test_batch_info(
        peer_id,
        1,
        105_000_000, // expires at T=105s
        10, // 10 transactions
    );
    let proof = create_test_proof(batch_info.clone());
    queue.insert_proof(proof);
    
    // 2. Simulate commit notification at T=100s
    // This would normally remove batches expiring at <= 100s
    queue.handle_updated_block_timestamp(100_000_000);
    
    // 3. Pull proofs for a block at T=110s BEFORE the next commit notification
    // The batch should be expired but will still be included!
    let (proofs, _, _, _) = queue.pull_proofs(
        &HashSet::new(),
        PayloadTxnsSize::new(1000, 1000000),
        1000,
        900,
        false,
        Duration::from_secs(110), // T=110s, batch expired at 105s!
    );
    
    // BUG: The expired batch is included even though 105M < 110M
    assert_eq!(proofs.len(), 1, "Expired batch was incorrectly included!");
    assert_eq!(proofs[0].info().expiration(), 105_000_000);
    
    // The batch is expired relative to block timestamp (110s > 105s)
    // but was still included because pull_internal doesn't check batch expiration
}
```

## Notes

This vulnerability demonstrates a subtle but critical gap in the expiration validation logic. While individual transaction expiration is checked during batch processing [7](#0-6) , the batch-level expiration check is missing from the selection criteria. The asynchronous nature of the ProofManager's message handling exacerbates this issue by creating natural opportunities for the race condition to manifest.

### Citations

**File:** consensus/src/quorum_store/batch_proof_queue.rs (L175-179)
```rust
    pub(crate) fn insert_proof(&mut self, proof: ProofOfStore<BatchInfoExt>) {
        if proof.expiration() <= self.latest_block_timestamp {
            counters::inc_rejected_pos_count(counters::POS_EXPIRED_LABEL);
            return;
        }
```

**File:** consensus/src/quorum_store/batch_proof_queue.rs (L561-572)
```rust
    fn pull_internal(
        &mut self,
        batches_without_proofs: bool,
        excluded_batches: &HashSet<BatchInfoExt>,
        exclude_authors: &HashSet<Author>,
        max_txns: PayloadTxnsSize,
        max_txns_after_filtering: u64,
        soft_max_txns_after_filtering: u64,
        return_non_full: bool,
        block_timestamp: Duration,
        min_batch_age_usecs: Option<u64>,
    ) -> (Vec<&QueueItem>, PayloadTxnsSize, u64, bool) {
```

**File:** consensus/src/quorum_store/batch_proof_queue.rs (L601-622)
```rust
            let batch_iter = batches.iter().rev().filter_map(|(sort_key, info)| {
                if let Some(item) = self.items.get(&sort_key.batch_key) {
                    let batch_create_ts_usecs =
                        item.info.expiration() - self.batch_expiry_gap_when_init_usecs;

                    // Ensure that the batch was created at least `min_batch_age_usecs` ago to
                    // reduce the chance of inline fetches.
                    if max_batch_creation_ts_usecs
                        .is_some_and(|max_create_ts| batch_create_ts_usecs > max_create_ts)
                    {
                        return None;
                    }

                    if item.is_committed() {
                        return None;
                    }
                    if !(batches_without_proofs ^ item.proof.is_none()) {
                        return Some((info, item));
                    }
                }
                None
            });
```

**File:** consensus/src/quorum_store/batch_proof_queue.rs (L644-647)
```rust
                                            && block_timestamp.as_secs()
                                                < txn_summary.expiration_timestamp_secs
                                    })
                                    .count() as u64
```

**File:** consensus/src/quorum_store/batch_proof_queue.rs (L716-729)
```rust
    pub(crate) fn handle_updated_block_timestamp(&mut self, block_timestamp: u64) {
        // tolerate asynchronous notification
        if self.latest_block_timestamp > block_timestamp {
            return;
        }
        let start = Instant::now();
        self.latest_block_timestamp = block_timestamp;
        if let Some(time_lag) = aptos_infallible::duration_since_epoch()
            .checked_sub(Duration::from_micros(block_timestamp))
        {
            counters::TIME_LAG_IN_BATCH_PROOF_QUEUE.observe_duration(time_lag);
        }

        let expired = self.expirations.expire(block_timestamp);
```

**File:** consensus/consensus-types/src/proof_of_store.rs (L46-58)
```rust
#[derive(
    Clone, Debug, Deserialize, Serialize, CryptoHasher, BCSCryptoHash, PartialEq, Eq, Hash,
)]
pub struct BatchInfo {
    author: PeerId,
    batch_id: BatchId,
    epoch: u64,
    expiration: u64,
    digest: HashValue,
    num_txns: u64,
    num_bytes: u64,
    gas_bucket_start: u64,
}
```

**File:** consensus/src/quorum_store/proof_manager.rs (L281-292)
```rust
            tokio::select! {
                    Some(msg) = proposal_rx.next() => monitor!("proof_manager_handle_proposal", {
                        self.handle_proposal_request(msg);

                        let updated_back_pressure = self.qs_back_pressure();
                        if updated_back_pressure != back_pressure {
                            back_pressure = updated_back_pressure;
                            if back_pressure_tx.send(back_pressure).await.is_err() {
                                debug!("Failed to send back_pressure for proposal");
                            }
                        }
                    }),
```
