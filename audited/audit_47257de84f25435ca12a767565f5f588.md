# Audit Report

## Title
Integer Overflow in Subscription Stream Lag Metrics Enables Monitoring Blindness via Malicious Peer Advertisement

## Summary
A malicious peer can advertise a fabricated storage summary with an inflated ledger info version (approaching u64::MAX), causing the subscription stream lag calculation to exceed i64::MAX. When this value is cast to i64 in the metrics system, it wraps to a large negative number, completely hiding massive synchronization lag from monitoring systems and preventing timely detection of state sync failures.

## Finding Description
The vulnerability exists in the interaction between peer storage summary handling and metrics reporting:

**1. Unvalidated Peer Storage Summaries**

When nodes poll peers for their storage summaries, the received `synced_ledger_info` is accepted without signature verification: [1](#0-0) 

The storage summary is directly stored in peer states without cryptographic validation: [2](#0-1) 

**2. Global Data Summary Aggregation**

These unvalidated peer summaries are aggregated into a global data summary, where the `synced_ledger_infos` from all peers (including malicious ones) are collected: [3](#0-2) 

The highest version among all advertised ledger infos is selected without validation: [4](#0-3) 

**3. Subscription Stream Lag Calculation**

During subscription stream processing, the lag is calculated as the difference between the highest advertised version and the current response version: [5](#0-4) 

If a malicious peer advertises a version near u64::MAX, the calculated lag will be massive (potentially exceeding i64::MAX).

**4. Integer Overflow in Metrics**

The critical vulnerability occurs when this lag value is reported to metrics. The function casts u64 to i64 without bounds checking: [6](#0-5) 

When the lag exceeds i64::MAX (9,223,372,036,854,775,807), the cast wraps around to a large negative number per Rust's casting semantics.

**Attack Scenario:**
1. Malicious peer creates a `StorageServerSummary` with `synced_ledger_info.version` ≈ u64::MAX (18,446,744,073,709,551,615)
2. Honest node polls this peer and accepts the summary without signature verification
3. The inflated version becomes part of the global data summary as the "highest advertised version"
4. Subscription stream calculates lag: u64::MAX - current_version (e.g., 1 billion) ≈ u64::MAX
5. This lag value (> i64::MAX) is cast to i64, wrapping to approximately -9,223,372,036,854,775,808
6. Monitoring systems see negative lag values instead of the actual massive lag
7. Operators cannot detect that the node is billions of versions behind

## Impact Explanation
This vulnerability meets **High Severity** criteria per the Aptos bug bounty program:

- **Prevents timely detection of state sync failures**: Operators rely on the `SUBSCRIPTION_STREAM_LAG` metric to monitor node health. With negative values, alerting systems fail completely.

- **Validator node slowdowns**: Nodes operating with massive undetected lag effectively become degraded participants. They cannot serve current state to peers and may fall further behind.

- **Significant protocol violations**: The subscription stream is a critical component of Aptos state synchronization. Hiding lag violates the protocol's assumption that monitoring can detect and remediate sync issues.

- **Operational blindness**: In production environments, metrics-based monitoring is essential. This vulnerability creates a complete blind spot for one of the most critical operational metrics, potentially leading to:
  - Prolonged operation with stale state
  - Failure to trigger manual intervention
  - Cascading failures if multiple nodes are affected
  - Delayed incident response

While the internal recovery logic (`is_beyond_recovery`) still uses u64 comparisons and functions correctly, the operator monitoring blind spot is the primary security concern, as it prevents human intervention when automated recovery may be insufficient.

## Likelihood Explanation
**High Likelihood:**

- **Low attacker requirements**: Any peer (validator or fullnode) can send fabricated storage summaries. No special privileges or Byzantine quorum required.

- **Trivial to execute**: The attacker simply needs to craft a `StorageServerSummary` with an inflated version number. No complex cryptographic attacks or timing dependencies.

- **No validation barriers**: There is no signature verification, sanity checking, or rate limiting on advertised versions in storage summaries.

- **Affects all polling nodes**: Any node that polls the malicious peer will incorporate the inflated version into its global data summary calculations.

- **Persistent impact**: Once a malicious peer is in the peer set, it can continuously affect monitoring until detected and removed through other means (peer scoring, manual intervention).

The only limiting factor is that honest peers may eventually score down the malicious peer due to failed data requests, but the metrics corruption occurs immediately upon receiving the first malicious storage summary.

## Recommendation

**Immediate Fix: Add bounds checking before casting to i64** [6](#0-5) 

Replace the unsafe cast with saturating conversion:

```rust
/// Sets the subscription stream lag
pub fn set_subscription_stream_lag(value: u64) {
    // Saturate to i64::MAX instead of wrapping on overflow
    let clamped_value = if value > i64::MAX as u64 {
        i64::MAX
    } else {
        value as i64
    };
    SUBSCRIPTION_STREAM_LAG.set(clamped_value);
}
```

**Longer-term Solutions:**

1. **Use u64 for the metric gauge**: Modify the metric definition to use unsigned gauge if the metrics framework supports it, eliminating the need for casting.

2. **Validate storage summaries**: Add cryptographic validation when receiving storage summaries from peers:
   - Verify ledger info signatures against the current epoch's validator set
   - Implement sanity bounds (e.g., reject versions more than N ahead of local state)
   - Add checksums or commitments to detect tampering

3. **Enhanced peer reputation**: Immediately penalize peers advertising implausible versions that fail validation.

4. **Add overflow alerts**: Even with saturated values, add logging/alerting when lag values approach i64::MAX to detect potential attacks.

## Proof of Concept

```rust
// This PoC demonstrates the integer overflow vulnerability
// File: test_overflow_poc.rs

use aptos_types::ledger_info::{LedgerInfo, LedgerInfoWithSignatures};
use aptos_types::block_info::BlockInfo;
use aptos_storage_service_types::responses::{DataSummary, StorageServerSummary, ProtocolMetadata};

#[test]
fn test_subscription_lag_overflow() {
    // Simulate a malicious peer advertising near u64::MAX version
    let malicious_version: u64 = u64::MAX - 1000;
    
    // Current honest node version (realistic mainnet value)
    let current_version: u64 = 1_000_000_000; // ~1 billion
    
    // Calculate lag as done in check_subscription_stream_lag
    let lag = malicious_version.saturating_sub(current_version);
    
    println!("Malicious advertised version: {}", malicious_version);
    println!("Current version: {}", current_version);
    println!("Calculated lag (u64): {}", lag);
    println!("i64::MAX: {}", i64::MAX);
    println!("Lag > i64::MAX: {}", lag > i64::MAX as u64);
    
    // This is what happens in metrics::set_subscription_stream_lag
    let metric_value = lag as i64;
    
    println!("Metric value after cast (i64): {}", metric_value);
    println!("Is negative: {}", metric_value < 0);
    
    // Assertions demonstrating the bug
    assert!(lag > i64::MAX as u64, "Lag should exceed i64::MAX");
    assert!(metric_value < 0, "Cast should wrap to negative");
    
    // The metric will show a large negative number, hiding the true lag
    println!("\n[VULNERABILITY] Actual lag of {} versions is hidden", lag);
    println!("[VULNERABILITY] Metric shows: {} (negative!)", metric_value);
    println!("[VULNERABILITY] Operators cannot detect the massive sync lag");
}

#[test]
fn test_saturating_fix() {
    let malicious_version: u64 = u64::MAX - 1000;
    let current_version: u64 = 1_000_000_000;
    let lag = malicious_version.saturating_sub(current_version);
    
    // FIXED version: saturate to i64::MAX instead of wrapping
    let metric_value = if lag > i64::MAX as u64 {
        i64::MAX
    } else {
        lag as i64
    };
    
    println!("Fixed metric value: {}", metric_value);
    assert!(metric_value == i64::MAX, "Should saturate to i64::MAX");
    assert!(metric_value > 0, "Should remain positive");
    
    println!("\n[FIXED] Lag is clamped to i64::MAX");
    println!("[FIXED] Operators can still detect massive lag (positive value)");
}
```

**Expected Output:**
```
Malicious advertised version: 18446744073709550615
Current version: 1000000000
Calculated lag (u64): 18446744073708550615
i64::MAX: 9223372036854775807
Lag > i64::MAX: true
Metric value after cast (i64): -9223372037855001001
Is negative: true

[VULNERABILITY] Actual lag of 18446744073708550615 versions is hidden
[VULNERABILITY] Metric shows: -9223372037855001001 (negative!)
[VULNERABILITY] Operators cannot detect the massive sync lag
```

This demonstrates that with realistic parameters, a malicious peer can cause the subscription stream lag metric to wrap to negative values, completely hiding synchronization failures from operators.

### Citations

**File:** state-sync/aptos-data-client/src/poller.rs (L422-439)
```rust
        let storage_summary = match result {
            Ok(storage_summary) => storage_summary,
            Err(error) => {
                warn!(
                    (LogSchema::new(LogEntry::StorageSummaryResponse)
                        .event(LogEvent::PeerPollingError)
                        .message("Error encountered when polling peer!")
                        .error(&error)
                        .peer(&peer))
                );
                return;
            },
        };

        // Update the summary for the peer
        data_summary_poller
            .data_client
            .update_peer_storage_summary(peer, storage_summary);
```

**File:** state-sync/aptos-data-client/src/peer_states.rs (L324-330)
```rust
    /// Updates the storage summary for the given peer
    pub fn update_summary(&self, peer: PeerNetworkId, storage_summary: StorageServerSummary) {
        self.peer_to_state
            .entry(peer)
            .or_insert(PeerState::new(self.data_client_config.clone()))
            .update_storage_summary(storage_summary);
    }
```

**File:** state-sync/aptos-data-client/src/peer_states.rs (L374-378)
```rust
            if let Some(synced_ledger_info) = summary.data_summary.synced_ledger_info.as_ref() {
                advertised_data
                    .synced_ledger_infos
                    .push(synced_ledger_info.clone());
            }
```

**File:** state-sync/aptos-data-client/src/global_summary.rs (L184-198)
```rust
    pub fn highest_synced_ledger_info(&self) -> Option<LedgerInfoWithSignatures> {
        let highest_synced_position = self
            .synced_ledger_infos
            .iter()
            .map(|ledger_info_with_sigs| ledger_info_with_sigs.ledger_info().version())
            .position_max();

        if let Some(highest_synced_position) = highest_synced_position {
            self.synced_ledger_infos
                .get(highest_synced_position)
                .cloned()
        } else {
            None
        }
    }
```

**File:** state-sync/data-streaming-service/src/data_stream.rs (L586-607)
```rust
        // Get the highest advertised version
        let highest_advertised_version = global_data_summary
            .advertised_data
            .highest_synced_ledger_info()
            .map(|ledger_info| ledger_info.ledger_info().version())
            .ok_or_else(|| {
                aptos_data_client::error::Error::UnexpectedErrorEncountered(
                    "The highest synced ledger info is missing from the global data summary!"
                        .into(),
                )
            })?;

        // If the stream is not lagging behind, reset the lag and return
        if highest_response_version >= highest_advertised_version {
            self.reset_subscription_stream_lag();
            return Ok(());
        }

        // Otherwise, the stream is lagging behind the advertised version.
        // Check if the stream is beyond recovery (i.e., has failed).
        let current_stream_lag =
            highest_advertised_version.saturating_sub(highest_response_version);
```

**File:** state-sync/data-streaming-service/src/metrics.rs (L278-281)
```rust
/// Sets the subscription stream lag
pub fn set_subscription_stream_lag(value: u64) {
    SUBSCRIPTION_STREAM_LAG.set(value as i64);
}
```
