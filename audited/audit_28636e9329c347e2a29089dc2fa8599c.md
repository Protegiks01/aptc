# Audit Report

## Title
JWK Consensus Mode Divergence Due to Unsafe Feature Flag Fallback

## Summary
Validators can enter different JWK consensus modes (per-issuer vs per-key) within the same epoch if they experience different outcomes when reading the on-chain Features configuration. This occurs because the JWK consensus epoch manager uses `unwrap_or_default()` when fetching Features, causing validators with database access failures to fall back to default settings that may differ from the on-chain state. This breaks consensus safety by making validators unable to communicate.

## Finding Description

The JWK consensus system can operate in two modes controlled by the `JWK_CONSENSUS_PER_KEY_MODE` feature flag (FeatureFlag #92):
- **Per-Issuer Mode**: Uses `IssuerLevelConsensusManager` and sends `ObservationRequest` messages
- **Per-Key Mode**: Uses `KeyLevelConsensusManager` and sends `KeyLevelObservationRequest` messages [1](#0-0) 

When starting a new epoch, the JWK consensus epoch manager reads the Features configuration with a fallback to default: [2](#0-1) 

The consensus mode is then selected based on whether the feature flag is enabled. The critical issue is that `Features::default()` **enables** the `JWK_CONSENSUS_PER_KEY_MODE` flag: [3](#0-2) 

**Vulnerability Scenario:**

If governance has **disabled** the per-key mode on-chain, but some validators fail to read the Features config (due to database corruption, state sync lag, or missing resources), the following divergence occurs:

1. Validators A, B, C successfully read Features from on-chain state → per-key mode DISABLED → instantiate `IssuerLevelConsensusManager`
2. Validator D fails to read Features (returns Err) → falls back to `Features::default()` → per-key mode ENABLED → instantiates `KeyLevelConsensusManager`

These managers expect incompatible message types: [4](#0-3) [5](#0-4) 

When Validator D (per-key mode) sends `KeyLevelObservationRequest` to Validators A/B/C (per-issuer mode), they reject it with "unexpected rpc". Similarly, when A/B/C send `ObservationRequest` to D, it's rejected. This makes consensus impossible.

## Impact Explanation

This vulnerability constitutes a **Critical Severity** consensus safety violation:

- **Consensus Breakdown**: Validators in the same epoch cannot communicate, preventing any quorum from forming on JWK updates
- **DoS on JWK Consensus**: Keyless accounts cannot update their JWKs, rendering keyless authentication potentially unusable
- **Non-Deterministic Behavior**: The consensus mode depends on database state rather than deterministic on-chain configuration
- **Violates Invariant #1**: "All validators must produce identical state roots for identical blocks" - validators make divergent consensus decisions based on local database state

Per Aptos bug bounty criteria, this is Critical because it causes consensus/safety violations and can lead to non-recoverable network partition for JWK consensus.

## Likelihood Explanation

**Likelihood: LOW to MEDIUM**

While the Features resource is initialized at genesis and should always exist, failures can occur due to:
- Database corruption from storage failures
- Incomplete state sync during epoch transitions
- State pruning bugs that remove critical resources
- Validators joining late with incomplete blockchain history

The impact is amplified because there's no logging or error indication when the fallback occurs - validators silently use different modes without detection.

## Recommendation

Replace the unsafe `unwrap_or_default()` pattern with explicit error handling that fails fast:

```rust
let features = payload
    .get::<Features>()
    .context("Failed to read Features config - critical for consensus mode selection")?;
```

This ensures that if Features cannot be read, the validator fails to start the epoch rather than silently using incorrect default settings. This matches the pattern used for ValidatorSet which is considered mandatory: [6](#0-5) 

Additionally, add defensive logging when consensus mode is selected to aid debugging:

```rust
let per_key_mode_enabled = features.is_enabled(FeatureFlag::JWK_CONSENSUS_PER_KEY_MODE);
info!(
    epoch = epoch_state.epoch,
    per_key_mode = per_key_mode_enabled,
    "Selecting JWK consensus mode"
);
```

## Proof of Concept

```rust
// Simulated test demonstrating mode divergence
#[test]
fn test_consensus_mode_divergence() {
    // Setup: Two validators at the same epoch
    // Validator A reads Features successfully (per-key mode disabled by governance)
    let features_a = Features { features: vec![0; 5] }; // JWK_CONSENSUS_PER_KEY_MODE not set
    
    // Validator B fails to read and falls back to default (per-key mode enabled)
    let features_b = Features::default(); // JWK_CONSENSUS_PER_KEY_MODE IS set (line 261)
    
    assert_ne!(
        features_a.is_enabled(FeatureFlag::JWK_CONSENSUS_PER_KEY_MODE),
        features_b.is_enabled(FeatureFlag::JWK_CONSENSUS_PER_KEY_MODE)
    );
    
    // Result: Validator A uses IssuerLevelConsensusManager
    // Validator B uses KeyLevelConsensusManager
    // They cannot communicate - consensus fails
}
```

To reproduce in production-like environment:
1. Deploy network with JWK_CONSENSUS_PER_KEY_MODE disabled via governance
2. Corrupt one validator's database to remove Features resource at reconfiguration version
3. Trigger epoch transition
4. Observe that corrupted validator selects per-key mode while others select per-issuer mode
5. Verify that JWK consensus messages are rejected as "unexpected rpc"

## Notes

This vulnerability specifically relates to the security question by showing how different effective "implementations" of the consensus protocol (different modes selected based on feature flags) can cause consensus divergence. While the TUpdateCertifier implementation itself is deterministic, the mode selection logic creates a path for divergence through unsafe fallback behavior.

The fix is straightforward: treat Features as a mandatory configuration and fail fast if it cannot be read, ensuring all validators in an epoch make identical consensus mode selections.

### Citations

**File:** crates/aptos-jwk-consensus/src/epoch_manager.rs (L155-157)
```rust
        let validator_set: ValidatorSet = payload
            .get()
            .expect("failed to get ValidatorSet from payload");
```

**File:** crates/aptos-jwk-consensus/src/epoch_manager.rs (L172-172)
```rust
        let features = payload.get::<Features>().unwrap_or_default();
```

**File:** crates/aptos-jwk-consensus/src/epoch_manager.rs (L227-246)
```rust
            let jwk_consensus_manager: Box<dyn TConsensusManager> =
                if features.is_enabled(FeatureFlag::JWK_CONSENSUS_PER_KEY_MODE) {
                    Box::new(KeyLevelConsensusManager::new(
                        Arc::new(my_sk),
                        self.my_addr,
                        epoch_state.clone(),
                        rb,
                        self.vtxn_pool.clone(),
                    ))
                } else {
                    //TODO: move this into IssuerLevelConsensusManager construction?
                    let update_certifier = UpdateCertifier::new(rb);
                    Box::new(IssuerLevelConsensusManager::new(
                        Arc::new(my_sk),
                        self.my_addr,
                        epoch_state.clone(),
                        Arc::new(update_certifier),
                        self.vtxn_pool.clone(),
                    ))
                };
```

**File:** types/src/on_chain_config/aptos_features.rs (L260-262)
```rust
            FeatureFlag::DEFAULT_ACCOUNT_RESOURCE,
            FeatureFlag::JWK_CONSENSUS_PER_KEY_MODE,
            FeatureFlag::TRANSACTION_PAYLOAD_V2,
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager/mod.rs (L300-319)
```rust
        match msg {
            JWKConsensusMsg::ObservationRequest(request) => {
                let state = self.states_by_issuer.entry(request.issuer).or_default();
                let response: Result<JWKConsensusMsg> = match &state.consensus_state {
                    ConsensusState::NotStarted => Err(anyhow!("observed update unavailable")),
                    ConsensusState::InProgress { my_proposal, .. }
                    | ConsensusState::Finished { my_proposal, .. } => Ok(
                        JWKConsensusMsg::ObservationResponse(ObservedUpdateResponse {
                            epoch: self.epoch_state.epoch,
                            update: my_proposal.clone(),
                        }),
                    ),
                };
                response_sender.send(response);
                Ok(())
            },
            _ => {
                bail!("unexpected rpc: {}", msg.name());
            },
        }
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager_per_key.rs (L271-308)
```rust
        match msg {
            JWKConsensusMsg::KeyLevelObservationRequest(request) => {
                let ObservedKeyLevelUpdateRequest { issuer, kid, .. } = request;
                let consensus_state = self
                    .states_by_key
                    .entry((issuer.clone(), kid.clone()))
                    .or_default();
                let response: Result<JWKConsensusMsg> = match &consensus_state {
                    ConsensusState::NotStarted => {
                        debug!(
                            issuer = String::from_utf8(issuer.clone()).ok(),
                            kid = String::from_utf8(kid.clone()).ok(),
                            "key-level jwk consensus not started"
                        );
                        return Ok(());
                    },
                    ConsensusState::InProgress { my_proposal, .. }
                    | ConsensusState::Finished { my_proposal, .. } => Ok(
                        JWKConsensusMsg::ObservationResponse(ObservedUpdateResponse {
                            epoch: self.epoch_state.epoch,
                            update: ObservedUpdate {
                                author: self.my_addr,
                                observed: my_proposal
                                    .observed
                                    .try_as_issuer_level_repr()
                                    .context("process_peer_request failed with repr conversion")?,
                                signature: my_proposal.signature.clone(),
                            },
                        }),
                    ),
                };
                response_sender.send(response);
                Ok(())
            },
            _ => {
                bail!("unexpected rpc: {}", msg.name());
            },
        }
```
