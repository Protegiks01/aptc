# Audit Report

## Title
Multisig Account State Corruption Due to Unhandled Cleanup Failure

## Summary
The `failure_multisig_payload_cleanup()` function in the Aptos VM lacks proper error recovery when the cleanup process fails. If the Move-based cleanup function encounters an error, the multisig account is left in a corrupted state where the failed transaction remains in the pending queue and the sequence number is not incremented, effectively causing a permanent denial-of-service on the multisig account.

## Finding Description

When a multisig transaction execution fails, the system invokes `failure_multisig_payload_cleanup()` to perform critical state maintenance: [1](#0-0) 

This cleanup function is responsible for invoking the Move-based `failed_transaction_execution_cleanup` function: [2](#0-1) 

The Move cleanup function performs critical state updates: [3](#0-2) 

The cleanup removes the failed transaction from the pending queue and increments `last_executed_sequence_number`: [4](#0-3) 

**The Vulnerability**: If the cleanup function fails (returns an error), the `?` operator at line 1321 of `aptos_vm.rs` propagates the error upward. The error passes through generic failure handling that has no knowledge of multisig-specific state requirements: [5](#0-4) 

When this happens:
1. The failed transaction is NOT removed from the pending transactions table
2. The `last_executed_sequence_number` is NOT incremented
3. All future multisig transactions are blocked because they must execute in order (sequence_number == last_resolved_sequence_number + 1)
4. The multisig account enters a deadlock state

While manual recovery is theoretically possible via the rejection mechanism, it requires coordinated owner action: [6](#0-5) 

## Impact Explanation

This vulnerability qualifies as **Medium severity** under the Aptos bug bounty program criteria:
- **State inconsistencies requiring intervention**: The multisig account state becomes corrupted with the failed transaction stuck in the queue
- **Limited funds manipulation**: Funds in the multisig account become temporarily inaccessible until manual intervention occurs
- **Denial of Service**: All multisig account functionality is blocked until owners coordinate to reject the stuck transaction

The impact includes:
- Immediate DOS on all multisig account operations
- Temporary freeze of funds controlled by the multisig account
- Requires manual coordination of owners to vote for rejection and execute `execute_rejected_transaction()`
- No automatic recovery mechanism exists in the code path

## Likelihood Explanation

**Likelihood: Low to Medium**

The cleanup function uses `UnmeteredGasMeter`, eliminating gas exhaustion as a trigger. However, cleanup could still fail due to:

1. **Move VM execution errors**: Unexpected runtime conditions, assertion failures in system code
2. **State corruption**: Pre-existing inconsistencies in multisig account state
3. **Resource constraints**: Memory limits, stack depth issues (though unlikely with unmetered gas)
4. **Module loading failures**: Issues with the multisig_account module itself

While intentional exploitation is difficult, the lack of defensive error handling means any unexpected failure condition leaves the system in an unrecoverable state. The severity is compounded by the "all-or-nothing" principle violation: state transitions should be atomic, but here we have partial failure states.

## Recommendation

Implement robust error handling for cleanup failures with fallback mechanisms:

```rust
let epilogue_session = match execution_result {
    Err(execution_error) => {
        // Attempt cleanup with error recovery
        match self.failure_multisig_payload_cleanup(
            resolver,
            module_storage,
            prologue_session_change_set,
            execution_error.clone(),
            txn_data,
            cleanup_args,
            traversal_context,
        ) {
            Ok(session) => session,
            Err(cleanup_error) => {
                // Log the cleanup failure
                alert!(
                    *log_context,
                    "Multisig cleanup failed: {:?}. Original error: {:?}",
                    cleanup_error,
                    execution_error
                );
                
                // Return standard failure epilogue without multisig-specific cleanup
                // This ensures the transaction is still processed (gas charged, etc.)
                // while marking the multisig account state as requiring manual intervention
                return self.on_user_transaction_execution_failure(
                    prologue_session_change_set.clone(),
                    cleanup_error,
                    resolver,
                    module_storage,
                    serialized_signers,
                    txn_data,
                    log_context,
                    gas_meter,
                    change_set_configs,
                    traversal_context,
                );
            }
        }
    },
    // ... rest of the code
};
```

Additionally, consider implementing:
1. A recovery function in the multisig_account module that allows emergency state reset
2. Automated monitoring and alerting for stuck multisig accounts
3. Defensive checks before cleanup to validate state consistency

## Proof of Concept

Due to the defensive nature of this vulnerability (requires forcing cleanup to fail), a complete PoC requires either:

1. **Integration test with failure injection**:
```rust
#[test]
fn test_multisig_cleanup_failure_leaves_corrupted_state() {
    // Setup multisig account with transaction
    // Execute transaction that fails
    // Mock cleanup function to return error
    // Verify: transaction still in pending queue
    // Verify: last_executed_sequence_number not incremented
    // Verify: subsequent transactions blocked
}
```

2. **Manual reproduction** (theoretical):
    - Create a multisig account with a transaction that will abort
    - Introduce a transient error condition during cleanup (e.g., resource exhaustion)
    - Observe the multisig account becomes unresponsive to new transactions
    - Verify recovery requires manual rejection votes

The vulnerability's validity rests on the code's lack of error recovery rather than a specific exploit vector, making it a **defensive programming issue with real security impact**.

## Notes

While this vulnerability has clear code-level evidence and definite impact, its exploitability is constrained by the difficulty of forcing cleanup failures. The cleanup uses `UnmeteredGasMeter` and performs simple operations that should rarely fail. However, the **complete absence of error recovery mechanisms** means any failure—however unlikely—results in permanent multisig account corruption without automatic recovery.

This represents a violation of the "State Consistency" invariant: state transitions should be atomic and properly handled even in exceptional circumstances. The current implementation has a critical gap between ideal behavior and edge case handling.

### Citations

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1312-1321)
```rust
        let epilogue_session = match execution_result {
            Err(execution_error) => self.failure_multisig_payload_cleanup(
                resolver,
                module_storage,
                prologue_session_change_set,
                execution_error,
                txn_data,
                cleanup_args,
                traversal_context,
            )?,
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1427-1439)
```rust
        epilogue_session.execute(|session| {
            session
                .execute_function_bypass_visibility(
                    &MULTISIG_ACCOUNT_MODULE,
                    FAILED_TRANSACTION_EXECUTION_CLEANUP,
                    vec![],
                    cleanup_args,
                    &mut UnmeteredGasMeter,
                    traversal_context,
                    module_storage,
                )
                .map_err(|e| e.into_vm_status())
        })?;
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L2105-2118)
```rust
        let (vm_status, mut output) = result.unwrap_or_else(|err| {
            self.on_user_transaction_execution_failure(
                prologue_change_set,
                err,
                resolver,
                code_storage,
                &serialized_signers,
                &txn_data,
                log_context,
                gas_meter,
                change_set_configs,
                &mut traversal_context,
            )
        });
```

**File:** aptos-move/framework/aptos-framework/sources/multisig_account.move (L1075-1117)
```text
    public entry fun execute_rejected_transaction(
        owner: &signer,
        multisig_account: address,
    ) acquires MultisigAccount {
        assert_multisig_account_exists(multisig_account);
        assert_is_owner(owner, multisig_account);

        let sequence_number = last_resolved_sequence_number(multisig_account) + 1;
        let owner_addr = address_of(owner);
        if (features::multisig_v2_enhancement_feature_enabled()) {
            // Implicitly vote for rejection if the owner has not voted for rejection yet.
            if (!has_voted_for_rejection(multisig_account, sequence_number, owner_addr)) {
                reject_transaction(owner, multisig_account, sequence_number);
            }
        };

        let multisig_account_resource = borrow_global_mut<MultisigAccount>(multisig_account);
        let (_, num_rejections) = remove_executed_transaction(multisig_account_resource);
        assert!(
            num_rejections >= multisig_account_resource.num_signatures_required,
            error::invalid_state(ENOT_ENOUGH_REJECTIONS),
        );

        if (std::features::module_event_migration_enabled()) {
            emit(
                ExecuteRejectedTransaction {
                    multisig_account,
                    sequence_number,
                    num_rejections,
                    executor: address_of(owner),
                }
            );
        } else {
            emit_event(
                &mut multisig_account_resource.execute_rejected_transaction_events,
                ExecuteRejectedTransactionEvent {
                    sequence_number,
                    num_rejections,
                    executor: owner_addr,
                }
            );
        };
    }
```

**File:** aptos-move/framework/aptos-framework/sources/multisig_account.move (L1219-1250)
```text
    fun failed_transaction_execution_cleanup(
        executor: address,
        multisig_account: address,
        transaction_payload: vector<u8>,
        execution_error: ExecutionError,
    ) acquires MultisigAccount {
        let num_approvals = transaction_execution_cleanup_common(executor, multisig_account);
        let multisig_account_resource = borrow_global_mut<MultisigAccount>(multisig_account);
        if (std::features::module_event_migration_enabled()) {
            emit(
                TransactionExecutionFailed {
                    multisig_account,
                    executor,
                    sequence_number: multisig_account_resource.last_executed_sequence_number,
                    transaction_payload,
                    num_approvals,
                    execution_error,
                }
            );
        } else {
            emit_event(
                &mut multisig_account_resource.transaction_execution_failed_events,
                TransactionExecutionFailedEvent {
                    executor,
                    sequence_number: multisig_account_resource.last_executed_sequence_number,
                    transaction_payload,
                    num_approvals,
                    execution_error,
                }
            );
        };
    }
```

**File:** aptos-move/framework/aptos-framework/sources/multisig_account.move (L1288-1293)
```text
    fun remove_executed_transaction(multisig_account_resource: &mut MultisigAccount): (u64, u64) {
        let sequence_number = multisig_account_resource.last_executed_sequence_number + 1;
        let transaction = table::remove(&mut multisig_account_resource.transactions, sequence_number);
        multisig_account_resource.last_executed_sequence_number = sequence_number;
        num_approvals_and_rejections_internal(&multisig_account_resource.owners, &transaction)
    }
```
