# Audit Report

## Title
Critical Authentication Bypass in Database Bootstrap Process Allows Malicious State Injection via Attacker-Controlled Storage Backends

## Summary
The database bootstrap process in `restore.rs` allows initialization from attacker-controlled storage backends without proper cryptographic validation of the authenticity of ledger data. Two critical bypasses exist: (1) the `--skip-epoch-endings` flag disables all validator signature verification, and (2) state snapshots from epochs beyond the loaded epoch history bypass verification with only a warning, enabling complete database corruption. [1](#0-0) 

## Finding Description

The vulnerability exists in the database restoration flow where storage backends are initialized without validating that the data source is trustworthy. The attack chain works as follows:

**Primary Attack Vector - Epoch History Bypass:**

1. The `RestoreCoordinator` loads epoch history from the backup storage to verify ledger authenticity. [2](#0-1) 

2. When restoring state snapshots, the system attempts to verify the `LedgerInfoWithSignatures` against the epoch history. [3](#0-2) 

3. **Critical Flaw**: If the snapshot's epoch exceeds the epoch history coverage, verification is bypassed entirely with only a warning: [4](#0-3) 

4. The verification flow only checks internal consistency (transaction info matches ledger info, chunks match root hash) but never validates the `LedgerInfoWithSignatures` itself contains legitimate validator signatures: [5](#0-4) 

**Secondary Attack Vector - Debug Flag Abuse:**

When operators use the `--skip-epoch-endings` flag (documented as "for debugging"), the epoch history is never loaded, causing all cryptographic verification to be skipped: [6](#0-5) 

**Exploitation Scenario:**

An attacker who controls or compromises a backup storage backend can:
1. Serve legitimate epoch ending backups up to epoch N
2. Craft a fake `LedgerInfoWithSignatures` with arbitrary state root for epoch M > N
3. Generate consistent but fake `TransactionInfoWithProof` and `SparseMerkleRangeProof` data
4. Serve this malicious state snapshot through the storage backend
5. The node accepts this data because the verification at line 279-287 returns `Ok(())` after the epoch check fails
6. The corrupted state is committed to the database with arbitrary balances, validator sets, and smart contract state

This breaks the **State Consistency** and **Cryptographic Correctness** invariants, as the system accepts data without proper validator signature verification.

## Impact Explanation

**Severity: CRITICAL** (per Aptos Bug Bounty criteria)

This vulnerability enables multiple critical attack scenarios:

1. **Consensus Safety Violation**: A node restored with fake state will disagree with honest nodes on the chain state, potentially causing consensus failures or chain splits.

2. **Loss of Funds**: The attacker can craft state with arbitrary account balances, enabling theft or minting of tokens when the node processes transactions based on this corrupted state.

3. **Validator Set Manipulation**: The fake state could contain a malicious validator set, compromising the network's security model.

4. **Non-Recoverable State Corruption**: Once the fake state is committed to the database, the node cannot distinguish it from legitimate data without re-syncing from a trusted source, effectively requiring a manual intervention or hard fork recovery.

5. **Complete Node Compromise**: The node becomes an unreliable participant in the network, potentially propagating incorrect state to other nodes or accepting invalid transactions.

The impact extends to all operators performing database restoration, which is a common operation for:
- Disaster recovery scenarios
- Node migration to new hardware
- Validator onboarding from snapshots
- Archive node synchronization

## Likelihood Explanation

**Likelihood: MEDIUM to HIGH**

The attack is feasible in realistic operational scenarios:

1. **Backup Source Compromise**: Cloud storage buckets (S3, GCS, Azure Blob) used for backups can be compromised through credential theft, misconfiguration, or supply chain attacks.

2. **Third-Party Backup Services**: Operators might use untrusted or compromised third-party backup services to reduce operational costs.

3. **Disaster Recovery Context**: During emergency situations, operators may restore from the most readily available backup source without thoroughly vetting its authenticity.

4. **Epoch History Limitation**: The epoch-too-new bypass (lines 279-287) affects normal operations because epoch history is often pruned or incomplete, making it easy for an attacker to serve snapshots from epochs just beyond the available history.

5. **Incremental Data Serving**: The storage backend API allows serving data incrementally through streaming interfaces, enabling sophisticated attacks that appear legitimate during initial validation.

The warning message at line 283-286 suggests this is a known issue that has not been fully addressed ("TODO(aldenhu): fix this from upper level").

## Recommendation

**Immediate Fixes:**

1. **Mandatory Epoch History Verification**: Remove the `--skip-epoch-endings` flag or make it a compile-time testing feature only. Epoch history verification must be mandatory for production restores.

2. **Reject Incomplete Epoch History**: Change the verification logic to reject state snapshots from epochs not covered by the loaded epoch history instead of bypassing with a warning: [4](#0-3) 

**Recommended fix**: Replace `return Ok(())` with `bail!("Cannot verify LedgerInfo from epoch {} - epoch history only covers up to epoch {}. Refusing to restore potentially malicious data.", epoch, self.epoch_endings.len())`

3. **Trusted Waypoint Enforcement**: Require operators to provide at least one trusted waypoint for the target restoration version via the `--trust-waypoint` flag, and validate that the restored state matches this waypoint.

4. **Storage Backend Authentication**: Add cryptographic signing of backup metadata by the backup creator, verified against a trusted public key during restoration.

5. **Chain ID Verification**: Validate that all restored data corresponds to the expected chain ID to prevent cross-chain backup attacks.

**Long-Term Improvements:**

1. Implement a backup attestation system where validators sign backup metadata, similar to how they sign blocks.
2. Add a two-phase restore process: first verify all cryptographic proofs, then commit to database only if all validations pass.
3. Create a manifest of expected checksums for backup files that can be independently verified.

## Proof of Concept

**Conceptual PoC Steps (Rust test scenario):**

```
1. Setup malicious CommandAdapter storage backend:
   - Configure command_adapter config pointing to attacker-controlled scripts
   - Scripts serve fake metadata, epoch endings (epochs 0-100), and state snapshot (epoch 200)

2. Create fake LedgerInfoWithSignatures:
   - Generate arbitrary state_root_hash
   - Create TransactionInfo with this state root
   - Create fake but internally-consistent TransactionAccumulatorProof
   - Skip validator signatures or use fake validator set

3. Generate consistent fake state snapshot:
   - Create StateSnapshotBackup manifest with fake root_hash
   - Generate SparseMerkleRangeProof that validates against the fake root
   - Craft state chunks with arbitrary account balances

4. Execute restore:
   aptos-db-tool restore bootstrap-db \
     --command-adapter-config /path/to/malicious/config.yaml \
     --target-db-dir /tmp/corrupted-db \
     --target-version 1000000

5. Verify exploitation:
   - Check that database contains the fake state
   - Confirm that accounts have attacker-specified balances
   - Demonstrate that node would disagree with honest nodes on state queries
```

**Expected Result**: The restore completes successfully despite serving completely fabricated state data, because the epoch-too-new check at line 279-287 returns `Ok(())` with only a warning, and no validator signature verification occurs.

**Verification**: Query the restored database for state that differs from the canonical chain, proving that fake data was accepted without proper cryptographic validation.

## Notes

This vulnerability is particularly insidious because:

1. The code comment at lines 283-286 acknowledges the issue but relies on the assumption that "node won't be able to start if this data is malicious" - however, a sophisticated attacker can craft state that appears valid enough for the node to start while still being malicious (e.g., incorrect balances).

2. The `--trust-waypoint` option exists but is documented as not applying to state snapshot restoration (line 341-343 of utils/mod.rs), providing a false sense of security.

3. The circular validation logic (TransactionInfo proves against LedgerInfo, chunks prove against root hash, but LedgerInfo itself is never proven) creates a complete authentication bypass when epoch history is insufficient.

This represents a fundamental trust boundary violation in the backup/restore system that must be addressed before operators can safely restore databases from potentially untrusted sources.

### Citations

**File:** storage/db-tool/src/restore.rs (L114-122)
```rust
            Command::BootstrapDB(bootstrap) => {
                RestoreCoordinator::new(
                    bootstrap.opt,
                    bootstrap.global.try_into()?,
                    bootstrap.storage.init_storage().await?,
                )
                .run()
                .await?;
            },
```

**File:** storage/backup/backup-cli/src/coordinators/restore.rs (L42-43)
```rust
    #[clap(long, help = "Skip restoring epoch ending info, used for debugging.")]
    pub skip_epoch_endings: bool,
```

**File:** storage/backup/backup-cli/src/coordinators/restore.rs (L219-231)
```rust
        let epoch_history = if !self.skip_epoch_endings {
            Some(Arc::new(
                EpochHistoryRestoreController::new(
                    epoch_handles,
                    self.global_opt.clone(),
                    self.storage.clone(),
                )
                .run()
                .await?,
            ))
        } else {
            None
        };
```

**File:** storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs (L137-139)
```rust
        if let Some(epoch_history) = self.epoch_history.as_ref() {
            epoch_history.verify_ledger_info(&li)?;
        }
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L279-288)
```rust
        if epoch > self.epoch_endings.len() as u64 {
            // TODO(aldenhu): fix this from upper level
            warn!(
                epoch = epoch,
                epoch_history_until = self.epoch_endings.len(),
                "Epoch is too new and can't be verified. Previous chunks are verified and node \
                won't be able to start if this data is malicious."
            );
            return Ok(());
        }
```

**File:** types/src/proof/mod.rs (L40-60)
```rust
fn verify_transaction_info(
    ledger_info: &LedgerInfo,
    transaction_version: Version,
    transaction_info: &TransactionInfo,
    ledger_info_to_transaction_info_proof: &TransactionAccumulatorProof,
) -> Result<()> {
    ensure!(
        transaction_version <= ledger_info.version(),
        "Transaction version {} is newer than LedgerInfo version {}.",
        transaction_version,
        ledger_info.version(),
    );

    let transaction_info_hash = transaction_info.hash();
    ledger_info_to_transaction_info_proof.verify(
        ledger_info.transaction_accumulator_hash(),
        transaction_info_hash,
        transaction_version,
    )?;

    Ok(())
```
