# Audit Report

## Title
Token v1 Description Mutation Enables Unbounded Event Spam Attack on Indexers and APIs

## Summary
The Token v1 `mutate_tokendata_description` function lacks description length validation, allowing attackers to emit arbitrarily large `DescriptionMutate` events (containing both old and new descriptions up to transaction size limits). An attacker can repeatedly mutate token descriptions with maximum-size strings (~30KB each), generating events containing ~60KB of data per transaction. This overwhelms indexer processing pipelines, exhausts database storage, and causes API crashes or timeouts.

## Finding Description
Token v1 (`aptos_token::token`) defines maximum lengths for collection names (128 bytes), NFT names (128 bytes), and URIs (512 bytes), but **does not define or enforce any maximum for description fields**. [1](#0-0) 

In contrast, Token v2 (`aptos_token_objects::token`) defines and enforces a `MAX_DESCRIPTION_LENGTH` of 2048 bytes: [2](#0-1) 

Token v2's `set_description` function validates this limit: [3](#0-2) 

However, Token v1's `mutate_tokendata_description` function performs **no length validation whatsoever**: [4](#0-3) 

Each call to this function emits a `DescriptionMutate` event containing both the old and new description strings via `emit_token_descrition_mutate_event`: [5](#0-4) 

The event structure stores both descriptions in full: [6](#0-5) 

**Attack Path:**
1. Attacker creates a token collection with `mutability_config.description = true`
2. Attacker creates a token with a description of ~30KB (staying under the 64KB transaction size limit)
3. Attacker calls `mutate_tokendata_description` with a new ~30KB description
4. The emitted `DescriptionMutate` event contains ~60KB of data (old_description + new_description)
5. Attacker repeats step 3 in millions of separate transactions, alternating between two large descriptions

While gas is charged proportionally to event size (based on `legacy_abstract_memory_size`), this does not prevent the attackâ€”the attacker simply pays the gas cost while causing infrastructure damage: [7](#0-6) 

The transaction size limit of 64KB per transaction does not mitigate this issue, as attackers can submit unlimited transactions: [8](#0-7) 

**Invariant Violation:**
This breaks **Invariant #9: Resource Limits** - "All operations must respect gas, storage, and computational limits." While gas is charged, the lack of description length validation allows unbounded storage consumption in event databases and computational load on indexers/APIs, violating the principle that resource usage should be bounded and reasonable.

## Impact Explanation
This vulnerability qualifies as **High Severity** under the Aptos Bug Bounty program criteria: "API crashes, Validator node slowdowns, Significant protocol violations."

**Specific Impacts:**
1. **Indexer Overload**: Indexers must deserialize, process, and store these massive events in PostgreSQL or RocksDB. Events containing 60KB of description data (compared to the Token v2 limit of 4KB maximum) cause:
   - Database storage exhaustion (millions of 60KB events = tens of GB)
   - Query performance degradation
   - Processing pipeline slowdowns

2. **API Crashes**: APIs that fetch and return event data must:
   - Deserialize large event payloads from storage
   - Transmit them over network connections
   - Hold them in memory during processing
   This leads to memory exhaustion, timeouts, and service crashes.

3. **Network and Storage Strain**: Full nodes must propagate and store these events, consuming excessive bandwidth and disk space compared to legitimate usage patterns.

The attack does not directly impact consensus (events are post-execution artifacts), but critically compromises the infrastructure that users and applications depend on for querying blockchain state.

## Likelihood Explanation
**Likelihood: High**

The attack is trivial to execute:
- **Low Barrier**: Any user can create tokens with mutable descriptions
- **Low Cost**: Gas costs scale with event size, but storage/indexer damage exceeds gas paid
- **High Scalability**: Attacker can automate millions of transactions
- **No Rate Limiting**: No per-account or per-token rate limits on mutations
- **Clear Asymmetry**: Token v2 has a 2048-byte limit, demonstrating this was an oversight in Token v1 that attackers can exploit

## Recommendation
Add description length validation to Token v1, consistent with Token v2's approach:

```move
// In aptos-move/framework/aptos-token/sources/token.move

// Add constant (around line 35)
const MAX_DESCRIPTION_LENGTH: u64 = 2048;

// Add error code (around line 153)
const EDESCRIPTION_TOO_LONG: u64 = 41;

// Modify mutate_tokendata_description (line 852)
public fun mutate_tokendata_description(
    creator: &signer, 
    token_data_id: TokenDataId, 
    description: String
) acquires Collections {
    assert!(
        description.length() <= MAX_DESCRIPTION_LENGTH, 
        error::out_of_range(EDESCRIPTION_TOO_LONG)
    );
    assert_tokendata_exists(creator, token_data_id);
    
    let all_token_data = &mut Collections[token_data_id.creator].token_data;
    let token_data = all_token_data.borrow_mut(token_data_id);
    assert!(token_data.mutability_config.description, error::permission_denied(EFIELD_NOT_MUTABLE));
    token_event_store::emit_token_descrition_mutate_event(
        creator, 
        token_data_id.collection, 
        token_data_id.name, 
        token_data.description, 
        description
    );
    token_data.description = description;
}

// Also add validation to mutate_collection_description (line 766)
public fun mutate_collection_description(
    creator: &signer, 
    collection_name: String, 
    description: String
) acquires Collections {
    assert!(
        description.length() <= MAX_DESCRIPTION_LENGTH,
        error::out_of_range(EDESCRIPTION_TOO_LONG)
    );
    // ... rest of function
}
```

This aligns Token v1 with Token v2's security posture and prevents the event spam attack.

## Proof of Concept

```move
#[test_only]
module test_addr::description_spam_poc {
    use aptos_token::token;
    use std::string::{Self, String};
    use std::signer;
    use std::vector;

    #[test(creator = @0xCAFE)]
    fun test_unbounded_description_mutation(creator: &signer) {
        // Initialize token collections
        token::initialize_token_store(creator);
        
        // Create collection with mutable descriptions
        token::create_collection(
            creator,
            string::utf8(b"Test Collection"),
            string::utf8(b"Description"),
            string::utf8(b"https://example.com"),
            1000,
            vector[true, true, true] // All fields mutable
        );

        // Create a large description string (~30KB)
        let large_desc = build_large_string(30000);
        
        // Create token with large description
        let token_id = token::create_tokendata(
            creator,
            string::utf8(b"Test Collection"),
            string::utf8(b"Token 1"),
            large_desc, // No length validation!
            1,
            string::utf8(b"https://example.com"),
            signer::address_of(creator),
            100, 100,
            token::create_token_mutability_config(&vector[true, true, true, true, true]),
            vector[], vector[], vector[]
        );

        // Mutate description repeatedly with different large strings
        // Each mutation emits ~60KB event (old + new description)
        let another_large_desc = build_large_string(30000);
        token::mutate_tokendata_description(
            creator,
            token_id,
            another_large_desc // Still no length validation!
        );
        
        // Attacker would repeat this millions of times
        // Event spam overwhelms indexers and APIs
    }

    fun build_large_string(size: u64): String {
        let bytes = vector::empty<u8>();
        let i = 0;
        while (i < size) {
            vector::push_back(&mut bytes, 65); // 'A'
            i = i + 1;
        };
        string::utf8(bytes)
    }
}
```

**Expected Result**: The test should compile and execute, demonstrating that Token v1 accepts arbitrarily large descriptions without validation. In production, an attacker would submit this pattern across millions of transactions to overwhelm infrastructure.

**Notes**
- This vulnerability exists only in Token v1 (`aptos_token::token` at address `0x3`)
- Token v2 (`aptos_token_objects::token` at address `0x4`) is **not vulnerable** due to its `MAX_DESCRIPTION_LENGTH` enforcement
- The inconsistency between v1 and v2 implementations confirms this is an oversight rather than intentional design
- While collection description mutations have the same issue, token descriptions are more easily spammable (unlimited tokens per collection vs. limited collections per account)
- Event storage fees were reduced to zero in gas version 14+, making the attack even cheaper

### Citations

**File:** aptos-move/framework/aptos-token/sources/token.move (L32-34)
```text
    const MAX_COLLECTION_NAME_LENGTH: u64 = 128;
    const MAX_NFT_NAME_LENGTH: u64 = 128;
    const MAX_URI_LENGTH: u64 = 512;
```

**File:** aptos-move/framework/aptos-token/sources/token.move (L852-860)
```text
    public fun mutate_tokendata_description(creator: &signer, token_data_id: TokenDataId, description: String) acquires Collections {
        assert_tokendata_exists(creator, token_data_id);

        let all_token_data = &mut Collections[token_data_id.creator].token_data;
        let token_data = all_token_data.borrow_mut(token_data_id);
        assert!(token_data.mutability_config.description, error::permission_denied(EFIELD_NOT_MUTABLE));
        token_event_store::emit_token_descrition_mutate_event(creator, token_data_id.collection, token_data_id.name, token_data.description, description);
        token_data.description = description;
    }
```

**File:** aptos-move/framework/aptos-token-objects/sources/token.move (L44-44)
```text
    const MAX_DESCRIPTION_LENGTH: u64 = 2048;
```

**File:** aptos-move/framework/aptos-token-objects/sources/token.move (L774-775)
```text
    public fun set_description(mutator_ref: &MutatorRef, description: String) acquires Token {
        assert!(description.length() <= MAX_DESCRIPTION_LENGTH, error::out_of_range(EDESCRIPTION_TOO_LONG));
```

**File:** aptos-move/framework/aptos-token/sources/token_event_store.move (L142-150)
```text
    #[event]
    /// Event emitted when the tokendata description is mutated
    struct DescriptionMutate has drop, store {
        creator: address,
        collection: String,
        token: String,
        old_description: String,
        new_description: String,
    }
```

**File:** aptos-move/framework/aptos-token/sources/token_event_store.move (L412-446)
```text
    friend fun emit_token_descrition_mutate_event(
        creator: &signer,
        collection: String,
        token: String,
        old_description: String,
        new_description: String,
    ) acquires TokenEventStoreV1 {
        let creator_addr = signer::address_of(creator);

        let event = DescriptionMutateEvent {
            creator: creator_addr,
            collection,
            token,
            old_description,
            new_description,
        };

        initialize_token_event_store(creator);
        let token_event_store = &mut TokenEventStoreV1[creator_addr];
        if (std::features::module_event_migration_enabled()) {
            event::emit(
                DescriptionMutate {
                    creator: creator_addr,
                    collection,
                    token,
                    old_description,
                    new_description,
                });
        } else {
            event::emit_event<DescriptionMutateEvent>(
                &mut token_event_store.description_mutate_events,
                event,
            );
        };
    }
```

**File:** third_party/move/move-stdlib/src/natives/event.rs (L28-41)
```rust
fn native_write_to_event_store(
    gas_params: &WriteToEventStoreGasParameters,
    _context: &mut NativeContext,
    ty_args: &[Type],
    mut arguments: VecDeque<Value>,
) -> PartialVMResult<NativeResult> {
    debug_assert!(ty_args.len() == 1);
    debug_assert!(arguments.len() == 3);

    let msg = arguments.pop_back().unwrap();
    let cost = gas_params.unit_cost * std::cmp::max(msg.legacy_abstract_memory_size(), 1.into());

    Ok(NativeResult::ok(cost, smallvec![]))
}
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L73-76)
```rust
            max_transaction_size_in_bytes: NumBytes,
            "max_transaction_size_in_bytes",
            64 * 1024
        ],
```
