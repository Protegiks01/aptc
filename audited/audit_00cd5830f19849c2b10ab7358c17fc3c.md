# Audit Report

## Title
Unvalidated Source Code in Package Metadata Enables Misleading Auditors and Analysis Tools

## Summary
The Aptos package publishing mechanism does not validate that the source code stored in `PackageMetadata.modules[].source` matches the actual bytecode being published. An attacker can publish legitimate bytecode while including arbitrary, misleading source code in the package metadata, which will be retrieved and displayed by debugging tools and analysis interfaces without any indication of the discrepancy.

## Finding Description

When a Move package is published via `publish_package_txn`, two distinct pieces of data are provided: [1](#0-0) 

The `metadata_serialized` parameter contains `PackageMetadata`, which includes the `modules` vector with source code for each module: [2](#0-1) 

The source code in `ModuleMetadata.source` is stored as gzipped text and is explicitly stated as "Empty if not provided," indicating it's optional metadata. However, when provided, there is **no validation** that this source code matches the actual compiled bytecode in the `code` parameter.

The `publish_package` function stores the metadata directly into the `PackageRegistry`: [3](#0-2) 

The actual bytecode validation occurs in a separate native function call that does not receive or validate the source code: [4](#0-3) 

The native implementation creates a `PublishRequest` with only the bytecode bundle, completely ignoring the source code from metadata: [5](#0-4) 

The VM's validation function performs comprehensive checks but never validates source code authenticity: [6](#0-5) 

The metadata validation specifically checks attributes but not source code content: [7](#0-6) 

When debugging tools retrieve source code via `retrieve_available_src()`, they fetch this unvalidated metadata: [8](#0-7) 

This retrieved source code is then used by debugging and analysis tools: [9](#0-8) 

**Attack Scenario:**
1. Attacker compiles legitimate, benign Move source code to bytecode
2. Attacker crafts malicious source code containing hidden vulnerabilities or backdoors
3. Attacker includes the malicious source in `PackageMetadata.modules[].source`
4. Attacker publishes the package with legitimate bytecode but malicious source metadata
5. The package is accepted and stored on-chain
6. Auditors reviewing the source via REST API or debugging tools see the malicious source
7. The malicious source appears to match what's on-chain, misleading security reviews
8. The actual bytecode executes the benign logic while auditors believe they reviewed the malicious version

## Impact Explanation

This vulnerability falls under **Medium Severity** per Aptos bug bounty criteria for the following reasons:

1. **State Inconsistencies**: The on-chain state contains unverified metadata that does not correspond to the executable code, creating a discrepancy between what auditors see and what executes.

2. **Indirect Security Impact**: While this doesn't directly compromise consensus or steal funds, it undermines the security audit process. Auditors and analysis tools that rely on the on-chain source code will be reviewing incorrect code, potentially missing real vulnerabilities in the actual bytecode or being misled about backdoors.

3. **Breaks Trust Assumptions**: The system stores source code as if it's been verified and trustworthy, but provides no mechanism to detect discrepancies. Tools and auditors may reasonably assume that on-chain source code corresponds to published bytecode.

4. **No Mitigation Available**: Users have no way to detect this attack through the standard interfaces - the REST API returns the fake source code with no warnings or validation status.

## Likelihood Explanation

This vulnerability has **HIGH likelihood** of exploitation:

1. **Low Barrier to Entry**: Any user with package publishing permissions can exploit this - no special access or validator privileges required

2. **No Detection Mechanism**: There is no on-chain or off-chain mechanism to detect when source code doesn't match bytecode

3. **Plausible Attack Motivation**: Attackers could use this to:
   - Hide backdoors during security audits
   - Make malicious contracts appear safe to increase adoption
   - Confuse incident response by providing misleading source during exploit investigations
   - Manipulate code review tools and automated analysis systems

4. **Simple Exploitation**: The attack requires only modifying metadata before publishing - no complex exploitation chains or timing dependencies

## Recommendation

Implement source code validation during package publishing:

**Option 1: Recompile and Compare (Strongest)**
- When source code is provided in metadata, recompile it during `publish_package`
- Compare the resulting bytecode hash with the provided bytecode
- Reject the publication if hashes don't match

**Option 2: Source Digest Validation**
- Enhance the `source_digest` field validation
- Compute the digest from provided source code
- Verify it matches the `source_digest` in metadata
- Cross-reference with bytecode compilation metadata

**Option 3: Explicit Validation Flag**
- Add a `source_verified` boolean field to `PackageMetadata`
- Set to `true` only after validation
- Update `retrieve_available_src()` to return validation status
- Display warnings in tools when `source_verified` is `false`

**Recommended Fix (Option 3 - Least Breaking):**

In `code.move`, add validation field:
```move
struct PackageMetadata has copy, drop, store {
    name: String,
    upgrade_policy: UpgradePolicy,
    upgrade_number: u64,
    source_digest: String,
    manifest: vector<u8>,
    modules: vector<ModuleMetadata>,
    deps: vector<PackageDep>,
    extension: Option<Any>,
    source_verified: bool  // NEW FIELD
}
```

Update REST interface to return verification status and display warnings when unverified.

## Proof of Concept

```rust
// Proof of Concept: Publishing with Fake Source Code

// Step 1: Compile legitimate Move source to bytecode
let legitimate_source = r#"
module 0xCAFE::SafeContract {
    public fun safe_function() {
        // Safe implementation
    }
}
"#;
// Compile to bytecode (assume bytecode_result contains compiled bytes)

// Step 2: Create malicious fake source
let malicious_source = r#"
module 0xCAFE::SafeContract {
    public fun safe_function() {
        // Hidden backdoor: transfers funds to attacker
        transfer_to_attacker(sender);
    }
}
"#;

// Step 3: Construct PackageMetadata with fake source
let metadata = PackageMetadata {
    name: "SafeContract".to_string(),
    upgrade_policy: UpgradePolicy::compat(),
    upgrade_number: 0,
    source_digest: "fake_digest".to_string(),  // Not validated
    manifest: vec![],
    modules: vec![ModuleMetadata {
        name: "SafeContract".to_string(),
        source: zip_metadata_str(&malicious_source).unwrap(),  // FAKE SOURCE
        source_map: vec![],
        extension: None,
    }],
    deps: vec![],
    extension: None,
};

// Step 4: Serialize metadata
let metadata_serialized = bcs::to_bytes(&metadata).unwrap();

// Step 5: Publish with legitimate bytecode but fake source
publish_package_txn(
    &owner_signer,
    metadata_serialized,  // Contains malicious source
    vec![bytecode_result]  // Contains legitimate bytecode
);

// Result: Package is accepted and stored on-chain
// Auditors reviewing via retrieve_available_src() will see malicious source
// Actual execution uses legitimate bytecode
// No warnings or errors are generated
```

## Notes

This vulnerability represents a **metadata integrity issue** where the transparency layer (source code) can be compromised without affecting the execution layer (bytecode). While the bytecode itself is validated and secure, the lack of source code validation enables social engineering attacks against auditors, developers, and automated analysis tools that rely on source code for security reviews.

The severity is Medium rather than High because:
- The attack doesn't directly compromise protocol security
- The bytecode (which actually executes) is properly validated
- Professional auditors should independently verify bytecode
- The impact is primarily on the audit process, not the runtime

However, this remains a significant issue because it undermines the entire purpose of publishing source code with packages and can enable more sophisticated attacks that combine fake source code with subtle bytecode vulnerabilities.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/code.move (L58-67)
```text
    struct ModuleMetadata has copy, drop, store {
        /// Name of the module.
        name: String,
        /// Source text, gzipped String. Empty if not provided.
        source: vector<u8>,
        /// Source map, in compressed BCS. Empty if not provided.
        source_map: vector<u8>,
        /// For future extensions.
        extension: Option<Any>,
    }
```

**File:** aptos-move/framework/aptos-framework/sources/code.move (L207-214)
```text
        let packages = &mut borrow_global_mut<PackageRegistry>(addr).packages;
        // Update registry
        let policy = pack.upgrade_policy;
        if (index < len) {
            *vector::borrow_mut(packages, index) = pack
        } else {
            vector::push_back(packages, pack)
        };
```

**File:** aptos-move/framework/aptos-framework/sources/code.move (L222-227)
```text
        if (features::code_dependency_check_enabled())
            request_publish_with_allowed_deps(addr, module_names, allowed_deps, code, policy.policy)
        else
        // The new `request_publish_with_allowed_deps` has not yet rolled out, so call downwards
        // compatible code.
            request_publish(addr, module_names, code, policy.policy)
```

**File:** aptos-move/framework/aptos-framework/sources/code.move (L256-259)
```text
    public entry fun publish_package_txn(owner: &signer, metadata_serialized: vector<u8>, code: vector<vector<u8>>)
    acquires PackageRegistry {
        publish_package(owner, util::from_bytes<PackageMetadata>(metadata_serialized), code)
    }
```

**File:** aptos-move/framework/src/natives/code.rs (L353-359)
```rust
    code_context.requested_module_bundle = Some(PublishRequest {
        destination,
        bundle: ModuleBundle::new(code),
        expected_modules,
        allowed_deps,
        check_compat: policy != ARBITRARY_POLICY,
    });
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1680-1739)
```rust
    fn validate_publish_request(
        &self,
        module_storage: &impl AptosModuleStorage,
        traversal_context: &mut TraversalContext,
        gas_meter: &mut impl GasMeter,
        modules: &[CompiledModule],
        mut expected_modules: BTreeSet<String>,
        allowed_deps: Option<BTreeMap<AccountAddress, BTreeSet<String>>>,
    ) -> VMResult<()> {
        self.reject_unstable_bytecode(modules)?;
        native_validation::validate_module_natives(modules)?;

        for m in modules {
            if !expected_modules.remove(m.self_id().name().as_str()) {
                return Err(Self::metadata_validation_error(&format!(
                    "unregistered module: '{}'",
                    m.self_id().name()
                )));
            }
            if let Some(allowed) = &allowed_deps {
                for dep in m.immediate_dependencies() {
                    if !allowed
                        .get(dep.address())
                        .map(|modules| {
                            modules.contains("") || modules.contains(dep.name().as_str())
                        })
                        .unwrap_or(false)
                    {
                        return Err(Self::metadata_validation_error(&format!(
                            "unregistered dependency: '{}'",
                            dep
                        )));
                    }
                }
            }
            verify_module_metadata_for_module_publishing(m, self.features())
                .map_err(|err| Self::metadata_validation_error(&err.to_string()))?;
        }

        resource_groups::validate_resource_groups(
            self.features(),
            module_storage,
            traversal_context,
            gas_meter,
            modules,
        )?;
        event_validation::validate_module_events(
            self.features(),
            module_storage,
            traversal_context,
            modules,
        )?;

        if !expected_modules.is_empty() {
            return Err(Self::metadata_validation_error(
                "not all registered modules published",
            ));
        }
        Ok(())
    }
```

**File:** types/src/vm/module_metadata.rs (L441-456)
```rust
pub fn verify_module_metadata_for_module_publishing(
    module: &CompiledModule,
    features: &Features,
) -> Result<(), MetaDataValidationError> {
    if features.is_enabled(FeatureFlag::SAFER_METADATA) {
        check_module_complexity(module)?;
    }

    if features.are_resource_groups_enabled() {
        check_metadata_format(module)?;
    }
    let metadata = if let Some(metadata) = get_metadata_from_compiled_code(module) {
        metadata
    } else {
        return Ok(());
    };
```

**File:** aptos-move/aptos-validator-interface/src/rest_interface.rs (L36-58)
```rust
async fn retrieve_available_src(
    client: &Client,
    version: u64,
    package: &PackageMetadata,
    account_address: AccountAddress,
    data: &mut HashMap<(AccountAddress, String), PackageMetadata>,
    package_registry_cache: &mut HashMap<AccountAddress, PackageRegistry>,
) -> Result<()> {
    if package.modules.is_empty() || package.modules[0].source.is_empty() {
        Err(anyhow::anyhow!("source code is not available"))
    } else {
        let package_name = package.clone().name;
        if let std::collections::hash_map::Entry::Vacant(e) =
            data.entry((account_address, package_name.clone()))
        {
            e.insert(package.clone());
            retrieve_dep_packages_with_src(client, version, package, data, package_registry_cache)
                .await
        } else {
            Ok(())
        }
    }
}
```

**File:** aptos-move/aptos-debugger/src/aptos_debugger.rs (L44-46)
```rust
    pub fn rest_client(rest_client: Client) -> anyhow::Result<Self> {
        Ok(Self::new(Arc::new(RestDebuggerInterface::new(rest_client))))
    }
```
