# Audit Report

## Title
Delegation Pool Balance Aggregation Failure in Rosetta API - Multiple Pool Stakes Underreported

## Summary
The Aptos Rosetta API cannot correctly handle accounts delegated to multiple delegation pools simultaneously. While the on-chain Move code allows and correctly tracks delegation to multiple pools, the Rosetta API's identifier design only supports querying one pool at a time and provides no mechanism to discover all pools or aggregate balances, leading to systematic balance underreporting in integrations.

## Finding Description

**On-Chain Behavior (Works Correctly):**

The delegation pool Move contract allows any delegator to stake to multiple different delegation pools simultaneously. The `add_stake` function accepts a `pool_address` parameter with no restriction preventing multiple calls with different pool addresses: [1](#0-0) 

Each delegation pool independently tracks delegator stakes using share accounting. The view function `get_stake` returns stake for a specific (pool_address, delegator_address) pair: [2](#0-1) 

**Rosetta API Limitation (Broken):**

The Rosetta API's `AccountIdentifier` uses an optional `sub_account` field with `metadata.pool_address` to specify which pool to query: [3](#0-2) [4](#0-3) 

The account balance retrieval logic branches based on whether a pool_address is provided: [5](#0-4) 

When `pool_address.is_some()`, the API calls `get_delegation_info` which queries ONLY the specified pool: [6](#0-5) 

This function internally calls the on-chain view function for a single pool: [7](#0-6) 

**The Critical Gap:**

1. When querying a **base account** (no sub_account), the API returns coin/fungible asset balances but provides NO delegation pool information whatsoever
2. When querying with a **specific pool_address**, the API returns stake in ONLY that one pool
3. There is **NO API endpoint** to discover all pools a delegator has staked to
4. There is **NO API endpoint** to aggregate total delegated stake across all pools

**Exploitation Scenario:**

1. User delegates 100 APT to Pool A (address 0xAAA...)
2. User delegates 100 APT to Pool B (address 0xBBB...)  
3. User delegates 100 APT to Pool C (address 0xCCC...)
4. Total staked: 300 APT across 3 pools

A DeFi integration using Rosetta queries the user's balance:
- Query with Pool A identifier → Returns 100 APT (missing 200 APT)
- Query with Pool B identifier → Returns 100 APT (missing 200 APT)
- Query as base account → Returns 0 APT delegation stake (missing all 300 APT)

The integration makes decisions based on incomplete data:
- Collateral calculations use 100 APT instead of 300 APT
- Reward distributions calculated on 100 APT instead of 300 APT
- Voting power shows 100 APT instead of 300 APT
- User appears to have "lost" 200 APT of their stake

## Impact Explanation

**Medium Severity** per Aptos Bug Bounty criteria:

1. **State inconsistencies requiring intervention**: The Rosetta API systematically provides incomplete state information for accounts with multiple delegation pools. Users must manually track all pool addresses or risk losing access to their funds in integrations. This requires external intervention to resolve.

2. **Limited funds loss or manipulation**: While funds are not directly stolen from the blockchain, integrations relying on Rosetta for balance information will systematically underreport user holdings. This can lead to:
   - Users unable to access full collateral value in lending protocols
   - Incorrect reward distribution calculations
   - Reduced voting power in governance
   - De facto loss of utility value for a portion of staked assets

The vulnerability affects the Rosetta API, which is explicitly part of the Aptos Core codebase and used by exchanges, wallets, and DeFi protocols for account balance queries.

## Likelihood Explanation

**HIGH Likelihood:**

1. **Natural user behavior**: Diversifying stake across multiple validators/pools is a common and encouraged practice for risk management
2. **No warnings**: The API documentation and code provide no warning about this limitation
3. **Automatic triggering**: Any integration that queries account balances via Rosetta without explicitly handling multiple pools will be affected
4. **No discovery mechanism**: There is no on-chain view function or API endpoint to enumerate all pools a delegator has staked to, making it impossible for integrations to work around this issue programmatically
5. **Silent failure**: The API returns a successful response with partial data rather than an error, making the issue difficult to detect

## Recommendation

**Short-term fix**: Add comprehensive documentation warning that:
- Rosetta balance queries return stake for only ONE specified pool
- Users must query each pool separately and manually aggregate
- No discovery mechanism exists for enumerating all pools

**Medium-term fix**: Add new Rosetta API endpoint or extend existing functionality:

```rust
// In account.rs - add new query mode
async fn get_all_delegation_balances(
    server_context: &RosettaContext,
    account: AccountIdentifier,
    version: u64,
) -> ApiResult<Vec<(AccountAddress, Amount)>> {
    // Query indexer or iterate through events to find all pools
    // where the delegator has active/inactive/pending_inactive stake
    // Return vector of (pool_address, total_stake) pairs
}
```

**Long-term fix**: Extend the Move contract with a view function to track delegator→pools mapping:

```move
// In delegation_pool.move
struct DelegatorPools has key {
    pools: vector<address>  // All pools this delegator has staked to
}

#[view]
public fun get_delegator_pools(delegator: address): vector<address> acquires DelegatorPools {
    // Return all pools the delegator has ever staked to
}
```

Then update Rosetta to use this for aggregation when no pool_address is specified.

## Proof of Concept

**Move Test** (add to delegation_pool.move):

```move
#[test(aptos_framework = @aptos_framework, delegator = @0xABCD, validator1 = @0x123, validator2 = @0x456)]
public entry fun test_multiple_pool_delegation(
    aptos_framework: &signer,
    delegator: &signer,
    validator1: &signer,
    validator2: &signer,
) acquires DelegationPool, GovernanceRecords, BeneficiaryForOperator, NextCommissionPercentage {
    initialize_for_test(aptos_framework);
    initialize_test_validator(validator1, 100 * ONE_APT, true, false);
    initialize_test_validator(validator2, 100 * ONE_APT, true, false);
    
    let delegator_address = signer::address_of(delegator);
    let pool1_address = get_owned_pool_address(signer::address_of(validator1));
    let pool2_address = get_owned_pool_address(signer::address_of(validator2));
    
    // Delegate to two different pools
    stake::mint(delegator, 200 * ONE_APT);
    add_stake(delegator, pool1_address, 100 * ONE_APT);
    add_stake(delegator, pool2_address, 100 * ONE_APT);
    
    // Each pool correctly shows 100 APT
    let (active1, _, _) = get_stake(pool1_address, delegator_address);
    let (active2, _, _) = get_stake(pool2_address, delegator_address);
    assert!(active1 == 100 * ONE_APT, 1);
    assert!(active2 == 100 * ONE_APT, 2);
    
    // ISSUE: No way to query total delegation of 200 APT across both pools
    // get_owned_pool_address() only returns ONE pool (the one they own)
    // No view function to get all pools delegator has staked to
}
```

**Rosetta Integration Test** (pseudocode):

```rust
// User stakes to multiple pools
add_delegated_stake(delegator, pool_a, 100_000_000);
add_delegated_stake(delegator, pool_b, 100_000_000);
add_delegated_stake(delegator, pool_c, 100_000_000);

// Query balance with pool A
let balance_a = rosetta_client.account_balance(
    AccountIdentifier {
        address: delegator_address,
        sub_account: Some(SubAccountIdentifier {
            address: "active_stake",
            metadata: Some(SubAccountIdentifierMetadata {
                pool_address: pool_a
            })
        })
    }
).await?;
assert_eq!(balance_a.value, "100000000"); // Only shows pool A

// Query balance as base account  
let balance_base = rosetta_client.account_balance(
    AccountIdentifier {
        address: delegator_address,
        sub_account: None
    }
).await?;
// balance_base shows coin balance but NO delegation stakes at all!

// ISSUE: Total delegation of 300 APT is not retrievable in one query
// Integration only sees 100 APT and makes incorrect decisions
```

## Notes

This vulnerability specifically affects the Rosetta API layer, not the underlying Move contract implementation. The on-chain delegation pool contract correctly handles multiple pool delegation with proper accounting. However, the Rosetta API's design limitation prevents integrations from obtaining complete balance information, creating a systemic state inconsistency issue that meets the Medium severity criteria for the Aptos Bug Bounty program.

The issue is particularly concerning because Rosetta is used by exchanges, wallets, and DeFi protocols that rely on accurate balance information for critical operations like collateral management, reward distribution, and governance voting.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/delegation_pool.move (L637-643)
```text
    #[view]
    /// Return total stake owned by `delegator_address` within delegation pool `pool_address`
    /// in each of its individual states: (`active`,`inactive`,`pending_inactive`)
    public fun get_stake(
        pool_address: address,
        delegator_address: address
    ): (u64, u64, u64) acquires DelegationPool, BeneficiaryForOperator {
```

**File:** aptos-move/framework/aptos-framework/sources/delegation_pool.move (L1561-1565)
```text
    public entry fun add_stake(
        delegator: &signer,
        pool_address: address,
        amount: u64
    ) acquires DelegationPool, GovernanceRecords, BeneficiaryForOperator, NextCommissionPercentage, DelegationPoolAllowlisting {
```

**File:** crates/aptos-rosetta/src/types/identifiers.rs (L24-31)
```rust
#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
pub struct AccountIdentifier {
    /// Hex encoded AccountAddress beginning with 0x
    pub address: String,
    /// Sub account only used for staking
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sub_account: Option<SubAccountIdentifier>,
}
```

**File:** crates/aptos-rosetta/src/types/identifiers.rs (L397-409)
```rust
#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
pub struct SubAccountIdentifierMetadata {
    /// Hex encoded Pool beginning with 0x
    pub pool_address: String,
}

impl SubAccountIdentifierMetadata {
    pub fn new_pool_address(pool_address: AccountAddress) -> Self {
        SubAccountIdentifierMetadata {
            pool_address: to_hex_lower(&pool_address),
        }
    }
}
```

**File:** crates/aptos-rosetta/src/account.rs (L125-141)
```rust
    // Regular account, FA and Coin
    if account.is_base_account() {
        balances =
            get_base_balances(&rest_client, owner_address, version, currencies_to_lookup).await?;
    } else if pool_address.is_some() {
        // Lookup the delegation pool, if it's provided in the account information
        // Filter appropriately, must have native coin
        if currencies_to_lookup.contains(&native_coin()) {
            (balances, lockup_expiration) = get_delegation_info(
                &rest_client,
                &account,
                owner_address,
                pool_address.unwrap(),
                version,
            )
            .await?;
        }
```

**File:** crates/aptos-rosetta/src/account.rs (L269-299)
```rust
async fn get_delegation_info(
    rest_client: &Client,
    account: &AccountIdentifier,
    owner_address: AccountAddress,
    pool_address: AccountAddress,
    version: u64,
) -> ApiResult<(Vec<Amount>, u64)> {
    let mut balances = vec![];
    let mut lockup_expiration: u64 = 0;

    match get_delegation_stake_balances(rest_client, account, owner_address, pool_address, version)
        .await
    {
        Ok(Some(balance_result)) => {
            if let Some(balance) = balance_result.balance {
                balances.push(Amount {
                    value: balance.value,
                    currency: native_coin(),
                });
            }
            lockup_expiration = balance_result.lockup_expiration;
        },
        result => {
            warn!(
                    "Failed to retrieve requested balance for delegator_address: {}, pool_address: {}: {:?}",
                    owner_address, pool_address, result
                )
        },
    }
    Ok((balances, lockup_expiration))
}
```

**File:** crates/aptos-rosetta/src/types/misc.rs (L384-435)
```rust
pub async fn get_delegation_stake_balances(
    rest_client: &aptos_rest_client::Client,
    account_identifier: &AccountIdentifier,
    owner_address: AccountAddress,
    pool_address: AccountAddress,
    version: u64,
) -> ApiResult<Option<BalanceResult>> {
    // get requested_balance
    let balances_response = rest_client
        .view(
            &ViewRequest {
                function: DELEGATION_POOL_GET_STAKE_FUNCTION.clone(),
                type_arguments: vec![],
                arguments: vec![
                    serde_json::Value::String(pool_address.to_string()),
                    serde_json::Value::String(owner_address.to_string()),
                ],
            },
            Some(version),
        )
        .await?;

    let requested_balance =
        parse_requested_balance(account_identifier, balances_response.into_inner());

    // get lockup_secs
    let lockup_secs_response = rest_client
        .view(
            &ViewRequest {
                function: STAKE_GET_LOCKUP_SECS_FUNCTION.clone(),
                type_arguments: vec![],
                arguments: vec![serde_json::Value::String(pool_address.to_string())],
            },
            Some(version),
        )
        .await?;
    let lockup_expiration = parse_lockup_expiration(lockup_secs_response.into_inner());

    if let Some(balance) = requested_balance {
        Ok(Some(BalanceResult {
            balance: Some(Amount {
                value: balance,
                currency: native_coin(),
            }),
            lockup_expiration,
        }))
    } else {
        Err(ApiError::InternalError(Some(
            "Unable to construct BalanceResult instance".to_string(),
        )))
    }
}
```
