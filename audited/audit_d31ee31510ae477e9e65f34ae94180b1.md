# Audit Report

## Title
Complete Absence of Audit Logging for Database Debugger Commands Enables Undetected Validator State Reconnaissance

## Summary
The AptosDB debugger commands (`db-tool debug`) provide extensive read access to validator state including transactions, account data, and state snapshots, but implement **zero audit logging**. An attacker who gains filesystem access to a validator node can use these tools to conduct reconnaissance on sensitive validator state without leaving any evidence in security logs, preventing forensic analysis and incident detection.

## Finding Description

The database debugger commands in the `storage/aptosdb/src/db_debugger/` module provide powerful introspection capabilities but lack any audit logging infrastructure: [1](#0-0) [2](#0-1) [3](#0-2) 

The debugger commands can access:
- **Transaction data**: Full transaction contents, write sets, events at any version
- **State values**: Any account resource or module at any version
- **Complete state dumps**: Scan all key-values in state snapshots  
- **Merkle tree internals**: Jellyfish Merkle tree structure and leaf data
- **Database metadata**: Ledger progress, pruner status, version information

The entry point shows no logging infrastructure: [4](#0-3) [5](#0-4) 

While Aptos has a comprehensive `SecurityEvent` audit logging infrastructure for consensus and validator operations: [6](#0-5) 

**None of these security events are used by the db_debugger module**. A grep search confirms zero logging statements (`info!`, `warn!`, `error!`, `SecurityEvent`) in any db_debugger code.

### Attack Scenario

1. Attacker gains filesystem access to validator node (compromised credentials, privilege escalation, or insider threat)
2. Attacker runs: `aptos-debugger aptos-db debug state-kv get-value --db-dir /opt/aptos/data/db --address 0x1 --struct-tag "0x1::stake::StakePool" --version 1000000`
3. Attacker extracts sensitive staking configuration, validator keys, or account balances
4. Attacker runs: `aptos-debugger aptos-db debug state-kv scan-snapshot --db-dir /opt/aptos/data/db --version 1000000` to dump entire state
5. **No audit logs are generated** - the access is completely undetected
6. Forensic investigation after incident finds no evidence of data access

## Impact Explanation

This qualifies as **High severity** per the Aptos bug bounty criteria for "Significant protocol violations" because:

1. **Violates Security Auditing Requirements**: Production systems handling sensitive financial data must log privileged access for compliance and security monitoring
2. **Prevents Incident Detection**: Security teams cannot detect ongoing reconnaissance during active compromises
3. **Eliminates Forensic Evidence**: Post-incident investigations cannot determine what data was accessed, preventing proper incident response
4. **Defense in Depth Failure**: Even if perimeter security is breached, audit logging provides detection and deterrence - its absence removes this critical security layer

The impact extends to all validator operators, as any compromise becomes significantly more dangerous without detection capabilities.

## Likelihood Explanation

**Likelihood: Medium**

While the attack requires filesystem access (system compromise or insider threat), such scenarios are realistic:
- Insider threats from malicious operators
- Credential compromise via phishing or password reuse  
- Privilege escalation vulnerabilities in the OS
- Supply chain attacks on validator infrastructure

Once filesystem access is obtained, exploitation is trivial - the tools are documented and easily executable. The complete absence of logging makes this a guaranteed blind spot in security monitoring.

## Recommendation

Implement comprehensive audit logging for all db_debugger commands:

```rust
// In storage/aptosdb/src/db_debugger/examine/print_raw_data_by_version.rs
use aptos_logger::{info, SecurityEvent};

impl Cmd {
    pub fn run(self) -> Result<()> {
        // AUDIT LOG: Record command execution
        info!(
            SecurityEvent::DebugToolAccess,
            command = "print_raw_data_by_version",
            db_dir = ?self.db_dir,
            version = self.version,
            user = std::env::var("USER").unwrap_or_else(|_| "unknown".to_string()),
            timestamp = chrono::Utc::now().to_rfc3339(),
        );
        
        // Existing command logic...
    }
}
```

**Additional recommendations:**
1. Add new `SecurityEvent::DebugToolAccess` variant to the SecurityEvent enum
2. Log all debugger command invocations with parameters, user, timestamp, and affected data ranges
3. Configure audit logs to forward to tamper-proof external logging systems
4. Implement rate limiting and anomaly detection on debugger tool usage
5. Require additional authentication (e.g., hardware token) for debugger access
6. Document operational procedures requiring security approval before debugger use

## Proof of Concept

```bash
# Terminal 1: Start monitoring system logs
journalctl -f | grep -i "debug\|audit\|security"

# Terminal 2: Execute debugger commands with sensitive data access
aptos-debugger aptos-db debug examine print-db-versions \
  --db-dir /opt/aptos/data/db

aptos-debugger aptos-db debug state-kv get-value \
  --db-dir /opt/aptos/data/db \
  --address 0x1 \
  --struct-tag "0x1::stake::StakePool" \
  --version 1000000

aptos-debugger aptos-db debug examine print-raw-data-by-version \
  --db-dir /opt/aptos/data/db \
  --version 1000000

# RESULT: Terminal 1 shows NO audit logs
# No SecurityEvent entries
# No command execution logs  
# No access records
# Complete operational blindness
```

The PoC demonstrates that sensitive validator state can be accessed without generating any security audit trail, confirming the vulnerability.

## Notes

This vulnerability represents a critical gap in operational security. While it requires elevated access (filesystem permissions), such access is a realistic threat model that production security systems must defend against through audit logging. The complete absence of logging for these powerful introspection tools violates fundamental security principles and prevents organizations from meeting compliance requirements for financial systems.

The fix is straightforward but essential: every debugger command invocation must be logged with sufficient detail to support forensic investigation and anomaly detection.

### Citations

**File:** storage/aptosdb/src/db_debugger/examine/mod.rs (L16-23)
```rust
impl Cmd {
    pub fn run(self) -> Result<()> {
        match self {
            Self::PrintDbVersions(cmd) => cmd.run(),
            Self::PrintRawDataByVersion(cmd) => cmd.run(),
        }
    }
}
```

**File:** storage/aptosdb/src/db_debugger/examine/print_raw_data_by_version.rs (L23-79)
```rust
impl Cmd {
    pub fn run(self) -> Result<()> {
        let rocksdb_config = RocksdbConfigs {
            enable_storage_sharding: self.sharding_config.enable_storage_sharding,
            ..Default::default()
        };
        let env = None;
        let block_cache = None;

        let (ledger_db, _, _, _) = AptosDB::open_dbs(
            &StorageDirPaths::from_path(&self.db_dir),
            rocksdb_config,
            env,
            block_cache,
            /*readonly=*/ true,
            /*max_num_nodes_per_lru_cache_shard=*/ 0,
            /*reset_hot_state=*/ false,
        )?;

        println!(
            "Transaction: {:?}",
            ledger_db.transaction_db().get_transaction(self.version)?
        );

        println!(
            "PersistedAuxiliaryInfo: {:?}",
            ledger_db
                .persisted_auxiliary_info_db()
                .get_persisted_auxiliary_info(self.version)?
        );

        println!(
            "WriteSet: {:?}",
            ledger_db.write_set_db().get_write_set(self.version)?
        );

        println!(
            "Events: {:?}",
            ledger_db.event_db().get_events_by_version(self.version)?
        );

        println!(
            "TransactionInfo: {:?}",
            ledger_db
                .transaction_info_db()
                .get_transaction_info(self.version)?
        );

        println!(
            "TransactionAccumulatorHash: {:?}",
            ledger_db
                .transaction_accumulator_db()
                .get_root_hash(self.version)?
        );

        Ok(())
    }
```

**File:** storage/aptosdb/src/db_debugger/state_kv/get_value.rs (L34-92)
```rust
impl Cmd {
    pub fn run(self) -> Result<()> {
        /*
        let key_vec = hex::decode(&self.key_hex).unwrap();
        let key: StateKey = bcs::from_bytes(&key_vec)?;
        println!(
            "{}",
            format!(
                "* Get state value for key {:?} at version {}. \n",
                key, self.version,
            )
            .yellow()
        );*/

        let address = AccountAddress::from_hex_literal(&self.address).unwrap();
        let struct_tag = StructTag::from_str(&self.struct_tag)?;
        let key = StateKey::resource(&address, &struct_tag)?;

        let ledger_db = self.db_dir.open_ledger_db()?;
        let db = self.db_dir.open_state_kv_db()?;
        let latest_version = ledger_db
            .metadata_db()
            .get_synced_version()?
            .expect("DB is empty.");
        println!("latest version: {latest_version}");
        if self.version != Version::MAX && self.version > latest_version {
            println!(
                "{}",
                format!(
                    "warning: version {} is greater than latest version {}",
                    self.version, latest_version
                )
                .red()
            );
        }

        let mut start_version = self.version;
        let mut count = 0;
        while count < 10 {
            match db.get_state_value_with_version_by_version(&key, start_version)? {
                None => {
                    if count == 0 {
                        println!("{}", "Value not found.".to_string().yellow());
                    }
                    break;
                },
                Some((version, value)) => {
                    Self::print_value(version, value);
                    count += 1;
                    if version == 0 {
                        break;
                    }
                    start_version = version - 1;
                },
            }
        }

        Ok(())
    }
```

**File:** crates/aptos-debugger/src/main.rs (L14-19)
```rust
#[tokio::main]
async fn main() -> Result<()> {
    Logger::new().level(Level::Info).init();
    let _mp = MetricsPusher::start(vec![]);

    Cmd::parse().run().await
```

**File:** storage/db-tool/src/lib.rs (L46-62)
```rust
impl DBTool {
    pub async fn run(self) -> Result<()> {
        match self {
            DBTool::Backup(cmd) => cmd.run().await,
            DBTool::BackupMaintenance(cmd) => cmd.run().await,
            DBTool::Bootstrap(cmd) => cmd.run(),
            DBTool::Debug(cmd) => Ok(cmd.run()?),
            DBTool::ReplayVerify(cmd) => {
                let ret = cmd.run().await;
                info!("Replay verify result: {:?}", ret);
                ret
            },
            DBTool::GenReplayVerifyJobs(cmd) => cmd.run().await,
            DBTool::Restore(cmd) => cmd.run().await,
            DBTool::ReplayOnArchive(cmd) => cmd.run().await,
        }
    }
```

**File:** crates/aptos-logger/src/security.rs (L23-88)
```rust
#[derive(Clone, Copy, Debug, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum SecurityEvent {
    //
    // Mempool
    //
    /// Mempool received a transaction from another peer with an invalid signature
    InvalidTransactionMempool,

    /// Mempool received an invalid network event
    InvalidNetworkEventMempool,

    // Consensus
    // ---------
    /// Consensus received an invalid message (not well-formed, invalid vote data or incorrect signature)
    ConsensusInvalidMessage,

    /// Consensus received an equivocating vote
    ConsensusEquivocatingVote,

    /// Consensus received an equivocating order vote
    ConsensusEquivocatingOrderVote,

    /// Consensus received an invalid proposal
    InvalidConsensusProposal,

    /// Consensus received an invalid new round message
    InvalidConsensusRound,

    /// Consensus received an invalid sync info message
    InvalidSyncInfoMsg,

    /// A received block is invalid
    InvalidRetrievedBlock,

    /// A block being committed or executed is invalid
    InvalidBlock,

    // State-Sync
    // ----------
    /// Invalid chunk of transactions received
    StateSyncInvalidChunk,

    // Health Checker
    // --------------
    /// HealthChecker received an invalid network event
    InvalidNetworkEventHC,

    /// HealthChecker received an invalid message
    InvalidHealthCheckerMsg,

    // Network
    // -------
    /// Network received an invalid message from a remote peer
    InvalidNetworkEvent,

    /// A failed noise handshake that's either a clear bug or indicates some
    /// security issue.
    NoiseHandshake,
}

impl Schema for SecurityEvent {
    fn visit(&self, visitor: &mut dyn Visitor) {
        visitor.visit_pair(Key::new("security-event"), Value::from_serde(self))
    }
}
```
