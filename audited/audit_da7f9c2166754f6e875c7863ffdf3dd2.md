# Audit Report

## Title
Missing Input Validation on API Content-Length Limit Configuration Enables Memory Exhaustion DoS

## Summary
The `PostSizeLimit::new()` function and `ApiConfig` configuration sanitizer lack validation for the `content_length_limit` parameter, allowing extremely large values (up to u64::MAX) to be configured. This misconfiguration can enable memory exhaustion attacks via POST requests with large Content-Length headers.

## Finding Description

The API service uses a `PostSizeLimit` middleware to validate request sizes, but the configuration value is never validated: [1](#0-0) 

The configuration value comes from the `ApiConfig` struct: [2](#0-1) 

The `content_length_limit()` method returns either the configured value or an 8MB default with no bounds checking: [3](#0-2) 

The `ApiConfig::sanitize()` method validates other configuration parameters but completely omits validation of `content_length_limit`: [4](#0-3) 

The middleware checks Content-Length headers against this unvalidated limit: [5](#0-4) 

**Attack Path:**
1. Configuration file sets `content_length_limit: 18446744073709551615` (u64::MAX) or similar large value
2. Node loads configuration without validation
3. Attacker sends POST request with `Content-Length: 10000000000` (10GB)
4. Middleware passes check since `10GB < u64::MAX`
5. Poem framework attempts to allocate buffer for request body
6. Memory exhaustion causes API service DoS

## Impact Explanation

This is a **Medium severity** defense-in-depth issue according to Aptos bug bounty criteria:
- **Limited DoS**: API service availability can be disrupted, but consensus and core blockchain operations are unaffected
- **Requires misconfiguration**: Exploitation requires prior configuration access (operator privilege)
- **State inconsistencies**: Could require manual intervention to recover API service

The issue breaks **Invariant #9** ("Resource Limits: All operations must respect gas, storage, and computational limits") by allowing unbounded memory allocation through misconfiguration.

## Likelihood Explanation

**Likelihood: Low to Medium**

**Prerequisites:**
- Operator access to modify configuration files (privileged)
- Accidental misconfiguration (e.g., typo, unit confusion) or malicious configuration injection

**Realistic scenarios:**
- Operator mistakenly sets value in bytes instead of MB
- Compromised configuration management system
- Inexperienced operator sets arbitrarily large "safe" value

**Mitigating factors:**
- Default value (8MB) is reasonable if not overridden
- Operators are generally trusted actors
- Impact limited to API service, not consensus

## Recommendation

Add validation in the `ApiConfig::sanitize()` method to enforce reasonable upper bounds:

```rust
impl ConfigSanitizer for ApiConfig {
    fn sanitize(
        node_config: &NodeConfig,
        node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();
        let api_config = &node_config.api;

        if !api_config.enabled {
            return Ok(());
        }

        // Validate content_length_limit
        const MAX_REASONABLE_CONTENT_LENGTH: u64 = 100 * 1024 * 1024; // 100 MB
        if let Some(limit) = api_config.content_length_limit {
            if limit > MAX_REASONABLE_CONTENT_LENGTH {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    format!(
                        "content_length_limit ({}) exceeds maximum allowed ({})",
                        limit, MAX_REASONABLE_CONTENT_LENGTH
                    ),
                ));
            }
        }

        // ... existing validation code
    }
}
```

Alternative: Add validation in `PostSizeLimit::new()`:
```rust
impl PostSizeLimit {
    pub fn new(max_size: u64) -> Self {
        const MAX_REASONABLE_SIZE: u64 = 100 * 1024 * 1024; // 100 MB
        let validated_size = max_size.min(MAX_REASONABLE_SIZE);
        Self { max_size: validated_size }
    }
}
```

## Proof of Concept

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use aptos_config::config::{ApiConfig, NodeConfig};
    use aptos_types::chain_id::ChainId;

    #[test]
    fn test_unbounded_content_length_limit() {
        // Create a config with extremely large content_length_limit
        let mut node_config = NodeConfig::default();
        node_config.api.content_length_limit = Some(u64::MAX);
        
        // This should fail but currently passes
        let result = ApiConfig::sanitize(
            &node_config,
            NodeType::Validator,
            Some(ChainId::testnet())
        );
        
        // Currently passes (vulnerability)
        assert!(result.is_ok());
        
        // Should fail with proper validation
        // assert!(result.is_err());
    }
    
    #[tokio::test]
    async fn test_dos_with_large_content_length() {
        // Setup API with u64::MAX limit
        let context = Context::new(/* ... */);
        context.node_config.api.content_length_limit = Some(u64::MAX);
        
        // Simulate POST with 10GB Content-Length
        let req = Request::builder()
            .method("POST")
            .header("Content-Length", "10000000000")
            .body(Body::empty())
            .unwrap();
        
        // Middleware would pass this through
        let limit = PostSizeLimit::new(u64::MAX);
        // This would cause memory allocation issues downstream
    }
}
```

**Notes:**
- This is a defense-in-depth issue requiring configuration access to exploit
- The default 8MB limit is reasonable; only explicit misconfigurations are vulnerable
- Impact is limited to API service availability, not blockchain consensus
- Comparable services (telemetry) use 1MB limit for reference [6](#0-5)

### Citations

**File:** api/src/check_size.rs (L17-20)
```rust
impl PostSizeLimit {
    pub fn new(max_size: u64) -> Self {
        Self { max_size }
    }
```

**File:** api/src/check_size.rs (L43-58)
```rust
    async fn call(&self, req: Request) -> Result<Self::Output> {
        if req.method() != Method::POST {
            return self.inner.call(req).await;
        }

        let content_length = req
            .headers()
            .typed_get::<headers::ContentLength>()
            .ok_or(SizedLimitError::MissingContentLength)?;

        if content_length.0 > self.max_size {
            return Err(SizedLimitError::PayloadTooLarge.into());
        }

        self.inner.call(req).await
    }
```

**File:** config/src/config/api_config.rs (L29-31)
```rust
    /// A maximum limit to the body of a POST request in bytes
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub content_length_limit: Option<u64>,
```

**File:** config/src/config/api_config.rs (L155-160)
```rust
    pub fn content_length_limit(&self) -> u64 {
        match self.content_length_limit {
            Some(v) => v,
            None => DEFAULT_REQUEST_CONTENT_LENGTH_LIMIT,
        }
    }
```

**File:** config/src/config/api_config.rs (L163-199)
```rust
impl ConfigSanitizer for ApiConfig {
    fn sanitize(
        node_config: &NodeConfig,
        node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();
        let api_config = &node_config.api;

        // If the API is disabled, we don't need to do anything
        if !api_config.enabled {
            return Ok(());
        }

        // Verify that failpoints are not enabled in mainnet
        if let Some(chain_id) = chain_id {
            if chain_id.is_mainnet() && api_config.failpoints_enabled {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "Failpoints are not supported on mainnet nodes!".into(),
                ));
            }
        }

        // Validate basic runtime properties
        if api_config.max_runtime_workers.is_none() && api_config.runtime_worker_multiplier == 0 {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "runtime_worker_multiplier must be greater than 0!".into(),
            ));
        }

        // Sanitize the gas estimation config
        GasEstimationConfig::sanitize(node_config, node_type, chain_id)?;

        Ok(())
    }
```

**File:** crates/aptos-telemetry-service/src/constants.rs (L4-5)
```rust
/// The maximum content length to accept in the http body.
pub const MAX_CONTENT_LENGTH: u64 = 1024 * 1024;
```
