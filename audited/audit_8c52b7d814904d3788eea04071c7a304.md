# Audit Report

## Title
Event Sequence Number Collision During Module Event Migration Causing Royalty History Divergence

## Summary
During the module event migration period, a sequence number collision vulnerability exists in the royalty mutation event system. When the `MODULE_EVENT_MIGRATION` feature flag changes between transactions, the EventHandle counter becomes desynchronized from translated V2 event sequence numbers, causing both native V1 events and translated V2 events to receive identical sequence numbers. This results in event overwrites in the indexer database, leading to inconsistent royalty histories across different indexers and data loss.

## Finding Description

The vulnerability arises from a fundamental mismatch between how V1 and V2 events handle sequence numbering:

**V1 Event Emission (feature flag disabled):**
When `emit_token_royalty_mutate_event` is called with the feature flag disabled, it emits a V1 event through the EventHandle mechanism. [1](#0-0)  The `emit_event` function increments the EventHandle counter after each emission.

**V2 Event Emission (feature flag enabled):**
When the same function is called with the feature flag enabled, it emits a V2 module event instead. [2](#0-1)  The V2 emission path uses `event::emit()`, which calls the native function [3](#0-2)  and does NOT increment the EventHandle counter at all.

**Translation Layer Vulnerability:**
The `RoyaltyMutateTranslator` translates V2 events back to V1 format for backward compatibility. [4](#0-3)  It reads the `TokenEventStoreV1` resource from the latest state checkpoint [5](#0-4)  and uses the EventHandle's current counter value to determine the sequence number for translated events. [6](#0-5) 

**Sequence Number Assignment Logic:**
The `get_next_sequence_number` function returns: cached_value+1 if in cache, DB_value+1 if in DB, or the EventHandle counter as a fallback. [7](#0-6) 

**Collision Scenario:**
```
Version 1000: Feature DISABLED → Royalty mutated to A → V1 event seq=0 emitted → EventHandle counter = 1
Version 1001: Feature DISABLED → Royalty mutated to B → V1 event seq=1 emitted → EventHandle counter = 2  
Version 1002: Feature ENABLED → Royalty mutated to C → V2 event emitted → EventHandle counter remains 2 (not incremented!)
Version 1003: Feature DISABLED → Royalty mutated to D → V1 event seq=2 emitted → EventHandle counter = 3

Indexer processes V1002:
- Translator reads TokenEventStoreV1 resource
- EventHandle counter = 2
- No cached/DB entry for this event key yet
- Assigns sequence number = 2 to translated V1 event for V1002
- Caches and stores seq=2 for royalty C

Indexer processes V1003:
- Native V1 event already has seq=2 for royalty D
- COLLISION: Both V1002 (royalty C) and V1003 (royalty D) have sequence number 2
```

**Database Overwrite:**
Both events are stored in `EventByKeySchema` with the same key `(event_key, sequence_number)`. [8](#0-7) [9](#0-8)  The `put` operation causes whichever event is processed last to overwrite the first, resulting in data loss and divergent royalty histories across indexers.

## Impact Explanation

This vulnerability qualifies as **HIGH severity** under the Aptos bug bounty program:

1. **Data Integrity Violation**: Breaks the invariant that event sequence numbers must be unique and monotonically increasing for each event key. This causes permanent data corruption in the indexer database.

2. **NFT Marketplace Disruption**: NFT marketplaces rely on accurate royalty history to calculate and distribute royalty payments. Inconsistent royalty data leads to:
   - Incorrect royalty payments to creators
   - Legal/contractual violations in NFT sales
   - Loss of trust in the platform

3. **Indexer Divergence**: Different indexers processing transactions at different times will see different "winning" events for the same sequence number, causing non-deterministic query results across the ecosystem.

4. **Widespread Impact**: Affects all token royalty mutations during the migration period, which could span millions of NFT transactions across the Aptos ecosystem.

While this doesn't directly cause fund loss or consensus breaks, it represents a **significant protocol violation** affecting critical infrastructure (indexers) and could lead to **limited funds loss or manipulation** through incorrect royalty payments, meeting the High severity criteria.

## Likelihood Explanation

This vulnerability has **HIGH likelihood**:

1. **Natural Occurrence**: The bug triggers automatically during the normal module event migration period when the `MODULE_EVENT_MIGRATION` feature flag is toggled by governance. No attacker action is required.

2. **Frequent Trigger Condition**: Any token creator calling `mutate_tokendata_royalty` [10](#0-9)  during the migration period will trigger the vulnerability. NFT royalty updates are common operations.

3. **No Special Permissions Required**: Any user who owns a token with mutable royalty configuration can trigger the event emission. This is a standard NFT operation, not a privileged action.

4. **Extended Exposure Window**: The migration period could last weeks or months as the ecosystem transitions, providing ample opportunity for the collision to occur across numerous transactions.

5. **Guaranteed Collision**: Mathematics guarantees collisions will occur: if N V1 events are emitted (counter increments to N), then M V2 events are emitted (counter stays at N), then more V1 events will reuse sequence numbers N through N+M-1.

## Recommendation

Implement one of the following solutions:

**Solution 1: True Dual Emission (Backward Compatible)**
Modify the event emission to ALWAYS increment the EventHandle counter, regardless of which event type is emitted:

```move
friend fun emit_token_royalty_mutate_event(
    creator: &signer,
    collection: String,
    token: String,
    old_royalty_numerator: u64,
    old_royalty_denominator: u64,
    old_royalty_payee_addr: address,
    new_royalty_numerator: u64,
    new_royalty_denominator: u64,
    new_royalty_payee_addr: address,
) acquires TokenEventStoreV1 {
    let creator_addr = signer::address_of(creator);
    initialize_token_event_store(creator);
    let token_event_store = &mut TokenEventStoreV1[creator_addr];
    
    if (std::features::module_event_migration_enabled()) {
        event::emit(RoyaltyMutate { /* ... */ });
    } else {
        let event = RoyaltyMutateEvent { /* ... */ };
        event::emit_event<RoyaltyMutateEvent>(
            &mut token_event_store.royalty_mutate_events,
            event,
        );
    };
    
    // CRITICAL FIX: Always increment counter manually when V2 is emitted
    if (std::features::module_event_migration_enabled()) {
        token_event_store.royalty_mutate_events.counter = 
            token_event_store.royalty_mutate_events.counter + 1;
    }
}
```

**Solution 2: Translator Uses Independent Sequence Tracking**
Modify the translator to maintain completely independent sequence number tracking that never relies on EventHandle counters:

- Remove the fallback to `object_resource.royalty_mutate_events().count()` 
- Always initialize from cache/DB with starting value 0
- Persist sequence numbers after each translation to ensure consistency across restarts

**Solution 3: Disable V1 Emission During Migration**
Once the feature flag is enabled, permanently disable V1 event emission and rely solely on translation. This prevents new V1 events from being emitted that could collide with translated sequence numbers.

## Proof of Concept

```move
#[test_only]
module test_addr::royalty_collision_poc {
    use aptos_framework::account;
    use aptos_token::token;
    use std::string;
    use std::signer;

    #[test(creator = @0xCAFE, framework = @0x1)]
    fun test_royalty_event_collision(creator: &signer, framework: &signer) {
        // Setup accounts
        account::create_account_for_test(signer::address_of(creator));
        account::create_account_for_test(@0x1);
        
        // Create collection and token with mutable royalty
        let collection_name = string::utf8(b"Test Collection");
        let token_name = string::utf8(b"Test Token");
        
        token::create_collection(
            creator,
            collection_name,
            string::utf8(b"Description"),
            string::utf8(b"https://example.com"),
            1000,
            vector[false, false, true] // collection mutability: description, uri, max
        );
        
        let token_data_id = token::create_tokendata(
            creator,
            collection_name,
            token_name,
            string::utf8(b"Token Description"),
            1,
            string::utf8(b"https://example.com/token"),
            signer::address_of(creator),
            10, // royalty denominator
            1,  // royalty numerator  
            token::create_token_mutability_config(&vector[false, false, true, false, false]), // royalty mutable
            vector[], vector[], vector[], vector[]
        );
        
        // Scenario: Feature flag disabled
        // Transaction 1: Mutate royalty A → B (V1 event seq=0, counter=1)
        let royalty_b = token::create_royalty(2, 10, signer::address_of(creator));
        token::mutate_tokendata_royalty(creator, token_data_id, royalty_b);
        
        // Transaction 2: Mutate royalty B → C (V1 event seq=1, counter=2)  
        let royalty_c = token::create_royalty(3, 10, signer::address_of(creator));
        token::mutate_tokendata_royalty(creator, token_data_id, royalty_c);
        
        // Simulate feature flag enable (V2 emission mode)
        // In real scenario: std::features::change_feature_flags(framework, vector[57], vector[]);
        
        // Transaction 3: Mutate royalty C → D (V2 event, counter stays 2)
        let royalty_d = token::create_royalty(4, 10, signer::address_of(creator));
        token::mutate_tokendata_royalty(creator, token_data_id, royalty_d);
        // Translator will assign seq=2 to this V2 event
        
        // Simulate feature flag disable (V1 emission mode again)
        
        // Transaction 4: Mutate royalty D → E (V1 event seq=2, counter=3) 
        let royalty_e = token::create_royalty(5, 10, signer::address_of(creator));
        token::mutate_tokendata_royalty(creator, token_data_id, royalty_e);
        
        // RESULT: Both Transaction 3 (royalty D) and Transaction 4 (royalty E) 
        // have sequence number 2, causing collision in EventByKeySchema
        // Indexers will show inconsistent royalty histories depending on 
        // which event overwrote the other in their database
    }
}
```

**Notes**:
- The premise of "dual emission" in the security question is misleading; the code uses conditional emission (if-else), not simultaneous emission of both event types
- The vulnerability stems from the EventHandle counter not being synchronized with V2 event emission
- This is a design flaw in the migration strategy rather than a malicious exploit
- The issue affects all event types during migration, not just royalty events, but royalty events are particularly critical for NFT marketplace integrity

### Citations

**File:** aptos-move/framework/aptos-framework/sources/event.move (L17-19)
```text
    public fun emit<T: store + drop>(msg: T) {
        write_module_event_to_store<T>(msg);
    }
```

**File:** aptos-move/framework/aptos-framework/sources/event.move (L54-60)
```text
    public fun emit_event<T: drop + store>(handle_ref: &mut EventHandle<T>, msg: T) {
        write_to_event_store<T>(bcs::to_bytes(&handle_ref.guid), handle_ref.counter, msg);
        spec {
            assume handle_ref.counter + 1 <= MAX_U64;
        };
        handle_ref.counter += 1;
    }
```

**File:** aptos-move/framework/aptos-token/sources/token_event_store.move (L475-493)
```text
        if (std::features::module_event_migration_enabled()) {
            event::emit(
                RoyaltyMutate {
                    creator: creator_addr,
                    collection,
                    token,
                    old_royalty_numerator,
                    old_royalty_denominator,
                    old_royalty_payee_addr,
                    new_royalty_numerator,
                    new_royalty_denominator,
                    new_royalty_payee_addr,
                });
        } else {
            event::emit_event<RoyaltyMutateEvent>(
                &mut token_event_store.royalty_mutate_events,
                event,
            );
        };
```

**File:** storage/indexer/src/event_v2_translator.rs (L190-200)
```rust
    pub fn get_next_sequence_number(&self, event_key: &EventKey, default: u64) -> Result<u64> {
        if let Some(seq) = self.get_cached_sequence_number(event_key) {
            Ok(seq + 1)
        } else {
            let seq = self
                .internal_indexer_db
                .get::<EventSequenceNumberSchema>(event_key)?
                .map_or(default, |seq| seq + 1);
            Ok(seq)
        }
    }
```

**File:** storage/indexer/src/event_v2_translator.rs (L202-214)
```rust
    pub fn get_state_value_bytes_for_resource(
        &self,
        address: &AccountAddress,
        struct_tag: &StructTag,
    ) -> Result<Option<Bytes>> {
        let state_view = self
            .main_db_reader
            .latest_state_checkpoint_view()
            .expect("Failed to get state view");
        let state_key = StateKey::resource(address, struct_tag)?;
        let maybe_state_value = state_view.get_state_value(&state_key)?;
        Ok(maybe_state_value.map(|state_value| state_value.bytes().clone()))
    }
```

**File:** storage/indexer/src/event_v2_translator.rs (L1247-1286)
```rust
    fn translate_event_v2_to_v1(
        &self,
        v2: &ContractEventV2,
        engine: &EventV2TranslationEngine,
    ) -> Result<ContractEventV1> {
        let royalty_mutation = RoyaltyMutate::try_from_bytes(v2.event_data())?;
        let struct_tag = StructTag::from_str("0x3::token_event_store::TokenEventStoreV1")?;
        let (key, sequence_number) = if let Some(state_value_bytes) =
            engine.get_state_value_bytes_for_resource(royalty_mutation.creator(), &struct_tag)?
        {
            let object_resource: TokenEventStoreV1Resource = bcs::from_bytes(&state_value_bytes)?;
            let key = *object_resource.royalty_mutate_events().key();
            let sequence_number = engine
                .get_next_sequence_number(&key, object_resource.royalty_mutate_events().count())?;
            (key, sequence_number)
        } else {
            // If the TokenEventStoreV1 resource is not found, we skip the event translation to
            // avoid panic because the creation number cannot be decided.
            return Err(AptosDbError::from(anyhow::format_err!(
                "TokenEventStoreV1 resource not found"
            )));
        };
        let royalty_mutation_event = RoyaltyMutateEvent::new(
            *royalty_mutation.creator(),
            royalty_mutation.collection().clone(),
            royalty_mutation.token().clone(),
            *royalty_mutation.old_royalty_numerator(),
            *royalty_mutation.old_royalty_denominator(),
            *royalty_mutation.old_royalty_payee_addr(),
            *royalty_mutation.new_royalty_numerator(),
            *royalty_mutation.new_royalty_denominator(),
            *royalty_mutation.new_royalty_payee_addr(),
        );
        Ok(ContractEventV1::new(
            key,
            sequence_number,
            ROYALTY_MUTATE_EVENT_TYPE.clone(),
            bcs::to_bytes(&royalty_mutation_event)?,
        )?)
    }
```

**File:** storage/indexer/src/db_indexer.rs (L434-446)
```rust
                    if let ContractEvent::V1(v1) = event {
                        batch
                            .put::<EventByKeySchema>(
                                &(*v1.key(), v1.sequence_number()),
                                &(version, idx as u64),
                            )
                            .expect("Failed to put events by key to a batch");
                        batch
                            .put::<EventByVersionSchema>(
                                &(*v1.key(), version, v1.sequence_number()),
                                &(idx as u64),
                            )
                            .expect("Failed to put events by version to a batch");
```

**File:** storage/indexer/src/db_indexer.rs (L464-469)
```rust
                                batch
                                    .put::<EventByKeySchema>(
                                        &(key, sequence_number),
                                        &(version, idx as u64),
                                    )
                                    .expect("Failed to put events by key to a batch");
```

**File:** aptos-move/framework/aptos-token/sources/token.move (L831-850)
```text
    public fun mutate_tokendata_royalty(creator: &signer, token_data_id: TokenDataId, royalty: Royalty) acquires Collections {
        assert_tokendata_exists(creator, token_data_id);

        let all_token_data = &mut Collections[token_data_id.creator].token_data;
        let token_data = all_token_data.borrow_mut(token_data_id);
        assert!(token_data.mutability_config.royalty, error::permission_denied(EFIELD_NOT_MUTABLE));

        token_event_store::emit_token_royalty_mutate_event(
            creator,
            token_data_id.collection,
            token_data_id.name,
            token_data.royalty.royalty_points_numerator,
            token_data.royalty.royalty_points_denominator,
            token_data.royalty.payee_address,
            royalty.royalty_points_numerator,
            royalty.royalty_points_denominator,
            royalty.payee_address
        );
        token_data.royalty = royalty;
    }
```
