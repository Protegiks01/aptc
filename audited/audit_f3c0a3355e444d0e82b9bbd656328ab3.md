# Audit Report

## Title
Testing-Only Code Can Be Deployed to Production Networks via `__COMPILE_FOR_TESTING__` Constant

## Summary
Move modules compiled with language version V2_2 and the `compile_for_testing` flag enabled can be deployed to production networks, including mainnet. The `CompilationMetadata` structure does not track whether code was compiled for testing, and the test-only native function `monotonically_increasing_counter_internal_for_test_only` is unconditionally registered in production builds. This allows testing code paths that bypass feature flag checks to execute on production networks, potentially breaking consensus through non-deterministic execution.

## Finding Description

The `__COMPILE_FOR_TESTING__` builtin constant was introduced in Move language version 2.2 to enable conditional compilation of testing-only code paths. [1](#0-0) 

When code is compiled with the `compile_for_testing` option enabled, this constant is defined and set to `true`. [2](#0-1) 

The Aptos Framework's `transaction_context.move` module uses this pattern to provide a test-only implementation that bypasses production security checks: [3](#0-2) 

The production implementation requires a feature flag check (`features::is_monotonically_increasing_counter_enabled()`), while the test implementation bypasses this check entirely and returns different values.

**Critical Vulnerability**: The `CompilationMetadata` structure only tracks compiler version, language version, and an `unstable` flag based on version stability. It does NOT track whether code was compiled with `compile_for_testing=true`. [4](#0-3) 

Language version V2_2 is marked as **stable** (returns `false` for `unstable()`), meaning bytecode compiled with V2_2 passes mainnet deployment validation: [5](#0-4) 

The module publishing validation in `aptos_vm.rs` only checks if the `unstable` flag is true, rejecting unstable bytecode on mainnet: [6](#0-5) 

Since V2_2 is stable, code compiled with `compile_for_testing=true` has `unstable=false` and passes this validation.

**Critically**, the test-only native function `monotonically_increasing_counter_internal_for_test_only` is registered in production builds WITHOUT any conditional compilation guard: [7](#0-6) 

The function is always available at lines 537-538 in the native function registry, unlike other dangerous test-only natives that are protected by `#[cfg(feature = "testing")]` guards and checked by `assert_no_test_natives`.

## Impact Explanation

This vulnerability breaks the **Deterministic Execution** invariant: "All validators must produce identical state roots for identical blocks."

**Attack Scenario**:
1. An attacker (or malicious/negligent developer) compiles Move code with language version V2_2 and `compile_for_testing=true`
2. The `__COMPILE_FOR_TESTING__` constant is inlined as `true` in the bytecode
3. The compilation metadata has `unstable=false` (V2_2 is stable)
4. The bytecode passes mainnet validation and is deployed
5. Production validators execute the testing code path, which:
   - Bypasses feature flag checks (`features::is_monotonically_increasing_counter_enabled()`)
   - Returns different values (test version returns only `local_counter` while production returns `timestamp || transaction_index || session_counter || local_counter`)

**Consensus Impact**: If different validators have different feature flag configurations (e.g., some have the feature enabled, others disabled), they would execute different code paths and produce different state roots, causing consensus divergence.

This qualifies as **High Severity** per Aptos bug bounty criteria:
- Significant protocol violations (breaks deterministic execution)
- Bypasses access controls (feature flag checks)
- Affects network-wide consensus integrity

## Likelihood Explanation

**High Likelihood** - This can occur through:
1. **Developer error**: Accidentally compiling with test flags for production deployment
2. **CI/CD misconfiguration**: Build pipelines using incorrect compilation flags
3. **Malicious deployment**: Intentional bypass of security features

The vulnerability requires no special privileges - any account with sufficient gas to deploy modules can exploit this. The compilation tooling provides no warnings that code compiled with `compile_for_testing=true` should not be deployed to production networks.

## Recommendation

Implement multiple defense layers:

**1. Track `compile_for_testing` in CompilationMetadata**:
```rust
#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct CompilationMetadata {
    pub unstable: bool,
    pub compiler_version: String,
    pub language_version: String,
    pub compile_for_testing: bool,  // NEW FIELD
}
```

**2. Reject testing-compiled bytecode on mainnet**:
```rust
fn reject_unstable_bytecode(&self, modules: &[CompiledModule]) -> VMResult<()> {
    if self.chain_id().is_mainnet() {
        for module in modules {
            if let Some(metadata) = get_compilation_metadata(module) {
                if metadata.unstable {
                    return Err(/* existing error */);
                }
                // NEW CHECK
                if metadata.compile_for_testing {
                    return Err(PartialVMError::new(StatusCode::CONSTRAINT_NOT_SATISFIED)
                        .with_message("code compiled for testing cannot be deployed to mainnet".to_string())
                        .finish(Location::Undefined));
                }
            }
        }
    }
    Ok(())
}
```

**3. Add runtime assertion** to protect test-only natives:
```rust
fn native_monotonically_increasing_counter_internal_for_test_only(
    context: &mut SafeNativeContext,
    _ty_args: &[Type],
    _args: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    // Abort if called on mainnet
    if context.chain_id() == ChainId::mainnet() {
        return Err(SafeNativeError::Abort {
            abort_code: error::invalid_state(ETEST_ONLY_FUNCTION_CALLED_ON_MAINNET),
        });
    }
    // ... existing implementation
}
```

## Proof of Concept

**Compilation Step**:
```bash
# Compile Move module with testing flag enabled
aptos move compile \
  --named-addresses test_module=0x1234 \
  --language-version 2.2 \
  --experiments COMPILE_FOR_TESTING \
  --output-dir ./build
```

**Vulnerable Move Module** (`sources/test_deploy.move`):
```move
module test_module::vulnerable {
    use aptos_framework::transaction_context;
    
    public entry fun exploit() {
        // This will call the test-only implementation
        // bypassing the feature flag check
        let counter = transaction_context::monotonically_increasing_counter();
        // counter now contains test-only value (just local_counter)
        // instead of production value (timestamp || txn_index || session || local)
    }
}
```

**Deploy to Mainnet**:
```bash
# This will succeed because V2_2 is stable (unstable=false)
aptos move publish \
  --package-dir . \
  --named-addresses test_module=<deployer_address>
```

**Verification**: The deployed module will execute `monotonically_increasing_counter_internal_for_test_only()` on production validators, bypassing the `features::is_monotonically_increasing_counter_enabled()` check and returning different values than expected, potentially causing consensus divergence if validators have different feature flag states.

### Citations

**File:** third_party/move/move-model/src/metadata.rs (L29-38)
```rust
pub mod lang_feature_versions {
    use crate::LanguageVersion;
    /// This version guards built-in constant `__COMPILE_FOR_TESTING__`,
    /// which is set to `true` when the code is compiled for testing purposes.
    pub const LANGUAGE_VERSION_FOR_COMPILE_FOR_TESTING: LanguageVersion = LanguageVersion::V2_2;
    pub const LANGUAGE_VERSION_FOR_SINT: LanguageVersion = LanguageVersion::V2_3;
    pub const LANGUAGE_VERSION_FOR_PUBLIC_STRUCT: LanguageVersion = LanguageVersion::V2_4;
    pub const LANGUAGE_VERSION_FOR_RAC: LanguageVersion =
        crate::metadata::LATEST_LANGUAGE_VERSION_VALUE;
}
```

**File:** third_party/move/move-model/src/metadata.rs (L49-71)
```rust
#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct CompilationMetadata {
    /// A flag indicating whether, at time of creation, the compilation
    /// result was considered as unstable. Unstable code may have restrictions
    /// for deployment on production networks. This flag is true if either the
    /// compiler or language versions are unstable.
    pub unstable: bool,
    /// The version of the compiler, as a string. See
    /// `CompilationVersion::from_str` for supported version strings.
    pub compiler_version: String,
    /// The version of the language, as a string. See
    /// `LanguageVersion::from_str` for supported version strings.
    pub language_version: String,
}

impl CompilationMetadata {
    pub fn new(compiler_version: CompilerVersion, language_version: LanguageVersion) -> Self {
        Self {
            compiler_version: compiler_version.to_string(),
            language_version: language_version.to_string(),
            unstable: compiler_version.unstable() || language_version.unstable(),
        }
    }
```

**File:** third_party/move/move-model/src/metadata.rs (L286-294)
```rust
    /// Whether the language version is unstable. An unstable version
    /// should not be allowed on production networks.
    pub const fn unstable(self) -> bool {
        use LanguageVersion::*;
        match self {
            V1 | V2_0 | V2_1 | V2_2 | V2_3 => false,
            V2_4 | V2_5 => true,
        }
    }
```

**File:** third_party/move/move-model/src/builder/builtins.rs (L70-81)
```rust
    {
        if options
            .language_version
            .is_at_least(LANGUAGE_VERSION_FOR_COMPILE_FOR_TESTING)
        {
            use EntryVisibility::SpecAndImpl;
            // Compiler builtin constants.
            trans.define_const(
                trans.builtin_qualified_symbol("__COMPILE_FOR_TESTING__"),
                mk_bool_const(options.compile_for_testing, SpecAndImpl),
            );
        }
```

**File:** aptos-move/framework/aptos-framework/sources/transaction_context.move (L195-207)
```text
    /// Returns a monotonically increasing counter value that combines timestamp, transaction index,
    /// session counter, and local counter into a 128-bit value.
    /// Format: `<reserved_byte (8 bits)> || timestamp_us (64 bits) || transaction_index (32 bits) || session_counter (8 bits) || local_counter (16 bits)`
    /// The function aborts if the local counter overflows (after 65535 calls in a single session).
    /// When compiled for testing, this function bypasses feature checks and returns a simplified counter value.
    public fun monotonically_increasing_counter(): u128 {
        if (__COMPILE_FOR_TESTING__) {
            monotonically_increasing_counter_internal_for_test_only()
        } else {
            assert!(features::is_monotonically_increasing_counter_enabled(), error::invalid_state(EMONOTONICALLY_INCREASING_COUNTER_NOT_ENABLED));
            monotonically_increasing_counter_internal(timestamp::now_microseconds())
        }
    }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1741-1757)
```rust
    /// Check whether the bytecode can be published to mainnet based on the unstable tag in the metadata
    fn reject_unstable_bytecode(&self, modules: &[CompiledModule]) -> VMResult<()> {
        if self.chain_id().is_mainnet() {
            for module in modules {
                if let Some(metadata) = get_compilation_metadata(module) {
                    if metadata.unstable {
                        return Err(PartialVMError::new(StatusCode::UNSTABLE_BYTECODE_REJECTED)
                            .with_message(
                                "code marked unstable is not published on mainnet".to_string(),
                            )
                            .finish(Location::Undefined));
                    }
                }
            }
        }
        Ok(())
    }
```

**File:** aptos-move/framework/src/natives/transaction_context.rs (L526-560)
```rust
pub fn make_all(
    builder: &SafeNativeBuilder,
) -> impl Iterator<Item = (String, NativeFunction)> + '_ {
    let natives = [
        ("get_script_hash", native_get_script_hash as RawSafeNative),
        ("generate_unique_address", native_generate_unique_address),
        (
            "monotonically_increasing_counter_internal",
            native_monotonically_increasing_counter_internal,
        ),
        (
            "monotonically_increasing_counter_internal_for_test_only",
            native_monotonically_increasing_counter_internal_for_test_only,
        ),
        ("get_txn_hash", native_get_txn_hash),
        ("sender_internal", native_sender_internal),
        (
            "secondary_signers_internal",
            native_secondary_signers_internal,
        ),
        ("gas_payer_internal", native_gas_payer_internal),
        ("max_gas_amount_internal", native_max_gas_amount_internal),
        ("gas_unit_price_internal", native_gas_unit_price_internal),
        ("chain_id_internal", native_chain_id_internal),
        (
            "entry_function_payload_internal",
            native_entry_function_payload_internal,
        ),
        (
            "multisig_payload_internal",
            native_multisig_payload_internal,
        ),
    ];

    builder.make_named_natives(natives)
```
