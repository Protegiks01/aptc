# Audit Report

## Title
Byzantine Peers Can Manipulate Reputation Scores Through Strategic Timeout Exploitation

## Summary
Byzantine peers can maintain artificially high reputation scores by strategically choosing to timeout on requests instead of sending invalid responses. The peer scoring system applies asymmetric penalties: timeouts receive a 0.95 multiplier (NotUseful), while invalid proof responses receive +1.0 followed by 0.8 multiplier (Malicious), creating an effective ~0.816 multiplier. This allows Byzantine peers to misbehave approximately 4x longer before being ignored (13 timeouts vs 3 proof failures from a score of 50). [1](#0-0) 

## Finding Description

The peer scoring system tracks peer behavior to identify and ignore misbehaving peers. The scoring constants define two error categories: [2](#0-1) 

When a response is successfully received, the peer immediately gains +1.0 score: [3](#0-2) 

Then, if the response later fails validation (e.g., proof verification), the score is multiplied by the error type multiplier: [4](#0-3) 

However, when an RPC error (timeout, disconnection) occurs, the peer only receives the NotUseful multiplier without the initial +1.0 bonus: [5](#0-4) 

The error type mapping shows that ProofVerificationError is the only error classified as Malicious: [6](#0-5) 

**Attack Path:**
1. Byzantine peer establishes connection and receives data requests
2. Peer builds reputation by occasionally sending valid responses (+1.0 per response)
3. When peer wants to misbehave, it strategically chooses to timeout rather than send invalid proofs:
   - **Timeout path**: Score × 0.95 (loss of ~2.5 from score of 50)
   - **Invalid proof path**: (Score + 1.0) × 0.8 (loss of ~9.2 from score of 50)
4. Peer can perform ~13 timeouts vs ~3 proof failures before dropping below the ignore threshold of 25.0

**Mathematical Analysis:**
- Starting score: 50.0 (STARTING_SCORE)
- Ignore threshold: 25.0 (IGNORE_PEER_THRESHOLD)
- Timeouts to reach threshold: 50 × (0.95^n) = 25 → n ≈ 13.5 timeouts
- Invalid proofs to reach threshold: ~3-4 responses with proof failures [7](#0-6) 

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos bug bounty criteria for the following reasons:

1. **Validator Node Slowdowns**: Byzantine peers can cause significant state-sync delays by timing out while maintaining high reputation scores. This forces honest nodes to repeatedly select the same misbehaving peers, wasting timeout periods (up to 60 seconds per request) and retry resources.

2. **Significant Protocol Violations**: The peer reputation system is designed to quickly identify and isolate misbehaving peers. This vulnerability subverts that protocol by allowing Byzantine peers to misbehave 4x longer than intended, reducing network resilience.

3. **Resource Exhaustion**: Each timeout wastes client resources including:
   - Request timeout periods (configured up to 60 seconds)
   - Network bandwidth for retries
   - CPU cycles for request processing and peer selection

4. **Network Health Degradation**: If multiple Byzantine peers exploit this, the state-sync network's ability to filter out bad actors is significantly degraded, potentially causing widespread synchronization delays across the network.

## Likelihood Explanation

**Likelihood: HIGH**

This vulnerability is highly likely to be exploited because:

1. **Simple Exploitation**: Byzantine peers only need to not respond to requests they want to avoid sending valid data for. No complex cryptographic operations or protocol manipulation required.

2. **No Special Access Required**: Any network peer can exploit this without validator privileges or special network position.

3. **Difficult to Detect**: Strategic timeout behavior is indistinguishable from legitimate network issues, making it hard to detect and mitigate.

4. **Clear Attacker Incentive**: Malicious peers benefit by:
   - Maintaining high reputation scores while providing invalid/stale data
   - Avoiding the severe Malicious penalty for proof failures
   - Prolonging their ability to waste honest node resources

5. **Default Configuration Vulnerable**: The feature is enabled by default (`ignore_low_score_peers: true`), and the scoring constants make the attack mathematically favorable.

## Recommendation

**Immediate Fix**: Treat timeouts with the same severity as proof verification failures, or implement a separate timeout counter that ignores peers after a lower threshold of timeouts.

**Option 1 - Unified Penalty (Recommended)**:
Modify the error handling to classify repeated timeouts from the same peer as potentially Malicious behavior:

```rust
// In peer_states.rs
const MAX_CONSECUTIVE_TIMEOUTS: u32 = 3;

pub struct PeerState {
    // ... existing fields ...
    consecutive_timeouts: u32,
}

impl PeerState {
    fn update_score_timeout(&mut self) {
        self.consecutive_timeouts += 1;
        
        // After 3 consecutive timeouts, treat as malicious
        let error_type = if self.consecutive_timeouts >= MAX_CONSECUTIVE_TIMEOUTS {
            ErrorType::Malicious
        } else {
            ErrorType::NotUseful
        };
        
        self.update_score_error(error_type);
    }
    
    fn reset_timeout_counter(&mut self) {
        self.consecutive_timeouts = 0;
    }
}
```

**Option 2 - Asymmetric Success Bonus**:
Remove or reduce the immediate +1.0 bonus when responses are received, and only apply it after successful validation:

```rust
// In client.rs, remove line 817
// Don't call update_score_success immediately

// Instead, call it only after validation succeeds
// via the ResponseCallback mechanism
```

**Option 3 - Timeout-Specific Threshold**:
Implement a separate ignore threshold specifically for timeouts:

```rust
const TIMEOUT_IGNORE_THRESHOLD: u32 = 5;

pub struct PeerState {
    timeout_count: u32,
}

impl PeerState {
    fn is_ignored(&self) -> bool {
        if !self.data_client_config.ignore_low_score_peers {
            return false;
        }
        
        self.score <= IGNORE_PEER_THRESHOLD || 
        self.timeout_count >= TIMEOUT_IGNORE_THRESHOLD
    }
}
```

## Proof of Concept

```rust
#[tokio::test]
async fn byzantine_peer_timeout_exploitation() {
    use aptos_config::config::AptosDataClientConfig;
    use aptos_data_client::peer_states::*;
    
    // Create peer state with default scoring
    let config = Arc::new(AptosDataClientConfig::default());
    let peer_states = PeerStates::new(config.clone());
    let peer = create_mock_peer_network_id();
    
    // Initialize peer with starting score
    peer_states.update_summary(peer, create_mock_storage_summary());
    let initial_score = get_peer_score(&peer_states, peer); // 50.0
    
    // Scenario 1: Byzantine peer sends 3 invalid proofs
    for _ in 0..3 {
        peer_states.update_score_success(peer);  // +1.0
        peer_states.update_score_error(peer, ErrorType::Malicious);  // ×0.8
    }
    let score_after_proofs = get_peer_score(&peer_states, peer);
    assert!(score_after_proofs < 30.0);  // Significantly penalized
    
    // Reset for Scenario 2
    peer_states.reset_peer_score(peer, 50.0);
    
    // Scenario 2: Byzantine peer causes 13 timeouts
    for _ in 0..13 {
        peer_states.update_score_error(peer, ErrorType::NotUseful);  // ×0.95
    }
    let score_after_timeouts = get_peer_score(&peer_states, peer);
    assert!(score_after_timeouts > 25.0);  // Still not ignored!
    assert!(score_after_timeouts > score_after_proofs);  // Better off with timeouts
    
    // Verify the peer is not ignored after 13 timeouts
    let peer_state = peer_states.get_peer_to_states().get(&peer).unwrap();
    assert!(!peer_state.is_ignored());
    
    println!("Score after 3 proof failures: {}", score_after_proofs);
    println!("Score after 13 timeouts: {}", score_after_timeouts);
    println!("Byzantine peer maintained higher score with timeouts!");
}
```

## Notes

The vulnerability exists at the intersection of the peer scoring system and error classification logic. The asymmetry between how successful responses (additive +1.0) and error responses (multiplicative penalties) are scored, combined with the differential treatment of timeouts vs proof failures, creates a strategic opportunity for Byzantine actors.

While this does not directly break consensus safety, it significantly degrades the network's ability to maintain liveness and performance under Byzantine conditions. The state-sync mechanism is critical for onboarding new validators and catching up lagging nodes, so any degradation here impacts overall network health.

The default configuration enables peer ignoring (`ignore_low_score_peers: true`), making all production deployments potentially vulnerable to this exploitation strategy.

### Citations

**File:** state-sync/aptos-data-client/src/peer_states.rs (L32-43)
```rust
/// Scores for peer rankings based on preferences and behavior.
const MAX_SCORE: f64 = 100.0;
const MIN_SCORE: f64 = 0.0;
const STARTING_SCORE: f64 = 50.0;
/// Add this score on a successful response.
const SUCCESSFUL_RESPONSE_DELTA: f64 = 1.0;
/// Not necessarily a malicious response, but not super useful.
const NOT_USEFUL_MULTIPLIER: f64 = 0.95;
/// Likely to be a malicious response.
const MALICIOUS_MULTIPLIER: f64 = 0.8;
/// Ignore a peer when their score dips below this threshold.
const IGNORE_PEER_THRESHOLD: f64 = 25.0;
```

**File:** state-sync/aptos-data-client/src/peer_states.rs (L45-52)
```rust
pub enum ErrorType {
    /// A response or error that's not actively malicious but also doesn't help
    /// us make progress, e.g., timeouts, remote errors, invalid data, etc...
    NotUseful,
    /// A response or error that appears to be actively hindering progress or
    /// attempting to deceive us, e.g., invalid proof.
    Malicious,
}
```

**File:** state-sync/aptos-data-client/src/peer_states.rs (L54-63)
```rust
impl From<ResponseError> for ErrorType {
    fn from(error: ResponseError) -> Self {
        match error {
            ResponseError::InvalidData | ResponseError::InvalidPayloadDataType => {
                ErrorType::NotUseful
            },
            ResponseError::ProofVerificationError => ErrorType::Malicious,
        }
    }
}
```

**File:** state-sync/aptos-data-client/src/peer_states.rs (L162-165)
```rust
    /// Updates the score of the peer according to a successful operation
    fn update_score_success(&mut self) {
        self.score = f64::min(self.score + SUCCESSFUL_RESPONSE_DELTA, MAX_SCORE);
    }
```

**File:** state-sync/aptos-data-client/src/peer_states.rs (L167-174)
```rust
    /// Updates the score of the peer according to an error
    fn update_score_error(&mut self, error: ErrorType) {
        let multiplier = match error {
            ErrorType::NotUseful => NOT_USEFUL_MULTIPLIER,
            ErrorType::Malicious => MALICIOUS_MULTIPLIER,
        };
        self.score = f64::max(self.score * multiplier, MIN_SCORE);
    }
```

**File:** state-sync/aptos-data-client/src/client.rs (L830-868)
```rust
            Err(error) => {
                // Convert network error and storage service error types into
                // data client errors. Also categorize the error type for scoring
                // purposes.
                let client_error = match error {
                    aptos_storage_service_client::Error::RpcError(rpc_error) => match rpc_error {
                        RpcError::NotConnected(_) => {
                            Error::DataIsUnavailable(rpc_error.to_string())
                        },
                        RpcError::TimedOut => {
                            Error::TimeoutWaitingForResponse(rpc_error.to_string())
                        },
                        _ => Error::UnexpectedErrorEncountered(rpc_error.to_string()),
                    },
                    aptos_storage_service_client::Error::StorageServiceError(err) => {
                        Error::UnexpectedErrorEncountered(err.to_string())
                    },
                    _ => Error::UnexpectedErrorEncountered(error.to_string()),
                };

                warn!(
                    (LogSchema::new(LogEntry::StorageServiceResponse)
                        .event(LogEvent::ResponseError)
                        .request_type(&request.get_label())
                        .request_id(id)
                        .peer(&peer)
                        .error(&client_error))
                );

                increment_request_counter(
                    &metrics::ERROR_RESPONSES,
                    client_error.get_label(),
                    peer,
                );

                self.notify_bad_response(id, peer, &request, ErrorType::NotUseful);
                Err(client_error)
            },
        }
```

**File:** config/src/config/state_sync_config.rs (L460-466)
```rust
impl Default for AptosDataClientConfig {
    fn default() -> Self {
        Self {
            enable_transaction_data_v2: true,
            data_poller_config: AptosDataPollerConfig::default(),
            data_multi_fetch_config: AptosDataMultiFetchConfig::default(),
            ignore_low_score_peers: true,
```
