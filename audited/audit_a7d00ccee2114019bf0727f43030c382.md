# Audit Report

## Title
Zero-Cost Comparison Operations During Gas Schedule Version Transition Window

## Summary
The versioned gas parameters for `std::cmp::compare` operations (`cmp_compare_base` and `cmp_compare_per_abs_val_unit`) introduced at RELEASE_V1_24 (gas feature version 28) create a critical vulnerability window where comparison operations execute with zero gas cost when `feature_version < 28`. This violates the Resource Limits invariant and enables resource exhaustion attacks during framework deployment transitions.

## Finding Description

The vulnerability stems from how versioned gas parameters are handled when the gas feature version doesn't match their version constraint. [1](#0-0) 

When `feature_version < 28`, the gas parameter extraction macro returns `None` for versioned parameters: [2](#0-1) 

These skipped parameters remain at their initialized zero values: [3](#0-2) 

The native comparison function always charges gas using these parameters: [4](#0-3) 

When both parameters are zero, the gas cost becomes `0 + 0 * (size1 + size2) = 0`, allowing unlimited free comparisons.

**Exploitation Window:**

The multi-step governance proposal system executes framework upgrades and gas schedule updates as separate proposals: [5](#0-4) 

This creates a window between framework deployment (containing `std::cmp` module) and gas schedule updates where:
1. The `std::cmp::compare` native function is registered and callable
2. Gas parameters remain at zero because `feature_version < 28`
3. Users can perform unlimited comparisons without gas charges

The natives are unconditionally registered regardless of gas version: [6](#0-5) 

Unlike missing required parameters which cause `VM_STARTUP_FAILURE`, versioned parameters at zero do not trigger errors and the system falls back to zero-cost execution when gas parameter loading encounters errors: [7](#0-6) 

## Impact Explanation

**Severity: High** ($50,000 bounty tier)

This vulnerability qualifies as High severity under Aptos bug bounty criteria for the following reasons:

1. **Gas Metering Bypass**: Violates Critical Invariant #9 ("Resource Limits: All operations must respect gas, storage, and computational limits"). Attackers can perform unlimited computational operations without gas payment.

2. **Validator Node Resource Exhaustion**: Repeated free comparison operations on large data structures can cause validator slowdowns, meeting the "Validator node slowdowns" criterion for High severity.

3. **Consensus Determinism Risk**: If validators have inconsistent gas schedules applied during the transition window (due to network partitions or delayed config propagation), they could charge different gas amounts for identical transactions, potentially causing state divergence.

4. **Protocol Violation**: Breaks the fundamental gas metering guarantee that all operations must be charged, enabling denial-of-service vectors during the vulnerable window.

While the vulnerability is time-limited to transition periods, its presence enables immediate exploitation the moment the framework is deployed but before gas parameters are updated.

## Likelihood Explanation

**Likelihood: Medium-High**

The vulnerability occurrence depends on the coordination between framework and gas schedule governance proposals:

**Factors Increasing Likelihood:**
- Multi-step proposals execute sequentially but not atomically
- Network propagation delays could cause validators to apply updates at different times
- Emergency framework hotfixes might not coordinate gas schedule updates
- Forked networks or testnets may deploy framework without proper gas schedule updates
- The vulnerability is inherent to the versioning design, not a deployment accident

**Factors Decreasing Likelihood:**
- Core team typically coordinates framework and gas updates in same release cycle
- Governance proposal execution is monitored and follows established procedures
- The window is typically short (hours to days) between coordinated proposals

However, the vulnerability's **exploitability is trivial** once the window exists - any user can call `std::cmp::compare` through normal Move transactions without special privileges.

## Recommendation

Implement strict validation to prevent native function execution when gas parameters are zero or missing:

**Option 1: Fail-Fast Validation**
Add validation in the native function wrapper to reject execution when gas parameters are uninitialized:

```rust
fn native_compare(
    context: &mut SafeNativeContext,
    _ty_args: &[Type],
    args: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    // Validate gas parameters are non-zero
    if CMP_COMPARE_BASE.evaluate(context.gas_feature_version(), context.native_gas_params()) == 0.into() {
        return Err(SafeNativeError::InvariantViolation(PartialVMError::new(
            StatusCode::FEATURE_UNDER_GATING,
        )));
    }
    
    let cost = CMP_COMPARE_BASE + CMP_COMPARE_PER_ABS_VAL_UNIT * ...;
    // ... rest of function
}
```

**Option 2: Coordinated Deployment**
Ensure framework and gas schedule updates are atomically bundled in the same governance proposal execution, preventing the vulnerability window from existing.

**Option 3: Minimum Gas Guarantees**
Modify the gas parameter macro to enforce minimum non-zero values for all gas parameters, even when versioned parameters don't match.

## Proof of Concept

```rust
// Test demonstrating zero-cost comparison exploitation
// File: aptos-move/e2e-move-tests/src/tests/zero_cost_cmp.rs

use crate::MoveHarness;
use aptos_types::account_address::AccountAddress;
use move_core_types::value::MoveValue;

#[test]
fn test_zero_cost_comparison_pre_v24() {
    let mut h = MoveHarness::new();
    
    // Set gas feature version to 27 (pre-RELEASE_V1_24)
    h.modify_gas_schedule_raw(|gas_schedule| {
        gas_schedule.feature_version = 27;
        // Remove cmp gas parameters as they don't exist in v27
        gas_schedule.entries.retain(|(key, _)| !key.starts_with("cmp."));
    });
    
    // Deploy test module that uses cmp::compare
    let acc = h.new_account_at(AccountAddress::from_hex_literal("0xcafe").unwrap());
    let result = h.run_entry_function(
        &acc,
        str::parse("0x1::cmp::compare").unwrap(),
        vec![],
        vec![
            bcs::to_bytes(&MoveValue::Vector(vec![MoveValue::U64(1)])).unwrap(),
            bcs::to_bytes(&MoveValue::Vector(vec![MoveValue::U64(2)])).unwrap(),
        ],
    );
    
    // Verify comparison succeeds with zero gas cost
    assert!(result.is_success());
    let gas_used = result.gas_used();
    
    // Gas should be close to zero (only VM overhead, no comparison cost)
    assert!(gas_used < 100, "Expected near-zero gas, got {}", gas_used);
}
```

## Notes

This vulnerability highlights a systemic design flaw in the gas parameter versioning system: versioned parameters that don't match the current feature version silently default to zero rather than preventing feature usage. While this provides backward compatibility, it creates dangerous exploitation windows during protocol upgrades. The issue is particularly concerning because:

1. The vulnerability is **intrinsic to the design**, not a deployment accident
2. It affects **all versioned native function gas parameters**, not just `cmp::compare`  
3. The exploitation requires **no special privileges** - any transaction can trigger it
4. It can cause **consensus divergence** if validators have different gas schedules applied

Future gas parameter additions should require explicit feature gates or minimum gas enforcement to prevent similar vulnerabilities.

### Citations

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/move_stdlib.rs (L48-49)
```rust
        [cmp_compare_base: InternalGas, { RELEASE_V1_24.. => "cmp.compare.base" }, 367],
        [cmp_compare_per_abs_val_unit: InternalGasPerAbstractValueUnit, { RELEASE_V1_24.. => "cmp.compare.per_abs_val_unit"}, 14],
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/macros.rs (L9-15)
```rust
    ({ $($ver: pat => $key: literal),+ }, $cur_ver: expr) => {
        match $cur_ver {
            $($ver => Some($key)),+,
            #[allow(unreachable_patterns)]
            _ => None,
        }
    }
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/macros.rs (L64-67)
```rust
            pub fn zeros() -> Self {
                Self {
                    $($name: 0.into()),*
                }
```

**File:** aptos-move/framework/move-stdlib/src/natives/cmp.rs (L48-52)
```rust
    let cost = CMP_COMPARE_BASE
        + CMP_COMPARE_PER_ABS_VAL_UNIT
            * (context.abs_val_size_dereferenced(&args[0])?
                + context.abs_val_size_dereferenced(&args[1])?);
    context.charge(cost)?;
```

**File:** aptos-move/aptos-release-builder/data/example.yaml (L4-23)
```yaml
  - name: framework
    metadata:
      title: ""
      description: ""
      source_code_url: ""
      discussion_url: ""
    execution_mode: MultiStep
    update_sequence:
      - Framework:
          bytecode_version: 7
          git_hash: ~
  - name: gas
    metadata:
      title: ""
      description: ""
      source_code_url: ""
      discussion_url: ""
    execution_mode: MultiStep
    update_sequence:
      - DefaultGas
```

**File:** aptos-move/framework/move-stdlib/src/natives/mod.rs (L38-41)
```rust
    builder.with_incremental_gas_charging(false, |builder| {
        add_natives!("bcs", bcs::make_all(builder));
        add_natives!("cmp", cmp::make_all(builder));
        add_natives!("hash", hash::make_all(builder));
```

**File:** aptos-move/aptos-vm-environment/src/environment.rs (L257-264)
```rust
            Err(_) => {
                let ty_builder = aptos_default_ty_builder();
                (
                    NativeGasParameters::zeros(),
                    MiscGasParameters::zeros(),
                    ty_builder,
                )
            },
```
