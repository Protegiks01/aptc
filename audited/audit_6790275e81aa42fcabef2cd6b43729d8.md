# Audit Report

## Title
VFN Deployment Exposes Validator Private Keys via Shared Kubernetes Secret

## Summary
The Validator Full Node (VFN) deployment architecture stores both `validator-identity.yaml` and `validator-full-node-identity.yaml` in the same Kubernetes secret, mounted to both validator and VFN pods. This allows an attacker who compromises a VFN to read the validator's consensus and network private keys, enabling validator impersonation, double-signing, and consensus safety violations.

## Finding Description

The security design in `generate_key_objects()` intentionally creates separate identity blobs for validators and VFNs, where the VFN blob omits sensitive keys: [1](#0-0) 

However, the production deployment pattern undermines this security separation. Both identity files are packaged into a single Kubernetes secret: [2](#0-1) [3](#0-2) 

This same secret is mounted to both validator and VFN pods: [4](#0-3) [5](#0-4) 

The testnet deployment code confirms both identity files are in the same secret: [6](#0-5) 

The secret is copied to a writable directory accessible by the VFN: [7](#0-6) 

**Attack Path:**
1. Attacker compromises VFN pod (shell access via container escape, vulnerable service, or supply chain attack)
2. Attacker reads `/opt/aptos/genesis/validator-identity.yaml` (contains validator's `consensus_private_key` and `network_private_key`)
3. Attacker exfiltrates these keys
4. Attacker runs malicious validator node using stolen keys, impersonating the legitimate validator
5. If both nodes are online simultaneously, this causes double-signing on consensus votes
6. ValidatorVerifier accepts messages from both because they share the same on-chain registered keys: [8](#0-7) 

The consensus messages are signed with the stolen consensus key and sent on the validator network: [9](#0-8) 

This breaks **Consensus Safety (Invariant #2)**: "AptosBFT must prevent double-spending and chain splits under < 1/3 Byzantine." A single compromised VFN effectively gives the attacker control of an additional validator vote, potentially contributing to Byzantine threshold violations.

## Impact Explanation

**Critical Severity - Consensus/Safety Violations**

This vulnerability meets the Critical severity criteria per Aptos bug bounty rules:
- **Consensus/Safety violations**: Enables validator impersonation and double-signing, directly threatening AptosBFT safety guarantees
- **Impact on network**: Every validator-VFN pair in the network is potentially vulnerable. With multiple compromised VFNs, attackers could accumulate Byzantine voting power
- **Systemic risk**: The shared secret pattern is the recommended deployment method in official documentation, affecting all production validators following best practices

The compromise breaks the fundamental security separation between validators (consensus participants) and VFNs (non-consensus nodes), violating the principle of least privilege designed into the key generation logic.

## Likelihood Explanation

**High Likelihood:**

1. **Attack Surface**: VFNs are more exposed than validators - they connect to public networks and serve API requests, making them more vulnerable to remote exploits
2. **Widespread Pattern**: This is the documented deployment method in official AWS and GCP guides, meaning most production validators are affected
3. **Attacker Motivation**: Compromising a VFN to gain validator access is extremely valuable - it provides consensus voting power without directly attacking the validator node's hardened security
4. **No Additional Authentication**: Once the VFN is compromised, reading the identity file requires no additional privilege escalation beyond filesystem access

The only barrier is initial VFN compromise, but VFNs are intentionally more accessible than validators, making this a realistic threat.

## Recommendation

**Implement Separate Secrets for Validator and VFN Identities:**

1. Create two distinct Kubernetes secrets:
   - `validator-genesis-secret`: Contains only `validator-identity.yaml`, `genesis.blob`, and `waypoint.txt`
   - `vfn-genesis-secret`: Contains only `validator-full-node-identity.yaml`, `genesis.blob`, and `waypoint.txt`

2. Mount validator secret only to validator pods, VFN secret only to VFN pods

3. Update deployment documentation:

```bash
# Validator secret (mounted only to validator pod)
$ kubectl create secret generic ${WORKSPACE}-validator-genesis-e1 \
    --from-file=genesis.blob=genesis.blob \
    --from-file=waypoint.txt=waypoint.txt \
    --from-file=validator-identity.yaml=validator-identity.yaml

# VFN secret (mounted only to VFN pod)  
$ kubectl create secret generic ${WORKSPACE}-vfn-genesis-e1 \
    --from-file=genesis.blob=genesis.blob \
    --from-file=waypoint.txt=waypoint.txt \
    --from-file=validator-full-node-identity.yaml=validator-full-node-identity.yaml
```

4. Update Helm templates to reference separate secrets based on node type

5. Add security warning in key generation documentation: "Never store validator and VFN identity files in the same secret or filesystem location accessible to the VFN"

## Proof of Concept

**Exploitation Steps (requires initial VFN compromise):**

```bash
# 1. Attacker gains shell access to compromised VFN pod
kubectl exec -it aptos-fullnode-0 -- /bin/bash

# 2. Verify secret is mounted with both identity files
ls -la /opt/aptos/genesis/
# Output shows: validator-identity.yaml, validator-full-node-identity.yaml

# 3. Exfiltrate validator's private keys
cat /opt/aptos/genesis/validator-identity.yaml
# Contains:
# - account_address
# - account_private_key  
# - consensus_private_key (BLS12-381 private key)
# - network_private_key (x25519 private key)

# 4. Attacker copies these keys to external system
# 5. Attacker launches malicious validator node with stolen keys
# 6. Malicious node connects to validator network using stolen network_private_key
#    (PeerId matches legitimate validator)
# 7. Malicious node signs consensus votes with stolen consensus_private_key
# 8. ValidatorVerifier accepts votes (signature and address match on-chain registration)
# 9. If both nodes online: double-signing occurs, violating consensus safety
```

**Verification that VFN has access:**

```bash
# Check deployed secret contents
kubectl get secret ${WORKSPACE}-aptos-node-genesis-e1 -o yaml

# Confirm both identity files are present in data section:
# - validator-identity.yaml: <base64-encoded-data>
# - validator-full-node-identity.yaml: <base64-encoded-data>

# Verify secret is mounted to both pods
kubectl describe pod validator-0 | grep genesis-config
kubectl describe pod fullnode-0 | grep genesis-config
# Both show the same secret mounted
```

**Notes**

This vulnerability exists at the deployment/infrastructure layer rather than the core protocol code. The key generation logic correctly implements security separation, but the deployment patterns documented in official guides undermine this design. The fix requires updating deployment practices, documentation, and Helm templates to maintain the intended security boundary between validator and VFN identities.

### Citations

**File:** crates/aptos-genesis/src/keys.rs (L53-58)
```rust
    let vfn_blob = IdentityBlob {
        account_address: Some(account_address),
        account_private_key: None,
        consensus_private_key: None,
        network_private_key: full_node_network_key.private_key(),
    };
```

**File:** terraform/aptos-node/aws/README.md (L181-186)
```markdown
    $ kubectl create secret generic ${WORKSPACE}-aptos-node-genesis-e1 \
        --from-file=genesis.blob=genesis.blob \
        --from-file=waypoint.txt=waypoint.txt \
        --from-file=validator-identity.yaml=validator-identity.yaml \
        --from-file=validator-full-node-identity.yaml=validator-full-node-identity.yaml
    ```
```

**File:** terraform/aptos-node/gcp/README.md (L191-196)
```markdown
    $ kubectl create secret generic ${WORKSPACE}-aptos-node-genesis-e1 \
        --from-file=genesis.blob=genesis.blob \
        --from-file=waypoint.txt=waypoint.txt \
        --from-file=validator-identity.yaml=validator-identity.yaml \
        --from-file=validator-full-node-identity.yaml=validator-full-node-identity.yaml
    ```
```

**File:** terraform/helm/aptos-node/templates/validator.yaml (L235-239)
```yaml
      - name: genesis-config
        # Current implementation of `forge::backend::k8s::stateful_set::{set_identity, get_identity}`
        # depends on the position of this volume item within the parent list.
        secret:
          secretName: {{ include "aptos-validator.fullname" $ }}-{{$i}}-genesis-e{{ $.Values.chain.era }}
```

**File:** terraform/helm/aptos-node/templates/fullnode.yaml (L130-147)
```yaml
            - |
              set -x
              cp /opt/aptos/genesis_readonly/* /opt/aptos/genesis
              if [ ! -f /opt/aptos/genesis/genesis.blob ]; then
                genesis_blob_upload_url="{{ $.Values.genesis_blob_upload_url }}"
                genesis_blob_upload_url="$genesis_blob_upload_url&namespace={{ $.Release.Namespace }}&method=GET"
                echo "genesis.blob not found locally, downloading..."
                signed_url=$(curl -s -X GET "$genesis_blob_upload_url")
                curl -o /opt/aptos/genesis/genesis.blob "$signed_url"
              else
                echo "genesis.blob found locally"
              fi
              ls -l /opt/aptos/genesis
          volumeMounts:
            - name: genesis-config
              mountPath: /opt/aptos/genesis_readonly
            - name: writable-genesis
              mountPath: /opt/aptos/genesis
```

**File:** terraform/helm/aptos-node/templates/fullnode.yaml (L251-253)
```yaml
      - name: genesis-config
        secret:
          secretName: {{ include "aptos-validator.fullname" $ }}-{{$i}}-genesis-e{{ $.Values.chain.era }}
```

**File:** testsuite/pangu_lib/testnet_commands/create_testnet.py (L753-760)
```python
    identity_data = {
        "validator-identity.yaml": system_context.filesystem.read(
            f"{node_info.user_dir}/validator-identity.yaml"
        ).decode("utf-8"),
        "validator-full-node-identity.yaml": system_context.filesystem.read(
            f"{node_info.user_dir}/validator-full-node-identity.yaml"
        ).decode("utf-8"),
    }
```

**File:** types/src/validator_verifier.rs (L254-267)
```rust
    /// Verify the correctness of a signature of a message by a known author.
    pub fn verify<T: Serialize + CryptoHash>(
        &self,
        author: AccountAddress,
        message: &T,
        signature: &bls12381::Signature,
    ) -> std::result::Result<(), VerifyError> {
        match self.get_public_key(&author) {
            Some(public_key) => public_key
                .verify_struct_signature(message, signature)
                .map_err(|_| VerifyError::InvalidMultiSignature),
            None => Err(VerifyError::UnknownAuthor),
        }
    }
```

**File:** consensus/src/network_interface.rs (L235-237)
```rust
    fn get_peer_network_id_for_peer(&self, peer: PeerId) -> PeerNetworkId {
        PeerNetworkId::new(NetworkId::Validator, peer)
    }
```
