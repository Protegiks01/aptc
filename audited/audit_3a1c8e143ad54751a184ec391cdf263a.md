# Audit Report

## Title
Partial Commit Proof Accepts Signatures for Mismatched LedgerInfos Due to Incomplete Validation

## Summary
The `add_signature_if_matched()` function in the consensus pipeline's buffer item management validates only the `BlockInfo` component when accepting commit vote signatures, failing to validate the complete `LedgerInfo` (which includes both `BlockInfo` and `consensus_data_hash`). This allows Byzantine validators to inject signatures for semantically different ledger states that share the same block metadata, causing honest nodes to waste computational resources on repeated signature aggregation failures and filtering cycles.

## Finding Description

The vulnerability exists in the signature acceptance logic for both `Executed` and `Signed` buffer item states. [1](#0-0) [2](#0-1) 

The `LedgerInfo` structure contains two critical fields that together define consensus commitment: [3](#0-2) 

The current validation compares only `commit_info` (the `BlockInfo` component), ignoring the `consensus_data_hash`. This violates the semantic integrity of the `LedgerInfo` structure, where the hash represents consensus-specific data critical to protocol correctness.

**Attack Propagation Path:**

1. Byzantine validator creates a `CommitVote` with valid signature for `LedgerInfo(BlockInfo_X, malicious_hash)` where `malicious_hash â‰  correct_hash`
2. Vote passes cryptographic verification since signature is valid for that specific LedgerInfo: [4](#0-3) 

3. Vote reaches `add_signature_if_matched()` which incorrectly accepts it based only on `BlockInfo` equality
4. Byzantine signature is added to aggregator: [5](#0-4) 

5. Node attempts aggregation when voting power threshold is reached: [6](#0-5) 

6. Aggregated signature verification fails because Byzantine signatures are for wrong `consensus_data_hash`: [7](#0-6) 

7. System filters invalid signatures and retries aggregation, wasting CPU cycles

## Impact Explanation

**Severity: High** (Validator Node Slowdowns / Significant Protocol Violations)

This vulnerability enables Byzantine validators to launch a **resource exhaustion attack** against honest nodes:

- **Computational DoS**: Each malicious signature triggers expensive BLS signature verification and aggregation operations that are designed to fail, wasting validator CPU resources
- **Liveness Degradation**: Honest nodes repeatedly attempt aggregation, fail verification, filter signatures, and retry, delaying consensus progress
- **Network Bandwidth Waste**: Nodes incorrectly ACK invalid votes, encouraging continued transmission of malicious data
- **State Confusion**: Voting power calculations temporarily include invalid signatures, creating misleading quorum metrics

While Byzantine validators cannot prevent eventual consensus (invalid signatures are filtered out), they can significantly degrade network performance and increase time-to-finality, affecting the user experience and potentially causing transaction delays.

The attack does not compromise consensus safety because:
- Invalid signatures are eventually filtered via cryptographic verification
- Honest 2f+1 quorum can still commit after filtering
- No double-signing or equivocation is enabled

## Likelihood Explanation

**Likelihood: High**

This vulnerability is **highly exploitable** because:

1. **Low Barrier to Entry**: Any validator (even with minimal stake) can execute the attack by sending malformed `CommitVote` messages
2. **No Detection**: The code incorrectly ACKs invalid votes, providing no feedback to prevent continued exploitation
3. **Amplification Factor**: Each invalid signature triggers multiple expensive cryptographic operations (aggregation attempt, verification failure, individual signature checks, filtering, re-aggregation)
4. **Persistent Effect**: Attack can be sustained across multiple rounds and blocks
5. **No Rate Limiting**: Each validator can contribute one malicious signature per block, and with sufficient Byzantine validators, the impact scales

The attack requires only:
- Control of any validator (Byzantine or compromised)
- Ability to compute valid signatures for incorrect `LedgerInfo` structures
- Standard network connectivity to send `CommitMessage::Vote`

## Recommendation

**Fix**: Validate complete `LedgerInfo` equality instead of only `BlockInfo`:

```rust
// For Executed state:
Self::Executed(executed) => {
    // Compare full LedgerInfo, not just BlockInfo
    if executed.partial_commit_proof.data() == vote.ledger_info() {
        executed
            .partial_commit_proof
            .add_signature(author, signature);
        return Ok(());
    }
},

// For Signed state:
Self::Signed(signed) => {
    // Compare full LedgerInfo, not just BlockInfo  
    if signed.partial_commit_proof.data() == vote.ledger_info() {
        signed.partial_commit_proof.add_signature(author, signature);
        return Ok(());
    }
},
```

**Additional Hardening**: Apply the same fix to `try_advance_to_aggregated_with_ledger_info()`: [8](#0-7) 

Change to:
```rust
assert_eq!(
    local_commit_proof.data(),
    commit_proof.ledger_info()
);
```

## Proof of Concept

```rust
// Add to consensus/src/pipeline/buffer_item.rs tests module

#[test]
fn test_mismatched_consensus_hash_rejection() {
    let (validator_signers, validator_verifier) = create_validators();
    let pipelined_block = create_pipelined_block();
    let block_info = pipelined_block.block_info();
    
    // Create correct LedgerInfo with consensus_data_hash = zero
    let correct_ledger_info = LedgerInfo::new(
        block_info.clone(), 
        HashValue::zero()
    );
    
    // Create malicious LedgerInfo with DIFFERENT consensus_data_hash
    let malicious_ledger_info = LedgerInfo::new(
        block_info.clone(),
        HashValue::random()  // Different hash!
    );
    
    let ordered_proof = LedgerInfoWithSignatures::new(
        correct_ledger_info.clone(), 
        AggregateSignature::empty()
    );
    
    // Create vote for CORRECT LedgerInfo
    let correct_vote = CommitVote::new(
        validator_signers[0].author(),
        correct_ledger_info.clone(),
        &validator_signers[0],
    ).unwrap();
    
    // Create vote for MALICIOUS LedgerInfo (same BlockInfo, different hash)
    let malicious_vote = CommitVote::new(
        validator_signers[1].author(),
        malicious_ledger_info.clone(),
        &validator_signers[1],
    ).unwrap();
    
    // Both votes have same commit_info
    assert_eq!(correct_vote.commit_info(), malicious_vote.commit_info());
    // But different ledger_info
    assert_ne!(correct_vote.ledger_info(), malicious_vote.ledger_info());
    
    let mut item = BufferItem::new_ordered(
        vec![pipelined_block.clone()],
        ordered_proof.clone(),
        HashMap::new(),
    );
    
    // Advance to executed
    item = item.advance_to_executed_or_aggregated(
        vec![pipelined_block.clone()],
        &validator_verifier,
        None,
        true,
    );
    
    // Add correct vote - should succeed
    assert!(item.add_signature_if_matched(correct_vote).is_ok());
    
    // Add malicious vote - CURRENTLY SUCCEEDS (BUG), should FAIL
    let result = item.add_signature_if_matched(malicious_vote);
    
    // With the fix, this should return Err
    // assert!(result.is_err(), "Should reject vote with mismatched consensus_data_hash");
    
    // Current buggy behavior: accepts the vote
    assert!(result.is_ok(), "BUG: Currently accepts mismatched vote");
    
    // Try to aggregate - will fail due to mismatched signature
    item = item.try_advance_to_aggregated(&validator_verifier);
    
    // Should still be in Executed state (aggregation failed)
    assert!(item.is_executed(), "Aggregation should fail with mismatched signatures");
}
```

## Notes

The vulnerability demonstrates a **partial validation failure** where cryptographic correctness (signature validity) is verified but semantic correctness (complete data structure equality) is not. The `consensus_data_hash` field is security-critical as it commits to consensus-specific data beyond the block metadata, and mixing signatures across different hash values violates the integrity model of BLS threshold signatures in the AptosBFT protocol.

### Citations

**File:** consensus/src/pipeline/buffer_item.rs (L243-246)
```rust
                assert_eq!(
                    local_commit_proof.data().commit_info(),
                    commit_proof.commit_info()
                );
```

**File:** consensus/src/pipeline/buffer_item.rs (L297-318)
```rust
                if signed_item
                    .partial_commit_proof
                    .check_voting_power(validator, true)
                    .is_ok()
                {
                    let _time = counters::VERIFY_MSG
                        .with_label_values(&["commit_vote_aggregate_and_verify"])
                        .start_timer();
                    if let Ok(commit_proof) = signed_item
                        .partial_commit_proof
                        .clone()
                        .aggregate_and_verify(validator)
                        .map(|(ledger_info, aggregated_sig)| {
                            LedgerInfoWithSignatures::new(ledger_info, aggregated_sig)
                        })
                    {
                        return Self::Aggregated(Box::new(AggregatedItem {
                            executed_blocks: signed_item.executed_blocks,
                            commit_proof,
                        }));
                    }
                }
```

**File:** consensus/src/pipeline/buffer_item.rs (L393-399)
```rust
            Self::Executed(executed) => {
                if executed.commit_info == *target_commit_info {
                    executed
                        .partial_commit_proof
                        .add_signature(author, signature);
                    return Ok(());
                }
```

**File:** consensus/src/pipeline/buffer_item.rs (L401-405)
```rust
            Self::Signed(signed) => {
                if signed.partial_commit_proof.data().commit_info() == target_commit_info {
                    signed.partial_commit_proof.add_signature(author, signature);
                    return Ok(());
                }
```

**File:** types/src/ledger_info.rs (L51-59)
```rust
#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize, CryptoHasher, BCSCryptoHash)]
#[cfg_attr(any(test, feature = "fuzzing"), derive(Arbitrary))]
pub struct LedgerInfo {
    commit_info: BlockInfo,

    /// Hash of consensus specific data that is opaque to all parts of the system other than
    /// consensus.
    consensus_data_hash: HashValue,
}
```

**File:** types/src/ledger_info.rs (L460-462)
```rust
    pub fn add_signature(&mut self, validator: AccountAddress, signature: &SignatureWithStatus) {
        self.signatures.insert(validator, signature.clone());
    }
```

**File:** types/src/ledger_info.rs (L517-535)
```rust
    pub fn aggregate_and_verify(
        &mut self,
        verifier: &ValidatorVerifier,
    ) -> Result<(T, AggregateSignature), VerifyError> {
        let aggregated_sig = self.try_aggregate(verifier)?;

        match verifier.verify_multi_signatures(&self.data, &aggregated_sig) {
            Ok(_) => {
                // We are not marking all the signatures as "verified" here, as two malicious
                // voters can collude and create a valid aggregated signature.
                Ok((self.data.clone(), aggregated_sig))
            },
            Err(_) => {
                self.filter_invalid_signatures(verifier);

                let aggregated_sig = self.try_aggregate(verifier)?;
                Ok((self.data.clone(), aggregated_sig))
            },
        }
```

**File:** consensus/consensus-types/src/pipeline/commit_vote.rs (L103-113)
```rust
    pub fn verify(&self, sender: Author, validator: &ValidatorVerifier) -> anyhow::Result<()> {
        ensure!(
            self.author() == sender,
            "Commit vote author {:?} doesn't match with the sender {:?}",
            self.author(),
            sender
        );
        validator
            .optimistic_verify(self.author(), &self.ledger_info, &self.signature)
            .context("Failed to verify Commit Vote")
    }
```
