# Audit Report

## Title
Non-Canonical JSON Serialization in UnsupportedJWK Breaks Consensus Determinism

## Summary
The `UnsupportedJWK::from(serde_json::Value)` implementation uses non-canonical JSON serialization (`to_string()`) to generate payload bytes and compute ID hashes. Different validators can receive the same JSON object with different key orderings from OIDC providers, producing different payload bytes, different ID hashes, and ultimately different BCS-serialized `ProviderJWKs` structures. This breaks consensus determinism, preventing validators from aggregating signatures into valid quorum certificates for JWK updates. [1](#0-0) 

## Finding Description

The vulnerability exists in the conversion of unsupported JSON Web Keys to the `UnsupportedJWK` type. When validators fetch JWKs from OIDC providers, any JWK that doesn't conform to the RSA_JWK format is converted to an `UnsupportedJWK` using the fallback path: [2](#0-1) 

This conversion uses `json_value.to_string()` which does NOT guarantee canonical JSON serialization. The serde_json library preserves the insertion order of JSON object keys as they were parsed, meaning two semantically identical JSON objects with different key orderings will produce different string representations.

**Attack Scenario:**

1. An OIDC provider serves an unsupported JWK format (e.g., EC key, new key type)
2. Different validators receive the same JWK with different key orderings due to:
   - Different backend servers with different JSON libraries
   - CDN caching with different serialization
   - Load balancer routing to different endpoints
   - Intentional manipulation by malicious provider

3. Example received by validators:
   - Validator A: `{"kty":"EC","kid":"abc","crv":"P-256","x":"...","y":"..."}`
   - Validator B: `{"kid":"abc","kty":"EC","crv":"P-256","x":"...","y":"..."}`

4. Each validator computes different payload bytes and ID hashes: [3](#0-2) 

5. These different `UnsupportedJWK` instances are wrapped in `JWKMoveStruct` and included in `ProviderJWKs`: [4](#0-3) 

6. Validators sign different BCS-serialized `ProviderJWKs` structures (note the `CryptoHasher` and `BCSCryptoHash` derives)

7. During consensus, when creating a `QuorumCertifiedUpdate`: [5](#0-4) 

8. Validators cannot aggregate signatures because they signed different data

9. During execution, multi-signature verification fails: [6](#0-5) 

**Flow Through System:**

1. JWKs are fetched by observers: [7](#0-6) 

2. Observations are processed by consensus manager: [8](#0-7) 

3. Validators sign and attempt to reach consensus: [9](#0-8) 

4. Quorum-certified update is submitted as validator transaction: [10](#0-9) 

5. Transaction fails verification and is rejected

This breaks the **Deterministic Execution** invariant - validators cannot produce identical state roots because they cannot agree on the byte representation of unsupported JWKs.

## Impact Explanation

**Severity: Critical**

This vulnerability causes **consensus liveness failure** for JWK updates, which qualifies as Critical severity under the Aptos bug bounty program:

- **Total loss of liveness** for the JWK consensus subsystem
- Validators cannot update on-chain JWK state when unsupported key formats are encountered
- Users of keyless accounts depending on these JWKs cannot transact if the JWK set becomes stale
- While not a complete network freeze, it prevents a critical authentication subsystem from functioning
- No recovery possible without removing the problematic OIDC provider or implementing a fix

The impact is amplified because:
1. The vulnerability can be triggered **accidentally** by legitimate OIDC providers changing their JSON serialization library
2. It can be **deliberately exploited** by malicious OIDC providers to prevent JWK updates
3. It affects **all validators simultaneously** - this is not a single-node issue
4. The system has **no fallback mechanism** to handle this scenario

The codebase demonstrates awareness of this issue through the TODO comment but it remains unfixed: [11](#0-10) 

For comparison, the codebase properly implements canonical JSON serialization for WebAuthn where determinism is critical: [12](#0-11) 

## Likelihood Explanation

**Likelihood: High**

This vulnerability is highly likely to occur because:

1. **No attacker privileges required**: Any OIDC provider (trusted or malicious) can trigger this
2. **Accidental triggering**: Legitimate providers using different JSON libraries, CDNs, or load balancers naturally produce non-canonical JSON
3. **Common scenario**: EC keys and new key types (Ed25519, etc.) are increasingly common and would all trigger the unsupported path
4. **No mitigations in place**: The code has a TODO but no protective measures
5. **Observable in production**: As soon as any major OIDC provider (Google, Facebook, Apple) rotates to a new key type not yet supported by Aptos, this could trigger

The only requirement is that an OIDC provider serves a non-RSA JWK format, which is a standard practice for supporting multiple signing algorithms.

## Recommendation

Implement canonical JSON serialization before hashing. The recommended approach is to sort JSON object keys alphabetically before serialization:

```rust
impl From<serde_json::Value> for UnsupportedJWK {
    fn from(json_value: serde_json::Value) -> Self {
        // Convert to canonical form by sorting keys recursively
        let canonical_json = canonicalize_json(&json_value);
        let payload = canonical_json.into_bytes();
        Self {
            id: HashValue::sha3_256_of(payload.as_slice()).to_vec(),
            payload,
        }
    }
}

fn canonicalize_json(value: &serde_json::Value) -> String {
    match value {
        serde_json::Value::Object(map) => {
            let mut sorted: Vec<_> = map.iter().collect();
            sorted.sort_by_key(|(k, _)| *k);
            let entries: Vec<String> = sorted
                .iter()
                .map(|(k, v)| format!("\"{}\":{}", k, canonicalize_json(v)))
                .collect();
            format!("{{{}}}", entries.join(","))
        },
        serde_json::Value::Array(arr) => {
            let elements: Vec<String> = arr.iter().map(canonicalize_json).collect();
            format!("[{}]", elements.join(","))
        },
        _ => value.to_string(),
    }
}
```

Alternatively, use a canonical JSON library like `serde_jcs` (JSON Canonicalization Scheme, RFC 8785):

```rust
use serde_jcs;

impl From<serde_json::Value> for UnsupportedJWK {
    fn from(json_value: serde_json::Value) -> Self {
        // Use RFC 8785 JSON Canonicalization Scheme
        let payload = serde_jcs::to_vec(&json_value)
            .expect("JSON canonicalization failed");
        Self {
            id: HashValue::sha3_256_of(payload.as_slice()).to_vec(),
            payload,
        }
    }
}
```

## Proof of Concept

```rust
#[test]
fn test_non_canonical_json_produces_different_hashes() {
    use aptos_types::jwks::{jwk::JWK, unsupported::UnsupportedJWK};
    use aptos_crypto::HashValue;
    use serde_json::json;
    
    // Same semantic JSON object with different key orderings
    let json1_str = r#"{"kty":"EC","kid":"test123","crv":"P-256","x":"abc","y":"def"}"#;
    let json2_str = r#"{"kid":"test123","kty":"EC","crv":"P-256","x":"abc","y":"def"}"#;
    
    let json1: serde_json::Value = serde_json::from_str(json1_str).unwrap();
    let json2: serde_json::Value = serde_json::from_str(json2_str).unwrap();
    
    // Both should fail RSA parsing and become UnsupportedJWK
    let jwk1 = JWK::from(json1);
    let jwk2 = JWK::from(json2);
    
    let unsupported1 = match jwk1 {
        JWK::Unsupported(u) => u,
        _ => panic!("Expected UnsupportedJWK"),
    };
    
    let unsupported2 = match jwk2 {
        JWK::Unsupported(u) => u,
        _ => panic!("Expected UnsupportedJWK"),
    };
    
    // Payloads will be different due to key ordering
    assert_ne!(unsupported1.payload, unsupported2.payload);
    
    // IDs (hashes) will be different
    assert_ne!(unsupported1.id, unsupported2.id);
    
    // When BCS-serialized as part of ProviderJWKs, these will produce different hashes
    // that validators will sign, breaking consensus
    let bcs1 = bcs::to_bytes(&unsupported1).unwrap();
    let bcs2 = bcs::to_bytes(&unsupported2).unwrap();
    assert_ne!(bcs1, bcs2);
    
    println!("Payload 1: {}", String::from_utf8_lossy(&unsupported1.payload));
    println!("Payload 2: {}", String::from_utf8_lossy(&unsupported2.payload));
    println!("ID 1: {}", hex::encode(&unsupported1.id));
    println!("ID 2: {}", hex::encode(&unsupported2.id));
    println!("This demonstrates that validators receiving the same JWK with different");
    println!("key orderings will compute different IDs and fail to reach consensus.");
}
```

**Notes:**
- The vulnerability is real and exploitable without any validator privileges
- It affects the critical JWK consensus subsystem used for keyless accounts
- The fix is straightforward: implement canonical JSON serialization
- The TODO comment at line 53 confirms the developers were aware of this concern
- This breaks the fundamental determinism requirement for blockchain consensus systems

### Citations

**File:** types/src/jwks/unsupported/mod.rs (L51-59)
```rust
impl From<serde_json::Value> for UnsupportedJWK {
    fn from(json_value: serde_json::Value) -> Self {
        let payload = json_value.to_string().into_bytes(); //TODO: canonical to_string.
        Self {
            id: HashValue::sha3_256_of(payload.as_slice()).to_vec(),
            payload,
        }
    }
}
```

**File:** types/src/jwks/jwk/mod.rs (L80-89)
```rust
impl From<serde_json::Value> for JWK {
    fn from(value: serde_json::Value) -> Self {
        match RSA_JWK::try_from(&value) {
            Ok(rsa) => Self::RSA(rsa),
            Err(_) => {
                let unsupported = UnsupportedJWK::from(value);
                Self::Unsupported(unsupported)
            },
        }
    }
```

**File:** types/src/jwks/mod.rs (L122-128)
```rust
#[derive(Clone, Default, Eq, PartialEq, Serialize, Deserialize, CryptoHasher, BCSCryptoHash)]
pub struct ProviderJWKs {
    #[serde(with = "serde_bytes")]
    pub issuer: Issuer,
    pub version: u64,
    pub jwks: Vec<JWKMoveStruct>,
}
```

**File:** types/src/jwks/mod.rs (L303-307)
```rust
#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize, CryptoHasher, BCSCryptoHash)]
pub struct QuorumCertifiedUpdate {
    pub update: ProviderJWKs,
    pub multi_sig: AggregateSignature,
}
```

**File:** aptos-move/aptos-vm/src/validator_txns/jwk.rs (L139-142)
```rust
        // Verify multi-sig.
        verifier
            .verify_multi_signatures(&observed, &multi_sig)
            .map_err(|_| Expected(MultiSigVerificationFailed))?;
```

**File:** crates/jwk-utils/src/lib.rs (L34-36)
```rust
    let JWKsResponse { keys } = request_builder.send().await?.json().await?;
    let jwks = keys.into_iter().map(JWK::from).collect();
    Ok(jwks)
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager/mod.rs (L150-152)
```rust
                (issuer, jwks) = local_observation_rx.select_next_some() => {
                    let jwks = jwks.into_iter().map(JWKMoveStruct::from).collect();
                    this.process_new_observation(issuer, jwks)
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager/mod.rs (L202-205)
```rust
            let signature = self
                .consensus_key
                .sign(&observed)
                .context("process_new_observation failed with signing error")?;
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager/mod.rs (L335-338)
```rust
                let txn = ValidatorTransaction::ObservedJWKUpdate(update.clone());
                let vtxn_guard =
                    self.vtxn_pool
                        .put(Topic::JWK_CONSENSUS(issuer.clone()), Arc::new(txn), None);
```

**File:** types/src/transaction/webauthn.rs (L418-466)
```rust
    /// This is the custom serialization of [`CollectedClientData`](CollectedClientData)
    /// that is performed by the device authenticator, referenced in the WebAuthn spec, under
    /// Section ยง5.8.1.1 Serialization.
    ///
    /// This is helpful for ensuring that the serialization of [`CollectedClientData`](CollectedClientData)
    /// is identical to the device authenticator's output for clientDataJSON in client assertions.
    ///
    /// The serialization of the [`CollectedClientData`](CollectedClientData)
    /// is a subset of the algorithm for JSON-serializing
    /// to bytes. I.e. it produces a valid JSON encoding of the `CollectedClientData` but also provides
    /// additional structure that may be exploited by verifiers to avoid integrating a full JSON parser.
    /// While verifiers are recommended to perform standard JSON parsing, they may use the more
    /// limited algorithm below in contexts where a full JSON parser is too large. This verification
    /// algorithm requires only base64url encoding, appending of bytestrings (which could be
    /// implemented by writing into a fixed template), and three conditional checks (assuming that
    /// inputs are known not to need escaping).
    ///
    /// The serialization algorithm works by appending successive byte strings to an, initially empty,
    /// partial result until the complete result is obtained.
    ///
    /// 1. Let result be an empty byte string.
    /// 2. Append 0x7b2274797065223a ({"type":) to result.
    /// 3. Append CCDToString(type) to result.
    /// 4. Append 0x2c226368616c6c656e6765223a (,"challenge":) to result.
    /// 5. Append CCDToString(challenge) to result.
    /// 6. Append 0x2c226f726967696e223a (,"origin":) to result.
    /// 7. Append CCDToString(origin) to result.
    /// 8. Append 0x2c2263726f73734f726967696e223a (,"crossOrigin":) to result.
    /// 9. If crossOrigin is not present, or is false:
    ///     1. Append 0x66616c7365 (false) to result.
    /// 10. Otherwise:
    ///     1. Append 0x74727565 (true) to result.
    /// 11. Create a temporary copy of the CollectedClientData and remove the fields
    ///     type, challenge, origin, and crossOrigin (if present).
    /// 12. If no fields remain in the temporary copy then:
    ///     1. Append 0x7d (}) to result.
    /// 13. Otherwise:
    ///     1. Invoke serialize JSON to bytes on the temporary copy to produce a byte string remainder.
    ///         (see below for how this is done)
    ///     2. Append 0x2c (,) to result.
    ///     3. Remove the leading byte from remainder.
    ///     4. Append remainder to result.
    /// 14. The result of the serialization is the value of result.
    ///
    /// From step 13.1
    /// To serialize a JavaScript value to JSON bytes, given a JavaScript value value:
    ///     1. Let string be the result of serializing a JavaScript value to a JSON string given value.
    ///     2. Return the result of running UTF-8 encode on string.
    fn collected_client_data_to_json_bytes(ccd: &CollectedClientData) -> Vec<u8> {
```
