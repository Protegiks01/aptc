# Audit Report

## Title
Index Orphaning in Transaction Pruning Leads to API Failures and Data Inconsistency

## Summary
When storage sharding is disabled (`enable_storage_sharding = false`), the transaction pruning mechanism fails to prune `OrderedTransactionByAccountSchema` indices while successfully pruning the actual transaction data. This creates orphaned index entries that reference non-existent transactions, causing API queries to fail with `NotFound` errors and resulting in database inconsistency.

## Finding Description

The vulnerability exists in the transaction pruning logic when `internal_indexer_db` is `None`, which occurs when storage sharding is disabled.

**Write Path:** During transaction commits, when `skip_index_and_usage` is `false` (which equals `!enable_storage_sharding`), the system writes index entries to `OrderedTransactionByAccountSchema` mapping `(account_address, sequence_number)` to transaction `version`. [1](#0-0) 

**Pruning Path:** The `TransactionPruner::prune()` method successfully prunes `TransactionSchema`, `TransactionByHashSchema`, and `TransactionSummariesByAccountSchema`, but conditionally prunes `OrderedTransactionByAccountSchema` only when `internal_indexer_db.is_some()`: [2](#0-1) 

**Configuration Constraint:** The config sanitizer enforces that when storage sharding is disabled, `internal_indexer_db` must be `None`: [3](#0-2) 

**Default Configuration:** The default configuration has storage sharding disabled and internal indexer disabled: [4](#0-3) 

**Query Failure:** When clients query using `get_account_ordered_transaction_version()`, they receive version numbers from orphaned indices. Attempting to fetch these transactions via `get_transaction()` results in `AptosDbError::NotFound`: [5](#0-4) [6](#0-5) 

This breaks the **State Consistency** invariant: the database maintains inconsistent state where indices reference pruned data, violating the requirement that state transitions be atomic and verifiable.

## Impact Explanation

**High Severity** per Aptos bug bounty criteria:

1. **API Crashes**: Queries for account transactions by sequence number fail with `NotFound` errors, breaking API reliability
2. **Significant Protocol Violations**: Database maintains inconsistent state with orphaned indices
3. **Node Service Degradation**: Affects all nodes running with pruning enabled and storage sharding disabled, which includes default and common configurations

This does not reach Critical severity as it doesn't cause loss of funds, consensus violations, or permanent network unavailability, but significantly impacts node operations and client applications.

## Likelihood Explanation

**High Likelihood:**

1. **Automatic Occurrence**: This happens automatically on any node with pruning enabled (`ledger_pruner_config` active) and storage sharding disabled
2. **Common Configuration**: Storage sharding disabled is the default configuration and may be used by many nodes
3. **No Attacker Required**: The vulnerability manifests through normal pruning operations without malicious input
4. **Inevitable Accumulation**: As the chain grows and pruning occurs, orphaned indices continuously accumulate

The main node initialization uses this configuration path: [7](#0-6) 

## Recommendation

The `TransactionPruner::prune()` method must unconditionally prune `OrderedTransactionByAccountSchema` when indices were written to the main database. Fix the conditional logic:

```rust
// Current buggy code at transaction_pruner.rs lines 58-72
if let Some(indexer_db) = self.internal_indexer_db.as_ref() {
    if indexer_db.transaction_enabled() {
        // Prune to indexer_db
    } else {
        // Prune to main batch
    }
}
// Missing: else clause to prune when internal_indexer_db is None

// Fixed code:
if let Some(indexer_db) = self.internal_indexer_db.as_ref() {
    if indexer_db.transaction_enabled() {
        let mut index_batch = SchemaBatch::new();
        self.transaction_store
            .prune_transaction_by_account(&candidate_transactions, &mut index_batch)?;
        index_batch.put::<InternalIndexerMetadataSchema>(
            &IndexerMetadataKey::TransactionPrunerProgress,
            &IndexerMetadataValue::Version(target_version),
        )?;
        indexer_db.get_inner_db_ref().write_schemas(index_batch)?;
    } else {
        self.transaction_store
            .prune_transaction_by_account(&candidate_transactions, &mut batch)?;
    }
} else {
    // ADDED: When internal_indexer_db is None, still need to prune indices written to main DB
    self.transaction_store
        .prune_transaction_by_account(&candidate_transactions, &mut batch)?;
}
```

## Proof of Concept

```rust
// Test demonstrating the vulnerability
#[test]
fn test_index_orphaning_without_internal_indexer() {
    use aptos_temppath::TempPath;
    use aptos_config::config::{RocksdbConfigs, NO_OP_STORAGE_PRUNER_CONFIG};
    use aptos_storage_interface::DbWriter;
    
    let tmpdir = TempPath::new();
    
    // Open DB without storage sharding (default config)
    let mut rocksdb_config = RocksdbConfigs::default();
    rocksdb_config.enable_storage_sharding = false; // Triggers the bug
    
    let db = AptosDB::open(
        StorageDirPaths::from_path(&tmpdir),
        false,
        NO_OP_STORAGE_PRUNER_CONFIG,
        rocksdb_config,
        false,
        1000,
        10000,
        None, // internal_indexer_db = None
        HotStateConfig::default(),
    ).unwrap();
    
    // Write transactions with indices
    // ... (commit transactions 0-100 with user signed transactions)
    
    // Enable pruning and prune transactions 0-50
    // ... (configure pruner and execute pruning)
    
    // Verify bug: TransactionSchema entries are gone
    for v in 0..50 {
        assert!(db.get_transaction(v).is_err()); // NotFound
    }
    
    // Verify bug: OrderedTransactionByAccountSchema entries remain (orphaned)
    let version = db.transaction_store
        .get_account_ordered_transaction_version(sender_addr, 0, 100)
        .unwrap();
    assert!(version.is_some()); // Index still exists!
    
    // Verify bug: Query returns version but transaction fetch fails
    let v = version.unwrap();
    assert!(v < 50); // Points to pruned transaction
    assert!(db.get_transaction(v).is_err()); // Fails with NotFound!
    
    // This demonstrates the inconsistency: index points to non-existent data
}
```

**Notes:**
This vulnerability affects nodes running with the default or common configuration where storage sharding is disabled. The orphaned indices accumulate over time as pruning occurs, leading to persistent API failures for account transaction queries. The fix requires adding an `else` clause to ensure `OrderedTransactionByAccountSchema` is pruned regardless of whether `internal_indexer_db` exists.

### Citations

**File:** storage/aptosdb/src/ledger_db/transaction_db.rs (L56-60)
```rust
    pub(crate) fn get_transaction(&self, version: Version) -> Result<Transaction> {
        self.db
            .get::<TransactionSchema>(&version)?
            .ok_or_else(|| AptosDbError::NotFound(format!("Txn {version}")))
    }
```

**File:** storage/aptosdb/src/ledger_db/transaction_db.rs (L137-146)
```rust
        if !skip_index {
            if let Some(txn) = transaction.try_as_signed_user_txn() {
                if let ReplayProtector::SequenceNumber(seq_num) = txn.replay_protector() {
                    batch.put::<OrderedTransactionByAccountSchema>(
                        &(txn.sender(), seq_num),
                        &version,
                    )?;
                }
            }
        }
```

**File:** storage/aptosdb/src/pruner/ledger_pruner/transaction_pruner.rs (L58-72)
```rust
        if let Some(indexer_db) = self.internal_indexer_db.as_ref() {
            if indexer_db.transaction_enabled() {
                let mut index_batch = SchemaBatch::new();
                self.transaction_store
                    .prune_transaction_by_account(&candidate_transactions, &mut index_batch)?;
                index_batch.put::<InternalIndexerMetadataSchema>(
                    &IndexerMetadataKey::TransactionPrunerProgress,
                    &IndexerMetadataValue::Version(target_version),
                )?;
                indexer_db.get_inner_db_ref().write_schemas(index_batch)?;
            } else {
                self.transaction_store
                    .prune_transaction_by_account(&candidate_transactions, &mut batch)?;
            }
        }
```

**File:** config/src/config/internal_indexer_db_config.rs (L69-79)
```rust
impl Default for InternalIndexerDBConfig {
    fn default() -> Self {
        Self {
            enable_transaction: false,
            enable_event: false,
            enable_event_v2_translation: false,
            event_v2_translation_ignores_below_version: 0,
            enable_statekeys: false,
            batch_size: 10_000,
        }
    }
```

**File:** config/src/config/internal_indexer_db_config.rs (L91-99)
```rust
        // Shouldn't turn on internal indexer for db without sharding
        if !node_config.storage.rocksdb_configs.enable_storage_sharding
            && config.is_internal_indexer_db_enabled()
        {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "Don't turn on internal indexer db if DB sharding is off".into(),
            ));
        }
```

**File:** storage/aptosdb/src/transaction_store/mod.rs (L36-52)
```rust
    pub fn get_account_ordered_transaction_version(
        &self,
        address: AccountAddress,
        sequence_number: u64,
        ledger_version: Version,
    ) -> Result<Option<Version>> {
        if let Some(version) =
            self.ledger_db
                .transaction_db_raw()
                .get::<OrderedTransactionByAccountSchema>(&(address, sequence_number))?
        {
            if version <= ledger_version {
                return Ok(Some(version));
            }
        }
        Ok(None)
    }
```

**File:** aptos-node/src/storage.rs (L55-65)
```rust
    let internal_indexer_db = InternalIndexerDBService::get_indexer_db(node_config);
    let (update_sender, update_receiver) = if internal_indexer_db.is_some() {
        let (sender, receiver) = channel::<(Instant, Version)>((Instant::now(), 0 as Version));
        (Some(sender), Some(receiver))
    } else {
        (None, None)
    };

    let (aptos_db_reader, db_rw, backup_service) = match FastSyncStorageWrapper::initialize_dbs(
        node_config,
        internal_indexer_db.clone(),
```
