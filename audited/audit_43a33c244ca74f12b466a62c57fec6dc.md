# Audit Report

## Title
Unauthenticated Peer Score Information Disclosure Enables Eclipse Attack Planning and Malicious Peer Evasion

## Summary
The Aptos inspection service exposes detailed peer scoring information through an unauthenticated HTTP endpoint (`/peer_information` on port 9101). This endpoint reveals internal peer reputation metrics, including exact scores (0-100 range), which peers are near the ignore threshold (â‰¤25), and request/response patterns. This information disclosure enables attackers to plan eclipse attacks more effectively and allows malicious peers to monitor their own reputation and adapt behavior to evade detection.

## Finding Description

The inspection service endpoint `/peer_information` exposes sensitive peer scoring data without authentication. [1](#0-0) 

The endpoint is enabled by default and binds to all network interfaces (0.0.0.0). [2](#0-1) 

The exposed peer scores are critical security metrics used to exclude misbehaving peers. Scores range from 0-100, starting at 50, increasing by 1 on successful responses, and decreasing by multiplication factors (0.95 for "not useful" errors, 0.8 for "malicious" errors). Peers with scores at or below 25 are ignored when `ignore_low_score_peers` is enabled (default). [3](#0-2) 

The vulnerable code path exposes these scores through the state sync metadata display: [4](#0-3) 

The peer scoring system is designed as a reputation mechanism where ignored peers cannot service requests: [5](#0-4) 

This security-through-obscurity mechanism is completely undermined when scores are publicly visible. Attackers can:

1. **Eclipse Attack Planning**: Query the victim node to identify honest peers with borderline scores (26-30), then target those specific peers with attacks to push them below the ignore threshold, forcing the victim to rely on attacker-controlled or unreliable peers.

2. **Adaptive Malicious Behavior**: A malicious peer can periodically query its own score on victim nodes, behaving honestly when scores drop too low to avoid being ignored, then resuming malicious activity once scores recover.

3. **Strategic Peer Targeting**: Identify which peers the node relies on most (via request/response counts), then target those specific peers with network-level attacks.

The inspection service has no authentication mechanism, unlike other sensitive services in the codebase. [6](#0-5) 

## Impact Explanation

This vulnerability qualifies as **High severity** because it constitutes a significant protocol violation by exposing internal security state that directly undermines the peer reputation defense mechanism. While the information disclosure itself doesn't immediately cause fund loss or consensus violations, it significantly facilitates network-level attacks that can lead to:

- **Validator node slowdowns**: Eclipse attacks enabled by this information can isolate nodes from honest peers, degrading state synchronization performance
- **Protocol security violations**: The peer scoring system is a core security component designed to exclude malicious actors; making it transparent defeats its protective purpose
- **Increased attack surface**: Transforms a defense mechanism into an intelligence source for attackers

This exceeds "minor information leaks" (Low severity) because it exposes an entire security-critical subsystem, not just isolated metadata.

## Likelihood Explanation

This vulnerability is **highly likely** to be exploited because:

1. **No authentication required**: Any network-accessible attacker can query the endpoint
2. **Enabled by default**: The `expose_peer_information` flag defaults to `true` with no mainnet-specific sanitization (unlike `expose_configuration`)
3. **Public accessibility**: The service binds to 0.0.0.0, making it accessible from external networks unless specifically firewalled
4. **Simple exploitation**: A basic HTTP GET request reveals all peer scores
5. **High attacker motivation**: Eclipse attacks and network topology mapping are valuable for sophisticated attackers targeting blockchain networks

## Recommendation

Implement the following security controls:

1. **Disable by default for production networks**: [2](#0-1) 

Change default to `expose_peer_information: false` for mainnet deployments, similar to `expose_configuration`.

2. **Add mainnet sanitization check**: [7](#0-6) 

Extend the sanitizer to reject `expose_peer_information: true` on mainnet validators.

3. **Implement authentication**: Add passcode-based authentication similar to the admin service, or restrict access to localhost only (bind to 127.0.0.1 instead of 0.0.0.0).

4. **Remove or redact sensitive fields**: If peer information must be exposed for debugging, remove the exact score values and only show boolean "ignored" status.

5. **Add configuration warning**: Document in node operator guides that enabling this endpoint on production networks creates security risks.

## Proof of Concept

```bash
# Step 1: Query an Aptos node's peer information endpoint (no authentication needed)
curl http://[target-node-ip]:9101/peer_information

# Step 2: Parse the response to extract peer scores
# Example output shows:
# State sync metadata for each peer:
#   - Peer: 00000000000000000000000000000000/validator, score: 48.5, bucket ID: 0
#   - Peer: 11111111111111111111111111111111/validator, score: 26.3, bucket ID: 1
#   - Peer: 22222222222222222222222222222222/validator, score: 89.1, bucket ID: 2

# Step 3: Attacker identifies peer 11111111... has score 26.3 (near ignore threshold of 25)
# Step 4: Attacker sends malicious traffic or DoS targeting peer 11111111...
# Step 5: Peer's score drops below 25, victim node ignores it
# Step 6: Attacker repeats for other borderline peers to isolate the victim

# Alternative attack: Malicious peer monitors its own score
# If score = 28, continue malicious behavior
# If score = 26, temporarily behave honestly to recover
# Cycle continues, maximizing harm while evading permanent ignoring
```

**Reproduction steps**:
1. Start an Aptos fullnode with default configuration (port 9101 exposed)
2. From external host: `curl http://[node-ip]:9101/peer_information`
3. Observe complete peer score disclosure without authentication
4. Correlate scores with peer behaviors to plan targeted attacks

## Notes

The vulnerability exists because the inspection service was designed for debugging without considering production security implications. The `expose_peer_information` flag provides an opt-out mechanism, but defaulting to `true` and lacking mainnet-specific protections (unlike the stricter `expose_configuration` controls) creates a security gap. While peer priorities (High/Medium/Low) are determined by network topology rather than scores, the score-based ignore mechanism is a critical secondary defense that becomes ineffective when transparent to attackers.

### Citations

**File:** crates/aptos-inspection-service/src/server/peer_information.rs (L21-38)
```rust
pub fn handle_peer_information_request(
    node_config: &NodeConfig,
    aptos_data_client: AptosDataClient,
    peers_and_metadata: Arc<PeersAndMetadata>,
) -> (StatusCode, Body, String) {
    // Only return peer information if the endpoint is enabled
    let (status_code, body) = if node_config.inspection_service.expose_peer_information {
        let peer_information = get_peer_information(aptos_data_client, peers_and_metadata);
        (StatusCode::OK, Body::from(peer_information))
    } else {
        (
            StatusCode::FORBIDDEN,
            Body::from(PEER_INFO_DISABLED_MESSAGE),
        )
    };

    (status_code, body, CONTENT_TYPE_TEXT.into())
}
```

**File:** crates/aptos-inspection-service/src/server/peer_information.rs (L236-254)
```rust
    // Fetch and display the state sync metadata for each peer
    let peer_to_state = aptos_data_client.get_peer_states().get_peer_to_states();
    for peer in all_peers {
        if let Some(peer_state_entry) = peer_to_state.get(peer) {
            // Get the peer states
            let peer = *peer_state_entry.key();
            let peer_bucket_id = peer_states::get_bucket_id_for_peer(peer);
            let peer_score = peer_state_entry.get_score();
            let peer_storage_summary = peer_state_entry.get_storage_summary();

            // Display the peer states
            peer_information_output.push(format!(
                "\t- Peer: {}, score: {}, bucket ID: {}",
                peer, peer_score, peer_bucket_id
            ));
            peer_information_output.push(format!(
                "\t\t- Advertised storage summary: {:?}",
                peer_storage_summary
            ));
```

**File:** config/src/config/inspection_service_config.rs (L26-37)
```rust
impl Default for InspectionServiceConfig {
    fn default() -> InspectionServiceConfig {
        InspectionServiceConfig {
            address: "0.0.0.0".to_string(),
            port: 9101,
            expose_configuration: false,
            expose_identity_information: true,
            expose_peer_information: true,
            expose_system_information: true,
        }
    }
}
```

**File:** config/src/config/inspection_service_config.rs (L45-68)
```rust
impl ConfigSanitizer for InspectionServiceConfig {
    fn sanitize(
        node_config: &NodeConfig,
        node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();
        let inspection_service_config = &node_config.inspection_service;

        // Verify that mainnet validators do not expose the configuration
        if let Some(chain_id) = chain_id {
            if node_type.is_validator()
                && chain_id.is_mainnet()
                && inspection_service_config.expose_configuration
            {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "Mainnet validators should not expose the node configuration!".to_string(),
                ));
            }
        }

        Ok(())
    }
```

**File:** state-sync/aptos-data-client/src/peer_states.rs (L32-43)
```rust
/// Scores for peer rankings based on preferences and behavior.
const MAX_SCORE: f64 = 100.0;
const MIN_SCORE: f64 = 0.0;
const STARTING_SCORE: f64 = 50.0;
/// Add this score on a successful response.
const SUCCESSFUL_RESPONSE_DELTA: f64 = 1.0;
/// Not necessarily a malicious response, but not super useful.
const NOT_USEFUL_MULTIPLIER: f64 = 0.95;
/// Likely to be a malicious response.
const MALICIOUS_MULTIPLIER: f64 = 0.8;
/// Ignore a peer when their score dips below this threshold.
const IGNORE_PEER_THRESHOLD: f64 = 25.0;
```

**File:** state-sync/aptos-data-client/src/peer_states.rs (L142-160)
```rust
    /// Returns the storage summary iff the peer is not below the ignore threshold
    pub fn get_storage_summary_if_not_ignored(&self) -> Option<&StorageServerSummary> {
        if self.is_ignored() {
            None
        } else {
            self.storage_summary.as_ref()
        }
    }

    /// Returns true iff the peer is currently ignored
    fn is_ignored(&self) -> bool {
        // Only ignore peers if the config allows it
        if !self.data_client_config.ignore_low_score_peers {
            return false;
        }

        // Otherwise, ignore peers with a low score
        self.score <= IGNORE_PEER_THRESHOLD
    }
```

**File:** crates/aptos-inspection-service/src/server/mod.rs (L103-169)
```rust
/// A simple helper function that handles each endpoint request
async fn serve_requests(
    req: Request<Body>,
    node_config: NodeConfig,
    aptos_data_client: AptosDataClient,
    peers_and_metadata: Arc<PeersAndMetadata>,
) -> Result<Response<Body>, hyper::Error> {
    // Process the request and get the response components
    let (status_code, body, content_type) = match req.uri().path() {
        CONFIGURATION_PATH => {
            // /configuration
            // Exposes the node configuration
            configuration::handle_configuration_request(&node_config)
        },
        CONSENSUS_HEALTH_CHECK_PATH => {
            // /consensus_health_check
            // Exposes the consensus health check
            metrics::handle_consensus_health_check(&node_config).await
        },
        FORGE_METRICS_PATH => {
            // /forge_metrics
            // Exposes forge encoded metrics
            metrics::handle_forge_metrics()
        },
        IDENTITY_INFORMATION_PATH => {
            // /identity_information
            // Exposes the identity information of the node
            identity_information::handle_identity_information_request(&node_config)
        },
        INDEX_PATH => {
            // /
            // Exposes the index and list of available endpoints
            index::handle_index_request()
        },
        JSON_METRICS_PATH => {
            // /json_metrics
            // Exposes JSON encoded metrics
            metrics::handle_json_metrics_request()
        },
        METRICS_PATH => {
            // /metrics
            // Exposes text encoded metrics
            metrics::handle_metrics_request()
        },
        PEER_INFORMATION_PATH => {
            // /peer_information
            // Exposes the peer information
            peer_information::handle_peer_information_request(
                &node_config,
                aptos_data_client,
                peers_and_metadata,
            )
        },
        SYSTEM_INFORMATION_PATH => {
            // /system_information
            // Exposes the system and build information
            system_information::handle_system_information_request(node_config)
        },
        _ => {
            // Handle the invalid path
            (
                StatusCode::NOT_FOUND,
                Body::from(INVALID_ENDPOINT_MESSAGE),
                CONTENT_TYPE_TEXT.into(),
            )
        },
    };
```
