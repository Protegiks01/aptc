# Audit Report

## Title
Lazy Loading Mode Allows Publishing Modules With Undetected Cyclic Dependencies and Unverified Transitive Dependency Links

## Summary
When lazy loading is enabled (default in production), the module publishing verification in `create_with_compat_config()` only checks immediate dependencies, not transitive dependency chains or cyclic dependencies. This allows publishing module bundles that pass verification but fail deterministically at runtime.

## Finding Description

The `StagingModuleStorage::create_with_compat_config()` function performs different levels of verification depending on whether lazy loading is enabled: [1](#0-0) 

In lazy loading mode (lines 245-275), the verification:
1. Only collects immediate dependencies (lines 262-271)
2. Explicitly does NOT check cyclic dependencies (comment at line 259)
3. Loads immediate dependencies with `unmetered_get_existing_lazily_verified_module` which skips linking checks [2](#0-1) 

The lazy verification path (line 321) calls `build_verified_module_skip_linking_checks`, meaning transitive dependency linking is NOT re-verified.

In contrast, the eager loading path recursively verifies ALL transitive dependencies and detects cycles: [3](#0-2) 

Lazy loading is enabled by default in production: [4](#0-3) [5](#0-4) 

**Exploitation Scenario:**

An attacker can publish a module bundle where:
- Module A depends on Module B
- Module B depends on Module C  
- Module C depends on Module A (forming a cycle)

During publishing with lazy loading:
1. Each module's immediate dependencies are verified to exist (in the staged bundle)
2. Linking checks with immediate dependencies pass
3. No cycle detection occurs
4. Publishing succeeds

At runtime, when attempting to execute these modules, the cycle detection in `visit_dependencies_and_verify` triggers, causing `CYCLIC_MODULE_DEPENDENCY` errors.

## Impact Explanation

This issue allows publishing modules that appear valid but are unusable, breaking the invariant that **published modules should be executable**. However, the impact is limited:

- **Not Critical**: Failures are deterministic across all validators (no consensus divergence), no fund theft/minting, no network partition
- **Not High**: No validator slowdown, no API crashes
- **Medium/Low**: State inconsistency (unusable modules exist on-chain), resource waste (gas spent on failed transactions attempting to use these modules)

The primary harm is griefing: wasting storage space and causing gas waste for users attempting to use the modules.

## Likelihood Explanation

**High likelihood** - The attack is straightforward:
- Lazy loading is enabled by default
- Publishing multiple modules in a bundle is a standard operation
- Creating cyclic dependencies is trivial
- No special permissions required

The limitation is acknowledged in the code comments, suggesting it's a known design trade-off rather than an oversight.

## Recommendation

Add cycle detection and transitive dependency verification to the lazy loading publish path:

```rust
// After line 275, before line 276, add:
// Verify no cyclic dependencies in the bundle
let mut dependency_graph = BTreeMap::new();
for (addr, account_storage) in staged_module_storage.storage.byte_storage().staged_modules.iter() {
    for (name, (_, compiled_module)) in account_storage.iter() {
        let module_id = ModuleId::new(*addr, name.clone());
        let deps: Vec<ModuleId> = compiled_module.immediate_dependencies()
            .into_iter()
            .map(|dep| dep.clone())
            .collect();
        dependency_graph.insert(module_id, deps);
    }
}
// Perform cycle detection on dependency_graph
verify_no_cycles(&dependency_graph)?;
```

Alternatively, always use eager verification during publishing regardless of the lazy loading flag, since the upfront cost is acceptable for the one-time publish operation.

## Proof of Concept

```move
// Module A
module 0x1::A {
    use 0x1::B;
    public fun foo() {
        B::bar();
    }
}

// Module B  
module 0x1::B {
    use 0x1::C;
    public fun bar() {
        C::baz();
    }
}

// Module C
module 0x1::C {
    use 0x1::A;
    public fun baz() {
        A::foo(); // Creates cycle A->B->C->A
    }
}

// Publish all three in single bundle with lazy loading enabled:
// 1. Publishing succeeds (no cycle detection)
// 2. Attempting to execute A::foo() fails with CYCLIC_MODULE_DEPENDENCY at runtime
```

## Notes

This issue represents a design trade-off in lazy loading where verification is deferred to runtime for performance. The code comment explicitly acknowledges that cyclic dependencies are not checked. While this allows publishing unusable modules, it does not create consensus issues since failures are deterministic. The severity is limited to griefing attacks and resource waste rather than critical security violations.

### Citations

**File:** third_party/move/move-vm/runtime/src/storage/publishing.rs (L245-275)
```rust
            if is_lazy_loading_enabled {
                // Local bytecode verification.
                staged_runtime_environment.paranoid_check_module_address_and_name(
                    compiled_module,
                    compiled_module.self_addr(),
                    compiled_module.self_name(),
                )?;
                let locally_verified_code = staged_runtime_environment
                    .build_locally_verified_module(
                        compiled_module.clone(),
                        bytes.len(),
                        &sha3_256(bytes),
                    )?;

                // Linking checks to immediate dependencies. Note that we do not check cyclic
                // dependencies here.
                let mut verified_dependencies = vec![];
                for (dep_addr, dep_name) in locally_verified_code.immediate_dependencies_iter() {
                    // INVARIANT:
                    //   Immediate dependency of the module in a bundle must be metered at the
                    //   caller side.
                    let dependency =
                        staged_module_storage.unmetered_get_existing_lazily_verified_module(
                            &ModuleId::new(*dep_addr, dep_name.to_owned()),
                        )?;
                    verified_dependencies.push(dependency);
                }
                staged_runtime_environment.build_verified_module_with_linking_checks(
                    locally_verified_code,
                    &verified_dependencies,
                )?;
```

**File:** third_party/move/move-vm/runtime/src/storage/module_storage.rs (L295-329)
```rust
    fn unmetered_get_lazily_verified_module(
        &self,
        module_id: &ModuleId,
    ) -> VMResult<Option<Arc<Module>>> {
        let (module, version) = match self.get_module_or_build_with(module_id, self)? {
            Some(module_and_version) => module_and_version,
            None => return Ok(None),
        };

        if module.code().is_verified() {
            return Ok(Some(module.code().verified().clone()));
        }

        let _timer = VM_TIMER.timer_with_label("unmetered_get_lazily_verified_module [cache miss]");
        let runtime_environment = self.runtime_environment();
        runtime_environment.paranoid_check_module_address_and_name(
            module.code().deserialized(),
            module_id.address(),
            module_id.name(),
        )?;
        let locally_verified_code = runtime_environment.build_locally_verified_module(
            module.code().deserialized().clone(),
            module.extension().size_in_bytes(),
            module.extension().hash(),
        )?;
        let verified_code =
            runtime_environment.build_verified_module_skip_linking_checks(locally_verified_code)?;
        let verified_module = self.insert_verified_module(
            module_id.clone(),
            verified_code,
            module.extension().clone(),
            version,
        )?;
        Ok(Some(verified_module.code().verified().clone()))
    }
```

**File:** third_party/move/move-vm/runtime/src/storage/module_storage.rs (L399-415)
```rust
        if visited.insert(dependency_id.clone()) {
            // Dependency is not verified, and we have not visited it yet.
            let verified_dependency = visit_dependencies_and_verify(
                dependency_id.clone(),
                dependency,
                dependency_version,
                visited,
                module_cache_with_context,
            )?;
            verified_dependencies.push(verified_dependency);
        } else {
            // We must have found a cycle otherwise.
            return Err(module_cyclic_dependency_error!(
                dependency_id.address(),
                dependency_id.name()
            ));
        }
```

**File:** types/src/on_chain_config/aptos_features.rs (L145-148)
```rust
    /// With lazy loading, modules are loaded lazily (as opposed to loading the transitive closure
    /// of dependencies). For more details, see:
    ///   AIP-127 (https://github.com/aptos-foundation/AIPs/blob/main/aips/aip-127.md)
    ENABLE_LAZY_LOADING = 95,
```

**File:** types/src/on_chain_config/aptos_features.rs (L266-266)
```rust
            FeatureFlag::ENABLE_LAZY_LOADING,
```
