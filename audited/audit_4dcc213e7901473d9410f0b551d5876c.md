# Audit Report

## Title
Information Disclosure via Unsanitized Error Messages in REST Client

## Summary
The `parse_error()` function in the Aptos REST client fails to sanitize error messages from HTTP responses, allowing sensitive server information (internal paths, stack traces, configuration details) to leak to end users through CLI output and external APIs like Rosetta.

## Finding Description

The vulnerability exists in the error parsing logic that handles non-JSON HTTP error responses. When the REST API server returns an error response that cannot be parsed as JSON, the raw error text is captured without any sanitization. [1](#0-0) 

At line 1995, when JSON parsing fails, the function attempts to parse the response as UTF-8 text and directly wraps it in `RestError::Unknown(anyhow!(error_text.to_string()))` without any filtering or sanitization.

This unsanitized error then flows through multiple conversion layers:

1. **CLI Path**: The `RestError` is converted to `CliError::ApiError` using the error's string representation: [2](#0-1) 

2. **Display to Users**: The `CliError::ApiError` variant displays the error with the "API error: {0}" format: [3](#0-2) 

3. **Rosetta API Path**: The `RestError::Unknown` is converted to `ApiError::InternalError` with the raw message preserved: [4](#0-3) 

4. **External Exposure**: The internal error details are exposed through the API's error details field: [5](#0-4) 

**Attack Scenario**:
An attacker could trigger server errors that produce non-JSON responses containing sensitive information by:
- Sending malformed requests that cause framework-level errors
- Triggering edge cases in the web framework (Poem)
- Exploiting misconfigurations where HTML error pages are returned
- Causing the server to panic or crash in ways that expose debug information

When the server returns error responses with internal file paths, stack traces, or configuration details (especially common in development/staging environments or during framework errors), this information is directly propagated to the client without any filtering.

## Impact Explanation

This is a **Low Severity** information disclosure vulnerability per the Aptos bug bounty criteria: "Minor information leaks". 

While it does not directly compromise funds, consensus, or system availability, leaked information can aid attackers in:
- Understanding internal server architecture and file structure
- Identifying software versions and dependencies from stack traces
- Discovering potential attack vectors from error messages
- Gaining insights into security mechanisms and configurations

The impact is limited because:
- It requires triggering specific error conditions
- It only affects information confidentiality, not integrity or availability
- It doesn't directly enable further exploitation without additional vulnerabilities

## Likelihood Explanation

**Likelihood: Medium**

The vulnerability will trigger when:
1. The REST API server returns a non-JSON error response (uncommon but possible)
2. The error response contains sensitive information
3. The user/attacker observes the error message

Realistic scenarios include:
- **Development/Staging Environments**: Often configured with verbose error reporting
- **Framework Errors**: The Poem web framework may return detailed errors in certain edge cases
- **Reverse Proxy Errors**: Load balancers or proxies may return HTML error pages
- **Panic Handlers**: While the panic handler sanitizes to "internal error", framework errors are not sanitized: [6](#0-5) 

## Recommendation

Implement error message sanitization in the `parse_error()` function before wrapping non-JSON responses:

```rust
async fn parse_error(response: reqwest::Response) -> RestError {
    let status_code = response.status();
    let maybe_state = parse_state_optional(&response);
    response
        .bytes()
        .await
        .map(|bytes| match serde_json::from_slice(&bytes) {
            Ok(error_json) => (error_json, maybe_state, status_code).into(),
            Err(json_parse_error) => match std::str::from_utf8(&bytes) {
                Ok(error_text) => {
                    // Sanitize error message to prevent information leakage
                    let sanitized_msg = format!(
                        "Server returned non-JSON error response with status {}",
                        status_code
                    );
                    RestError::Unknown(anyhow!(sanitized_msg))
                },
                Err(_utf8_error) => RestError::Json(json_parse_error),
            },
        })
        .unwrap_or_else(|reqwest_error| RestError::Http(status_code, reqwest_error))
}
```

Alternatively, truncate or redact the error message while preserving useful debugging information in logs only.

## Proof of Concept

This vulnerability cannot be easily demonstrated with a standalone PoC without setting up a mock REST API server that returns malicious error responses. However, the code path can be triggered by:

1. Setting up a test server that returns HTML error pages or framework errors
2. Configuring the Aptos REST API to run with debug error reporting enabled
3. Sending requests that trigger framework-level errors (e.g., invalid Content-Type, malformed headers)
4. Observing the raw error text propagated to the CLI or Rosetta API

The vulnerability is confirmed through code analysis showing the direct path from `error_text.to_string()` to user-facing error messages without any sanitization layer.

---

## Notes

This is a valid Low severity information disclosure vulnerability. While it does not meet the Critical/High/Medium thresholds typically prioritized for consensus or financial impact, it is explicitly categorized as valid in the Aptos bug bounty program under "Low Severity: Minor information leaks". The security question itself is scoped to Low severity, confirming this is within the expected findings scope.

### Citations

**File:** crates/aptos-rest-client/src/lib.rs (L1986-2000)
```rust
async fn parse_error(response: reqwest::Response) -> RestError {
    let status_code = response.status();
    let maybe_state = parse_state_optional(&response);
    response
        .bytes()
        .await
        .map(|bytes| match serde_json::from_slice(&bytes) {
            Ok(error_json) => (error_json, maybe_state, status_code).into(),
            Err(json_parse_error) => match std::str::from_utf8(&bytes) {
                Ok(error_text) => RestError::Unknown(anyhow!(error_text.to_string())),
                Err(_utf8_error) => RestError::Json(json_parse_error),
            },
        })
        .unwrap_or_else(|reqwest_error| RestError::Http(status_code, reqwest_error))
}
```

**File:** crates/aptos/src/common/types.rs (L119-120)
```rust
    #[error("API error: {0}")]
    ApiError(String),
```

**File:** crates/aptos/src/common/types.rs (L180-184)
```rust
impl From<RestError> for CliError {
    fn from(e: RestError) -> Self {
        CliError::ApiError(e.to_string())
    }
}
```

**File:** crates/aptos-rosetta/src/error.rs (L219-219)
```rust
            ApiError::InternalError(inner) => inner,
```

**File:** crates/aptos-rosetta/src/error.rs (L328-328)
```rust
            RestError::Unknown(err) => ApiError::InternalError(Some(err.to_string())),
```

**File:** api/src/error_converter.rs (L21-38)
```rust
pub async fn convert_error(error: poem::Error) -> impl poem::IntoResponse {
    // This is a bit of a hack but errors we return have no source, whereas
    // those returned by the framework do. As such, if we cannot downcast the
    // error we know it's one of ours and we just return it directly.
    let error_string = error.to_string();
    let is_framework_error = error.has_source();
    if is_framework_error {
        // Build the response.
        let mut response = error.into_response();
        // Replace the body with the response.
        response.set_body(build_error_response(error_string).take_body());
        response
            .headers_mut()
            .insert(CONTENT_TYPE, HeaderValue::from_static(JSON));
        response
    } else {
        error.into_response()
    }
```
