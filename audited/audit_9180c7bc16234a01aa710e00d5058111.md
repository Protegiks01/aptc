# Audit Report

## Title
Missing Configuration Sanitizer for System and Identity Information Endpoints on Mainnet Validators Enables Hardware Fingerprinting Reconnaissance

## Summary
The Aptos inspection service exposes detailed system information (CPU specifications, memory, disk, OS details) and validator identity (peer ID) through unauthenticated HTTP endpoints that are enabled by default. While the configuration sanitizer prevents mainnet validators from exposing the `/configuration` endpoint, it fails to apply the same protection to `/system_information` and `/identity_information` endpoints. This inconsistency creates a security gap where properly configured network-level protections may be bypassed through operator misconfiguration, allowing attackers to fingerprint validator hardware and correlate it with on-chain validator identities.

## Finding Description

The inspection service configuration has an inconsistent security model. The `InspectionServiceConfig` struct defines four endpoint exposure flags: [1](#0-0) 

The configuration sanitizer explicitly prevents mainnet validators from exposing the configuration endpoint: [2](#0-1) 

However, there is **no equivalent sanitizer check** for `expose_system_information` or `expose_identity_information` on mainnet validators, despite both being enabled by default: [3](#0-2) 

The `/system_information` endpoint exposes highly detailed hardware specifications: [4](#0-3) 

The `/identity_information` endpoint exposes the validator's peer ID (account address): [5](#0-4) 

Both endpoints lack any authentication mechanism: [6](#0-5) 

The service binds to all network interfaces by default: [7](#0-6) 

**Attack Path:**
1. Validator operator misconfigures firewall rules or uses custom deployment without proper network isolation
2. Attacker scans for open port 9101 on validator IP addresses
3. Attacker queries `/identity_information` to obtain peer ID (validator account address)
4. Attacker queries `/system_information` to obtain detailed hardware specifications
5. Attacker correlates peer ID with on-chain validator set data
6. Attacker analyzes CPU brand/model, memory size, disk configuration to identify cloud provider and instance type
7. Attacker builds profile of validator infrastructure enabling targeted attacks

## Impact Explanation

This vulnerability enables reconnaissance attacks that facilitate targeted infrastructure exploitation against validators. The impact qualifies as **High Severity** under the Aptos bug bounty program for the following reasons:

1. **Enables Validator Node Slowdowns**: Attackers can identify validators running on specific cloud providers or with limited resources, enabling targeted attacks designed to degrade performance of specific validators.

2. **Privacy Violation**: Validator operators may not intend to disclose their infrastructure setup, but the default configuration exposes this information if network protection is misconfigured.

3. **Infrastructure-Specific Exploitation**: Different cloud providers have different security characteristics. Knowing a validator runs on AWS vs Azure vs bare metal enables provider-specific attack vectors.

4. **Inconsistent Security Model**: The presence of a sanitizer for `expose_configuration` but not for `expose_system_information`/`expose_identity_information` indicates a recognized security concern that was incompletely addressed.

While reference deployments (Kubernetes, Docker Compose) provide network-level protection, the codebase should not rely solely on deployment configuration for security-critical information protection.

## Likelihood Explanation

**Likelihood: Medium-to-High**

The likelihood is elevated because:

1. **Default Configuration is Insecure**: Both endpoints are enabled by default and bind to all interfaces, requiring explicit operator action to disable or restrict access.

2. **Easy Misconfiguration**: Operators may modify firewall rules for legitimate monitoring purposes without understanding the reconnaissance implications.

3. **Monitoring System Compromise**: Kubernetes NetworkPolicy allows monitoring pods to access port 9101. If monitoring infrastructure is compromised, attackers gain access to these endpoints.

4. **Custom Deployments**: Not all operators use reference deployments. Custom deployments may lack proper network isolation.

5. **No Warning or Documentation**: The lack of sanitizer check means operators receive no warning when enabling these endpoints on mainnet.

## Recommendation

Implement configuration sanitizers for `expose_system_information` and `expose_identity_information` consistent with the existing `expose_configuration` protection:

```rust
impl ConfigSanitizer for InspectionServiceConfig {
    fn sanitize(
        node_config: &NodeConfig,
        node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();
        let inspection_service_config = &node_config.inspection_service;

        // Verify that mainnet validators do not expose sensitive information
        if let Some(chain_id) = chain_id {
            if node_type.is_validator() && chain_id.is_mainnet() {
                if inspection_service_config.expose_configuration {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name,
                        "Mainnet validators should not expose the node configuration!".to_string(),
                    ));
                }
                
                // ADD THESE CHECKS:
                if inspection_service_config.expose_system_information {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name,
                        "Mainnet validators should not expose system information!".to_string(),
                    ));
                }
                
                if inspection_service_config.expose_identity_information {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name,
                        "Mainnet validators should not expose identity information!".to_string(),
                    ));
                }
            }
        }

        Ok(())
    }
}
```

Additionally, consider:
1. Changing default binding address to `127.0.0.1` instead of `0.0.0.0`
2. Adding authentication to inspection service endpoints
3. Documenting the reconnaissance risks in operator guidelines

## Proof of Concept

**Step 1**: Create a minimal test demonstrating the security gap:

```rust
#[test]
fn test_mainnet_validator_exposes_system_info_without_sanitizer_error() {
    use aptos_config::config::{NodeConfig, InspectionServiceConfig, NodeType};
    use aptos_config::config::config_sanitizer::ConfigSanitizer;
    use aptos_types::chain_id::ChainId;

    // Create a mainnet validator config with system info exposed
    let node_config = NodeConfig {
        inspection_service: InspectionServiceConfig {
            expose_configuration: false,  // This would be blocked by sanitizer
            expose_system_information: true,  // This is NOT blocked!
            expose_identity_information: true,  // This is NOT blocked!
            ..Default::default()
        },
        ..Default::default()
    };

    // Attempt to sanitize - this should fail but currently succeeds
    let result = InspectionServiceConfig::sanitize(
        &node_config,
        NodeType::Validator,
        Some(ChainId::mainnet()),
    );

    // VULNERABILITY: This passes when it should fail
    assert!(result.is_ok()); // Currently passes - this is the bug
    
    // Expected behavior: result should be Err() for mainnet validators
    // with expose_system_information or expose_identity_information enabled
}
```

**Step 2**: Demonstrate information correlation attack:

```bash
# If port 9101 is accessible, attacker can:

# 1. Get validator identity
curl http://validator-ip:9101/identity_information
# Returns: "Validator network (vn), peer ID: 0x1a2b3c..."

# 2. Get system information  
curl http://validator-ip:9101/system_information
# Returns JSON with:
# - cpu_brand: "Intel(R) Xeon(R) Platinum 8175M"  (indicates AWS)
# - cpu_count: "96"
# - memory_total: "384GB"  (indicates specific instance type)
# - build_commit_hash, build_time, etc.

# 3. Correlate with on-chain validator set
# - Match peer ID to on-chain validator account
# - Identify specific validator's infrastructure
# - Build targeted attack profile
```

This demonstrates that the missing sanitizer check allows mainnet validators to expose reconnaissance-enabling information, violating the security principle established by the `expose_configuration` sanitizer.

---

**Notes:**

The vulnerability is in the **incomplete implementation of security controls** in the configuration sanitizer, not in the deployment configuration. While reference deployments provide network-level protection, defense-in-depth principles require application-level enforcement for security-critical configurations. The existence of the `expose_configuration` sanitizer proves the developers recognized this need but failed to apply it consistently to equally sensitive endpoints.

### Citations

**File:** config/src/config/inspection_service_config.rs (L17-24)
```rust
pub struct InspectionServiceConfig {
    pub address: String,
    pub port: u16,
    pub expose_configuration: bool,
    pub expose_identity_information: bool,
    pub expose_peer_information: bool,
    pub expose_system_information: bool,
}
```

**File:** config/src/config/inspection_service_config.rs (L26-36)
```rust
impl Default for InspectionServiceConfig {
    fn default() -> InspectionServiceConfig {
        InspectionServiceConfig {
            address: "0.0.0.0".to_string(),
            port: 9101,
            expose_configuration: false,
            expose_identity_information: true,
            expose_peer_information: true,
            expose_system_information: true,
        }
    }
```

**File:** config/src/config/inspection_service_config.rs (L54-65)
```rust
        // Verify that mainnet validators do not expose the configuration
        if let Some(chain_id) = chain_id {
            if node_type.is_validator()
                && chain_id.is_mainnet()
                && inspection_service_config.expose_configuration
            {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "Mainnet validators should not expose the node configuration!".to_string(),
                ));
            }
        }
```

**File:** crates/aptos-telemetry/src/system_information.rs (L14-33)
```rust
/// System information keys
const CPU_BRAND: &str = "cpu_brand";
const CPU_COUNT: &str = "cpu_count";
const CPU_CORE_COUNT: &str = "cpu_core_count";
const CPU_FREQUENCY: &str = "cpu_frequency";
const CPU_NAME: &str = "cpu_name";
const CPU_VENDOR_ID: &str = "cpu_vendor_id";
const DISK_AVAILABLE_SPACE: &str = "disk_available_space";
const DISK_COUNT: &str = "disk_count";
const DISK_FILE_SYSTEM: &str = "disk_file_system";
const DISK_NAME: &str = "disk_name";
const DISK_TOTAL_SPACE: &str = "disk_total_space";
const DISK_TYPE: &str = "disk_type";
const MEMORY_AVAILABLE: &str = "memory_available";
const MEMORY_TOTAL: &str = "memory_total";
const MEMORY_USED: &str = "memory_used";
const SYSTEM_HOST_NAME: &str = "system_host_name";
const SYSTEM_KERNEL_VERSION: &str = "system_kernel_version";
const SYSTEM_NAME: &str = "system_name";
const SYSTEM_OS_VERSION: &str = "system_os_version";
```

**File:** crates/aptos-inspection-service/src/server/identity_information.rs (L34-40)
```rust
    if let Some(validator_network) = &node_config.validator_network {
        identity_information.push(format!(
            "\t- Validator network ({}), peer ID: {}",
            validator_network.network_id,
            validator_network.peer_id()
        ));
    }
```

**File:** crates/aptos-inspection-service/src/server/mod.rs (L111-160)
```rust
    let (status_code, body, content_type) = match req.uri().path() {
        CONFIGURATION_PATH => {
            // /configuration
            // Exposes the node configuration
            configuration::handle_configuration_request(&node_config)
        },
        CONSENSUS_HEALTH_CHECK_PATH => {
            // /consensus_health_check
            // Exposes the consensus health check
            metrics::handle_consensus_health_check(&node_config).await
        },
        FORGE_METRICS_PATH => {
            // /forge_metrics
            // Exposes forge encoded metrics
            metrics::handle_forge_metrics()
        },
        IDENTITY_INFORMATION_PATH => {
            // /identity_information
            // Exposes the identity information of the node
            identity_information::handle_identity_information_request(&node_config)
        },
        INDEX_PATH => {
            // /
            // Exposes the index and list of available endpoints
            index::handle_index_request()
        },
        JSON_METRICS_PATH => {
            // /json_metrics
            // Exposes JSON encoded metrics
            metrics::handle_json_metrics_request()
        },
        METRICS_PATH => {
            // /metrics
            // Exposes text encoded metrics
            metrics::handle_metrics_request()
        },
        PEER_INFORMATION_PATH => {
            // /peer_information
            // Exposes the peer information
            peer_information::handle_peer_information_request(
                &node_config,
                aptos_data_client,
                peers_and_metadata,
            )
        },
        SYSTEM_INFORMATION_PATH => {
            // /system_information
            // Exposes the system and build information
            system_information::handle_system_information_request(node_config)
        },
```
