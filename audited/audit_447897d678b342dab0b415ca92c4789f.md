# Audit Report

## Title
Off-by-One Error in Indexer Metadata Management Causes Persistent Re-Indexing and State Inconsistency

## Summary
The indexer's `index_with_annotator()` function contains an off-by-one error in its metadata management. The metadata stores `end_version - 1` (the last indexed version) but on restart, this value is loaded directly as `next_version` (the next version to index), causing the last processed transaction to be re-indexed on every restart. This violates the **State Consistency** invariant and can lead to data corruption or resource waste.

## Finding Description

The vulnerability exists in the mismatch between how metadata is stored versus how it's loaded:

**Storage Logic:** [1](#0-0) 

The metadata is stored with `end_version - 1`, which represents the last successfully indexed version. The in-memory `next_version` atomic is then updated to `end_version`, representing the next version to process.

**Loading Logic:** [2](#0-1) 

On restart, the metadata value (which contains the last indexed version) is loaded directly into `next_version` without adding 1, creating an off-by-one error.

**Validation Logic:** [3](#0-2) 

When processing resumes, the indexer checks if `first_version <= next_version` and proceeds if `end_version > next_version`. Due to the off-by-one error, the last processed version passes these checks and gets re-indexed.

**Execution Flow:**
1. Initial indexing of versions 10-14 completes successfully
   - Metadata stores: 14 (last indexed)
   - In-memory stores: 15 (next to index)
2. Node restarts
3. Indexer loads metadata: 14
4. Sets `next_version` to 14 (should be 15!)
5. Catch-up logic attempts to sync from current ledger state
6. Indexer accepts and re-processes version 14, even though it was already indexed
7. This happens on **every restart**, permanently

The batch write operation is atomic [4](#0-3) , so the security question's premise about "batch write failing after metadata update" is not the actual issue. The real vulnerability is the off-by-one semantic error in metadata interpretation.

## Impact Explanation

**Medium Severity** - State inconsistencies requiring intervention:

1. **Data Re-Indexing**: Every restart causes the last processed transaction's table information to be re-indexed and potentially overwritten
2. **State Inconsistency**: The metadata claims version N is the next to process, but version N was already processed, creating a mismatch between metadata and actual indexed data
3. **Resource Waste**: Redundant processing on every restart consumes computational resources
4. **Potential Corruption**: If table information has evolved or state dependencies exist, re-indexing with a different state view could produce inconsistent results
5. **Non-Idempotent Risk**: While the current `put` operation [5](#0-4)  may overwrite with identical data in many cases, this is not guaranteed if state has changed

This does not reach Critical severity because:
- It doesn't directly cause consensus violations
- The indexer is a secondary component, not consensus-critical
- The re-indexing is typically idempotent in practice

However, it qualifies as Medium severity because it causes persistent state inconsistencies that violate the system's correctness guarantees.

## Likelihood Explanation

**Likelihood: High (100%)**

This bug triggers on **every single restart** of any Aptos node with the indexer enabled. It is not dependent on:
- Attacker actions
- Race conditions  
- Specific timing
- Network conditions
- Validator behavior

The catch-up logic in AptosDB initialization [6](#0-5)  will always trigger the re-indexing because it fetches write sets starting from the incorrect `next_version` value.

## Recommendation

**Fix Option 1 - Adjust Loading (Recommended):**
Modify the initialization to add 1 when loading the last indexed version:

```rust
// In storage/indexer/src/lib.rs, line 73-75
let next_version = db
    .get::<IndexerMetadataSchema>(&MetadataKey::LatestVersion)?
    .map_or(0, |v| v.expect_version() + 1); // Add 1 to convert last indexed to next version
```

**Fix Option 2 - Adjust Storage:**
Store `end_version` instead of `end_version - 1`:

```rust
// In storage/indexer/src/lib.rs, line 140-142
batch.put::<IndexerMetadataSchema>(
    &MetadataKey::LatestVersion,
    &MetadataValue::Version(end_version), // Store next version, not last version
)?;
```

**Fix Option 1 is recommended** because:
1. It maintains backward compatibility with existing metadata values
2. It clearly documents the semantic conversion from "last indexed" to "next to index"
3. The same pattern exists in other components like `db_indexer.rs` [7](#0-6)  which should also be fixed

## Proof of Concept

```rust
// Rust unit test demonstrating the bug
#[test]
fn test_indexer_off_by_one_bug() {
    use tempfile::TempDir;
    use aptos_config::config::RocksdbConfig;
    
    let tmpdir = TempDir::new().unwrap();
    let db_path = tmpdir.path();
    
    // Create mock write sets for versions 0-4 (5 transactions)
    let write_sets: Vec<WriteSet> = (0..5)
        .map(|_| WriteSet::default())
        .collect();
    let write_set_refs: Vec<&WriteSet> = write_sets.iter().collect();
    
    // First indexing session
    {
        let indexer = Indexer::open(db_path, RocksdbConfig::default()).unwrap();
        let mock_annotator = /* create mock annotator */;
        
        // Index versions 0-4
        indexer.index_with_annotator(&mock_annotator, 0, &write_set_refs).unwrap();
        
        // Verify in-memory state: next_version should be 5
        assert_eq!(indexer.next_version(), 5);
        
        // Verify persisted metadata: should be 4 (last indexed)
        let metadata = indexer.db
            .get::<IndexerMetadataSchema>(&MetadataKey::LatestVersion)
            .unwrap()
            .unwrap()
            .expect_version();
        assert_eq!(metadata, 4);
    }
    
    // Simulate restart by reopening
    {
        let indexer = Indexer::open(db_path, RocksdbConfig::default()).unwrap();
        
        // BUG: next_version is now 4 instead of 5!
        assert_eq!(indexer.next_version(), 4); // Should be 5!
        
        // If we try to index from version 5, it will fail the continuity check
        // If we try to index from version 4, it will RE-INDEX version 4!
        
        // This demonstrates the off-by-one error causing persistent re-indexing
    }
}
```

**Notes:**
- This vulnerability affects the core storage layer's indexer component
- The same pattern appears in `db_indexer.rs` suggesting a systemic issue
- While the batch write itself is atomic, the semantic mismatch between stored and loaded metadata creates persistent inconsistency
- Every node restart triggers unnecessary re-indexing of the last processed transaction
- The fix is simple but requires careful coordination to maintain backward compatibility with existing deployments

### Citations

**File:** storage/indexer/src/lib.rs (L73-75)
```rust
        let next_version = db
            .get::<IndexerMetadataSchema>(&MetadataKey::LatestVersion)?
            .map_or(0, |v| v.expect_version());
```

**File:** storage/indexer/src/lib.rs (L101-117)
```rust
        let next_version = self.next_version();
        db_ensure!(
            first_version <= next_version,
            "Indexer expects to see continuous transaction versions. Expecting: {}, got: {}",
            next_version,
            first_version,
        );
        let end_version = first_version + write_sets.len() as Version;
        if end_version <= next_version {
            warn!(
                "Seeing old transactions. Expecting version: {}, got {} transactions starting from version {}.",
                next_version,
                write_sets.len(),
                first_version,
            );
            return Ok(());
        }
```

**File:** storage/indexer/src/lib.rs (L140-145)
```rust
        batch.put::<IndexerMetadataSchema>(
            &MetadataKey::LatestVersion,
            &MetadataValue::Version(end_version - 1),
        )?;
        self.db.write_schemas(batch)?;
        self.next_version.store(end_version, Ordering::Relaxed);
```

**File:** storage/indexer/src/lib.rs (L323-325)
```rust
                .try_for_each(|(table_handle, table_info)| {
                    batch.put::<TableInfoSchema>(&table_handle, &table_info)
                })?;
```

**File:** storage/schemadb/src/lib.rs (L289-303)
```rust
    fn write_schemas_inner(&self, batch: impl IntoRawBatch, option: &WriteOptions) -> DbResult<()> {
        let labels = [self.name.as_str()];
        let _timer = APTOS_SCHEMADB_BATCH_COMMIT_LATENCY_SECONDS.timer_with(&labels);

        let raw_batch = batch.into_raw_batch(self)?;

        let serialized_size = raw_batch.inner.size_in_bytes();
        self.inner
            .write_opt(raw_batch.inner, option)
            .into_db_res()?;

        raw_batch.stats.commit();
        APTOS_SCHEMADB_BATCH_COMMIT_BYTES.observe_with(&[&self.name], serialized_size as f64);

        Ok(())
```

**File:** storage/aptosdb/src/db/aptosdb_internal.rs (L207-227)
```rust
        if indexer.next_version() < ledger_next_version {
            use aptos_storage_interface::state_store::state_view::db_state_view::DbStateViewAtVersion;
            let db: Arc<dyn DbReader> = self.state_store.clone();

            let state_view = db.state_view_at_version(Some(ledger_next_version - 1))?;
            let annotator = AptosValueAnnotator::new(&state_view);

            const BATCH_SIZE: Version = 10000;
            let mut next_version = indexer.next_version();
            while next_version < ledger_next_version {
                info!(next_version = next_version, "AptosDB Indexer catching up. ",);
                let end_version = std::cmp::min(ledger_next_version, next_version + BATCH_SIZE);
                let write_sets = self
                    .ledger_db
                    .write_set_db()
                    .get_write_sets(next_version, end_version)?;
                let write_sets_ref: Vec<_> = write_sets.iter().collect();
                indexer.index_with_annotator(&annotator, next_version, &write_sets_ref)?;

                next_version = end_version;
            }
```

**File:** storage/indexer/src/db_indexer.rs (L506-545)
```rust
            batch.put::<InternalIndexerMetadataSchema>(
                &MetadataKey::EventV2TranslationVersion,
                &MetadataValue::Version(version - 1),
            )?;

            for event_key in event_keys {
                batch
                    .put::<EventSequenceNumberSchema>(
                        &event_key,
                        &self
                            .event_v2_translation_engine
                            .get_cached_sequence_number(&event_key)
                            .unwrap_or(0),
                    )
                    .expect("Failed to put events by key to a batch");
            }
        }

        if self.indexer_db.transaction_enabled() {
            batch.put::<InternalIndexerMetadataSchema>(
                &MetadataKey::TransactionVersion,
                &MetadataValue::Version(version - 1),
            )?;
        }
        if self.indexer_db.event_enabled() {
            batch.put::<InternalIndexerMetadataSchema>(
                &MetadataKey::EventVersion,
                &MetadataValue::Version(version - 1),
            )?;
        }
        if self.indexer_db.statekeys_enabled() {
            batch.put::<InternalIndexerMetadataSchema>(
                &MetadataKey::StateVersion,
                &MetadataValue::Version(version - 1),
            )?;
        }
        batch.put::<InternalIndexerMetadataSchema>(
            &MetadataKey::LatestVersion,
            &MetadataValue::Version(version - 1),
        )?;
```
