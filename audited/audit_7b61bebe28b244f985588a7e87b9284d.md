# Audit Report

## Title
Missing Protocol ID Validation in Consensus Observer Network Events Enabling Message Routing Confusion

## Summary
The `event_to_request()` function in the consensus observer network layer does not validate that incoming message `protocol_id` fields match expected consensus observer protocols (ConsensusObserver or ConsensusObserverRpc). This lack of validation, combined with the absence of runtime checks against handshake-negotiated protocols in the network layer, allows malicious peers to send messages with arbitrary or incorrect protocol IDs, causing message routing failures and potential denial of service.

## Finding Description
The consensus observer system processes network messages without validating the `protocol_id` field against expected values: [1](#0-0) 

The extracted `protocol_id` is placed into the `NetworkMessage` struct but never validated. The network handler explicitly ignores this field: [2](#0-1) 

At the lower network layer, when messages arrive, the `protocol_id` is used directly for message deserialization without validation against the protocols negotiated during handshake: [3](#0-2) 

The `ConnectionMetadata` stores negotiated protocols in the `application_protocols` field: [4](#0-3) 

However, this negotiated protocol set is never checked when processing incoming messages. Different protocols use different encodings: [5](#0-4) 

**Attack Scenario:**
1. A malicious peer successfully completes handshake, negotiating support for multiple protocols (e.g., ConsensusObserver, MempoolDirectSend)
2. The peer sends consensus observer messages but sets `protocol_id` to a different value (e.g., MempoolDirectSend or an unsupported protocol)
3. Messages with incorrect protocol_id either:
   - Route to the wrong handler (if a handler exists), causing deserialization failures
   - Get dropped silently (if no handler exists), bypassing consensus observer processing
4. Valid consensus observer messages never reach their intended destination

The deserialization uses the provided `protocol_id` to determine encoding: [6](#0-5) 

## Impact Explanation
**Medium Severity** - This vulnerability causes state inconsistencies requiring intervention:

- **Consensus Observer Disruption**: Malicious peers can prevent legitimate consensus observer messages from being processed, forcing nodes to fall back to slower consensus mechanisms
- **Message Routing Confusion**: Messages may be routed to incorrect handlers, causing repeated deserialization failures and log spam
- **Resource Exhaustion**: Continuous invalid messages consume CPU resources through repeated failed deserialization attempts
- **No Consensus Safety Impact**: While disruptive, this does not break consensus safety as the core consensus mechanism remains functional

The impact aligns with Medium severity: "State inconsistencies requiring intervention" where consensus observer state becomes inconsistent across nodes, requiring operator intervention to identify and disconnect malicious peers.

## Likelihood Explanation
**Moderate Likelihood:**
- Requires peer network access (validator or full node)
- Does not require validator collusion or stake majority
- Easy to exploit once peer access is obtained (simply send messages with wrong protocol_id)
- Network handshake provides access to multiple protocol IDs, enabling the attack
- Detection is difficult as messages are silently dropped or logged as normal deserialization failures

## Recommendation
Implement protocol ID validation at two levels:

**Level 1 - Consensus Observer Layer:**
Add validation in `event_to_request()` to ensure protocol_id matches expected values:

```rust
fn event_to_request(
    network_id: NetworkId,
    network_event: Event<ConsensusObserverMessage>,
) -> Option<NetworkMessage> {
    match network_event {
        Event::RpcRequest(peer_id, consensus_observer_message, protocol_id, response_tx) => {
            // Validate protocol_id matches expected RPC protocol
            if protocol_id != ProtocolId::ConsensusObserverRpc {
                warn!(
                    "Received RPC request with invalid protocol_id: {:?} from peer: {:?}",
                    protocol_id, peer_id
                );
                return None;
            }
            // ... rest of function
        },
        Event::Message(peer_id, consensus_observer_message) => {
            // DirectSend messages should use ConsensusObserver protocol
            // Note: protocol_id is not available in Message events, validation happens at lower layer
            // ... rest of function
        },
    }
}
```

**Level 2 - Network Layer:**
Add validation in `Peer::handle_inbound_network_message()` to check against negotiated protocols:

```rust
fn handle_inbound_network_message(
    &mut self,
    message: NetworkMessage,
) -> Result<(), PeerManagerError> {
    match &message {
        NetworkMessage::DirectSendMsg(direct) => {
            // Validate protocol_id was negotiated during handshake
            if !self.connection_metadata.application_protocols.contains(direct.protocol_id) {
                warn!(
                    "Received message with non-negotiated protocol_id: {:?} from peer: {:?}",
                    direct.protocol_id, self.remote_peer_id()
                );
                return Ok(()); // Drop the message
            }
            // ... rest of function
        },
        NetworkMessage::RpcRequest(request) => {
            // Validate protocol_id was negotiated during handshake
            if !self.connection_metadata.application_protocols.contains(request.protocol_id) {
                warn!(
                    "Received RPC with non-negotiated protocol_id: {:?} from peer: {:?}",
                    request.protocol_id, self.remote_peer_id()
                );
                return Ok(()); // Drop the message
            }
            // ... rest of function
        },
        // ... rest of match
    }
}
```

## Proof of Concept

```rust
// Test demonstrating the vulnerability
#[tokio::test]
async fn test_invalid_protocol_id_accepted() {
    use aptos_network::protocols::wire::handshake::v1::ProtocolId;
    
    // Setup: Create peer with both ConsensusObserver and Mempool protocols
    let peer_network_id = create_peer_with_protocols(vec![
        ProtocolId::ConsensusObserver,
        ProtocolId::ConsensusObserverRpc,
        ProtocolId::MempoolDirectSend,
    ]);
    
    // Create valid ConsensusObserverMessage
    let consensus_message = ConsensusObserverMessage::new_ordered_block_message(
        vec![create_test_block()],
        create_test_ledger_info(),
    );
    
    // Serialize with correct encoding (CompressedBcs)
    let serialized = ProtocolId::ConsensusObserver
        .to_bytes(&consensus_message)
        .unwrap();
    
    // Attack: Send with WRONG protocol_id (MempoolDirectSend)
    let malicious_message = NetworkMessage::DirectSendMsg(DirectSendMsg {
        protocol_id: ProtocolId::MempoolDirectSend, // Wrong protocol!
        priority: 0,
        raw_msg: serialized,
    });
    
    // Send through network layer
    send_network_message(peer_network_id, malicious_message).await;
    
    // Observe: Message is routed to Mempool handler instead of ConsensusObserver
    // Deserialization fails as Mempool expects different message format
    // ConsensusObserver never receives the message
    
    // Expected: Message should be rejected with protocol_id validation error
    // Actual: Message is silently dropped or causes deserialization error in wrong handler
}
```

**Notes:**
- The vulnerability affects the consensus observer optimization layer, not core consensus safety
- While classified as Medium severity, the practical impact is limited as core consensus remains functional
- The fix is straightforward: add protocol_id validation at both the application and network layers
- Consider also adding metrics to track protocol_id mismatches for monitoring purposes

### Citations

**File:** consensus/src/consensus_observer/network/network_events.rs (L64-93)
```rust
    fn event_to_request(
        network_id: NetworkId,
        network_event: Event<ConsensusObserverMessage>,
    ) -> Option<NetworkMessage> {
        match network_event {
            Event::Message(peer_id, consensus_observer_message) => {
                // Transform the direct send event into a network message
                let peer_network_id = PeerNetworkId::new(network_id, peer_id);
                let network_message = NetworkMessage {
                    peer_network_id,
                    protocol_id: None,
                    consensus_observer_message,
                    response_sender: None,
                };
                Some(network_message)
            },
            Event::RpcRequest(peer_id, consensus_observer_message, protocol_id, response_tx) => {
                // Transform the RPC request event into a network message
                let response_sender = ResponseSender::new(response_tx);
                let peer_network_id = PeerNetworkId::new(network_id, peer_id);
                let network_message = NetworkMessage {
                    peer_network_id,
                    protocol_id: Some(protocol_id),
                    consensus_observer_message,
                    response_sender: Some(response_sender),
                };
                Some(network_message)
            },
        }
    }
```

**File:** consensus/src/consensus_observer/network/network_handler.rs (L132-137)
```rust
                    let NetworkMessage {
                        peer_network_id,
                        protocol_id: _,
                        consensus_observer_message,
                        response_sender,
                    } = network_message;
```

**File:** network/framework/src/peer/mod.rs (L447-492)
```rust
    fn handle_inbound_network_message(
        &mut self,
        message: NetworkMessage,
    ) -> Result<(), PeerManagerError> {
        match &message {
            NetworkMessage::DirectSendMsg(direct) => {
                let data_len = direct.raw_msg.len();
                network_application_inbound_traffic(
                    self.network_context,
                    direct.protocol_id,
                    data_len as u64,
                );
                match self.upstream_handlers.get(&direct.protocol_id) {
                    None => {
                        counters::direct_send_messages(&self.network_context, UNKNOWN_LABEL).inc();
                        counters::direct_send_bytes(&self.network_context, UNKNOWN_LABEL)
                            .inc_by(data_len as u64);
                    },
                    Some(handler) => {
                        let key = (self.connection_metadata.remote_peer_id, direct.protocol_id);
                        let sender = self.connection_metadata.remote_peer_id;
                        let network_id = self.network_context.network_id();
                        let sender = PeerNetworkId::new(network_id, sender);
                        match handler.push(key, ReceivedMessage::new(message, sender)) {
                            Err(_err) => {
                                // NOTE: aptos_channel never returns other than Ok(()), but we might switch to tokio::sync::mpsc and then this would work
                                counters::direct_send_messages(
                                    &self.network_context,
                                    DECLINED_LABEL,
                                )
                                .inc();
                                counters::direct_send_bytes(&self.network_context, DECLINED_LABEL)
                                    .inc_by(data_len as u64);
                            },
                            Ok(_) => {
                                counters::direct_send_messages(
                                    &self.network_context,
                                    RECEIVED_LABEL,
                                )
                                .inc();
                                counters::direct_send_bytes(&self.network_context, RECEIVED_LABEL)
                                    .inc_by(data_len as u64);
                            },
                        }
                    },
                }
```

**File:** network/framework/src/transport/mod.rs (L100-108)
```rust
pub struct ConnectionMetadata {
    pub remote_peer_id: PeerId,
    pub connection_id: ConnectionId,
    pub addr: NetworkAddress,
    pub origin: ConnectionOrigin,
    pub messaging_protocol: MessagingProtocolVersion,
    pub application_protocols: ProtocolIdSet,
    pub role: PeerRole,
}
```

**File:** network/framework/src/protocols/wire/handshake/v1/mod.rs (L156-172)
```rust
    fn encoding(self) -> Encoding {
        match self {
            ProtocolId::ConsensusDirectSendJson | ProtocolId::ConsensusRpcJson => Encoding::Json,
            ProtocolId::ConsensusDirectSendCompressed | ProtocolId::ConsensusRpcCompressed => {
                Encoding::CompressedBcs(RECURSION_LIMIT)
            },
            ProtocolId::ConsensusObserver => Encoding::CompressedBcs(RECURSION_LIMIT),
            ProtocolId::DKGDirectSendCompressed | ProtocolId::DKGRpcCompressed => {
                Encoding::CompressedBcs(RECURSION_LIMIT)
            },
            ProtocolId::JWKConsensusDirectSendCompressed
            | ProtocolId::JWKConsensusRpcCompressed => Encoding::CompressedBcs(RECURSION_LIMIT),
            ProtocolId::MempoolDirectSend => Encoding::CompressedBcs(USER_INPUT_RECURSION_LIMIT),
            ProtocolId::MempoolRpc => Encoding::Bcs(USER_INPUT_RECURSION_LIMIT),
            _ => Encoding::Bcs(RECURSION_LIMIT),
        }
    }
```

**File:** network/framework/src/protocols/wire/messaging/v1/mod.rs (L111-113)
```rust
    fn to_message<TMessage: DeserializeOwned>(&self) -> anyhow::Result<TMessage> {
        self.protocol_id().from_bytes(self.data())
    }
```
