# Audit Report

## Title
Storage Service Rate Limiting Bypass via Stale Cached Summary and Pruned Data Requests

## Summary
The storage service's request moderator can be bypassed by crafting requests for recently-pruned state versions. These requests pass validation against a stale cached storage summary but fail during processing with `StorageErrorEncountered`, which does not increment the `invalid_request_count` used for rate limiting. This allows attackers to spam the storage service with expensive database operations without being ignored.

## Finding Description

The storage service implements a rate limiting mechanism to protect against misbehaving peers. When peers send too many invalid requests, they are temporarily ignored. However, there is a critical flaw in how different error types are counted.

The moderator's `validate_request` function only increments `invalid_request_count` when returning `Error::InvalidRequest`: [1](#0-0) 

However, when storage operations fail with database errors, they are converted to `Error::StorageErrorEncountered`: [2](#0-1) 

The attack exploits a timing window between when the storage summary is cached and when pruning progresses:

1. **Cached Summary Calculation**: The storage service advertises available state ranges based on configuration (prune window), not actual pruner state: [3](#0-2) 

2. **Periodic Refresh**: The cached summary is only refreshed periodically (default 100ms) or on commit notifications: [4](#0-3) 

3. **Validation Uses Cached Summary**: The moderator validates requests against this cached summary: [5](#0-4) 

4. **Processing Checks Actual Pruner State**: During processing, the database checks against the actual minimum readable version from the pruner: [6](#0-5) 

**Attack Scenario:**
- Storage summary claims states available from version 90,001 to 100,000 (based on prune window)
- Pruner has actually progressed and minimum readable version is now 95,000
- Attacker sends requests for versions 90,001 to 94,999
- Validation passes (cached summary says these are available)
- Processing fails with `AptosDbError` â†’ `StorageErrorEncountered`
- `invalid_request_count` is NOT incremented
- Attacker bypasses rate limiting entirely

## Impact Explanation

**Severity: High** (up to $50,000 per Aptos Bug Bounty)

This vulnerability enables **validator node slowdowns** through resource exhaustion:

1. **Unbounded Request Processing**: Attackers can send unlimited requests for pruned data without being rate-limited
2. **Database Load**: Each request triggers expensive database operations (pruner checks, iterator creation) before failing
3. **Resource Exhaustion**: Can cause CPU and I/O exhaustion on storage service nodes
4. **Legitimate Service Degradation**: Other peers may experience degraded service due to resource contention
5. **No Automatic Recovery**: The ignore mechanism is completely bypassed, providing no protection

While this doesn't directly cause consensus violations or fund loss, it significantly impacts network availability and validator performance, meeting the "validator node slowdowns" criterion for High severity.

## Likelihood Explanation

**Likelihood: High**

This vulnerability is highly likely to occur and be exploited:

1. **Always Exploitable**: The timing window exists continuously during active pruning operations
2. **No Special Knowledge Required**: Attackers only need to monitor the advertised storage summary to identify pruned versions
3. **Low Attack Complexity**: Simply send `GetStateValuesWithProof` requests with versions in the pruned range
4. **Amplification Factor**: One attacker can send thousands of requests before any refresh cycle completes
5. **Production Relevance**: Pruning runs continuously on production nodes to manage storage growth
6. **No Authentication Required**: Any network peer can exploit this

The default 100ms refresh interval provides a small but exploitable window, and operators may configure longer intervals for performance reasons, widening the attack surface.

## Recommendation

**Fix 1: Track Storage Errors in Rate Limiting**

Modify the error handling to increment `invalid_request_count` for storage errors that indicate invalid requests (e.g., pruned data):

```rust
// In moderator.rs validate_request
match storage_server_summary.can_service(...) {
    false => {
        unhealthy_peer_state.increment_invalid_request_count(peer_network_id);
        return Err(Error::InvalidRequest(...));
    }
    true => Ok(())
}

// In handler.rs validate_and_handle_request  
match self.validate_and_handle_request(peer_network_id, &request) {
    Err(Error::StorageErrorEncountered(msg)) if msg.contains("pruned") => {
        // Retroactively increment invalid_request_count for pruned data requests
        self.request_moderator.record_storage_error_for_pruned_data(peer_network_id);
        Err(error)
    }
    result => result
}
```

**Fix 2: Use Actual Pruner State in Summary**

Modify `fetch_state_values_range` to query the actual minimum readable version from the pruner instead of calculating based on configuration:

```rust
fn fetch_state_values_range(...) -> Result<Option<CompleteDataRange<Version>>, Error> {
    let pruner_enabled = self.storage.is_state_merkle_pruner_enabled()?;
    if !pruner_enabled {
        return Ok(*transactions_range);
    }
    
    // Get actual minimum readable version from pruner (not configuration)
    let min_readable = self.storage.get_state_merkle_min_readable_version()?;
    let state_range = CompleteDataRange::new(min_readable, latest_version)?;
    Ok(Some(state_range))
}
```

**Fix 3: Aggressive Summary Refresh on Pruning**

Add a notification mechanism from the pruner to immediately refresh the cached summary when significant pruning occurs.

## Proof of Concept

```rust
#[cfg(test)]
mod test_rate_limit_bypass {
    use super::*;
    use aptos_config::config::StorageServiceConfig;
    use aptos_types::PeerId;
    use aptos_config::network_id::{NetworkId, PeerNetworkId};
    use aptos_storage_service_types::requests::{
        DataRequest, StateValuesWithProofRequest, StorageServiceRequest
    };

    #[tokio::test]
    async fn test_pruned_version_bypasses_rate_limiting() {
        // Setup: Create storage service with pruning enabled
        let mut config = StorageServiceConfig::default();
        config.max_invalid_requests_per_peer = 5;
        
        // Mock storage that:
        // 1. Advertises states 90001-100000 in summary
        // 2. Actually has min_readable_version = 95000 (versions 90001-94999 pruned)
        let mock_storage = create_mock_storage_with_pruned_data();
        
        let moderator = RequestModerator::new(
            config,
            cached_storage_summary.clone(),
            peers_and_metadata,
            time_service.clone(),
        );
        
        // Attacker: PFN peer
        let attacker_peer = PeerNetworkId::new(NetworkId::Public, PeerId::random());
        
        // Send 10 requests for pruned versions (should be invalid but bypass rate limiting)
        for version in 90001..90011 {
            let request = StorageServiceRequest {
                data_request: DataRequest::GetStateValuesWithProof(
                    StateValuesWithProofRequest {
                        version,
                        start_index: 0,
                        end_index: 100,
                    }
                ),
                use_compression: false,
            };
            
            // Validation passes (cached summary says version is available)
            let validation_result = moderator.validate_request(&attacker_peer, &request);
            assert!(validation_result.is_ok(), "Validation should pass");
            
            // Processing fails with StorageErrorEncountered (version pruned)
            let processing_result = handler.process_request(&attacker_peer, request, false);
            assert!(matches!(
                processing_result,
                Err(StorageServiceError::InternalError(msg)) if msg.contains("pruned")
            ));
        }
        
        // Verify: Attacker is NOT ignored (rate limiting bypassed)
        let peer_states = moderator.get_unhealthy_peer_states();
        if let Some(peer_state) = peer_states.get(&attacker_peer) {
            // invalid_request_count should be 0 (not incremented for storage errors)
            assert_eq!(peer_state.invalid_request_count, 0);
            assert!(!peer_state.is_ignored());
        }
        
        // Expected: After 10 storage errors, peer should have been ignored
        // Actual: Peer can continue sending unlimited requests
        println!("VULNERABILITY CONFIRMED: Rate limiting bypassed for pruned data requests");
    }
}
```

## Notes

This vulnerability is particularly concerning because:

1. **Silent Exploitation**: Storage errors don't trigger warnings about rate limiting
2. **Persistent Attack Surface**: The pruning window continuously moves, providing fresh targets
3. **Network-Wide Impact**: Can be executed against all storage service nodes simultaneously
4. **Difficulty in Detection**: Legitimate peers may also occasionally hit pruned data, making attack traffic blend in

The fix requires careful consideration of which storage errors should count as "invalid requests" vs. legitimate temporary failures, to avoid penalizing honest peers experiencing transient issues.

### Citations

**File:** state-sync/storage-service/server/src/moderator.rs (L151-159)
```rust
            // Get the latest storage server summary
            let storage_server_summary = self.cached_storage_server_summary.load();

            // Verify the request is serviceable using the current storage server summary
            if !storage_server_summary.can_service(
                &self.aptos_data_client_config,
                self.time_service.clone(),
                request,
            ) {
```

**File:** state-sync/storage-service/server/src/moderator.rs (L160-184)
```rust
                // Increment the invalid request count for the peer
                let mut unhealthy_peer_state = self
                    .unhealthy_peer_states
                    .entry(*peer_network_id)
                    .or_insert_with(|| {
                        // Create a new unhealthy peer state (this is the first invalid request)
                        let max_invalid_requests =
                            self.storage_service_config.max_invalid_requests_per_peer;
                        let min_time_to_ignore_peers_secs =
                            self.storage_service_config.min_time_to_ignore_peers_secs;
                        let time_service = self.time_service.clone();

                        UnhealthyPeerState::new(
                            max_invalid_requests,
                            min_time_to_ignore_peers_secs,
                            time_service,
                        )
                    });
                unhealthy_peer_state.increment_invalid_request_count(peer_network_id);

                // Return the validation error
                return Err(Error::InvalidRequest(format!(
                    "The given request cannot be satisfied. Request: {:?}, storage summary: {:?}",
                    request, storage_server_summary
                )));
```

**File:** state-sync/storage-service/server/src/error.rs (L43-47)
```rust
impl From<aptos_storage_interface::AptosDbError> for Error {
    fn from(error: aptos_storage_interface::AptosDbError) -> Self {
        Error::StorageErrorEncountered(error.to_string())
    }
}
```

**File:** state-sync/storage-service/server/src/storage.rs (L143-176)
```rust
    /// Returns the state values range held in the database (lowest to highest).
    /// Note: it is currently assumed that if a node contains a transaction at a
    /// version, V, the node also contains all state values at V.
    fn fetch_state_values_range(
        &self,
        latest_version: Version,
        transactions_range: &Option<CompleteDataRange<Version>>,
    ) -> aptos_storage_service_types::Result<Option<CompleteDataRange<Version>>, Error> {
        let pruner_enabled = self.storage.is_state_merkle_pruner_enabled()?;
        if !pruner_enabled {
            return Ok(*transactions_range);
        }
        let pruning_window = self.storage.get_epoch_snapshot_prune_window()?;

        if latest_version > pruning_window as Version {
            // lowest_state_version = latest_version - pruning_window + 1;
            let mut lowest_state_version = latest_version
                .checked_sub(pruning_window as Version)
                .ok_or_else(|| {
                    Error::UnexpectedErrorEncountered("Lowest state version has overflown!".into())
                })?;
            lowest_state_version = lowest_state_version.checked_add(1).ok_or_else(|| {
                Error::UnexpectedErrorEncountered("Lowest state version has overflown!".into())
            })?;

            // Create the state range
            let state_range = CompleteDataRange::new(lowest_state_version, latest_version)
                .map_err(|error| Error::UnexpectedErrorEncountered(error.to_string()))?;
            return Ok(Some(state_range));
        }

        // No pruning has occurred. Return the transactions range.
        Ok(*transactions_range)
    }
```

**File:** state-sync/storage-service/server/src/lib.rs (L180-217)
```rust
        // Spawn the task
        self.runtime.spawn(async move {
            // Create a ticker for the refresh interval
            let duration = Duration::from_millis(config.storage_summary_refresh_interval_ms);
            let ticker = time_service.interval(duration);
            futures::pin_mut!(ticker);

            // Continuously refresh the cache
            loop {
                futures::select! {
                    _ = ticker.select_next_some() => {
                        // Refresh the cache periodically
                        refresh_cached_storage_summary(
                            cached_storage_server_summary.clone(),
                            storage.clone(),
                            config,
                            cache_update_notifiers.clone(),
                        )
                    },
                    notification = storage_service_listener.select_next_some() => {
                        trace!(LogSchema::new(LogEntry::ReceivedCommitNotification)
                            .message(&format!(
                                "Received commit notification for highest synced version: {:?}.",
                                notification.highest_synced_version
                            ))
                        );

                        // Refresh the cache because of a commit notification
                        refresh_cached_storage_summary(
                            cached_storage_server_summary.clone(),
                            storage.clone(),
                            config,
                            cache_update_notifiers.clone(),
                        )
                    },
                }
            }
        });
```

**File:** storage/aptosdb/src/db/aptosdb_internal.rs (L273-303)
```rust
    pub(super) fn error_if_state_merkle_pruned(
        &self,
        data_type: &str,
        version: Version,
    ) -> Result<()> {
        let min_readable_version = self
            .state_store
            .state_db
            .state_merkle_pruner
            .get_min_readable_version();
        if version >= min_readable_version {
            return Ok(());
        }

        let min_readable_epoch_snapshot_version = self
            .state_store
            .state_db
            .epoch_snapshot_pruner
            .get_min_readable_version();
        if version >= min_readable_epoch_snapshot_version {
            self.ledger_db.metadata_db().ensure_epoch_ending(version)
        } else {
            bail!(
                "{} at version {} is pruned. snapshots are available at >= {}, epoch snapshots are available at >= {}",
                data_type,
                version,
                min_readable_version,
                min_readable_epoch_snapshot_version,
            )
        }
    }
```
