# Audit Report

## Title
Gas Metering Bypass in Annotated Layout Serialization via Malicious Field Names

## Summary
The `struct_to_type_layout()` function constructs annotated layouts with field names that can be exploited to cause gas undercharging. When a struct has the maximum allowed number of fields (255) with maximum-length field names (255 bytes each under current feature flags), the `native_format` function charges only a flat base gas cost per type node while performing expensive string allocation and concatenation operations proportional to the total field name byte size (~65KB).

## Finding Description
The vulnerability spans two components:

1. **Layout Construction** (lines 499-511): [1](#0-0) 
   The annotated layout builder clones field names from struct definitions and includes them in `MoveFieldLayout` structures without checking total byte size—only node count and depth are validated.

2. **Field Name Serialization** (line 84): [2](#0-1) 
   Field names are written to output strings without per-byte gas charging, despite potentially being 255 bytes each.

3. **Insufficient Gas Charging** (line 233): [3](#0-2) 
   Only `STRING_UTILS_BASE` (1102 gas units) is charged per type node, regardless of field name lengths.

**Attack Path:**
1. Attacker publishes a Move module containing a struct with 255 fields, each field name exactly 255 bytes (maximum allowed per [4](#0-3) )
2. Field count limit is 255 per [5](#0-4) 
3. Total field name metadata: 255 fields × 255 bytes = 65,025 bytes
4. User calls `string_utils::native_format` on a value of this type
5. Layout construction passes validation (256 nodes, depth 2) per [6](#0-5) 
6. Gas charged: ~256 nodes × 1102 = ~282,112 gas units per [7](#0-6) 
7. Gas should be charged: ~282k + (65,025 bytes × 3 gas/byte) = ~477k units per [8](#0-7) 
8. Attacker gains ~40% discount on computation costs

The feature flag `LIMIT_MAX_IDENTIFIER_LENGTH` is enabled by default [9](#0-8) , limiting identifiers to 255 bytes rather than the legacy 65,535-byte limit.

## Impact Explanation
This represents a **Medium severity** gas metering bypass:

- **Resource Limits Violation**: Breaks invariant #9 ("All operations must respect gas, storage, and computational limits")
- **Economic Impact**: Attacker receives ~195k gas units worth of computation for free per call (~40% discount)
- **Limited Exploitability**: While the undercharge is real, 65KB allocations per call are insufficient to cause validator node slowdowns at realistic transaction volumes
- **No Consensus Impact**: Does not affect deterministic execution or state root computation
- **No Direct Funds Loss**: Not directly stealing funds, but gaining underpriced computation

Per Aptos bounty criteria, this falls into the gray area between Medium ("Limited funds loss or manipulation") and Low severity, as the gas theft is limited in scope and unlikely to cause node availability issues.

## Likelihood Explanation
**Moderate likelihood** of exploitation:
- Simple to execute (requires only publishing a specially crafted module)
- No special privileges required
- Economic viability is questionable (attacker still pays ~282k gas per call)
- Limited practical impact (savings of ~195k gas per call insufficient for profitable attack)
- Would require sustained high-volume exploitation to cause validator impacts

## Recommendation
Add per-byte gas charging for field name serialization in `native_format_impl`:

```rust
fn write_name(&self, context: &mut FormatContext, out: &mut String) -> SafeNativeResult<()> {
    if context.should_charge_gas {
        context.context.charge(STRING_UTILS_PER_BYTE * NumBytes::new(self.name.len() as u64))?;
    }
    write!(out, "{}: ", self.name).unwrap();
    Ok(())
}
```

Additionally, consider adding a total byte size check during layout construction to prevent excessively large metadata allocations.

## Proof of Concept
```move
module 0xCAFE::exploit {
    use std::string_utils;
    
    // Field names are each 255 bytes (maximum identifier length)
    struct MaliciousStruct has drop {
        aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa: u64,
        // Repeat 254 more times with unique 255-byte names
        // ... (truncated for brevity)
    }
    
    public entry fun trigger_undercharge() {
        let val = MaliciousStruct { aaaaaaa...: 1, /* ... */ };
        // Calling format will undercharge by ~195k gas units
        let _formatted = string_utils::debug_string(&val);
    }
}
```

**Notes:**
- The feature flag enforcement at deserialization time [10](#0-9)  prevents legacy modules with 65KB identifiers from being loaded when `LIMIT_MAX_IDENTIFIER_LENGTH` is enabled
- Field names originate from validated bytecode [11](#0-10)  and pass identifier validation [12](#0-11) 
- The `max_depth` and `max_len` parameters in `FormatContext` are set to `usize::MAX` [13](#0-12) , providing no practical output size limits

### Citations

**File:** third_party/move/move-vm/runtime/src/storage/ty_layout_converter.rs (L197-222)
```rust
    fn check_depth_and_increment_count(
        &self,
        node_count: &mut u64,
        depth: u64,
    ) -> PartialVMResult<()> {
        let max_count = self.vm_config().layout_max_size;
        if *node_count > max_count || *node_count == max_count && self.is_lazy_loading_enabled() {
            return Err(
                PartialVMError::new(StatusCode::TOO_MANY_TYPE_NODES).with_message(format!(
                    "Number of type nodes when constructing type layout exceeded the maximum of {}",
                    max_count
                )),
            );
        }
        *node_count += 1;

        if depth > self.vm_config().layout_max_depth {
            return Err(
                PartialVMError::new(StatusCode::VM_MAX_VALUE_DEPTH_REACHED).with_message(format!(
                    "Depth of a layout exceeded the maximum of {} during construction",
                    self.vm_config().layout_max_depth
                )),
            );
        }
        Ok(())
    }
```

**File:** third_party/move/move-vm/runtime/src/storage/ty_layout_converter.rs (L499-511)
```rust
                            if ANNOTATED {
                                let ty_tag_converter = TypeTagConverter::new(
                                    self.struct_definition_loader.runtime_environment(),
                                );
                                let struct_tag =
                                    ty_tag_converter.struct_name_idx_to_struct_tag(idx, ty_args)?;
                                let field_layouts = fields
                                    .iter()
                                    .map(|(name, _)| name.clone())
                                    .zip(field_layouts)
                                    .map(|(name, layout)| MoveFieldLayout::new(name, layout))
                                    .collect();
                                MoveStructLayout::with_types(struct_tag, field_layouts)
```

**File:** aptos-move/framework/src/natives/string_utils.rs (L83-85)
```rust
    fn write_name(&self, out: &mut String) {
        write!(out, "{}: ", self.name).unwrap();
    }
```

**File:** aptos-move/framework/src/natives/string_utils.rs (L232-234)
```rust
    if context.should_charge_gas {
        context.context.charge(STRING_UTILS_BASE)?;
    }
```

**File:** aptos-move/framework/src/natives/string_utils.rs (L578-587)
```rust
    let mut format_context = FormatContext {
        context,
        should_charge_gas: true,
        max_depth: usize::MAX,
        max_len: usize::MAX,
        type_tag,
        canonicalize,
        single_line,
        include_int_type,
    };
```

**File:** third_party/move/move-binary-format/src/file_format_common.rs (L67-67)
```rust
pub const IDENTIFIER_SIZE_MAX: u64 = 255;
```

**File:** third_party/move/move-binary-format/src/file_format_common.rs (L78-78)
```rust
pub const FIELD_COUNT_MAX: u64 = 255;
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/aptos_framework.rs (L357-357)
```rust
        [string_utils_base: InternalGas, { 8.. => "string_utils.format.base" }, 1102],
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/aptos_framework.rs (L358-358)
```rust
        [string_utils_per_byte: InternalGasPerByte, { 8.. =>"string_utils.format.per_byte" }, 3],
```

**File:** types/src/on_chain_config/aptos_features.rs (L212-212)
```rust
            FeatureFlag::LIMIT_MAX_IDENTIFIER_LENGTH,
```

**File:** third_party/move/move-binary-format/src/deserializer.rs (L394-396)
```rust
fn load_identifier_size(cursor: &mut VersionedCursor) -> BinaryLoaderResult<usize> {
    read_uleb_internal(cursor, cursor.max_identifier_size())
}
```

**File:** third_party/move/move-vm/runtime/src/loader/modules.rs (L495-502)
```rust
    ) -> PartialVMResult<(Identifier, Type)> {
        let ty = convert_tok_to_type(
            BinaryIndexedView::Module(module),
            &field.signature.0,
            struct_name_table,
        )?;
        Ok((module.identifier_at(field.name).to_owned(), ty))
    }
```

**File:** third_party/move/move-core/types/src/identifier.rs (L82-94)
```rust
pub const fn is_valid(s: &str) -> bool {
    // Rust const fn's don't currently support slicing or indexing &str's, so we
    // have to operate on the underlying byte slice. This is not a problem as
    // valid identifiers are (currently) ASCII-only.
    let b = s.as_bytes();
    match b {
        b"<SELF>" => true,
        [b'<', b'S', b'E', b'L', b'F', b'>', b'_', ..] if b.len() > 7 => all_bytes_numeric(b, 7),
        [b'a'..=b'z', ..] | [b'A'..=b'Z', ..] => all_bytes_valid(b, 1),
        [b'_', ..] | [b'$', ..] if b.len() > 1 => all_bytes_valid(b, 1),
        _ => false,
    }
}
```
