# Audit Report

## Title
Non-Atomic Configuration File Write Causes Validator Availability Failure on System Crashes

## Summary
The `write_file()` function in `PersistableConfig` uses a non-atomic write operation that truncates the configuration file before writing new content. If the write operation fails partway through (due to power failure, process termination, disk full, or I/O errors), the configuration file is left in a corrupted state, preventing validator restart and causing availability failures.

## Finding Description

The vulnerability exists in the configuration persistence mechanism used throughout the Aptos codebase. [1](#0-0) 

The `write_file()` method performs two sequential operations:
1. `File::create()` - immediately truncates any existing configuration file
2. `write_all()` - writes the new configuration content

If the system crashes, loses power, runs out of disk space, or the process is terminated between these operations or during the write, the configuration file is left truncated or partially written.

When this occurs in production configuration files (used by `NodeConfig`, `OverrideNodeConfig`, and `SafetyRulesConfig`), validators cannot restart because the YAML parsing fails: [2](#0-1) 

The `save_config()` implementation in `OverrideNodeConfig` (line 151, not 150 as mentioned in the question) directly calls this vulnerable `write_file()` method: [3](#0-2) 

Similarly, `NodeConfig::save_to_path()` uses the same vulnerable pattern when persisting validator configurations: [4](#0-3) 

**Attack Scenario:**
While this cannot be directly exploited by an external attacker, it creates a reliability vulnerability that affects network availability:

1. During routine validator configuration updates (common in production operations), an operator saves a new configuration using the affected code paths
2. A system failure occurs (power outage, kernel panic, OOM killer, disk full condition)
3. The configuration file is left in a corrupted state - either truncated or partially written
4. The validator cannot restart because YAML parsing fails with a panic
5. If multiple validators in a network experience coordinated failures (e.g., during a data center power event affecting multiple validators simultaneously), and >1/3 of validators have corrupted configs, the network cannot achieve consensus

## Impact Explanation

This issue falls under **Medium Severity** according to Aptos bug bounty criteria as "State inconsistencies requiring intervention":

- Corrupted configuration files require manual intervention to recover (restoring from backup, regenerating configuration)
- Can cause validator unavailability, reducing network capacity
- In coordinated failure scenarios (data center outages affecting multiple validators), can contribute to network liveness failures if >1/3 of validators are affected

While this is primarily an operational reliability issue rather than a directly exploitable security vulnerability, it violates the availability guarantees expected of validator infrastructure and can contribute to network-wide liveness failures under adverse conditions.

## Likelihood Explanation

**Likelihood: Medium**

This vulnerability is triggered by environmental failures rather than attacker actions:
- System crashes, power failures, and disk full conditions occur regularly in production environments
- Configuration updates happen during validator maintenance, upgrades, and operational changes
- The window of vulnerability is small (during the write operation) but non-zero
- Cloud infrastructure, despite redundancy, can experience correlated failures affecting multiple validators

The issue is exacerbated because configuration updates often happen across multiple validators in a coordinated manner (e.g., during network upgrades), increasing the risk of multiple validators being affected by a single environmental event.

## Recommendation

Implement atomic file writes using the write-rename pattern to ensure configuration persistence is crash-safe:

```rust
fn write_file<P: AsRef<Path>>(serialized_config: Vec<u8>, output_file: P) -> Result<(), Error> {
    use std::fs;
    use std::io::Write;
    
    let output_path = output_file.as_ref();
    
    // Create temporary file in same directory as target (ensures same filesystem for atomic rename)
    let temp_path = output_path.with_extension("tmp");
    
    // Write to temporary file
    let mut temp_file = File::create(&temp_path)
        .map_err(|e| Error::IO(temp_path.to_str().unwrap().to_string(), e))?;
    
    temp_file.write_all(&serialized_config)
        .map_err(|e| Error::IO(temp_path.to_str().unwrap().to_string(), e))?;
    
    // Ensure data is flushed to disk before rename
    temp_file.sync_all()
        .map_err(|e| Error::IO(temp_path.to_str().unwrap().to_string(), e))?;
    
    // Atomic rename (POSIX guarantees atomicity)
    fs::rename(&temp_path, output_path)
        .map_err(|e| Error::IO(output_path.to_str().unwrap().to_string(), e))?;
    
    Ok(())
}
```

This ensures that:
1. The original file remains intact until the new file is fully written and synced
2. The rename operation is atomic on POSIX systems
3. No intermediate state is observable during crashes or power failures
4. Either the old configuration or the new configuration exists, never a corrupted state

## Proof of Concept

```rust
// Reproduction steps demonstrating the vulnerability:
// 1. Create a validator with a configuration file
// 2. Modify and save the configuration
// 3. Simulate crash during write (requires system-level intervention)
// 4. Attempt to restart validator - observe panic on corrupted YAML

use aptos_config::config::{NodeConfig, PersistableConfig};
use std::fs;
use std::path::PathBuf;

#[test]
fn test_non_atomic_write_vulnerability() {
    let temp_dir = tempfile::tempdir().unwrap();
    let config_path = temp_dir.path().join("node.yaml");
    
    // Create initial config
    let mut config = NodeConfig::default();
    config.save_config(&config_path).unwrap();
    
    // Verify config loads successfully
    let loaded = NodeConfig::load_config(&config_path).unwrap();
    
    // Simulate corruption by truncating file (mimics crash during write)
    fs::write(&config_path, "api:\n  enable").unwrap(); // Partial YAML
    
    // Attempt to load corrupted config - this will panic in production
    let result = NodeConfig::load_config(&config_path);
    assert!(result.is_err()); // Parsing fails on corrupted YAML
    
    // In production, this causes validator startup failure per lib.rs:177-183
    // The panic prevents validator participation in consensus
}
```

## Notes

- The security question referenced line 150 in `override_node_config.rs`, but the actual `write_file` call occurs at line 151
- This vulnerability affects all configuration types implementing `PersistableConfig`: `NodeConfig`, `SafetyRulesConfig`, and `OverrideNodeConfig`
- While not directly exploitable by external attackers, this creates operational fragility that can lead to availability failures under environmental stress
- The recommended fix using atomic writes is a standard best practice for crash-safe file persistence in systems software

### Citations

**File:** config/src/config/persistable_config.rs (L43-50)
```rust
    fn write_file<P: AsRef<Path>>(serialized_config: Vec<u8>, output_file: P) -> Result<(), Error> {
        let mut file = File::create(output_file.as_ref())
            .map_err(|e| Error::IO(output_file.as_ref().to_str().unwrap().to_string(), e))?;
        file.write_all(&serialized_config)
            .map_err(|e| Error::IO(output_file.as_ref().to_str().unwrap().to_string(), e))?;

        Ok(())
    }
```

**File:** aptos-node/src/lib.rs (L177-183)
```rust
            let config = NodeConfig::load_from_path(config_path.clone()).unwrap_or_else(|error| {
                panic!(
                    "Failed to load the node config file! Given file path: {:?}. Error: {:?}",
                    config_path.display(),
                    error
                )
            });
```

**File:** config/src/config/override_node_config.rs (L142-152)
```rust
    fn save_config<P: AsRef<Path>>(&self, output_file: P) -> Result<(), Error> {
        let yaml_value = self.get_yaml()?;
        let yaml_string = serde_yaml::to_string(&yaml_value).map_err(|e| {
            Error::Yaml(
                "Unable to serialize override config to yaml. Error: {}".to_string(),
                e,
            )
        })?;
        let yaml_bytes = yaml_string.as_bytes().to_vec();
        Self::write_file(yaml_bytes, output_file)
    }
```

**File:** config/src/config/node_config.rs (L171-181)
```rust
    pub fn save_to_path<P: AsRef<Path>>(&mut self, output_path: P) -> Result<(), Error> {
        // Save the execution config to disk.
        let output_dir = RootPath::new(&output_path);
        self.execution.save_to_path(&output_dir)?;

        // Write the node config to disk. Note: this must be called last
        // as calling save_to_path() on subconfigs may change fields.
        self.save_config(&output_path)?;

        Ok(())
    }
```
