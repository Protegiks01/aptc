# Audit Report

## Title
Missing Final Root Hash Verification in State Restore Allows Silent Database Corruption

## Summary
The `JellyfishMerkleRestore::finish_impl()` method fails to verify that the final reconstructed Merkle tree's root hash matches the `expected_root_hash` parameter. This allows incomplete or corrupted state trees to be committed to persistent storage without any error being raised, violating the fundamental invariant that "state transitions must be atomic and verifiable via Merkle proofs."

## Finding Description

The state restoration process in Aptos uses the Jellyfish Merkle Tree to restore blockchain state from snapshots. The `expected_root_hash` parameter is passed during initialization to ensure the restored tree matches the expected state. [1](#0-0) 

However, the implementation has a critical flaw: while individual chunks are verified during restoration through the `verify()` method, the **final root hash is never checked** when the restoration completes.

**Code Flow Analysis:**

1. **During chunk addition**: The `add_chunk_impl()` method calls `verify()` after each chunk to ensure the proof is valid. [2](#0-1) 

2. **The verify method**: This validates that the partial tree combined with the proof produces the expected root hash. [3](#0-2) 

3. **The critical flaw in finish_impl()**: When restoration completes, `finish_impl()` calls `freeze(0)` to freeze all remaining nodes including the root, then writes them to storage **without any final verification**. [4](#0-3) 

4. **Root hash computation without verification**: The `freeze_internal_nodes()` method computes the root node's hash but never compares it to `expected_root_hash`. [5](#0-4) 

5. **Only post-facto check exists**: The only verification happens when resuming a previously completed restore, which is too late—invalid state has already been written. [6](#0-5) 

**Attack Scenario:**
1. State restore is initiated with a valid `expected_root_hash` from the manifest
2. Partial chunks are provided with valid proofs (each passes incremental verification)
3. Restore finishes prematurely due to: network interruption, timeout, bug in chunk provider, or malicious truncation
4. The incomplete tree is frozen with a root hash that does **NOT** match `expected_root_hash`
5. No error is raised—invalid state is committed to database
6. Different nodes may end up with different state trees, breaking consensus

## Impact Explanation

**Critical Severity** - This vulnerability meets multiple critical impact categories:

1. **Consensus/Safety Violations**: Different validator nodes could restore different incomplete states, leading to consensus disagreement on the state root. This violates Aptos's fundamental invariant #1: "All validators must produce identical state roots for identical blocks."

2. **State Corruption**: Invalid, incomplete Merkle trees are permanently written to the database. Once committed, this corrupted state becomes part of the node's canonical view, potentially requiring manual intervention or hard fork to recover.

3. **Silent Failure**: The vulnerability is particularly dangerous because no error is raised—operators have no indication that corruption occurred until subsequent operations fail or state divergence is detected through external monitoring.

4. **Deterministic Execution Violation**: State inconsistencies across nodes violate deterministic execution guarantees, potentially causing block execution to produce different results on different validators.

This meets the **Critical Severity** criteria for "Consensus/Safety violations" and "State inconsistencies requiring intervention."

## Likelihood Explanation

**High Likelihood** - This vulnerability can be triggered in multiple realistic scenarios:

1. **Network Interruptions**: During state synchronization, network failures could cause chunk delivery to stop prematurely, yet `finish()` might still be called.

2. **Timeout Conditions**: Restore operations with timeouts may call `finish()` before all chunks are received.

3. **Implementation Bugs**: Bugs in the backup/restore orchestration layer could provide incomplete chunk sets.

4. **Malicious Actors**: An attacker controlling the backup source could provide valid partial chunks then trigger early completion.

The backup-cli code shows that after calling `finish()`, no verification occurs. [7](#0-6) 

Test code demonstrates that external verification is expected but not enforced by the restore implementation itself. [8](#0-7) 

## Recommendation

Add a final root hash verification in `finish_impl()` before writing nodes to storage:

```rust
pub fn finish_impl(mut self) -> Result<()> {
    self.wait_for_async_commit()?;
    
    // ... existing special case handling ...
    
    self.freeze(0);
    
    // CRITICAL FIX: Verify final root hash before committing
    let root_node_key = NodeKey::new_empty_path(self.version);
    if let Some(root_node) = self.frozen_nodes.get(&root_node_key) {
        let actual_root_hash = root_node.hash();
        ensure!(
            actual_root_hash == self.expected_root_hash,
            "Final root hash mismatch. Actual: {:x}, Expected: {:x}",
            actual_root_hash,
            self.expected_root_hash
        );
    } else {
        return Err(anyhow!("Root node not found after freezing"));
    }
    
    self.store.write_node_batch(&self.frozen_nodes)?;
    Ok(())
}
```

This ensures that any mismatch between the reconstructed tree and the expected state is caught before invalid data is persisted.

## Proof of Concept

```rust
// Test demonstrating the vulnerability
#[test]
fn test_incomplete_restore_silently_accepted() {
    use aptos_jellyfish_merkle::JellyfishMerkleTree;
    use aptos_crypto::HashValue;
    
    // Setup: Create a tree with 100 leaves
    let (db, version) = create_test_tree_with_leaves(100);
    let tree = JellyfishMerkleTree::new(&db);
    let expected_root_hash = tree.get_root_hash(version).unwrap();
    
    // Attack: Restore only 50 leaves instead of 100
    let restore_db = Arc::new(MockSnapshotStore::default());
    let mut restore = StateSnapshotRestore::new(
        &restore_db,
        &restore_db,
        version,
        expected_root_hash, // Expecting 100 leaves
        false,
        StateSnapshotRestoreMode::Default,
    ).unwrap();
    
    // Add only first 50 leaves (each with valid proof)
    for (key, value) in get_first_n_leaves(&db, 50) {
        let proof = tree.get_range_proof(key, version).unwrap();
        restore.add_chunk(vec![(key, value)], proof).unwrap();
    }
    
    // BUG: finish() succeeds even though tree is incomplete
    restore.finish().unwrap(); // <-- Should fail but doesn't!
    
    // Verify corruption: actual root != expected root
    let corrupted_tree = JellyfishMerkleTree::new(&restore_db);
    let actual_root = corrupted_tree.get_root_hash(version).unwrap();
    
    assert_ne!(actual_root, expected_root_hash); // Different hashes!
    // Yet no error was raised - CRITICAL BUG
}
```

**Notes:**
- The vulnerability exists in the core Jellyfish Merkle tree restoration logic, affecting all state restore operations
- The incremental verification during chunk addition is insufficient because it only verifies the proof for the partial tree
- Production deployments should implement external verification after restore completion as a workaround until this is fixed
- This violates Aptos's critical invariant #4: "State transitions must be atomic and verifiable via Merkle proofs"

### Citations

**File:** storage/aptosdb/src/state_restore/mod.rs (L163-164)
```rust
                version,
                expected_root_hash,
```

**File:** storage/jellyfish-merkle/src/restore/mod.rs (L200-205)
```rust
            ensure!(
                root_node.hash() == expected_root_hash,
                "Previous completed restore has root hash {}, expecting {}",
                root_node.hash(),
                expected_root_hash,
            );
```

**File:** storage/jellyfish-merkle/src/restore/mod.rs (L391-391)
```rust
        self.verify(proof)?;
```

**File:** storage/jellyfish-merkle/src/restore/mod.rs (L594-596)
```rust
            let node_hash = internal_node.hash();
            let node_leaf_count = internal_node.leaf_count();
            self.frozen_nodes.insert(node_key, internal_node.into());
```

**File:** storage/jellyfish-merkle/src/restore/mod.rs (L690-696)
```rust
        proof
            .verify(
                self.expected_root_hash,
                SparseMerkleLeafNode::new(*previous_key, previous_leaf.value_hash()),
                left_siblings,
            )
            .map_err(Into::into)
```

**File:** storage/jellyfish-merkle/src/restore/mod.rs (L786-788)
```rust
        self.freeze(0);
        self.store.write_node_batch(&self.frozen_nodes)?;
        Ok(())
```

**File:** storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs (L228-230)
```rust
        tokio::task::spawn_blocking(move || receiver.lock().take().unwrap().finish()).await??;
        self.run_mode.finish();
        Ok(())
```

**File:** storage/aptosdb/src/state_restore/restore_test.rs (L251-252)
```rust
    let actual_root_hash = tree.get_root_hash(version).unwrap();
    assert_eq!(actual_root_hash, expected_root_hash);
```
