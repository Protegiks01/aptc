# Audit Report

## Title
Arc Aliasing Enables Block Double-Finalization During State Sync Transitions

## Summary
The BTreeMap clone at line 49 creates shallow copies that alias Arc<PipelinedBlock> references. This aliasing, combined with insufficient cleanup during state sync transitions, allows blocks to be finalized twice—once during normal operation and again when state sync completes—potentially corrupting execution pipeline state.

## Finding Description

The vulnerability stems from the shallow clone semantics of the `get_all_ordered_blocks()` function combined with timing windows during state sync operations. [1](#0-0) 

The clone operation creates a new BTreeMap but preserves Arc references to the underlying PipelinedBlock objects, which contain interior mutability through Mutex and OnceCell fields: [2](#0-1) 

**Attack Scenario:**

1. **Normal Processing Phase**: An ordered block arrives when the observer is NOT syncing. The block is inserted into `ordered_blocks` and immediately finalized: [3](#0-2) 

2. **State Sync Trigger**: Before the finalized block is committed (and thus removed from `ordered_blocks`), a commit decision for a future round arrives, triggering state sync.

3. **State Sync Completion**: When state sync completes, ALL blocks in `ordered_blocks` are processed again: [4](#0-3) 

4. **Double Finalization**: The previously-finalized block is finalized again, causing:
   - Pipeline state corruption through repeated `build_for_observer()` calls
   - Duplicate `execution_client.finalize_order()` calls with the same blocks
   - Potential race conditions on Mutex-protected fields in PipelinedBlock [5](#0-4) 

The critical timing window exists because blocks remain in `ordered_blocks` until the commit callback removes them, which only occurs after execution completes: [6](#0-5) 

## Impact Explanation

This qualifies as **Medium Severity** based on:

- **State Inconsistencies**: Double finalization can cause execution pipeline state corruption, requiring manual intervention to restore consistency
- **Consensus Observer Disruption**: Affected observer nodes may diverge from consensus or fail to properly track committed state
- **Limited Scope**: Only affects consensus observer nodes during specific state sync transitions, not the core consensus mechanism itself

The vulnerability breaks the **State Consistency** invariant by allowing the same block to enter the execution pipeline multiple times, potentially causing non-deterministic execution results on observer nodes.

## Likelihood Explanation

**Likelihood: Medium**

The vulnerability requires specific timing conditions:
- A block must be finalized during normal operation
- State sync must be triggered (via a future commit decision) before the block is committed
- State sync must complete while the block still exists in `ordered_blocks`

This timing window is narrow but realistic in production environments where:
- Network latency varies between peers
- Some validators may be ahead of others
- State sync can be triggered by any valid future commit decision

The vulnerability does NOT require attacker capabilities beyond normal network participation, as legitimate commit decisions from honest validators can trigger the condition.

## Recommendation

Add a tracking mechanism to prevent double-finalization of blocks:

**Option 1**: Track finalized blocks and skip them during state sync processing:

```rust
// In OrderedBlockStore
finalized_blocks: BTreeSet<(u64, Round)>,

pub fn mark_finalized(&mut self, epoch: u64, round: Round) {
    self.finalized_blocks.insert((epoch, round));
}

pub fn is_finalized(&self, epoch: u64, round: Round) -> bool {
    self.finalized_blocks.contains(&(epoch, round))
}

// In consensus_observer.rs, line 791
if !self.state_sync_manager.is_syncing_to_commit() {
    self.finalize_ordered_block(ordered_block.clone()).await;
    self.observer_block_data.lock().mark_finalized(
        ordered_block.last_block().epoch(),
        ordered_block.last_block().round()
    );
}

// In consensus_observer.rs, line 1052
for (_, (observed_ordered_block, commit_decision)) in all_ordered_blocks {
    let ordered_block = observed_ordered_block.consume_ordered_block();
    let epoch = ordered_block.last_block().epoch();
    let round = ordered_block.last_block().round();
    
    if !self.observer_block_data.lock().is_finalized(epoch, round) {
        self.finalize_ordered_block(ordered_block).await;
    }
    // ... rest of code
}
```

**Option 2**: Clear `ordered_blocks` when blocks are finalized during normal operation, relying only on pending blocks during state sync.

## Proof of Concept

The vulnerability can be demonstrated with the following test scenario:

```rust
#[tokio::test]
async fn test_double_finalization_via_state_sync() {
    // 1. Initialize consensus observer
    let mut observer = create_test_observer();
    
    // 2. Receive ordered block when NOT syncing
    let block_epoch = 0;
    let block_round = 10;
    let ordered_block = create_test_ordered_block(block_epoch, block_round);
    
    // Block is inserted into ordered_blocks and finalized immediately
    observer.process_ordered_block_message(ordered_block.clone()).await;
    
    // 3. Verify block is in ordered_blocks
    let all_blocks = observer.observer_block_data.lock().get_all_ordered_blocks();
    assert!(all_blocks.contains_key(&(block_epoch, block_round)));
    
    // 4. Trigger state sync with a future commit decision
    let future_commit = create_commit_decision(block_epoch, block_round + 5);
    observer.process_commit_decision_message(future_commit).await;
    
    // 5. Simulate state sync completion
    observer.handle_state_sync_commit_notification(block_epoch, block_round + 5).await;
    
    // 6. Observe that finalize_ordered_block is called twice for the same block
    // This can be verified through execution pipeline logs or instrumentation
    // showing duplicate finalize_order calls with identical block IDs
}
```

**Notes:**
- The vulnerability requires careful observation of execution pipeline state
- Production manifestation would show duplicate execution attempts in logs
- State corruption symptoms may include inconsistent state roots or execution failures

### Citations

**File:** consensus/src/consensus_observer/observer/ordered_blocks.rs (L45-50)
```rust
    /// Returns a copy of the ordered blocks
    pub fn get_all_ordered_blocks(
        &self,
    ) -> BTreeMap<(u64, Round), (ObservedOrderedBlock, Option<CommitDecision>)> {
        self.ordered_blocks.clone()
    }
```

**File:** consensus/consensus-types/src/pipelined_block.rs (L198-217)
```rust
pub struct PipelinedBlock {
    /// Block data that cannot be regenerated.
    block: Block,
    /// A window of blocks that are needed for execution with the execution pool, EXCLUDING the current block
    block_window: OrderedBlockWindow,
    /// Input transactions in the order of execution. DEPRECATED stay for serialization compatibility.
    input_transactions: Vec<SignedTransaction>,
    /// The state_compute_result is calculated for all the pending blocks prior to insertion to
    /// the tree. The execution results are not persisted: they're recalculated again for the
    /// pending blocks upon restart.
    state_compute_result: Mutex<StateComputeResult>,
    randomness: OnceCell<Randomness>,
    pipeline_insertion_time: OnceCell<Instant>,
    execution_summary: OnceCell<ExecutionSummary>,
    /// pipeline related fields
    pipeline_futs: Mutex<Option<PipelineFutures>>,
    pipeline_tx: Mutex<Option<PipelineInputTx>>,
    pipeline_abort_handle: Mutex<Option<Vec<AbortHandle>>>,
    block_qc: Mutex<Option<Arc<QuorumCert>>>,
}
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L275-293)
```rust
        for block in ordered_block.blocks() {
            let commit_callback =
                block_data::create_commit_callback(self.observer_block_data.clone());
            self.pipeline_builder().build_for_observer(
                block,
                parent_fut.take().expect("future should be set"),
                commit_callback,
            );
            parent_fut = Some(block.pipeline_futs().expect("pipeline futures just built"));
        }

        // Send the ordered block to the execution pipeline
        if let Err(error) = self
            .execution_client
            .finalize_order(
                ordered_block.blocks().clone(),
                WrappedLedgerInfo::new(VoteData::dummy(), ordered_block.ordered_proof().clone()),
            )
            .await
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L785-792)
```rust
            self.observer_block_data
                .lock()
                .insert_ordered_block(observed_ordered_block.clone());

            // If state sync is not syncing to a commit, finalize the ordered blocks
            if !self.state_sync_manager.is_syncing_to_commit() {
                self.finalize_ordered_block(ordered_block).await;
            }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L1050-1061)
```rust
        // Process all the newly ordered blocks
        let all_ordered_blocks = self.observer_block_data.lock().get_all_ordered_blocks();
        for (_, (observed_ordered_block, commit_decision)) in all_ordered_blocks {
            // Finalize the ordered block
            let ordered_block = observed_ordered_block.consume_ordered_block();
            self.finalize_ordered_block(ordered_block).await;

            // If a commit decision is available, forward it to the execution pipeline
            if let Some(commit_decision) = commit_decision {
                self.forward_commit_decision(commit_decision.clone());
            }
        }
```

**File:** consensus/src/consensus_observer/observer/block_data.rs (L185-189)
```rust
            ledger_info.commit_info().epoch(),
            ledger_info.commit_info().round(),
        );
        self.ordered_block_store
            .remove_blocks_for_commit(&ledger_info);
```
