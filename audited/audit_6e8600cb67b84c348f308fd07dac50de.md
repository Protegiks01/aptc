# Audit Report

## Title
Unbounded Memory Allocation in StateKey BCS Deserialization Can Crash Indexer and Backup Restore Processes

## Summary
The `StateKey::decode()` function performs BCS deserialization without size limits, allowing malformed data with oversized length prefixes to trigger unbounded memory allocation attempts. This can crash indexer processes and backup restore operations through out-of-memory errors.

## Finding Description

The vulnerability exists in the `StateKey::decode()` implementation which deserializes StateKey objects from their binary representation: [1](#0-0) 

Specifically, line 73 performs BCS deserialization of an `AccessPath` structure without any maximum size constraint. The `AccessPath` structure contains a variable-length `path: Vec<u8>` field: [2](#0-1) 

When BCS deserializes a vector, it:
1. Reads a ULEB128-encoded length prefix
2. Attempts to allocate memory for that many bytes
3. Reads the actual data

A malicious or corrupted byte sequence with a length prefix claiming 4GB (u32::MAX) will cause the allocator to attempt allocating 4GB of memory before discovering the actual data doesn't match, resulting in process crash via OOM.

**Attack Vector 1: Malicious Backup Files**

The backup restore process deserializes StateKeys from backup files without bounds checking: [3](#0-2) 

Critically, this deserialization occurs BEFORE cryptographic proof verification. An attacker can provide backup files containing malformed StateKeys that trigger OOM during the `read_state_value()` call, crashing the restore process before validation rejects the malicious data.

**Attack Vector 2: Indexer Schema Decoding**

The indexer uses the same vulnerable decode path when reading StateKeys from its database: [4](#0-3) 

While the indexer database is typically populated with legitimate data, database corruption or direct filesystem tampering could introduce malformed StateKeys that crash the indexer on read.

**Contrast with Protected Paths**

Other parts of the codebase recognize this risk and use bounded deserialization. For example, transaction argument validation enforces a maximum size limit: [5](#0-4) 

The API layer uses depth-limited BCS deserialization: [6](#0-5) 

However, `StateKey::decode()` lacks any such protections, violating the **Resource Limits** invariant that "all operations must respect gas, storage, and computational limits."

## Impact Explanation

This is a **High Severity** vulnerability under Aptos bug bounty criteria:

1. **Validator Node Slowdowns**: Indexer crashes force nodes to rebuild indexes, causing performance degradation
2. **API Crashes**: Indexer failures impact API query performance and availability
3. **Backup Restore Denial of Service**: Attackers can prevent nodes from restoring from backups by providing malicious backup files

The vulnerability does NOT:
- Affect consensus safety or liveness
- Enable fund theft or minting
- Cause permanent state corruption
- Allow remote code execution

The impact is limited to availability and operational disruption, qualifying as High severity but not Critical.

## Likelihood Explanation

**Likelihood: Medium to High**

For backup restore attacks:
- Node operators frequently restore from backups during disaster recovery
- Backup files may be hosted on cloud storage that could be compromised
- Social engineering could trick operators into using malicious backups
- No authentication or cryptographic binding exists between backup file providers and consumers prior to deserialization

For indexer crashes:
- Database corruption is rare but can occur due to hardware failures or bugs
- Requires filesystem access for deliberate tampering (lower likelihood)

The lack of size validation is an obvious oversight that attackers familiar with BCS serialization would recognize and exploit.

## Recommendation

Implement bounded deserialization for StateKey decoding using `bcs::from_bytes_with_limit()` with appropriate limits:

```rust
pub fn decode(val: &[u8]) -> Result<StateKey, StateKeyDecodeErr> {
    use access_path::Path;

    if val.is_empty() {
        return Err(StateKeyDecodeErr::EmptyInput);
    }
    
    // Add reasonable size limit for StateKey deserialization
    const MAX_STATE_KEY_SIZE: usize = 10_000_000; // 10MB
    
    if val.len() > MAX_STATE_KEY_SIZE {
        return Err(StateKeyDecodeErr::ExceedsMaxSize { 
            size: val.len(), 
            max_size: MAX_STATE_KEY_SIZE 
        });
    }
    
    let tag = val[0];
    let state_key_tag =
        StateKeyTag::from_u8(tag).ok_or(StateKeyDecodeErr::UnknownTag { unknown_tag: tag })?;
    let myself = match state_key_tag {
        StateKeyTag::AccessPath => {
            // Use bounded deserialization
            let AccessPath { address, path } = 
                bcs::from_bytes_with_limit(&val[1..], MAX_STATE_KEY_SIZE)?;
            let path: Path = bcs::from_bytes_with_limit(&path, MAX_STATE_KEY_SIZE)?;
            // ... rest of the code
        },
        // ... other cases
    };
    Ok(myself)
}
```

Additionally, validate StateKeys during backup restore BEFORE deserialization by checking raw byte lengths against reasonable bounds.

## Proof of Concept

```rust
#[test]
fn test_malformed_state_key_oom() {
    use aptos_types::state_store::state_key::StateKey;
    
    // Craft malicious StateKey bytes:
    // - Tag byte for AccessPath (0)
    // - Malformed BCS-encoded AccessPath with huge Vec<u8> length prefix
    let mut malicious_bytes = vec![0u8]; // AccessPath tag
    
    // Add valid AccountAddress (32 bytes)
    malicious_bytes.extend_from_slice(&[0u8; 32]);
    
    // Add path length: ULEB128 encoding of u32::MAX (0xFFFFFFFF)
    // ULEB128: 0xFF, 0xFF, 0xFF, 0xFF, 0x0F
    malicious_bytes.extend_from_slice(&[0xFF, 0xFF, 0xFF, 0xFF, 0x0F]);
    
    // Don't add actual data - the allocator will fail before reading
    
    // Attempt to decode - this should trigger OOM or large allocation
    let result = StateKey::decode(&malicious_bytes);
    
    // Without the fix, this either:
    // 1. Crashes with OOM
    // 2. Allocates ~4GB of memory before failing
    // 
    // With the fix, this returns an error without excessive allocation
    assert!(result.is_err());
}
```

To demonstrate the backup restore vulnerability, create a malicious backup file with crafted StateKey records containing oversized length prefixes, then attempt to restore from it. The process will crash during `read_state_value()` before proof verification occurs.

## Notes

The vulnerability is real and exploitable, but the impact is limited to denial of service rather than more severe consequences like consensus violations or fund theft. The attack requires either providing malicious backup files (which may be detected by other validation mechanisms) or direct filesystem access for database tampering. Nevertheless, the lack of basic bounds checking on untrusted deserialization represents a clear security deficiency that should be remediated.

### Citations

**File:** types/src/state_store/state_key/mod.rs (L62-95)
```rust
    pub fn decode(val: &[u8]) -> Result<StateKey, StateKeyDecodeErr> {
        use access_path::Path;

        if val.is_empty() {
            return Err(StateKeyDecodeErr::EmptyInput);
        }
        let tag = val[0];
        let state_key_tag =
            StateKeyTag::from_u8(tag).ok_or(StateKeyDecodeErr::UnknownTag { unknown_tag: tag })?;
        let myself = match state_key_tag {
            StateKeyTag::AccessPath => {
                let AccessPath { address, path } = bcs::from_bytes(&val[1..])?;
                let path: Path = bcs::from_bytes(&path)?;
                match path {
                    Path::Code(ModuleId { address, name }) => Self::module(&address, &name),
                    Path::Resource(struct_tag) => Self::resource(&address, &struct_tag)?,
                    Path::ResourceGroup(struct_tag) => Self::resource_group(&address, &struct_tag),
                }
            },
            StateKeyTag::TableItem => {
                const HANDLE_SIZE: usize = std::mem::size_of::<TableHandle>();
                if val.len() < 1 + HANDLE_SIZE {
                    return Err(StateKeyDecodeErr::NotEnoughBytes {
                        tag,
                        num_bytes: val.len(),
                    });
                }
                let handle = bcs::from_bytes(&val[1..1 + HANDLE_SIZE])?;
                Self::table_item(&handle, &val[1 + HANDLE_SIZE..])
            },
            StateKeyTag::Raw => Self::raw(&val[1..]),
        };
        Ok(myself)
    }
```

**File:** types/src/access_path.rs (L54-59)
```rust
#[derive(Clone, Eq, PartialEq, Hash, Serialize, Deserialize, Ord, PartialOrd)]
pub struct AccessPath {
    pub address: AccountAddress,
    #[serde(with = "serde_bytes")]
    pub path: Vec<u8>,
}
```

**File:** storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs (L253-266)
```rust
    async fn read_state_value(
        storage: &Arc<dyn BackupStorage>,
        file_handle: FileHandle,
    ) -> Result<Vec<(StateKey, StateValue)>> {
        let mut file = storage.open_for_read(&file_handle).await?;

        let mut chunk = vec![];

        while let Some(record_bytes) = file.read_record_bytes().await? {
            chunk.push(bcs::from_bytes(&record_bytes)?);
        }

        Ok(chunk)
    }
```

**File:** storage/indexer_schemas/src/schema/state_keys/mod.rs (L14-23)
```rust
impl KeyCodec<StateKeysSchema> for StateKey {
    fn encode_key(&self) -> Result<Vec<u8>> {
        Ok(self.encoded().to_vec())
    }

    fn decode_key(data: &[u8]) -> Result<Self> {
        let state_key: StateKey = StateKey::decode(data)?;
        Ok(state_key)
    }
}
```

**File:** aptos-move/aptos-vm/src/verifier/transaction_arg_validation.rs (L557-563)
```rust
    const MAX_NUM_BYTES: usize = 1_000_000;
    if len.checked_add(n).is_none_or(|s| s > MAX_NUM_BYTES) {
        return Err(deserialization_error(&format!(
            "Couldn't read bytes: maximum limit of {} bytes exceeded",
            MAX_NUM_BYTES
        )));
    }
```

**File:** api/src/transactions.rs (L851-851)
```rust
    const MAX_SIGNED_TRANSACTION_DEPTH: usize = 16;
```
