# Audit Report

## Title
Integer Overflow Vulnerabilities in Epoch Ending Backup Manifest Verification Allow Corrupted Manifests to Pass Validation

## Summary
The epoch ending backup manifest verification logic contains multiple integer overflow vulnerabilities that allow maliciously crafted manifests with invalid epoch ranges (including first_epoch > last_epoch or absurdly large ranges) to bypass all validation checks. This can cause validator node crashes during restore operations and potential state corruption.

## Finding Description

The `EpochEndingBackup::verify()` function performs validation checks on backup manifests to ensure epoch ranges are valid and consistent. However, it uses unchecked arithmetic operations that can overflow, allowing invalid manifests to pass validation. [1](#0-0) 

**Vulnerability 1: Waypoint Count Validation Overflow**

The validation checks that the number of waypoints matches the epoch range using: `self.last_epoch - self.first_epoch + 1 == self.waypoints.len() as u64`. If `last_epoch = u64::MAX` and `first_epoch = 0`, the calculation `u64::MAX - 0 + 1` overflows to `0` in release builds, requiring zero waypoints to pass the check.

**Vulnerability 2: Chunk Iteration Overflow** [2](#0-1) 

When iterating through chunks, `next_epoch = chunk.last_epoch + 1` can overflow if `chunk.last_epoch = u64::MAX`, wrapping to `0`. This breaks the continuity validation logic.

**Vulnerability 3: Final Epoch Validation Underflow** [3](#0-2) 

The final check `next_epoch - 1 == self.last_epoch` can underflow if `next_epoch = 0` (due to previous overflow), wrapping to `u64::MAX` and incorrectly matching a manifest with `last_epoch = u64::MAX`.

**Vulnerability 4: Chunk Item Count Validation Overflow** [4](#0-3) 

During restore, the validation `chunk.first_epoch + lis.len() as u64 == chunk.last_epoch + 1` can be bypassed when `chunk.last_epoch = u64::MAX` causes `chunk.last_epoch + 1` to overflow to `0`, matching an empty chunk with `first_epoch = 0`.

**Attack Scenario:**

An attacker with write access to backup storage creates a malicious manifest:
```
{
  "first_epoch": 0,
  "last_epoch": 18446744073709551615,  // u64::MAX
  "waypoints": [],
  "chunks": [{
    "first_epoch": 0,
    "last_epoch": 18446744073709551615,
    "ledger_infos": "<handle_to_empty_chunk_file>"
  }]
}
```

This manifest passes all validation checks due to integer overflows but represents an invalid state (claiming 2^64 epochs exist with zero waypoints). When the restore process attempts to use this manifest: [5](#0-4) 

The code calls `.expect("Epoch ending backup can't be empty.")` on an empty `ledger_infos` vector, causing a panic that crashes the restore process.

## Impact Explanation

**HIGH SEVERITY** per Aptos bug bounty criteria:

1. **Validator node crashes**: The panic in restore operations causes immediate node failure, fitting "Validator node slowdowns" and "API crashes" categories
2. **State inconsistencies requiring intervention**: Invalid manifests passing validation can lead to corrupted state that requires manual intervention to fix
3. **Denial of Service**: An attacker can repeatedly trigger restore failures by poisoning backup storage with malicious manifests

This does not reach Critical severity because:
- It requires write access to backup storage (not fully unprivileged)
- Does not directly compromise consensus or cause fund loss
- Network can recover by using different backup sources

However, in disaster recovery scenarios where backup restore is critical, this vulnerability could prevent network recovery, escalating the impact.

## Likelihood Explanation

**Likelihood: MEDIUM**

**Factors increasing likelihood:**
- Backup storage is often a shared resource (cloud storage, NFS) that may have weaker access controls than the blockchain nodes themselves
- Supply chain attacks could inject malicious manifests
- Compromised backup infrastructure could serve corrupted manifests
- The vulnerability is in production code, not test-only paths

**Factors decreasing likelihood:**
- Requires attacker to have write access to backup storage or ability to MITM backup operations
- Most operators secure backup storage with appropriate access controls
- The attack is detectable through monitoring of restore operations

The vulnerability is realistic and exploitable in environments where backup storage security is not properly hardened.

## Recommendation

Replace all unchecked arithmetic operations in the verification logic with checked arithmetic using `.checked_add()`, `.checked_sub()` methods, returning errors on overflow:

```rust
impl EpochEndingBackup {
    pub fn verify(&self) -> Result<()> {
        // check number of waypoints with overflow protection
        let expected_waypoints = self.last_epoch
            .checked_sub(self.first_epoch)
            .and_then(|v| v.checked_add(1))
            .ok_or_else(|| anyhow!("Integer overflow computing expected waypoints"))?;
        
        ensure!(
            self.first_epoch <= self.last_epoch
                && expected_waypoints == self.waypoints.len() as u64,
            "Malformed manifest. first epoch: {}, last epoch {}, num waypoints {}",
            self.first_epoch,
            self.last_epoch,
            self.waypoints.len(),
        );

        // check chunk ranges
        ensure!(!self.chunks.is_empty(), "No chunks.");
        let mut next_epoch = self.first_epoch;
        for chunk in &self.chunks {
            ensure!(
                chunk.first_epoch == next_epoch,
                "Chunk ranges not continuous. Expected first epoch: {}, actual: {}.",
                next_epoch,
                chunk.first_epoch,
            );
            ensure!(
                chunk.last_epoch >= chunk.first_epoch,
                "Chunk range invalid. [{}, {}]",
                chunk.first_epoch,
                chunk.last_epoch,
            );
            next_epoch = chunk.last_epoch
                .checked_add(1)
                .ok_or_else(|| anyhow!("Integer overflow in chunk iteration at epoch {}", chunk.last_epoch))?;
        }

        // check last epoch in chunk matches manifest
        let last_chunk_epoch = next_epoch
            .checked_sub(1)
            .ok_or_else(|| anyhow!("Integer underflow computing last chunk epoch"))?;
        ensure!(
            last_chunk_epoch == self.last_epoch,
            "Last epoch in chunks: {}, in manifest: {}",
            last_chunk_epoch,
            self.last_epoch,
        );

        Ok(())
    }
}
```

Similarly update the restore validation: [4](#0-3) 

```rust
let expected_items = chunk.last_epoch
    .checked_sub(chunk.first_epoch)
    .and_then(|v| v.checked_add(1))
    .ok_or_else(|| anyhow!("Integer overflow computing expected chunk items"))?;

ensure!(
    expected_items == lis.len() as u64,
    "Number of items in chunks doesn't match that in manifest. \
    first_epoch: {}, last_epoch: {}, items in chunk: {}, expected: {}",
    chunk.first_epoch,
    chunk.last_epoch,
    lis.len(),
    expected_items,
);
```

## Proof of Concept

```rust
#[test]
fn test_overflow_manifest_validation() {
    use crate::backup_types::epoch_ending::manifest::{EpochEndingBackup, EpochEndingChunk};
    use crate::storage::FileHandle;
    
    // Create malicious manifest with integer overflow exploit
    let malicious_manifest = EpochEndingBackup {
        first_epoch: 0,
        last_epoch: u64::MAX,
        waypoints: vec![], // Empty waypoints
        chunks: vec![EpochEndingChunk {
            first_epoch: 0,
            last_epoch: u64::MAX,
            ledger_infos: FileHandle::from("dummy_chunk.bin".to_string()),
        }],
    };
    
    // In release builds with unchecked arithmetic, this INCORRECTLY passes
    // due to integer overflow: u64::MAX - 0 + 1 = 0 (wraps around)
    let result = malicious_manifest.verify();
    
    // This should fail but currently passes in release builds
    assert!(result.is_err(), "Manifest with overflowing epoch range should fail validation");
    
    // Additional test: manifest claiming to span all possible epochs
    let another_malicious = EpochEndingBackup {
        first_epoch: 1,
        last_epoch: u64::MAX,
        waypoints: vec![], // Claims (u64::MAX - 1 + 1) = u64::MAX epochs, overflows to 0
        chunks: vec![EpochEndingChunk {
            first_epoch: 1,
            last_epoch: u64::MAX,
            ledger_infos: FileHandle::from("dummy_chunk2.bin".to_string()),
        }],
    };
    
    let result2 = another_malicious.verify();
    assert!(result2.is_err(), "Manifest with maximum epoch range should fail validation");
}
```

**Notes**

This vulnerability demonstrates a critical oversight in input validation where integer overflow in Rust's release mode (wrapping arithmetic) allows security checks to be bypassed. While the backup/restore functionality is not in the hot path of consensus, it is critical for disaster recovery scenarios. The vulnerability affects the **State Consistency** invariant by allowing manifests that claim to represent invalid blockchain state to pass validation, potentially leading to node crashes or data corruption during recovery operations.

The issue is particularly concerning because backup systems are often treated as trusted infrastructure, and this vulnerability shows that even "verified" manifests can be malicious. The fix is straightforward: use Rust's checked arithmetic operations throughout the validation logic to detect and reject overflowing calculations.

### Citations

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/manifest.rs (L31-38)
```rust
        ensure!(
            self.first_epoch <= self.last_epoch
                && self.last_epoch - self.first_epoch + 1 == self.waypoints.len() as u64,
            "Malformed manifest. first epoch: {}, last epoch {}, num waypoints {}",
            self.first_epoch,
            self.last_epoch,
            self.waypoints.len(),
        );
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/manifest.rs (L56-56)
```rust
            next_epoch = chunk.last_epoch + 1;
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/manifest.rs (L60-65)
```rust
        ensure!(
            next_epoch - 1 == self.last_epoch, // okay to -1 because chunks is not empty.
            "Last epoch in chunks: {}, in manifest: {}",
            next_epoch - 1,
            self.last_epoch,
        );
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L98-105)
```rust
            ensure!(
                chunk.first_epoch + lis.len() as u64 == chunk.last_epoch + 1,
                "Number of items in chunks doesn't match that in manifest. \
                first_epoch: {}, last_epoch: {}, items in chunk: {}",
                chunk.first_epoch,
                chunk.last_epoch,
                lis.len(),
            );
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L213-216)
```rust
        let first_li = preheat_data
            .ledger_infos
            .first()
            .expect("Epoch ending backup can't be empty.");
```
