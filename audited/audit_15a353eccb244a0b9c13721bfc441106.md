# Audit Report

## Title
Indexer Denial of Service via Malformed TransactionsFromNodeResponse with Missing Oneof Field

## Summary
Multiple critical indexer components will panic and crash when they receive a `TransactionsFromNodeResponse` message from a malicious fullnode where the `response` oneof field is unset (None). The affected components call `.unwrap()` or `.expect()` on the `response` field without first validating that it contains a value, causing immediate process termination.

## Finding Description

The `TransactionsFromNodeResponse` protobuf message is defined with a oneof field named `response` that should contain either `StreamStatus` or `TransactionsOutput`: [1](#0-0) 

When this message is deserialized by prost (the Rust protobuf library), the `response` field becomes an `Option<Response>` enum: [2](#0-1) 

According to the protobuf3 specification, oneof fields are optional. If neither variant is set in the wire format, the field deserializes to `None`. The serde deserialization implementation confirms this behavior: [3](#0-2) 

The `response__` variable is initialized to `None` and only set if "status" or "data" fields are encountered during deserialization.

**Attack Vector:**

A malicious fullnode can craft a `TransactionsFromNodeResponse` message with only the `chain_id` field set and the `response` field completely omitted. This message will successfully deserialize, but the `response` field will be `None`.

**Vulnerable Code Locations:**

1. **Cache Worker** - Line 189 calls `.unwrap()` without validation: [4](#0-3) 

2. **Cache Worker** - Line 293 calls `.expect()` during initialization: [5](#0-4) 

3. **File Store Backfiller** - Line 159 calls `.unwrap()` on init signal: [6](#0-5) 

4. **File Store Backfiller** - Line 276 calls `.unwrap()` in streaming loop: [7](#0-6) 

5. **Localnet Data Service** - Line 122 calls `.expect()`: [8](#0-7) 

6. **V2 File Store Backfiller** - Line 177 calls `.unwrap()`: [9](#0-8) 

**Exploitation Steps:**

1. Malicious actor operates a fullnode or intercepts gRPC traffic
2. Craft a `TransactionsFromNodeResponse` with `chain_id` set but `response` field omitted
3. Send the malformed message to any indexer component connecting via the `GetTransactionsFromNode` RPC
4. The indexer receives the message, deserializes it successfully (response = None)
5. Code calls `.unwrap()` or `.expect()` on `response`, triggering a panic
6. The indexer process crashes immediately
7. Repeat to cause persistent denial of service

**Regarding "Both Fields Set" Scenario:**

When both `status` and `data` fields are present in the protobuf wire format, the protobuf deserializer will take the **last one encountered** and store only that variant in the `Response` enum. This is standard protobuf3 behavior for oneof fields. The consuming code will only see one variant, so this scenario does NOT cause crashes.

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos bug bounty program criteria:

- **API crashes**: Multiple indexer gRPC APIs will crash when receiving malformed responses
- **Significant protocol violations**: The indexer infrastructure is critical for blockchain data availability and cannot function with crashed components
- **Service disruption**: Affects the cache worker (critical for indexer performance), file store backfiller (critical for historical data), and other indexer components

The cache worker is particularly critical as it maintains the Redis cache that serves indexer queries. When it crashes:
- Indexer queries will fail or have degraded performance
- Data indexing stops, causing gaps in blockchain data availability
- Applications relying on indexer data experience outages

This does not reach Critical severity because:
- It does not directly affect consensus or validator nodes
- It does not cause loss of funds or permanent state corruption
- It is recoverable by restarting the affected services

However, persistent exploitation can make indexer services effectively unavailable.

## Likelihood Explanation

**Likelihood: HIGH**

This vulnerability is highly likely to be exploited because:

1. **Trivial to exploit**: Creating a malformed protobuf message requires minimal effort - just omit the `response` field
2. **Low attacker requirements**: 
   - Any entity running a fullnode can send malicious responses
   - Network attackers who can intercept/modify gRPC traffic can inject malicious messages
   - No authentication or special privileges required
3. **Widespread vulnerability**: Six different critical indexer components are affected
4. **Immediate impact**: Single malformed message causes immediate crash
5. **Repeatable**: Attack can be automated to cause persistent denial of service

The attack is detectable (indexer crashes are logged), but the damage is done before detection, and automated exploitation can overwhelm manual mitigation efforts.

## Recommendation

**Immediate Fix**: Add validation to check that the `response` field is `Some` before calling `.unwrap()` or `.expect()`. Use proper error handling instead of panicking.

**Example fix for cache worker (worker.rs line 189)**:

```rust
// Before (vulnerable):
match response.response.unwrap() {
    Response::Status(status) => { /* ... */ },
    Response::Data(data) => { /* ... */ },
}

// After (fixed):
match response.response {
    Some(Response::Status(status)) => { /* ... */ },
    Some(Response::Data(data)) => { /* ... */ },
    None => {
        ERROR_COUNT.with_label_values(&["invalid_response_none"]).inc();
        return Err(anyhow::anyhow!(
            "Received TransactionsFromNodeResponse with no response field set"
        ));
    }
}
```

**Apply this pattern to all affected locations:**
- `ecosystem/indexer-grpc/indexer-grpc-cache-worker/src/worker.rs` lines 189, 293
- `ecosystem/indexer-grpc/indexer-grpc-file-store-backfiller/src/processor.rs` lines 159, 276
- `ecosystem/indexer-grpc/indexer-grpc-fullnode/src/localnet_data_service.rs` line 122
- `ecosystem/indexer-grpc/indexer-grpc-v2-file-store-backfiller/src/processor.rs` line 177

**Defense in Depth**: Consider adding server-side validation in the `FullnodeDataService` to ensure all outgoing `TransactionsFromNodeResponse` messages have the `response` field set before sending.

## Proof of Concept

```rust
// PoC demonstrating the vulnerability
// Save as: indexer_crash_poc.rs

use prost::Message;
use aptos_protos::internal::fullnode::v1::TransactionsFromNodeResponse;

fn main() {
    // Malicious fullnode creates a message with only chain_id set
    let malicious_message = TransactionsFromNodeResponse {
        chain_id: 1, // Valid chain ID
        response: None, // Oneof field intentionally omitted
    };
    
    // Encode to bytes (wire format)
    let bytes = malicious_message.encode_to_vec();
    
    println!("Malicious message bytes: {:?}", bytes);
    println!("Size: {} bytes", bytes.len());
    
    // Deserialize (simulating indexer receiving the message)
    let received = TransactionsFromNodeResponse::decode(&bytes[..])
        .expect("Deserialization succeeds");
    
    println!("Received message - chain_id: {}", received.chain_id);
    println!("Received message - response: {:?}", received.response);
    
    // Simulate indexer code that calls .unwrap()
    println!("\nSimulating indexer processing...");
    match received.response.unwrap() { // <-- THIS WILL PANIC
        _ => unreachable!(),
    }
}

// Expected output:
// Malicious message bytes: [24, 1]
// Size: 2 bytes
// Received message - chain_id: 1
// Received message - response: None
// 
// Simulating indexer processing...
// thread 'main' panicked at 'called `Option::unwrap()` on a `None` value'
```

**To test against live indexer:**
1. Set up a malicious fullnode that implements the `FullnodeData` gRPC service
2. In the `get_transactions_from_node` method, send a `TransactionsFromNodeResponse` with `response: None`
3. Configure an indexer component to connect to this malicious fullnode
4. Observe the indexer crash when it receives the malformed message

## Notes

This vulnerability demonstrates a common pattern where protobuf oneof fields are assumed to always be set when deserializing from trusted sources. However, in a distributed system with potentially malicious peers, all input must be validated before use. The protobuf3 specification explicitly allows oneof fields to be unset, making this a valid attack vector that must be defended against.

### Citations

**File:** protos/proto/aptos/internal/fullnode/v1/fullnode_data.proto (L47-54)
```text
message TransactionsFromNodeResponse {
  oneof response {
    StreamStatus status = 1;
    TransactionsOutput data = 2;
  }
  // Making sure that all the responses include a chain id
  uint32 chain_id = 3;
}
```

**File:** protos/rust/src/pb/aptos.internal.fullnode.v1.rs (L77-96)
```rust
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransactionsFromNodeResponse {
    /// Making sure that all the responses include a chain id
    #[prost(uint32, tag="3")]
    pub chain_id: u32,
    #[prost(oneof="transactions_from_node_response::Response", tags="1, 2")]
    pub response: ::core::option::Option<transactions_from_node_response::Response>,
}
/// Nested message and enum types in `TransactionsFromNodeResponse`.
pub mod transactions_from_node_response {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Response {
        #[prost(message, tag="1")]
        Status(super::StreamStatus),
        #[prost(message, tag="2")]
        Data(super::TransactionsOutput),
    }
}
```

**File:** protos/rust/src/pb/aptos.internal.fullnode.v1.serde.rs (L610-613)
```rust
                Ok(TransactionsFromNodeResponse {
                    chain_id: chain_id__.unwrap_or_default(),
                    response: response__,
                })
```

**File:** ecosystem/indexer-grpc/indexer-grpc-cache-worker/src/worker.rs (L183-209)
```rust
async fn process_transactions_from_node_response(
    response: TransactionsFromNodeResponse,
    cache_operator: &mut CacheOperator<redis::aio::ConnectionManager>,
    download_start_time: std::time::Instant,
) -> Result<GrpcDataStatus> {
    let size_in_bytes = response.encoded_len();
    match response.response.unwrap() {
        Response::Status(status) => {
            match StatusType::try_from(status.r#type).expect("[Indexer Cache] Invalid status type.")
            {
                StatusType::Init => Ok(GrpcDataStatus::StreamInit(status.start_version)),
                StatusType::BatchEnd => {
                    let start_version = status.start_version;
                    let num_of_transactions = status
                        .end_version
                        .expect("TransactionsFromNodeResponse status end_version is None")
                        - start_version
                        + 1;
                    Ok(GrpcDataStatus::BatchEnd {
                        start_version,
                        num_of_transactions,
                    })
                },
                StatusType::Unspecified => unreachable!("Unspecified status type."),
            }
        },
        Response::Data(data) => {
```

**File:** ecosystem/indexer-grpc/indexer-grpc-cache-worker/src/worker.rs (L286-308)
```rust
async fn verify_fullnode_init_signal(
    cache_operator: &mut CacheOperator<redis::aio::ConnectionManager>,
    init_signal: TransactionsFromNodeResponse,
    file_store_metadata: FileStoreMetadata,
) -> Result<(ChainID, StartingVersion)> {
    let (fullnode_chain_id, starting_version) = match init_signal
        .response
        .expect("[Indexer Cache] Response type does not exist.")
    {
        Response::Status(status_frame) => {
            match StatusType::try_from(status_frame.r#type)
                .expect("[Indexer Cache] Invalid status type.")
            {
                StatusType::Init => (init_signal.chain_id, status_frame.start_version),
                _ => {
                    bail!("[Indexer Cache] Streaming error: first frame is not INIT signal.");
                },
            }
        },
        _ => {
            bail!("[Indexer Cache] Streaming error: first frame is not siganl frame.");
        },
    };
```

**File:** ecosystem/indexer-grpc/indexer-grpc-file-store-backfiller/src/processor.rs (L154-169)
```rust
        let init_frame = grpc_stream
            .next()
            .await
            .expect("Failed to get the first frame")?
            .response
            .unwrap();
        match init_frame {
            Response::Status(signal) => {
                if signal.r#type() != StatusType::Init {
                    anyhow::bail!("Unexpected status signal type");
                }
            },
            _ => {
                anyhow::bail!("Unexpected response type");
            },
        }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-file-store-backfiller/src/processor.rs (L265-302)
```rust
        loop {
            let item = grpc_stream.next().await;
            let item = item.unwrap();
            let response = match item {
                Ok(response) => response,
                Err(e) => {
                    tracing::error!("Failed to get response: {:?}", e);
                    panic!("Failed to get response: {:?}", e);
                },
            };

            let resp = response.response.unwrap();
            match resp {
                Response::Data(txns) => {
                    let transactions = txns.transactions;
                    for txn in transactions {
                        let version = txn.version;
                        // Partial batch may be received; split and insert into buffer.
                        transactions_buffer.insert(version, txn);
                    }
                },
                Response::Status(signal) => {
                    if signal.r#type() != StatusType::BatchEnd {
                        anyhow::bail!("Unexpected status signal type");
                    }
                    while transactions_buffer.len() >= 1000 {
                        // Take the first 1000 transactions.
                        let mut transactions = Vec::new();
                        // Pop the first 1000 transactions from buffer.
                        for _ in 0..1000 {
                            let (_, txn) = transactions_buffer.pop_first().unwrap();
                            transactions.push(txn);
                        }
                        sender.send(transactions).await?;
                    }
                },
            }
        }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/localnet_data_service.rs (L120-135)
```rust
                let response = response.map(|t| TransactionsResponse {
                    chain_id: Some(ledger_chain_id as u64),
                    transactions: match t.response.expect("Response must be set") {
                        transactions_from_node_response::Response::Data(transaction_output) => {
                            let mut transactions = transaction_output.transactions;
                            let current_transactions_count = transactions.len() as u64;
                            if let Some(count) = response_transactions_count.as_mut() {
                                transactions =
                                    transactions.into_iter().take(*count as usize).collect();
                                *count = count.saturating_sub(current_transactions_count);
                            }
                            transactions
                        },
                        _ => panic!("Unexpected response type."),
                    },
                    processed_range: None,
```

**File:** ecosystem/indexer-grpc/indexer-grpc-v2-file-store-backfiller/src/processor.rs (L173-185)
```rust
                        while let Some(response_item) = stream.next().await {
                            match response_item {
                                Ok(r) => {
                                    assert!(r.chain_id == chain_id);
                                    match r.response.unwrap() {
                                        Response::Data(data) => {
                                            let transactions = data.transactions;
                                            for transaction in transactions {
                                                file_store_operator
                                                    .buffer_and_maybe_dump_transactions_to_file(
                                                        transaction,
                                                        tx.clone(),
                                                    )
```
