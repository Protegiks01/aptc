# Audit Report

## Title
State Snapshot Version Mismatch Attack - Missing Validation Allows Restoring State from Version Y at Version X

## Summary
The `StateSnapshotRestoreController::run_impl()` function verifies the cryptographic proof for `manifest.version` but restores the state at `self.version` without validating these two values match. This allows an attacker to restore state from version Y while claiming it belongs to version X, breaking state consistency invariants and potentially causing consensus divergence.

## Finding Description

The vulnerability exists in the state snapshot restore logic where two separate version values are used without cross-validation: [1](#0-0) 

The `version` field (line 54) comes from the command-line argument `--state-into-version`, while the manifest is loaded from external storage: [2](#0-1) 

Line 127 verifies the proof using `manifest.version`, confirming that at transaction accumulator position `manifest.version`, the state root hash matches `manifest.root_hash`. However, line 142 creates the restore receiver using `self.version`: [3](#0-2) 

The `TransactionInfo` structure does not contain a version field, only cryptographic hashes: [4](#0-3) 

The verification function only checks that the transaction version is not newer than the ledger info and that the accumulator proof is valid: [5](#0-4) 

This means the proof verification confirms "at position `manifest.version`, this state root exists" but does NOT verify "this state root belongs to version `self.version`".

**Attack Path:**

1. Attacker obtains or creates a legitimate state snapshot at version 500 with root hash H_500
2. Attacker crafts a manifest file with `version: 500`, `root_hash: H_500`, and valid proof
3. Victim runs restore command: `--state-into-version 1000 --state-manifest attacker_manifest.json`
4. Line 127 verification passes (proof is valid for version 500)
5. Line 142 restores state at version 1000 with root hash H_500
6. Database now incorrectly believes state at version 1000 has root hash H_500 (which is actually from version 500)

The state is written to the database with the wrong version metadata: [6](#0-5) 

## Impact Explanation

This vulnerability constitutes **Critical Severity** under the Aptos Bug Bounty program because it enables:

1. **Consensus Safety Violations**: Different nodes restoring from tampered manifests will have divergent state roots at identical versions, breaking the fundamental consensus invariant that all validators must produce identical state for identical blocks.

2. **State Consistency Breach**: The database will store state from version Y at position X, violating the critical invariant: "State transitions must be atomic and verifiable via Merkle proofs." Any subsequent transaction execution at or after version X will use incorrect state.

3. **Deterministic Execution Failure**: If nodes have different state roots at version X, they will produce different execution results for the same transactions, breaking the deterministic execution invariant.

This directly maps to the Critical impact category "Consensus/Safety violations" worth up to $1,000,000 in the bug bounty program.

## Likelihood Explanation

The likelihood is **Medium** because exploitation requires specific conditions:

**Required for exploitation:**
- Attacker must control or compromise backup storage, OR
- Victim must use an untrusted/unverified manifest file, OR  
- Configuration error where operator specifies wrong version

**Factors increasing likelihood:**
- The `StateSnapshotRestoreController` is a public API that can be invoked directly
- No validation exists to catch this error
- Error messages don't warn users about version mismatches
- The normal `RestoreCoordinator` always passes matching versions, hiding this bug in typical usage

**Factors decreasing likelihood:**
- Requires attacker to have some level of access to backup infrastructure or social engineering
- Most restores go through the `RestoreCoordinator` which correctly matches versions

## Recommendation

Add explicit validation that `manifest.version` equals `self.version` in the `run_impl()` function immediately after loading the manifest:

```rust
let manifest: StateSnapshotBackup =
    self.storage.load_json_file(&self.manifest_handle).await?;

// Add this validation:
ensure!(
    manifest.version == self.version,
    "Manifest version {} does not match requested restore version {}. \
     This could indicate manifest tampering or configuration error.",
    manifest.version,
    self.version,
);

let (txn_info_with_proof, li): (TransactionInfoWithProof, LedgerInfoWithSignatures) =
    self.storage.load_bcs_file(&manifest.proof).await?;
```

This should be added between lines 124 and 125 in the file.

Additionally, add documentation warnings to the `StateSnapshotRestoreOpt` struct explaining that the version parameter must match the manifest version.

## Proof of Concept

```rust
// Proof of Concept demonstrating the vulnerability
// This would be added to storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs tests

#[cfg(test)]
mod security_tests {
    use super::*;
    
    #[tokio::test]
    async fn test_version_mismatch_vulnerability() {
        // Setup: Create a mock storage with a manifest claiming version 500
        let storage = create_mock_storage();
        let manifest_version = 500u64;
        let requested_version = 1000u64;  // Attacker wants to restore at different version
        
        // Create manifest with version 500 but valid proof for version 500
        let manifest = StateSnapshotBackup {
            version: manifest_version,  // Claims version 500
            epoch: 1,
            root_hash: HashValue::random(),
            chunks: vec![],
            proof: create_valid_proof_for_version(manifest_version), // Valid proof for 500
        };
        
        storage.save_json_file("manifest.json", &manifest).await.unwrap();
        
        // Create controller with MISMATCHED versions
        let opt = StateSnapshotRestoreOpt {
            manifest_handle: FileHandle::new("manifest.json"),
            version: requested_version,  // Requesting version 1000
            validate_modules: false,
            restore_mode: StateSnapshotRestoreMode::Default,
        };
        
        let controller = StateSnapshotRestoreController::new(
            opt,
            create_global_opts(requested_version),
            storage,
            None,
        );
        
        // BUG: This should fail but currently succeeds
        // The proof validates for version 500, but state gets restored at version 1000
        let result = controller.run().await;
        
        assert!(result.is_ok(), "Version mismatch not detected!");
        
        // Verify the database now has WRONG state at version 1000
        // (state that was proven for version 500 is now stored at version 1000)
        verify_state_version_mismatch();
    }
}
```

## Notes

While the `RestoreCoordinator` correctly matches versions when calling the controller, the vulnerability exists in the lower-level `StateSnapshotRestoreController` API which performs no validation. This creates a security boundary violation where a critical safety check is missing at the API layer that directly interacts with external data (backup storage).

The manifest file is deserialized from JSON loaded from potentially untrusted backup storage, making it attacker-controlled input. The lack of validation between `manifest.version` and `self.version` allows this untrusted input to cause state inconsistency in the database.

### Citations

**File:** storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs (L49-59)
```rust
#[derive(Parser)]
pub struct StateSnapshotRestoreOpt {
    #[clap(long = "state-manifest")]
    pub manifest_handle: FileHandle,
    #[clap(long = "state-into-version")]
    pub version: Version,
    #[clap(long)]
    pub validate_modules: bool,
    #[clap(long)]
    pub restore_mode: StateSnapshotRestoreMode,
}
```

**File:** storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs (L123-127)
```rust
        let manifest: StateSnapshotBackup =
            self.storage.load_json_file(&self.manifest_handle).await?;
        let (txn_info_with_proof, li): (TransactionInfoWithProof, LedgerInfoWithSignatures) =
            self.storage.load_bcs_file(&manifest.proof).await?;
        txn_info_with_proof.verify(li.ledger_info(), manifest.version)?;
```

**File:** storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs (L141-145)
```rust
        let receiver = Arc::new(Mutex::new(Some(self.run_mode.get_state_restore_receiver(
            self.version,
            manifest.root_hash,
            self.restore_mode,
        )?)));
```

**File:** types/src/transaction/mod.rs (L2023-2051)
```rust
#[derive(Clone, CryptoHasher, BCSCryptoHash, Debug, Eq, PartialEq, Serialize, Deserialize)]
#[cfg_attr(any(test, feature = "fuzzing"), derive(Arbitrary))]
pub struct TransactionInfoV0 {
    /// The amount of gas used.
    gas_used: u64,

    /// The vm status. If it is not `Executed`, this will provide the general error class. Execution
    /// failures and Move abort's receive more detailed information. But other errors are generally
    /// categorized with no status code or other information
    status: ExecutionStatus,

    /// The hash of this transaction.
    transaction_hash: HashValue,

    /// The root hash of Merkle Accumulator storing all events emitted during this transaction.
    event_root_hash: HashValue,

    /// The hash value summarizing all changes caused to the world state by this transaction.
    /// i.e. hash of the output write set.
    state_change_hash: HashValue,

    /// The root hash of the Sparse Merkle Tree describing the world state at the end of this
    /// transaction. Depending on the protocol configuration, this can be generated periodical
    /// only, like per block.
    state_checkpoint_hash: Option<HashValue>,

    /// The hash value summarizing PersistedAuxiliaryInfo.
    auxiliary_info_hash: Option<HashValue>,
}
```

**File:** types/src/proof/mod.rs (L39-61)
```rust
/// Verifies that a given `transaction_info` exists in the ledger using provided proof.
fn verify_transaction_info(
    ledger_info: &LedgerInfo,
    transaction_version: Version,
    transaction_info: &TransactionInfo,
    ledger_info_to_transaction_info_proof: &TransactionAccumulatorProof,
) -> Result<()> {
    ensure!(
        transaction_version <= ledger_info.version(),
        "Transaction version {} is newer than LedgerInfo version {}.",
        transaction_version,
        ledger_info.version(),
    );

    let transaction_info_hash = transaction_info.hash();
    ledger_info_to_transaction_info_proof.verify(
        ledger_info.transaction_accumulator_hash(),
        transaction_info_hash,
        transaction_version,
    )?;

    Ok(())
}
```

**File:** storage/aptosdb/src/state_store/mod.rs (L1281-1315)
```rust
    fn kv_finish(&self, version: Version, usage: StateStorageUsage) -> Result<()> {
        self.ledger_db.metadata_db().put_usage(version, usage)?;
        if let Some(internal_indexer_db) = self.internal_indexer_db.as_ref() {
            if version > 0 {
                let mut batch = SchemaBatch::new();
                batch.put::<InternalIndexerMetadataSchema>(
                    &MetadataKey::LatestVersion,
                    &MetadataValue::Version(version - 1),
                )?;
                if internal_indexer_db.statekeys_enabled() {
                    batch.put::<InternalIndexerMetadataSchema>(
                        &MetadataKey::StateVersion,
                        &MetadataValue::Version(version - 1),
                    )?;
                }
                if internal_indexer_db.transaction_enabled() {
                    batch.put::<InternalIndexerMetadataSchema>(
                        &MetadataKey::TransactionVersion,
                        &MetadataValue::Version(version - 1),
                    )?;
                }
                if internal_indexer_db.event_enabled() {
                    batch.put::<InternalIndexerMetadataSchema>(
                        &MetadataKey::EventVersion,
                        &MetadataValue::Version(version - 1),
                    )?;
                }
                internal_indexer_db
                    .get_inner_db_ref()
                    .write_schemas(batch)?;
            }
        }

        Ok(())
    }
```
