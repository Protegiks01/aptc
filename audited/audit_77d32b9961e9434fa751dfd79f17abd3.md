# Audit Report

## Title
Missing SHA256 Checksum Verification in Aptos CLI Self-Update Mechanism Enables Supply Chain Attacks

## Summary
The Aptos CLI self-update mechanism downloads and installs binary updates from GitHub releases without generating or verifying SHA256 checksums, creating a supply chain attack vector where compromised binaries could be installed on validator nodes and developer machines without detection.

## Finding Description

The `build_updater()` function in the Aptos CLI update mechanism fails to implement cryptographic verification of downloaded binaries, violating supply chain security best practices. [1](#0-0) 

The updater configuration uses the `self_update` crate but does not configure any checksum verification mechanism. The `Update::configure()` builder is called without the `.identifier()` method that would enable hash verification.

Additionally, the release build process does not generate SHA256 checksums: [2](#0-1) 

The build script only creates ZIP files without generating accompanying checksum files. The GitHub Actions workflow then publishes these assets without checksums: [3](#0-2) 

The update flow executes the downloaded binary without verification: [4](#0-3) 

**Attack Scenario:**
1. Attacker compromises GitHub release infrastructure or maintainer credentials
2. Attacker uploads malicious binary to official Aptos CLI release
3. Users (including validator operators) run `aptos update`
4. Malicious binary is downloaded and installed without verification
5. Attacker gains arbitrary code execution with user/validator privileges

This breaks the **Cryptographic Correctness** invariant requiring secure operations and enables potential **Remote Code Execution on validator nodes**.

## Impact Explanation

**Critical Severity** - This vulnerability enables Remote Code Execution on validator nodes, which qualifies for Critical severity under Aptos bug bounty criteria. 

If a validator operator runs `aptos update` and downloads a compromised binary, the attacker gains:
- Complete control over the validator node
- Access to validator private keys
- Ability to manipulate consensus (vote maliciously, cause safety violations)
- Access to staked funds
- Ability to corrupt the blockchain state

The impact extends beyond validators to:
- Developer machines with access to private keys and production systems
- Build/CI systems that may use `aptos update`
- Any system where the CLI is installed via the self-update mechanism

## Likelihood Explanation

**Moderate Likelihood** - While this requires compromise of GitHub release infrastructure or maintainer credentials, such attacks are increasingly common:

- Supply chain attacks have successfully targeted package repositories (SolarWinds, npm, PyPI)
- GitHub account compromises occur regularly via phishing or credential theft
- No technical barrier prevents a compromised maintainer from uploading malicious releases
- The attack is completely silent - users have no way to detect compromised binaries
- Wide deployment of the Aptos CLI makes this a high-value target

The lack of checksum verification means the attack requires zero technical sophistication once initial access is obtained.

## Recommendation

Implement comprehensive checksum verification:

**1. Generate SHA256 checksums during build:**
```bash
# In scripts/cli/build_cli_release.sh after line 66:
echo "Generating SHA256 checksum..."
sha256sum "$ZIP_NAME" > "$ZIP_NAME.sha256"
mv "$ZIP_NAME.sha256" ../..
```

**2. Publish checksums with releases:** [5](#0-4) 

Modify to include:
```yaml
files: |
  aptos-cli-*.zip
  aptos-cli-*.zip.sha256
```

**3. Verify checksums before installation:**

Configure the updater to verify checksums:
```rust
// In build_updater(), add checksum configuration
.identifier("sha256") // Specify hash algorithm
// The self_update crate will automatically look for .sha256 files
```

**4. Additional hardening:**
- Sign releases with GPG keys
- Implement reproducible builds for verification
- Document checksum verification in security documentation
- Add checksum verification to homebrew formula
- Warn users if verification fails

## Proof of Concept

**Demonstrating the vulnerability:**

1. Create a test release with modified binary:
```bash
# Clone repo and build
cargo build -p aptos --profile cli

# Create malicious binary (proof of concept - just adds marker)
echo "COMPROMISED" >> target/cli/aptos

# Package it
cd target/cli/
zip malicious-aptos.zip aptos

# Upload to GitHub release (requires maintainer access)
# Users running `aptos update` will download and execute this without warning
```

2. Verify no checksum validation occurs:
```bash
# Run update with network interception
aptos update --repo-owner=<attacker-org>

# Binary is downloaded and executed without verification
# No SHA256 check occurs
# No signature verification occurs
# User has no way to detect compromise
```

**Testing the fix:**

After implementing checksums:
```bash
# Generate checksum
sha256sum aptos-cli-*.zip > aptos-cli-*.zip.sha256

# Modify binary
echo "tampered" >> aptos-cli-*.zip

# Update fails with checksum mismatch
aptos update
# Expected: "Error: Checksum verification failed"
```

The current implementation provides zero protection against this attack vector, making it a critical supply chain vulnerability requiring immediate remediation.

## Notes

This vulnerability exists in all CLI updater implementations across the codebase: [6](#0-5) [7](#0-6) [8](#0-7) 

All external binary downloads share this vulnerability. The Homebrew distribution does include checksums, but only for Homebrew-specific installation, not for direct binary updates: [9](#0-8)

### Citations

**File:** crates/aptos/src/update/aptos.rs (L96-149)
```rust
    fn build_updater(&self, info: &UpdateRequiredInfo) -> Result<Box<dyn ReleaseUpdate>> {
        let installation_method =
            InstallationMethod::from_env().context("Failed to determine installation method")?;
        match installation_method {
            InstallationMethod::Source => {
                return Err(anyhow!(
                    "Detected this CLI was built from source, refusing to update"
                ));
            },
            InstallationMethod::Homebrew => {
                return Err(anyhow!(
                    "Detected this CLI comes from homebrew, use `brew upgrade aptos` instead"
                ));
            },
            InstallationMethod::PackageManager => {
                return Err(anyhow!(
                    "Detected this CLI comes from a package manager, use your package manager to update instead"
                ));
            },
            InstallationMethod::Other => {},
        }

        // Determine the target we should download. This is necessary because we don't
        // name our binary releases using the target triples nor do we build specifically
        // for all major triples, so we have to generalize to one of the binaries we do
        // happen to build. We figure this out based on what system the CLI was built on.
        let build_info = cli_build_information();
        let target = match build_info.get(BUILD_OS).context("Failed to determine build info of current CLI")?.as_str() {
            "linux-x86_64" => "Linux-x86_64",
            "linux-aarch64" => "Linux-aarch64",
            "macos-x86_64" => "macOS-x86_64",
            "macos-aarch64" => "macOS-arm64",
            "windows-x86_64" => "Windows-x86_64",
            wildcard => return Err(anyhow!("Self-updating is not supported on your OS ({}) right now, please download the binary manually", wildcard)),
        };

        let current_version = match &info.current_version {
            Some(version) => version,
            None => unreachable!("current_version should always be Some at this point"),
        };

        // Build a new configuration that will direct the library to download the
        // binary with the target version tag and target that we determined above.
        Update::configure()
            .repo_owner(&self.repo_owner)
            .repo_name(&self.repo_name)
            .bin_name("aptos")
            .current_version(current_version)
            .target_version_tag(&format!("aptos-cli-v{}", info.target_version))
            .target(target)
            .no_confirm(self.prompt_options.assume_yes)
            .build()
            .map_err(|e| anyhow!("Failed to build self-update configuration: {:#}", e))
    }
```

**File:** scripts/cli/build_cli_release.sh (L62-67)
```shellscript
# Compress the CLI
ZIP_NAME="$NAME-$VERSION-$PLATFORM_NAME-$ARCH.zip"

echo "Zipping release: $ZIP_NAME"
zip "$ZIP_NAME" "$CRATE_NAME"
mv "$ZIP_NAME" ../..
```

**File:** .github/workflows/cli-release.yaml (L172-180)
```yaml
      - name: Create GitHub Release
        uses: marvinpinto/action-automatic-releases@919008cf3f741b179569b7a6fb4d8860689ab7f0 # pin@v1.2.1
        with:
          repo_token: "${{ secrets.GITHUB_TOKEN }}"
          automatic_release_tag: "${{ format('aptos-cli-v{0}', inputs.release_version) }}"
          prerelease: false
          title: "${{ format('Aptos CLI Release v{0}', inputs.release_version) }}"
          files: |
            aptos-cli-*.zip
```

**File:** crates/aptos/src/update/mod.rs (L50-56)
```rust
        // Build the updater.
        let updater = self.build_updater(&info)?;

        // Update the binary.
        let result = updater
            .update()
            .map_err(|e| anyhow!("Failed to update {}: {:#}", self.pretty_name(), e))?;
```

**File:** crates/aptos/src/update/revela.rs (L95-107)
```rust
    fn build_updater(&self, info: &UpdateRequiredInfo) -> Result<Box<dyn ReleaseUpdate>> {
        build_updater(
            info,
            self.install_dir.clone(),
            self.repo_owner.clone(),
            self.repo_name.clone(),
            REVELA_BINARY_NAME,
            "unknown-linux-gnu",
            "apple-darwin",
            "pc-windows-gnu",
            self.prompt_options.assume_yes,
        )
    }
```

**File:** crates/aptos/src/update/movefmt.rs (L102-114)
```rust
    fn build_updater(&self, info: &UpdateRequiredInfo) -> Result<Box<dyn ReleaseUpdate>> {
        build_updater(
            info,
            self.install_dir.clone(),
            self.repo_owner.clone(),
            self.repo_name.clone(),
            FORMATTER_BINARY_NAME,
            "unknown-linux-gnu",
            "apple-darwin",
            "windows",
            self.prompt_options.assume_yes,
        )
    }
```

**File:** crates/aptos/src/update/move_mutation_test.rs (L102-114)
```rust
    fn build_updater(&self, info: &UpdateRequiredInfo) -> Result<Box<dyn ReleaseUpdate>> {
        build_updater(
            info,
            self.install_dir.clone(),
            self.repo_owner.clone(),
            self.repo_name.clone(),
            MUTATION_TEST_BINARY_NAME,
            "unknown-linux-gnu",
            "apple-darwin",
            "windows",
            self.prompt_options.assume_yes,
        )
    }
```

**File:** crates/aptos/homebrew/README.md (L98-100)
```markdown
  url "https://github.com/aptos-labs/aptos-core/archive/refs/tags/aptos-cli-v1.0.3.tar.gz"
  sha256 "670bb6cb841cb8a65294878af9a4f03d4cba2a598ab4550061fed3a4b1fe4e98"
  license "Apache-2.0"
```
