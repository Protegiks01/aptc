# Audit Report

## Title
Indexer Crash Due to Missing Database Schema When `skip_migrations` is Enabled

## Summary
Setting `skip_migrations` to `true` in the indexer configuration causes the indexer to crash immediately on startup or during operation when it attempts to access the `processor_status` table that was never created by database migrations. This leads to service unavailability and potential data inconsistency.

## Finding Description

The `skip_migrations` configuration field controls whether database migrations are executed when the indexer starts. [1](#0-0) 

When `skip_migrations` is set to `true`, the indexer skips running migrations: [2](#0-1) 

The critical issue is that the indexer code relies on the `processor_status` table to track indexing progress using the `ProcessorStatusV2` model: [3](#0-2) 

This table is referenced in the schema: [4](#0-3) 

However, after exhaustive examination of all migration files in the repository, **no migration exists that creates the `processor_status` table**. Only the `processor_statuses` (plural) table is created: [5](#0-4) 

The indexer attempts to query this non-existent table during startup: [6](#0-5) 

If the query fails due to missing table, the code panics: [7](#0-6) 

Additionally, during processing, the indexer attempts to update this table: [8](#0-7) 

Update failures also cause panic: [9](#0-8) 

**Attack Scenario:**
1. Operator deploys indexer with fresh database
2. Sets `skip_migrations=true` in configuration (default is `false` but can be overridden)
3. Even if migrations run, the `processor_status` table is never created (missing migration)
4. Indexer starts and attempts to query `processor_status` table
5. PostgreSQL returns error: "relation processor_status does not exist"
6. Indexer panics and crashes
7. Continuous restart loop prevents indexer from serving queries

## Impact Explanation

This qualifies as **High Severity** under the Aptos bug bounty criteria:

- **API crashes**: The indexer completely fails to start or crashes during operation, making the indexer API unavailable
- **Validator node slowdowns**: If validators rely on local indexer instances for monitoring or operational queries, this causes operational disruption
- **Significant protocol violations**: The indexer cannot track processing status, leading to potential data inconsistencies if the service is forcibly restarted

The impact affects:
- All indexer deployments that set `skip_migrations=true`
- Any deployment where the `processor_status` table migration is missing from the database
- Operators who cannot diagnose why the indexer crashes immediately on startup

## Likelihood Explanation

**High likelihood** for the following reasons:

1. **Configuration default**: While `skip_migrations` defaults to `false`, operators may enable it to speed up deployments or avoid migration overhead: [10](#0-9) 

2. **Missing migration**: The `processor_status` table appears to have no creation migration, meaning even with migrations enabled, the table may not exist in databases initialized from the migration files in this repository

3. **No validation**: The code has no defensive checks for table existence before attempting queries

4. **Inevitable crash**: The crash is guaranteed to occur on every startup attempt, making this a deterministic failure

## Recommendation

**Immediate fixes required:**

1. **Create migration for `processor_status` table**: Add a new migration file that creates the missing `processor_status` table with proper schema:
```sql
CREATE TABLE processor_status (
    processor VARCHAR(50) PRIMARY KEY NOT NULL,
    last_success_version BIGINT NOT NULL,
    last_updated TIMESTAMP NOT NULL DEFAULT NOW()
);
```

2. **Add graceful degradation**: Instead of panicking, implement fallback logic to use the `processor_statuses` table or create the table dynamically if missing

3. **Add validation**: On startup, verify that required tables exist before attempting queries, and provide clear error messages if they don't

4. **Document migration requirements**: Clearly document that `skip_migrations` should only be used when the database schema is already up-to-date and contains all required tables

5. **Prevent misconfiguration**: Add a warning log when `skip_migrations=true` is detected, alerting operators to potential risks

## Proof of Concept

**Reproduction Steps:**

1. Set up a fresh PostgreSQL database
2. Create indexer configuration file with:
```yaml
indexer:
  enabled: true
  skip_migrations: true
  postgres_uri: "postgresql://user:pass@localhost/testdb"
  processor: "default_processor"
```

3. Start the indexer node
4. Observe crash with error message similar to:
```
Failed to get starting version: Database(DatabaseError(Unknown, "relation \"processor_status\" does not exist"))
```

**Alternative PoC - Even with migrations enabled:**

1. Run all existing migrations from the repository
2. Verify `processor_statuses` table exists but `processor_status` does not
3. Start indexer
4. Observe the same crash due to missing table

**Notes:**
The vulnerability is exacerbated by the fact that the code explicitly tracks two different tables (`processor_status` and `processor_statuses`), with the V2 version marked as the current implementation but lacking the necessary migration to create it.

### Citations

**File:** config/src/config/indexer_config.rs (L52-54)
```rust
    /// If set, don't run any migrations
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub skip_migrations: Option<bool>,
```

**File:** config/src/config/indexer_config.rs (L174-174)
```rust
        indexer_config.skip_migrations = indexer_config.skip_migrations.or(Some(false));
```

**File:** crates/indexer/src/runtime.rs (L152-155)
```rust
    if !skip_migrations {
        info!(processor_name = processor_name, "Running migrations...");
        tailer.run_migrations();
    }
```

**File:** crates/indexer/src/runtime.rs (L163-172)
```rust
    let starting_version_from_db_short = tailer
        .get_start_version(&processor_name)
        .unwrap_or_else(|e| panic!("Failed to get starting version: {:?}", e))
        .unwrap_or_else(|| {
            info!(
                processor_name = processor_name,
                "No starting version from db so starting from version 0"
            );
            0
        }) as u64;
```

**File:** crates/indexer/src/runtime.rs (L251-261)
```rust
        tailer
            .update_last_processed_version(&processor_name, batch_end_version)
            .unwrap_or_else(|e| {
                error!(
                    processor_name = processor_name,
                    end_version = batch_end_version,
                    error = format!("{:?}", e),
                    "Failed to update last processed version!"
                );
                panic!("Failed to update last processed version: {:?}", e);
            });
```

**File:** crates/indexer/src/models/processor_status.rs (L7-13)
```rust
#[derive(AsChangeset, Debug, Insertable)]
#[diesel(table_name = processor_status)]
/// Only tracking the latest version successfully processed
pub struct ProcessorStatusV2 {
    pub processor: String,
    pub last_success_version: i64,
}
```

**File:** crates/indexer/src/schema.rs (L606-613)
```rust
diesel::table! {
    processor_status (processor) {
        #[max_length = 50]
        processor -> Varchar,
        last_success_version -> Int8,
        last_updated -> Timestamp,
    }
}
```

**File:** crates/indexer/migrations/2022-08-08-043603_core_tables/up.sql (L306-314)
```sql
CREATE TABLE processor_statuses (
  name VARCHAR(50) NOT NULL,
  version BIGINT NOT NULL,
  success BOOLEAN NOT NULL,
  details TEXT,
  last_updated TIMESTAMP NOT NULL DEFAULT NOW(),
  -- Constraints
  PRIMARY KEY (name, version)
);
```

**File:** crates/indexer/src/indexer/tailer.rs (L170-191)
```rust
    pub fn update_last_processed_version(&self, processor_name: &str, version: u64) -> Result<()> {
        let mut conn = self.connection_pool.get()?;

        let status = ProcessorStatusV2 {
            processor: processor_name.to_owned(),
            last_success_version: version as i64,
        };
        execute_with_better_error(
            &mut conn,
            diesel::insert_into(processor_status::table)
                .values(&status)
                .on_conflict(processor_status::processor)
                .do_update()
                .set((
                    processor_status::last_success_version
                        .eq(excluded(processor_status::last_success_version)),
                    processor_status::last_updated.eq(excluded(processor_status::last_updated)),
                )),
            Some(" WHERE processor_status.last_success_version <= EXCLUDED.last_success_version "),
        )?;
        Ok(())
    }
```
