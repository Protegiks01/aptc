# Audit Report

## Title
Missing Global Rate Limiting in Aptos Faucet Service Enables Resource Exhaustion DoS Attack

## Summary
The Aptos Faucet service lacks global rate limiting middleware at the service level, relying solely on endpoint-specific checkers that are not applied uniformly across all API components. The `/request_captcha` endpoint is completely unprotected, allowing unlimited captcha generation requests that can exhaust server resources and crash the API service.

## Finding Description

The `build_openapi_service()` function constructs the OpenAPI service by combining three API components (BasicApi, CaptchaApi, FundApi) without applying any global rate limiting middleware. [1](#0-0) 

The server initialization applies only CORS and logging middleware to the route, with no global rate limiting protection. [2](#0-1) 

Rate limiting is implemented only through individual checkers (MemoryRatelimitChecker, RedisRatelimitChecker) that are part of the `FundApiComponents` and only applied to funding-related endpoints (`/fund`, `/is_eligible`, `/mint`). [3](#0-2) 

The rate limiting checkers are invoked in the `preprocess_request()` function, but only for the FundApi endpoints. [4](#0-3) 

Critically, the CaptchaApi's `/request_captcha` endpoint has **no rate limiting whatsoever** - it doesn't use the FundApiComponents checkers system and has no semaphore protection. [5](#0-4) 

**Attack Scenario:**
1. Attacker sends unlimited HTTP GET requests to `/v1/request_captcha`
2. Each request triggers `captcha_manager.create_challenge()`, generating a new captcha image in memory
3. No rate limiting prevents this, allowing thousands of requests per second
4. Server memory and CPU resources are exhausted through captcha generation
5. Faucet API becomes unresponsive or crashes, denying service to legitimate users

## Impact Explanation

This qualifies as **High Severity** under the Aptos Bug Bounty program criteria for "API crashes." The vulnerability allows an unprivileged attacker to:

- **Exhaust server resources** through unlimited captcha image generation (CPU-intensive operation)
- **Cause API service unavailability** affecting all faucet users
- **Crash the faucet service** through memory exhaustion
- **Bypass intended rate limiting** by targeting unprotected endpoints

While this does not directly affect validator nodes or blockchain consensus (the faucet is a separate service), it qualifies under the High Severity category for causing API crashes and service disruption.

## Likelihood Explanation

**Likelihood: HIGH**

This vulnerability is trivial to exploit:
- No authentication required
- No special knowledge needed
- Simple HTTP GET requests to a public endpoint
- Attack can be executed with basic tools (curl, simple scripts)
- No rate limiting or throttling to prevent abuse
- Attacker complexity: MINIMAL

The attack requires only:
```bash
while true; do curl http://faucet-url/v1/request_captcha & done
```

## Recommendation

Implement global rate limiting middleware at the service level before the OpenAPI service handler. This can be achieved using Poem's middleware capabilities:

1. **Add a global rate limiting middleware** that applies to all endpoints regardless of which API component handles them
2. **Apply the concurrent_requests_semaphore check** to ALL endpoints, not just FundApi
3. **Add specific rate limiting to the captcha endpoint** using the existing checker infrastructure

Example fix for the CaptchaApi:

```rust
pub struct CaptchaApi {
    pub enabled: bool,
    pub captcha_manager: Arc<Mutex<CaptchaManager>>,
    pub concurrent_requests_semaphore: Option<Arc<Semaphore>>,  // Add semaphore
}

async fn request_captcha(&self) -> Result<Response<Binary<Vec<u8>>>, AptosTapErrorResponse> {
    // Add semaphore check
    if let Some(ref semaphore) = self.concurrent_requests_semaphore {
        if semaphore.available_permits() == 0 {
            return Err(AptosTapError::new(
                "Server overloaded, please try again later".to_string(),
                AptosTapErrorCode::ServerOverloaded,
            ).into());
        }
    }
    
    // Existing captcha logic...
}
```

Additionally, consider implementing a global Poem middleware for rate limiting that wraps the entire service.

## Proof of Concept

**Attack Script:**
```bash
#!/bin/bash
# Simple DoS attack on faucet captcha endpoint
FAUCET_URL="http://localhost:8081/v1"

# Spawn 1000 concurrent requests
for i in {1..1000}; do
    curl -X GET "$FAUCET_URL/request_captcha" &
done
wait

# Monitor server response time and memory usage
# Expected: API becomes slow/unresponsive, memory usage spikes
```

**Verification Steps:**
1. Start the Aptos faucet service with default configuration
2. Monitor server memory and CPU usage (baseline)
3. Execute the above script
4. Observe:
   - Memory consumption increases continuously
   - CPU usage spikes due to captcha generation
   - API response times degrade significantly
   - Eventually: service becomes unresponsive or crashes
5. Verify that `/fund` endpoint is protected but `/request_captcha` is not

**Expected Impact:**
- Without rate limiting: Successful DoS, API crashes
- With proper global rate limiting: Requests throttled, service remains stable

## Notes

This vulnerability stems from architectural decisions where rate limiting is implemented as an opt-in feature per API component rather than a mandatory service-level protection. The `concurrent_requests_semaphore` exists but is not uniformly applied across all API components, leaving critical gaps in the protection model.

### Citations

**File:** crates/aptos-faucet/core/src/endpoints/api.rs (L9-28)
```rust
pub fn build_openapi_service(
    basic_api: BasicApi,
    captcha_api: CaptchaApi,
    fund_api: FundApi,
) -> OpenApiService<(BasicApi, CaptchaApi, FundApi), ()> {
    let version = VERSION.to_string();
    let license =
        LicenseObject::new("Apache 2.0").url("https://www.apache.org/licenses/LICENSE-2.0.html");
    let contact = ContactObject::new()
        .name("Aptos Labs")
        .url("https://github.com/aptos-labs");

    let apis = (basic_api, captcha_api, fund_api);

    OpenApiService::new(apis, "Aptos Tap", version.trim())
        .server("/v1")
        .description("todo")
        .license(license)
        .contact(contact)
}
```

**File:** crates/aptos-faucet/core/src/server/run.rs (L207-220)
```rust
        let api_server_future = Server::new_with_acceptor(TcpAcceptor::from_tokio(listener)?).run(
            Route::new()
                .nest(
                    &self.server_config.api_path_base,
                    Route::new()
                        .nest("", api_service)
                        .catch_all_error(convert_error),
                )
                .at("/spec.json", spec_json)
                .at("/spec.yaml", spec_yaml)
                .at("/mint", poem::post(mint.data(fund_api_components)))
                .with(cors)
                .around(middleware_log),
        );
```

**File:** crates/aptos-faucet/core/src/endpoints/fund.rs (L170-187)
```rust
pub struct FundApiComponents {
    /// If any of the allowers say yes, the request is allowed unconditionally
    /// and we never write anything to storage.
    pub bypassers: Vec<Bypasser>,

    /// If any of the checkers say no, the request is rejected.
    pub checkers: Vec<Checker>,

    /// The component that funds accounts.
    pub funder: Arc<Funder>,

    /// See the comment in `RunConfig`.
    pub return_rejections_early: bool,

    /// This semaphore is used to ensure we only process a certain number of
    /// requests concurrently.
    pub concurrent_requests_semaphore: Option<Arc<Semaphore>>,
}
```

**File:** crates/aptos-faucet/core/src/endpoints/fund.rs (L261-278)
```rust
        // Ensure request passes checkers.
        let mut rejection_reasons = Vec::new();
        for checker in &self.checkers {
            rejection_reasons.extend(checker.check(checker_data.clone(), dry_run).await.map_err(
                |e| AptosTapError::new_with_error_code(e, AptosTapErrorCode::CheckerError),
            )?);
            if !rejection_reasons.is_empty() && self.return_rejections_early {
                break;
            }
        }

        if !rejection_reasons.is_empty() {
            return Err(AptosTapError::new(
                format!("Request rejected by {} checkers", rejection_reasons.len()),
                AptosTapErrorCode::Rejected,
            )
            .rejection_reasons(rejection_reasons));
        }
```

**File:** crates/aptos-faucet/core/src/endpoints/captcha.rs (L40-58)
```rust
    async fn request_captcha(&self) -> Result<Response<Binary<Vec<u8>>>, AptosTapErrorResponse> {
        if !self.enabled {
            return Err(AptosTapError::new(
                "The CaptchaChecker is not enabled".to_string(),
                AptosTapErrorCode::EndpointNotEnabled,
            )
            .into());
        }
        let mut captcha_manager = self.captcha_manager.lock().await;
        let (key, image) = match captcha_manager.create_challenge() {
            Ok((key, image)) => (key, image),
            Err(e) => {
                return Err(
                    AptosTapError::new_with_error_code(e, AptosTapErrorCode::CheckerError).into(),
                );
            },
        };
        Ok(Response::new(Binary(image)).header(CAPTCHA_KEY, key))
    }
```
