# Audit Report

## Title
Transaction Filter Bypass via On-Demand Batch Fetch Enables Cross-Validator Divergence and Emergency Protection Circumvention

## Summary
The `BatchCoordinator` applies transaction filters inconsistently across different code paths, allowing filters to be completely bypassed. Batches rejected via the gossip path due to filter rules are automatically accepted when fetched on-demand, defeating the emergency filtering mechanism and enabling cross-validator divergence during the propagation phase.

## Finding Description

The Aptos quorum store implements a transaction filtering mechanism intended for emergency scenarios where specific transactions need to be blocked network-wide. However, the filter is only enforced in one of two batch acquisition paths, creating a critical bypass vulnerability.

**The Two Paths:**

**Path 1 (Gossip):** When batches arrive via network propagation, the filter IS enforced: [1](#0-0) 

If any transaction in the batch fails the filter, ALL batches in that message are dropped without being persisted to the batch store.

**Path 2 (On-Demand Fetch):** When batches are fetched to validate proposals, the filter is NOT enforced: [2](#0-1) 

The fetched batch is directly persisted to the batch store without any filter validation, completely bypassing the emergency protection mechanism.

**Cross-Validator Divergence:**

Each validator loads its filter configuration from its local node config: [3](#0-2) 

This configuration is then passed to the `BatchCoordinator`: [4](#0-3) 

Since validators can have different filter configurations, the following scenario creates divergence:

1. **Configuration Divergence**: Validator A has `quorum_store_filter` enabled with rules denying transactions from address X. Validator B has the filter disabled.

2. **Batch Propagation**: A batch containing a transaction from address X is gossiped:
   - Validator A receives it → filter check rejects it → batch is NOT persisted
   - Validator B receives it → no filter or different rules → batch IS persisted

3. **Proposal Phase**: Validator B creates a block proposal including this batch

4. **Verification Divergence**: 
   - Validator A checks payload availability → batch missing → triggers on-demand fetch
   - On-demand fetch **bypasses filter** → batch is now accepted and persisted
   - The same batch that was explicitly rejected via gossip is now accepted via a different path

This creates two critical security violations:

**Violation 1 - Filter Bypass:** The emergency filtering mechanism designed to block malicious transactions can be completely circumvented by forcing validators to fetch batches on-demand rather than receiving them via gossip.

**Violation 2 - Non-Deterministic Behavior:** Whether a batch is accepted depends on the arrival path and timing, creating non-deterministic validator behavior that violates consensus safety assumptions.

## Impact Explanation

**High Severity** - This qualifies as a "Significant protocol violation" under the Aptos bug bounty program:

1. **Emergency Protection Failure:** The transaction filter is documented in tests as an emergency mechanism to block malicious transactions: [5](#0-4) 

When this protection is needed most (during an active attack requiring emergency filtering), it fails completely.

2. **Consensus Safety Impact:** Different validators applying different validation rules to the same batches breaks the fundamental consensus requirement that all validators must deterministically validate the same data. This violates **Critical Invariant #1: Deterministic Execution**.

3. **Liveness Degradation:** If network conditions prevent successful on-demand fetches, validators with strict filters may be unable to validate proposals, potentially preventing quorum and causing liveness failures.

4. **Attack Amplification:** An attacker who discovers a vulnerability that should be blocked by emergency filters can exploit the bypass to continue the attack even after filters are deployed.

## Likelihood Explanation

**Medium to High Likelihood:**

1. **Configuration Divergence is Natural:** Validators are independent operators who may:
   - Apply emergency filters at different times during an incident
   - Have different interpretations of which transactions to filter
   - Experience configuration synchronization delays

2. **Emergency Scenarios are Critical:** While filters may not be used in normal operation, their failure during emergency scenarios (when they're specifically deployed to stop an active attack) represents the worst possible timing.

3. **No Enforcement of Configuration Consistency:** The protocol does not enforce that all validators have identical filter configurations, making divergence inevitable in practice.

4. **Bypass is Automatic:** The bypass requires no attacker sophistication - it happens automatically whenever a proposal triggers on-demand batch fetching.

## Recommendation

**Fix Option 1 - Apply Filter to All Paths (Recommended):**

Modify `BatchReaderImpl::get_or_fetch_batch` to accept and apply the transaction filter configuration. The filter should be checked immediately after receiving the batch from peers and before persisting:

```rust
// In get_or_fetch_batch, after line 703:
let payload = requester
    .request_batch(
        batch_digest,
        batch_info.expiration(),
        responders,
        subscriber_rx,
    )
    .await?;

// ADD FILTER CHECK HERE before persist:
if transaction_filter_config.is_enabled() {
    let transaction_filter = transaction_filter_config.batch_transaction_filter();
    for transaction in &payload {
        if !transaction_filter.allows_transaction(
            *batch_info.batch_id(),
            batch_info.author(),
            batch_info.digest(),
            transaction,
        ) {
            return Err(ExecutorError::CouldNotGetData); // Reject filtered batch
        }
    }
}

batch_store.persist(vec![PersistedValue::new(
    batch_info.into(),
    Some(payload.clone()),
)]);
```

**Fix Option 2 - Remove Filter from Gossip Path:**

If filters are not intended for security-critical use, remove them entirely from `BatchCoordinator` to avoid misleading operators into believing they provide protection.

**Fix Option 3 - Enforce Global Filter Consistency:**

Make filter configurations part of on-chain consensus parameters that all validators must agree on, preventing configuration divergence.

## Proof of Concept

The existing test demonstrates the filter works on the gossip path: [6](#0-5) 

To demonstrate the bypass, extend this test:

```rust
#[tokio::test(flavor = "multi_thread")]
async fn test_filter_bypass_via_on_demand_fetch() {
    // Create two validators: A with filter enabled, B without
    let (validator_a_store, validator_a_filter) = create_validator_with_filter();
    let (validator_b_store, validator_b_filter) = create_validator_without_filter();
    
    // Create batch with filtered transaction
    let filtered_tx = create_transaction_from_filtered_sender();
    let batch = create_batch_with_transaction(filtered_tx);
    
    // Gossip to Validator A - should be rejected
    validator_a_coordinator.handle_batches_msg(batch.author(), vec![batch.clone()]).await;
    assert!(validator_a_store.get_batch_from_local(batch.digest()).is_err()); // NOT stored
    
    // Gossip to Validator B - should be accepted
    validator_b_coordinator.handle_batches_msg(batch.author(), vec![batch.clone()]).await;
    assert!(validator_b_store.get_batch_from_local(batch.digest()).is_ok()); // IS stored
    
    // Validator B creates proposal with this batch
    let proposal = create_proposal_with_batch(batch.clone());
    
    // Validator A receives proposal and triggers on-demand fetch
    validator_a_reader.get_batch(batch.batch_info(), vec![validator_b_id]).await;
    
    // BUG: Validator A now has the batch despite filter!
    assert!(validator_a_store.get_batch_from_local(batch.digest()).is_ok()); // BYPASSED!
}
```

This demonstrates that a batch explicitly rejected via gossip is automatically accepted via on-demand fetch, completely bypassing the emergency filtering mechanism.

**Notes**

This vulnerability is particularly concerning because:

1. **Silent Failure:** Operators deploying emergency filters believe they are protecting the network, but the protection silently fails for any batch included in proposals.

2. **Timing Dependency:** The filter only works if batches arrive via gossip before being included in proposals. Once included in a proposal, the filter is bypassed.

3. **Configuration Divergence is Undetectable:** There is no mechanism to detect or alert when validators have divergent filter configurations, making this issue difficult to diagnose in production.

The fix requires ensuring filter validation is applied consistently across all batch acquisition paths, or alternatively, removing the filter mechanism entirely if it cannot be made secure.

### Citations

**File:** consensus/src/quorum_store/batch_coordinator.rs (L191-213)
```rust
        if self.transaction_filter_config.is_enabled() {
            let transaction_filter = &self.transaction_filter_config.batch_transaction_filter();
            for batch in batches.iter() {
                for transaction in batch.txns() {
                    if !transaction_filter.allows_transaction(
                        batch.batch_info().batch_id(),
                        batch.author(),
                        batch.digest(),
                        transaction,
                    ) {
                        error!(
                            "Transaction {}, in batch {}, from {}, was rejected by the filter. Dropping {} batches!",
                            transaction.committed_hash(),
                            batch.batch_info().batch_id(),
                            author.short_str().as_str(),
                            batches.len()
                        );
                        counters::RECEIVED_BATCH_REJECTED_BY_FILTER.inc();
                        return;
                    }
                }
            }
        }
```

**File:** consensus/src/quorum_store/batch_store.rs (L684-709)
```rust
                let fut = async move {
                    let batch_digest = *batch_info.digest();
                    defer!({
                        inflight_requests_clone.lock().remove(&batch_digest);
                    });
                    // TODO(ibalajiarun): Support V2 batch
                    if let Ok(mut value) = batch_store.get_batch_from_local(&batch_digest) {
                        Ok(value.take_payload().expect("Must have payload"))
                    } else {
                        // Quorum store metrics
                        counters::MISSED_BATCHES_COUNT.inc();
                        let subscriber_rx = batch_store.subscribe(*batch_info.digest());
                        let payload = requester
                            .request_batch(
                                batch_digest,
                                batch_info.expiration(),
                                responders,
                                subscriber_rx,
                            )
                            .await?;
                        batch_store.persist(vec![PersistedValue::new(
                            batch_info.into(),
                            Some(payload.clone()),
                        )]);
                        Ok(payload)
                    }
```

**File:** consensus/src/epoch_manager.rs (L212-213)
```rust
        let quorum_store_txn_filter_config =
            node_config.transaction_filters.quorum_store_filter.clone();
```

**File:** consensus/src/quorum_store/quorum_store_builder.rs (L324-336)
```rust
            let batch_coordinator = BatchCoordinator::new(
                self.author,
                self.network_sender.clone(),
                self.proof_manager_cmd_tx.clone(),
                self.batch_generator_cmd_tx.clone(),
                self.batch_store.clone().unwrap(),
                self.config.receiver_max_batch_txns as u64,
                self.config.receiver_max_batch_bytes as u64,
                self.config.receiver_max_total_txns as u64,
                self.config.receiver_max_total_bytes as u64,
                self.config.batch_expiry_gap_when_init_usecs,
                self.transaction_filter_config.clone(),
            );
```

**File:** testsuite/smoke-test/src/transaction_filter.rs (L272-283)
```rust
/// Adds a filter to the quorum store config to ignore transactions from the given sender
fn filter_quorum_store_transactions(node_config: &mut NodeConfig, sender_address: AccountAddress) {
    // Create the batch transaction filter
    let batch_transaction_filter = BatchTransactionFilter::empty()
        .add_multiple_matchers_filter(false, vec![BatchTransactionMatcher::Transaction(
            TransactionMatcher::Sender(sender_address),
        )])
        .add_all_filter(true);

    // Update the node config with the new filter
    node_config.transaction_filters.quorum_store_filter =
        BatchTransactionFilterConfig::new(true, batch_transaction_filter);
```

**File:** consensus/src/quorum_store/tests/batch_coordinator_test.rs (L83-120)
```rust
#[tokio::test(flavor = "multi_thread")]
async fn test_handle_batches_msg_filter_enabled() {
    // Create the message channels
    let (sender_to_proof_manager, _receiver_for_proof_manager) = channel(100);
    let (sender_to_batch_generator, mut receiver_for_batch_generator) = channel(100);

    // Create a filtering config with filtering enabled (the first transaction sender is rejected)
    let transactions = create_signed_transactions(10);
    let transaction_filter =
        BatchTransactionFilter::empty().add_sender_filter(false, transactions[0].sender());
    let transaction_filter_config = BatchTransactionFilterConfig::new(true, transaction_filter);

    // Create a batch coordinator
    let mut batch_coordinator = create_batch_coordinator(
        sender_to_proof_manager,
        sender_to_batch_generator,
        transaction_filter_config,
    );

    // Create a single batch
    let account_address = AccountAddress::random();
    let batch = Batch::new_v1(
        BatchId::new_for_test(109),
        transactions.clone(),
        1,
        1,
        account_address,
        0,
    );

    // Handle a batches message
    batch_coordinator
        .handle_batches_msg(account_address, vec![batch])
        .await;

    // Verify that the receiver for the batch generator does not receive the batch
    assert!(receiver_for_batch_generator.recv().now_or_never().is_none());
}
```
