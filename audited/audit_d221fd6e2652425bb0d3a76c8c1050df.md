# Audit Report

## Title
Version 0 Gas Parameters Defense-in-Depth Failure - Unlimited Write Operation Limits

## Summary
The Aptos VM has a code path where gas feature version 0 results in unlimited write operation and event size limits (`u64::MAX`), potentially allowing massive state bloat and consensus disruption. However, this vulnerability is not directly exploitable on properly configured networks because version 0 should never be active on mainnet after genesis initialization.

## Finding Description

When `GasScheduleV2::fetch_config` returns `None`, the system falls back to version 0: [1](#0-0) 

With feature version 0, `ChangeSetConfigs::new()` creates unlimited configuration: [2](#0-1) 

The `unlimited_at_gas_feature_version()` function sets all limits to `u64::MAX`: [3](#0-2) 

This means transactions would bypass validation for:
- `max_bytes_per_write_op`
- `max_bytes_all_write_ops_per_transaction`  
- `max_bytes_per_event`
- `max_bytes_all_events_per_transaction`
- `max_write_ops_per_transaction`

The checks are performed in `check_change_set()` but become ineffective with `u64::MAX` limits: [4](#0-3) 

## Impact Explanation

**IF version 0 were active**, this would be **Critical Severity** enabling:
- Consensus splits (validators OOM processing massive change sets)
- Network-wide DoS (chain halt due to resource exhaustion)
- State explosion (unbounded storage growth)

However, **version 0 cannot be triggered by an unprivileged attacker** because:
1. Genesis initializes with LATEST_GAS_FEATURE_VERSION (45): [5](#0-4) 
2. Governance updates require version >= current version: [6](#0-5) 

## Likelihood Explanation

**Extremely Low** on mainnet because:
- GasScheduleV2 is initialized at genesis and persists
- Governance protections prevent version downgrades
- No attacker-controlled path to delete/corrupt GasScheduleV2

Could only occur through:
- State database corruption (operational failure, not attack)
- Legacy test networks with old GasSchedule format
- Emergency state recovery scenarios

## Recommendation

While not immediately exploitable, add defensive validation in `get_gas_feature_version()`:

```rust
pub fn get_gas_feature_version(state_view: &impl StateView) -> u64 {
    GasScheduleV2::fetch_config(state_view)
        .map(|gas_schedule| {
            // Enforce minimum version after network initialization
            if gas_schedule.feature_version == 0 {
                warn!("GasScheduleV2 has version 0, using safe fallback");
                MIN_SAFE_GAS_FEATURE_VERSION
            } else {
                gas_schedule.feature_version
            }
        })
        .unwrap_or(MIN_SAFE_GAS_FEATURE_VERSION)
}
```

Also add explicit panic in `ChangeSetConfigs::new()` if version < 3 to prevent silent unlimited limits.

## Proof of Concept

Cannot provide executable PoC because:
1. Requires manually corrupting state to remove GasScheduleV2
2. No attacker-controlled path to trigger version 0
3. Would require privileged database access

**Theoretical attack flow** (not executable without state corruption):
1. Corrupt state to remove GasScheduleV2 â†’ version 0 active
2. Submit transaction calling Move function with large loop creating resources
3. Transaction generates 1GB+ of write operations
4. Bypasses all `check_change_set` validations
5. Causes validator OOM/consensus split

---

## Notes

This is a **defense-in-depth issue**, not a directly exploitable vulnerability. The code has a weakness (unlimited limits for version 0), but the weakness is not reachable through any attacker-controlled path on properly configured mainnet. It represents a failure of defensive programming rather than an active exploit vector.

**Classification: Code Quality Issue / Edge Case Hardening Needed**

The actual answer to the security question "are there known vulnerabilities in version 0 gas parameters" is: **Yes, version 0 has unlimited limits, but no, they cannot be exploited by unprivileged attackers on mainnet.**

Given the extremely high validation bar requiring exploitability by unprivileged attackers with realistic attack paths, this does not qualify as a valid critical/high severity bug bounty submission, though it merits code hardening.

### Citations

**File:** aptos-move/aptos-vm-environment/src/gas.rs (L15-19)
```rust
pub fn get_gas_feature_version(state_view: &impl StateView) -> u64 {
    GasScheduleV2::fetch_config(state_view)
        .map(|gas_schedule| gas_schedule.feature_version)
        .unwrap_or(0)
}
```

**File:** aptos-move/aptos-vm-types/src/storage/change_set_configs.rs (L20-29)
```rust
    pub fn unlimited_at_gas_feature_version(gas_feature_version: u64) -> Self {
        Self::new_impl(
            gas_feature_version,
            u64::MAX,
            u64::MAX,
            u64::MAX,
            u64::MAX,
            u64::MAX,
        )
    }
```

**File:** aptos-move/aptos-vm-types/src/storage/change_set_configs.rs (L31-39)
```rust
    pub fn new(feature_version: u64, gas_params: &AptosGasParameters) -> Self {
        if feature_version >= 5 {
            Self::from_gas_params(feature_version, gas_params)
        } else if feature_version >= 3 {
            Self::for_feature_version_3()
        } else {
            Self::unlimited_at_gas_feature_version(feature_version)
        }
    }
```

**File:** aptos-move/aptos-vm-types/src/storage/change_set_configs.rs (L95-128)
```rust
        if self.max_write_ops_per_transaction != 0
            && change_set.num_write_ops() as u64 > self.max_write_ops_per_transaction
        {
            return storage_write_limit_reached(Some("Too many write ops."));
        }

        let mut write_set_size = 0;
        for (key, op_size) in change_set.write_set_size_iter() {
            if let Some(len) = op_size.write_len() {
                let write_op_size = len + (key.size() as u64);
                if write_op_size > self.max_bytes_per_write_op {
                    return storage_write_limit_reached(None);
                }
                write_set_size += write_op_size;
            }
            if write_set_size > self.max_bytes_all_write_ops_per_transaction {
                return storage_write_limit_reached(None);
            }
        }

        let mut total_event_size = 0;
        for event in change_set.events_iter() {
            let size = event.event_data().len() as u64;
            if size > self.max_bytes_per_event {
                return storage_write_limit_reached(None);
            }
            total_event_size += size;
            if total_event_size > self.max_bytes_all_events_per_transaction {
                return storage_write_limit_reached(None);
            }
        }

        Ok(())
    }
```

**File:** aptos-move/vm-genesis/src/lib.rs (L128-133)
```rust
pub fn default_gas_schedule() -> GasScheduleV2 {
    GasScheduleV2 {
        feature_version: LATEST_GAS_FEATURE_VERSION,
        entries: AptosGasParameters::initial().to_on_chain_gas_schedule(LATEST_GAS_FEATURE_VERSION),
    }
}
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L95-101)
```text
        if (exists<GasScheduleV2>(@aptos_framework)) {
            let cur_gas_schedule = borrow_global<GasScheduleV2>(@aptos_framework);
            assert!(
                new_gas_schedule.feature_version >= cur_gas_schedule.feature_version,
                error::invalid_argument(EINVALID_GAS_FEATURE_VERSION)
            );
        };
```
