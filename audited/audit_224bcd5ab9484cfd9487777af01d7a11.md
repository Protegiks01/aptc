# Audit Report

## Title
Feature Flag Bypass: Mempool Transactions Evade Post-Upgrade Cryptographic Restrictions

## Summary
Transactions validated under enabled feature flags remain in the mempool across epoch boundaries and execute successfully even after those feature flags are disabled. This allows deprecated or vulnerable cryptographic signature schemes to continue being accepted post-upgrade, bypassing security improvements.

## Finding Description

The Aptos blockchain uses feature flags to gate cryptographic signature schemes like `SLH_DSA_SHA2_128S_SIGNATURE`. When governance disables a signature scheme due to security concerns, the intent is to reject all transactions using that scheme. However, a critical gap exists in the validation architecture:

**Feature Flag Check Location Mismatch:**

1. Feature flag validation occurs in `validate_transaction` during mempool admission [1](#0-0) 

2. Block execution performs signature verification via `SignedTransaction::verify_signature()` which only validates cryptographic correctness, NOT feature flags [2](#0-1) 

3. The `From<Transaction>` implementation for `SignatureVerifiedTransaction` calls `verify_signature()` without feature flag checks [3](#0-2) 

4. Mempool's `get_batch()` retrieves transactions for consensus without re-validation [4](#0-3) 

5. Critically, the mempool does NOT flush on epoch changes - pending valid transactions persist across epoch boundaries [5](#0-4) 

**Attack Scenario:**

1. Epoch N: `SLH_DSA_SHA2_128S_SIGNATURE` feature enabled
2. Attacker submits transactions with SLH-DSA signatures
3. Mempool validates transactions (feature flag check passes)
4. Governance proposal disables `SLH_DSA_SHA2_128S_SIGNATURE` for epoch N+1 due to discovered vulnerability
5. Epoch change occurs via `features::on_new_epoch` [6](#0-5) 
6. Attacker's pre-validated transactions remain in mempool (no flush occurs)
7. Consensus pulls transactions via `get_batch()` - no feature flag recheck
8. Block execution converts to `SignatureVerifiedTransaction` - only cryptographic validation, no feature flag check
9. Transactions execute successfully, bypassing the security improvement

This violates the **Cryptographic Correctness** invariant that deprecated signature schemes must be rejected, and the **Transaction Validation** invariant that all validation checks must be enforced.

## Impact Explanation

**HIGH Severity** - This vulnerability enables:

1. **Security Bypass**: If a cryptographic scheme is disabled due to discovered vulnerabilities (e.g., signature malleability, weak parameters), attackers can continue exploiting it by pre-loading the mempool
2. **Protocol Invariant Violation**: Breaks the guarantee that disabled features are immediately rejected network-wide
3. **Deterministic Execution Risk**: Different validators might have different mempool states, potentially causing consensus disagreements if some reject while others execute
4. **Governance Ineffectiveness**: Undermines the security upgrade mechanism, requiring additional hardfork-level interventions

While not causing immediate fund loss or consensus split, this significantly weakens the blockchain's ability to respond to cryptographic vulnerabilities through feature flags.

## Likelihood Explanation

**HIGH Likelihood** - This will occur in every protocol upgrade that disables a signature scheme:

1. **Automatic Occurrence**: No sophisticated attack needed - normal mempool behavior causes the bypass
2. **Window of Opportunity**: Attackers have advance notice (governance proposal period) to flood mempool
3. **No Special Privileges**: Any transaction sender can exploit this
4. **Realistic Scenario**: Cryptographic upgrades are common in blockchain systems as new vulnerabilities are discovered

The only requirement is that transactions exist in the mempool when the epoch change occurs, which is guaranteed during normal operation.

## Recommendation

**Solution: Re-validate Feature Flags During Block Execution**

Add feature flag validation to the block execution path:

1. Modify `SignatureVerifiedTransaction::from()` to accept feature flags and validate signature schemes
2. Pass current `Features` from `AptosEnvironment` to the signature verification stage
3. Alternatively, add a pre-execution validation stage that checks all transactions against current feature flags before converting to `SignatureVerifiedTransaction`

**Specific Fix in `signature_verified_transaction.rs`:**

Change the `From<Transaction>` implementation to check feature flags during conversion, similar to how `validate_transaction` checks them in mempool admission. This ensures that even if a transaction bypasses mempool re-validation, it will be caught during block execution.

**Alternative: Mempool Flush on Feature Flag Changes**

Implement selective mempool clearing when security-critical feature flags change:
- In `process_config_update` [7](#0-6) , detect feature flag changes that affect signature schemes
- Trigger re-validation of all mempool transactions against new feature flags
- Remove transactions that would now fail validation

## Proof of Concept

```rust
// Integration test demonstrating the bypass

#[tokio::test]
async fn test_feature_flag_bypass() {
    let mut harness = TestHarness::new();
    
    // Step 1: Enable SLH_DSA feature in epoch 0
    harness.enable_feature(FeatureFlag::SLH_DSA_SHA2_128S_SIGNATURE);
    harness.new_epoch();
    
    // Step 2: Submit transaction with SLH-DSA signature
    let slh_dsa_txn = create_slh_dsa_signed_transaction();
    harness.submit_to_mempool(slh_dsa_txn.clone());
    
    // Verify transaction is in mempool
    assert!(harness.mempool_contains(&slh_dsa_txn));
    
    // Step 3: Governance disables SLH_DSA feature for next epoch
    harness.disable_feature(FeatureFlag::SLH_DSA_SHA2_128S_SIGNATURE);
    harness.new_epoch(); // Triggers features::on_new_epoch
    
    // Step 4: Verify feature is now disabled
    assert!(!harness.features().is_enabled(FeatureFlag::SLH_DSA_SHA2_128S_SIGNATURE));
    
    // Step 5: Transaction should still be in mempool (NOT flushed)
    assert!(harness.mempool_contains(&slh_dsa_txn));
    
    // Step 6: Consensus pulls transaction from mempool
    let batch = harness.get_mempool_batch(100, 1000000);
    assert!(batch.contains(&slh_dsa_txn));
    
    // Step 7: Execute block - transaction SHOULD be rejected but isn't
    let result = harness.execute_block(batch);
    
    // BUG: Transaction executes successfully despite feature being disabled
    assert!(result.transaction_outputs[0].status().is_success());
    
    // Expected: Transaction should fail with FEATURE_UNDER_GATING error
    // assert_eq!(result.transaction_outputs[0].status().status(), 
    //            TransactionStatus::Discard(StatusCode::FEATURE_UNDER_GATING));
}
```

## Notes

The `compat` module referenced in the security question [8](#0-7)  is actually just a wrapper for RustCrypto trait implementations [9](#0-8)  and is not directly involved in this vulnerability. The real issue lies in the feature flag enforcement architecture across the mempool-consensus-execution pipeline.

This vulnerability affects all feature-gated signature schemes including `WEBAUTHN_SIGNATURE`, `SINGLE_SENDER_AUTHENTICATOR`, and future cryptographic upgrades managed through feature flags.

### Citations

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L3196-3212)
```rust
        if !self
            .features()
            .is_enabled(FeatureFlag::SLH_DSA_SHA2_128S_SIGNATURE)
        {
            if let Ok(sk_authenticators) = transaction
                .authenticator_ref()
                .to_single_key_authenticators()
            {
                for authenticator in sk_authenticators {
                    if let AnySignature::SlhDsa_Sha2_128s { .. } = authenticator.signature() {
                        return VMValidatorResult::error(StatusCode::FEATURE_UNDER_GATING);
                    }
                }
            } else {
                return VMValidatorResult::error(StatusCode::INVALID_SIGNATURE);
            }
        }
```

**File:** types/src/transaction/mod.rs (L1315-1318)
```rust
    pub fn verify_signature(&self) -> Result<()> {
        self.authenticator.verify(&self.raw_txn)?;
        Ok(())
    }
```

**File:** types/src/transaction/signature_verified_transaction.rs (L129-138)
```rust
impl From<Transaction> for SignatureVerifiedTransaction {
    fn from(txn: Transaction) -> Self {
        match txn {
            Transaction::UserTransaction(txn) => match txn.verify_signature() {
                Ok(_) => SignatureVerifiedTransaction::Valid(Transaction::UserTransaction(txn)),
                Err(_) => SignatureVerifiedTransaction::Invalid(Transaction::UserTransaction(txn)),
            },
            _ => SignatureVerifiedTransaction::Valid(txn),
        }
    }
```

**File:** mempool/src/core_mempool/mempool.rs (L425-431)
```rust
    pub(crate) fn get_batch(
        &self,
        max_txns: u64,
        max_bytes: u64,
        return_non_full: bool,
        exclude_transactions: BTreeMap<TransactionSummary, TransactionInProgress>,
    ) -> Vec<SignedTransaction> {
```

**File:** mempool/src/shared_mempool/coordinator.rs (L268-291)
```rust
async fn handle_mempool_reconfig_event<NetworkClient, TransactionValidator, ConfigProvider>(
    smp: &mut SharedMempool<NetworkClient, TransactionValidator>,
    bounded_executor: &BoundedExecutor,
    config_update: OnChainConfigPayload<ConfigProvider>,
) where
    NetworkClient: NetworkClientInterface<MempoolSyncMsg> + 'static,
    TransactionValidator: TransactionValidation + 'static,
    ConfigProvider: OnChainConfigProvider,
{
    info!(LogSchema::event_log(
        LogEntry::ReconfigUpdate,
        LogEvent::Received
    ));
    let _timer =
        counters::task_spawn_latency_timer(counters::RECONFIG_EVENT_LABEL, counters::SPAWN_LABEL);

    bounded_executor
        .spawn(tasks::process_config_update(
            config_update,
            smp.validator.clone(),
            smp.broadcast_within_validator_network.clone(),
        ))
        .await;
}
```

**File:** aptos-move/framework/aptos-framework/sources/reconfiguration_with_dkg.move (L46-61)
```text
    public(friend) fun finish(framework: &signer) {
        system_addresses::assert_aptos_framework(framework);
        dkg::try_clear_incomplete_session(framework);
        consensus_config::on_new_epoch(framework);
        execution_config::on_new_epoch(framework);
        gas_schedule::on_new_epoch(framework);
        std::version::on_new_epoch(framework);
        features::on_new_epoch(framework);
        jwk_consensus_config::on_new_epoch(framework);
        jwks::on_new_epoch(framework);
        keyless_account::on_new_epoch(framework);
        randomness_config_seqnum::on_new_epoch(framework);
        randomness_config::on_new_epoch(framework);
        randomness_api_v0_config::on_new_epoch(framework);
        reconfiguration::reconfigure();
    }
```

**File:** mempool/src/shared_mempool/tasks.rs (L762-794)
```rust
pub(crate) async fn process_config_update<V, P>(
    config_update: OnChainConfigPayload<P>,
    validator: Arc<RwLock<V>>,
    broadcast_within_validator_network: Arc<RwLock<bool>>,
) where
    V: TransactionValidation,
    P: OnChainConfigProvider,
{
    info!(LogSchema::event_log(
        LogEntry::ReconfigUpdate,
        LogEvent::Process
    ));

    if let Err(e) = validator.write().restart() {
        counters::VM_RECONFIG_UPDATE_FAIL_COUNT.inc();
        error!(LogSchema::event_log(LogEntry::ReconfigUpdate, LogEvent::VMUpdateFail).error(&e));
    }

    let consensus_config: anyhow::Result<OnChainConsensusConfig> = config_update.get();
    match consensus_config {
        Ok(consensus_config) => {
            *broadcast_within_validator_network.write() =
                !consensus_config.quorum_store_enabled() && !consensus_config.is_dag_enabled()
        },
        Err(e) => {
            error!(
                "Failed to read on-chain consensus config, keeping value broadcast_within_validator_network={}: {}",
                *broadcast_within_validator_network.read(),
                e
            );
        },
    }
}
```

**File:** third_party/move/move-examples/diem-framework/crates/crypto/src/lib.rs (L11-11)
```rust
pub mod compat;
```

**File:** crates/aptos-crypto/src/compat.rs (L1-62)
```rust
// Copyright (c) Aptos Foundation
// Licensed pursuant to the Innovation-Enabling Source Code License, available at https://github.com/aptos-labs/aptos-core/blob/main/LICENSE

//! Wrapper structs for types that need [RustCrypto](https://github.com/RustCrypto)
//! traits implemented.

use digest::{
    consts::{U136, U32},
    generic_array::GenericArray,
    BlockInput, Digest, FixedOutput, Reset, Update,
};
use tiny_keccak::{Hasher, Sha3};

/// A wrapper for [`tiny_keccak::Sha3::v256`] that
/// implements RustCrypto [`digest`] traits [`BlockInput`], [`Update`], [`Reset`],
/// and [`FixedOutput`]. Consequently, this wrapper can be used in RustCrypto
/// APIs that require a hash function (usually something that impls [`Digest`]).
#[derive(Clone)]
pub struct Sha3_256(Sha3);

// ensure that we impl all of the sub-traits required for the Digest trait alias
static_assertions::assert_impl_all!(Sha3_256: Digest);

impl Default for Sha3_256 {
    #[inline]
    fn default() -> Self {
        Self(Sha3::v256())
    }
}

impl BlockInput for Sha3_256 {
    type BlockSize = U136;
}

impl Update for Sha3_256 {
    #[inline]
    fn update(&mut self, data: impl AsRef<[u8]>) {
        self.0.update(data.as_ref());
    }
}

impl Reset for Sha3_256 {
    #[inline]
    fn reset(&mut self) {
        *self = Self::default();
    }
}

impl FixedOutput for Sha3_256 {
    type OutputSize = U32;

    #[inline]
    fn finalize_into(self, out: &mut GenericArray<u8, Self::OutputSize>) {
        self.0.finalize(out.as_mut());
    }

    #[inline]
    fn finalize_into_reset(&mut self, out: &mut GenericArray<u8, Self::OutputSize>) {
        self.clone().finalize_into(out);
        Reset::reset(self)
    }
}
```
