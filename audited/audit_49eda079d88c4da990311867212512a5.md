# Audit Report

## Title
Event JSON Serialization Failure Causes Complete Transaction API Unavailability

## Summary
In `api/types/src/convert.rs`, the `try_into_events()` function uses error propagation (`?` operator) when converting event data to JSON. If `MoveValue::json()` fails for any single event, the entire transaction conversion fails, causing API queries to return HTTP 500 errors. This makes successfully committed on-chain transactions invisible to API clients and indexers.

## Finding Description

The vulnerability exists in the event-to-JSON conversion pipeline: [1](#0-0) 

When converting events, if JSON serialization fails for any event in the array, the `?` operator propagates the error, causing `try_into_events()` to fail entirely.

This failure cascades through the transaction conversion: [2](#0-1) 

When `try_into_onchain_transaction()` calls `try_into_events()`, any error causes the entire transaction conversion to fail. The API layer handles this by returning an HTTP 500 Internal Server Error: [3](#0-2) 

The JSON serialization implementation delegates to serde_json: [4](#0-3) 

**How a malicious actor could exploit this:**

1. Deploy a Move module that emits events with complex nested structures approaching Move VM's depth limit (128 levels)
2. The event data passes Move VM validation and is stored on-chain successfully
3. When API clients query this transaction, the JSON conversion could fail due to:
   - Recursion depth approaching serde_json limits
   - Edge cases in type conversion between Move VM and JSON representations
   - Complex struct serialization with deeply nested fields

4. The transaction becomes "invisible" via the API despite being successfully committed on-chain

**Broken Invariant:** While not explicitly listed, this violates the principle of **API transparency and data availability** - committed transactions should be queryable via API interfaces.

## Impact Explanation

This issue is classified as **Medium severity** based on the Aptos bug bounty criteria:

- **Not Critical**: Does not affect consensus, on-chain state, or funds
- **Not High**: Not a validator node issue or significant protocol violation
- **Medium**: Creates state inconsistencies requiring intervention - transactions exist on-chain but are invisible via API, requiring direct database queries or alternative access methods

**Affected Components:**
- REST API endpoints serving transaction data
- Indexers relying on API for transaction processing
- Block explorers and monitoring tools
- Any application querying transaction events via API

**Attack Scenario Impact:**
- Malicious actors could hide their on-chain activities from API monitoring
- Legitimate transactions with complex event data become invisible
- Indexer synchronization failures for affected transactions
- Loss of transparency for on-chain activity

## Likelihood Explanation

**Likelihood: Medium to Low**

While the vulnerability exists, several factors affect likelihood:

**Mitigating Factors:**
- Move VM enforces `DEFAULT_MAX_VM_VALUE_NESTED_DEPTH = 128` for values [5](#0-4) 
- Type tag nesting limited to 8 levels [6](#0-5) 
- Both serde_json and Move VM have similar recursion limits

**Enabling Factors:**
- Edge cases may exist where BCS deserialization succeeds but JSON fails
- Complex struct layouts with many nested fields
- No fallback mechanism or graceful degradation
- Inconsistent error handling (events use `?`, table items use `.unwrap()`) [7](#0-6) 

## Recommendation

Implement graceful degradation for event serialization failures:

```rust
pub fn try_into_events(&self, events: &[ContractEvent]) -> Result<Vec<Event>> {
    let mut ret = vec![];
    for event in events {
        let data = self
            .inner
            .view_value(event.type_tag(), event.event_data())?;
        
        // Gracefully handle JSON serialization failures
        match MoveValue::try_from(data) {
            Ok(move_value) => match move_value.json() {
                Ok(json_val) => ret.push((event, json_val).into()),
                Err(e) => {
                    // Log error but continue processing other events
                    aptos_logger::warn!(
                        "Failed to serialize event to JSON: {:?}, error: {}",
                        event.type_tag(),
                        e
                    );
                    // Include placeholder or raw BCS data
                    ret.push((event, serde_json::json!({
                        "__error__": "JSON serialization failed",
                        "__raw_bcs__": hex::encode(event.event_data())
                    })).into());
                }
            },
            Err(e) => {
                aptos_logger::error!(
                    "Failed to convert event data: {:?}, error: {}",
                    event.type_tag(),
                    e
                );
                return Err(e);
            }
        }
    }
    Ok(ret)
}
```

**Additional fixes:**
1. Make error handling consistent - replace `.unwrap()` with proper error handling for table items
2. Add depth validation before JSON conversion
3. Implement API endpoint to retrieve raw event data for problematic transactions
4. Add monitoring/alerting for JSON serialization failures

## Proof of Concept

```rust
// This would need to be a full integration test
#[test]
fn test_deeply_nested_event_serialization() {
    // Create a Move module that emits an event with deeply nested vectors
    // approaching the VM depth limit (e.g., Vec<Vec<Vec<...>>> at 120+ levels)
    
    let module_code = r#"
    module 0x1::deep_event {
        use std::event;
        
        struct DeepStruct has drop, store {
            // Create nested structure approaching depth limit
            level: vector<vector<vector<u64>>>,
        }
        
        public entry fun emit_deep_event() {
            // Build deeply nested structure
            let mut deep_data = vector::empty();
            // ... populate with many nested levels ...
            
            event::emit(DeepStruct { level: deep_data });
        }
    }
    "#;
    
    // 1. Deploy module and execute transaction
    // 2. Verify transaction commits successfully on-chain
    // 3. Query transaction via API
    // 4. Expect HTTP 500 error due to JSON serialization failure
    // 5. Verify transaction is queryable via direct DB access
}
```

**Note:** A complete PoC would require setting up a full Aptos node environment and crafting Move bytecode that maximizes nesting depth while staying within Move VM limits.

---

**Notes:**
- This vulnerability affects the API layer post-consensus, not the blockchain core
- Transactions remain valid and committed on-chain regardless of API conversion failures
- The issue represents a transparency and observability problem rather than a direct security threat to funds or consensus
- Fixing the inconsistent error handling (`.unwrap()` vs `?`) is also recommended to prevent potential node crashes

### Citations

**File:** api/types/src/convert.rs (L192-192)
```rust
        let events = self.try_into_events(&data.events)?;
```

**File:** api/types/src/convert.rs (L573-576)
```rust
            key: key.json().unwrap(),
            key_type: table_info.key_type.to_canonical_string(),
            value: value.json().unwrap(),
            value_type: table_info.value_type.to_canonical_string(),
```

**File:** api/types/src/convert.rs (L601-610)
```rust
    pub fn try_into_events(&self, events: &[ContractEvent]) -> Result<Vec<Event>> {
        let mut ret = vec![];
        for event in events {
            let data = self
                .inner
                .view_value(event.type_tag(), event.event_data())?;
            ret.push((event, MoveValue::try_from(data)?.json()?).into());
        }
        Ok(ret)
    }
```

**File:** api/src/context.rs (L758-765)
```rust
                let txn = converter.try_into_onchain_transaction(timestamp, t)?;
                Ok(txn)
            })
            .collect::<Result<_, anyhow::Error>>()
            .context("Failed to convert transaction data from storage")
            .map_err(|err| {
                E::internal_with_code(err, AptosErrorCode::InternalError, ledger_info)
            })?;
```

**File:** api/types/src/move_types.rs (L387-389)
```rust
    pub fn json(&self) -> anyhow::Result<serde_json::Value> {
        Ok(serde_json::to_value(self)?)
    }
```

**File:** api/types/src/move_types.rs (L688-688)
```rust
pub const MAX_RECURSIVE_TYPES_ALLOWED: u8 = 8;
```

**File:** third_party/move/move-vm/types/src/values/values_impl.rs (L57-57)
```rust
pub const DEFAULT_MAX_VM_VALUE_NESTED_DEPTH: u64 = 128;
```
