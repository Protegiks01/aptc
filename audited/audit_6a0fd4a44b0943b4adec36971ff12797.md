# Audit Report

## Title
Cryptographic Verification Bypass in Backup Replay-Verify Tool Enables Acceptance of Forged Transaction History

## Summary
The `ReplayVerifyCoordinator` in `replay_verify.rs` unconditionally passes `None` for `epoch_history` to both `StateSnapshotRestoreController` and `TransactionRestoreBatchController`, completely bypassing cryptographic verification of LedgerInfo signatures. This allows malicious backup data with forged validator signatures to pass verification checks, undermining the fundamental security guarantee that all ledger state must be certified by a quorum of validators. [1](#0-0) 

## Finding Description

The Aptos blockchain's security model requires that all ledger state transitions be cryptographically signed by a quorum (2f+1) of validators through BLS signature aggregation in `LedgerInfoWithSignatures`. This ensures Byzantine fault tolerance and prevents unauthorized state modifications.

When loading transaction chunks during backup restoration, the `LoadedChunk::load()` function performs critical signature verification: [2](#0-1) 

The `EpochHistory::verify_ledger_info()` method validates:
1. For genesis epoch: LedgerInfo matches known genesis
2. For trusted waypoints: LedgerInfo matches the waypoint hash
3. **For all other epochs: Cryptographically verifies signatures using the previous epoch's validator set** [3](#0-2) 

However, in `replay_verify.rs`, the `epoch_history` parameter is **unconditionally set to `None`** at both invocation points: [4](#0-3) 

When `epoch_history` is `None`, the signature verification is completely skipped. The tool only verifies:
- Transaction accumulator proofs against the (unverified) LedgerInfo
- Execution consistency (that replay produces same outputs)

**Attack Scenario:**
1. Attacker compromises backup storage or performs MITM on backup retrieval
2. Crafts malicious backup containing `LedgerInfoWithSignatures` with **forged or missing validator signatures**
3. Ensures transactions are internally consistent (valid accumulator proofs, matching execution outputs)
4. The `replay-verify` tool loads this data and reports success
5. Operators believe the backup is cryptographically verified when signatures were never checked
6. If this "verified" backup is used for node recovery or archival purposes, the compromised data propagates

**Comparison with Proper Implementation:**
The `VerifyCoordinator` in `verify.rs` correctly implements epoch verification: [5](#0-4) 

The regular restore coordinator also properly verifies epochs: [6](#0-5) 

## Impact Explanation

**Severity: Medium to High**

This vulnerability breaks the **Cryptographic Correctness** invariant (Invariant #10): "BLS signatures, VRF, and hash operations must be secure."

**Impact categorization:**
- **State Consistency Violation**: Accepting unsigned/forged ledger state violates Byzantine fault tolerance guarantees
- **Trust Boundary Bypass**: The tool's name "replay-verify" and acceptance of `trusted_waypoints_opt` parameter suggests cryptographic verification, creating false security assumptions
- **Supply Chain Risk**: If used in production pipelines to validate backups before deployment, compromised backups could be accepted

While this tool operates offline and doesn't directly compromise running consensus, it creates a **security false positive** where operators believe data is cryptographically verified when only execution consistency is checked. The tool is actively used in CI/CD workflows: [7](#0-6) 

## Likelihood Explanation

**Likelihood: Medium**

Prerequisites for exploitation:
1. Attacker gains access to backup storage (cloud storage compromise, credential theft) OR MITM position
2. Operators use `replay-verify` to validate backup authenticity (common operational practice)
3. Reliance on the tool's "success" output as security guarantee

The tool accepts `trusted_waypoints_opt` parameter but never uses it due to `None` epoch_history, reinforcing user confusion: [8](#0-7) 

Note that the documentation states waypoints are not checked for transaction-only restores, but this is buried in help text and contradicts the tool accepting the parameter.

## Recommendation

**Option 1: Enable Epoch Verification (Recommended)**
Modify `replay_verify.rs` to restore epoch history before transaction verification:

```rust
// In run_impl(), after line 171, add:
let epoch_ending_backups = metadata_view.select_epoch_ending_backups(self.end_version)?;
let epoch_history = if !epoch_ending_backups.is_empty() {
    Some(Arc::new(
        EpochHistoryRestoreController::new(
            epoch_ending_backups
                .into_iter()
                .map(|backup| backup.manifest)
                .collect(),
            global_opt.clone(),
            Arc::clone(&self.storage),
        )
        .run()
        .await?,
    ))
} else {
    None
};

// Then pass epoch_history to both controllers instead of None
```

**Option 2: Rename Tool and Add Explicit Warnings**
If execution-only verification is intentional:
1. Rename to `replay-execution-verify` to clarify it doesn't verify authenticity
2. Add prominent warning when tool starts: "WARNING: This tool only verifies execution consistency. Cryptographic signatures are NOT verified."
3. Remove `trusted_waypoints_opt` parameter to avoid confusion

## Proof of Concept

Create malicious backup data with forged LedgerInfo:

```rust
// Proof of Concept: Demonstrate accepting forged backup data
use aptos_types::ledger_info::{LedgerInfo, LedgerInfoWithSignatures};
use aptos_crypto::bls12381;

// Step 1: Create LedgerInfo with correct structure but NO valid signatures
let malicious_ledger_info = LedgerInfo::new(
    BlockInfo::new(
        epoch,
        round,
        version,
        executed_state_root, // Valid root from real transaction execution
        version,
        timestamp,
        None,
    ),
    HashValue::zero(),
);

// Step 2: Create LedgerInfoWithSignatures with EMPTY or forged signatures
let forged_signatures = AggregateSignature::empty(); // No actual validator signatures
let ledger_info_with_sigs = LedgerInfoWithSignatures::new(
    malicious_ledger_info,
    forged_signatures,
);

// Step 3: Create backup with transactions matching the accumulator
// (transactions are valid, but LedgerInfo was never signed by validators)
create_backup_with_forged_ledger_info(
    transactions,
    ledger_info_with_sigs,
);

// Step 4: Run replay-verify - it will PASS verification
// despite the LedgerInfo never being signed by any validators
// because epoch_history is None and signature check is skipped
```

**Verification Steps:**
1. Create backup with valid transaction structure but unsigned LedgerInfo
2. Run: `aptos-debugger aptos-db replay-verify --target-db-dir test_db --start-version 0 --end-version 1000 [backup params]`
3. Tool reports SUCCESS despite forged signatures
4. Compare with `aptos-debugger aptos-db verify` (with epoch endings) - that tool would FAIL

## Notes

The vulnerability exists because `replay_verify.rs` diverges from the security pattern used in both `verify.rs` and `restore.rs`, which properly verify epoch signatures. The trusted waypoints parameter is accepted but unused, creating operator confusion about security guarantees. This tool is actively used in production CI/CD pipelines, making the false security signal particularly concerning for operational security.

### Citations

**File:** storage/backup/backup-cli/src/coordinators/replay_verify.rs (L183-188)
```rust
                    Arc::clone(&self.storage),
                    None, /* epoch_history */
                )
                .run()
                .await?;
            }
```

**File:** storage/backup/backup-cli/src/coordinators/replay_verify.rs (L191-205)
```rust
        TransactionRestoreBatchController::new(
            global_opt,
            self.storage,
            transactions
                .into_iter()
                .map(|t| t.manifest)
                .collect::<Vec<_>>(),
            save_start_version,
            Some((next_txn_version, false)), /* replay_from_version */
            None,                            /* epoch_history */
            self.verify_execution_mode.clone(),
            None,
        )
        .run()
        .await?;
```

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L152-154)
```rust
        if let Some(epoch_history) = epoch_history {
            epoch_history.verify_ledger_info(&ledger_info)?;
        }
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L276-312)
```rust
    pub fn verify_ledger_info(&self, li_with_sigs: &LedgerInfoWithSignatures) -> Result<()> {
        let epoch = li_with_sigs.ledger_info().epoch();
        ensure!(!self.epoch_endings.is_empty(), "Empty epoch history.",);
        if epoch > self.epoch_endings.len() as u64 {
            // TODO(aldenhu): fix this from upper level
            warn!(
                epoch = epoch,
                epoch_history_until = self.epoch_endings.len(),
                "Epoch is too new and can't be verified. Previous chunks are verified and node \
                won't be able to start if this data is malicious."
            );
            return Ok(());
        }
        if epoch == 0 {
            ensure!(
                li_with_sigs.ledger_info() == &self.epoch_endings[0],
                "Genesis epoch LedgerInfo info doesn't match.",
            );
        } else if let Some(wp_trusted) = self
            .trusted_waypoints
            .get(&li_with_sigs.ledger_info().version())
        {
            let wp_li = Waypoint::new_any(li_with_sigs.ledger_info());
            ensure!(
                *wp_trusted == wp_li,
                "Waypoints don't match. In backup: {}, trusted: {}",
                wp_li,
                wp_trusted,
            );
        } else {
            self.epoch_endings[epoch as usize - 1]
                .next_epoch_state()
                .ok_or_else(|| anyhow!("Shouldn't contain non- epoch bumping LIs."))?
                .verify(li_with_sigs)?;
        };
        Ok(())
    }
```

**File:** storage/backup/backup-cli/src/coordinators/verify.rs (L106-121)
```rust
        let epoch_history = if self.skip_epoch_endings {
            None
        } else {
            Some(Arc::new(
                EpochHistoryRestoreController::new(
                    epoch_endings
                        .into_iter()
                        .map(|backup| backup.manifest)
                        .collect(),
                    global_opt.clone(),
                    self.storage.clone(),
                )
                .run()
                .await?,
            ))
        };
```

**File:** storage/backup/backup-cli/src/coordinators/restore.rs (L219-231)
```rust
        let epoch_history = if !self.skip_epoch_endings {
            Some(Arc::new(
                EpochHistoryRestoreController::new(
                    epoch_handles,
                    self.global_opt.clone(),
                    self.storage.clone(),
                )
                .run()
                .await?,
            ))
        } else {
            None
        };
```

**File:** .github/workflows/workflow-run-replay-verify.yaml (L248-259)
```yaml
                ./aptos-debugger aptos-db replay-verify \
                  --metadata-cache-dir $MC \
                  --command-adapter-config ${{ inputs.BACKUP_CONFIG_TEMPLATE_PATH }} \
                  --start-version $begin \
                  --end-version $end \
                  \
                  --lazy-quit \
                  --enable-storage-sharding \
                  --target-db-dir $DB \
                  --concurrent-downloads 8 \
                  --replay-concurrency-level 4 \
                  || res=$?
```

**File:** storage/backup/backup-cli/src/utils/mod.rs (L332-346)
```rust
pub struct TrustedWaypointOpt {
    #[clap(
        long,
        help = "(multiple) When provided, an epoch ending LedgerInfo at the waypoint version will be \
        checked against the hash in the waypoint, but signatures on it are NOT checked. \
        Use this for two purposes: \
        1. set the genesis or the latest waypoint to confirm the backup is compatible. \
        2. set waypoints at versions where writeset transactions were used to overwrite the \
        validator set, so that the signature check is skipped. \
        N.B. LedgerInfos are verified only when restoring / verifying the epoch ending backups, \
        i.e. they are NOT checked at all when doing one-shot restoring of the transaction \
        and state backups."
    )]
    pub trust_waypoint: Vec<Waypoint>,
}
```
