# Audit Report

## Title
Unauthenticated Fullnode Ping Service Exposes Node Sync Status for Network Reconnaissance

## Summary
The `PingFullnodeResponse` service in the Aptos fullnode gRPC API exposes the node's `known_latest_version` without any authentication or rate limiting. This allows attackers to scan the network to identify nodes that are behind on sync, enabling targeted reconnaissance for eclipse attacks, network mapping, and selective DoS attacks against vulnerable nodes.

## Finding Description

The Ping service is implemented in the `FullnodeData` gRPC service and returns a `FullnodeInfo` structure containing operational metadata about the fullnode. The protobuf definition shows: [1](#0-0) 

The implementation retrieves and returns the node's current sync status: [2](#0-1) 

Critically, the service is exposed without any authentication mechanism in the runtime configuration: [3](#0-2) 

**Attack Scenario:**
1. Attacker scans multiple fullnode endpoints by calling the Ping RPC
2. Compares `known_latest_version` across nodes to identify lagging nodes
3. Uses this information to:
   - Target eclipse attacks against nodes significantly behind
   - Map network topology and identify geographic regions with sync issues
   - Time attacks when specific nodes are known to be vulnerable
   - Focus DoS resources on already-struggling nodes

The protobuf package name `aptos.internal.fullnode.v1` suggests this API was intended for internal use only, yet it's exposed without access controls.

## Impact Explanation

This qualifies as **Low Severity** per Aptos bug bounty criteria: "Minor information leaks." 

The disclosed information enables reconnaissance but does not directly compromise funds, consensus, or availability. However, it provides actionable intelligence for:
- **Eclipse Attack Targeting**: Identify nodes behind sync for easier network isolation
- **Selective DoS**: Focus attacks on already-vulnerable nodes
- **Network Mapping**: Understand network health distribution

While the impact is limited to information gathering, it materially aids more serious attacks by providing targeting intelligence that would otherwise require significant effort to obtain.

## Likelihood Explanation

**Likelihood: HIGH**

The attack is trivial to execute:
- No authentication required
- No rate limiting implemented  
- Standard gRPC client can access the endpoint
- Scanning multiple nodes is straightforward

Any attacker with network access to fullnode gRPC endpoints can immediately gather this intelligence. The "internal" package naming suggests the exposure may be unintentional.

## Recommendation

Implement authentication and authorization for the Ping service:

```rust
// In runtime.rs, add an authentication interceptor
use tonic::service::Interceptor;

// Define an auth interceptor
fn auth_interceptor(req: Request<()>) -> Result<Request<()>, Status> {
    // Validate token from metadata
    let token = req.metadata()
        .get("authorization")
        .ok_or_else(|| Status::unauthenticated("Missing auth token"))?;
    
    // Validate token against allowlist or JWT verification
    if !is_valid_token(token) {
        return Err(Status::permission_denied("Invalid token"));
    }
    
    Ok(req)
}

// Apply to service
let svc = FullnodeDataServer::new(server)
    .with_interceptor(auth_interceptor)  // Add this line
    .send_compressed(CompressionEncoding::Zstd)
    .accept_compressed(CompressionEncoding::Zstd)
    .accept_compressed(CompressionEncoding::Gzip);
```

Alternative mitigations:
1. Restrict the service to internal networks only via firewall rules
2. Implement rate limiting per IP address
3. Add configuration option to disable the Ping endpoint entirely
4. Rename package from "internal" to "public" if exposure is intentional

## Proof of Concept

```rust
// Simple gRPC client to demonstrate reconnaissance
use aptos_protos::internal::fullnode::v1::{
    fullnode_data_client::FullnodeDataClient,
    PingFullnodeRequest,
};

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // List of fullnode endpoints to scan
    let targets = vec![
        "http://fullnode1.example.com:50051",
        "http://fullnode2.example.com:50051",
        "http://fullnode3.example.com:50051",
    ];
    
    for target in targets {
        let mut client = FullnodeDataClient::connect(target.clone()).await?;
        let response = client.ping(PingFullnodeRequest {}).await?;
        
        if let Some(info) = response.into_inner().info {
            println!("Target: {}", target);
            println!("  Chain ID: {}", info.chain_id);
            println!("  Latest Version: {:?}", info.known_latest_version);
            println!("  Timestamp: {:?}", info.timestamp);
            
            // Identify nodes behind sync for targeting
            if let Some(version) = info.known_latest_version {
                if version < expected_latest_version {
                    println!("  ⚠️  NODE IS BEHIND - VULNERABLE TO TARGETING");
                }
            }
        }
    }
    
    Ok(())
}
```

## Notes

This vulnerability is correctly classified as Low severity because the information disclosure itself does not directly compromise system security. However, it violates the principle of least privilege by exposing operational data without access controls to untrusted parties. The "internal" naming in the protobuf package (`aptos.internal.fullnode.v1`) suggests this exposure may be unintentional. While network-level controls (firewalls) can mitigate this, defense-in-depth principles recommend authentication at the application layer as well.

### Citations

**File:** protos/rust/src/pb/aptos.indexer.v1.rs (L223-230)
```rust
pub struct FullnodeInfo {
    #[prost(uint64, tag="1")]
    pub chain_id: u64,
    #[prost(message, optional, tag="2")]
    pub timestamp: ::core::option::Option<super::super::util::timestamp::Timestamp>,
    #[prost(uint64, optional, tag="3")]
    pub known_latest_version: ::core::option::Option<u64>,
}
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/fullnode_data_service.rs (L207-242)
```rust
    async fn ping(
        &self,
        _request: Request<PingFullnodeRequest>,
    ) -> Result<Response<PingFullnodeResponse>, Status> {
        let timestamp = timestamp_now_proto();
        let known_latest_version = self
            .service_context
            .context
            .db
            .get_synced_version()
            .map_err(|e| Status::internal(format!("{e}")))?;

        let table_info_version = self
            .service_context
            .context
            .indexer_reader
            .as_ref()
            .and_then(|r| r.get_latest_table_info_ledger_version().ok().flatten());

        if known_latest_version.is_some() && table_info_version.is_some() {
            let version = std::cmp::min(known_latest_version.unwrap(), table_info_version.unwrap());
            if let Ok(timestamp_us) = self.service_context.context.db.get_block_timestamp(version) {
                let latency = SystemTime::now().duration_since(UNIX_EPOCH).unwrap()
                    - Duration::from_micros(timestamp_us);
                LATENCY_MS.set(latency.as_millis() as i64);
            }
        }

        let info = FullnodeInfo {
            chain_id: self.service_context.context.chain_id().id() as u64,
            timestamp: Some(timestamp),
            known_latest_version,
        };
        let response = PingFullnodeResponse { info: Some(info) };
        Ok(Response::new(response))
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/runtime.rs (L108-112)
```rust
                let svc = FullnodeDataServer::new(server)
                    .send_compressed(CompressionEncoding::Zstd)
                    .accept_compressed(CompressionEncoding::Zstd)
                    .accept_compressed(CompressionEncoding::Gzip);
                tonic_server.add_service(svc)
```
