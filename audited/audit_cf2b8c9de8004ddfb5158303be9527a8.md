# Audit Report

## Title
V2 Module Events Lack Replay Protection Causing External Indexer Data Loss

## Summary
V2 module events (including `RoyaltyMutate`) lack replay protection mechanisms (sequence numbers, nonces, or transaction hashes) in their event data structure. When combined with the external indexer's schema design, this causes later events to overwrite earlier ones, resulting in data loss and incomplete event history. [1](#0-0) 

## Finding Description

The `RoyaltyMutate` V2 module event structure contains only mutation data (creator, collection, token, old/new royalty values) without any replay protection fields. When the `module_event_migration_enabled()` feature is active, these V2 events are emitted instead of V1 `RoyaltyMutateEvent`. [2](#0-1) 

When V2 events are exposed through the API, they are assigned dummy values for identification: [3](#0-2) [4](#0-3) 

The external indexer's `events` table uses `(account_address, creation_number, sequence_number)` as its primary key: [5](#0-4) 

All events (V1 and V2) are inserted into this table: [6](#0-5) 

When a primary key conflict occurs (multiple V2 events with identical dummy GUID/sequence), the indexer performs an UPDATE operation that overwrites the previous event: [7](#0-6) 

**Attack Flow:**
1. Token creator emits first `RoyaltyMutate` event at transaction version 100
2. Indexer stores: `(0x0, 0, 0, version=100, data=event1)`
3. Creator emits second `RoyaltyMutate` event at transaction version 200
4. Indexer attempts to insert `(0x0, 0, 0, version=200, data=event2)`
5. Primary key conflict triggers UPDATE
6. First event is overwritten and lost; only event2 remains

## Impact Explanation

This issue causes **data loss in external indexers**, resulting in incomplete event history. Applications relying on indexer data for royalty tracking will have:
- Missing historical royalty mutations
- Only the most recent mutation visible
- Inability to reconstruct full mutation history

While this doesn't directly meet Critical/High severity criteria (no fund loss, consensus breaks, or validator impact), it falls under **Medium severity** as it creates "state inconsistencies requiring intervention" in the indexer infrastructure. However, since indexers are off-chain components, this may be considered a design limitation rather than a core protocol vulnerability.

## Likelihood Explanation

This occurs with 100% certainty when:
1. Module event migration feature is enabled
2. Multiple royalty mutations occur for any token across different transactions
3. External indexers use the default processor schema

The issue is inherent to the current V2 event design and indexer schema mismatch, not requiring any malicious actor.

## Recommendation

**Option 1: Use Proper V2 Event Indexing**
V2 events should be indexed using `(transaction_version, event_index)` as the primary key, similar to the `token_activities_v2` table: [8](#0-7) 

**Option 2: Add Sequence Numbers to V2 Events**
The internal indexer already translates V2 events back to V1 with proper sequence numbers: [9](#0-8) 

External indexers could implement similar translation logic or V2 events could include sequence numbers in their data structure.

**Option 3: Separate V2 Events Table**
Create a dedicated `events_v2` table with primary key `(transaction_version, event_index, type)` for all V2 module events.

## Proof of Concept

```rust
// Pseudo-code demonstrating the issue
// Transaction 1
emit_token_royalty_mutate_event(creator, "Collection", "Token", 10, 100, addr1, 20, 100, addr2);
// Indexer stores: (0x0, 0, 0, v=1, ...)

// Transaction 2  
emit_token_royalty_mutate_event(creator, "Collection", "Token", 20, 100, addr2, 30, 100, addr3);
// Indexer performs UPDATE on (0x0, 0, 0)
// Transaction 1 event is lost

// Query indexer: only transaction 2 event visible
// Historical mutation from transaction 1 is permanently lost
```

## Notes

Upon strict validation against the bounty criteria, while this is a genuine implementation issue causing data loss, it may not qualify as a security vulnerability because:
- It affects off-chain indexer infrastructure, not core consensus
- No attacker exploitation required (normal system operation)
- No direct fund loss, consensus violation, or availability impact

This is more accurately characterized as a **design limitation** where V2 event architecture is incompatible with the V1-oriented indexer schema. The issue is known and V2-specific tables (like `token_activities_v2`) already use the correct primary key approach.

### Citations

**File:** types/src/account_config/events/royalty_mutate.rs (L16-27)
```rust
#[derive(Debug, Deserialize, Serialize)]
pub struct RoyaltyMutate {
    creator: AccountAddress,
    collection: String,
    token: String,
    old_royalty_numerator: u64,
    old_royalty_denominator: u64,
    old_royalty_payee_addr: AccountAddress,
    new_royalty_numerator: u64,
    new_royalty_denominator: u64,
    new_royalty_payee_addr: AccountAddress,
}
```

**File:** aptos-move/framework/aptos-token/sources/token_event_store.move (L475-487)
```text
        if (std::features::module_event_migration_enabled()) {
            event::emit(
                RoyaltyMutate {
                    creator: creator_addr,
                    collection,
                    token,
                    old_royalty_numerator,
                    old_royalty_denominator,
                    old_royalty_payee_addr,
                    new_royalty_numerator,
                    new_royalty_denominator,
                    new_royalty_payee_addr,
                });
```

**File:** api/types/src/transaction.rs (L48-52)
```rust
static DUMMY_GUID: Lazy<EventGuid> = Lazy::new(|| EventGuid {
    creation_number: U64::from(0u64),
    account_address: Address::from(AccountAddress::ZERO),
});
static DUMMY_SEQUENCE_NUMBER: Lazy<U64> = Lazy::new(|| U64::from(0));
```

**File:** api/types/src/transaction.rs (L886-891)
```rust
            ContractEvent::V2(v2) => Self {
                guid: *DUMMY_GUID,
                sequence_number: *DUMMY_SEQUENCE_NUMBER,
                typ: v2.type_tag().into(),
                data,
            },
```

**File:** crates/indexer/src/schema.rs (L509-521)
```rust
    events (account_address, creation_number, sequence_number) {
        sequence_number -> Int8,
        creation_number -> Int8,
        #[max_length = 66]
        account_address -> Varchar,
        transaction_version -> Int8,
        transaction_block_height -> Int8,
        #[sql_name = "type"]
        type_ -> Text,
        data -> Jsonb,
        inserted_at -> Timestamp,
        event_index -> Nullable<Int8>,
    }
```

**File:** crates/indexer/src/models/transactions.rs (L141-145)
```rust
                    EventModel::from_events(
                        &user_txn.events,
                        user_txn.info.version.0 as i64,
                        block_height,
                    ),
```

**File:** crates/indexer/src/processors/default_processor.rs (L287-292)
```rust
                .on_conflict((account_address, creation_number, sequence_number))
                .do_update()
                .set((
                    inserted_at.eq(excluded(inserted_at)),
                    event_index.eq(excluded(event_index)),
                )),
```

**File:** crates/indexer/src/models/token_models/v2_token_activities.rs (L23-24)
```rust
#[diesel(primary_key(transaction_version, event_index))]
#[diesel(table_name = token_activities_v2)]
```

**File:** storage/indexer/src/event_v2_translator.rs (L1245-1286)
```rust
struct RoyaltyMutateTranslator;
impl EventV2Translator for RoyaltyMutateTranslator {
    fn translate_event_v2_to_v1(
        &self,
        v2: &ContractEventV2,
        engine: &EventV2TranslationEngine,
    ) -> Result<ContractEventV1> {
        let royalty_mutation = RoyaltyMutate::try_from_bytes(v2.event_data())?;
        let struct_tag = StructTag::from_str("0x3::token_event_store::TokenEventStoreV1")?;
        let (key, sequence_number) = if let Some(state_value_bytes) =
            engine.get_state_value_bytes_for_resource(royalty_mutation.creator(), &struct_tag)?
        {
            let object_resource: TokenEventStoreV1Resource = bcs::from_bytes(&state_value_bytes)?;
            let key = *object_resource.royalty_mutate_events().key();
            let sequence_number = engine
                .get_next_sequence_number(&key, object_resource.royalty_mutate_events().count())?;
            (key, sequence_number)
        } else {
            // If the TokenEventStoreV1 resource is not found, we skip the event translation to
            // avoid panic because the creation number cannot be decided.
            return Err(AptosDbError::from(anyhow::format_err!(
                "TokenEventStoreV1 resource not found"
            )));
        };
        let royalty_mutation_event = RoyaltyMutateEvent::new(
            *royalty_mutation.creator(),
            royalty_mutation.collection().clone(),
            royalty_mutation.token().clone(),
            *royalty_mutation.old_royalty_numerator(),
            *royalty_mutation.old_royalty_denominator(),
            *royalty_mutation.old_royalty_payee_addr(),
            *royalty_mutation.new_royalty_numerator(),
            *royalty_mutation.new_royalty_denominator(),
            *royalty_mutation.new_royalty_payee_addr(),
        );
        Ok(ContractEventV1::new(
            key,
            sequence_number,
            ROYALTY_MUTATE_EVENT_TYPE.clone(),
            bcs::to_bytes(&royalty_mutation_event)?,
        )?)
    }
```
