# Audit Report

## Title
REST Client Version Rollback Attack: Malicious API Server Can Provide Stale Ledger State

## Summary
The Aptos REST client (`aptos-rest-client`) accepts ledger version numbers from API server HTTP headers without validating them against previously seen versions. A malicious or compromised API server can provide lower version numbers, causing clients to accept stale blockchain state and potentially submit transactions based on outdated information (e.g., sequence numbers, account balances).

## Finding Description

The `State::from_headers()` function blindly extracts ledger metadata from HTTP response headers without any version monotonicity validation: [1](#0-0) 

The function parses headers including `X-Aptos-Ledger-Version`, `X-Aptos-Epoch`, `X-Aptos-Block-Height`, and `X-Aptos-Ledger-Timestamp` without checking if these values represent progression from previous responses. The `Client` struct maintains no state tracking: [2](#0-1) 

The `check_response()` function calls `parse_state()` which directly invokes `State::from_headers()` with no validation: [3](#0-2) [4](#0-3) 

While Aptos provides a `TrustedState` mechanism that enforces version monotonicity and rejects stale responses: [5](#0-4) 

The REST client does not use this protection mechanism at all.

**Attack Scenario:**

1. Client queries API server at version 1000, receives account sequence number = 50
2. Client queries again, malicious server responds with version 900, sequence number = 45 (stale)
3. Client accepts the rolled-back state without validation
4. Client builds transaction with sequence number 45 (already used)
5. Transaction fails due to sequence number conflict OR if the sequence number gap allows, creates nonce confusion
6. Similar attacks work for account balances, resource states, and other critical data

This breaks the **State Consistency** invariant: clients must verify state authenticity and reject stale information.

## Impact Explanation

**High Severity** per Aptos Bug Bounty criteria:

1. **Significant Protocol Violations**: Clients accepting stale state violates fundamental trust assumptions in client-server architectures. The client believes it has current ledger state but is operating on outdated information.

2. **Transaction Failures**: Applications using sequence numbers from stale state will experience transaction rejections: [6](#0-5) 

3. **Financial Impact**: Applications checking account balances before transfers may receive stale balance information, leading to failed transactions or incorrect business logic.

4. **Trust Model Violation**: Users trust that REST API responses represent current blockchain state. Version rollback attacks undermine this fundamental assumption without any client-side detection.

5. **No Built-in Mitigation**: Unlike light client implementations that use `TrustedState`, REST clients have zero protection against this attack class.

## Likelihood Explanation

**HIGH Likelihood**:

1. **Simple to Execute**: Any compromised or malicious API server can trivially manipulate HTTP headers. No cryptographic attacks or complex exploits required.

2. **Wide Attack Surface**: Every REST client interaction is vulnerable:
   - Account queries
   - Resource lookups  
   - Transaction submission preparation
   - Balance checks
   - State synchronization

3. **No Detection**: Clients have no mechanism to detect version rollbacks since they don't track previous versions.

4. **Realistic Threat Model**: Compromised infrastructure, malicious load balancer configurations, or intentionally malicious API providers can all execute this attack.

5. **Deployment Pattern**: Many applications use third-party API providers rather than running their own nodes, increasing exposure to malicious servers.

## Recommendation

Implement version monotonicity validation in the REST client by:

**Option 1: Add State Tracking to Client (Recommended)**

```rust
#[derive(Clone, Debug)]
pub struct Client {
    inner: ReqwestClient,
    base_url: Url,
    version_path_base: String,
    last_seen_version: Arc<AtomicU64>, // Track highest seen version
}

impl Client {
    async fn check_response(
        &self,
        response: reqwest::Response,
    ) -> AptosResult<(reqwest::Response, State)> {
        if !response.status().is_success() {
            Err(parse_error(response).await)
        } else {
            let state = parse_state(&response)?;
            
            // Validate version monotonicity
            let current_version = state.version;
            let last_version = self.last_seen_version.load(Ordering::Acquire);
            
            if current_version < last_version {
                return Err(RestError::Unknown(anyhow!(
                    "Version rollback detected: current version {} < last seen version {}. \
                    Possible malicious API server or state synchronization issue.",
                    current_version, last_version
                )));
            }
            
            // Update highest seen version
            self.last_seen_version.fetch_max(current_version, Ordering::Release);
            
            Ok((response, state))
        }
    }
}
```

**Option 2: Integrate TrustedState**

Leverage the existing `TrustedState` mechanism already present in the codebase for light clients, adapting it for REST client use.

**Option 3: Warning Mode**

If breaking changes are unacceptable, add warning logs when version decreases are detected, allowing applications to detect anomalies.

## Proof of Concept

```rust
#[cfg(test)]
mod version_rollback_test {
    use super::*;
    use mockito::{mock, Mock};
    use aptos_api_types::*;
    
    #[tokio::test]
    async fn test_version_rollback_attack() {
        // Setup mock server
        let mut server = mockito::Server::new_async().await;
        let base_url = server.url().parse().unwrap();
        
        // First response: version 1000
        let _mock1 = server.mock("GET", "/v1/")
            .with_status(200)
            .with_header(X_APTOS_CHAIN_ID, "1")
            .with_header(X_APTOS_LEDGER_VERSION, "1000")
            .with_header(X_APTOS_LEDGER_TIMESTAMP, "1234567890000000")
            .with_header(X_APTOS_EPOCH, "10")
            .with_header(X_APTOS_LEDGER_OLDEST_VERSION, "0")
            .with_header(X_APTOS_BLOCK_HEIGHT, "500")
            .with_header(X_APTOS_OLDEST_BLOCK_HEIGHT, "0")
            .with_body(r#"{"chain_id":1,"epoch":"10","ledger_version":"1000","oldest_ledger_version":"0","ledger_timestamp":"1234567890000000","node_role":"full_node","oldest_block_height":"0","block_height":"500","git_hash":null}"#)
            .create_async()
            .await;
        
        let client = Client::new(base_url.clone());
        let state1 = client.get_ledger_information().await.unwrap();
        assert_eq!(state1.inner().version, 1000);
        
        // Second response: version 900 (ROLLBACK!)
        let _mock2 = server.mock("GET", "/v1/")
            .with_status(200)
            .with_header(X_APTOS_CHAIN_ID, "1")
            .with_header(X_APTOS_LEDGER_VERSION, "900") // Version decreased!
            .with_header(X_APTOS_LEDGER_TIMESTAMP, "1234567880000000")
            .with_header(X_APTOS_EPOCH, "10")
            .with_header(X_APTOS_LEDGER_OLDEST_VERSION, "0")
            .with_header(X_APTOS_BLOCK_HEIGHT, "450")
            .with_header(X_APTOS_OLDEST_BLOCK_HEIGHT, "0")
            .with_body(r#"{"chain_id":1,"epoch":"10","ledger_version":"900","oldest_ledger_version":"0","ledger_timestamp":"1234567880000000","node_role":"full_node","oldest_block_height":"0","block_height":"450","git_hash":null}"#)
            .create_async()
            .await;
        
        // BUG: Client accepts rolled-back version without error
        let state2 = client.get_ledger_information().await.unwrap();
        assert_eq!(state2.inner().version, 900); // Stale state accepted!
        
        // This should have failed with version rollback error
        // but currently succeeds, demonstrating the vulnerability
    }
}
```

**Notes**

The vulnerability exists because the REST client is designed as a stateless wrapper around HTTP requests, prioritizing simplicity over security. However, this design decision creates a fundamental trust issue: clients cannot distinguish between legitimate state and maliciously rolled-back state. The existing `TrustedState` implementation in the codebase demonstrates that Aptos developers understand the importance of version monotonicity validation for light clients, but this protection was never extended to the REST client.

This is a genuine **High Severity** vulnerability that violates the State Consistency invariant and enables realistic attacks against applications using the Aptos REST client to interact with potentially untrusted API servers.

### Citations

**File:** crates/aptos-rest-client/src/state.rs (L23-102)
```rust
    pub fn from_headers(headers: &reqwest::header::HeaderMap) -> anyhow::Result<Self> {
        let maybe_chain_id = headers
            .get(X_APTOS_CHAIN_ID)
            .and_then(|h| h.to_str().ok())
            .and_then(|s| s.parse().ok());
        let maybe_version = headers
            .get(X_APTOS_LEDGER_VERSION)
            .and_then(|h| h.to_str().ok())
            .and_then(|s| s.parse().ok());
        let maybe_timestamp = headers
            .get(X_APTOS_LEDGER_TIMESTAMP)
            .and_then(|h| h.to_str().ok())
            .and_then(|s| s.parse().ok());
        let maybe_epoch = headers
            .get(X_APTOS_EPOCH)
            .and_then(|h| h.to_str().ok())
            .and_then(|s| s.parse().ok());
        let maybe_oldest_ledger_version = headers
            .get(X_APTOS_LEDGER_OLDEST_VERSION)
            .and_then(|h| h.to_str().ok())
            .and_then(|s| s.parse().ok());
        let maybe_block_height = headers
            .get(X_APTOS_BLOCK_HEIGHT)
            .and_then(|h| h.to_str().ok())
            .and_then(|s| s.parse().ok());
        let maybe_oldest_block_height = headers
            .get(X_APTOS_OLDEST_BLOCK_HEIGHT)
            .and_then(|h| h.to_str().ok())
            .and_then(|s| s.parse().ok());
        let cursor = headers
            .get(X_APTOS_CURSOR)
            .and_then(|h| h.to_str().ok())
            .map(|s| s.to_string());

        let state = if let (
            Some(chain_id),
            Some(version),
            Some(timestamp_usecs),
            Some(epoch),
            Some(oldest_ledger_version),
            Some(block_height),
            Some(oldest_block_height),
            cursor,
        ) = (
            maybe_chain_id,
            maybe_version,
            maybe_timestamp,
            maybe_epoch,
            maybe_oldest_ledger_version,
            maybe_block_height,
            maybe_oldest_block_height,
            cursor,
        ) {
            Self {
                chain_id,
                epoch,
                version,
                timestamp_usecs,
                oldest_ledger_version,
                block_height,
                oldest_block_height,
                cursor,
            }
        } else {
            anyhow::bail!(
                "Failed to build State from headers due to missing values in response. \
                Chain ID: {:?}, Version: {:?}, Timestamp: {:?}, Epoch: {:?}, \
                Oldest Ledger Version: {:?}, Block Height: {:?} Oldest Block Height: {:?}",
                maybe_chain_id,
                maybe_version,
                maybe_timestamp,
                maybe_epoch,
                maybe_oldest_ledger_version,
                maybe_block_height,
                maybe_oldest_block_height,
            )
        };

        Ok(state)
    }
```

**File:** crates/aptos-rest-client/src/lib.rs (L80-85)
```rust
#[derive(Clone, Debug)]
pub struct Client {
    inner: ReqwestClient,
    base_url: Url,
    version_path_base: String,
}
```

**File:** crates/aptos-rest-client/src/lib.rs (L1645-1656)
```rust
    async fn check_response(
        &self,
        response: reqwest::Response,
    ) -> AptosResult<(reqwest::Response, State)> {
        if !response.status().is_success() {
            Err(parse_error(response).await)
        } else {
            let state = parse_state(&response)?;

            Ok((response, state))
        }
    }
```

**File:** crates/aptos-rest-client/src/lib.rs (L1976-1978)
```rust
fn parse_state(response: &reqwest::Response) -> AptosResult<State> {
    Ok(State::from_headers(response.headers())?)
}
```

**File:** types/src/trusted_state.rs (L147-159)
```rust
    pub fn verify_and_ratchet_inner<'a>(
        &self,
        latest_li: &'a LedgerInfoWithSignatures,
        epoch_change_proof: &'a EpochChangeProof,
    ) -> Result<TrustedStateChange<'a>> {
        // Abort early if the response is stale.
        let curr_version = self.version();
        let target_version = latest_li.ledger_info().version();
        ensure!(
            target_version >= curr_version,
            "The target latest ledger info version is stale ({}) and behind our current trusted version ({})",
            target_version, curr_version,
        );
```

**File:** crates/aptos/src/common/utils.rs (L287-293)
```rust
/// Retrieves sequence number from the rest client
pub async fn get_sequence_number(
    client: &aptos_rest_client::Client,
    address: AccountAddress,
) -> CliTypedResult<u64> {
    Ok(get_account(client, address).await?.sequence_number)
}
```
