# Audit Report

## Title
Critical Information Leakage: Unauthenticated Peer Information Endpoint Enables Complete Network Topology Mapping and Validator Targeting

## Summary
The Aptos inspection service exposes a `/peer_information` endpoint that is enabled by default, requires no authentication, and leaks comprehensive network topology information including validator IP addresses, connection graphs, and trusted peer lists. Attackers can correlate data from multiple nodes to build a complete network map and identify high-value attack targets.

## Finding Description

The vulnerability exists in the inspection service's peer information endpoint, which aggregates and exposes sensitive network data through multiple display functions without any access control.

**Configuration Weakness:**

The `expose_peer_information` configuration defaults to `true`, and critically, the config sanitizer only validates `expose_configuration` for mainnet validators but does NOT validate `expose_peer_information`. [1](#0-0) [2](#0-1) 

**No Authentication:**

The endpoint has zero authentication mechanisms. Any attacker can send HTTP GET requests to `<node_ip>:9101/peer_information`. [3](#0-2) 

**Information Leakage via Multiple Display Functions:**

The endpoint exposes sensitive data through several functions that can be correlated:

1. **Trusted Peers with Network Addresses** - Exposes complete validator set and seed peers with their IP addresses and public keys: [4](#0-3) 

The `Peer` structure contains network addresses (IP:port), x25519 public keys, and roles: [5](#0-4) 

2. **Connection Metadata with IP Addresses** - Serializes connection metadata as JSON including NetworkAddress: [6](#0-5) [7](#0-6) 

3. **Network Information Response with Connected Peers Map** - The most critical leak occurs in detailed monitoring metadata which uses Debug formatting and includes `NetworkInformationResponse`: [8](#0-7) 

The `PeerMonitoringMetadata` contains `latest_network_info_response`: [9](#0-8) 

The `NetworkInformationResponse` contains a complete map of all connected peers with their network addresses: [10](#0-9) 

This map is populated by extracting connection metadata including IP addresses from all connected peers: [11](#0-10) 

4. **State Sync Metadata** - Reveals priority/regular peer classification, scores, and request patterns: [12](#0-11) 

**Attack Execution:**

1. Attacker queries `/peer_information` on multiple publicly accessible Aptos nodes
2. From each response, extract:
   - Trusted peers list (validators with IP addresses and roles)
   - `NetworkInformationResponse.connected_peers` map showing each node's peer connections
   - Connection metadata with network addresses
   - State sync peer classifications
3. Correlate data across multiple nodes to construct complete network topology
4. Identify validators by `PeerRole::Validator` and map their IP addresses
5. Identify critical network hubs and connection patterns
6. Execute targeted attacks: DDoS on validator IPs, eclipse attacks to isolate nodes, or strategic attacks to disrupt consensus

## Impact Explanation

**Critical Severity** - This vulnerability meets multiple criteria from the Aptos bug bounty program:

1. **Enables Consensus Disruption**: By identifying validator IP addresses and network topology, attackers can execute targeted attacks to disrupt consensus, potentially causing network partitioning or liveness failures.

2. **Network Protocol Attack Vector**: This is a severe network protocol vulnerability that exposes the entire validator network infrastructure, enabling sophisticated attacks like eclipse attacks, Sybil positioning, and strategic node isolation.

3. **No Privilege Required**: Unlike theoretical attacks requiring validator collusion, any external attacker can exploit this by simply querying public HTTP endpoints.

4. **Scale of Impact**: Affects the entire Aptos network as the vulnerability is present by default configuration, potentially exposing hundreds of validators and their infrastructure.

5. **Violates Core Security Principles**: Blockchain networks rely on validator anonymity and network topology obfuscation to resist targeted attacks. This leak completely undermines these defenses.

## Likelihood Explanation

**Very High Likelihood:**

1. **Default Configuration**: The endpoint is enabled by default (`expose_peer_information: true`)
2. **No Sanitizer Protection**: Unlike `expose_configuration`, there is no sanitizer preventing mainnet validators from exposing peer information
3. **Zero Skill Barrier**: Exploitation requires only basic HTTP requests - no cryptographic attacks, consensus manipulation, or sophisticated techniques
4. **Widespread Deployment**: Any node using default configuration is vulnerable, likely including many production validators
5. **Already Exploitable**: The vulnerability is present in the current codebase and can be exploited immediately

## Recommendation

Implement multiple defense layers:

1. **Disable by Default for Production**: Change the default value of `expose_peer_information` to `false`:

```rust
impl Default for InspectionServiceConfig {
    fn default() -> InspectionServiceConfig {
        InspectionServiceConfig {
            address: "0.0.0.0".to_string(),
            port: 9101,
            expose_configuration: false,
            expose_identity_information: true,
            expose_peer_information: false, // Changed from true
            expose_system_information: true,
        }
    }
}
```

2. **Add Sanitizer Enforcement**: Extend the sanitizer to prevent mainnet validators from exposing peer information:

```rust
impl ConfigSanitizer for InspectionServiceConfig {
    fn sanitize(
        node_config: &NodeConfig,
        node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();
        let inspection_service_config = &node_config.inspection_service;

        if let Some(chain_id) = chain_id {
            if node_type.is_validator() && chain_id.is_mainnet() {
                // Verify configuration is not exposed
                if inspection_service_config.expose_configuration {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name,
                        "Mainnet validators should not expose the node configuration!".to_string(),
                    ));
                }
                
                // NEW: Verify peer information is not exposed
                if inspection_service_config.expose_peer_information {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name,
                        "Mainnet validators should not expose peer information!".to_string(),
                    ));
                }
            }
        }

        Ok(())
    }
}
```

3. **Redact Sensitive Information**: If peer information must be exposed, remove sensitive fields from the response (network addresses, connected peer maps, trusted peer IPs).

4. **Add Authentication**: Implement authentication for the inspection service endpoints using tokens or IP allowlisting.

## Proof of Concept

```rust
// Simple HTTP client to exploit the vulnerability
use reqwest;
use std::collections::HashMap;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Target multiple Aptos nodes
    let target_nodes = vec![
        "http://validator1.aptos.network:9101",
        "http://validator2.aptos.network:9101",
        "http://fullnode1.aptos.network:9101",
    ];
    
    let mut network_topology: HashMap<String, Vec<String>> = HashMap::new();
    
    for node in target_nodes {
        let endpoint = format!("{}/peer_information", node);
        
        // No authentication required - just make the request
        let response = reqwest::get(&endpoint).await?;
        
        if response.status().is_success() {
            let peer_info = response.text().await?;
            
            // Parse response to extract:
            // 1. Trusted peers (validator set) with IP addresses
            // 2. Connected peers map from NetworkInformationResponse
            // 3. Connection metadata with network addresses
            
            println!("=== Node: {} ===", node);
            println!("{}", peer_info);
            
            // Extract validator IPs, connection graph, etc.
            // Store in network_topology map for correlation
        }
    }
    
    // Correlate data to build complete network map
    println!("\n=== Network Topology Reconstructed ===");
    // Display validator IPs, connection graph, attack targets
    
    Ok(())
}
```

**Exploitation Steps:**
1. Compile and run the PoC against accessible Aptos nodes
2. The output reveals complete network topology without any authentication
3. Identify validator IP addresses from `PeerRole::Validator` entries
4. Map connection graph from `connected_peers` data across multiple nodes
5. Use this intelligence to plan targeted attacks (DDoS validator IPs, eclipse specific nodes, etc.)

The vulnerability is immediately exploitable against any Aptos node with default configuration.

### Citations

**File:** config/src/config/inspection_service_config.rs (L26-36)
```rust
impl Default for InspectionServiceConfig {
    fn default() -> InspectionServiceConfig {
        InspectionServiceConfig {
            address: "0.0.0.0".to_string(),
            port: 9101,
            expose_configuration: false,
            expose_identity_information: true,
            expose_peer_information: true,
            expose_system_information: true,
        }
    }
```

**File:** config/src/config/inspection_service_config.rs (L45-68)
```rust
impl ConfigSanitizer for InspectionServiceConfig {
    fn sanitize(
        node_config: &NodeConfig,
        node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();
        let inspection_service_config = &node_config.inspection_service;

        // Verify that mainnet validators do not expose the configuration
        if let Some(chain_id) = chain_id {
            if node_type.is_validator()
                && chain_id.is_mainnet()
                && inspection_service_config.expose_configuration
            {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "Mainnet validators should not expose the node configuration!".to_string(),
                ));
            }
        }

        Ok(())
    }
```

**File:** crates/aptos-inspection-service/src/server/mod.rs (L103-169)
```rust
/// A simple helper function that handles each endpoint request
async fn serve_requests(
    req: Request<Body>,
    node_config: NodeConfig,
    aptos_data_client: AptosDataClient,
    peers_and_metadata: Arc<PeersAndMetadata>,
) -> Result<Response<Body>, hyper::Error> {
    // Process the request and get the response components
    let (status_code, body, content_type) = match req.uri().path() {
        CONFIGURATION_PATH => {
            // /configuration
            // Exposes the node configuration
            configuration::handle_configuration_request(&node_config)
        },
        CONSENSUS_HEALTH_CHECK_PATH => {
            // /consensus_health_check
            // Exposes the consensus health check
            metrics::handle_consensus_health_check(&node_config).await
        },
        FORGE_METRICS_PATH => {
            // /forge_metrics
            // Exposes forge encoded metrics
            metrics::handle_forge_metrics()
        },
        IDENTITY_INFORMATION_PATH => {
            // /identity_information
            // Exposes the identity information of the node
            identity_information::handle_identity_information_request(&node_config)
        },
        INDEX_PATH => {
            // /
            // Exposes the index and list of available endpoints
            index::handle_index_request()
        },
        JSON_METRICS_PATH => {
            // /json_metrics
            // Exposes JSON encoded metrics
            metrics::handle_json_metrics_request()
        },
        METRICS_PATH => {
            // /metrics
            // Exposes text encoded metrics
            metrics::handle_metrics_request()
        },
        PEER_INFORMATION_PATH => {
            // /peer_information
            // Exposes the peer information
            peer_information::handle_peer_information_request(
                &node_config,
                aptos_data_client,
                peers_and_metadata,
            )
        },
        SYSTEM_INFORMATION_PATH => {
            // /system_information
            // Exposes the system and build information
            system_information::handle_system_information_request(node_config)
        },
        _ => {
            // Handle the invalid path
            (
                StatusCode::NOT_FOUND,
                Body::from(INVALID_ENDPOINT_MESSAGE),
                CONTENT_TYPE_TEXT.into(),
            )
        },
    };
```

**File:** crates/aptos-inspection-service/src/server/peer_information.rs (L108-126)
```rust
/// Displays detailed peer monitoring metadata for each peer
fn display_detailed_monitoring_metadata(
    peer_information_output: &mut Vec<String>,
    all_peers: &Vec<PeerNetworkId>,
    peers_and_metadata: &PeersAndMetadata,
) {
    peer_information_output.push("Detailed monitoring metadata for each peer:".into());

    // Fetch and display the detailed metadata for each peer
    for peer in all_peers {
        if let Ok(peer_metadata) = peers_and_metadata.get_metadata_for_peer(*peer) {
            let peer_monitoring_metadata = peer_metadata.get_peer_monitoring_metadata();
            peer_information_output.push(format!(
                "\t- Peer: {}, detailed metadata: {:?}", // Debug formatting for detailed metadata
                peer, peer_monitoring_metadata
            ));
        }
    }
}
```

**File:** crates/aptos-inspection-service/src/server/peer_information.rs (L148-168)
```rust
/// Displays connection metadata for each peer
fn display_peer_connection_metadata(
    peer_information_output: &mut Vec<String>,
    all_peers: &Vec<PeerNetworkId>,
    peers_and_metadata: &PeersAndMetadata,
) {
    peer_information_output.push("Connection metadata for each peer:".into());

    // Fetch and display the connection metadata for each peer
    for peer in all_peers {
        if let Ok(peer_metadata) = peers_and_metadata.get_metadata_for_peer(*peer) {
            let connection_metadata = peer_metadata.get_connection_metadata();
            peer_information_output.push(format!(
                "\t- Peer: {}, connection state: {:?}, connection metadata: {}",
                peer,
                peer_metadata.get_connection_state(),
                serde_json::to_string(&connection_metadata).unwrap_or_default()
            ));
        }
    }
}
```

**File:** crates/aptos-inspection-service/src/server/peer_information.rs (L205-271)
```rust
/// Displays state sync metadata for each peer
fn display_state_sync_metadata(
    peer_information_output: &mut Vec<String>,
    all_peers: &Vec<PeerNetworkId>,
    aptos_data_client: AptosDataClient,
) {
    peer_information_output.push("State sync metadata for each peer:".into());

    // Fetch and display the priority and regular peers
    if let Ok((priority_peers, regular_peers)) = aptos_data_client.get_priority_and_regular_peers()
    {
        // Sort the peer lists before displaying them
        let mut priority_peers: Vec<_> = priority_peers.into_iter().collect();
        priority_peers.sort();
        let mut regular_peers: Vec<_> = regular_peers.into_iter().collect();
        regular_peers.sort();

        // Display the priority and regular peers
        peer_information_output.push(format!(
            "\t- Priority peers: {:?}, regular peers: {:?}",
            priority_peers, regular_peers
        ));
    }

    // Fetch and display the global advertised data summary
    let global_data_summary = aptos_data_client.get_global_data_summary();
    peer_information_output.push(format!(
        "\t- Global advertised data summary: {:?}",
        global_data_summary
    ));

    // Fetch and display the state sync metadata for each peer
    let peer_to_state = aptos_data_client.get_peer_states().get_peer_to_states();
    for peer in all_peers {
        if let Some(peer_state_entry) = peer_to_state.get(peer) {
            // Get the peer states
            let peer = *peer_state_entry.key();
            let peer_bucket_id = peer_states::get_bucket_id_for_peer(peer);
            let peer_score = peer_state_entry.get_score();
            let peer_storage_summary = peer_state_entry.get_storage_summary();

            // Display the peer states
            peer_information_output.push(format!(
                "\t- Peer: {}, score: {}, bucket ID: {}",
                peer, peer_score, peer_bucket_id
            ));
            peer_information_output.push(format!(
                "\t\t- Advertised storage summary: {:?}",
                peer_storage_summary
            ));

            // Get the peer's request/response counts
            let sent_requests_by_type = peer_state_entry.get_sent_requests_by_type();
            let received_responses_by_type = peer_state_entry.get_received_responses_by_type();

            // Display the peer's request/response counts
            peer_information_output.push(format!(
                "\t\t- Sent requests by type: {:?}",
                sent_requests_by_type
            ));
            peer_information_output.push(format!(
                "\t\t- Received responses by type: {:?}",
                received_responses_by_type
            ));
        }
    }
}
```

**File:** crates/aptos-inspection-service/src/server/peer_information.rs (L273-300)
```rust
/// Displays the entire set of trusted peers
fn display_trusted_peers(
    peer_information_output: &mut Vec<String>,
    registered_networks: Vec<NetworkId>,
    peers_and_metadata: &PeersAndMetadata,
) {
    peer_information_output.push("Trusted peers (validator set & seeds):".into());

    // Fetch and display the trusted peers for each network
    for network in registered_networks {
        peer_information_output.push(format!("\t- Network: {}", network));
        if let Ok(trusted_peers) = peers_and_metadata.get_trusted_peers(&network) {
            // Sort the peers before displaying them
            let mut sorted_trusted_peers = BTreeMap::new();
            for (peer_id, peer_info) in trusted_peers {
                sorted_trusted_peers.insert(peer_id, peer_info);
            }

            // Display the trusted peers
            for (peer_id, peer_info) in sorted_trusted_peers {
                peer_information_output.push(format!(
                    "\t\t- Peer: {:?}, peer information: {:?}",
                    peer_id, peer_info
                ));
            }
        }
    }
}
```

**File:** config/src/config/network_config.rs (L457-464)
```rust
/// Represents a single seed configuration for a seed peer
#[derive(Clone, Debug, Default, Deserialize, PartialEq, Eq, Serialize)]
#[serde(default)]
pub struct Peer {
    pub addresses: Vec<NetworkAddress>,
    pub keys: HashSet<x25519::PublicKey>,
    pub role: PeerRole,
}
```

**File:** network/framework/src/transport/mod.rs (L98-108)
```rust
/// Metadata associated with an established and fully upgraded connection.
#[derive(Clone, Deserialize, Eq, PartialEq, Serialize)]
pub struct ConnectionMetadata {
    pub remote_peer_id: PeerId,
    pub connection_id: ConnectionId,
    pub addr: NetworkAddress,
    pub origin: ConnectionOrigin,
    pub messaging_protocol: MessagingProtocolVersion,
    pub application_protocols: ProtocolIdSet,
    pub role: PeerRole,
}
```

**File:** peer-monitoring-service/types/src/lib.rs (L44-51)
```rust
#[derive(Clone, Default, Deserialize, PartialEq, Serialize)]
pub struct PeerMonitoringMetadata {
    pub average_ping_latency_secs: Option<f64>, // The average latency ping for the peer
    pub latest_ping_latency_secs: Option<f64>,  // The latest latency ping for the peer
    pub latest_network_info_response: Option<NetworkInformationResponse>, // The latest network info response
    pub latest_node_info_response: Option<NodeInformationResponse>, // The latest node info response
    pub internal_client_state: Option<String>, // A detailed client state string for debugging and logging
}
```

**File:** peer-monitoring-service/types/src/response.rs (L50-55)
```rust
/// A response for the network information request
#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
pub struct NetworkInformationResponse {
    pub connected_peers: BTreeMap<PeerNetworkId, ConnectionMetadata>, // Connected peers
    pub distance_from_validators: u64, // The distance of the peer from the validator set
}
```

**File:** peer-monitoring-service/server/src/lib.rs (L217-247)
```rust
    fn get_network_information(&self) -> Result<PeerMonitoringServiceResponse, Error> {
        // Get the connected peers
        let connected_peers_and_metadata =
            self.peers_and_metadata.get_connected_peers_and_metadata()?;
        let connected_peers = connected_peers_and_metadata
            .into_iter()
            .map(|(peer, metadata)| {
                let connection_metadata = metadata.get_connection_metadata();
                (
                    peer,
                    ConnectionMetadata::new(
                        connection_metadata.addr,
                        connection_metadata.remote_peer_id,
                        connection_metadata.role,
                    ),
                )
            })
            .collect();

        // Get the distance from the validators
        let distance_from_validators =
            get_distance_from_validators(&self.base_config, self.peers_and_metadata.clone());

        // Create and return the response
        let network_information_response = NetworkInformationResponse {
            connected_peers,
            distance_from_validators,
        };
        Ok(PeerMonitoringServiceResponse::NetworkInformation(
            network_information_response,
        ))
```
