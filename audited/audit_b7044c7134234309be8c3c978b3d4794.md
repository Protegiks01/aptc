# Audit Report

## Title
Peer Capability Filtering Bypass Allows Malicious Nodes to Cause Repeated Synchronization Failures

## Summary
The `can_service_request` check in `identify_serviceable()` fails to validate peer-advertised storage capabilities, allowing malicious peers to claim they can service data requests they cannot fulfill. This causes repeated failed synchronization attempts, resource exhaustion, and significant validator node slowdowns.

## Finding Description

The vulnerability exists in the state synchronization peer filtering mechanism. When a node needs to synchronize blockchain data, it filters peers based on their advertised storage capabilities. However, these capabilities are self-reported by peers without cryptographic proof or cross-validation.

**Attack Flow:**

1. **Peer Discovery & Polling**: The data client periodically polls connected peers for their storage summaries via `GetStorageServerSummary` requests. [1](#0-0) 

2. **Blind Trust**: The client receives the peer's `StorageServerSummary` and stores it without any validation. [2](#0-1) 

3. **Filtering Based on False Claims**: When selecting peers to service data requests, the `identify_serviceable()` function filters peers using their stored (potentially false) storage summaries. [3](#0-2) 

4. **Capability Check Uses Self-Reported Data**: The `can_service_request` method checks if the peer can service the request based solely on the peer's claimed data ranges. [4](#0-3) 

5. **Request Failure**: When the actual data request is sent, the malicious peer's server-side validation fails (because it checks its actual storage, not its false advertisement), causing the request to fail. [5](#0-4) 

6. **Inadequate Penalty**: The failed request reduces the peer's score by only 5% (multiplied by 0.95), requiring approximately 14 consecutive failures before the peer is ignored. [6](#0-5) 

**Malicious Scenario:**

A malicious peer advertises a `StorageServerSummary` claiming to have complete data ranges (e.g., transactions 0-1000000, states 0-1000000) when it actually has no data or only partial ranges. The client's filtering logic selects this peer for sync requests, which then fail when the server-side validation catches the mismatch. The client must retry with other peers, wasting time and bandwidth on each attempt.

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos bug bounty program for the following reasons:

**Validator Node Slowdowns**: Nodes attempting to synchronize state (especially bootstrapping nodes or nodes catching up after downtime) will experience significant delays. Each failed sync attempt wastes:
- Network bandwidth on the initial peer selection and request
- CPU cycles on request processing and error handling  
- Time waiting for timeouts or error responses
- Resources on retry logic and peer reselection

**Significant Protocol Violations**: The state synchronization protocol assumes peers honestly advertise their capabilities. This attack violates that assumption, causing protocol-level failures that propagate through the entire sync pipeline.

**Resource Exhaustion**: With multiple malicious peers coordinating attacks, a node could spend most of its time retrying failed requests rather than making actual sync progress. Given ~14 failures per peer before ignoring, and the ability for peers to periodically provide valid responses to reset their scores, this attack can be sustained indefinitely.

**Amplification Effect**: The impact multiplies if:
- Multiple malicious peers coordinate the attack
- Malicious peers target specific critical data ranges (e.g., recent epochs)
- The network has a high percentage of malicious public fullnodes

## Likelihood Explanation

**High Likelihood** due to:

1. **Low Attacker Barrier**: Any peer can participate in the network and advertise false storage summaries. No privileged access, stake, or validator status required.

2. **No Detection Mechanism**: There is no cross-validation of storage summaries between peers or against trusted sources. The client has no way to detect false advertisements until attempting to fetch data.

3. **Sustainable Attack**: The slow score degradation (0.95 multiplier per failure) allows malicious peers to cause 13-14 failed requests before being ignored. Peers can periodically provide valid responses to maintain acceptable scores.

4. **Network Exposure**: Public fullnodes are particularly vulnerable as they rely heavily on other public fullnodes for state sync, many of which could be controlled by attackers.

5. **Bootstrapping Vulnerability**: New nodes joining the network are most vulnerable during initial synchronization when they have no historical peer behavior data to reference.

## Recommendation

Implement cryptographic validation of storage summaries and add proactive verification:

**1. Add Merkle Proof Validation**: Require peers to provide cryptographic proofs of their claimed data ranges tied to known trusted ledger infos.

**2. Implement Cross-Validation**: Before trusting a peer's storage summary, cross-validate claimed ranges against multiple peers and check for consensus.

**3. Increase Penalties for False Claims**: When a peer fails to service a request it claimed it could service, apply a much harsher penalty (e.g., 0.5 multiplier instead of 0.95) and potentially temporary ban.

**4. Add Sampling Verification**: Periodically send probe requests to verify peers actually have the data they claim, independent of sync requests.

**5. Enhanced Code Fix**:

In `peer_states.rs`, add validation logic:
```rust
pub fn can_service_request(
    &self,
    peer: &PeerNetworkId,
    time_service: TimeService,
    request: &StorageServiceRequest,
) -> bool {
    // Existing checks...
    
    if let Some(peer_state) = self.peer_to_state.get(peer) {
        return match peer_state.get_storage_summary_if_not_ignored() {
            Some(storage_summary) => {
                // Check if peer can service request
                let can_service = storage_summary.can_service(&self.data_client_config, time_service, request);
                
                // If this is a critical request, require recent verification
                if can_service && requires_verification(request) {
                    return peer_state.is_recently_verified();
                }
                
                can_service
            },
            None => false,
        };
    }
    false
}
```

In `peer_states.rs`, update error handling:
```rust
const CLAIM_FAILURE_MULTIPLIER: f64 = 0.5; // Harsh penalty for false claims

fn update_score_error(&mut self, error: ErrorType) {
    let multiplier = match error {
        ErrorType::NotUseful => NOT_USEFUL_MULTIPLIER,
        ErrorType::Malicious => MALICIOUS_MULTIPLIER,
        ErrorType::FalseClaim => CLAIM_FAILURE_MULTIPLIER, // New variant
    };
    self.score = f64::max(self.score * multiplier, MIN_SCORE);
}
```

## Proof of Concept

```rust
// Integration test demonstrating the vulnerability
#[tokio::test]
async fn test_malicious_peer_false_storage_advertisement() {
    use aptos_config::config::AptosDataClientConfig;
    use aptos_storage_service_types::{
        requests::{DataRequest, TransactionsWithProofRequest},
        responses::{CompleteDataRange, DataSummary, StorageServerSummary, ProtocolMetadata},
    };
    
    // Create a data client with default config
    let data_client_config = AptosDataClientConfig::default();
    let (data_client, poller) = create_test_data_client(data_client_config);
    
    // Add a malicious peer to the network
    let malicious_peer = create_test_peer(NetworkId::Public);
    
    // Malicious peer advertises false storage capabilities
    let false_summary = StorageServerSummary {
        protocol_metadata: ProtocolMetadata::default(),
        data_summary: DataSummary {
            synced_ledger_info: Some(create_test_ledger_info(1000000)),
            transactions: Some(CompleteDataRange::new(0, 1000000).unwrap()),
            transaction_outputs: Some(CompleteDataRange::new(0, 1000000).unwrap()),
            states: Some(CompleteDataRange::new(0, 1000000).unwrap()),
            epoch_ending_ledger_infos: Some(CompleteDataRange::new(0, 100).unwrap()),
        },
    };
    
    // Client stores the false summary without validation
    data_client.update_peer_storage_summary(malicious_peer, false_summary.clone());
    
    // Client attempts to sync transactions from malicious peer
    let mut failed_attempts = 0;
    for i in 0..20 {
        // Create a request that the malicious peer claims to service
        let request = StorageServiceRequest::new(
            DataRequest::GetTransactionsWithProof(TransactionsWithProofRequest {
                start_version: 0,
                end_version: 1000,
                proof_version: 1000,
                include_events: false,
            }),
            false
        );
        
        // Peer passes the can_service_request filter (VULNERABILITY)
        let peers = data_client.choose_peers_for_request(&request).unwrap();
        assert!(peers.contains(&malicious_peer), 
            "Malicious peer should be selected based on false claims");
        
        // Actual request fails because peer doesn't have the data
        let result = data_client
            .send_request_to_peer_and_decode::<TransactionListWithProofV2, _>(
                malicious_peer,
                request,
                5000
            )
            .await;
        
        if result.is_err() {
            failed_attempts += 1;
        }
        
        // Check if peer is still being selected after multiple failures
        if i < 13 {
            // Peer should still be selectable (score hasn't dropped below threshold)
            let peer_state = data_client.get_peer_states()
                .get_peer_to_states()
                .get(&malicious_peer)
                .unwrap();
            assert!(!peer_state.is_ignored(), 
                "Peer should not be ignored yet after {} failures", i + 1);
        }
    }
    
    // Demonstrate that multiple sync attempts were wasted
    assert!(failed_attempts >= 13, 
        "At least 13 sync attempts should fail before peer is ignored");
    
    println!("VULNERABILITY CONFIRMED: Malicious peer caused {} failed sync attempts \
              before being ignored, wasting network bandwidth and sync time", failed_attempts);
}
```

## Notes

This vulnerability is particularly dangerous because:

1. **No Cryptographic Security**: The entire peer capability system relies on trust without cryptographic verification.

2. **Asymmetric Impact**: A small number of malicious peers can significantly impact many honest nodes trying to sync.

3. **Attack Persistence**: Malicious peers can maintain their attack by occasionally providing valid responses, keeping their scores above the ignore threshold.

4. **Bootstrapping Nodes Most Vulnerable**: New nodes have no peer reputation history and are most susceptible to selecting malicious peers.

5. **Difficult Detection**: Network operators have limited visibility into which peers are advertising false capabilities versus having intermittent connectivity issues.

The fix requires fundamental changes to the storage summary advertisement and validation system to add cryptographic proofs and cross-validation mechanisms.

### Citations

**File:** state-sync/aptos-data-client/src/poller.rs (L406-408)
```rust
        let data_request = DataRequest::GetStorageServerSummary;
        let use_compression = data_summary_poller.data_client_config.use_compression;
        let storage_request = StorageServiceRequest::new(data_request, use_compression);
```

**File:** state-sync/aptos-data-client/src/poller.rs (L437-439)
```rust
        data_summary_poller
            .data_client
            .update_peer_storage_summary(peer, storage_summary);
```

**File:** state-sync/aptos-data-client/src/client.rs (L553-559)
```rust
        prospective_peers
            .into_iter()
            .filter(|peer| {
                self.peer_states
                    .can_service_request(peer, self.time_service.clone(), request)
            })
            .collect()
```

**File:** state-sync/aptos-data-client/src/peer_states.rs (L37-43)
```rust
const SUCCESSFUL_RESPONSE_DELTA: f64 = 1.0;
/// Not necessarily a malicious response, but not super useful.
const NOT_USEFUL_MULTIPLIER: f64 = 0.95;
/// Likely to be a malicious response.
const MALICIOUS_MULTIPLIER: f64 = 0.8;
/// Ignore a peer when their score dips below this threshold.
const IGNORE_PEER_THRESHOLD: f64 = 25.0;
```

**File:** state-sync/aptos-data-client/src/peer_states.rs (L200-227)
```rust
    pub fn can_service_request(
        &self,
        peer: &PeerNetworkId,
        time_service: TimeService,
        request: &StorageServiceRequest,
    ) -> bool {
        // Storage services can always respond to data advertisement requests.
        // We need this outer check, since we need to be able to send data summary
        // requests to new peers (who don't have a peer state yet).
        if request.data_request.is_storage_summary_request()
            || request.data_request.is_protocol_version_request()
        {
            return true;
        }

        // Check if the peer can service the request
        if let Some(peer_state) = self.peer_to_state.get(peer) {
            return match peer_state.get_storage_summary_if_not_ignored() {
                Some(storage_summary) => {
                    storage_summary.can_service(&self.data_client_config, time_service, request)
                },
                None => false, // The peer is temporarily ignored
            };
        }

        // Otherwise, the request cannot be serviced
        false
    }
```

**File:** state-sync/storage-service/server/src/moderator.rs (L154-185)
```rust
            // Verify the request is serviceable using the current storage server summary
            if !storage_server_summary.can_service(
                &self.aptos_data_client_config,
                self.time_service.clone(),
                request,
            ) {
                // Increment the invalid request count for the peer
                let mut unhealthy_peer_state = self
                    .unhealthy_peer_states
                    .entry(*peer_network_id)
                    .or_insert_with(|| {
                        // Create a new unhealthy peer state (this is the first invalid request)
                        let max_invalid_requests =
                            self.storage_service_config.max_invalid_requests_per_peer;
                        let min_time_to_ignore_peers_secs =
                            self.storage_service_config.min_time_to_ignore_peers_secs;
                        let time_service = self.time_service.clone();

                        UnhealthyPeerState::new(
                            max_invalid_requests,
                            min_time_to_ignore_peers_secs,
                            time_service,
                        )
                    });
                unhealthy_peer_state.increment_invalid_request_count(peer_network_id);

                // Return the validation error
                return Err(Error::InvalidRequest(format!(
                    "The given request cannot be satisfied. Request: {:?}, storage summary: {:?}",
                    request, storage_server_summary
                )));
            }
```
