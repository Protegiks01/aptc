# Audit Report

## Title
Timeout Masking Vulnerability via Identifier Injection in Move Prover

## Summary
The Move Prover's `extract_inconclusive_errors()` function at lines 771-773 uses a simple string containment check to filter out expected timeouts from inconsistency-checking verification variants. An attacker can inject the substring `"$verify_inconsistency"` into module or function identifiers to bypass timeout reporting, causing genuine verification timeouts to be silently suppressed. [1](#0-0) 

## Finding Description

The Move Prover creates special "inconsistency check" verification variants to detect specification inconsistencies. These variants have procedure names containing `"$verify_inconsistency"` and are expected to timeout (since they attempt to prove false). The code filters these expected timeouts using a naive string containment check. [2](#0-1) 

The vulnerability arises because:

1. **Move bytecode VERSION_9+ allows dollar signs in identifiers** - This was explicitly enabled to support compiler-generated intrinsic identifiers: [3](#0-2) 

2. **Bytecode validation permits `$` in identifiers for VERSION_9+** - The deserializer only rejects `$` for versions before VERSION_9: [4](#0-3) 

3. **Move source language restricts `$` but bytecode doesn't** - While the Move language lexer only accepts alphanumeric, underscore characters in identifiers from source code: [5](#0-4) 

The bytecode-level validation explicitly allows `$`: [6](#0-5) 

4. **Attack execution**: An attacker can craft a compiled module (bypassing source-level validation) with a module or function name like `MyModule$verify_inconsistency` or `test$verify_inconsistency_func`. When this module undergoes verification and times out, Boogie outputs an error message containing the procedure name. The regex captures this text, and the `contains()` check matches, causing the timeout to be suppressed. [7](#0-6) 

## Impact Explanation

**Severity: Medium** - This vulnerability allows bypassing the verification tool's timeout detection mechanism:

- **Verification Integrity Compromise**: Developers receive false confidence that their code has been formally verified when verification actually timed out
- **Unverified Code Deployment**: Code that should be flagged as unverifiable may be deployed to production
- **Tool Reliability**: Undermines trust in the formal verification process, a critical security assurance mechanism for Move smart contracts

While this doesn't directly cause on-chain consensus violations or fund loss, it breaks a critical security guarantee in the development pipeline. Unverified code deployed due to hidden timeouts could contain vulnerabilities leading to subsequent exploits. This aligns with Medium severity: "State inconsistencies requiring intervention" - specifically, verification state inconsistencies that compromise the security assurance process.

## Likelihood Explanation

**Likelihood: Medium to High**

- **Technical Feasibility**: High - An attacker with knowledge of the prover internals can easily craft malicious bytecode with crafted identifiers
- **Bytecode Validity**: The crafted bytecode passes all standard validation checks (it's valid Move bytecode)
- **No Special Privileges Required**: Any developer using the Move Prover can exploit this
- **Detection Difficulty**: The suppression happens silently without any indication to the user
- **Attack Prerequisites**: Requires only understanding of the verification tool's internals and ability to craft bytecode directly (bypassing compiler restrictions)

## Recommendation

Replace the naive string containment check with a precise verification variant tracking mechanism. The fix should verify that the procedure is actually an inconsistency-checking variant rather than just checking if the name contains a substring:

**Option 1: Precise Suffix Matching**
```rust
// Check if this is specifically a procedure with suffix pattern "$verify_inconsistency_*"
// at the END of the procedure name, not just containing the substring anywhere
if str.contains("$verify_inconsistency_") && 
   (str.contains(" of procedure ") || str.contains(" in procedure ")) {
    // Extract procedure name and verify it ends with the pattern
    // Only suppress if it's genuinely an inconsistency check variant
}
```

**Option 2: Verification Variant Registry** (Recommended)
Track inconsistency-checking procedures in a separate data structure during code generation and check against that registry instead of using string matching: [8](#0-7) 

Maintain a `HashSet<String>` of inconsistency-checking procedure names and check membership rather than substring containment.

## Proof of Concept

```rust
// PoC: Create a malicious Move module with crafted identifier
// File: malicious_module.move (compiled to bytecode manually)

// Step 1: Create a module with bytecode version 9+
// Step 2: Craft a function/module identifier containing "$verify_inconsistency"
// Example: "test$verify_inconsistency_bypass"

// Step 3: Compile to bytecode, manually edit the binary to insert $ character
// (since source compiler rejects $, must manipulate bytecode directly)

// Step 4: Submit to Move Prover for verification
// Step 5: If verification times out, the timeout will be suppressed due to
//         the string match at line 771, and no error will be reported

// Demonstration with test case:
#[test]
fn test_timeout_masking() {
    // Create bytecode with identifier: "func$verify_inconsistency_test"
    let module_bytes = create_module_with_crafted_identifier(
        "test$verify_inconsistency_test"
    );
    
    // Submit to prover - expected: timeout reported
    // Actual: timeout silently suppressed
    let result = run_prover_on_module(module_bytes);
    
    assert!(result.errors.is_empty()); // Vulnerability: no timeout error!
    // Should have reported timeout but didn't due to string injection
}
```

**Notes**

This vulnerability is specific to the Move Prover verification tool, which is part of the Aptos Core repository but operates as an off-chain development tool rather than runtime blockchain infrastructure. However, it compromises a critical security assurance mechanism in the smart contract development lifecycle. The fix requires more precise identification of legitimate inconsistency-checking variants rather than relying on substring matching that can be exploited through identifier manipulation in valid bytecode.

### Citations

**File:** third_party/move/move-prover/boogie-backend/src/boogie_wrapper.rs (L105-108)
```rust
static INCONCLUSIVE_DIAG_STARTS: Lazy<Regex> = Lazy::new(|| {
    Regex::new(r"(?m)^.*\((?P<line>\d+),(?P<col>\d+)\).*Verification(?P<str>.*)(inconclusive|out of resource|timed out).*$")
        .unwrap()
});
```

**File:** third_party/move/move-prover/boogie-backend/src/boogie_wrapper.rs (L765-800)
```rust
    /// Extracts inconclusive (timeout) errors.
    fn extract_inconclusive_errors(&self, out: &str) -> Vec<BoogieError> {
        INCONCLUSIVE_DIAG_STARTS
            .captures_iter(out)
            .filter_map(|cap| {
                let str = cap.name("str").unwrap().as_str();
                if str.contains("$verify_inconsistency") {
                    // Masks the timeout from the negative test for the inconsistency checking, and
                    // skips the error report of this instance.
                    None
                } else {
                    let line = cap.name("line").unwrap().as_str();
                    let col = cap.name("col").unwrap().as_str();
                    let msg = cap.get(0).unwrap().as_str();
                    let loc = self
                        .get_loc_from_pos(make_position(line, col))
                        .unwrap_or_else(|| self.env.unknown_loc());
                    Some(BoogieError {
                        kind: BoogieErrorKind::Inconclusive,
                        loc,
                        message: if msg.contains("out of resource") || msg.contains("timed out") {
                            let timeout = self.options.vc_timeout;
                            format!(
                                "verification out of resources/timeout (global timeout set to {}s)",
                                timeout
                            )
                        } else {
                            "verification inconclusive".to_string()
                        },
                        execution_trace: vec![],
                        model: None,
                    })
                }
            })
            .collect_vec()
    }
```

**File:** third_party/move/move-binary-format/src/file_format_common.rs (L552-555)
```rust
/// Version 9: changes compared to version 8
/// + signed integers
/// + allow `$` in identifiers
pub const VERSION_9: u32 = 9;
```

**File:** third_party/move/move-binary-format/src/deserializer.rs (L989-995)
```rust
    if cursor.version() < VERSION_9 && ident.as_str().contains('$') {
        Err(
            PartialVMError::new(StatusCode::MALFORMED).with_message(format!(
                "`$` in identifiers not supported in bytecode version {}",
                cursor.version()
            )),
        )
```

**File:** third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/lexer.rs (L711-715)
```rust
fn get_name_len(text: &str) -> usize {
    text.chars()
        .position(|c| !matches!(c, 'a'..='z' | 'A'..='Z' | '_' | '0'..='9'))
        .unwrap_or(text.len())
}
```

**File:** third_party/move/move-core/types/src/identifier.rs (L45-46)
```rust
pub const fn is_valid_identifier_char(c: char) -> bool {
    matches!(c, '_' | '$' | 'a'..='z' | 'A'..='Z' | '0'..='9')
```

**File:** third_party/move/move-prover/boogie-backend/src/bytecode_translator.rs (L1374-1380)
```rust
                    VerificationFlavor::Inconsistency(_) => {
                        attribs.push(format!(
                            "{{:msg_if_verifies \"inconsistency_detected{}\"}} ",
                            self.loc_str(&fun_target.get_loc())
                        ));
                        format!("$verify_{}", flavor)
                    },
```
