# Audit Report

## Title
Premature Peer Score Update Allows Malicious Peers to Boost Reputation by Serving Invalid Data

## Summary
The `send_request_to_peer()` function updates peer scores immediately upon receiving a network-level response, before validating compression settings or response data type. Malicious peers can exploit this timing gap to maintain artificially high scores by sending well-formed but invalid responses that pass network checks but fail later validation stages, with some failure paths never triggering score penalties.

## Finding Description

The vulnerability exists in the peer scoring mechanism within the Aptos data client's request handling flow. The issue manifests in two critical timing problems:

**Problem 1: Immediate Score Update Before Validation** [1](#0-0) 

The peer score is updated with a success delta (+1.0) immediately after receiving an RPC response, before any data validation occurs.

**Problem 2: Validation Failures Without Score Penalties** [2](#0-1) 

Compression validation failures return early without invoking the response callback, meaning the peer retains the +1.0 score boost without penalty.

**Attack Execution Path:**

1. Malicious peer receives a data request from an honest node
2. Peer crafts a response with intentionally wrong compression settings (e.g., sends compressed data when uncompressed was requested, or vice versa)
3. Response passes network/RPC layer checks [3](#0-2) 
4. Peer immediately receives +1.0 score boost [4](#0-3) 
5. Response validation detects compression mismatch and returns error, but **never calls the response callback** to penalize the peer
6. Peer maintains inflated score and continues to be selected for future requests

**Score Update Mechanics:**

Success delta: +1.0 (capped at MAX_SCORE of 100.0) [5](#0-4) 

Error multipliers that SHOULD apply but don't in compression failure case:
- NotUseful: 0.95x multiplier [6](#0-5) 
- Malicious: 0.8x multiplier [7](#0-6) 

Even when the callback IS eventually called (e.g., for type conversion failures), the timing gap allows malicious peers to maintain higher-than-deserved scores during the validation window, increasing their selection probability for subsequent requests.

## Impact Explanation

This vulnerability meets **High Severity** criteria per the Aptos bug bounty program as it enables:

**1. Validator Node Slowdowns:** Malicious peers can repeatedly send invalid data while maintaining high reputation scores, forcing honest nodes to waste resources on:
- Network bandwidth receiving invalid responses
- CPU cycles attempting decompression/validation
- Memory allocations for invalid payloads
- Request retries and fallback logic [8](#0-7) 

**2. State Sync Disruption:** Since peers with higher scores are preferentially selected [9](#0-8) , malicious peers with inflated scores will dominate the peer selection pool, causing:
- Increased latency in state synchronization
- Wasted parallel fetch attempts in multi-fetch scenarios
- Degraded data availability for nodes catching up to the network

**3. Peer Reputation System Subversion:** The ignore threshold mechanism intended to filter out low-quality peers becomes ineffective [10](#0-9) , as malicious peers can stay above the 25.0 ignore threshold indefinitely.

## Likelihood Explanation

**Likelihood: HIGH**

This vulnerability is highly likely to occur because:

1. **No Special Access Required:** Any network peer can connect to validator nodes and serve data responses - no validator credentials or stake required

2. **Trivial Exploitation:** The attack requires only sending responses with mismatched compression flags, which is a simple protocol violation

3. **No Detection Mechanism:** The current scoring system has no mechanism to detect peers consistently sending invalid data while maintaining high scores through this exploit

4. **Continuous Opportunity:** State sync is an ongoing process with frequent peer requests, providing continuous exploitation opportunities

5. **Resource Asymmetry:** The cost to the attacker (bandwidth for invalid responses) is minimal compared to the cost imposed on victims (validation overhead, retry logic, bandwidth waste)

## Recommendation

**Fix 1: Delay Score Update Until After Basic Validation**

Move the score success update to occur only after compression and type validation passes:

In `send_request_to_peer()`, remove the immediate score update at line 817 and instead update it after validation succeeds in `send_request_to_peer_and_decode()`.

**Fix 2: Add Score Penalty for Compression Validation Failures**

In `send_request_to_peer_and_decode()`, ensure the response callback is invoked for compression failures:

```rust
// Lines 738-748 should be updated to:
if request.use_compression && !storage_response.is_compressed() {
    context
        .response_callback
        .notify_bad_response(ResponseError::InvalidPayloadDataType);
    return Err(Error::InvalidResponse(format!(
        "Requested compressed data, but the response was uncompressed! Response: {:?}",
        storage_response.get_label()
    )));
} else if !request.use_compression && storage_response.is_compressed() {
    context
        .response_callback
        .notify_bad_response(ResponseError::InvalidPayloadDataType);
    return Err(Error::InvalidResponse(format!(
        "Requested uncompressed data, but the response was compressed! Response: {:?}",
        storage_response.get_label()
    )));
}
```

**Fix 3: Implement Two-Phase Scoring**

Use a provisional score update that only commits after validation:
- Grant provisional +1.0 on RPC success
- Commit the increase only if validation passes
- Revert and apply penalty if validation fails

## Proof of Concept

```rust
// Simulation demonstrating the vulnerability

// Setup: Malicious peer starts with score of 50.0
let initial_score = 50.0;

// Attack execution over 10 requests:
for i in 0..10 {
    // Step 1: Peer receives request for UNCOMPRESSED data
    // Step 2: Peer sends COMPRESSED data (wrong format)
    
    // Step 3: send_request_to_peer() succeeds at RPC layer
    // Line 817 executes: peer score += 1.0
    let score_after_response = initial_score + (i + 1) as f64; // 51, 52, 53...
    
    // Step 4: Compression validation fails at lines 738-747
    // Returns error but callback.notify_bad_response() is NEVER called
    
    // Result: Peer retains the +1.0 score increase with NO penalty
}

// Final score: 60.0 (up from 50.0)
// Expected score if penalties applied: ~35.0 (with 0.95 multiplier per error)

// With inflated score of 60.0, malicious peer:
// - Remains above IGNORE_PEER_THRESHOLD (25.0)
// - Has higher selection probability in peer selection logic
// - Continues to be chosen for future requests
// - Can repeat attack indefinitely

// Impact: Honest node wastes resources validating invalid data
// from a peer that should have been ignored or penalized.
```

**Verification Steps:**

1. Deploy a malicious peer that consistently sends responses with wrong compression flags
2. Monitor peer score updates in honest node logs
3. Observe score increases without corresponding decreases
4. Verify peer remains selected despite serving 100% invalid data
5. Measure resource consumption (CPU, bandwidth) on honest node processing invalid responses

### Citations

**File:** state-sync/aptos-data-client/src/client.rs (L272-280)
```rust
        // Identify the peers that can service the request (ordered by priority)
        let mut serviceable_peers_by_priorities = vec![];
        for priority in PeerPriority::get_all_ordered_priorities() {
            // Identify the serviceable peers for the priority
            let peers = self.identify_serviceable(&peers_by_priorities, priority, request);

            // Add the serviceable peers to the ordered list
            serviceable_peers_by_priorities.push(peers);
        }
```

**File:** state-sync/aptos-data-client/src/client.rs (L736-748)
```rust
        // Ensure the response obeys the compression requirements
        let (context, storage_response) = storage_response.into_parts();
        if request.use_compression && !storage_response.is_compressed() {
            return Err(Error::InvalidResponse(format!(
                "Requested compressed data, but the response was uncompressed! Response: {:?}",
                storage_response.get_label()
            )));
        } else if !request.use_compression && storage_response.is_compressed() {
            return Err(Error::InvalidResponse(format!(
                "Requested uncompressed data, but the response was compressed! Response: {:?}",
                storage_response.get_label()
            )));
        }
```

**File:** state-sync/aptos-data-client/src/client.rs (L790-797)
```rust
        let result = self
            .storage_service_client
            .send_request(
                peer,
                Duration::from_millis(request_timeout_ms),
                request.clone(),
            )
            .await;
```

**File:** state-sync/aptos-data-client/src/client.rs (L817-817)
```rust
                self.peer_states.update_score_success(peer);
```

**File:** state-sync/aptos-data-client/src/peer_states.rs (L33-37)
```rust
const MAX_SCORE: f64 = 100.0;
const MIN_SCORE: f64 = 0.0;
const STARTING_SCORE: f64 = 50.0;
/// Add this score on a successful response.
const SUCCESSFUL_RESPONSE_DELTA: f64 = 1.0;
```

**File:** state-sync/aptos-data-client/src/peer_states.rs (L39-39)
```rust
const NOT_USEFUL_MULTIPLIER: f64 = 0.95;
```

**File:** state-sync/aptos-data-client/src/peer_states.rs (L41-41)
```rust
const MALICIOUS_MULTIPLIER: f64 = 0.8;
```

**File:** state-sync/aptos-data-client/src/peer_states.rs (L152-160)
```rust
    fn is_ignored(&self) -> bool {
        // Only ignore peers if the config allows it
        if !self.data_client_config.ignore_low_score_peers {
            return false;
        }

        // Otherwise, ignore peers with a low score
        self.score <= IGNORE_PEER_THRESHOLD
    }
```

**File:** state-sync/aptos-data-client/src/peer_states.rs (L163-165)
```rust
    fn update_score_success(&mut self) {
        self.score = f64::min(self.score + SUCCESSFUL_RESPONSE_DELTA, MAX_SCORE);
    }
```

**File:** state-sync/data-streaming-service/src/data_stream.rs (L729-744)
```rust
    fn resend_data_client_request(
        &mut self,
        data_client_request: &DataClientRequest,
    ) -> Result<(), Error> {
        // Increment the number of client failures for this request
        self.request_failure_count += 1;

        // Resend the client request
        let pending_client_response = self.send_client_request(true, data_client_request.clone());

        // Push the pending response to the head of the sent requests queue
        self.get_sent_data_requests()?
            .push_front(pending_client_response);

        Ok(())
    }
```
