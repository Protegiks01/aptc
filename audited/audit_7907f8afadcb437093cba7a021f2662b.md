# Audit Report

## Title
Memory Ordering Vulnerability in skip_module_reads_validation Flag Enables Consensus Split

## Summary
The `skip_module_reads_validation` flag in the parallel block executor uses `Ordering::Relaxed` for both reads and writes, creating a race condition that can cause different validators to validate transactions differently. This breaks deterministic execution and can lead to consensus splits.

## Finding Description

The vulnerability exists in the memory ordering semantics of the `skip_module_reads_validation` atomic flag used during parallel transaction execution. [1](#0-0) 

The flag is initialized to `true` to skip module validation as an optimization when no modules have been published. When a transaction publishes a module, the flag is set to `false`: [2](#0-1) 

During validation, the flag is read to determine whether to skip module validation: [3](#0-2) [4](#0-3) 

**The Critical Issue:**

Both the write and read use `Ordering::Relaxed`, which provides **no synchronization guarantees**. Even though `decrease_validation_idx` is called immediately after setting the flag (using `SeqCst`), the relaxed load in the validation thread is not synchronized with the relaxed store, allowing the following race:

**Attack Scenario:**

1. **Initial state**: Module M version 1 exists in global cache, `skip_module_reads_validation = true`
2. **Transaction 5** (higher index) executes first in parallel, reads Module M version 1 from global cache
3. **Transaction 3** (lower index) executes, publishes Module M version 2, commits:
   - Marks Module M as overridden: [5](#0-4) 
   - Sets `skip_module_reads_validation = false` with `Relaxed` ordering
   - Calls `decrease_validation_idx(4)` with `SeqCst`, triggering re-validation of transactions 4+
4. **Validation thread** picks up Transaction 5 validation task (with new wave from step 3's `SeqCst` operation)
5. **Race occurs**: The validation thread reads `skip_module_reads_validation` with `Relaxed` and sees `true` (old value due to lack of synchronization)
6. Module validation is skipped: [6](#0-5) 
7. Transaction 5 validation passes without checking that Module M was overridden
8. Transaction 5 commits with execution result based on stale Module M version 1

**Module validation would have caught this:** [7](#0-6) 

The validation checks `contains_not_overridden` which would return `false` for Module M: [8](#0-7) 

**Why this breaks consensus:**

Different validator nodes running on different hardware (x86 with TSO vs ARM with weaker memory model) or with different thread scheduling can observe the flag update at different times. This leads to:

- **Validator Node A**: Validation thread sees flag as `true`, skips module check, commits Transaction 5
- **Validator Node B**: Validation thread sees flag as `false`, performs module check, aborts Transaction 5

This violates the **Deterministic Execution** invariant - identical blocks produce different state roots on different validators, causing a consensus split.

## Impact Explanation

**Critical Severity - Consensus/Safety Violation**

This vulnerability directly breaks the fundamental consensus invariant that all validators must produce identical state roots for identical blocks. The non-deterministic behavior can cause:

1. **Chain Split**: Different validators commit different blocks, requiring manual intervention or hard fork
2. **Network Partition**: Validators diverge into incompatible states
3. **Loss of BFT Safety**: Even with <1/3 Byzantine nodes, honest validators disagree on block validity

This meets the **Critical Severity** criteria per Aptos bug bounty rules:
- Consensus/Safety violations
- Non-recoverable network partition (requires hardfork)

## Likelihood Explanation

**Medium-High Likelihood**

The vulnerability requires:
1. Concurrent transaction execution with module publishing (common in production)
2. Parallel validation racing with module commit (occurs every time modules are published)
3. Memory ordering race to manifest differently across validators (depends on hardware/timing)

**Factors increasing likelihood:**
- Aptos encourages high transaction throughput with parallel execution
- Module upgrades are common operations
- Different validators may run on different CPU architectures (x86 vs ARM)
- The race window exists on every module publish operation

**Factors decreasing likelihood:**
- Race window is narrow (microseconds)
- Requires specific timing of parallel execution
- x86 TSO memory model makes race less likely (but not impossible)
- May not manifest on every module publish

Despite the narrow race window, the **catastrophic impact** (consensus split) and **regular occurrence** of module publishing make this a serious vulnerability.

## Recommendation

**Fix: Use proper memory ordering semantics**

Replace `Ordering::Relaxed` with at least `Ordering::Release` for writes and `Ordering::Acquire` for reads, or use `Ordering::SeqCst` for both to ensure proper synchronization.

**In scheduler_wrapper.rs:**
```rust
SchedulerWrapper::V1(_, skip_module_reads_validation) => {
    // Use Release ordering to ensure all prior operations (including mark_overridden)
    // are visible to threads that Acquire-load this flag
    skip_module_reads_validation.store(false, Ordering::Release);
},
```

**In executor.rs:**
```rust
let valid = Self::validate(
    txn_idx,
    last_input_output,
    global_module_cache,
    versioned_cache,
    // Use Acquire ordering to synchronize with the Release store
    skip_module_reads_validation.load(Ordering::Acquire),
);
```

**Alternative: Use SeqCst for both operations** for strongest guarantees:
```rust
// Write site
skip_module_reads_validation.store(false, Ordering::SeqCst);

// Read site
skip_module_reads_validation.load(Ordering::SeqCst)
```

The comment at line 85-86 in scheduler_wrapper.rs is **incorrect** - it claims "Relaxed suffices" but this is false. The subsequent SeqCst operation on `validation_idx` does not provide synchronization for the relaxed flag operations.

## Proof of Concept

**Reproduction Strategy:**

This is a memory ordering bug that requires concurrent execution to manifest. Here's a conceptual PoC:

```rust
// Pseudo-code demonstrating the race
// Thread A: Committing transaction that publishes module
fn thread_a_commit_module_publisher() {
    publish_module_write_set(); // Marks module as overridden
    skip_module_reads_validation.store(false, Ordering::Relaxed); // BUG: Should be Release
    decrease_validation_idx(); // Uses SeqCst
}

// Thread B: Validating transaction that read the module
fn thread_b_validate_module_reader() {
    let skip = skip_module_reads_validation.load(Ordering::Relaxed); // BUG: Should be Acquire
    // Due to Relaxed ordering, may see 'true' even after Thread A's store
    if skip {
        // Incorrectly skips validation of module read
        return true; // Should have been false - module was overridden
    }
    // Should validate and detect module was overridden
    validate_module_reads();
}
```

**Stress Test to Expose Race:**

Run parallel block execution with:
- High transaction throughput (100+ TPS)
- Frequent module publishing (every 10-20 transactions)
- Multiple validator nodes on different CPU architectures
- Monitor for state root divergence

**Expected Result:** With sufficient stress testing across heterogeneous validator nodes (especially ARM vs x86), state root mismatches will eventually occur when the race manifests.

**Verification:** After applying the fix (Acquire/Release ordering), the same stress test should show no divergence.

### Citations

**File:** aptos-move/block-executor/src/executor.rs (L808-815)
```rust
        read_set.validate_data_reads(versioned_cache.data(), idx_to_validate)
            && read_set.validate_group_reads(versioned_cache.group_data(), idx_to_validate)
            && (skip_module_reads_validation
                || read_set.validate_module_reads(
                    global_module_cache,
                    versioned_cache.module_cache(),
                    None,
                ))
```

**File:** aptos-move/block-executor/src/executor.rs (L1367-1373)
```rust
                    let valid = Self::validate(
                        txn_idx,
                        last_input_output,
                        global_module_cache,
                        versioned_cache,
                        skip_module_reads_validation.load(Ordering::Relaxed),
                    );
```

**File:** aptos-move/block-executor/src/executor.rs (L1895-1896)
```rust
        let skip_module_reads_validation = AtomicBool::new(true);
        // +1 for potential BlockEpilogue txn.
```

**File:** aptos-move/block-executor/src/scheduler_wrapper.rs (L84-87)
```rust
            SchedulerWrapper::V1(_, skip_module_reads_validation) => {
                // Relaxed suffices as syncronization (reducing validation index) occurs after
                // setting the module read validation flag.
                skip_module_reads_validation.store(false, Ordering::Relaxed);
```

**File:** aptos-move/block-executor/src/code_cache_global.rs (L115-119)
```rust
    pub fn contains_not_overridden(&self, key: &K) -> bool {
        self.module_cache
            .get(key)
            .is_some_and(|entry| entry.is_not_overridden())
    }
```

**File:** aptos-move/block-executor/src/code_cache_global.rs (L317-317)
```rust
    global_module_cache.mark_overridden(write.module_id());
```

**File:** aptos-move/block-executor/src/captured_reads.rs (L1060-1061)
```rust
        let validate = |key: &K, read: &ModuleRead<DC, VC, S>| match read {
            ModuleRead::GlobalCache(_) => global_module_cache.contains_not_overridden(key),
```
