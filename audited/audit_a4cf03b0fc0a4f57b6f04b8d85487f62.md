# Audit Report

## Title
Table Info Service Panic on Empty Transactions Array Due to Pruned Genesis Block Access

## Summary
The `transactions_in_epochs()` function in the table info service can panic when processing an empty transactions array on pruned fullnodes. When the service is caught up with the ledger and no new transactions are available, the function defaults `last_version` to 0 and attempts to query block information for the genesis block, which fails if version 0 has been pruned from the ledger. [1](#0-0) 

## Finding Description
The vulnerability occurs in the `transactions_in_epochs()` function when it receives an empty transactions vector. The code uses `unwrap_or_default()` to extract `first_version` and `last_version` from the transactions array. When the array is empty, both values default to 0 (the default value for `u64`). [2](#0-1) 

The function then unconditionally calls `get_block_info_by_version(last_version)` with `last_version = 0`, expecting to retrieve block information for the genesis block. However, on fullnodes with ledger pruning enabled, the genesis block at version 0 may have been pruned to conserve disk space. [3](#0-2) 

The `get_block_info_by_version` function first checks if the requested version has been pruned using `error_if_ledger_pruned()`: [4](#0-3) 

When version 0 has been pruned (i.e., `min_readable_version > 0`), this check fails and returns an error. The calling code uses `unwrap_or_else` with a panic handler, causing the entire table info service to crash: [5](#0-4) 

The empty transactions array scenario occurs legitimately when the service catches up to the ledger tip. The main processing loop calls `get_batches()` which returns an empty vector when `current_version > ledger_version`: [6](#0-5) 

This empty batch list leads to an empty transactions vector from `fetch_batches()`, which is then passed to `transactions_in_epochs()` without validation: [7](#0-6) 

## Impact Explanation
This qualifies as **High Severity** per Aptos bug bounty criteria under "API crashes". The table info service is a critical component of the indexer-grpc infrastructure that:

1. Provides table metadata information to clients via the gRPC API
2. Integrates with the fullnode data streaming service
3. Affects the `highest_known_version` calculation for transaction streaming [8](#0-7) 

When this panic occurs:
- The table info service process terminates
- All table info API queries fail
- The indexer-grpc service becomes degraded or unavailable
- Manual intervention (service restart) is required to restore functionality

While this doesn't affect consensus or validator operations directly, it impacts the availability of critical indexer infrastructure that many applications depend on for querying blockchain state.

## Likelihood Explanation
**High Likelihood** - This bug will trigger reliably under normal operating conditions on any fullnode with ledger pruning enabled once:

1. The blockchain has progressed beyond the pruning window (typically 150M versions based on default configuration)
2. The genesis block at version 0 has been pruned (when `min_readable_version > 0`)
3. The table info service catches up to the ledger tip (a routine occurrence) [9](#0-8) 

On mature Aptos networks with active pruning, this condition is met regularly, making the crash virtually certain to occur during normal operation.

## Recommendation
Add validation to check if the transactions array is empty before processing in `transactions_in_epochs()`. When empty, the function should return early with safe default values rather than attempting to query block information with version 0.

**Recommended Fix:**
```rust
fn transactions_in_epochs(
    context: &ApiContext,
    current_epoch: Option<u64>,
    mut transactions: Vec<TransactionOnChainData>,
) -> (
    Vec<TransactionOnChainData>,
    Vec<TransactionOnChainData>,
    u64,
) {
    // Add early return for empty transactions
    if transactions.is_empty() {
        // Return empty vecs and current epoch (or 0 if none)
        return (vec![], vec![], current_epoch.unwrap_or(0));
    }
    
    let last_version = transactions
        .last()
        .map(|txn| txn.version)
        .unwrap_or_default();
    // ... rest of the function
}
```

This matches the pattern already used in `parse_table_info()`: [10](#0-9) 

## Proof of Concept

**Reproduction Steps:**

1. Set up a fullnode with ledger pruning enabled and a small prune window (e.g., 1000 versions)
2. Let the chain progress beyond the prune window so version 0 is pruned
3. Configure and start the table info service  
4. Wait for the service to catch up to the ledger tip
5. Observe the panic when the service processes an empty transaction batch

**Expected Error Message:**
```
thread 'tokio-runtime-worker' panicked at 'Could not get block_info for last version 0'
```

**Verification:**
Check the `min_readable_version` value:
```rust
let min_readable_version = context.db.ledger_pruner.get_min_readable_version();
assert!(min_readable_version > 0); // Version 0 is pruned
```

Then trigger the empty transactions path:
```rust
let empty_txns = vec![];
let current_epoch = Some(100);
// This will panic with "Could not get block_info for last version 0"
let result = transactions_in_epochs(&context, current_epoch, empty_txns);
```

## Notes
- This bug affects the indexer infrastructure, not core consensus
- The fix is straightforward and low-risk
- Similar empty-check validation patterns exist elsewhere in the codebase and should be consistently applied
- The service can be restarted to recover, but the crash will recur until the code is fixed

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-table-info/src/table_info_service.rs (L113-121)
```rust
            let batches = self.get_batches(ledger_version).await;
            let transactions = self.fetch_batches(batches, ledger_version).await.unwrap();
            let num_transactions = transactions.len();
            let last_version = transactions
                .last()
                .map(|txn| txn.version)
                .unwrap_or_default();
            let (transactions_in_previous_epoch, transactions_in_current_epoch, epoch) =
                transactions_in_epochs(&self.context, current_epoch, transactions);
```

**File:** ecosystem/indexer-grpc/indexer-grpc-table-info/src/table_info_service.rs (L360-390)
```rust
    async fn get_batches(&self, ledger_version: u64) -> Vec<TransactionBatchInfo> {
        let mut start_version = self.current_version.load(Ordering::SeqCst);
        info!(
            current_version = start_version,
            highest_known_version = ledger_version,
            parser_batch_size = self.parser_batch_size,
            parser_task_count = self.parser_task_count,
            "[Table Info] Preparing to fetch transactions"
        );

        let mut num_fetches = 0;
        let mut batches = vec![];

        while num_fetches < self.parser_task_count && start_version <= ledger_version {
            let num_transactions_to_fetch = std::cmp::min(
                self.parser_batch_size as u64,
                ledger_version + 1 - start_version,
            ) as u16;

            batches.push(TransactionBatchInfo {
                start_version,
                num_transactions_to_fetch,
                head_version: ledger_version,
            });

            start_version += num_transactions_to_fetch as u64;
            num_fetches += 1;
        }

        batches
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-table-info/src/table_info_service.rs (L393-400)
```rust
    fn parse_table_info(
        context: Arc<ApiContext>,
        raw_txns: &[TransactionOnChainData],
        indexer_async_v2: Arc<IndexerAsyncV2>,
    ) -> Result<(), Error> {
        if raw_txns.is_empty() {
            return Ok(());
        }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-table-info/src/table_info_service.rs (L625-637)
```rust
    let last_version = transactions
        .last()
        .map(|txn| txn.version)
        .unwrap_or_default();
    let first_version = transactions
        .first()
        .map(|txn| txn.version)
        .unwrap_or_default();
    // Get epoch information.
    let (epoch_first_version, _, block_epoch) = context
        .db
        .get_block_info_by_version(last_version)
        .unwrap_or_else(|_| panic!("Could not get block_info for last version {}", last_version));
```

**File:** storage/aptosdb/src/db/aptosdb_reader.rs (L779-789)
```rust
    fn get_block_info_by_version(
        &self,
        version: Version,
    ) -> Result<(Version, Version, NewBlockEvent)> {
        gauged_api("get_block_info", || {
            self.error_if_ledger_pruned("NewBlockEvent", version)?;

            let (block_height, block_info) = self.get_raw_block_info_by_version(version)?;
            self.to_api_block_info(block_height, block_info)
        })
    }
```

**File:** storage/aptosdb/src/db/aptosdb_internal.rs (L261-271)
```rust
    pub(super) fn error_if_ledger_pruned(&self, data_type: &str, version: Version) -> Result<()> {
        let min_readable_version = self.ledger_pruner.get_min_readable_version();
        ensure!(
            version >= min_readable_version,
            "{} at version {} is pruned, min available version is {}.",
            data_type,
            version,
            min_readable_version
        );
        Ok(())
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-table-info/src/runtime.rs (L1-50)
```rust
// Copyright (c) Aptos Foundation
// Licensed pursuant to the Innovation-Enabling Source Code License, available at https://github.com/aptos-labs/aptos-core/blob/main/LICENSE

use crate::{
    backup_restore::gcs::GcsBackupRestoreOperator,
    internal_indexer_db_service::InternalIndexerDBService, table_info_service::TableInfoService,
};
use aptos_api::context::Context;
use aptos_config::config::{NodeConfig, TableInfoServiceMode};
use aptos_db_indexer::{
    db_indexer::{DBIndexer, InternalIndexerDB},
    db_ops::open_db,
    db_v2::IndexerAsyncV2,
};
use aptos_mempool::MempoolClientSender;
use aptos_storage_interface::DbReaderWriter;
use aptos_types::{chain_id::ChainId, transaction::Version};
use std::{sync::Arc, time::Instant};
use tokio::{runtime::Runtime, sync::watch::Receiver as WatchReceiver};

const INDEX_ASYNC_V2_DB_NAME: &str = "index_indexer_async_v2_db";

pub fn bootstrap_internal_indexer_db(
    config: &NodeConfig,
    db_rw: DbReaderWriter,
    internal_indexer_db: Option<InternalIndexerDB>,
    update_receiver: Option<WatchReceiver<(Instant, Version)>>,
) -> Option<(Runtime, Arc<DBIndexer>)> {
    if !config.indexer_db_config.is_internal_indexer_db_enabled() || internal_indexer_db.is_none() {
        return None;
    }
    let runtime = aptos_runtimes::spawn_named_runtime("index-db".to_string(), None);
    // Set up db config and open up the db initially to read metadata
    let mut indexer_service = InternalIndexerDBService::new(
        db_rw.reader,
        internal_indexer_db.unwrap(),
        update_receiver.expect("Internal indexer db update receiver is missing"),
    );
    let db_indexer = indexer_service.get_db_indexer();
    // Spawn task for db indexer
    let config_clone = config.to_owned();
    runtime.spawn(async move {
        indexer_service.run(&config_clone).await.unwrap();
    });

    Some((runtime, db_indexer))
}

/// Creates a runtime which creates a thread pool which sets up fullnode indexer table info service
/// Returns corresponding Tokio runtime
```

**File:** storage/aptosdb/src/pruner/ledger_pruner/ledger_pruner_manager.rs (L1-50)
```rust
// Copyright (c) Aptos Foundation
// Licensed pursuant to the Innovation-Enabling Source Code License, available at https://github.com/aptos-labs/aptos-core/blob/main/LICENSE

use crate::{
    ledger_db::LedgerDb,
    metrics::{PRUNER_BATCH_SIZE, PRUNER_VERSIONS, PRUNER_WINDOW},
    pruner::{
        ledger_pruner::LedgerPruner, pruner_manager::PrunerManager, pruner_utils,
        pruner_worker::PrunerWorker,
    },
};
use aptos_config::config::LedgerPrunerConfig;
use aptos_db_indexer::db_indexer::InternalIndexerDB;
use aptos_infallible::Mutex;
use aptos_storage_interface::Result;
use aptos_types::transaction::{AtomicVersion, Version};
use std::sync::{atomic::Ordering, Arc};

/// The `PrunerManager` for `LedgerPruner`.
pub(crate) struct LedgerPrunerManager {
    ledger_db: Arc<LedgerDb>,
    /// DB version window, which dictates how many version of other stores like transaction, ledger
    /// info, events etc to keep.
    prune_window: Version,
    /// It is None iff the pruner is not enabled.
    pruner_worker: Option<PrunerWorker>,
    /// Ideal batch size of the versions to be sent to the ledger pruner
    pruning_batch_size: usize,
    /// latest version
    latest_version: Arc<Mutex<Version>>,
    /// Offset for displaying to users
    user_pruning_window_offset: u64,
    /// The minimal readable version for the ledger data.
    min_readable_version: AtomicVersion,
}

impl PrunerManager for LedgerPrunerManager {
    type Pruner = LedgerPruner;

    fn is_pruner_enabled(&self) -> bool {
        self.pruner_worker.is_some()
    }

    fn get_prune_window(&self) -> Version {
        self.prune_window
    }

    fn get_min_readable_version(&self) -> Version {
        self.min_readable_version.load(Ordering::SeqCst)
    }
```
