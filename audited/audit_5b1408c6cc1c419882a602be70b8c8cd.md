# Audit Report

## Title
Indexer GRPC Data Service Lacks Chain ID Configuration Validation Leading to Cross-Chain Data Leakage

## Summary
The indexer-grpc-data-service does not validate that it is configured to serve data from the expected Aptos chain (mainnet/testnet/devnet) before accepting client requests. While it validates internal consistency between Redis and file store chain IDs, it lacks an `expected_chain_id` configuration parameter to prevent accidental misconfiguration where the service serves data from the wrong chain.

## Finding Description

The indexer-grpc-data-service is missing a critical configuration validation that exists in other indexer components. Specifically:

**Missing Configuration Field:**
The `IndexerGrpcDataServiceConfig` struct lacks an `expected_chain_id` field, unlike the `IndexerGrpcManagerConfig` which includes this validation. [1](#0-0) 

Compare this to the manager config which HAS chain_id validation: [2](#0-1) 

**Insufficient Validation:**
The service only validates that Redis chain_id matches file store chain_id, but doesn't verify this matches an expected/configured chain_id: [3](#0-2) 

**No Client-Side Chain Specification:**
The `GetTransactionsRequest` proto message does not include a chain_id field, so clients cannot specify which chain they expect: [4](#0-3) 

**Client Validation Gap:**
Many clients don't validate the chain_id in responses, as seen in example implementations: [5](#0-4) 

## Impact Explanation

This qualifies as **High severity** based on the following reasoning:

1. **Data Integrity Violation**: Applications consuming indexer data for critical operations (wallet balance displays, governance decisions, price feeds, DEX operations) could receive data from the wrong chain, leading to incorrect application state and potential financial losses at the application layer.

2. **API Reliability Issue**: Per Aptos bug bounty criteria, "API crashes" and "Significant protocol violations" fall under High severity. While this isn't a crash, serving data from the wrong chain represents a significant API integrity violation.

3. **Operational Risk**: In multi-environment deployments (mainnet/testnet/devnet), configuration errors are common. Without safeguards, operators could accidentally point production services to test infrastructure.

However, it's important to note that this does **not** affect:
- Blockchain consensus or validator operations
- On-chain state or fund security
- Core protocol security

The chain continues to operate correctly; only the off-chain indexer API serves incorrect data.

## Likelihood Explanation

**Likelihood: Medium-High**

1. **Configuration Complexity**: Production deployments typically manage multiple environments (mainnet, testnet, devnet), each with separate Redis instances and GCS buckets. Without explicit chain_id validation, misconfiguration is likely during deployments, migrations, or disaster recovery.

2. **No Startup Safeguards**: The service starts successfully even when pointing to the wrong chain's infrastructure, as long as Redis and file store chain IDs match each other.

3. **Silent Failure Mode**: Clients that don't validate chain_id will silently process incorrect data without errors.

4. **Human Error Factor**: Operators using configuration templates or copying configs between environments may accidentally mix mainnet and testnet configurations.

## Recommendation

Add an `expected_chain_id` configuration field and validate it at startup:

```rust
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IndexerGrpcDataServiceConfig {
    /// Expected chain ID - service will refuse to start if data sources don't match
    pub expected_chain_id: u64,
    // ... existing fields ...
}

impl IndexerGrpcDataServiceConfig {
    pub fn validate(&self) -> Result<()> {
        // Existing validation
        if self.data_service_grpc_non_tls_config.is_none()
            && self.data_service_grpc_tls_config.is_none()
        {
            bail!("At least one of data_service_grpc_non_tls_config and data_service_grpc_tls_config must be set");
        }
        
        // NEW: Validate chain ID at startup
        // This would require synchronous access to Redis and file store during validation
        // Alternatively, perform this check in the run() method before accepting requests
        
        Ok(())
    }
}
```

Better approach - validate in `run()` before starting the gRPC server:

```rust
async fn run(&self) -> Result<()> {
    // Get chain IDs from both sources
    let redis_conn = redis::Client::open(self.redis_read_replica_address.0.clone())?
        .get_tokio_connection_manager()
        .await?;
    
    let mut cache_operator = CacheOperator::new(redis_conn, cache_storage_format);
    let redis_chain_id = cache_operator.get_chain_id().await?
        .ok_or_else(|| anyhow!("Redis chain_id not found"))?;
    
    let file_store_operator: Box<dyn FileStoreOperator> = self.file_store_config.create();
    let metadata = file_store_operator.get_file_store_metadata().await
        .ok_or_else(|| anyhow!("File store metadata not found"))?;
    
    // Validate against expected chain_id
    if redis_chain_id != self.expected_chain_id {
        bail!("Redis chain_id {} does not match expected chain_id {}", 
              redis_chain_id, self.expected_chain_id);
    }
    
    if metadata.chain_id != self.expected_chain_id {
        bail!("File store chain_id {} does not match expected chain_id {}", 
              metadata.chain_id, self.expected_chain_id);
    }
    
    // Continue with server startup...
}
```

## Proof of Concept

**Setup Scenario:**
```yaml
# Misconfigured production data service pointing to testnet infrastructure
health_check_port: 8083
server_config:
    expected_chain_id: 1  # Expects mainnet (chain_id 1)
    file_store_config:
      file_store_type: GcsFileStore
      gcs_file_store_bucket_name: indexer-grpc-testnet-bucket  # WRONG: testnet bucket
    redis_read_replica_address: testnet-redis.example.com:6379  # WRONG: testnet Redis
    data_service_grpc_non_tls_config:
      data_service_grpc_listen_address: 0.0.0.0:50051
```

**Current Behavior (Vulnerable):**
1. Service starts successfully
2. Both testnet Redis and testnet GCS have chain_id=2
3. Service validates Redis chain_id (2) == file store chain_id (2) âœ“
4. Service accepts client requests and serves testnet data
5. Clients expecting mainnet data receive testnet data

**Fixed Behavior:**
1. Service attempts to start
2. Detects Redis chain_id (2) != expected_chain_id (1)
3. Service exits with error: "Redis chain_id 2 does not match expected chain_id 1"
4. Operator is immediately alerted to misconfiguration
5. No data is served until configuration is corrected

## Notes

While this is a valid configuration issue that could lead to operational problems and data integrity issues at the application layer, it's important to recognize that:

1. **Scope Limitation**: This affects the indexer-grpc-data-service, which is an auxiliary off-chain API service, not a core blockchain component. It does not impact consensus, validator operations, or on-chain security.

2. **Existing Mitigation**: The `TransactionsResponse` already includes a `chain_id` field. Well-designed clients should validate this field to ensure they're receiving data from the expected chain.

3. **Defense in Depth**: The recommended fix adds an additional layer of defense at the service configuration level, preventing misconfiguration at deployment time rather than relying solely on client-side validation.

4. **Severity Context**: While marked as "High" in the security question, this is primarily an API data integrity and operational reliability issue rather than a blockchain security vulnerability affecting funds, consensus, or core protocol security.

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service/src/config.rs (L48-85)
```rust
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IndexerGrpcDataServiceConfig {
    /// If given, we will run a server that uses TLS.
    pub data_service_grpc_tls_config: Option<TlsConfig>,
    /// If given, we will run a server that does not use TLS.
    pub data_service_grpc_non_tls_config: Option<NonTlsConfig>,
    /// The size of the response channel that response can be buffered.
    #[serde(default = "IndexerGrpcDataServiceConfig::default_data_service_response_channel_size")]
    pub data_service_response_channel_size: usize,
    /// Deprecated: a list of auth tokens that are allowed to access the service.
    #[serde(default)]
    pub whitelisted_auth_tokens: Vec<String>,
    /// Deprecated: if set, don't check for auth tokens.
    #[serde(default)]
    pub disable_auth_check: bool,
    /// File store config.
    pub file_store_config: IndexerGrpcFileStoreConfig,
    /// Redis read replica address.
    pub redis_read_replica_address: RedisUrl,
    /// Support compressed cache data.
    #[serde(default = "IndexerGrpcDataServiceConfig::default_enable_cache_compression")]
    pub enable_cache_compression: bool,
    #[serde(default)]
    pub in_memory_cache_config: InMemoryCacheConfig,
    /// Any transaction that matches this filter will be stripped. This means we remove
    /// the payload, signature, events, and writesets from it before sending it
    /// downstream. This should only be used in an emergency situation, e.g. when txns
    /// related to a certain module are too large and are causing issues for the data
    /// service. Learn more here:
    ///
    /// https://www.notion.so/aptoslabs/Runbook-c006a37259394ac2ba904d6b54d180fa?pvs=4#171c210964ec42a89574fc80154f9e85
    ///
    /// Generally you will want to start with this with an OR, and then list out
    /// separate filters that describe each type of txn we want to strip.
    #[serde(default = "IndexerGrpcDataServiceConfig::default_txns_to_strip_filter")]
    pub txns_to_strip_filter: BooleanTransactionFilter,
}
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/config.rs (L29-42)
```rust
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IndexerGrpcManagerConfig {
    pub(crate) chain_id: u64,
    pub(crate) service_config: ServiceConfig,
    #[serde(default = "default_cache_config")]
    pub(crate) cache_config: CacheConfig,
    pub(crate) file_store_config: IndexerGrpcFileStoreConfig,
    pub(crate) self_advertised_address: GrpcAddress,
    pub(crate) grpc_manager_addresses: Vec<GrpcAddress>,
    pub(crate) fullnode_addresses: Vec<GrpcAddress>,
    pub(crate) is_master: bool,
    pub(crate) allow_fn_fallback: bool,
}
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service/src/service.rs (L414-463)
```rust
    // Validate chain id
    let mut metadata = file_store_operator.get_file_store_metadata().await;
    while metadata.is_none() {
        metadata = file_store_operator.get_file_store_metadata().await;
        tracing::warn!(
            "[File worker] File store metadata not found. Waiting for {} ms.",
            FILE_STORE_METADATA_WAIT_MS
        );
        tokio::time::sleep(std::time::Duration::from_millis(
            FILE_STORE_METADATA_WAIT_MS,
        ))
        .await;
    }

    let metadata_chain_id = metadata.unwrap().chain_id;

    // Validate redis chain id. Must be present by the time it gets here
    let chain_id = match cache_operator.get_chain_id().await {
        Ok(chain_id) => chain_id.unwrap(),
        Err(e) => {
            ERROR_COUNT
                .with_label_values(&["redis_get_chain_id_failed"])
                .inc();
            // Connection will be dropped anyway, so we ignore the error here.
            let _result = tx
                .send_timeout(
                    Err(Status::unavailable(
                        "[Data Service] Cannot get the chain id from redis; please retry.",
                    )),
                    RESPONSE_CHANNEL_SEND_TIMEOUT,
                )
                .await;
            error!(
                error = e.to_string(),
                "[Data Service] Failed to get chain id from redis."
            );
            return;
        },
    };

    if metadata_chain_id != chain_id {
        let _result = tx
            .send_timeout(
                Err(Status::unavailable("[Data Service] Chain ID mismatch.")),
                RESPONSE_CHANNEL_SEND_TIMEOUT,
            )
            .await;
        error!("[Data Service] Chain ID mismatch.",);
        return;
    }
```

**File:** protos/proto/aptos/indexer/v1/raw_data.proto (L19-33)
```text
message GetTransactionsRequest {
  // Required; start version of current stream.
  optional uint64 starting_version = 1 [jstype = JS_STRING];

  // Optional; number of transactions to return in current stream.
  // If not present, return an infinite stream of transactions.
  optional uint64 transactions_count = 2 [jstype = JS_STRING];

  // Optional; number of transactions in each `TransactionsResponse` for current stream.
  // If not present, default to 1000. If larger than 1000, request will be rejected.
  optional uint64 batch_size = 3;

  // If provided, only transactions that match the filter will be included.
  optional BooleanTransactionFilter transaction_filter = 4;
}
```

**File:** ecosystem/indexer-grpc/indexer-transaction-generator/src/transaction_importer.rs (L40-48)
```rust
            let mut stream = client.get_transactions(request).await?.into_inner();
            while let Some(resp) = stream.message().await.context(format!(
                "[Transaction Importer] Stream ended unexpected for endpoint {:?}",
                self.transaction_stream_endpoint
            ))? {
                let transaction = resp.transactions.first().context(format!(
                    "[Transaction Importer] Transaction at version {} is not in response.",
                    version
                ))?;
```
