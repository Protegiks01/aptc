# Audit Report

## Title
API State Query Inconsistency Due to Sharding Configuration Mismatch

## Summary
The `get_state_values()` function and related pagination methods in `api/src/context.rs` switch between two different data access paths based on the `db_sharding_enabled` configuration flag. This creates a critical mismatch where the configuration check doesn't align with the actual database state check, potentially causing API failures and inconsistent behavior across nodes with different configurations.

## Finding Description

The vulnerability exists in the dual-path state query mechanism implemented in the API layer: [1](#0-0) 

The function checks `db_sharding_enabled(&self.node_config)` to decide between:
1. **Non-sharded path**: Calls `self.db.get_prefixed_state_value_iterator()` 
2. **Sharded path**: Calls `self.indexer_reader.get_prefixed_state_value_iterator()`

However, the actual database reader implementation has its own independent check: [2](#0-1) 

This creates a **configuration-vs-reality mismatch** where:
- The API checks the **configuration value** (`node_config.storage.rocksdb_configs.enable_storage_sharding`)
- The DB checks the **actual database state** (`self.state_kv_db.enabled_sharding()`)

The helper function reads from configuration: [3](#0-2) 

The two data paths use fundamentally different iteration strategies:

**Non-sharded iterator** queries directly from the state_kv DB: [4](#0-3) 

**Sharded iterator** uses the indexer to find keys, then queries the main DB: [5](#0-4) 

## Impact Explanation

This vulnerability breaks the **State Consistency** invariant (Invariant #4) and causes:

1. **Configuration Mismatch Failures**: If `enable_storage_sharding` is set to `false` in config but the database was initialized with sharding enabled, all API calls will fail with "This API is not supported with sharded DB". This can occur during migration periods.

2. **Inter-Node API Inconsistency**: Different fullnodes in the network with different sharding configurations will route queries through different code paths. While both paths should theoretically return the same data, implementation differences could cause subtle inconsistencies.

3. **Missing Indexer Reader**: When `db_sharding_enabled` returns `true`, the code expects `indexer_reader` to exist. If it's `None`, the API fails with "Indexer reader doesn't exist" even if the data exists in the main DB.

This qualifies as **High Severity** under "API crashes" and "Significant protocol violations" categories. While it doesn't directly cause fund loss or consensus breaks, it violates the fundamental assumption that all nodes should provide consistent API responses for the same queries.

## Likelihood Explanation

**High likelihood** during operational scenarios:
- AIP-97 migration requires nodes to update both configuration and database state
- Misconfiguration during rollout is common
- Different node operators may be at different migration stages
- The same pagination functions are used extensively: `get_resources_by_pagination` and `get_modules_by_pagination` are core API endpoints [6](#0-5) 

## Recommendation

Implement a unified consistency check that validates configuration matches database state at startup:

```rust
// In api/src/context.rs Context::new()
pub fn new(
    chain_id: ChainId,
    db: Arc<dyn DbReader>,
    mp_sender: MempoolClientSender,
    node_config: NodeConfig,
    indexer_reader: Option<Arc<dyn IndexerReader>>,
) -> Result<Self> {
    // Validate configuration consistency
    let config_sharding_enabled = db_sharding_enabled(&node_config);
    let db_sharding_enabled = db.is_sharding_enabled()?;
    
    ensure!(
        config_sharding_enabled == db_sharding_enabled,
        "Configuration mismatch: config has sharding={} but DB has sharding={}. \
         Please update node_config.storage.rocksdb_configs.enable_storage_sharding to match DB state.",
        config_sharding_enabled,
        db_sharding_enabled
    );
    
    // When sharding is enabled, require indexer_reader
    if config_sharding_enabled {
        ensure!(
            indexer_reader.is_some(),
            "Indexer reader is required when storage sharding is enabled"
        );
    }
    
    // ... rest of initialization
}
```

Additionally, add a DB method to check actual sharding state:
```rust
// In storage-interface/src/lib.rs
fn is_sharding_enabled(&self) -> Result<bool>;
```

## Proof of Concept

```rust
// Reproduction test showing configuration mismatch
#[test]
fn test_sharding_config_mismatch() {
    // Setup: Create DB with sharding enabled
    let mut db_config = RocksdbConfigs::default();
    db_config.enable_storage_sharding = true;
    let db = AptosDB::new_for_test_with_sharding(&tmp_dir, true);
    
    // Setup: Create node config with sharding disabled  
    let mut node_config = NodeConfig::default();
    node_config.storage.rocksdb_configs.enable_storage_sharding = false;
    
    // Setup: Create Context
    let context = Context::new(
        ChainId::test(),
        Arc::new(db),
        mempool_sender,
        node_config,
        None, // No indexer reader
    );
    
    // Test: Try to query state values
    let address = AccountAddress::random();
    let version = 100;
    
    // This should fail with "This API is not supported with sharded DB"
    let result = context.get_state_values(address, version);
    
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("This API is not supported with sharded DB"));
}
```

## Notes

The configuration enforcement for mainnet/testnet requires explicit sharding: [7](#0-6) 

However, this check only validates the configuration file has the setting, not that it matches the actual database state.

### Citations

**File:** api/src/context.rs (L438-468)
```rust
    pub fn get_state_values(
        &self,
        address: AccountAddress,
        version: u64,
    ) -> Result<HashMap<StateKey, StateValue>> {
        let mut iter = if !db_sharding_enabled(&self.node_config) {
            Box::new(
                self.db
                    .get_prefixed_state_value_iterator(
                        &StateKeyPrefix::from(address),
                        None,
                        version,
                    )?
                    .map(|item| item.map_err(|err| anyhow!(err.to_string()))),
            )
        } else {
            self.indexer_reader
                .as_ref()
                .ok_or_else(|| format_err!("Indexer reader doesn't exist"))?
                .get_prefixed_state_value_iterator(&StateKeyPrefix::from(address), None, version)?
        };

        let kvs = iter
            .by_ref()
            .take(MAX_REQUEST_LIMIT as usize)
            .collect::<Result<_>>()?;
        if iter.next().transpose()?.is_some() {
            bail!("Too many state items under account ({:?}).", address);
        }
        Ok(kvs)
    }
```

**File:** api/src/context.rs (L1771-1773)
```rust
fn db_sharding_enabled(node_config: &NodeConfig) -> bool {
    node_config.storage.rocksdb_configs.enable_storage_sharding
}
```

**File:** storage/aptosdb/src/db/aptosdb_reader.rs (L78-97)
```rust
    fn get_prefixed_state_value_iterator(
        &self,
        key_prefix: &StateKeyPrefix,
        cursor: Option<&StateKey>,
        version: Version,
    ) -> Result<Box<dyn Iterator<Item = Result<(StateKey, StateValue)>> + '_>> {
        gauged_api("get_prefixed_state_value_iterator", || {
            ensure!(
                !self.state_kv_db.enabled_sharding(),
                "This API is not supported with sharded DB"
            );
            self.error_if_state_kv_pruned("StateValue", version)?;

            Ok(Box::new(
                self.state_store
                    .get_prefixed_state_value_iterator(key_prefix, cursor, version)?,
            )
                as Box<dyn Iterator<Item = Result<(StateKey, StateValue)>>>)
        })
    }
```

**File:** storage/aptosdb/src/utils/iterators.rs (L148-179)
```rust
    fn next_by_kv(&mut self) -> Result<Option<(StateKey, StateValue)>> {
        let iter = self.kv_iter.as_mut().unwrap();
        if !self.is_finished {
            while let Some(((state_key, version), state_value_opt)) = iter.next().transpose()? {
                // In case the previous seek() ends on the same key with version 0.
                if Some(&state_key) == self.prev_key.as_ref() {
                    continue;
                }
                // Cursor is currently at the first available version of the state key.
                // Check if the key_prefix is a valid prefix of the state_key we got from DB.
                if !self.key_prefix.is_prefix(&state_key)? {
                    // No more keys matching the key_prefix, we can return the result.
                    self.is_finished = true;
                    break;
                }

                if version > self.desired_version {
                    iter.seek(&(state_key.clone(), self.desired_version))?;
                    continue;
                }

                self.prev_key = Some(state_key.clone());
                // Seek to the next key - this can be done by seeking to the current key with version 0
                iter.seek(&(state_key.clone(), 0))?;

                if let Some(state_value) = state_value_opt {
                    return Ok(Some((state_key, state_value)));
                }
            }
        }
        Ok(None)
    }
```

**File:** storage/indexer/src/utils.rs (L49-75)
```rust
    pub fn next_impl(&mut self) -> anyhow::Result<Option<(StateKey, StateValue)>> {
        let iter = &mut self.state_keys_iter;
        if self.is_finished {
            return Ok(None);
        }
        while let Some((state_key, _)) = iter.next().transpose()? {
            if !self.key_prefix.is_prefix(&state_key)? {
                self.is_finished = true;
                return Ok(None);
            }

            match self
                .main_db
                .get_state_value_by_version(&state_key, self.desired_version)?
            {
                Some(state_value) => {
                    return Ok(Some((state_key, state_value)));
                },
                None => {
                    // state key doesn't have value before the desired version, continue to next state key
                    continue;
                },
            }
        }
        Ok(None)
    }
}
```

**File:** api/src/accounts.rs (L448-471)
```rust
    pub fn resources(self, accept_type: &AcceptType) -> BasicResultWith404<Vec<MoveResource>> {
        let max_account_resources_page_size = self.context.max_account_resources_page_size();
        let (resources, next_state_key) = self
            .context
            .get_resources_by_pagination(
                self.address.into(),
                self.start.as_ref(),
                self.ledger_version,
                // Just use the max as the default
                determine_limit(
                    self.limit,
                    max_account_resources_page_size,
                    max_account_resources_page_size,
                    &self.latest_ledger_info,
                )? as u64,
            )
            .context("Failed to get resources from storage")
            .map_err(|err| {
                BasicErrorWith404::internal_with_code(
                    err,
                    AptosErrorCode::InternalError,
                    &self.latest_ledger_info,
                )
            })?;
```

**File:** config/src/config/storage_config.rs (L664-668)
```rust
            if (chain_id.is_testnet() || chain_id.is_mainnet())
                && config_yaml["rocksdb_configs"]["enable_storage_sharding"].as_bool() != Some(true)
            {
                panic!("Storage sharding (AIP-97) is not enabled in node config. Please follow the guide to migration your node, and set storage.rocksdb_configs.enable_storage_sharding to true explicitly in your node config. https://aptoslabs.notion.site/DB-Sharding-Migration-Public-Full-Nodes-1978b846eb7280b29f17ceee7d480730");
            }
```
