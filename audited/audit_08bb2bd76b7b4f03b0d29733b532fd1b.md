# Audit Report

## Title
Incomplete Framework Reserved Address Validation in Account Creation Function

## Summary
The `create_account_if_does_not_exist` function in the account module fails to validate all framework reserved addresses (0x1-0xa), only checking three addresses (@vm_reserved, @aptos_framework, @aptos_token) instead of the complete set defined in the system specification. This creates a formal verification gap where the implementation does not match the documented security invariants.

## Finding Description
The Aptos framework reserves addresses 0x1 through 0xa for system use under governance control. The formal specification explicitly states this requirement: [1](#0-0) 

The `system_addresses.move` module implements `is_framework_reserved_address()` which correctly validates all addresses from 0x1 to 0xa: [2](#0-1) 

However, the `create_account_if_does_not_exist` function only checks three addresses: [3](#0-2) 

This means addresses 0x2, 0x4 (@aptos_token_objects), 0x5, 0x6, 0x7 (@aptos_experimental), 0x8, 0x9, and 0xa (@aptos_fungible_asset) are not protected by this validation, as confirmed by the named address configuration: [4](#0-3) 

While genesis initialization correctly creates all reserved addresses using the properly-validated `create_framework_reserved_account` function: [5](#0-4) 

The incomplete validation in `create_account_if_does_not_exist` violates the documented invariant that all addresses 0x1-0xa must be protected.

## Impact Explanation
**Severity: Medium**

This issue represents a **formal verification gap** rather than a directly exploitable vulnerability. In practice, genesis creates all framework reserved addresses before any user transactions execute, preventing exploitation. However, this incomplete validation violates Critical Invariant #8 ("Access Control: System addresses must be protected") and creates technical debt that could become exploitable if:

1. Code refactoring changes genesis ordering
2. New execution paths bypass genesis
3. Future features allow account creation in unexpected contexts

The Aptos VM calls this function for sponsored transactions, which theoretically could target these addresses if the execution flow were compromised: [6](#0-5) 

## Likelihood Explanation
**Likelihood: Low**

Current exploitation is effectively impossible because:
- Genesis atomically creates all addresses 0x1-0xa before any transactions run
- Transactions cannot be sent from addresses without valid signatures
- Framework address keys are controlled by governance through SignerCapabilities

However, the formal verification gap exists and violates stated invariants, warranting correction to maintain specification compliance.

## Recommendation
Update `create_account_if_does_not_exist` to use the complete framework reserved address check:

```move
public fun create_account_if_does_not_exist(account_address: address) {
    if (!resource_exists_at(account_address)) {
        assert!(
            !system_addresses::is_framework_reserved_address(account_address) && 
            account_address != @vm_reserved,
            error::invalid_argument(ECANNOT_RESERVED_ADDRESS)
        );
        create_account_unchecked(account_address);
    }
}
```

This ensures all addresses from 0x0-0xa are properly protected, aligning implementation with specification and preventing potential future vulnerabilities.

## Proof of Concept
```move
#[test(account = @0x4)]
#[expected_failure(abort_code = 0x10005, location = aptos_framework::account)]
fun test_cannot_create_token_objects_address(account: signer) {
    // This should fail but currently only checks @vm_reserved, @aptos_framework, @aptos_token
    // Address 0x4 (@aptos_token_objects) is reserved but not validated
    account::create_account_if_does_not_exist(@0x4);
}
```

Note: This test would pass (correctly aborting) if run against a properly initialized chain because genesis creates the account first. The vulnerability is the formal verification gap in the validation logic itself.

## Notes
While this finding represents a genuine formal verification gap where code diverges from specification, the practical security impact is mitigated by genesis initialization creating these addresses first. This should be fixed to maintain specification compliance and prevent potential future exploitation if execution flows change.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/account/account.spec.move (L616-616)
```text
    /// The system reserved addresses is @0x1 / @0x2 / @0x3 / @0x4 / @0x5  / @0x6 / @0x7 / @0x8 / @0x9 / @0xa.
```

**File:** aptos-move/framework/aptos-framework/sources/system_addresses.move (L45-56)
```text
    public fun is_framework_reserved_address(addr: address): bool {
        is_aptos_framework_address(addr) ||
            addr == @0x2 ||
            addr == @0x3 ||
            addr == @0x4 ||
            addr == @0x5 ||
            addr == @0x6 ||
            addr == @0x7 ||
            addr == @0x8 ||
            addr == @0x9 ||
            addr == @0xa
    }
```

**File:** aptos-move/framework/aptos-framework/sources/account/account.move (L276-284)
```text
    public fun create_account_if_does_not_exist(account_address: address) {
        if (!resource_exists_at(account_address)) {
            assert!(
                account_address != @vm_reserved && account_address != @aptos_framework && account_address != @aptos_token,
                error::invalid_argument(ECANNOT_RESERVED_ADDRESS)
            );
            create_account_unchecked(account_address);
        }
    }
```

**File:** aptos-move/framework/src/aptos.rs (L190-209)
```rust
static NAMED_ADDRESSES: Lazy<BTreeMap<String, NumericalAddress>> = Lazy::new(|| {
    let mut result = BTreeMap::new();
    let zero = NumericalAddress::parse_str("0x0").unwrap();
    let one = NumericalAddress::parse_str("0x1").unwrap();
    let three = NumericalAddress::parse_str("0x3").unwrap();
    let four = NumericalAddress::parse_str("0x4").unwrap();
    let seven = NumericalAddress::parse_str("0x7").unwrap();
    let ten = NumericalAddress::parse_str("0xA").unwrap();
    let resources = NumericalAddress::parse_str("0xA550C18").unwrap();
    result.insert("std".to_owned(), one);
    result.insert("aptos_std".to_owned(), one);
    result.insert("aptos_framework".to_owned(), one);
    result.insert("aptos_token".to_owned(), three);
    result.insert("aptos_token_objects".to_owned(), four);
    result.insert("aptos_experimental".to_owned(), seven);
    result.insert("aptos_fungible_asset".to_owned(), ten);
    result.insert("core_resources".to_owned(), resources);
    result.insert("vm".to_owned(), zero);
    result.insert("vm_reserved".to_owned(), zero);
    result
```

**File:** aptos-move/framework/aptos-framework/sources/genesis.move (L101-106)
```text
        let framework_reserved_addresses = vector<address>[@0x2, @0x3, @0x4, @0x5, @0x6, @0x7, @0x8, @0x9, @0xa];
        while (!vector::is_empty(&framework_reserved_addresses)) {
            let address = vector::pop_back<address>(&mut framework_reserved_addresses);
            let (_, framework_signer_cap) = account::create_framework_reserved_account(address);
            aptos_governance::store_signer_cap(&aptos_framework_account, address, framework_signer_cap);
        };
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L713-719)
```rust
                create_account_if_does_not_exist(
                    session,
                    module_storage,
                    gas_meter,
                    txn_data.sender(),
                    traversal_context,
                )
```
