# Audit Report

## Title
Missing Data Integrity Validation in Quorum Store Database Schema Layer Enables State Corruption via Malformed Persisted Data

## Summary
The quorum store schema module lacks data validation constraints when persisting and loading batch data. While validation occurs at network boundaries, the database layer accepts and serves potentially malformed data without verification, creating a defense-in-depth vulnerability that could lead to consensus divergence if exploited through code bugs or data corruption.

## Finding Description

The quorum store schema module provides database serialization for batch data but performs **zero validation** of data integrity constraints. This breaks the **State Consistency** invariant (#4) and creates risk for **Deterministic Execution** (#1). [1](#0-0) 

The schema's `ValueCodec` implementations blindly serialize/deserialize using BCS without checking that the payload matches the metadata in `BatchInfo` (digest, num_txns, num_bytes, gas_bucket_start). [2](#0-1) 

When data is loaded from the database and converted from `PersistedValue` to `Batch`, no validation occurs: [3](#0-2) 

This conversion creates a `Batch` without calling the `verify()` method that would check payload consistency: [4](#0-3) 

When nodes restart and repopulate the cache, all database entries are loaded without validation: [5](#0-4) 

The loaded data is then served to other nodes without re-validation: [6](#0-5) 

## Impact Explanation

This qualifies as **Medium Severity** (up to $10,000) - "State inconsistencies requiring intervention":

1. **Consensus Divergence Risk**: If malformed data (mismatched digest, incorrect transaction counts) enters the database through any code path bug, it will be loaded on restart and could cause different nodes to process batches differently, violating deterministic execution.

2. **Data Integrity Weakness**: The lack of validation means the database becomes a trusted data store without integrity checks. Any bug in the persistence logic, memory corruption, or disk corruption could introduce inconsistent state that propagates through the system.

3. **Recovery Complexity**: Once malformed data is in the database, it requires manual intervention to detect and repair, as there are no automated integrity checks.

## Likelihood Explanation

**Likelihood: Low-Medium**

While direct exploitation by an external attacker is not feasible (all network paths are validated), the vulnerability can be triggered by:

1. **Software Bugs**: Any future bug in the persistence code path that creates inconsistent `PersistedValue` objects
2. **Disk Corruption**: Hardware failures that corrupt database files
3. **Race Conditions**: Potential races between validation and persistence under high load
4. **Upgrade Bugs**: Schema migration errors during version upgrades

The current code has validation at network boundaries, reducing immediate risk. However, defense-in-depth requires validation at the storage layer to catch bugs before they cause consensus issues.

## Recommendation

Add data integrity validation to the schema layer and database operations:

**1. Add validation to `PersistedValue::new()`**:
```rust
impl<T: TBatchInfo> PersistedValue<T> {
    pub(crate) fn new(info: T, maybe_payload: Option<Vec<SignedTransaction>>) -> anyhow::Result<Self> {
        // Validate payload matches info if payload exists
        if let Some(payload) = &maybe_payload {
            let batch_payload = BatchPayload::new(info.author(), payload.clone());
            ensure!(
                batch_payload.hash() == *info.digest(),
                "Payload hash doesn't match batch info digest"
            );
            ensure!(
                batch_payload.num_txns() as u64 == info.num_txns(),
                "Payload num_txns doesn't match batch info"
            );
            ensure!(
                batch_payload.num_bytes() as u64 == info.num_bytes(),
                "Payload num_bytes doesn't match batch info"
            );
        }
        Ok(Self { info, maybe_payload })
    }
}
```

**2. Add validation when loading from database**:
```rust
fn get_batch(&self, digest: &HashValue) -> Result<Option<PersistedValue<BatchInfo>>, DbError> {
    if let Some(value) = self.db.get::<BatchSchema>(digest)? {
        // Validate before returning
        if let Some(payload) = value.payload() {
            let batch: Batch<BatchInfo> = value.clone().try_into()?;
            batch.verify().map_err(|e| DbError::Other(e.to_string()))?;
        }
        Ok(Some(value))
    } else {
        Ok(None)
    }
}
```

**3. Add validation when converting `PersistedValue` to `Batch`**:
```rust
impl<T: TBatchInfo> TryFrom<PersistedValue<T>> for Batch<T> {
    type Error = anyhow::Error;
    
    fn try_from(value: PersistedValue<T>) -> Result<Self, Self::Error> {
        let author = value.author();
        let batch = Batch {
            batch_info: value.info,
            payload: BatchPayload::new(
                author,
                value.maybe_payload.ok_or_else(|| anyhow::anyhow!("Payload not exist"))?,
            ),
        };
        // Validate before returning
        batch.verify()?;
        Ok(batch)
    }
}
```

## Proof of Concept

```rust
// Rust test demonstrating the vulnerability
#[test]
fn test_malformed_persisted_value_not_validated() {
    use aptos_consensus_types::proof_of_store::BatchInfo;
    use aptos_crypto::HashValue;
    use aptos_types::transaction::SignedTransaction;
    
    // Create a BatchInfo with specific metadata
    let batch_info = BatchInfo::new(
        PeerId::random(),
        BatchId::new_for_test(1),
        1, // epoch
        1000, // expiration
        HashValue::random(), // digest - doesn't match payload!
        10, // num_txns - wrong!
        5000, // num_bytes - wrong!
        100, // gas_bucket_start
    );
    
    // Create a different payload that doesn't match
    let wrong_payload: Vec<SignedTransaction> = vec![]; // Empty, but batch_info says 10 txns
    
    // PersistedValue::new accepts this without validation!
    let persisted = PersistedValue::new(batch_info, Some(wrong_payload));
    
    // This would be serialized and stored in the database
    let encoded = bcs::to_bytes(&persisted).unwrap();
    
    // On restart, it's deserialized without validation
    let decoded: PersistedValue<BatchInfo> = bcs::from_bytes(&encoded).unwrap();
    
    // Converting to Batch doesn't validate either
    let batch: Batch<BatchInfo> = decoded.try_into().unwrap();
    
    // Only when verify() is explicitly called does it fail
    assert!(batch.verify().is_err()); // This should fail!
}
```

**Notes**

While the immediate exploitability is limited due to validation at network boundaries, this represents a significant defense-in-depth weakness. The database should serve as a trusted integrity checkpoint, not just a data dump. The lack of validation means any future bug in the persistence logic could introduce consensus-breaking state that persists across restarts and propagates through the network via batch serving.

### Citations

**File:** consensus/src/quorum_store/schema.rs (L38-46)
```rust
impl ValueCodec<BatchSchema> for PersistedValue<BatchInfo> {
    fn encode_value(&self) -> Result<Vec<u8>> {
        Ok(bcs::to_bytes(&self)?)
    }

    fn decode_value(data: &[u8]) -> Result<Self> {
        Ok(bcs::from_bytes(data)?)
    }
}
```

**File:** consensus/src/quorum_store/quorum_store_db.rs (L110-117)
```rust
    fn save_batch(&self, batch: PersistedValue<BatchInfo>) -> Result<(), DbError> {
        trace!(
            "QS: db persists digest {} expiration {:?}",
            batch.digest(),
            batch.expiration()
        );
        self.put::<BatchSchema>(batch.digest(), &batch)
    }
```

**File:** consensus/src/quorum_store/types.rs (L95-109)
```rust
impl<T: TBatchInfo> TryFrom<PersistedValue<T>> for Batch<T> {
    type Error = anyhow::Error;

    fn try_from(value: PersistedValue<T>) -> Result<Self, Self::Error> {
        let author = value.author();
        Ok(Batch {
            batch_info: value.info,
            payload: BatchPayload::new(
                author,
                value
                    .maybe_payload
                    .ok_or_else(|| anyhow::anyhow!("Payload not exist"))?,
            ),
        })
    }
```

**File:** consensus/src/quorum_store/types.rs (L262-290)
```rust
    pub fn verify(&self) -> anyhow::Result<()> {
        ensure!(
            self.payload.author() == self.author(),
            "Payload author doesn't match the info"
        );
        ensure!(
            self.payload.hash() == *self.digest(),
            "Payload hash doesn't match the digest"
        );
        ensure!(
            self.payload.num_txns() as u64 == self.num_txns(),
            "Payload num txns doesn't match batch info"
        );
        ensure!(
            self.payload.num_bytes() as u64 == self.num_bytes(),
            "Payload num bytes doesn't match batch info"
        );
        for txn in self.payload.txns() {
            ensure!(
                txn.gas_unit_price() >= self.gas_bucket_start(),
                "Payload gas unit price doesn't match batch info"
            );
            ensure!(
                !txn.payload().is_encrypted_variant(),
                "Encrypted transaction is not supported yet"
            );
        }
        Ok(())
    }
```

**File:** consensus/src/quorum_store/batch_store.rs (L292-325)
```rust
    fn populate_cache_and_gc_expired_batches_v2(
        db: Arc<dyn QuorumStoreStorage>,
        current_epoch: u64,
        last_certified_time: u64,
        expiration_buffer_usecs: u64,
        batch_store: &BatchStore,
    ) {
        let db_content = db
            .get_all_batches_v2()
            .expect("failed to read v1 data from db");
        info!(
            epoch = current_epoch,
            "QS: Read v1 batches from storage. Len: {}, Last Cerified Time: {}",
            db_content.len(),
            last_certified_time
        );

        let mut expired_keys = Vec::new();
        let gc_timestamp = last_certified_time.saturating_sub(expiration_buffer_usecs);
        for (digest, value) in db_content {
            let expiration = value.expiration();
            trace!(
                "QS: Batchreader recovery content exp {:?}, digest {}",
                expiration,
                digest
            );

            if expiration < gc_timestamp {
                expired_keys.push(digest);
            } else {
                batch_store
                    .insert_to_cache(&value)
                    .expect("Storage limit exceeded upon BatchReader construction");
            }
```

**File:** consensus/src/quorum_store/quorum_store_builder.rs (L408-415)
```rust
                let response = if let Ok(value) =
                    batch_store.get_batch_from_local(&rpc_request.req.digest())
                {
                    let batch: Batch<BatchInfoExt> = value.try_into().unwrap();
                    let batch: Batch<BatchInfo> = batch
                        .try_into()
                        .expect("Batch retieval requests must be for V1 batch");
                    BatchResponse::Batch(batch)
```
