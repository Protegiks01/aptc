# Audit Report

## Title
Faucet `is_eligible()` Endpoint Provides Incomplete Transaction Validation Leading to False Positive Eligibility Responses

## Summary
The `is_eligible()` endpoint calls `funder.fund()` with `check_only=true`, performing only preliminary checks without executing the full blockchain transaction validation (prologue checks). This causes false positives where users are told they're eligible but actual funding transactions fail due to blockchain-level validation failures.

## Finding Description

The `is_eligible()` function is designed to validate whether a funding request will succeed before actual transaction submission. [1](#0-0) 

It calls `funder.fund()` with `check_only=true`: [2](#0-1) 

However, when `check_only=true`, the TransferFunder only performs limited checks: [3](#0-2) 

And returns without transaction submission: [4](#0-3) 

**Critical Gap**: These checks do NOT include the blockchain's prologue validation that occurs during actual transaction submission. The prologue performs additional checks including: [5](#0-4) 

Specifically, the prologue validates:
1. Transaction expiration timestamp
2. Chain ID matching
3. Authentication key verification
4. Exact sequence number matching (not just >= check)
5. Gas payer balance sufficient for `txn_gas_price * txn_max_gas_units`

The sequence number check requires exact match: [6](#0-5) 

And gas payment verification: [7](#0-6) 

## Impact Explanation

**Severity: Medium** per Aptos bug bounty criteria - "State inconsistencies requiring intervention"

1. **False Positive Guarantees**: Users receive eligibility confirmation but transactions fail, violating API contract expectations
2. **State Inconsistency**: Checker systems may record eligibility decisions that don't match actual funding outcomes: [8](#0-7) 
3. **Resource Waste**: Rate limiting quotas consumed without successful funding
4. **Sequence Number Races**: Concurrent requests can cause sequence number mismatches undetected by `is_eligible()`
5. **Gas Exhaustion Scenarios**: Funder may pass health checks but lack gas payment capacity when transactions execute

While this affects a testnet/devnet service, it creates operational inconsistencies and violates the stated purpose of the eligibility check.

## Likelihood Explanation

**High Likelihood** - This will occur regularly in normal operations:

1. **Sequence Number Races**: When multiple funding requests are processed concurrently, the sequence number checked by `is_eligible()` becomes stale before transaction submission
2. **Gas Price Volatility**: The gas payment check uses current balance but doesn't account for pending transactions' gas consumption
3. **Network Delays**: Time gap between `is_eligible()` and `fund()` calls allows blockchain state changes

## Recommendation

Add comprehensive prologue simulation to `is_eligible()`:

```rust
async fn is_eligible(...) -> poem::Result<(), AptosTapErrorResponse> {
    let (checker_data, bypass, _semaphore_permit) = self
        .components
        .preprocess_request(&fund_request.0, source_ip, header_map, true)
        .await?;

    if bypass {
        return Ok(());
    }

    // NEW: Perform transaction validation simulation
    self.components
        .validate_transaction_would_succeed(
            fund_request.amount,
            checker_data.receiver,
            asset.0,
        )
        .await?;

    Ok(())
}
```

Implement `validate_transaction_would_succeed()` to:
1. Build the actual transaction that would be submitted
2. Call blockchain simulation APIs to validate prologue checks
3. Return errors matching actual transaction rejection reasons

This ensures `is_eligible()` responses accurately reflect whether funding will succeed.

## Proof of Concept

```rust
#[tokio::test]
async fn test_is_eligible_false_positive_sequence_race() {
    // Setup faucet with TransferFunder
    let faucet = setup_test_faucet().await;
    let receiver = generate_test_address();
    
    // Call is_eligible() - returns OK
    let eligible_response = faucet
        .is_eligible(FundRequest {
            address: Some(receiver.to_string()),
            amount: Some(100_000),
            ..Default::default()
        })
        .await;
    assert!(eligible_response.is_ok());
    
    // Simulate sequence number advance from concurrent transaction
    advance_funder_sequence_number(&faucet).await;
    
    // Actual funding fails with PROLOGUE_ESEQUENCE_NUMBER_TOO_OLD
    let fund_response = faucet
        .fund(FundRequest {
            address: Some(receiver.to_string()),
            amount: Some(100_000),
            ..Default::default()
        })
        .await;
    
    assert!(fund_response.is_err());
    assert_eq!(
        fund_response.unwrap_err().error_code,
        AptosTapErrorCode::TransactionFailed
    );
    // Demonstrates is_eligible() gave false positive
}
```

## Notes

This vulnerability stems from the fundamental mismatch between pre-submission checks (`check_only=true`) and actual blockchain validation (prologue execution). The gap creates a TOCTOU (Time-of-Check-Time-of-Use) vulnerability where state changes between eligibility verification and transaction submission cause unexpected failures. While the faucet operates on testnet, the pattern violates security invariant #7 (Transaction Validation) by providing incomplete validation guarantees.

### Citations

**File:** crates/aptos-faucet/core/src/endpoints/fund.rs (L121-126)
```rust
    /// Check whether a given requester is eligible to be funded
    ///
    /// This function runs only the various eligibility checks that we perform
    /// in `fund` without actually funding the account or writing anything to
    /// storage. If the request is valid it returns an empty 200. If it is invalid
    /// it returns a 400 or 403 with an explanation in the response body.
```

**File:** crates/aptos-faucet/core/src/endpoints/fund.rs (L155-164)
```rust
        self.components
            .funder
            .fund(
                fund_request.amount,
                checker_data.receiver,
                asset.0,
                true,
                bypass,
            )
            .await?;
```

**File:** crates/aptos-faucet/core/src/endpoints/fund.rs (L329-347)
```rust
        // Give all Checkers the chance to run the completion step. We should
        // monitor for failures in these steps because they could lead to an
        // unintended data state.
        if !bypass {
            let response_is_500 = match &fund_result {
                Ok(_) => false,
                Err(e) => e.error_code.status().is_server_error(),
            };
            let complete_data = CompleteData {
                checker_data,
                txn_hashes: txn_hashes.clone(),
                response_is_500,
            };
            for checker in &self.checkers {
                checker.complete(complete_data.clone()).await.map_err(|e| {
                    AptosTapError::new_with_error_code(e, AptosTapErrorCode::CheckerError)
                })?;
            }
        }
```

**File:** crates/aptos-faucet/core/src/funder/transfer.rs (L263-306)
```rust
    async fn fund(
        &self,
        amount: Option<u64>,
        receiver_address: AccountAddress,
        _asset: Option<String>,
        check_only: bool,
        did_bypass_checkers: bool,
    ) -> Result<Vec<SignedTransaction>, AptosTapError> {
        // Confirm the funder has sufficient balance, return a 500 if not. This
        // will only happen briefly, soon after we get into this state the LB
        // will deregister this instance based on the health check responses
        // being returned from `/`.
        self.is_healthy_as_result().await?;

        let client = self.get_api_client();

        // Determine amount to fund.
        let amount = self.get_amount(amount, did_bypass_checkers);

        // Update the sequence numbers of the accounts.
        // TransferFunder always uses DEFAULT_ASSET_NAME since it only handles a single asset.
        let (_funder_seq_num, receiver_seq_num) = update_sequence_numbers(
            &client,
            &self.faucet_account,
            &self.outstanding_requests,
            receiver_address,
            amount,
            self.wait_for_outstanding_txns_secs,
            DEFAULT_ASSET_NAME,
        )
        .await?;

        // When updating the sequence numbers, we expect that the receiver sequence
        // number should be None, because the account should not exist yet.
        if receiver_seq_num.is_some() {
            return Err(AptosTapError::new(
                "Account ineligible".to_string(),
                AptosTapErrorCode::Rejected,
            )
            .rejection_reasons(vec![RejectionReason::new(
                format!("Account {} already exists", receiver_address),
                RejectionReasonCode::AccountAlreadyExists,
            )]));
        }
```

**File:** crates/aptos-faucet/core/src/funder/transfer.rs (L311-328)
```rust
        let transactions = if check_only {
            vec![]
        } else {
            let txn = self
                .execute_transaction(
                    &client,
                    aptos_stdlib::aptos_account_transfer(receiver_address, amount),
                    &receiver_address,
                )
                .await?;
            info!(
                hash = txn.committed_hash().to_hex_literal(),
                address = receiver_address,
                amount = amount,
                event = "transaction_submitted"
            );
            vec![txn]
        };
```

**File:** aptos-move/framework/aptos-framework/sources/transaction_validation.move (L126-213)
```text
    fun prologue_common(
        sender: &signer,
        gas_payer: &signer,
        replay_protector: ReplayProtector,
        txn_authentication_key: Option<vector<u8>>,
        txn_gas_price: u64,
        txn_max_gas_units: u64,
        txn_expiration_time: u64,
        chain_id: u8,
        is_simulation: bool,
    ) {
        let sender_address = signer::address_of(sender);
        let gas_payer_address = signer::address_of(gas_payer);
        assert!(
            timestamp::now_seconds() < txn_expiration_time,
            error::invalid_argument(PROLOGUE_ETRANSACTION_EXPIRED),
        );
        assert!(chain_id::get() == chain_id, error::invalid_argument(PROLOGUE_EBAD_CHAIN_ID));

        // TODO[Orderless]: Here, we are maintaining the same order of validation steps as before orderless txns were introduced.
        // Ideally, do the replay protection check in the end after the authentication key check and gas payment checks.

        // Check if the authentication key is valid
        if (!skip_auth_key_check(is_simulation, &txn_authentication_key)) {
            if (option::is_some(&txn_authentication_key)) {
                if (
                    sender_address == gas_payer_address ||
                    account::exists_at(sender_address) ||
                    !features::sponsored_automatic_account_creation_enabled()
                ) {
                    assert!(
                        txn_authentication_key == option::some(account::get_authentication_key(sender_address)),
                        error::invalid_argument(PROLOGUE_EINVALID_ACCOUNT_AUTH_KEY),
                    );
                };
            } else {
                assert!(
                    allow_missing_txn_authentication_key(sender_address),
                    error::invalid_argument(PROLOGUE_EINVALID_ACCOUNT_AUTH_KEY)
                );
            };
        };

        // Check for replay protection
        match (replay_protector) {
            SequenceNumber(txn_sequence_number) => {
                check_for_replay_protection_regular_txn(
                    sender_address,
                    gas_payer_address,
                    txn_sequence_number,
                );
            },
            Nonce(nonce) => {
                check_for_replay_protection_orderless_txn(
                    sender_address,
                    nonce,
                    txn_expiration_time,
                );
            }
        };

        // Check if the gas payer has enough balance to pay for the transaction
        let max_transaction_fee = txn_gas_price * txn_max_gas_units;
        if (!skip_gas_payment(
            is_simulation,
            gas_payer_address
        )) {
            assert!(
                permissioned_signer::check_permission_capacity_above(
                    gas_payer,
                    (max_transaction_fee as u256),
                    GasPermission {}
                ),
                error::permission_denied(PROLOGUE_PERMISSIONED_GAS_LIMIT_INSUFFICIENT)
            );
            if (features::operations_default_to_fa_apt_store_enabled()) {
                assert!(
                    aptos_account::is_fungible_balance_at_least(gas_payer_address, max_transaction_fee),
                    error::invalid_argument(PROLOGUE_ECANT_PAY_GAS_DEPOSIT)
                );
            } else {
                assert!(
                    coin::is_balance_at_least<AptosCoin>(gas_payer_address, max_transaction_fee),
                    error::invalid_argument(PROLOGUE_ECANT_PAY_GAS_DEPOSIT)
                );
            }
        };
    }
```

**File:** aptos-move/framework/aptos-framework/sources/transaction_validation.move (L215-250)
```text
    fun check_for_replay_protection_regular_txn(
        sender_address: address,
        gas_payer_address: address,
        txn_sequence_number: u64,
    ) {
        if (
            sender_address == gas_payer_address
                || account::exists_at(sender_address)
                || !features::sponsored_automatic_account_creation_enabled()
                || txn_sequence_number > 0
        ) {
            assert!(account::exists_at(sender_address), error::invalid_argument(PROLOGUE_EACCOUNT_DOES_NOT_EXIST));
            let account_sequence_number = account::get_sequence_number(sender_address);
            assert!(
                txn_sequence_number < (1u64 << 63),
                error::out_of_range(PROLOGUE_ESEQUENCE_NUMBER_TOO_BIG)
            );

            assert!(
                txn_sequence_number >= account_sequence_number,
                error::invalid_argument(PROLOGUE_ESEQUENCE_NUMBER_TOO_OLD)
            );

            assert!(
                txn_sequence_number == account_sequence_number,
                error::invalid_argument(PROLOGUE_ESEQUENCE_NUMBER_TOO_NEW)
            );
        } else {
            // In this case, the transaction is sponsored and the account does not exist, so ensure
            // the default values match.
            assert!(
                txn_sequence_number == 0,
                error::invalid_argument(PROLOGUE_ESEQUENCE_NUMBER_TOO_NEW)
            );
        };
    }
```
