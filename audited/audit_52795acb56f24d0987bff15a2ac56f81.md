# Audit Report

## Title
Missing State Root Verification in Fast Sync Finalization Allows Silent State Corruption

## Summary
The `finalize_state_snapshot()` function completes state snapshot restoration without verifying that the final state root hash in the database matches the `expected_root_hash` provided to `get_state_snapshot_receiver()`. This allows silent state corruption during fast sync operations, breaking the fundamental invariant that all validators must have identical state roots for the same version.

## Finding Description

The fast sync flow operates as follows:

1. `get_state_snapshot_receiver()` is called with an `expected_root_hash` extracted from the transaction info's state checkpoint hash [1](#0-0) 

2. This creates a `StateSnapshotRestore` that stores the expected root hash in the underlying `JellyfishMerkleRestore` [2](#0-1) 

3. State chunks are added via `add_chunk()`, which verifies each chunk against the expected root using Merkle proofs [3](#0-2) 

4. **CRITICAL VULNERABILITY**: When restoration completes via `finish_impl()`, the function freezes all nodes and writes them to storage WITHOUT verifying the final root hash [4](#0-3) 

5. The wrapper's `finalize_state_snapshot()` then saves transaction metadata without any root hash verification [5](#0-4) 

6. The state sync flow completes without checking if the actual state root matches the expected value [6](#0-5) 

**Attack Vector**: A malicious state sync peer or buggy implementation could provide:
- Incomplete state chunks that pass intermediate Merkle proof verification
- Corrupted state data that produces a different final root hash
- State chunks that are prematurely finalized before all data is received

The system would accept this corrupted state without detection, causing the validator to have a different state root than honest peers.

## Impact Explanation

**Critical Severity** - This vulnerability breaks the most fundamental blockchain invariant: **Deterministic Execution** (all validators must produce identical state roots for identical blocks).

**Consensus Safety Violation**: Different validators syncing from different peers could end up with different state roots for the same version, leading to:
- Chain splits when validators execute subsequent transactions
- Byzantine behavior appearing from honest nodes
- Non-recoverable network partition requiring manual intervention or hardfork
- Loss of funds due to incorrect state (e.g., incorrect account balances, missing resources)

**State Consistency Violation**: The corrupted state cannot be detected until:
- Transaction execution produces different results
- Validators fail to reach consensus on subsequent blocks
- State proofs fail verification against published ledger infos

This satisfies multiple **Critical Severity** categories:
- Consensus/Safety violations
- Non-recoverable network partition (requires hardfork)
- Potential loss of funds (incorrect state balances)

## Likelihood Explanation

**High Likelihood** in production environments:

1. **Fast sync is the default bootstrapping mode** for new validators joining the network [7](#0-6) 

2. **No authentication of state sync peers**: Any network peer can serve state chunks, including malicious actors

3. **Multiple failure modes**:
   - Malicious peers intentionally serving corrupted state
   - Network errors causing incomplete chunk delivery
   - Race conditions in state sync chunk processing
   - Bugs in Merkle proof generation/verification logic

4. **Silent failure**: The corruption is not detected at finalization time, making debugging extremely difficult

## Recommendation

Add explicit root hash verification in `JellyfishMerkleRestore::finish_impl()` before writing final nodes to storage:

```rust
pub fn finish_impl(mut self) -> Result<()> {
    self.wait_for_async_commit()?;
    
    // Handle special cases...
    if self.partial_nodes.len() == 1 {
        // ... existing special case handling ...
    }
    
    self.freeze(0);
    
    // CRITICAL FIX: Verify the final root hash before committing
    let root_node_key = NodeKey::new_empty_path(self.version);
    let root_node = self.frozen_nodes.get(&root_node_key)
        .ok_or_else(|| anyhow!("Root node not found after state restoration at version {}", self.version))?;
    
    let actual_root_hash = root_node.hash();
    ensure!(
        actual_root_hash == self.expected_root_hash,
        "State root hash mismatch at version {}! Expected: {:?}, Actual: {:?}. \
         This indicates corrupted or incomplete state data during fast sync.",
        self.version,
        self.expected_root_hash,
        actual_root_hash
    );
    
    self.store.write_node_batch(&self.frozen_nodes)?;
    Ok(())
}
```

This ensures that state corruption is detected immediately at finalization time rather than causing silent consensus divergence.

## Proof of Concept

```rust
#[test]
fn test_state_root_verification_missing() {
    // Setup: Create a state tree at version 100
    let tmp_dir = TempPath::new();
    let db = AptosDB::new_for_test(&tmp_dir);
    
    // Insert state and get the correct root hash
    let key1 = StateKey::raw(b"key1");
    let value1 = StateValue::from(b"value1".to_vec());
    db.state_store.commit_block_for_test(99, vec![vec![(key1.clone(), value1.clone())]]);
    let correct_root = db.state_store.get_root_hash(100).unwrap();
    
    // Malicious scenario: Create restoration with WRONG expected root
    let wrong_root = HashValue::random();
    let mut restore = db.get_state_snapshot_receiver(100, wrong_root).unwrap();
    
    // Add chunks with valid proofs (these will pass intermediate verification)
    let snapshot = vec![(key1, value1)];
    let proof = db.get_backup_handler()
        .get_account_state_range_proof(snapshot[0].0.hash(), 100)
        .unwrap();
    
    restore.add_chunk(snapshot, proof).unwrap();
    
    // BUG: finish() succeeds even though actual root != expected root!
    // This should FAIL but currently passes:
    restore.finish_box().unwrap();
    
    // Verify the vulnerability: DB has correct_root but we expected wrong_root
    let actual_root = db.state_store.get_root_hash(100).unwrap();
    assert_eq!(actual_root, correct_root);  // Actual state is correct
    assert_ne!(actual_root, wrong_root);    // But we "expected" wrong_root!
    
    // This proves the system accepted mismatched state roots without verification
}
```

This test demonstrates that `finish_box()` succeeds even when the expected root hash doesn't match the actual state root in the database, confirming the vulnerability.

### Citations

**File:** state-sync/state-sync-driver/src/storage_synchronizer.rs (L847-860)
```rust
        let expected_root_hash = target_output_with_proof
            .get_output_list_with_proof()
            .proof
            .transaction_infos
            .first()
            .expect("Target transaction info should exist!")
            .ensure_state_checkpoint_hash()
            .expect("Must be at state checkpoint.");

        // Create the snapshot receiver
        let mut state_snapshot_receiver = storage
            .writer
            .get_state_snapshot_receiver(version, expected_root_hash)
            .expect("Failed to initialize the state snapshot receiver!");
```

**File:** state-sync/state-sync-driver/src/storage_synchronizer.rs (L1123-1138)
```rust
    state_snapshot_receiver.finish_box().map_err(|error| {
        format!(
            "Failed to finish the state value synchronization! Error: {:?}",
            error
        )
    })?;
    storage
        .writer
        .finalize_state_snapshot(
            version,
            target_output_with_proof.clone(),
            epoch_change_proofs,
        )
        .map_err(|error| format!("Failed to finalize the state snapshot! Error: {:?}", error))?;

    info!("All states have synced, version: {}", version);
```

**File:** storage/jellyfish-merkle/src/restore/mod.rs (L176-176)
```rust
    expected_root_hash: HashValue,
```

**File:** storage/jellyfish-merkle/src/restore/mod.rs (L390-391)
```rust
        // Verify what we have added so far is all correct.
        self.verify(proof)?;
```

**File:** storage/jellyfish-merkle/src/restore/mod.rs (L750-789)
```rust
    pub fn finish_impl(mut self) -> Result<()> {
        self.wait_for_async_commit()?;
        // Deal with the special case when the entire tree has a single leaf or null node.
        if self.partial_nodes.len() == 1 {
            let mut num_children = 0;
            let mut leaf = None;
            for i in 0..16 {
                if let Some(ref child_info) = self.partial_nodes[0].children[i] {
                    num_children += 1;
                    if let ChildInfo::Leaf(node) = child_info {
                        leaf = Some(node.clone());
                    }
                }
            }

            match num_children {
                0 => {
                    let node_key = NodeKey::new_empty_path(self.version);
                    assert!(self.frozen_nodes.is_empty());
                    self.frozen_nodes.insert(node_key, Node::Null);
                    self.store.write_node_batch(&self.frozen_nodes)?;
                    return Ok(());
                },
                1 => {
                    if let Some(node) = leaf {
                        let node_key = NodeKey::new_empty_path(self.version);
                        assert!(self.frozen_nodes.is_empty());
                        self.frozen_nodes.insert(node_key, node.into());
                        self.store.write_node_batch(&self.frozen_nodes)?;
                        return Ok(());
                    }
                },
                _ => (),
            }
        }

        self.freeze(0);
        self.store.write_node_batch(&self.frozen_nodes)?;
        Ok(())
    }
```

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L125-241)
```rust
    fn finalize_state_snapshot(
        &self,
        version: Version,
        output_with_proof: TransactionOutputListWithProofV2,
        ledger_infos: &[LedgerInfoWithSignatures],
    ) -> Result<()> {
        let (output_with_proof, persisted_aux_info) = output_with_proof.into_parts();
        gauged_api("finalize_state_snapshot", || {
            // Ensure the output with proof only contains a single transaction output and info
            let num_transaction_outputs = output_with_proof.get_num_outputs();
            let num_transaction_infos = output_with_proof.proof.transaction_infos.len();
            ensure!(
                num_transaction_outputs == 1,
                "Number of transaction outputs should == 1, but got: {}",
                num_transaction_outputs
            );
            ensure!(
                num_transaction_infos == 1,
                "Number of transaction infos should == 1, but got: {}",
                num_transaction_infos
            );

            // TODO(joshlind): include confirm_or_save_frozen_subtrees in the change set
            // bundle below.

            // Update the merkle accumulator using the given proof
            let frozen_subtrees = output_with_proof
                .proof
                .ledger_info_to_transaction_infos_proof
                .left_siblings();
            restore_utils::confirm_or_save_frozen_subtrees(
                self.ledger_db.transaction_accumulator_db_raw(),
                version,
                frozen_subtrees,
                None,
            )?;

            // Create a single change set for all further write operations
            let mut ledger_db_batch = LedgerDbSchemaBatches::new();
            let mut sharded_kv_batch = self.state_kv_db.new_sharded_native_batches();
            let mut state_kv_metadata_batch = SchemaBatch::new();
            // Save the target transactions, outputs, infos and events
            let (transactions, outputs): (Vec<Transaction>, Vec<TransactionOutput>) =
                output_with_proof
                    .transactions_and_outputs
                    .into_iter()
                    .unzip();
            let events = outputs
                .clone()
                .into_iter()
                .map(|output| output.events().to_vec())
                .collect::<Vec<_>>();
            let wsets: Vec<WriteSet> = outputs
                .into_iter()
                .map(|output| output.write_set().clone())
                .collect();
            let transaction_infos = output_with_proof.proof.transaction_infos;
            // We should not save the key value since the value is already recovered for this version
            restore_utils::save_transactions(
                self.state_store.clone(),
                self.ledger_db.clone(),
                version,
                &transactions,
                &persisted_aux_info,
                &transaction_infos,
                &events,
                wsets,
                Some((
                    &mut ledger_db_batch,
                    &mut sharded_kv_batch,
                    &mut state_kv_metadata_batch,
                )),
                false,
            )?;

            // Save the epoch ending ledger infos
            restore_utils::save_ledger_infos(
                self.ledger_db.metadata_db(),
                ledger_infos,
                Some(&mut ledger_db_batch.ledger_metadata_db_batches),
            )?;

            ledger_db_batch
                .ledger_metadata_db_batches
                .put::<DbMetadataSchema>(
                    &DbMetadataKey::LedgerCommitProgress,
                    &DbMetadataValue::Version(version),
                )?;
            ledger_db_batch
                .ledger_metadata_db_batches
                .put::<DbMetadataSchema>(
                    &DbMetadataKey::OverallCommitProgress,
                    &DbMetadataValue::Version(version),
                )?;

            // Apply the change set writes to the database (atomically) and update in-memory state
            //
            // state kv and SMT should use shared way of committing.
            self.ledger_db.write_schemas(ledger_db_batch)?;

            self.ledger_pruner.save_min_readable_version(version)?;
            self.state_store
                .state_merkle_pruner
                .save_min_readable_version(version)?;
            self.state_store
                .epoch_snapshot_pruner
                .save_min_readable_version(version)?;
            self.state_store
                .state_kv_pruner
                .save_min_readable_version(version)?;

            restore_utils::update_latest_ledger_info(self.ledger_db.metadata_db(), ledger_infos)?;
            self.state_store.reset();

            Ok(())
        })
    }
```

**File:** storage/aptosdb/src/fast_sync_storage_wrapper.rs (L66-77)
```rust
        if config
            .state_sync
            .state_sync_driver
            .bootstrapping_mode
            .is_fast_sync()
            && (db_main
                .ledger_db
                .metadata_db()
                .get_synced_version()?
                .map_or(0, |v| v)
                == 0)
        {
```
