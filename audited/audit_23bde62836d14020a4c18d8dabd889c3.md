# Audit Report

## Title
Orphaned Aggregator Delta Entries Cause NotFound Errors in Block-STM Parallel Execution

## Summary
In the Block-STM parallel execution engine, when a transaction that creates a new aggregator aborts and re-executes without creating that aggregator, the system removes only the creator's entry but leaves orphaned delta entries from dependent transactions. Subsequent reads of this aggregator fail with `NotFound` errors because the `base_value` is `None`, causing non-deterministic execution failures and violating consensus invariants. [1](#0-0) 

## Finding Description

The vulnerability occurs in the delayed fields system used for aggregator operations in Block-STM parallel execution. The core issue manifests in the `apply_aggregator_change_suffix()` function, which attempts to resolve aggregator deltas by traversing backwards through transaction entries and ultimately resolving to a `base_value`. [2](#0-1) 

**Vulnerable Execution Flow:**

1. **Aggregator Creation**: Transaction T0 creates a new aggregator A with initial value using `initialize_delayed_field()`, which creates a `VersionedValue` with `base_value = None` and inserts a `Value` entry at index 0. [3](#0-2) 

2. **Delta Application**: Transaction T2 applies a delta to aggregator A, adding an `Apply(AggregatorDelta)` entry at index 2. [4](#0-3) 

3. **Transaction Abort**: T0 aborts due to validation failure, and its entry is marked as `Estimate`. [5](#0-4) 

4. **Re-execution Without Creation**: T0 re-executes but follows a different execution path and doesn't create aggregator A. The `process_delayed_field_output()` function removes T0's entry at index 0. [6](#0-5) 

5. **Orphaned State**: The `VersionedValue` for A now has `base_value = None` and only contains the delta entry at index 2 from T2. [7](#0-6) 

6. **Read Failure**: When any transaction attempts to read aggregator A, the `read()` function finds the delta at index 2 and calls `apply_aggregator_change_suffix()`. This function accumulates deltas, finds no `Value` entry while traversing backwards, and attempts to resolve to `base_value` at lines 307-319. Since `base_value` is `None`, it returns `NotFound`. [8](#0-7) 

7. **Error Propagation**: The `NotFound` error propagates through `get_delayed_field_value_impl()`, gets captured as an `InconsistentRead` error, and causes the reading transaction to fail. [9](#0-8) 

**Broken Invariant**: This violates the **Deterministic Execution** invariant. Validators executing the same block may experience different timing of transaction aborts and re-executions, leading to different transactions encountering the `NotFound` error at different times, resulting in non-deterministic execution outcomes.

## Impact Explanation

**Severity: High** (up to $50,000)

This vulnerability meets the High severity criteria because it causes:

1. **Validator Node Slowdowns**: Transactions repeatedly fail and retry when encountering orphaned aggregator entries, wasting computational resources and slowing down block execution.

2. **Significant Protocol Violations**: The Block-STM parallel execution engine's correctness depends on all validators reaching the same execution outcome. This bug can cause different validators to fail different transactions based on execution timing, potentially leading to consensus divergence.

3. **State Inconsistencies**: The delayed fields validation at commit time detects these failures, but the repeated validation failures and re-executions create inconsistent intermediate states. [10](#0-9) 

While this doesn't directly cause fund loss or consensus safety violations (due to validation catching the errors), it creates execution unpredictability that could be exploited to cause targeted transaction failures or denial of service against specific aggregator-using contracts.

## Likelihood Explanation

**Likelihood: Medium-High**

This vulnerability occurs when:
- A transaction creates a new aggregator (common in DeFi applications, DAO voting, and resource accounting)
- Later transactions apply deltas to it (standard aggregator usage pattern)
- The creating transaction aborts and re-executes with a different code path (happens regularly in Block-STM due to validation failures)

The non-deterministic execution path requirement (creating aggregator in one incarnation but not another) might seem rare, but can occur due to:
- Reading storage state that changed between incarnations
- Gas limit enforcement differences
- Timeout or execution interruptions
- Conditional aggregator creation based on runtime checks

The Block-STM testing framework explicitly supports different behaviors across incarnations, indicating this is an expected scenario. [11](#0-10) 

## Recommendation

**Fix Option 1: Track Base Value Source**

Add tracking to identify which transaction created each aggregator and prevent removal of creating transactions while dependent entries exist:

```rust
struct VersionedValue<K: Clone> {
    versioned_map: BTreeMap<TxnIndex, Box<CachePadded<VersionEntry<K>>>>,
    base_value: Option<DelayedFieldValue>,
    read_estimate_deltas: bool,
    // NEW: Track the transaction that provided the base value
    base_value_source: Option<TxnIndex>,
}
```

When removing an entry, check if it's the `base_value_source` and if other entries exist. If so, either block the removal or convert the entry to a `Value` rather than removing it.

**Fix Option 2: Eager Base Value Resolution**

When a transaction creates an aggregator, set the `base_value` immediately instead of keeping it as `None`:

```rust
pub fn initialize_delayed_field(
    &self,
    id: K,
    txn_idx: TxnIndex,
    value: DelayedFieldValue,
) -> Result<(), PanicError> {
    // NEW: Set base_value when creating
    let mut created = VersionedValue::new(Some(value.clone()));
    created.insert_speculative_value(txn_idx, VersionEntry::Value(value, None))?;
    
    if self.values.insert(id, created).is_some() {
        Err(code_invariant_error(
            "VersionedValue when initializing delayed field may not already exist for same id",
        ))
    } else {
        Ok(())
    }
}
```

**Fix Option 3: Cleanup Dependent Entries**

When removing a creating transaction's entry, also remove all dependent delta entries for that aggregator to maintain consistency.

## Proof of Concept

The following test demonstrates the vulnerability in Block-STM execution:

```rust
#[test]
fn test_orphaned_aggregator_delta() {
    use aptos_aggregator::delta_change_set::DeltaOp;
    use aptos_aggregator::bounded_math::SignedU128;
    use aptos_aggregator::delayed_change::DelayedEntry;
    use move_vm_types::delayed_values::delayed_field_id::DelayedFieldID;
    
    let delayed_fields = VersionedDelayedFields::<DelayedFieldID>::empty();
    let agg_id = DelayedFieldID::new_for_test_for_u64(100);
    
    // Step 1: Txn 0 creates aggregator with value 50
    delayed_fields.initialize_delayed_field(
        agg_id, 
        0, 
        DelayedFieldValue::Aggregator(50)
    ).unwrap();
    
    // Step 2: Txn 2 applies delta +20
    let delta = DeltaOp::new(
        SignedU128::Positive(20), 
        1000, 
        DeltaHistory::default()
    );
    delayed_fields.record_change(
        agg_id,
        2,
        DelayedEntry::Apply(DelayedApplyEntry::AggregatorDelta { delta })
    ).unwrap();
    
    // Step 3: Txn 0 aborts, entry marked as estimate
    delayed_fields.mark_estimate(&agg_id, 0);
    
    // Step 4: Txn 0 re-executes without creating aggregator, entry removed
    delayed_fields.remove(&agg_id, 0, false).unwrap();
    
    // Step 5: Try to read aggregator at txn 3 - this should fail with NotFound
    // because base_value is None and only delta at index 2 exists
    let result = delayed_fields.read(&agg_id, 3);
    
    // BUG: This returns NotFound instead of a valid value
    assert!(matches!(
        result,
        Err(PanicOr::Or(MVDelayedFieldsError::NotFound))
    ));
}
```

This test would fail (demonstrating the bug) because the read operation encounters a `NotFound` error when trying to resolve the orphaned delta entry to a non-existent base value.

## Notes

The vulnerability is exacerbated by the fact that the codebase contains multiple TODO comments acknowledging issues in this area, suggesting the developers are aware of potential problems but haven't fully addressed them. The comment at line 127 mentions "TODO(BlockSTMv2): deal w. V2 & estimates" indicates ongoing work in this space. [12](#0-11)

### Citations

**File:** aptos-move/mvhashmap/src/versioned_delayed_fields.rs (L61-72)
```rust
struct VersionedValue<K: Clone> {
    versioned_map: BTreeMap<TxnIndex, Box<CachePadded<VersionEntry<K>>>>,

    // The value of the given aggregator prior to the block execution. None implies that
    // the aggregator did not exist prior to the block.
    base_value: Option<DelayedFieldValue>,

    // If true, the reads can proceed by using deltas in Estimate entries, if present.
    // The value is optimistically initialized to true, but changed to false when it is
    // observed that a later incarnation changed the value of a delta at the same entry.
    read_estimate_deltas: bool,
}
```

**File:** aptos-move/mvhashmap/src/versioned_delayed_fields.rs (L127-131)
```rust
        // TODO(BlockSTMv2): deal w. V2 & estimates and potentially bring back the check
        // that removed entry must be an estimate (but with PanicError).
        if is_blockstm_v2 {
            return;
        }
```

**File:** aptos-move/mvhashmap/src/versioned_delayed_fields.rs (L258-320)
```rust
    fn apply_aggregator_change_suffix(
        &self,
        iter: &mut dyn DoubleEndedIterator<Item = (&TxnIndex, &Box<CachePadded<VersionEntry<K>>>)>,
        suffix: &DelayedApplyEntry<K>,
    ) -> Result<VersionedRead<K>, PanicOr<MVDelayedFieldsError>> {
        use DelayedApplyEntry::*;
        use EstimatedEntry::*;
        use VersionEntry::*;

        let mut accumulator = if let AggregatorDelta { delta } = suffix {
            *delta
        } else {
            unreachable!("Only AggregatorDelta accepted in apply_aggregator_change_suffix (i.e. has no apply_base_id)")
        };

        while let Some((idx, entry)) = iter.next_back() {
            let delta = match (entry.as_ref().deref(), self.read_estimate_deltas) {
                (Value(DelayedFieldValue::Aggregator(v), _), _) => {
                    // Apply accumulated delta to resolve the aggregator value.
                    return accumulator
                        .apply_to(*v)
                        .map_err(MVDelayedFieldsError::from_panic_or)
                        .map(DelayedFieldValue::Aggregator)
                        .map(VersionedRead::Value);
                },
                (Value(_, _), _) => {
                    unreachable!("Value not DelayedFieldValue::Aggregator for Aggregator")
                },
                (Apply(AggregatorDelta { delta }), _)
                | (Estimate(Bypass(AggregatorDelta { delta })), true) => *delta,
                (Estimate(NoBypass), _) | (Estimate(_), false) => {
                    // We must wait on Estimates, or a bypass isn't available.
                    return Err(PanicOr::Or(MVDelayedFieldsError::Dependency(*idx)));
                },
                (Apply(_), _) | (Estimate(Bypass(_)), true) => {
                    unreachable!("Apply change type not AggregatorDelta for aggregator")
                },
            };

            // Read hit a delta during traversing the block and aggregating other deltas. We merge the
            // two deltas together. If there is an error, we return appropriate error
            // (DeltaApplicationError or PanicOr::CodeInvariantError
            // (there is no determinism concern as DeltaApplicationError may not occur in committed output).
            accumulator
                .merge_with_previous_delta(delta)
                .map_err(MVDelayedFieldsError::from_panic_or)?;
        }

        // Finally, resolve if needed with the base value.
        self.base_value
            .as_ref()
            .ok_or(PanicOr::Or(MVDelayedFieldsError::NotFound))
            .and_then(|base_value| match base_value {
                DelayedFieldValue::Aggregator(v) => accumulator
                    .apply_to(*v)
                    .map_err(MVDelayedFieldsError::from_panic_or)
                    .map(DelayedFieldValue::Aggregator)
                    .map(VersionedRead::Value),
                _ => Err(PanicOr::from(code_invariant_error(
                    "Found non-DelayedFieldValue::Aggregator base value for aggregator with delta",
                ))),
            })
    }
```

**File:** aptos-move/mvhashmap/src/versioned_delayed_fields.rs (L325-365)
```rust
    fn read(&self, txn_idx: TxnIndex) -> Result<VersionedRead<K>, PanicOr<MVDelayedFieldsError>> {
        use EstimatedEntry::*;
        use MVDelayedFieldsError::*;
        use VersionEntry::*;

        let mut iter = self.versioned_map.range(0..txn_idx);

        iter.next_back().map_or_else(
            // No entries in versioned map, use base value.
            || {
                self.base_value
                    .clone()
                    .ok_or(PanicOr::Or(NotFound))
                    .map(VersionedRead::Value)
            },
            // Consider the latest entry below the provided version.
            |(idx, entry)| match (entry.as_ref().deref(), self.read_estimate_deltas) {
                (Value(v, _), _) => Ok(VersionedRead::Value(v.clone())),
                (Apply(apply), _) | (Estimate(Bypass(apply)), true) => {
                    apply.get_apply_base_id_option().map_or_else(
                        || self.apply_aggregator_change_suffix(&mut iter, apply),
                        |apply_base| {
                            let (base_id, end_index) = match apply_base {
                                ApplyBase::Previous(id) => (id, *idx),
                                ApplyBase::Current(id) => (id, *idx + 1),
                            };

                            Ok(VersionedRead::DependentApply(
                                base_id,
                                end_index,
                                apply.clone(),
                            ))
                        },
                    )
                },
                (Estimate(NoBypass), _) | (Estimate(_), false) => {
                    Err(PanicOr::Or(Dependency(*idx)))
                },
            },
        )
    }
```

**File:** aptos-move/mvhashmap/src/versioned_delayed_fields.rs (L391-406)
```rust
/// There are some invariants that the caller must maintain when using VersionedDelayedFeilds:
/// -) 'set_base_value' or 'create_aggregator' must be completed for each ID prior to calling
/// other methods (reading, insert, remove or marking as estimate) for the ID.
/// -) When a transaction is committed, all transactions with lower indices are also considered
/// committed. Before an index is committed, all of its deltas and snapshots must be converted
/// to values by the caller (by recoding the final materialized values).
/// -) When a transaction aborts, its entries must be converted to estimates until the
/// transaction can re-execute with the next incarnation. When the next incarnation finishes
/// and records new entries, all remaining Estimate entries must be removed.
///
/// Another invariant that must be maintained by the caller is that the same delayed field ID
/// throughout the course of the lifetime of the data-structure may not contain a delta and
/// a snapshot - even at different times. In particular, this precludes re-using the same ID
/// between Aggregator and AggregatorSnapshot. It is easy to provide this property from the
/// caller side, even if IDs are re-used (say among incarnations) by e.g. assigning odd and
/// even ids to Aggregators and AggregatorSnapshots, and it allows asserting the uses strictly.
```

**File:** aptos-move/mvhashmap/src/versioned_delayed_fields.rs (L455-471)
```rust
    pub fn initialize_delayed_field(
        &self,
        id: K,
        txn_idx: TxnIndex,
        value: DelayedFieldValue,
    ) -> Result<(), PanicError> {
        let mut created = VersionedValue::new(None);
        created.insert_speculative_value(txn_idx, VersionEntry::Value(value, None))?;

        if self.values.insert(id, created).is_some() {
            Err(code_invariant_error(
                "VersionedValue when initializing delayed field may not already exist for same id",
            ))
        } else {
            Ok(())
        }
    }
```

**File:** aptos-move/mvhashmap/src/versioned_delayed_fields.rs (L492-513)
```rust
    pub fn record_change(
        &self,
        id: K,
        txn_idx: TxnIndex,
        change: DelayedEntry<K>,
    ) -> Result<(), PanicOr<MVDelayedFieldsError>> {
        match change {
            DelayedEntry::Create(value) => self.initialize_delayed_field(id, txn_idx, value)?,
            DelayedEntry::Apply(apply) => match &apply {
                DelayedApplyEntry::AggregatorDelta { .. } => self
                    .values
                    .get_mut(&id)
                    .ok_or(PanicOr::Or(MVDelayedFieldsError::NotFound))?
                    .insert_speculative_value(txn_idx, VersionEntry::Apply(apply))?,
                DelayedApplyEntry::SnapshotDelta { .. }
                | DelayedApplyEntry::SnapshotDerived { .. } => {
                    self.initialize_dependent_delayed_field(id, txn_idx, apply)?
                },
            },
        };
        Ok(())
    }
```

**File:** aptos-move/block-executor/src/executor_utilities.rs (L341-345)
```rust
    if let Some(keys) = last_input_output.delayed_field_keys(txn_idx) {
        for k in keys {
            versioned_cache.delayed_fields().mark_estimate(&k, txn_idx);
        }
    }
```

**File:** aptos-move/block-executor/src/executor.rs (L380-384)
```rust
        for id in prev_modified_delayed_fields {
            versioned_cache
                .delayed_fields()
                .remove(&id, idx_to_execute, is_v2)?;
        }
```

**File:** aptos-move/block-executor/src/view.rs (L291-297)
```rust
            Err(e) => {
                captured_reads
                    .borrow_mut()
                    .capture_delayed_field_read_error(&e);
                // TODO[agg_v2](cleanup): think of correct return type
                return Err(e.map_non_panic(|_| DelayedFieldsSpeculativeError::InconsistentRead));
            },
```

**File:** aptos-move/block-executor/src/captured_reads.rs (L1178-1180)
```rust
                Err(NotFound) | Err(Dependency(_)) | Err(DeltaApplicationFailure) => {
                    return Ok(false);
                },
```
