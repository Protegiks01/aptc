# Audit Report

## Title
Critical: Unauthenticated Cross-Shard StopMsg Injection Causes Network-Wide Deadlock and Liveness Failure

## Summary
A malicious or compromised shard can inject a premature `StopMsg` to any other shard in the remote execution system, causing the victim shard's cross-shard commit receiver to terminate before receiving all required state updates. This results in permanent deadlock of execution threads waiting for cross-shard dependencies, leading to total loss of network liveness and consensus failure.

## Finding Description

The remote cross-shard execution system implements a message-passing architecture where shards communicate state updates via network channels. When a shard completes execution, it sends a `StopMsg` to itself to terminate its `CrossShardCommitReceiver` loop. [1](#0-0) 

However, the `RemoteCrossShardClient` implementation has no authentication or authorization checks on who can send messages to whom: [2](#0-1) 

The underlying GRPC network service accepts messages from any remote peer without validation: [3](#0-2) 

When a `StopMsg` is received, the `CrossShardCommitReceiver` immediately breaks its message processing loop: [4](#0-3) 

**The Critical Vulnerability:**

Cross-shard dependencies use `RemoteStateValue` objects that block indefinitely waiting for state updates: [5](#0-4) 

If a premature `StopMsg` terminates the receiver before all dependencies are satisfied, execution threads deadlock permanently on the condition variable wait with **no timeout**.

**Attack Path:**

1. Shard A is executing a block with cross-shard dependencies on state from Shard B
2. Shard A's `CrossShardCommitReceiver` runs in a separate thread, waiting for messages from Shard B
3. Malicious Shard B (or any compromised shard) crafts a `CrossShardMsg::StopMsg`
4. Shard B sends it to Shard A via `send_cross_shard_msg(shard_id=A, round, StopMsg)` 
5. The network controller routes the message over GRPC to Shard A
6. Shard A's receiver gets the `StopMsg` and breaks its loop (line 41)
7. Shard A's execution threads remain blocked in `RemoteStateValue::get_value()` waiting for state that will never arrive
8. **Shard A is permanently deadlocked** - it cannot complete execution or participate in consensus

All shards share the same `remote_shard_addresses` list, allowing any shard to send to any other: [6](#0-5) 

## Impact Explanation

This is a **Critical Severity** vulnerability per Aptos bug bounty criteria:

- **Total loss of liveness/network availability**: Affected shards cannot complete execution and become permanently unresponsive
- **Consensus failure**: Deadlocked shards cannot participate in consensus, violating the BFT liveness guarantee
- **Non-recoverable without intervention**: Requires manual node restart, but attack can be immediately repeated
- **State consistency violations**: Incomplete cross-shard state synchronization leads to divergent state across shards
- **No recovery mechanism**: The indefinite blocking has no timeout or error handling

The attack requires only a single compromised or malicious shard to affect all other shards in the network, making this a critical availability vulnerability.

## Likelihood Explanation

**High Likelihood:**

- **Low Attack Complexity**: Attacker only needs to send a single malicious message
- **No Authentication**: The network layer has zero authentication or sender validation
- **Easy to Execute**: Simple BCS serialization of `StopMsg` and GRPC send
- **Wide Attack Surface**: Any compromised shard, malicious operator, or even a software bug could trigger this
- **Repeatable**: Attack can be executed repeatedly after recovery attempts
- **No Detection**: No logging or validation to detect premature `StopMsg` reception

The design comment explicitly states "Send a self message to stop the cross-shard commit receiver" but this invariant is not enforced: [7](#0-6) 

## Recommendation

**Immediate Fixes:**

1. **Sender Authentication**: Validate that `StopMsg` only comes from the shard itself
2. **Message Sequencing**: Track expected message count before accepting `StopMsg`
3. **Timeout Protection**: Add timeouts to `RemoteStateValue::get_value()` with error handling
4. **Network Authentication**: Implement mutual TLS or message signing for cross-shard communication

**Code Fix Example:**

In `RemoteCrossShardClient`, add sender tracking and validation:

```rust
fn receive_cross_shard_msg(&self, current_round: RoundId) -> CrossShardMsg {
    let rx = self.message_rxs[current_round].lock().unwrap();
    let message = rx.recv().unwrap();
    let msg: CrossShardMsg = bcs::from_bytes(&message.to_bytes()).unwrap();
    
    // Validate StopMsg only comes from self
    if matches!(msg, CrossShardMsg::StopMsg) {
        // Reject StopMsg from remote sources - it should only be sent locally
        // This requires tracking the local shard_id and message origin
        panic!("Received StopMsg from remote source - security violation");
    }
    
    msg
}
```

In `RemoteStateValue::get_value()`, add timeout:

```rust
pub fn get_value(&self) -> Option<StateValue> {
    let (lock, cvar) = &*self.value_condition;
    let mut status = lock.lock().unwrap();
    let timeout = Duration::from_secs(30); // Configurable timeout
    
    while let RemoteValueStatus::Waiting = *status {
        let result = cvar.wait_timeout(status, timeout).unwrap();
        status = result.0;
        if result.1.timed_out() {
            panic!("Timeout waiting for cross-shard state value");
        }
    }
    
    match &*status {
        RemoteValueStatus::Ready(value) => value.clone(),
        RemoteValueStatus::Waiting => unreachable!(),
    }
}
```

## Proof of Concept

```rust
// PoC demonstrating the vulnerability
// This would be a Rust test in the executor-service crate

#[test]
fn test_malicious_stop_msg_injection() {
    use std::thread;
    use std::time::Duration;
    
    // Setup 2 shards with remote execution
    let num_shards = 2;
    let (executor_client, mut executor_services) =
        create_thread_remote_executor_shards(num_shards, Some(2));
    
    thread::sleep(Duration::from_millis(100)); // Wait for setup
    
    // Shard 1 (malicious) gets a reference to Shard 0's cross-shard client
    // and sends a premature StopMsg to Shard 0 during execution
    
    // Create a block with cross-shard dependencies: 
    // Shard 0 depends on state from Shard 1
    let partitioned_txns = create_cross_shard_dependent_block();
    
    // Start execution on both shards
    let execution_handle = thread::spawn(move || {
        executor_client.execute_block(
            state_view,
            partitioned_txns,
            2, // concurrency
            config
        )
    });
    
    // Wait briefly for execution to start
    thread::sleep(Duration::from_millis(50));
    
    // ATTACK: Malicious Shard 1 sends StopMsg to Shard 0
    let malicious_shard_1_client = get_cross_shard_client_for_shard(1);
    malicious_shard_1_client.send_cross_shard_msg(
        0, // target shard_id = 0
        0, // round = 0
        CrossShardMsg::StopMsg // premature stop message
    );
    
    // RESULT: Shard 0's CrossShardCommitReceiver stops processing
    // Shard 0's execution threads are now deadlocked waiting for 
    // cross-shard state that will never arrive
    
    // This call will hang indefinitely
    let result = execution_handle.join();
    // Test will timeout and fail, demonstrating the deadlock
}
```

## Notes

This vulnerability exists specifically in the **remote execution mode** where shards communicate over network channels. The local execution mode is not affected as all shards run in the same process. However, any production deployment using remote/distributed shards would be vulnerable to this critical attack. The lack of authentication in the cross-shard messaging layer represents a fundamental security flaw that enables complete denial of service against the sharded execution system.

### Citations

**File:** aptos-move/aptos-vm/src/sharded_block_executor/messages.rs (L7-11)
```rust
#[derive(Clone, Debug, Deserialize, Serialize)]
pub enum CrossShardMsg {
    RemoteTxnWriteMsg(RemoteTxnWrite),
    StopMsg,
}
```

**File:** execution/executor-service/src/remote_cross_shard_client.rs (L55-59)
```rust
    fn send_cross_shard_msg(&self, shard_id: ShardId, round: RoundId, msg: CrossShardMsg) {
        let input_message = bcs::to_bytes(&msg).unwrap();
        let tx = self.message_txs[shard_id][round].lock().unwrap();
        tx.send(Message::new(input_message)).unwrap();
    }
```

**File:** secure/net/src/grpc_network_service/mod.rs (L93-115)
```rust
    async fn simple_msg_exchange(
        &self,
        request: Request<NetworkMessage>,
    ) -> Result<Response<Empty>, Status> {
        let _timer = NETWORK_HANDLER_TIMER
            .with_label_values(&[&self.self_addr.to_string(), "inbound_msgs"])
            .start_timer();
        let remote_addr = request.remote_addr();
        let network_message = request.into_inner();
        let msg = Message::new(network_message.message);
        let message_type = MessageType::new(network_message.message_type);

        if let Some(handler) = self.inbound_handlers.lock().unwrap().get(&message_type) {
            // Send the message to the registered handler
            handler.send(msg).unwrap();
        } else {
            error!(
                "No handler registered for sender: {:?} and msg type {:?}",
                remote_addr, message_type
            );
        }
        Ok(Response::new(Empty {}))
    }
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/cross_shard_client.rs (L26-45)
```rust
    pub fn start<S: StateView + Sync + Send>(
        cross_shard_state_view: Arc<CrossShardStateView<S>>,
        cross_shard_client: Arc<dyn CrossShardClient>,
        round: RoundId,
    ) {
        loop {
            let msg = cross_shard_client.receive_cross_shard_msg(round);
            match msg {
                RemoteTxnWriteMsg(txn_commit_msg) => {
                    let (state_key, write_op) = txn_commit_msg.take();
                    cross_shard_state_view
                        .set_value(&state_key, write_op.and_then(|w| w.as_state_value()));
                },
                CrossShardMsg::StopMsg => {
                    trace!("Cross shard commit receiver stopped for round {}", round);
                    break;
                },
            }
        }
    }
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/remote_state_value.rs (L29-39)
```rust
    pub fn get_value(&self) -> Option<StateValue> {
        let (lock, cvar) = &*self.value_condition;
        let mut status = lock.lock().unwrap();
        while let RemoteValueStatus::Waiting = *status {
            status = cvar.wait(status).unwrap();
        }
        match &*status {
            RemoteValueStatus::Ready(value) => value.clone(),
            RemoteValueStatus::Waiting => unreachable!(),
        }
    }
```

**File:** execution/executor-service/src/tests.rs (L29-48)
```rust
    let remote_shard_addresses = (0..num_shards)
        .map(|_| {
            let listen_port = utils::get_available_port();
            SocketAddr::new(IpAddr::V4(Ipv4Addr::LOCALHOST), listen_port)
        })
        .collect::<Vec<_>>();

    let num_threads =
        num_threads.unwrap_or_else(|| (num_cpus::get() as f64 / num_shards as f64).ceil() as usize);

    let remote_executor_services = (0..num_shards)
        .map(|shard_id| {
            ThreadExecutorService::new(
                shard_id,
                num_shards,
                num_threads,
                coordinator_address,
                remote_shard_addresses.clone(),
            )
        })
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/sharded_executor_service.rs (L163-168)
```rust
                    // Send a self message to stop the cross-shard commit receiver.
                    cross_shard_client_clone.send_cross_shard_msg(
                        shard_id,
                        round,
                        CrossShardMsg::StopMsg,
                    );
```
