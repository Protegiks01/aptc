# Audit Report

## Title
Unchecked JSON Deserialization in File Store Metadata Leading to Indexer Service Crash

## Summary
The indexer-grpc file store metadata deserialization uses `.expect()` on JSON parsing, which causes a panic and crashes the indexer service when the metadata file contains malformed JSON. Additionally, if `num_transactions_per_folder` is set to 0, it causes a division-by-zero panic during path generation.

## Finding Description
When the `FileStoreUploader` initializes, it calls `get_file_store_metadata()` which deserializes the `metadata.json` file from the file store. [1](#0-0) 

The deserialization implementation uses `.expect()` which will panic if the JSON is invalid: [2](#0-1) 

An attacker with write access to the file store (S3 bucket, GCS, or filesystem) can:
1. Replace `metadata.json` with malformed JSON (invalid syntax, wrong types, missing fields)
2. Set `num_transactions_per_folder` to 0, causing division by zero when `get_folder_name()` is called: [3](#0-2) 

This affects multiple services during initialization and runtime:
- FileStoreUploader initialization
- FileStoreReader initialization [4](#0-3) 
- DataManager initialization [5](#0-4) 
- Runtime calls to `get_latest_version()` [6](#0-5) 

The `FileStoreMetadata` struct has no validation on deserialized values: [7](#0-6) 

## Impact Explanation
This qualifies as **High Severity** per the Aptos bug bounty criteria: "API crashes". When the metadata is malformed, the indexer gRPC service crashes and becomes unavailable, preventing clients from querying blockchain data through the indexer API.

However, this vulnerability has significant limitations:
- **Does not affect core blockchain operation**: The consensus, execution, and state management layers continue functioning normally. Validators are unaffected.
- **Requires privileged access**: The attacker needs write access to the file store (S3/GCS credentials or filesystem access), which is typically protected by IAM policies and access controls.
- **Indexer is auxiliary infrastructure**: While important for applications, the indexer is not part of the core blockchain consensus protocol.

## Likelihood Explanation
**Low to Medium likelihood** due to access requirements:
- Attacker needs write access to the file store through:
  - Misconfigured cloud storage permissions (public write access)
  - Compromised cloud credentials or IAM roles
  - Insider threat with infrastructure access
  - Exploitation of another vulnerability leading to file write capability
- The primary security boundary is the file store access control, not the code validation
- Properly configured production deployments with strict IAM policies would prevent this attack

## Recommendation
Implement proper error handling for metadata deserialization with validation:

```rust
pub async fn get_file_store_metadata(&self) -> Result<Option<FileStoreMetadata>> {
    let raw_data = self.reader
        .get_raw_file(PathBuf::from(METADATA_FILE_NAME))
        .await?;
    
    match raw_data {
        Some(data) => {
            let metadata: FileStoreMetadata = serde_json::from_slice(&data)
                .context("Failed to deserialize file store metadata")?;
            
            // Validate critical fields
            if metadata.num_transactions_per_folder == 0 {
                return Err(anyhow::anyhow!("num_transactions_per_folder cannot be zero"));
            }
            
            Ok(Some(metadata))
        },
        None => Ok(None),
    }
}
```

Similarly, update batch metadata deserialization and add validation in all initialization paths to return proper errors instead of panicking.

## Proof of Concept
**Attack Scenario:**
1. Attacker gains write access to the file store (e.g., misconfigured S3 bucket)
2. Attacker overwrites `metadata.json` with malformed content:
   ```json
   {"chain_id": "invalid", "num_transactions_per_folder": 100000, "version": 0}
   ```
   or
   ```json
   {"chain_id": 1, "num_transactions_per_folder": 0, "version": 0}
   ```
3. When the indexer service restarts or calls `get_latest_version()`, it panics:
   - Malformed JSON: `thread 'main' panicked at 'Metadata JSON is invalid.'`
   - Division by zero: `thread 'main' panicked at 'attempt to divide by zero'`
4. The indexer gRPC service crashes and becomes unavailable

**Note**: This requires privileged access to the file store, which exceeds the "unprivileged attacker" requirement specified in the validation checklist.

---

## Notes
While this is a valid code quality and defense-in-depth issue that should be fixed, it **does not fully meet the strict criteria** for a high-severity bug bounty vulnerability because:

1. **Requires privileged access**: The attacker needs write access to the file store, which is not available to "unprivileged attackers" as required by the validation checklist
2. **Not a core protocol component**: The indexer is auxiliary infrastructure for data querying, not part of the consensus, execution, or state management layers that are the primary focus
3. **Primary security boundary is access control**: The file store permissions (IAM/ACLs) are the first line of defense, and proper operational security prevents this attack

The code should still be hardened with proper error handling and validation, but this represents an operational security concern rather than a core protocol vulnerability exploitable by unprivileged attackers.

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/file_store_uploader.rs (L68-75)
```rust
        assert_eq!(
            reader
                .get_file_store_metadata()
                .await
                .unwrap()
                .num_transactions_per_folder,
            NUM_TXNS_PER_FOLDER
        );
```

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/file_store_operator_v2/file_store_reader.rs (L43-46)
```rust
        let metadata = Self::get_file_store_metadata(&myself)
            .await
            .expect("Failed to fetch num_transactions_per_folder.");

```

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/file_store_operator_v2/file_store_reader.rs (L160-166)
```rust
    pub async fn get_file_store_metadata(&self) -> Option<FileStoreMetadata> {
        self.reader
            .get_raw_file(PathBuf::from(METADATA_FILE_NAME))
            .await
            .expect("Failed to get file store metadata.")
            .map(|data| serde_json::from_slice(&data).expect("Metadata JSON is invalid."))
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/file_store_operator_v2/file_store_reader.rs (L180-187)
```rust
    pub async fn get_latest_version(&self) -> Option<u64> {
        let metadata = self.get_file_store_metadata().await;
        let latest_version = metadata.map(|metadata| {
            if metadata.chain_id != self.chain_id {
                panic!("Wrong chain_id.");
            }
            metadata.version
        });
```

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/file_store_operator_v2/file_store_reader.rs (L207-211)
```rust
    fn get_folder_name(&self, version: u64) -> PathBuf {
        let mut buf = PathBuf::new();
        buf.push(format!("{}", version / self.num_transactions_per_folder));
        buf
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/data_manager.rs (L164-165)
```rust
        let file_store_reader = FileStoreReader::new(chain_id, file_store).await;
        let file_store_version = file_store_reader.get_latest_version().await.unwrap();
```

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/file_store_operator_v2/common.rs (L11-16)
```rust
#[derive(Serialize, Deserialize, Debug)]
pub struct FileStoreMetadata {
    pub chain_id: u64,
    pub num_transactions_per_folder: u64,
    pub version: u64,
}
```
