# Audit Report

## Title
State Sync Failure Due to Overly Restrictive Empty Ledger Info Check

## Summary
The `save_ledger_infos()` function in `restore_utils.rs` contains an overly restrictive `ensure!` check that causes state synchronization to fail unnecessarily when syncing to a version within the same epoch (where no epoch-ending ledger infos exist). This breaks node liveness and prevents legitimate state sync operations.

## Finding Description

The vulnerability exists in the state sync finalization path where epoch-ending ledger infos are saved to the database. The issue manifests in the following code flow:

1. During bootstrapping, when a node syncs to a target version that remains within the current epoch (no epoch changes), the bootstrapper correctly identifies this scenario and logs "No new epoch ending ledger infos to fetch! All peers are in the same epoch!" [1](#0-0) 

2. In this legitimate scenario, `all_epoch_ending_ledger_infos()` returns an empty vector because no epoch boundaries were crossed [2](#0-1) 

3. This empty vector is passed as `epoch_change_proofs` to `initialize_state_synchronizer()` [3](#0-2) 

4. Eventually, when finalizing the state snapshot, this empty array is passed to `save_ledger_infos()` [4](#0-3) 

5. The `save_ledger_infos()` function has an unconditional check that fails for empty arrays [5](#0-4) 

This check causes the entire state sync operation to abort with "No LedgerInfos to save." error, even though:
- The state snapshot data itself is valid
- An empty epoch-ending ledger info array is legitimate when syncing within a single epoch
- The code path with `existing_batch` (used in `finalize_state_snapshot`) would safely handle empty arrays by simply iterating over nothing [6](#0-5) 

## Impact Explanation

**Medium Severity** - This vulnerability causes denial of service and liveness issues:

- **Node Synchronization Failure**: Nodes attempting to fast-sync to a version within the current epoch will fail and cannot catch up with the network
- **Network Availability Impact**: During periods of low epoch turnover, multiple nodes could be affected simultaneously
- **Operational Disruption**: Requires manual intervention or workarounds to restore affected nodes
- **No Consensus Violation**: Does not affect consensus safety or enable fund theft, but impacts network health

This aligns with **Medium Severity** criteria: "State inconsistencies requiring intervention" and impacts network liveness without causing critical consensus or fund security issues.

## Likelihood Explanation

**High Likelihood** - This will occur in production under normal conditions:

- Epochs in Aptos can span many transactions (hours or days)
- State sync operations frequently occur within the same epoch, especially during normal operation
- The code explicitly acknowledges this as a valid scenario with dedicated logging
- No special attacker action required - happens naturally during normal node operation
- Affected nodes include: new validators joining, nodes recovering from downtime, archive nodes syncing

The bootstrapper code confirms this is an expected scenario [1](#0-0) 

## Recommendation

Remove the overly restrictive `ensure!` check or make it conditional. The function should gracefully handle empty arrays:

**Option 1: Early return for empty arrays (cleanest)**
```rust
pub(crate) fn save_ledger_infos(
    ledger_metadata_db: &LedgerMetadataDb,
    ledger_infos: &[LedgerInfoWithSignatures],
    existing_batch: Option<&mut SchemaBatch>,
) -> Result<()> {
    // Early return for empty arrays - no epoch ending ledger infos to save
    if ledger_infos.is_empty() {
        return Ok(());
    }

    if let Some(existing_batch) = existing_batch {
        save_ledger_infos_impl(ledger_metadata_db, ledger_infos, existing_batch)?;
    } else {
        let mut batch = SchemaBatch::new();
        save_ledger_infos_impl(ledger_metadata_db, ledger_infos, &mut batch)?;
        ledger_metadata_db.write_schemas(batch)?;
        update_latest_ledger_info(ledger_metadata_db, ledger_infos)?;
    }

    Ok(())
}
```

**Option 2: Also fix `update_latest_ledger_info` to handle empty arrays safely**
```rust
pub(crate) fn update_latest_ledger_info(
    ledger_metadata_db: &LedgerMetadataDb,
    ledger_infos: &[LedgerInfoWithSignatures],
) -> Result<()> {
    if ledger_infos.is_empty() {
        return Ok(());
    }
    
    if let Some(li) = ledger_metadata_db.get_latest_ledger_info_option() {
        if li.ledger_info().epoch() > ledger_infos.last().unwrap().ledger_info().epoch() {
            return Ok(());
        }
    }
    ledger_metadata_db.set_latest_ledger_info(ledger_infos.last().unwrap().clone());
    Ok(())
}
```

## Proof of Concept

**Rust Integration Test Scenario:**

```rust
#[tokio::test]
async fn test_state_sync_same_epoch_empty_ledger_infos() {
    // Setup: Create a test environment with genesis state
    let (mut swarm, _) = create_test_swarm(1).await;
    let validator = swarm.validators().next().unwrap();
    
    // Generate transactions within the same epoch (no epoch boundary)
    let mut account = create_test_account();
    for _ in 0..100 {
        submit_and_wait_transaction(&validator, &mut account, 100).await;
    }
    
    // Add a new node that needs to sync
    let new_node = swarm.add_validator().await.unwrap();
    
    // Configure the new node to use fast sync (state snapshot)
    configure_fast_sync(&new_node, validator.get_latest_version()).await;
    
    // Start the new node - it should sync to the target version
    // which is within the same epoch as genesis (no epoch changes)
    new_node.start().await.expect("Node should start successfully");
    
    // Wait for sync to complete
    new_node.wait_for_sync(Duration::from_secs(60)).await;
    
    // Verify: The node should successfully sync despite having
    // no epoch ending ledger infos to save (empty array)
    assert_eq!(
        new_node.get_latest_version().await,
        validator.get_latest_version().await,
        "New node should successfully sync to target version"
    );
}
```

**Expected Behavior:** The test should pass with the fix applied, allowing the node to sync successfully even when `epoch_change_proofs` is empty.

**Current Behavior:** Without the fix, the `finalize_state_snapshot` call fails with "No LedgerInfos to save." and the node cannot complete synchronization.

## Notes

The root cause is a defensive programming check that is too strict for the actual requirements. The `finalize_state_snapshot` function documentation states it is "required to...save the epoch ending ledger infos" [7](#0-6) , but this does not imply that the array must be non-empty in all cases. When no epoch boundaries are crossed during a sync operation, having zero epoch-ending ledger infos is the correct and expected state.

### Citations

**File:** state-sync/state-sync-driver/src/bootstrapper.rs (L196-202)
```rust
    /// Return all epoch ending ledger infos
    pub fn all_epoch_ending_ledger_infos(&self) -> Vec<LedgerInfoWithSignatures> {
        self.new_epoch_ending_ledger_infos
            .values()
            .cloned()
            .collect()
    }
```

**File:** state-sync/state-sync-driver/src/bootstrapper.rs (L861-866)
```rust
        } else if self.verified_epoch_states.verified_waypoint() {
            info!(LogSchema::new(LogEntry::Bootstrapper).message(
                "No new epoch ending ledger infos to fetch! All peers are in the same epoch!"
            ));
            self.verified_epoch_states
                .set_fetched_epoch_ending_ledger_infos();
```

**File:** state-sync/state-sync-driver/src/bootstrapper.rs (L986-992)
```rust
            // Fetch all verified epoch change proofs
            let version_to_sync = ledger_info_to_sync.ledger_info().version();
            let epoch_change_proofs = if version_to_sync == GENESIS_TRANSACTION_VERSION {
                vec![ledger_info_to_sync.clone()] // Sync to genesis
            } else {
                self.verified_epoch_states.all_epoch_ending_ledger_infos() // Sync beyond genesis
            };
```

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L200-205)
```rust
            // Save the epoch ending ledger infos
            restore_utils::save_ledger_infos(
                self.ledger_db.metadata_db(),
                ledger_infos,
                Some(&mut ledger_db_batch.ledger_metadata_db_batches),
            )?;
```

**File:** storage/aptosdb/src/backup/restore_utils.rs (L46-46)
```rust
    ensure!(!ledger_infos.is_empty(), "No LedgerInfos to save.");
```

**File:** storage/aptosdb/src/backup/restore_utils.rs (L48-49)
```rust
    if let Some(existing_batch) = existing_batch {
        save_ledger_infos_impl(ledger_metadata_db, ledger_infos, existing_batch)?;
```

**File:** storage/storage-interface/src/lib.rs (L592-605)
```rust
    /// Finalizes a state snapshot that has already been restored to the database through
    /// a state snapshot receiver. This is required to bootstrap the transaction accumulator,
    /// populate transaction information, save the epoch ending ledger infos and delete genesis.
    ///
    /// Note: this assumes that the output with proof has already been verified and that the
    /// state snapshot was restored at the same version.
    fn finalize_state_snapshot(
        &self,
        version: Version,
        output_with_proof: TransactionOutputListWithProofV2,
        ledger_infos: &[LedgerInfoWithSignatures],
    ) -> Result<()> {
        unimplemented!()
    }
```
