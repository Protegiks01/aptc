# Audit Report

## Title
PostgreSQL Credential Exposure in Local Testnet Health Checker Logs and Error Messages

## Summary
The local testnet health checker exposes PostgreSQL connection strings containing plaintext passwords in stdout output, structured logs, and error messages. When users run the Aptos local testnet with `--use-host-postgres --host-postgres-password`, credentials are leaked through multiple code paths accessible to attackers with log read access.

## Finding Description
The `HealthChecker::Postgres` variant stores the full PostgreSQL connection string including password in the format `postgres://user:password@host:port/database`. This connection string is exposed in five distinct locations:

**1. Success Path - Stdout Output:**
When the Postgres health check succeeds, the connection string is printed directly to stdout via `println!` [1](#0-0) 

**2. Success Path - Structured Logging:**
For silent services, the connection string is logged via the `info!` tracing macro [2](#0-1) 

**3. Health Check Failure - Wait Timeout:**
The `wait()` method constructs error messages that include `address_str()`, which returns the full connection string for Postgres health checkers [3](#0-2) 

The `address_str()` implementation directly returns the connection string [4](#0-3) 

**4. Database Connection Failure - Explicit Context:**
During host database recreation, connection failures explicitly include the connection string in error context [5](#0-4) 

**5. Error Propagation to User:**
Health check failures are formatted with Debug display and shown to users as CLI errors [6](#0-5) 

The connection string is constructed with the password included when `--use-host-postgres` is set [7](#0-6) 

## Impact Explanation
This vulnerability qualifies as **High Severity** under "Significant protocol violations" because:

1. **Widespread Exposure**: Credentials appear in stdout, structured logs, and error messages
2. **Persistent Risk**: Logs are often retained long-term, backed up to cloud storage, monitored by SIEM systems, and accessible to multiple personnel
3. **Production Database Risk**: Users may connect local testnets to production-adjacent databases for testing, exposing real credentials
4. **Attack Surface**: Attackers gaining read access to any log storage location (CI/CD logs, terminal history, log aggregation systems, backup archives) can extract credentials
5. **Lateral Movement**: Compromised database credentials enable unauthorized data access, exfiltration, modification, or complete database takeover

While this affects the local testnet tool rather than validator nodes, it violates fundamental security principles (never log credentials) and creates real-world attack vectors against developers and their infrastructure.

## Likelihood Explanation
**Likelihood: High**

This vulnerability triggers automatically in normal usage scenarios:
- Every successful Postgres startup logs the connection string
- Every connection failure exposes credentials in error messages
- Users frequently run local testnets with `--use-host-postgres` during development
- CI/CD pipelines may capture this output
- No special attacker actions are required beyond reading logs that developers routinely generate

The attack requires only read access to locations where developers commonly store logs: workstations, shared servers, CI/CD systems, or monitoring platforms.

## Recommendation
Sanitize connection strings before logging by redacting password components. Implement a `sanitize_connection_string()` function that replaces password values with `***REDACTED***`:

```rust
fn sanitize_connection_string(connection_string: &str) -> String {
    // Use regex or URL parsing to redact password component
    // For postgres://user:password@host:port/database
    // Return: postgres://user:***REDACTED***@host:port/database
    connection_string
        .split('@')
        .enumerate()
        .map(|(i, part)| {
            if i == 0 && part.contains(':') {
                // Redact password in user:password portion
                let mut parts: Vec<&str> = part.split(':').collect();
                if parts.len() > 2 {
                    parts[2] = "***REDACTED***";
                }
                parts.join(":")
            } else {
                part.to_string()
            }
        })
        .collect::<Vec<_>>()
        .join("@")
}
```

Apply sanitization in:
1. `address_str()` method for `HealthChecker::Postgres`
2. Error context messages before including connection strings
3. All logging statements that output connection information

Alternatively, change `address_str()` to return only the host and port for Postgres health checkers, avoiding the credential entirely.

## Proof of Concept

**Steps to Reproduce:**

1. Run Aptos local testnet with host Postgres credentials:
```bash
aptos node run-local-testnet \
  --with-indexer-api \
  --use-host-postgres \
  --host-postgres-password "MySecretPassword123" \
  --postgres-database test_db
```

2. Observe stdout output when Postgres starts:
```
Postgres is ready. Endpoint: postgres://postgres:MySecretPassword123@127.0.0.1:5432/test_db
```

3. Simulate connection failure by providing wrong credentials or unavailable database:
```bash
aptos node run-local-testnet \
  --with-indexer-api \
  --use-host-postgres \
  --host-postgres-password "WrongPassword" \
  --host-postgres-port 9999
```

4. Observe error message containing the full connection string with password:
```
Error: Unexpected error: Postgres at postgres://postgres:WrongPassword@127.0.0.1:9999/local_testnet did not start up
```

5. Check any log files in the test directory - credentials will be present in plain text.

The password `MySecretPassword123` or `WrongPassword` appears in plaintext in terminal output, making it accessible to anyone with access to terminal history, screen recordings, or log files.

### Citations

**File:** crates/aptos/src/node/local_testnet/mod.rs (L162-166)
```rust
                    println!(
                        "{} is ready. Endpoint: {}",
                        health_checker,
                        health_checker.address_str()
                    );
```

**File:** crates/aptos/src/node/local_testnet/mod.rs (L168-172)
```rust
                    info!(
                        "[silent] {} is ready. Endpoint: {}",
                        health_checker,
                        health_checker.address_str()
                    );
```

**File:** crates/aptos/src/node/local_testnet/mod.rs (L183-190)
```rust
            f.map_err(|err| {
                CliError::UnexpectedError(format!(
                    "One of the services failed to start up: {:?}. \
                    Please check the logs at {} for more information.",
                    err,
                    test_dir.display(),
                ))
            })?;
```

**File:** crates/aptos/src/node/local_testnet/health_checker.rs (L135-153)
```rust
    pub async fn wait(
        &self,
        // The service, if any, waiting for this service to start up.
        waiting_service: Option<&str>,
    ) -> Result<()> {
        let prefix = self.to_string();
        wait_for_startup(|| self.check(), match waiting_service {
            Some(waiting_service) => {
                format!(
                    "{} at {} did not start up before {}",
                    prefix,
                    self.address_str(),
                    waiting_service,
                )
            },
            None => format!("{} at {} did not start up", prefix, self.address_str()),
        })
        .await
    }
```

**File:** crates/aptos/src/node/local_testnet/health_checker.rs (L162-162)
```rust
            HealthChecker::Postgres(url) => url.as_str(),
```

**File:** crates/aptos/src/node/local_testnet/postgres.rs (L92-116)
```rust
    pub fn get_connection_string(&self, database: Option<&str>, external: bool) -> String {
        let password = match self.use_host_postgres {
            true => match &self.host_postgres_password {
                Some(password) => format!(":{}", password),
                None => "".to_string(),
            },
            false => "".to_string(),
        };
        let port = self.get_postgres_port(external);
        let database = match database {
            Some(database) => database,
            None => &self.postgres_database,
        };
        let host = match self.use_host_postgres {
            true => &self.host_postgres_host,
            false => match external {
                true => "127.0.0.1",
                false => POSTGRES_CONTAINER_NAME,
            },
        };
        format!(
            "postgres://{}{}@{}:{}/{}",
            self.postgres_user, password, host, port, database,
        )
    }
```

**File:** crates/aptos/src/node/local_testnet/postgres.rs (L154-156)
```rust
        let mut connection = AsyncPgConnection::establish(&connection_string)
            .await
            .with_context(|| format!("Failed to connect to postgres at {}", connection_string))?;
```
