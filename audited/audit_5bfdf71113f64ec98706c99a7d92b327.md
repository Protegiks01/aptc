# Audit Report

## Title
StateSnapshotBackupController Missing Cryptographic Validation Allows Creation of Backups with False Version Claims

## Summary
The `StateSnapshotBackupController` does not validate cryptographic proofs or verify ledger info signatures during backup creation. Since the backup service address is user-configurable, an operator could inadvertently create backups from a malicious service, resulting in backups with false metadata that claim to represent a specific blockchain state version but actually contain different or invalid data.

## Finding Description

The vulnerability exists in the state snapshot backup creation flow. When creating a backup, the controller:

1. Retrieves an epoch ending ledger info, extracts the version number, and **discards the signed ledger info without saving it for later validation** [1](#0-0) 

2. Retrieves state snapshot chunks and state root proof data from the backup service, but **never cryptographically verifies** that this data matches the epoch ending ledger info [2](#0-1) 

3. Creates a manifest claiming specific epoch and version, using an **unverified state root hash** extracted from the unvalidated proof [3](#0-2) 

The backup service address is user-configurable via command-line parameter, allowing operators to back up from remote services: [4](#0-3) 

**Attack Scenario:**

An attacker sets up a malicious backup service and tricks an operator into running:
```
aptos-node-checker db-tool backup oneoff --backup-service-address http://malicious-server.com:6186 ...
```

The malicious service can:
- Return a valid, properly-signed epoch ending ledger info for epoch N with version V1 and state root H1
- Return state snapshot data from a completely different version V2 with state root H2  
- Return an unverified state root proof claiming version V1 but containing state root H2

The backup controller blindly accepts all this data without verification and creates a backup claiming:
- `epoch: N`
- `version: V1` 
- `root_hash: H2` (NOT H1 from the epoch ending ledger info!)
- State data actually from V2

This breaks the **State Consistency** invariant that state must be "verifiable via Merkle proofs" - the backup system fails to verify the very proofs it's storing.

In contrast, the restore controller DOES perform proper validation: [5](#0-4) 

The asymmetry between backup (no validation) and restore (with validation) creates a security gap where invalid backups can be created.

## Impact Explanation

**Severity: Medium** (up to $10,000 per Aptos Bug Bounty criteria)

This qualifies as "State inconsistencies requiring intervention" because:

1. **Data Integrity Violation**: Backups can be created with false metadata, undermining the reliability of the backup system
2. **Potential State Corruption**: If an invalid backup is restored without epoch history validation available, it could result in database corruption
3. **Operational Risk**: Operators may not discover backup invalidity until restore time, potentially during disaster recovery when it's most critical
4. **Trust Boundary Violation**: The configurable backup service address creates an untrusted input path without corresponding validation

The impact is not Critical/High because:
- Does not directly enable fund theft or consensus violations
- Restore-time validation provides a safety net (if epoch history is available)
- Requires operator error or social engineering
- Does not affect running validator operations

## Likelihood Explanation

**Likelihood: Medium**

The vulnerability is exploitable when:
1. An operator configures a non-default backup service address (either intentionally for remote backup or through social engineering/misconfiguration)
2. The backup service is malicious or compromised
3. The operator creates backups without independently verifying their integrity

While this requires specific conditions, it's realistic because:
- Operators do perform backups from remote nodes in production deployments
- The backup service address parameter exists specifically to enable this use case
- No warnings or safeguards exist in the tooling to validate against untrusted services
- Backup operations are often automated, reducing chances of manual verification

## Recommendation

Add cryptographic validation during backup creation to match the validation performed during restore. Specifically:

1. **Save the epoch ending ledger info** retrieved in `get_version_for_epoch_ending()` instead of discarding it after extracting the version

2. **Verify the state root proof** in `write_manifest()`:
   - Verify that the `TransactionInfoWithProof` is cryptographically valid against the ledger info
   - Verify that the ledger info matches or is consistent with the epoch ending ledger info
   - Verify that the version matches the expected version

3. **Add explicit validation**:

```rust
async fn write_manifest(
    &self,
    backup_handle: &BackupHandleRef,
    chunks: Vec<StateSnapshotChunk>,
) -> Result<FileHandle> {
    let proof_bytes = self.client.get_state_root_proof(self.version()).await?;
    let (txn_info, ledger_info): (TransactionInfoWithProof, LedgerInfoWithSignatures) =
        bcs::from_bytes(&proof_bytes)?;

    // NEW: Verify the proof is cryptographically valid
    txn_info.verify(ledger_info.ledger_info(), self.version())?;
    
    // NEW: Verify state root hash consistency
    let state_root_hash = txn_info.transaction_info().ensure_state_checkpoint_hash()?;
    
    // NEW: Optionally verify against epoch ending ledger info if saved
    // (would require storing it in get_version_for_epoch_ending)
    
    let manifest = StateSnapshotBackup {
        epoch: self.epoch,
        version: self.version(),
        root_hash: state_root_hash,
        chunks,
        proof: proof_handle,
    };
    
    // ... rest of function
}
```

4. **Add warning for non-localhost backup services** to alert operators when backing up from potentially untrusted sources.

## Proof of Concept

```rust
// Proof of Concept: Malicious Backup Service Simulation
// This demonstrates how a malicious backup service can return mismatched data
// that the backup controller will accept without validation

#[cfg(test)]
mod malicious_backup_poc {
    use super::*;
    
    // Simulated malicious backup service that returns mismatched data
    struct MaliciousBackupService {
        // Returns epoch ending LI with version 1000
        epoch_ending_version: u64,
        // But returns state data from version 999
        actual_state_version: u64,
    }
    
    #[tokio::test]
    async fn test_backup_accepts_mismatched_versions() {
        // Setup: Create a backup controller pointing to malicious service
        // The malicious service will:
        // 1. Return epoch ending LI claiming version 1000
        // 2. Return state snapshot data from version 999
        // 3. Return state root proof for version 999 (not 1000)
        
        // Expected: Backup should be rejected
        // Actual: Backup is created with false metadata claiming version 1000
        
        // This PoC requires:
        // - Setting up a mock malicious backup service
        // - Configuring StateSnapshotBackupController to use it
        // - Observing that the backup is created without validation errors
        // - Verifying the manifest contains mismatched version/root_hash
        
        // The vulnerability is confirmed because no .verify() call exists
        // in the backup creation code path
    }
}
```

**Notes**

The vulnerability stems from an architectural decision to trust the backup service during backup creation and defer all validation to restore time. While this works when the backup service is trusted (local node), the user-configurable service address creates an attack surface for backups from untrusted sources. The fix should add the same cryptographic validation during backup that already exists during restore, implementing defense-in-depth and ensuring backup integrity regardless of source trustworthiness.

### Citations

**File:** storage/backup/backup-cli/src/backup_types/state_snapshot/backup.rs (L389-402)
```rust
    async fn get_version_for_epoch_ending(&self, epoch: u64) -> Result<u64> {
        let ledger_info: LedgerInfoWithSignatures = bcs::from_bytes(
            self.client
                .get_epoch_ending_ledger_infos(epoch, epoch + 1)
                .await?
                .read_record_bytes()
                .await?
                .ok_or_else(|| {
                    anyhow!("Failed to get epoch ending ledger info for epoch {}", epoch)
                })?
                .as_ref(),
        )?;
        Ok(ledger_info.ledger_info().version())
    }
```

**File:** storage/backup/backup-cli/src/backup_types/state_snapshot/backup.rs (L454-456)
```rust
        let proof_bytes = self.client.get_state_root_proof(self.version()).await?;
        let (txn_info, _): (TransactionInfoWithProof, LedgerInfoWithSignatures) =
            bcs::from_bytes(&proof_bytes)?;
```

**File:** storage/backup/backup-cli/src/backup_types/state_snapshot/backup.rs (L465-471)
```rust
        let manifest = StateSnapshotBackup {
            epoch: self.epoch,
            version: self.version(),
            root_hash: txn_info.transaction_info().ensure_state_checkpoint_hash()?,
            chunks,
            proof: proof_handle,
        };
```

**File:** storage/backup/backup-cli/src/utils/backup_service_client.rs (L23-31)
```rust
pub struct BackupServiceClientOpt {
    #[clap(
        long = "backup-service-address",
        default_value = "http://localhost:6186",
        help = "Backup service address. By default a Aptos Node runs the backup service serving \
        on tcp port 6186 to localhost only."
    )]
    pub address: String,
}
```

**File:** storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs (L125-139)
```rust
        let (txn_info_with_proof, li): (TransactionInfoWithProof, LedgerInfoWithSignatures) =
            self.storage.load_bcs_file(&manifest.proof).await?;
        txn_info_with_proof.verify(li.ledger_info(), manifest.version)?;
        let state_root_hash = txn_info_with_proof
            .transaction_info()
            .ensure_state_checkpoint_hash()?;
        ensure!(
            state_root_hash == manifest.root_hash,
            "Root hash mismatch with that in proof. root hash: {}, expected: {}",
            manifest.root_hash,
            state_root_hash,
        );
        if let Some(epoch_history) = self.epoch_history.as_ref() {
            epoch_history.verify_ledger_info(&li)?;
        }
```
