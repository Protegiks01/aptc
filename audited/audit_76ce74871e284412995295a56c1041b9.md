# Audit Report

## Title
PeerId Not Cryptographically Bound to Network Private Key - Identity Spoofing Vulnerability

## Summary
The `aptos_node_identity::init()` function accepts an arbitrary PeerId without validating it matches the node's network private key. This allows Byzantine validators to operate with a peer identity that doesn't cryptographically correspond to their network keys, violating the fundamental security invariant that identity must be cryptographically bound to keys.

## Finding Description

The Aptos Core codebase fails to enforce cryptographic binding between a node's PeerId and its network private key at multiple critical points:

**1. No Validation in aptos_node_identity::init()** [1](#0-0) 

The `init()` function accepts a `peer_id` parameter and stores it globally without any verification that it was correctly derived from the node's x25519 private key using `from_identity_public_key()`.

**2. NetworkConfig Allows Mismatched PeerId** [2](#0-1) 

The `peer_id()` method returns PeerIds from multiple sources without validation:
- `Identity::FromConfig`: Returns `config.peer_id` directly without verification
- `Identity::FromFile`: Returns `account_address` from file if present, without verifying it matches the `network_private_key`
- `Identity::FromStorage`: Returns stored peer_id without verification [3](#0-2) 

The `prepare_identity()` function only derives the correct PeerId when `peer_id == PeerId::ZERO`. If a non-zero PeerId is provided, it's accepted without validation.

**3. Identity Configuration Constructor Accepts Arbitrary Values** [4](#0-3) 

The `Identity::from_config()` constructor accepts both a private key and peer_id as separate, independent parameters without enforcing their cryptographic relationship.

**4. On-Chain Validator Registration Lacks Validation** [5](#0-4) 

The `update_network_and_fullnode_addresses()` function accepts network addresses as raw bytes without validating that embedded x25519 public keys derive to the validator's account_address (which serves as their PeerId).

**5. Trusted Peer Authentication Doesn't Verify Derivation** [6](#0-5) 

For trusted peers (validators), authentication only checks if the presented public key exists in the peer's key set, but doesn't verify the PeerId was correctly derived from that public key. [7](#0-6) 

**Attack Path:**

1. Byzantine validator with account_address A generates a separate keypair (privB, pubB) where derived_peer_id_B = `from_identity_public_key(pubB)` ≠ A
2. Validator registers on-chain with network_addresses containing pubB (no validation prevents this)
3. Validator configures their node with `Identity::FromConfig(privB, peer_id=A)` - mismatched identity
4. Other validators fetch validator set, creating trusted peer mapping: `A -> keys{pubB}`
5. When Byzantine validator connects:
   - Sends PeerId A in handshake prologue
   - Uses privB in Noise protocol
   - Remote validator authenticates against peer A's key set
   - Finds pubB in the set → authentication succeeds
6. Byzantine validator now operates as peer A with cryptographic identity pubB

The validator is identified throughout the network as peer A, but their actual cryptographic identity (pubB) should derive to a different PeerId. This breaks the fundamental security property that identity is cryptographically verifiable.

## Impact Explanation

**Severity: HIGH / CRITICAL**

This vulnerability violates **Invariant #10: Cryptographic Correctness** - the system assumes PeerId is cryptographically derived from network keys, but this isn't enforced.

**Concrete Impacts:**

1. **Identity Spoofing**: A validator can claim an identity (PeerId A) that doesn't correspond to their cryptographic keys (pubB), enabling them to impersonate or confuse identity-based systems

2. **Accountability Bypass**: Malicious actions signed with pubB are attributed to peer A in logs and monitoring systems, breaking forensic analysis

3. **Trust Model Violation**: Any component expecting PeerId to be derived from public keys will have incorrect assumptions, potentially enabling further exploits

4. **Validator Set Manipulation**: If stake, rewards, or governance are tied to PeerId while network operations use public keys, this creates an exploitable inconsistency

While this doesn't enable traditional eclipse attacks (different PeerIds to different peers simultaneously), it's a fundamental architectural flaw that undermines the cryptographic security model. It falls under **"Significant protocol violations"** (High Severity) and potentially **"Consensus/Safety violations"** (Critical Severity) depending on how identity is used in consensus.

## Likelihood Explanation

**Likelihood: HIGH**

- Requires only validator operator access (Byzantine validator scenario explicitly mentioned in the security question)
- No complex cryptographic exploits needed - simple configuration manipulation
- All necessary code paths exist and are easily accessible
- No runtime detection or prevention mechanisms in place
- The vulnerability exists in production code with no mitigating controls

The test at lines 176-221 in `network/discovery/src/validator_set.rs` explicitly demonstrates that key mismatches are expected and only result in metric updates, not enforcement. [8](#0-7) 

## Recommendation

**Immediate Fix:**

1. Add validation in `aptos_node_identity::init()` to verify PeerId matches the network private key:

```rust
pub fn init(peer_id: Option<PeerId>, identity_key: Option<x25519::PrivateKey>) -> Result<()> {
    if let (Some(pid), Some(key)) = (peer_id, identity_key) {
        let derived_peer_id = aptos_types::account_address::from_identity_public_key(
            key.public_key()
        );
        if pid != derived_peer_id {
            return Err(format_err!(
                "PeerId mismatch: configured={}, derived={}", 
                pid, derived_peer_id
            ));
        }
    }
    // ... rest of init
}
```

2. Add validation in `NetworkConfig::peer_id()` to always verify consistency:

```rust
pub fn peer_id(&self) -> PeerId {
    let peer_id = match &self.identity {
        // ... existing logic
    }.expect("peer id should be present");
    
    // Always verify consistency
    let identity_key = self.identity_key();
    let derived = from_identity_public_key(identity_key.public_key());
    assert_eq!(peer_id, derived, "PeerId must match derived value");
    
    peer_id
}
```

3. Add on-chain validation in `stake.move`:

```move
public entry fun update_network_and_fullnode_addresses(
    operator: &signer,
    pool_address: address,
    new_network_addresses: vector<u8>,
    new_fullnode_addresses: vector<u8>,
) {
    // Existing checks...
    
    // Validate network addresses contain keys deriving to pool_address
    validate_network_addresses_match_account(pool_address, new_network_addresses);
    
    // ... rest of function
}
```

4. Change `Identity::from_config()` to always derive PeerId:

```rust
pub fn from_config(key: x25519::PrivateKey) -> Self {
    let peer_id = from_identity_public_key(key.public_key());
    // Don't accept peer_id as parameter - always derive it
    Identity::FromConfig(IdentityFromConfig { key, peer_id, ... })
}
```

## Proof of Concept

```rust
// Rust PoC demonstrating the vulnerability
use aptos_config::config::{Identity, IdentityConfig};
use aptos_crypto::x25519;
use aptos_types::PeerId;

fn main() {
    // Generate two different keypairs
    let key_a = x25519::PrivateKey::generate(&mut rng);
    let key_b = x25519::PrivateKey::generate(&mut rng);
    
    // Derive correct peer IDs
    let peer_id_a = aptos_types::account_address::from_identity_public_key(
        key_a.public_key()
    );
    let peer_id_b = aptos_types::account_address::from_identity_public_key(
        key_b.public_key()
    );
    
    assert_ne!(peer_id_a, peer_id_b);
    
    // Create mismatched identity - key_b with peer_id_a
    let mismatched_identity = Identity::from_config(key_b, peer_id_a);
    
    // This succeeds! No validation occurs
    let mut config = NetworkConfig::default();
    config.identity = mismatched_identity;
    
    // peer_id() returns peer_id_a (mismatched)
    assert_eq!(config.peer_id(), peer_id_a);
    
    // But identity_key() returns key_b
    assert_eq!(config.identity_key().public_key(), key_b.public_key());
    
    // Node would initialize with this inconsistent state
    aptos_node_identity::init(Some(peer_id_a)).unwrap();
    
    println!("Successfully created mismatched identity!");
    println!("Claimed PeerId: {}", peer_id_a);
    println!("Actual key derives to: {}", peer_id_b);
}
```

### Citations

**File:** crates/aptos-node-identity/src/lib.rs (L20-32)
```rust
/// Initializes the [AptosNodeIdentity] using the provided [PeerId] and
/// sets it globally exactly once.
pub fn init(peer_id: Option<PeerId>) -> Result<()> {
    let identity = AptosNodeIdentity {
        chain_id: OnceCell::new(),
        peer_id,
        peer_id_str: peer_id.map(|id| id.to_string()),
    };

    APTOS_NODE_IDENTITY
        .set(Arc::new(identity))
        .map_err(|_| format_err!("APTOS_NODE_IDENTITY was already set"))
}
```

**File:** config/src/config/network_config.rs (L244-270)
```rust
    pub fn peer_id(&self) -> PeerId {
        match &self.identity {
            Identity::FromConfig(config) => Some(config.peer_id),
            Identity::FromStorage(config) => {
                let storage: Storage = (&config.backend).into();
                let peer_id = storage
                    .get::<PeerId>(&config.peer_id_name)
                    .expect("Unable to read peer id")
                    .value;
                Some(peer_id)
            },
            Identity::FromFile(config) => {
                let identity_blob: IdentityBlob = IdentityBlob::from_file(&config.path).unwrap();

                // If account is not specified, generate peer id from public key
                if let Some(address) = identity_blob.account_address {
                    Some(address)
                } else {
                    Some(from_identity_public_key(
                        identity_blob.network_private_key.public_key(),
                    ))
                }
            },
            Identity::None => None,
        }
        .expect("peer id should be present")
    }
```

**File:** config/src/config/network_config.rs (L272-288)
```rust
    fn prepare_identity(&mut self) {
        match &mut self.identity {
            Identity::FromStorage(_) => (),
            Identity::None => {
                let mut rng = StdRng::from_seed(OsRng.r#gen());
                let key = x25519::PrivateKey::generate(&mut rng);
                let peer_id = from_identity_public_key(key.public_key());
                self.identity = Identity::from_config_auto_generated(key, peer_id);
            },
            Identity::FromConfig(config) => {
                if config.peer_id == PeerId::ZERO {
                    config.peer_id = from_identity_public_key(config.key.public_key());
                }
            },
            Identity::FromFile(_) => (),
        };
    }
```

**File:** config/src/config/identity_config.rs (L75-82)
```rust
    pub fn from_config(key: x25519::PrivateKey, peer_id: PeerId) -> Self {
        let key = ConfigKey::new(key);
        Identity::FromConfig(IdentityFromConfig {
            key,
            peer_id,
            source: IdentitySource::UserProvided,
        })
    }
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L955-995)
```text
    public entry fun update_network_and_fullnode_addresses(
        operator: &signer,
        pool_address: address,
        new_network_addresses: vector<u8>,
        new_fullnode_addresses: vector<u8>,
    ) acquires StakePool, ValidatorConfig {
        check_stake_permission(operator);
        assert_reconfig_not_in_progress();
        assert_stake_pool_exists(pool_address);
        let stake_pool = borrow_global_mut<StakePool>(pool_address);
        assert!(signer::address_of(operator) == stake_pool.operator_address, error::unauthenticated(ENOT_OPERATOR));
        assert!(exists<ValidatorConfig>(pool_address), error::not_found(EVALIDATOR_CONFIG));
        let validator_info = borrow_global_mut<ValidatorConfig>(pool_address);
        let old_network_addresses = validator_info.network_addresses;
        validator_info.network_addresses = new_network_addresses;
        let old_fullnode_addresses = validator_info.fullnode_addresses;
        validator_info.fullnode_addresses = new_fullnode_addresses;

        if (std::features::module_event_migration_enabled()) {
            event::emit(
                UpdateNetworkAndFullnodeAddresses {
                    pool_address,
                    old_network_addresses,
                    new_network_addresses,
                    old_fullnode_addresses,
                    new_fullnode_addresses,
                },
            );
        } else {
            event::emit_event(
                &mut stake_pool.update_network_and_fullnode_addresses_events,
                UpdateNetworkAndFullnodeAddressesEvent {
                    pool_address,
                    old_network_addresses,
                    new_network_addresses,
                    old_fullnode_addresses,
                    new_fullnode_addresses,
                },
            );
        };
    }
```

**File:** network/framework/src/noise/handshake.rs (L366-382)
```rust
        // if mutual auth mode, verify the remote pubkey is in our set of trusted peers
        let network_id = self.network_context.network_id();
        let peer_role = match &self.auth_mode {
            HandshakeAuthMode::Mutual {
                peers_and_metadata, ..
            } => {
                let trusted_peers = peers_and_metadata.get_trusted_peers(&network_id)?;
                let trusted_peer = trusted_peers.get(&remote_peer_id).cloned();
                match trusted_peer {
                    Some(peer) => {
                        Self::authenticate_inbound(remote_peer_short, &peer, &remote_public_key)
                    },
                    None => Err(NoiseHandshakeError::UnauthenticatedClient(
                        remote_peer_short,
                        remote_peer_id,
                    )),
                }
```

**File:** network/framework/src/noise/handshake.rs (L488-500)
```rust
    fn authenticate_inbound(
        remote_peer_short: ShortHexStr,
        peer: &Peer,
        remote_public_key: &x25519::PublicKey,
    ) -> Result<PeerRole, NoiseHandshakeError> {
        if !peer.keys.contains(remote_public_key) {
            return Err(NoiseHandshakeError::UnauthenticatedClientPubkey(
                remote_peer_short,
                hex::encode(remote_public_key.as_slice()),
            ));
        }
        Ok(peer.role)
    }
```

**File:** network/discovery/src/validator_set.rs (L176-221)
```rust
    fn metric_if_key_mismatch() {
        aptos_logger::Logger::init_for_testing();
        let runtime = Runtime::new().unwrap();
        let consensus_private_key = bls12381::PrivateKey::generate_for_testing();
        let consensus_pubkey = consensus_private_key.public_key();
        let pubkey = test_pubkey([0u8; 32]);
        let different_pubkey = test_pubkey([1u8; 32]);
        let peer_id = aptos_types::account_address::from_identity_public_key(pubkey);

        // Build up the Reconfig Listener
        let (conn_mgr_reqs_tx, _rx) = aptos_channels::new_test(1);
        let (mut reconfig_sender, reconfig_events) = aptos_channel::new(QueueStyle::LIFO, 1, None);
        let reconfig_listener = ReconfigNotificationListener {
            notification_receiver: reconfig_events,
        };
        let network_context = NetworkContext::mock_with_peer_id(peer_id);
        let listener = DiscoveryChangeListener::validator_set(
            network_context,
            conn_mgr_reqs_tx,
            pubkey,
            reconfig_listener,
        );

        // Build up and send an update with a different pubkey
        send_pubkey_update(
            peer_id,
            consensus_pubkey,
            different_pubkey,
            &mut reconfig_sender,
        );

        let listener_future = async move {
            // Run the test, ensuring we actually stop after a couple seconds in case it fails to fail
            timeout_at(
                tokio::time::Instant::from(Instant::now() + Duration::from_secs(1)),
                Box::pin(listener).run(),
            )
            .await
            .expect_err("Expect timeout");
        };

        // Ensure the metric is updated
        check_network_key_mismatch_metric(0, &network_context);
        block_on(runtime.spawn(listener_future)).unwrap();
        check_network_key_mismatch_metric(1, &network_context);
    }
```
