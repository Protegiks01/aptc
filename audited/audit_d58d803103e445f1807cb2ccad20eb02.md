# Audit Report

## Title
Admin Service Information Disclosure: Validator Operational Intelligence Exposure via Unauthenticated Debug Endpoints

## Summary
The Admin Service exposes sensitive validator operational data through debug endpoints (`/debug/consensus/*`) that bind to all network interfaces (0.0.0.0) by default and require no authentication on testnet/devnet networks. An attacker with network access to port 9102 can extract consensus state, validator behavior patterns, and pending transactions, enabling reconnaissance for targeted attacks. [1](#0-0) 

## Finding Description

The `db_tool.rs` functionality is exposed through the Admin Service HTTP endpoints, creating an information disclosure vulnerability. The tool reads from ConsensusDB and QuorumStoreDB to extract blocks, transactions, and consensus metadata. [2](#0-1) 

The Admin Service implements weak access controls:

1. **Default Network Binding**: The service binds to `0.0.0.0` (all interfaces) rather than `127.0.0.1` (localhost only), making it accessible from any network interface. [3](#0-2) 

2. **Unauthenticated by Default on Testnet**: When `authentication_configs` is empty (the default), all requests are allowed without authentication on non-mainnet networks. [4](#0-3) 

3. **Enabled by Default on Testnet**: The service is automatically enabled on non-mainnet networks. [5](#0-4) 

The exposed endpoints reveal:
- **Validator identities**: Block authors and proposal patterns [6](#0-5) 

- **Consensus state**: Votes, timeout certificates, quorum certificates
- **Transaction data**: Pending and committed transactions from blocks [7](#0-6) 

- **Timing information**: Block timestamps, round progression, epoch data

An attacker can use this intelligence for:
1. **Targeted DDoS**: Identify and attack the next block proposer before their round
2. **MEV Exploitation**: Extract value from visibility into pending transactions
3. **Validator Deanonymization**: Correlate IP addresses with on-chain validator identities
4. **Eclipse Attacks**: Map network topology through block parent relationships
5. **Consensus Timing Attacks**: Understand round timing for strategic disruption

## Impact Explanation

This qualifies as **Medium Severity** under the Aptos Bug Bounty program. While it doesn't directly cause funds loss or consensus breaks, it provides significant intelligence that materially aids more sophisticated attacks against validator infrastructure.

The disclosure of validator behavior patterns, pending transactions, and consensus state breaks the **Access Control** security invariant that sensitive operational data should be restricted. Even though mainnet has protections, testnet and devnet validators are production systems handling real operational workloads and should maintain confidentiality of internal state.

The weak authentication mechanism (SHA256 hashes of passcodes in URL query parameters) is vulnerable to:
- Log file leakage (URLs with query parameters are commonly logged)
- Network traffic analysis (if not using HTTPS)
- Brute force attacks (if weak passcodes are chosen) [8](#0-7) 

## Likelihood Explanation

The likelihood varies by deployment:

**High on Testnet/Devnet**: The service is enabled by default with no authentication, and port 9102 may be exposed through misconfigured firewalls or in containerized environments where 0.0.0.0 binding is necessary for external access. [9](#0-8) 

**Low on Mainnet**: The service is disabled by default and the sanitizer enforces authentication if enabled. [10](#0-9) 

However, misconfigurations can occur, and the default 0.0.0.0 binding increases the attack surface unnecessarily.

## Recommendation

Implement defense-in-depth measures:

1. **Bind to localhost by default**: Change the default address from `0.0.0.0` to `127.0.0.1` to prevent external network access. Allow override via explicit configuration for containerized deployments.

```rust
// In admin_service_config.rs
impl Default for AdminServiceConfig {
    fn default() -> Self {
        Self {
            enabled: None,
            address: "127.0.0.1".to_string(), // Changed from "0.0.0.0"
            port: 9102,
            authentication_configs: vec![],
            malloc_stats_max_len: 2 * 1024 * 1024,
        }
    }
}
```

2. **Require authentication on all networks**: Enforce authentication even on testnet/devnet, not just mainnet.

3. **Use stronger authentication**: Replace query parameter passcodes with HTTP header-based authentication (e.g., Bearer tokens) or mutual TLS.

4. **Add rate limiting**: Implement rate limits on debug endpoints to prevent abuse.

5. **Implement audit logging**: Log all access attempts to debug endpoints for security monitoring.

6. **Document security implications**: Add prominent warnings in configuration documentation about the security risks of exposing these endpoints.

## Proof of Concept

On a testnet validator node with default configuration where port 9102 is network-accessible:

```bash
# Enumerate consensus database contents
curl -v http://<validator-ip>:9102/debug/consensus/consensusdb

# Extract all blocks and transactions
curl -v http://<validator-ip>:9102/debug/consensus/block

# Query specific block
curl -v "http://<validator-ip>:9102/debug/consensus/block?block_id=<hash>"

# Dump quorum store batches
curl -v http://<validator-ip>:9102/debug/consensus/quorumstoredb
```

The responses expose:
- Validator addresses and proposal patterns
- Block IDs, epochs, rounds, timestamps
- Transaction payloads
- Quorum certificates and voting data

This information enables an attacker to profile validator behavior and plan targeted attacks without requiring any authentication or privileged access.

## Notes

While mainnet deployments have appropriate protections (disabled by default, authentication required), the security posture for testnet/devnet is inadequate. Testnet validators often mirror production configurations and handle sensitive operational workloads. The principle of least privilege and defense-in-depth suggest that debugging endpoints should be restricted to localhost access by default across all network types, with explicit opt-in for external access when operationally necessary.

The underlying `db_tool.rs` is a legitimate debugging utility, but its exposure through an unauthenticated HTTP service on all network interfaces creates an unnecessary attack surface that violates security best practices.

### Citations

**File:** consensus/src/util/db_tool.rs (L25-67)
```rust
#[derive(Parser)]
#[clap(about = "Dump txns from consensus db.")]
pub struct Command {
    #[clap(long, value_parser)]
    pub db_dir: PathBuf,

    // If None, will dump all blocks.
    #[clap(long)]
    pub block_id: Option<HashValue>,
}

impl Command {
    pub async fn run(self) -> Result<()> {
        let txns = self.dump_pending_txns()?;
        println!("{txns:?}");

        Ok(())
    }

    pub fn dump_pending_txns(&self) -> Result<Vec<Transaction>> {
        let quorum_store_db = QuorumStoreDB::new(self.db_dir.clone());
        let all_batches = quorum_store_db.get_all_batches().unwrap();

        let consensus_db = ConsensusDB::new(self.db_dir.clone());
        let (_, _, blocks, _) = consensus_db.get_data()?;

        let mut txns = Vec::new();
        for block in blocks {
            let id = block.id();
            #[allow(clippy::unwrap_in_result)]
            if self.block_id.is_none() || id == self.block_id.unwrap() {
                txns.extend(
                    extract_txns_from_block(&block, &all_batches)?
                        .into_iter()
                        .cloned()
                        .map(Transaction::UserTransaction),
                );
            }
        }

        Ok(txns)
    }
}
```

**File:** crates/aptos-admin-service/src/server/consensus/mod.rs (L130-156)
```rust
fn dump_consensus_db(consensus_db: &dyn PersistentLivenessStorage) -> anyhow::Result<String> {
    let mut body = String::new();

    let (last_vote, highest_tc, consensus_blocks, consensus_qcs) =
        consensus_db.consensus_db().get_data()?;

    body.push_str(&format!("Last vote: \n{last_vote:?}\n\n"));
    body.push_str(&format!("Highest tc: \n{highest_tc:?}\n\n"));
    body.push_str("Blocks: \n");
    for block in consensus_blocks {
        body.push_str(&format!(
            "[id: {:?}, author: {:?}, epoch: {}, round: {:02}, parent_id: {:?}, timestamp: {}, payload: {:?}]\n\n",
            block.id(),
            block.author(),
            block.epoch(),
            block.round(),
            block.parent_id(),
            block.timestamp_usecs(),
            block.payload(),
        ));
    }
    body.push_str("QCs: \n");
    for qc in consensus_qcs {
        body.push_str(&format!("{qc:?}\n\n"));
    }
    Ok(body)
}
```

**File:** crates/aptos-admin-service/src/server/consensus/mod.rs (L179-215)
```rust
fn dump_blocks(
    consensus_db: &dyn PersistentLivenessStorage,
    quorum_store_db: &dyn QuorumStoreStorage,
    block_id: Option<HashValue>,
) -> anyhow::Result<String> {
    let mut body = String::new();

    let all_batches = quorum_store_db.get_all_batches()?;

    let (_, _, blocks, _) = consensus_db.consensus_db().get_data()?;

    for block in blocks {
        let id = block.id();
        if block_id.is_none() || id == block_id.unwrap() {
            body.push_str(&format!("Block ({id:?}): \n\n"));
            match extract_txns_from_block(&block, &all_batches) {
                Ok(txns) => {
                    body.push_str(&format!("{txns:?}"));
                },
                Err(e) => {
                    body.push_str(&format!("Not available: {e:?}"));
                },
            };
            body.push_str("\n\n");
        }
    }

    if body.is_empty() {
        if let Some(block_id) = block_id {
            body.push_str(&format!("Done, block ({block_id:?}) is not found."));
        } else {
            body.push_str("Done, no block is found.");
        }
    }

    Ok(body)
}
```

**File:** config/src/config/admin_service_config.rs (L26-39)
```rust
#[derive(Clone, Debug, Deserialize, PartialEq, Eq, Serialize)]
#[serde(rename_all = "snake_case")]
pub enum AuthenticationConfig {
    // This will allow authentication through query parameter.
    // e.g. `/profilez?passcode=abc`.
    //
    // To calculate sha256, use sha256sum tool, or other online tools.
    //
    // e.g.
    //
    // printf abc |sha256sum
    PasscodeSha256(String),
    // TODO(grao): Add SSL support if necessary.
}
```

**File:** config/src/config/admin_service_config.rs (L41-50)
```rust
impl Default for AdminServiceConfig {
    fn default() -> Self {
        Self {
            enabled: None,
            address: "0.0.0.0".to_string(),
            port: 9102,
            authentication_configs: vec![],
            malloc_stats_max_len: 2 * 1024 * 1024,
        }
    }
```

**File:** config/src/config/admin_service_config.rs (L67-78)
```rust
        if node_config.admin_service.enabled == Some(true) {
            if let Some(chain_id) = chain_id {
                if chain_id.is_mainnet()
                    && node_config.admin_service.authentication_configs.is_empty()
                {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name,
                        "Must enable authentication for AdminService on mainnet.".into(),
                    ));
                }
            }
        }
```

**File:** config/src/config/admin_service_config.rs (L93-101)
```rust
        if node_config.admin_service.enabled.is_none() {
            // Only enable the admin service if the chain is not mainnet
            let admin_service_enabled = if let Some(chain_id) = chain_id {
                !chain_id.is_mainnet()
            } else {
                false // We cannot determine the chain ID, so we disable the admin service
            };
            node_config.admin_service.enabled = Some(admin_service_enabled);

```

**File:** crates/aptos-admin-service/src/server/mod.rs (L154-174)
```rust
        let mut authenticated = false;
        if context.config.authentication_configs.is_empty() {
            authenticated = true;
        } else {
            for authentication_config in &context.config.authentication_configs {
                match authentication_config {
                    AuthenticationConfig::PasscodeSha256(passcode_sha256) => {
                        let query = req.uri().query().unwrap_or("");
                        let query_pairs: HashMap<_, _> =
                            url::form_urlencoded::parse(query.as_bytes()).collect();
                        let passcode: Option<String> =
                            query_pairs.get("passcode").map(|p| p.to_string());
                        if let Some(passcode) = passcode {
                            if sha256::digest(passcode) == *passcode_sha256 {
                                authenticated = true;
                            }
                        }
                    },
                }
            }
        };
```

**File:** terraform/helm/aptos-node/templates/validator.yaml (L32-34)
```yaml
    port: 9101
  - name: admin
    port: 9102
```
