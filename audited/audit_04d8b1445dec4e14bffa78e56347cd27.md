# Audit Report

## Title
Unauthorized Account State Manipulation via System Module Entry Function in Coin Migration

## Summary
The `migrate_coin_store_to_fungible_store<CoinType>()` entry function in the 0x1::coin system module lacks signer-based access control, allowing any attacker to forcibly migrate arbitrary users' CoinStore resources to FungibleStore without their consent when migration feature flags are enabled. This bypasses the fundamental Move access control principle that resource owners must authorize modifications to their own resources.

## Finding Description

The Aptos Framework's coin module contains a public entry function that violates access control invariants: [1](#0-0) 

This function accepts a `vector<address>` parameter without requiring any signer authentication. When feature flags `new_accounts_default_to_fa_store_enabled` or `new_accounts_default_to_fa_apt_store_enabled` are enabled, anyone can call this function to forcibly migrate other users' CoinStores.

The underlying migration logic performs privileged operations on user resources: [2](#0-1) 

The `move_from<CoinStore<CoinType>>(account)` operation extracts resources from arbitrary addresses without requiring their authorization.

**Attack Path:**

1. Attacker creates an EntryFunction transaction with:
   - `module`: ModuleId for `0x1::coin`
   - `function`: Identifier `"migrate_coin_store_to_fungible_store"`  
   - `ty_args`: `[0x1::aptos_coin::AptosCoin]` (or any CoinType)
   - `args`: BCS-serialized `vector<address>` containing victim addresses

2. The VM loads and executes the entry function without signer validation: [3](#0-2) 

3. The validation only checks that the function is marked as `entry`, not whether it has proper access controls: [4](#0-3) 

4. Transaction arguments are validated for type correctness but NOT for authorization: [5](#0-4) 

The signer parameters are only matched to transaction senders. Since this function has NO signer parameters, no authorization check occurs.

5. Each victim's CoinStore is forcibly migrated, changing their account state structure without consent.

**Invariant Violation:**

This breaks the Access Control invariant (#8): "System addresses (@aptos_framework, @core_resources) must be protected" and the broader Move principle that resource modifications require owner authorization through signers.

## Impact Explanation

**Severity: HIGH** (per Aptos Bug Bounty criteria: "Significant protocol violations")

This vulnerability enables:

1. **Unauthorized State Modification**: Attackers can modify the storage structure of any user's coin holdings without permission
2. **Loss of User Control**: Users cannot prevent or delay migration of their assets
3. **Application Breakage**: dApps expecting CoinStore structure will break when users are prematurely migrated
4. **Griefing Vector**: Mass migration attacks could disrupt the ecosystem
5. **Access Control Bypass**: Violates the fundamental principle that only resource owners (via signers) can modify their resources

While no funds are directly stolen, this represents a significant protocol-level access control failure in a core system module. The feature flag gating reduces likelihood but does not eliminate the vulnerability once flags are enabled for legitimate migration purposes.

## Likelihood Explanation

**Likelihood: MEDIUM to HIGH** (when feature flags are enabled)

**Pre-conditions:**
- Feature flag `NEW_ACCOUNTS_DEFAULT_TO_FA_STORE` or related flags must be enabled via governance [6](#0-5) 

**Attacker Requirements:**
- Standard transaction submission capability (no special privileges)
- Knowledge of victim addresses
- Gas fees for transaction execution

**Exploitation Complexity: LOW**
Once feature flags are enabled (which is expected during migration phases), exploitation is trivial. Any user can submit the malicious EntryFunction transaction targeting arbitrary addresses.

## Recommendation

**Fix: Require signer-based authorization**

The framework already provides a secure alternative with proper access control: [7](#0-6) 

**Recommended Changes:**

1. **Remove the vulnerable function** or change it to `public(friend)` visibility to restrict access to trusted modules only

2. **Alternative**: If batch migration is needed, require explicit authorization:
```move
public entry fun migrate_coin_store_to_fungible_store_with_consent<CoinType>(
    account: &signer
) acquires CoinStore, CoinConversionMap, CoinInfo {
    let account_addr = signer::address_of(account);
    maybe_convert_to_fungible_store<CoinType>(account_addr);
}
```

3. **Governance-Only Option**: If permissionless migration is truly intended, make it callable only by @aptos_framework:
```move
public entry fun migrate_coin_store_to_fungible_store<CoinType>(
    framework: &signer,
    accounts: vector<address>
) acquires CoinStore, CoinConversionMap, CoinInfo {
    system_addresses::assert_aptos_framework(framework);
    // ... existing logic
}
```

## Proof of Concept

```move
#[test_only]
module attacker::exploit {
    use aptos_framework::coin;
    use aptos_framework::aptos_coin::AptosCoin;
    use std::signer;
    use std::vector;
    
    #[test(attacker = @0xBAD, victim = @0x123, aptos_framework = @0x1)]
    fun test_unauthorized_migration(
        attacker: &signer,
        victim: &signer,
        aptos_framework: &signer
    ) {
        // Setup: Create victim account with CoinStore
        let victim_addr = signer::address_of(victim);
        aptos_framework::account::create_account_for_test(victim_addr);
        coin::register<AptosCoin>(victim);
        
        // Enable feature flag (normally via governance)
        features::change_feature_flags_for_testing(
            aptos_framework,
            vector[features::get_new_accounts_default_to_fa_store_feature()],
            vector[]
        );
        
        // ATTACK: Attacker (with no special privileges) forces victim's migration
        let victims = vector::empty<address>();
        vector::push_back(&mut victims, victim_addr);
        
        // This call succeeds even though attacker != victim
        coin::migrate_coin_store_to_fungible_store<AptosCoin>(victims);
        
        // Victim's CoinStore has been forcibly migrated without their consent
        assert!(!coin::is_account_registered<AptosCoin>(victim_addr), 1);
    }
}
```

**Notes:**

The vulnerability exists at the intersection of EntryFunction transaction validation and Move framework design. While `EntryFunction::new()` itself has no validation logic (it's just a constructor), the security issue emerges because the VM's validation of entry functions checks only that the function is marked `entry` and has valid parameter types, but does NOT enforce that functions modifying user state must require signer authorization from affected accounts. [8](#0-7)

### Citations

**File:** aptos-move/framework/aptos-framework/sources/coin.move (L650-701)
```text
    fun maybe_convert_to_fungible_store<CoinType>(
        account: address
    ) acquires CoinStore, CoinConversionMap, CoinInfo {
        if (exists<CoinStore<CoinType>>(account)) {
            let CoinStore<CoinType> { coin, frozen, deposit_events, withdraw_events } =
                move_from<CoinStore<CoinType>>(account);
            if (is_coin_initialized<CoinType>() && coin.value > 0) {
                let metadata = ensure_paired_metadata<CoinType>();
                let store =
                    primary_fungible_store::ensure_primary_store_exists(
                        account, metadata
                    );

                event::emit(
                    CoinStoreDeletion {
                        coin_type: type_info::type_name<CoinType>(),
                        event_handle_creation_address: guid::creator_address(
                            event::guid(&deposit_events)
                        ),
                        deleted_deposit_event_handle_creation_number: guid::creation_num(
                            event::guid(&deposit_events)
                        ),
                        deleted_withdraw_event_handle_creation_number: guid::creation_num(
                            event::guid(&withdraw_events)
                        )
                    }
                );

                if (coin.value == 0) {
                    destroy_zero(coin);
                } else {
                    fungible_asset::unchecked_deposit_with_no_events(
                        object_address(&store),
                        coin_to_fungible_asset(coin)
                    );
                };

                // Note:
                // It is possible the primary fungible store may already exist before this function call.
                // In this case, if the account owns a frozen CoinStore and an unfrozen primary fungible store, this
                // function would convert and deposit the rest coin into the primary store and freeze it to make the
                // `frozen` semantic as consistent as possible.
                if (frozen != fungible_asset::is_frozen(store)) {
                    fungible_asset::set_frozen_flag_internal(store, frozen);
                }
            } else {
                destroy_zero(coin);
            };
            event::destroy_handle(deposit_events);
            event::destroy_handle(withdraw_events);
        };
    }
```

**File:** aptos-move/framework/aptos-framework/sources/coin.move (L717-723)
```text
    public entry fun migrate_to_fungible_store<CoinType>(
        account: &signer
    ) acquires CoinStore, CoinConversionMap, CoinInfo {
        let account_addr = signer::address_of(account);
        assert_signer_has_permission<CoinType>(account);
        maybe_convert_to_fungible_store<CoinType>(account_addr);
    }
```

**File:** aptos-move/framework/aptos-framework/sources/coin.move (L726-738)
```text
    public entry fun migrate_coin_store_to_fungible_store<CoinType>(
        accounts: vector<address>
    ) acquires CoinStore, CoinConversionMap, CoinInfo {
        if (features::new_accounts_default_to_fa_store_enabled()
            || features::new_accounts_default_to_fa_apt_store_enabled()) {
            std::vector::for_each(
                accounts,
                |account| {
                    maybe_convert_to_fungible_store<CoinType>(account);
                }
            );
        }
    }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L945-1016)
```rust
    fn validate_and_execute_entry_function(
        &self,
        module_storage: &impl AptosModuleStorage,
        session: &mut SessionExt<impl AptosMoveResolver>,
        serialized_signers: &SerializedSigners,
        gas_meter: &mut impl AptosGasMeter,
        traversal_context: &mut TraversalContext,
        entry_fn: &EntryFunction,
        trace_recorder: &mut impl TraceRecorder,
    ) -> Result<(), VMStatus> {
        dispatch_loader!(module_storage, loader, {
            let legacy_loader_config = LegacyLoaderConfig {
                charge_for_dependencies: self.gas_feature_version() >= RELEASE_V1_10,
                charge_for_ty_tag_dependencies: self.gas_feature_version() >= RELEASE_V1_27,
            };
            let function = loader.load_instantiated_function(
                &legacy_loader_config,
                gas_meter,
                traversal_context,
                entry_fn.module(),
                entry_fn.function(),
                entry_fn.ty_args(),
            )?;

            // Native entry function is forbidden.
            if function.is_native() {
                return Err(
                    PartialVMError::new(StatusCode::USER_DEFINED_NATIVE_NOT_ALLOWED)
                        .with_message(
                            "Executing user defined native entry function is not allowed"
                                .to_string(),
                        )
                        .finish(Location::Module(entry_fn.module().clone()))
                        .into_vm_status(),
                );
            }

            // The check below should have been feature-gated in 1.11...
            if function.is_friend_or_private() {
                let maybe_randomness_annotation = get_randomness_annotation_for_entry_function(
                    entry_fn,
                    &function.owner_as_module()?.metadata,
                );
                if maybe_randomness_annotation.is_some() {
                    session.mark_unbiasable();
                }
            }

            let args = dispatch_transaction_arg_validation!(
                session,
                &loader,
                gas_meter,
                traversal_context,
                serialized_signers,
                entry_fn.args().to_vec(),
                &function,
                self.features().is_enabled(FeatureFlag::STRUCT_CONSTRUCTORS),
            )?;

            // Execute the function. The function also must be an entry function!
            function.is_entry_or_err()?;
            session.execute_loaded_function(
                function,
                args,
                gas_meter,
                traversal_context,
                &loader,
                trace_recorder,
            )?;
            Ok(())
        })
    }
```

**File:** third_party/move/move-vm/runtime/src/loader/function.rs (L552-561)
```rust
    pub fn is_entry_or_err(&self) -> VMResult<()> {
        if !self.function.is_entry() {
            let module_id = self.owner_as_module()?.self_id().clone();
            let err = PartialVMError::new(
                StatusCode::EXECUTE_ENTRY_FUNCTION_CALLED_ON_NON_ENTRY_FUNCTION,
            );
            return Err(err.finish(Location::Module(module_id)));
        }
        Ok(())
    }
```

**File:** aptos-move/aptos-vm/src/verifier/transaction_arg_validation.rs (L108-192)
```rust
pub(crate) fn validate_combine_signer_and_txn_args(
    session: &mut SessionExt<impl AptosMoveResolver>,
    loader: &impl Loader,
    gas_meter: &mut impl GasMeter,
    traversal_context: &mut TraversalContext,
    serialized_signers: &SerializedSigners,
    args: Vec<Vec<u8>>,
    func: &LoadedFunction,
    are_struct_constructors_enabled: bool,
) -> Result<Vec<Vec<u8>>, VMStatus> {
    let _timer = VM_TIMER.timer_with_label("AptosVM::validate_combine_signer_and_txn_args");

    // Entry function should not return.
    if !func.return_tys().is_empty() {
        return Err(VMStatus::error(
            StatusCode::INVALID_MAIN_FUNCTION_SIGNATURE,
            None,
        ));
    }
    let mut signer_param_cnt = 0;
    // find all signer params at the beginning
    for ty in func.param_tys() {
        if ty.is_signer_or_signer_ref() {
            signer_param_cnt += 1;
        }
    }

    let allowed_structs = get_allowed_structs(are_struct_constructors_enabled);
    let ty_builder = &loader.runtime_environment().vm_config().ty_builder;

    // Need to keep this here to ensure we return the historic correct error code for replay
    for ty in func.param_tys()[signer_param_cnt..].iter() {
        let subst_res = ty_builder.create_ty_with_subst(ty, func.ty_args());
        let ty = subst_res.map_err(|e| e.finish(Location::Undefined).into_vm_status())?;
        let valid = is_valid_txn_arg(loader.runtime_environment(), &ty, allowed_structs);
        if !valid {
            return Err(VMStatus::error(
                StatusCode::INVALID_MAIN_FUNCTION_SIGNATURE,
                None,
            ));
        }
    }

    if (signer_param_cnt + args.len()) != func.param_tys().len() {
        return Err(VMStatus::error(
            StatusCode::NUMBER_OF_ARGUMENTS_MISMATCH,
            None,
        ));
    }

    // If the invoked function expects one or more signers, we need to check that the number of
    // signers actually passed is matching first to maintain backward compatibility before
    // moving on to the validation of non-signer args.
    // the number of txn senders should be the same number of signers
    let sender_signers = serialized_signers.senders();
    if signer_param_cnt > 0 && sender_signers.len() != signer_param_cnt {
        return Err(VMStatus::error(
            StatusCode::NUMBER_OF_SIGNER_ARGUMENTS_MISMATCH,
            None,
        ));
    }

    // This also validates that the args are valid. If they are structs, they have to be allowed
    // and must be constructed successfully. If construction fails, this would fail with a
    // FAILED_TO_DESERIALIZE_ARGUMENT error.
    let args = construct_args(
        session,
        loader,
        gas_meter,
        traversal_context,
        &func.param_tys()[signer_param_cnt..],
        args,
        func.ty_args(),
        allowed_structs,
        false,
    )?;

    // Combine signer and non-signer arguments.
    let combined_args = if signer_param_cnt == 0 {
        args
    } else {
        sender_signers.into_iter().chain(args).collect()
    };
    Ok(combined_args)
}
```

**File:** aptos-move/framework/move-stdlib/sources/configs/features.move (L673-681)
```text
    /// Whether new accounts default to the Fungible Asset store.
    /// Lifetime: transient
    const NEW_ACCOUNTS_DEFAULT_TO_FA_STORE: u64 = 90;

    public fun get_new_accounts_default_to_fa_store_feature(): u64 { NEW_ACCOUNTS_DEFAULT_TO_FA_STORE }

    public fun new_accounts_default_to_fa_store_enabled(): bool acquires Features {
        is_enabled(NEW_ACCOUNTS_DEFAULT_TO_FA_STORE)
    }
```

**File:** types/src/transaction/script.rs (L118-130)
```rust
    pub fn new(
        module: ModuleId,
        function: Identifier,
        ty_args: Vec<TypeTag>,
        args: Vec<Vec<u8>>,
    ) -> Self {
        EntryFunction {
            module,
            function,
            ty_args,
            args,
        }
    }
```
