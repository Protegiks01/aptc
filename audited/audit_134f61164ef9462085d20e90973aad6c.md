# Audit Report

## Title
Randomness State Persistence Enables Unauthorized Access in Module Initialization Functions

## Summary
The `mark_unbiasable()` function sets a session-wide randomness permission flag that persists across module publishing operations, allowing `init_module` functions to access randomness APIs without the required `#[randomness]` annotation. This breaks the fundamental unbiasability guarantee of Aptos randomness.

## Finding Description

The Aptos randomness system requires entry functions to have a `#[randomness]` attribute to access randomness APIs. However, a critical flaw exists in how randomness permissions persist across session operations.

**Attack Flow:**

1. An attacker creates an entry function with `#[randomness]` annotation that calls `code::publish_package_txn()` to publish a new module

2. During transaction execution, when the entry function has the randomness annotation, `mark_unbiasable()` is called on the session, setting `RandomnessContext.unbiasable = true`: [1](#0-0) [2](#0-1) 

3. The entry function executes and registers a module publish request. After execution, the publish request is extracted and processed in the same session: [3](#0-2) 

4. Module publishing is resolved and `init_module` functions are executed **in the same session** using the existing session without creating a new one: [4](#0-3) [5](#0-4) 

5. The `init_module` function can call randomness APIs (e.g., `randomness::u64_integer()`) because the `is_unbiasable()` check passes - the flag remains `true` throughout: [6](#0-5) 

6. The native `is_unbiasable()` function returns `true` because the flag is still set from the parent entry function: [7](#0-6) 

**Security Invariant Broken:**

The randomness system guarantees that only functions explicitly marked with `#[randomness]` can access randomness APIs. While the `SessionListener::start()` method would reset the flag to `false`, it is never called during this flow: [8](#0-7) 

The `init_module` function has strict validation requirements, but there is no check preventing randomness usage: [9](#0-8) 

## Impact Explanation

**Severity: High**

This vulnerability constitutes a **significant protocol violation** qualifying for High severity ($50,000) under the Aptos bug bounty program because:

1. **Security Guarantee Bypass**: The `#[randomness]` annotation system is a critical security mechanism documented in the codebase. Bypassing it violates the documented randomness safety model.

2. **Unbiasability Violation**: Module initialization is intended to be deterministic setup code. Allowing randomness access enables biasable operations where `init_module` can test random values and abort if unfavorable, creating unfair initial conditions.

3. **Wide Attack Surface**: Any user capable of publishing modules can exploit this vulnerability - no special privileges required.

4. **Protocol-Level Impact**: This breaks a fundamental security invariant of the randomness system, affecting all applications that rely on unbiasable randomness.

## Likelihood Explanation

**Likelihood: High**

This vulnerability is highly likely to be exploited because:

1. **Easy Discovery**: Any developer experimenting with randomness in module publishing would discover this behavior.

2. **No Special Requirements**: Only requires ability to publish modules (available to any user with sufficient gas) and create an entry function with `#[randomness]` annotation.

3. **Clear Incentive**: Module publishers could gain unfair advantages in games, lotteries, NFT mints, or other randomness-dependent applications by biasing initialization.

4. **No Detection**: The transaction appears completely valid and passes all existing validation checks, making exploitation undetectable.

## Recommendation

The fix should ensure that `init_module` functions cannot inherit randomness permissions from their publishing transaction. Recommended approaches:

1. **Reset randomness context before init_module execution**: Call `SessionListener::start()` on all extensions before executing `init_module`, or explicitly reset the `unbiasable` flag.

2. **Add explicit validation**: In `verify_init_module_function()`, add a check that prevents `init_module` from calling randomness APIs by analyzing the function bytecode.

3. **Create isolated session**: Execute `init_module` in a new session that does not inherit the randomness permission from the parent transaction.

## Proof of Concept

```move
// Attacker's module with malicious init_module
module attacker::exploit {
    use aptos_framework::randomness;
    
    // This init_module will be able to call randomness APIs
    // when published from an entry function with #[randomness]
    fun init_module(deployer: &signer) {
        // This should fail but doesn't due to inherited permission
        let random_val = randomness::u64_integer();
        
        // Attacker can abort if value is unfavorable
        assert!(random_val > 1000000, 1);
        
        // Only proceed with initialization if random value is favorable
        // ... rest of initialization ...
    }
}

// Attacker's publishing entry function
module attacker::publisher {
    use aptos_framework::code;
    
    #[randomness]  // This grants randomness permission to the session
    public entry fun publish_with_randomness(
        deployer: &signer,
        metadata: vector<u8>,
        code: vector<vector<u8>>
    ) {
        // Publish the exploit module
        // The init_module will inherit the randomness permission
        code::publish_package_txn(deployer, metadata, code);
    }
}
```

The attacker calls `publisher::publish_with_randomness` which has `#[randomness]` annotation, causing the session's `unbiasable` flag to be set to `true`. When the module is published, the `exploit::init_module` executes in the same session and can successfully call `randomness::u64_integer()`, enabling biasable behavior through test-and-abort patterns.

## Notes

This vulnerability demonstrates a state management flaw where session-level permissions persist incorrectly across different execution contexts. The core issue is that `init_module` execution was not designed to be isolated from the permissions of the publishing transaction, creating an unintended privilege inheritance path that bypasses the randomness annotation security mechanism.

### Citations

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L984-990)
```rust
                let maybe_randomness_annotation = get_randomness_annotation_for_entry_function(
                    entry_fn,
                    &function.owner_as_module()?.metadata,
                );
                if maybe_randomness_annotation.is_some() {
                    session.mark_unbiasable();
                }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1464-1473)
```rust
    fn resolve_pending_code_publish_and_finish_user_session(
        &self,
        mut session: UserSession,
        resolver: &impl AptosMoveResolver,
        module_storage: &impl AptosModuleStorage,
        gas_meter: &mut impl AptosGasMeter,
        traversal_context: &mut TraversalContext,
        change_set_configs: &ChangeSetConfigs,
    ) -> Result<UserSessionChangeSet, VMStatus> {
        let maybe_publish_request = session.execute(|session| session.extract_publish_request());
```

**File:** aptos-move/framework/src/natives/randomness.rs (L32-36)
```rust
impl SessionListener for RandomnessContext {
    fn start(&mut self, _session_hash: &[u8; 32], _script_hash: &[u8], _session_counter: u8) {
        self.txn_local_state = vec![0; 8];
        self.unbiasable = false;
    }
```

**File:** aptos-move/framework/src/natives/randomness.rs (L70-72)
```rust
    pub fn mark_unbiasable(&mut self) {
        self.unbiasable = true;
    }
```

**File:** aptos-move/framework/src/natives/randomness.rs (L79-97)
```rust
pub fn fetch_and_increment_txn_counter(
    context: &mut SafeNativeContext,
    _ty_args: &[Type],
    _args: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    if context.gas_feature_version() >= RELEASE_V1_23 {
        context.charge(RANDOMNESS_FETCH_AND_INC_COUNTER)?;
    }

    let ctx = context.extensions_mut().get_mut::<RandomnessContext>();
    if !ctx.is_unbiasable() {
        return Err(SafeNativeError::Abort {
            abort_code: E_API_USE_SUSCEPTIBLE_TO_TEST_AND_ABORT,
        });
    }

    let ret = ctx.txn_local_state.to_vec();
    ctx.increment();
    Ok(smallvec![Value::vector_u8(ret)])
```

**File:** aptos-move/framework/src/natives/randomness.rs (L100-115)
```rust
pub fn is_unbiasable(
    context: &mut SafeNativeContext,
    _ty_args: &[Type],
    _args: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    // Because we need to run a special transaction prologue to pre-charge maximum
    // amount of gas, we require all callers to have an annotation that the entry
    // function call is unbiasable. This property is only checked at runtime here.
    let is_unbiasable = context
        .extensions()
        .get::<RandomnessContext>()
        .is_unbiasable();

    // TODO: charge gas?
    Ok(smallvec![Value::bool(is_unbiasable)])
}
```

**File:** aptos-move/aptos-vm/src/move_vm_ext/session/user_transaction_sessions/user.rs (L122-147)
```rust
            self.session.execute(|session| {
                dispatch_loader!(&staging_module_storage, loader, {
                    #[allow(clippy::collapsible_else_if)]
                    if gas_feature_version <= RELEASE_V1_30 {
                        if let Ok(init_func) = loader.load_instantiated_function(
                            &LegacyLoaderConfig::unmetered(),
                            gas_meter,
                            traversal_context,
                            &module.self_id(),
                            init_func_name,
                            &[],
                        ) {
                            // We need to check that init_module function we found is well-formed.
                            verifier::module_init::legacy_verify_module_init_function(module)
                                .map_err(|e| e.finish(Location::Undefined))?;

                            session.execute_loaded_function(
                                init_func,
                                vec![MoveValue::Signer(destination).simple_serialize().unwrap()],
                                gas_meter,
                                traversal_context,
                                &loader,
                                // We should never enable trace record for init_module - it runs on
                                // newly published state so it is safer to do checks in-place.
                                &mut NoOpTraceRecorder,
                            )?;
```

**File:** aptos-move/aptos-vm/src/move_vm_ext/session/respawned_session.rs (L61-69)
```rust
    pub fn execute<T>(
        &mut self,
        fun: impl FnOnce(&mut SessionExt<StorageAdapter<'_, ExecutorViewWithChangeSet<'_>>>) -> T,
    ) -> T {
        self.with_session_mut(|session| {
            fun(session
                .as_mut()
                .expect("session is set on construction and live until destruction."))
        })
```

**File:** aptos-move/aptos-vm/src/verifier/module_init.rs (L65-104)
```rust
pub(crate) fn verify_init_module_function(function: &Function) -> Result<(), VMStatus> {
    let err = |msg| Err(VMStatus::error(StatusCode::INVALID_INIT_MODULE, Some(msg)));

    if !function.is_private() {
        return err("init_module function must be private, but it is not".to_string());
    }

    if !function.return_tys().is_empty() {
        return err(format!(
            "init_module function must return 0 values, but returns {}",
            function.return_tys().len()
        ));
    }

    let param_tys = function.param_tys();
    if param_tys.len() != 1 {
        return err(format!(
            "init_module function should have a single signer or &signer parameter, \
             but has {} parameters",
            param_tys.len()
        ));
    }

    let arg_ty = &param_tys[0];
    if !arg_ty.is_signer_or_signer_ref() {
        return err(
            "init_module function expects a single signer or &signer parameter, \
             but its parameter type is different"
                .to_string(),
        );
    }

    if function.ty_params_count() != 0 {
        return err(format!(
            "init_module function expects 0 type parameters, but has {} type parameters",
            function.ty_params_count()
        ));
    }

    Ok(())
```
