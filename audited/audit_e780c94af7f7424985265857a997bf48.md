# Audit Report

## Title
Memory Exhaustion via Oversized NodeInformationResponse Messages in Peer Monitoring Service

## Summary
A malicious peer can send `NodeInformationResponse` messages with extremely large `build_information` maps (up to 4 MiB) that exhaust memory on receiving nodes. The application-level size limit (100 KB) is checked only after BCS deserialization allocates memory, creating a gap that allows memory exhaustion attacks against validators and fullnodes.

## Finding Description
The peer monitoring service requests node information from connected peers at regular intervals (every 15 seconds). When a response is received, the following sequence occurs:

1. The network layer receives the message frame (limited to 4 MiB by network configuration) [1](#0-0) 

2. BCS deserialization occurs at the network layer, allocating memory for the entire structure including the `build_information` BTreeMap [2](#0-1) 

3. The deserialized response is passed to the application layer [3](#0-2) 

4. Only then is `sanity_check_response_size` called to verify the response doesn't exceed 100 KB [4](#0-3) 

The `NodeInformationResponse` struct has an unbounded `build_information` field of type `BTreeMap<String, String>` [5](#0-4) 

An attacker can exploit this by:
- Running a malicious peer node
- Responding to `GetNodeInformation` requests with crafted responses containing:
  - Thousands of key-value pairs in `build_information` (e.g., 10,000 entries)
  - Long strings for keys and values (hundreds of bytes each)
  - Total serialized size approaching 4 MiB (just under the network frame limit)

The BCS recursion limit of 64 does not prevent this attack because it only controls nesting depth, not collection size [6](#0-5) . A flat map with thousands of entries has minimal nesting depth.

The legitimate server creates responses with only ~13 build information keys [7](#0-6) , but there is no validation preventing malicious responses with much larger maps.

## Impact Explanation
This vulnerability qualifies as **High Severity** under the Aptos bug bounty program because it enables "Validator node slowdowns." 

Specific impacts:
- **Memory exhaustion**: Each malicious response consumes up to 4 MiB of memory during deserialization
- **Amplification**: With node info requests every 15 seconds per peer [8](#0-7) , multiple malicious peers can rapidly accumulate memory consumption
- **Validator degradation**: Validators experiencing memory pressure will have degraded performance, potentially affecting consensus participation
- **Network availability**: Fullnodes can be crashed or severely degraded, reducing network availability

The peer monitoring service configuration allows a maximum of 100 KB responses [9](#0-8) , but this limit is enforced post-deserialization, after memory has already been allocated.

## Likelihood Explanation
This attack is **highly likely** to occur because:

1. **Low barrier to entry**: Any peer can send malicious responses; no validator privileges required
2. **Regular polling**: The client automatically requests node information every 15 seconds
3. **No authentication**: Peer responses are not cryptographically authenticated beyond basic network-level peer identity
4. **Simple exploitation**: Crafting an oversized map is trivial
5. **Multiple attack vectors**: Attacker can run multiple malicious peers or compromise existing nodes

The configuration shows that peer monitoring clients are enabled by default [10](#0-9) , meaning all nodes are vulnerable.

## Recommendation
Enforce the size limit **before** deserialization by checking the raw message size at the network protocol level. Implement one or both of these fixes:

**Option 1: Pre-deserialization size check** - Add validation in the network message handler before BCS deserialization:
```rust
// In network/framework/src/protocols/wire/messaging/v1/mod.rs
// Before calling bcs::from_bytes, check raw frame size against protocol-specific limits
```

**Option 2: Protocol-specific frame limits** - Set a smaller max_frame_size for peer monitoring service RPC protocol to match the application's 100 KB expectation, rather than using the global 4 MiB limit.

**Option 3: BCS byte limit** - If the BCS library supports it, use a byte-count limit in addition to the recursion limit during deserialization.

The fix should also add validation on the server side to prevent legitimate nodes from accidentally creating oversized responses.

## Proof of Concept
```rust
// Malicious peer monitoring server that responds with oversized NodeInformationResponse
use aptos_peer_monitoring_service_types::response::NodeInformationResponse;
use std::collections::BTreeMap;
use std::time::Duration;

fn create_malicious_response() -> NodeInformationResponse {
    let mut build_information = BTreeMap::new();
    
    // Create 10,000 key-value pairs with 200-byte strings each
    // Total size: ~4 MB (within 4 MiB network frame limit, exceeds 100 KB app limit)
    for i in 0..10_000 {
        let key = format!("malicious_key_{:0>190}", i); // 200 bytes
        let value = format!("malicious_value_{:0>185}", i); // 200 bytes
        build_information.insert(key, value);
    }
    
    NodeInformationResponse {
        build_information,
        highest_synced_epoch: 1000,
        highest_synced_version: 1000000,
        ledger_timestamp_usecs: 1234567890,
        lowest_available_version: 0,
        uptime: Duration::from_secs(3600),
    }
}

#[test]
fn test_oversized_response_memory_consumption() {
    let malicious_response = create_malicious_response();
    
    // Serialize to verify it fits within network frame limit (4 MiB)
    let serialized = bcs::to_bytes(&malicious_response).unwrap();
    assert!(serialized.len() < 4 * 1024 * 1024); // Under 4 MiB
    assert!(serialized.len() > 100 * 1024); // Over 100 KB
    
    // This response would be accepted by network layer and deserialized
    // consuming ~4 MB of memory before being rejected by sanity_check_response_size
    println!("Malicious response size: {} bytes", serialized.len());
    println!("Memory allocated during deserialization: ~{} MB", serialized.len() / (1024 * 1024));
}
```

**Notes:**
The vulnerability exists due to a defense-in-depth failure where:
1. The network layer enforces a 4 MiB frame size limit (appropriate for large consensus messages)
2. The peer monitoring service expects 100 KB responses but checks this limit post-deserialization
3. BCS deserialization's recursion limit doesn't constrain flat collection sizes
4. No per-protocol frame size customization prevents oversized peer monitoring messages

This creates a 40x gap (4 MiB network limit vs 100 KB application limit) that attackers can exploit to exhaust memory on victim nodes.

### Citations

**File:** config/src/config/network_config.rs (L49-50)
```rust
pub const MAX_FRAME_SIZE: usize = 4 * 1024 * 1024; /* 4 MiB large messages will be chunked into multiple frames and streamed */
pub const MAX_MESSAGE_SIZE: usize = 64 * 1024 * 1024; /* 64 MiB */
```

**File:** network/framework/src/protocols/wire/messaging/v1/mod.rs (L225-241)
```rust
    fn poll_next(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<Self::Item>> {
        match self.project().framed_read.poll_next(cx) {
            Poll::Ready(Some(Ok(frame))) => {
                let frame = frame.freeze();

                match bcs::from_bytes(&frame) {
                    Ok(message) => Poll::Ready(Some(Ok(message))),
                    // Failed to deserialize the NetworkMessage
                    Err(err) => {
                        let mut frame = frame;
                        let frame_len = frame.len();
                        // Keep a few bytes from the frame for debugging
                        frame.truncate(8);
                        let err = ReadError::DeserializeError(err, frame_len, frame);
                        Poll::Ready(Some(Err(err)))
                    },
                }
```

**File:** peer-monitoring-service/client/src/peer_states/peer_state.rs (L124-132)
```rust
            let monitoring_service_response = match monitoring_service_response {
                Ok(monitoring_service_response) => monitoring_service_response,
                Err(error) => {
                    peer_state_value
                        .write()
                        .handle_monitoring_service_response_error(&peer_network_id, error);
                    return;
                },
            };
```

**File:** peer-monitoring-service/client/src/peer_states/peer_state.rs (L135-142)
```rust
            if let Err(error) =
                sanity_check_response_size(max_num_response_bytes, &monitoring_service_response)
            {
                peer_state_value
                    .write()
                    .handle_monitoring_service_response_error(&peer_network_id, error);
                return;
            }
```

**File:** peer-monitoring-service/types/src/response.rs (L94-102)
```rust
#[derive(Clone, Debug, Default, Deserialize, Eq, PartialEq, Serialize)]
pub struct NodeInformationResponse {
    pub build_information: BTreeMap<String, String>, // The build information of the node
    pub highest_synced_epoch: u64,                   // The highest synced epoch of the node
    pub highest_synced_version: u64,                 // The highest synced version of the node
    pub ledger_timestamp_usecs: u64, // The latest timestamp of the blockchain (in microseconds)
    pub lowest_available_version: u64, // The lowest stored version of the node (in storage)
    pub uptime: Duration,            // The amount of time the peer has been running
}
```

**File:** network/framework/src/protocols/wire/handshake/v1/mod.rs (L39-39)
```rust
pub const RECURSION_LIMIT: usize = 64;
```

**File:** crates/aptos-build-info/src/lib.rs (L59-104)
```rust
pub fn get_build_information() -> BTreeMap<String, String> {
    shadow!(build);

    let mut build_information = BTreeMap::new();

    // Get Git metadata from shadow_rs crate.
    // This is applicable for native builds where the cargo has
    // access to the .git directory.
    build_information.insert(BUILD_BRANCH.into(), build::BRANCH.into());
    build_information.insert(BUILD_CARGO_VERSION.into(), build::CARGO_VERSION.into());
    build_information.insert(BUILD_CLEAN_CHECKOUT.into(), build::GIT_CLEAN.to_string());
    build_information.insert(BUILD_COMMIT_HASH.into(), build::COMMIT_HASH.into());
    build_information.insert(BUILD_TAG.into(), build::TAG.into());
    build_information.insert(BUILD_TIME.into(), build::BUILD_TIME.into());
    build_information.insert(BUILD_OS.into(), build::BUILD_OS.into());
    build_information.insert(BUILD_RUST_CHANNEL.into(), build::RUST_CHANNEL.into());
    build_information.insert(BUILD_RUST_VERSION.into(), build::RUST_VERSION.into());

    // Compilation information
    build_information.insert(BUILD_IS_RELEASE_BUILD.into(), is_release().to_string());
    build_information.insert(BUILD_PROFILE_NAME.into(), get_build_profile_name());
    build_information.insert(
        BUILD_USING_TOKIO_UNSTABLE.into(),
        std::env!("USING_TOKIO_UNSTABLE").to_string(),
    );

    // Get Git metadata from environment variables set during build-time.
    // This is applicable for docker based builds  where the cargo cannot
    // access the .git directory, or to override shadow_rs provided info.
    if let Ok(git_sha) = std::env::var("GIT_SHA") {
        build_information.insert(BUILD_COMMIT_HASH.into(), git_sha);
    }

    if let Ok(git_branch) = std::env::var("GIT_BRANCH") {
        build_information.insert(BUILD_BRANCH.into(), git_branch);
    }

    if let Ok(git_tag) = std::env::var("GIT_TAG") {
        build_information.insert(BUILD_TAG.into(), git_tag);
    }

    if let Ok(build_date) = std::env::var("BUILD_DATE") {
        build_information.insert(BUILD_TIME.into(), build_date);
    }

    build_information
```

**File:** config/src/config/peer_monitoring_config.rs (L24-24)
```rust
            enable_peer_monitoring_client: true,
```

**File:** config/src/config/peer_monitoring_config.rs (L28-28)
```rust
            max_num_response_bytes: 100 * 1024, // 100 KB
```

**File:** config/src/config/peer_monitoring_config.rs (L84-84)
```rust
            node_info_request_interval_ms: 15_000, // 15 seconds
```
