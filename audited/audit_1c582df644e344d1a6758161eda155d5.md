# Audit Report

## Title
Unvalidated QuorumStoreBackPressureConfig Enables Validator DoS via Inverted Backpressure Control

## Summary
The `sanitize()` function in `quorum_store_config.rs` fails to validate `QuorumStoreBackPressureConfig` fields, allowing invalid values such as `decrease_fraction > 1.0` to cause inverted backpressure behavior that degrades validator performance under load, and arithmetic overflow values that crash validator nodes. [1](#0-0) 

## Finding Description

The `QuorumStoreConfig::sanitize()` function validates send/recv batch limits and batch/total limits, but completely omits validation of the `back_pressure` field containing `QuorumStoreBackPressureConfig`. [2](#0-1) 

This configuration controls the Additive Increase Multiplicative Decrease (AIMD) algorithm used by the BatchGenerator to dynamically adjust transaction pulling rates under backpressure. Invalid values break this critical congestion control mechanism:

**Vulnerability 1: Inverted Backpressure (decrease_fraction > 1.0)**

When backpressure is detected, the BatchGenerator performs multiplicative decrease: [3](#0-2) 

If `decrease_fraction` is set to a value > 1.0 (e.g., 2.0), the multiplication INCREASES the pull rate instead of decreasing it. This creates a positive feedback loop where the validator pulls MORE transactions when overloaded, exacerbating congestion and causing severe performance degradation.

**Vulnerability 2: Integer Overflow Panic**

When ProofManager is instantiated, it multiplies the config value by the number of validators: [4](#0-3) 

With Aptos' release profile setting `overflow-checks = true`: [5](#0-4) 

If `backlog_per_validator_batch_limit_count` is set to a large value (e.g., `u64::MAX / 100`) and the validator set has 100+ validators, the multiplication overflows and **panics the entire validator node**.

**Vulnerability 3: Invalid Floating Point Values**

If `decrease_fraction` is set to `NaN`, `Infinity`, or negative values, the cast to `u64` produces 0, causing the rate to immediately drop to `dynamic_min_txn_per_s` regardless of actual load conditions.

## Impact Explanation

Per Aptos bug bounty criteria:

**High Severity (up to $50,000):**
- **Validator node slowdowns**: Inverted backpressure (decrease_fraction > 1.0) causes validators to pull excessive transactions under load, severely degrading performance
- **Validator node crashes**: Integer overflow in multiplication causes immediate panic, taking the validator offline

Both scenarios directly impact consensus liveness. If multiple validators misconfigure their nodes, network throughput degrades significantly or validators drop out of consensus entirely.

## Likelihood Explanation

**Likelihood: Medium-High**

- Configuration files are manually edited by node operators
- No validation occurs at startup - invalid values are silently accepted
- The sanitize function validates similar fields but omits backpressure config, creating false confidence
- Default values are safe (decrease_fraction = 0.5), but overrides are common for performance tuning
- Testnet/development environments may experiment with extreme values
- Once deployed, the bug manifests immediately under load, making it difficult to debug

## Recommendation

Add comprehensive validation to the `sanitize()` function:

```rust
fn sanitize_backpressure_config(
    sanitizer_name: &str,
    config: &QuorumStoreBackPressureConfig,
) -> Result<(), Error> {
    // Validate decrease_fraction is in valid range (0.0, 1.0]
    if config.decrease_fraction <= 0.0 || config.decrease_fraction > 1.0 
        || !config.decrease_fraction.is_finite() {
        return Err(Error::ConfigSanitizerFailed(
            sanitizer_name.to_owned(),
            format!("decrease_fraction must be in (0.0, 1.0], got {}", config.decrease_fraction),
        ));
    }
    
    // Validate min <= max
    if config.dynamic_min_txn_per_s > config.dynamic_max_txn_per_s {
        return Err(Error::ConfigSanitizerFailed(
            sanitizer_name.to_owned(),
            format!("dynamic_min_txn_per_s ({}) must be <= dynamic_max_txn_per_s ({})",
                config.dynamic_min_txn_per_s, config.dynamic_max_txn_per_s),
        ));
    }
    
    // Validate durations are reasonable
    if config.decrease_duration_ms == 0 || config.increase_duration_ms == 0 {
        return Err(Error::ConfigSanitizerFailed(
            sanitizer_name.to_owned(),
            "duration_ms values must be > 0".to_string(),
        ));
    }
    
    // Validate no overflow in multiplication (max validators is 65536)
    const MAX_VALIDATORS: u64 = 65536;
    if let None = config.backlog_per_validator_batch_limit_count.checked_mul(MAX_VALIDATORS) {
        return Err(Error::ConfigSanitizerFailed(
            sanitizer_name.to_owned(),
            format!("backlog_per_validator_batch_limit_count too large: {}", 
                config.backlog_per_validator_batch_limit_count),
        ));
    }
    
    Ok(())
}
```

Then call this in the main sanitize function: [1](#0-0) 

Add before line 270:
```rust
Self::sanitize_backpressure_config(&sanitizer_name, &node_config.consensus.quorum_store.back_pressure)?;
```

## Proof of Concept

**Test Case 1: Inverted Backpressure**

```rust
#[test]
fn test_invalid_decrease_fraction_above_one() {
    let node_config = NodeConfig {
        consensus: ConsensusConfig {
            quorum_store: QuorumStoreConfig {
                back_pressure: QuorumStoreBackPressureConfig {
                    decrease_fraction: 2.0, // Should decrease but will increase!
                    ..Default::default()
                },
                ..Default::default()
            },
            ..Default::default()
        },
        ..Default::default()
    };
    
    // This should fail but currently passes
    let result = QuorumStoreConfig::sanitize(&node_config, NodeType::Validator, None);
    assert!(result.is_err(), "Should reject decrease_fraction > 1.0");
}
```

**Test Case 2: Integer Overflow**

```rust
#[test]
fn test_backlog_per_validator_overflow() {
    let node_config = NodeConfig {
        consensus: ConsensusConfig {
            quorum_store: QuorumStoreConfig {
                back_pressure: QuorumStoreBackPressureConfig {
                    backlog_per_validator_batch_limit_count: u64::MAX / 10, // Will overflow with 100+ validators
                    ..Default::default()
                },
                ..Default::default()
            },
            ..Default::default()
        },
        ..Default::default()
    };
    
    // This should fail but currently passes
    let result = QuorumStoreConfig::sanitize(&node_config, NodeType::Validator, None);
    assert!(result.is_err(), "Should reject values that overflow in multiplication");
}
```

**Test Case 3: Invalid Float Values**

```rust
#[test]
fn test_invalid_decrease_fraction_nan() {
    let node_config = NodeConfig {
        consensus: ConsensusConfig {
            quorum_store: QuorumStoreConfig {
                back_pressure: QuorumStoreBackPressureConfig {
                    decrease_fraction: f64::NAN,
                    ..Default::default()
                },
                ..Default::default()
            },
            ..Default::default()
        },
        ..Default::default()
    };
    
    let result = QuorumStoreConfig::sanitize(&node_config, NodeType::Validator, None);
    assert!(result.is_err(), "Should reject NaN values");
}
```

## Notes

- The sanitize function's selective validation creates a false sense of security - operators may assume all invalid configs are caught
- The Aptos codebase's coding guidelines explicitly require checked arithmetic, but the multiplication on line 371 uses direct operators
- The vulnerability affects consensus liveness but not safety (no double-spend or fork risk)
- Defense in depth principle: even if operators are trusted, the system should validate inputs to prevent accidents

### Citations

**File:** config/src/config/quorum_store_config.rs (L18-27)
```rust
pub struct QuorumStoreBackPressureConfig {
    pub backlog_txn_limit_count: u64,
    pub backlog_per_validator_batch_limit_count: u64,
    pub decrease_duration_ms: u64,
    pub increase_duration_ms: u64,
    pub decrease_fraction: f64,
    pub dynamic_min_txn_per_s: u64,
    pub dynamic_max_txn_per_s: u64,
    pub additive_increase_when_no_backpressure: u64,
}
```

**File:** config/src/config/quorum_store_config.rs (L254-271)
```rust
    fn sanitize(
        node_config: &NodeConfig,
        _node_type: NodeType,
        _chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();

        // Sanitize the send/recv batch limits
        Self::sanitize_send_recv_batch_limits(
            &sanitizer_name,
            &node_config.consensus.quorum_store,
        )?;

        // Sanitize the batch total limits
        Self::sanitize_batch_total_limits(&sanitizer_name, &node_config.consensus.quorum_store)?;

        Ok(())
    }
```

**File:** consensus/src/quorum_store/batch_generator.rs (L434-443)
```rust
                    if self.back_pressure.txn_count {
                        // multiplicative decrease, every second
                        if back_pressure_decrease_latest.elapsed() >= back_pressure_decrease_duration {
                            back_pressure_decrease_latest = tick_start;
                            dynamic_pull_txn_per_s = std::cmp::max(
                                (dynamic_pull_txn_per_s as f64 * self.config.back_pressure.decrease_fraction) as u64,
                                self.config.back_pressure.dynamic_min_txn_per_s,
                            );
                            trace!("QS: dynamic_max_pull_txn_per_s: {}", dynamic_pull_txn_per_s);
                        }
```

**File:** consensus/src/quorum_store/quorum_store_builder.rs (L365-371)
```rust
        let proof_manager = ProofManager::new(
            self.author,
            self.config.back_pressure.backlog_txn_limit_count,
            self.config
                .back_pressure
                .backlog_per_validator_batch_limit_count
                * self.num_validators,
```

**File:** Cargo.toml (L921-923)
```text
[profile.release]
debug = true
overflow-checks = true
```
