# Audit Report

## Title
Transaction Pruner Silently Skips Missing Versions, Leading to Orphaned Index Accumulation

## Summary
The `get_pruning_candidate_transactions()` function in the transaction pruner fails to detect and error on missing transaction versions. When seeking to a start version that doesn't exist, the iterator silently positions at the next available version or returns empty results, causing the pruner to skip versions without cleaning up their associated indices. This leads to permanent orphaned index entries and incorrect pruner progress metadata.

## Finding Description

The vulnerability lies in how `get_pruning_candidate_transactions()` handles missing transaction versions: [1](#0-0) 

The critical issue is at line 117 where `iter.seek(&start)?` is called. The `seek()` operation never returns an error when a key is not found - it always returns `Ok(())`: [2](#0-1) 

When the start version doesn't exist in the database:
1. RocksDB's `seek()` positions the iterator at the first key ≥ start, or marks it invalid if no such key exists
2. The pruner silently proceeds with whatever transactions it finds
3. The loop collects only the transactions that exist (skipping the gap)
4. Orphaned indices remain because they depend on the candidate transaction list

**Critical Contrast with Normal Transaction Reading:**

The codebase explicitly expects continuous versions elsewhere using `ExpectContinuousVersions`: [3](#0-2) 

This iterator checks for gaps at line 47-54 and errors if `version != expected_next_version`. However, the pruner does NOT use this safeguard. [4](#0-3) 

**Attack Scenario:**

If versions 100-105 are missing from `TransactionSchema` (due to database corruption, incomplete restore, or a bug elsewhere):

1. Pruner calls `get_pruning_candidate_transactions(100, 200)`
2. `seek(100)` positions iterator at version 106 (first version ≥ 100)
3. Returns transactions 106-199 (versions 100-105 SKIPPED)
4. `prune_transaction_by_hash_indices()` only deletes indices for 106-199 [5](#0-4) 

5. `prune_transactions(100, 200)` tries to delete all versions 100-199 [6](#0-5) 

6. `prune_transaction_summaries_by_account()` only processes 106-199 [7](#0-6) 

7. Progress metadata updated to 200 [8](#0-7) 

**Result:** Indices for versions 100-105 remain orphaned in `TransactionByHashSchema` and `TransactionSummariesByAccountSchema`, but progress metadata indicates they were pruned.

## Impact Explanation

This qualifies as **High Severity** under Aptos bug bounty criteria:

**Primary Impact - Storage Exhaustion & Node Degradation:**
- Orphaned indices accumulate indefinitely since progress metadata prevents re-processing
- Each orphaned transaction retains hash indices and account summary indices
- Over time with repeated gaps, storage bloat degrades validator performance
- Falls under "Validator node slowdowns" (High Severity)

**Secondary Impact - State Inconsistency:**
- Database queries may return results for non-existent transactions
- Index-to-transaction references become invalid
- Could cause unexpected behavior in APIs and internal queries
- Falls under "Significant protocol violations" (High Severity)

**Defense-in-Depth Violation:**
- The code silently hides evidence of database corruption or gaps
- Makes diagnosis of underlying issues extremely difficult
- Violates the principle of failing fast on data integrity issues

## Likelihood Explanation

**Likelihood: MEDIUM to LOW**

The vulnerability requires pre-existing version gaps, which can occur through:

1. **Database Corruption** (MEDIUM likelihood):
   - Hardware failures, disk corruption
   - Incomplete database restore operations
   - File system errors

2. **Bugs in Other Components** (LOW-MEDIUM likelihood):
   - Race conditions in transaction writing (though atomic writes should prevent this)
   - State sync bugs creating gaps
   - Epoch transition edge cases

3. **Manual Intervention** (LOW likelihood for attackers):
   - Requires privileged database access
   - Not achievable by unprivileged attackers

**Mitigation:** While atomic writes prevent this in normal operation: [9](#0-8) 

The lack of defensive validation means ANY scenario creating gaps will be silently masked.

## Recommendation

**Immediate Fix:** Add explicit gap detection in `get_pruning_candidate_transactions()`:

```rust
fn get_pruning_candidate_transactions(
    &self,
    start: Version,
    end: Version,
) -> Result<Vec<(Version, Transaction)>> {
    ensure!(end >= start, "{} must be >= {}", end, start);

    let mut iter = self
        .ledger_db
        .transaction_db_raw()
        .iter::<TransactionSchema>()?;
    iter.seek(&start)?;

    let mut txns = Vec::with_capacity((end - start) as usize);
    let mut expected_version = start;
    
    for item in iter {
        let (version, txn) = item?;
        if version >= end {
            break;
        }
        
        // CRITICAL: Detect version gaps
        ensure!(
            version == expected_version,
            "Transaction version gap detected during pruning: expected {}, got {}. \
             Database may be corrupted. Pruning aborted to prevent orphaned indices.",
            expected_version,
            version
        );
        
        txns.push((version, txn));
        expected_version += 1;
    }
    
    // Verify we got all expected transactions
    ensure!(
        expected_version == end || txns.is_empty(),
        "Expected {} transactions from {} to {}, but only found {} ending at {}",
        end - start,
        start,
        end,
        txns.len(),
        expected_version - 1
    );

    Ok(txns)
}
```

**Alternative Approach:** Reuse the existing `ExpectContinuousVersions` trait:

```rust
fn get_pruning_candidate_transactions(
    &self,
    start: Version,
    end: Version,
) -> Result<Vec<(Version, Transaction)>> {
    ensure!(end >= start, "{} must be >= {}", end, start);

    let mut iter = self
        .ledger_db
        .transaction_db_raw()
        .iter::<TransactionSchema>()?;
    iter.seek(&start)?;
    
    // Use ExpectContinuousVersions to enforce gap detection
    let continuous_iter = iter.expect_continuous_versions(start, (end - start) as usize)?;
    
    continuous_iter.collect()
}
```

## Proof of Concept

```rust
#[cfg(test)]
mod test {
    use super::*;
    use aptos_schemadb::SchemaBatch;
    use aptos_temppath::TempPath;
    
    #[test]
    fn test_pruner_detects_version_gaps() {
        let tmp_dir = TempPath::new();
        let db = AptosDB::new_for_test(&tmp_dir);
        
        // Write transactions 0-99, but skip 50-59 (simulate corruption)
        let mut batch = SchemaBatch::new();
        for version in 0..50 {
            db.ledger_db.transaction_db().put_transaction(
                version,
                &create_test_transaction(),
                true,
                &mut batch,
            ).unwrap();
        }
        // Gap: versions 50-59 missing
        for version in 60..100 {
            db.ledger_db.transaction_db().put_transaction(
                version,
                &create_test_transaction(),
                true,
                &mut batch,
            ).unwrap();
        }
        db.ledger_db.transaction_db().write_schemas(batch).unwrap();
        
        // Create pruner
        let pruner = TransactionPruner::new(
            Arc::new(TransactionStore::new(Arc::clone(&db.ledger_db))),
            Arc::clone(&db.ledger_db),
            0,
            None,
        ).unwrap();
        
        // Attempt to get candidates - should FAIL with current implementation
        let result = pruner.get_pruning_candidate_transactions(45, 65);
        
        // CURRENT BEHAVIOR: Returns Ok with transactions 45-49, 60-64 (skips gap)
        // EXPECTED BEHAVIOR: Returns Err indicating version gap detected
        match result {
            Ok(txns) => {
                println!("BUG CONFIRMED: Pruner silently skipped versions 50-59");
                println!("Returned {} transactions instead of expected 20", txns.len());
                assert!(txns.len() < 20, "Gap was silently skipped");
            }
            Err(e) => {
                println!("FIXED: Pruner correctly detected gap: {}", e);
            }
        }
    }
}
```

## Notes

**Validation Against Checklist:**
- ✅ Vulnerability in Aptos Core codebase (transaction_pruner.rs)
- ⚠️ Requires pre-existing database corruption (not directly exploitable by unprivileged attacker)
- ✅ Realistic scenario (database corruption, bugs creating gaps)
- ✅ High severity impact (validator slowdowns, storage exhaustion)
- ✅ PoC demonstrable with Rust test
- ✅ Breaks state consistency and storage management invariants

**Important Caveat:** While this is a real correctness bug with potentially severe consequences, the primary attack vector requires either database corruption or another bug that creates version gaps. An unprivileged attacker cannot directly trigger this condition without first exploiting a separate vulnerability. This is primarily a **defense-in-depth** and **robustness issue** that should be fixed to prevent silent failures and ensure data integrity guarantees are maintained.

### Citations

**File:** storage/aptosdb/src/pruner/ledger_pruner/transaction_pruner.rs (L37-74)
```rust
    fn prune(&self, current_progress: Version, target_version: Version) -> Result<()> {
        let mut batch = SchemaBatch::new();
        let candidate_transactions =
            self.get_pruning_candidate_transactions(current_progress, target_version)?;
        self.ledger_db
            .transaction_db()
            .prune_transaction_by_hash_indices(
                candidate_transactions.iter().map(|(_, txn)| txn.hash()),
                &mut batch,
            )?;
        self.ledger_db.transaction_db().prune_transactions(
            current_progress,
            target_version,
            &mut batch,
        )?;
        self.transaction_store
            .prune_transaction_summaries_by_account(&candidate_transactions, &mut batch)?;
        batch.put::<DbMetadataSchema>(
            &DbMetadataKey::TransactionPrunerProgress,
            &DbMetadataValue::Version(target_version),
        )?;
        if let Some(indexer_db) = self.internal_indexer_db.as_ref() {
            if indexer_db.transaction_enabled() {
                let mut index_batch = SchemaBatch::new();
                self.transaction_store
                    .prune_transaction_by_account(&candidate_transactions, &mut index_batch)?;
                index_batch.put::<InternalIndexerMetadataSchema>(
                    &IndexerMetadataKey::TransactionPrunerProgress,
                    &IndexerMetadataValue::Version(target_version),
                )?;
                indexer_db.get_inner_db_ref().write_schemas(index_batch)?;
            } else {
                self.transaction_store
                    .prune_transaction_by_account(&candidate_transactions, &mut batch)?;
            }
        }
        self.ledger_db.transaction_db().write_schemas(batch)
    }
```

**File:** storage/aptosdb/src/pruner/ledger_pruner/transaction_pruner.rs (L106-131)
```rust
    fn get_pruning_candidate_transactions(
        &self,
        start: Version,
        end: Version,
    ) -> Result<Vec<(Version, Transaction)>> {
        ensure!(end >= start, "{} must be >= {}", end, start);

        let mut iter = self
            .ledger_db
            .transaction_db_raw()
            .iter::<TransactionSchema>()?;
        iter.seek(&start)?;

        // The capacity is capped by the max number of txns we prune in a single batch. It's a
        // relatively small number set in the config, so it won't cause high memory usage here.
        let mut txns = Vec::with_capacity((end - start) as usize);
        for item in iter {
            let (version, txn) = item?;
            if version >= end {
                break;
            }
            txns.push((version, txn));
        }

        Ok(txns)
    }
```

**File:** storage/schemadb/src/iterator.rs (L64-74)
```rust
    pub fn seek<SK>(&mut self, seek_key: &SK) -> aptos_storage_interface::Result<()>
    where
        SK: SeekKeyCodec<S>,
    {
        let _timer =
            APTOS_SCHEMADB_SEEK_LATENCY_SECONDS.timer_with(&[S::COLUMN_FAMILY_NAME, "seek"]);
        let key = <SK as SeekKeyCodec<S>>::encode_seek_key(seek_key)?;
        self.db_iter.seek(&key);
        self.status = Status::DoneSeek;
        Ok(())
    }
```

**File:** storage/aptosdb/src/utils/iterators.rs (L76-102)
```rust
pub trait ExpectContinuousVersions<T>: Iterator<Item = Result<(Version, T)>> + Sized {
    fn expect_continuous_versions(
        self,
        first_version: Version,
        limit: usize,
    ) -> Result<ContinuousVersionIter<Self, T>>;
}

impl<I, T> ExpectContinuousVersions<T> for I
where
    I: Iterator<Item = Result<(Version, T)>>,
{
    fn expect_continuous_versions(
        self,
        first_version: Version,
        limit: usize,
    ) -> Result<ContinuousVersionIter<Self, T>> {
        Ok(ContinuousVersionIter {
            inner: self,
            first_version,
            expected_next_version: first_version,
            end_version: first_version
                .checked_add(limit as u64)
                .ok_or(AptosDbError::TooManyRequested(first_version, limit as u64))?,
            _phantom: Default::default(),
        })
    }
```

**File:** storage/aptosdb/src/ledger_db/transaction_db.rs (L63-71)
```rust
    pub(crate) fn get_transaction_iter(
        &self,
        start_version: Version,
        num_transactions: usize,
    ) -> Result<impl Iterator<Item = Result<Transaction>> + '_> {
        let mut iter = self.db.iter::<TransactionSchema>()?;
        iter.seek(&start_version)?;
        iter.expect_continuous_versions(start_version, num_transactions)
    }
```

**File:** storage/aptosdb/src/ledger_db/transaction_db.rs (L169-179)
```rust
    pub(crate) fn prune_transactions(
        &self,
        begin: Version,
        end: Version,
        db_batch: &mut SchemaBatch,
    ) -> Result<()> {
        for version in begin..end {
            db_batch.delete::<TransactionSchema>(&version)?;
        }
        Ok(())
    }
```
