# Audit Report

## Title
Configuration Disclosure Through Failpoint API Endpoint Error Messages

## Summary
The Aptos REST API exposes a `/v1/set_failpoint` endpoint that leaks build configuration information through differential error messages, allowing unauthenticated attackers to determine whether a node was compiled with the `failpoints` feature flag enabled.

## Finding Description
The vulnerability exists in the `set_failpoint_poem` handler which has two different implementations based on compile-time feature flags. [1](#0-0) 

When the `failpoints` feature is **not compiled in**, the endpoint returns: `"Failpoints are not enabled at a feature level"` [2](#0-1) 

When the `failpoints` feature **is compiled in** but disabled at runtime, the endpoint returns: `"Failpoints are not enabled at a config level"` [3](#0-2) 

This endpoint is publicly accessible without authentication at `/v1/set_failpoint` as registered in the API runtime. [4](#0-3) 

The failpoints feature is controlled by a compile-time feature flag in the API's Cargo.toml. [5](#0-4) 

An attacker can fingerprint nodes by sending a GET request to this endpoint and observing which error message is returned, thus determining:
1. Whether the binary was built with testing/debugging capabilities
2. Whether the node is running a production vs development build
3. The security posture of the deployment

While failpoints are prevented from being enabled on mainnet through configuration sanitization [6](#0-5) , the information disclosure still occurs on all nodes regardless of chain ID.

## Impact Explanation
This is a **Low severity** information disclosure vulnerability per the Aptos bug bounty program. It falls under the category of "Minor information leaks" (up to $1,000 reward tier). The vulnerability does not directly compromise funds, consensus, or availability, but provides reconnaissance information to potential attackers.

## Likelihood Explanation
This vulnerability is trivially exploitable with a **100% success rate**. Any unauthenticated user can query the endpoint via a simple HTTP GET request. The information disclosure is deterministic and consistent across all requests. However, the actual security impact is minimal as it only reveals build configuration, not runtime secrets or security-critical data.

## Recommendation
Implement consistent error messaging regardless of feature flag compilation status. The endpoint should return a generic error message that does not disclose configuration details:

```rust
#[handler]
pub fn set_failpoint_poem(
    context: Data<&std::sync::Arc<Context>>,
    Query(failpoint_conf): Query<FailpointConf>,
) -> poem::Result<String> {
    Err(poem::Error::from(anyhow::anyhow!(
        "Failpoint configuration is not available"
    )))
}
```

Alternatively, remove the endpoint entirely from production builds using conditional compilation or protect it with authentication/authorization that restricts access to administrative users only.

## Proof of Concept

**Step 1:** Query a node compiled WITHOUT failpoints feature:
```bash
curl "http://node-address:8080/v1/set_failpoint?name=test&actions=return"
# Response: {"message":"Failpoints are not enabled at a feature level",...}
```

**Step 2:** Query a node compiled WITH failpoints feature (but disabled in config):
```bash
curl "http://node-address:8080/v1/set_failpoint?name=test&actions=return"
# Response: {"message":"Failpoints are not enabled at a config level",...}
```

**Step 3:** Fingerprinting script:
```python
import requests

def fingerprint_node(node_url):
    response = requests.get(f"{node_url}/v1/set_failpoint", 
                           params={"name": "test", "actions": "return"})
    
    if "feature level" in response.text:
        return "Production build (failpoints not compiled)"
    elif "config level" in response.text:
        return "Development build (failpoints compiled but disabled)"
    else:
        return "Unknown or failpoints enabled"

# Test against target node
result = fingerprint_node("http://target-node:8080")
print(f"Node fingerprint: {result}")
```

## Notes
While this vulnerability meets the definition of the security question asked (configuration disclosure through error message differences), it only achieves **Low severity** impact per the Aptos bug bounty criteria. The issue does not affect consensus safety, state integrity, or any of the critical blockchain invariants. It serves primarily as a reconnaissance tool for attackers to identify test/development environments.

### Citations

**File:** api/src/set_failpoints.rs (L21-52)
```rust
#[cfg(feature = "failpoints")]
#[handler]
pub fn set_failpoint_poem(
    context: Data<&std::sync::Arc<Context>>,
    Query(failpoint_conf): Query<FailpointConf>,
) -> poem::Result<String> {
    if context.failpoints_enabled() {
        fail::cfg(&failpoint_conf.name, &failpoint_conf.actions)
            .map_err(|e| poem::Error::from(anyhow::anyhow!(e)))?;
        info!(
            "Configured failpoint {} to {}",
            failpoint_conf.name, failpoint_conf.actions
        );
        Ok(format!("Set failpoint {}", failpoint_conf.name))
    } else {
        Err(poem::Error::from(anyhow::anyhow!(
            "Failpoints are not enabled at a config level"
        )))
    }
}

#[allow(unused_variables)]
#[cfg(not(feature = "failpoints"))]
#[handler]
pub fn set_failpoint_poem(
    context: Data<&std::sync::Arc<Context>>,
    Query(failpoint_conf): Query<FailpointConf>,
) -> poem::Result<String> {
    Err(poem::Error::from(anyhow::anyhow!(
        "Failpoints are not enabled at a feature level"
    )))
}
```

**File:** api/src/runtime.rs (L248-251)
```rust
                    .at(
                        "/set_failpoint",
                        poem::get(set_failpoints::set_failpoint_poem).data(context.clone()),
                    ),
```

**File:** api/Cargo.toml (L70-71)
```text
[features]
failpoints = ["fail/failpoints"]
```

**File:** config/src/config/config_sanitizer.rs (L82-90)
```rust
    // Verify that failpoints are not enabled in mainnet
    let failpoints_enabled = are_failpoints_enabled();
    if let Some(chain_id) = chain_id {
        if chain_id.is_mainnet() && failpoints_enabled {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "Failpoints are not supported on mainnet nodes!".into(),
            ));
        }
```
