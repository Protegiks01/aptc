# Audit Report

## Title
Historical State View Timing Vulnerability in Feature Flag Checks

## Summary
The `feature_enabled()` function in the REST API uses `latest_state_view()` to check feature flags, regardless of the historical version being queried. This creates a timing mismatch where feature flag checks use the current blockchain state while the actual data query uses a historical version, leading to non-deterministic and inconsistent API responses for historical queries.

## Finding Description

The vulnerability exists in the interaction between two functions: [1](#0-0) 

The `feature_enabled()` function always queries the latest state to check if a feature flag is enabled. [2](#0-1) 

It calls `latest_state_view()` which retrieves the current state checkpoint, not a historical version.

This timing mismatch is exploited when querying account data at a specific historical version: [3](#0-2) 

The attack flow works as follows:

1. **Historical Account Query**: A user queries `GET /accounts/0xABCD?ledger_version=1000` for an account that doesn't exist at version 1000
2. **Resource Fetch at Historical Version**: The API calls `get_account_resource()` which queries state at the requested `ledger_version` (1000)
3. **Feature Check at Latest Version**: If no account resource exists, the code checks if `DEFAULT_ACCOUNT_RESOURCE` feature is enabled via `feature_enabled()`, which queries the **latest** state (e.g., version 2000), not version 1000
4. **Inconsistent Result**: If the feature was disabled at version 1000 but enabled at version 2000, the API incorrectly returns a stateless account instead of an error [4](#0-3) 

When the feature is enabled, `new_stateless()` creates a default AccountResource with sequence number 0.

The feature flag is defined in the Move framework: [5](#0-4) 

This feature is marked as "transient," meaning it's expected to change over time via governance.

**Which Security Guarantees Are Broken:**

1. **Historical State Immutability**: Historical queries should return consistent results regardless of when they are executed
2. **Deterministic API Responses**: The same query with the same parameters should always return the same result
3. **State Consistency Invariant**: The API violates the principle that state at version V should be reconstructed identically regardless of current blockchain state

## Impact Explanation

This vulnerability qualifies as **MEDIUM severity** per the Aptos bug bounty criteria for the following reasons:

**State Inconsistencies Requiring Intervention:**
- Historical API queries return different results depending on when they are executed
- The same account query at version V₁ will return different responses before and after a feature flag change at version V₂
- This breaks the fundamental expectation that historical blockchain data is immutable and reproducible

**Concrete Harm:**
- **Application Logic Errors**: DApps and indexers relying on historical state queries will receive inconsistent data, potentially leading to incorrect business logic decisions
- **Audit Trail Corruption**: Historical transaction analysis and forensics become unreliable when the same query produces different results over time
- **Data Integrity Violations**: Multiple API nodes queried at different times could return conflicting historical data for the same version

**Why Not Higher Severity:**
- Does NOT affect consensus layer (execution is still deterministic)
- Does NOT enable fund theft or loss
- Does NOT cause validator crashes or network partition
- Limited to API layer responses, not actual blockchain state

**Why Not Lower Severity:**
- More significant than "minor information leak" or "non-critical bug"
- Affects core API functionality (historical state queries)
- Requires code changes to fix
- Has measurable impact on application correctness

## Likelihood Explanation

**Likelihood: HIGH**

This vulnerability will naturally manifest whenever:
1. A feature flag changes state via on-chain governance (happens regularly as new features are enabled)
2. Users query historical versions for accounts that don't exist
3. The feature flag affects behavior (like `DEFAULT_ACCOUNT_RESOURCE`)

**No Special Conditions Required:**
- Any user can trigger this with standard API queries
- No privileged access needed
- No complex setup or timing attacks required
- Occurs naturally through normal API usage

**Real-World Occurrence:**
- Feature flags are changed regularly through governance proposals
- Applications commonly query historical state for analytics, auditing, and indexing
- Queries for non-existent accounts are common when checking if an address has ever been used

## Recommendation

**Fix: Add version parameter to feature flag checks**

Modify `feature_enabled()` to accept an optional version parameter:

```rust
// In api/src/context.rs
pub fn feature_enabled_at_version(&self, feature: FeatureFlag, version: Option<Version>) -> Result<bool> {
    let state_view = match version {
        Some(v) => self.state_view_at_version(v)?,
        None => self.latest_state_view()?,
    };
    let features = Features::fetch_config(&state_view)
        .ok_or_else(|| anyhow::anyhow!("Failed to fetch features from state view"))?;
    Ok(features.is_enabled(feature))
}

// Keep existing function for backwards compatibility
pub fn feature_enabled(&self, feature: FeatureFlag) -> Result<bool> {
    self.feature_enabled_at_version(feature, None)
}
```

Update the call site in `api/src/accounts.rs`:

```rust
let stateless_account_enabled = self
    .context
    .feature_enabled_at_version(
        aptos_types::on_chain_config::FeatureFlag::DEFAULT_ACCOUNT_RESOURCE,
        Some(self.ledger_version),  // Use the queried version, not latest
    )?;
```

**Verification:**
- Ensure all feature flag checks use the appropriate version context
- Add integration tests that verify historical queries return consistent results before and after feature flag changes
- Audit other uses of `latest_state_view()` for similar timing issues

## Proof of Concept

**Reproduction Steps:**

```rust
// Integration test demonstrating the vulnerability
#[tokio::test]
async fn test_historical_feature_flag_timing_bug() {
    let mut test_context = TestContext::new().await;
    
    // Step 1: At version V1, DEFAULT_ACCOUNT_RESOURCE is disabled
    let account_address = AccountAddress::random();
    let version_before_feature = test_context.get_latest_version().await;
    
    // Step 2: Query non-existent account at V1 - should return error
    let response1 = test_context
        .get(&format!("/accounts/{}?ledger_version={}", account_address, version_before_feature))
        .await;
    assert_eq!(response1.status(), 404); // Account not found
    
    // Step 3: Enable DEFAULT_ACCOUNT_RESOURCE feature via governance
    test_context.enable_feature(FeatureFlag::DEFAULT_ACCOUNT_RESOURCE).await;
    let version_after_feature = test_context.get_latest_version().await;
    
    // Step 4: Query the SAME non-existent account at V1 again
    let response2 = test_context
        .get(&format!("/accounts/{}?ledger_version={}", account_address, version_before_feature))
        .await;
    
    // BUG: This now returns 200 OK with stateless account
    // even though we're querying the same historical version V1
    // where the feature was disabled!
    assert_eq!(response2.status(), 200); // Incorrectly returns stateless account
    
    let account_data: AccountData = response2.json().await;
    assert_eq!(account_data.sequence_number, "0"); // Stateless account created
    
    // EXPECTED: response2 should match response1 (404 error)
    // ACTUAL: response2 returns 200 with default account
    // This violates historical state immutability!
}
```

**Expected Behavior:**
Both queries at `version_before_feature` should return identical 404 responses, regardless of feature flag changes at later versions.

**Actual Behavior:**
The second query returns a 200 response with a stateless account because the feature check uses the latest state where the feature is enabled.

## Notes

This vulnerability is limited to the REST API layer and does not affect consensus or transaction execution, which remain deterministic. However, it represents a significant data integrity issue for applications relying on historical state queries. The fix requires careful review of all feature flag checks throughout the API codebase to ensure version consistency.

### Citations

**File:** api/src/context.rs (L156-158)
```rust
    pub fn latest_state_view(&self) -> Result<DbStateView> {
        Ok(self.db.latest_state_checkpoint_view()?)
    }
```

**File:** api/src/context.rs (L170-175)
```rust
    pub fn feature_enabled(&self, feature: FeatureFlag) -> Result<bool> {
        let state_view = self.latest_state_view()?;
        let features = Features::fetch_config(&state_view)
            .ok_or_else(|| anyhow::anyhow!("Failed to fetch features from state view"))?;
        Ok(features.is_enabled(feature))
    }
```

**File:** api/src/accounts.rs (L264-302)
```rust
    pub fn account(self, accept_type: &AcceptType) -> BasicResultWith404<AccountData> {
        // Retrieve the Account resource and convert it accordingly
        let state_value_opt = self.get_account_resource()?;

        let account_resource = if let Some(state_value) = &state_value_opt {
            let account_resource: AccountResource = bcs::from_bytes(state_value)
                .context("Internal error deserializing response from DB")
                .map_err(|err| {
                    BasicErrorWith404::internal_with_code(
                        err,
                        AptosErrorCode::InternalError,
                        &self.latest_ledger_info,
                    )
                })?;
            account_resource
        } else {
            let stateless_account_enabled = self
                .context
                .feature_enabled(
                    aptos_types::on_chain_config::FeatureFlag::DEFAULT_ACCOUNT_RESOURCE,
                )
                .context("Failed to check if stateless account is enabled")
                .map_err(|_| {
                    BasicErrorWith404::internal_with_code(
                        "Failed to check if stateless account is enabled",
                        AptosErrorCode::InternalError,
                        &self.latest_ledger_info,
                    )
                })?;
            if stateless_account_enabled {
                AccountResource::new_stateless(*self.address.inner())
            } else {
                Err(account_not_found(
                    self.address,
                    self.ledger_version,
                    &self.latest_ledger_info,
                ))?
            }
        };
```

**File:** types/src/account_config/resources/core_account.rs (L50-60)
```rust
    pub fn new_stateless(address: AccountAddress) -> Self {
        AccountResource {
            authentication_key: bcs::to_bytes(&address).unwrap(),
            sequence_number: 0,
            guid_creation_num: 2,
            coin_register_events: EventHandle::new(EventKey::new(0, address), 0),
            key_rotation_events: EventHandle::new(EventKey::new(1, address), 0),
            rotation_capability_offer: None,
            signer_capability_offer: None,
        }
    }
```

**File:** aptos-move/framework/move-stdlib/sources/configs/features.move (L683-690)
```text
    /// Lifetime: transient
    const DEFAULT_ACCOUNT_RESOURCE: u64 = 91;

    public fun get_default_account_resource_feature(): u64 { DEFAULT_ACCOUNT_RESOURCE }

    public fun is_default_account_resource_enabled(): bool acquires Features {
        is_enabled(DEFAULT_ACCOUNT_RESOURCE)
    }
```
