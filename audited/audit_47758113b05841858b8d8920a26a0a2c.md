# Audit Report

## Title
Indexer Panic Due to Unhandled Serialization Failure in Move Resource Processing

## Summary
The Aptos indexer contains multiple `.unwrap()` calls in the critical path of processing WriteResource objects that can cause the indexer process to crash if serialization fails, leading to a Denial of Service of the indexing service.

## Finding Description
The vulnerability exists in the indexer's coin processing pipeline. When processing WriteResource objects from committed blockchain transactions, the code performs JSON serialization without proper error handling.

The critical unwrap is located in `MoveResource::from_write_resource()`: [1](#0-0) 

This function is called when processing coin-related resources: [2](#0-1) 

The resulting MoveResource is then accessed with another unwrap: [3](#0-2) 

When the indexer processes transactions, it calls these functions through: [4](#0-3) 

If any of these unwrap calls panic, the crash handler terminates the process: [5](#0-4) 

## Impact Explanation
This qualifies as **High Severity** per the Aptos bug bounty criteria ("API crashes" / "Validator node slowdowns"). A panic in the indexer causes:

1. **Complete indexer service unavailability** - The process exits with code 12
2. **No automatic recovery** - Manual intervention required to restart
3. **Blockchain data inaccessibility** - Applications depending on the indexer API lose access to on-chain data
4. **Cascading service failures** - Downstream services (wallets, explorers, dApps) become non-functional

The indexer is a critical infrastructure component that provides queryable access to blockchain state and transaction history.

## Likelihood Explanation
**Likelihood: VERY LOW**

While the code vulnerability is real, exploitation requires extraordinary circumstances:

1. **Defense-in-depth layers prevent malformed data:**
   - All WriteResource objects come from consensus-validated transactions
   - The Move VM validates all resource data before storage
   - The API conversion layer has error handling: [6](#0-5) 

2. **Serialization is inherently safe for the data type:**
   - `MoveStructValue` is `BTreeMap<IdentifierWrapper, serde_json::Value>` - already JSON-compatible
   - Both key and value types implement `Serialize` correctly

3. **Requires one of these exceptional scenarios:**
   - A critical bug in the Move VM allowing invalid resource data to be committed
   - Database corruption at the storage layer
   - A bug in the API conversion layer that constructs invalid MoveResource objects

The fetcher explicitly panics on conversion errors: [7](#0-6) 

## Recommendation
Replace all `.unwrap()` calls with proper error handling using the `Result` return type. The functions should propagate errors up the call stack where they can be logged and handled gracefully.

**Fix for `move_resources.rs`:**
```rust
pub fn from_write_resource(
    write_resource: &WriteResource,
    write_set_change_index: i64,
    transaction_version: i64,
    transaction_block_height: i64,
) -> Result<Self> {  // Return Result instead of Self
    let parsed_data = Self::convert_move_struct_tag(&write_resource.data.typ);
    Ok(Self {
        transaction_version,
        transaction_block_height,
        write_set_change_index,
        type_: write_resource.data.typ.to_string(),
        name: parsed_data.name.clone(),
        address: standardize_address(&write_resource.address.to_string()),
        module: parsed_data.module.clone(),
        generic_type_params: parsed_data.generic_type_params,
        data: Some(serde_json::to_value(&write_resource.data.data)?),  // Use ? instead of unwrap
        is_deleted: false,
        state_key_hash: standardize_address(write_resource.state_key_hash.as_str()),
    })
}
```

**Fix for `coin_utils.rs`:**
```rust
pub fn from_write_resource(
    write_resource: &WriteResource,
    txn_version: i64,
) -> Result<Option<CoinResource>> {
    let type_str = format!(
        "{}::{}::{}",
        write_resource.data.typ.address,
        write_resource.data.typ.module,
        write_resource.data.typ.name
    );
    if !CoinResource::is_resource_supported(type_str.as_str()) {
        return Ok(None);
    }
    let resource = MoveResource::from_write_resource(
        write_resource,
        0,
        txn_version,
        0,
    )?;  // Propagate error instead of panicking
    Ok(Some(Self::from_resource(
        &type_str,
        resource.data.as_ref().context("Missing resource data")?,  // Better error message
        txn_version,
    )?))
}
```

Update all call sites to handle the Result properly: [8](#0-7) 

## Proof of Concept
A realistic PoC is not feasible because it would require either:
1. Crafting a malicious Move transaction that bypasses VM validation and writes invalid resource data
2. Corrupting the AptosDB database directly
3. Exploiting an unknown bug in the API conversion layer

However, the vulnerability can be demonstrated through unit testing:

```rust
#[test]
#[should_panic(expected = "called `Result::unwrap()` on an `Err` value")]
fn test_move_resource_serialization_failure() {
    // This would require mocking a WriteResource with data that fails serialization
    // In practice, this is prevented by the validation layers
    
    // Hypothetical malformed WriteResource construction
    let malformed_resource = construct_malformed_write_resource();
    
    // This should panic due to unwrap() on serialization error
    let _ = MoveResource::from_write_resource(
        &malformed_resource,
        0,
        1000,
        100
    );
}
```

**Notes**

This is a **defense-in-depth vulnerability** rather than an actively exploitable security flaw. The code violates the principle of robust error handling by assuming serialization will never fail. While the likelihood of exploitation is extremely low due to multiple validation layers, the code should handle errors gracefully to prevent unexpected crashes in extraordinary circumstances such as:

- Future VM implementation bugs
- Storage layer corruption
- Refactoring that changes data validation assumptions

The severity classification as High is justified by the **impact** (complete indexer DoS), even though the **likelihood** is very low. This is consistent with defense-in-depth security principles where critical infrastructure should have multiple layers of protection.

### Citations

**File:** crates/indexer/src/models/move_resources.rs (L52-52)
```rust
            data: Some(serde_json::to_value(&write_resource.data.data).unwrap()),
```

**File:** crates/indexer/src/models/coin_models/coin_utils.rs (L224-229)
```rust
        let resource = MoveResource::from_write_resource(
            write_resource,
            0, // Placeholder, this isn't used anyway
            txn_version,
            0, // Placeholder, this isn't used anyway
        );
```

**File:** crates/indexer/src/models/coin_models/coin_utils.rs (L230-235)
```rust
        Ok(Some(Self::from_resource(
            &type_str,
            resource.data.as_ref().unwrap(),
            txn_version,
        )?))
    }
```

**File:** crates/indexer/src/models/coin_models/coin_activities.rs (L130-144)
```rust
            let (maybe_coin_info, maybe_coin_balance_data) =
                if let APIWriteSetChange::WriteResource(write_resource) = wsc {
                    (
                        CoinInfo::from_write_resource(write_resource, txn_version, txn_timestamp)
                            .unwrap(),
                        CoinBalance::from_write_resource(
                            write_resource,
                            txn_version,
                            txn_timestamp,
                        )
                        .unwrap(),
                    )
                } else {
                    (None, None)
                };
```

**File:** crates/crash-handler/src/lib.rs (L56-57)
```rust
    // Kill the process
    process::exit(12);
```

**File:** api/types/src/convert.rs (L498-502)
```rust
                Path::Resource(typ) => vec![WriteSetChange::WriteResource(WriteResource {
                    address: access_path.address.into(),
                    state_key_hash,
                    data: self.try_into_resource(&typ, bytes)?,
                })],
```

**File:** crates/indexer/src/indexer/fetcher.rs (L313-316)
```rust
                panic!(
                    "Could not convert txn {} from OnChainTransactions: {:?}",
                    txn_version, err
                );
```
