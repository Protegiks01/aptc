# Audit Report

## Title
Missing Epoch Validation in JWK Consensus Allows Cross-Epoch State Contamination

## Summary
The `new_rb_request()` function in `per_issuer.rs` lacks validation of epoch/payload consistency. More critically, the JWK consensus system fails to validate the `epoch` field of `ObservedJWKsUpdated` events before processing them, allowing on-chain state from incorrect epochs to contaminate the consensus process and create inconsistent epoch/payload combinations.

## Finding Description

The vulnerability exists across multiple layers of the JWK consensus system:

**Layer 1: Missing Local Validation** [1](#0-0) 

The `new_rb_request()` function constructs an `ObservedUpdateRequest` with no validation that the `epoch` parameter corresponds to the `payload` parameter. The function signature allows arbitrary epoch/payload combinations.

**Layer 2: Epoch Manager Fails to Filter Events** [2](#0-1) 

The `process_onchain_event()` method forwards all `ObservedJWKsUpdated` events to the JWK manager without validating that `jwk_event.epoch` matches `self.epoch_state.epoch`. Events from previous epochs can be forwarded to managers running in later epochs.

**Layer 3: JWK Manager Discards Epoch Information** [3](#0-2) 

When processing `ObservedJWKsUpdated` events, the epoch field is explicitly discarded with the `..` pattern. The manager updates its internal state (`states_by_issuer`) with JWKs from potentially wrong epochs.

**Layer 4: Inconsistent Request Creation** [4](#0-3) 

When `process_new_observation()` creates consensus requests via `start_produce()`, it uses:
- `self.epoch_state.epoch` (current epoch, e.g., N+1)
- `state.on_chain_version() + 1` (version computed from potentially stale on-chain state from epoch N)

**The Attack Path:**

1. Validator runs JWK manager for epoch N+1 with `epoch_state.epoch = N+1`
2. A delayed `ObservedJWKsUpdated` event from epoch N arrives (contains `epoch: N` and JWK data from epoch N)
3. Epoch manager forwards event without epoch validation
4. JWK manager processes event, discarding epoch field and updating `states_by_issuer` with epoch N data
5. JWKObserver triggers `process_new_observation()` with new observation
6. Manager creates `ObservedUpdateRequest` with `epoch: N+1` but `issuer` and version derived from epoch N state
7. This inconsistent epoch/payload combination violates the invariant that each epoch operates on consistent state

**Violated Invariant:**
This breaks **State Consistency** (Invariant #4): "State transitions must be atomic and verifiable." The JWK manager's state becomes a hybrid of epoch N and epoch N+1 data, violating the atomic epoch boundary.

## Impact Explanation

**Severity: Medium** (up to $10,000 per Aptos Bug Bounty)

This qualifies as "State inconsistencies requiring intervention" because:

1. **Consensus Correctness**: Validators operating on different epoch states may fail to reach consensus on JWK updates, causing liveness degradation
2. **Version Inconsistencies**: JWK version numbers may be computed incorrectly, potentially leading to rejected validator transactions
3. **State Divergence**: Different validators may certify different JWK states if timing of delayed events varies across nodes

The impact is mitigated by downstream aggregation checks [5](#0-4)  that prevent validators from aggregating signatures across different epochs. However, this provides defense-in-depth rather than preventing the root cause of state inconsistency.

## Likelihood Explanation

**Likelihood: Medium**

This vulnerability can manifest during normal operations:

1. **Epoch Transitions**: During each epoch transition, there's a window where events from the old epoch may still be in flight
2. **Event Delivery Delays**: Network or processing delays can cause events to arrive after epoch boundaries
3. **No Byzantine Behavior Required**: This is a protocol design flaw that occurs without malicious actors

The event notification system [6](#0-5)  includes epoch information specifically to enable validation, but this information is not utilized.

## Recommendation

Add epoch validation at three critical points:

**1. Epoch Manager Level (Primary Fix):**
```rust
fn process_onchain_event(&mut self, notification: EventNotification) -> Result<()> {
    let EventNotification {
        subscribed_events, ..
    } = notification;
    for event in subscribed_events {
        if let Ok(jwk_event) = ObservedJWKsUpdated::try_from(&event) {
            // ADD EPOCH VALIDATION
            if Some(jwk_event.epoch) != self.epoch_state.as_ref().map(|s| s.epoch) {
                warn!(
                    "Dropping ObservedJWKsUpdated event from wrong epoch: event_epoch={}, current_epoch={:?}",
                    jwk_event.epoch,
                    self.epoch_state.as_ref().map(|s| s.epoch)
                );
                continue;
            }
            if let Some(tx) = self.jwk_updated_event_txs.as_ref() {
                let _ = tx.push((), jwk_event);
            }
        }
    }
    Ok(())
}
```

**2. JWK Manager Level (Defense in Depth):**
```rust
jwk_updated = jwk_updated_rx.select_next_some() => {
    let ObservedJWKsUpdated { epoch, jwks } = jwk_updated;
    // ADD EPOCH VALIDATION
    if epoch != this.epoch_state.epoch {
        warn!("Ignoring JWK update from wrong epoch: {}", epoch);
        Ok(())
    } else {
        this.reset_with_on_chain_state(jwks)
    }
},
```

**3. Function Level (Type Safety):**
Consider making `new_rb_request()` validate consistency or accept a single `EpochState` parameter instead of separate `epoch` and `payload` to prevent misuse at the type level.

## Proof of Concept

```rust
// Reproduction scenario (pseudo-code for clarity)
#[tokio::test]
async fn test_cross_epoch_event_contamination() {
    // Setup: Create epoch manager and JWK manager for epoch 1
    let epoch_1_state = create_epoch_state(1);
    let mut epoch_manager = create_epoch_manager(epoch_1_state.clone());
    
    // Transition to epoch 2
    let epoch_2_state = create_epoch_state(2);
    epoch_manager.on_new_epoch(epoch_2_notification).await.unwrap();
    
    // Simulate delayed event from epoch 1 arriving after transition
    let stale_event = ObservedJWKsUpdated {
        epoch: 1,  // Event from epoch 1
        jwks: create_test_jwks("issuer_a", 100),
    };
    
    // This event will be processed by epoch 2 manager without validation
    epoch_manager.process_onchain_event(
        create_event_notification(stale_event)
    ).unwrap();
    
    // Verify: The epoch 2 manager now has contaminated state
    // When it creates a consensus request, it will use:
    // - epoch: 2 (from epoch_state)
    // - version: 101 (computed from epoch 1 on-chain state + 1)
    // This is an inconsistent epoch/payload combination
}
```

## Notes

- The `ObservedUpdateRequest` struct [7](#0-6)  was designed to include epoch for validation purposes
- RPC requests have epoch validation [8](#0-7)  but on-chain events do not
- The per-key mode implementation [9](#0-8)  has similar validation gaps
- This issue specifically affects JWK consensus and does not directly impact core AptosBFT consensus, limiting its severity

### Citations

**File:** crates/aptos-jwk-consensus/src/mode/per_issuer.rs (L23-28)
```rust
    fn new_rb_request(epoch: u64, payload: &ProviderJWKs) -> anyhow::Result<ObservedUpdateRequest> {
        Ok(ObservedUpdateRequest {
            epoch,
            issuer: payload.issuer.clone(),
        })
    }
```

**File:** crates/aptos-jwk-consensus/src/epoch_manager.rs (L99-104)
```rust
        if Some(rpc_request.msg.epoch()) == self.epoch_state.as_ref().map(|s| s.epoch) {
            if let Some(tx) = &self.jwk_rpc_msg_tx {
                let _ = tx.push(peer_id, (peer_id, rpc_request));
            }
        }
        Ok(())
```

**File:** crates/aptos-jwk-consensus/src/epoch_manager.rs (L108-120)
```rust
    fn process_onchain_event(&mut self, notification: EventNotification) -> Result<()> {
        let EventNotification {
            subscribed_events, ..
        } = notification;
        for event in subscribed_events {
            if let Ok(jwk_event) = ObservedJWKsUpdated::try_from(&event) {
                if let Some(tx) = self.jwk_updated_event_txs.as_ref() {
                    let _ = tx.push((), jwk_event);
                }
            }
        }
        Ok(())
    }
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager/mod.rs (L140-143)
```rust
                jwk_updated = jwk_updated_rx.select_next_some() => {
                    let ObservedJWKsUpdated { jwks, .. } = jwk_updated;
                    this.reset_with_on_chain_state(jwks)
                },
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager/mod.rs (L206-215)
```rust
            let abort_handle = self
                .update_certifier
                .start_produce(
                    self.epoch_state.clone(),
                    observed.clone(),
                    self.qc_update_tx.clone(),
                )
                .context(
                    "process_new_observation failed with update_certifier.start_produce failure",
                )?;
```

**File:** crates/aptos-jwk-consensus/src/observation_aggregation/mod.rs (L60-63)
```rust
        ensure!(
            epoch == self.epoch_state.epoch,
            "adding peer observation failed with invalid epoch",
        );
```

**File:** types/src/jwks/mod.rs (L481-484)
```rust
pub struct ObservedJWKsUpdated {
    pub epoch: u64,
    pub jwks: AllProvidersJWKs,
}
```

**File:** crates/aptos-jwk-consensus/src/types.rs (L59-62)
```rust
pub struct ObservedUpdateRequest {
    pub epoch: u64,
    pub issuer: Issuer,
}
```

**File:** crates/aptos-jwk-consensus/src/mode/per_key.rs (L32-40)
```rust
    fn new_rb_request(
        epoch: u64,
        payload: &ProviderJWKs,
    ) -> anyhow::Result<ObservedKeyLevelUpdateRequest> {
        let KeyLevelUpdate { issuer, kid, .. } =
            KeyLevelUpdate::try_from_issuer_level_repr(payload)
                .context("new_rb_request failed with repr translation")?;
        Ok(ObservedKeyLevelUpdateRequest { epoch, issuer, kid })
    }
```
