# Audit Report

## Title
State Snapshot Restore Bypasses Validator Signature Verification via None epoch_history Parameter

## Summary
The `db-tool oneoff state-snapshot` command passes `None` for the `epoch_history` parameter when invoking `StateSnapshotRestoreController`, creating a double-bypass that completely skips validator signature verification on the `LedgerInfoWithSignatures`. This allows loading fabricated blockchain state into a production database without cryptographic validation, violating the fundamental security invariant that all committed state must be signed by a quorum of validators. [1](#0-0) 

## Finding Description

The vulnerability exists in the interaction between two security layers:

**Layer 1 - Merkle Proof Verification (Insufficient):**
The `StateSnapshotRestoreController::run_impl` method verifies the transaction info exists in the ledger via `TransactionInfoWithProof::verify`, but this only validates the Merkle accumulator proof structure, NOT the validator signatures on the `LedgerInfo` itself. [2](#0-1) 

The underlying `verify_transaction_info` function only checks version consistency and Merkle proof validity: [3](#0-2) 

**Layer 2 - Signature Verification (Bypassed):**
The second security layer would verify validator signatures through `epoch_history.verify_ledger_info()`, which delegates to `EpochState::verify` to check BLS signatures from a quorum of validators: [4](#0-3) [5](#0-4) 

However, when `epoch_history` is `None`, this entire validation is skipped, creating a complete bypass of signature verification.

**The Double-Bypass Attack:**

1. Attacker creates a malicious backup containing:
   - Fake `LedgerInfoWithSignatures` with invalid/missing validator signatures
   - Arbitrary `state_root_hash` pointing to manipulated state
   - Self-consistent Merkle proofs (attacker controls both proof and root)

2. Operator runs: `aptos-db-tool restore oneoff state-snapshot --state-manifest <malicious> --target-db-dir /var/lib/aptos/db`

3. The malicious state loads successfully because:
   - Layer 1 only checks Merkle proof structure (passes for self-consistent fake data)
   - Layer 2 signature verification is completely bypassed

4. Node now has corrupted state that could show incorrect balances, modified contracts, or manipulated governance configuration.

**Exacerbating Factor - Trusted Waypoints Ignored:**

Even if the operator provides `--trust-waypoint` flags to establish trust anchors, these are completely ignored because they are only checked inside `epoch_history.verify_ledger_info()`. The documentation acknowledges this behavior: [6](#0-5) 

## Impact Explanation

**Critical Severity** - This vulnerability enables:

1. **Consensus Safety Violations**: A node with fabricated state will compute different state roots and vote incorrectly, potentially causing consensus splits when combined with other compromised nodes.

2. **State Corruption**: The database contains unvalidated state that fails the fundamental security invariant: *all committed blockchain state must be cryptographically signed by a validator quorum*.

3. **Loss of Funds**: Fabricated state could show incorrect account balances, enabling theft when the node serves queries to wallets/exchanges, or incorrect validator rewards.

4. **Network Integrity**: Compromised nodes participating in consensus could violate Byzantine Fault Tolerance assumptions if enough operators are tricked into using malicious backups.

This breaks Critical Invariants #2 (Consensus Safety) and #10 (Cryptographic Correctness).

## Likelihood Explanation

**Medium-High Likelihood** due to:

1. **Operator Error Surface**: The oneoff command provides no warnings about security implications. An operator needing to restore state might choose this "simpler" path instead of BootstrapDB.

2. **Compromised Backup Storage**: If backup storage (S3, GCS, etc.) is compromised, attackers can inject malicious backups that will be accepted by the oneoff command.

3. **No Runtime Safeguards**: The command can write directly to production databases with no checks or confirmations about the lack of signature verification.

4. **Documentation Ambiguity**: While the codebase documents that "LedgerInfos are NOT checked", this is buried in CLI help text rather than prominently displayed as a security warning.

The production restore path (`BootstrapDB`) properly builds epoch history and validates signatures, but nothing prevents operators from using the dangerous oneoff path: [7](#0-6) 

## Recommendation

**Immediate Fix**: Add mandatory signature verification or explicit security warnings:

```rust
// In storage/db-tool/src/restore.rs, modify the StateSnapshot oneoff handler:

Oneoff::StateSnapshot {
    storage,
    opt,
    global,
} => {
    // SECURITY WARNING: Validate this is not being used on production databases
    if !global.dry_run {
        eprintln!("WARNING: oneoff state-snapshot restore does NOT verify validator signatures!");
        eprintln!("This command should ONLY be used for testing/debugging.");
        eprintln!("For production restores, use: aptos-db-tool restore bootstrap-db");
        eprintln!("\nType 'I UNDERSTAND THE RISKS' to continue:");
        
        let mut confirmation = String::new();
        std::io::stdin().read_line(&mut confirmation)?;
        ensure!(
            confirmation.trim() == "I UNDERSTAND THE RISKS",
            "Restore cancelled for safety. Use bootstrap-db for production restores."
        );
    }
    
    // Build epoch_history even for oneoff to enable signature verification
    // OR keep None but document the security trade-off clearly
    StateSnapshotRestoreController::new(
        opt,
        global.try_into()?,
        storage.init_storage().await?,
        None, /* epoch_history - WARNING: disables signature verification */
    )
    .run()
    .await?;
},
```

**Long-term Fix**: Refactor to always require epoch_history or trusted waypoints for non-dry-run restores, making signature bypass impossible in production scenarios.

## Proof of Concept

```rust
// Conceptual PoC - demonstrates the attack flow

// 1. Attacker creates fake backup with arbitrary state_root_hash
let fake_ledger_info = LedgerInfo::new(
    BlockInfo::new(/* fake epoch */ 100, /* fake version */ 1000000, 
                   HashValue::random(), /* malicious state_root */
                   HashValue::zero(), 0, 0, None),
    HashValue::zero()
);

// 2. Create self-consistent but unsigned LedgerInfoWithSignatures
let fake_li_with_sigs = LedgerInfoWithSignatures::new(
    fake_ledger_info,
    AggregateSignature::empty() // No valid validator signatures!
);

// 3. Create fake TransactionInfoWithProof with self-consistent Merkle proof
let fake_txn_info = TransactionInfo::new(
    HashValue::zero(),
    malicious_state_checkpoint_hash, // Points to fabricated state
    HashValue::zero(),
    0, 0
);

// 4. Package into manifest and save to backup storage
let malicious_manifest = StateSnapshotBackup {
    version: 1000000,
    root_hash: malicious_state_checkpoint_hash,
    chunks: vec![/* fake but self-consistent chunks */],
    proof: fake_proof_handle,
};

// 5. Victim runs (without epoch_history):
// $ aptos-db-tool restore oneoff state-snapshot \
//     --state-manifest <malicious_manifest> \
//     --target-db-dir /var/lib/aptos/db

// Result: Malicious state loaded WITHOUT signature verification because:
// - Line 127: verify() only checks Merkle proof (self-consistent fake passes)
// - Lines 137-139: signature check is skipped (epoch_history is None)
```

The actual exploitation requires creating a well-formed backup structure with consistent Merkle proofs, but the fundamental issue is that NO validator signatures are checked when `epoch_history` is `None`, allowing completely fabricated state to be accepted as valid.

## Notes

While the documentation at line 341-343 of `storage/backup/backup-cli/src/utils/mod.rs` acknowledges that "LedgerInfos are NOT checked" in one-shot restore, this does not make the behavior secure. The lack of runtime safeguards, combined with the ability to write to production databases, creates a critical attack surface for operator error or backup storage compromise. The proper production path (BootstrapDB with RestoreCoordinator) correctly validates signatures, but nothing prevents dangerous misuse of the oneoff command.

### Citations

**File:** storage/db-tool/src/restore.rs (L88-95)
```rust
                        StateSnapshotRestoreController::new(
                            opt,
                            global.try_into()?,
                            storage.init_storage().await?,
                            None, /* epoch_history */
                        )
                        .run()
                        .await?;
```

**File:** storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs (L125-136)
```rust
        let (txn_info_with_proof, li): (TransactionInfoWithProof, LedgerInfoWithSignatures) =
            self.storage.load_bcs_file(&manifest.proof).await?;
        txn_info_with_proof.verify(li.ledger_info(), manifest.version)?;
        let state_root_hash = txn_info_with_proof
            .transaction_info()
            .ensure_state_checkpoint_hash()?;
        ensure!(
            state_root_hash == manifest.root_hash,
            "Root hash mismatch with that in proof. root hash: {}, expected: {}",
            manifest.root_hash,
            state_root_hash,
        );
```

**File:** storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs (L137-139)
```rust
        if let Some(epoch_history) = self.epoch_history.as_ref() {
            epoch_history.verify_ledger_info(&li)?;
        }
```

**File:** types/src/proof/mod.rs (L40-61)
```rust
fn verify_transaction_info(
    ledger_info: &LedgerInfo,
    transaction_version: Version,
    transaction_info: &TransactionInfo,
    ledger_info_to_transaction_info_proof: &TransactionAccumulatorProof,
) -> Result<()> {
    ensure!(
        transaction_version <= ledger_info.version(),
        "Transaction version {} is newer than LedgerInfo version {}.",
        transaction_version,
        ledger_info.version(),
    );

    let transaction_info_hash = transaction_info.hash();
    ledger_info_to_transaction_info_proof.verify(
        ledger_info.transaction_accumulator_hash(),
        transaction_info_hash,
        transaction_version,
    )?;

    Ok(())
}
```

**File:** types/src/epoch_state.rs (L41-49)
```rust
    fn verify(&self, ledger_info: &LedgerInfoWithSignatures) -> anyhow::Result<()> {
        ensure!(
            self.epoch == ledger_info.ledger_info().epoch(),
            "LedgerInfo has unexpected epoch {}, expected {}",
            ledger_info.ledger_info().epoch(),
            self.epoch
        );
        ledger_info.verify_signatures(&self.verifier)?;
        Ok(())
```

**File:** storage/backup/backup-cli/src/utils/mod.rs (L341-343)
```rust
        N.B. LedgerInfos are verified only when restoring / verifying the epoch ending backups, \
        i.e. they are NOT checked at all when doing one-shot restoring of the transaction \
        and state backups."
```

**File:** storage/backup/backup-cli/src/coordinators/restore.rs (L219-231)
```rust
        let epoch_history = if !self.skip_epoch_endings {
            Some(Arc::new(
                EpochHistoryRestoreController::new(
                    epoch_handles,
                    self.global_opt.clone(),
                    self.storage.clone(),
                )
                .run()
                .await?,
            ))
        } else {
            None
        };
```
