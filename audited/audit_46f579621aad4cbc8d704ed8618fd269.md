# Audit Report

## Title
Batch Filter Bypass Due to BatchInfoExt Variant Mismatch Allowing Transaction Duplication

## Summary
When the `enable_batch_v2` configuration flag is enabled, batches stored as `BatchInfoExt::V2` in the quorum store can bypass the `PayloadFilter` due to a variant mismatch during filter extraction. This allows the same batch (and its transactions) to be included multiple times across different blocks, violating the consensus filtering invariant that pending transactions should be excluded from new proposals.

## Finding Description

The vulnerability exists in the filter creation and comparison logic for the quorum store's batch exclusion mechanism. The root cause is a type conversion mismatch that occurs through the following sequence:

**Stage 1: Batch Creation with V2 Variant**
When `enable_batch_v2 = true`, batches are created and stored in the quorum store as `BatchInfoExt::V2` (containing both `BatchInfo` and `ExtraBatchInfo`). [1](#0-0) 

**Stage 2: Payload Construction Strips Variant Information**
When creating block payloads in `ProofManager::handle_proposal_request`, all `BatchInfoExt` instances (whether V1 or V2) are converted to plain `BatchInfo` by calling `.info().clone()`, which extracts only the inner `BatchInfo` and discards the variant wrapper. [2](#0-1) 

This conversion happens for all payload types (`QuorumStoreInlineHybrid`, `QuorumStoreInlineHybridV2`, and `OptQuorumStore`), as they all use `BatchInfo` rather than `BatchInfoExt` in their type definitions. [3](#0-2) 

**Stage 3: Filter Creation Always Produces V1 Variants**
When extracting the `PayloadFilter` from pending blocks to exclude already-proposed batches, the filter creation code converts `BatchInfo` back to `BatchInfoExt` using the `.into()` method. However, this conversion **always** creates `BatchInfoExt::V1` variants, regardless of how the batch was originally created. [4](#0-3) [5](#0-4) 

**Stage 4: Filter Check Fails Due to Variant Inequality**
The filter is applied in `BatchProofQueue::pull_internal` by checking if a batch exists in the `excluded_batches` HashSet. Since `BatchInfoExt` derives `PartialEq`, `Eq`, and `Hash`, the comparison is structural and includes the enum variant tag. [6](#0-5) [7](#0-6) 

When comparing `BatchInfoExt::V1 { info: X }` (from the filter) against `BatchInfoExt::V2 { info: X, extra: Y }` (from the quorum store), they are **not equal** even though they represent the same underlying batch with identical `BatchInfo`.

**Attack Scenario:**
1. Node has `enable_batch_v2 = true` configured
2. Node creates Batch X as `BatchInfoExt::V2 { info: BatchInfo {...}, extra: ExtraBatchInfo {...} }`
3. Batch X is stored in the quorum store as `BatchInfoExt::V2`
4. Batch X is included in a block proposal (any payload type: QuorumStoreInlineHybrid, OptQuorumStore, etc.)
5. During payload construction, the batch info is converted to plain `BatchInfo` (line 191, 195, or 201 in proof_manager.rs)
6. Block is propagated and committed
7. Node creates the next proposal and extracts the filter from pending blocks
8. Filter extraction converts the pending block's `BatchInfo` back to `BatchInfoExt::V1` (lines 805, 808 in common.rs)
9. When pulling from the quorum store, Batch X is still stored as `BatchInfoExt::V2`
10. Filter check: `excluded_batches.contains(&BatchInfoExt::V2{...})` with filter containing `BatchInfoExt::V1{...}`
11. **Check returns false** - batch is NOT excluded!
12. Batch X (with all its transactions) is included again in the new block
13. Same transactions appear in multiple blocks, violating consensus filtering rules

## Impact Explanation

This is a **HIGH severity** consensus violation that breaks the fundamental invariant that pending transactions must be excluded from new proposals. The impact includes:

1. **Transaction Duplication**: The same transactions can be included in multiple blocks, potentially causing:
   - Double execution of state transitions
   - Incorrect balance updates if execution is not idempotent
   - Gas fee duplication (users charged multiple times)

2. **Consensus State Inconsistency**: Different validators may have different views of which batches should be excluded, leading to:
   - Block proposal rejections
   - Validation failures
   - Potential consensus liveness issues

3. **Deterministic Execution Violation**: If the same transactions execute multiple times with different outcomes (due to changed state), validators will compute different state roots, breaking consensus safety.

4. **Protocol Integrity**: The filtering mechanism is a core consensus invariant designed to prevent resource exhaustion and ensure efficiency. Bypassing it undermines protocol guarantees.

Per the Aptos bug bounty program, this qualifies as **High Severity** due to being a "Significant protocol violation" that affects consensus filtering rules and can lead to state inconsistencies.

## Likelihood Explanation

**Likelihood: HIGH**

This vulnerability will occur **automatically and deterministically** on any node where:
1. `enable_batch_v2 = true` is configured in the quorum store settings
2. The node creates and proposes at least one batch
3. That batch is committed in a block
4. The node subsequently proposes another block

No attacker action is required - this is a logic bug in the normal operation of the consensus protocol when the V2 batch feature is enabled. Given that `enable_batch_v2` is a configurable flag that operators may enable to test or use new features, the likelihood of encountering this bug in production is high.

The vulnerability requires no special privileges, no malicious behavior, and no complex attack setup. It manifests during routine consensus operation.

## Recommendation

The root cause is that filter comparison uses the full `BatchInfoExt` enum (including variant), but payload construction strips the variant information, and filter creation always produces V1 variants. The fix should ensure consistent comparison semantics.

**Option 1: Normalize Filter Entries (Recommended)**
Modify the filter extraction logic to normalize all `BatchInfoExt` instances to V1 before insertion, ensuring consistency:

```rust
// In consensus/consensus-types/src/common.rs, lines 814-835
Payload::OptQuorumStore(OptQuorumStorePayload::V1(p)) => {
    for batch in p.inline_batches().iter() {
        // Extract inner BatchInfo, then convert to V1
        exclude_batches.insert(batch.info().clone().into());
    }
    for batch_info in &p.opt_batches().batch_summary {
        exclude_batches.insert(batch_info.clone().into());
    }
    for proof in &p.proof_with_data().batch_summary {
        exclude_batches.insert(proof.info().clone().into());
    }
},
Payload::OptQuorumStore(OptQuorumStorePayload::V2(p)) => {
    for batch in p.inline_batches().iter() {
        // CHANGED: Extract inner BatchInfo first, then convert to V1
        exclude_batches.insert(batch.info().as_batch_info().clone().into());
    }
    for batch_info in &p.opt_batches().batch_summary {
        // CHANGED: Extract inner BatchInfo first
        exclude_batches.insert(batch_info.as_batch_info().clone().into());
    }
    for proof in &p.proof_with_data().batch_summary {
        // CHANGED: Extract inner BatchInfo first
        exclude_batches.insert(proof.info().as_batch_info().clone().into());
    }
},
```

**Option 2: Comparison Based on Inner BatchInfo**
Implement custom `PartialEq` and `Hash` for `BatchInfoExt` that only compares the inner `BatchInfo`, ignoring the variant:

```rust
// In consensus/consensus-types/src/proof_of_store.rs
impl PartialEq for BatchInfoExt {
    fn eq(&self, other: &Self) -> bool {
        self.info() == other.info()  // Compare only inner BatchInfo
    }
}

impl Hash for BatchInfoExt {
    fn hash<H: Hasher>(&self, state: &mut H) {
        self.info().hash(state);  // Hash only inner BatchInfo
    }
}
```

However, this changes the semantics globally and may have unintended side effects.

**Option 3: Normalize Quorum Store Storage**
Ensure the quorum store always normalizes batches to V1 when storing them, maintaining variant consistency across the system.

## Proof of Concept

```rust
// Test demonstrating the variant mismatch
// Add to consensus/consensus-types/src/proof_of_store.rs

#[cfg(test)]
mod batch_info_variant_mismatch_test {
    use super::*;
    use aptos_types::{quorum_store::BatchId, PeerId};
    use aptos_crypto::HashValue;
    use std::collections::HashSet;

    #[test]
    fn test_batch_info_ext_variant_inequality() {
        // Create a BatchInfo representing a batch
        let batch_info = BatchInfo::new(
            PeerId::random(),
            BatchId::new(1),
            1, // epoch
            1000, // expiration
            HashValue::random(),
            10, // num_txns
            1024, // num_bytes
            0, // gas_bucket_start
        );

        // Scenario 1: Batch stored as V2 in quorum store
        let batch_v2 = BatchInfoExt::V2 {
            info: batch_info.clone(),
            extra: ExtraBatchInfo {
                batch_kind: BatchKind::Normal,
            },
        };

        // Scenario 2: Filter creates V1 from BatchInfo (via .into())
        let batch_v1_from_filter: BatchInfoExt = batch_info.clone().into();

        // Verify they have the same inner BatchInfo
        assert_eq!(batch_v2.info(), batch_v1_from_filter.info());
        assert_eq!(batch_v2.as_batch_info(), batch_v1_from_filter.as_batch_info());

        // But the variants themselves are NOT equal!
        assert_ne!(batch_v2, batch_v1_from_filter);

        // Demonstrate filter bypass
        let mut excluded_batches = HashSet::new();
        excluded_batches.insert(batch_v1_from_filter); // Filter has V1

        // Check if V2 batch from quorum store is in the filter
        assert!(!excluded_batches.contains(&batch_v2)); // FAILS TO EXCLUDE!

        println!("❌ VULNERABILITY CONFIRMED:");
        println!("   Batch V2 from quorum store: {:?}", batch_v2);
        println!("   Batch V1 from filter: {:?}", excluded_batches.iter().next().unwrap());
        println!("   Filter contains V2? {}", excluded_batches.contains(&batch_v2));
        println!("   Same inner BatchInfo? {}", batch_v2.info() == batch_v1_from_filter.info());
    }
}
```

**Expected Output:**
```
❌ VULNERABILITY CONFIRMED:
   Batch V2 from quorum store: V2 { info: BatchInfo(...), extra: ExtraBatchInfo(...) }
   Batch V1 from filter: V1 { info: BatchInfo(...) }
   Filter contains V2? false
   Same inner BatchInfo? true
```

This demonstrates that two `BatchInfoExt` instances with identical underlying `BatchInfo` but different variants (V1 vs V2) are not considered equal, causing the filter to fail at excluding batches that should be excluded.

## Notes

This vulnerability demonstrates a subtle type system issue where the abstraction boundary between `BatchInfo` and `BatchInfoExt` is violated during payload serialization/deserialization. The use of enum variants to version batch metadata is sound, but the inconsistent handling during filter operations creates an exploitable gap.

The issue is particularly insidious because:
1. It requires no malicious input - it's a logic error in normal operation
2. It only manifests when the `enable_batch_v2` feature is enabled
3. The same-named types (`BatchInfo` vs `BatchInfoExt`) make the conversion easy to overlook
4. The filter appears to work correctly for V1-only systems

The recommended fix (Option 1) ensures filter extraction always normalizes to a canonical form, preventing variant mismatches during comparison.

### Citations

**File:** consensus/src/quorum_store/batch_generator.rs (L190-211)
```rust
        if self.config.enable_batch_v2 {
            // TODO(ibalajiarun): Specify accurate batch kind
            let batch_kind = BatchKind::Normal;
            Batch::new_v2(
                batch_id,
                txns,
                self.epoch,
                expiry_time,
                self.my_peer_id,
                bucket_start,
                batch_kind,
            )
        } else {
            Batch::new_v1(
                batch_id,
                txns,
                self.epoch,
                expiry_time,
                self.my_peer_id,
                bucket_start,
            )
        }
```

**File:** consensus/src/quorum_store/proof_manager.rs (L188-203)
```rust
        // TODO(ibalajiarun): Avoid clones
        let inline_block: Vec<_> = inline_block
            .into_iter()
            .map(|(info, txns)| (info.info().clone(), txns))
            .collect();
        let opt_batches: Vec<_> = opt_batches
            .into_iter()
            .map(|info| info.info().clone())
            .collect();
        let proof_block: Vec<_> = proof_block
            .into_iter()
            .map(|proof| {
                let (info, sig) = proof.unpack();
                ProofOfStore::new(info.info().clone(), sig)
            })
            .collect();
```

**File:** consensus/consensus-types/src/common.rs (L209-224)
```rust
pub enum Payload {
    DirectMempool(Vec<SignedTransaction>),
    InQuorumStore(ProofWithData),
    InQuorumStoreWithLimit(ProofWithDataWithTxnLimit),
    QuorumStoreInlineHybrid(
        Vec<(BatchInfo, Vec<SignedTransaction>)>,
        ProofWithData,
        Option<u64>,
    ),
    OptQuorumStore(OptQuorumStorePayload),
    QuorumStoreInlineHybridV2(
        Vec<(BatchInfo, Vec<SignedTransaction>)>,
        ProofWithData,
        PayloadExecutionLimit,
    ),
}
```

**File:** consensus/consensus-types/src/common.rs (L802-810)
```rust
                    Payload::QuorumStoreInlineHybrid(inline_batches, proof_with_data, _)
                    | Payload::QuorumStoreInlineHybridV2(inline_batches, proof_with_data, _) => {
                        for proof in &proof_with_data.proofs {
                            exclude_batches.insert(proof.info().clone().into());
                        }
                        for (batch_info, _) in inline_batches {
                            exclude_batches.insert(batch_info.clone().into());
                        }
                    },
```

**File:** consensus/consensus-types/src/proof_of_store.rs (L120-124)
```rust
impl From<BatchInfo> for BatchInfoExt {
    fn from(info: BatchInfo) -> Self {
        Self::V1 { info }
    }
}
```

**File:** consensus/consensus-types/src/proof_of_store.rs (L192-203)
```rust
#[derive(
    Clone, Debug, Deserialize, Serialize, CryptoHasher, BCSCryptoHash, PartialEq, Eq, Hash,
)]
pub enum BatchInfoExt {
    V1 {
        info: BatchInfo,
    },
    V2 {
        info: BatchInfo,
        extra: ExtraBatchInfo,
    },
}
```

**File:** consensus/src/quorum_store/batch_proof_queue.rs (L634-636)
```rust
                    if excluded_batches.contains(batch) {
                        excluded_txns += batch.num_txns();
                    } else {
```
