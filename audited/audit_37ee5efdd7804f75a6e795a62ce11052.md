# Audit Report

## Title
Admin Service Binds to Public Interface (0.0.0.0) by Default, Exposing Sensitive Debug Endpoints

## Summary
The Aptos admin service defaults to binding on all network interfaces (0.0.0.0) instead of localhost only (127.0.0.1), potentially exposing sensitive consensus state, mempool information, and system profiling endpoints to the public internet when operators enable the service without proper firewall configuration.

## Finding Description

The `AdminServiceConfig` struct defines a default binding address of "0.0.0.0" for the admin service [1](#0-0) , which binds the service to all network interfaces rather than restricting it to localhost.

When the admin service starts, it directly binds to this configured address without validation [2](#0-1) .

The admin service exposes highly sensitive debug endpoints including:

1. **Consensus state endpoints** that dump complete consensus database information including votes, timeout certificates, blocks, quorum certificates, and can extract all transactions from blocks [3](#0-2) 

2. **Consensus database dump** revealing last votes, highest timeout certificates, all consensus blocks with their IDs, authors, epochs, rounds, parent IDs, timestamps, payloads, and all QCs [4](#0-3) 

3. **Mempool parking lot addresses** exposing which addresses are being rate-limited [5](#0-4) 

4. **System profiling endpoints** for CPU profiling, thread dumps, and memory statistics [6](#0-5) 

**Authentication Weaknesses:**

On non-mainnet networks (testnet, devnet), the admin service is enabled by default [7](#0-6)  with no authentication required by default [1](#0-0) .

The authentication mechanism has no rate limiting [8](#0-7) , making it vulnerable to brute force attacks if a weak passcode is configured.

**No Validation:**

The codebase contains no validation that warns against or prevents binding to 0.0.0.0. The config sanitizer only checks that authentication is enabled on mainnet, but doesn't validate the binding address [9](#0-8) .

**Attack Scenario:**

1. Operator deploys a testnet or devnet validator/fullnode
2. Admin service is enabled by default on non-mainnet networks
3. Service binds to 0.0.0.0:9102 (all interfaces)
4. Operator misconfigures firewall or runs node with direct internet exposure
5. Attacker discovers open port 9102 via port scanning
6. Attacker accesses `/debug/consensus/consensusdb` without authentication
7. Attacker obtains complete consensus state including voting patterns, blocks, QCs, and transactions
8. Attacker uses `/profilez` or `/threadz` endpoints to cause resource exhaustion

## Impact Explanation

This vulnerability falls under **High Severity** per the Aptos bug bounty program criteria for the following reasons:

1. **Validator Node Slowdowns**: The profiling endpoints (`/profilez`, `/threadz`) can be repeatedly triggered to cause CPU and memory exhaustion, degrading validator performance.

2. **Significant Protocol Violations**: Exposing complete consensus state (votes, quorum certificates, blocks) violates confidentiality assumptions and enables attackers to:
   - Predict validator behavior and consensus rounds
   - Identify which validators are offline or slow to vote
   - Extract unpublished transactions from pending blocks
   - Perform reconnaissance for more sophisticated attacks

3. **Information Disclosure**: The consensus database dump reveals sensitive internal state that should never be publicly accessible, including voting patterns and block construction details.

While this doesn't directly break consensus safety or cause fund loss, it enables attacks that could degrade network performance and violates security principles requiring debug interfaces to be localhost-only.

## Likelihood Explanation

**Likelihood: Medium to High**

This vulnerability is likely to be exploited because:

1. **Default Configuration Flaw**: The insecure default (0.0.0.0) will affect any operator who doesn't explicitly override it.

2. **Testnet/Devnet Auto-Enable**: The admin service is automatically enabled on non-mainnet networks, increasing the attack surface.

3. **No Warning or Validation**: Operators receive no warning that they're binding to a public interface, making accidental exposure likely.

4. **Common Deployment Scenarios**: 
   - Development/testing nodes often have relaxed firewall rules
   - Cloud deployments may expose all ports by default
   - Operators testing on testnet may not realize the security implications

5. **Easy Discovery**: Port 9102 is a known default and easily discoverable via automated scanning.

While Kubernetes deployments have `enableAdminPort: false` by default [10](#0-9) , operators running validators directly or using custom deployment methods will be affected.

## Recommendation

**Immediate Fix**: Change the default binding address to localhost and add validation to prevent binding to public interfaces.

```rust
// In config/src/config/admin_service_config.rs
impl Default for AdminServiceConfig {
    fn default() -> Self {
        Self {
            enabled: None,
            address: "127.0.0.1".to_string(), // Changed from "0.0.0.0"
            port: 9102,
            authentication_configs: vec![],
            malloc_stats_max_len: 2 * 1024 * 1024,
        }
    }
}

// Add validation in the sanitizer
impl ConfigSanitizer for AdminServiceConfig {
    fn sanitize(
        node_config: &NodeConfig,
        _node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();

        if node_config.admin_service.enabled == Some(true) {
            // NEW: Validate binding address
            if node_config.admin_service.address != "127.0.0.1" 
                && node_config.admin_service.address != "localhost" {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    format!(
                        "Admin service must bind to localhost only (127.0.0.1), not {}. Binding to {} exposes sensitive debug endpoints to the network.",
                        node_config.admin_service.address,
                        node_config.admin_service.address
                    ),
                ));
            }

            if let Some(chain_id) = chain_id {
                if chain_id.is_mainnet()
                    && node_config.admin_service.authentication_configs.is_empty()
                {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name,
                        "Must enable authentication for AdminService on mainnet.".into(),
                    ));
                }
            }
        }

        Ok(())
    }
}
```

**Additional Recommendations:**

1. **Add Rate Limiting**: Implement rate limiting on authentication attempts to prevent brute force attacks.

2. **Disable by Default**: Consider disabling the admin service by default even on testnet/devnet, requiring explicit opt-in.

3. **Documentation**: Add prominent warnings in documentation about the security implications of enabling the admin service.

4. **HAProxy Configuration**: For production deployments using HAProxy, ensure the admin backend is only accessible from trusted networks.

## Proof of Concept

**Setup:**
1. Deploy an Aptos testnet validator with default configuration
2. Enable admin service (automatically enabled on testnet)
3. Ensure port 9102 is accessible from the internet (simulating misconfigured firewall)

**Exploitation Steps:**

```bash
# 1. Discover the open admin service port
nmap -p 9102 <target-validator-ip>

# 2. Access consensus database without authentication (testnet/devnet)
curl http://<target-validator-ip>:9102/debug/consensus/consensusdb

# Expected output: Complete dump of consensus state including:
# - Last vote from validator
# - Highest timeout certificate
# - All consensus blocks with IDs, authors, epochs, rounds, parent IDs, timestamps, payloads
# - All quorum certificates (QCs)

# 3. Extract transactions from specific block
curl http://<target-validator-ip>:9102/debug/consensus/block?block_id=<block_hash>

# Expected output: All transactions from the specified block

# 4. Cause resource exhaustion with profiling
curl "http://<target-validator-ip>:9102/profilez?duration=60"

# Expected output: CPU profiling data for 60 seconds
# Side effect: Increased CPU usage on validator node

# 5. Get mempool parking lot addresses
curl http://<target-validator-ip>:9102/debug/mempool/parking-lot/addresses

# Expected output: BCS-encoded list of addresses being rate-limited
```

**Verification:**

The PoC demonstrates that when the admin service is enabled with default configuration (0.0.0.0), all sensitive debug endpoints are accessible without authentication on testnet/devnet networks, and the binding to all interfaces allows remote access from any network location.

---

**Notes:**

While production Kubernetes deployments have protections (disabled by default, HAProxy filtering), the core vulnerability exists in the default configuration itself. Operators using custom deployment methods or running nodes directly are at risk. The combination of insecure default (0.0.0.0), auto-enable on testnet/devnet, and lack of validation creates a significant security gap that violates defense-in-depth principles.

### Citations

**File:** config/src/config/admin_service_config.rs (L41-50)
```rust
impl Default for AdminServiceConfig {
    fn default() -> Self {
        Self {
            enabled: None,
            address: "0.0.0.0".to_string(),
            port: 9102,
            authentication_configs: vec![],
            malloc_stats_max_len: 2 * 1024 * 1024,
        }
    }
```

**File:** config/src/config/admin_service_config.rs (L59-82)
```rust
impl ConfigSanitizer for AdminServiceConfig {
    fn sanitize(
        node_config: &NodeConfig,
        _node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();

        if node_config.admin_service.enabled == Some(true) {
            if let Some(chain_id) = chain_id {
                if chain_id.is_mainnet()
                    && node_config.admin_service.authentication_configs.is_empty()
                {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name,
                        "Must enable authentication for AdminService on mainnet.".into(),
                    ));
                }
            }
        }

        Ok(())
    }
}
```

**File:** config/src/config/admin_service_config.rs (L93-103)
```rust
        if node_config.admin_service.enabled.is_none() {
            // Only enable the admin service if the chain is not mainnet
            let admin_service_enabled = if let Some(chain_id) = chain_id {
                !chain_id.is_mainnet()
            } else {
                false // We cannot determine the chain ID, so we disable the admin service
            };
            node_config.admin_service.enabled = Some(admin_service_enabled);

            modified_config = true; // The config was modified
        }
```

**File:** crates/aptos-admin-service/src/server/mod.rs (L124-140)
```rust
    fn start(&self, address: SocketAddr, enabled: bool) {
        let context = self.context.clone();
        self.runtime.spawn(async move {
            let make_service = make_service_fn(move |_conn| {
                let context = context.clone();
                async move {
                    Ok::<_, Infallible>(service_fn(move |req| {
                        Self::serve_requests(context.clone(), req, enabled)
                    }))
                }
            });

            let server = Server::bind(&address).serve(make_service);
            info!("Started AdminService at {address:?}, enabled: {enabled}.");
            server.await
        });
    }
```

**File:** crates/aptos-admin-service/src/server/mod.rs (L154-181)
```rust
        let mut authenticated = false;
        if context.config.authentication_configs.is_empty() {
            authenticated = true;
        } else {
            for authentication_config in &context.config.authentication_configs {
                match authentication_config {
                    AuthenticationConfig::PasscodeSha256(passcode_sha256) => {
                        let query = req.uri().query().unwrap_or("");
                        let query_pairs: HashMap<_, _> =
                            url::form_urlencoded::parse(query.as_bytes()).collect();
                        let passcode: Option<String> =
                            query_pairs.get("passcode").map(|p| p.to_string());
                        if let Some(passcode) = passcode {
                            if sha256::digest(passcode) == *passcode_sha256 {
                                authenticated = true;
                            }
                        }
                    },
                }
            }
        };

        if !authenticated {
            return Ok(reply_with_status(
                StatusCode::NETWORK_AUTHENTICATION_REQUIRED,
                format!("{} endpoint requires authentication.", req.uri().path()),
            ));
        }
```

**File:** crates/aptos-admin-service/src/server/mod.rs (L184-193)
```rust
            #[cfg(target_os = "linux")]
            (hyper::Method::GET, "/profilez") => handle_cpu_profiling_request(req).await,
            #[cfg(target_os = "linux")]
            (hyper::Method::GET, "/threadz") => handle_thread_dump_request(req).await,
            #[cfg(unix)]
            (hyper::Method::GET, "/malloc/stats") => {
                malloc::handle_malloc_stats_request(context.config.malloc_stats_max_len)
            },
            #[cfg(unix)]
            (hyper::Method::GET, "/malloc/dump_profile") => malloc::handle_dump_profile_request(),
```

**File:** crates/aptos-admin-service/src/server/mod.rs (L194-229)
```rust
            (hyper::Method::GET, "/debug/consensus/consensusdb") => {
                let consensus_db = context.consensus_db.read().clone();
                if let Some(consensus_db) = consensus_db {
                    consensus::handle_dump_consensus_db_request(req, consensus_db).await
                } else {
                    Ok(reply_with_status(
                        StatusCode::NOT_FOUND,
                        "Consensus db is not available.",
                    ))
                }
            },
            (hyper::Method::GET, "/debug/consensus/quorumstoredb") => {
                let quorum_store_db = context.quorum_store_db.read().clone();
                if let Some(quorum_store_db) = quorum_store_db {
                    consensus::handle_dump_quorum_store_db_request(req, quorum_store_db).await
                } else {
                    Ok(reply_with_status(
                        StatusCode::NOT_FOUND,
                        "Quorum store db is not available.",
                    ))
                }
            },
            (hyper::Method::GET, "/debug/consensus/block") => {
                let consensus_db = context.consensus_db.read().clone();
                let quorum_store_db = context.quorum_store_db.read().clone();
                if let Some(consensus_db) = consensus_db
                    && let Some(quorum_store_db) = quorum_store_db
                {
                    consensus::handle_dump_block_request(req, consensus_db, quorum_store_db).await
                } else {
                    Ok(reply_with_status(
                        StatusCode::NOT_FOUND,
                        "Consensus db and/or quorum store db is not available.",
                    ))
                }
            },
```

**File:** crates/aptos-admin-service/src/server/mod.rs (L230-241)
```rust
            (hyper::Method::GET, "/debug/mempool/parking-lot/addresses") => {
                let mempool_client_sender = context.mempool_client_sender.read().clone();
                if let Some(mempool_client_sender) = mempool_client_sender {
                    mempool::mempool_handle_parking_lot_address_request(req, mempool_client_sender)
                        .await
                } else {
                    Ok(reply_with_status(
                        StatusCode::NOT_FOUND,
                        "Mempool parking lot is not available.",
                    ))
                }
            },
```

**File:** crates/aptos-admin-service/src/server/consensus/mod.rs (L130-156)
```rust
fn dump_consensus_db(consensus_db: &dyn PersistentLivenessStorage) -> anyhow::Result<String> {
    let mut body = String::new();

    let (last_vote, highest_tc, consensus_blocks, consensus_qcs) =
        consensus_db.consensus_db().get_data()?;

    body.push_str(&format!("Last vote: \n{last_vote:?}\n\n"));
    body.push_str(&format!("Highest tc: \n{highest_tc:?}\n\n"));
    body.push_str("Blocks: \n");
    for block in consensus_blocks {
        body.push_str(&format!(
            "[id: {:?}, author: {:?}, epoch: {}, round: {:02}, parent_id: {:?}, timestamp: {}, payload: {:?}]\n\n",
            block.id(),
            block.author(),
            block.epoch(),
            block.round(),
            block.parent_id(),
            block.timestamp_usecs(),
            block.payload(),
        ));
    }
    body.push_str("QCs: \n");
    for qc in consensus_qcs {
        body.push_str(&format!("{qc:?}\n\n"));
    }
    Ok(body)
}
```

**File:** terraform/helm/aptos-node/values.yaml (L159-159)
```yaml
    enableAdminPort: false
```
