# Audit Report

## Title
DKG Range Proof Verification Panic Due to Missing Length Validation Causes Validator Node Crashes

## Summary
The `verify()` function in the DeKART univariate range proof implementation fails to validate that proof vector lengths match the expected `ell` parameter before performing multi-scalar multiplication (MSM) operations. A malicious validator can craft a DKG transcript with mismatched vector lengths, causing verifying validators to panic and crash during consensus execution.

## Finding Description

The range proof verification function uses `.expect()` on MSM operations without validating input vector lengths, violating the principle that verification should return errors rather than panic. [1](#0-0) 

The `Proof` struct contains vectors `c` and `c_hat` that should have length `ell`, but this constraint is not enforced during deserialization (which uses derived `CanonicalDeserialize`) or before verification. [2](#0-1) 

At line 580, MSM is called with `&self.c` (arbitrary length from untrusted proof) and `&vk.powers_of_two[..ell]` (length `ell`). If these lengths don't match, the arkworks MSM implementation returns an error, which triggers the panic via `.expect()`.

The codebase shows that length mismatches in MSM are explicitly checked elsewhere: [3](#0-2) 

**Attack Path:**
1. Malicious validator creates DKG transcript during distributed key generation
2. Range proof is constructed with `c.len() != ell` or `c_hat.len() != ell`
3. Transcript is serialized and submitted as part of DKG protocol
4. Other validators deserialize the transcript successfully (no length checks)
5. VM processes DKG transcript via validator transaction [4](#0-3) 

6. Transcript verification calls range proof verification [5](#0-4) 

7. MSM at line 580 fails due to length mismatch → `.expect()` panics → validator node crashes

Additional panic points exist at lines 601, 605, and 617 for similar reasons. [6](#0-5) 

## Impact Explanation

**Severity: High**

This vulnerability enables a **denial-of-service attack on the validator network**:

- **Validator Node Crashes**: Each validator processing the malicious transcript will panic and crash
- **Consensus Disruption**: If enough validators crash, the network loses liveness
- **Deterministic Failure**: All honest validators will crash identically when processing the same malicious transcript
- **Byzantine Fault Tolerance Violation**: A single malicious validator (< 1/3 Byzantine threshold) can crash honest validators

Per Aptos bug bounty criteria:
- **High Severity** applies: "Validator node slowdowns, API crashes, Significant protocol violations"
- The impact includes both node crashes and protocol violations (broken consensus invariants)

This breaks the **Consensus Safety** invariant (AptosBFT must maintain liveness under < 1/3 Byzantine validators) and **Deterministic Execution** invariant (panics cause non-deterministic state transitions).

## Likelihood Explanation

**Likelihood: High**

- **Low Attacker Requirements**: Any validator can submit DKG transcripts as part of normal operations
- **Simple Exploitation**: Creating a proof with wrong vector lengths is trivial - just modify `c` or `c_hat` length before serialization
- **No Detection**: The vulnerability lies in core cryptographic verification code with no upstream validation
- **Guaranteed Success**: The attack deterministically crashes all verifying validators
- **Active Attack Surface**: DKG runs during epoch transitions, providing regular opportunities

The only requirement is validator status, which is not an "insider threat" but a normal network participant role.

## Recommendation

Add explicit length validation before performing cryptographic operations:

```rust
fn verify(
    &self,
    vk: &Self::VerificationKey,
    n: usize,
    ell: usize,
    comm: &Self::Commitment,
) -> anyhow::Result<()> {
    let mut fs_t = merlin::Transcript::new(Self::DST);

    ensure!(
        ell <= vk.max_ell,
        "ell (got {}) must be ≤ max_ell (which is {})",
        ell,
        vk.max_ell
    );

    // ADD THESE CHECKS:
    ensure!(
        self.c.len() == ell,
        "proof c length (got {}) must equal ell (expected {})",
        self.c.len(),
        ell
    );
    ensure!(
        self.c_hat.len() == ell,
        "proof c_hat length (got {}) must equal ell (expected {})",
        self.c_hat.len(),
        ell
    );

    let commitment_recomputed: E::G1 =
        VariableBaseMSM::msm(&self.c, &vk.powers_of_two[..ell])
            .context("MSM computation failed")?; // Also change .expect() to ?
    
    // ... rest of verification
}
```

Additionally, consider implementing custom `CanonicalDeserialize` to enforce constraints at deserialization time, similar to patterns in `dekart_univariate_v2.rs`.

## Proof of Concept

```rust
#[cfg(test)]
mod test_malformed_proof {
    use super::*;
    use aptos_crypto::arkworks::GroupGenerators;
    use ark_bls12_381::Bls12_381;
    use rand::thread_rng;

    #[test]
    #[should_panic(expected = "Failed to compute msm")]
    fn test_proof_with_wrong_c_length_causes_panic() {
        type E = Bls12_381;
        let mut rng = thread_rng();
        let group_gens = GroupGenerators::<E>::new();
        
        // Setup with ell=4
        let (pk, vk) = Proof::<E>::setup(10, 4, group_gens, &mut rng);
        
        // Create valid proof
        let values: Vec<_> = (0..5).map(|_| E::ScalarField::from(42u64)).collect();
        let r = Scalar(E::ScalarField::from(123u64));
        let comm = Proof::<E>::commit_with_randomness(&pk, &values, &r);
        let mut proof = Proof::<E>::prove(&pk, &values, 4, &comm, &r, &mut rng);
        
        // Maliciously modify proof to have wrong length
        proof.c.truncate(2); // Make c length = 2 instead of 4
        
        // This will panic with "Failed to compute msm"
        proof.verify(&vk, 5, 4, &comm).unwrap();
    }

    #[test]
    fn test_proof_with_correct_length_succeeds() {
        type E = Bls12_381;
        let mut rng = thread_rng();
        let group_gens = GroupGenerators::<E>::new();
        
        let (pk, vk) = Proof::<E>::setup(10, 4, group_gens, &mut rng);
        let values: Vec<_> = (0..5).map(|_| E::ScalarField::from(42u64)).collect();
        let r = Scalar(E::ScalarField::from(123u64));
        let comm = Proof::<E>::commit_with_randomness(&pk, &values, &r);
        let proof = Proof::<E>::prove(&pk, &values, 4, &comm, &r, &mut rng);
        
        // Valid proof should verify without panic
        assert!(proof.verify(&vk, 5, 4, &comm).is_ok());
    }
}
```

This PoC demonstrates that a proof with mismatched vector length causes a panic during verification, confirming the vulnerability. In a real attack, this malformed proof would be embedded in a DKG transcript and cause all verifying validators to crash.

### Citations

**File:** crates/aptos-dkg/src/range_proofs/dekart_univariate.rs (L31-36)
```rust
#[derive(CanonicalSerialize, CanonicalDeserialize, Debug, Clone, PartialEq, Eq)]
pub struct Proof<E: Pairing> {
    d: E::G1,                // commitment to h(X) = \sum_{j=0}^{\ell-1} beta_j h_j(X)
    c: Vec<E::G1Affine>,     // of size \ell
    c_hat: Vec<E::G2Affine>, // of size \ell
}
```

**File:** crates/aptos-dkg/src/range_proofs/dekart_univariate.rs (L564-582)
```rust
    fn verify(
        &self,
        vk: &Self::VerificationKey,
        n: usize,
        ell: usize,
        comm: &Self::Commitment,
    ) -> anyhow::Result<()> {
        let mut fs_t = merlin::Transcript::new(Self::DST);

        assert!(
            ell <= vk.max_ell,
            "ell (got {}) must be ≤ max_ell (which is {})",
            ell,
            vk.max_ell
        );

        let commitment_recomputed: E::G1 =
            VariableBaseMSM::msm(&self.c, &vk.powers_of_two[..ell]).expect("Failed to compute msm");
        ensure!(comm.0 == commitment_recomputed);
```

**File:** crates/aptos-dkg/src/range_proofs/dekart_univariate.rs (L598-617)
```rust
        // Verify h(\tau)
        let h_check = E::multi_pairing(
            (0..ell)
                .map(|j| self.c[j] * betas[j]) // E::G1
                .chain(once(-self.d)) // add -d
                .collect::<Vec<_>>(), // collect into Vec<E::G1>
            (0..ell)
                .map(|j| self.c_hat[j] - vk.tau_2) // E::G2
                .chain(once(vk.vanishing_com)) // add vanishing commitment
                .collect::<Vec<_>>(), // collect into Vec<E::G2>
        );
        ensure!(PairingOutput::<E>::ZERO == h_check);

        // Ensure duality: c[j] matches c_hat[j].

        // Compute MSM in G1: sum_j (alphas[j] * proof.c[j])
        let g1_comb = VariableBaseMSM::msm(&self.c, &alphas).unwrap();

        // Compute MSM in G2: sum_j (alphas[j] * proof.c_hat[j])
        let g2_comb = VariableBaseMSM::msm(&self.c_hat, &alphas).unwrap();
```

**File:** aptos-move/framework/src/natives/cryptography/algebra/arithmetics/scalar_mul.rs (L199-205)
```rust
        let num_elements = element_handles.len();
        let num_scalars = scalar_handles.len();
        if num_elements != num_scalars {
            return Err(SafeNativeError::Abort {
                abort_code: MOVE_ABORT_CODE_INPUT_VECTOR_SIZES_NOT_MATCHING,
            });
        }
```

**File:** aptos-move/aptos-vm/src/validator_txns/dkg.rs (L104-112)
```rust
        // Deserialize transcript and verify it.
        let pub_params = DefaultDKG::new_public_params(&in_progress_session_state.metadata);
        let transcript = bcs::from_bytes::<<DefaultDKG as DKGTrait>::Transcript>(
            dkg_node.transcript_bytes.as_slice(),
        )
        .map_err(|_| Expected(TranscriptDeserializationFailed))?;

        DefaultDKG::verify_transcript(&pub_params, &transcript)
            .map_err(|_| Expected(TranscriptVerificationFailed))?;
```

**File:** crates/aptos-dkg/src/pvss/chunky/weighted_transcript.rs (L192-200)
```rust
            // Verify the range proof
            if let Err(err) = self.sharing_proof.range_proof.verify(
                &pp.pk_range_proof.vk,
                sc.get_total_weight() * num_chunks_per_scalar::<E::ScalarField>(pp.ell) as usize,
                pp.ell as usize,
                &self.sharing_proof.range_proof_commitment,
            ) {
                bail!("Range proof batch verification failed: {:?}", err);
            }
```
