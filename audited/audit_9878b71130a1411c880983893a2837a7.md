# Audit Report

## Title
Genesis Vesting Schedule Configuration Bypass via Missing Timestamp Validation

## Summary
The genesis configuration process lacks validation for `employee_vesting_start` timestamps, allowing vesting schedules to be created with past timestamps. This enables immediate unlocking of all vested tokens by repeatedly calling `vest()`, completely bypassing the intended multi-year vesting mechanism.

## Finding Description
The vulnerability exists in a critical gap between genesis timestamp initialization and vesting schedule validation:

**Step 1: Genesis Timestamp Initialization** [1](#0-0) 

During genesis, the blockchain timestamp is initialized to 0 microseconds.

**Step 2: Missing Configuration Validation** [2](#0-1) 

The `validate_genesis_config` function performs various sanity checks but **completely omits validation** of `employee_vesting_start` and `employee_vesting_period_duration` fields.

**Step 3: Vesting Schedule Creation During Genesis** [3](#0-2) 

Employee vesting accounts are created with the unchecked `employee_vesting_start` parameter.

**Step 4: Weak Temporal Check** [4](#0-3) 

The vesting schedule creation only validates that `start_timestamp_secs >= timestamp::now_seconds()`. Since genesis timestamp is 0, any value ≥ 0 passes validation.

**Step 5: Exploitation via vest() Function** [5](#0-4) 

After genesis completes and blockchain time advances to actual Unix time (e.g., 1700000000+ for year 2023), if `employee_vesting_start` was set to 0 or a small value, the calculation at line 695-696 shows thousands of completed periods. An attacker can call `vest()` repeatedly (once per period) to unlock all tokens immediately.

**Attack Scenario:**
1. Genesis configuration sets `employee_vesting_start: 0` (either maliciously or through misconfiguration)
2. Vesting period is 2592000 seconds (30 days)
3. Blockchain starts at Unix timestamp 1700000000 (Nov 2023)
4. Completed periods = 1700000000 / 2592000 = 655,864 periods
5. Attacker calls `vest()` repeatedly until all tokens are unlocked
6. Calls `distribute()` to withdraw tokens immediately [6](#0-5) 

The configuration structure shows these are optional fields loaded from YAML without validation.

## Impact Explanation
**High Severity** - This violates the vesting security guarantee and can result in:
- Immediate access to tokens meant to vest over multiple years
- Loss of employee retention mechanism
- Potential market impact from premature token distribution
- Violation of investor/regulatory vesting commitments

While this requires access to genesis configuration (typically a trusted role), it represents a **critical configuration vulnerability** that could occur through:
- Human error in genesis setup
- Copy-paste errors from test configurations
- Automated script mistakes
- Supply chain attacks on genesis tooling

The vulnerability is **exploitable post-genesis** by any employee with a misconfigured vesting contract, making it a **runtime security issue** stemming from configuration-time validation failures.

## Likelihood Explanation
**Medium Likelihood** - While genesis setup is typically performed by trusted Aptos core developers, the complete absence of validation makes configuration errors highly likely in real-world deployment scenarios. The complexity of coordinating mainnet genesis with multiple teams increases the probability of timestamp configuration mistakes.

## Recommendation
Add mandatory validation in the genesis configuration process:

```rust
fn validate_genesis_config(genesis_config: &GenesisConfiguration) {
    // Existing validations...
    
    // Add vesting schedule validation
    let current_time = std::time::SystemTime::now()
        .duration_since(std::time::UNIX_EPOCH)
        .expect("Time went backwards")
        .as_secs();
    
    assert!(
        genesis_config.employee_vesting_start > current_time,
        "Employee vesting start time must be in the future (got {}, current time {})",
        genesis_config.employee_vesting_start,
        current_time
    );
    
    assert!(
        genesis_config.employee_vesting_period_duration > 0,
        "Employee vesting period duration must be > 0"
    );
    
    // Ensure vesting start is reasonable (e.g., within 1 year of now)
    const ONE_YEAR_SECS: u64 = 365 * 24 * 60 * 60;
    assert!(
        genesis_config.employee_vesting_start < current_time + ONE_YEAR_SECS,
        "Employee vesting start time is too far in the future (max 1 year)"
    );
}
```

## Proof of Concept
```move
#[test(aptos_framework = @0x1, employee = @0x100)]
fun test_vesting_schedule_bypass(aptos_framework: signer, employee: signer) {
    // Setup genesis with timestamp = 0
    timestamp::set_time_has_started_for_testing(&aptos_framework);
    
    // Create vesting schedule with start_time = 0 (passes validation during genesis)
    let schedule = vector[
        fixed_point32::create_from_rational(1, 48),
    ];
    let vesting_schedule = vesting::create_vesting_schedule(
        schedule,
        0,  // ← Malicious/misconfigured start time
        2592000,  // 30 days period
    );
    
    // Fast-forward to actual blockchain time (e.g., Nov 2023)
    timestamp::update_global_time_for_test_secs(1700000000);
    
    // Now thousands of periods have "completed"
    // Call vest() repeatedly to unlock all tokens immediately
    let i = 0;
    while (i < 100) {  // Unlock 100 periods at once
        vesting::vest(contract_address);
        i = i + 1;
    };
    
    // All tokens now unlocked, bypassing multi-year vesting
    vesting::distribute(contract_address);
}
```

### Citations

**File:** aptos-move/framework/aptos-framework/sources/timestamp.move (L25-29)
```text
    public(friend) fun set_time_has_started(aptos_framework: &signer) {
        system_addresses::assert_aptos_framework(aptos_framework);
        let timer = CurrentTimeMicroseconds { microseconds: 0 };
        move_to(aptos_framework, timer);
    }
```

**File:** aptos-move/vm-genesis/src/lib.rs (L405-439)
```rust
fn validate_genesis_config(genesis_config: &GenesisConfiguration) {
    assert!(
        genesis_config.min_stake <= genesis_config.max_stake,
        "Min stake must be smaller than or equal to max stake"
    );
    assert!(
        genesis_config.epoch_duration_secs > 0,
        "Epoch duration must be > 0"
    );
    assert!(
        genesis_config.recurring_lockup_duration_secs > 0,
        "Recurring lockup duration must be > 0"
    );
    assert!(
        genesis_config.recurring_lockup_duration_secs >= genesis_config.epoch_duration_secs,
        "Recurring lockup duration must be at least as long as epoch duration"
    );
    assert!(
        genesis_config.rewards_apy_percentage > 0 && genesis_config.rewards_apy_percentage < 100,
        "Rewards APY must be > 0% and < 100%"
    );
    assert!(
        genesis_config.voting_duration_secs > 0,
        "On-chain voting duration must be > 0"
    );
    assert!(
        genesis_config.voting_duration_secs < genesis_config.recurring_lockup_duration_secs,
        "Voting duration must be strictly smaller than recurring lockup"
    );
    assert!(
        genesis_config.voting_power_increase_limit > 0
            && genesis_config.voting_power_increase_limit <= 50,
        "voting_power_increase_limit must be > 0 and <= 50"
    );
}
```

**File:** aptos-move/framework/aptos-framework/sources/genesis.move (L209-255)
```text
    fun create_employee_validators(
        employee_vesting_start: u64,
        employee_vesting_period_duration: u64,
        employees: vector<EmployeeAccountMap>,
    ) {
        let unique_accounts = vector::empty();

        vector::for_each_ref(&employees, |employee_group| {
            let j = 0;
            let employee_group: &EmployeeAccountMap = employee_group;
            let num_employees_in_group = vector::length(&employee_group.accounts);

            let buy_ins = simple_map::create();

            while (j < num_employees_in_group) {
                let account = vector::borrow(&employee_group.accounts, j);
                assert!(
                    !vector::contains(&unique_accounts, account),
                    error::already_exists(EDUPLICATE_ACCOUNT),
                );
                vector::push_back(&mut unique_accounts, *account);

                let employee = create_signer(*account);
                let total = coin::balance<AptosCoin>(*account);
                let coins = coin::withdraw<AptosCoin>(&employee, total);
                simple_map::add(&mut buy_ins, *account, coins);

                j = j + 1;
            };

            let j = 0;
            let num_vesting_events = vector::length(&employee_group.vesting_schedule_numerator);
            let schedule = vector::empty();

            while (j < num_vesting_events) {
                let numerator = vector::borrow(&employee_group.vesting_schedule_numerator, j);
                let event = fixed_point32::create_from_rational(*numerator, employee_group.vesting_schedule_denominator);
                vector::push_back(&mut schedule, event);

                j = j + 1;
            };

            let vesting_schedule = vesting::create_vesting_schedule(
                schedule,
                employee_vesting_start,
                employee_vesting_period_duration,
            );
```

**File:** aptos-move/framework/aptos-framework/sources/vesting.move (L524-542)
```text
    public fun create_vesting_schedule(
        schedule: vector<FixedPoint32>,
        start_timestamp_secs: u64,
        period_duration: u64,
    ): VestingSchedule {
        assert!(vector::length(&schedule) > 0, error::invalid_argument(EEMPTY_VESTING_SCHEDULE));
        assert!(period_duration > 0, error::invalid_argument(EZERO_VESTING_SCHEDULE_PERIOD));
        assert!(
            start_timestamp_secs >= timestamp::now_seconds(),
            error::invalid_argument(EVESTING_START_TOO_SOON),
        );

        VestingSchedule {
            schedule,
            start_timestamp_secs,
            period_duration,
            last_vested_period: 0,
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/vesting.move (L679-717)
```text
    public entry fun vest(contract_address: address) acquires VestingContract {
        // Unlock all rewards first, if any.
        unlock_rewards(contract_address);

        // Unlock the vested amount. This amount will become withdrawable when the underlying stake pool's lockup
        // expires.
        let vesting_contract = borrow_global_mut<VestingContract>(contract_address);
        // Short-circuit if vesting hasn't started yet.
        if (vesting_contract.vesting_schedule.start_timestamp_secs > timestamp::now_seconds()) {
            return
        };

        // Check if the next vested period has already passed. If not, short-circuit since there's nothing to vest.
        let vesting_schedule = &mut vesting_contract.vesting_schedule;
        let last_vested_period = vesting_schedule.last_vested_period;
        let next_period_to_vest = last_vested_period + 1;
        let last_completed_period =
            (timestamp::now_seconds() - vesting_schedule.start_timestamp_secs) / vesting_schedule.period_duration;
        if (last_completed_period < next_period_to_vest) {
            return
        };

        // Calculate how much has vested, excluding rewards.
        // Index is 0-based while period is 1-based so we need to subtract 1.
        let schedule = &vesting_schedule.schedule;
        let schedule_index = next_period_to_vest - 1;
        let vesting_fraction = if (schedule_index < vector::length(schedule)) {
            *vector::borrow(schedule, schedule_index)
        } else {
            // Last vesting schedule fraction will repeat until the grant runs out.
            *vector::borrow(schedule, vector::length(schedule) - 1)
        };
        let total_grant = pool_u64::total_coins(&vesting_contract.grant_pool);
        let vested_amount = fixed_point32::multiply_u64(total_grant, vesting_fraction);
        // Cap vested amount by the remaining grant amount so we don't try to distribute more than what's remaining.
        vested_amount = min(vested_amount, vesting_contract.remaining_grant);
        vesting_contract.remaining_grant = vesting_contract.remaining_grant - vested_amount;
        vesting_schedule.last_vested_period = next_period_to_vest;
        unlock_stake(vesting_contract, vested_amount);
```

**File:** crates/aptos-genesis/src/config.rs (L68-71)
```rust
    /// Timestamp (in seconds) when employee vesting starts.
    pub employee_vesting_start: Option<u64>,
    /// Duration of each vesting period (in seconds).
    pub employee_vesting_period_duration: Option<u64>,
```
