# Audit Report

## Title
TOCTOU Race in Configuration Check Leading to Protocol Violation During Epoch Transitions

## Summary
A Time-of-Check to Time-of-Use (TOCTOU) race condition exists in `aptos_governance::reconfigure()` where the decision to start DKG is based on stale configuration data. When validator transaction or randomness configs transition from disabled to enabled, the system checks the old configuration but applies the new configuration, resulting in an epoch that has randomness enabled in its configuration but lacks the necessary DKG session to make it functional.

## Finding Description

The vulnerability exists in the reconfiguration flow when on-chain configurations are updated. The function `validator_txn_enabled()` reads from the active global storage configuration [1](#0-0) , but the buffered configuration changes are applied later during the reconfiguration process [2](#0-1) .

In `aptos_governance::reconfigure()`, the code checks whether to start DKG based on the current active configuration [3](#0-2) . If the check returns false (because the old config has validator transactions or randomness disabled), it calls `finish()` without starting DKG. However, `finish()` then applies the buffered configuration [4](#0-3) , which may enable validator transactions and randomness.

**Attack Scenario:**
1. Current epoch: `validator_txn_enabled = false` (or `randomness = false`)
2. Governance proposes and buffers new config: `validator_txn_enabled = true`, `randomness = true`
3. `reconfigure()` is called following the standard pattern documented in the code
4. Check at line 687 reads old config → condition evaluates to `false`
5. `finish()` is called without DKG
6. `consensus_config::on_new_epoch()` applies buffered config → new values become active
7. New epoch starts with `validator_txn_enabled = true`, `randomness = true`
8. Consensus layer attempts to initialize randomness but fails due to missing DKG session [5](#0-4) 
9. Entire epoch runs without randomness despite configuration indicating it should be enabled

This breaks the protocol invariant that configuration accurately reflects system behavior.

## Impact Explanation

This qualifies as **High Severity** under the "Significant protocol violations" category. The on-chain configuration explicitly indicates that validator transactions and randomness are enabled, but the protocol operates in a degraded state without functional randomness for an entire epoch. 

While all validators remain in consistent state (preventing consensus safety issues) and the system auto-recovers at the next epoch transition [6](#0-5) , the protocol violation is significant because:

- Randomness is a critical security feature for the blockchain
- Smart contracts and applications expecting randomness will not receive it
- The configuration misrepresents the actual system state
- Affects all validators network-wide for an entire epoch

## Likelihood Explanation

This issue has **high likelihood** of occurrence because:

1. It can happen during routine governance operations without malicious intent
2. The standard configuration update pattern documented in the code triggers this race [7](#0-6) 
3. No validation prevents buffered configs from differing significantly from active configs
4. Governance participants following documented procedures will inadvertently trigger this

The issue requires no special privileges beyond normal governance access and can occur accidentally whenever configuration transitions enable validator transactions or randomness.

## Recommendation

Modify `aptos_governance::reconfigure()` to check the buffered configuration (if it exists) rather than only the active configuration when deciding whether to start DKG. This ensures the decision aligns with the configuration that will be active in the new epoch.

**Proposed fix approach:**
1. Add a function to peek at buffered configs without extracting them (extend `config_buffer` module)
2. In `reconfigure()`, check if buffered configs exist
3. If buffered configs exist, use their values for the decision
4. If no buffered configs, fall back to current active config

Alternatively, always call `try_start()` when randomness configuration exists, and let the DKG module handle whether to actually start a new session based on current state. This would require refactoring the decision logic.

## Proof of Concept

```move
// Move test demonstrating the TOCTOU race

#[test_only]
module test_account::toctou_test {
    use aptos_framework::consensus_config;
    use aptos_framework::randomness_config;
    use aptos_framework::aptos_governance;
    use std::vector;
    
    #[test(framework = @aptos_framework)]
    fun test_config_toctou_race(framework: &signer) {
        // Setup: Initialize with validator_txn disabled
        let disabled_config = create_disabled_consensus_config();
        consensus_config::initialize(framework, disabled_config);
        
        // Verify initial state
        assert!(!consensus_config::validator_txn_enabled(), 0);
        
        // Governance action: Buffer a config with validator_txn enabled
        let enabled_config = create_enabled_consensus_config();
        consensus_config::set_for_next_epoch(framework, enabled_config);
        
        // Before reconfiguration: validator_txn_enabled() still returns false
        assert!(!consensus_config::validator_txn_enabled(), 1);
        
        // Trigger reconfiguration - this will check old config but apply new config
        aptos_governance::reconfigure(framework);
        
        // After reconfiguration: validator_txn is now enabled
        assert!(consensus_config::validator_txn_enabled(), 2);
        
        // But no DKG was started because the check saw the old config
        // New epoch runs with validator_txn=true but no DKG session
        // This creates the protocol violation
    }
}
```

## Notes

This TOCTOU race is inherent to the current design where configuration checks read active storage while buffered changes are applied later. The issue manifests specifically during configuration transitions that enable features requiring DKG (validator transactions and randomness). The consensus layer properly handles the missing DKG session by failing gracefully [8](#0-7) , preventing consensus safety violations, but the protocol-level inconsistency between configuration and actual behavior remains a significant violation.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/configs/consensus_config.move (L46-51)
```text
    /// This can be called by on-chain governance to update on-chain consensus configs for the next epoch.
    /// Example usage:
    /// ```
    /// aptos_framework::consensus_config::set_for_next_epoch(&framework_signer, some_config_bytes);
    /// aptos_framework::aptos_governance::reconfigure(&framework_signer);
    /// ```
```

**File:** aptos-move/framework/aptos-framework/sources/configs/consensus_config.move (L59-69)
```text
    public(friend) fun on_new_epoch(framework: &signer) acquires ConsensusConfig {
        system_addresses::assert_aptos_framework(framework);
        if (config_buffer::does_exist<ConsensusConfig>()) {
            let new_config = config_buffer::extract_v2<ConsensusConfig>();
            if (exists<ConsensusConfig>(@aptos_framework)) {
                *borrow_global_mut<ConsensusConfig>(@aptos_framework) = new_config;
            } else {
                move_to(framework, new_config);
            };
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/consensus_config.move (L71-74)
```text
    public fun validator_txn_enabled(): bool acquires ConsensusConfig {
        let config_bytes = borrow_global<ConsensusConfig>(@aptos_framework).config;
        validator_txn_enabled_internal(config_bytes)
    }
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L685-692)
```text
    public entry fun reconfigure(aptos_framework: &signer) {
        system_addresses::assert_aptos_framework(aptos_framework);
        if (consensus_config::validator_txn_enabled() && randomness_config::enabled()) {
            reconfiguration_with_dkg::try_start();
        } else {
            reconfiguration_with_dkg::finish(aptos_framework);
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/reconfiguration_with_dkg.move (L46-61)
```text
    public(friend) fun finish(framework: &signer) {
        system_addresses::assert_aptos_framework(framework);
        dkg::try_clear_incomplete_session(framework);
        consensus_config::on_new_epoch(framework);
        execution_config::on_new_epoch(framework);
        gas_schedule::on_new_epoch(framework);
        std::version::on_new_epoch(framework);
        features::on_new_epoch(framework);
        jwk_consensus_config::on_new_epoch(framework);
        jwks::on_new_epoch(framework);
        keyless_account::on_new_epoch(framework);
        randomness_config_seqnum::on_new_epoch(framework);
        randomness_config::on_new_epoch(framework);
        randomness_api_v0_config::on_new_epoch(framework);
        reconfiguration::reconfigure();
    }
```

**File:** consensus/src/epoch_manager.rs (L1031-1033)
```rust
        if !consensus_config.is_vtxn_enabled() {
            return Err(NoRandomnessReason::VTxnDisabled);
        }
```

**File:** consensus/src/epoch_manager.rs (L1039-1045)
```rust
        let dkg_state = maybe_dkg_state.map_err(NoRandomnessReason::DKGStateResourceMissing)?;
        let dkg_session = dkg_state
            .last_completed
            .ok_or_else(|| NoRandomnessReason::DKGCompletedSessionResourceMissing)?;
        if dkg_session.metadata.dealer_epoch + 1 != new_epoch_state.epoch {
            return Err(NoRandomnessReason::CompletedSessionTooOld);
        }
```

**File:** aptos-move/framework/aptos-framework/sources/block.move (L244-246)
```text
        if (timestamp - reconfiguration::last_reconfiguration_time() >= epoch_interval) {
            reconfiguration_with_dkg::try_start();
        };
```
