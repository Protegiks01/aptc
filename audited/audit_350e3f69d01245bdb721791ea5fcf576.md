# Audit Report

## Title
Temporal Inconsistency Between LedgerInfo and Jellyfish Merkle Tree Persistence for Non-Epoch-Ending Blocks

## Summary
The AptosDB commit flow allows `LedgerInfoWithSignatures` to be written to the database for non-epoch-ending blocks before their corresponding Jellyfish Merkle tree nodes are fully persisted. This creates a temporal inconsistency where the ledger claims a version is committed, but the state tree for that version is incomplete, breaking state consistency invariants.

## Finding Description

The vulnerability exists in the two-phase commit process between `pre_commit_ledger` and `commit_ledger`:

**Phase 1 - Asynchronous State Merkle Commit:** [1](#0-0) 

The pre-commit phase calls `pre_commit_ledger` with `sync_commit=false`, which triggers asynchronous Merkle tree node commits via background threads. [2](#0-1) 

The buffered state update uses the condition `sync_commit || chunk.is_reconfig` to determine synchronous vs. asynchronous commits. For non-reconfiguration (non-epoch-ending) blocks with `sync_commit=false`, Merkle nodes are committed asynchronously. [3](#0-2) 

The `enqueue_commit` function sends the commit to a background thread via channel and returns immediately without waiting for completion.

**Phase 2 - LedgerInfo Write Without Verification:** [4](#0-3) 

The critical flaw: `check_and_put_ledger_info` only verifies state snapshot persistence for epoch-ending blocks (`ends_epoch()` check). For non-epoch-ending blocks, the LedgerInfo is written without verifying that the Merkle tree is fully persisted. [5](#0-4) 

Non-epoch-ending LedgerInfos proceed directly to write without the state snapshot check.

**Attack Scenario:**
1. Consensus commits a non-epoch-ending block at version V (e.g., a regular quorum certificate)
2. `pre_commit_block` triggers async Merkle commit for version V
3. `commit_ledger` is immediately called with LedgerInfo for version V
4. Since V is not epoch-ending, no check that state tree exists
5. LedgerInfo for V is written to `LedgerInfoSchema` (keyed by epoch) [6](#0-5) 

6. Node crashes or database is replicated before async Merkle commit completes
7. **Result**: LedgerInfo claims V is committed, but Jellyfish Merkle nodes for V are incomplete

**Evidence of Async Commits:** [7](#0-6) 

State Merkle nodes are committed in background threads, separate from the main commit flow.

## Impact Explanation

**Severity: High** - Significant protocol violation meeting the "State inconsistencies requiring intervention" criterion from the bug bounty program.

**Broken Invariant:** "State Consistency: State transitions must be atomic and verifiable via Merkle proofs"

**Concrete Impact:**
1. **State Query Failures**: Attempts to read state at version V fail because Merkle nodes are missing, breaking API functionality
2. **State Sync Broken**: Peers attempting to sync from this node fail when requesting state proofs for version V
3. **Proof Generation Impossible**: Cannot generate Merkle proofs for transactions at version V
4. **Database Corruption Appearance**: The database appears corrupted with incomplete state trees
5. **Recovery Required**: Manual intervention needed to identify and fix the inconsistent state

The comment acknowledging partial commits exists: [8](#0-7) 

This shows awareness of the issue but indicates it was only partially addressed (for epoch-ending blocks only).

## Likelihood Explanation

**Likelihood: Medium-High**

This can occur naturally during normal operation:
- **No Malicious Input Required**: Happens in standard consensus flow
- **Timing Window**: The vulnerability window exists between LedgerInfo write and async Merkle commit completion (typically milliseconds to seconds)
- **Trigger Events**: Node crashes, database replication, or backup operations during this window
- **Frequency**: Every non-epoch-ending block with a LedgerInfo creates this exposure

In production environments with continuous block production, thousands of such windows occur daily. Database replication for backup or read replicas can capture this inconsistent state.

## Recommendation

Add state snapshot verification for ALL LedgerInfo writes, not just epoch-ending ones:

```rust
// In check_and_put_ledger_info function (aptosdb_writer.rs)
// After line 582, before the write:

// Ensure that state tree is persisted for this version
let state_snapshot = self.state_store.get_state_snapshot_before(version + 1)?;
ensure!(
    state_snapshot.is_some() && state_snapshot.as_ref().unwrap().0 == version,
    "State checkpoint not persisted for version {}, snapshot in db: {:?}",
    version,
    state_snapshot,
);
```

**Alternative Solution:** Force synchronous Merkle commits for all blocks that will receive a LedgerInfo:

```rust
// In block_executor/mod.rs pre_commit_block function
// Modify line 355 to:
let needs_sync = output.as_chunk_to_commit().is_reconfig || block_will_have_ledger_info;
self.db.writer.pre_commit_ledger(output.as_chunk_to_commit(), needs_sync)?;
```

## Proof of Concept

```rust
// Integration test demonstrating the vulnerability
#[test]
fn test_ledger_info_merkle_tree_temporal_inconsistency() {
    use aptos_types::ledger_info::{LedgerInfo, LedgerInfoWithSignatures};
    use aptos_types::block_info::BlockInfo;
    
    // Setup: Create AptosDB instance and execute transactions
    let (db, transactions) = setup_db_with_transactions(100);
    let version = 99;
    
    // Step 1: Pre-commit with sync_commit=false (async Merkle commit)
    let chunk = create_chunk_to_commit(transactions, is_reconfig=false);
    db.writer.pre_commit_ledger(chunk, false).unwrap();
    
    // Step 2: Immediately commit LedgerInfo without waiting for async commit
    let block_info = BlockInfo::new(
        /* epoch */ 0,
        /* round */ 10,
        /* id */ HashValue::random(),
        /* executed_state_id */ HashValue::random(),
        /* version */ version,
        /* timestamp_usecs */ 1000000,
        /* next_epoch_state */ None, // NOT epoch-ending
    );
    let ledger_info = LedgerInfo::new(block_info, HashValue::zero());
    let ledger_info_with_sigs = create_signed_ledger_info(ledger_info);
    
    // This should fail but currently succeeds for non-epoch-ending blocks
    db.writer.commit_ledger(version, Some(&ledger_info_with_sigs), None).unwrap();
    
    // Step 3: Simulate crash by dropping db before async commit completes
    drop(db);
    
    // Step 4: Reopen database and verify inconsistency
    let db = reopen_db();
    
    // LedgerInfo exists for the epoch
    let ledger_info_read = db.reader.get_latest_ledger_info().unwrap();
    assert_eq!(ledger_info_read.ledger_info().version(), version);
    
    // But state snapshot is incomplete or missing
    let snapshot = db.reader.get_state_snapshot_before(version + 1);
    // This will either:
    // 1. Return None (incomplete)
    // 2. Return Some(version) but fail on root hash retrieval
    // 3. Return older version, proving temporal inconsistency
    
    match snapshot {
        Ok(Some((snap_version, _))) if snap_version == version => {
            // Try to get root hash - will fail due to missing nodes
            let root_result = db.state_merkle_db.get_root_hash(version);
            assert!(root_result.is_err(), "Expected missing root hash");
        },
        Ok(Some((snap_version, _))) => {
            assert!(snap_version < version, "Temporal inconsistency: LedgerInfo at {} but snapshot at {}", version, snap_version);
        },
        Ok(None) => {
            panic!("Temporal inconsistency: LedgerInfo exists but no snapshot");
        },
        Err(e) => panic!("Error reading snapshot: {}", e),
    }
}
```

## Notes

This vulnerability represents a violation of atomicity in the database commit protocol. While epoch-ending blocks are protected by explicit verification, the codebase assumes non-epoch-ending blocks don't require the same guarantees. However, since LedgerInfos can be written for any block that receives a quorum certificate in consensus (not just epoch boundaries), this assumption is incorrect.

The asynchronous Merkle commit optimization improves performance but introduces a consistency window that should be closed before declaring the version committed via LedgerInfo persistence.

### Citations

**File:** execution/executor/src/block_executor/mod.rs (L355-355)
```rust
                .pre_commit_ledger(output.as_chunk_to_commit(), false)?;
```

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L68-72)
```rust
            self.state_store.buffered_state().lock().update(
                chunk.result_ledger_state_with_summary(),
                chunk.estimated_total_state_updates(),
                sync_commit || chunk.is_reconfig,
            )?;
```

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L99-101)
```rust
            if let Some(li) = ledger_info_with_sigs {
                self.check_and_put_ledger_info(version, li, &mut ledger_batch)?;
            }
```

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L584-594)
```rust
        // Ensure that state tree at the end of the epoch is persisted.
        if ledger_info_with_sig.ledger_info().ends_epoch() {
            let state_snapshot = self.state_store.get_state_snapshot_before(version + 1)?;
            ensure!(
                state_snapshot.is_some() && state_snapshot.as_ref().unwrap().0 == version,
                "State checkpoint not persisted at the end of the epoch, version {}, next_epoch {}, snapshot in db: {:?}",
                version,
                ledger_info_with_sig.ledger_info().next_block_epoch(),
                state_snapshot,
            );
        }
```

**File:** storage/aptosdb/src/state_store/buffered_state.rs (L123-134)
```rust
    fn enqueue_commit(&mut self, checkpoint: StateWithSummary) {
        let _timer = OTHER_TIMERS_SECONDS.timer_with(&["buffered_state___enqueue_commit"]);

        self.state_commit_sender
            .send(CommitMessage::Data(checkpoint.clone()))
            .unwrap();
        // n.b. if the latest state is not a (the latest) checkpoint, the items between them are
        // not counted towards the next commit. If this becomes a concern we can count the items
        // instead of putting it 0 here.
        self.estimated_items = 0;
        self.last_snapshot = checkpoint;
    }
```

**File:** storage/aptosdb/src/ledger_db/ledger_metadata_db.rs (L197-197)
```rust
        batch.put::<LedgerInfoSchema>(&ledger_info.epoch(), ledger_info_with_sigs)
```

**File:** storage/aptosdb/src/state_store/state_merkle_batch_committer.rs (L80-81)
```rust
                    self.commit(&self.state_db.state_merkle_db, current_version, cold_batch)
                        .expect("State merkle nodes commit failed.");
```

**File:** storage/aptosdb/src/state_merkle_db.rs (L340-343)
```rust
                // Since we split state merkle commit into multiple batches, it's possible that
                // the root is not committed yet. In this case we need to look at the previous
                // root.
                return self.get_state_snapshot_version_before(version);
```
