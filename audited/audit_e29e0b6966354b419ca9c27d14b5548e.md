# Audit Report

## Title
JWT Replay Attack Enabling Validator Impersonation in Telemetry Service

## Summary
The Aptos telemetry service's JWT authentication mechanism lacks replay protection, allowing attackers who intercept a valid JWT token to impersonate validators and submit arbitrary telemetry data (metrics, logs, events) for up to 60 minutes per token. The `run_uuid` field in JWT claims is designed to identify unique validator sessions but is never validated during authorization.

## Finding Description

The telemetry service implements JWT-based authentication for validators to submit telemetry data. Each validator session generates a unique `run_uuid` that gets embedded in the JWT token claims. However, the authorization logic fails to validate this session identifier against active sessions.

**Vulnerable Authentication Flow:**

When a validator authenticates, the server creates a JWT containing: [1](#0-0) 

The JWT is created with a 60-minute expiration: [2](#0-1) 

**Critical Vulnerability - Missing run_uuid Validation:**

The `authorize_jwt` function only validates JWT signature, expiration time, epoch match, and node type - but never checks if the `run_uuid` corresponds to an active session: [3](#0-2) 

Notice that line 72 only checks `claims.epoch == current_epoch && claims.exp > Utc::now().timestamp()` - there is no validation of `claims.run_uuid` against any session tracking mechanism.

**Attack Execution:**

1. Attacker intercepts a legitimate JWT token via network sniffing or MITM attack
2. Attacker extracts the Bearer token from the Authorization header
3. Attacker replays the JWT to protected endpoints:
   - `/api/v1/ingest/metrics` [4](#0-3) 
   - `/api/v1/ingest/logs` [5](#0-4) 
   - `/api/v1/ingest/custom-event`

4. The replayed JWT passes all authorization checks since `run_uuid` is never validated
5. Fake telemetry data is attributed to the legitimate validator with the same `peer_id` and `run_uuid`: [6](#0-5) 

6. Attack persists for the entire 60-minute JWT lifetime or until epoch changes

**Why run_uuid Exists But Doesn't Protect:**

The client generates a unique `run_uuid` per session: [7](#0-6) 

This UUID is sent during authentication: [8](#0-7) 

But the server never maintains a registry of active `run_uuid` values or validates them during subsequent requests.

## Impact Explanation

**Severity: Low** (per Aptos Bug Bounty criteria)

This vulnerability affects the telemetry/monitoring system, not the core blockchain protocol. The impact is limited to:

1. **Telemetry Data Poisoning**: Attackers can inject fake metrics, logs, and events attributed to legitimate validators
2. **Monitoring Corruption**: False data may hide real issues or trigger spurious alerts
3. **Operational Impact**: Validator operators may make incorrect decisions based on corrupted telemetry

**Why Not Higher Severity:**
- Does NOT affect consensus, block production, or validator operations
- Does NOT enable fund theft or loss
- Does NOT cause network partition or liveness failures  
- Does NOT affect on-chain state, governance, or staking
- Limited to monitoring/observability infrastructure

Per Aptos bounty criteria, this falls under "Non-critical implementation bugs" (Low severity), not Medium/High/Critical categories which require blockchain protocol impact.

## Likelihood Explanation

**Moderate Likelihood:**

**Attack Prerequisites:**
- Network position allowing JWT interception (MITM, compromised infrastructure, etc.)
- Telemetry traffic not using additional transport-layer encryption
- JWT tokens transmitted in plaintext Authorization headers

**Mitigating Factors:**
- Requires active network interception
- 60-minute attack window per captured token
- Limited to telemetry system impact only

The attack is technically feasible but requires network access, making it less likely than pure logic vulnerabilities but more likely than attacks requiring privileged access.

## Recommendation

Implement proper session tracking with `run_uuid` validation:

```rust
// Add to Context struct
pub struct ActiveSessions {
    sessions: RwLock<HashMap<(ChainId, PeerId, Uuid), Instant>>,
}

impl ActiveSessions {
    pub fn register_session(&self, chain_id: ChainId, peer_id: PeerId, run_uuid: Uuid) {
        self.sessions.write().insert((chain_id, peer_id, run_uuid), Instant::now());
    }
    
    pub fn validate_session(&self, chain_id: ChainId, peer_id: PeerId, run_uuid: Uuid) -> bool {
        self.sessions.read().contains_key(&(chain_id, peer_id, run_uuid))
    }
    
    pub fn remove_session(&self, chain_id: ChainId, peer_id: PeerId, run_uuid: Uuid) {
        self.sessions.write().remove(&(chain_id, peer_id, run_uuid));
    }
}

// Modify authorize_jwt to validate run_uuid
pub async fn authorize_jwt(
    token: String,
    context: Context,
    allow_roles: Vec<NodeType>,
) -> anyhow::Result<Claims, Rejection> {
    let decoded: TokenData<Claims> = context.jwt_service().decode(&token).map_err(|e| {
        error!("unable to authorize jwt token: {}", e);
        reject::custom(ServiceError::unauthorized(
            JwtAuthError::InvalidAuthToken.into(),
        ))
    })?;
    let claims = decoded.claims;

    // Validate run_uuid against active sessions
    if !context.active_sessions().validate_session(claims.chain_id, claims.peer_id, claims.run_uuid) {
        return Err(reject::custom(ServiceError::unauthorized(
            JwtAuthError::InvalidSession.into(),
        )));
    }

    // ... existing validation code ...
}
```

**Alternative:** Implement shorter-lived tokens with refresh mechanism and add request nonces.

## Proof of Concept

```rust
// Test demonstrating JWT replay attack
#[tokio::test]
async fn test_jwt_replay_attack() {
    use crate::tests::test_context::new_test_context;
    use crate::jwt_auth::create_jwt_token;
    use aptos_types::{chain_id::ChainId, PeerId};
    use uuid::Uuid;
    
    let context = new_test_context().await;
    let chain_id = ChainId::new(25);
    let peer_id = PeerId::random();
    let run_uuid = Uuid::new_v4();
    
    // Setup validator in cache
    {
        let mut validators = context.inner.peers().validators().write();
        validators.insert(chain_id, (10, HashMap::new()));
    }
    
    // Create JWT token
    let token = create_jwt_token(
        context.inner.jwt_service(),
        chain_id,
        peer_id,
        NodeType::Validator,
        10,
        run_uuid,
    ).unwrap();
    
    // First request succeeds (legitimate)
    let result1 = authorize_jwt(
        token.clone(),
        context.inner.clone(),
        vec![NodeType::Validator],
    ).await;
    assert!(result1.is_ok());
    
    // REPLAY ATTACK: Same JWT token can be reused multiple times
    let result2 = authorize_jwt(
        token.clone(),
        context.inner.clone(),
        vec![NodeType::Validator],
    ).await;
    assert!(result2.is_ok()); // ❌ Should fail but succeeds
    
    // Even after simulating "session end", token still works
    std::thread::sleep(Duration::from_secs(1));
    let result3 = authorize_jwt(
        token,
        context.inner.clone(),
        vec![NodeType::Validator],
    ).await;
    assert!(result3.is_ok()); // ❌ Should fail but succeeds
    
    // Attacker can submit fake metrics using replayed JWT
    let fake_metrics = Bytes::from("fake_metrics_data");
    let metrics_result = handle_metrics_ingest(
        context.inner.clone(),
        result3.unwrap(),
        Some("gzip".into()),
        fake_metrics,
    ).await;
    // Fake metrics are accepted and attributed to legitimate validator
}
```

## Notes

This vulnerability demonstrates a gap between intended security design (session tracking via `run_uuid`) and actual implementation (no session validation). While the telemetry service correctly includes session identifiers in JWT claims, it fails to enforce their uniqueness or validate them against active sessions.

The impact is confined to the monitoring infrastructure and does not directly threaten blockchain consensus, validator operations, or fund security. However, corrupted telemetry data can impair operational decision-making and potentially mask real security incidents.

**Comparison with Custom Contract Auth:** The codebase shows that custom contract authentication implements proper challenge-response with nonce validation, demonstrating awareness of replay attack risks - yet the standard JWT auth lacks similar protections.

### Citations

**File:** crates/aptos-telemetry-service/src/types/auth.rs (L28-37)
```rust
#[derive(Debug, Serialize, Deserialize, PartialEq, Eq)]
pub struct Claims {
    pub chain_id: ChainId,
    pub peer_id: PeerId,
    pub node_type: NodeType,
    pub epoch: u64,
    pub exp: usize,
    pub iat: usize,
    pub run_uuid: Uuid,
}
```

**File:** crates/aptos-telemetry-service/src/jwt_auth.rs (L18-42)
```rust
pub fn create_jwt_token(
    jwt_service: &JsonWebTokenService,
    chain_id: ChainId,
    peer_id: PeerId,
    node_type: NodeType,
    epoch: u64,
    uuid: Uuid,
) -> Result<String, Error> {
    let issued = Utc::now().timestamp();
    let expiration = Utc::now()
        .checked_add_signed(chrono::Duration::minutes(60))
        .expect("valid timestamp")
        .timestamp();

    let claims = Claims {
        chain_id,
        peer_id,
        node_type,
        epoch,
        exp: expiration as usize,
        iat: issued as usize,
        run_uuid: uuid,
    };
    jwt_service.encode(claims)
}
```

**File:** crates/aptos-telemetry-service/src/jwt_auth.rs (L44-79)
```rust
pub async fn authorize_jwt(
    token: String,
    context: Context,
    allow_roles: Vec<NodeType>,
) -> anyhow::Result<Claims, Rejection> {
    let decoded: TokenData<Claims> = context.jwt_service().decode(&token).map_err(|e| {
        error!("unable to authorize jwt token: {}", e);
        reject::custom(ServiceError::unauthorized(
            JwtAuthError::InvalidAuthToken.into(),
        ))
    })?;
    let claims = decoded.claims;

    let current_epoch = match context.peers().validators().read().get(&claims.chain_id) {
        Some(info) => info.0,
        None => {
            return Err(reject::custom(ServiceError::unauthorized(
                JwtAuthError::ExpiredAuthToken.into(),
            )));
        },
    };

    if !allow_roles.contains(&claims.node_type) {
        return Err(reject::custom(ServiceError::forbidden(
            JwtAuthError::AccessDenied.into(),
        )));
    }

    if claims.epoch == current_epoch && claims.exp > Utc::now().timestamp() as usize {
        Ok(claims)
    } else {
        Err(reject::custom(ServiceError::unauthorized(
            JwtAuthError::ExpiredAuthToken.into(),
        )))
    }
}
```

**File:** crates/aptos-telemetry-service/src/prometheus_push_metrics.rs (L22-38)
```rust
pub fn metrics_ingest(context: Context) -> BoxedFilter<(impl Reply,)> {
    warp::path!("ingest" / "metrics")
        .and(warp::post())
        .and(context.clone().filter())
        .and(with_auth(context, vec![
            NodeType::Validator,
            NodeType::ValidatorFullNode,
            NodeType::PublicFullNode,
            NodeType::UnknownValidator,
            NodeType::UnknownFullNode,
        ]))
        .and(warp::header::optional(CONTENT_ENCODING.as_str()))
        .and(warp::body::content_length_limit(MAX_CONTENT_LENGTH))
        .and(warp::body::bytes())
        .and_then(handle_metrics_ingest)
        .boxed()
}
```

**File:** crates/aptos-telemetry-service/src/prometheus_push_metrics.rs (L158-187)
```rust
fn claims_to_extra_labels(claims: &Claims, common_name: Option<&String>) -> Vec<String> {
    let chain_name = if claims.chain_id.id() == 3 {
        format!("chain_name={}", claims.chain_id.id())
    } else {
        format!("chain_name={}", claims.chain_id)
    };
    let pod_name = if let Some(common_name) = common_name {
        format!(
            "kubernetes_pod_name=peer_id:{}//{}",
            common_name,
            claims.peer_id.to_hex_literal()
        )
    } else {
        // for community nodes we cannot determine which pod name they run in (or whether they run in k8s at all),
        // so we use the peer id as an approximation/replacement for pod_name
        // This works well with our existing grafana dashboards
        format!(
            "kubernetes_pod_name=peer_id:{}",
            claims.peer_id.to_hex_literal()
        )
    };
    vec![
        format!("role={}", claims.node_type),
        format!("metrics_source={}", "telemetry-service"),
        chain_name,
        format!("namespace={}", "telemetry-service"),
        pod_name,
        format!("run_uuid={}", claims.run_uuid),
    ]
}
```

**File:** crates/aptos-telemetry-service/src/log_ingest.rs (L23-39)
```rust
pub fn log_ingest(context: Context) -> BoxedFilter<(impl Reply,)> {
    warp::path!("ingest" / "logs")
        .and(warp::post())
        .and(context.clone().filter())
        .and(with_auth(context, vec![
            NodeType::Validator,
            NodeType::ValidatorFullNode,
            NodeType::PublicFullNode,
            NodeType::UnknownFullNode,
            NodeType::UnknownValidator,
        ]))
        .and(warp::header::optional(CONTENT_ENCODING.as_str()))
        .and(warp::body::content_length_limit(MAX_CONTENT_LENGTH))
        .and(warp::body::aggregate())
        .and_then(handle_log_ingest)
        .boxed()
}
```

**File:** crates/aptos-telemetry-service/src/sender.rs (L48-92)
```rust

```

**File:** crates/aptos-telemetry-service/src/sender.rs (L319-326)
```rust

```
