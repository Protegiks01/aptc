# Audit Report

## Title
CAPTCHA Bypass in Aptos Faucet Service Due to Misconfigured Service Composition

## Summary
When `CaptchaApi` is disabled (by omitting CAPTCHA checkers from configuration), the faucet service composition fails to enforce CAPTCHA validation on `/fund` endpoints. Attackers can bypass CAPTCHA entirely by calling `/fund` directly without providing CAPTCHA headers, enabling automated mass funding requests that could drain the faucet account.

## Finding Description

The Aptos faucet service has a critical architectural flaw in how CAPTCHA protection is implemented. The service consists of three APIs composed together: `BasicApi`, `CaptchaApi`, and `FundApi`.

**The Vulnerability:**

The `CaptchaApi.enabled` flag only controls whether the `/request_captcha` endpoint returns captcha challenges or an error. It does NOT prevent access to the `/fund` endpoint or enforce CAPTCHA validation on funding requests. [1](#0-0) 

CAPTCHA validation is performed by checkers (`TapCaptchaChecker` or `GoogleCaptchaChecker`) that are added to the `FundApiComponents.checkers` list. When no CAPTCHA checker is configured, the `CaptchaApi.enabled` flag is set to false, but critically, the `FundApi` remains fully accessible without any CAPTCHA validation. [2](#0-1) 

The service composition always includes all three APIs regardless of the `enabled` flag: [3](#0-2) 

**Attack Path:**

1. Operator configures faucet without `TapCaptcha` or `GoogleCaptcha` in `checker_configs`
2. `CaptchaApi.enabled` is set to `false` 
3. `/request_captcha` endpoint returns error (leading operator to believe CAPTCHA is enforced)
4. However, `/fund` endpoint remains accessible
5. Attacker sends POST request to `/fund` without CAPTCHA headers
6. Request passes through `preprocess_request` function: [4](#0-3) 

7. Since no CAPTCHA checker exists in the `checkers` list, no CAPTCHA validation occurs
8. Account gets funded successfully
9. Attacker automates this to drain faucet funds

The CAPTCHA validation only occurs if a checker is present: [5](#0-4) 

Without a CAPTCHA checker in the configuration, these validation checks never execute.

## Impact Explanation

Per Aptos Bug Bounty criteria, this qualifies as **High Severity** under "API crashes" and "Significant protocol violations":

- **Service Abuse**: Attackers can bypass rate limiting and CAPTCHA protection to make unlimited automated funding requests
- **Fund Drainage**: The faucet account balance can be completely drained, causing service unavailability 
- **False Security Assumption**: Operators may incorrectly believe CAPTCHA is enforced when `CaptchaApi.enabled=false`, creating a security misconfiguration vulnerability

**Note**: This vulnerability is limited to the faucet service itself and does not affect blockchain consensus, Move VM execution, or other users' funds. However, it represents a complete bypass of an intended security control in an official Aptos service.

## Likelihood Explanation

**Likelihood: High**

This vulnerability will occur in any deployment where:
- CAPTCHA checkers (`TapCaptcha` or `GoogleCaptcha`) are omitted from configuration
- Operators rely on `CaptchaApi.enabled=false` to believe CAPTCHA is disabled intentionally
- No other rate-limiting checkers provide adequate protection

The attack requires no special privileges or sophisticated techniques - simply making HTTP POST requests to `/fund` without CAPTCHA headers. The confusion between "CaptchaApi disabled" (endpoint unavailable) and "CAPTCHA validation enforced" makes this likely to occur in practice.

## Recommendation

**Immediate Fix**: Add explicit validation to ensure CAPTCHA checkers are present when CaptchaApi is enabled, or prevent FundApi from being accessible when CAPTCHA is expected but not configured.

**Option 1 - Enforce CAPTCHA checker presence:**
```rust
// In run.rs after building checkers
if tap_captcha_api_enabled {
    let has_captcha_checker = checkers.iter().any(|c| matches!(
        c, 
        Checker::TapCaptchaChecker(_) | Checker::GoogleCaptchaChecker(_)
    ));
    if !has_captcha_checker {
        return Err(anyhow!("CaptchaApi enabled but no CAPTCHA checker configured"));
    }
}
```

**Option 2 - Conditional service composition:**
Modify `build_openapi_service` to conditionally include APIs based on configuration, or add middleware that enforces CAPTCHA requirements at the service level rather than only through checkers.

**Option 3 - Clear documentation and validation:**
Add configuration validation that warns operators when no CAPTCHA checker is present, and clarify that `CaptchaApi.enabled` only controls the `/request_captcha` endpoint, not CAPTCHA enforcement.

## Proof of Concept

**Configuration file (`no_captcha.yaml`):**
```yaml
server_config:
  api_path_base: ""
  listen_address: "0.0.0.0"
  listen_port: 8081
metrics_server_config:
  disable: true
bypasser_configs: []
checker_configs: []  # No CAPTCHA checker configured
funder_config:
  type: "FakeFunder"
handler_config:
  use_helpful_errors: true
  return_rejections_early: false
```

**Attack script:**
```bash
#!/bin/bash
# Start faucet with no CAPTCHA checker
# cargo run --bin aptos-faucet run --config-path no_captcha.yaml

# Verify /request_captcha is disabled
curl http://localhost:8081/v1/request_captcha
# Returns error: "The CaptchaChecker is not enabled"

# But /fund is still accessible without CAPTCHA
for i in {1..1000}; do
  curl -X POST http://localhost:8081/v1/fund \
    -H "Content-Type: application/json" \
    -d "{\"address\":\"0x$(openssl rand -hex 32)\"}" &
done
# All requests succeed without CAPTCHA validation
# Faucet account gets drained
```

The attack succeeds because the service composition includes `FundApi` unconditionally, and no CAPTCHA checker exists to validate the requests.

---

**Notes:**

This vulnerability is **limited to the faucet service** and does not affect Aptos blockchain consensus, Move VM execution, state consistency, or other core security properties. The impact is service-level abuse enabling faucet fund drainage and DoS, not blockchain-level security compromise. While this is a valid security issue requiring remediation, it should be assessed within the context of auxiliary service security rather than core blockchain protocol security.

### Citations

**File:** crates/aptos-faucet/core/src/server/run.rs (L128-152)
```rust
        let mut checkers: Vec<Checker> = Vec::new();
        for checker_config in &self.checker_configs {
            let checker = checker_config
                .clone()
                .build(captcha_manager.clone())
                .await
                .with_context(|| {
                    format!("Failed to build Checker with args: {:?}", checker_config)
                })?;
            checker.spawn_periodic_tasks(&mut join_set);
            checkers.push(checker);
        }

        // Sort Checkers by cost, where lower numbers is lower cost, and lower
        // cost Checkers are at the start of the vec.
        checkers.sort_by_key(|a| a.cost());

        // Using those, build the fund API components.
        let fund_api_components = Arc::new(FundApiComponents {
            bypassers,
            checkers,
            funder,
            return_rejections_early: self.handler_config.return_rejections_early,
            concurrent_requests_semaphore,
        });
```

**File:** crates/aptos-faucet/core/src/server/run.rs (L158-169)
```rust
        // Build the CaptchaApi.
        let mut tap_captcha_api_enabled = false;
        for checker in &self.checker_configs {
            if let CheckerConfig::TapCaptcha(_) = checker {
                tap_captcha_api_enabled = true;
                break;
            }
        }
        let captcha_api = CaptchaApi {
            enabled: tap_captcha_api_enabled,
            captcha_manager,
        };
```

**File:** crates/aptos-faucet/core/src/endpoints/api.rs (L9-28)
```rust
pub fn build_openapi_service(
    basic_api: BasicApi,
    captcha_api: CaptchaApi,
    fund_api: FundApi,
) -> OpenApiService<(BasicApi, CaptchaApi, FundApi), ()> {
    let version = VERSION.to_string();
    let license =
        LicenseObject::new("Apache 2.0").url("https://www.apache.org/licenses/LICENSE-2.0.html");
    let contact = ContactObject::new()
        .name("Aptos Labs")
        .url("https://github.com/aptos-labs");

    let apis = (basic_api, captcha_api, fund_api);

    OpenApiService::new(apis, "Aptos Tap", version.trim())
        .server("/v1")
        .description("todo")
        .license(license)
        .contact(contact)
}
```

**File:** crates/aptos-faucet/core/src/endpoints/fund.rs (L261-280)
```rust
        // Ensure request passes checkers.
        let mut rejection_reasons = Vec::new();
        for checker in &self.checkers {
            rejection_reasons.extend(checker.check(checker_data.clone(), dry_run).await.map_err(
                |e| AptosTapError::new_with_error_code(e, AptosTapErrorCode::CheckerError),
            )?);
            if !rejection_reasons.is_empty() && self.return_rejections_early {
                break;
            }
        }

        if !rejection_reasons.is_empty() {
            return Err(AptosTapError::new(
                format!("Request rejected by {} checkers", rejection_reasons.len()),
                AptosTapErrorCode::Rejected,
            )
            .rejection_reasons(rejection_reasons));
        }

        Ok((checker_data, false, permit))
```

**File:** crates/aptos-faucet/core/src/checkers/tap_captcha.rs (L48-114)
```rust
#[async_trait]
impl CheckerTrait for TapCaptchaChecker {
    async fn check(
        &self,
        data: CheckerData,
        _dry_run: bool,
    ) -> Result<Vec<RejectionReason>, AptosTapError> {
        let captcha_key = match data.headers.get(CAPTCHA_KEY) {
            Some(header_value) => match header_value
                .to_str()
                .map_err(|e| {
                    AptosTapError::new_with_error_code(e, AptosTapErrorCode::InvalidRequest)
                })?
                .parse::<u32>()
            {
                Ok(value) => value,
                Err(e) => {
                    return Ok(vec![RejectionReason::new(
                        format!("Captcha value not a number: {:#}", e),
                        RejectionReasonCode::CaptchaInvalid,
                    )])
                },
            },
            None => {
                return Ok(vec![RejectionReason::new(
                    format!("Captcha header {} not found", CAPTCHA_KEY),
                    RejectionReasonCode::CaptchaInvalid,
                )])
            },
        };

        let captcha_value = match data.headers.get(CAPTCHA_VALUE) {
            Some(header_value) => header_value.to_str().map_err(|e| {
                AptosTapError::new_with_error_code(e, AptosTapErrorCode::InvalidRequest)
            })?,
            None => {
                return Ok(vec![RejectionReason::new(
                    format!("Captcha header {} not found", CAPTCHA_VALUE),
                    RejectionReasonCode::CaptchaInvalid,
                )])
            },
        };

        let captcha_correct = match self
            .captcha_manager
            .lock()
            .await
            .check_challenge(captcha_key, captcha_value)
        {
            Ok(correct) => correct,
            Err(e) => {
                return Ok(vec![RejectionReason::new(
                    format!("Captcha key unknown: {}", e),
                    RejectionReasonCode::CaptchaInvalid,
                )])
            },
        };

        if !captcha_correct {
            return Ok(vec![RejectionReason::new(
                format!("Captcha value {} incorrect", captcha_value),
                RejectionReasonCode::CaptchaInvalid,
            )]);
        }

        Ok(vec![])
    }
```
