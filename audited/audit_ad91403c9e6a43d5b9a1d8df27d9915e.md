# Audit Report

## Title
Undocumented Security-Critical Failpoint Endpoint with No Authentication in OpenAPI Specification

## Summary
The `/v1/set_failpoint` endpoint is manually added to the Aptos Node API but excluded from the OpenAPI specification, violating the spec completeness requirement. This endpoint lacks authentication and can be abused to inject faults into consensus operations and VM execution when enabled on testnet/devnet nodes, causing validator crashes and network disruption.

## Finding Description
The OpenAPI specification generated by `get_spec()` does not accurately reflect all security-critical endpoints. Specifically, the `/v1/set_failpoint` endpoint is added manually outside the OpenAPI service registration and is explicitly excluded from the specification. [1](#0-0) 

The endpoint is registered as a GET route that accepts `name` and `actions` query parameters to configure failpoints. When failpoints are enabled in the node configuration, this endpoint has **no authentication mechanism** - it only verifies that `context.failpoints_enabled()` returns true. [2](#0-1) 

The API runtime applies middleware for CORS, compression, size limits, and logging, but **no authentication middleware** exists to protect security-critical endpoints. [3](#0-2) 

Failpoints are injected at critical locations throughout the codebase that can disrupt consensus and VM execution. For example, in consensus proposal processing: [4](#0-3) 

And in VM transaction execution: [5](#0-4) 

While the config sanitizer prevents enabling failpoints on mainnet, testnets and devnets commonly enable them for debugging purposes: [6](#0-5) 

An attacker who discovers this undocumented endpoint can inject arbitrary faults by calling:
```
GET /v1/set_failpoint?name=consensus::process_proposal_msg&actions=return
```

This breaks the **Access Control** invariant - security-critical operations must require proper authentication. It also violates the spec completeness requirement, as security auditors and developers relying on the OpenAPI specification will not know this endpoint exists or requires protection.

## Impact Explanation
This qualifies as **HIGH severity** per Aptos bug bounty criteria because it enables:

1. **Validator node slowdowns** - Injecting failpoints in consensus paths causes proposal processing failures and round delays
2. **API crashes** - Failpoints can inject panic conditions in critical code paths
3. **Significant protocol violations** - Disrupting consensus operations on testnet validators affects network stability

While mainnet is protected, testnet and devnet validators are production infrastructure used for:
- Pre-release testing
- Integration testing for ecosystem projects
- Developer onboarding
- Network upgrades validation

Disrupting these networks has real operational impact and can delay critical releases or cause ecosystem-wide testing failures.

## Likelihood Explanation
**Likelihood: MEDIUM-HIGH on testnets/devnets**

Attack requirements:
- Target must be a testnet/devnet node with `failpoints_enabled: true`
- Endpoint must be network-accessible
- No special credentials or validator access needed

Many testnet validators enable failpoints for debugging and chaos testing. The endpoint is trivially discoverable through:
- Source code review (public repository)
- API endpoint enumeration
- Error messages that reference failpoint names

Once discovered, exploitation requires only a simple HTTP GET request with appropriate failpoint names (which are visible in source code).

## Recommendation

**Immediate Fix:**

1. **Add the endpoint to OpenAPI spec** with proper documentation:

```rust
// In a new API struct
#[OpenApi]
impl FailpointApi {
    /// Configure failpoint (debugging only)
    ///
    /// This endpoint is only available when failpoints are enabled in configuration.
    /// It should never be exposed on production networks.
    #[oai(
        path = "/set_failpoint",
        method = "get",
        operation_id = "set_failpoint",
        tag = "ApiTags::Debug"
    )]
    async fn set_failpoint(
        &self,
        /// Failpoint name
        name: Query<String>,
        /// Failpoint actions  
        actions: Query<String>,
    ) -> poem::Result<String> {
        // Implementation
    }
}
```

2. **Add authentication** to protect the endpoint when enabled:

```rust
pub fn set_failpoint_poem(
    context: Data<&std::sync::Arc<Context>>,
    Query(failpoint_conf): Query<FailpointConf>,
    // Add authentication check
    auth_header: &HeaderMap,
) -> poem::Result<String> {
    if context.failpoints_enabled() {
        // Verify authentication token
        let auth_token = auth_header
            .get("Authorization")
            .and_then(|v| v.to_str().ok())
            .ok_or_else(|| poem::Error::from(anyhow::anyhow!("Missing Authorization header")))?;
        
        if !context.verify_failpoint_token(auth_token) {
            return Err(poem::Error::from(anyhow::anyhow!("Invalid authentication")));
        }
        
        fail::cfg(&failpoint_conf.name, &failpoint_conf.actions)
            .map_err(|e| poem::Error::from(anyhow::anyhow!(e)))?;
        info!("Configured failpoint {} to {}", failpoint_conf.name, failpoint_conf.actions);
        Ok(format!("Set failpoint {}", failpoint_conf.name))
    } else {
        Err(poem::Error::from(anyhow::anyhow!("Failpoints are not enabled")))
    }
}
```

3. **Document the security requirements** in the OpenAPI spec with a warning that this endpoint should never be publicly exposed.

## Proof of Concept

**Setup**: Deploy a testnet node with failpoints enabled in configuration:

```yaml
api:
  enabled: true
  failpoints_enabled: true
```

**Attack**:

```bash
# Step 1: Discover the undocumented endpoint (not in /v1/spec.json)
curl http://testnet-validator:8080/v1/spec.json | jq '.paths' 
# /set_failpoint is missing

# Step 2: Inject failpoint to disrupt consensus
curl "http://testnet-validator:8080/v1/set_failpoint?name=consensus::process_proposal_msg&actions=return"
# Returns: "Set failpoint consensus::process_proposal_msg"

# Step 3: Validator now fails to process all proposals
# Check logs: "Injected error in process_proposal_msg"

# Step 4: Inject failpoint to crash VM execution  
curl "http://testnet-validator:8080/v1/set_failpoint?name=aptos_vm::execute_script_or_entry_function&actions=return"

# Step 5: All transactions now fail with UNKNOWN_INVARIANT_VIOLATION_ERROR
```

**Impact**: Validator becomes unable to participate in consensus and process transactions, causing network instability if multiple validators are targeted.

## Notes

The vulnerability directly answers the security question: **NO**, the generated OpenAPI spec does NOT accurately reflect all security-critical endpoints. The `/set_failpoint` endpoint is security-critical (can disrupt consensus and crash nodes), lacks authentication requirements, and has undocumented parameter validation rules, yet it is completely absent from the OpenAPI specification that developers and security auditors rely upon.

### Citations

**File:** api/src/runtime.rs (L246-251)
```rust
                    // TODO: We add this manually outside of the OpenAPI spec for now.
                    // https://github.com/poem-web/poem/issues/364
                    .at(
                        "/set_failpoint",
                        poem::get(set_failpoints::set_failpoint_poem).data(context.clone()),
                    ),
```

**File:** api/src/runtime.rs (L253-259)
```rust
            .with(cors)
            .with_if(config.api.compression_enabled, Compression::new())
            .with(PostSizeLimit::new(size_limit))
            .with(CatchPanic::new().with_handler(panic_handler))
            // NOTE: Make sure to keep this after all the `with` middleware.
            .catch_all_error(convert_error)
            .around(middleware_log);
```

**File:** api/src/set_failpoints.rs (L21-40)
```rust
#[cfg(feature = "failpoints")]
#[handler]
pub fn set_failpoint_poem(
    context: Data<&std::sync::Arc<Context>>,
    Query(failpoint_conf): Query<FailpointConf>,
) -> poem::Result<String> {
    if context.failpoints_enabled() {
        fail::cfg(&failpoint_conf.name, &failpoint_conf.actions)
            .map_err(|e| poem::Error::from(anyhow::anyhow!(e)))?;
        info!(
            "Configured failpoint {} to {}",
            failpoint_conf.name, failpoint_conf.actions
        );
        Ok(format!("Set failpoint {}", failpoint_conf.name))
    } else {
        Err(poem::Error::from(anyhow::anyhow!(
            "Failpoints are not enabled at a config level"
        )))
    }
}
```

**File:** consensus/src/round_manager.rs (L727-729)
```rust
        fail_point!("consensus::process_proposal_msg", |_| {
            Err(anyhow::anyhow!("Injected error in process_proposal_msg"))
        });
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1032-1038)
```rust
        fail_point!("aptos_vm::execute_script_or_entry_function", |_| {
            Err(VMStatus::Error {
                status_code: StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR,
                sub_status: Some(move_core_types::vm_status::sub_status::unknown_invariant_violation::EPARANOID_FAILURE),
                message: None,
            })
        });
```

**File:** config/src/config/api_config.rs (L177-184)
```rust
        // Verify that failpoints are not enabled in mainnet
        if let Some(chain_id) = chain_id {
            if chain_id.is_mainnet() && api_config.failpoints_enabled {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "Failpoints are not supported on mainnet nodes!".into(),
                ));
            }
```
