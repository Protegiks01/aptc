# Audit Report

## Title
Transaction Filter Bypass via Future TransactionPayload Variant Additions

## Summary
The transaction filter implementation contains a design flaw where future additions of new `TransactionPayload` variants will default to returning `false` in all matcher functions, causing them to bypass filter rules and be allowed by default, undermining the security guarantees of mempool and consensus filtering.

## Finding Description

The transaction filter system is designed to allow/deny transactions based on configurable rules. [1](#0-0) 

Currently, `TransactionPayload` has 6 variants that must be exhaustively matched: [2](#0-1) 

All filter matching functions use exhaustive pattern matching: [3](#0-2) 

**The Vulnerability:**

When a new `TransactionPayload` variant is added in the future:

1. All match statements will fail to compile (Rust exhaustive matching)
2. Developers will add the new variant to ~6-8 match statements across the file
3. The natural/quick fix is: `NewVariant(_) => false,` (returning false for all matchers)
4. This causes the new variant to **never match any filter rule**
5. When no rules match, the default behavior is to **ALLOW the transaction**

**Exploitation Path:**

Given a filter configuration:
```
Deny(vec![EntryFunction(0x1, "coin", "transfer")])  // Deny coin transfers
```

When a transaction arrives with `TransactionPayload::NewVariant(...)`:
- `matches_entry_function()` returns `false` (doesn't match)
- The Deny rule doesn't apply
- No other rules match
- Default behavior: **ALLOW** (line 46)
- Transaction bypasses the intended deny filter

**Affected Systems:**

Mempool filtering: [4](#0-3) 

Consensus block filtering: [5](#0-4) 

Both use the same "allow by default if no rules match" pattern, making them vulnerable to the same bypass.

## Impact Explanation

**Medium Severity** per Aptos bug bounty criteria:

- **State inconsistencies requiring intervention**: Filters are security controls that operators rely on to enforce policies (e.g., preventing certain transactions during emergency periods, blocking specific accounts). Bypassing these controls creates state inconsistencies between intended policy and actual enforcement.

- **Protocol violation**: The documented behavior states "the first matching rule determines the outcome" and "if no rules match, allow by default". The vulnerability breaks the invariant that deny rules will block matching transactions.

- **Not Critical/High** because:
  - Does not directly cause fund loss or consensus break
  - Requires a new payload variant to be added (future development)
  - Does not affect currently deployed code

## Likelihood Explanation

**High Likelihood** in future versions:

1. **Aptos is actively evolving**: New transaction formats are explicitly mentioned in code comments as planned additions [6](#0-5) 

2. **Developer behavior is predictable**: When adding a new variant, the quickest fix to compilation errors is to add `=> false` to all match statements

3. **No safeguards exist**: There are no assertions, runtime checks, or documentation warning developers about this pattern

4. **Filter configurations vary**: Many operators use specific deny rules without catch-all defaults, making them vulnerable

## Recommendation

**Add a defensive default that fails-safe instead of fails-open:**

```rust
fn matches_entry_function(
    signed_transaction: &SignedTransaction,
    address: &AccountAddress,
    module_name: &String,
    function: &String,
) -> bool {
    match signed_transaction.payload() {
        TransactionPayload::Script(_) | TransactionPayload::ModuleBundle(_) => false,
        TransactionPayload::Multisig(multisig) => { /* ... */ },
        TransactionPayload::EntryFunction(entry_function) => { /* ... */ },
        TransactionPayload::Payload(TransactionPayloadInner::V1 { executable, .. }) => { /* ... */ },
        TransactionPayload::EncryptedPayload(payload) => { /* ... */ },
        
        // DEFENSIVE: For any future variants, log a warning and return true to match conservatively
        // This ensures new variants are caught by deny filters rather than bypassing them
        #[allow(unreachable_patterns)]
        _ => {
            error!("Unknown TransactionPayload variant encountered in filter - conservatively matching");
            true  // Conservative default: match all deny rules
        }
    }
}
```

**Better: Use a trait-based design:**

Define a trait on `TransactionPayload` that returns filter-relevant information, forcing new variants to explicitly implement matching logic.

**Short-term: Add documentation and testing:**

Add explicit warnings in code comments and integration tests that verify new payload variants are properly handled by filters.

## Proof of Concept

```rust
#[cfg(test)]
mod test_future_bypass {
    use super::*;
    
    // This test demonstrates the vulnerability when a new variant is added
    // Currently won't compile, but shows the pattern
    
    #[test]
    fn test_new_variant_bypasses_deny_filter() {
        // Create a deny filter for coin transfers
        let filter = TransactionFilter::empty()
            .add_entry_function_filter(false, 
                AccountAddress::from_hex_literal("0x1").unwrap(),
                "coin".to_string(), 
                "transfer".to_string());
        
        // Create a transaction with the hypothetical new variant
        // If TransactionPayload::NewVariant existed and returned false in matchers:
        // let txn = create_transaction_with_new_variant();
        
        // This would incorrectly return true (allowed) despite the deny rule
        // assert!(filter.allows_transaction(&txn)); // BYPASS!
        
        // Expected behavior: should return false (denied)
    }
    
    #[test]
    fn test_filter_requires_catchall_for_safety() {
        // Filters WITHOUT a final catch-all are vulnerable to future bypasses
        let unsafe_filter = TransactionFilter::empty()
            .add_entry_function_filter(false, 
                AccountAddress::from_hex_literal("0x1").unwrap(),
                "coin".to_string(),
                "transfer".to_string());
        // Missing: .add_all_filter(false)
        
        // Safe filters include a catch-all deny at the end
        let safe_filter = TransactionFilter::empty()
            .add_entry_function_filter(true, 
                AccountAddress::from_hex_literal("0x1").unwrap(),
                "account".to_string(),
                "create_account".to_string())
            .add_all_filter(false); // Deny everything else
    }
}
```

**Notes**

This vulnerability represents a **forward-compatibility security flaw** in the filter design. While all current `TransactionPayload` variants are properly handled [7](#0-6) , the pattern of exhaustive matching with `false` returns creates an attack surface for future payload additions. The same pattern exists in multiple matcher functions [8](#0-7)  and affects all three filter types (TransactionFilter, BlockTransactionFilter, BatchTransactionFilter), amplifying the risk. Operators who configure filters without catch-all deny rules will be particularly vulnerable when new variants are introduced.

### Citations

**File:** crates/aptos-transaction-filters/src/transaction_filter.rs (L29-46)
```rust
    /// Returns true iff the filter allows the transaction
    pub fn allows_transaction(&self, signed_transaction: &SignedTransaction) -> bool {
        // If the filter is empty, allow the transaction by default
        if self.is_empty() {
            return true;
        }

        // Check if any rule matches the transaction
        for transaction_rule in &self.transaction_rules {
            if transaction_rule.matches(signed_transaction) {
                return match transaction_rule {
                    TransactionRule::Allow(_) => true,
                    TransactionRule::Deny(_) => false,
                };
            }
        }

        true // No rules match (allow the transaction by default)
```

**File:** crates/aptos-transaction-filters/src/transaction_filter.rs (L333-375)
```rust
fn matches_entry_function(
    signed_transaction: &SignedTransaction,
    address: &AccountAddress,
    module_name: &String,
    function: &String,
) -> bool {
    // Match all variants explicitly to ensure future enum changes are caught during compilation
    match signed_transaction.payload() {
        TransactionPayload::Script(_) | TransactionPayload::ModuleBundle(_) => false,
        TransactionPayload::Multisig(multisig) => multisig
            .transaction_payload
            .as_ref()
            .map(|payload| match payload {
                MultisigTransactionPayload::EntryFunction(entry_function) => {
                    compare_entry_function(entry_function, address, module_name, function)
                },
            })
            .unwrap_or(false),
        TransactionPayload::EntryFunction(entry_function) => {
            compare_entry_function(entry_function, address, module_name, function)
        },
        TransactionPayload::Payload(TransactionPayloadInner::V1 { executable, .. }) => {
            match executable.as_ref() {
                TransactionExecutableRef::Script(_) | TransactionExecutableRef::Empty => false,
                TransactionExecutableRef::EntryFunction(entry_function) => {
                    compare_entry_function(entry_function, address, module_name, function)
                },
            }
        },
        TransactionPayload::EncryptedPayload(payload) => {
            if let Ok(executable) = payload.executable_ref() {
                match executable {
                    TransactionExecutableRef::Script(_) | TransactionExecutableRef::Empty => false,
                    TransactionExecutableRef::EntryFunction(entry_function) => {
                        compare_entry_function(entry_function, address, module_name, function)
                    },
                }
            } else {
                false
            }
        },
    }
}
```

**File:** crates/aptos-transaction-filters/src/transaction_filter.rs (L377-418)
```rust
/// Returns true iff the transaction's module address matches the given account address
fn matches_entry_function_module_address(
    signed_transaction: &SignedTransaction,
    module_address: &AccountAddress,
) -> bool {
    // Match all variants explicitly to ensure future enum changes are caught during compilation
    match signed_transaction.payload() {
        TransactionPayload::Script(_) | TransactionPayload::ModuleBundle(_) => false,
        TransactionPayload::Multisig(multisig) => multisig
            .transaction_payload
            .as_ref()
            .map(|payload| match payload {
                MultisigTransactionPayload::EntryFunction(entry_function) => {
                    compare_entry_function_module_address(entry_function, module_address)
                },
            })
            .unwrap_or(false),
        TransactionPayload::EntryFunction(entry_function) => {
            compare_entry_function_module_address(entry_function, module_address)
        },
        TransactionPayload::Payload(TransactionPayloadInner::V1 { executable, .. }) => {
            match executable.as_ref() {
                TransactionExecutableRef::Script(_) | TransactionExecutableRef::Empty => false,
                TransactionExecutableRef::EntryFunction(entry_function) => {
                    compare_entry_function_module_address(entry_function, module_address)
                },
            }
        },
        TransactionPayload::EncryptedPayload(payload) => {
            if let Ok(executable) = payload.executable_ref() {
                match executable {
                    TransactionExecutableRef::Script(_) | TransactionExecutableRef::Empty => false,
                    TransactionExecutableRef::EntryFunction(entry_function) => {
                        compare_entry_function_module_address(entry_function, module_address)
                    },
                }
            } else {
                false
            }
        },
    }
}
```

**File:** types/src/transaction/mod.rs (L689-706)
```rust
#[derive(Clone, Debug, Hash, Eq, PartialEq, Serialize, Deserialize)]
pub enum TransactionPayload {
    /// A transaction that executes code.
    Script(Script),
    /// Deprecated.
    ModuleBundle(DeprecatedPayload),
    /// A transaction that executes an existing entry function published on-chain.
    EntryFunction(EntryFunction),
    /// A multisig transaction that allows an owner of a multisig account to execute a pre-approved
    /// transaction as the multisig account.
    Multisig(Multisig),
    /// A new transaction payload format with support for versioning.
    /// Contains an executable (script/entry function) along with extra configuration.
    /// Once this new format is fully rolled out, above payload variants will be deprecated.
    Payload(TransactionPayloadInner),
    /// Represents an encrypted transaction payload
    EncryptedPayload(EncryptedPayload),
}
```

**File:** mempool/src/shared_mempool/tasks.rs (L408-466)
```rust
fn filter_transactions(
    transaction_filter_config: &TransactionFilterConfig,
    transactions: Vec<(
        SignedTransaction,
        Option<u64>,
        Option<BroadcastPeerPriority>,
    )>,
    statuses: &mut Vec<(SignedTransaction, (MempoolStatus, Option<StatusCode>))>,
) -> Vec<(
    SignedTransaction,
    Option<u64>,
    Option<BroadcastPeerPriority>,
)> {
    // If the filter is not enabled, return early
    if !transaction_filter_config.is_enabled() {
        return transactions;
    }

    // Start the filter processing timer
    let transaction_filter_timer = counters::PROCESS_TXN_BREAKDOWN_LATENCY
        .with_label_values(&[counters::FILTER_TRANSACTIONS_LABEL])
        .start_timer();

    // Filter the transactions and update the statuses accordingly
    let transactions = transactions
        .into_iter()
        .filter_map(|(transaction, account_sequence_number, priority)| {
            if transaction_filter_config
                .transaction_filter()
                .allows_transaction(&transaction)
            {
                Some((transaction, account_sequence_number, priority))
            } else {
                info!(LogSchema::event_log(
                    LogEntry::TransactionFilter,
                    LogEvent::TransactionRejected
                )
                .message(&format!(
                    "Transaction {} rejected by filter",
                    transaction.committed_hash()
                )));

                statuses.push((
                    transaction.clone(),
                    (
                        MempoolStatus::new(MempoolStatusCode::RejectedByFilter),
                        None,
                    ),
                ));
                None
            }
        })
        .collect();

    // Update the filter processing latency metrics
    transaction_filter_timer.stop_and_record();

    transactions
}
```

**File:** crates/aptos-transaction-filters/src/block_transaction_filter.rs (L10-58)
```rust
/// A block transaction filter that applies a set of rules to determine
/// if a transaction in a block should be allowed or denied.
///
/// Rules are applied in the order they are defined, and the first
/// matching rule determines the outcome for the transaction.
/// If no rules match, the transaction is allowed by default.
#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
pub struct BlockTransactionFilter {
    block_transaction_rules: Vec<BlockTransactionRule>,
}

impl BlockTransactionFilter {
    pub fn new(block_transaction_rules: Vec<BlockTransactionRule>) -> Self {
        Self {
            block_transaction_rules,
        }
    }

    /// Returns true iff the filter allows the transaction in the block
    pub fn allows_transaction(
        &self,
        block_id: HashValue,
        block_author: Option<AccountAddress>,
        block_epoch: u64,
        block_timestamp: u64,
        signed_transaction: &SignedTransaction,
    ) -> bool {
        // If the filter is empty, allow the transaction by default
        if self.is_empty() {
            return true;
        }

        // Check if any rule matches the block transaction
        for block_transaction_rule in &self.block_transaction_rules {
            if block_transaction_rule.matches(
                block_id,
                block_author,
                block_epoch,
                block_timestamp,
                signed_transaction,
            ) {
                return match block_transaction_rule {
                    BlockTransactionRule::Allow(_) => true,
                    BlockTransactionRule::Deny(_) => false,
                };
            }
        }

        true // No rules match (allow the block transaction by default)
```
