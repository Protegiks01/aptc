# Audit Report

## Title
Unverified Target Ledger Info Selection Enables State Sync Denial of Service

## Summary
The state synchronization system selects a target ledger info from peer advertisements without cryptographic verification, allowing malicious peers to advertise arbitrarily high versions that stall synchronization until retry limits are exhausted.

## Finding Description

The vulnerability exists in how continuous transaction streams select their synchronization target. When `highest_synced_ledger_info()` is used to determine which version to sync to, it selects the ledger info with the highest version number from all peer advertisements without verifying the signatures or validity of that ledger info.

**Attack Flow:**

1. **Malicious Advertisement**: An attacker-controlled peer advertises a `StorageServerSummary` with a `synced_ledger_info` containing an arbitrarily high version (e.g., 10,000,000 when honest peers are at 100,000). [1](#0-0) 

2. **Unverified Aggregation**: The data client aggregates all peer advertisements including the malicious one without verification. [2](#0-1) 

3. **Highest Version Selection**: `highest_synced_ledger_info()` selects the malicious ledger info purely based on version number. [3](#0-2) 

4. **Target Set Without Verification**: The continuous transaction stream engine sets this unverified ledger info as the sync target. [4](#0-3) 

5. **Synchronization Stall**: The stream creates requests for data at the impossible version. Honest peers cannot service these requests because they don't have data at that version. [5](#0-4) 

6. **Retry Exhaustion**: The system retries up to `max_request_retry` times (default: 5) with exponentially increasing timeouts before terminating the stream. [6](#0-5) [7](#0-6) 

**The Critical Gap**: While ledger info signatures ARE verified when data is received, verification does NOT occur when selecting the target ledger info. The verification only happens at: [8](#0-7) [9](#0-8) 

But by this point, the stream has already committed to an unreachable target.

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos bug bounty program criteria for "Validator node slowdowns" and "Significant protocol violations."

**Demonstrated Impact:**
- Syncing nodes experience repeated synchronization failures and delays
- Each failed attempt incurs exponentially increasing timeout delays (up to `max_response_timeout_ms`)
- Multiple retry cycles before stream termination delay synchronization by minutes
- If the attacker maintains multiple malicious peers or the malicious peer isn't fully ignored before stream restart, the attack can be repeated
- This degrades validator performance and delays their ability to participate in consensus

The attack does not cause permanent liveness loss because:
- Stream terminates after 5 retries by default
- Malicious peers eventually get ignored when their score drops below the threshold
- New streams can be created after termination

However, the disruption window is significant and can be extended if the attacker operates multiple peers.

## Likelihood Explanation

**Likelihood: High**

**Attacker Requirements:**
- Ability to run a network peer (no validator credentials needed)
- Ability to advertise a storage summary with fabricated `synced_ledger_info`
- No stake or governance participation required

**Attack Complexity: Low**
- Simply advertise a `StorageServerSummary` with inflated version number
- The system automatically selects it due to highest version logic
- No sophisticated timing or coordination needed

**Detection Difficulty: Medium**
- Attacks appear as legitimate synchronization failures initially
- Requires correlation of peer advertisements with sync failures to identify malicious peers
- Peer scoring eventually identifies and ignores the malicious peer, but not before causing disruption

## Recommendation

**Immediate Fix**: Verify ledger info signatures before using it as a synchronization target.

Add verification in `select_target_ledger_info()`:

```rust
fn select_target_ledger_info(
    &self,
    advertised_data: &AdvertisedData,
    epoch_state: &EpochState,  // Add parameter
) -> Result<Option<LedgerInfoWithSignatures>, Error> {
    // ... existing final target check ...

    // Get the highest synced ledger info
    if let Some(highest_synced_ledger_info) = advertised_data.highest_synced_ledger_info() {
        // VERIFY SIGNATURES BEFORE USING AS TARGET
        epoch_state.verify(&highest_synced_ledger_info).map_err(|error| {
            Error::VerificationError(format!(
                "Advertised ledger info failed verification: {:?}", 
                error
            ))
        })?;
        
        let (next_request_version, _) = self.next_request_version_and_epoch;
        if next_request_version > highest_synced_ledger_info.ledger_info().version() {
            Ok(None)
        } else {
            Ok(Some(highest_synced_ledger_info))
        }
    } else {
        Err(Error::DataIsUnavailable(
            "Unable to find the highest synced ledger info!".into(),
        ))
    }
}
```

**Alternative/Additional Mitigations:**

1. **Sanity Check Version Bounds**: Reject ledger infos with versions more than a threshold above the current known maximum from trusted sources.

2. **Require Quorum Agreement**: Only select targets that are advertised by multiple peers (quorum-based selection).

3. **Faster Peer Blacklisting**: More aggressively penalize peers that advertise data they cannot deliver.

4. **Verification in Aggregation**: Verify signatures when adding to `synced_ledger_infos` list in `calculate_global_data_summary()`.

## Proof of Concept

```rust
// Malicious Peer PoC - demonstrates creating and advertising fake ledger info

use aptos_types::{
    ledger_info::{LedgerInfo, LedgerInfoWithSignatures},
    block_info::BlockInfo,
    aggregate_signature::AggregateSignature,
};
use aptos_storage_service_types::responses::{
    DataSummary, StorageServerSummary, ProtocolMetadata,
};

fn create_malicious_storage_summary() -> StorageServerSummary {
    // Create a fake ledger info with arbitrarily high version
    let malicious_version = 10_000_000_u64;  // Far beyond honest peers
    let malicious_epoch = 1000_u64;
    
    let block_info = BlockInfo::new(
        malicious_epoch,
        0, // round
        HashValue::zero(),
        HashValue::zero(), 
        malicious_version,
        0, // timestamp
        None, // next_epoch_state
    );
    
    let ledger_info = LedgerInfo::new(block_info, HashValue::zero());
    
    // Create fake signatures (will appear valid until verification)
    let fake_signatures = AggregateSignature::empty();
    let malicious_ledger_info = LedgerInfoWithSignatures::new(
        ledger_info,
        fake_signatures,
    );
    
    // Create storage summary with malicious ledger info
    let data_summary = DataSummary {
        synced_ledger_info: Some(malicious_ledger_info),
        epoch_ending_ledger_infos: None,
        transactions: None,
        transaction_outputs: None,
        states: None,
    };
    
    StorageServerSummary {
        protocol_metadata: ProtocolMetadata::default(),
        data_summary,
    }
}

// When honest node's continuous syncer initializes stream:
// 1. Poller fetches malicious summary and updates peer states
// 2. Global summary includes malicious ledger info
// 3. highest_synced_ledger_info() returns malicious target (version 10M)
// 4. Stream tries to sync to version 10M
// 5. No peers can service requests at version 10M
// 6. Requests fail repeatedly for 5 retries with increasing timeouts
// 7. Stream terminates after several minutes of delays
```

**Testing Steps:**
1. Deploy a malicious peer advertising inflated `synced_ledger_info`
2. Observe honest node's data client includes the malicious advertisement in global summary
3. Observe continuous transaction stream selects the inflated version as target
4. Observe synchronization requests fail to find serviceable peers
5. Observe retry delays and eventual stream termination
6. Measure total synchronization delay caused by the attack

## Notes

This vulnerability demonstrates a verification gap where advertised metadata is trusted without cryptographic validation. While the system has recovery mechanisms (retry limits, peer scoring), the disruption window is significant enough to impact network performance. The fix is straightforward: verify signatures before committing to a synchronization target, applying the same verification logic currently used for received data.

### Citations

**File:** state-sync/storage-service/server/src/storage.rs (L1036-1073)
```rust
    fn get_data_summary(&self) -> aptos_storage_service_types::Result<DataSummary, Error> {
        // Fetch the latest ledger info
        let latest_ledger_info_with_sigs = self.storage.get_latest_ledger_info()?;

        // Fetch the epoch ending ledger info range
        let latest_ledger_info = latest_ledger_info_with_sigs.ledger_info();
        let epoch_ending_ledger_infos = if latest_ledger_info.ends_epoch() {
            let highest_ending_epoch = latest_ledger_info.epoch();
            Some(CompleteDataRange::from_genesis(highest_ending_epoch))
        } else if latest_ledger_info.epoch() > 0 {
            let highest_ending_epoch =
                latest_ledger_info.epoch().checked_sub(1).ok_or_else(|| {
                    Error::UnexpectedErrorEncountered("Highest ending epoch overflowed!".into())
                })?;
            Some(CompleteDataRange::from_genesis(highest_ending_epoch))
        } else {
            None // We haven't seen an epoch change yet
        };

        // Fetch the transaction and transaction output ranges
        let latest_version = latest_ledger_info.version();
        let transactions = self.fetch_transaction_range(latest_version)?;
        let transaction_outputs = self.fetch_transaction_output_range(latest_version)?;

        // Fetch the state values range
        let states = self.fetch_state_values_range(latest_version, &transactions)?;

        // Return the relevant data summary
        let data_summary = DataSummary {
            synced_ledger_info: Some(latest_ledger_info_with_sigs),
            epoch_ending_ledger_infos,
            transactions,
            transaction_outputs,
            states,
        };

        Ok(data_summary)
    }
```

**File:** state-sync/aptos-data-client/src/peer_states.rs (L338-408)
```rust
    /// Calculates a global data summary using all known storage summaries
    pub fn calculate_global_data_summary(&self) -> GlobalDataSummary {
        // Gather all storage summaries, but exclude peers that are ignored
        let storage_summaries: Vec<StorageServerSummary> = self
            .peer_to_state
            .iter()
            .filter_map(|peer_state| {
                peer_state
                    .value()
                    .get_storage_summary_if_not_ignored()
                    .cloned()
            })
            .collect();

        // If we have no peers, return an empty global summary
        if storage_summaries.is_empty() {
            return GlobalDataSummary::empty();
        }

        // Calculate the global data summary using the advertised peer data
        let mut advertised_data = AdvertisedData::empty();
        let mut max_epoch_chunk_sizes = vec![];
        let mut max_state_chunk_sizes = vec![];
        let mut max_transaction_chunk_sizes = vec![];
        let mut max_transaction_output_chunk_sizes = vec![];
        for summary in storage_summaries {
            // Collect aggregate data advertisements
            if let Some(epoch_ending_ledger_infos) = summary.data_summary.epoch_ending_ledger_infos
            {
                advertised_data
                    .epoch_ending_ledger_infos
                    .push(epoch_ending_ledger_infos);
            }
            if let Some(states) = summary.data_summary.states {
                advertised_data.states.push(states);
            }
            if let Some(synced_ledger_info) = summary.data_summary.synced_ledger_info.as_ref() {
                advertised_data
                    .synced_ledger_infos
                    .push(synced_ledger_info.clone());
            }
            if let Some(transactions) = summary.data_summary.transactions {
                advertised_data.transactions.push(transactions);
            }
            if let Some(transaction_outputs) = summary.data_summary.transaction_outputs {
                advertised_data
                    .transaction_outputs
                    .push(transaction_outputs);
            }

            // Collect preferred max chunk sizes
            max_epoch_chunk_sizes.push(summary.protocol_metadata.max_epoch_chunk_size);
            max_state_chunk_sizes.push(summary.protocol_metadata.max_state_chunk_size);
            max_transaction_chunk_sizes.push(summary.protocol_metadata.max_transaction_chunk_size);
            max_transaction_output_chunk_sizes
                .push(summary.protocol_metadata.max_transaction_output_chunk_size);
        }

        // Calculate optimal chunk sizes based on the advertised data
        let optimal_chunk_sizes = calculate_optimal_chunk_sizes(
            &self.data_client_config,
            max_epoch_chunk_sizes,
            max_state_chunk_sizes,
            max_transaction_chunk_sizes,
            max_transaction_output_chunk_sizes,
        );
        GlobalDataSummary {
            advertised_data,
            optimal_chunk_sizes,
        }
    }
```

**File:** state-sync/aptos-data-client/src/global_summary.rs (L184-198)
```rust
    pub fn highest_synced_ledger_info(&self) -> Option<LedgerInfoWithSignatures> {
        let highest_synced_position = self
            .synced_ledger_infos
            .iter()
            .map(|ledger_info_with_sigs| ledger_info_with_sigs.ledger_info().version())
            .position_max();

        if let Some(highest_synced_position) = highest_synced_position {
            self.synced_ledger_infos
                .get(highest_synced_position)
                .cloned()
        } else {
            None
        }
    }
```

**File:** state-sync/data-streaming-service/src/stream_engine.rs (L1188-1221)
```rust
        if self.current_target_ledger_info.is_none() {
            // Try to select a new ledger info from the advertised data
            if let Some(target_ledger_info) =
                self.select_target_ledger_info(&global_data_summary.advertised_data)?
            {
                if target_ledger_info.ledger_info().epoch() > next_request_epoch {
                    // There was an epoch change. Request an epoch ending ledger info.
                    info!(
                        (LogSchema::new(LogEntry::AptosDataClient)
                            .event(LogEvent::Pending)
                            .message(&format!(
                                "Requested an epoch ending ledger info for epoch: {:?}",
                                next_request_epoch
                            )))
                    );
                    self.end_of_epoch_requested = true;
                    return Ok(vec![DataClientRequest::EpochEndingLedgerInfos(
                        EpochEndingLedgerInfosRequest {
                            start_epoch: next_request_epoch,
                            end_epoch: next_request_epoch,
                        },
                    )]);
                } else {
                    debug!(
                        (LogSchema::new(LogEntry::ReceivedDataResponse)
                            .event(LogEvent::Success)
                            .message(&format!(
                                "Setting new target ledger info. Version: {:?}, Epoch: {:?}",
                                target_ledger_info.ledger_info().version(),
                                target_ledger_info.ledger_info().epoch()
                            )))
                    );
                    self.current_target_ledger_info = Some(target_ledger_info);
                }
```

**File:** state-sync/data-streaming-service/src/stream_engine.rs (L1259-1266)
```rust
            let client_requests = create_data_client_request_batch(
                next_request_version,
                target_ledger_info.ledger_info().version(),
                num_requests_to_send,
                optimal_chunk_sizes,
                self.clone().into(),
            )?;
            self.update_request_tracking(&client_requests, &target_ledger_info)?;
```

**File:** config/src/config/state_sync_config.rs (L254-277)
```rust
    /// Maximum number of retries for a single client request before a data
    /// stream will terminate.
    pub max_request_retry: u64,

    /// Maximum lag (in seconds) we'll tolerate when sending subscription requests
    pub max_subscription_stream_lag_secs: u64,

    /// The interval (milliseconds) at which to check the progress of each stream.
    pub progress_check_interval_ms: u64,
}

impl Default for DataStreamingServiceConfig {
    fn default() -> Self {
        Self {
            dynamic_prefetching: DynamicPrefetchingConfig::default(),
            enable_subscription_streaming: false,
            global_summary_refresh_interval_ms: 50,
            max_concurrent_requests: MAX_CONCURRENT_REQUESTS,
            max_concurrent_state_requests: MAX_CONCURRENT_STATE_REQUESTS,
            max_data_stream_channel_sizes: 50,
            max_notification_id_mappings: 300,
            max_num_consecutive_subscriptions: 45, // At ~3 blocks per second, this should last ~15 seconds
            max_pending_requests: 50,
            max_request_retry: 5,
```

**File:** state-sync/data-streaming-service/src/data_stream.rs (L446-454)
```rust
        if self.stream_engine.is_stream_complete()
            || self.request_failure_count >= self.streaming_service_config.max_request_retry
            || self.send_failure
        {
            if !self.send_failure && self.stream_end_notification_id.is_none() {
                self.send_end_of_stream_notification().await?;
            }
            return Ok(()); // There's nothing left to do
        }
```

**File:** state-sync/state-sync-driver/src/continuous_syncer.rs (L452-466)
```rust
        // Verify the ledger info state and signatures
        if let Err(error) = self
            .get_speculative_stream_state()?
            .verify_ledger_info_with_signatures(ledger_info_with_signatures)
        {
            self.reset_active_stream(Some(NotificationAndFeedback::new(
                notification_id,
                NotificationFeedback::PayloadProofFailed,
            )))
            .await?;
            Err(error)
        } else {
            Ok(())
        }
    }
```

**File:** state-sync/state-sync-driver/src/utils.rs (L100-110)
```rust
    /// Verifies the given ledger info with signatures against the current epoch state
    pub fn verify_ledger_info_with_signatures(
        &mut self,
        ledger_info_with_signatures: &LedgerInfoWithSignatures,
    ) -> Result<(), Error> {
        self.epoch_state
            .verify(ledger_info_with_signatures)
            .map_err(|error| {
                Error::VerificationError(format!("Ledger info failed verification: {:?}", error))
            })
    }
```
