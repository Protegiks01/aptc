# Audit Report

## Title
Missing Sender Authentication in Remote Executor Service Enables Consensus Manipulation

## Summary
The remote executor service network controller lacks sender authentication, allowing any network peer to inject fake execution results, state view data, or cross-shard messages. The dead code markers reveal an incomplete implementation where sender tracking was planned but never finished, leaving a critical security gap in the sharded block execution system. [1](#0-0) 

## Finding Description

The `NetworkMessage` struct contains a `sender: SocketAddr` field intended for sender authentication, but this struct is marked as dead code and completely unused. Instead, the actual gRPC implementation uses a protobuf `NetworkMessage` without sender tracking. [2](#0-1) 

The gRPC server receives `remote_addr` but only logs it in error cases - it never validates message sources or passes sender information to handlers. This breaks the **Deterministic Execution** invariant: an attacker can send fake execution results to the coordinator, causing different validator nodes to commit different state roots for identical blocks.

Attack flow:
1. Remote executor shards communicate via unauthenticated gRPC (`http://` without TLS)
2. Coordinator sends execution commands to shards 
3. Shards return execution results with no sender verification
4. Attacker races to send fake `RemoteExecutionResult` before legitimate shard responds
5. Coordinator accepts attacker's fake results and commits incorrect state [3](#0-2) 

The executor workflow uses this vulnerable remote executor when addresses are configured: [4](#0-3) 

The dead error modules further confirm incomplete implementation: [5](#0-4) [6](#0-5) 

## Impact Explanation

**Severity: HIGH** - Significant protocol violation per Aptos bug bounty criteria.

If the remote executor service is deployed:
- **Consensus Safety Violation**: Attackers can cause different validators to execute blocks with different results, breaking consensus safety guarantees
- **State Corruption**: Fake state view responses lead to incorrect transaction execution
- **Execution Result Manipulation**: Coordinator accepts fabricated execution outputs

This breaks the fundamental invariant that "all validators must produce identical state roots for identical blocks."

## Likelihood Explanation

**Likelihood: MEDIUM**

The remote executor is configurable and deployable via `ProcessExecutorService`: [7](#0-6) 

While not confirmed to be deployed in production mainnet, the feature is:
- Fully implemented with production-ready code
- Integrated into the core execution workflow
- Configurable via command-line arguments
- Used in benchmarking and testing environments

Network access requirements:
- Attacker must reach executor service gRPC endpoints (typically configured with IP:PORT)
- No additional authentication required once network access is obtained
- Endpoints may be exposed in misconfigured deployments or compromised networks

## Recommendation

Implement proper sender authentication using one of these approaches:

**Option 1: Use Aptos Network Framework's Noise Protocol**
Replace `aptos_secure_net` with the authenticated `network/framework` that implements NoiseIK handshake with mutual authentication.

**Option 2: Implement Application-Level Authentication**
Complete the incomplete sender authentication by:

1. Add sender verification to message handlers:
```rust
pub struct NetworkMessage {
    pub sender: SocketAddr,
    pub message: Message,
    pub message_type: MessageType,
}
```

2. Validate sender in the gRPC handler:
```rust
async fn simple_msg_exchange(
    &self,
    request: Request<NetworkMessage>,
) -> Result<Response<Empty>, Status> {
    let remote_addr = request.remote_addr().ok_or(Status::unauthenticated("No remote address"))?;
    
    // Validate remote_addr is in allowed shard addresses
    if !self.is_authorized_sender(&remote_addr) {
        return Err(Status::permission_denied("Unauthorized sender"));
    }
    // ... rest of handler
}
```

3. Use TLS for transport encryption and certificate-based authentication

**Option 3: Network Isolation**
If authentication cannot be added immediately, document that remote executor must only run on isolated, trusted networks (e.g., localhost, private VPC) and add runtime checks to prevent deployment on untrusted networks.

## Proof of Concept

```rust
// Malicious client that sends fake execution results
use aptos_protos::remote_executor::v1::{
    network_message_service_client::NetworkMessageServiceClient,
    NetworkMessage,
};
use aptos_executor_service::RemoteExecutionResult;
use aptos_types::{transaction::TransactionOutput, vm_status::VMStatus};

#[tokio::test]
async fn test_unauthenticated_execution_result_injection() {
    // Assume coordinator is listening at localhost:52200
    let coordinator_addr = "http://127.0.0.1:52200";
    
    // Attacker creates fake execution result
    let fake_result = RemoteExecutionResult {
        inner: Ok(vec![vec![/* fake transaction outputs */]]),
    };
    
    let mut client = NetworkMessageServiceClient::connect(coordinator_addr)
        .await
        .expect("Failed to connect");
    
    // Send fake execution result - NO AUTHENTICATION REQUIRED
    let request = tonic::Request::new(NetworkMessage {
        message: bcs::to_bytes(&fake_result).unwrap(),
        message_type: "execute_result_0".to_string(), // Claim to be shard 0
    });
    
    // This succeeds - coordinator accepts fake result from any sender
    let response = client.simple_msg_exchange(request).await;
    assert!(response.is_ok(), "Fake message accepted without authentication");
}
```

**Notes:**
- The vulnerability exists in production-ready code that can be deployed
- Dead code markers (`#[allow(dead_code)]`) on lines 16, 23, 31, 57, 83 indicate incomplete security implementation
- The unused `NetworkMessage` struct with `sender` field shows authentication was planned but never implemented
- Both error modules (`secure/net/src/network_controller/error.rs` and `execution/executor-service/src/error.rs`) are marked dead code, suggesting error handling for authentication failures was never completed
- Exploitation requires network access to executor service endpoints, but no additional authentication
- Impact is HIGH if deployed, breaking consensus safety guarantees

### Citations

**File:** secure/net/src/network_controller/mod.rs (L23-28)
```rust
#[allow(dead_code)]
pub struct NetworkMessage {
    pub sender: SocketAddr,
    pub message: Message,
    pub message_type: MessageType,
}
```

**File:** secure/net/src/grpc_network_service/mod.rs (L93-115)
```rust
    async fn simple_msg_exchange(
        &self,
        request: Request<NetworkMessage>,
    ) -> Result<Response<Empty>, Status> {
        let _timer = NETWORK_HANDLER_TIMER
            .with_label_values(&[&self.self_addr.to_string(), "inbound_msgs"])
            .start_timer();
        let remote_addr = request.remote_addr();
        let network_message = request.into_inner();
        let msg = Message::new(network_message.message);
        let message_type = MessageType::new(network_message.message_type);

        if let Some(handler) = self.inbound_handlers.lock().unwrap().get(&message_type) {
            // Send the message to the registered handler
            handler.send(msg).unwrap();
        } else {
            error!(
                "No handler registered for sender: {:?} and msg type {:?}",
                remote_addr, message_type
            );
        }
        Ok(Response::new(Empty {}))
    }
```

**File:** execution/executor-service/src/remote_cordinator_client.rs (L115-119)
```rust
    fn send_execution_result(&self, result: Result<Vec<Vec<TransactionOutput>>, VMStatus>) {
        let remote_execution_result = RemoteExecutionResult::new(result);
        let output_message = bcs::to_bytes(&remote_execution_result).unwrap();
        self.result_tx.send(Message::new(output_message)).unwrap();
    }
```

**File:** execution/executor/src/workflow/do_get_execution_output.rs (L261-267)
```rust
        if !get_remote_addresses().is_empty() {
            Ok(V::execute_block_sharded(
                &REMOTE_SHARDED_BLOCK_EXECUTOR.lock(),
                partitioned_txns,
                state_view,
                onchain_config,
            )?)
```

**File:** secure/net/src/network_controller/error.rs (L1-16)
```rust
// Copyright (c) Aptos Foundation
// Licensed pursuant to the Innovation-Enabling Source Code License, available at https://github.com/aptos-labs/aptos-core/blob/main/LICENSE

use crate::network_controller;
use crossbeam_channel::{RecvError, SendError};
use serde::{Deserialize, Serialize};
use thiserror::Error;

#[derive(Clone, Debug, Deserialize, Error, PartialEq, Eq, Serialize)]
/// Different reasons for executor service fails to execute a block.
pub enum Error {
    #[error("Internal error: {0}")]
    InternalError(String),
    #[error("Serialization error: {0}")]
    SerializationError(String),
}
```

**File:** execution/executor-service/src/error.rs (L1-14)
```rust
// Copyright (c) Aptos Foundation
// Licensed pursuant to the Innovation-Enabling Source Code License, available at https://github.com/aptos-labs/aptos-core/blob/main/LICENSE

use serde::{Deserialize, Serialize};
use thiserror::Error;

#[derive(Clone, Debug, Deserialize, Error, PartialEq, Eq, Serialize)]
/// Different reasons for executor service fails to execute a block.
pub enum Error {
    #[error("Internal error: {0}")]
    InternalError(String),
    #[error("Serialization error: {0}")]
    SerializationError(String),
}
```

**File:** execution/executor-service/src/main.rs (L27-48)
```rust
fn main() {
    let args = Args::parse();
    aptos_logger::Logger::new().init();

    let (tx, rx) = crossbeam_channel::unbounded();
    ctrlc::set_handler(move || {
        tx.send(()).unwrap();
    })
    .expect("Error setting Ctrl-C handler");

    let _exe_service = ProcessExecutorService::new(
        args.shard_id,
        args.num_shards,
        args.num_executor_threads,
        args.coordinator_address,
        args.remote_executor_addresses,
    );

    rx.recv()
        .expect("Could not receive Ctrl-C msg from channel.");
    info!("Process executor service shutdown successfully.");
}
```
