# Audit Report

## Title
Missing Metrics for Consensus Observer Payload Retrieval Failures Enable Undetected Attacks

## Summary
The consensus observer payload manager lacks specific metrics to track payload retrieval failures (missing payloads) and unverified payload attempts. All such errors are aggregated under a generic "UnexpectedError" label, making it impossible for operators to detect and respond to targeted attacks against the consensus observer's payload delivery mechanism.

## Finding Description

The consensus observer uses `ConsensusObserverPayloadManager` to retrieve transaction payloads for block execution. When payloads are missing or unverified, the system returns generic `InternalError` responses without incrementing specific metrics. [1](#0-0) [2](#0-1) 

These errors are eventually tracked via `log_executor_error_occurred`, but all `InternalError` cases are lumped together as "UnexpectedError": [3](#0-2) 

Additionally, the payload store metrics only track total payload counts, not verification status distribution: [4](#0-3) 

**Attack Scenarios Enabled:**

1. **Payload Withholding DoS**: An attacker repeatedly sends ordered blocks without corresponding payloads, causing the observer to fail at execution. Without specific metrics, operators cannot distinguish this from transient network issues.

2. **Signature Verification Bypass Attempts**: An attacker races payload delivery with block ordering to trigger unverified payload errors, probing for timing vulnerabilities. These attempts go unmonitored.

3. **Eclipse Attack Detection Failure**: If an attacker partitions the network to prevent payload delivery to specific observers, repeated "missing payload" errors would be indistinguishable from normal operation in aggregate metrics.

## Impact Explanation

This is categorized as **Low Severity** per Aptos bug bounty criteria as it represents an observability gap rather than a direct exploitable vulnerability. While it doesn't directly enable fund theft or consensus violations, it significantly impairs an operator's ability to:

- Detect ongoing attacks against consensus observer nodes
- Distinguish malicious activity from benign network issues  
- Establish security baselines for normal vs. abnormal behavior
- Respond quickly to targeted payload delivery attacks

The lack of metrics allows attacks to persist undetected, potentially enabling reconnaissance for more sophisticated attacks or degrading observer reliability over time.

## Likelihood Explanation

The likelihood of this monitoring gap being exploited is **moderate to high** because:

1. Consensus observers are publicly accessible network endpoints
2. Payload delivery is a critical dependency for observer functionality
3. Attackers can easily send malformed messages or withhold payloads
4. Without specific metrics, operators operate blind to these attack patterns
5. The attack surface is continuously available to any network participant

## Recommendation

Add specific metrics to track payload retrieval failures:

```rust
// In consensus/src/counters.rs, add:
pub static CONSENSUS_OBSERVER_PAYLOAD_RETRIEVAL_ERRORS: Lazy<IntCounterVec> = Lazy::new(|| {
    register_int_counter_vec!(
        "aptos_consensus_observer_payload_retrieval_errors",
        "Count of payload retrieval errors by type",
        &["error_type"] // "missing_payload", "unverified_payload"
    )
    .unwrap()
});

pub static CONSENSUS_OBSERVER_PAYLOAD_VERIFICATION_STATUS: Lazy<IntGaugeVec> = Lazy::new(|| {
    register_int_gauge_vec!(
        "aptos_consensus_observer_payload_verification_status",
        "Number of payloads by verification status",
        &["status"] // "verified", "unverified"
    )
    .unwrap()
});
```

Update `get_transactions_for_observer` to increment specific counters:

```rust
// In consensus/src/payload_manager/co_payload_manager.rs
BlockPayloadStatus::AvailableAndUnverified(_) => {
    counters::CONSENSUS_OBSERVER_PAYLOAD_RETRIEVAL_ERRORS
        .with_label_values(&["unverified_payload"])
        .inc();
    return Err(InternalError { error });
},
// ... similar for missing payload case
```

Update `update_payload_store_metrics` to track verification status distribution:

```rust
// Count verified vs unverified payloads
let (verified_count, unverified_count) = self.block_payloads.lock()
    .values()
    .fold((0u64, 0u64), |(v, u), status| {
        match status {
            BlockPayloadStatus::AvailableAndVerified(_) => (v + 1, u),
            BlockPayloadStatus::AvailableAndUnverified(_) => (v, u + 1),
        }
    });

counters::CONSENSUS_OBSERVER_PAYLOAD_VERIFICATION_STATUS
    .with_label_values(&["verified"])
    .set(verified_count as i64);
counters::CONSENSUS_OBSERVER_PAYLOAD_VERIFICATION_STATUS
    .with_label_values(&["unverified"])
    .set(unverified_count as i64);
```

## Proof of Concept

This monitoring gap can be demonstrated by:

1. Running a consensus observer node with metric collection
2. Sending ordered blocks without corresponding payloads (simulating attack)
3. Observing that only generic "UnexpectedError" metrics increment
4. Confirming inability to distinguish this from other error types in dashboards

The test would show metrics aggregation prevents attack pattern detection:

```rust
#[tokio::test]
async fn test_missing_payload_metrics_gap() {
    // Setup consensus observer with empty payload store
    let payload_store = Arc::new(Mutex::new(BTreeMap::new()));
    let payload_manager = ConsensusObserverPayloadManager::new(
        payload_store.clone(),
        None,
    );
    
    // Attempt to get transactions for a block with missing payload
    let block = create_test_block(1, 100);
    let result = payload_manager.get_transactions(&block, None).await;
    
    // Error occurs but no specific "missing_payload" metric exists
    assert!(result.is_err());
    // Verify generic counter incremented (when error is logged)
    // Verify NO specific counter exists for missing payloads
}
```

## Notes

This finding represents a **legitimate security monitoring gap** that reduces an operator's ability to detect and respond to attacks. However, it does **not** constitute a direct exploitable vulnerability in the consensus protocol itself. The system continues to function correctly (rejecting invalid blocks), but operators lack visibility into attack patterns. This aligns with the "Low" severity classification in the security question.

### Citations

**File:** consensus/src/payload_manager/co_payload_manager.rs (L39-47)
```rust
            BlockPayloadStatus::AvailableAndUnverified(_) => {
                // This shouldn't happen (the payload should already be verified)
                let error = format!(
                    "Payload data for block epoch {}, round {} is unverified!",
                    block.epoch(),
                    block.round()
                );
                return Err(InternalError { error });
            },
```

**File:** consensus/src/payload_manager/co_payload_manager.rs (L49-57)
```rust
        Entry::Vacant(_) => {
            // This shouldn't happen (the payload should already be present)
            let error = format!(
                "Missing payload data for block epoch {}, round {}!",
                block.epoch(),
                block.round()
            );
            return Err(InternalError { error });
        },
```

**File:** consensus/src/counters.rs (L1204-1211)
```rust
        e => {
            counter.with_label_values(&["UnexpectedError"]).inc();
            warn!(
                block_id = block_id,
                "Execution error {:?} for {}", e, block_id
            );
        },
    }
```

**File:** consensus/src/consensus_observer/observer/payload_store.rs (L133-154)
```rust
    pub fn update_payload_store_metrics(&self) {
        // Update the number of block payloads
        let num_payloads = self.block_payloads.lock().len() as u64;
        metrics::set_gauge_with_label(
            &metrics::OBSERVER_NUM_PROCESSED_BLOCKS,
            metrics::STORED_PAYLOADS_LABEL,
            num_payloads,
        );

        // Update the highest round for the block payloads
        let highest_round = self
            .block_payloads
            .lock()
            .last_key_value()
            .map(|((_, round), _)| *round)
            .unwrap_or(0);
        metrics::set_gauge_with_label(
            &metrics::OBSERVER_PROCESSED_BLOCK_ROUNDS,
            metrics::STORED_PAYLOADS_LABEL,
            highest_round,
        );
    }
```
