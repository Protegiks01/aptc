# Audit Report

## Title
Missing Low-Order Point Validation in x25519 Noise Handshake Enables Session Key Compromise

## Summary
The Noise IK handshake implementation in Aptos Core fails to validate x25519 public keys against low-order curve points. An attacker can provide weak ephemeral or static keys during the handshake, causing predictable Diffie-Hellman outputs that compromise the derived session keys. This affects both the telemetry service authentication and validator peer-to-peer networking.

## Finding Description
The x25519 public key implementation does not validate against low-order points when deserializing keys from bytes. [1](#0-0) 

The Noise handshake implementation receives client public keys and directly uses them in Diffie-Hellman operations without validation. [2](#0-1) 

During the Noise IK handshake, the responder (server) performs two critical Diffie-Hellman operations:
1. **es**: Server's static key with client's ephemeral key (`re`)
2. **ss**: Server's static key with client's static key (`rs`)

If an attacker provides low-order points for either `e` or `s` (or both), the DH outputs become predictable. Curve25519 has 8 known low-order points (torsion points), including the identity point (all zeros). [3](#0-2) 

These predictable DH outputs flow through HKDF to derive encryption keys used in the handshake. With weak DH outputs, the derived keys become predictable, allowing the attacker to:
- Decrypt the server's handshake response
- Obtain the JWT token sent by the telemetry service
- Decrypt or forge messages in validator peer communications

The codebase has validation for Ed25519 low-order points using `point.is_small_order()` [4](#0-3)  but this validation is NOT applied to x25519 keys used in Noise handshakes.

The vulnerability is exploitable in both:
1. **Telemetry Service**: Authentication endpoint processes untrusted handshake messages [5](#0-4) 
2. **Validator Network**: Inbound peer connections process handshake messages [6](#0-5) 

## Impact Explanation
**Severity: HIGH**

This vulnerability enables **session key compromise** through predictable Diffie-Hellman outputs, meeting the "Significant protocol violations" criteria for High severity per the Aptos bug bounty program.

**Concrete Impacts:**
1. **Telemetry Service**: Attackers can decrypt JWT authentication tokens, potentially enabling:
   - Unauthorized telemetry data injection
   - Impersonation of validator nodes
   - Information disclosure of node identities and epochs

2. **Validator Network**: Attackers can compromise peer-to-peer session keys, potentially enabling:
   - Decryption of consensus messages
   - Man-in-the-middle attacks on validator communications
   - Network partition through message manipulation

This breaks the **Cryptographic Correctness** invariant: "BLS signatures, VRF, and hash operations must be secure" - which extends to all cryptographic operations including key exchange protocols.

## Likelihood Explanation
**Likelihood: HIGH**

The attack is highly likely to succeed because:
1. **No authentication required**: Any network peer can send handshake messages
2. **Simple to execute**: Attacker only needs to provide known low-order points (e.g., all zeros)
3. **No complex timing or race conditions**: The vulnerability is deterministic
4. **Affects all deployments**: Both telemetry service and validator nodes are vulnerable

The only complexity is computing the predictable session keys, which is feasible given known DH outputs with low-order points.

## Recommendation
Add validation to reject low-order x25519 public keys before using them in cryptographic operations. Similar to the Ed25519 validation, check if points are in the small-order subgroup.

**Recommended Fix:**
Add a validation function for x25519 public keys that converts to Edwards form and checks for small order:

```rust
// In crates/aptos-crypto/src/x25519.rs
impl PublicKey {
    /// Validates that this public key is not a low-order point
    pub fn is_low_order(&self) -> bool {
        // Convert x25519 (Montgomery) to Ed25519 (Edwards) to check order
        if let Ok(ed_point) = curve25519_dalek::edwards::CompressedEdwardsY::from_slice(&self.0)
            .decompress() {
            ed_point.is_small_order()
        } else {
            // If conversion fails, reject the key
            true
        }
    }
}
```

**Apply validation in Noise handshake:** [7](#0-6) 

```rust
// After line 446, add validation:
let re = x25519::PublicKey::from(re);
if re.is_low_order() {
    return Err(NoiseError::WrongPublicKeyReceived);
}
```

Similarly after line 465:
```rust
let rs = x25519::PublicKey::try_from(rs).map_err(|_| NoiseError::WrongPublicKeyReceived)?;
if rs.is_low_order() {
    return Err(NoiseError::WrongPublicKeyReceived);
}
```

## Proof of Concept
```rust
#[cfg(test)]
mod test_low_order_attack {
    use super::*;
    use aptos_crypto::{noise, x25519};
    use rand::rngs::OsRng;

    #[test]
    fn test_identity_point_attack() {
        // Server setup
        let mut rng = OsRng;
        let server_private = x25519::PrivateKey::generate(&mut rng);
        let server_config = noise::NoiseConfig::new(server_private);
        
        // Attacker creates handshake with identity point (all zeros) as ephemeral key
        let identity_point = [0u8; 32];
        let weak_ephemeral = x25519::PublicKey::from(identity_point);
        
        // When server performs DH with identity point
        let dh_output = server_private.diffie_hellman(&weak_ephemeral);
        
        // The DH output should be predictable/weak
        // With proper validation, this handshake should be rejected
        // Without validation, the handshake proceeds with compromised keys
        
        // Build a malicious handshake message with weak ephemeral key
        let prologue = b"test_prologue";
        let mut client_msg = vec![0u8; noise::handshake_init_msg_len(0)];
        client_msg[..32].copy_from_slice(&identity_point);
        
        // Server attempts to parse - should fail with validation
        let result = server_config.parse_client_init_message(prologue, &client_msg);
        
        // Currently this may not fail, proving the vulnerability
        // With fix, this should return Err(NoiseError::WrongPublicKeyReceived)
        match result {
            Ok(_) => panic!("VULNERABLE: Accepted low-order point in handshake"),
            Err(_) => println!("SECURE: Rejected low-order point"),
        }
    }
}
```

## Notes
This is a well-documented class of vulnerability in Diffie-Hellman protocols known as "contributory behavior" or "small subgroup attacks." The Noise protocol specification explicitly recommends validating public keys to prevent this. The x25519_dalek library intentionally delegates this validation to the caller, making it the application's responsibility to implement. The same 8 torsion points that are validated for Ed25519 in the codebase apply to x25519 (Curve25519 in Montgomery form), but no such validation is currently performed for x25519 keys in Noise handshakes.

### Citations

**File:** crates/aptos-crypto/src/x25519.rs (L222-236)
```rust
impl std::convert::From<[u8; PUBLIC_KEY_SIZE]> for PublicKey {
    fn from(public_key_bytes: [u8; PUBLIC_KEY_SIZE]) -> Self {
        Self(public_key_bytes)
    }
}

impl std::convert::TryFrom<&[u8]> for PublicKey {
    type Error = traits::CryptoMaterialError;

    fn try_from(public_key_bytes: &[u8]) -> Result<Self, Self::Error> {
        let public_key_bytes: [u8; PUBLIC_KEY_SIZE] = public_key_bytes
            .try_into()
            .map_err(|_| traits::CryptoMaterialError::WrongLengthError)?;
        Ok(Self(public_key_bytes))
    }
```

**File:** crates/aptos-crypto/src/noise.rs (L440-469)
```rust
        // <- e
        let mut re = [0u8; x25519::PUBLIC_KEY_SIZE];
        cursor
            .read_exact(&mut re)
            .map_err(|_| NoiseError::MsgTooShort)?;
        mix_hash(&mut h, &re);
        let re = x25519::PublicKey::from(re);

        // <- es
        let dh_output = self.private_key.diffie_hellman(&re);
        let k = mix_key(&mut ck, &dh_output)?;

        // <- s
        let mut encrypted_remote_static = [0u8; x25519::PUBLIC_KEY_SIZE + AES_GCM_TAGLEN];
        cursor
            .read_exact(&mut encrypted_remote_static)
            .map_err(|_| NoiseError::MsgTooShort)?;

        let aead = aes_key(&k[..]);
        let mut in_out = encrypted_remote_static.to_vec();
        let nonce = aead::Nonce::assume_unique_for_key([0u8; AES_NONCE_SIZE]);
        let rs: &[u8] = aead
            .open_in_place(nonce, Aad::from(&h), &mut in_out)
            .map_err(|_| NoiseError::Decrypt)?;

        let rs = x25519::PublicKey::try_from(rs).map_err(|_| NoiseError::WrongPublicKeyReceived)?;
        mix_hash(&mut h, &encrypted_remote_static);

        // <- ss
        let dh_output = self.private_key.diffie_hellman(&rs);
```

**File:** crates/aptos-crypto/src/unit_tests/ed25519_test.rs (L514-540)
```rust
pub const EIGHT_TORSION: [[u8; 32]; 8] = [
    [
        1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0,
    ],
    [
        199, 23, 106, 112, 61, 77, 216, 79, 186, 60, 11, 118, 13, 16, 103, 15, 42, 32, 83, 250, 44,
        57, 204, 198, 78, 199, 253, 119, 146, 172, 3, 122,
    ],
    [
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 128,
    ],
    [
        38, 232, 149, 143, 194, 178, 39, 176, 69, 195, 244, 137, 242, 239, 152, 240, 213, 223, 172,
        5, 211, 198, 51, 57, 177, 56, 2, 136, 109, 83, 252, 5,
    ],
    [
        236, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
        255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 127,
    ],
    [
        38, 232, 149, 143, 194, 178, 39, 176, 69, 195, 244, 137, 242, 239, 152, 240, 213, 223, 172,
        5, 211, 198, 51, 57, 177, 56, 2, 136, 109, 83, 252, 133,
    ],
    [
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
```

**File:** aptos-move/framework/src/natives/cryptography/ed25519.rs (L76-82)
```rust
    // Check if the point lies on a small subgroup. This is required when using curves with a
    // small cofactor (e.g., in Ed25519, cofactor = 8).
    // NOTE(Gas): O(1) cost: multiplies the point by the cofactor
    context.charge(ED25519_PER_PUBKEY_SMALL_ORDER_CHECK * NumArgs::one())?;
    let valid = !point.is_small_order();

    Ok(smallvec![Value::bool(valid)])
```

**File:** crates/aptos-telemetry-service/src/auth.rs (L55-64)
```rust
    let (remote_public_key, handshake_state, _payload) = context
        .noise_config()
        .parse_client_init_message(&prologue, client_init_message)
        .map_err(|e| {
            debug!("error performing noise handshake: {}", e);
            reject::custom(ServiceError::bad_request(ServiceErrorCode::AuthError(
                AuthError::NoiseHandshakeError(e),
                body.chain_id,
            )))
        })?;
```

**File:** network/framework/src/noise/handshake.rs (L359-364)
```rust
        // parse it
        let (prologue, client_init_message) = client_message.split_at(Self::PROLOGUE_SIZE);
        let (remote_public_key, handshake_state, payload) = self
            .noise_config
            .parse_client_init_message(prologue, client_init_message)
            .map_err(|err| NoiseHandshakeError::ServerParseClient(remote_peer_short, err))?;
```
