# Audit Report

## Title
DKG Transcript Metadata Bypass Allows Invalid-Epoch DKGResults to Enter Consensus

## Summary
The `is_vtxn_expected()` function in consensus validation only checks if randomness is enabled but does not validate DKGTranscript metadata (epoch, author) before accepting DKGResult transactions into consensus blocks. This allows malicious validators to inject DKGResults from wrong epochs, wasting block space and potentially blocking valid DKG operations.

## Finding Description

The vulnerability exists in the `is_vtxn_expected()` function: [1](#0-0) 

This function receives the full `ValidatorTransaction` including the DKGTranscript with its metadata (epoch and author), but only checks whether randomness is enabled. It does not validate that the DKGResult's epoch matches the current consensus epoch.

The DKGTranscript structure contains critical metadata: [2](#0-1) 

And the full DKGTranscript structure: [3](#0-2) 

During consensus proposal validation in RoundManager, the flow is: [4](#0-3) 

The `is_vtxn_expected()` call at line 1130 returns true if randomness is enabled, without checking the DKGResult's metadata epoch. The subsequent `vtxn.verify()` call only verifies the transcript bytes cryptographically: [5](#0-4) 

The epoch validation only happens later during VM execution: [6](#0-5) 

By this point, the block has already been accepted into consensus and committed. The invalid DKGResult is discarded with an abort status, but the damage is done: [7](#0-6) 

**Attack Path:**
1. Malicious validator creates a DKGResult with `metadata.epoch` set to a wrong epoch (e.g., epoch N-1 when current epoch is N)
2. The transcript bytes themselves are cryptographically valid (from a previous epoch)
3. Malicious validator proposes a block containing this invalid DKGResult
4. Honest validators validate the proposal: `is_vtxn_expected()` returns true (randomness enabled, no epoch check), `vtxn.verify()` passes (valid transcript bytes)
5. Block is accepted in consensus and committed
6. During execution, epoch mismatch is detected and transaction is discarded
7. Block space and validator transaction slots are wasted

The RoundManager has access to the current epoch via `self.epoch_state.epoch`: [8](#0-7) 

But this information is not passed to or used by `is_vtxn_expected()`.

## Impact Explanation

**High Severity** - This vulnerability meets multiple High severity criteria per the Aptos bug bounty:

1. **Validator node slowdowns**: All validators must process, vote on, and execute blocks containing invalid DKGResults, wasting computational resources.

2. **Significant protocol violations**: DKGResults from wrong epochs violate the DKG protocol's epoch-based security model.

3. **Block space exhaustion**: Validator transactions have strict per-block limits: [9](#0-8) 

With only 2 validator transactions allowed per block, a malicious validator can fill both slots with invalid DKGResults, preventing valid ones from being included.

4. **DKG protocol disruption**: If valid DKGResults need to be propagated for randomness generation but slots are occupied by invalid ones, it delays DKG completion, potentially affecting randomness availability for the network.

## Likelihood Explanation

**Medium-High Likelihood**:
- **Attacker requirements**: Requires being an active validator selected as block proposer
- **Complexity**: Low - simply create a DKGResult with wrong epoch but valid transcript bytes from a previous/saved DKG session
- **Detection**: Difficult to detect without analyzing transaction discard rates
- **Motivation**: Economic (delaying DKG to affect randomness-dependent operations) or disruption

The same validation pattern exists in DAG consensus: [10](#0-9) 

Both code paths share the same vulnerability.

## Recommendation

Modify `is_vtxn_expected()` to accept the current epoch as a parameter and validate DKGResult metadata:

```rust
pub fn is_vtxn_expected(
    current_epoch: u64,
    randomness_config: &OnChainRandomnessConfig,
    jwk_consensus_config: &OnChainJWKConsensusConfig,
    vtxn: &ValidatorTransaction,
) -> bool {
    match vtxn {
        ValidatorTransaction::DKGResult(dkg_transcript) => {
            // First check if randomness is enabled
            if !randomness_config.randomness_enabled() {
                return false;
            }
            // Then validate epoch matches
            dkg_transcript.metadata.epoch == current_epoch
        },
        ValidatorTransaction::ObservedJWKUpdate(_) => jwk_consensus_config.jwk_consensus_enabled(),
    }
}
```

Update call sites in RoundManager and RBHandler to pass `self.epoch_state.epoch`:

```rust
ensure!(
    is_vtxn_expected(
        self.epoch_state.epoch,
        &self.randomness_config, 
        &self.jwk_consensus_config, 
        vtxn
    ),
    "unexpected validator txn: {:?}",
    vtxn_type_name
);
```

## Proof of Concept

```rust
// Create a malicious DKGResult with wrong epoch
let wrong_epoch = current_epoch - 1; // or current_epoch + 1

// Create valid transcript bytes (from previous epoch or crafted)
let valid_transcript_bytes = get_saved_transcript_from_previous_epoch();

let malicious_dkg_result = ValidatorTransaction::DKGResult(
    DKGTranscript {
        metadata: DKGTranscriptMetadata {
            epoch: wrong_epoch,  // WRONG EPOCH
            author: malicious_validator_address,
        },
        transcript_bytes: valid_transcript_bytes, // Valid bytes
    }
);

// Propose block containing this malicious DKGResult
let block = create_proposal_with_vtxns(vec![malicious_dkg_result]);

// Verification steps:
// 1. is_vtxn_expected() returns true (randomness enabled, no epoch check)
// 2. vtxn.verify() passes (transcript bytes are cryptographically valid)
// 3. Block enters consensus
// 4. During execution, transaction is discarded with EpochNotCurrent error
// 5. Block space wasted, validator transaction slot consumed
```

To demonstrate: Create a consensus test that proposes a block with a DKGResult having `metadata.epoch = current_epoch - 1`, verify it passes consensus validation but gets discarded during execution, and confirm the validator transaction slot is consumed.

### Citations

**File:** consensus/src/util/mod.rs (L15-24)
```rust
pub fn is_vtxn_expected(
    randomness_config: &OnChainRandomnessConfig,
    jwk_consensus_config: &OnChainJWKConsensusConfig,
    vtxn: &ValidatorTransaction,
) -> bool {
    match vtxn {
        ValidatorTransaction::DKGResult(_) => randomness_config.randomness_enabled(),
        ValidatorTransaction::ObservedJWKUpdate(_) => jwk_consensus_config.jwk_consensus_enabled(),
    }
}
```

**File:** types/src/dkg/mod.rs (L28-32)
```rust
#[derive(Clone, Serialize, Deserialize, Debug, PartialEq, Eq, CryptoHasher, BCSCryptoHash)]
pub struct DKGTranscriptMetadata {
    pub epoch: u64,
    pub author: AccountAddress,
}
```

**File:** types/src/dkg/mod.rs (L49-54)
```rust
#[derive(Clone, Serialize, Deserialize, PartialEq, Eq)]
pub struct DKGTranscript {
    pub metadata: DKGTranscriptMetadata,
    #[serde(with = "serde_bytes")]
    pub transcript_bytes: Vec<u8>,
}
```

**File:** types/src/dkg/mod.rs (L83-88)
```rust
    pub(crate) fn verify(&self, verifier: &ValidatorVerifier) -> Result<()> {
        let transcripts: Transcripts = bcs::from_bytes(&self.transcript_bytes)
            .context("Transcripts deserialization failed")?;
        RealDKG::verify_transcript_extra(&transcripts, verifier, true, None)
    }
}
```

**File:** consensus/src/round_manager.rs (L1126-1137)
```rust
        if let Some(vtxns) = proposal.validator_txns() {
            for vtxn in vtxns {
                let vtxn_type_name = vtxn.type_name();
                ensure!(
                    is_vtxn_expected(&self.randomness_config, &self.jwk_consensus_config, vtxn),
                    "unexpected validator txn: {:?}",
                    vtxn_type_name
                );
                vtxn.verify(self.epoch_state.verifier.as_ref())
                    .context(format!("{} verify failed", vtxn_type_name))?;
            }
        }
```

**File:** aptos-move/aptos-vm/src/validator_txns/dkg.rs (L68-77)
```rust
            Err(Expected(failure)) => {
                // Pretend we are inside Move, and expected failures are like Move aborts.
                Ok((
                    VMStatus::MoveAbort {
                        location: AbortLocation::Script,
                        code: failure as u64,
                        message: None,
                    },
                    VMOutput::empty_with_status(TransactionStatus::Discard(StatusCode::ABORTED)),
                ))
```

**File:** aptos-move/aptos-vm/src/validator_txns/dkg.rs (L99-102)
```rust
        // Check epoch number.
        if dkg_node.metadata.epoch != config_resource.epoch() {
            return Err(Expected(EpochNotCurrent));
        }
```

**File:** types/src/epoch_state.rs (L19-22)
```rust
pub struct EpochState {
    pub epoch: u64,
    pub verifier: Arc<ValidatorVerifier>,
}
```

**File:** types/src/on_chain_config/consensus_config.rs (L125-126)
```rust
const VTXN_CONFIG_PER_BLOCK_LIMIT_TXN_COUNT_DEFAULT: u64 = 2;
const VTXN_CONFIG_PER_BLOCK_LIMIT_TOTAL_BYTES_DEFAULT: u64 = 2097152; //2MB
```

**File:** consensus/src/dag/rb_handler.rs (L122-131)
```rust
        for vtxn in node.validator_txns() {
            let vtxn_type_name = vtxn.type_name();
            ensure!(
                is_vtxn_expected(&self.randomness_config, &self.jwk_consensus_config, vtxn),
                "unexpected validator transaction: {:?}",
                vtxn_type_name
            );
            vtxn.verify(self.epoch_state.verifier.as_ref())
                .context(format!("{} verification failed", vtxn_type_name))?;
        }
```
