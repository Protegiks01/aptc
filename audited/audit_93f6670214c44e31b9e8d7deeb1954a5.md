# Audit Report

## Title
Indexer GRPC Service Liveness Failure Due to Unvalidated Zero `processor_batch_size` Configuration

## Summary
The `processor_batch_size` configuration field in `IndexerGrpcConfig` can be set to 0 without validation, causing the indexer GRPC service to fail silently without processing any transactions. This results in complete service unavailability for clients relying on the transaction stream.

## Finding Description

The vulnerability exists in the configuration and batch processing logic of the Aptos indexer GRPC service. The `processor_batch_size` field has no validation to prevent it from being set to 0. [1](#0-0) 

The configuration sanitizer only validates that storage is enabled when the indexer is enabled, but does not validate the actual batch size values: [2](#0-1) 

When `processor_batch_size` is 0, the `get_batches()` method in the stream coordinator creates batches with `num_transactions_to_fetch = 0`, and critically, `starting_version` never advances: [3](#0-2) 

The storage layer correctly returns an empty result when queried with limit=0: [4](#0-3) 

This causes `process_next_batch()` to return empty results, which the main processing loop interprets as a client disconnection, causing immediate exit: [5](#0-4) 

The same pattern exists in the localnet data service: [6](#0-5) 

## Impact Explanation

This vulnerability causes **complete liveness failure** of the indexer GRPC service:

1. The service initializes successfully but processes zero transactions
2. The service exits immediately, logging misleading "Client disconnected" messages
3. No transaction data is streamed to clients
4. The failure mode is silent and difficult to diagnose

While this does not affect the core blockchain consensus or validator operations, it represents a **Medium severity** issue per the Aptos bug bounty criteria as it causes significant service degradation. External services and applications relying on the indexer GRPC stream (such as indexers, explorers, and data analytics tools) would receive no data, effectively rendering the indexer infrastructure non-functional.

## Likelihood Explanation

This vulnerability has **high likelihood** of occurrence through:

1. **Configuration errors**: Operators might accidentally set the value to 0 during testing or misconfiguration
2. **Template/default misconfigurations**: Automated deployment systems might propagate incorrect configurations
3. **No fail-fast validation**: The service starts successfully without warning, making the issue difficult to detect until clients report data unavailability

The vulnerability requires only configuration file access, which is standard for node operators. No privileged access or attack sophistication is needed.

## Recommendation

Implement validation in the configuration sanitizer to enforce minimum values for batch sizes:

```rust
impl ConfigSanitizer for IndexerGrpcConfig {
    fn sanitize(
        node_config: &NodeConfig,
        _node_type: NodeType,
        _chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();

        if !node_config.indexer_grpc.enabled {
            return Ok(());
        }

        // Existing storage validation
        if !node_config.storage.enable_indexer
            && !node_config
                .indexer_table_info
                .table_info_service_mode
                .is_enabled()
        {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "storage.enable_indexer must be true or indexer_table_info.table_info_service_mode must be IndexingOnly if indexer_grpc.enabled is true".to_string(),
            ));
        }

        // Add batch size validation
        if node_config.indexer_grpc.processor_batch_size == 0 {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "indexer_grpc.processor_batch_size must be greater than 0".to_string(),
            ));
        }

        if node_config.indexer_grpc.output_batch_size == 0 {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "indexer_grpc.output_batch_size must be greater than 0".to_string(),
            ));
        }

        Ok(())
    }
}
```

## Proof of Concept

To reproduce this vulnerability:

1. **Configure the node** with `processor_batch_size: 0` in the indexer GRPC config:

```yaml
indexer_grpc:
  enabled: true
  processor_batch_size: 0  # Vulnerable configuration
  output_batch_size: 100
  processor_task_count: 20
```

2. **Start the node** - it will initialize successfully without errors

3. **Attempt to stream transactions** via the GRPC API:
   - The stream will initialize with the init message
   - No transactions will be processed or returned
   - The service will log "Client disconnected" and exit
   - `current_version` will never advance from the starting version

4. **Observe the logs**:
```
[Indexer Fullnode] Init connection
[Indexer Fullnode] Client disconnected.
```

5. **Result**: Zero transactions are processed despite transactions being available in storage, and the service terminates immediately after initialization.

The vulnerability can be verified by examining the debug state where `get_batches()` creates batches with `num_transactions_to_fetch: 0` and `starting_version` remains unchanged across all iterations.

## Notes

This vulnerability specifically affects the indexer GRPC auxiliary service and does not impact core blockchain consensus, validator operations, or transaction processing. However, it represents a critical operational issue for deployments that depend on the indexer for external data access, such as block explorers, analytics platforms, and third-party applications that rely on real-time transaction streaming.

### Citations

**File:** config/src/config/indexer_grpc_config.rs (L49-49)
```rust
    pub processor_batch_size: u16,
```

**File:** config/src/config/indexer_grpc_config.rs (L103-128)
```rust
impl ConfigSanitizer for IndexerGrpcConfig {
    fn sanitize(
        node_config: &NodeConfig,
        _node_type: NodeType,
        _chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();

        if !node_config.indexer_grpc.enabled {
            return Ok(());
        }

        if !node_config.storage.enable_indexer
            && !node_config
                .indexer_table_info
                .table_info_service_mode
                .is_enabled()
        {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "storage.enable_indexer must be true or indexer_table_info.table_info_service_mode must be IndexingOnly if indexer_grpc.enabled is true".to_string(),
            ));
        }
        Ok(())
    }
}
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/stream_coordinator.rs (L293-318)
```rust
    async fn get_batches(&mut self) -> Vec<TransactionBatchInfo> {
        if !self.ensure_highest_known_version().await {
            return vec![];
        }

        let mut starting_version = self.current_version;
        let mut num_fetches = 0;
        let mut batches = vec![];
        let end_version = std::cmp::min(self.end_version, self.highest_known_version + 1);

        while num_fetches < self.processor_task_count && starting_version < end_version {
            let num_transactions_to_fetch = std::cmp::min(
                self.processor_batch_size as u64,
                end_version - starting_version,
            ) as u16;

            batches.push(TransactionBatchInfo {
                start_version: starting_version,
                head_version: self.highest_known_version,
                num_transactions_to_fetch,
            });
            starting_version += num_transactions_to_fetch as u64;
            num_fetches += 1;
        }
        batches
    }
```

**File:** storage/aptosdb/src/db/aptosdb_reader.rs (L277-279)
```rust
            if start_version > ledger_version || limit == 0 {
                return Ok(TransactionListWithProofV2::new_empty());
            }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/fullnode_data_service.rs (L135-150)
```rust
            while coordinator.current_version < coordinator.end_version {
                let start_time = std::time::Instant::now();
                // Processes and sends batch of transactions to client
                let results = coordinator.process_next_batch().await;
                if abort_handle.load(Ordering::SeqCst) {
                    info!("FullnodeDataService is aborted.");
                    break;
                }
                if results.is_empty() {
                    info!(
                        start_version = starting_version,
                        chain_id = ledger_chain_id,
                        "[Indexer Fullnode] Client disconnected."
                    );
                    break;
                }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/localnet_data_service.rs (L90-100)
```rust
            while coordinator.current_version < coordinator.end_version {
                // Processes and sends batch of transactions to client
                let results = coordinator.process_next_batch().await;
                if results.is_empty() {
                    info!(
                        start_version = starting_version,
                        chain_id = ledger_chain_id,
                        "[Indexer Fullnode] Client disconnected."
                    );
                    break;
                }
```
