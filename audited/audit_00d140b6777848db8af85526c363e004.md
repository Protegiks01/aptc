# Audit Report

## Title
Unauthenticated Inspection Service Exposes Sensitive Validator Network Topology and State Information

## Summary
The inspection service configuration allows public exposure of sensitive validator network topology, peer information, state synchronization status, and internal metrics through unauthenticated HTTP endpoints. While the sanitizer prevents mainnet validators from exposing their configuration, it fails to restrict exposure of peer information, identity information, and system informationâ€”all enabled by default and accessible without authentication on `0.0.0.0:9101`.

## Finding Description
The `InspectionServiceConfig` structure defines four exposure flags that control which endpoints are publicly accessible. [1](#0-0) 

By default, the service binds to all network interfaces and enables three of four sensitive endpoints, with only configuration exposure disabled. [1](#0-0) 

The sanitizer only validates that mainnet validators don't expose configuration, completely ignoring the other three endpoints. [2](#0-1) 

The inspection service starts without any authentication mechanism, processing all HTTP GET/HEAD requests based solely on configuration flags. [3](#0-2) 

The `/peer_information` endpoint exposes comprehensive network topology data including all connected peers, their network addresses, connection states, trusted validators, state sync metadata, peer scores, and internal client state. [4](#0-3) 

Connection metadata includes the actual network address (IP and port) of each connected peer. [5](#0-4) 

Peer monitoring metadata exposes detailed node state including highest synced epoch, version, ledger timestamp, build information, and uptime. [6](#0-5) 

Network information responses include complete lists of connected peers with their roles, addresses, and the node's distance from validators. [7](#0-6) 

An attacker exploiting this vulnerability would:
1. Send HTTP GET requests to `http://<validator-ip>:9101/peer_information`
2. Extract all connected peer IPs, roles, and connection states
3. Query `/identity_information` to obtain validator peer IDs
4. Access `/system_information` for build versions and system details
5. Monitor `/metrics` for real-time operational data
6. Use this intelligence to map the validator network topology
7. Identify optimal targets for DDoS, eclipse, or timing attacks
8. Monitor validator sync status to detect when validators are vulnerable

## Impact Explanation
This finding qualifies as **Medium Severity** information disclosure that enables reconnaissance for targeted attacks against validator infrastructure. While it doesn't directly compromise consensus safety or cause fund loss, it provides attackers with critical intelligence needed to:

- Launch targeted DDoS attacks against specific validators or their connections
- Position themselves for eclipse attacks by understanding network topology  
- Identify validators running vulnerable software versions
- Monitor state sync status to exploit validators during catch-up periods
- Map the complete validator network for coordinated attacks

The exposure violates the principle that validator operational state should remain confidential to prevent reconnaissance. This enables attack vectors that could indirectly lead to validator slowdowns (High severity) or availability issues.

## Likelihood Explanation
**Likelihood: High**

This vulnerability is trivially exploitable by any attacker with network connectivity to the validator's inspection service port (9101). Exploitation requirements:
- Network access to port 9101 (default configuration binds to 0.0.0.0)
- Ability to send HTTP GET requests (any HTTP client)
- No authentication required
- No rate limiting documented in codebase

The only mitigation is external firewall configuration, which is not enforced or validated by the Aptos codebase itself. Validators following default configuration are immediately vulnerable unless they manually configure firewall rules.

## Recommendation
Implement defense-in-depth protection for the inspection service:

**1. Restrict Default Binding Address:**
```rust
fn default() -> InspectionServiceConfig {
    InspectionServiceConfig {
        address: "127.0.0.1".to_string(), // Bind to localhost only by default
        port: 9101,
        expose_configuration: false,
        expose_identity_information: false, // Disable by default
        expose_peer_information: false,     // Disable by default
        expose_system_information: false,   // Disable by default
    }
}
```

**2. Enhance Sanitizer to Protect Mainnet Validators:**
```rust
fn sanitize(
    node_config: &NodeConfig,
    node_type: NodeType,
    chain_id: Option<ChainId>,
) -> Result<(), Error> {
    let sanitizer_name = Self::get_sanitizer_name();
    let inspection_service_config = &node_config.inspection_service;

    if let Some(chain_id) = chain_id {
        if node_type.is_validator() && chain_id.is_mainnet() {
            // Prevent ALL sensitive endpoints on mainnet validators
            if inspection_service_config.expose_configuration {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "Mainnet validators must not expose configuration!".to_string(),
                ));
            }
            if inspection_service_config.expose_peer_information {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "Mainnet validators must not expose peer information!".to_string(),
                ));
            }
            if inspection_service_config.expose_identity_information {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "Mainnet validators must not expose identity information!".to_string(),
                ));
            }
        }
    }
    Ok(())
}
```

**3. Add Authentication Layer:**
Implement bearer token authentication for all inspection service endpoints, similar to the admin service.

**4. Documentation:**
Add prominent warnings in configuration documentation about the security implications of exposing inspection service endpoints.

## Proof of Concept
```bash
# Reconnaissance attack against a vulnerable validator
VALIDATOR_IP="<target-validator-ip>"
PORT=9101

# Step 1: Enumerate peer topology
curl "http://${VALIDATOR_IP}:${PORT}/peer_information" > peer_topology.txt

# Step 2: Extract all connected peer IPs and roles
grep -oP 'network_address.*?(/ip4/\K[0-9.]+|/ip6/\K[0-9a-f:]+)' peer_topology.txt | sort -u > peer_ips.txt

# Step 3: Identify validator set members
grep "Validator" peer_topology.txt > validator_peers.txt

# Step 4: Get target's identity
curl "http://${VALIDATOR_IP}:${PORT}/identity_information"

# Step 5: Check sync status for timing attacks
curl "http://${VALIDATOR_IP}:${PORT}/peer_information" | grep "highest_synced_epoch"

# Step 6: Identify build version for exploit targeting
curl "http://${VALIDATOR_IP}:${PORT}/system_information" | jq '.build_commit'

# Step 7: Monitor metrics for operational intelligence
curl "http://${VALIDATOR_IP}:${PORT}/json_metrics" | jq '.aptos_consensus_*'

# The attacker now has:
# - Complete network topology map
# - All validator and peer IP addresses  
# - State synchronization status
# - Build versions
# - Real-time operational metrics
# This intelligence enables targeted DDoS, eclipse attacks, and vulnerability exploitation
```

**Notes**

The core vulnerability exists in the permissive default configuration combined with inadequate sanitization. The sanitizer at line 54-64 only protects against configuration exposure, while the three other sensitive endpoints remain exposed by default on mainnet validators. [8](#0-7) 

The re-export mentioned in the security question is merely the mechanism that makes the configuration public; the actual vulnerability is in the configuration defaults and sanitizer logic that fails to adequately protect sensitive endpoints on production validators.

### Citations

**File:** config/src/config/inspection_service_config.rs (L26-36)
```rust
impl Default for InspectionServiceConfig {
    fn default() -> InspectionServiceConfig {
        InspectionServiceConfig {
            address: "0.0.0.0".to_string(),
            port: 9101,
            expose_configuration: false,
            expose_identity_information: true,
            expose_peer_information: true,
            expose_system_information: true,
        }
    }
```

**File:** config/src/config/inspection_service_config.rs (L45-68)
```rust
impl ConfigSanitizer for InspectionServiceConfig {
    fn sanitize(
        node_config: &NodeConfig,
        node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();
        let inspection_service_config = &node_config.inspection_service;

        // Verify that mainnet validators do not expose the configuration
        if let Some(chain_id) = chain_id {
            if node_type.is_validator()
                && chain_id.is_mainnet()
                && inspection_service_config.expose_configuration
            {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "Mainnet validators should not expose the node configuration!".to_string(),
                ));
            }
        }

        Ok(())
    }
```

**File:** crates/aptos-inspection-service/src/server/mod.rs (L103-198)
```rust
/// A simple helper function that handles each endpoint request
async fn serve_requests(
    req: Request<Body>,
    node_config: NodeConfig,
    aptos_data_client: AptosDataClient,
    peers_and_metadata: Arc<PeersAndMetadata>,
) -> Result<Response<Body>, hyper::Error> {
    // Process the request and get the response components
    let (status_code, body, content_type) = match req.uri().path() {
        CONFIGURATION_PATH => {
            // /configuration
            // Exposes the node configuration
            configuration::handle_configuration_request(&node_config)
        },
        CONSENSUS_HEALTH_CHECK_PATH => {
            // /consensus_health_check
            // Exposes the consensus health check
            metrics::handle_consensus_health_check(&node_config).await
        },
        FORGE_METRICS_PATH => {
            // /forge_metrics
            // Exposes forge encoded metrics
            metrics::handle_forge_metrics()
        },
        IDENTITY_INFORMATION_PATH => {
            // /identity_information
            // Exposes the identity information of the node
            identity_information::handle_identity_information_request(&node_config)
        },
        INDEX_PATH => {
            // /
            // Exposes the index and list of available endpoints
            index::handle_index_request()
        },
        JSON_METRICS_PATH => {
            // /json_metrics
            // Exposes JSON encoded metrics
            metrics::handle_json_metrics_request()
        },
        METRICS_PATH => {
            // /metrics
            // Exposes text encoded metrics
            metrics::handle_metrics_request()
        },
        PEER_INFORMATION_PATH => {
            // /peer_information
            // Exposes the peer information
            peer_information::handle_peer_information_request(
                &node_config,
                aptos_data_client,
                peers_and_metadata,
            )
        },
        SYSTEM_INFORMATION_PATH => {
            // /system_information
            // Exposes the system and build information
            system_information::handle_system_information_request(node_config)
        },
        _ => {
            // Handle the invalid path
            (
                StatusCode::NOT_FOUND,
                Body::from(INVALID_ENDPOINT_MESSAGE),
                CONTENT_TYPE_TEXT.into(),
            )
        },
    };

    // Create a response builder
    let response_builder = Response::builder()
        .header(HEADER_CONTENT_TYPE, content_type)
        .status(status_code);

    // Build the response based on the request methods
    let response = match *req.method() {
        Method::HEAD => response_builder.body(Body::empty()), // Return only the headers
        Method::GET => response_builder.body(body),           // Include the response body
        _ => {
            // Invalid method found
            Response::builder()
                .status(StatusCode::METHOD_NOT_ALLOWED)
                .body(Body::empty())
        },
    };

    // Return the processed response
    Ok(response.unwrap_or_else(|error| {
        // Log the internal error
        debug!("Error encountered when generating response: {:?}", error);

        // Return a failure response
        let mut response = Response::new(Body::from(UNEXPECTED_ERROR_MESSAGE));
        *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
        response
    }))
}
```

**File:** crates/aptos-inspection-service/src/server/peer_information.rs (L40-106)
```rust
/// Returns a simple text formatted string with peer and network information
fn get_peer_information(
    aptos_data_client: AptosDataClient,
    peers_and_metadata: Arc<PeersAndMetadata>,
) -> String {
    // Get all registered networks
    let registered_networks: Vec<NetworkId> =
        peers_and_metadata.get_registered_networks().collect();

    // Get all peers (sorted by peer ID)
    let mut all_peers = peers_and_metadata.get_all_peers();
    all_peers.sort();

    // Display a summary of all peers and networks
    let mut peer_information_output = Vec::<String>::new();
    display_peer_information_summary(
        &mut peer_information_output,
        &all_peers,
        &registered_networks,
    );
    peer_information_output.push("\n".into());

    // Display connection metadata for each peer
    display_peer_connection_metadata(
        &mut peer_information_output,
        &all_peers,
        peers_and_metadata.deref(),
    );
    peer_information_output.push("\n".into());

    // Display the entire set of trusted peers
    display_trusted_peers(
        &mut peer_information_output,
        registered_networks,
        peers_and_metadata.deref(),
    );
    peer_information_output.push("\n".into());

    // Display basic peer metadata for each peer
    display_peer_monitoring_metadata(
        &mut peer_information_output,
        &all_peers,
        peers_and_metadata.deref(),
    );
    peer_information_output.push("\n".into());

    // Display state sync metadata for each peer
    display_state_sync_metadata(&mut peer_information_output, &all_peers, aptos_data_client);
    peer_information_output.push("\n".into());

    // Display detailed peer metadata for each peer
    display_detailed_monitoring_metadata(
        &mut peer_information_output,
        &all_peers,
        peers_and_metadata.deref(),
    );
    peer_information_output.push("\n".into());

    // Display the internal client state for each peer
    display_internal_client_state(
        &mut peer_information_output,
        &all_peers,
        peers_and_metadata.deref(),
    );

    peer_information_output.join("\n") // Separate each entry with a newline to construct the output
}
```

**File:** network/framework/src/transport/mod.rs (L98-129)
```rust
/// Metadata associated with an established and fully upgraded connection.
#[derive(Clone, Deserialize, Eq, PartialEq, Serialize)]
pub struct ConnectionMetadata {
    pub remote_peer_id: PeerId,
    pub connection_id: ConnectionId,
    pub addr: NetworkAddress,
    pub origin: ConnectionOrigin,
    pub messaging_protocol: MessagingProtocolVersion,
    pub application_protocols: ProtocolIdSet,
    pub role: PeerRole,
}

impl ConnectionMetadata {
    pub fn new(
        remote_peer_id: PeerId,
        connection_id: ConnectionId,
        addr: NetworkAddress,
        origin: ConnectionOrigin,
        messaging_protocol: MessagingProtocolVersion,
        application_protocols: ProtocolIdSet,
        role: PeerRole,
    ) -> ConnectionMetadata {
        ConnectionMetadata {
            remote_peer_id,
            connection_id,
            addr,
            origin,
            messaging_protocol,
            application_protocols,
            role,
        }
    }
```

**File:** peer-monitoring-service/types/src/response.rs (L50-75)
```rust
/// A response for the network information request
#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
pub struct NetworkInformationResponse {
    pub connected_peers: BTreeMap<PeerNetworkId, ConnectionMetadata>, // Connected peers
    pub distance_from_validators: u64, // The distance of the peer from the validator set
}

// Display formatting provides a high-level summary of the response
impl Display for NetworkInformationResponse {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "{{ num_connected_peers: {:?}, distance_from_validators: {:?} }}",
            self.connected_peers.len(),
            self.distance_from_validators,
        )
    }
}

/// Simple connection metadata associated with each peer
#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
pub struct ConnectionMetadata {
    pub network_address: NetworkAddress,
    pub peer_id: PeerId,
    pub peer_role: PeerRole,
}
```

**File:** peer-monitoring-service/types/src/response.rs (L93-118)
```rust
/// A response for the node information request
#[derive(Clone, Debug, Default, Deserialize, Eq, PartialEq, Serialize)]
pub struct NodeInformationResponse {
    pub build_information: BTreeMap<String, String>, // The build information of the node
    pub highest_synced_epoch: u64,                   // The highest synced epoch of the node
    pub highest_synced_version: u64,                 // The highest synced version of the node
    pub ledger_timestamp_usecs: u64, // The latest timestamp of the blockchain (in microseconds)
    pub lowest_available_version: u64, // The lowest stored version of the node (in storage)
    pub uptime: Duration,            // The amount of time the peer has been running
}

// Display formatting provides a high-level summary of the response
impl Display for NodeInformationResponse {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "{{ highest_synced_epoch: {:?}, highest_synced_version: {:?}, ledger_timestamp_usecs: {:?}, \
            lowest_available_version: {:?}, uptime: {:?} }}",
            self.highest_synced_epoch,
            self.highest_synced_version,
            self.ledger_timestamp_usecs,
            self.lowest_available_version,
            self.uptime,
        )
    }
}
```
