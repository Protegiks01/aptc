# Audit Report

## Title
Integer Underflow in Validator Transaction Accounting Causes Proposer Node Crashes and Consensus Liveness Failure

## Summary
The `MixedPayloadClient` in `consensus/src/payload_client/mixed.rs` performs unchecked subtraction when adjusting payload limits after pulling validator transactions. When the number of validator transactions exceeds `max_txns_after_filtering` or `soft_max_txns_after_filtering`, integer underflow occurs, causing the node to panic and crash due to enabled overflow checks in release builds. This can be triggered via governance-controlled validator transaction limits, leading to consensus liveness failure.

## Finding Description
The vulnerability exists in the payload pulling logic where validator and user transactions are composed into blocks. The system first pulls validator transactions, then adjusts the remaining capacity for user transactions by subtracting the validator transaction count from the limits. [1](#0-0) 

These lines perform unchecked subtraction without validating that `validator_txns.len()` is less than or equal to `max_txns_after_filtering` and `soft_max_txns_after_filtering`. 

The number of validator transactions pulled is limited by: [2](#0-1) 

The `validator_txn_config.per_block_limit_txn_count()` is controlled by on-chain governance: [3](#0-2) 

With default value of 2, but modifiable via governance proposals.

Meanwhile, `max_txns_after_filtering` can be reduced to as low as 100 via backpressure mechanisms: [4](#0-3) 

The Cargo configuration enables overflow checks in release builds: [5](#0-4) 

**Attack Scenario:**
1. Malicious governance proposal sets `per_block_limit_txn_count` to 5000
2. Validator transaction pool accumulates 5000+ transactions
3. Backpressure reduces `max_txns_after_filtering` to 100
4. During block proposal, `params.max_txns.count()` remains 5000
5. Validator transaction pull retrieves min(5000, 5000) = 5000 transactions
6. Line 94 attempts: `100 - 5000`, causing integer underflow
7. With `overflow-checks = true`, node panics and crashes
8. All proposers crash when attempting to create blocks
9. Consensus halts, network stops producing blocks

## Impact Explanation
This qualifies as **Critical Severity** under the Aptos bug bounty program:
- **Total loss of liveness/network availability**: If all or most proposers crash simultaneously, consensus cannot proceed and the network stops producing blocks
- **Non-recoverable network partition**: Recovery requires coordinating all validators to restart with a configuration fix or governance rollback, potentially requiring emergency intervention

The attack exploits a governance-controlled parameter to crash consensus nodes deterministically, violating the **Consensus Liveness** and **Resource Limits** invariants.

## Likelihood Explanation
**Medium to High Likelihood:**
- Requires governance proposal approval (social attack surface)
- Once malicious configuration is deployed, crash is deterministic
- All proposers affected simultaneously when attempting block creation
- Validator transaction accumulation is natural under certain network conditions
- Backpressure reducing limits is an intended mechanism, making the vulnerable state reachable

The attack combines governance manipulation with exploitation of integer underflow in critical consensus path.

## Recommendation
Replace unchecked subtraction with saturating subtraction to prevent underflow:

```rust
// Update constraints with validator txn pull results.
let mut user_txn_pull_params = params;
user_txn_pull_params.max_txns -= vtxn_size;
user_txn_pull_params.max_txns_after_filtering = 
    user_txn_pull_params.max_txns_after_filtering
        .saturating_sub(validator_txns.len() as u64);
user_txn_pull_params.soft_max_txns_after_filtering = 
    user_txn_pull_params.soft_max_txns_after_filtering
        .saturating_sub(validator_txns.len() as u64);
```

Additionally, add validation to ensure validator transaction limits don't exceed payload limits:

```rust
let validator_txn_limit = min(
    params.max_txns.count(),
    self.validator_txn_config.per_block_limit_txn_count(),
).min(params.max_txns_after_filtering);
```

## Proof of Concept

```rust
// Rust unit test demonstrating the panic
#[test]
#[should_panic(expected = "attempt to subtract with overflow")]
fn test_validator_txn_underflow_panic() {
    use consensus::payload_client::mixed::MixedPayloadClient;
    use consensus_types::payload_pull_params::PayloadPullParameters;
    use aptos_types::on_chain_config::ValidatorTxnConfig;
    
    // Simulate backpressure-reduced limits
    let mut params = PayloadPullParameters::new_for_test(
        Duration::from_secs(1),
        5000, // max_txns count
        5_000_000, // max_txns bytes  
        100, // max_txns_after_filtering - reduced by backpressure
        100, // soft_max_txns_after_filtering
        100, // max_inline_txns
        100_000, // max_inline_bytes
        PayloadFilter::Empty,
        false,
        0,
        0.0,
        Duration::from_secs(0),
    );
    
    // Governance-controlled limit set to high value
    let vtxn_config = ValidatorTxnConfig::V1 {
        per_block_limit_txn_count: 5000,
        per_block_limit_total_bytes: 10_000_000,
    };
    
    // Simulate pulling 5000 validator txns (allowed by config)
    let validator_txns_count = 5000u64;
    
    // This will panic with overflow-checks = true
    params.max_txns_after_filtering -= validator_txns_count; // 100 - 5000 = underflow!
    params.soft_max_txns_after_filtering -= validator_txns_count;
}
```

**Notes:**
- While the security question asked about inverted `max_txns_after_filtering` vs `soft_max_txns_after_filtering` causing unlimited transaction acceptance, the actual vulnerability discovered is different but related: unchecked arithmetic on these same parameters causes node crashes
- The filtering logic itself correctly enforces the hard limit even with inverted values, so the original question's scenario does not bypass limits
- However, the integer underflow vulnerability is a genuine critical issue affecting consensus liveness that exists in the same code path handling these parameters

### Citations

**File:** consensus/src/payload_client/mixed.rs (L69-72)
```rust
                min(
                    params.max_txns.count(),
                    self.validator_txn_config.per_block_limit_txn_count(),
                ),
```

**File:** consensus/src/payload_client/mixed.rs (L91-95)
```rust
        // Update constraints with validator txn pull results.
        let mut user_txn_pull_params = params;
        user_txn_pull_params.max_txns -= vtxn_size;
        user_txn_pull_params.max_txns_after_filtering -= validator_txns.len() as u64;
        user_txn_pull_params.soft_max_txns_after_filtering -= validator_txns.len() as u64;
```

**File:** types/src/on_chain_config/consensus_config.rs (L125-137)
```rust
const VTXN_CONFIG_PER_BLOCK_LIMIT_TXN_COUNT_DEFAULT: u64 = 2;
const VTXN_CONFIG_PER_BLOCK_LIMIT_TOTAL_BYTES_DEFAULT: u64 = 2097152; //2MB

#[derive(Clone, Debug, Deserialize, PartialEq, Eq, Serialize)]
pub enum ValidatorTxnConfig {
    /// Disabled. In Jolteon, it also means to not use `BlockType::ProposalExt`.
    V0,
    /// Enabled. Per-block vtxn count and their total bytes are limited.
    V1 {
        per_block_limit_txn_count: u64,
        per_block_limit_total_bytes: u64,
    },
}
```

**File:** config/src/config/consensus_config.rs (L28-28)
```rust
const MIN_BLOCK_TXNS_AFTER_FILTERING: u64 = DEFEAULT_MAX_BATCH_TXNS as u64 * 2;
```

**File:** Cargo.toml (L921-923)
```text
[profile.release]
debug = true
overflow-checks = true
```
