# Audit Report

## Title
Event Sequence Number Collision via Feature Flag Toggling in Token Event System

## Summary
The `DefaultPropertyMutate` V2 event implementation causes sequence number collisions when the `MODULE_EVENT_MIGRATION` feature flag is toggled from enabled back to disabled. This results in event data loss and indexer corruption for token property mutation events.

## Finding Description

The Aptos token system supports dual event emission modes controlled by the `MODULE_EVENT_MIGRATION` feature flag. When enabled, V2 events are emitted; when disabled, V1 events are emitted. However, a critical flaw exists in how sequence numbers are tracked across these modes. [1](#0-0) 

The `emit_default_property_mutate_event` function checks the feature flag and emits either V2 (`DefaultPropertyMutate`) or V1 (`DefaultPropertyMutateEvent`). The critical issue is that V1 events increment the `EventHandle.counter` field, while V2 events do not. [2](#0-1) 

When V2 events are translated back to V1 format for indexing, the translator uses the stale `EventHandle.counter` as a default value for determining sequence numbers: [3](#0-2) 

**Attack Scenario:**

1. **Phase 1** (Flag DISABLED): Creator emits 2 V1 events → sequences 0, 1 → `EventHandle.counter = 2`

2. **Phase 2** (Flag ENABLED): Creator emits 2 V2 events → Translator assigns sequences 2, 3 → `EventHandle.counter` stays at 2 (not incremented!)

3. **Phase 3** (Flag DISABLED again): Creator emits V1 event → `emit_event()` reads stale `counter = 2` → assigns sequence 2 → **COLLISION with Phase 2 event!** [4](#0-3) 

The database schema uses `(EventKey, SeqNum)` as the primary key. Writing to the same key twice causes the second write to overwrite the first, resulting in permanent event data loss. [5](#0-4) 

The feature flag system allows governance proposals to enable and disable flags without restrictions, making this scenario realistic. [6](#0-5) 

## Impact Explanation

This vulnerability causes **state inconsistencies requiring intervention**, meeting the **Medium Severity** criteria (up to $10,000) per the Aptos bug bounty program. Specifically:

1. **Event Data Loss**: Historical events are permanently overwritten in the indexer database
2. **Indexer Corruption**: Event APIs return incorrect or missing events for affected tokens
3. **Determinism Violation**: Different nodes syncing at different times may have different event histories
4. **State Consistency Break**: The system violates the critical invariant that "State transitions must be atomic and verifiable"

While this doesn't directly cause fund loss or consensus safety violations, it corrupts critical historical data that off-chain systems and applications rely upon for token metadata tracking.

## Likelihood Explanation

**Likelihood: Medium-High**

- **Prerequisites**: Requires governance to toggle the `MODULE_EVENT_MIGRATION` flag from enabled → disabled, which is explicitly permitted by the feature flag system
- **Affected Users**: All token creators who emit property mutation events during the toggling period
- **Complexity**: Low - happens automatically without attacker action once flag is toggled
- **Detection**: Difficult to detect until event queries return inconsistent results

The feature is marked as "transient" (temporary), suggesting it's intended to eventually be disabled after migration, making this scenario likely during the deprecation process. [7](#0-6) 

## Recommendation

**Solution 1: Make MODULE_EVENT_MIGRATION One-Way**

Prevent the flag from being disabled once enabled by adding validation in `change_feature_flags_for_next_epoch`:

```move
// In features.move
const EFEATURE_CANNOT_BE_DISABLED: u64 = 3;

public fun change_feature_flags_for_next_epoch(
    framework: &signer,
    enable: vector<u64>,
    disable: vector<u64>
) acquires PendingFeatures, Features {
    // Check if MODULE_EVENT_MIGRATION is being disabled
    if (disable.contains(&MODULE_EVENT_MIGRATION) && is_enabled(MODULE_EVENT_MIGRATION)) {
        abort error::invalid_argument(EFEATURE_CANNOT_BE_DISABLED)
    };
    // ... rest of function
}
```

**Solution 2: Synchronize EventHandle Counter with V2 Events**

Update the Move framework to increment `EventHandle.counter` even when emitting V2 events:

```move
// In token_event_store.move
friend fun emit_default_property_mutate_event(...) acquires TokenEventStoreV1 {
    // ... existing code ...
    
    if (std::features::module_event_migration_enabled()) {
        event::emit(DefaultPropertyMutate { ... });
        // CRITICAL: Increment counter to maintain synchronization
        token_event_store.default_property_mutate_events.counter += 1;
    } else {
        event::emit_event<DefaultPropertyMutateEvent>(...);
    };
}
```

**Recommended Approach**: Implement Solution 1 (one-way flag) as it's simpler and prevents the fundamental issue. Document that `MODULE_EVENT_MIGRATION` should be treated as permanent once enabled.

## Proof of Concept

```move
// Move test demonstrating the vulnerability
#[test(framework = @std, creator = @0xCAFE)]
fun test_event_sequence_collision(framework: &signer, creator: &signer) {
    use std::features;
    use aptos_token::token_event_store;
    
    // Setup: Initialize token with event store
    token_event_store::initialize_token_event_store(creator);
    
    // Phase 1: Emit 2 V1 events (flag disabled)
    features::change_feature_flags_for_testing(framework, vector[], vector[57]); // Disable
    token_event_store::emit_default_property_mutate_event(
        creator, string::utf8(b"Collection"), string::utf8(b"Token"),
        vector[string::utf8(b"key1")], 
        vector[option::none()],
        vector[property_value_1]
    );
    // EventHandle.counter = 1, event seq = 0
    
    token_event_store::emit_default_property_mutate_event(
        creator, string::utf8(b"Collection"), string::utf8(b"Token"),
        vector[string::utf8(b"key2")], 
        vector[option::none()],
        vector[property_value_2]
    );
    // EventHandle.counter = 2, event seq = 1
    
    // Phase 2: Enable flag and emit 2 V2 events
    features::change_feature_flags_for_testing(framework, vector[57], vector[]); // Enable
    token_event_store::emit_default_property_mutate_event(
        creator, string::utf8(b"Collection"), string::utf8(b"Token"),
        vector[string::utf8(b"key3")], 
        vector[option::none()],
        vector[property_value_3]
    );
    // V2 emitted, EventHandle.counter still = 2, translator assigns seq = 2
    
    token_event_store::emit_default_property_mutate_event(
        creator, string::utf8(b"Collection"), string::utf8(b"Token"),
        vector[string::utf8(b"key4")], 
        vector[option::none()],
        vector[property_value_4]
    );
    // V2 emitted, EventHandle.counter still = 2, translator assigns seq = 3
    
    // Phase 3: Disable flag and emit V1 event
    features::change_feature_flags_for_testing(framework, vector[], vector[57]); // Disable
    token_event_store::emit_default_property_mutate_event(
        creator, string::utf8(b"Collection"), string::utf8(b"Token"),
        vector[string::utf8(b"key5")], 
        vector[option::none()],
        vector[property_value_5]
    );
    // V1 emitted with seq = 2 (reads stale counter = 2)
    // COLLISION: Overwrites the event from Phase 2 with key3!
    
    // Verification: Query events by sequence number
    // Event at seq 2 should be key3 but will return key5 due to overwrite
}
```

**Notes:**

The vulnerability demonstrates a fundamental design flaw in the event migration strategy where the state synchronization between V1 EventHandle counters and V2 event translation is not maintained. This breaks the deterministic execution invariant and causes permanent data loss in the indexer layer.

### Citations

**File:** aptos-move/framework/aptos-token/sources/token_event_store.move (L372-409)
```text
    friend fun emit_default_property_mutate_event(
        creator: &signer,
        collection: String,
        token: String,
        keys: vector<String>,
        old_values: vector<Option<PropertyValue>>,
        new_values: vector<PropertyValue>,
    ) acquires TokenEventStoreV1 {
        let creator_addr = signer::address_of(creator);

        let event = DefaultPropertyMutateEvent {
            creator: creator_addr,
            collection,
            token,
            keys,
            old_values,
            new_values,
        };

        initialize_token_event_store(creator);
        let token_event_store = &mut TokenEventStoreV1[creator_addr];
        if (std::features::module_event_migration_enabled()) {
            event::emit(
                DefaultPropertyMutate {
                    creator: creator_addr,
                    collection,
                    token,
                    keys,
                    old_values,
                    new_values,
                });
        } else {
            event::emit_event<DefaultPropertyMutateEvent>(
                &mut token_event_store.default_property_mutate_events,
                event,
            );
        };
    }
```

**File:** aptos-move/framework/aptos-framework/sources/event.move (L54-60)
```text
    public fun emit_event<T: drop + store>(handle_ref: &mut EventHandle<T>, msg: T) {
        write_to_event_store<T>(bcs::to_bytes(&handle_ref.guid), handle_ref.counter, msg);
        spec {
            assume handle_ref.counter + 1 <= MAX_U64;
        };
        handle_ref.counter += 1;
    }
```

**File:** storage/indexer/src/event_v2_translator.rs (L1160-1201)
```rust
struct DefaultPropertyMutateTranslator;
impl EventV2Translator for DefaultPropertyMutateTranslator {
    fn translate_event_v2_to_v1(
        &self,
        v2: &ContractEventV2,
        engine: &EventV2TranslationEngine,
    ) -> Result<ContractEventV1> {
        let default_property_mutate = DefaultPropertyMutate::try_from_bytes(v2.event_data())?;
        let struct_tag = StructTag::from_str("0x3::token_event_store::TokenEventStoreV1")?;
        let (key, sequence_number) = if let Some(state_value_bytes) = engine
            .get_state_value_bytes_for_resource(default_property_mutate.creator(), &struct_tag)?
        {
            let object_resource: TokenEventStoreV1Resource = bcs::from_bytes(&state_value_bytes)?;
            let key = *object_resource.default_property_mutate_events().key();
            let sequence_number = engine.get_next_sequence_number(
                &key,
                object_resource.default_property_mutate_events().count(),
            )?;
            (key, sequence_number)
        } else {
            // If the TokenEventStoreV1 resource is not found, we skip the event translation to
            // avoid panic because the creation number cannot be decided.
            return Err(AptosDbError::from(anyhow::format_err!(
                "TokenEventStoreV1 resource not found"
            )));
        };
        let default_property_mutate_event = DefaultPropertyMutateEvent::new(
            *default_property_mutate.creator(),
            default_property_mutate.collection().clone(),
            default_property_mutate.token().clone(),
            default_property_mutate.keys().clone(),
            default_property_mutate.old_values().clone(),
            default_property_mutate.new_values().clone(),
        );
        Ok(ContractEventV1::new(
            key,
            sequence_number,
            DEFAULT_PROPERTY_MUTATE_EVENT_TYPE.clone(),
            bcs::to_bytes(&default_property_mutate_event)?,
        )?)
    }
}
```

**File:** storage/indexer_schemas/src/schema/event_by_key/mod.rs (L23-29)
```rust
define_pub_schema!(EventByKeySchema, Key, Value, EVENT_BY_KEY_CF_NAME);

type SeqNum = u64;
type Key = (EventKey, SeqNum);

type Index = u64;
type Value = (Version, Index);
```

**File:** aptos-move/framework/move-stdlib/sources/configs/features.move (L465-474)
```text
    /// Whether aptos_framwork enables the behavior of module event migration.
    ///
    /// Lifetime: transient
    const MODULE_EVENT_MIGRATION: u64 = 57;

    public fun get_module_event_migration_feature(): u64 { MODULE_EVENT_MIGRATION }

    public fun module_event_migration_enabled(): bool acquires Features {
        is_enabled(MODULE_EVENT_MIGRATION)
    }
```

**File:** aptos-move/framework/move-stdlib/sources/configs/features.move (L805-828)
```text
    public fun change_feature_flags_for_next_epoch(
        framework: &signer,
        enable: vector<u64>,
        disable: vector<u64>
    ) acquires PendingFeatures, Features {
        assert!(signer::address_of(framework) == @std, error::permission_denied(EFRAMEWORK_SIGNER_NEEDED));

        // Figure out the baseline feature vec that the diff will be applied to.
        let new_feature_vec = if (exists<PendingFeatures>(@std)) {
            // If there is a buffered feature vec, use it as the baseline.
            let PendingFeatures { features } = move_from<PendingFeatures>(@std);
            features
        } else if (exists<Features>(@std)) {
            // Otherwise, use the currently effective feature flag vec as the baseline, if it exists.
            Features[@std].features
        } else {
            // Otherwise, use an empty feature vec.
            vector[]
        };

        // Apply the diff and save it to the buffer.
        apply_diff(&mut new_feature_vec, enable, disable);
        move_to(framework, PendingFeatures { features: new_feature_vec });
    }
```
