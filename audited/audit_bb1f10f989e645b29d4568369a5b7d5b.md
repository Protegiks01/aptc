# Audit Report

## Title
LiveDataServiceInfo.known_latest_version Can Decrease Over Time Without Validation or Alerts

## Summary
The `LiveDataServiceInfo` struct's `known_latest_version` field can decrease over time due to the ping response mechanism using the request's version instead of the service's internal atomic version. This violates the monotonicity invariant expected for blockchain version tracking and silently accepts version decreases that should trigger alerts for potential chain rollbacks or reorganizations.

## Finding Description
The vulnerability exists in how `LiveDataServiceInfo` constructs ping responses and how the MetadataManager stores them without validation.

**Root Cause in LiveDataService Ping Response:** [1](#0-0) 

The ping handler extracts `known_latest_version` from the incoming request and uses it directly in the response, rather than using the service's internal atomic version tracker. While the internal tracker is updated via `fetch_max` (ensuring monotonic increase internally), the response value is decoupled from this.

**Lack of Validation in MetadataManager:** [2](#0-1) 

When the MetadataManager receives a `LiveDataServiceInfo` from a ping response, it directly pushes it to `recent_states` without checking if `known_latest_version` has decreased compared to previous entries.

**Attack Scenario:**
1. At T1: MetadataManager has `known_latest_version = 1000`, sends ping to LiveDataService
2. LiveDataService responds with `LiveDataServiceInfo { known_latest_version: Some(1000) }`, stored in `recent_states[0]`
3. At T2: Fullnode updates MetadataManager to version 2000
4. MetadataManager sends ping with version 2000
5. LiveDataService responds with `LiveDataServiceInfo { known_latest_version: Some(2000) }`, stored in `recent_states[1]`
6. At T3: Due to network delays, a retry, or async processing, a ping request from T1.5 with version 1500 arrives late
7. LiveDataService responds with `LiveDataServiceInfo { known_latest_version: Some(1500) }`
8. This gets stored in `recent_states[2]`, creating the sequence: `[1000, 2000, 1500]` — **the version decreased**

The internal atomic tracker at the LiveDataService correctly maintains monotonicity via `fetch_max`: [3](#0-2) 

However, this protection doesn't extend to the response construction, creating a disconnect between internal state and reported state.

## Impact Explanation
**Severity: HIGH**

This vulnerability breaks critical monitoring and alerting assumptions:

1. **Silent Version Decreases**: Blockchain version numbers should only increase. A decrease typically indicates a chain rollback or reorganization—critical events requiring immediate investigation and alerts. Currently, the system silently accepts these decreases.

2. **Monitoring System Blindness**: Any monitoring checking `recent_states.back().known_latest_version` for anomalies will see non-monotonic sequences but has no built-in detection or alerting mechanism.

3. **Data Inconsistency**: Consumers of `LiveDataServiceInfo` may make incorrect assumptions about data availability, potentially requesting transactions at versions that no longer exist in the canonical chain.

4. **Indexer Reliability**: The indexer GRPC infrastructure is critical for applications querying blockchain state. Version inconsistencies can propagate to dependent systems, causing cascading failures.

Per Aptos bug bounty criteria, this qualifies as **High Severity** ($50,000 tier) due to "Significant protocol violations" in the indexer subsystem that could affect validator node operations and API reliability.

## Likelihood Explanation
**Likelihood: MEDIUM-HIGH**

This can occur through normal operational conditions:

1. **Network Delays**: Distributed systems with network latency can easily have out-of-order message delivery
2. **Concurrent Operations**: Multiple ping operations happening simultaneously across different components
3. **Retry Logic**: If ping requests are retried, older versions may arrive after newer ones
4. **No Prevention Mechanism**: The code has no checks preventing this scenario

The vulnerability doesn't require an active attacker—it can happen due to normal distributed system timing issues, making it likely to occur in production.

## Recommendation

**Fix 1: Use Internal Version in Response**

Modify the ping response to use the service's internal `known_latest_version` instead of the request version:

```rust
// In service.rs, line 179, change from:
known_latest_version: Some(known_latest_version),
// To:
known_latest_version: Some(self.connection_manager.known_latest_version()),
```

**Fix 2: Add Validation in MetadataManager**

Add monotonicity validation when storing `LiveDataServiceInfo`:

```rust
fn handle_live_data_service_info(
    &self,
    address: GrpcAddress,
    mut info: LiveDataServiceInfo,
) -> Result<()> {
    let mut entry = self
        .live_data_services
        .entry(address.clone())
        .or_insert(LiveDataService::new(address));
    
    // Validate monotonicity
    if let (Some(new_ver), Some(last_state)) = 
        (info.known_latest_version, entry.value().recent_states.back()) {
        if let Some(last_ver) = last_state.known_latest_version {
            if new_ver < last_ver {
                warn!(
                    "Version decreased for {}: {} -> {}. Possible rollback!",
                    address, last_ver, new_ver
                );
                // Emit alert metric
                COUNTER.with_label_values(&["version_decrease_detected"]).inc();
            }
        }
    }
    
    if info.stream_info.is_none() {
        info.stream_info = Some(StreamInfo {
            active_streams: vec![],
        });
    }
    entry.value_mut().recent_states.push_back(info);
    if entry.value().recent_states.len() > MAX_NUM_OF_STATES_TO_KEEP {
        entry.value_mut().recent_states.pop_front();
    }

    Ok(())
}
```

## Proof of Concept

```rust
#[tokio::test]
async fn test_version_decrease_in_ping_response() {
    // Setup connection manager with initial version
    let connection_manager = Arc::new(
        ConnectionManager::new(
            1, // chain_id
            vec!["http://localhost:50051".to_string()],
            "http://localhost:50052".to_string(),
            true, // is_live_data_service
        ).await
    );
    
    // Set internal version to 2000
    connection_manager.update_known_latest_version(2000);
    assert_eq!(connection_manager.known_latest_version(), 2000);
    
    // Simulate ping with OLD version 1500 (delayed/retried request)
    let request = PingDataServiceRequest {
        known_latest_version: Some(1500),
        ping_live_data_service: true,
    };
    
    // Create service wrapper
    let (tx, _rx) = tokio::sync::mpsc::channel(100);
    let service = DataServiceWrapper::new(
        connection_manager.clone(),
        tx,
        100,
        true,
    );
    
    // Send ping
    let response = service.ping(Request::new(request)).await.unwrap();
    let info = response.into_inner();
    
    // Extract LiveDataServiceInfo
    if let Some(Info::LiveDataServiceInfo(live_info)) = info.info {
        // BUG: Response contains 1500, not 2000!
        assert_eq!(live_info.known_latest_version, Some(1500));
        
        // Internal state is still 2000 (correct)
        assert_eq!(connection_manager.known_latest_version(), 2000);
        
        // This demonstrates the disconnect: internal=2000, response=1500
        println!("VULNERABILITY: Response version (1500) < Internal version (2000)");
        println!("This creates non-monotonic version sequences in MetadataManager!");
    }
}
```

## Notes

This vulnerability is particularly insidious because:
- The internal atomic protection (`fetch_max`) gives false confidence that versions are monotonic
- The disconnect only appears in the externally-visible API responses
- No validation exists at the consumer side (MetadataManager)
- Silent failures make debugging difficult in production

The fix should implement both recommendations: use internal version in responses AND add validation with alerting when storing states.

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/service.rs (L164-179)
```rust
        let known_latest_version = request.known_latest_version();
        self.connection_manager
            .update_known_latest_version(known_latest_version);
        let stream_info = StreamInfo {
            active_streams: self.connection_manager.get_active_streams(),
        };

        let response = if self.is_live_data_service {
            let min_servable_version = match LIVE_DATA_SERVICE.get() {
                Some(svc) => Some(svc.get_min_servable_version().await),
                None => None,
            };
            let info = LiveDataServiceInfo {
                chain_id: self.connection_manager.chain_id(),
                timestamp: Some(timestamp_now_proto()),
                known_latest_version: Some(known_latest_version),
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L489-509)
```rust
    fn handle_live_data_service_info(
        &self,
        address: GrpcAddress,
        mut info: LiveDataServiceInfo,
    ) -> Result<()> {
        let mut entry = self
            .live_data_services
            .entry(address.clone())
            .or_insert(LiveDataService::new(address));
        if info.stream_info.is_none() {
            info.stream_info = Some(StreamInfo {
                active_streams: vec![],
            });
        }
        entry.value_mut().recent_states.push_back(info);
        if entry.value().recent_states.len() > MAX_NUM_OF_STATES_TO_KEEP {
            entry.value_mut().recent_states.pop_front();
        }

        Ok(())
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/connection_manager.rs (L185-188)
```rust
    pub(crate) fn update_known_latest_version(&self, version: u64) {
        self.known_latest_version
            .fetch_max(version, Ordering::SeqCst);
    }
```
