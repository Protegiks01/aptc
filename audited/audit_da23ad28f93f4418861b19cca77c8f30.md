# Audit Report

## Title
Memory Rate Limiter Silent Failure in complete() Breaks Rate Limit Guarantees Due to LRU Cache Eviction

## Summary
The `complete()` function in `MemoryRatelimitChecker` silently succeeds with `Ok(())` even when the decrement operation fails to properly rollback the rate limit counter due to LRU cache eviction. This breaks rate limit guarantees by allowing IPs to reset their counters or triggering integer underflow. [1](#0-0) 

## Finding Description
The `MemoryRatelimitChecker` uses an LRU cache with a maximum size (default 1,000,000 entries) to track IP request counts. When the cache is full, the least recently used IPs are automatically evicted. The vulnerability occurs in the interaction between the `check()` and `complete()` functions: [2](#0-1) 

**Attack Flow:**

1. During `check()`, an IP's counter is incremented (e.g., from 0 to 1) [3](#0-2) 

2. The LRU cache evicts this IP when 1,000,000+ other IPs make requests

3. A 500 error occurs for the original request, triggering `complete()` with `response_is_500 = true` [4](#0-3) 

4. In `complete()`, `get_or_insert_mut(ip, || 1)` **re-inserts** the evicted IP with value 1 (not the original incremented value)

5. The decrement operation (`-= 1`) changes the value from 1 to 0

6. The function returns `Ok(())` with no indication that the rollback failed

**The Silent Failure:** The original increment is NOT properly rolled back. Instead, a fresh entry was created and decremented, leaving the IP with count 0 and effectively resetting their rate limit.

**Integer Underflow Risk:** If `complete()` is called multiple times for the same evicted IP:
- First call: insert 1, decrement to 0
- Second call: get 0, decrement causes integer underflow (wraps to `u32::MAX = 4,294,967,295` in release mode or panics in debug mode)

This differs from the Redis implementation which correctly handles non-existent keys: [5](#0-4) 

## Impact Explanation
**Medium Severity** - This vulnerability breaks rate limiting security controls:

1. **Rate Limit Bypass**: Attackers can reset their IP counters by forcing cache eviction, allowing unlimited requests beyond the configured `max_requests_per_day` limit

2. **Faucet Funds Drainage**: Attackers can drain the faucet faster than intended by circumventing rate limits

3. **Potential DoS**: Integer underflow can cause:
   - Panic in debug builds (crashes the faucet service)
   - Counter wraparound to `u32::MAX` in release builds (permanent IP bans after 2 consecutive 500 errors)

Per Aptos bug bounty criteria, this qualifies as **Medium Severity**: "State inconsistencies requiring intervention" and "Limited funds loss or manipulation" - the rate limit counter state becomes inconsistent, and faucet funds can be manipulated through bypassed limits.

## Likelihood Explanation
**High Likelihood** - The vulnerability is easily exploitable:

1. **No Special Privileges Required**: Any network client can trigger this by making faucet requests

2. **Natural Cache Eviction**: With the default 1,000,000 entry limit, cache eviction happens naturally in high-traffic scenarios

3. **Attacker-Induced Eviction**: An attacker can deliberately flood the faucet with requests from 1,000,000+ different IPs to force eviction of their target IP

4. **500 Errors Are Common**: Server errors occur naturally during high load, deployment, or database issues

5. **No Monitoring**: The function returns `Ok(())` silently, so operators won't be alerted to the failure

## Recommendation
Replace `get_or_insert_mut()` with `get_mut()` to avoid re-inserting evicted entries. Only decrement if the IP exists in the cache:

```rust
async fn complete(&self, data: CompleteData) -> Result<(), AptosTapError> {
    if data.response_is_500 {
        let mut ip_to_requests_today = self.ip_to_requests_today.lock().await;
        if let Some(count) = ip_to_requests_today.get_mut(&data.checker_data.source_ip) {
            // Only decrement if we can avoid underflow
            *count = count.saturating_sub(1);
        }
        // If IP not in cache (evicted), we silently skip the decrement
        // This is acceptable because the IP already "paid" by being evicted
    }
    Ok(())
}
```

**Alternative Fix**: Track pending decrements in a separate structure to handle evicted IPs correctly, or log warnings when decrement fails.

## Proof of Concept

```rust
#[tokio::test]
async fn test_complete_after_cache_eviction() {
    use std::net::IpAddr;
    use std::sync::Arc;
    
    // Create rate limiter with small cache (3 entries) and limit of 5 requests/day
    let config = MemoryRatelimitCheckerConfig {
        max_requests_per_day: 5,
        max_entries_in_map: NonZeroUsize::new(3).unwrap(),
    };
    let checker = MemoryRatelimitChecker::new(config);
    
    // IP that will be evicted
    let target_ip: IpAddr = "1.2.3.4".parse().unwrap();
    let target_addr = AccountAddress::random();
    
    // Step 1: Make request from target IP (counter: 0 -> 1 -> 2 after increment)
    let checker_data = CheckerData {
        time_request_received_secs: get_current_time_secs(),
        receiver: target_addr,
        source_ip: target_ip,
        headers: Arc::new(HeaderMap::new()),
    };
    
    let result = checker.check(checker_data.clone(), false).await.unwrap();
    assert!(result.is_empty()); // Request allowed
    
    // Verify counter is 2 (inserted as 1, then incremented)
    assert_eq!(*checker.ip_to_requests_today.lock().await.get(&target_ip).unwrap(), 2);
    
    // Step 2: Fill cache with 3 other IPs to evict target IP
    for i in 0..3 {
        let evicting_ip: IpAddr = format!("10.0.0.{}", i).parse().unwrap();
        let evicting_data = CheckerData {
            time_request_received_secs: get_current_time_secs(),
            receiver: AccountAddress::random(),
            source_ip: evicting_ip,
            headers: Arc::new(HeaderMap::new()),
        };
        checker.check(evicting_data, false).await.unwrap();
    }
    
    // Step 3: Verify target IP was evicted
    assert!(checker.ip_to_requests_today.lock().await.get(&target_ip).is_none());
    
    // Step 4: Call complete() with response_is_500 = true
    let complete_data = CompleteData {
        checker_data: checker_data.clone(),
        txn_hashes: vec![],
        response_is_500: true,
    };
    
    // This returns Ok(()) even though the decrement didn't rollback the original increment!
    checker.complete(complete_data).await.unwrap();
    
    // Step 5: Verify the bug - IP now has count 0 instead of being absent
    // The original increment (0->2) was NOT rolled back
    // Instead, a new entry (1->0) was created
    let final_count = checker.ip_to_requests_today.lock().await.get(&target_ip).copied();
    assert_eq!(final_count, Some(0)); // BUG: Should be None (absent) or 1 (rolled back)
    
    // Step 6: Demonstrate rate limit bypass - IP can now make 5 more requests
    let result = checker.check(checker_data.clone(), false).await.unwrap();
    assert!(result.is_empty()); // Should be rejected if rate limit worked correctly
    
    // Step 7: Demonstrate underflow vulnerability
    let complete_data2 = CompleteData {
        checker_data: checker_data.clone(),
        txn_hashes: vec![],
        response_is_500: true,
    };
    checker.complete(complete_data2).await.unwrap();
    
    // Counter underflows: 0 - 1 = u32::MAX (in release mode)
    let underflowed_count = checker.ip_to_requests_today.lock().await.get(&target_ip).copied();
    // In release mode: u32::MAX, in debug mode: would panic
    println!("Underflowed count: {:?}", underflowed_count);
}
```

## Notes
This vulnerability specifically affects the in-memory rate limiter implementation. The Redis-based implementation does not have this issue because Redis `DECR` on non-existent keys creates the key with value -1 rather than re-inserting with an arbitrary value. The issue fundamentally stems from using `get_or_insert_mut()` instead of `get_mut()` in a context where the insertion behavior is incorrect.

### Citations

**File:** crates/aptos-faucet/core/src/checkers/memory_ratelimit.rs (L31-42)
```rust
pub struct MemoryRatelimitChecker {
    pub max_requests_per_day: u32,

    /// Map of IP to how many requests they've submitted today (where the
    /// response wasn't a 500). To avoid OOMing the server, we set a limit
    /// on how many entries we have in the table.
    pub ip_to_requests_today: Mutex<LruCache<IpAddr, u32>>,

    /// Used for tracking daily ratelimit. See the comment in RedisRatelimitChecker
    /// for more information on how we track daily limits.
    pub current_day: AtomicU64,
}
```

**File:** crates/aptos-faucet/core/src/checkers/memory_ratelimit.rs (L77-88)
```rust
        let requests_today = ip_to_requests_today.get_or_insert_mut(data.source_ip, || 1);
        if *requests_today >= self.max_requests_per_day {
            return Ok(vec![RejectionReason::new(
                format!(
                    "IP {} has exceeded the daily limit of {} requests",
                    data.source_ip, self.max_requests_per_day
                ),
                RejectionReasonCode::UsageLimitExhausted,
            )]);
        } else if !dry_run {
            *requests_today += 1;
        }
```

**File:** crates/aptos-faucet/core/src/checkers/memory_ratelimit.rs (L93-102)
```rust
    async fn complete(&self, data: CompleteData) -> Result<(), AptosTapError> {
        if data.response_is_500 {
            *self
                .ip_to_requests_today
                .lock()
                .await
                .get_or_insert_mut(data.checker_data.source_ip, || 1) -= 1;
        }
        Ok(())
    }
```

**File:** crates/aptos-faucet/core/src/endpoints/fund.rs (L332-346)
```rust
        if !bypass {
            let response_is_500 = match &fund_result {
                Ok(_) => false,
                Err(e) => e.error_code.status().is_server_error(),
            };
            let complete_data = CompleteData {
                checker_data,
                txn_hashes: txn_hashes.clone(),
                response_is_500,
            };
            for checker in &self.checkers {
                checker.complete(complete_data.clone()).await.map_err(|e| {
                    AptosTapError::new_with_error_code(e, AptosTapErrorCode::CheckerError)
                })?;
            }
```

**File:** crates/aptos-faucet/core/src/checkers/redis_ratelimit.rs (L328-334)
```rust
        let _: () = conn.decr(&key, 1).await.map_err(|e| {
            AptosTapError::new_with_error_code(
                format!("Failed to decrement value for redis key {}: {}", key, e),
                AptosTapErrorCode::StorageError,
            )
        })?;
        Ok(())
```
