# Audit Report

## Title
Missing Field Consistency Validation in ChangeSetConfigs Enables Network DoS via Governance Misconfiguration

## Summary
The `ChangeSetConfigs` struct lacks validation of mutual consistency between its six limit fields (`max_bytes_per_write_op`, `max_bytes_all_write_ops_per_transaction`, `max_bytes_per_event`, `max_bytes_all_events_per_transaction`, `max_write_ops_per_transaction`, and `gas_feature_version`). Invalid combinations—particularly zero values or logically inconsistent limits—can pass construction and become active on-chain, causing complete network failure by rejecting all transactions with write operations or events.

## Finding Description

The `ChangeSetConfigs` struct is constructed without any validation of field consistency at multiple layers:

**Layer 1 - Rust Constructor:**
The `new_impl()` method accepts all parameters without validation: [1](#0-0) 

**Layer 2 - Move Framework:**
The gas schedule update functions contain explicit TODO comments acknowledging missing consistency checks: [2](#0-1) [3](#0-2) 

**Layer 3 - Validation Logic Inconsistency:**
The `check_change_set()` method treats zero values inconsistently. It explicitly checks if `max_write_ops_per_transaction != 0` before validation (treating 0 as "skip check"), but applies direct comparisons to byte limits without this safeguard: [4](#0-3) 

This means:
- If `max_bytes_per_write_op = 0`, any write operation with size > 0 is rejected (line 105)
- If `max_bytes_all_write_ops_per_transaction = 0`, any transaction with write ops is rejected (line 110)
- If `max_bytes_per_event = 0`, any event with size > 0 is rejected (line 118)
- If `max_bytes_all_events_per_transaction = 0`, any transaction with events is rejected (line 122)

**Attack Propagation:**
1. Governance proposes gas schedule update with invalid values (e.g., byte limits = 0, or `max_bytes_per_write_op = 10MB` while `max_bytes_all_write_ops_per_transaction = 1MB`)
2. Update functions accept the malformed configuration without validation: [5](#0-4) 

3. At epoch transition, the malformed config becomes active: [6](#0-5) 

4. All subsequent transactions with write operations or events fail with `STORAGE_WRITE_LIMIT_REACHED`

**Precedent for Required Validation:**
The Diem framework demonstrates the expected validation pattern with consistency checks: [7](#0-6) 

## Impact Explanation

**Severity: Medium** - This meets the Aptos bug bounty criteria for "State inconsistencies requiring intervention" with network-wide impact:

1. **Complete Network Halt**: If byte limits are set to 0, no transactions can modify state or emit events, effectively freezing the blockchain
2. **Non-deterministic Failures**: Inconsistent limits (e.g., per-op limit > total limit) cause confusing transaction rejections
3. **Difficult Recovery**: Emergency governance proposals also require write operations, creating a deadlock scenario potentially requiring hard fork
4. **Consensus Impact**: All validators would process transactions identically (deterministic execution preserved), but the network would be unable to process any state-changing transactions

The impact is limited to Medium rather than Critical because:
- Requires governance control to trigger (not directly exploitable by unprivileged attacker)
- Deterministic execution is maintained (no consensus splits)
- Theoretically recoverable through emergency procedures

## Likelihood Explanation

**Likelihood: Medium-Low** 

While this requires governance control (high barrier), the likelihood is elevated because:

1. **No Safeguards**: Zero validation exists at any layer to prevent misconfiguration
2. **Known Issue**: TODO comments confirm developers were aware validation was needed but never implemented it
3. **Human Error**: Governance participants could accidentally propose incorrect values without malicious intent
4. **No Testing**: The governance proposal generation has minimal validation: [8](#0-7) 

The only check is blob size, not parameter consistency.

## Recommendation

Implement multi-layer consistency validation:

**1. Add Rust-level validation in ChangeSetConfigs constructor:**

```rust
fn new_impl(
    gas_feature_version: u64,
    max_bytes_per_write_op: u64,
    max_bytes_all_write_ops_per_transaction: u64,
    max_bytes_per_event: u64,
    max_bytes_all_events_per_transaction: u64,
    max_write_ops_per_transaction: u64,
) -> Result<Self, String> {
    // Validate non-zero for critical limits (or document 0 as meaning "unlimited")
    if max_bytes_per_write_op == 0 {
        return Err("max_bytes_per_write_op cannot be 0".to_string());
    }
    if max_bytes_all_write_ops_per_transaction == 0 {
        return Err("max_bytes_all_write_ops_per_transaction cannot be 0".to_string());
    }
    
    // Validate logical consistency
    if max_bytes_per_write_op > max_bytes_all_write_ops_per_transaction {
        return Err("max_bytes_per_write_op cannot exceed max_bytes_all_write_ops_per_transaction".to_string());
    }
    
    // Similar checks for events
    if max_bytes_per_event == 0 {
        return Err("max_bytes_per_event cannot be 0".to_string());
    }
    if max_bytes_all_events_per_transaction == 0 {
        return Err("max_bytes_all_events_per_transaction cannot be 0".to_string());
    }
    if max_bytes_per_event > max_bytes_all_events_per_transaction {
        return Err("max_bytes_per_event cannot exceed max_bytes_all_events_per_transaction".to_string());
    }
    
    Ok(Self {
        gas_feature_version,
        max_bytes_per_write_op,
        max_bytes_all_write_ops_per_transaction,
        max_bytes_per_event,
        max_bytes_all_events_per_transaction,
        max_write_ops_per_transaction,
    })
}
```

**2. Implement TODO validation in Move gas_schedule module:**

```move
// Replace TODO comments with actual validation
fun validate_gas_schedule_consistency(schedule: &GasScheduleV2) {
    // Extract relevant parameters from entries
    let max_bytes_per_write_op = get_param(schedule, "txn.max_bytes_per_write_op");
    let max_bytes_all_write_ops = get_param(schedule, "txn.max_bytes_all_write_ops_per_transaction");
    
    assert!(max_bytes_per_write_op > 0, EINVALID_GAS_SCHEDULE);
    assert!(max_bytes_all_write_ops > 0, EINVALID_GAS_SCHEDULE);
    assert!(max_bytes_per_write_op <= max_bytes_all_write_ops, EINVALID_GAS_SCHEDULE);
    
    // Similar checks for events
}
```

Call this function in `initialize()`, `set_gas_schedule()`, and `set_for_next_epoch()`.

## Proof of Concept

```move
#[test_only]
module aptos_framework::gas_schedule_consistency_test {
    use aptos_framework::gas_schedule;
    use std::vector;
    
    #[test(framework = @aptos_framework)]
    #[expected_failure(abort_code = 0x10001)] // EINVALID_GAS_SCHEDULE
    fun test_zero_byte_limit_should_fail(framework: signer) {
        // Construct a gas schedule with max_bytes_per_write_op = 0
        let entries = vector::empty();
        
        // Add valid entries for most parameters
        vector::push_back(&mut entries, GasEntry {
            key: string::utf8(b"txn.max_bytes_per_write_op"),
            val: 0  // INVALID: zero limit
        });
        vector::push_back(&mut entries, GasEntry {
            key: string::utf8(b"txn.max_bytes_all_write_ops_per_transaction"),
            val: 10485760  // 10MB
        });
        
        let malformed_schedule = GasScheduleV2 {
            feature_version: 15,
            entries,
        };
        
        let blob = bcs::to_bytes(&malformed_schedule);
        
        // This should fail with validation error, but currently succeeds
        gas_schedule::set_for_next_epoch(&framework, blob);
    }
    
    #[test(framework = @aptos_framework)]
    #[expected_failure(abort_code = 0x10001)] // EINVALID_GAS_SCHEDULE
    fun test_inconsistent_limits_should_fail(framework: signer) {
        // max_bytes_per_write_op > max_bytes_all_write_ops_per_transaction
        let entries = vector::empty();
        
        vector::push_back(&mut entries, GasEntry {
            key: string::utf8(b"txn.max_bytes_per_write_op"),
            val: 10485760  // 10MB
        });
        vector::push_back(&mut entries, GasEntry {
            key: string::utf8(b"txn.max_bytes_all_write_ops_per_transaction"),
            val: 1048576  // 1MB - INVALID: smaller than per-op limit
        });
        
        let malformed_schedule = GasScheduleV2 {
            feature_version: 15,
            entries,
        };
        
        let blob = bcs::to_bytes(&malformed_schedule);
        
        // This should fail with validation error, but currently succeeds
        gas_schedule::set_for_next_epoch(&framework, blob);
    }
}
```

**Note:** These tests currently demonstrate the vulnerability - they would PASS (not abort) in the current implementation because no validation exists, but they SHOULD fail with the recommended fixes in place.

### Citations

**File:** aptos-move/aptos-vm-types/src/storage/change_set_configs.rs (L41-57)
```rust
    fn new_impl(
        gas_feature_version: u64,
        max_bytes_per_write_op: u64,
        max_bytes_all_write_ops_per_transaction: u64,
        max_bytes_per_event: u64,
        max_bytes_all_events_per_transaction: u64,
        max_write_ops_per_transaction: u64,
    ) -> Self {
        Self {
            gas_feature_version,
            max_bytes_per_write_op,
            max_bytes_all_write_ops_per_transaction,
            max_bytes_per_event,
            max_bytes_all_events_per_transaction,
            max_write_ops_per_transaction,
        }
    }
```

**File:** aptos-move/aptos-vm-types/src/storage/change_set_configs.rs (L95-113)
```rust
        if self.max_write_ops_per_transaction != 0
            && change_set.num_write_ops() as u64 > self.max_write_ops_per_transaction
        {
            return storage_write_limit_reached(Some("Too many write ops."));
        }

        let mut write_set_size = 0;
        for (key, op_size) in change_set.write_set_size_iter() {
            if let Some(len) = op_size.write_len() {
                let write_op_size = len + (key.size() as u64);
                if write_op_size > self.max_bytes_per_write_op {
                    return storage_write_limit_reached(None);
                }
                write_set_size += write_op_size;
            }
            if write_set_size > self.max_bytes_all_write_ops_per_transaction {
                return storage_write_limit_reached(None);
            }
        }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L43-50)
```text
    public(friend) fun initialize(aptos_framework: &signer, gas_schedule_blob: vector<u8>) {
        system_addresses::assert_aptos_framework(aptos_framework);
        assert!(!vector::is_empty(&gas_schedule_blob), error::invalid_argument(EINVALID_GAS_SCHEDULE));

        // TODO(Gas): check if gas schedule is consistent
        let gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
        move_to<GasScheduleV2>(aptos_framework, gas_schedule);
    }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L62-77)
```text
        if (exists<GasScheduleV2>(@aptos_framework)) {
            let gas_schedule = borrow_global_mut<GasScheduleV2>(@aptos_framework);
            let new_gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
            assert!(new_gas_schedule.feature_version >= gas_schedule.feature_version,
                error::invalid_argument(EINVALID_GAS_FEATURE_VERSION));
            // TODO(Gas): check if gas schedule is consistent
            *gas_schedule = new_gas_schedule;
        }
        else {
            if (exists<GasSchedule>(@aptos_framework)) {
                _ = move_from<GasSchedule>(@aptos_framework);
            };
            let new_gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
            // TODO(Gas): check if gas schedule is consistent
            move_to<GasScheduleV2>(aptos_framework, new_gas_schedule);
        };
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L91-103)
```text
    public fun set_for_next_epoch(aptos_framework: &signer, gas_schedule_blob: vector<u8>) acquires GasScheduleV2 {
        system_addresses::assert_aptos_framework(aptos_framework);
        assert!(!vector::is_empty(&gas_schedule_blob), error::invalid_argument(EINVALID_GAS_SCHEDULE));
        let new_gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
        if (exists<GasScheduleV2>(@aptos_framework)) {
            let cur_gas_schedule = borrow_global<GasScheduleV2>(@aptos_framework);
            assert!(
                new_gas_schedule.feature_version >= cur_gas_schedule.feature_version,
                error::invalid_argument(EINVALID_GAS_FEATURE_VERSION)
            );
        };
        config_buffer::upsert(new_gas_schedule);
    }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L135-145)
```text
    public(friend) fun on_new_epoch(framework: &signer) acquires GasScheduleV2 {
        system_addresses::assert_aptos_framework(framework);
        if (config_buffer::does_exist<GasScheduleV2>()) {
            let new_gas_schedule = config_buffer::extract_v2<GasScheduleV2>();
            if (exists<GasScheduleV2>(@aptos_framework)) {
                *borrow_global_mut<GasScheduleV2>(@aptos_framework) = new_gas_schedule;
            } else {
                move_to(framework, new_gas_schedule);
            }
        }
    }
```

**File:** third_party/move/move-examples/diem-framework/move-packages/DPN/sources/DiemVMConfig.move (L154-161)
```text
        assert!(
            min_price_per_gas_unit <= max_price_per_gas_unit,
            errors::invalid_argument(EGAS_CONSTANT_INCONSISTENCY)
        );
        assert!(
            min_transaction_gas_units <= maximum_number_of_gas_units,
            errors::invalid_argument(EGAS_CONSTANT_INCONSISTENCY)
        );
```

**File:** aptos-move/aptos-release-builder/src/components/gas.rs (L124-126)
```rust
            let gas_schedule_blob = bcs::to_bytes(new_gas_schedule).unwrap();
            assert!(gas_schedule_blob.len() < 65536);

```
