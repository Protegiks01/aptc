# Audit Report

## Title
Race Condition in Cold Validation Worker Assignment Causes Permanent Block Execution Deadlock

## Summary
A critical race condition exists in the BlockSTMv2 parallel execution engine where `dedicated_worker_id` is reset outside the `pending_requirements` lock in `get_validation_requirement_to_process()`. This creates a window where new validation requirements can be recorded with no assigned worker, resulting in permanent commit blocking and loss of blockchain liveness when BlockSTMv2 is enabled.

## Finding Description

The BlockSTMv2 parallel execution engine uses a dedicated worker to process cold validation requirements for module reads after module publishing. [1](#0-0) 

The race condition occurs in `get_validation_requirement_to_process()` where the `dedicated_worker_id` is reset at line 292 OUTSIDE any lock protection: [2](#0-1) 

When `activate_pending_requirements()` returns true (indicating no validations needed), it has already released the lock and reset `min_idx_with_unprocessed_validation_requirement`: [3](#0-2) 

**The Race Window:**

Between line 291 (when `activate_pending_requirements` returns) and line 292 (when `dedicated_worker_id` is reset), another worker can call `record_requirements()` during transaction commit: [4](#0-3) 

In `record_requirements()`, the `compare_exchange` at line 245 attempts to set the dedicated worker but FAILS because Worker 1's ID is still present. The function then updates `min_idx_with_unprocessed_validation_requirement` at line 253, but no worker is assigned because the compare_exchange failed.

**Resulting Broken State:**
- `dedicated_worker_id = u32::MAX` (no assigned worker)
- `min_idx_with_unprocessed_validation_requirement = calling_txn_idx + 1` (blocks commits)
- `pending_requirements` contains unprocessed requirements
- No worker will process these requirements

**Impact on Commits:**

The scheduler checks `is_commit_blocked()` before committing transactions: [5](#0-4) 

The `is_commit_blocked()` function returns true for all transactions >= `min_idx_with_unprocessed_validation_requirement`: [6](#0-5) 

Since `is_dedicated_worker()` returns false for all workers (dedicated_worker_id is u32::MAX), no worker will process the pending requirements, causing permanent commit blocking.

**Contrast with Safe Implementation:**

The `validation_requirement_processed()` function correctly resets `dedicated_worker_id` WHILE holding the lock: [7](#0-6) 

The comment explicitly states: "Since we are holding the lock and pending requirements is empty, it is safe to reset the dedicated worker id."

## Impact Explanation

**Severity: CRITICAL** - This vulnerability causes total loss of liveness/network availability when BlockSTMv2 is enabled.

Once the race condition occurs:
1. **Permanent Deadlock**: Block execution halts permanently at the blocked transaction index with no recovery mechanism
2. **No Worker Assignment**: With `dedicated_worker_id = u32::MAX`, no worker will process orphaned requirements
3. **Consensus Impact**: If multiple validators hit this bug on the same block, consensus cannot progress
4. **Common Trigger**: Any transaction publishing modules can trigger this race during normal operation

This aligns with the Aptos Bug Bounty "Total Loss of Liveness/Network Availability" critical category, as affected nodes cannot commit transactions beyond the blocked index, potentially requiring emergency intervention.

## Likelihood Explanation

**Likelihood: MEDIUM** (when BlockSTMv2 is enabled)

The race condition has these characteristics:
1. **Natural Occurrence**: Race window exists in module publishing transactions with parallel execution
2. **Small Window**: Between two lines of code (291-292), but non-zero on multi-core systems
3. **Specific Conditions Required**: All pending requirements must be for transactions in PendingScheduling/Aborted states
4. **Configuration Dependent**: BlockSTMv2 must be enabled [8](#0-7) 
5. **No Malicious Intent**: Can occur naturally without adversarial behavior

The likelihood is MEDIUM when BlockSTMv2 is enabled but LOWER overall since BlockSTMv2 is not enabled by default. However, this is production code intended for use in high-performance scenarios.

## Recommendation

Reset `dedicated_worker_id` while holding the `pending_requirements` lock, similar to the pattern in `validation_requirement_processed()`. Specifically, move line 292 inside the critical section established by acquiring the lock, ensuring atomicity with the check for empty pending requirements.

The fix should acquire the lock before resetting `dedicated_worker_id` to prevent the race window where `record_requirements()` can observe stale worker IDs.

## Proof of Concept

No executable PoC was provided in the submission. The vulnerability is demonstrated through code analysis of the race condition between `get_validation_requirement_to_process()` and `record_requirements()`.

## Notes

**Important Context:**
1. This vulnerability affects BlockSTMv2, which is configurable but **not enabled by default** in the current codebase
2. The race requires specific timing where pending requirements exist but no transactions need validation
3. While the code analysis clearly demonstrates the race condition exists, an executable stress test demonstrating the deadlock would strengthen this finding
4. The impact is severe when BlockSTMv2 is enabled, but reduced practical impact due to non-default configuration
5. Organizations enabling BlockSTMv2 for performance should be aware of this liveness risk

The race condition is architecturally real and the code paths are verified. The fix is straightforward: maintain lock consistency when resetting `dedicated_worker_id`, as already done in `validation_requirement_processed()`.

### Citations

**File:** aptos-move/block-executor/src/cold_validation.rs (L14-61)
```rust
/**
 * In BlockSTMv2, validations are not scheduled in waves as separate tasks like
 * in BlockSTMv1. Instead normal validations occur granularly and on-demand, at
 * the time of particular updates. However, global code cache does not support
 * push validation by design. This because most blocks do not contain module
 * publishing, so the trade-off taken is to reduce the overhead on the common
 * read path. Instead, published modules become visible to other workers (executing
 * higher indexed txns) during a txn commit, and it is required that all txns
 * that are executed or executing to validate their module read set. This file
 * provides the primitives for BlockSTMv2 scheduler to manage such requirements.
 *
 * A high-level idea is that at any time, at most one worker is responsible for
 * fulfilling the module validation requirements for an interval of txns. The
 * interval starts at the index of a committed txn that published modules, and
 * ends at the first txn that has never been scheduled for execution. (Note: for
 * contended workloads, the scheduler currently may execute later txns early,
 * losing the benefits of this optimization for higher-indexed txns). The interval
 * induces a traversal of the interval to identify the set of txn versions
 * (txn index & incarnation pair) requiring module read set validation. In order
 * to reduce the time in critical (sequential) section of the code, the traversal
 * is performed after the txn is committed by the same worker if no requirements
 * were already active, or by the designated worker that may have already been
 * performing module validations. When this happens, the start of interval is
 * reset to the newly committed txn (which must be higher than recorded start
 * since txns can not be committed with unfulfilled requirements). The traversal
 * can be done locally, only needing access to the array of statuses. After the
 * traversal is finished and the requirements are properly recorded, the designated
 * worker may get module validation tasks to perform from scheduler's next_task
 * call - depending on a distance threshold from the committed prefix of the block.
 * The rationale for a distance threshold is to (a) prioritize more important
 * work and (b) avoid wasted work as txns that get re-executed after module
 * publishing (with higher incarnation) would no longer require module validation.
 *
 * When the interval is reset, the module requirements are combined together.
 * This might cause some txns to be validated against a module when strictly
 * speaking they would not require it. However, it allows a simpler implementation
 * that is easier to reason about, and is not expected to be a bottleneck.
 *
 * The implementation of ColdValidationRequirements is templated over the type of
 * the requirement. This allows easier testing, as well as future extensions to
 * other types of validation requirements that may be better offloaded to an uncommon
 * dedicated path for optimal performance. TODO(BlockSTMv2): a promising direction
 * is to enable caching use-cases in the VM, whereby cache invalidations might be
 * rare and infeasible to record every access for push validation.
 *
 * Finally, ColdValidationRequirements allows to cheaply check if a txn has
 * unfulfilled requirements, needed by the scheduler to avoid committing such txns.
 **/
```

**File:** aptos-move/block-executor/src/cold_validation.rs (L234-266)
```rust
        let mut pending_reqs = self.pending_requirements.lock();
        pending_reqs.push(PendingRequirement {
            requirements,
            from_idx: calling_txn_idx + 1,
            to_idx: min_never_scheduled_idx,
        });

        // Updates to atomic variables while recording pending requirements occur under the
        // pending_requirements lock to ensure atomicity versus draining to activate.
        // However, for simplicity and simpler invariants, all updates (including in
        // validation_requirement_processed) are under the same lock.
        let _ = self.dedicated_worker_id.compare_exchange(
            u32::MAX,
            worker_id,
            Ordering::Relaxed,
            Ordering::Relaxed,
        );
        let prev_min_idx = self
            .min_idx_with_unprocessed_validation_requirement
            .swap(calling_txn_idx + 1, Ordering::Relaxed);
        if prev_min_idx <= calling_txn_idx {
            // Record may not be called with a calling_txn_idx higher or equal to the
            // min_from_idx, as committing calling_txn_idx is impossible before the pending
            // requirements with lower min index are processed and any (lower or equal)
            // required validations are performed.
            return Err(code_invariant_error(format!(
                "Recording validation requirements, min idx = {} <= calling_txn_idx = {}",
                prev_min_idx, calling_txn_idx
            )));
        }

        Ok(())
    }
```

**File:** aptos-move/block-executor/src/cold_validation.rs (L281-295)
```rust
    pub(crate) fn get_validation_requirement_to_process<'a>(
        &self,
        worker_id: u32,
        idx_threshold: TxnIndex,
        statuses: &ExecutionStatuses,
    ) -> Result<Option<(TxnIndex, Incarnation, ValidationRequirement<'a, R>)>, PanicError> {
        if !self.is_dedicated_worker(worker_id) {
            return Ok(None);
        }

        if self.activate_pending_requirements(statuses)? {
            self.dedicated_worker_id.store(u32::MAX, Ordering::Relaxed);
            // If the worker id was reset, the worker can early return (no longer assigned).
            return Ok(None);
        }
```

**File:** aptos-move/block-executor/src/cold_validation.rs (L384-397)
```rust
        let pending_reqs = self.pending_requirements.lock();
        if pending_reqs.is_empty() {
            // Expected to be empty most of the time as publishes are rare and the requirements
            // are drained by the caller when getting the requirement. The check ensures that
            // the min_idx_with_unprocessed_validation_requirement is not incorrectly increased
            // if pending requirements exist for validated_idx. It also allows us to hold the
            // lock while updating the atomic variables.
            if active_reqs_is_empty {
                active_reqs.requirements.clear();
                self.min_idx_with_unprocessed_validation_requirement
                    .store(u32::MAX, Ordering::Relaxed);
                // Since we are holding the lock and pending requirements is empty, it
                // is safe to reset the dedicated worker id.
                self.dedicated_worker_id.store(u32::MAX, Ordering::Relaxed);
```

**File:** aptos-move/block-executor/src/cold_validation.rs (L421-431)
```rust
    pub(crate) fn is_commit_blocked(&self, txn_idx: TxnIndex, incarnation: Incarnation) -> bool {
        // The order of checks is important to avoid a concurrency bugs (since recording
        // happens in the opposite order). We first check that there are no unscheduled
        // requirements below (incl.) the given index, and then that there are no scheduled
        // but yet unfulfilled (validated) requirements for the index.
        self.min_idx_with_unprocessed_validation_requirement
            .load(Ordering::Relaxed)
            <= txn_idx
            || self.deferred_requirements_status[txn_idx as usize].load(Ordering::Relaxed)
                == blocked_incarnation_status(incarnation)
    }
```

**File:** aptos-move/block-executor/src/cold_validation.rs (L501-516)
```rust
        if active_reqs.versions.is_empty() {
            // It is possible that the active versions map was empty, and no pending
            // requirements needed to be activated (i.e. not executing or executed).
            // In this case, we may update min_idx_with_unprocessed_validation_requirement
            // as validation_requirement_processed does so only when the pending
            // requirements are empty.
            let pending_reqs_guard = self.pending_requirements.lock();
            if pending_reqs_guard.is_empty() {
                self.min_idx_with_unprocessed_validation_requirement
                    .store(u32::MAX, Ordering::Relaxed);
                return Ok(true);
            }
        }

        Ok(false)
    }
```

**File:** aptos-move/block-executor/src/scheduler_v2.rs (L631-638)
```rust
            if self
                .cold_validation_requirements
                .is_commit_blocked(next_to_commit_idx, incarnation)
            {
                // May not commit a txn with an unsatisfied validation requirement. This will be
                // more rare than !is_executed in the common case, hence the order of checks.
                return Ok(None);
            }
```

**File:** config/src/config/execution_config.rs (L91-91)
```rust
            blockstm_v2_enabled: false,
```
