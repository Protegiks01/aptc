# Audit Report

## Title
Subscription Stream Desynchronization via Mutual Exclusivity Violation in TransactionDataWithProofResponse

## Summary
The `TryFrom` implementations for `TransactionOrOutputListWithProofV2` do not validate that `transaction_list_with_proof` and `transaction_output_list_with_proof` fields are mutually exclusive. A malicious storage service peer can send responses with both fields populated, causing the server-side subscription tracker to count items based on `transaction_data_response_type` while the client processes different data based on `if-else if` logic. This creates a version tracking mismatch that breaks the subscription protocol, causing state sync failures.

## Finding Description
The vulnerability exists in the state sync subscription protocol where server and client track the peer's synchronized version differently when processing `TransactionDataWithProofResponse`.

**Design Intent:** The `TransactionDataWithProofResponse` struct contains three fields: [1](#0-0) 

The design intent is that exactly one of `transaction_list_with_proof` or `transaction_output_list_with_proof` should be `Some` based on the `transaction_data_response_type` field. However, there is no validation enforcing this mutual exclusivity.

**Vulnerability Path:**

1. **No deserialization validation:** The struct uses auto-derived `Deserialize` with no custom validation to reject malicious payloads where both fields are `Some`.

2. **TryFrom bypasses validation:** When converting to `TransactionOrOutputListWithProofV2`: [2](#0-1) 

The code directly returns both Option fields without checking mutual exclusivity.

3. **Server-side tracking uses type field:** In subscription processing, the server counts items based on `transaction_data_response_type`: [3](#0-2) 

If type is `TransactionOutputData` and `transaction_output_list_with_proof` contains 50 items, the server increments `highest_known_version` by 50: [4](#0-3) 

4. **Client-side processing uses if-else if:** When converting to `ResponsePayload`: [5](#0-4) 

If both fields are `Some`, it always picks `transaction_list` and ignores the type field and output list entirely. If `transaction_list_with_proof` contains 100 items, the client processes all 100 transactions.

5. **Subscription desynchronization:** The server uses `highest_known_version` to generate the next request: [6](#0-5) 

**Attack Scenario:**
- Client subscribes at version 0
- Malicious server sends: `transaction_data_response_type: TransactionOutputData`, `transaction_list_with_proof: Some(100 txns)`, `transaction_output_list_with_proof: Some(50 outputs)`
- Server counts 50 items, updates `highest_known_version = 50`
- Client processes 100 transactions, reaches version 100
- Next request: server fetches from version 51, but client is at version 100
- Result: duplicate data (v51-100) or missing data (v101+), state sync failure

## Impact Explanation
**Severity: High**

This vulnerability causes **significant protocol violations** meeting the High severity criteria:

1. **State Sync Failure:** Nodes using subscription-based sync become stuck or desynchronized when receiving malicious responses, requiring manual intervention to recover
2. **Resource Waste:** Duplicate processing of the same version range wastes compute and bandwidth
3. **Network Degradation:** Multiple nodes affected simultaneously could cause network-wide sync issues
4. **Validator Impact:** Fullnodes unable to sync properly cannot serve queries or participate in the network effectively

The vulnerability does not meet Critical severity because:
- No direct fund loss or theft
- No consensus safety violation (validators use different sync mechanisms)
- Recoverable through node restart or stream reset
- Does not cause permanent state corruption

## Likelihood Explanation
**Likelihood: Medium-High**

This vulnerability is highly likely to be exploited:

1. **Low Attack Complexity:** Attacker only needs to run a malicious storage service peer and craft a single malformed response
2. **No Authentication Required:** Storage service peers are untrusted by design; any peer can serve data
3. **No Privilege Required:** Does not require validator access, just network connectivity
4. **Deterministic Trigger:** The vulnerability is triggered reliably with crafted payloads
5. **Wide Attack Surface:** Affects all nodes using subscription-based state sync (`SubscribeTransactionDataWithProof` requests)

Factors reducing likelihood:
- Requires victim node to connect to malicious peer
- Network may have peer reputation/selection mechanisms
- Honest peers are more common than malicious ones

## Recommendation
Add validation to enforce mutual exclusivity at multiple layers:

1. **Add serde validation:**
```rust
#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
pub struct TransactionDataWithProofResponse {
    pub transaction_data_response_type: TransactionDataResponseType,
    pub transaction_list_with_proof: Option<TransactionListWithProofV2>,
    pub transaction_output_list_with_proof: Option<TransactionOutputListWithProofV2>,
}

impl TransactionDataWithProofResponse {
    pub fn validate(&self) -> Result<(), Error> {
        let txn_present = self.transaction_list_with_proof.is_some();
        let output_present = self.transaction_output_list_with_proof.is_some();
        
        match self.transaction_data_response_type {
            TransactionDataResponseType::TransactionData => {
                if !txn_present || output_present {
                    return Err(Error::UnexpectedResponseError(
                        "TransactionData type must have only transaction_list_with_proof".into()
                    ));
                }
            }
            TransactionDataResponseType::TransactionOutputData => {
                if txn_present || !output_present {
                    return Err(Error::UnexpectedResponseError(
                        "TransactionOutputData type must have only transaction_output_list_with_proof".into()
                    ));
                }
            }
        }
        Ok(())
    }
}
```

2. **Enforce in TryFrom:** [7](#0-6) 

Replace direct return with validation:
```rust
DataResponse::TransactionDataWithProof(response) => {
    response.validate()?;
    Ok((
        response.transaction_list_with_proof,
        response.transaction_output_list_with_proof,
    ))
}
```

3. **Add validation in ResponsePayload conversion:** [8](#0-7) 

Replace with:
```rust
impl TryFrom<TransactionOrOutputListWithProofV2> for ResponsePayload {
    type Error = Error;
    
    fn try_from(inner: TransactionOrOutputListWithProofV2) -> error::Result<Self, Error> {
        let (transaction_list, output_list) = inner;
        match (transaction_list, output_list) {
            (Some(txns), None) => Ok(Self::TransactionsWithProof(txns)),
            (None, Some(outputs)) => Ok(Self::TransactionOutputsWithProof(outputs)),
            (Some(_), Some(_)) => Err(Error::InvalidResponse(
                "Both transaction list and output list present - violates mutual exclusivity!".into()
            )),
            (None, None) => Err(Error::InvalidResponse(
                "No transaction or output list was returned!".into()
            )),
        }
    }
}
```

## Proof of Concept
```rust
// Test demonstrating the vulnerability
#[test]
fn test_mutual_exclusivity_violation() {
    use aptos_storage_service_types::responses::{
        TransactionDataWithProofResponse, TransactionDataResponseType,
    };
    use aptos_types::transaction::{TransactionListWithProofV2, TransactionOutputListWithProofV2};
    
    // Create malicious response with both fields populated
    let malicious_response = TransactionDataWithProofResponse {
        transaction_data_response_type: TransactionDataResponseType::TransactionOutputData,
        transaction_list_with_proof: Some(create_transaction_list_with_100_items()), // 100 transactions
        transaction_output_list_with_proof: Some(create_output_list_with_50_items()), // 50 outputs
    };
    
    // Server-side: counts based on type field
    let server_count = match malicious_response.transaction_data_response_type {
        TransactionDataResponseType::TransactionOutputData => {
            malicious_response.transaction_output_list_with_proof
                .as_ref()
                .unwrap()
                .get_output_list_with_proof()
                .get_num_outputs() // Returns 50
        }
        _ => panic!("Wrong type"),
    };
    assert_eq!(server_count, 50);
    
    // Client-side: TryFrom conversion
    let storage_response = StorageServiceResponse::RawResponse(
        DataResponse::TransactionDataWithProof(malicious_response)
    );
    let result: TransactionOrOutputListWithProofV2 = storage_response.try_into().unwrap();
    
    // Client picks transaction_list due to if-else if logic
    let (txn_list, output_list) = result;
    assert!(txn_list.is_some());
    assert!(output_list.is_some()); // Both are Some! Violation!
    
    let client_count = txn_list.unwrap()
        .get_transaction_list_with_proof()
        .get_num_transactions(); // Returns 100
    
    assert_eq!(client_count, 100);
    assert_ne!(server_count, client_count); // Desynchronization!
}
```

## Notes
This vulnerability specifically affects the v2 transaction data API (`TransactionDataWithProofResponse` and `NewTransactionDataWithProofResponse`). The older v1 APIs use separate response types and are not affected. The issue is exploitable against any node using subscription-based state sync, which is common for fullnodes and fast-sync scenarios.

### Citations

**File:** state-sync/storage-service/types/src/responses.rs (L163-168)
```rust
#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
pub struct TransactionDataWithProofResponse {
    pub transaction_data_response_type: TransactionDataResponseType,
    pub transaction_list_with_proof: Option<TransactionListWithProofV2>,
    pub transaction_output_list_with_proof: Option<TransactionOutputListWithProofV2>,
}
```

**File:** state-sync/storage-service/types/src/responses.rs (L577-600)
```rust
impl TryFrom<StorageServiceResponse> for TransactionOrOutputListWithProofV2 {
    type Error = crate::responses::Error;

    fn try_from(response: StorageServiceResponse) -> crate::Result<Self, Self::Error> {
        let data_response = response.get_data_response()?;
        match data_response {
            DataResponse::TransactionsOrOutputsWithProof((
                transaction_list_with_proof,
                output_list_with_proof,
            )) => Ok((
                transaction_list_with_proof.map(TransactionListWithProofV2::new_from_v1),
                output_list_with_proof.map(TransactionOutputListWithProofV2::new_from_v1),
            )),
            DataResponse::TransactionDataWithProof(response) => Ok((
                response.transaction_list_with_proof,
                response.transaction_output_list_with_proof,
            )),
            _ => Err(Error::UnexpectedResponseError(format!(
                "expected transactions_or_outputs_with_proof, found {}",
                data_response.get_label()
            ))),
        }
    }
}
```

**File:** state-sync/storage-service/server/src/subscription.rs (L500-530)
```rust
            DataResponse::NewTransactionDataWithProof(response) => {
                let num_data_items = match response.transaction_data_response_type {
                    TransactionDataResponseType::TransactionData => {
                        if let Some(transaction_list_with_proof_v2) =
                            &response.transaction_list_with_proof
                        {
                            transaction_list_with_proof_v2
                                .get_transaction_list_with_proof()
                                .get_num_transactions()
                        } else {
                            return Err(Error::UnexpectedErrorEncountered(format!(
                                "Transaction data response is missing transaction list: {:?}",
                                data_response
                            )));
                        }
                    },
                    TransactionDataResponseType::TransactionOutputData => {
                        if let Some(output_list_with_proof_v2) =
                            &response.transaction_output_list_with_proof
                        {
                            output_list_with_proof_v2
                                .get_output_list_with_proof()
                                .get_num_outputs()
                        } else {
                            return Err(Error::UnexpectedErrorEncountered(format!(
                                "Transaction output data response is missing output list: {:?}",
                                data_response
                            )));
                        }
                    },
                };
```

**File:** state-sync/storage-service/server/src/subscription.rs (L543-544)
```rust
        // Update the highest known version
        self.highest_known_version += num_data_items as u64;
```

**File:** state-sync/storage-service/server/src/subscription.rs (L665-695)
```rust
                        subscription_stream_requests.highest_known_version,
                    )
                });

        // Handle the subscription
        if let Some((Some(subscription_request), known_version)) =
            subscription_request_and_known_version
        {
            // Clone all required components for the task
            let cached_storage_server_summary = cached_storage_server_summary.clone();
            let optimistic_fetches = optimistic_fetches.clone();
            let lru_response_cache = lru_response_cache.clone();
            let request_moderator = request_moderator.clone();
            let storage = storage.clone();
            let subscriptions = subscriptions.clone();
            let time_service = time_service.clone();

            // Spawn a blocking task to handle the subscription
            let active_task = runtime.spawn_blocking(move || {
                // Get the subscription start time and request
                let subscription_start_time = subscription_request.request_start_time;
                let subscription_data_request = subscription_request.request.clone();

                // Handle the subscription request and time the operation
                let handle_request = || {
                    // Get the storage service request for the missing data
                    let missing_data_request = subscription_request
                        .get_storage_request_for_missing_data(
                            config,
                            known_version,
                            &target_ledger_info,
```

**File:** state-sync/aptos-data-client/src/interface.rs (L349-364)
```rust
        let ((transaction_list, output_list), ledger_info) = inner;
        if let Some(transaction_list) = transaction_list {
            Ok(Self::NewTransactionsWithProof((
                transaction_list,
                ledger_info,
            )))
        } else if let Some(output_list) = output_list {
            Ok(Self::NewTransactionOutputsWithProof((
                output_list,
                ledger_info,
            )))
        } else {
            Err(Error::InvalidResponse(
                "Invalid response! No transaction or output list was returned!".into(),
            ))
        }
```

**File:** state-sync/aptos-data-client/src/interface.rs (L386-400)
```rust
impl TryFrom<TransactionOrOutputListWithProofV2> for ResponsePayload {
    type Error = Error;

    fn try_from(inner: TransactionOrOutputListWithProofV2) -> error::Result<Self, Error> {
        let (transaction_list, output_list) = inner;
        if let Some(transaction_list) = transaction_list {
            Ok(Self::TransactionsWithProof(transaction_list))
        } else if let Some(output_list) = output_list {
            Ok(Self::TransactionOutputsWithProof(output_list))
        } else {
            Err(Error::InvalidResponse(
                "Invalid response! No transaction or output list was returned!".into(),
            ))
        }
    }
```
