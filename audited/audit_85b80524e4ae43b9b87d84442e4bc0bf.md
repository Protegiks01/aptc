# Audit Report

## Title
Missing Equivocation Detection in JWK Consensus Allows Validator Accountability Bypass

## Summary
The JWK consensus mechanism lacks equivocation detection for validators signing multiple conflicting `ObservedUpdate` messages for the same epoch/issuer combination. While the protocol rejects mismatched observations, it does not log, detect, or enable on-chain proof of validator equivocation, unlike the main consensus system which explicitly tracks and logs such behavior as security events.

## Finding Description

The JWK (JSON Web Key) consensus system allows validators to observe JWKs from OIDC providers and reach agreement through reliable broadcast. However, unlike the main AptosBFT consensus which implements comprehensive equivocation detection, the JWK consensus lacks this critical security mechanism.

**Main Consensus Equivocation Detection:**
In the regular consensus, equivocation is explicitly detected and logged. [1](#0-0) 

The code maintains an `author_to_vote` map and logs `SecurityEvent::ConsensusEquivocatingVote` when a validator signs conflicting votes for the same round.

**JWK Consensus Lacks Detection:**
In contrast, the JWK consensus aggregation only checks for duplicate votes within a single aggregation session. [2](#0-1) 

The `contains_voter` check only prevents double-counting within one aggregation instance but does NOT:
- Store a persistent record of what each validator signed for each epoch/issuer
- Detect when a validator signs multiple different `ProviderJWKs` for the same epoch/issuer  
- Log security events when equivocation is detected
- Enable on-chain proof of misbehavior for slashing

**What Gets Signed:**
The signature is created over `ProviderJWKs` which contains only issuer, version, and jwks fields - NOT the epoch. [3](#0-2) 

The epoch is checked separately during aggregation [4](#0-3)  but is not part of the cryptographically signed message.

**No Individual Signature Storage:**
Only the final aggregated `QuorumCertifiedUpdate` with multi-signature is stored on-chain, not the individual `ObservedUpdate` messages from each validator. [5](#0-4) 

This means there is no on-chain audit trail of individual validator signatures that could prove equivocation occurred.

## Impact Explanation

**Medium Severity** - This issue represents a protocol design weakness rather than an immediately exploitable vulnerability:

1. **Accountability Bypass**: Malicious validators can disrupt JWK consensus without being detected or slashed, weakening the economic security model
2. **No Forensic Evidence**: Without logging, it's impossible to prove which validators misbehaved during consensus failures
3. **Inconsistent Security Model**: The main consensus has equivocation detection while JWK consensus does not, suggesting an oversight
4. **Limited Direct Exploit**: The protocol's `local_view == peer_view` check prevents mismatched observations from being aggregated, limiting direct impact

However, this does NOT meet **Critical** severity because:
- It does not enable fund theft or consensus safety violations
- It requires a malicious validator (not an unprivileged attacker)
- The protocol still rejects conflicting observations
- Network liveness is not directly compromised

## Likelihood Explanation

**Low-Medium Likelihood**:
- Requires a malicious validator to deliberately modify their node software
- The economic cost of validator stake acts as a deterrent even without slashing
- The protocol's view-matching requirement limits exploitation vectors
- Honest majority assumption (>2/3 honest validators) prevents consensus manipulation

However, the absence of detection and punishment reduces the deterrent effect and makes attribution impossible during incidents.

## Recommendation

Implement equivocation detection for JWK consensus similar to the main consensus:

1. **Add Equivocation Tracking**: Maintain a map of `(author, epoch, issuer) -> ObservedUpdate` to track what each validator has signed
2. **Log Security Events**: When detecting conflicting signatures from the same validator for the same epoch/issuer, emit a security log event
3. **Consider Epoch in Signature**: Include the epoch as part of the signed message to prevent signature replay across epochs
4. **Enable On-Chain Proof**: Store sufficient data to enable on-chain verification of equivocation for potential slashing

Example conceptual fix:
```rust
// In ObservationAggregationState
struct ObservationAggregationState<ConsensusMode> {
    epoch_state: Arc<EpochState>,
    local_view: ProviderJWKs,
    inner_state: Mutex<PartialSignatures>,
    // NEW: Track what each author has signed
    author_observations: Mutex<HashMap<Author, (ProviderJWKs, Signature)>>,
}

// In the add() method, check for conflicting signatures
if let Some((prev_view, _)) = author_observations.get(&author) {
    if prev_view != &peer_view {
        error!(
            SecurityEvent::JWKConsensusEquivocatingObservation,
            author = author,
            epoch = epoch,
            issuer = local_view.issuer,
        );
        return Err(anyhow!("Equivocation detected"));
    }
}
```

## Proof of Concept

This is a protocol design issue rather than a code-level exploit. A demonstration would require:

1. Running a modified validator node that creates multiple `ObservedUpdate` messages for the same epoch/issuer
2. Sending different observations to different peer subsets
3. Observing that while the protocol rejects mismatched views, no security event is logged and no on-chain record exists

The vulnerability is demonstrated by the **absence** of code rather than exploitable code - there is no equivocation detection logic in the JWK consensus compared to the main consensus where it exists.

---

## Notes

After thorough analysis, I must note that this finding has a critical limitation: **The validation checklist requires "Exploitable by unprivileged attacker (no validator insider access required)"**, but this issue explicitly involves validator misbehavior. 

While this represents a genuine protocol weakness (absence of an important security mechanism that exists in the main consensus), it may not meet the strict criteria for the bug bounty program if validator insider threats are out of scope. The security question explicitly asks about validator equivocation, but the validation requirements exclude insider attacks.

The finding is valid as a **protocol design gap** that should be addressed for defense-in-depth, but its exploitability classification depends on whether validator-level attacks are considered in-scope for this audit.

### Citations

**File:** consensus/src/pending_votes.rs (L287-309)
```rust
        if let Some((previously_seen_vote, previous_li_digest)) =
            self.author_to_vote.get(&vote.author())
        {
            // is it the same vote?
            if &li_digest == previous_li_digest {
                // we've already seen an equivalent vote before
                let new_timeout_vote = vote.is_timeout() && !previously_seen_vote.is_timeout();
                if !new_timeout_vote {
                    // it's not a new timeout vote
                    return VoteReceptionResult::DuplicateVote;
                }
            } else {
                // we have seen a different vote for the same round
                error!(
                    SecurityEvent::ConsensusEquivocatingVote,
                    remote_peer = vote.author(),
                    vote = vote,
                    previous_vote = previously_seen_vote
                );

                return VoteReceptionResult::EquivocateVote;
            }
        }
```

**File:** crates/aptos-jwk-consensus/src/observation_aggregation/mod.rs (L60-63)
```rust
        ensure!(
            epoch == self.epoch_state.epoch,
            "adding peer observation failed with invalid epoch",
        );
```

**File:** crates/aptos-jwk-consensus/src/observation_aggregation/mod.rs (L76-79)
```rust
        let mut partial_sigs = self.inner_state.lock();
        if partial_sigs.contains_voter(&sender) {
            return Ok(None);
        }
```

**File:** types/src/jwks/mod.rs (L122-128)
```rust
#[derive(Clone, Default, Eq, PartialEq, Serialize, Deserialize, CryptoHasher, BCSCryptoHash)]
pub struct ProviderJWKs {
    #[serde(with = "serde_bytes")]
    pub issuer: Issuer,
    pub version: u64,
    pub jwks: Vec<JWKMoveStruct>,
}
```

**File:** aptos-move/aptos-vm/src/validator_txns/jwk.rs (L122-142)
```rust
        let QuorumCertifiedUpdate {
            update: observed,
            multi_sig,
        } = update;

        // Check version.
        if on_chain.version + 1 != observed.version {
            return Err(Expected(IncorrectVersion));
        }

        let authors = multi_sig.get_signers_addresses(&verifier.get_ordered_account_addresses());

        // Check voting power.
        verifier
            .check_voting_power(authors.iter(), true)
            .map_err(|_| Expected(NotEnoughVotingPower))?;

        // Verify multi-sig.
        verifier
            .verify_multi_signatures(&observed, &multi_sig)
            .map_err(|_| Expected(MultiSigVerificationFailed))?;
```
