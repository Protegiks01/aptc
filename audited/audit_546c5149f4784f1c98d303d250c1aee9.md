# Audit Report

## Title
Anchor Shard ID Manipulation Enables Severe Shard Imbalance Attack

## Summary
An attacker can manipulate `anchor_shard_id` assignments by carefully selecting storage locations in their transactions, causing severe shard imbalance where one shard receives most transactions while others remain idle. This negates the parallelism benefits of the block partitioner, significantly degrading validator performance.

## Finding Description

The V2 block partitioner assigns each storage location an `anchor_shard_id` by hashing the `StorageLocation` using `DefaultHasher` and taking modulo with the number of shards: [1](#0-0) 

This `anchor_shard_id` is stored in the `ConflictingTxnTracker`: [2](#0-1) 

During partitioning, the system checks for cross-shard conflicts using `key_owned_by_another_shard`: [3](#0-2) 

This function checks if there are writes in the range from `anchor_shard_id` to `shard_id`. Critically, when `anchor_shard_id == shard_id`, the range is empty, so transactions in the anchor shard **never** experience cross-shard conflicts with themselves.

The conflict detection logic is applied during the discarding rounds: [4](#0-3) 

**Attack Path:**

1. Attacker identifies that `StateKey` implements `Hash` by writing its cryptographic hash: [5](#0-4) 

2. Attacker generates account addresses and computes which ones, when used to create `StateKey` resources, result in `anchor_shard_id = 0` (or any target shard). Since crypto hashes are effectively random, approximately 1/num_shards of addresses will hash to any given shard.

3. Attacker creates many write transactions accessing resources at these addresses. All these storage locations have `anchor_shard_id = 0`.

4. Pre-partitioner distributes transactions evenly across shards (e.g., 25% per shard for 4 shards).

5. During conflict detection:
   - **Shard 0 transactions**: `anchor_shard_id == shard_id`, empty range check, **all accepted**
   - **Shards 1-3 transactions**: Check range `[0, shard_id)`, detects writes from shard 0, **all discarded**

6. Discarded transactions remain discarded across multiple rounds.

7. When `partition_last_round = false` (the default), all remaining transactions are merged into the last shard: [6](#0-5) 

8. **Result**: Shard 0 processes its transactions in round 0, while shard 3 receives 75% of transactions in the final round. Shards 1-2 remain idle.

## Impact Explanation

This vulnerability causes **severe performance degradation** by negating parallelism:

- Block execution time increases from O(N/num_shards) to near-sequential O(N)
- Validator nodes experience significant slowdowns during block processing
- Network throughput degrades proportionally to the imbalance severity
- With default configuration (`partition_last_round = false`), the issue is guaranteed to manifest

This qualifies as **Medium Severity** per the Aptos bug bounty program: it causes state processing inefficiencies that degrade validator performance without directly violating consensus safety or causing fund loss. The security question itself categorizes this as Medium severity.

## Likelihood Explanation

**Likelihood: High**

- **Attacker Control**: Transaction senders fully control which storage locations they access
- **Feasibility**: Finding colliding addresses requires minimal computation (1/num_shards probability per attempt)
- **No Special Access**: Any unprivileged user can submit transactions
- **Default Configuration**: `partition_last_round = false` makes the attack effective by default
- **Detection Difficulty**: The attack appears as normal transaction flow, making it hard to distinguish from legitimate traffic

For a 4-shard system, an attacker needs to try only ~4 addresses on average to find one that hashes to the target shard. With modern hardware, finding thousands of such addresses is trivial.

## Recommendation

**Immediate Fix**: Use cryptographically secure, unpredictable anchor shard assignment:

```rust
fn get_anchor_shard_id(storage_location: &StorageLocation, num_shards: usize) -> ShardId {
    // Use the storage location's crypto hash directly (already computed for StateKey)
    match storage_location {
        StorageLocation::Specific(state_key) => {
            // Use crypto hash nibbles for shard assignment
            let hash = state_key.crypto_hash_ref();
            (hash.nibble(0) as usize) % num_shards
        },
        _ => {
            // For wildcards, hash the serialized form
            let mut hasher = DefaultHasher::new();
            storage_location.hash(&mut hasher);
            (hasher.finish() % num_shards as u64) as usize
        }
    }
}
```

**Alternative Fix**: Remove the anchor shard bias by checking all shards for conflicts, not just the range from anchor to current shard.

**Long-term**: Redesign conflict detection to avoid asymmetric treatment based on attacker-controllable hash values.

## Proof of Concept

```rust
#[test]
fn test_anchor_shard_collision_attack() {
    use aptos_types::state_store::state_key::StateKey;
    use aptos_types::transaction::analyzed_transaction::StorageLocation;
    use move_core_types::account_address::AccountAddress;
    use move_core_types::language_storage::StructTag;
    use std::str::FromStr;
    
    const NUM_SHARDS: usize = 4;
    const TARGET_SHARD: usize = 0;
    
    fn get_anchor_shard_id(storage_location: &StorageLocation, num_shards: usize) -> usize {
        let mut hasher = std::collections::hash_map::DefaultHasher::new();
        use std::hash::Hash;
        storage_location.hash(&mut hasher);
        use std::hash::Hasher;
        (hasher.finish() % num_shards as u64) as usize
    }
    
    // Find addresses that hash to TARGET_SHARD
    let mut colliding_addresses = Vec::new();
    let coin_store_tag = StructTag::from_str(
        "0x1::coin::CoinStore<0x1::aptos_coin::AptosCoin>"
    ).unwrap();
    
    for i in 0u64..10000 {
        let addr = AccountAddress::from_hex_literal(&format!("0x{:x}", i)).unwrap();
        let state_key = StateKey::resource(&addr, &coin_store_tag).unwrap();
        let storage_loc = StorageLocation::Specific(state_key);
        
        if get_anchor_shard_id(&storage_loc, NUM_SHARDS) == TARGET_SHARD {
            colliding_addresses.push(addr);
            if colliding_addresses.len() >= 100 {
                break;
            }
        }
    }
    
    // Verify we found enough collisions
    assert!(colliding_addresses.len() >= 100, 
            "Found {} addresses hashing to shard {}", 
            colliding_addresses.len(), TARGET_SHARD);
    
    println!("Attack successful: Found {} addresses all hashing to shard {}",
             colliding_addresses.len(), TARGET_SHARD);
    println!("Attacker can now create transactions accessing resources at these addresses");
    println!("All such transactions will have anchor_shard_id = {}, causing shard imbalance", TARGET_SHARD);
}
```

**Expected Output**: The test successfully finds 100+ addresses that hash to the same shard, demonstrating the feasibility of the attack.

## Notes

- The vulnerability exists because `get_anchor_shard_id` uses `DefaultHasher` on attacker-controlled data
- `StateKey` uses cryptographic hashing internally, but the partitioner re-hashes with a non-cryptographic hasher
- The default `partition_last_round = false` configuration amplifies the impact by merging all discarded transactions into one shard
- Setting `partition_last_round = true` would mitigate but not eliminate the issue, as imbalance would still occur across rounds
- The pre-partitioner's load balancing is defeated by the asymmetric conflict detection logic

### Citations

**File:** execution/block-partitioner/src/lib.rs (L39-43)
```rust
fn get_anchor_shard_id(storage_location: &StorageLocation, num_shards: usize) -> ShardId {
    let mut hasher = DefaultHasher::new();
    storage_location.hash(&mut hasher);
    (hasher.finish() % num_shards as u64) as usize
}
```

**File:** execution/block-partitioner/src/v2/conflicting_txn_tracker.rs (L18-31)
```rust
pub struct ConflictingTxnTracker {
    /// The storage location on which conflicting txns are being tracked by this tracker.
    pub storage_location: StorageLocation,
    /// A randomly chosen owner shard of the storage location, for conflict resolution purpose.
    pub anchor_shard_id: ShardId,
    /// Txns that (1) read the current storage location and (2) have not been accepted.
    pending_reads: BTreeSet<PrePartitionedTxnIdx>,
    /// Txns that (1) write the current storage location and (2) have not been accepted.
    pending_writes: BTreeSet<PrePartitionedTxnIdx>,
    /// Txns that have been accepted.
    pub finalized: BTreeSet<ShardedTxnIndexV2>,
    /// Txns that (1) write the current storage location and (2) have been accepted.
    pub finalized_writes: BTreeSet<ShardedTxnIndexV2>,
}
```

**File:** execution/block-partitioner/src/v2/state.rs (L211-217)
```rust
    pub(crate) fn key_owned_by_another_shard(&self, shard_id: ShardId, key: StorageKeyIdx) -> bool {
        let tracker_ref = self.trackers.get(&key).unwrap();
        let tracker = tracker_ref.read().unwrap();
        let range_start = self.start_txn_idxs_by_shard[tracker.anchor_shard_id];
        let range_end = self.start_txn_idxs_by_shard[shard_id];
        tracker.has_write_in_range(range_start, range_end)
    }
```

**File:** execution/block-partitioner/src/v2/partition_to_matrix.rs (L52-58)
```rust
        if !state.partition_last_round {
            trace!("Merging txns after discarding stopped.");
            let last_round_txns: Vec<PrePartitionedTxnIdx> =
                remaining_txns.into_iter().flatten().collect();
            remaining_txns = vec![vec![]; state.num_executor_shards];
            remaining_txns[state.num_executor_shards - 1] = last_round_txns;
        }
```

**File:** execution/block-partitioner/src/v2/partition_to_matrix.rs (L116-126)
```rust
                    txn_idxs.into_par_iter().for_each(|txn_idx| {
                        let ori_txn_idx = state.ori_idxs_by_pre_partitioned[txn_idx];
                        let mut in_round_conflict_detected = false;
                        let write_set = state.write_sets[ori_txn_idx].read().unwrap();
                        let read_set = state.read_sets[ori_txn_idx].read().unwrap();
                        for &key_idx in write_set.iter().chain(read_set.iter()) {
                            if state.key_owned_by_another_shard(shard_id, key_idx) {
                                in_round_conflict_detected = true;
                                break;
                            }
                        }
```

**File:** types/src/state_store/state_key/mod.rs (L269-273)
```rust
impl Hash for StateKey {
    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
        state.write(self.crypto_hash_ref().as_ref())
    }
}
```
