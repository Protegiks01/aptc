Audit Report

## Title
Consensus Liveness Break via Asymmetric `safe_to_vote` and `safe_to_timeout` Round Advancement Rules

## Summary
Aptos core’s 2-chain consensus implementation contains a liveness-breaking vulnerability due to inconsistent round advancement rules between `safe_to_vote` and `safe_to_timeout`. Under non-Byzantine yet adversarial network conditions, a validator may find itself able to cast a vote for a round, but be permanently unable to timeout that round if quorum is not reached. This causes a validator to deadlock and stop participating in consensus, potentially fragmenting or halting the network if enough validators are affected.

## Finding Description
The core vulnerability lies in the mismatch between the preconditions for voting and timing out:

- `safe_to_vote` allows voting for a block at round R if its QC is for round R-1 **without checking** whether R-1 >= `one_chain_round` [1](#0-0) .
- `safe_to_timeout`, on the other hand, **always requires** that the hqc_round (from the QC carried in the timeout) is >= `one_chain_round` [2](#0-1) .

This leads to the following exploitation path:
1. Validator V votes for round R using a QC for R-1 (meeting `safe_to_vote` condition).
2. Before a timeout is needed, network messages arrive that increase V’s `one_chain_round` to R (or higher), via the `observe_qc` logic when V processes another QC (for a different branch or fork) [3](#0-2) .
3. If enough votes for round R are missing (Byzantine validators have withheld), V will attempt to timeout round R.
4. However, in order to timeout, `safe_to_timeout` requires that the hqc_round (for R-1) be >= `one_chain_round` (now R or higher), which fails, preventing V from timing out the round.
5. V is now stuck—it cannot vote again for R (already voted for R), and cannot timeout R. It is deadlocked indefinitely.

This is a realistic case, as network asynchrony and adversarial leaders can cause QC propagation to races that “overtake” the `one_chain_round` pointer, especially in the presence of equivocation or forks (without requiring validators to be strictly Byzantine), only by exploiting normal message delivery order and routine rebroadcasts.

## Impact Explanation
This is a Critical Severity issue under the Aptos bug bounty program:

- **Total loss of liveness:** If a quorum of honest validators are deadlocked this way, consensus halts permanently, requiring human/manual intervention or hardfork to recover.
- **Non-recoverable network partition:** This can create a situation where some validators are unable to advance in rounds, diverging from peers that progress, potentially leading to chain splits or network stalling.
- **Not mitigable via network restart or re-sync:** Because the lock is on the SafetyData’s internal state machine (`one_chain_round` advancement), only a reset of persistent SafetyData (unsafe) or code fix can restore participation.

## Likelihood Explanation
- **Easy to trigger** by network-level adversary, without any validator being Byzantine, just by controlling delivery order of QCs and proposals.
- Can be exploited within a single epoch, without further colluding validators, so the likelihood is high in adversarial network deployments or the open Internet.

## Recommendation
Align the logic between `safe_to_vote` and `safe_to_timeout` to ensure no state transition can render a validator unable to make forward progress. There are two possible fixes:

1. **Option A:** Add the `qc_round >= one_chain_round` check to the initial case in `safe_to_vote`, matching the requirement in `safe_to_timeout`.
2. **Option B:** Remove the `qc_round >= one_chain_round` requirement in `safe_to_timeout` for the `round == qc_round + 1` path (with a rigorous proof this cannot allow safety violation).

A minimal code change (Option A):
```rust
// In safe_to_vote(), require qc_round >= one_chain_round even if no TC present
let one_chain_round = safety_data.one_chain_round;
if (round == next_round(qc_round)? && qc_round >= one_chain_round)
    || (round == next_round(tc_round)? && qc_round >= hqc_round)
```

## Proof of Concept
1. Launch a local testnet with multiple validators.
2. Make validator V vote for round R w/ QC for R-1.
3. Before V times out, inject a QC for round R or higher via gossip, updating V’s `one_chain_round`.
4. Prevent QC aggregation for round R (e.g., by dropping honest votes).
5. V will be unable to timeout round R or progress.
6. Observe V’s participation ceasing, and see the network deadlock if a quorum is similarly affected.

---

**Citations:** [1](#0-0) [2](#0-1) [3](#0-2)

### Citations

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L124-145)
```rust
    fn safe_to_timeout(
        &self,
        timeout: &TwoChainTimeout,
        maybe_tc: Option<&TwoChainTimeoutCertificate>,
        safety_data: &SafetyData,
    ) -> Result<(), Error> {
        let round = timeout.round();
        let qc_round = timeout.hqc_round();
        let tc_round = maybe_tc.map_or(0, |tc| tc.round());
        if (round == next_round(qc_round)? || round == next_round(tc_round)?)
            && qc_round >= safety_data.one_chain_round
        {
            Ok(())
        } else {
            Err(Error::NotSafeToTimeout(
                round,
                qc_round,
                tc_round,
                safety_data.one_chain_round,
            ))
        }
    }
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L150-166)
```rust
    fn safe_to_vote(
        &self,
        block: &Block,
        maybe_tc: Option<&TwoChainTimeoutCertificate>,
    ) -> Result<(), Error> {
        let round = block.round();
        let qc_round = block.quorum_cert().certified_block().round();
        let tc_round = maybe_tc.map_or(0, |tc| tc.round());
        let hqc_round = maybe_tc.map_or(0, |tc| tc.highest_hqc_round());
        if round == next_round(qc_round)?
            || (round == next_round(tc_round)? && qc_round >= hqc_round)
        {
            Ok(())
        } else {
            Err(Error::NotSafeToVote(round, qc_round, tc_round, hqc_round))
        }
    }
```

**File:** consensus/safety-rules/src/safety_rules.rs (L135-156)
```rust
    pub(crate) fn observe_qc(&self, qc: &QuorumCert, safety_data: &mut SafetyData) -> bool {
        let mut updated = false;
        let one_chain = qc.certified_block().round();
        let two_chain = qc.parent_block().round();
        if one_chain > safety_data.one_chain_round {
            safety_data.one_chain_round = one_chain;
            trace!(
                SafetyLogSchema::new(LogEntry::OneChainRound, LogEvent::Update)
                    .preferred_round(safety_data.one_chain_round)
            );
            updated = true;
        }
        if two_chain > safety_data.preferred_round {
            safety_data.preferred_round = two_chain;
            trace!(
                SafetyLogSchema::new(LogEntry::PreferredRound, LogEvent::Update)
                    .preferred_round(safety_data.preferred_round)
            );
            updated = true;
        }
        updated
    }
```
