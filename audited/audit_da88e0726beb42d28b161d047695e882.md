# Audit Report

## Title
Missing Length Validation for write_sets Vector in Backup Restore Leading to Potential Panic

## Summary
The `LoadedChunk::load()` function fails to validate that the `write_sets` vector has the same length as the other four vectors (txns, persisted_aux_info, txn_infos, event_vecs), creating a defense-in-depth gap. While the deserialization logic should theoretically maintain equal lengths, the lack of explicit validation means mismatched vectors would not be detected until causing panics in downstream `drain()` operations.

## Finding Description

In the backup restore functionality, the `LoadedChunk::load()` function deserializes transaction data into five parallel vectors. However, the verification step only validates four of the five vectors: [1](#0-0) 

The `write_sets` vector is constructed during deserialization but is **never passed to the verification logic**. The `TransactionListWithProofV2::verify()` only checks:
- `txns.len() == txn_infos.len()`
- `event_vecs.len() == txns.len()` 
- `persisted_aux_info.len() == txn_infos.len()` [2](#0-1) [3](#0-2) [4](#0-3) 

Subsequently, these vectors are unpacked and manipulated with `drain()` operations that **assume equal lengths**: [5](#0-4) [6](#0-5) [7](#0-6) 

If `write_sets` is shorter than the other vectors, these `drain()` calls will **panic** with an index out of bounds error.

The chunk executor also performs similar drain operations without length validation: [8](#0-7) 

## Impact Explanation

This issue qualifies as **Medium Severity** under Aptos bug bounty criteria for the following reasons:

1. **State Inconsistency**: If exploitable, mismatched vector lengths would cause transaction restore operations to panic before completing, leaving the database in an incomplete state requiring manual intervention.

2. **Validator Node Crashes**: During backup restore operations (disaster recovery scenario), affected validator nodes would crash, impacting network availability.

3. **Database Corruption Risk**: The `save_transactions_impl()` function iterates over each vector separately. Mismatched lengths could lead to transactions being saved without corresponding write_sets or vice versa: [9](#0-8) [10](#0-9) 

This breaks the **State Consistency** invariant (invariant #4) as transactions and their state changes would be desynchronized.

## Likelihood Explanation

**Likelihood: Low to Medium**

While the BCS deserialization process is atomic per-record, there are scenarios where this could occur:

1. **Malicious Backup Files**: An attacker with access to backup storage could craft backup files with intentionally malformed data that bypasses the manifest checks but produces mismatched vectors during deserialization.

2. **Backup Creation Bugs**: Future bugs in the backup creation code could produce malformed backups that pass manifest validation but have inconsistent record counts.

3. **Partial File Corruption**: Storage corruption affecting only certain portions of the backup file could lead to incomplete deserialization.

The main protection is that BCS deserialization is typed and should fail completely if data is malformed. However, **defense-in-depth** principles require explicit validation of critical invariants.

## Recommendation

Add explicit length validation for `write_sets` after the deserialization loop and before constructing the `LoadedChunk`:

```rust
// After line 137 in restore.rs, add:
ensure!(
    write_sets.len() == txns.len(),
    "Number of write_sets ({}) doesn't match number of transactions ({})",
    write_sets.len(),
    txns.len()
);

// Alternatively, add comprehensive validation:
ensure!(
    txns.len() == persisted_aux_info.len() 
    && txns.len() == txn_infos.len()
    && txns.len() == event_vecs.len()
    && txns.len() == write_sets.len(),
    "Vector length mismatch: txns={}, aux={}, infos={}, events={}, writesets={}",
    txns.len(), persisted_aux_info.len(), txn_infos.len(), 
    event_vecs.len(), write_sets.len()
);
```

This should be added at line 138 in the `LoadedChunk::load()` function, immediately after the while loop and before the existing manifest length check.

## Proof of Concept

**Test Scenario**: Demonstrate panic when vectors have mismatched lengths

```rust
#[tokio::test]
async fn test_mismatched_vector_lengths_panic() {
    // This test demonstrates the panic that occurs when write_sets 
    // has different length than other vectors
    
    let mut txns = vec![create_test_transaction(); 10];
    let mut persisted_aux_info = vec![PersistedAuxiliaryInfo::None; 10];
    let mut txn_infos = vec![create_test_txn_info(); 10];
    let mut event_vecs = vec![vec![]; 10];
    let mut write_sets = vec![WriteSet::default(); 5]; // ONLY 5 instead of 10
    
    // This should panic when trying to drain
    let num_to_keep = 8;
    txns.drain(num_to_keep..);
    persisted_aux_info.drain(num_to_keep..);
    txn_infos.drain(num_to_keep..);
    event_vecs.drain(num_to_keep..);
    write_sets.drain(num_to_keep..); // PANIC: range end index 8 out of range for slice of length 5
}
```

**Note**: This PoC demonstrates the panic behavior. To create an actual malicious backup file that triggers this in production would require deeper understanding of the BCS format and backup file structure, which may or may not be feasible depending on BCS type safety guarantees.

## Notes

While the current deserialization logic should maintain vector length consistency through atomic tuple deserialization, this vulnerability represents a critical gap in defense-in-depth. The verification logic explicitly validates the lengths of four vectors but completely omits `write_sets`, creating an unverified invariant that could be exploited if any bugs exist in the serialization/deserialization pipeline or if malicious backup files are crafted. The missing validation violates secure coding principles and creates unnecessary risk during critical disaster recovery operations.

### Citations

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L157-167)
```rust
        let txn_list_with_proof =
            TransactionListWithProofV2::new(TransactionListWithAuxiliaryInfos::new(
                TransactionListWithProof::new(
                    txns,
                    Some(event_vecs),
                    Some(manifest.first_version),
                    TransactionInfoListWithProof::new(range_proof, txn_infos),
                ),
                persisted_aux_info,
            ));
        txn_list_with_proof.verify(ledger_info.ledger_info(), Some(manifest.first_version))?;
```

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L474-482)
```rust
                    // remove the txns that exceeds the target_version to be restored
                    if target_version < last_version {
                        let num_to_keep = (target_version - first_version + 1) as usize;
                        txns.drain(num_to_keep..);
                        persisted_aux_info.drain(num_to_keep..);
                        txn_infos.drain(num_to_keep..);
                        event_vecs.drain(num_to_keep..);
                        write_sets.drain(num_to_keep..);
                        last_version = target_version;
```

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L486-494)
```rust
                    if global_first_version > first_version {
                        let num_to_remove = (global_first_version - first_version) as usize;

                        txns.drain(..num_to_remove);
                        persisted_aux_info.drain(..num_to_remove);
                        txn_infos.drain(..num_to_remove);
                        event_vecs.drain(..num_to_remove);
                        write_sets.drain(..num_to_remove);
                        first_version = global_first_version;
```

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L498-506)
```rust
                    if first_version < first_to_replay {
                        let num_to_save =
                            (min(first_to_replay, last_version + 1) - first_version) as usize;
                        let txns_to_save: Vec<_> = txns.drain(..num_to_save).collect();
                        let persisted_aux_info_to_save: Vec<_> =
                            persisted_aux_info.drain(..num_to_save).collect();
                        let txn_infos_to_save: Vec<_> = txn_infos.drain(..num_to_save).collect();
                        let event_vecs_to_save: Vec<_> = event_vecs.drain(..num_to_save).collect();
                        let write_sets_to_save = write_sets.drain(..num_to_save).collect();
```

**File:** types/src/transaction/mod.rs (L2309-2315)
```rust
        ensure!(
            self.proof.transaction_infos.len() == self.get_num_transactions(),
            "The number of TransactionInfo objects ({}) does not match the number of \
             transactions ({}).",
            self.proof.transaction_infos.len(),
            self.get_num_transactions(),
        );
```

**File:** types/src/transaction/mod.rs (L2340-2345)
```rust
            ensure!(
                event_lists.len() == self.get_num_transactions(),
                "The length of event_lists ({}) does not match the number of transactions ({}).",
                event_lists.len(),
                self.get_num_transactions(),
            );
```

**File:** types/src/transaction/mod.rs (L2817-2822)
```rust
    ensure!(
        auxiliary_infos.len() == transaction_infos.len(),
        "The number of auxiliary infos ({}) does not match the number of transaction infos ({})",
        auxiliary_infos.len(),
        transaction_infos.len(),
    );
```

**File:** execution/executor/src/chunk_executor/mod.rs (L666-673)
```rust
        let num_txns = (end_version - begin_version) as usize;
        let txn_infos: Vec<_> = transaction_infos.drain(..num_txns).collect();
        let (transactions, persisted_aux_info, transaction_outputs) = multizip((
            transactions.drain(..num_txns),
            persisted_aux_info.drain(..num_txns),
            txn_infos.iter(),
            write_sets.drain(..num_txns),
            event_vecs.drain(..num_txns),
```

**File:** storage/aptosdb/src/backup/restore_utils.rs (L206-267)
```rust
    for (idx, txn) in txns.iter().enumerate() {
        ledger_db.transaction_db().put_transaction(
            first_version + idx as Version,
            txn,
            /*skip_index=*/ false,
            &mut ledger_db_batch.transaction_db_batches,
        )?;
    }

    for (idx, aux_info) in persisted_aux_info.iter().enumerate() {
        PersistedAuxiliaryInfoDb::put_persisted_auxiliary_info(
            first_version + idx as Version,
            aux_info,
            &mut ledger_db_batch.persisted_auxiliary_info_db_batches,
        )?;
    }

    for (idx, txn_info) in txn_infos.iter().enumerate() {
        TransactionInfoDb::put_transaction_info(
            first_version + idx as Version,
            txn_info,
            &mut ledger_db_batch.transaction_info_db_batches,
        )?;
    }

    ledger_db
        .transaction_accumulator_db()
        .put_transaction_accumulator(
            first_version,
            txn_infos,
            &mut ledger_db_batch.transaction_accumulator_db_batches,
        )?;

    ledger_db.event_db().put_events_multiple_versions(
        first_version,
        events,
        &mut ledger_db_batch.event_db_batches,
    )?;

    if ledger_db.enable_storage_sharding() {
        for (idx, txn_events) in events.iter().enumerate() {
            for event in txn_events {
                if let Some(event_key) = event.event_key() {
                    if *event_key == new_block_event_key() {
                        LedgerMetadataDb::put_block_info(
                            first_version + idx as Version,
                            event,
                            &mut ledger_db_batch.ledger_metadata_db_batches,
                        )?;
                    }
                }
            }
        }
    }
    // insert changes in write set schema batch
    for (idx, ws) in write_sets.iter().enumerate() {
        WriteSetDb::put_write_set(
            first_version + idx as Version,
            ws,
            &mut ledger_db_batch.write_set_db_batches,
        )?;
    }
```

**File:** storage/aptosdb/src/backup/restore_utils.rs (L279-279)
```rust
    let last_version = first_version + txns.len() as u64 - 1;
```
