# Audit Report

## Title
Database Credential Disclosure via Unauthenticated Ready Server Health Endpoint in Local Testnet

## Summary
The local testnet ready server exposes an unauthenticated HTTP endpoint that returns health check information including PostgreSQL connection strings with embedded passwords. In multi-tenant environments, this allows any network client to extract database credentials and potentially gain unauthorized access to the PostgreSQL database.

## Finding Description

The ready server in the local testnet implementation exposes a root endpoint (`/`) that returns JSON containing all health checkers for running services. When users run the local testnet with external PostgreSQL using the `--host-postgres-password` flag, the password is embedded in the connection string and exposed through this endpoint.

**Vulnerable Code Flow:**

1. In `PostgresManager::get_health_checkers()`, a health checker is created with the full connection string: [1](#0-0) 

2. The `get_connection_string()` method constructs the connection string with embedded password: [2](#0-1) 

3. The password is formatted into the connection string when `use_host_postgres` is enabled: [3](#0-2) 

4. All health checkers (including those with connection strings) are passed to the `ReadyServerManager`: [4](#0-3) 

5. The `root()` handler exposes these health checkers via JSON serialization without any authentication: [5](#0-4) 

6. The `HealthChecker` enum derives `Serialize`, meaning all fields including connection strings are serialized: [6](#0-5) 

**Attack Scenario:**
An attacker in a shared network environment (cloud VMs, containerized workspaces, corporate networks) can:
1. Scan for port 8070 (or custom ready server port)
2. Send `GET http://target:8070/` 
3. Parse JSON response to extract PostgreSQL connection strings with embedded credentials
4. Connect to the victim's database using the stolen credentials
5. Read, modify, or delete sensitive data

## Impact Explanation

This vulnerability qualifies as **Medium Severity** under the Aptos bug bounty program criteria for the following reasons:

- **Information Disclosure**: Exposes database credentials (username, password, host, port, database name) to any network-accessible attacker
- **Lateral Movement Potential**: Stolen credentials enable unauthorized database access, potentially leading to data theft or manipulation
- **Multi-Tenant Risk**: Particularly dangerous in shared development environments where multiple users run local testnets on the same network
- **Scope Limitation**: Impact is limited to local testnet deployments (development/testing tool) rather than production blockchain infrastructure

The issue aligns with "Minor information leaks" category but with elevated risk due to credential exposure enabling further attacks.

## Likelihood Explanation

**Likelihood: Medium-High** in specific deployment scenarios:

**Factors Increasing Likelihood:**
- Default ready server port (8070) is predictable and scannable
- No authentication required - any network client can query
- Health check endpoints are commonly probed by attackers
- Developers often share networks in cloud/containerized environments

**Factors Decreasing Likelihood:**
- Requires explicit use of `--host-postgres-password` flag
- Local testnet is primarily a development tool
- Most deployments likely use Docker-managed Postgres without passwords
- Ready server typically binds to localhost (127.0.0.1) unless in container environment

The vulnerability is most likely to be exploited in:
- Cloud-based development environments (AWS EC2, GCP, Azure VMs)
- Shared Kubernetes/Docker environments
- Corporate networks with multiple developers
- CI/CD pipelines exposing ready server for monitoring

## Recommendation

Implement one or more of the following mitigations:

**Option 1: Sanitize Connection Strings (Recommended)**
Modify health checker serialization to redact sensitive information before exposure:

```rust
// In health_checker.rs
impl Serialize for HealthChecker {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            HealthChecker::Postgres(conn_str) => {
                let sanitized = sanitize_connection_string(conn_str);
                serializer.serialize_newtype_variant("HealthChecker", 3, "Postgres", &sanitized)
            }
            HealthChecker::Processor(conn_str, name) => {
                let sanitized = sanitize_connection_string(conn_str);
                serializer.serialize_tuple_variant("HealthChecker", 4, "Processor", 2)?
                    .serialize_field(&sanitized)?
                    .serialize_field(name)?
                    .end()
            }
            // ... other variants use default serialization
        }
    }
}

fn sanitize_connection_string(conn_str: &str) -> String {
    // Parse connection string and redact password
    if let Some(at_pos) = conn_str.find('@') {
        if let Some(colon_pos) = conn_str[..at_pos].rfind(':') {
            return format!("{}:***{}", &conn_str[..colon_pos], &conn_str[at_pos..]);
        }
    }
    conn_str.to_string()
}
```

**Option 2: Add Authentication**
Require authentication token for ready server access via request header validation.

**Option 3: Disable External Access**
Always bind ready server to 127.0.0.1 regardless of container detection, requiring explicit port forwarding for external access.

**Option 4: Configuration Flag**
Add `--ready-server-expose-details` flag (default: false) to control whether sensitive information is exposed.

## Proof of Concept

**Setup:**
```bash
# Terminal 1: Start local testnet with external Postgres
aptos node run-local-testnet \
  --with-indexer-api \
  --use-host-postgres \
  --host-postgres-password=SuperSecret123 \
  --host-postgres-host=192.168.1.100 \
  --host-postgres-port=5432 \
  --postgres-database=my_testnet_db
```

**Exploitation:**
```bash
# Terminal 2: Query ready server (attacker)
curl -s http://localhost:8070/ | jq '.'

# Expected output includes:
# {
#   "ready": [
#     {
#       "Postgres": "postgres://postgres:SuperSecret123@192.168.1.100:5432/my_testnet_db"
#     },
#     {
#       "Processor": [
#         "postgres://postgres:SuperSecret123@192.168.1.100:5432/my_testnet_db",
#         "token_processor"
#       ]
#     }
#   ],
#   "not_ready": []
# }

# Attacker extracts credentials and connects:
PGPASSWORD=SuperSecret123 psql -h 192.168.1.100 -p 5432 -U postgres -d my_testnet_db
# Now has full database access
```

**Rust Integration Test:**
```rust
#[tokio::test]
async fn test_ready_server_credential_leak() {
    // Start ready server with mock health checker containing sensitive data
    let sensitive_conn_str = "postgres://admin:SecretPass@10.0.0.1:5432/testdb";
    let health_checkers = hashset! {
        HealthChecker::Postgres(sensitive_conn_str.to_string())
    };
    
    // Start server on random port
    let config = ReadyServerArgs { ready_server_listen_port: 0 };
    let bind_to = Ipv4Addr::new(127, 0, 0, 1);
    
    // Query endpoint
    let response = reqwest::get(format!("http://{}:{}/", bind_to, config.ready_server_listen_port))
        .await
        .unwrap()
        .json::<ReadyData>()
        .await
        .unwrap();
    
    // Verify password is exposed
    let postgres_checker = &response.ready[0];
    assert!(format!("{:?}", postgres_checker).contains("SecretPass"));
}
```

## Notes

This vulnerability specifically affects the local testnet development tool when configured with external PostgreSQL databases. While the local testnet is not intended for production use, developers commonly run it in shared environments (cloud VMs, containerized workspaces) where network isolation between users may be weak or non-existent. The lack of access control on the ready server endpoint combined with credential embedding in connection strings creates a clear information disclosure vector that violates the principle of least privilege and secure credential handling.

### Citations

**File:** crates/aptos/src/node/local_testnet/postgres.rs (L92-116)
```rust
    pub fn get_connection_string(&self, database: Option<&str>, external: bool) -> String {
        let password = match self.use_host_postgres {
            true => match &self.host_postgres_password {
                Some(password) => format!(":{}", password),
                None => "".to_string(),
            },
            false => "".to_string(),
        };
        let port = self.get_postgres_port(external);
        let database = match database {
            Some(database) => database,
            None => &self.postgres_database,
        };
        let host = match self.use_host_postgres {
            true => &self.host_postgres_host,
            false => match external {
                true => "127.0.0.1",
                false => POSTGRES_CONTAINER_NAME,
            },
        };
        format!(
            "postgres://{}{}@{}:{}/{}",
            self.postgres_user, password, host, port, database,
        )
    }
```

**File:** crates/aptos/src/node/local_testnet/postgres.rs (L210-214)
```rust
    fn get_health_checkers(&self) -> HashSet<HealthChecker> {
        hashset! {HealthChecker::Postgres(
            self.args.get_connection_string(None, true),
        )}
    }
```

**File:** crates/aptos/src/node/local_testnet/mod.rs (L352-363)
```rust
        let health_checkers: HashSet<HealthChecker> = managers
            .iter()
            .flat_map(|m| m.get_health_checkers())
            .collect();

        // The final manager we add is the ready server. This must happen last since
        // it use the health checkers from all the other services.
        managers.push(Box::new(ReadyServerManager::new(
            &self,
            bind_to,
            health_checkers.clone(),
        )?));
```

**File:** crates/aptos/src/node/local_testnet/ready_server.rs (L110-131)
```rust
#[handler]
async fn root(health_checkers: Data<&HealthCheckers>) -> impl IntoResponse + use<> {
    let mut ready = vec![];
    let mut not_ready = vec![];
    for health_checker in &health_checkers.health_checkers {
        // Use timeout since some of these checks can take quite a while if the
        // underlying service is not ready. This is best effort of course, see the docs
        // for tokio::time::timeout for more information.
        match timeout(Duration::from_secs(3), health_checker.check()).await {
            Ok(Ok(())) => ready.push(health_checker.clone()),
            _ => {
                not_ready.push(health_checker.clone());
            },
        }
    }
    let status_code = if not_ready.is_empty() {
        StatusCode::OK
    } else {
        StatusCode::SERVICE_UNAVAILABLE
    };
    Json(ReadyData { ready, not_ready }).with_status(status_code)
}
```

**File:** crates/aptos/src/node/local_testnet/health_checker.rs (L24-42)
```rust
#[derive(Clone, Debug, Eq, Hash, PartialEq, Serialize)]
pub enum HealthChecker {
    /// Check that a HTTP API is up. The second param is the name of the HTTP service.
    Http(Url, String),
    /// Check that the node API is up. This is just a specific case of Http for extra
    /// guarantees around liveliness.
    NodeApi(Url),
    /// Check that a data service GRPC stream is up.
    DataServiceGrpc(Url),
    /// Check that a postgres instance is up.
    Postgres(String),
    /// Check that a processor is successfully processing txns. The first value is the
    /// postgres connection string. The second is the name of the processor. We check
    /// the that last_success_version in the processor_status table is present and > 0.
    Processor(String, String),
    /// Check that the indexer API is up and the metadata has been applied. We only use
    /// this one in the ready server.
    IndexerApiMetadata(Url),
}
```
