# Audit Report

## Title
Missing Database Consistency Validation Before RestoreHandler Creation Enables State Corruption During Recovery

## Summary
The `get_restore_handler()` function creates a `RestoreHandler` without validating that the underlying databases (ledger_db, state_kv_db, state_merkle_db) are in consistent states. When restore operations are initiated via `open_kv_only()`, the critical `sync_commit_progress()` consistency check is bypassed, allowing inconsistent database states from previous crashes to propagate corruption through the restore process.

## Finding Description

The vulnerability exists in the interaction between three key components:

1. **Missing Validation in get_restore_handler()**: The function directly creates a RestoreHandler without any consistency checks. [1](#0-0) 

2. **Skipped Consistency Check During Restore**: When `AptosDB::open_kv_only()` is called for restore operations, it sets `empty_buffered_state_for_restore=true`. [2](#0-1) 

3. **Bypassed sync_commit_progress()**: This flag causes `StateStore::new()` to skip the critical `sync_commit_progress()` function that detects and fixes database inconsistencies. [3](#0-2) 

The `sync_commit_progress()` function is responsible for ensuring all databases are synchronized to the same `OverallCommitProgress` point and truncating any database that has progressed ahead. [4](#0-3) 

**Exploitation Scenario**:

1. Node crashes during commit when:
   - `OverallCommitProgress` = version 1000
   - `StateKvCommitProgress` = version 1005 (ahead)
   - `LedgerCommitProgress` = version 1003 (ahead)

2. Operator initiates restore using backup-cli, which calls `open_kv_only()` [5](#0-4) 

3. RestoreHandler is created with inconsistent databases, no validation occurs

4. Restore operations read `OverallCommitProgress` (1000) via `get_next_expected_transaction_version()` but write to databases already containing data beyond that version [6](#0-5) 

5. Restore writes from `save_transactions()` conflict with existing state_kv_db entries at versions 1001-1005, causing:
   - Overwritten state values with incorrect transaction associations
   - Merkle tree corruption (orphaned nodes, incorrect parent-child relationships)
   - Mismatched state roots between validators [7](#0-6) 

This breaks the **State Consistency** invariant: "State transitions must be atomic and verifiable via Merkle proofs" and the **Deterministic Execution** invariant: "All validators must produce identical state roots for identical blocks."

## Impact Explanation

**High Severity** - This qualifies as "Significant protocol violations" under the Aptos bug bounty program:

- **State Corruption**: Inconsistent database states lead to corrupted Merkle trees and invalid state roots
- **Consensus Safety Risk**: Validators with corrupted state will compute different state roots for identical blocks, potentially causing consensus failures or chain splits
- **Requires Manual Intervention**: Recovery requires database cleanup or restoration from known-good backups
- **Affects Network Operations**: Multiple validators experiencing this issue simultaneously could cause network-wide consensus problems

The issue does not require authentication or privileged access - it manifests from natural crash scenarios during normal operations.

## Likelihood Explanation

**High Likelihood**:

- **Common Trigger**: Node crashes during commits are not rare in production environments (hardware failures, power loss, OOM kills, operator errors)
- **Automatic Manifestation**: The vulnerability automatically manifests when restore operations are attempted after such crashes without manual database cleanup
- **No Special Conditions Required**: Does not require specific timing, transaction types, or network conditions
- **Affects Standard Operations**: Restore operations are standard recovery procedures documented in Aptos operational guides

The only requirement is a crash during a commit operation followed by a restore attempt - both are routine operational scenarios.

## Recommendation

Add explicit database consistency validation before creating the RestoreHandler. Option 1 (Preferred):

```rust
impl GetRestoreHandler for Arc<AptosDB> {
    fn get_restore_handler(&self) -> RestoreHandler {
        // Validate and synchronize database consistency before restore
        StateStore::sync_commit_progress(
            Arc::clone(&self.ledger_db),
            Arc::clone(&self.state_kv_db),
            Arc::clone(&self.state_merkle_db),
            /*crash_if_difference_is_too_large=*/ true,
        );
        
        RestoreHandler::new(Arc::clone(self), Arc::clone(&self.state_store))
    }
}
```

Option 2: Add validation in `RestoreHandler::new()`:

```rust
pub(crate) fn new(aptosdb: Arc<AptosDB>, state_store: Arc<StateStore>) -> Self {
    // Verify database consistency
    let overall_progress = aptosdb.ledger_db.metadata_db()
        .get_synced_version()
        .expect("Failed to read overall commit progress");
    
    if let Some(overall_version) = overall_progress {
        let state_kv_progress = state_store.state_kv_db.metadata_db()
            .get::<DbMetadataSchema>(&DbMetadataKey::StateKvCommitProgress)
            .expect("Failed to read state KV commit progress")
            .expect("State KV commit progress cannot be None")
            .expect_version();
        
        ensure!(
            state_kv_progress == overall_version,
            "Database inconsistency detected: StateKV at {}, Overall at {}. Run database truncation first.",
            state_kv_progress,
            overall_version
        );
    }
    
    Self {
        ledger_db: Arc::clone(&aptosdb.ledger_db),
        aptosdb,
        state_store,
    }
}
```

Option 3: Document requirement for manual cleanup and add CLI command for database synchronization before restore.

## Proof of Concept

```rust
// Reproduction steps (pseudocode - would need test harness):

#[test]
fn test_restore_handler_inconsistent_state_corruption() {
    // 1. Initialize AptosDB and commit transactions up to version 1000
    let db = AptosDB::open(...);
    commit_transactions(&db, 0..=1000);
    
    // 2. Simulate partial commit crash:
    // - Write StateKvCommitProgress = 1005 directly
    db.state_kv_db.metadata_db().put::<DbMetadataSchema>(
        &DbMetadataKey::StateKvCommitProgress,
        &DbMetadataValue::Version(1005)
    );
    // - Write some state values at versions 1001-1005
    write_state_values(&db, 1001..=1005, test_data);
    // - Keep OverallCommitProgress at 1000
    
    // 3. Close and reopen with open_kv_only() (restore mode)
    drop(db);
    let db_restore = AptosDB::open_kv_only(...);
    
    // 4. Create RestoreHandler (should detect inconsistency but doesn't)
    let restore_handler = db_restore.get_restore_handler();
    
    // 5. Attempt to restore transactions from version 1001
    let next_version = restore_handler.get_next_expected_transaction_version();
    assert_eq!(next_version, 1001); // Based on OverallCommitProgress
    
    // 6. Save transactions at version 1001 - this conflicts with existing data
    restore_handler.save_transactions(
        1001,
        &transactions,
        &aux_info,
        &txn_infos,
        &events,
        write_sets
    );
    
    // 7. Verify corruption:
    // - State root mismatch
    // - Orphaned Merkle nodes
    // - Inconsistent state values
    let state_root = db_restore.get_state_root_hash(1001);
    let expected_root = compute_expected_root(&transactions, &write_sets);
    assert_ne!(state_root, expected_root); // Corruption detected
}
```

## Notes

This vulnerability specifically affects the restore pathway where `open_kv_only()` intentionally bypasses consistency checks. While this design choice may have been made for performance reasons during incremental restore operations, it creates a window for corruption propagation when databases are already in inconsistent states. The fix should maintain restore performance while ensuring database consistency at the critical RestoreHandler creation point.

### Citations

**File:** storage/aptosdb/src/get_restore_handler.rs (L13-15)
```rust
    fn get_restore_handler(&self) -> RestoreHandler {
        RestoreHandler::new(Arc::clone(self), Arc::clone(&self.state_store))
    }
```

**File:** storage/aptosdb/src/db/mod.rs (L92-103)
```rust
        Self::open_internal(
            &db_paths,
            readonly,
            pruner_config,
            rocksdb_configs,
            enable_indexer,
            buffered_state_target_items,
            max_num_nodes_per_lru_cache_shard,
            true,
            internal_indexer_db,
            HotStateConfig::default(),
        )
```

**File:** storage/aptosdb/src/state_store/mod.rs (L353-360)
```rust
        if !hack_for_tests && !empty_buffered_state_for_restore {
            Self::sync_commit_progress(
                Arc::clone(&ledger_db),
                Arc::clone(&state_kv_db),
                Arc::clone(&state_merkle_db),
                /*crash_if_difference_is_too_large=*/ true,
            );
        }
```

**File:** storage/aptosdb/src/state_store/mod.rs (L408-446)
```rust
    // We commit the overall commit progress at the last, and use it as the source of truth of the
    // commit progress.
    pub fn sync_commit_progress(
        ledger_db: Arc<LedgerDb>,
        state_kv_db: Arc<StateKvDb>,
        state_merkle_db: Arc<StateMerkleDb>,
        crash_if_difference_is_too_large: bool,
    ) {
        let ledger_metadata_db = ledger_db.metadata_db();
        if let Some(overall_commit_progress) = ledger_metadata_db
            .get_synced_version()
            .expect("DB read failed.")
        {
            info!(
                overall_commit_progress = overall_commit_progress,
                "Start syncing databases..."
            );
            let ledger_commit_progress = ledger_metadata_db
                .get_ledger_commit_progress()
                .expect("Failed to read ledger commit progress.");
            assert_ge!(ledger_commit_progress, overall_commit_progress);

            let state_kv_commit_progress = state_kv_db
                .metadata_db()
                .get::<DbMetadataSchema>(&DbMetadataKey::StateKvCommitProgress)
                .expect("Failed to read state K/V commit progress.")
                .expect("State K/V commit progress cannot be None.")
                .expect_version();
            assert_ge!(state_kv_commit_progress, overall_commit_progress);

            // LedgerCommitProgress was not guaranteed to commit after all ledger changes finish,
            // have to attempt truncating every column family.
            info!(
                ledger_commit_progress = ledger_commit_progress,
                "Attempt ledger truncation...",
            );
            let difference = ledger_commit_progress - overall_commit_progress;
            if crash_if_difference_is_too_large {
                assert_le!(difference, MAX_COMMIT_PROGRESS_DIFFERENCE);
```

**File:** storage/backup/backup-cli/src/utils/mod.rs (L305-315)
```rust
            let restore_handler = Arc::new(AptosDB::open_kv_only(
                StorageDirPaths::from_path(db_dir),
                false,                       /* read_only */
                NO_OP_STORAGE_PRUNER_CONFIG, /* pruner config */
                opt.rocksdb_opt.clone().into(),
                false, /* indexer */
                BUFFERED_STATE_TARGET_ITEMS,
                DEFAULT_MAX_NUM_NODES_PER_LRU_CACHE_SHARD,
                internal_indexer_db,
            )?)
            .get_restore_handler();
```

**File:** storage/aptosdb/src/backup/restore_handler.rs (L128-130)
```rust
    pub fn get_next_expected_transaction_version(&self) -> Result<Version> {
        Ok(self.aptosdb.get_synced_version()?.map_or(0, |ver| ver + 1))
    }
```

**File:** storage/aptosdb/src/backup/restore_utils.rs (L165-172)
```rust
        // commit the state kv before ledger in case of failure happens
        let last_version = first_version + txns.len() as u64 - 1;
        state_store
            .state_db
            .state_kv_db
            .commit(last_version, None, sharded_kv_schema_batch)?;

        ledger_db.write_schemas(ledger_db_batch)?;
```
