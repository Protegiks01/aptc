# Audit Report

## Title
Path Traversal Vulnerability in LocalFs Backup Storage via Forged FileHandles

## Summary
The backup/restore system allows arbitrary file read through path traversal in forged FileHandles. The `LocalFs::open_for_read()` function joins user-controlled FileHandles directly with the base directory without validation, enabling attackers who can modify backup manifests to read any file on the filesystem.

## Finding Description

The Aptos backup system stores `FileHandle` references in manifest files to locate backup data chunks. A `FileHandle` is defined as a simple `String` type alias with no validation. [1](#0-0) 

During restore operations, manifests containing chunks with `FileHandle` fields are deserialized from JSON without integrity verification. [2](#0-1) 

The deserialization uses `serde_json::from_slice()` which blindly accepts any string value for FileHandles. [3](#0-2) 

**Critical Vulnerability**: In `LocalFs::open_for_read()`, the FileHandle is joined directly with the base directory using `PathBuf::join()` without any path validation or sanitization: [4](#0-3) 

Rust's `PathBuf::join()` does NOT prevent path traversal. If the second argument contains `..` components or is an absolute path, it can escape the base directory.

**Attack Path:**
1. Attacker gains write access to backup storage (S3/GCS compromise, MITM during backup, or local file access)
2. Attacker modifies a manifest file (e.g., `transaction_backup.json`) to inject a malicious FileHandle like `"../../../../../../../etc/passwd"` or `"/etc/shadow"`
3. Victim runs restore operation, which loads the manifest [5](#0-4) 
4. The malicious FileHandle is extracted and passed to `storage.open_for_read()`
5. `self.dir.join("../../../../../../../etc/passwd")` creates a path that escapes the backup directory
6. Arbitrary file is opened and read, leaking sensitive data

The manifest's `verify()` method only checks internal consistency (version ranges, chunk continuity) but does NOT validate FileHandle paths. [6](#0-5) 

## Impact Explanation

**Critical Severity** - This vulnerability enables:

1. **Arbitrary File Read**: Attackers can read any file accessible to the backup/restore process, including:
   - Validator private keys (`/root/.aptos/validator-key.yaml`)
   - Database credentials and configuration files
   - System secrets (`/etc/shadow`, SSL certificates)
   - Other sensitive application data

2. **Credential Theft**: Reading validator keys or operator credentials could lead to:
   - Validator impersonation
   - Unauthorized transaction signing
   - Consensus manipulation if combined with other attacks

3. **Information Disclosure**: Leaked configuration files could reveal:
   - Network topology and internal IP addresses
   - Database connection strings
   - API keys and access tokens

This meets **Critical Severity** criteria per Aptos Bug Bounty as it can lead to:
- Loss of Funds (if validator keys are stolen)
- Remote Code Execution (if credentials enable further exploitation)
- Consensus violations (if validator keys are compromised)

## Likelihood Explanation

**Medium to High Likelihood:**

**Prerequisites:**
- Attacker must compromise backup storage (S3, GCS, or local directory) OR perform MITM during backup operations
- No cryptographic signing or integrity protection on manifests exists

**Feasibility Factors:**
- Backup storage is often less secured than production systems (shared buckets, weaker access controls)
- Cloud storage misconfigurations are common (public S3 buckets, overly permissive IAM policies)
- Backup processes may use different credentials with broader filesystem access
- The attack is trivial once manifest access is gained (simple JSON edit)

**Attack Complexity:** Low
- No special tools required (text editor to modify JSON)
- Well-known path traversal technique (`../../../`)
- Immediate exploitation upon restore operation

The attack becomes highly likely in scenarios where:
- Backups are stored on compromised infrastructure
- Multiple teams share backup storage
- Automated backup processes run with elevated privileges

## Recommendation

Implement strict FileHandle validation before use:

```rust
async fn open_for_read(
    &self,
    file_handle: &FileHandleRef,
) -> Result<Box<dyn AsyncRead + Send + Unpin>> {
    // Validate and sanitize the file_handle
    let handle_path = Path::new(file_handle);
    
    // Reject absolute paths
    ensure!(
        handle_path.is_relative(),
        "FileHandle must be relative: {}",
        file_handle
    );
    
    // Reject paths with parent directory components
    for component in handle_path.components() {
        ensure!(
            !matches!(component, std::path::Component::ParentDir),
            "FileHandle cannot contain '..': {}",
            file_handle
        );
    }
    
    // Join and canonicalize to prevent symlink attacks
    let full_path = self.dir.join(file_handle);
    let canonical_path = full_path.canonicalize().err_notes(&full_path)?;
    let canonical_base = self.dir.canonicalize().err_notes(&self.dir)?;
    
    // Ensure the resolved path is still within the backup directory
    ensure!(
        canonical_path.starts_with(&canonical_base),
        "FileHandle resolves outside backup directory: {}",
        file_handle
    );
    
    let file = OpenOptions::new()
        .read(true)
        .open(&canonical_path)
        .await
        .err_notes(&canonical_path)?;
    Ok(Box::new(file))
}
```

**Additional Recommendations:**
1. Add cryptographic signing to manifests to prevent tampering
2. Implement manifest integrity verification during restore
3. Apply the same validation to `CommandAdapter::open_for_read()` to prevent shell injection via FILE_HANDLE environment variable
4. Add security tests for path traversal attempts
5. Consider using a dedicated FileHandle type with built-in validation instead of raw String

## Proof of Concept

```rust
#[tokio::test]
async fn test_path_traversal_attack() {
    use std::fs;
    use tempfile::TempDir;
    use crate::storage::{BackupStorage, local_fs::LocalFs};
    
    // Setup: Create backup directory and a sensitive file outside it
    let backup_dir = TempDir::new().unwrap();
    let sensitive_dir = TempDir::new().unwrap();
    let sensitive_file = sensitive_dir.path().join("secret.txt");
    fs::write(&sensitive_file, b"SENSITIVE_DATA").unwrap();
    
    // Calculate relative path from backup dir to sensitive file
    let backup_path = backup_dir.path().canonicalize().unwrap();
    let sensitive_path = sensitive_file.canonicalize().unwrap();
    
    // Create path traversal FileHandle
    let mut traversal = String::new();
    for _ in 0..10 {
        traversal.push_str("../");
    }
    traversal.push_str(&sensitive_path.to_string_lossy());
    
    // Attack: Try to read sensitive file using forged FileHandle
    let storage = LocalFs::new(backup_path);
    let result = storage.open_for_read(&traversal).await;
    
    // Vulnerability confirmed if file is accessible
    if let Ok(mut reader) = result {
        let mut contents = String::new();
        use tokio::io::AsyncReadExt;
        reader.read_to_string(&mut contents).await.unwrap();
        
        // This should NOT succeed - it demonstrates the vulnerability
        assert_eq!(contents, "SENSITIVE_DATA");
        panic!("VULNERABILITY: Path traversal allowed reading arbitrary file!");
    }
}

// Alternative PoC: Create malicious manifest and restore it
#[tokio::test]
async fn test_malicious_manifest_restore() {
    use crate::backup_types::transaction::manifest::{TransactionBackup, TransactionChunk};
    use std::fs;
    use tempfile::TempDir;
    
    let backup_dir = TempDir::new().unwrap();
    
    // Create malicious manifest with path traversal in FileHandle
    let malicious_manifest = TransactionBackup {
        first_version: 0,
        last_version: 0,
        chunks: vec![TransactionChunk {
            first_version: 0,
            last_version: 0,
            transactions: "../../../../../../../etc/passwd".to_string(), // Path traversal
            proof: "dummy_proof".to_string(),
            format: crate::backup_types::transaction::manifest::TransactionChunkFormat::V0,
        }],
    };
    
    // Serialize malicious manifest
    let manifest_json = serde_json::to_string(&malicious_manifest).unwrap();
    let manifest_path = backup_dir.path().join("malicious_manifest.json");
    fs::write(&manifest_path, manifest_json).unwrap();
    
    // Attempt to restore - will read /etc/passwd instead of backup data
    let storage = std::sync::Arc::new(LocalFs::new(backup_dir.path().to_path_buf()));
    let loaded_manifest: TransactionBackup = storage
        .load_json_file(&manifest_path.to_string_lossy())
        .await
        .unwrap();
    
    // Try to open the malicious FileHandle
    let result = storage.open_for_read(&loaded_manifest.chunks[0].transactions).await;
    
    assert!(result.is_ok(), "VULNERABILITY: Arbitrary file access succeeded!");
}
```

## Notes

This vulnerability affects the **LocalFs** storage backend directly. The **CommandAdapter** backend is also potentially vulnerable depending on shell command configuration, as FileHandles are passed as environment variables to shell commands without validation. [7](#0-6) 

In production deployments using GCS/S3 via CommandAdapter, the shell commands execute FileHandles like: `gsutil cp "gs://$BUCKET/$SUB_DIR/$FILE_HANDLE"` [8](#0-7) 

While the quotes provide some protection, path traversal patterns in FILE_HANDLE could still access unintended bucket paths or leverage cloud storage features in unexpected ways.

### Citations

**File:** storage/backup/backup-cli/src/storage/mod.rs (L40-41)
```rust
pub type FileHandle = String;
pub type FileHandleRef = str;
```

**File:** storage/backup/backup-cli/src/backup_types/transaction/manifest.rs (L19-34)
```rust
#[derive(Clone, Deserialize, Serialize, Debug)]
pub struct TransactionChunk {
    pub first_version: Version,
    pub last_version: Version,
    /// Repeated `len(record) + record`, where `record` is BCS serialized tuple
    /// `(Transaction, TransactionInfo)`
    pub transactions: FileHandle,
    /// BCS serialized `(TransactionAccumulatorRangeProof, LedgerInfoWithSignatures)`.
    /// The `TransactionAccumulatorRangeProof` links the transactions to the
    /// `LedgerInfoWithSignatures`, and the `LedgerInfoWithSignatures` can be verified by the
    /// signatures it carries, against the validator set in the epoch. (Hence proper
    /// `EpochEndingBackup` is needed for verification.)
    pub proof: FileHandle,
    #[serde(default = "default_to_v0")]
    pub format: TransactionChunkFormat,
}
```

**File:** storage/backup/backup-cli/src/backup_types/transaction/manifest.rs (L50-88)
```rust
    pub fn verify(&self) -> Result<()> {
        // check number of waypoints
        ensure!(
            self.first_version <= self.last_version,
            "Bad version range: [{}, {}]",
            self.first_version,
            self.last_version,
        );

        // check chunk ranges
        ensure!(!self.chunks.is_empty(), "No chunks.");

        let mut next_version = self.first_version;
        for chunk in &self.chunks {
            ensure!(
                chunk.first_version == next_version,
                "Chunk ranges not continuous. Expected first version: {}, actual: {}.",
                next_version,
                chunk.first_version,
            );
            ensure!(
                chunk.last_version >= chunk.first_version,
                "Chunk range invalid. [{}, {}]",
                chunk.first_version,
                chunk.last_version,
            );
            next_version = chunk.last_version + 1;
        }

        // check last version in chunk matches manifest
        ensure!(
            next_version - 1 == self.last_version, // okay to -1 because chunks is not empty.
            "Last version in chunks: {}, in manifest: {}",
            next_version - 1,
            self.last_version,
        );

        Ok(())
    }
```

**File:** storage/backup/backup-cli/src/utils/storage_ext.rs (L35-37)
```rust
    async fn load_json_file<T: DeserializeOwned>(&self, file_handle: &FileHandleRef) -> Result<T> {
        Ok(serde_json::from_slice(&self.read_all(file_handle).await?)?)
    }
```

**File:** storage/backup/backup-cli/src/storage/local_fs/mod.rs (L98-109)
```rust
    async fn open_for_read(
        &self,
        file_handle: &FileHandleRef,
    ) -> Result<Box<dyn AsyncRead + Send + Unpin>> {
        let path = self.dir.join(file_handle);
        let file = OpenOptions::new()
            .read(true)
            .open(&path)
            .await
            .err_notes(&path)?;
        Ok(Box::new(file))
    }
```

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L100-105)
```rust
    async fn load(
        manifest: TransactionChunk,
        storage: &Arc<dyn BackupStorage>,
        epoch_history: Option<&Arc<EpochHistory>>,
    ) -> Result<Self> {
        let mut file = BufReader::new(storage.open_for_read(&manifest.transactions).await?);
```

**File:** storage/backup/backup-cli/src/storage/command_adapter/mod.rs (L114-124)
```rust
    async fn open_for_read(
        &self,
        file_handle: &FileHandleRef,
    ) -> Result<Box<dyn AsyncRead + Send + Unpin>> {
        let child = self
            .cmd(&self.config.commands.open_for_read, vec![
                EnvVar::file_handle(file_handle.to_string()),
            ])
            .spawn()?;
        Ok(Box::new(child.into_data_source()))
    }
```

**File:** storage/backup/backup-cli/src/storage/command_adapter/sample_configs/gcp.sample.yaml (L19-21)
```yaml
  open_for_read: |
    # route file handle content to stdout
    gsutil -q cp "gs://$BUCKET/$SUB_DIR/$FILE_HANDLE" - | gzip -cd
```
