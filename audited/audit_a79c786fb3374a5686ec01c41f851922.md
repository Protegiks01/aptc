# Audit Report

## Title
ElGamal Randomness Reuse Vulnerability in Aptos Confidential Asset System

## Summary
The ElGamal encryption implementation in Aptos Core does not prevent or detect randomness reuse across multiple encryptions. Users can submit multiple confidential transactions using the same randomness value, allowing observers to link transactions, infer plaintext differences, and potentially decrypt amounts, completely breaking the privacy guarantees of the confidential asset system.

## Finding Description

The Aptos Core codebase implements a Twisted ElGamal encryption scheme for confidential assets in the `aptos-experimental` module. The encryption function accepts randomness as a parameter but provides no mechanism to prevent its reuse across different transactions. [1](#0-0) 

The `encrypt` function generates fresh randomness on each call using the provided RNG, but it does not track or enforce uniqueness of randomness values. The function trusts the caller to provide proper non-repeating random values.

In the confidential asset system, users generate ElGamal ciphertexts off-chain and submit them in transactions. The on-chain storage structure maintains only encrypted balances and encryption keys: [2](#0-1) 

Critically, there is **no tracking of previously used randomness values** and **no nonce system** to prevent reuse. The verification logic only checks the validity of zero-knowledge proofs, not randomness uniqueness: [3](#0-2) 

**Attack Scenario:**

1. A user (maliciously or due to buggy client software) generates two transactions using the same randomness `r`:
   - Transaction T1: Encrypts amount A₁ → ciphertext (A₁·G + r·H, r·Y)  
   - Transaction T2: Encrypts amount A₂ → ciphertext (A₂·G + r·H, r·Y)

2. An observer monitoring the blockchain notices identical right components (r·Y) across the two ciphertexts

3. The observer computes the difference of the left components:
   - (A₁·G + r·H) - (A₂·G + r·H) = (A₁ - A₂)·G

4. If the observer knows one plaintext amount (e.g., from a public deposit or withdrawal), they can solve for the other amount using discrete logarithm techniques

5. The observer can build a transaction graph correlating all transactions using the same randomness, completely de-anonymizing the user's confidential transaction history

The verification function `balance_c_equals` intentionally checks that sender and recipient amounts use the same randomness **within a single transaction** (for homomorphic properties), but provides no protection **across different transactions**: [4](#0-3) 

## Impact Explanation

**Severity Assessment: LOW (Information Leak)**

While this vulnerability breaks the fundamental privacy guarantee of the confidential asset system, it falls under **Low Severity** per Aptos bug bounty criteria because:

1. **No funds are lost or stolen** - The vulnerability only leaks information about transaction amounts; user balances remain secure
2. **No consensus or state integrity issues** - The blockchain continues to function correctly with valid state transitions
3. **Affects experimental module only** - The confidential asset system is in `aptos-experimental`, not core Aptos functionality
4. **Privacy loss, not security breach** - This is an information disclosure vulnerability, not a funds theft or consensus violation

The impact is classified as a "Minor information leak" which aligns with Low Severity ($1,000) in the bug bounty program.

## Likelihood Explanation

**Likelihood: MEDIUM to HIGH**

The likelihood depends on client implementation quality:

**Factors increasing likelihood:**
- No on-chain protection exists at any layer (Rust, Move VM, smart contract)
- Users must implement proper randomness generation in client software
- Buggy client libraries could easily reuse randomness accidentally
- No warnings or safeguards in the protocol itself
- RNG state corruption or poor seeding could cause unintentional reuse

**Factors decreasing likelihood:**
- Requires either malicious intent or significant client bugs
- Reputable client implementations would use proper CSPRNGs
- Test-only proof generation functions prevent accidental on-chain misuse [5](#0-4) 

## Recommendation

**Multi-Layer Defense Approach:**

1. **Client-Side (Primary Defense):**
   - Client libraries MUST use cryptographically secure RNGs (e.g., `OsRng`)
   - Implement randomness tracking in client state to detect accidental reuse
   - Add explicit warnings in SDK documentation about randomness requirements

2. **Protocol-Level (Secondary Defense):**
   - Add optional on-chain commitment scheme for randomness values
   - Implement a nonce-based system where users must include a unique nonce with each transaction
   - Store hash of used randomness commitments (without revealing actual values)

3. **Verification Enhancement:**
   - Add a check comparing new ciphertext right components against recent transaction history
   - Reject transactions if right components match previous transactions within a time window

**Proposed Code Fix (Simplified):**

```move
// In ConfidentialAssetStore, add:
struct ConfidentialAssetStore has key {
    // ... existing fields ...
    
    // Store hash of recent randomness commitments (limited history for privacy)
    recent_randomness_commitments: vector<vector<u8>>,
}

// In confidential_transfer_internal, add verification:
fun verify_no_randomness_reuse(
    randomness_commitment: vector<u8>,
    store: &ConfidentialAssetStore
) {
    assert!(
        !store.recent_randomness_commitments.contains(&randomness_commitment),
        error::invalid_argument(ERANDOMNESS_REUSE_DETECTED)
    );
}
```

## Proof of Concept

```rust
// Rust PoC demonstrating randomness reuse attack
use aptos_crypto::elgamal::{encrypt, key_gen, Curve25519};
use curve25519_dalek::scalar::Scalar;

#[test]
fn test_randomness_reuse_attack() {
    let mut rng = rand_core::OsRng;
    
    // Generate ElGamal keypair
    let (sk, pk) = key_gen::<Curve25519, _>(&mut rng);
    
    // Create a deterministic RNG that will return the same randomness
    struct DeterministicRng(u64);
    impl rand_core::RngCore for DeterministicRng {
        fn next_u32(&mut self) -> u32 { self.0 as u32 }
        fn next_u64(&mut self) -> u64 { self.0 }
        fn fill_bytes(&mut self, dest: &mut [u8]) {
            dest.fill(self.0 as u8);
        }
        fn try_fill_bytes(&mut self, dest: &mut [u8]) -> Result<(), rand_core::Error> {
            self.fill_bytes(dest);
            Ok(())
        }
    }
    impl rand_core::CryptoRng for DeterministicRng {}
    
    let mut bad_rng = DeterministicRng(12345);
    
    // Encrypt two different messages with the SAME randomness (reused RNG state)
    let msg1 = Curve25519::generator_mul(&Scalar::from(100u64));
    let msg2 = Curve25519::generator_mul(&Scalar::from(200u64));
    
    let (c0_1, c1_1) = encrypt::<Curve25519, _>(&mut bad_rng, &pk, &msg1);
    
    // Reset RNG to reuse randomness
    bad_rng = DeterministicRng(12345);
    let (c0_2, c1_2) = encrypt::<Curve25519, _>(&mut bad_rng, &pk, &msg2);
    
    // VULNERABILITY: c0 components are identical (r*G is the same)
    assert_eq!(c0_1, c0_2, "Randomness reuse detected: c0 components match!");
    
    // Attacker can compute difference: c1_2 - c1_1 = msg2 - msg1
    // This leaks information about the plaintext messages
    println!("ATTACK SUCCESS: Randomness reuse allows linking transactions!");
}
```

**Notes:**

- This vulnerability is a **client-side responsibility issue** rather than a blockchain-level exploit
- The Aptos protocol correctly implements ElGamal encryption; the weakness is the lack of safeguards against misuse
- Users must ensure their client software uses proper CSPRNGs and never reuses randomness
- The experimental nature of the confidential asset module means this should be documented as a known limitation
- Production deployments should include comprehensive client-side validation and user education about cryptographic hygiene requirements

### Citations

**File:** crates/aptos-crypto/src/elgamal/mod.rs (L50-60)
```rust
/// ElGamal encryption.
pub fn encrypt<G: ElGamalFriendlyGroup, R: CryptoRng + RngCore>(
    rng: &mut R,
    pk: &G::Element,
    msg: &G::Element,
) -> (G::Element, G::Element) {
    let r = G::rand_scalar(rng);
    let c0 = G::generator_mul(&r);
    let c1 = G::add(msg, &G::mul(pk, &r));
    (c0, c1)
}
```

**File:** aptos-move/framework/aptos-experimental/sources/confidential_asset/confidential_asset.move (L113-147)
```text
    struct ConfidentialAssetStore has key {
        /// Indicates if the account is frozen. If `true`, transactions are temporarily disabled
        /// for this account. This is particularly useful during key rotations, which require
        /// two transactions: rolling over the pending balance to the actual balance and rotating
        /// the encryption key. Freezing prevents the user from accepting additional payments
        /// between these two transactions.
        frozen: bool,

        /// A flag indicating whether the actual balance is normalized. A normalized balance
        /// ensures that all chunks fit within the defined 16-bit bounds, preventing overflows.
        normalized: bool,

        /// Tracks the maximum number of transactions the user can accept before normalization
        /// is required. For example, if the user can accept up to 2^16 transactions and each
        /// chunk has a 16-bit limit, the maximum chunk value before normalization would be
        /// 2^16 * 2^16 = 2^32. Maintaining this counter is crucial because users must solve
        /// a discrete logarithm problem of this size to decrypt their balances.
        pending_counter: u64,

        /// Stores the user's pending balance, which is used for accepting incoming payments.
        /// Represented as four 16-bit chunks (p0 + 2^16 * p1 + 2^32 * p2 + 2^48 * p3), that can grow up to 32 bits.
        /// All payments are accepted into this pending balance, which users must roll over into the actual balance
        /// to perform transactions like withdrawals or transfers.
        /// This separation helps protect against front-running attacks, where small incoming transfers could force
        /// frequent regenerating of zk-proofs.
        pending_balance: confidential_balance::CompressedConfidentialBalance,

        /// Represents the actual user balance, which is available for sending payments.
        /// It consists of eight 16-bit chunks (p0 + 2^16 * p1 + ... + 2^112 * p8), supporting a 128-bit balance.
        /// Users can decrypt this balance with their decryption keys and by solving a discrete logarithm problem.
        actual_balance: confidential_balance::CompressedConfidentialBalance,

        /// The encryption key associated with the user's confidential asset account, different for each token.
        ek: twisted_elgamal::CompressedPubkey
    }
```

**File:** aptos-move/framework/aptos-experimental/sources/confidential_asset/confidential_asset.move (L862-872)
```text
        confidential_proof::verify_transfer_proof(
            &sender_ek,
            &recipient_ek,
            &sender_current_actual_balance,
            &new_balance,
            &sender_amount,
            &recipient_amount,
            &auditor_eks,
            &auditor_amounts,
            &proof
        );
```

**File:** aptos-move/framework/aptos-experimental/sources/confidential_asset/confidential_balance.move (L258-280)
```text
    /// Checks if the corresponding value components (`C`) of two confidential balances are equivalent.
    public fun balance_c_equals(
        lhs: &ConfidentialBalance, rhs: &ConfidentialBalance
    ): bool {
        assert!(
            lhs.chunks.length() == rhs.chunks.length(),
            error::internal(EINTERNAL_ERROR)
        );

        let ok = true;

        lhs.chunks.zip_ref(
            &rhs.chunks,
            |l, r| {
                let (lc, _) = twisted_elgamal::ciphertext_as_points(l);
                let (rc, _) = twisted_elgamal::ciphertext_as_points(r);

                ok = ok && ristretto255::point_equals(lc, rc);
            }
        );

        ok
    }
```

**File:** aptos-move/framework/aptos-experimental/sources/confidential_asset/confidential_proof.move (L1642-1659)
```text
    #[test_only]
    public fun prove_transfer(
        sender_dk: &Scalar,
        sender_ek: &twisted_elgamal::CompressedPubkey,
        recipient_ek: &twisted_elgamal::CompressedPubkey,
        amount: u64,
        new_amount: u128,
        current_balance: &confidential_balance::ConfidentialBalance,
        auditor_eks: &vector<twisted_elgamal::CompressedPubkey>
    ): (
        TransferProof,
        confidential_balance::ConfidentialBalance,
        confidential_balance::ConfidentialBalance,
        confidential_balance::ConfidentialBalance,
        vector<confidential_balance::ConfidentialBalance>
    ) {
        let amount_r = confidential_balance::generate_balance_randomness();
        let new_balance_r = confidential_balance::generate_balance_randomness();
```
