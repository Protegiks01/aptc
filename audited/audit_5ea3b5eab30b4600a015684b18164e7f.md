# Audit Report

## Title
JWK Consensus State Inconsistency: ConfigV1 with Empty Providers Creates Non-Functional "Enabled" State

## Summary
There is a critical semantic difference between `ConfigV1{oidc_providers: vec![]}` and `ConfigOff` that creates an inconsistent system state. The empty-list configuration causes the system to report JWK consensus as "enabled" while being non-functional, leading to resource waste, reduced DoS protection, and potential keyless account failures. This inconsistent state is used by default in genesis initialization.

## Finding Description

The `OnChainJWKConsensusConfig` enum has a method `jwk_consensus_enabled()` that determines whether the JWK consensus subsystem is active: [1](#0-0) 

This method returns `false` for `ConfigOff` but returns `true` for any `ConfigV1` variant, regardless of whether the `oidc_providers` list is empty. This creates a semantic inconsistency when `ConfigV1{oidc_providers: vec![]}` is used.

**Critical Usage in Consensus Validation:** [2](#0-1) 

The `is_vtxn_expected` function uses `jwk_consensus_enabled()` to determine if `ObservedJWKUpdate` validator transactions should be accepted. With `ConfigV1{oidc_providers: vec![]}`, this returns `true`, allowing such transactions through consensus validation. [3](#0-2) 

**Non-Functional JWK Manager:** [4](#0-3) 

When the config has an empty provider list, the JWK manager starts but spawns zero observers: [5](#0-4) 

**Default Genesis Configuration:** [6](#0-5) 

The comment explicitly acknowledges this is a workaround, but it's used in production genesis: [7](#0-6) 

**Validator Transaction Verification Gap:** [8](#0-7) 

`ObservedJWKUpdate` transactions pass consensus validation without cryptographic verification, deferring all checks to the VM execution phase.

## Impact Explanation

This vulnerability qualifies as **Medium Severity** per Aptos bug bounty criteria ("State inconsistencies requiring intervention") because:

1. **State Inconsistency**: The system reports JWK consensus as "enabled" via `jwk_consensus_enabled()` returning `true`, but the subsystem is non-functional (no observers to fetch JWK updates). This violates the "State Consistency" invariant.

2. **Resource Waste**: The JWK consensus manager thread runs unnecessarily, consuming CPU, memory, and network resources while performing no useful work.

3. **Reduced DoS Protection**: With `ConfigOff`, bogus `ObservedJWKUpdate` transactions are rejected immediately at consensus validation. With `ConfigV1{oidc_providers: vec![]}`, they pass consensus validation and only fail during VM execution, consuming more resources per malicious transaction.

4. **Keyless Account Impact**: If keyless accounts are feature-enabled while JWK consensus is in this broken state, users experience unexpected transaction failures as JWKs cannot be updated: [9](#0-8) 

5. **Production Deployment Risk**: This broken state is the **default configuration for genesis**, meaning new networks inherit this vulnerability unless explicitly overridden.

## Likelihood Explanation

**Likelihood: HIGH**

- The vulnerable configuration is used by default in `default_for_genesis()`, affecting every new network deployment
- No attacker action required - the vulnerability exists in the default state
- Operators may not realize the semantic difference between the two configurations
- The inconsistency persists until governance explicitly changes the configuration

## Recommendation

**Option 1: Fix `jwk_consensus_enabled()` logic** (Preferred)

Modify the function to return `false` when the provider list is empty:

```rust
pub fn jwk_consensus_enabled(&self) -> bool {
    match self {
        OnChainJWKConsensusConfig::Off => false,
        OnChainJWKConsensusConfig::V1(config) => !config.oidc_providers.is_empty(),
    }
}
```

**Option 2: Fix default genesis configuration**

Change `default_for_genesis()` to use `ConfigOff`:

```rust
pub fn default_for_genesis() -> Self {
    Self::Off  // Explicitly disable rather than using empty list
}
```

**Option 3: Add epoch manager validation**

Prevent JWK manager from starting when the provider list is empty:

```rust
let (jwk_manager_should_run, oidc_providers) = match jwk_consensus_config {
    Ok(config) => {
        let providers_vec = config.oidc_providers_cloned();
        let should_run = config.jwk_consensus_enabled() 
            && !providers_vec.is_empty()  // Add this check
            && onchain_consensus_config.is_vtxn_enabled();
        // ...
    }
    // ...
};
```

## Proof of Concept

Create a Rust integration test demonstrating the inconsistency:

```rust
#[test]
fn test_jwk_consensus_config_inconsistency() {
    // ConfigOff correctly reports as disabled
    let config_off = OnChainJWKConsensusConfig::Off;
    assert_eq!(config_off.jwk_consensus_enabled(), false);
    assert_eq!(config_off.oidc_providers_cloned().len(), 0);
    
    // ConfigV1 with empty providers incorrectly reports as enabled
    let config_empty = OnChainJWKConsensusConfig::V1(ConfigV1 {
        oidc_providers: vec![],
    });
    assert_eq!(config_empty.jwk_consensus_enabled(), true);  // BUG: Should be false
    assert_eq!(config_empty.oidc_providers_cloned().len(), 0);
    
    // Default genesis uses the broken configuration
    let genesis_default = OnChainJWKConsensusConfig::default_for_genesis();
    assert!(matches!(genesis_default, OnChainJWKConsensusConfig::V1(_)));
    assert_eq!(genesis_default.jwk_consensus_enabled(), true);  // Reports enabled
    assert_eq!(genesis_default.oidc_providers_cloned().len(), 0);  // But has no providers
    
    // Demonstrate consensus validation difference
    let randomness_config = OnChainRandomnessConfig::default_disabled();
    let dummy_update = ValidatorTransaction::ObservedJWKUpdate(
        jwks::QuorumCertifiedUpdate::dummy()
    );
    
    // ConfigOff rejects ObservedJWKUpdate
    assert_eq!(
        is_vtxn_expected(&randomness_config, &config_off, &dummy_update),
        false
    );
    
    // ConfigV1 with empty list accepts ObservedJWKUpdate (vulnerability)
    assert_eq!(
        is_vtxn_expected(&randomness_config, &config_empty, &dummy_update),
        true
    );
}
```

**Notes:**
- The vulnerability exists at the intersection of configuration semantics and system behavior
- Both configurations result in no JWK updates, but with different resource and validation implications
- The issue is architectural rather than a simple coding error, requiring careful consideration of the fix approach
- Production networks should immediately assess their JWK consensus configuration and migrate away from the empty-list state

### Citations

**File:** types/src/on_chain_config/jwk_consensus_config.rs (L61-67)
```rust
    pub fn default_for_genesis() -> Self {
        // Here it is supposed to use `default_enabled()`.
        // Using an empty list instead to avoid DDoSing the CI infra or the actual providers.
        Self::V1(ConfigV1 {
            oidc_providers: vec![],
        })
    }
```

**File:** types/src/on_chain_config/jwk_consensus_config.rs (L69-74)
```rust
    pub fn jwk_consensus_enabled(&self) -> bool {
        match self {
            OnChainJWKConsensusConfig::Off => false,
            OnChainJWKConsensusConfig::V1 { .. } => true,
        }
    }
```

**File:** consensus/src/util/mod.rs (L15-24)
```rust
pub fn is_vtxn_expected(
    randomness_config: &OnChainRandomnessConfig,
    jwk_consensus_config: &OnChainJWKConsensusConfig,
    vtxn: &ValidatorTransaction,
) -> bool {
    match vtxn {
        ValidatorTransaction::DKGResult(_) => randomness_config.randomness_enabled(),
        ValidatorTransaction::ObservedJWKUpdate(_) => jwk_consensus_config.jwk_consensus_enabled(),
    }
}
```

**File:** consensus/src/round_manager.rs (L1126-1137)
```rust
        if let Some(vtxns) = proposal.validator_txns() {
            for vtxn in vtxns {
                let vtxn_type_name = vtxn.type_name();
                ensure!(
                    is_vtxn_expected(&self.randomness_config, &self.jwk_consensus_config, vtxn),
                    "unexpected validator txn: {:?}",
                    vtxn_type_name
                );
                vtxn.verify(self.epoch_state.verifier.as_ref())
                    .context(format!("{} verify failed", vtxn_type_name))?;
            }
        }
```

**File:** crates/aptos-jwk-consensus/src/epoch_manager.rs (L177-197)
```rust
        let (jwk_manager_should_run, oidc_providers) = match jwk_consensus_config {
            Ok(config) => {
                let should_run =
                    config.jwk_consensus_enabled() && onchain_consensus_config.is_vtxn_enabled();
                let providers = config
                    .oidc_providers_cloned()
                    .into_iter()
                    .map(jwks::OIDCProvider::from)
                    .collect();
                (should_run, Some(SupportedOIDCProviders { providers }))
            },
            Err(_) => {
                //TODO: remove this case once the framework change of this commit is published.
                let should_run = features.is_enabled(FeatureFlag::JWK_CONSENSUS)
                    && onchain_consensus_config.is_vtxn_enabled();
                let providers = payload.get::<SupportedOIDCProviders>().ok();
                (should_run, providers)
            },
        };

        if jwk_manager_should_run && my_index.is_some() {
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager/mod.rs (L108-134)
```rust
        this.jwk_observers = oidc_providers
            .unwrap_or_default()
            .into_provider_vec()
            .into_iter()
            .filter_map(|provider| {
                let OIDCProvider { name, config_url } = provider;
                let maybe_issuer = String::from_utf8(name);
                let maybe_config_url = String::from_utf8(config_url);
                match (maybe_issuer, maybe_config_url) {
                    (Ok(issuer), Ok(config_url)) => Some(JWKObserver::spawn(
                        this.epoch_state.epoch,
                        this.my_addr,
                        issuer,
                        config_url,
                        Duration::from_secs(10),
                        local_observation_tx.clone(),
                    )),
                    (maybe_issuer, maybe_config_url) => {
                        warn!(
                            "unable to spawn observer, issuer={:?}, config_url={:?}",
                            maybe_issuer, maybe_config_url
                        );
                        None
                    },
                }
            })
            .collect();
```

**File:** aptos-move/vm-genesis/src/lib.rs (L354-363)
```rust
    let jwk_consensus_config = genesis_config
        .jwk_consensus_config_override
        .clone()
        .unwrap_or_else(OnChainJWKConsensusConfig::default_for_genesis);
    initialize_jwk_consensus_config(
        &mut session,
        &module_storage,
        &mut traversal_context,
        &jwk_consensus_config,
    );
```

**File:** types/src/validator_txn.rs (L45-52)
```rust
    pub fn verify(&self, verifier: &ValidatorVerifier) -> anyhow::Result<()> {
        match self {
            ValidatorTransaction::DKGResult(dkg_result) => dkg_result
                .verify(verifier)
                .context("DKGResult verification failed"),
            ValidatorTransaction::ObservedJWKUpdate(_) => Ok(()),
        }
    }
```

**File:** aptos-move/aptos-vm/src/keyless_validation.rs (L112-126)
```rust
fn get_jwk_for_authenticator(
    jwks: &AllProvidersJWKs,
    pk: &KeylessPublicKey,
    sig: &KeylessSignature,
) -> Result<JWK, VMStatus> {
    let jwt_header = sig
        .parse_jwt_header()
        .map_err(|_| invalid_signature!("Failed to parse JWT header"))?;

    let jwk_move_struct = jwks.get_jwk(&pk.iss_val, &jwt_header.kid).map_err(|_| {
        invalid_signature!(format!(
            "JWK for {} with KID {} was not found",
            pk.iss_val, jwt_header.kid
        ))
    })?;
```
