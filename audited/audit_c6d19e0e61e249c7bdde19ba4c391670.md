# Audit Report

## Title
Type Instantiation CPU Exhaustion via Unmetered Struct Field Expansion in Bytecode Verification

## Summary
The bytecode verifier performs type instantiation for all struct fields without proper metering in `type_fields_signature()`, allowing attackers to cause O(num_fields × type_complexity) CPU usage during module verification while only being charged for O(type_complexity) in complexity checks. This enables validator node slowdowns through maliciously crafted Move modules.

## Finding Description

The vulnerability exists in the bytecode verification pipeline, specifically in how generic struct instantiations are metered during the type safety verification pass.

Module verification is executed synchronously during transaction processing. [1](#0-0)  When a validator processes a module publishing transaction, it calls `verify_module_with_config`, which invokes `CodeUnitVerifier::verify_module` [2](#0-1) , which then calls `type_safety::verify` for each function [3](#0-2) .

During static complexity checking, `meter_struct_instantiation()` only meters the type parameters signature: [4](#0-3) 

However, during bytecode verification, when the verifier encounters a `PackGeneric` instruction, it charges for the type arguments via `charge_tys` [5](#0-4)  and then calls `pack()` which invokes `type_fields_signature()` [6](#0-5) .

The critical issue is at line 404 where the meter parameter is explicitly unused with a TODO comment indicating missing metering implementation: [7](#0-6) 

This function calls `instantiate()` recursively for each field: [8](#0-7) 

The `instantiate()` function recursively traverses the entire type tree: [9](#0-8) 

This performs O(type_depth) work per field, but this work is completely unmetered.

**Attack Path:**
1. Attacker creates a struct with the maximum allowed fields (255 per binary format limit [10](#0-9) ) with a generic type parameter
2. Production configuration allows unlimited fields: [11](#0-10) 
3. Attacker instantiates the struct with a deeply nested type (up to 20 levels in production [12](#0-11) )
4. During verification, the verifier charges only for the type parameters via `charge_tys`
5. But then performs 255 × 20 = 5,100 type node traversals without additional metering
6. This bypasses the `max_per_fun_meter_units` limit [13](#0-12)  intended to prevent excessive verification cost

## Impact Explanation

This vulnerability enables **High Severity** validator node slowdowns as defined in the Aptos bug bounty program category "Validator Node Slowdowns (High): Significant performance degradation affecting consensus, DoS through resource exhaustion."

An attacker can:
- Cause significant CPU exhaustion on all validators during module verification
- Delay block production and consensus progress by making verification slow
- Force validators to process malicious modules repeatedly if published in successive transactions
- Impact all validators simultaneously since all must verify published modules synchronously

The attack does not require validator privileges and can be executed by any account capable of publishing modules. The verification happens synchronously during transaction execution, directly impacting consensus performance.

## Likelihood Explanation

**High likelihood** - The attack is:
- **Easy to execute**: Simply publish a Move module with a struct containing 255 fields of generic type `T`, then instantiate it with a deeply nested type
- **Low cost**: Only requires gas for module publication
- **Guaranteed impact**: Every validator must verify the module during transaction execution
- **Repeatable**: Attacker can publish multiple such modules in successive transactions
- **Currently unmitigated**: The TODO comment at line 404 explicitly confirms metering is not implemented: [14](#0-13) 

The binary format explicitly allows up to 255 fields, and production configuration sets no limit on struct field count, making this attack fully viable in production.

## Recommendation

Implement proper metering in `type_fields_signature()` by removing the underscore prefix from the `_meter` parameter and adding metering for each field instantiation:

```rust
fn type_fields_signature(
    verifier: &mut TypeSafetyChecker,
    meter: &mut impl Meter,  // Remove underscore
    offset: CodeOffset,
    struct_def: &StructDefinition,
    variant: Option<VariantIndex>,
    type_args: &Signature,
) -> PartialVMResult<Signature> {
    match (&struct_def.field_information, variant) {
        (StructFieldInformation::Declared(fields), None) => {
            let instantiated_fields: Vec<SignatureToken> = fields
                .iter()
                .map(|field_def| {
                    let instantiated = instantiate(&field_def.signature.0, type_args);
                    // Add metering for each instantiated field
                    verifier.charge_ty(meter, &instantiated)?;
                    Ok(instantiated)
                })
                .collect::<PartialVMResult<Vec<_>>>()?;
            Ok(Signature(instantiated_fields))
        },
        // Similar fix for variant case...
    }
}
```

## Proof of Concept

A proof of concept would create a Move module with the following structure:

```move
module attacker::exploit {
    struct MaliciousStruct<T> has drop {
        field_000: T, field_001: T, field_002: T, /* ... 252 more fields ... */
        field_254: T
    }
    
    public fun exploit() {
        // Instantiate with deeply nested type
        let _ = MaliciousStruct<vector<vector<vector<vector<vector<
                vector<vector<vector<vector<vector<
                vector<vector<vector<vector<vector<
                vector<vector<vector<vector<u64>>>>>>>>>>>>>>>>>>>> {
            field_000: /* initialize all 255 fields */
        };
    }
}
```

When this module is published, during verification of the `PackGeneric` instruction, the verifier will:
1. Charge TYPE_NODE_COST (30) × 20 nodes = 600 units for the type arguments
2. Call `type_fields_signature()` which instantiates all 255 fields without metering
3. Perform 255 × 20 = 5,100 unmetered type node traversals
4. This bypasses the intended meter limit while consuming significant CPU time on all validators

## Notes

The vulnerability is confirmed by the explicit TODO comment at line 404 of `type_safety.rs` acknowledging that metering should be implemented but currently is not. The underscore prefix on `_meter` indicates the parameter is intentionally unused. This represents a known gap in the verification metering logic that can be exploited for validator DoS attacks.

### Citations

**File:** third_party/move/move-bytecode-verifier/src/verifier.rs (L134-173)
```rust
pub fn verify_module_with_config(config: &VerifierConfig, module: &CompiledModule) -> VMResult<()> {
    if config.verify_nothing() {
        return Ok(());
    }
    let prev_state = move_core_types::state::set_state(VMState::VERIFIER);
    let result = std::panic::catch_unwind(|| {
        // Always needs to run bound checker first as subsequent passes depend on it
        BoundsChecker::verify_module(module).map_err(|e| {
            // We can't point the error at the module, because if bounds-checking
            // failed, we cannot safely index into module's handle to itself.
            e.finish(Location::Undefined)
        })?;
        FeatureVerifier::verify_module(config, module)?;
        LimitsVerifier::verify_module(config, module)?;
        DuplicationChecker::verify_module(module)?;

        signature_v2::verify_module(config, module)?;

        InstructionConsistency::verify_module(module)?;
        constants::verify_module(module)?;
        friends::verify_module(module)?;

        RecursiveStructDefChecker::verify_module(module)?;
        InstantiationLoopChecker::verify_module(module)?;
        CodeUnitVerifier::verify_module(config, module)?;

        // Add the failpoint injection to test the catch_unwind behavior.
        fail::fail_point!("verifier-failpoint-panic");

        script_signature::verify_module(module, no_additional_script_signature_checks)
    })
    .unwrap_or_else(|_| {
        Err(
            PartialVMError::new(StatusCode::VERIFIER_INVARIANT_VIOLATION)
                .finish(Location::Undefined),
        )
    });
    move_core_types::state::set_state(prev_state);
    result
}
```

**File:** third_party/move/move-bytecode-verifier/src/code_unit_verifier.rs (L185-185)
```rust
        type_safety::verify(&self.resolver, &self.function_view, meter)?;
```

**File:** third_party/move/move-binary-format/src/check_complexity.rs (L126-137)
```rust
    fn meter_struct_instantiation(
        &self,
        struct_inst_idx: StructDefInstantiationIndex,
    ) -> PartialVMResult<()> {
        let struct_insts = self.resolver.struct_instantiations().ok_or_else(|| {
            PartialVMError::new(StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR)
                .with_message("Can't get struct instantiations -- not a module.".to_string())
        })?;
        let struct_inst = safe_get_table(struct_insts, struct_inst_idx.0)?;

        self.meter_signature(struct_inst.type_parameters)
    }
```

**File:** third_party/move/move-bytecode-verifier/src/type_safety.rs (L402-409)
```rust
fn type_fields_signature(
    verifier: &mut TypeSafetyChecker,
    _meter: &mut impl Meter, // TODO: metering
    offset: CodeOffset,
    struct_def: &StructDefinition,
    variant: Option<VariantIndex>,
    type_args: &Signature,
) -> PartialVMResult<Signature> {
```

**File:** third_party/move/move-bytecode-verifier/src/type_safety.rs (L410-426)
```rust
    match (&struct_def.field_information, variant) {
        (StructFieldInformation::Declared(fields), None) => Ok(Signature(
            fields
                .iter()
                .map(|field_def| instantiate(&field_def.signature.0, type_args))
                .collect(),
        )),
        (StructFieldInformation::DeclaredVariants(variants), Some(variant))
            if (variant as usize) < variants.len() =>
        {
            Ok(Signature(
                variants[variant as usize]
                    .fields
                    .iter()
                    .map(|field_def| instantiate(&field_def.signature.0, type_args))
                    .collect(),
            ))
```

**File:** third_party/move/move-bytecode-verifier/src/type_safety.rs (L435-455)
```rust
fn pack(
    verifier: &mut TypeSafetyChecker,
    meter: &mut impl Meter,
    offset: CodeOffset,
    struct_def: &StructDefinition,
    variant: Option<VariantIndex>,
    type_args: &Signature,
) -> PartialVMResult<()> {
    let struct_type = materialize_type(struct_def.struct_handle, type_args);
    let field_sig = type_fields_signature(verifier, meter, offset, struct_def, variant, type_args)?;
    for sig in field_sig.0.iter().rev() {
        let arg = safe_unwrap!(verifier.stack.pop());
        // For field signature to argument, use assignability
        if !sig.is_assignable_from(&arg) {
            return Err(verifier.error(StatusCode::PACK_TYPE_MISMATCH_ERROR, offset));
        }
    }

    verifier.push(meter, struct_type)?;
    Ok(())
}
```

**File:** third_party/move/move-bytecode-verifier/src/type_safety.rs (L890-896)
```rust
        Bytecode::PackGeneric(idx) => {
            let struct_inst = verifier.resolver.struct_instantiation_at(*idx)?;
            let struct_def = verifier.resolver.struct_def_at(struct_inst.def)?;
            let type_args = verifier.resolver.signature_at(struct_inst.type_parameters);
            verifier.charge_tys(meter, &type_args.0)?;
            pack(verifier, meter, offset, struct_def, None, type_args)?
        },
```

**File:** third_party/move/move-bytecode-verifier/src/type_safety.rs (L1348-1389)
```rust
fn instantiate(token: &SignatureToken, subst: &Signature) -> SignatureToken {
    use SignatureToken::*;

    if subst.0.is_empty() {
        return token.clone();
    }

    let inst_vec = |v: &[SignatureToken]| -> Vec<SignatureToken> {
        v.iter().map(|ty| instantiate(ty, subst)).collect()
    };
    match token {
        Bool => Bool,
        U8 => U8,
        U16 => U16,
        U32 => U32,
        U64 => U64,
        U128 => U128,
        U256 => U256,
        I8 => I8,
        I16 => I16,
        I32 => I32,
        I64 => I64,
        I128 => I128,
        I256 => I256,
        Address => Address,
        Signer => Signer,
        Vector(ty) => Vector(Box::new(instantiate(ty, subst))),
        Function(args, result, abilities) => Function(inst_vec(args), inst_vec(result), *abilities),
        Struct(idx) => Struct(*idx),
        StructInstantiation(idx, struct_type_args) => {
            StructInstantiation(*idx, inst_vec(struct_type_args))
        },
        Reference(ty) => Reference(Box::new(instantiate(ty, subst))),
        MutableReference(ty) => MutableReference(Box::new(instantiate(ty, subst))),
        TypeParameter(idx) => {
            // Assume that the caller has previously parsed and verified the structure of the
            // file and that this guarantees that type parameter indices are always in bounds.
            debug_assert!((*idx as usize) < subst.len());
            subst.0[*idx as usize].clone()
        },
    }
}
```

**File:** third_party/move/move-binary-format/src/file_format_common.rs (L78-78)
```rust
pub const FIELD_COUNT_MAX: u64 = 255;
```

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L170-170)
```rust
        max_fields_in_struct: None,
```

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L175-175)
```rust
        max_per_fun_meter_units: Some(1000 * 80000),
```

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L188-192)
```rust
        max_type_depth: if enable_function_values {
            Some(20)
        } else {
            None
        },
```
