# Audit Report

## Title
Unmetered Multi-Agent Transaction Prologue Validation Enables Resource Exhaustion Attack

## Summary
Multi-agent transactions with excessive secondary signers (up to 31) bypass gas accounting for expensive prologue validation work. The `transaction_context::secondary_signers()` per-signer cost of 576 gas units only applies when the function is called during execution, while the actual validation work in the prologue (storage reads, authentication key verification) is performed with an `UnmeteredGasMeter`, allowing attackers to cause disproportionate computational load without corresponding gas payment.

## Finding Description
The vulnerability exists in the multi-agent transaction validation flow where prologue validation work is not metered against the transaction's gas budget. [1](#0-0) 

The gas parameter `transaction_context_secondary_signers_per_signer` is set to 576 gas units. However, this cost is only charged when `transaction_context::secondary_signers()` is explicitly called during transaction execution: [2](#0-1) 

The critical issue occurs in the prologue validation phase, which runs with an `UnmeteredGasMeter`: [3](#0-2) 

The `multi_agent_common_prologue` function loops through all secondary signers performing expensive operations without gas charges: [4](#0-3) 

Each iteration performs:
1. `account::exists_at()` - storage read
2. `account::get_authentication_key()` - storage read  
3. Authentication key comparison

The only limit is the signature count, not the number of secondary signers: [5](#0-4) 

With `MAX_NUM_OF_SIGS = 32`, an attacker can include up to 31 secondary signers (each with single Ed25519 signatures), causing:
- 31+ unmetered storage reads in prologue
- 32 signature verifications (pre-VM execution, also unmetered)
- Minimal gas payment if transaction payload doesn't call `secondary_signers()`

**Attack Path:**
1. Attacker creates transaction with 31 secondary signers
2. Transaction payload performs minimal work (doesn't call `secondary_signers()`)
3. Pre-execution: 32 Ed25519 signature verifications (~30M gas worth of computation) - unmetered
4. Prologue: 31+ storage reads for validation - unmetered (UnmeteredGasMeter)
5. Execution: Minimal gas consumed by simple payload
6. Transaction costs minimal fees despite causing expensive validation work

## Impact Explanation
This qualifies as **Medium Severity** based on validator node slowdowns and resource exhaustion. An attacker can submit multiple such transactions to cause:

- **Validator Performance Degradation**: Each transaction forces validators to perform ~30M gas units worth of signature verification plus 31+ storage reads, while paying minimal execution gas
- **Mempool Congestion**: Transactions appear valid and inexpensive until execution, making mempool filtering difficult
- **State Inconsistencies**: If validators selectively reject such transactions due to resource constraints, network partitioning could occur

The attack violates **Invariant #9**: "Resource Limits: All operations must respect gas, storage, and computational limits" - prologue operations bypass gas accounting entirely.

## Likelihood Explanation
**High Likelihood:**
- Attack requires no special privileges
- Multi-agent transactions are standard Aptos functionality
- Maximum 31 secondary signers is within `MAX_NUM_OF_SIGS` limit
- Transaction construction is straightforward
- No consensus required for individual attack transactions
- Attacker cost is minimal (only execution gas, not validation gas)

## Recommendation
Implement one or more mitigations:

1. **Add per-secondary-signer intrinsic gas cost**: Charge intrinsic gas at transaction submission proportional to secondary signer count, before prologue execution.

2. **Enforce stricter limit on secondary signers**: Add explicit `MAX_SECONDARY_SIGNERS` constant (e.g., 8-10) separate from `MAX_NUM_OF_SIGS`.

3. **Meter prologue storage operations**: Track prologue storage reads and charge them against transaction gas budget post-execution.

**Recommended Fix (Option 2 - Simplest):**
```rust
// In types/src/transaction/authenticator.rs
pub const MAX_NUM_OF_SIGS: usize = 32;
pub const MAX_SECONDARY_SIGNERS: usize = 10;  // New limit

// In verify() method, add:
let num_secondary_signers = self.secondary_signers().len();
if num_secondary_signers > MAX_SECONDARY_SIGNERS {
    return Err(Error::new(AuthenticationError::TooManySecondarySigners));
}
```

## Proof of Concept
```rust
// Rust test demonstrating the vulnerability
#[test]
fn test_excessive_secondary_signers_resource_exhaustion() {
    let mut executor = FakeExecutor::from_head_genesis();
    
    // Create sender and 31 secondary signers
    let sender = executor.create_raw_account_data(1_000_000, 0);
    executor.add_account_data(&sender);
    
    let mut secondary_signers = vec![];
    let mut secondary_keys = vec![];
    let mut secondary_pubkeys = vec![];
    
    for _ in 0..31 {  // Maximum within MAX_NUM_OF_SIGS limit
        let account = executor.create_raw_account_data(100_000, 0);
        executor.add_account_data(&account);
        secondary_signers.push(*account.address());
        secondary_keys.push(&account.account().privkey);
        secondary_pubkeys.push(account.account().pubkey.as_ed25519().unwrap());
    }
    
    // Create simple transaction that doesn't call secondary_signers()
    let payload = aptos_stdlib::aptos_coin_transfer(*sender.address(), 1);
    
    let signed_txn = transaction_test_helpers::get_test_unchecked_multi_agent_txn(
        *sender.address(),
        secondary_signers,
        0,
        &sender.account().privkey,
        sender.account().pubkey.as_ed25519().unwrap(),
        secondary_keys,
        secondary_pubkeys,
        Some(payload),
    );
    
    // Transaction executes successfully with minimal gas cost
    // despite causing 31+ storage reads in unmetered prologue
    let output = executor.execute_transaction(signed_txn);
    assert!(matches!(output.status(), TransactionStatus::Keep(ExecutionStatus::Success)));
    
    // Gas cost is minimal (doesn't reflect prologue validation work)
    let gas_used = output.gas_used();
    println!("Gas charged: {}, but caused 31+ unmetered storage reads", gas_used);
}
```

**Notes**
- The vulnerability is confirmed in RELEASE_V1_12 onward when transaction context extension was introduced
- Current implementation prioritizes user experience over DoS protection by making prologue validation cheap
- Similar issues may exist in other unmetered validation paths
- Production impact depends on mempool configuration and validator hardware capabilities

### Citations

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/aptos_framework.rs (L308-310)
```rust
        [transaction_context_sender_base: InternalGas, {RELEASE_V1_12.. => "transaction_context.sender.base"}, 735],
        [transaction_context_secondary_signers_base: InternalGas, {RELEASE_V1_12.. => "transaction_context.secondary_signers.base"}, 735],
        [transaction_context_secondary_signers_per_signer: InternalGasPerArg, {RELEASE_V1_12.. => "transaction_context.secondary_signers.per_signer"}, 576], // 18 * 32
```

**File:** aptos-move/framework/src/natives/transaction_context.rs (L290-310)
```rust
fn native_secondary_signers_internal(
    context: &mut SafeNativeContext,
    _ty_args: &[Type],
    _args: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    context.charge(TRANSACTION_CONTEXT_SECONDARY_SIGNERS_BASE)?;

    let user_transaction_context_opt = get_user_transaction_context_opt_from_context(context);
    if let Some(transaction_context) = user_transaction_context_opt {
        let secondary_signers = transaction_context.secondary_signers();
        context.charge(
            TRANSACTION_CONTEXT_SECONDARY_SIGNERS_PER_SIGNER
                * NumArgs::new(secondary_signers.len() as u64),
        )?;
        Ok(smallvec![Value::vector_address(secondary_signers)])
    } else {
        Err(SafeNativeError::Abort {
            abort_code: error::invalid_state(abort_codes::ETRANSACTION_CONTEXT_NOT_AVAILABLE),
        })
    }
}
```

**File:** aptos-move/aptos-vm/src/transaction_validation.rs (L115-124)
```rust
    is_simulation: bool,
) -> Result<(), VMStatus> {
    let txn_replay_protector = txn_data.replay_protector();
    let txn_authentication_key = txn_data.authentication_proof().optional_auth_key();
    let txn_gas_price = txn_data.gas_unit_price();
    let txn_max_gas_units = txn_data.max_gas_amount();
    let txn_expiration_timestamp_secs = txn_data.expiration_timestamp_secs();
    let chain_id = txn_data.chain_id();
    let mut gas_meter = UnmeteredGasMeter;

```

**File:** aptos-move/framework/aptos-framework/sources/transaction_validation.move (L380-438)
```text
    fun multi_agent_common_prologue(
        secondary_signer_addresses: vector<address>,
        secondary_signer_public_key_hashes: vector<Option<vector<u8>>>,
        is_simulation: bool,
    ) {
        let num_secondary_signers = vector::length(&secondary_signer_addresses);
        assert!(
            vector::length(&secondary_signer_public_key_hashes) == num_secondary_signers,
            error::invalid_argument(PROLOGUE_ESECONDARY_KEYS_ADDRESSES_COUNT_MISMATCH),
        );

        let i = 0;
        while ({
            // spec {
            //     invariant i <= num_secondary_signers;
            //     invariant forall j in 0..i:
            //         account::exists_at(secondary_signer_addresses[j]);
            //     invariant forall j in 0..i:
            //         secondary_signer_public_key_hashes[j] == account::get_authentication_key(secondary_signer_addresses[j]) ||
            //             (features::spec_simulation_enhancement_enabled() && is_simulation && vector::is_empty(secondary_signer_public_key_hashes[j]));
            //         account::account_resource_exists_at(secondary_signer_addresses[j])
            //         && secondary_signer_public_key_hashes[j]
            //             == account::get_authentication_key(secondary_signer_addresses[j])
            //             || features::account_abstraction_enabled() && account_abstraction::using_native_authenticator(
            //             secondary_signer_addresses[j]
            //         ) && option::spec_some(secondary_signer_public_key_hashes[j]) == account_abstraction::native_authenticator(
            //         account::exists_at(secondary_signer_addresses[j])
            //         && secondary_signer_public_key_hashes[j]
            //             == account::spec_get_authentication_key(secondary_signer_addresses[j])
            //             || features::spec_account_abstraction_enabled() && account_abstraction::using_native_authenticator(
            //             secondary_signer_addresses[j]
            //         ) && option::spec_some(
            //             secondary_signer_public_key_hashes[j]
            //         ) == account_abstraction::spec_native_authenticator(
            //             secondary_signer_addresses[j]
            //         );
            // };
            (i < num_secondary_signers)
        }) {
            let secondary_address = *vector::borrow(&secondary_signer_addresses, i);
            assert!(account::exists_at(secondary_address), error::invalid_argument(PROLOGUE_EACCOUNT_DOES_NOT_EXIST));
            let signer_public_key_hash = *vector::borrow(&secondary_signer_public_key_hashes, i);
            if (!skip_auth_key_check(is_simulation, &signer_public_key_hash)) {
                if (option::is_some(&signer_public_key_hash)) {
                    assert!(
                        signer_public_key_hash == option::some(account::get_authentication_key(secondary_address)),
                        error::invalid_argument(PROLOGUE_EINVALID_ACCOUNT_AUTH_KEY)
                    );
                } else {
                    assert!(
                        allow_missing_txn_authentication_key(secondary_address),
                        error::invalid_argument(PROLOGUE_EINVALID_ACCOUNT_AUTH_KEY)
                    )
                };
            };

            i = i + 1;
        }
    }
```

**File:** types/src/transaction/authenticator.rs (L32-34)
```rust
/// Maximum number of signatures supported in `TransactionAuthenticator`,
/// across all `AccountAuthenticator`s included.
pub const MAX_NUM_OF_SIGS: usize = 32;
```
