# Audit Report

## Title
No Emergency Circuit Breaker for Code Publishing - Missing Critical Incident Response Capability

## Summary
The Aptos blockchain lacks an emergency mechanism to immediately halt code publishing during active attacks. If a vulnerability is discovered in the bytecode verifier or module validation logic, malicious actors can continue deploying exploit code while governance proposals take days to execute, creating an extended exploitation window.

## Finding Description

The code publishing system in Aptos has no emergency stop mechanism. The current flow is:

1. **Code Publishing Path**: [1](#0-0) 

2. **Native Request Processing**: [2](#0-1) 

3. **VM Validation**: [3](#0-2) 

**Current Control Mechanisms:**

- **Permissioned Signer System**: Only checks individual account permissions, no global disable: [4](#0-3) 

- **Governance Feature Flags**: Can toggle features but require voting periods (days): [5](#0-4) 

- **Feature Flag System**: No specific "DISABLE_CODE_PUBLISHING" flag exists: [6](#0-5) 

**What's Missing:**

Unlike Diem's emergency halt mechanism: [7](#0-6) 

Aptos has **no equivalent** emergency stop for code publishing.

**Attack Scenario:**
1. Security researcher discovers bytecode verifier bypass
2. Malicious actors exploit vulnerability to deploy malicious modules
3. Governance proposal created to disable code publishing
4. Voting period requires multiple days per governance config: [8](#0-7) 
5. Attackers continue deploying exploit code during entire voting period
6. Potential for consensus violations, state corruption, or network compromise

## Impact Explanation

**HIGH Severity** - Significant protocol violations and extended exploitation windows:

- **Amplifies Impact**: Any bytecode validation vulnerability becomes more severe due to inability to quickly mitigate
- **Consensus Risk**: Malicious modules could exploit VM bugs causing non-deterministic execution
- **State Corruption**: Extended time window allows wider deployment of malicious code
- **Governance Delay**: Multi-day voting period during active attack is unacceptable for critical infrastructure

This qualifies as HIGH severity under "Significant protocol violations" as it represents a critical gap in the platform's incident response capabilities.

## Likelihood Explanation

**HIGH Likelihood of Needing Emergency Response:**

- Complex bytecode verification logic is vulnerability-prone
- History of VM exploits in blockchain systems (Ethereum, Solana)
- Move VM is relatively new with evolving validation rules
- No defense-in-depth if primary validation fails

**Moderate Likelihood of Exploitation Given Vulnerability:**
- Requires discovering bytecode validation bypass
- But once found, extended exploitation window is guaranteed
- No immediate mitigation available

## Recommendation

Implement a multi-layered emergency response system:

**1. Add Emergency Feature Flag:**
```move
// In features.move
const CODE_PUBLISHING_DISABLED: u64 = [NEXT_FLAG_NUMBER];

public fun code_publishing_disabled(): bool acquires Features {
    is_enabled(CODE_PUBLISHING_DISABLED)
}
```

**2. Add Emergency Check in code.move:**
```move
public fun publish_package(owner: &signer, pack: PackageMetadata, code: vector<vector<u8>>) acquires PackageRegistry {
    // Emergency circuit breaker check
    assert!(
        !features::code_publishing_disabled(),
        error::unavailable(ECODE_PUBLISHING_DISABLED)
    );
    
    check_code_publishing_permission(owner);
    // ... rest of function
}
```

**3. Add Fast-Track Emergency Governance:**
```move
// In aptos_governance.move
public entry fun emergency_disable_code_publishing(aptos_framework: &signer) {
    system_addresses::assert_aptos_framework(aptos_framework);
    features::change_feature_flags_for_next_epoch(
        aptos_framework, 
        vector[features::get_code_publishing_disabled_flag()], 
        vector[]
    );
    reconfigure(aptos_framework);
}
```

## Proof of Concept

The vulnerability cannot be demonstrated in isolation as it requires an actual bytecode validation bypass to show concrete harm. However, the absence of the emergency mechanism can be verified:

```move
#[test]
fun test_no_emergency_stop_exists() {
    // This test demonstrates that code publishing cannot be emergency-stopped
    // 1. Feature flag for disabling code publishing does not exist
    // 2. No function to immediately halt code publishing
    // 3. Governance requires multi-day voting period
    
    // Expected: Should have features::code_publishing_disabled() check
    // Actual: No such check exists in publish_package
}
```

**Notes:**
- This is a systemic security architecture gap
- Violates defense-in-depth principles for critical infrastructure  
- Increases blast radius of any code publishing vulnerabilities
- Response time measured in days rather than minutes is unacceptable for blockchain security

The lack of emergency response capability is a **significant protocol-level security gap** that should be addressed to protect against time-critical code publishing exploits.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/code.move (L117-122)
```text
    public(friend) fun check_code_publishing_permission(s: &signer) {
        assert!(
            permissioned_signer::check_permission_exists(s, CodePublishingPermission {}),
            error::permission_denied(ENO_CODE_PERMISSION),
        );
    }
```

**File:** aptos-move/framework/aptos-framework/sources/code.move (L168-228)
```text
    public fun publish_package(owner: &signer, pack: PackageMetadata, code: vector<vector<u8>>) acquires PackageRegistry {
        check_code_publishing_permission(owner);
        // Disallow incompatible upgrade mode. Governance can decide later if this should be reconsidered.
        assert!(
            pack.upgrade_policy.policy > upgrade_policy_arbitrary().policy,
            error::invalid_argument(EINCOMPATIBLE_POLICY_DISABLED),
        );

        let addr = signer::address_of(owner);
        if (!exists<PackageRegistry>(addr)) {
            move_to(owner, PackageRegistry { packages: vector::empty() })
        };

        // Checks for valid dependencies to other packages
        let allowed_deps = check_dependencies(addr, &pack);

        // Check package against conflicts
        // To avoid prover compiler error on spec
        // the package need to be an immutable variable
        let module_names = get_module_names(&pack);
        let package_immutable = &borrow_global<PackageRegistry>(addr).packages;
        let len = vector::length(package_immutable);
        let index = len;
        let upgrade_number = 0;
        vector::enumerate_ref(package_immutable
        , |i, old| {
            let old: &PackageMetadata = old;
            if (old.name == pack.name) {
                upgrade_number = old.upgrade_number + 1;
                check_upgradability(old, &pack, &module_names);
                index = i;
            } else {
                check_coexistence(old, &module_names)
            };
        });

        // Assign the upgrade counter.
        pack.upgrade_number = upgrade_number;

        let packages = &mut borrow_global_mut<PackageRegistry>(addr).packages;
        // Update registry
        let policy = pack.upgrade_policy;
        if (index < len) {
            *vector::borrow_mut(packages, index) = pack
        } else {
            vector::push_back(packages, pack)
        };

        event::emit(PublishPackage {
            code_address: addr,
            is_upgrade: upgrade_number > 0
        });

        // Request publish
        if (features::code_dependency_check_enabled())
            request_publish_with_allowed_deps(addr, module_names, allowed_deps, code, policy.policy)
        else
        // The new `request_publish_with_allowed_deps` has not yet rolled out, so call downwards
        // compatible code.
            request_publish(addr, module_names, code, policy.policy)
    }
```

**File:** aptos-move/framework/src/natives/code.rs (L284-362)
```rust
fn native_request_publish(
    context: &mut SafeNativeContext,
    _ty_args: &[Type],
    mut args: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    debug_assert!(matches!(args.len(), 4 | 5));
    let with_allowed_deps = args.len() == 5;

    context.charge(CODE_REQUEST_PUBLISH_BASE)?;

    let policy = safely_pop_arg!(args, u8);
    let mut code = vec![];
    for module in safely_pop_arg!(args, Vec<Value>) {
        let module_code = module.value_as::<Vec<u8>>()?;

        context.charge(CODE_REQUEST_PUBLISH_PER_BYTE * NumBytes::new(module_code.len() as u64))?;
        code.push(module_code);
    }

    let allowed_deps = if with_allowed_deps {
        let mut allowed_deps: BTreeMap<AccountAddress, BTreeSet<String>> = BTreeMap::new();

        for dep in safely_pop_arg!(args, Vec<Value>) {
            let (account, module_name) = unpack_allowed_dep(dep)?;

            let entry = allowed_deps.entry(account);

            if let Entry::Vacant(_) = &entry {
                // TODO: Is the 32 here supposed to indicate the length of an account address in bytes?
                context.charge(CODE_REQUEST_PUBLISH_PER_BYTE * NumBytes::new(32))?;
            }

            context
                .charge(CODE_REQUEST_PUBLISH_PER_BYTE * NumBytes::new(module_name.len() as u64))?;
            entry.or_default().insert(module_name);
        }

        Some(allowed_deps)
    } else {
        None
    };

    let mut expected_modules = BTreeSet::new();
    for name in safely_pop_arg!(args, Vec<Value>) {
        let str = get_move_string(name)?;

        // TODO(Gas): fine tune the gas formula
        context.charge(CODE_REQUEST_PUBLISH_PER_BYTE * NumBytes::new(str.len() as u64))?;
        expected_modules.insert(str);
    }

    let destination = safely_pop_arg!(args, AccountAddress);

    // Add own modules to allowed deps
    let allowed_deps = allowed_deps.map(|mut allowed| {
        allowed
            .entry(destination)
            .or_default()
            .extend(expected_modules.clone());
        allowed
    });

    let code_context = context.extensions_mut().get_mut::<NativeCodeContext>();
    if code_context.requested_module_bundle.is_some() || !code_context.enabled {
        // Can't request second time or if publish requests are not allowed.
        return Err(SafeNativeError::Abort {
            abort_code: EALREADY_REQUESTED,
        });
    }
    code_context.requested_module_bundle = Some(PublishRequest {
        destination,
        bundle: ModuleBundle::new(code),
        expected_modules,
        allowed_deps,
        check_compat: policy != ARBITRARY_POLICY,
    });

    Ok(smallvec![])
}
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1680-1739)
```rust
    fn validate_publish_request(
        &self,
        module_storage: &impl AptosModuleStorage,
        traversal_context: &mut TraversalContext,
        gas_meter: &mut impl GasMeter,
        modules: &[CompiledModule],
        mut expected_modules: BTreeSet<String>,
        allowed_deps: Option<BTreeMap<AccountAddress, BTreeSet<String>>>,
    ) -> VMResult<()> {
        self.reject_unstable_bytecode(modules)?;
        native_validation::validate_module_natives(modules)?;

        for m in modules {
            if !expected_modules.remove(m.self_id().name().as_str()) {
                return Err(Self::metadata_validation_error(&format!(
                    "unregistered module: '{}'",
                    m.self_id().name()
                )));
            }
            if let Some(allowed) = &allowed_deps {
                for dep in m.immediate_dependencies() {
                    if !allowed
                        .get(dep.address())
                        .map(|modules| {
                            modules.contains("") || modules.contains(dep.name().as_str())
                        })
                        .unwrap_or(false)
                    {
                        return Err(Self::metadata_validation_error(&format!(
                            "unregistered dependency: '{}'",
                            dep
                        )));
                    }
                }
            }
            verify_module_metadata_for_module_publishing(m, self.features())
                .map_err(|err| Self::metadata_validation_error(&err.to_string()))?;
        }

        resource_groups::validate_resource_groups(
            self.features(),
            module_storage,
            traversal_context,
            gas_meter,
            modules,
        )?;
        event_validation::validate_module_events(
            self.features(),
            module_storage,
            traversal_context,
            modules,
        )?;

        if !expected_modules.is_empty() {
            return Err(Self::metadata_validation_error(
                "not all registered modules published",
            ));
        }
        Ok(())
    }
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L87-91)
```text
    struct GovernanceConfig has key {
        min_voting_threshold: u128,
        required_proposer_stake: u64,
        voting_duration_secs: u64,
    }
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L714-718)
```text
    public fun toggle_features(aptos_framework: &signer, enable: vector<u64>, disable: vector<u64>) {
        system_addresses::assert_aptos_framework(aptos_framework);
        features::change_feature_flags_for_next_epoch(aptos_framework, enable, disable);
        reconfigure(aptos_framework);
    }
```

**File:** aptos-move/framework/move-stdlib/sources/configs/features.move (L36-45)
```text
    // Code Publishing

    /// Whether validation of package dependencies is enabled, and the related native function is
    /// available. This is needed because of introduction of a new native function.
    /// Lifetime: transient
    const CODE_DEPENDENCY_CHECK: u64 = 1;

    public fun code_dependency_check_enabled(): bool acquires Features {
        is_enabled(CODE_DEPENDENCY_CHECK)
    }
```

**File:** third_party/move/move-examples/diem-framework/move-packages/DPN/sources/DiemTransactionPublishingOption.move (L132-156)
```text
    public fun halt_all_transactions(dr_account: &signer) {
        Roles::assert_diem_root(dr_account);
        assert!(
            !exists<HaltAllTransactions>(signer::address_of(dr_account)),
            errors::already_published(EHALT_ALL_TRANSACTIONS),
        );
        move_to(dr_account, HaltAllTransactions {});
    }

    /// If called, transactions can be sent from any account once again
    public fun resume_transactions(dr_account: &signer) acquires HaltAllTransactions {
        Roles::assert_diem_root(dr_account);
        let dr_address = signer::address_of(dr_account);
        assert!(
            exists<HaltAllTransactions>(dr_address),
            errors::already_published(EHALT_ALL_TRANSACTIONS),
        );

        let HaltAllTransactions {} = move_from<HaltAllTransactions>(dr_address);
    }

    /// Return true if all non-administrative transactions are currently halted
    fun transactions_halted(): bool {
        exists<HaltAllTransactions>(@DiemRoot)
    }
```
