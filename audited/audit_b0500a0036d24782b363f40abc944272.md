# Audit Report

## Title
Missing Validation for `num_main_signer_accounts` Parameter Causes Multiple Panic Scenarios in Executor Benchmark

## Summary
The `run_benchmark()` function in the executor-benchmark module does not validate that `num_main_signer_accounts` is greater than zero before using it. When set to 0 via the command-line argument `--main-signer-accounts=0`, the benchmark crashes with panics in multiple code paths due to division by zero equivalent operations and empty range sampling attempts.

## Finding Description
The `run_benchmark()` function accepts `num_main_signer_accounts` as a `usize` parameter without any validation to ensure it is non-zero. [1](#0-0)  This parameter is passed directly from the command-line interface without bounds checking. [2](#0-1) [3](#0-2) 

When `num_main_signer_accounts` is set to 0, the account cache is split at index 0, resulting in an empty `main_signer_accounts` vector. [4](#0-3) [5](#0-4) 

This empty account pool triggers panics in three different workload execution paths:

**1. Hotspot Probability Mode**: When executing transfers with hotspot probability, the `get_random_with_hotspot_transfer_indices()` function retrieves the account count which becomes 0. [6](#0-5)  This zero value is then passed to `rand_with_hotspot()`, which calls `rng.gen_range(0, 0)` - an empty range that causes a panic. [7](#0-6) 

**2. Random Transfer Mode**: When using random transfers with transactions per sender, `get_random_transfer_batch()` attempts to sample `batch_size + 1` items from an empty account pool, causing `rand::seq::index::sample` to panic. [8](#0-7) 

**3. Connected Transaction Groups Mode**: When using connected transaction groups, `get_conflicting_grps_transfer_indices()` performs division by `conflicting_tx_grps` and validates that `num_signer_accounts > 2 * conflicting_tx_grps`. With `num_signer_accounts = 0`, this validation check triggers an explicit panic. [9](#0-8) 

## Impact Explanation
This vulnerability has **Medium** severity impact on the benchmarking and testing infrastructure:

- **Development Infrastructure Disruption**: The executor-benchmark tool is critical for performance testing, regression detection, and capacity planning. Crashes prevent these essential development activities.
- **CI/CD Pipeline Failures**: Automated benchmarking in continuous integration pipelines can be disrupted if malicious or misconfigured parameters are injected.
- **Resource Waste**: Benchmark runs consume significant computational resources. Crashes after lengthy setup phases waste these resources.

While this does not directly affect production validators, consensus, or funds, it degrades the development and testing infrastructure that ensures blockchain quality and performance. This aligns with Medium severity: "State inconsistencies requiring intervention" - in this case, intervention in the development workflow.

## Likelihood Explanation
The likelihood is **High**:

- **Easy to Trigger**: The parameter is exposed directly via command-line with no validation, making it trivial to trigger accidentally or intentionally.
- **No Guards**: There are no defensive checks at any layer - command-line parsing, function entry, or usage sites.
- **Multiple Failure Points**: The bug manifests across multiple code paths, increasing the probability of encounter.
- **Automation Risk**: Automated scripts or configuration files with incorrect values could repeatedly trigger this issue.

## Recommendation
Add validation at the entry point of `run_benchmark()` to ensure `num_main_signer_accounts > 0`:

```rust
pub fn run_benchmark<V>(
    block_size: usize,
    num_blocks: usize,
    workload: BenchmarkWorkload,
    mut transactions_per_sender: usize,
    num_main_signer_accounts: usize,
    num_additional_dst_pool_accounts: usize,
    source_dir: impl AsRef<Path>,
    checkpoint_dir: impl AsRef<Path>,
    verify_sequence_numbers: bool,
    storage_test_config: StorageTestConfig,
    pipeline_config: PipelineConfig,
    init_features: Features,
    is_keyless: bool,
) -> SingleRunResults
where
    V: VMBlockExecutor + 'static,
{
    // Add validation
    assert!(
        num_main_signer_accounts > 0,
        "num_main_signer_accounts must be greater than 0, got: {}",
        num_main_signer_accounts
    );
    
    // ... rest of function
}
```

Alternatively, use a more graceful error handling approach that returns a `Result` type instead of panicking.

## Proof of Concept
To reproduce this vulnerability:

1. Build the executor-benchmark tool:
```bash
cd execution/executor-benchmark
cargo build --release
```

2. Create a test database with accounts:
```bash
./target/release/aptos-executor-benchmark \
    --block-size 100 \
    create-db \
    --data-dir /tmp/test_db \
    --num-accounts 10000
```

3. Trigger the vulnerability by setting `main_signer_accounts` to 0:
```bash
./target/release/aptos-executor-benchmark \
    --block-size 100 \
    --hotspot-probability 0.8 \
    run-executor \
    --main-signer-accounts 0 \
    --blocks 10 \
    --data-dir /tmp/test_db \
    --checkpoint-dir /tmp/checkpoint
```

**Expected Result**: The process panics with an error similar to:
```
thread 'main' panicked at 'cannot sample from empty range'
```

This demonstrates that the lack of validation for `num_main_signer_accounts` allows the creation of an invalid state that causes immediate crashes during benchmark execution.

### Citations

**File:** execution/executor-benchmark/src/lib.rs (L282-287)
```rust
pub fn run_benchmark<V>(
    block_size: usize,
    num_blocks: usize,
    workload: BenchmarkWorkload,
    mut transactions_per_sender: usize,
    num_main_signer_accounts: usize,
```

**File:** execution/executor-benchmark/src/lib.rs (L357-364)
```rust
            let accounts_cache = TransactionGenerator::gen_user_account_cache(
                db.reader.clone(),
                num_accounts_to_be_loaded,
                num_accounts_to_skip,
                is_keyless,
            );
            let (main_signer_accounts, burner_accounts) =
                accounts_cache.split(num_main_signer_accounts);
```

**File:** execution/executor-benchmark/src/main.rs (L404-406)
```rust
        #[clap(long, default_value_t = 1000000)]
        main_signer_accounts: usize,

```

**File:** execution/executor-benchmark/src/main.rs (L556-561)
```rust
            aptos_executor_benchmark::run_benchmark::<E>(
                opt.block_size,
                blocks,
                workload,
                opt.transactions_per_sender,
                main_signer_accounts,
```

**File:** execution/executor-benchmark/src/account_generator.rs (L93-96)
```rust
    pub fn split(mut self, index: usize) -> (Vec<LocalAccount>, Vec<LocalAccount>) {
        let other = self.accounts.split_off(index);
        (self.accounts.into(), other.into())
    }
```

**File:** execution/executor-benchmark/src/account_generator.rs (L115-120)
```rust
    pub fn get_random_transfer_batch(&mut self, batch_size: usize) -> (usize, Vec<usize>) {
        let indices = rand::seq::index::sample(&mut self.rng, self.accounts.len(), batch_size + 1);
        let sender_idx = indices.index(0);
        let receivers = indices.iter().skip(1).collect();
        (sender_idx, receivers)
    }
```

**File:** execution/executor-benchmark/src/transaction_generator.rs (L649-656)
```rust
    fn get_random_with_hotspot_transfer_indices(
        &mut self,
        block_size: usize,
        hotspot_probability: f32,
    ) -> Vec<(usize, usize)> {
        let num_accounts = self.main_signer_accounts.as_ref().unwrap().len();
        let num_hotspot_accounts =
            ((1.0 - hotspot_probability) * num_accounts as f32).ceil() as usize;
```

**File:** execution/executor-benchmark/src/transaction_generator.rs (L678-699)
```rust
    fn get_conflicting_grps_transfer_indices(
        rng: &mut StdRng,
        num_signer_accounts: usize,
        block_size: usize,
        conflicting_tx_grps: usize,
        shuffle_indices: bool,
    ) -> Vec<(usize, usize)> {
        let num_accounts_per_grp = num_signer_accounts / conflicting_tx_grps;
        // TODO: handle when block_size isn't divisible by connected_tx_grps; an easy
        //       way to do this is to just generate a few more transactions in the last group
        let num_txns_per_grp = block_size / conflicting_tx_grps;

        if 2 * conflicting_tx_grps >= num_signer_accounts {
            panic!(
                "For the desired workload we want num_signer_accounts ({}) > 2 * num_txns_per_grp ({})",
                num_signer_accounts, num_txns_per_grp);
        } else if conflicting_tx_grps > block_size {
            panic!(
                "connected_tx_grps ({}) > block_size ({}) cannot guarantee at least 1 txn per grp",
                conflicting_tx_grps, block_size
            );
        }
```

**File:** execution/executor-benchmark/src/transaction_generator.rs (L941-950)
```rust
/// With probability `1-h/n`, pick an integer in [0, h) uniformly at random;
/// with probability `h/n`, pick an integer in [h, n) uniformly at random.
fn rand_with_hotspot<R: Rng>(rng: &mut R, n: usize, h: usize) -> usize {
    let from_hotspot = rng.gen_range(0, n) > h;
    if from_hotspot {
        rng.gen_range(0, h)
    } else {
        rng.gen_range(h, n)
    }
}
```
