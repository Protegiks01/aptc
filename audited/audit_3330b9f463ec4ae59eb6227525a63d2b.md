# Audit Report

## Title
AdminService Exposed Without Authentication on Non-Mainnet Networks via Test Configuration

## Summary
The `create_single_node_test_config()` function unconditionally enables AdminService without authentication for test environments. While the sanitizer protects mainnet deployments, it does not prevent unauthenticated AdminService exposure on testnet, devnet, or custom networks. This creates an information disclosure vulnerability where sensitive consensus state, transaction data, and system internals can be accessed without authentication.

## Finding Description

The vulnerability exists in the configuration generation and sanitization flow: [1](#0-0) 

The function enables AdminService unconditionally, but the sanitization occurs BEFORE this line: [2](#0-1) 

The sanitizer only validates mainnet deployments: [3](#0-2) 

The default AdminServiceConfig has no authentication: [4](#0-3) 

When authentication_configs is empty, all requests are automatically authenticated: [5](#0-4) 

The exposed endpoints include:
- Consensus DB dumps containing voting records, blocks, and quorum certificates
- Block transaction data (exportable as BCS)
- Quorum store batches
- Mempool parking lot addresses
- CPU profiling, thread dumps, and memory statistics [6](#0-5) 

## Impact Explanation

**Severity: Medium** (information disclosure requiring intervention)

While the endpoints are read-only and do not allow state modification, they expose:

1. **Consensus State:** Full voting records, block proposals, and quorum certificates that could reveal validator behavior patterns
2. **Transaction Data:** Unreleased transaction data from blocks and mempool
3. **System Internals:** Memory dumps and profiling data potentially containing sensitive information
4. **Network Intelligence:** Validator relationships and consensus participation patterns

The impact does not reach High/Critical severity because:
- No direct fund loss or theft
- No consensus safety violations
- No state modification capabilities
- No remote code execution

However, it exceeds Low severity due to the breadth of sensitive information exposed on production testnet/devnet environments used by ecosystem participants.

## Likelihood Explanation

**Likelihood: Medium**

The vulnerability occurs when:
1. Users run `aptos node run-local-testnet --test` for development
2. The service binds to 0.0.0.0:9102 (all network interfaces) by default
3. Attackers with network access can query debug endpoints

Mitigating factors:
- Test mode displays a warning (line 137): "WARNING: Entering test mode! This should never be used in production!"
- Production mainnet deployments are protected by the sanitizer
- Most production configs are loaded via `NodeConfig::load_from_path()` which sanitizes

However, testnet and devnet ARE production environments for ecosystem testing, and developers may run test nodes exposed to the network.

## Recommendation

**Fix 1: Extend sanitizer to all networks**

Modify the sanitizer to require authentication for AdminService on ALL chain IDs, not just mainnet:

```rust
// In config/src/config/admin_service_config.rs, line 67-76
if node_config.admin_service.enabled == Some(true) {
    if node_config.admin_service.authentication_configs.is_empty() {
        return Err(Error::ConfigSanitizerFailed(
            sanitizer_name,
            "Must enable authentication for AdminService on all networks.".into(),
        ));
    }
}
```

**Fix 2: Bind to localhost by default in test mode**

Change the default AdminService address in test configs to bind to localhost only:

```rust
// In aptos-node/src/lib.rs, after line 635
node_config.admin_service.address = "127.0.0.1".to_string();
```

**Fix 3: Re-sanitize config after modifications**

Call the sanitizer again after enabling AdminService:

```rust
// In aptos-node/src/lib.rs, after line 635
node_config.admin_service.enabled = Some(true);
aptos_config::config::sanitize_node_config(&mut node_config)?;
```

## Proof of Concept

```bash
# Terminal 1: Start a test node
$ aptos node run-local-testnet --test

# Terminal 2: Access unauthenticated endpoints
$ curl http://127.0.0.1:9102/debug/consensus/consensusdb
# Returns: Last vote, highest TC, all consensus blocks with full details

$ curl http://127.0.0.1:9102/debug/consensus/block
# Returns: All block transaction data

$ curl http://127.0.0.1:9102/debug/mempool/parking-lot/addresses  
# Returns: BCS-encoded mempool parking lot addresses

# If exposed on public interface (0.0.0.0):
$ curl http://<node-ip>:9102/debug/consensus/block
# Attacker can extract sensitive consensus and transaction data
```

**Notes:**
The vulnerability stems from the sanitizer's mainnet-only protection combined with test mode enabling AdminService without re-sanitization. While test mode warns against production use, the explicit design flaw is that the sanitizer allows unauthenticated AdminService on testnet/devnet, which ARE production environments for the Aptos ecosystem.

### Citations

**File:** aptos-node/src/lib.rs (L630-630)
```rust
    aptos_config::config::sanitize_node_config(validators[0].config.override_config_mut())?;
```

**File:** aptos-node/src/lib.rs (L634-635)
```rust
    // Enable the AdminService.
    node_config.admin_service.enabled = Some(true);
```

**File:** config/src/config/admin_service_config.rs (L41-50)
```rust
impl Default for AdminServiceConfig {
    fn default() -> Self {
        Self {
            enabled: None,
            address: "0.0.0.0".to_string(),
            port: 9102,
            authentication_configs: vec![],
            malloc_stats_max_len: 2 * 1024 * 1024,
        }
    }
```

**File:** config/src/config/admin_service_config.rs (L67-76)
```rust
        if node_config.admin_service.enabled == Some(true) {
            if let Some(chain_id) = chain_id {
                if chain_id.is_mainnet()
                    && node_config.admin_service.authentication_configs.is_empty()
                {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name,
                        "Must enable authentication for AdminService on mainnet.".into(),
                    ));
                }
```

**File:** crates/aptos-admin-service/src/server/mod.rs (L154-174)
```rust
        let mut authenticated = false;
        if context.config.authentication_configs.is_empty() {
            authenticated = true;
        } else {
            for authentication_config in &context.config.authentication_configs {
                match authentication_config {
                    AuthenticationConfig::PasscodeSha256(passcode_sha256) => {
                        let query = req.uri().query().unwrap_or("");
                        let query_pairs: HashMap<_, _> =
                            url::form_urlencoded::parse(query.as_bytes()).collect();
                        let passcode: Option<String> =
                            query_pairs.get("passcode").map(|p| p.to_string());
                        if let Some(passcode) = passcode {
                            if sha256::digest(passcode) == *passcode_sha256 {
                                authenticated = true;
                            }
                        }
                    },
                }
            }
        };
```

**File:** crates/aptos-admin-service/src/server/mod.rs (L183-243)
```rust
        match (req.method().clone(), req.uri().path()) {
            #[cfg(target_os = "linux")]
            (hyper::Method::GET, "/profilez") => handle_cpu_profiling_request(req).await,
            #[cfg(target_os = "linux")]
            (hyper::Method::GET, "/threadz") => handle_thread_dump_request(req).await,
            #[cfg(unix)]
            (hyper::Method::GET, "/malloc/stats") => {
                malloc::handle_malloc_stats_request(context.config.malloc_stats_max_len)
            },
            #[cfg(unix)]
            (hyper::Method::GET, "/malloc/dump_profile") => malloc::handle_dump_profile_request(),
            (hyper::Method::GET, "/debug/consensus/consensusdb") => {
                let consensus_db = context.consensus_db.read().clone();
                if let Some(consensus_db) = consensus_db {
                    consensus::handle_dump_consensus_db_request(req, consensus_db).await
                } else {
                    Ok(reply_with_status(
                        StatusCode::NOT_FOUND,
                        "Consensus db is not available.",
                    ))
                }
            },
            (hyper::Method::GET, "/debug/consensus/quorumstoredb") => {
                let quorum_store_db = context.quorum_store_db.read().clone();
                if let Some(quorum_store_db) = quorum_store_db {
                    consensus::handle_dump_quorum_store_db_request(req, quorum_store_db).await
                } else {
                    Ok(reply_with_status(
                        StatusCode::NOT_FOUND,
                        "Quorum store db is not available.",
                    ))
                }
            },
            (hyper::Method::GET, "/debug/consensus/block") => {
                let consensus_db = context.consensus_db.read().clone();
                let quorum_store_db = context.quorum_store_db.read().clone();
                if let Some(consensus_db) = consensus_db
                    && let Some(quorum_store_db) = quorum_store_db
                {
                    consensus::handle_dump_block_request(req, consensus_db, quorum_store_db).await
                } else {
                    Ok(reply_with_status(
                        StatusCode::NOT_FOUND,
                        "Consensus db and/or quorum store db is not available.",
                    ))
                }
            },
            (hyper::Method::GET, "/debug/mempool/parking-lot/addresses") => {
                let mempool_client_sender = context.mempool_client_sender.read().clone();
                if let Some(mempool_client_sender) = mempool_client_sender {
                    mempool::mempool_handle_parking_lot_address_request(req, mempool_client_sender)
                        .await
                } else {
                    Ok(reply_with_status(
                        StatusCode::NOT_FOUND,
                        "Mempool parking lot is not available.",
                    ))
                }
            },
            _ => Ok(reply_with_status(StatusCode::NOT_FOUND, "Not found.")),
        }
```
