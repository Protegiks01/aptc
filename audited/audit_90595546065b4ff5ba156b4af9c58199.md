# Audit Report

## Title
Indexer Backfiller Crash via Malformed gRPC Stream Messages

## Summary
The indexer-grpc-file-store-backfiller's `backfill()` function contains multiple panic points when processing gRPC stream responses from fullnodes. A malicious or compromised fullnode can crash the backfiller by sending an empty stream or messages with unset response fields, causing denial of service for the indexing infrastructure.

## Finding Description

The backfiller establishes a gRPC stream connection to a fullnode and expects specific message formats. However, the code uses `.unwrap()` and `.expect()` calls on external input without proper error handling. [1](#0-0) 

The protobuf definition shows that the `response` field is optional (a `oneof` type): [2](#0-1) 

The Rust generated code confirms this is an `Option` type: [3](#0-2) 

**Attack Vectors:**

1. **Empty Stream Attack**: Send no messages and close the stream immediately, triggering panic at line 157
2. **Malformed Init Frame**: Send a `TransactionsFromNodeResponse` with `response = None`, triggering panic at line 159  
3. **Stream Termination in Loop**: Close stream during processing, triggering panic at line 267: [4](#0-3) 

4. **Missing Response Field in Loop**: Send message with `response = None` during processing, triggering panic at line 276: [5](#0-4) 

The fullnode is connected via an unauthenticated gRPC client: [6](#0-5) 

## Impact Explanation

This vulnerability falls under **High Severity** per Aptos bug bounty criteria as an "API crash". The indexer-grpc-file-store-backfiller is critical infrastructure that:
- Backfills historical blockchain data to file storage
- Supports indexing services that APIs depend on for historical queries
- Enables data availability for analytics and external services

When crashed, the backfiller must be restarted (as noted in code comments), causing:
- Gaps in historical data indexing
- Service disruption for data consumers
- Potential data inconsistencies if not properly recovered

While this doesn't affect consensus or validator operations directly, it impacts the broader Aptos ecosystem's data availability layer.

## Likelihood Explanation

**Likelihood: Medium to High**

An attacker can exploit this if they can cause the backfiller to connect to a malicious fullnode through:
1. **DNS poisoning or MitM attacks** during initial connection setup
2. **Compromising the legitimate fullnode** the backfiller connects to
3. **Operator misconfiguration** pointing to an untrusted endpoint
4. **Network-level attacks** redirecting the gRPC connection

The lack of authentication in the gRPC client means the backfiller cannot verify it's connecting to a legitimate fullnode. Once connected, the attack is trivial - simply send malformed messages.

## Recommendation

Replace all `.unwrap()` and `.expect()` calls with proper error handling:

```rust
// Line 154-169: Handle init frame errors gracefully
let mut grpc_stream = self.grpc_stream.take().expect("Stream is not initialized.");
let init_frame = match grpc_stream.next().await {
    Some(Ok(response)) => match response.response {
        Some(resp) => resp,
        None => anyhow::bail!("Init frame missing response field"),
    },
    Some(Err(e)) => anyhow::bail!("gRPC error on init frame: {:?}", e),
    None => anyhow::bail!("Stream closed before init frame"),
};
match init_frame {
    Response::Status(signal) => {
        if signal.r#type() != StatusType::Init {
            anyhow::bail!("Unexpected status signal type");
        }
    },
    _ => anyhow::bail!("Unexpected response type"),
}

// Line 266-276: Handle stream errors gracefully
loop {
    let item = match grpc_stream.next().await {
        Some(item) => item,
        None => {
            tracing::warn!("Stream ended unexpectedly");
            anyhow::bail!("gRPC stream closed");
        }
    };
    let response = match item {
        Ok(response) => response,
        Err(e) => {
            tracing::error!("Failed to get response: {:?}", e);
            anyhow::bail!("Failed to get response: {:?}", e);
        },
    };
    
    let resp = match response.response {
        Some(resp) => resp,
        None => {
            tracing::error!("Response missing response field");
            anyhow::bail!("Malformed response");
        }
    };
    // ... rest of processing
}
```

Additionally, implement **authentication and authorization** for the gRPC connection to ensure the backfiller only connects to trusted fullnodes.

## Proof of Concept

```rust
// Mock malicious fullnode that sends empty stream
use tokio::sync::mpsc;
use tonic::{Response, Status};
use aptos_protos::internal::fullnode::v1::TransactionsFromNodeResponse;

#[tokio::test]
async fn test_backfiller_crash_empty_stream() {
    // Create empty stream
    let (tx, rx) = mpsc::channel::<Result<TransactionsFromNodeResponse, Status>>(1);
    drop(tx); // Close stream immediately
    
    let mut stream = tokio_stream::wrappers::ReceiverStream::new(rx);
    
    // This will panic when backfiller tries to read first frame
    let result = stream.next().await;
    assert!(result.is_none()); // Stream is empty
    
    // In actual backfiller code at line 157:
    // .expect("Failed to get the first frame")
    // This would panic: "Failed to get the first frame"
}

#[tokio::test]
async fn test_backfiller_crash_missing_response() {
    use futures::StreamExt;
    
    let (tx, rx) = mpsc::channel::<Result<TransactionsFromNodeResponse, Status>>(1);
    
    // Send message with response = None
    tx.send(Ok(TransactionsFromNodeResponse {
        chain_id: 1,
        response: None, // This will trigger panic at line 159
    })).await.unwrap();
    
    let mut stream = tokio_stream::wrappers::ReceiverStream::new(rx);
    let frame = stream.next().await.unwrap().unwrap();
    
    // In actual backfiller code at line 159:
    // .response.unwrap()
    // This would panic: "called `Option::unwrap()` on a `None` value"
    assert!(frame.response.is_none());
}
```

## Notes

While the indexer-grpc-file-store-backfiller is not a core consensus component, it is critical infrastructure for the Aptos ecosystem's data availability layer. The vulnerability demonstrates poor defensive programming practices when handling external input from potentially untrusted sources. The lack of authentication on the gRPC connection exacerbates the issue, as there's no mechanism to verify the fullnode's identity before trusting its data stream.

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-file-store-backfiller/src/processor.rs (L154-159)
```rust
        let init_frame = grpc_stream
            .next()
            .await
            .expect("Failed to get the first frame")?
            .response
            .unwrap();
```

**File:** ecosystem/indexer-grpc/indexer-grpc-file-store-backfiller/src/processor.rs (L266-267)
```rust
            let item = grpc_stream.next().await;
            let item = item.unwrap();
```

**File:** ecosystem/indexer-grpc/indexer-grpc-file-store-backfiller/src/processor.rs (L276-276)
```rust
            let resp = response.response.unwrap();
```

**File:** protos/proto/aptos/internal/fullnode/v1/fullnode_data.proto (L47-51)
```text
message TransactionsFromNodeResponse {
  oneof response {
    StreamStatus status = 1;
    TransactionsOutput data = 2;
  }
```

**File:** protos/rust/src/pb/aptos.internal.fullnode.v1.rs (L79-84)
```rust
pub struct TransactionsFromNodeResponse {
    /// Making sure that all the responses include a chain id
    #[prost(uint32, tag="3")]
    pub chain_id: u32,
    #[prost(oneof="transactions_from_node_response::Response", tags="1, 2")]
    pub response: ::core::option::Option<transactions_from_node_response::Response>,
```

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/lib.rs (L36-50)
```rust
pub async fn create_grpc_client(address: Url) -> GrpcClientType {
    backoff::future::retry(backoff::ExponentialBackoff::default(), || async {
        match FullnodeDataClient::connect(address.to_string()).await {
            Ok(client) => {
                tracing::info!(
                    address = address.to_string(),
                    "[Indexer Cache] Connected to indexer gRPC server."
                );
                Ok(client
                    .max_decoding_message_size(usize::MAX)
                    .max_encoding_message_size(usize::MAX)
                    .send_compressed(CompressionEncoding::Zstd)
                    .accept_compressed(CompressionEncoding::Gzip)
                    .accept_compressed(CompressionEncoding::Zstd))
            },
```
