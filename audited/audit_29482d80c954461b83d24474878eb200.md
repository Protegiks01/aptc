# Audit Report

## Title
Voter Address Uniqueness Bypass in Genesis Validation Allows Governance Vote Consolidation

## Summary
The genesis validation logic in `validate_employee_accounts()` and `validate_validators()` fails to enforce uniqueness of voter addresses, allowing multiple validators (including employee pools) to share the same voter address. This enables a single account to control and consolidate voting power from multiple stake pools, breaking the governance integrity invariant.

## Finding Description

The genesis validation process performs uniqueness checks for owner and operator addresses but completely omits voter address uniqueness validation.

In `validate_employee_accounts()`, voter addresses are only validated for existence in the balances file: [1](#0-0) 

The function adds employee accounts to `unique_accounts` but never adds voter addresses: [2](#0-1) 

In `validate_validators()`, owner and operator addresses are explicitly checked for uniqueness: [3](#0-2) 

However, voter addresses only receive an existence check without any uniqueness validation: [4](#0-3) 

The validation flow processes both employee pools and regular validators with the same `unique_accounts` set: [5](#0-4) 

This allows malicious genesis configurations to assign the same voter address to multiple validators. In the governance system, voter control is validated per stake pool: [6](#0-5) 

And during voting: [7](#0-6) 

A single voter controlling multiple stake pools can call `vote_internal()` multiple times (once per pool), accumulating voting power from all controlled pools to manipulate governance proposals.

## Impact Explanation

**Severity: HIGH** (per Aptos Bug Bounty: up to $50,000)

This vulnerability enables **Governance Power Manipulation** - a significant protocol violation. An attacker who controls genesis configuration can:

1. **Consolidate voting power** across multiple validators under a single voter account
2. **Manipulate governance proposals** by accumulating voting power from multiple stake pools
3. **Bypass voting power limits** that assume independent validator voting
4. **Influence protocol upgrades** and parameter changes disproportionately

This breaks Critical Invariant #5: "Governance Integrity: Voting power must be correctly calculated from stake" by allowing artificial consolidation of voting power beyond what any single validator should possess.

While this doesn't directly cause loss of funds or consensus violations, it represents a significant governance security failure that could enable attackers to:
- Pass malicious governance proposals
- Block legitimate proposals
- Manipulate validator set changes
- Alter protocol parameters for personal gain

## Likelihood Explanation

**Likelihood: MEDIUM**

This vulnerability can be exploited in two scenarios:

1. **At mainnet genesis** - If the genesis configuration allows duplicate voter addresses (which the validation does not prevent), the network launches with consolidated voting power
2. **At testnet/devnet genesis** - Can be easily demonstrated and exploited

The attack requires:
- Access to genesis configuration setup (limited to network deployers)
- No special privileges after genesis
- No validator collusion required

While genesis setup is typically controlled by trusted parties, the complete absence of voter address uniqueness validation represents a critical security gap. The impact is particularly severe because:
- It's undetectable after genesis without manual auditing
- It cannot be fixed without network reset or governance intervention
- It persists throughout the network's lifetime

## Recommendation

Add voter address uniqueness validation in both `validate_employee_accounts()` and `validate_validators()` functions, consistent with how owner and operator addresses are validated.

**Fix for `validate_employee_accounts()`** - Add after line 927:

```rust
if unique_accounts.contains(&pool.validator.validator.voter_address) {
    return Err(CliError::UnexpectedError(format!(
        "Voter address {} in employee pool #{} has already been seen elsewhere",
        pool.validator.validator.voter_address, i
    )));
}
unique_accounts.insert(pool.validator.validator.voter_address);
```

**Fix for `validate_validators()`** - Add after line 691:

```rust
if unique_accounts.contains(&validator.voter_account_address.into()) {
    errors.push(CliError::UnexpectedError(format!(
        "Voter '{}' in validator {} has already been seen elsewhere",
        validator.voter_account_address, name
    )));
}
unique_accounts.insert(validator.voter_account_address.into());
```

## Proof of Concept

Create two validator configurations sharing the same voter address:

**validator1/owner.yaml:**
```yaml
owner_account_address: "0x100"
owner_account_public_key: "0x[...]"
operator_account_address: "0x101"
operator_account_public_key: "0x[...]"
voter_account_address: "0x999"  # Shared voter
voter_account_public_key: "0x[...]"
stake_amount: 1000000
```

**validator2/owner.yaml:**
```yaml
owner_account_address: "0x200"
owner_account_public_key: "0x[...]"
operator_account_address: "0x201"
operator_account_public_key: "0x[...]"
voter_account_address: "0x999"  # Same shared voter!
voter_account_public_key: "0x[...]"
stake_amount: 1000000
```

**balances.yaml:**
```yaml
0x100: 1000000
0x101: 0
0x200: 1000000
0x201: 0
0x999: 0  # Shared voter account
```

Running `aptos genesis generate-genesis` with this configuration will **succeed** without errors, creating a genesis where account `0x999` controls voting power from both stake pools (2M total), allowing it to cast votes with double the intended power in governance proposals.

**Expected behavior:** Validation should fail with error "Voter '0x999' in validator validator2 has already been seen elsewhere"

**Actual behavior:** Validation passes, allowing governance vote consolidation attack.

### Citations

**File:** crates/aptos/src/genesis/mod.rs (L204-234)
```rust
    validate_employee_accounts(
        &employee_vesting_accounts,
        &initialized_accounts,
        &mut unique_accounts,
    )?;

    let mut seen_owners = BTreeMap::new();
    validate_validators(
        &layout,
        &employee_validators,
        &initialized_accounts,
        &mut unique_accounts,
        &mut unique_network_keys,
        &mut unique_consensus_keys,
        &mut unique_consensus_pop,
        &mut unique_hosts,
        &mut seen_owners,
        true,
    )?;
    validate_validators(
        &layout,
        &validators,
        &initialized_accounts,
        &mut unique_accounts,
        &mut unique_network_keys,
        &mut unique_consensus_keys,
        &mut unique_consensus_pop,
        &mut unique_hosts,
        &mut seen_owners,
        false,
    )?;
```

**File:** crates/aptos/src/genesis/mod.rs (L654-659)
```rust
        if !initialized_accounts.contains_key(&validator.voter_account_address.into()) {
            errors.push(CliError::UnexpectedError(format!(
                "Voter {} in validator {} is not in the balances.yaml file",
                validator.voter_account_address, name
            )));
        }
```

**File:** crates/aptos/src/genesis/mod.rs (L677-691)
```rust
        if unique_accounts.contains(&validator.owner_account_address.into()) {
            errors.push(CliError::UnexpectedError(format!(
                "Owner '{}' in validator {} has already been seen elsewhere",
                validator.owner_account_address, name
            )));
        }
        unique_accounts.insert(validator.owner_account_address.into());

        if unique_accounts.contains(&validator.operator_account_address.into()) {
            errors.push(CliError::UnexpectedError(format!(
                "Operator '{}' in validator {} has already been seen elsewhere",
                validator.operator_account_address, name
            )));
        }
        unique_accounts.insert(validator.operator_account_address.into());
```

**File:** crates/aptos/src/genesis/mod.rs (L892-898)
```rust
            if unique_accounts.contains(account) {
                return Err(CliError::UnexpectedError(format!(
                    "Account #{} '{}' in employee pool #{} has already been seen elsewhere",
                    j, account, i
                )));
            }
            unique_accounts.insert(*account);
```

**File:** crates/aptos/src/genesis/mod.rs (L922-927)
```rust
        if !initialized_accounts.contains_key(&pool.validator.validator.voter_address) {
            return Err(CliError::UnexpectedError(format!(
                "Voter address {} in employee pool #{} is not in the balances.yaml file",
                pool.validator.validator.voter_address, i
            )));
        }
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L416-418)
```text
            stake::get_delegated_voter(stake_pool) == proposer_address,
            error::invalid_argument(ENOT_DELEGATED_VOTER)
        );
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L548-548)
```text
        assert!(stake::get_delegated_voter(stake_pool) == voter_address, error::invalid_argument(ENOT_DELEGATED_VOTER));
```
