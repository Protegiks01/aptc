# Audit Report

## Title
Pureness Checker Incorrectly Classifies Native Functions, Leading to Formal Verification Soundness Violations

## Summary
The Move compiler v2's pureness checker contains a critical flaw in how it determines whether native functions are pure. It assumes any native function without mutable reference parameters or return types is pure, but native functions can have hidden state, side effects, and non-deterministic behavior. This can lead to unsound formal verification where proven properties don't hold at runtime.

## Finding Description
The pureness checker in [1](#0-0)  uses an insufficient heuristic to determine if native functions are pure. For functions without a Move definition (native functions), it only checks if they take or return mutable references.

However, native functions can be impure without using mutable references. Concrete examples from the Aptos Framework include:

**1. `generate_unique_address()`** - Declared in [2](#0-1)  with signature `native fun generate_unique_address(): address;`. The implementation at [3](#0-2)  increments an internal `auid_counter` on each call, returning a different address each time.

**2. `monotonically_increasing_counter_internal()`** - Implementation at [4](#0-3)  increments `local_counter` on each call.

**3. `get_txn_hash()`** - Implementation at [5](#0-4)  returns transaction-specific data that varies per transaction.

These functions maintain hidden mutable state in the `NativeTransactionContext` structure [6](#0-5) , but their Move signatures don't expose mutable references.

If a spec function calls these native functions directly, the pureness checker will incorrectly classify the spec function as pure. The Move Prover would then assume the function is deterministic and has no side effects, leading to unsound verification where proven properties are false at runtime.

## Impact Explanation
This is a **Critical Severity** issue that breaks formal verification soundness - a core security guarantee of the Move language. Per the Aptos bug bounty program, this falls under "Consensus/Safety violations" because:

1. **Verification Soundness Violation**: Formal verification is used to prove critical security properties in blockchain systems. If the verifier proves properties that don't hold at runtime, this undermines the entire security model.

2. **Potential for Exploitation**: While the current Aptos Framework code correctly uses `pragma opaque;` and abstract spec functions to avoid this issue, any new code that directly calls impure native functions from specifications would have incorrectly proven properties.

3. **Silent Failure**: The pureness checker accepts these calls without warning, making it easy for developers to inadvertently introduce unsound specifications.

## Likelihood Explanation
**Likelihood: Medium-to-High** for the following reasons:

1. **Bug Exists in Production**: The pureness checker flaw is present in the current codebase [7](#0-6) .

2. **Multiple Vulnerable Native Functions**: Numerous native functions throughout the framework have side effects but no mutable references in their signatures.

3. **Current Mitigation**: The existing framework code uses correct patterns (opaque pragma + abstract spec functions) as shown in [8](#0-7) , preventing immediate exploitation.

4. **Risk in New Code**: Any new Move modules that call native functions directly from specifications would be vulnerable. The checker provides no warning that this is unsafe.

## Recommendation
**Fix the pureness checker to correctly handle native functions with side effects:**

Add a whitelist/annotation system for native functions to explicitly mark their pureness. The checker should:

1. Require native functions to be explicitly annotated as pure or impure
2. Default to treating unannotated native functions as impure
3. For functions marked with `pragma opaque;`, require use of abstract spec functions instead of direct calls

Alternative fix: Detect when native functions are called from specification contexts and require they have `pragma opaque;` with corresponding spec functions.

The fix should be applied to [1](#0-0)  by adding additional checks beyond just mutable reference detection.

## Proof of Concept
```move
module 0x42::unsound_spec {
    use aptos_framework::transaction_context;
    
    // Spec function that calls impure native function
    spec fun get_two_addresses(): (address, address) {
        // Current pureness checker ALLOWS this because generate_unique_address()
        // has no mutable references in its signature
        // But it's IMPURE - returns different values on each call!
        (transaction_context::generate_unique_address(),
         transaction_context::generate_unique_address())
    }
    
    // This specification would be INCORRECTLY PROVEN true by the prover
    // because it assumes get_two_addresses() is pure
    spec module {
        // The prover would prove this invariant holds
        // But at runtime, the two addresses would be DIFFERENT!
        invariant {
            let (addr1, addr2) = get_two_addresses();
            addr1 == addr2  // FALSE at runtime, but "proven" true!
        };
    }
}
```

**Expected behavior**: The pureness checker should reject the spec function `get_two_addresses()` because it calls the impure native function `generate_unique_address()`.

**Actual behavior**: The pureness checker at [7](#0-6)  incorrectly classifies `generate_unique_address()` as pure, allowing unsound specifications.

## Notes
The current Aptos Framework avoids this issue by using the correct pattern with `pragma opaque;` and abstract spec functions [8](#0-7) . However, the underlying bug in the pureness checker remains and could affect new code or third-party Move modules that don't follow these best practices.

### Citations

**File:** third_party/move/move-model/src/pureness_checker.rs (L159-178)
```rust
    fn check_function(&mut self, env: &GlobalEnv, qid: QualifiedId<FunId>) {
        let fun = env.get_function(qid);
        if let Some(def) = fun.get_def() {
            // For breaking cycles, assume initially function is pure
            self.pureness.insert(qid, true);
            // Continue recursively
            self.check_exp(env, def);
        } else {
            // We consider a native as pure if it does not take or deliver a mutable reference.
            self.is_impure = fun
                .get_parameters()
                .iter()
                .any(|Parameter(_, ty, _)| ty.is_mutable_reference())
                || fun
                    .get_result_type()
                    .flatten()
                    .iter()
                    .any(|ty| ty.is_mutable_reference());
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/transaction_context.move (L61-61)
```text
    native fun generate_unique_address(): address;
```

**File:** aptos-move/framework/src/natives/transaction_context.rs (L43-60)
```rust
#[derive(Tid)]
pub struct NativeTransactionContext {
    session_hash: Vec<u8>,
    /// The number of AUIDs (Aptos unique identifiers) issued during the
    /// execution of this transaction.
    auid_counter: u64,
    /// The local counter to support the monotonically increasing counter feature.
    /// The monotically increasing counter outputs `<reserved_byte> timestamp || transaction_index || session counter || local_counter`.
    local_counter: u16,

    script_hash: Vec<u8>,
    chain_id: u8,
    /// A transaction context is available upon transaction prologue/execution/epilogue. It is not available
    /// when a VM session is created for other purposes, such as for processing validator transactions.
    user_transaction_context_opt: Option<UserTransactionContext>,
    /// A number to represent the sessions inside the execution of a transaction. Used for computing the `monotonically_increasing_counter` method.
    session_counter: u8,
}
```

**File:** aptos-move/framework/src/natives/transaction_context.rs (L118-129)
```rust
fn native_get_txn_hash(
    context: &mut SafeNativeContext,
    _ty_args: &[Type],
    _args: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    context.charge(TRANSACTION_CONTEXT_GET_TXN_HASH_BASE)?;
    let transaction_context = context.extensions().get::<NativeTransactionContext>();

    Ok(smallvec![Value::vector_u8(
        transaction_context.session_hash.clone()
    )])
}
```

**File:** aptos-move/framework/src/natives/transaction_context.rs (L137-155)
```rust
fn native_generate_unique_address(
    context: &mut SafeNativeContext,
    _ty_args: &[Type],
    _args: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    context.charge(TRANSACTION_CONTEXT_GENERATE_UNIQUE_ADDRESS_BASE)?;

    let transaction_context = context
        .extensions_mut()
        .get_mut::<NativeTransactionContext>();
    transaction_context.auid_counter += 1;

    let auid = AuthenticationKey::auid(
        transaction_context.session_hash.clone(),
        transaction_context.auid_counter,
    )
    .account_address();
    Ok(smallvec![Value::address(auid)])
}
```

**File:** aptos-move/framework/src/natives/transaction_context.rs (L163-180)
```rust
fn native_monotonically_increasing_counter_internal(
    context: &mut SafeNativeContext,
    _ty_args: &[Type],
    mut args: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    context.charge(TRANSACTION_CONTEXT_MONOTONICALLY_INCREASING_COUNTER_BASE)?;

    let transaction_context = context
        .extensions_mut()
        .get_mut::<NativeTransactionContext>();
    if transaction_context.local_counter == u16::MAX {
        return Err(SafeNativeError::Abort {
            abort_code: error::invalid_state(
                abort_codes::EMONOTONICALLY_INCREASING_COUNTER_OVERFLOW,
            ),
        });
    }
    transaction_context.local_counter += 1;
```

**File:** aptos-move/framework/aptos-framework/sources/transaction_context.spec.move (L59-64)
```text
    spec generate_unique_address(): address {
        pragma opaque;
        aborts_if [abstract] false;
        ensures [abstract] result == spec_generate_unique_address();
    }
    spec fun spec_generate_unique_address(): address;
```
