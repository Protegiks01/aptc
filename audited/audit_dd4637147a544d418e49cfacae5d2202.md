# Audit Report

## Title
Incorrect Rate Limit Updates in Faucet Service Due to Transaction Submission vs Execution Mismatch

## Summary
The faucet's `fund_inner()` function uses `fund_result.is_ok()` to determine success, which only reflects transaction submission status when `wait_for_transactions=false` (the default). If a transaction is submitted successfully but fails during on-chain execution, the rate limit counter is still incremented and logs show `success=true`, causing legitimate users to exhaust their rate limit quota without receiving funds.

## Finding Description
The vulnerability exists in the interaction between transaction submission and rate limit management: [1](#0-0) 

The success flag is determined solely by whether `fund()` returned Ok, which depends on the `wait_for_transactions` configuration: [2](#0-1) 

By default, `wait_for_transactions` is `false`, meaning the funder uses `submit_bcs()` instead of `submit_and_wait_bcs()`: [3](#0-2) 

This only validates transaction submission to mempool, not on-chain execution. The rate limit update logic uses `response_is_500` to determine if a counter should be refunded: [4](#0-3) [5](#0-4) 

**Attack Scenario:**
1. User requests funds with default configuration (wait_for_transactions=false)
2. Transaction validation passes, rate limit counter increments
3. Transaction submits to mempool successfully â†’ `fund_result.is_ok() = true`
4. Log records `success=true`
5. `complete()` called with `response_is_500=false`, no rate limit refund
6. Transaction fails on-chain due to gas estimation errors, validation failures, or state changes
7. User receives no funds but consumed their rate limit quota

## Impact Explanation
This qualifies as **Medium severity** per the Aptos bug bounty criteria for "State inconsistencies requiring intervention":

- **Incorrect accounting**: Rate limit state diverges from actual funding state
- **User DoS**: Legitimate users can exhaust their daily quota (e.g., `max_requests_per_day`) without receiving any funds
- **Service degradation**: Faucet capacity metrics are inflated with false positives
- **Unfair service**: Users are penalized for infrastructure-level failures beyond their control

While this doesn't directly threaten blockchain consensus or on-chain funds, it creates state inconsistencies in the faucet service that require administrative intervention to resolve (manually resetting rate limits for affected users).

## Likelihood Explanation
**High likelihood** in default deployments:
- Default configuration has `wait_for_transactions=false` 
- Common on-chain failure scenarios include: gas price volatility, transaction expiration, sequence number races, and account state changes between validation and execution
- Every user in default configuration is vulnerable
- No special attacker capabilities required

## Recommendation
**Option 1 (Immediate)**: Change the default to wait for execution:
```rust
#[serde(default = "TransactionSubmissionConfig::default_wait_for_transactions")]
pub wait_for_transactions: bool,

fn default_wait_for_transactions() -> bool {
    true  // Wait for on-chain execution by default
}
```

**Option 2 (Comprehensive)**: Track transaction execution status and refund rate limits for failed transactions:
```rust
// In fund_inner(), after logging:
let execution_failed = if !wait_for_transactions {
    // Check transaction status asynchronously or store txn hash for later verification
    check_transaction_execution_status(&txn_hashes).await
        .map(|status| !status.success)
        .unwrap_or(false)
} else {
    false
};

let response_is_500 = match &fund_result {
    Ok(_) => execution_failed,  // Refund if execution failed
    Err(e) => e.error_code.status().is_server_error(),
};
```

**Option 3 (Logging accuracy)**: Fix the misleading log to reflect submission vs execution:
```rust
info!(
    source_ip = checker_data.source_ip,
    address = checker_data.receiver,
    txn_hashes = txn_hashes,
    submitted = fund_result.is_ok(),
    execution_status = if wait_for_transactions { "confirmed" } else { "pending" },
);
```

## Proof of Concept
```rust
// Integration test demonstrating the vulnerability
#[tokio::test]
async fn test_rate_limit_not_refunded_on_execution_failure() {
    // Setup faucet with wait_for_transactions=false (default)
    let config = TransactionSubmissionConfig {
        wait_for_transactions: false,
        // ... other config
    };
    
    // Setup rate limiter with max_requests_per_day=1
    let rate_limiter = MemoryRatelimitChecker::new(
        MemoryRatelimitCheckerConfig {
            max_requests_per_day: 1,
            max_entries_in_map: NonZeroUsize::new(1000).unwrap(),
        }
    );
    
    // First request: submits successfully but will fail on-chain
    let request1 = FundRequest {
        address: Some("0xCAFE".to_string()),
        amount: Some(1000000),
        // Account will be created but transaction will fail due to
        // insufficient gas or other execution error
        ..Default::default()
    };
    
    let result1 = fund_api.fund(request1, source_ip, headers).await;
    // Submission succeeds
    assert!(result1.is_ok());
    
    // Second request: should be rate limited
    let request2 = FundRequest {
        address: Some("0xBEEF".to_string()),
        amount: Some(1000000),
        ..Default::default()
    };
    
    let result2 = fund_api.fund(request2, source_ip, headers).await;
    // User is rate limited despite never receiving funds from first request
    assert!(matches!(result2, Err(AptosTapError { 
        error_code: AptosTapErrorCode::Rejected,
        ..
    })));
    
    // Verify: User exhausted rate limit but received no funds
    let balance = check_account_balance("0xCAFE").await;
    assert_eq!(balance, 0); // No funds received, but rate limited
}
```

## Notes
This vulnerability is specific to the faucet service infrastructure and does not affect core blockchain consensus, on-chain fund security, or validator operations. However, it represents a legitimate state inconsistency issue where service-level accounting (rate limits) diverges from actual outcomes (successful funding), meeting the Medium severity criteria for bugs requiring intervention to resolve user-facing issues.

### Citations

**File:** crates/aptos-faucet/core/src/endpoints/fund.rs (L319-327)
```rust
        info!(
            source_ip = checker_data.source_ip,
            jwt_sub = jwt_sub(checker_data.headers.clone()).ok(),
            address = checker_data.receiver,
            requested_amount = fund_request.amount,
            asset = asset_for_logging,
            txn_hashes = txn_hashes,
            success = fund_result.is_ok(),
        );
```

**File:** crates/aptos-faucet/core/src/endpoints/fund.rs (L333-336)
```rust
            let response_is_500 = match &fund_result {
                Ok(_) => false,
                Err(e) => e.error_code.status().is_server_error(),
            };
```

**File:** crates/aptos-faucet/core/src/funder/common.rs (L125-127)
```rust
    /// Whether to wait for the transaction before returning.
    #[serde(default)]
    pub wait_for_transactions: bool,
```

**File:** crates/aptos-faucet/core/src/funder/common.rs (L364-375)
```rust
    } else {
        (
            client
                .submit_bcs(&signed_transaction)
                .await
                .map(|_| ())
                .map_err(|e| {
                    AptosTapError::new_with_error_code(e, AptosTapErrorCode::TransactionFailed)
                }),
            "transaction_submitted",
        )
    };
```

**File:** crates/aptos-faucet/core/src/checkers/memory_ratelimit.rs (L93-102)
```rust
    async fn complete(&self, data: CompleteData) -> Result<(), AptosTapError> {
        if data.response_is_500 {
            *self
                .ip_to_requests_today
                .lock()
                .await
                .get_or_insert_mut(data.checker_data.source_ip, || 1) -= 1;
        }
        Ok(())
    }
```
