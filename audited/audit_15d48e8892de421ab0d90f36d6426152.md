# Audit Report

## Title
Symlink Attack Vulnerability in Genesis Key Generation Allows Private Keys to be Written to Arbitrary System Paths

## Summary
The `GenerateKeys` command in the genesis key generation module does not validate whether the `output_dir` parameter is a symbolic link, allowing an attacker to cause validator private keys to be written to arbitrary system locations, including sensitive directories.

## Finding Description

The `GenerateKeys::execute()` function accepts an `output_dir` parameter that specifies where validator private keys should be written. [1](#0-0) 

The function processes this directory path through `dir_default_to_current()`, which simply returns the provided path without any validation. [2](#0-1) 

The utility function `dir_default_to_current()` performs no symlink resolution or canonicalization. [3](#0-2) 

Before writing keys, the code calls `create_dir_if_not_exist()`, which uses standard filesystem operations that follow symbolic links. [4](#0-3) 

The directory creation function does not perform any symlink validation and will follow symlinks during both the existence check and directory creation. [5](#0-4) 

Finally, the `write_to_user_only_file()` function opens files for writing using standard `OpenOptions`, which follows symbolic links. [6](#0-5) 

The keys being written include highly sensitive validator cryptographic material:
- Account private key (Ed25519)
- Consensus private key (BLS12-381) 
- Validator network private key (x25519)
- Full node network private key (x25519) [7](#0-6) 

**Attack Scenario:**

1. Attacker with local access creates a symlink: `ln -s /tmp/public-readable ~/validator-keys`
2. Operator runs: `aptos genesis generate-keys --output-dir ~/validator-keys`
3. Private keys are written to `/tmp/public-readable/private-keys.yaml` and related files
4. Attacker reads the private keys from the world-readable location
5. Attacker gains full control over the validator account and can sign malicious consensus votes

Alternatively, with sufficient permissions, keys could be written to system directories like `/etc/` or other critical paths, potentially overwriting system files or exposing keys to other users.

## Impact Explanation

This vulnerability falls under **High Severity** per the Aptos bug bounty criteria as it represents a significant validator node security issue. While it doesn't directly exploit consensus or on-chain protocols, it compromises the security of validator key material during the critical genesis/setup phase.

The compromise of validator private keys enables:
- Unauthorized consensus participation and vote signing
- Validator impersonation
- Potential network disruption if multiple validators are compromised
- Loss of validator operator funds and staked assets

However, the impact is limited by requiring local filesystem access or social engineering, preventing it from reaching Critical severity.

## Likelihood Explanation

**Likelihood: Low to Medium**

The vulnerability requires one of the following conditions:
1. **Local Access Scenario**: Attacker has local shell access to create symlinks in locations the operator will use
2. **Social Engineering**: Operator is tricked into using a malicious path for `--output-dir`
3. **Misconfiguration**: Operator unknowingly uses a symlinked directory

Mitigating factors:
- Default behavior (no `--output-dir` specified) uses current directory, which is relatively safer
- Genesis key generation is typically performed carefully by experienced operators
- Most operators generate keys in controlled environments

Aggravating factors:
- No warnings about symlink risks in documentation or CLI output
- Validator setup scripts could inadvertently use symlinked paths
- Shared/multi-user systems increase attack surface

## Recommendation

Validate that `output_dir` is not a symbolic link and canonicalize the path before writing sensitive key material:

```rust
pub fn dir_default_to_current(maybe_dir: Option<PathBuf>) -> CliTypedResult<PathBuf> {
    let dir = if let Some(dir) = maybe_dir {
        dir
    } else {
        current_dir()?
    };
    
    // Canonicalize to resolve symlinks and get absolute path
    let canonical_dir = dir.canonicalize().map_err(|e| {
        CliError::UnexpectedError(format!(
            "Failed to canonicalize path {:?}: {}. Ensure the path exists and is not a symbolic link.",
            dir, e
        ))
    })?;
    
    // Verify it's not a symlink
    let metadata = std::fs::symlink_metadata(&canonical_dir).map_err(|e| {
        CliError::UnexpectedError(format!("Failed to read path metadata: {}", e))
    })?;
    
    if metadata.is_symlink() {
        return Err(CliError::CommandArgumentError(
            "Output directory cannot be a symbolic link for security reasons".to_string()
        ));
    }
    
    Ok(canonical_dir)
}
```

Additionally, consider adding a check in `write_to_user_only_file()` to verify the parent directory is not a symlink before writing sensitive files.

## Proof of Concept

```bash
#!/bin/bash
# PoC demonstrating symlink attack on genesis key generation

# Setup: Create a world-readable target directory
mkdir -p /tmp/attacker-readable
chmod 755 /tmp/attacker-readable

# Attack: Create symlink in operator's home directory
ln -s /tmp/attacker-readable ~/malicious-keys

# Operator unknowingly generates keys to symlinked directory
aptos genesis generate-keys --output-dir ~/malicious-keys

# Result: Private keys are now in /tmp/attacker-readable/
ls -la /tmp/attacker-readable/
# Output shows:
# - private-keys.yaml (contains all validator private keys)
# - validator-identity.yaml
# - validator-full-node-identity.yaml
# - public-keys.yaml

# Attacker can now read the private keys
cat /tmp/attacker-readable/private-keys.yaml

# Cleanup
rm -rf ~/malicious-keys /tmp/attacker-readable
```

The vulnerability can be verified by examining that the files are created following the symlink rather than in the specified directory itself.

## Notes

This vulnerability specifically affects the CLI tooling for validator setup rather than the core blockchain protocol. While it doesn't directly compromise consensus or on-chain operations, it represents a significant security risk during the critical validator initialization phase. The issue is exacerbated in multi-user systems or automated deployment scripts where symlink creation might go unnoticed.

### Citations

**File:** crates/aptos/src/genesis/keys.rs (L38-49)
```rust
pub struct GenerateKeys {
    /// Output directory for the key files
    #[clap(long, value_parser)]
    pub(crate) output_dir: Option<PathBuf>,

    #[clap(flatten)]
    pub(crate) pool_address_args: OptionalPoolAddressArgs,
    #[clap(flatten)]
    pub(crate) prompt_options: PromptOptions,
    #[clap(flatten)]
    pub rng_args: RngArgs,
}
```

**File:** crates/aptos/src/genesis/keys.rs (L57-58)
```rust
    async fn execute(self) -> CliTypedResult<Vec<PathBuf>> {
        let output_dir = dir_default_to_current(self.output_dir.clone())?;
```

**File:** crates/aptos/src/genesis/keys.rs (L79-80)
```rust
        // Create the directory if it doesn't exist
        create_dir_if_not_exist(output_dir.as_path())?;
```

**File:** crates/aptos/src/common/utils.rs (L224-246)
```rust
pub fn write_to_user_only_file(path: &Path, name: &str, bytes: &[u8]) -> CliTypedResult<()> {
    let mut opts = OpenOptions::new();
    #[cfg(unix)]
    opts.mode(0o600);
    write_to_file_with_opts(path, name, bytes, &mut opts)
}

/// Write a `&[u8]` to a file with the given options
pub fn write_to_file_with_opts(
    path: &Path,
    name: &str,
    bytes: &[u8],
    opts: &mut OpenOptions,
) -> CliTypedResult<()> {
    let mut file = opts
        .write(true)
        .create(true)
        .truncate(true)
        .open(path)
        .map_err(|e| CliError::IO(name.to_string(), e))?;
    file.write_all(bytes)
        .map_err(|e| CliError::IO(name.to_string(), e))
}
```

**File:** crates/aptos/src/common/utils.rs (L408-414)
```rust
pub fn dir_default_to_current(maybe_dir: Option<PathBuf>) -> CliTypedResult<PathBuf> {
    if let Some(dir) = maybe_dir {
        Ok(dir)
    } else {
        current_dir()
    }
}
```

**File:** crates/aptos/src/common/utils.rs (L416-425)
```rust
pub fn create_dir_if_not_exist(dir: &Path) -> CliTypedResult<()> {
    // Check if the directory exists, if it's not a dir, it will also fail here
    if !dir.exists() || !dir.is_dir() {
        std::fs::create_dir_all(dir).map_err(|e| CliError::IO(dir.display().to_string(), e))?;
        debug!("Created {} folder", dir.display());
    } else {
        debug!("{} folder already exists", dir.display());
    }
    Ok(())
}
```

**File:** crates/aptos-genesis/src/keys.rs (L15-22)
```rust
#[derive(Deserialize, Serialize)]
pub struct PrivateIdentity {
    pub account_address: AccountAddress,
    pub account_private_key: Ed25519PrivateKey,
    pub consensus_private_key: bls12381::PrivateKey,
    pub full_node_network_private_key: x25519::PrivateKey,
    pub validator_network_private_key: x25519::PrivateKey,
}
```
