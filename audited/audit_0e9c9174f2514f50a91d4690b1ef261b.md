# Audit Report

## Title
Event Sequence Number Collision When MODULE_EVENT_MIGRATION Flag Is Toggled

## Summary
When the `MODULE_EVENT_MIGRATION` feature flag is toggled between enabled and disabled states via governance, V1 events and translated V2 events can be assigned duplicate sequence numbers for the same event key. This causes EventByKeySchema collisions, event loss, and database corruption errors during event queries.

## Finding Description

The Aptos event indexing system maintains two parallel event formats during the V1-to-V2 migration: EventHandle-based V1 events and directly-emitted V2 events. The `MODULE_EVENT_MIGRATION` feature flag controls which format is emitted at execution time. [1](#0-0) 

When V1 events are emitted, the on-chain `EventHandle` counter is incremented to generate sequence numbers. When V2 events are emitted, EventHandles are bypassed entirely—no counter is incremented. [2](#0-1) 

The indexer processes both event types: V1 events are indexed directly using their embedded sequence numbers, while V2 events are translated back to V1 format with sequence numbers generated from `EventSequenceNumberSchema` or the on-chain EventHandle counter. [3](#0-2) 

**The critical vulnerability:** When the feature flag is toggled from enabled (V2) back to disabled (V1), the on-chain EventHandle counters have NOT been updated to account for V2 events that were emitted while the flag was enabled. This causes V1 events to reuse sequence numbers already assigned to translated V2 events.

**Attack Scenario:**

1. **Transaction 100**: Flag OFF → V1 event emitted with `seq_num=5` (EventHandle counter → 6)
   - Indexed: `EventByKeySchema[(K, 5)] = (100, idx)`

2. **Transaction 101**: Flag OFF → V1 event with `seq_num=6` (counter → 7)
   - Indexed: `EventByKeySchema[(K, 6)] = (101, idx)`

3. **Governance toggles flag to ON**

4. **Transaction 102**: Flag ON → V2 event emitted (EventHandle counter still 7)
   - Indexer reads EventHandle counter = 7, assigns `seq_num=7`
   - Indexed: `EventByKeySchema[(K, 7)] = (102, idx)`
   - `EventSequenceNumberSchema[K] = 7`

5. **Transaction 103**: Flag ON → V2 event
   - Indexer uses cached/persisted value 7, assigns `seq_num=8`
   - Indexed: `EventByKeySchema[(K, 8)] = (103, idx)`

6. **Governance toggles flag back to OFF**

7. **Transaction 104**: Flag OFF → V1 event emitted
   - **EventHandle counter is still 7** (never incremented during V2 emissions)
   - Emits with `seq_num=7`, counter → 8
   - **COLLISION**: Overwrites `EventByKeySchema[(K, 7)] = (104, idx)`
   - The event from Transaction 102 is lost from the key-based index

8. **Transaction 105**: Flag OFF → V1 event with `seq_num=8`
   - **COLLISION**: Overwrites `EventByKeySchema[(K, 8)] = (105, idx)`
   - The event from Transaction 103 is lost

This violates the invariant that sequence numbers must be strictly increasing and unique per event key. The `EventByKeySchema` mapping becomes corrupted, causing queries for specific sequence numbers to return wrong events. [4](#0-3) 

When the `lookup_events_by_key` function detects non-continuous sequence numbers, it returns a "DB corruption: Sequence number not continuous" error, causing API failures.

## Impact Explanation

This is **HIGH severity** per Aptos bug bounty criteria:

1. **API Crashes**: Event queries via `/accounts/{address}/events/{event_handle}/{field_name}` will fail with database corruption errors when encountering non-continuous sequence numbers

2. **Event Loss**: The EventByKeySchema collision causes older events to be overwritten and become unretrievable via sequence number queries, breaking event history guarantees

3. **State Inconsistencies**: The same sequence number maps to different events at different versions, violating the semantic meaning of monotonic sequence numbers and breaking indexer integrity

4. **Protocol Violations**: The indexer assumes sequence numbers are unique and continuous per event key—this assumption is violated, causing undefined behavior in event querying logic

This affects all nodes running the internal indexer with `enable_event_v2_translation=true` and impacts users querying historical events through the REST API.

## Likelihood Explanation

**Likelihood: HIGH**

1. **Feature flag toggling is a normal governance operation**: The `MODULE_EVENT_MIGRATION` flag is designed to be toggled to facilitate the V1→V2 event migration. Toggling back (rollback) is a realistic scenario if issues are discovered. [5](#0-4) 

2. **No protection mechanisms exist**: The code contains no synchronization between on-chain EventHandle counters and the indexer's EventSequenceNumberSchema when the flag changes state

3. **Affects all event types**: Any event type that uses both V1 EventHandles and V2 direct emission (coin deposits/withdrawals, token events, governance events, etc.) is vulnerable

4. **Immediate impact**: The collision occurs as soon as the first V1 event is emitted after toggling the flag back, which could happen within minutes of the governance proposal execution

## Recommendation

**Option 1: Prevent Flag Toggle-Back (Safest)**

Make `MODULE_EVENT_MIGRATION` a one-way flag that cannot be disabled once enabled. Add validation in the governance proposal execution:

```move
public fun toggle_features(aptos_framework: &signer, enable: vector<u64>, disable: vector<u64>) {
    // Prevent disabling MODULE_EVENT_MIGRATION once enabled
    let i = 0;
    while (i < vector::length(&disable)) {
        let flag = *vector::borrow(&disable, i);
        assert!(flag != 57 || !std::features::module_event_migration_enabled(), 
                error::invalid_argument(ECANNOT_DISABLE_MODULE_EVENT_MIGRATION));
        i = i + 1;
    };
    // ... rest of toggle logic
}
```

**Option 2: Synchronize Counters on Flag Toggle**

When the flag is toggled back to disabled, update all on-chain EventHandle counters to match the indexer's EventSequenceNumberSchema values. This requires:

1. A system transaction at epoch boundary that reads EventSequenceNumberSchema from the indexer
2. Updates all affected EventHandle counters in on-chain resources
3. Significant complexity and potential performance impact

**Option 3: Unified Sequence Number Source**

Refactor the system so V2 events still update EventHandle counters even when emitted directly, maintaining a single source of truth for sequence numbers. This would require VM-level changes to ensure V2 emissions increment the associated EventHandle counter.

**Recommended Solution: Option 1** - Prevents the vulnerability entirely with minimal code changes and aligns with the forward-only migration philosophy.

## Proof of Concept

```move
#[test_only]
module aptos_framework::event_sequence_collision_test {
    use std::signer;
    use aptos_framework::aptos_coin::AptosCoin;
    use aptos_framework::coin;
    use aptos_framework::aptos_account;
    
    #[test(framework = @aptos_framework, user1 = @0x100, user2 = @0x200)]
    fun test_sequence_number_collision(framework: &signer, user1: &signer, user2: &signer) {
        // Setup
        aptos_framework::genesis::setup();
        aptos_account::create_account(signer::address_of(user1));
        aptos_account::create_account(signer::address_of(user2));
        
        // 1. Start with MODULE_EVENT_MIGRATION disabled
        std::features::change_feature_flags_for_next_epoch(
            framework, 
            vector[], 
            vector[57] // Disable MODULE_EVENT_MIGRATION
        );
        aptos_framework::reconfigure::reconfigure_for_test();
        
        // 2. Emit V1 events (seq_num = 0, 1)
        coin::transfer<AptosCoin>(user1, signer::address_of(user2), 100);
        coin::transfer<AptosCoin>(user1, signer::address_of(user2), 200);
        
        // 3. Enable MODULE_EVENT_MIGRATION
        std::features::change_feature_flags_for_next_epoch(
            framework,
            vector[57], // Enable MODULE_EVENT_MIGRATION
            vector[]
        );
        aptos_framework::reconfigure::reconfigure_for_test();
        
        // 4. Emit V2 events (translated to seq_num = 2, 3)
        coin::transfer<AptosCoin>(user1, signer::address_of(user2), 300);
        coin::transfer<AptosCoin>(user1, signer::address_of(user2), 400);
        
        // 5. Disable MODULE_EVENT_MIGRATION again
        std::features::change_feature_flags_for_next_epoch(
            framework,
            vector[],
            vector[57] // Disable MODULE_EVENT_MIGRATION
        );
        aptos_framework::reconfigure::reconfigure_for_test();
        
        // 6. Emit V1 events - THESE WILL REUSE seq_num = 2, 3
        // because EventHandle counter was never incremented during V2 emissions
        coin::transfer<AptosCoin>(user1, signer::address_of(user2), 500);
        coin::transfer<AptosCoin>(user1, signer::address_of(user2), 600);
        
        // At this point, the indexer has:
        // - EventByKeySchema[(user2_deposit_key, 2)] pointing to two different transactions
        // - EventByKeySchema[(user2_deposit_key, 3)] pointing to two different transactions
        // - Event queries will return wrong results or fail with "DB corruption" errors
    }
}
```

**Notes:**

The vulnerability stems from the fundamental architectural mismatch between execution-time event emission (which follows the MODULE_EVENT_MIGRATION flag) and post-execution indexing (which translates V2 events using separate sequence number tracking). When the flag toggles back, the two sequence number sources (on-chain EventHandle vs. EventSequenceNumberSchema) diverge permanently, causing collisions.

This breaks the **State Consistency** invariant that "state transitions must be atomic and verifiable" by creating inconsistent event indices that cannot be reliably queried.

### Citations

**File:** aptos-move/framework/aptos-token/sources/token_event_store.move (L242-256)
```text
        if (std::features::module_event_migration_enabled()) {
            event::emit(
                CollectionUriMutate {
                    creator_addr: signer::address_of(creator),
                    collection_name: collection,
                    old_uri,
                    new_uri,
                }
            );
        } else {
            event::emit_event<CollectionUriMutateEvent>(
                &mut token_event_store.collection_uri_mutate_events,
                event,
            );
        };
```

**File:** storage/indexer/src/db_indexer.rs (L209-242)
```rust
    pub fn lookup_events_by_key(
        &self,
        event_key: &EventKey,
        start_seq_num: u64,
        limit: u64,
        ledger_version: u64,
    ) -> Result<
        Vec<(
            u64,     // sequence number
            Version, // transaction version it belongs to
            u64,     // index among events for the same transaction
        )>,
    > {
        let mut iter = self.db.iter::<EventByKeySchema>()?;
        iter.seek(&(*event_key, start_seq_num))?;

        let mut result = Vec::new();
        let mut cur_seq = start_seq_num;
        for res in iter.take(limit as usize) {
            let ((path, seq), (ver, idx)) = res?;
            if path != *event_key || ver > ledger_version {
                break;
            }
            if seq != cur_seq {
                let msg = if cur_seq == start_seq_num {
                    "First requested event is probably pruned."
                } else {
                    "DB corruption: Sequence number not continuous."
                };
                bail!("{} expected: {}, actual: {}", msg, cur_seq, seq);
            }
            result.push((seq, ver, idx));
            cur_seq += 1;
        }
```

**File:** storage/indexer/src/db_indexer.rs (L432-486)
```rust
            if self.indexer_db.event_enabled() {
                events.iter().enumerate().try_for_each(|(idx, event)| {
                    if let ContractEvent::V1(v1) = event {
                        batch
                            .put::<EventByKeySchema>(
                                &(*v1.key(), v1.sequence_number()),
                                &(version, idx as u64),
                            )
                            .expect("Failed to put events by key to a batch");
                        batch
                            .put::<EventByVersionSchema>(
                                &(*v1.key(), version, v1.sequence_number()),
                                &(idx as u64),
                            )
                            .expect("Failed to put events by version to a batch");
                    }
                    if self.indexer_db.event_v2_translation_enabled() {
                        if let ContractEvent::V2(v2) = event {
                            if let Some(translated_v1_event) =
                                self.translate_event_v2_to_v1(v2).map_err(|e| {
                                    anyhow::anyhow!(
                                        "Failed to translate event: {:?}. Error: {}",
                                        v2,
                                        e
                                    )
                                })?
                            {
                                let key = *translated_v1_event.key();
                                let sequence_number = translated_v1_event.sequence_number();
                                self.event_v2_translation_engine
                                    .cache_sequence_number(&key, sequence_number);
                                event_keys.insert(key);
                                batch
                                    .put::<EventByKeySchema>(
                                        &(key, sequence_number),
                                        &(version, idx as u64),
                                    )
                                    .expect("Failed to put events by key to a batch");
                                batch
                                    .put::<EventByVersionSchema>(
                                        &(key, version, sequence_number),
                                        &(idx as u64),
                                    )
                                    .expect("Failed to put events by version to a batch");
                                batch
                                    .put::<TranslatedV1EventSchema>(
                                        &(version, idx as u64),
                                        &translated_v1_event,
                                    )
                                    .expect("Failed to put translated v1 events to a batch");
                            }
                        }
                    }
                    Ok::<(), AptosDbError>(())
                })?;
```

**File:** storage/indexer/src/event_v2_translator.rs (L238-273)
```rust
struct CoinDepositTranslator;
impl EventV2Translator for CoinDepositTranslator {
    fn translate_event_v2_to_v1(
        &self,
        v2: &ContractEventV2,
        engine: &EventV2TranslationEngine,
    ) -> Result<ContractEventV1> {
        let coin_deposit = CoinDeposit::try_from_bytes(v2.event_data())?;
        let struct_tag_str = format!("0x1::coin::CoinStore<{}>", coin_deposit.coin_type());
        let struct_tag = StructTag::from_str(&struct_tag_str)?;
        let (key, sequence_number) = if let Some(state_value_bytes) =
            engine.get_state_value_bytes_for_resource(coin_deposit.account(), &struct_tag)?
        {
            // We can use `DummyCoinType` as it does not affect the correctness of deserialization.
            let coin_store_resource: CoinStoreResource<DummyCoinType> =
                bcs::from_bytes(&state_value_bytes)?;
            let key = *coin_store_resource.deposit_events().key();
            let sequence_number = engine
                .get_next_sequence_number(&key, coin_store_resource.deposit_events().count())?;
            (key, sequence_number)
        } else {
            // The creation number of DepositEvent is deterministically 2.
            static DEPOSIT_EVENT_CREATION_NUMBER: u64 = 2;
            (
                EventKey::new(DEPOSIT_EVENT_CREATION_NUMBER, *coin_deposit.account()),
                0,
            )
        };
        let deposit_event = DepositEvent::new(coin_deposit.amount());
        Ok(ContractEventV1::new(
            key,
            sequence_number,
            DEPOSIT_EVENT_TYPE.clone(),
            bcs::to_bytes(&deposit_event)?,
        )?)
    }
```

**File:** api/src/tests/event_v2_translation_test.rs (L21-29)
```rust
async fn test_feature_enable_disable() {
    let mut context = new_test_context(current_function_name!());
    context.enable_feature(MODULE_EVENT_MIGRATION).await;
    assert!(context.is_feature_enabled(MODULE_EVENT_MIGRATION).await);
    context.disable_feature(MODULE_EVENT_MIGRATION).await;
    assert!(!context.is_feature_enabled(MODULE_EVENT_MIGRATION).await);
    context.enable_feature(MODULE_EVENT_MIGRATION).await;
    assert!(context.is_feature_enabled(MODULE_EVENT_MIGRATION).await);
}
```
