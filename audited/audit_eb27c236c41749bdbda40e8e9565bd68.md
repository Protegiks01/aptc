# Audit Report

## Title
Waypoint Verification Bypass Through Storage Version Check Enables Incorrect Bootstrap Fetch Decisions

## Summary
The bootstrapper's `verify_waypoint_is_satisfiable()` function bypasses cryptographic waypoint verification when storage version exceeds the waypoint version. This allows nodes with corrupted or wrong-chain storage to skip epoch fetching and proceed with unverified chain state, violating the waypoint's purpose as a trust anchor for correct-chain bootstrapping.

## Finding Description

The vulnerability exists in the interaction between the bootstrapper's waypoint verification and epoch fetching logic. The waypoint is designed as a cryptographic trust anchor to ensure nodes bootstrap to the correct chain, but this protection is bypassed through a version comparison optimization.

**Critical Code Path:**

The `should_fetch_epoch_ending_ledger_infos()` function uses OR logic to determine whether to fetch epochs: [1](#0-0) 

The waypoint can be marked as verified without any cryptographic validation: [2](#0-1) 

This bypasses the actual cryptographic verification function that validates both version AND hash: [3](#0-2) 

The cryptographic verification method in the Waypoint type itself: [4](#0-3) 

**Attack Scenario:**

1. Node starts with storage at version 10000 (from wrong chain, corrupted, or misconfigured snapshot)
2. Waypoint configured at version 5000 (correct chain)
3. Network advertises epoch matching storage epoch

**Execution Flow:**

- `fetch_epoch_ending_ledger_infos()` calls `verify_waypoint_is_satisfiable()` [5](#0-4) 
- Storage version check: 10000 >= 5000 â†’ Sets `verified_waypoint = true` WITHOUT cryptographic verification (line 888-889)
- Calculates `highest_local_epoch_end` from storage
- Compares with network's `highest_advertised_epoch_end`
- If equal, marks epochs as fetched without network validation: [6](#0-5) 

**Result:**
- `should_fetch_epoch_ending_ledger_infos()` returns false (both verified and fetched)
- Node proceeds to transaction sync without cryptographically verifying the waypoint
- Node relies on potentially corrupted/wrong-chain storage as source of truth

This violates the cryptographic correctness invariant. The waypoint serves as an "off-chain mechanism to verify the sync process" but is bypassed through version comparison alone.

## Impact Explanation

**Severity: Medium** (per Aptos bug bounty criteria: "State inconsistencies requiring intervention")

The waypoint is explicitly designed as a trust anchor to prevent wrong-chain bootstrapping and corrupted storage acceptance. Bypassing its cryptographic verification creates several risks:

1. **Wrong Chain Bootstrapping**: Node configured for mainnet with testnet storage snapshot would proceed without detecting the chain mismatch
2. **Corrupted Storage Acceptance**: Storage corruption from hardware failures or malicious tampering goes undetected if version checks pass
3. **Configuration Mismatch**: Waypoint updates between restarts aren't validated against actual storage data

While this doesn't directly enable consensus violations or fund theft within a single chain, it creates state inconsistencies where nodes may operate on incorrect chain state, requiring manual intervention to detect and repair. This aligns with the Medium severity category of "Limited Protocol Violations" requiring manual intervention.

## Likelihood Explanation

**Likelihood: Low-Medium**

This vulnerability requires one of these operational conditions:
- **Storage corruption** (malicious snapshot distribution, database tampering, bit rot)
- **Configuration changes** (waypoint updated but storage retained from previous version)
- **Cross-network errors** (testnet storage used with mainnet configuration)

These are operational/deployment scenarios rather than pure protocol attacks. However, in a distributed network with many node operators of varying sophistication, configuration errors and snapshot misuse occur regularly, making this a realistic concern.

The impact is amplified because:
- The waypoint mechanism exists specifically to prevent these scenarios
- Defense-in-depth principles dictate that critical security checks should not be skipped based on optimizations
- Silent failures (incorrect chain state) are harder to detect than explicit verification errors

## Recommendation

Modify `verify_waypoint_is_satisfiable()` to always verify the waypoint cryptographically when storage is ahead of waypoint version, rather than assuming storage integrity. The function should:

1. Fetch the epoch ending ledger info from storage at the waypoint version
2. Call the cryptographic `verify_waypoint()` function with this ledger info
3. Only mark waypoint as verified after successful cryptographic validation
4. If the storage doesn't contain a ledger info at the waypoint version, require fetching it from the network

This ensures the waypoint serves its intended purpose as a cryptographic trust anchor in all scenarios, including when storage has advanced beyond the waypoint.

## Proof of Concept

While a full PoC requires integration test setup, the vulnerability can be triggered by:

1. Initialize a node with storage from chain A at version 10000
2. Configure the node with a waypoint from chain B at version 5000
3. Connect to network peers from chain A advertising epoch matching storage
4. Observe that `verify_waypoint_is_satisfiable()` marks waypoint verified without cryptographic check
5. Node proceeds to sync using chain A storage without detecting the mismatch

The code path is clearly documented in the bootstrapper logic and can be validated by examining the control flow in `fetch_epoch_ending_ledger_infos()` and `verify_waypoint_is_satisfiable()`.

## Notes

This vulnerability represents a defense-in-depth failure. While subsequent transaction validation may catch some instances of wrong-chain data, the waypoint mechanism exists specifically as the first line of defense against bootstrap to incorrect chain state. The optimization of skipping verification based on version comparison undermines this security guarantee in realistic operational scenarios involving configuration errors, corrupted snapshots, or cross-network misconfigurations.

The intentional nature of this optimization (evidenced by the comment at line 884) suggests this is a design decision rather than an oversight, but it nevertheless creates a security gap in the waypoint protection mechanism.

### Citations

**File:** state-sync/state-sync-driver/src/bootstrapper.rs (L132-166)
```rust
    fn verify_waypoint(
        &mut self,
        epoch_ending_ledger_info: &LedgerInfoWithSignatures,
        waypoint: &Waypoint,
    ) -> Result<(), Error> {
        if !self.verified_waypoint {
            // Fetch the waypoint and ledger info versions
            let waypoint_version = waypoint.version();
            let ledger_info = epoch_ending_ledger_info.ledger_info();
            let ledger_info_version = ledger_info.version();

            // Verify we haven't missed the waypoint
            if ledger_info_version > waypoint_version {
                panic!(
                    "Failed to verify the waypoint: ledger info version is too high! Waypoint version: {:?}, ledger info version: {:?}",
                    waypoint_version, ledger_info_version
                );
            }

            // Check if we've found the ledger info corresponding to the waypoint version
            if ledger_info_version == waypoint_version {
                match waypoint.verify(ledger_info) {
                    Ok(()) => self.set_verified_waypoint(waypoint_version),
                    Err(error) => {
                        panic!(
                            "Failed to verify the waypoint: {:?}! Waypoint: {:?}, given ledger info: {:?}",
                            error, waypoint, ledger_info
                        );
                    },
                }
            }
        }

        Ok(())
    }
```

**File:** state-sync/state-sync-driver/src/bootstrapper.rs (L445-450)
```rust
    fn should_fetch_epoch_ending_ledger_infos(&self) -> bool {
        !self
            .verified_epoch_states
            .fetched_epoch_ending_ledger_infos()
            || !self.verified_epoch_states.verified_waypoint()
    }
```

**File:** state-sync/state-sync-driver/src/bootstrapper.rs (L814-820)
```rust
    async fn fetch_epoch_ending_ledger_infos(
        &mut self,
        global_data_summary: &GlobalDataSummary,
    ) -> Result<(), Error> {
        // Verify the waypoint can be satisfied
        self.verify_waypoint_is_satisfiable(global_data_summary)?;

```

**File:** state-sync/state-sync-driver/src/bootstrapper.rs (L848-873)
```rust
        if highest_local_epoch_end < highest_advertised_epoch_end {
            info!(LogSchema::new(LogEntry::Bootstrapper).message(&format!(
                "Found higher epoch ending ledger infos in the network! Local: {:?}, advertised: {:?}",
                   highest_local_epoch_end, highest_advertised_epoch_end
            )));
            let next_epoch_end = highest_local_epoch_end.checked_add(1).ok_or_else(|| {
                Error::IntegerOverflow("The next epoch end has overflown!".into())
            })?;
            let epoch_ending_stream = self
                .streaming_client
                .get_all_epoch_ending_ledger_infos(next_epoch_end)
                .await?;
            self.active_data_stream = Some(epoch_ending_stream);
        } else if self.verified_epoch_states.verified_waypoint() {
            info!(LogSchema::new(LogEntry::Bootstrapper).message(
                "No new epoch ending ledger infos to fetch! All peers are in the same epoch!"
            ));
            self.verified_epoch_states
                .set_fetched_epoch_ending_ledger_infos();
        } else {
            return Err(Error::AdvertisedDataError(format!(
                "Our waypoint is unverified, but there's no higher epoch ending ledger infos \
                advertised! Highest local epoch end: {:?}, highest advertised epoch end: {:?}",
                highest_local_epoch_end, highest_advertised_epoch_end
            )));
        };
```

**File:** state-sync/state-sync-driver/src/bootstrapper.rs (L880-891)
```rust
    fn verify_waypoint_is_satisfiable(
        &mut self,
        global_data_summary: &GlobalDataSummary,
    ) -> Result<(), Error> {
        // If our storage has already synced beyond our waypoint, nothing needs to be checked
        let latest_ledger_info = utils::fetch_latest_synced_ledger_info(self.storage.clone())?;
        let waypoint_version = self.driver_configuration.waypoint.version();
        if latest_ledger_info.ledger_info().version() >= waypoint_version {
            self.verified_epoch_states
                .set_verified_waypoint(waypoint_version);
            return Ok(());
        }
```

**File:** types/src/waypoint.rs (L62-79)
```rust
    pub fn verify(&self, ledger_info: &LedgerInfo) -> Result<()> {
        ensure!(
            ledger_info.version() == self.version(),
            "Waypoint version mismatch: waypoint version = {}, given version = {}",
            self.version(),
            ledger_info.version()
        );
        let converter = Ledger2WaypointConverter::new(ledger_info);
        ensure!(
            converter.hash() == self.value(),
            format!(
                "Waypoint value mismatch: waypoint value = {}, given value = {}",
                self.value().to_hex(),
                converter.hash().to_hex()
            )
        );
        Ok(())
    }
```
