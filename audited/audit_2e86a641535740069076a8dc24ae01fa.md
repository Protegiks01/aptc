# Audit Report

## Title
Unhandled BCS Deserialization Panic in Sharded Block Executor Causes Validator Crashes

## Summary
The `get_state_value()` function in the sharded block executor contains an `unwrap()` that will panic if BCS-deserialized state data is malformed, causing validator nodes to crash during block execution. This represents a critical fault tolerance failure in production consensus code.

## Finding Description

The vulnerability exists in the state value deserialization logic used during sharded block execution. [1](#0-0) 

The code path performs the following operations:
1. Retrieves state value bytes from the database
2. Attempts to deserialize the bytes using BCS into the target type `T`
3. Calls `.transpose().map_err(anyhow::Error::msg).unwrap()` - this will **panic** if deserialization fails

This function is called during block execution to read the total supply: [2](#0-1) 

The execution flow is:
1. Consensus proposes a block for execution
2. Block executor calls sharded execution: [3](#0-2) 
3. Sharded executor aggregates total supply across shards: [4](#0-3) 
4. If the `TOTAL_SUPPLY_STATE_KEY` contains malformed BCS data, the unwrap panics

When a panic occurs in production code (outside of VERIFIER/DESERIALIZER VMState), the panic handler terminates the process: [5](#0-4) 

**Triggering Conditions:**
- Database corruption of the `TOTAL_SUPPLY_STATE_KEY` value (filesystem errors, disk corruption, RocksDB bugs)
- State sync receiving and persisting corrupted state data
- Software bugs in state storage that write invalid BCS bytes
- The StateValue container itself can be valid while containing invalid BCS bytes for the expected type: [6](#0-5) 

The StateValue storage schema deserializes the wrapper correctly but does not validate content bytes: [7](#0-6) 

## Impact Explanation

This issue qualifies as **HIGH severity** under the Aptos bug bounty criteria:
- **"Validator node crashes"** - The panic directly causes `process::exit(12)`, terminating the validator
- **"Significant protocol violations"** - Breaks the fault tolerance invariant that validators should handle corrupted state gracefully

Impact on the network:
- **Single validator**: Loss of consensus participation, reduced network resilience
- **Multiple validators**: If database corruption affects multiple nodes (e.g., due to a common bug or synchronized state corruption), could threaten network liveness
- **Cascading failures**: Validators that cannot execute blocks fall behind and may struggle to catch up

The vulnerability breaks these invariants:
1. **Move VM Safety** - VM operations should not panic in production; errors should be handled gracefully
2. **State Consistency** - Corrupted state should be detectable and recoverable, not cause crashes
3. **Deterministic Execution** - If only some validators experience corruption, they crash while others continue, breaking consensus participation

## Likelihood Explanation

**Moderate Likelihood** due to multiple realistic trigger scenarios:

1. **Database Corruption**: While RocksDB includes checksums, bit flips in memory, filesystem bugs, or disk errors can corrupt data between validation and execution. Hardware failures are inevitable at scale.

2. **State Sync Edge Cases**: During state snapshot restoration or fast sync, edge cases in Merkle proof validation could allow malformed data to persist if the wrapper structure is valid but content bytes are corrupted.

3. **Software Bugs**: Bugs in the storage layer, transaction output processing, or state update logic could write incorrectly serialized data that passes initial validation but fails later deserialization.

The impact is amplified because:
- The vulnerability is in a hot path (every sharded block execution)
- The panic is immediate and unrecoverable
- No error recovery or retry mechanism exists
- Operators have no warning before the crash

Note: Similar vulnerable patterns exist elsewhere in the codebase: [8](#0-7) 

## Recommendation

Replace all `unwrap()` calls on BCS deserialization results with proper error handling that returns `Result` types. The panic should be converted to an error that propagates through the execution stack.

**Recommended fix for `get_state_value()`:**
```rust
pub fn get_state_value<S: StateView, T: DeserializeOwned>(
    state_key: &StateKey,
    state_view: &S,
) -> anyhow::Result<Option<T>> {
    let value = state_view
        .get_state_value_bytes(state_key)?
        .map(move |value| bcs::from_bytes(&value));
    value.transpose().map_err(|e| anyhow::anyhow!(
        "Failed to deserialize state value for key {:?}: {}", 
        state_key, e
    ))
}
```

**Update callers to handle errors:**
```rust
let total_supply_base_val: u128 = get_state_value(&TOTAL_SUPPLY_STATE_KEY, state_view)
    .context("Failed to read total supply from state")?
    .ok_or_else(|| anyhow::anyhow!("Total supply state key missing"))?;
```

This allows the error to propagate to the block execution layer, which can:
- Log the error with full context
- Mark the block execution as failed
- Trigger validator health monitoring
- Allow operators to diagnose and repair the database
- Potentially retry with state sync recovery

**Additional hardening:**
- Add state validation checks during database writes
- Implement periodic state integrity verification
- Add monitoring for BCS deserialization failures
- Consider checksums or type tags for critical state values

## Proof of Concept

```rust
#[cfg(test)]
mod test {
    use super::*;
    use aptos_types::state_store::{
        state_key::StateKey, 
        state_value::StateValue,
        StateView,
    };
    use bytes::Bytes;
    use std::collections::HashMap;

    struct MockCorruptedStateView {
        data: HashMap<StateKey, Bytes>,
    }

    impl StateView for MockCorruptedStateView {
        fn get_state_value_bytes(
            &self,
            state_key: &StateKey,
        ) -> anyhow::Result<Option<Bytes>> {
            Ok(self.data.get(state_key).cloned())
        }
        
        // Other required trait methods omitted for brevity
    }

    #[test]
    #[should_panic(expected = "called `Result::unwrap()` on an `Err` value")]
    fn test_malformed_bcs_causes_panic() {
        let mut state_data = HashMap::new();
        
        // Create a state key (using TOTAL_SUPPLY_STATE_KEY pattern)
        let state_key = StateKey::table_item(
            &"1b854694ae746cdbd8d44186ca4929b2b337df21d1c74633be19b2710552fdca"
                .parse()
                .unwrap(),
            &[6, 25, 220, 41, 160, 170, 200, 250, 20, 103, 20, 5, 
              142, 141, 214, 210, 208, 243, 189, 245, 246, 51, 25, 7, 
              191, 145, 243, 172, 216, 30, 105, 53],
        );
        
        // Insert malformed BCS data (not valid u128 encoding)
        // Valid u128 requires exactly 16 bytes, this has wrong length/content
        state_data.insert(state_key.clone(), Bytes::from(vec![0xFF; 10]));
        
        let state_view = MockCorruptedStateView { data: state_data };
        
        // This will panic because malformed BCS data cannot be deserialized
        let _result: Option<u128> = get_state_value(&state_key, &state_view);
        
        // Validator process would exit here with process::exit(12)
    }

    #[test]
    fn test_missing_state_key_also_panics() {
        let state_view = MockCorruptedStateView { 
            data: HashMap::new() 
        };
        
        let state_key = StateKey::table_item(
            &"1b854694ae746cdbd8d44186ca4929b2b337df21d1c74633be19b2710552fdca"
                .parse()
                .unwrap(),
            &[6, 25, 220, 41, 160, 170, 200, 250, 20, 103, 20, 5, 
              142, 141, 214, 210, 208, 243, 189, 245, 246, 51, 25, 7, 
              191, 145, 243, 172, 216, 30, 105, 53],
        );
        
        // Line 212 also has unwrap() on the Option result
        // This demonstrates the second panic path
        let result: Option<u128> = get_state_value(&state_key, &state_view);
        assert!(result.is_none());
        
        // aggregate_and_update_total_supply would panic here:
        // let total_supply_base_val: u128 = result.unwrap();
    }
}
```

## Notes

This vulnerability demonstrates a critical gap in fault tolerance: production consensus code should never panic on data corruption. The same pattern appears in multiple locations in the codebase and should be audited comprehensively.

While the most common trigger is database corruption rather than a deliberate attack, the impact on validator availability and network health is severe. Validators are critical infrastructure that must remain operational even when facing corrupted state, disk failures, or unexpected data formats.

The fix is straightforward: convert panics to error returns and handle them at appropriate levels in the execution stack. This allows graceful degradation, proper error reporting, and operator intervention rather than silent process termination.

### Citations

**File:** aptos-move/aptos-vm/src/sharded_block_executor/sharded_aggregator_service.rs (L15-24)
```rust
pub fn get_state_value<S: StateView, T: DeserializeOwned>(
    state_key: &StateKey,
    state_view: &S,
) -> Option<T> {
    let value = state_view
        .get_state_value_bytes(state_key)
        .ok()?
        .map(move |value| bcs::from_bytes(&value));
    value.transpose().map_err(anyhow::Error::msg).unwrap()
}
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/sharded_aggregator_service.rs (L212-212)
```rust
    let total_supply_base_val: u128 = get_state_value(&TOTAL_SUPPLY_STATE_KEY, state_view).unwrap();
```

**File:** execution/executor/src/workflow/do_get_execution_output.rs (L197-201)
```rust
        let transaction_outputs = Self::execute_block_sharded::<V>(
            transactions.clone(),
            state_view_arc.clone(),
            onchain_config,
        )?;
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/local_executor_shard.rs (L215-220)
```rust
        sharded_aggregator_service::aggregate_and_update_total_supply(
            &mut sharded_output,
            &mut global_output,
            state_view.as_ref(),
            self.global_executor.get_executor_thread_pool(),
        );
```

**File:** crates/crash-handler/src/lib.rs (L48-58)
```rust
    // Do not kill the process if the panics happened at move-bytecode-verifier.
    // This is safe because the `state::get_state()` uses a thread_local for storing states. Thus the state can only be mutated to VERIFIER by the thread that's running the bytecode verifier.
    //
    // TODO: once `can_unwind` is stable, we should assert it. See https://github.com/rust-lang/rust/issues/92988.
    if state::get_state() == VMState::VERIFIER || state::get_state() == VMState::DESERIALIZER {
        return;
    }

    // Kill the process
    process::exit(12);
}
```

**File:** types/src/state_store/state_value.rs (L183-187)
```rust
pub struct StateValue {
    data: Bytes,
    metadata: StateValueMetadata,
    maybe_rapid_hash: Option<(u64, usize)>,
}
```

**File:** storage/aptosdb/src/schema/state_value/mod.rs (L61-69)
```rust
impl ValueCodec<StateValueSchema> for Option<StateValue> {
    fn encode_value(&self) -> Result<Vec<u8>> {
        bcs::to_bytes(self).map_err(Into::into)
    }

    fn decode_value(data: &[u8]) -> Result<Self> {
        bcs::from_bytes(data).map_err(Into::into)
    }
}
```

**File:** types/src/write_set.rs (L717-724)
```rust
    fn get_total_supply(&self) -> Option<u128> {
        let value = self
            .0
            .get(&TOTAL_SUPPLY_STATE_KEY)
            .and_then(|op| op.bytes())
            .map(|bytes| bcs::from_bytes::<u128>(bytes));
        value.transpose().map_err(anyhow::Error::msg).unwrap()
    }
```
