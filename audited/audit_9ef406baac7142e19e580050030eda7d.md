# Audit Report

## Title
JWK Consensus Per-Key Mode: Semantic Validation Bypass Allows Commitment of Invalid Cryptographic Material On-Chain

## Summary
The `new_rb_request()` function in the per-key JWK consensus mode does not validate the semantic correctness of JWK cryptographic material before broadcasting. This allows syntactically valid but semantically invalid JWKs (e.g., RSA keys with malformed base64 encoding or incorrect modulus sizes) to be committed on-chain, causing denial-of-service for keyless authentication for the affected OIDC provider.

## Finding Description
The vulnerability exists in the JWK consensus reliable broadcast request creation flow: [1](#0-0) 

The `new_rb_request()` function calls `KeyLevelUpdate::try_from_issuer_level_repr()` which only validates that:
1. The `ProviderJWKs` contains exactly one JWK
2. The JWK can be deserialized from the Move `Any` type [2](#0-1) 

This validation does NOT check:
- Whether RSA modulus (`n`) contains valid base64 encoding
- Whether the modulus is the correct size (256 bytes)
- Whether RSA exponent (`e`) contains valid base64
- Whether the JWK's cryptographic parameters are mathematically valid

The JWK then flows through the consensus process and is committed on-chain via the Move function: [3](#0-2) 

The Move function performs version checking but NO cryptographic validation of the JWK material.

When keyless authentication is later attempted, the system calls `RSA_JWK::to_poseidon_scalar()`: [4](#0-3) 

This function validates the modulus by:
1. Base64 decoding the `n` field - fails if invalid base64
2. Checking the decoded size is exactly 256 bytes - fails if wrong size

If either check fails, the entire keyless authentication transaction fails, causing DoS.

**Attack Flow:**
1. Malicious/compromised OIDC provider serves JWKs with invalid base64 in modulus `n` (e.g., `"!!!invalid!!!"`)
2. JWK observer fetches these invalid JWKs from the OIDC endpoint
3. Validators observe and sign the same invalid JWKs (they all fetch from the same OIDC endpoint)
4. Consensus is reached and the invalid JWK is committed on-chain
5. Users attempt keyless authentication using that OIDC provider
6. Transaction validation calls `to_poseidon_scalar()` which fails on base64 decode
7. All keyless authentication for that issuer is blocked until governance removes the invalid JWK

## Impact Explanation
**HIGH Severity** - This qualifies as "Significant protocol violations" per the Aptos bug bounty criteria:

- **Availability Impact**: Complete denial-of-service for keyless authentication for the affected OIDC provider (e.g., Google, Apple, Facebook accounts)
- **Scope**: Affects all users relying on that OIDC provider for authentication
- **Duration**: Persists until governance intervention to remove the invalid JWK via patches
- **System Impact**: Validator nodes waste resources attempting to process transactions that will always fail

This breaks the **Deterministic Execution** and **Resource Limits** invariants because:
- Transaction validation behavior becomes non-deterministic (fails during JWK processing rather than proper validation)
- Resources are wasted processing transactions that cannot succeed

## Likelihood Explanation
**MEDIUM Likelihood:**

**Requirements:**
1. Malicious/compromised/buggy OIDC provider serving invalid JWKs, OR
2. Network attack during JWK fetch (less likely with HTTPS), OR
3. Bug in OIDC provider's JWK generation code

**Feasibility:**
- OIDC providers are external to Aptos and could be compromised
- Software bugs in JWK generation are realistic
- Multiple major OIDC providers are supported (Google, Apple, Facebook) - compromise of any causes impact
- Validators blindly fetch and agree on whatever the OIDC provider serves

**Mitigating Factors:**
- Requires majority of validators to observe the same invalid JWK
- Most established OIDC providers (Google, Apple) are well-maintained
- Issue is recoverable via governance, though this takes time

## Recommendation
Add semantic validation of JWK cryptographic material in `new_rb_request()` before broadcasting:

```rust
pub fn new_rb_request(
    epoch: u64,
    payload: &ProviderJWKs,
) -> anyhow::Result<ObservedKeyLevelUpdateRequest> {
    let KeyLevelUpdate { issuer, kid, to_upsert, .. } =
        KeyLevelUpdate::try_from_issuer_level_repr(payload)
            .context("new_rb_request failed with repr translation")?;
    
    // NEW: Validate JWK cryptographic material if present
    if let Some(ref jwk) = to_upsert {
        match jwk {
            JWK::RSA(rsa_jwk) => {
                // Validate RSA modulus is valid base64 and correct size
                rsa_jwk.to_poseidon_scalar()
                    .context("new_rb_request failed: invalid RSA modulus")?;
                
                // Validate RSA exponent is valid base64
                base64::decode_config(&rsa_jwk.e, URL_SAFE_NO_PAD)
                    .context("new_rb_request failed: invalid RSA exponent")?;
            },
            JWK::Unsupported(_) => {
                // Unsupported JWKs are allowed for future compatibility
            }
        }
    }
    
    Ok(ObservedKeyLevelUpdateRequest { epoch, issuer, kid })
}
```

Additionally, add validation in the JWK observer before proposing updates: [5](#0-4) 

Validate JWKs immediately after fetching from OIDC provider, before entering the consensus process.

## Proof of Concept
```rust
#[test]
fn test_invalid_jwk_validation_bypass() {
    use aptos_types::jwks::{ProviderJWKs, JWK, RSA_JWK};
    use crate::mode::per_key::PerKeyMode;
    use crate::mode::TConsensusMode;
    
    // Create a ProviderJWKs with invalid base64 in RSA modulus
    let invalid_rsa_jwk = RSA_JWK {
        kid: "test_key".to_string(),
        kty: "RSA".to_string(),
        alg: "RS256".to_string(),
        e: "AQAB".to_string(),
        n: "!!!INVALID_BASE64!!!".to_string(), // Invalid base64
    };
    
    let invalid_payload = ProviderJWKs {
        issuer: b"https://evil.oidc.provider".to_vec(),
        version: 1,
        jwks: vec![JWKMoveStruct::from(JWK::RSA(invalid_rsa_jwk))],
    };
    
    // This should fail but currently succeeds
    let result = PerKeyMode::new_rb_request(1, &invalid_payload);
    
    // VULNERABILITY: This passes when it should fail
    assert!(result.is_ok(), "Invalid JWK was accepted!");
    
    // Later, when trying to use this JWK for authentication, it will fail:
    let rsa_jwk = RSA_JWK {
        kid: "test_key".to_string(),
        kty: "RSA".to_string(),
        alg: "RS256".to_string(),
        e: "AQAB".to_string(),
        n: "!!!INVALID_BASE64!!!".to_string(),
    };
    
    // This is where it fails, causing DoS
    let poseidon_result = rsa_jwk.to_poseidon_scalar();
    assert!(poseidon_result.is_err(), "Expected base64 decode failure");
}
```

**Notes:**
- The vulnerability requires validators to observe invalid JWKs from OIDC providers
- While JWK fetching includes some validation in the pepper service, the consensus layer should independently validate before commitment
- The issue is exacerbated by per-key mode which processes individual JWKs, making validation more critical
- Recovery requires governance to patch out the invalid JWK, during which keyless auth is unavailable for that issuer

### Citations

**File:** crates/aptos-jwk-consensus/src/mode/per_key.rs (L32-40)
```rust
    fn new_rb_request(
        epoch: u64,
        payload: &ProviderJWKs,
    ) -> anyhow::Result<ObservedKeyLevelUpdateRequest> {
        let KeyLevelUpdate { issuer, kid, .. } =
            KeyLevelUpdate::try_from_issuer_level_repr(payload)
                .context("new_rb_request failed with repr translation")?;
        Ok(ObservedKeyLevelUpdateRequest { epoch, issuer, kid })
    }
```

**File:** types/src/jwks/mod.rs (L360-384)
```rust
    pub fn try_from_issuer_level_repr(repr: &ProviderJWKs) -> anyhow::Result<Self> {
        ensure!(
            repr.jwks.len() == 1,
            "wrapped repr of a key-level update should have exactly 1 jwk"
        );
        let jwk =
            JWK::try_from(&repr.jwks[0]).context("try_from_issuer_level_repr failed on JWK")?;
        let base_version = repr
            .version
            .checked_sub(1)
            .context("try_from_issuer_level_repr on version")?;
        Ok(Self {
            issuer: repr.issuer.clone(),
            base_version,
            kid: jwk.id(),
            to_upsert: match jwk {
                JWK::Unsupported(unsupported)
                    if unsupported.payload.as_slice() == DELETE_COMMAND_INDICATOR.as_bytes() =>
                {
                    None
                },
                _ => Some(jwk),
            },
        })
    }
```

**File:** aptos-move/framework/aptos-framework/sources/jwks.move (L462-505)
```text
    public fun upsert_into_observed_jwks(fx: &signer, provider_jwks_vec: vector<ProviderJWKs>) acquires ObservedJWKs, PatchedJWKs, Patches {
        system_addresses::assert_aptos_framework(fx);
        let observed_jwks = borrow_global_mut<ObservedJWKs>(@aptos_framework);

        if (features::is_jwk_consensus_per_key_mode_enabled()) {
            vector::for_each(provider_jwks_vec, |proposed_provider_jwks|{
                let maybe_cur_issuer_jwks = remove_issuer(&mut observed_jwks.jwks, proposed_provider_jwks.issuer);
                let cur_issuer_jwks = if (option::is_some(&maybe_cur_issuer_jwks)) {
                    option::extract(&mut maybe_cur_issuer_jwks)
                } else {
                    ProviderJWKs {
                        issuer: proposed_provider_jwks.issuer,
                        version: 0,
                        jwks: vector[],
                    }
                };
                assert!(cur_issuer_jwks.version + 1 == proposed_provider_jwks.version, error::invalid_argument(EUNEXPECTED_VERSION));
                vector::for_each(proposed_provider_jwks.jwks, |jwk|{
                    let variant_type_name = *string::bytes(copyable_any::type_name(&jwk.variant));
                    let is_delete = if (variant_type_name == b"0x1::jwks::UnsupportedJWK") {
                        let repr = copyable_any::unpack<UnsupportedJWK>(jwk.variant);
                        &repr.payload == &DELETE_COMMAND_INDICATOR
                    } else {
                        false
                    };
                    if (is_delete) {
                        remove_jwk(&mut cur_issuer_jwks, get_jwk_id(&jwk));
                    } else {
                        upsert_jwk(&mut cur_issuer_jwks, jwk);
                    }
                });
                cur_issuer_jwks.version = cur_issuer_jwks.version + 1;
                upsert_provider_jwks(&mut observed_jwks.jwks, cur_issuer_jwks);
            });
        } else {
            vector::for_each(provider_jwks_vec, |provider_jwks| {
                upsert_provider_jwks(&mut observed_jwks.jwks, provider_jwks);
            });
        };

        let epoch = reconfiguration::current_epoch();
        emit(ObservedJWKsUpdated { epoch, jwks: observed_jwks.jwks });
        regenerate_patched_jwks();
    }
```

**File:** types/src/jwks/rsa/mod.rs (L102-125)
```rust
    pub fn to_poseidon_scalar(&self) -> Result<ark_bn254::Fr> {
        let mut modulus = base64::decode_config(&self.n, URL_SAFE_NO_PAD)?;
        // The circuit only supports RSA256
        if modulus.len() != Self::RSA_MODULUS_BYTES {
            bail!(
                "Wrong modulus size, must be {} bytes",
                Self::RSA_MODULUS_BYTES
            );
        }

        // This is done to match the circuit, which requires the modulus in a verify specific format
        // due to how RSA verification is implemented
        modulus.reverse();

        let mut scalars = modulus
            .chunks(24) // Pack 3 64 bit limbs per scalar, so chunk into 24 bytes per scalar
            .map(|chunk| {
                poseidon_bn254::keyless::pack_bytes_to_one_scalar(chunk)
                    .expect("chunk converts to scalar")
            })
            .collect::<Vec<ark_bn254::Fr>>();
        scalars.push(ark_bn254::Fr::from(Self::RSA_MODULUS_BYTES as i32));
        poseidon_bn254::hash_scalars(scalars)
    }
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager/mod.rs (L184-228)
```rust
    pub fn process_new_observation(
        &mut self,
        issuer: Issuer,
        jwks: Vec<JWKMoveStruct>,
    ) -> Result<()> {
        debug!(
            epoch = self.epoch_state.epoch,
            issuer = String::from_utf8(issuer.clone()).ok(),
            "Processing new observation."
        );
        let state = self.states_by_issuer.entry(issuer.clone()).or_default();
        state.observed = Some(jwks.clone());
        if state.observed.as_ref() != state.on_chain.as_ref().map(ProviderJWKs::jwks) {
            let observed = ProviderJWKs {
                issuer: issuer.clone(),
                version: state.on_chain_version() + 1,
                jwks,
            };
            let signature = self
                .consensus_key
                .sign(&observed)
                .context("process_new_observation failed with signing error")?;
            let abort_handle = self
                .update_certifier
                .start_produce(
                    self.epoch_state.clone(),
                    observed.clone(),
                    self.qc_update_tx.clone(),
                )
                .context(
                    "process_new_observation failed with update_certifier.start_produce failure",
                )?;
            state.consensus_state = ConsensusState::InProgress {
                my_proposal: ObservedUpdate {
                    author: self.my_addr,
                    observed: observed.clone(),
                    signature,
                },
                abort_handle_wrapper: QuorumCertProcessGuard::new(abort_handle),
            };
            info!("[JWK] update observed, update={:?}", observed);
        }

        Ok(())
    }
```
