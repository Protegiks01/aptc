# Audit Report

## Title
Consensus Observer Publisher Accepts Unauthorized Subscriptions Without Validation

## Summary
The `ConsensusPublisher.process_network_message()` function accepts subscription requests from any connected peer without authorization checks or a formal handshake protocol. On VFN and public networks using `MaybeMutual` authentication, any peer can subscribe and receive consensus-critical messages, enabling information disclosure and resource exhaustion attacks.

## Finding Description

The consensus observer publisher lacks a formal subscription authorization protocol. When processing subscription requests, the publisher immediately adds any connected peer to the active subscribers list without validation. [1](#0-0) 

The `process_network_message()` function handles `Subscribe` requests by directly calling `add_active_subscriber()` without any checks for:
- Peer authorization or role verification
- Subscription initialization requirements  
- State synchronization readiness
- Rate limiting or subscription quotas

This contrasts with the observer side, which validates that messages only come from peers it has actively subscribed to: [2](#0-1) 

The vulnerability is exacerbated by the network authentication model. On VFN and public networks, the `HandshakeAuthMode::MaybeMutual` mode allows all inbound connections: [3](#0-2) 

The consensus observer is registered on all network types where enabled: [4](#0-3) 

Publishers are enabled by default on validators and VFNs: [5](#0-4) 

**Attack Path:**
1. Attacker establishes network connection to a VFN or validator on a VFN/public network (permitted by MaybeMutual authentication)
2. Attacker sends `ConsensusObserverRequest::Subscribe` RPC message
3. Publisher accepts subscription without validation
4. Attacker receives all consensus messages: `OrderedBlock`, `CommitDecision`, and `BlockPayload`

These messages contain consensus-critical data including block proposals, ledger info with validator signatures, commit proofs, and transaction payloads.

## Impact Explanation

This vulnerability qualifies as **Medium severity** per Aptos bug bounty criteria:

1. **Information Disclosure**: Unauthorized peers gain early access to consensus messages before blocks are finalized and publicly available. While this data eventually becomes public, early access could enable front-running or other timing-based attacks.

2. **Resource Exhaustion**: Multiple malicious peers can subscribe simultaneously, consuming:
   - Memory for maintaining active subscriber lists
   - Network bandwidth for broadcasting consensus messages to unauthorized peers
   - CPU resources for message serialization and transmission

3. **Protocol Violations**: Peers can subscribe without proper state synchronization, receiving messages they may not be prepared to process. This violates the expected protocol flow where observers should be properly initialized before receiving consensus data.

The impact is classified as "state inconsistencies requiring intervention" under Medium severity, as operators may need to manually identify and remove malicious subscribers consuming resources.

## Likelihood Explanation

This vulnerability is **highly likely** to occur because:

1. **Low Attack Barrier**: Any peer capable of establishing a network connection can exploit this. On VFN and public networks, the MaybeMutual authentication mode explicitly allows all inbound connections.

2. **No Detection**: There are no logging mechanisms to identify unauthorized subscriptions versus legitimate ones, making detection difficult.

3. **Automatic Exploitation**: The attack requires only sending a single Subscribe RPC message - no complex setup or timing requirements.

4. **Wide Attack Surface**: Publishers run on all validators and VFNs in the network, providing multiple potential targets.

The only mitigating factor is that network-level connection limits may bound the number of malicious subscriptions, but this doesn't prevent the attack entirely.

## Recommendation

Implement a multi-layered subscription authorization mechanism:

1. **Add Peer Role Verification**: Check if the subscribing peer has an appropriate role (e.g., only allow VFN or PFN roles to subscribe).

2. **Implement Subscription Limits**: Enforce per-peer and global subscription limits to prevent resource exhaustion.

3. **Add Formal Handshake Protocol**: Require subscribers to prove state synchronization readiness before receiving consensus messages.

4. **Enable Authorization Checks**: Verify subscribers against a whitelist of authorized observers or implement capability-based authorization.

**Proposed Fix:**

```rust
fn process_network_message(&self, network_message: ConsensusPublisherNetworkMessage) {
    let (peer_network_id, message, response_sender) = network_message.into_parts();
    
    // Update metrics
    metrics::increment_counter(
        &metrics::PUBLISHER_RECEIVED_REQUESTS,
        message.get_label(),
        &peer_network_id,
    );

    match message {
        ConsensusObserverRequest::Subscribe => {
            // NEW: Validate peer authorization
            if !self.is_peer_authorized_to_subscribe(&peer_network_id) {
                warn!(LogSchema::new(LogEntry::ConsensusPublisher)
                    .message(&format!(
                        "Rejected unauthorized subscription from peer: {:?}",
                        peer_network_id
                    )));
                response_sender.send(ConsensusObserverResponse::UnsubscribeAck);
                return;
            }
            
            // NEW: Check subscription limits
            if self.get_active_subscribers().len() >= self.consensus_observer_config.max_subscribers {
                warn!(LogSchema::new(LogEntry::ConsensusPublisher)
                    .message(&format!(
                        "Rejected subscription due to limit from peer: {:?}",
                        peer_network_id
                    )));
                response_sender.send(ConsensusObserverResponse::UnsubscribeAck);
                return;
            }
            
            // Existing subscription logic
            self.add_active_subscriber(peer_network_id);
            info!(LogSchema::new(LogEntry::ConsensusPublisher)
                .event(LogEvent::Subscription)
                .message(&format!(
                    "Authorized peer subscribed: {:?}",
                    peer_network_id
                )));
            response_sender.send(ConsensusObserverResponse::SubscribeAck);
        },
        // ... rest unchanged
    }
}

// NEW: Authorization check
fn is_peer_authorized_to_subscribe(&self, peer_network_id: &PeerNetworkId) -> bool {
    // Get peer metadata
    let peers_and_metadata = self.consensus_observer_client.get_peers_and_metadata();
    if let Ok(metadata_map) = peers_and_metadata.get_connected_peers_and_metadata() {
        if let Some(metadata) = metadata_map.get(peer_network_id) {
            // Verify peer supports consensus observer protocols
            if !metadata.supports_protocol(ProtocolId::ConsensusObserver) ||
               !metadata.supports_protocol(ProtocolId::ConsensusObserverRpc) {
                return false;
            }
            
            // Only allow VFN and PFN roles to subscribe (not other validators)
            let peer_role = metadata.get_connection_metadata().role;
            return matches!(peer_role, PeerRole::ValidatorFullNode | PeerRole::Unknown);
        }
    }
    false
}
```

Add configuration parameter:
```rust
pub max_subscribers: u64, // Add to ConsensusObserverConfig
```

## Proof of Concept

```rust
#[tokio::test]
async fn test_unauthorized_subscription_vulnerability() {
    use aptos_config::network_id::NetworkId;
    use aptos_network::application::storage::PeersAndMetadata;
    use aptos_types::PeerId;
    
    // Create a consensus observer config and client
    let consensus_observer_config = ConsensusObserverConfig {
        publisher_enabled: true,
        ..Default::default()
    };
    
    let network_ids = &[NetworkId::Vfn, NetworkId::Public];
    let peers_and_metadata = PeersAndMetadata::new(network_ids);
    let network_client = NetworkClient::new(vec![], vec![], HashMap::new(), peers_and_metadata.clone());
    let consensus_observer_client = Arc::new(ConsensusObserverClient::new(network_client));
    
    // Create publisher
    let (consensus_publisher, _) = ConsensusPublisher::new(
        consensus_observer_config,
        consensus_observer_client,
    );
    
    // Simulate malicious peer connecting (on VFN network with MaybeMutual auth)
    let malicious_peer = PeerNetworkId::new(NetworkId::Vfn, PeerId::random());
    let connection_metadata = ConnectionMetadata::mock(malicious_peer.peer_id());
    peers_and_metadata
        .insert_connection_metadata(malicious_peer, connection_metadata)
        .unwrap();
    
    // Malicious peer sends Subscribe request - NO authorization check!
    let subscribe_request = ConsensusObserverRequest::Subscribe;
    let (response_sender, _rx) = ResponseSender::new_for_test();
    let network_message = ConsensusPublisherNetworkMessage::new(
        malicious_peer,
        subscribe_request,
        response_sender,
    );
    
    // Process subscription - will succeed without authorization
    consensus_publisher.process_network_message(network_message);
    
    // VULNERABILITY: Malicious peer is now in active subscribers
    let active_subscribers = consensus_publisher.get_active_subscribers();
    assert!(active_subscribers.contains(&malicious_peer), 
        "Unauthorized peer successfully subscribed!");
    
    // The malicious peer will now receive ALL consensus messages:
    // - OrderedBlock (blocks and proofs)
    // - CommitDecision (commit decisions)  
    // - BlockPayload (transaction payloads)
    println!("VULNERABILITY CONFIRMED: Unauthorized peer {:?} successfully subscribed", malicious_peer);
}
```

## Notes

This vulnerability demonstrates a fundamental principle-of-least-privilege violation in the consensus observer architecture. While network-level authentication verifies peer identity, application-level authorization is required to determine subscription permissions. The asymmetry between the observer's strict message validation and the publisher's permissive subscription acceptance creates an exploitable security gap, particularly on networks using MaybeMutual authentication that allow unrestricted inbound connections.

### Citations

**File:** consensus/src/consensus_observer/publisher/consensus_publisher.rs (L168-208)
```rust
    fn process_network_message(&self, network_message: ConsensusPublisherNetworkMessage) {
        // Unpack the network message
        let (peer_network_id, message, response_sender) = network_message.into_parts();

        // Update the RPC request counter
        metrics::increment_counter(
            &metrics::PUBLISHER_RECEIVED_REQUESTS,
            message.get_label(),
            &peer_network_id,
        );

        // Handle the message
        match message {
            ConsensusObserverRequest::Subscribe => {
                // Add the peer to the set of active subscribers
                self.add_active_subscriber(peer_network_id);
                info!(LogSchema::new(LogEntry::ConsensusPublisher)
                    .event(LogEvent::Subscription)
                    .message(&format!(
                        "New peer subscribed to consensus updates! Peer: {:?}",
                        peer_network_id
                    )));

                // Send a simple subscription ACK
                response_sender.send(ConsensusObserverResponse::SubscribeAck);
            },
            ConsensusObserverRequest::Unsubscribe => {
                // Remove the peer from the set of active subscribers
                self.remove_active_subscriber(&peer_network_id);
                info!(LogSchema::new(LogEntry::ConsensusPublisher)
                    .event(LogEvent::Subscription)
                    .message(&format!(
                        "Peer unsubscribed from consensus updates! Peer: {:?}",
                        peer_network_id
                    )));

                // Send a simple unsubscription ACK
                response_sender.send(ConsensusObserverResponse::UnsubscribeAck);
            },
        }
    }
```

**File:** consensus/src/consensus_observer/observer/subscription_manager.rs (L80-103)
```rust
    /// Checks if the subscription to the given peer is still healthy.
    /// If not, an error explaining why it is unhealthy is returned.
    fn check_subscription_health(
        &mut self,
        connected_peers_and_metadata: &HashMap<PeerNetworkId, PeerMetadata>,
        peer_network_id: PeerNetworkId,
        skip_peer_optimality_check: bool,
    ) -> Result<(), Error> {
        // Get the active subscription for the peer
        let mut active_observer_subscriptions = self.active_observer_subscriptions.lock();
        let active_subscription = active_observer_subscriptions.get_mut(&peer_network_id);

        // Check the health of the subscription
        match active_subscription {
            Some(active_subscription) => active_subscription.check_subscription_health(
                connected_peers_and_metadata,
                skip_peer_optimality_check,
            ),
            None => Err(Error::UnexpectedError(format!(
                "The subscription to peer: {:?} is not active!",
                peer_network_id
            ))),
        }
    }
```

**File:** network/framework/src/noise/handshake.rs (L95-98)
```rust
    /// In `MaybeMutual` mode, the dialer authenticates the server and the server will allow all
    /// inbound connections from any peer but will mark connections as `Trusted` if the incoming
    /// connection is apart of its trusted peers set.
    MaybeMutual(Arc<PeersAndMetadata>),
```

**File:** aptos-node/src/network.rs (L336-358)
```rust
        // Register consensus observer (both client and server) with the network
        if node_config
            .consensus_observer
            .is_observer_or_publisher_enabled()
        {
            // Create the network handle for this network type
            let network_handle = register_client_and_service_with_network(
                &mut network_builder,
                network_id,
                &network_config,
                consensus_observer_network_configuration(node_config),
                false,
            );

            // Add the network handle to the set of handles
            if let Some(consensus_observer_network_handles) =
                &mut consensus_observer_network_handles
            {
                consensus_observer_network_handles.push(network_handle);
            } else {
                consensus_observer_network_handles = Some(vec![network_handle]);
            }
        }
```

**File:** config/src/config/consensus_observer_config.rs (L112-128)
```rust
            NodeType::Validator => {
                if ENABLE_ON_VALIDATORS && !publisher_manually_set {
                    // Only enable the publisher for validators
                    consensus_observer_config.publisher_enabled = true;
                    modified_config = true;
                }
            },
            NodeType::ValidatorFullnode => {
                if ENABLE_ON_VALIDATOR_FULLNODES
                    && !observer_manually_set
                    && !publisher_manually_set
                {
                    // Enable both the observer and the publisher for VFNs
                    consensus_observer_config.observer_enabled = true;
                    consensus_observer_config.publisher_enabled = true;
                    modified_config = true;
                }
```
