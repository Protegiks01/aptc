# Audit Report

## Title
Sequence Number Desynchronization in CoinClient::transfer() Due to Non-Atomic Sign-Submit Operation

## Summary
The `CoinClient::transfer()` function increments the `LocalAccount`'s sequence number during transaction signing but fails to roll it back when submission fails, causing permanent desynchronization between the SDK's local state and the blockchain's on-chain state. While the mutable borrow prevents concurrent calls, it does not prevent sequence number desynchronization from sequential failed submissions.

## Finding Description
The vulnerability lies in the non-atomic nature of the sign-and-submit operation in `CoinClient::transfer()`: [1](#0-0) 

The function calls `get_signed_transfer_txn()` which internally signs the transaction and increments the sequence number: [2](#0-1) 

The critical issue occurs when `sign_with_transaction_builder()` is called at line 96. This method increments the sequence number atomically: [3](#0-2) 

The sequence number increment happens via `fetch_add()` which is irreversible: [4](#0-3) 

**The Problem Flow:**
1. Transaction is signed â†’ sequence number incremented from N to N+1
2. API submission fails (network error, timeout, API unavailable)
3. Error is returned to caller BUT sequence number remains at N+1
4. Blockchain still expects sequence number N (never received the transaction)
5. Next transaction uses N+1, gets rejected with `SEQUENCE_NUMBER_TOO_NEW`

The blockchain strictly enforces that transaction sequence numbers must exactly match the account's on-chain sequence number: [5](#0-4) 

This error code is mapped to `SEQUENCE_NUMBER_TOO_NEW`: [6](#0-5) 

**Why the Mutable Borrow Doesn't Prevent This:**
The `&mut LocalAccount` parameter prevents *concurrent* calls at compile time, but the issue occurs in *sequential* calls where the first call fails. Each call releases the mutable borrow upon completion (even with an error), so the next call proceeds with a desynchronized sequence number.

## Impact Explanation
This qualifies as **Medium Severity** under the Aptos bug bounty program:
- **State inconsistencies requiring intervention**: The SDK's `LocalAccount` state becomes permanently desynchronized from blockchain state
- **Manual intervention required**: Users must call `decrement_sequence_number()` or `set_sequence_number()` to recover, which is not documented in the API
- **Transaction failures**: All subsequent transactions fail until manual recovery occurs
- **No automatic recovery**: Unlike the bulk transaction coordinator which implements rollback logic, the `CoinClient` provides no automatic recovery mechanism [7](#0-6) 

## Likelihood Explanation
**High likelihood** in production environments:
- Network failures, API timeouts, and connectivity issues are common in distributed systems
- The SDK is intended for client-side use where network reliability varies
- No documentation warns users about this behavior
- The `&mut LocalAccount` parameter creates a false sense of safety
- The issue is not obvious without deep understanding of the implementation

## Recommendation
Implement automatic sequence number rollback on submission failure. Modify `transfer()` to:

1. Store the initial sequence number before signing
2. On submission failure, roll back to the initial sequence number
3. Alternatively, implement retry logic with proper sequence number management

**Recommended Fix:**
```rust
pub async fn transfer(
    &self,
    from_account: &mut LocalAccount,
    to_account: AccountAddress,
    amount: u64,
    options: Option<TransferOptions<'_>>,
) -> Result<PendingTransaction> {
    let initial_seq_num = from_account.sequence_number();
    let signed_txn = self
        .get_signed_transfer_txn(from_account, to_account, amount, options)
        .await?;
    
    match self.api_client.submit(&signed_txn).await {
        Ok(response) => Ok(response.into_inner()),
        Err(e) => {
            // Rollback sequence number on submission failure
            from_account.set_sequence_number(initial_seq_num);
            Err(e).context("Failed to submit transfer transaction")
        }
    }
}
```

## Proof of Concept
```rust
use aptos_sdk::{
    coin_client::CoinClient,
    rest_client::Client,
    types::LocalAccount,
};
use anyhow::Result;

#[tokio::test]
async fn test_sequence_number_desync_on_failure() -> Result<()> {
    // Setup: Create a LocalAccount with sequence number 0
    let mut account = LocalAccount::generate(&mut rand::thread_rng());
    account.set_sequence_number(5); // Start at seq num 5
    
    // Simulate API client that will fail on submission
    let api_client = Client::new(url::Url::parse("http://invalid-url:8080")?);
    let coin_client = CoinClient::new(&api_client);
    
    // Attempt transfer - this will fail during submission
    // but sequence number will already be incremented during signing
    let result = coin_client.transfer(
        &mut account,
        AccountAddress::random(),
        100,
        None
    ).await;
    
    // Transfer fails as expected
    assert!(result.is_err());
    
    // BUG: Sequence number is now 6 instead of 5
    // Even though no transaction was submitted to the blockchain
    assert_eq!(account.sequence_number(), 6); 
    
    // Blockchain still expects sequence number 5
    // Next transaction with sequence number 6 will fail with SEQUENCE_NUMBER_TOO_NEW
    
    // Manual recovery required:
    // account.set_sequence_number(5);
    
    Ok(())
}
```

## Notes
While the mutable borrow successfully prevents concurrent access at compile time (answering the first part of the security question), it does not prevent sequence number desynchronization from sequential failed submissions (answering the second part). The root cause is the non-atomic nature of the sign-and-submit operation combined with lack of error-recovery rollback logic, which is a known pattern in other parts of the codebase but missing from the `CoinClient` implementation.

### Citations

**File:** sdk/src/coin_client.rs (L36-53)
```rust
    pub async fn transfer(
        &self,
        from_account: &mut LocalAccount,
        to_account: AccountAddress,
        amount: u64,
        options: Option<TransferOptions<'_>>,
    ) -> Result<PendingTransaction> {
        let signed_txn = self
            .get_signed_transfer_txn(from_account, to_account, amount, options)
            .await?;
        Ok(self
            .api_client
            .submit(&signed_txn)
            .await
            .context("Failed to submit transfer transaction")?
            .into_inner())
        // <:!:section_1
    }
```

**File:** sdk/src/coin_client.rs (L55-98)
```rust
    pub async fn get_signed_transfer_txn(
        &self,
        from_account: &mut LocalAccount,
        to_account: AccountAddress,
        amount: u64,
        options: Option<TransferOptions<'_>>,
    ) -> Result<SignedTransaction> {
        let options = options.unwrap_or_default();

        // :!:>section_1
        let chain_id = self
            .api_client
            .get_index()
            .await
            .context("Failed to get chain ID")?
            .inner()
            .chain_id;
        let transaction_builder = TransactionBuilder::new(
            TransactionPayload::EntryFunction(EntryFunction::new(
                ModuleId::new(
                    AccountAddress::ONE,
                    Identifier::new("aptos_account").unwrap(),
                ),
                Identifier::new("transfer_coins").unwrap(),
                vec![TypeTag::from_str(options.coin_type).unwrap()],
                vec![
                    bcs::to_bytes(&to_account).unwrap(),
                    bcs::to_bytes(&amount).unwrap(),
                ],
            )),
            SystemTime::now()
                .duration_since(UNIX_EPOCH)
                .unwrap()
                .as_secs()
                + options.timeout_secs,
            ChainId::new(chain_id),
        )
        .sender(from_account.address())
        .sequence_number(from_account.sequence_number())
        .max_gas_amount(options.max_gas_amount)
        .gas_unit_price(options.gas_unit_price);
        let signed_txn = from_account.sign_with_transaction_builder(transaction_builder);
        Ok(signed_txn)
    }
```

**File:** sdk/src/types.rs (L354-368)
```rust
    pub fn sign_with_transaction_builder(&self, builder: TransactionBuilder) -> SignedTransaction {
        let raw_txn = if builder.has_nonce() {
            // Do not increment sequence number for orderless transactions.
            builder
                .sender(self.address())
                .sequence_number(u64::MAX)
                .build()
        } else {
            builder
                .sender(self.address())
                .sequence_number(self.increment_sequence_number())
                .build()
        };
        self.sign_transaction(raw_txn)
    }
```

**File:** sdk/src/types.rs (L546-548)
```rust
    pub fn increment_sequence_number(&self) -> u64 {
        self.sequence_number.fetch_add(1, Ordering::SeqCst)
    }
```

**File:** aptos-move/framework/aptos-framework/sources/transaction_validation.move (L238-241)
```text
            assert!(
                txn_sequence_number == account_sequence_number,
                error::invalid_argument(PROLOGUE_ESEQUENCE_NUMBER_TOO_NEW)
            );
```

**File:** aptos-move/aptos-vm/src/errors.rs (L130-130)
```rust
                (INVALID_ARGUMENT, ESEQUENCE_NUMBER_TOO_NEW) => StatusCode::SEQUENCE_NUMBER_TOO_NEW,
```

**File:** experimental/bulk-txn-submit/src/coordinator.rs (L600-606)
```rust
        if let Some(min_failed) = min_failed {
            account.set_sequence_number(min_failed);
            if start_seq_num == account.sequence_number() {
                tokio::time::sleep(poll_interval).await;
                continue;
            }
        }
```
