# Audit Report

## Title
Node Health Checker Lacks Rate Limiting, Enabling Amplified DoS Attacks on Baseline Node Metrics Endpoints

## Summary
The Node Health Checker (NHC) service lacks rate limiting on its `/check` endpoint and creates separate, non-deduplicated provider instances for each request. An attacker can exploit this to send numerous concurrent requests with the target node URL set to a baseline node's address, causing the NHC service to amplify the attack by making many concurrent HTTP requests to the baseline node's `/metrics` endpoint, effectively bypassing cache protections and overwhelming the metrics infrastructure.

## Finding Description

The Node Health Checker service provides a `/check` endpoint that evaluates target nodes against baseline configurations. [1](#0-0) 

The security issue exists because:

1. **No rate limiting exists on the `/check` endpoint** - The server accepts unlimited concurrent requests from any client. [2](#0-1) 

2. **Target providers are created per-request with separate caches** - Each `/check` request creates new `MetricsProvider` instances for the target node, each with its own `OutputCache`. [3](#0-2) 

3. **Attacker controls the target node URL** - Clients can specify any URL as the target, including the baseline node's URL. [4](#0-3) 

4. **Multiple checkers query metrics multiple times** - Checkers like `ConsensusRoundChecker` query the metrics endpoint twice per request. [5](#0-4) 

5. **Cache bypass** - While baseline providers are cached and shared via `Arc` for normal operations, when an attacker sets the target URL to the baseline node's address, new target providers are created that bypass the baseline provider cache. [6](#0-5) 

**Attack Path:**

1. Attacker identifies a baseline configuration with a known baseline node URL (e.g., `http://baseline.aptos.network`)
2. Attacker sends 100 concurrent requests: `GET /check?baseline_configuration_id=devnet_fullnode&node_url=http://baseline.aptos.network&metrics_port=9101`
3. For each request, the NHC:
   - Creates a new `MetricsProvider` for the target (baseline node)
   - Runs 5-10 checkers concurrently
   - Each checker queries `/metrics` at least once, some twice
   - Results in ~500-1000 HTTP requests to the baseline node's `/metrics` endpoint
4. With default cache TTL of 1 second [7](#0-6) , the attacker can repeat this attack continuously
5. The baseline node's metrics endpoint becomes overwhelmed, affecting monitoring systems and potentially node performance

## Impact Explanation

This vulnerability qualifies as **Medium severity** based on the following impact:

1. **Availability Impact**: The `/metrics` endpoint can be rendered unavailable or severely degraded, affecting:
   - Real-time monitoring and alerting systems
   - Prometheus/Grafana dashboards
   - Operational visibility into node health

2. **Performance Degradation**: If the baseline node is a validator, the resource consumption (CPU, memory, network bandwidth) from handling excessive metrics requests could cause "Validator node slowdowns" which the Aptos bug bounty program classifies as High severity.

3. **Amplification Factor**: The NHC service acts as an amplification vector - each attacker request generates 5-10+ requests to the target, multiplied by the number of concurrent checkers and their multiple metric queries.

4. **Service Abuse**: Legitimate users of the NHC service may be unable to check their nodes if the baseline is overwhelmed.

However, this does not directly affect consensus, state integrity, or funds, keeping it below Critical/High severity thresholds.

## Likelihood Explanation

This vulnerability is **highly likely** to be exploited because:

1. **Low attack complexity**: Attacker only needs to send HTTP GET requests
2. **No authentication required**: The `/check` endpoint is publicly accessible
3. **Baseline URLs are often public knowledge**: Aptos Foundation's baseline nodes are likely documented or discoverable
4. **No existing mitigations**: There is no rate limiting, no request deduplication, and no per-IP throttling visible in the codebase
5. **Immediate impact**: The attack takes effect immediately with no setup required

The only limiting factor is that the attacker must know or discover the baseline node's URL, which is typically public information.

## Recommendation

Implement the following security controls:

1. **Add rate limiting per IP address**:
   - Use the `poem` middleware or external rate limiter (e.g., Redis-based)
   - Limit to 10 requests per minute per IP address
   - Return HTTP 429 (Too Many Requests) when exceeded

2. **Implement request deduplication**:
   - Cache active requests by target node URL
   - If a request for the same target is in progress, wait for it and return the cached result
   - This prevents concurrent requests from creating duplicate providers

3. **Add global request throttling**:
   - Limit total concurrent `/check` requests across all clients
   - Use a semaphore with a maximum of 100 concurrent requests

4. **Implement target URL validation**:
   - Maintain a blocklist of sensitive URLs (including baseline nodes)
   - Reject requests where `target_url` matches a baseline node URL
   - Return HTTP 400 with appropriate error message

**Example fix** for rate limiting (add to `run.rs`):

```rust
// Add to dependencies: tower = { version = "0.4", features = ["limit"] }
use tower::limit::RateLimitLayer;
use std::time::Duration;

// In run.rs, before .with(cors):
.with(RateLimitLayer::new(
    10, // max requests
    Duration::from_secs(60) // per 60 seconds
))
```

## Proof of Concept

**Prerequisites:**
- Running NHC service with baseline configuration
- Baseline node URL: `http://baseline.example.com:9101`

**Attack script** (using `curl` and bash):

```bash
#!/bin/bash

NHC_URL="http://localhost:20121"
BASELINE_CONFIG="devnet_fullnode"
TARGET_URL="http://baseline.example.com"  # Set to baseline node
METRICS_PORT=9101
CONCURRENT_REQUESTS=100

# Function to send a single request
send_request() {
    curl -s "${NHC_URL}/check?baseline_configuration_id=${BASELINE_CONFIG}&node_url=${TARGET_URL}&metrics_port=${METRICS_PORT}" \
        -o /dev/null -w "HTTP %{http_code}\n" &
}

# Send concurrent requests
echo "Sending ${CONCURRENT_REQUESTS} concurrent requests to NHC..."
for i in $(seq 1 $CONCURRENT_REQUESTS); do
    send_request
done

wait
echo "Attack complete. Check baseline node metrics endpoint for overload."
```

**Expected behavior (vulnerable):**
- NHC accepts all 100 requests
- Each request creates separate providers
- Baseline node receives ~500-1000 HTTP requests to `/metrics`
- Baseline node's metrics endpoint becomes slow or unresponsive
- Monitoring systems report errors

**Expected behavior (patched):**
- After 10 requests from same IP, NHC returns HTTP 429
- Subsequent requests are rejected
- Baseline node receives limited number of requests
- Service remains available for legitimate users

**Verification:**
Monitor the baseline node's HTTP access logs during the attack:
```bash
tail -f /var/log/aptos/metrics_access.log | grep "GET /metrics"
```

You should observe a burst of requests during the attack period, demonstrating the amplification effect.

### Citations

**File:** ecosystem/node-checker/src/server/api.rs (L29-45)
```rust
    #[oai(path = "/check", method = "get")]
    async fn check(
        &self,
        /// The ID of the baseline node configuration to use for the evaluation, e.g. devnet_fullnode
        baseline_configuration_id: Query<String>,
        /// The URL of the node to check, e.g. http://44.238.19.217 or http://fullnode.mysite.com
        node_url: Query<Url>,
        /// If given, we will assume the metrics service is available at the given port.
        metrics_port: Query<Option<u16>>,
        /// If given, we will assume the API is available at the given port.
        api_port: Query<Option<u16>>,
        /// If given, we will assume that clients can communicate with your node via noise at the given port.
        noise_port: Query<Option<u16>>,
        /// A public key for the node, e.g. 0x44fd1324c66371b4788af0b901c9eb8088781acb29e6b8b9c791d5d9838fbe1f.
        /// This is only necessary for certain checkers, e.g. HandshakeChecker.
        public_key: Query<Option<String>>,
    ) -> poem::Result<Json<CheckSummary>> {
```

**File:** ecosystem/node-checker/src/server/run.rs (L53-66)
```rust
    Server::new(TcpListener::bind((
        args.server_args.listen_address,
        args.server_args.listen_port,
    )))
    .run(
        Route::new()
            .nest(api_endpoint, api_service)
            .nest("/spec", ui)
            .at("/spec.json", spec_json)
            .at("/spec.yaml", spec_yaml)
            .with(cors),
    )
    .await
    .map_err(anyhow::Error::msg)
```

**File:** ecosystem/node-checker/src/runner/sync_runner.rs (L104-111)
```rust
        if let Ok(metrics_client) = target_node_address.get_metrics_client(Duration::from_secs(4)) {
            let metrics_client = Arc::new(metrics_client);
            provider_collection.target_metrics_provider = Some(MetricsProvider::new(
                self.provider_configs.metrics.clone(),
                metrics_client.clone(),
                target_node_address.url.clone(),
                target_node_address.get_metrics_port().unwrap(),
            ));
```

**File:** ecosystem/node-checker/src/checker/consensus_round.rs (L89-103)
```rust
        let first_scrape = match target_metrics_provider.provide().await {
            Ok(scrape) => scrape,
            Err(e) => {
                return Ok(vec![Self::build_result(
                    "Failed to check consensus round".to_string(),
                    0,
                    format!(
                        "Failed to scrape metrics from your node (1st time): {:#}",
                        e
                    ),
                )])
            },
        };

        tokio::time::sleep(target_metrics_provider.config.common.check_delay()).await;
```

**File:** ecosystem/node-checker/src/provider/provider_collection.rs (L36-40)
```rust
    /// Provider that returns a metrics scrape.
    pub baseline_metrics_provider: Option<Arc<MetricsProvider>>,

    /// Provider that returns a metrics scrape.
    pub target_metrics_provider: Option<MetricsProvider>,
```

**File:** ecosystem/node-checker/src/provider/mod.rs (L59-62)
```rust

    fn default_cache_ttl_ms() -> u64 {
        1000
    }
```
