# Audit Report

## Title
PackageMetadata Source Digest Forgery - No Cryptographic Verification During Publishing

## Summary
The `PackageMetadata.source_digest` field is never cryptographically verified against actual module bytecode during package publishing. This allows publishers to provide arbitrary source_digest values that don't correspond to the deployed bytecode, breaking the integrity guarantee that source_digest is supposed to provide.

## Finding Description

The Aptos package publishing system stores `PackageMetadata` (including `source_digest` - a SHA256 hash of source files) separately from module bytecode, but never verifies that they correspond to each other.

**The Flow:**

1. In `publish_package_txn`, PackageMetadata is deserialized from bytes without any verification: [1](#0-0) 

2. The metadata (including `source_digest`) is stored directly in `PackageRegistry`: [2](#0-1) 

3. Module names are extracted from the metadata and passed to `request_publish`: [3](#0-2) 

4. The VM validates bytecode structure and module names match, but NEVER verifies `source_digest`: [4](#0-3) 

5. Source digest verification only exists in the CLI tool `VerifyPackage` command, which is optional and separate from publishing: [5](#0-4) [6](#0-5) 

**Attack Scenario:**

A publisher (malicious or compromised) can:
1. Create `PackageMetadata` with `source_digest` claiming to match trusted source code (e.g., "abc123...")
2. Provide completely different, malicious bytecode in the `code` parameter
3. Call `publish_package_txn` - the transaction succeeds
4. On-chain `PackageRegistry` shows `source_digest = "abc123..."` 
5. Users/contracts checking `source_digest` believe the code is legitimate
6. Actual deployed bytecode executes malicious logic

This also affects the `ReleaseBundle` deserialization in cached-packages: [7](#0-6) 

The bundle is deserialized without any cryptographic verification that the bytecode matches the metadata's `source_digest`.

## Impact Explanation

**Critical Severity** - This breaks multiple security invariants:

1. **Deterministic Execution Violation**: If different build systems produce different bytecode but with the same claimed `source_digest`, validators could execute different code, breaking consensus.

2. **Trust Anchor Compromise**: The `source_digest` is documented as a cryptographic hash meant to verify source authenticity: [8](#0-7) 

Without verification, this trust anchor is meaningless.

3. **Supply Chain Attack Vector**: Compromised build systems or malicious framework updates could deploy arbitrary code while appearing legitimate on-chain.

4. **Governance Risk**: Framework upgrade proposals rely on source verification, but forged `source_digest` values undermine this process.

## Likelihood Explanation

**High Likelihood** - This vulnerability is:
- Always present in the current codebase
- Exploitable by any authorized publisher (not just privileged insiders)
- Requires no special conditions or timing
- Already exists in production without mitigation

The only limiting factor is that publishing requires permission, but any authorized publisher (including framework maintainers) could exploit this intentionally or accidentally.

## Recommendation

**Implement cryptographic verification during publishing:**

1. **During `publish_package_txn`**: Compute the actual source digest from the provided bytecode modules and verify it matches `PackageMetadata.source_digest` before storing.

2. **Add per-module hashes**: Extend `ModuleMetadata` to include a `bytecode_hash` field and verify each module's hash during publishing.

3. **Mandatory verification**: Make source digest verification mandatory in `publish_package`, not optional:

```rust
// In publish_package, after line 182:
verify_source_digest(&pack, &code)?;

fun verify_source_digest(metadata: &PackageMetadata, code: &vector<vector<u8>>): Result<()> {
    // Compute hash of actual bytecode
    let computed_digest = compute_bytecode_digest(code);
    
    // Verify against claimed source_digest
    if computed_digest != metadata.source_digest {
        return Err(error::invalid_argument(ESOURCE_DIGEST_MISMATCH));
    }
    Ok(())
}
```

4. **For ReleaseBundle deserialization**: Add verification in cached-packages that the stored bytecode matches the metadata.

## Proof of Concept

```move
// This Move test demonstrates the vulnerability
#[test(publisher = @0x42)]
fun test_forged_source_digest(publisher: &signer) {
    use aptos_framework::code;
    use std::string;
    
    // Create PackageMetadata with FORGED source_digest
    // claiming it matches some "trusted" source code
    let fake_metadata = PackageMetadata {
        name: string::utf8(b"malicious_package"),
        upgrade_policy: code::upgrade_policy_compat(),
        upgrade_number: 0,
        source_digest: string::utf8(b"FAKE_TRUSTED_HASH_abc123"),  // FORGED!
        manifest: vector::empty(),
        modules: vector[
            ModuleMetadata {
                name: string::utf8(b"evil_module"),
                source: vector::empty(),
                source_map: vector::empty(),
                extension: option::none()
            }
        ],
        deps: vector::empty(),
        extension: option::none()
    };
    
    // Provide DIFFERENT malicious bytecode
    let malicious_code = vector[
        x"a11ceb0b..." // Completely different bytecode with backdoor
    ];
    
    // Serialize metadata
    let metadata_bytes = bcs::to_bytes(&fake_metadata);
    
    // Publish - THIS SUCCEEDS despite mismatch!
    code::publish_package_txn(publisher, metadata_bytes, malicious_code);
    
    // On-chain registry now shows forged source_digest
    // Users trusting this digest will execute malicious code
    assert!(registry_shows_forged_digest(@0x42), 0);
}
```

The test would pass, demonstrating that forged `source_digest` values are accepted without verification, allowing unauthorized module modifications masked by legitimate-looking metadata.

## Notes

This vulnerability exists at multiple layers:
- ReleaseBundle deserialization (cached-packages)  
- On-chain package publishing (code.move)
- VM validation (aptos_vm.rs)

None of these layers verify cryptographic integrity between `PackageMetadata` and actual bytecode. The `source_digest` field is effectively decorative, providing no security guarantee despite being documented as a cryptographic hash for verification purposes.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/code.move (L38-40)
```text
        /// The source digest of the sources in the package. This is constructed by first building the
        /// sha256 of each individual source, than sorting them alphabetically, and sha256 them again.
        source_digest: String,
```

**File:** aptos-move/framework/aptos-framework/sources/code.move (L207-214)
```text
        let packages = &mut borrow_global_mut<PackageRegistry>(addr).packages;
        // Update registry
        let policy = pack.upgrade_policy;
        if (index < len) {
            *vector::borrow_mut(packages, index) = pack
        } else {
            vector::push_back(packages, pack)
        };
```

**File:** aptos-move/framework/aptos-framework/sources/code.move (L256-259)
```text
    public entry fun publish_package_txn(owner: &signer, metadata_serialized: vector<u8>, code: vector<vector<u8>>)
    acquires PackageRegistry {
        publish_package(owner, util::from_bytes<PackageMetadata>(metadata_serialized), code)
    }
```

**File:** aptos-move/framework/aptos-framework/sources/code.move (L354-362)
```text
    /// Get the names of the modules in a package.
    fun get_module_names(pack: &PackageMetadata): vector<String> {
        let module_names = vector::empty();
        vector::for_each_ref(&pack.modules, |pack_module| {
            let pack_module: &ModuleMetadata = pack_module;
            vector::push_back(&mut module_names, pack_module.name);
        });
        module_names
    }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1679-1717)
```rust
    /// Validate a publish request.
    fn validate_publish_request(
        &self,
        module_storage: &impl AptosModuleStorage,
        traversal_context: &mut TraversalContext,
        gas_meter: &mut impl GasMeter,
        modules: &[CompiledModule],
        mut expected_modules: BTreeSet<String>,
        allowed_deps: Option<BTreeMap<AccountAddress, BTreeSet<String>>>,
    ) -> VMResult<()> {
        self.reject_unstable_bytecode(modules)?;
        native_validation::validate_module_natives(modules)?;

        for m in modules {
            if !expected_modules.remove(m.self_id().name().as_str()) {
                return Err(Self::metadata_validation_error(&format!(
                    "unregistered module: '{}'",
                    m.self_id().name()
                )));
            }
            if let Some(allowed) = &allowed_deps {
                for dep in m.immediate_dependencies() {
                    if !allowed
                        .get(dep.address())
                        .map(|modules| {
                            modules.contains("") || modules.contains(dep.name().as_str())
                        })
                        .unwrap_or(false)
                    {
                        return Err(Self::metadata_validation_error(&format!(
                            "unregistered dependency: '{}'",
                            dep
                        )));
                    }
                }
            }
            verify_module_metadata_for_module_publishing(m, self.features())
                .map_err(|err| Self::metadata_validation_error(&err.to_string()))?;
        }
```

**File:** crates/aptos/src/move_tool/stored_package.rs (L195-243)
```rust
    pub fn verify(&self, package_metadata: &PackageMetadata) -> anyhow::Result<()> {
        let self_metadata = self.metadata;

        if self_metadata.name != package_metadata.name {
            bail!(
                "Package name doesn't match {} : {}",
                package_metadata.name,
                self_metadata.name
            )
        } else if self_metadata.deps != package_metadata.deps {
            bail!(
                "Dependencies don't match {:?} : {:?}",
                package_metadata.deps,
                self_metadata.deps
            )
        } else if self_metadata.modules != package_metadata.modules {
            bail!(
                "Modules don't match {:?} : {:?}",
                package_metadata.modules,
                self_metadata.modules
            )
        } else if self_metadata.manifest != package_metadata.manifest {
            bail!(
                "Manifest doesn't match {:?} : {:?}",
                package_metadata.manifest,
                self_metadata.manifest
            )
        } else if self_metadata.upgrade_policy != package_metadata.upgrade_policy {
            bail!(
                "Upgrade policy doesn't match {:?} : {:?}",
                package_metadata.upgrade_policy,
                self_metadata.upgrade_policy
            )
        } else if self_metadata.extension != package_metadata.extension {
            bail!(
                "Extensions doesn't match {:?} : {:?}",
                package_metadata.extension,
                self_metadata.extension
            )
        } else if self_metadata.source_digest != package_metadata.source_digest {
            bail!(
                "Source digests doesn't match {:?} : {:?}",
                package_metadata.source_digest,
                self_metadata.source_digest
            )
        }

        Ok(())
    }
```

**File:** crates/aptos/src/move_tool/mod.rs (L2079-2082)
```rust
        // Verify that the source digest matches
        package.verify(&compiled_metadata)?;

        Ok("Successfully verified source of package")
```

**File:** aptos-move/framework/cached-packages/src/lib.rs (L17-19)
```rust
static HEAD_RELEASE_BUNDLE: Lazy<ReleaseBundle> = Lazy::new(|| {
    bcs::from_bytes::<ReleaseBundle>(HEAD_RELEASE_BUNDLE_BYTES).expect("bcs succeeds")
});
```
