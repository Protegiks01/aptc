# Audit Report

## Title
OrderedBlockStore's highest_committed Tracking Diverges from ObserverBlockData Root Leading to Consensus Observer Desynchronization

## Summary
The `OrderedBlockStore.highest_committed_epoch_round` field can diverge from the actual committed state tracked in `ObserverBlockData.root`, causing the consensus observer to incorrectly drop valid commit decisions and fall out of sync with the network. This occurs through multiple code paths where only one of these tracking fields is updated.

## Finding Description

The consensus observer maintains two separate tracking mechanisms for committed blocks:

1. `ObserverBlockData.root` - The authoritative ledger info representing the actual committed state [1](#0-0) 

2. `OrderedBlockStore.highest_committed_epoch_round` - A cached value tracking the highest committed epoch and round [2](#0-1) 

**Divergence Scenario 1: Cross-Epoch Commit Handling**

In `handle_committed_blocks()`, the code updates `highest_committed_epoch_round` before checking epoch consistency: [3](#0-2) 

However, if the ledger info is for a different epoch than the current root, the function logs a warning and returns early WITHOUT updating the root: [4](#0-3) 

This leaves `highest_committed_epoch_round` pointing to the new epoch while `root` remains at the old epoch.

**Divergence Scenario 2: Non-Advancing Round Commits**

Even when epochs match, if the new commit round is not greater than the current root round, the root is not updated: [5](#0-4) 

But `highest_committed_epoch_round` was already updated via `remove_blocks_for_commit()` on line 188-189, creating divergence.

**Divergence Scenario 3: Direct Commit Decision Updates**

When `update_ordered_block_commit_decision()` is called, it updates only the `OrderedBlockStore` state without touching the root: [6](#0-5) 

This directly calls `update_commit_decision()` which updates `highest_committed_epoch_round`: [7](#0-6) 

**Divergence Scenario 4: Incomplete State Clearing**

When `clear_all_ordered_blocks()` is called, it only clears the `ordered_blocks` map but leaves `highest_committed_epoch_round` unchanged: [8](#0-7) 

This preserves stale committed state even after all blocks are cleared.

**Exploitation Impact**

The diverged value is used by `get_highest_committed_epoch_round()` to determine if incoming commit decisions should be dropped: [9](#0-8) 

This method is called in `process_commit_decision_message()` to filter out "stale" commits: [10](#0-9) 

If `highest_committed_epoch_round` is ahead of the actual root, valid commit decisions at the true committed level will be incorrectly dropped as stale, causing the observer to miss critical state updates and fall permanently out of sync.

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos bug bounty program due to:

1. **Validator Node Slowdowns**: Consensus observers that fall out of sync cannot serve as reliable data sources, degrading network performance and requiring manual intervention or state sync to recover.

2. **Significant Protocol Violations**: The consensus observer protocol's correctness depends on accurate commit tracking. This bug violates the fundamental invariant that all tracking mechanisms must remain synchronized with the actual committed state.

3. **Loss of Liveness**: Observer nodes that incorrectly drop valid commit decisions will fail to process new blocks, effectively losing liveness until they trigger state sync recovery, which may fail repeatedly if the divergence persists.

4. **State Inconsistency**: The divergence between `highest_committed_epoch_round` and `root` creates an internally inconsistent state where different subsystems have contradictory views of the committed blockchain state.

## Likelihood Explanation

This vulnerability has **HIGH likelihood** of occurring in production:

1. **Natural Occurrence**: Epoch transitions and concurrent commit processing are normal network operations. Any timing where commits arrive out of order or cross epoch boundaries can trigger divergence.

2. **No Special Privileges Required**: Any network peer can send commit decisions. No validator access, special keys, or insider knowledge is needed.

3. **Persistent Effect**: Once divergence occurs, it persists until the affected data structures are recreated or state sync resets the observer, potentially causing repeated failures.

4. **Multiple Trigger Paths**: Four distinct code paths can cause divergence, increasing the probability of triggering the bug during normal operation.

5. **Difficult to Detect**: The divergence is internal to the data structures and may not produce obvious error messages, allowing the bug to silently degrade observer functionality.

## Recommendation

**Solution 1: Synchronize All Updates**

Ensure that `highest_committed_epoch_round` and `root` are always updated atomically. Modify `handle_committed_blocks()`:

```rust
fn handle_committed_blocks(&mut self, ledger_info: LedgerInfoWithSignatures) {
    // Verify the ledger info is for the same epoch BEFORE making any updates
    let root_commit_info = self.root.commit_info();
    if ledger_info.commit_info().epoch() != root_commit_info.epoch() {
        warn!(...);
        return; // Early return before updating anything
    }
    
    // Only update if round advances
    if ledger_info.commit_info().round() <= root_commit_info.round() {
        return; // Early return if not advancing
    }
    
    // Now update both structures atomically
    self.block_payload_store.remove_blocks_for_epoch_round(...);
    self.ordered_block_store.remove_blocks_for_commit(&ledger_info);
    self.root = ledger_info;
}
```

**Solution 2: Reset highest_committed When Clearing**

Modify `clear_all_ordered_blocks()` to also reset the highest committed tracking:

```rust
pub fn clear_all_ordered_blocks(&mut self) {
    self.ordered_blocks.clear();
    self.highest_committed_epoch_round = None; // Reset to None
}
```

**Solution 3: Derive From Root Only**

Remove the separate `highest_committed_epoch_round` tracking entirely and always derive this value from the root when needed:

```rust
pub fn get_highest_committed_epoch_round(&self) -> (u64, Round) {
    // Always use root as single source of truth
    let root_block_info = self.root.commit_info().clone();
    (root_block_info.epoch(), root_block_info.round())
}
```

**Solution 4: Validation Checks**

Add invariant checks to detect divergence:

```rust
#[cfg(debug_assertions)]
fn validate_consistency(&self) {
    if let Some((epoch, round)) = self.ordered_block_store.get_highest_committed_epoch_round() {
        let root_info = self.root.commit_info();
        assert!((epoch, round) <= (root_info.epoch(), root_info.round()),
                "highest_committed ahead of root: ({}, {}) vs ({}, {})",
                epoch, round, root_info.epoch(), root_info.round());
    }
}
```

## Proof of Concept

```rust
#[test]
fn test_highest_committed_diverges_from_root() {
    // Create observer block data at epoch 10, round 5
    let epoch = 10;
    let round = 5;
    let root = create_ledger_info(epoch, round);
    let mut observer_block_data = 
        ObserverBlockData::new_with_root(ConsensusObserverConfig::default(), root.clone());
    
    // Insert an ordered block at epoch 10, round 10
    let ordered_block = create_and_add_ordered_blocks(&mut observer_block_data, 1, epoch, 10);
    
    // Update commit decision for round 10 (only updates highest_committed, not root)
    let commit_decision = CommitDecision::new(create_ledger_info(epoch, 10));
    observer_block_data.update_ordered_block_commit_decision(&commit_decision);
    
    // Verify divergence: highest_committed is at round 10 but root is still at round 5
    let (high_epoch, high_round) = observer_block_data.get_highest_committed_epoch_round();
    assert_eq!(high_epoch, epoch);
    assert_eq!(high_round, 10); // highest_committed shows round 10
    
    let root_round = observer_block_data.root().commit_info().round();
    assert_eq!(root_round, 5); // But root is still at round 5!
    
    // Now a valid commit at round 8 will be incorrectly dropped
    let valid_commit = CommitDecision::new(create_ledger_info(epoch, 8));
    // In process_commit_decision_message, line 457 check:
    // (10, 8) <= (10, 10) is TRUE, so valid commit would be dropped!
    assert!((epoch, 8) <= (high_epoch, high_round)); // Shows bug behavior
}

#[test]
fn test_cross_epoch_commit_divergence() {
    // Create observer at epoch 10, round 5
    let root = create_ledger_info(10, 5);
    let mut observer_block_data = 
        ObserverBlockData::new_with_root(ConsensusObserverConfig::default(), root);
    
    // Receive commit for epoch 11 (e.g., from malicious or out-of-order peer)
    let future_epoch_commit = create_ledger_info(11, 0);
    observer_block_data.handle_committed_blocks(future_epoch_commit.clone());
    
    // Verify divergence
    let (high_epoch, high_round) = observer_block_data.get_highest_committed_epoch_round();
    assert_eq!(high_epoch, 11); // highest_committed updated to epoch 11
    
    let root_epoch = observer_block_data.root().commit_info().epoch();
    assert_eq!(root_epoch, 10); // But root still at epoch 10!
    
    // Now ALL commits for epoch 10 will be incorrectly dropped as stale
}
```

## Notes

This vulnerability demonstrates a critical architectural flaw in maintaining dual tracking mechanisms for the same logical state. The `highest_committed_epoch_round` field in `OrderedBlockStore` acts as a performance cache but can desynchronize from the authoritative `root` ledger info through multiple code paths. The consensus observer's correctness depends on accurate commit tracking to filter messages, making this divergence a direct threat to observer liveness and protocol correctness.

The recommended fix is to eliminate the redundant tracking by deriving highest committed values directly from the root, or to ensure perfect synchronization through atomic updates and comprehensive validation checks. The current implementation's failure to maintain this critical invariant represents a significant protocol violation warranting immediate remediation.

### Citations

**File:** consensus/src/consensus_observer/observer/block_data.rs (L50-51)
```rust
    // The latest ledger info
    root: LedgerInfoWithSignatures,
```

**File:** consensus/src/consensus_observer/observer/block_data.rs (L132-141)
```rust
    pub fn get_highest_committed_epoch_round(&self) -> (u64, Round) {
        if let Some(epoch_round) = self.ordered_block_store.get_highest_committed_epoch_round() {
            // Return the highest committed epoch and round
            epoch_round
        } else {
            // Return the root epoch and round
            let root_block_info = self.root.commit_info().clone();
            (root_block_info.epoch(), root_block_info.round())
        }
    }
```

**File:** consensus/src/consensus_observer/observer/block_data.rs (L184-189)
```rust
        self.block_payload_store.remove_blocks_for_epoch_round(
            ledger_info.commit_info().epoch(),
            ledger_info.commit_info().round(),
        );
        self.ordered_block_store
            .remove_blocks_for_commit(&ledger_info);
```

**File:** consensus/src/consensus_observer/observer/block_data.rs (L191-201)
```rust
        // Verify the ledger info is for the same epoch
        let root_commit_info = self.root.commit_info();
        if ledger_info.commit_info().epoch() != root_commit_info.epoch() {
            warn!(
                LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                    "Received commit callback for a different epoch! Ledger info: {:?}, Root: {:?}",
                    ledger_info.commit_info(),
                    root_commit_info
                ))
            );
            return;
```

**File:** consensus/src/consensus_observer/observer/block_data.rs (L207-218)
```rust
        if ledger_info.commit_info().round() > root_commit_info.round() {
            info!(
            LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                "Updating the root ledger info! Old root: (epoch: {:?}, round: {:?}). New root: (epoch: {:?}, round: {:?})",
                root_commit_info.epoch(),
                root_commit_info.round(),
                ledger_info.commit_info().epoch(),
                ledger_info.commit_info().round(),
            ))
        );
            self.root = ledger_info;
        }
```

**File:** consensus/src/consensus_observer/observer/block_data.rs (L294-297)
```rust
    pub fn update_ordered_block_commit_decision(&mut self, commit_decision: &CommitDecision) {
        self.ordered_block_store
            .update_commit_decision(commit_decision);
    }
```

**File:** consensus/src/consensus_observer/observer/ordered_blocks.rs (L23-24)
```rust
    // The highest committed block (epoch and round)
    highest_committed_epoch_round: Option<(u64, Round)>,
```

**File:** consensus/src/consensus_observer/observer/ordered_blocks.rs (L40-43)
```rust
    /// Clears all ordered blocks
    pub fn clear_all_ordered_blocks(&mut self) {
        self.ordered_blocks.clear();
    }
```

**File:** consensus/src/consensus_observer/observer/ordered_blocks.rs (L140-142)
```rust
        // Update the highest committed epoch and round
        self.update_highest_committed_epoch_round(commit_decision.commit_proof());
    }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L452-461)
```rust
        // If the commit message is behind our highest committed block, ignore it
        let get_highest_committed_epoch_round = self
            .observer_block_data
            .lock()
            .get_highest_committed_epoch_round();
        if (commit_epoch, commit_round) <= get_highest_committed_epoch_round {
            // Update the metrics for the dropped commit decision
            update_metrics_for_dropped_commit_decision_message(peer_network_id, &commit_decision);
            return;
        }
```
