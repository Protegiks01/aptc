# Audit Report

## Title
Premature Peer Success Scoring Allows Malicious Peers to Evade Penalties for Type Mismatch Responses

## Summary
The `send_request_to_peer_and_decode()` function in the Aptos data client awards peer success scores before validating response type correctness. This allows malicious peers to send responses with wrong data types, receiving reduced penalties compared to legitimate failures, enabling them to persist 2-8x longer in the serviceable peer pool and cause validator slowdowns.

## Finding Description

The vulnerability exists in the state synchronization peer scoring logic. When a peer responds to a data request, the scoring system updates in two stages: [1](#0-0) 

**Execution Flow:**

1. `send_request_to_peer()` is called to fetch data from a peer
2. Upon receiving ANY valid RPC response, the peer immediately receives +1.0 score credit via `update_score_success()` [2](#0-1) 

3. The response is then checked for compression compatibility
4. Finally, `TryFrom` conversion validates the response type matches the expected type [3](#0-2) 

5. If type conversion fails, `notify_bad_response()` is called with `InvalidPayloadDataType`, applying a 0.95 multiplier penalty [4](#0-3) 

**The Problem:**

A malicious peer can exploit this by sending responses with incorrect data types (e.g., `TransactionOutputsWithProof` when `TransactionsWithProof` is requested). The TryFrom implementations detect type mismatches: [5](#0-4) 

However, the peer has already received the success bonus before this validation occurs. The net score change is: `min(score + 1.0, 100.0) * 0.95` instead of the correct `score * 0.95`.

**Mathematical Impact:** [6](#0-5) 

For a peer with score 50 sending wrong-type responses:
- Wrong-type response: 51 * 0.95 = 48.45 (net: -1.55 per response)
- Network timeout: 50 * 0.95 = 47.5 (net: -2.5 per response)
- Proof failure: 50 * 0.8 = 40 (net: -10 per response)

To reach the ignore threshold (25.0) from starting score (50.0):
- Wrong-type responses: ~32 iterations
- Network failures: ~14 iterations  
- Proof failures: ~4 iterations

**Attack Scenario:**

1. Malicious peer joins the network and gets initial score of 50.0
2. When requested for `GetTransactionsWithProof`, peer sends `TransactionOutputsWithProof`
3. Response passes RPC layer, peer gets +1.0 score
4. Type conversion fails, peer gets *0.95 penalty
5. Repeat: peer can send ~32 invalid responses before being ignored vs. 4-14 for legitimate failures

## Impact Explanation

This is a **Medium Severity** vulnerability under the Aptos bug bounty program criteria:

**Validator Node Slowdowns:** State sync operates by requesting data from peers. When malicious peers send wrong data types, validators must:
- Deserialize and attempt to convert invalid responses
- Retry requests with other peers
- Maintain connections to low-quality peers longer than necessary

**Resource Exhaustion:** Each failed type conversion consumes:
- CPU cycles for deserialization and type checking
- Network bandwidth for retries
- Memory for tracking bad responses

**Protocol Violation:** The peer scoring system is designed to filter out bad peers quickly. This vulnerability subverts that mechanism, allowing malicious peers to:
- Stay serviceable 2-8x longer than intended
- Consume disproportionate resources
- Slow state synchronization across the network

The vulnerability does not directly cause consensus failures or fund loss, but it enables sustained disruption of state sync operations, meeting the Medium severity criteria of "Validator node slowdowns" and "Significant protocol violations."

## Likelihood Explanation

**High Likelihood:**

**Attacker Requirements:**
- Ability to connect as a peer (no special privileges needed)
- Knowledge of storage service protocol (publicly documented)
- Ability to send valid RPC responses with wrong payload types

**Attack Complexity:** Low
- Trivial to implement: just return wrong DataResponse variant
- No cryptographic operations required
- No need for validator consensus participation
- Automated attack easily sustainable

**Detection Difficulty:** The attack appears as "normal" peer behavior issues rather than malicious activity, making it hard to distinguish from legitimate network problems.

**Motivation:** An attacker could exploit this to:
- Slow down specific validator nodes
- Degrade overall network state sync performance
- Create advantage for their own validators in a competitive network

## Recommendation

Fix the ordering issue by moving the success score update to occur AFTER type conversion validation succeeds:

**Modified `send_request_to_peer_and_decode()`:**

```rust
pub async fn send_request_to_peer_and_decode<T, E>(
    &self,
    peer: PeerNetworkId,
    request: StorageServiceRequest,
    request_timeout_ms: u64,
) -> crate::error::Result<Response<T>>
where
    T: TryFrom<StorageServiceResponse, Error = E> + Send + 'static,
    E: Into<Error>,
{
    let timer = start_request_timer(&metrics::REQUEST_LATENCIES, &request.get_label(), peer);
    
    // Get response (WITHOUT updating success score yet)
    let response = self
        .send_request_to_peer_without_score_update(peer, request.clone(), request_timeout_ms)
        .await;

    let storage_response = match response {
        Ok(storage_response) => {
            timer.stop_and_record();
            storage_response
        },
        Err(error) => {
            timer.stop_and_discard();
            return Err(error);
        },
    };

    // Validate compression
    let (context, storage_response) = storage_response.into_parts();
    if request.use_compression && !storage_response.is_compressed() {
        return Err(Error::InvalidResponse(format!(
            "Requested compressed data, but the response was uncompressed! Response: {:?}",
            storage_response.get_label()
        )));
    } else if !request.use_compression && storage_response.is_compressed() {
        return Err(Error::InvalidResponse(format!(
            "Requested uncompressed data, but the response was compressed! Response: {:?}",
            storage_response.get_label()
        )));
    }

    // Type conversion with scoring AFTER validation
    tokio::task::spawn_blocking(move || {
        match T::try_from(storage_response) {
            Ok(new_payload) => {
                // NOW update success score after validation passes
                context.response_callback.notify_successful_response();
                Ok(Response::new(context, new_payload))
            },
            Err(err) => {
                context
                    .response_callback
                    .notify_bad_response(ResponseError::InvalidPayloadDataType);
                Err(err.into())
            },
        }
    })
    .await
    .map_err(|error| Error::UnexpectedErrorEncountered(error.to_string()))?
}
```

Additionally, modify `send_request_to_peer()` to NOT automatically call `update_score_success()` and add a new `notify_successful_response()` callback method that gets called only after full validation.

## Proof of Concept

```rust
#[cfg(test)]
mod test_peer_scoring_vulnerability {
    use super::*;
    use aptos_storage_service_types::{
        requests::DataRequest,
        responses::{DataResponse, StorageServiceResponse},
    };

    #[tokio::test]
    async fn test_wrong_type_response_scoring() {
        // Setup: Create a data client and peer
        let (data_client, _) = setup_test_data_client();
        let peer = create_test_peer();
        
        // Initial score
        let initial_score = data_client.get_peer_states()
            .get_peer_to_states()
            .get(&peer)
            .unwrap()
            .get_score();
        assert_eq!(initial_score, 50.0); // STARTING_SCORE
        
        // Malicious peer sends wrong response type 10 times
        for _ in 0..10 {
            // Request TransactionsWithProof
            let request = StorageServiceRequest::new(
                DataRequest::GetTransactionsWithProof(request_params),
                false
            );
            
            // Peer maliciously responds with TransactionOutputsWithProof
            let wrong_response = StorageServiceResponse::RawResponse(
                DataResponse::TransactionOutputsWithProof(outputs)
            );
            
            // Simulate receiving and attempting to decode
            let result = data_client
                .send_request_to_peer_and_decode::<
                    (TransactionListWithProofV2, LedgerInfoWithSignatures),
                    _
                >(peer, request, 1000)
                .await;
            
            // Conversion should fail
            assert!(result.is_err());
        }
        
        // Check final score - with vulnerability, peer survives longer
        let final_score = data_client.get_peer_states()
            .get_peer_to_states()
            .get(&peer)
            .unwrap()
            .get_score();
        
        // With vulnerability: score â‰ˆ 48.45 after 1st, still >25 after 10
        // Expected behavior: score should be much lower
        println!("Score after 10 wrong-type responses: {}", final_score);
        
        // Compare to legitimate network failure
        let peer2 = create_test_peer();
        for _ in 0..10 {
            // Simulate timeout (no success bonus)
            data_client.get_peer_states()
                .update_score_error(peer2, ErrorType::NotUseful);
        }
        
        let peer2_score = data_client.get_peer_states()
            .get_peer_to_states()
            .get(&peer2)
            .unwrap()
            .get_score();
        
        // peer2 should have much lower score despite same number of failures
        assert!(final_score > peer2_score, 
            "Malicious peer has higher score than legitimate failure peer");
    }
}
```

## Notes

The vulnerability is confirmed by the explicit comment in the codebase acknowledging the design decision: [7](#0-6) 

This comment shows the developers were aware of the tradeoff but chose to mark RPC-layer success before consumer validation. However, this creates the exploitable inconsistency where type mismatch responses receive preferential treatment compared to legitimate network failures.

The fix requires adding a new callback method for successful validation and restructuring the scoring flow to occur after full validation rather than at the RPC layer.

### Citations

**File:** state-sync/aptos-data-client/src/client.rs (L705-766)
```rust
    pub async fn send_request_to_peer_and_decode<T, E>(
        &self,
        peer: PeerNetworkId,
        request: StorageServiceRequest,
        request_timeout_ms: u64,
    ) -> crate::error::Result<Response<T>>
    where
        T: TryFrom<StorageServiceResponse, Error = E> + Send + 'static,
        E: Into<Error>,
    {
        // Start the timer for the request
        let timer = start_request_timer(&metrics::REQUEST_LATENCIES, &request.get_label(), peer);

        // Get the response from the peer
        let response = self
            .send_request_to_peer(peer, request.clone(), request_timeout_ms)
            .await;

        // If an error occurred, stop the timer (without updating the metrics)
        // and return the error. Otherwise, stop the timer and update the metrics.
        let storage_response = match response {
            Ok(storage_response) => {
                timer.stop_and_record(); // Update the latency metrics
                storage_response
            },
            Err(error) => {
                timer.stop_and_discard(); // Discard the timer without updating the metrics
                return Err(error);
            },
        };

        // Ensure the response obeys the compression requirements
        let (context, storage_response) = storage_response.into_parts();
        if request.use_compression && !storage_response.is_compressed() {
            return Err(Error::InvalidResponse(format!(
                "Requested compressed data, but the response was uncompressed! Response: {:?}",
                storage_response.get_label()
            )));
        } else if !request.use_compression && storage_response.is_compressed() {
            return Err(Error::InvalidResponse(format!(
                "Requested uncompressed data, but the response was compressed! Response: {:?}",
                storage_response.get_label()
            )));
        }

        // Try to convert the storage service enum into the exact variant we're expecting.
        // We do this using spawn_blocking because it involves serde and compression.
        tokio::task::spawn_blocking(move || {
            match T::try_from(storage_response) {
                Ok(new_payload) => Ok(Response::new(context, new_payload)),
                // If the variant doesn't match what we're expecting, report the issue
                Err(err) => {
                    context
                        .response_callback
                        .notify_bad_response(ResponseError::InvalidPayloadDataType);
                    Err(err.into())
                },
            }
        })
        .await
        .map_err(|error| Error::UnexpectedErrorEncountered(error.to_string()))?
    }
```

**File:** state-sync/aptos-data-client/src/client.rs (L811-817)
```rust
                // For now, record all responses that at least pass the data
                // client layer successfully. An alternative might also have the
                // consumer notify both success and failure via the callback.
                // On the one hand, scoring dynamics are simpler when each request
                // is successful or failed but not both; on the other hand, this
                // feels simpler for the consumer.
                self.peer_states.update_score_success(peer);
```

**File:** state-sync/aptos-data-client/src/peer_states.rs (L32-43)
```rust
/// Scores for peer rankings based on preferences and behavior.
const MAX_SCORE: f64 = 100.0;
const MIN_SCORE: f64 = 0.0;
const STARTING_SCORE: f64 = 50.0;
/// Add this score on a successful response.
const SUCCESSFUL_RESPONSE_DELTA: f64 = 1.0;
/// Not necessarily a malicious response, but not super useful.
const NOT_USEFUL_MULTIPLIER: f64 = 0.95;
/// Likely to be a malicious response.
const MALICIOUS_MULTIPLIER: f64 = 0.8;
/// Ignore a peer when their score dips below this threshold.
const IGNORE_PEER_THRESHOLD: f64 = 25.0;
```

**File:** state-sync/aptos-data-client/src/peer_states.rs (L54-62)
```rust
impl From<ResponseError> for ErrorType {
    fn from(error: ResponseError) -> Self {
        match error {
            ResponseError::InvalidData | ResponseError::InvalidPayloadDataType => {
                ErrorType::NotUseful
            },
            ResponseError::ProofVerificationError => ErrorType::Malicious,
        }
    }
```

**File:** state-sync/storage-service/types/src/responses.rs (L396-431)
```rust
impl TryFrom<StorageServiceResponse> for (TransactionListWithProofV2, LedgerInfoWithSignatures) {
    type Error = crate::responses::Error;

    fn try_from(response: StorageServiceResponse) -> crate::Result<Self, Self::Error> {
        let data_response = response.get_data_response()?;
        match data_response {
            DataResponse::NewTransactionsWithProof((
                transaction_list_with_proof,
                ledger_info_with_signatures,
            )) => Ok((
                TransactionListWithProofV2::new_from_v1(transaction_list_with_proof),
                ledger_info_with_signatures,
            )),
            DataResponse::NewTransactionDataWithProof(response) => {
                if let TransactionDataResponseType::TransactionData =
                    response.transaction_data_response_type
                {
                    if let Some(transaction_list_with_proof_v2) =
                        response.transaction_list_with_proof
                    {
                        return Ok((
                            transaction_list_with_proof_v2,
                            response.ledger_info_with_signatures,
                        ));
                    }
                }
                Err(Error::UnexpectedResponseError(
                    "new_transaction_list_with_proof is empty".into(),
                ))
            },
            _ => Err(Error::UnexpectedResponseError(format!(
                "expected new_transactions_with_proof, found {}",
                data_response.get_label()
            ))),
        }
    }
```
