# Audit Report

## Title
Gas Schedule Update Can Cause Consensus Split During Version Mismatches

## Summary
The gas cost table update mechanism lacks validation to ensure on-chain `GasScheduleV2` compatibility with validator code versions. When a gas schedule is deployed with parameters that don't match validator expectations, different nodes can produce different execution results, breaking the "Deterministic Execution" invariant and causing consensus failure. [1](#0-0) 

## Finding Description

The gas schedule update system has a critical flaw: the on-chain `GasScheduleV2` resource can be updated to a version that is incompatible with the compiled parameter requirements in validator binaries, with no validation preventing this mismatch.

**The Vulnerability Chain:**

1. **Macro-Generated Parameter Loading**: Gas parameter extraction uses compile-time macros that define which parameters are required for each feature version. [2](#0-1) 

2. **Version-Gated Parameters**: Parameters can be version-specific (e.g., only required for versions 44+). [3](#0-2) 

3. **No Compatibility Validation**: The Move contract only validates that `new_version >= old_version`, but does NOT validate compatibility with LATEST_GAS_FEATURE_VERSION or check that required parameters exist. [4](#0-3) 

4. **Failure Mode**: When parameter loading fails, the error is stored and causes all transactions to get `VM_STARTUP_FAILURE`. [5](#0-4) 

**Consensus Split Scenario:**

During a rolling upgrade or with a misconfigured gas schedule:
- **Node Group A** (old code v45): Expects parameters {A, B, C} for version 45
- **Node Group B** (new code v45): Expects parameters {A, B, C, D} for version 45  
- **On-chain schedule**: Contains {A, B, C} with version 45

Result:
- Node Group A: Successfully loads gas params → executes transactions → produces blocks with transactions
- Node Group B: Fails to load parameter D → `VM_STARTUP_FAILURE` → discards all transactions → produces empty blocks

**Different nodes produce different blocks → consensus failure.**

The environment comparison is based on a hash that includes all gas parameters, so nodes with different parameter loading results are considered to have different environments. [6](#0-5) 

## Impact Explanation

**Critical Severity** - This breaks the fundamental "Deterministic Execution" invariant. When validators cannot agree on which transactions should be included in blocks due to inconsistent gas parameter loading:

1. **Consensus Failure**: Validators running different code versions or with incompatible gas schedules will propose different blocks and fail to reach consensus
2. **Network Partition**: The network could split into multiple forks if different validator subsets reach consensus on different block proposals
3. **Liveness Failure**: If >33% of validators cannot load gas parameters, the network loses quorum and halts
4. **Non-recoverable Without Hard Fork**: Once validators have diverged, manual intervention and potentially a hard fork would be required to restore consensus

This meets the Critical severity criteria: "Consensus/Safety violations" and "Non-recoverable network partition (requires hardfork)".

## Likelihood Explanation

**Medium to High Likelihood** - While this requires specific conditions, they commonly occur during normal operations:

1. **Rolling Upgrades**: Validators upgrade at different times, creating temporary version mismatches
2. **Gas Schedule Updates**: Any governance-approved gas schedule change could trigger this if not carefully coordinated
3. **Human Error**: Deploying a gas schedule before all validators have upgraded to compatible code
4. **No Safeguards**: The system lacks validation to prevent deployment of incompatible gas schedules

The vulnerability doesn't require malicious intent - it's an operational hazard that can occur during routine maintenance. The existing test coverage validates parameter loading but doesn't test cross-version compatibility scenarios. [7](#0-6) 

## Recommendation

Implement multi-layered safeguards:

1. **On-Chain Validation**: Add a maximum version check in the Move contract:
```move
const EGAS_VERSION_TOO_HIGH: u64 = 4;

public fun set_for_next_epoch(aptos_framework: &signer, gas_schedule_blob: vector<u8>) {
    let new_gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
    
    // Add: Validate version is not too far ahead
    assert!(
        new_gas_schedule.feature_version <= get_max_supported_version(),
        error::invalid_argument(EGAS_VERSION_TOO_HIGH)
    );
    
    // Existing validation...
}
```

2. **Parameter Completeness Validation**: Before storing, validate all required parameters exist for the specified version:
```move
// Add validation function
fun validate_gas_schedule_complete(schedule: &GasScheduleV2): bool {
    // Check that all required parameters for this feature_version exist
    // This requires maintaining a canonical list of required parameters
}
```

3. **Runtime Compatibility Check**: In Rust, add a check during Environment creation:
```rust
// In environment.rs
let (gas_params, storage_gas_params, gas_feature_version) = 
    get_gas_parameters(&mut sha3_256, &features, state_view);

if gas_feature_version > LATEST_GAS_FEATURE_VERSION {
    return Err(format!(
        "Gas feature version {} exceeds maximum supported version {}",
        gas_feature_version, LATEST_GAS_FEATURE_VERSION
    ));
}
```

4. **Coordinated Deployment Process**: Document and enforce a process where:
   - Code upgrades are deployed to all validators first
   - Gas schedule updates are only deployed after confirmation all validators are ready
   - Add a time delay between code deployment and gas schedule activation

## Proof of Concept

```rust
// Test demonstrating consensus split scenario
#[test]
fn test_gas_schedule_version_mismatch_causes_consensus_split() {
    // Setup two harnesses with different LATEST_GAS_FEATURE_VERSION
    let mut harness_old = MoveHarness::new(); // Simulates old code
    let mut harness_new = MoveHarness::new(); // Simulates new code
    
    // Deploy gas schedule missing a parameter required by new code
    let incomplete_schedule = GasScheduleV2 {
        feature_version: 45,
        entries: vec![
            ("instr.add".to_string(), 100),
            // Missing "instr.new_param" that new code expects
        ],
    };
    
    // Old code: should succeed
    harness_old.set_gas_schedule(incomplete_schedule.clone());
    let txn_old = harness_old.create_simple_transaction();
    let result_old = harness_old.run_transaction(txn_old);
    assert!(result_old.is_success()); // Executes normally
    
    // New code: should fail with VM_STARTUP_FAILURE
    harness_new.set_gas_schedule(incomplete_schedule);
    let txn_new = harness_new.create_simple_transaction();
    let result_new = harness_new.run_transaction(txn_new);
    assert!(matches!(
        result_new,
        TransactionStatus::Discard(StatusCode::VM_STARTUP_FAILURE)
    ));
    
    // Different nodes produce different results → consensus split
    assert_ne!(result_old.status(), result_new.status());
}
```

## Notes

This vulnerability is particularly insidious because:
1. It doesn't manifest until a specific combination of code version and gas schedule occurs
2. It can't be detected by single-node testing
3. The failure mode (network halt or split) is catastrophic
4. No rollback mechanism exists once divergence begins

The root cause is that gas parameter requirements are **code-dependent** (via compile-time macros) but deployed **data** (on-chain resource), with no synchronization mechanism between them. The system assumes perfect coordination between code deployments and gas schedule updates, which is fragile in a decentralized network.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L91-103)
```text
    public fun set_for_next_epoch(aptos_framework: &signer, gas_schedule_blob: vector<u8>) acquires GasScheduleV2 {
        system_addresses::assert_aptos_framework(aptos_framework);
        assert!(!vector::is_empty(&gas_schedule_blob), error::invalid_argument(EINVALID_GAS_SCHEDULE));
        let new_gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
        if (exists<GasScheduleV2>(@aptos_framework)) {
            let cur_gas_schedule = borrow_global<GasScheduleV2>(@aptos_framework);
            assert!(
                new_gas_schedule.feature_version >= cur_gas_schedule.feature_version,
                error::invalid_argument(EINVALID_GAS_FEATURE_VERSION)
            );
        };
        config_buffer::upsert(new_gas_schedule);
    }
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/macros.rs (L32-45)
```rust
        impl $crate::traits::FromOnChainGasSchedule for $params_name {
            #[allow(unused)]
            fn from_on_chain_gas_schedule(gas_schedule: &std::collections::BTreeMap<String, u64>, feature_version: u64) -> Result<Self, String> {
                let mut params = $params_name::zeros();

                $(
                    if let Some(key) = $crate::gas_schedule::macros::define_gas_parameters_extract_key_at_version!($key_bindings, feature_version) {
                        let name = format!("{}.{}", $prefix, key);
                        params.$name = gas_schedule.get(&name).cloned().ok_or_else(|| format!("Gas parameter {} does not exist. Feature version: {}.", name, feature_version))?.into();
                    }
                )*

                Ok(params)
            }
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/instr.rs (L25-26)
```rust
        [abort_msg_base: InternalGas, { RELEASE_V1_40.. => "abort_msg.base" }, 440],
        [abort_msg_per_byte: InternalGasPerByte, { RELEASE_V1_40.. => "abort_msg.per_byte" }, 45],
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L273-282)
```rust
pub(crate) fn get_or_vm_startup_failure<'a, T>(
    gas_params: &'a Result<T, String>,
    log_context: &AdapterLogSchema,
) -> Result<&'a T, VMStatus> {
    gas_params.as_ref().map_err(|err| {
        let msg = format!("VM Startup Failed. {}", err);
        speculative_error!(log_context, msg.clone());
        VMStatus::error(StatusCode::VM_STARTUP_FAILURE, Some(msg))
    })
}
```

**File:** aptos-move/aptos-vm-environment/src/environment.rs (L152-158)
```rust
impl PartialEq for AptosEnvironment {
    fn eq(&self, other: &Self) -> bool {
        self.0.hash == other.0.hash
    }
}

impl Eq for AptosEnvironment {}
```

**File:** aptos-move/e2e-move-tests/src/tests/missing_gas_parameter.rs (L8-28)
```rust
#[test]
fn missing_gas_parameter() {
    let mut h = MoveHarness::new();

    h.modify_gas_schedule_raw(|gas_schedule| {
        let idx = gas_schedule
            .entries
            .iter()
            .position(|(key, _val)| key == "instr.add")
            .unwrap();
        gas_schedule.entries.remove(idx);
    });

    // Load the code
    let acc = h.new_account_with_balance_at(AccountAddress::from_hex_literal("0xbeef").unwrap(), 0);
    let txn_status = h.publish_package(&acc, &common::test_dir_path("common.data/do_nothing"));
    assert!(matches!(
        txn_status,
        TransactionStatus::Discard(StatusCode::VM_STARTUP_FAILURE)
    ))
}
```
