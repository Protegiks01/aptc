# Audit Report

## Title
PriorityIndex Memory Exhaustion via Sustained High Transaction Volume

## Summary
The `PriorityIndex` BTreeSet in mempool can grow to accommodate all 2 million transactions (the default capacity) when they are in a "ready" state, consuming approximately 336 MB for the index structure alone plus several GB for associated transaction data. The eviction mechanism only targets parked transactions, not ready transactions in the `PriorityIndex`, allowing an attacker to cause memory exhaustion and denial-of-service by continuously submitting ready transactions that fill the mempool to capacity.

## Finding Description
The mempool's `PriorityIndex` is a `BTreeSet<OrderedQueueKey>` that stores references to all "ready" transactions available for consensus to pull. [1](#0-0) 

Transactions enter the `PriorityIndex` when they become "ready" for consensus. For nonce-based (orderless) transactions, they are always immediately ready. [2](#0-1)  For sequence number transactions, they're ready when sequential to the current account sequence number.

The critical issue is in the eviction mechanism. When mempool reaches capacity, the `check_is_full_after_eviction` function only attempts to evict transactions from the `parking_lot_index` (non-ready transactions), not from `priority_index`: [3](#0-2) 

The mempool capacity check is based on `system_ttl_index.size()`, which tracks all transactions regardless of ready state: [4](#0-3) 

With default configuration allowing 2 million transactions, an attacker can exploit this by: [5](#0-4) 

1. Submitting nonce-based transactions from multiple accounts (1000 per account limit, requiring ~2000 accounts) [6](#0-5) 
2. All nonce transactions immediately enter `PriorityIndex` as they're always ready
3. Filling mempool to 2 million transactions, consuming ~336 MB for the BTreeSet structure (each `OrderedQueueKey` is ~168 bytes) plus several GB for actual transaction data
4. Consensus pulls transactions but if commit rate < submission rate, mempool stays full
5. Legitimate transactions are rejected with "MempoolIsFull" errors
6. Even with GC running every 60 seconds, attacker can sustain the attack by continuously submitting new transactions with valid expiration times

The system relies on transaction commits or GC to free space, but an attacker can outpace these mechanisms by submitting fresh transactions continuously.

## Impact Explanation
This qualifies as **High Severity** per Aptos bug bounty criteria due to:
- **Validator node slowdown**: Memory exhaustion (multi-GB) degrades node performance
- **Denial of Service**: Legitimate users cannot submit transactions when mempool is full
- **Resource exhaustion**: Violates the invariant "All operations must respect gas, storage, and computational limits"

While not a consensus safety violation or fund loss, it significantly impacts network availability and validator operations, meeting the High severity threshold of "Validator node slowdowns" and "Significant protocol violations."

## Likelihood Explanation
**Likelihood: High**

Attack requirements:
- ~2000 funded accounts (for nonce-based transaction attack)
- Continuous transaction submission to maintain mempool at capacity
- Gas costs for sustained attack (mitigated by using low gas prices and relying on mempool accepting up to capacity)

The attack is realistic because:
1. Nonce-based transactions are always "ready" and bypass parking lot
2. No specific limit exists on `priority_index.size()` separate from total capacity
3. Eviction only targets parking lot, not ready transactions
4. GC timeout is 600 seconds, providing a large window for sustained attack
5. Per-account limit is 1000 for nonce transactions, achievable with modest account creation

## Recommendation
Implement a dedicated size limit for `priority_index` separate from the global mempool capacity, and add an eviction mechanism for ready transactions when the priority index reaches critical size. Consider:

1. Add a `max_priority_index_size` configuration parameter (e.g., 100,000 transactions)
2. When `priority_index.size()` exceeds this threshold, evict oldest ready transactions by insertion time
3. Implement tiered eviction: first from parking lot, then from priority index if necessary
4. Add monitoring metrics for `priority_index.size()` to detect attacks early

Example fix:
```rust
// In TransactionStore
pub struct TransactionStore {
    // ... existing fields
    max_priority_index_size: usize,  // Add new limit
}

fn check_is_full_after_eviction(&mut self, txn: &MempoolTransaction, account_sequence_number: Option<u64>) -> bool {
    if self.is_full() && self.check_txn_ready(txn, account_sequence_number) {
        // First try parking lot eviction
        // ... existing parking lot eviction code ...
        
        // If still full and priority index is large, evict from it
        if self.is_full() && self.priority_index.size() > self.max_priority_index_size {
            // Evict oldest transactions from priority_index based on insertion_time
            self.evict_from_priority_index();
        }
    }
    self.is_full()
}
```

## Proof of Concept
```rust
// Rust test demonstrating PriorityIndex growth
#[test]
fn test_priority_index_memory_exhaustion() {
    use aptos_config::config::MempoolConfig;
    use aptos_types::transaction::{SignedTransaction, RawTransaction, TransactionPayload};
    
    let mut config = MempoolConfig::default();
    config.capacity = 100000; // Reduced for testing
    config.orderless_txn_capacity_per_user = 1000;
    
    let mut mempool = Mempool::new(&NodeConfig {
        mempool: config,
        ..Default::default()
    });
    
    // Create 100 accounts, each submitting 1000 nonce transactions
    for account_idx in 0..100 {
        let account = AccountAddress::random();
        for nonce in 0..1000 {
            let txn = create_nonce_transaction(account, nonce);
            let status = mempool.add_txn(
                txn,
                100, // ranking_score
                None, // no sequence number for nonce txns
                TimelineState::NotReady,
                true,
                None,
                None,
            );
            assert_eq!(status.code, MempoolStatusCode::Accepted);
        }
    }
    
    // Verify priority index has all 100,000 transactions (all nonce txns are ready)
    let priority_index_size = mempool.get_transaction_store().priority_index.size();
    assert_eq!(priority_index_size, 100000);
    
    // Attempt to insert legitimate transaction - should fail if mempool is at capacity
    let legitimate_txn = create_nonce_transaction(AccountAddress::random(), 0);
    let status = mempool.add_txn(legitimate_txn, 1000, None, TimelineState::NotReady, true, None, None);
    
    // If capacity is reached, legitimate transactions are rejected
    if priority_index_size >= config.capacity {
        assert_eq!(status.code, MempoolStatusCode::MempoolIsFull);
    }
}
```

## Notes
While the growth is technically bounded by the configured capacity (2 million transactions), this bound is sufficiently high to cause memory exhaustion on validator nodes. The lack of a separate limit on `priority_index` size and the eviction mechanism's inability to remove ready transactions creates a practical DoS vector. The issue is exacerbated for nonce-based transactions which bypass the parking lot entirely and immediately consume `PriorityIndex` capacity.

### Citations

**File:** mempool/src/core_mempool/index.rs (L131-133)
```rust
pub struct PriorityIndex {
    data: BTreeSet<OrderedQueueKey>,
}
```

**File:** mempool/src/core_mempool/transaction_store.rs (L422-447)
```rust
            // try to free some space in Mempool from ParkingLot by evicting non-ready txns
            let mut evicted_txns = 0;
            let mut evicted_bytes = 0;
            while let Some(txn_pointer) = self.parking_lot_index.get_poppable() {
                if let Some(txn) = self
                    .transactions
                    .get_mut(&txn_pointer.sender)
                    .and_then(|txns| txns.remove(&txn_pointer.replay_protector))
                {
                    debug!(
                        LogSchema::new(LogEntry::MempoolFullEvictedTxn).txns(TxnsLog::new_txn(
                            txn.get_sender(),
                            txn.get_replay_protector()
                        ))
                    );
                    evicted_bytes += txn.get_estimated_bytes() as u64;
                    evicted_txns += 1;
                    self.index_remove(&txn);
                    if !self.is_full() {
                        break;
                    }
                } else {
                    error!("Transaction not found in mempool while evicting from parking lot");
                    break;
                }
            }
```

**File:** mempool/src/core_mempool/transaction_store.rs (L458-460)
```rust
    fn is_full(&self) -> bool {
        self.system_ttl_index.size() >= self.capacity || self.size_bytes >= self.capacity_bytes
    }
```

**File:** mempool/src/core_mempool/transaction_store.rs (L495-499)
```rust
            ReplayProtector::Nonce(_) => {
                // Nonce based transactions are always ready for broadcast
                true
            },
        }
```

**File:** config/src/config/mempool_config.rs (L121-122)
```rust
            capacity: 2_000_000,
            capacity_bytes: 2 * 1024 * 1024 * 1024,
```

**File:** config/src/config/mempool_config.rs (L171-171)
```rust
            orderless_txn_capacity_per_user: 1000,
```
