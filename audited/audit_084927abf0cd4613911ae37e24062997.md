# Audit Report

## Title
Missing Transaction Version Validation in Indexer Cache Worker Allows Cache Poisoning

## Summary
The `process_streaming_response()` function in the indexer-grpc cache worker increments `current_version` by transaction count without validating that received transactions actually match the expected version range. This allows a malicious or compromised fullnode to poison the cache with arbitrary transaction versions, creating gaps or inserting incorrect data.

## Finding Description

The cache worker's `process_streaming_response()` function fails to validate that incoming transaction chunks contain the expected version numbers before updating the tracking variable `current_version`. [1](#0-0) 

At line 399, `current_version` is blindly incremented by `num_of_transactions` without checking if the actual transaction versions in the chunk start at the expected `current_version`. While the code extracts the actual transaction versions for logging purposes: [2](#0-1) 

These version numbers are never compared against `current_version` to ensure they're sequential and match expectations. The transactions are then written to Redis by their actual version numbers: [3](#0-2) 

The `update_cache_transactions` function writes each transaction to Redis using its embedded version number as the key, without validating that these versions are sequential or match expected values.

The only validation occurs at BatchEnd: [4](#0-3) 

However, this check only verifies that `current_version` equals `start_version + num_of_transactions` - values that both come from the fullnode's signals, not the actual transaction data. A malicious fullnode can send BatchEnd signals that match the incremented `current_version`, regardless of what transaction versions were actually sent.

**Attack Scenario:**
1. Fullnode sends chunk claiming 100 transactions (versions 1000-1099 expected)
2. But actual transactions have versions 5000-5099
3. Worker increments: `current_version = 1000 + 100 = 1100`
4. Redis receives and stores versions 5000-5099
5. BatchEnd signal: `start_version=1000, end_version=1099`
6. Validation passes: `current_version (1100) == 1000 + 100` ✓
7. Result: Cache has gap at 1000-1099, wrong data at 5000-5099

In contrast, other Aptos components properly validate version sequences: [5](#0-4) 

The state-sync driver explicitly validates that `payload_start_version` matches `expected_version` and resets the stream if they don't match. The cache worker lacks equivalent protection.

## Impact Explanation

This vulnerability allows cache poisoning with **Medium severity** impact under Aptos bug bounty criteria:

**"State inconsistencies requiring intervention"** - The cache can become inconsistent with:
- Missing version ranges (gaps in transaction history)
- Wrong transactions stored at unexpected versions
- Out-of-order data serving to consumers

**Cascading effects:**
- Indexers consuming from cache process incorrect data
- APIs return wrong transaction history, balances, or state
- dApps relying on indexer data may malfunction (show wrong balances, retry transactions incorrectly)
- Requires manual intervention to detect and clear poisoned cache

While this doesn't directly affect on-chain consensus or validator operations, it compromises the integrity of the indexer infrastructure that many ecosystem participants rely on for querying blockchain state.

## Likelihood Explanation

**Likelihood: Medium to High**

Prerequisites for exploitation:
1. Attacker controls or compromises a fullnode that cache workers connect to
2. Fullnode sends malformed transaction chunks with manipulated version numbers

This is realistic because:
- Anyone can run a fullnode in Aptos network
- Cache workers must connect to fullnodes chosen by operators
- There's no cryptographic proof validation in the cache worker
- A compromised fullnode could serve multiple cache workers simultaneously

The vulnerability will trigger whenever a cache worker connects to a malicious fullnode, making it practical for attackers with network-level access or fullnode operation capabilities.

## Recommendation

Add explicit validation that incoming transactions match the expected version range before incrementing `current_version`:

```rust
GrpcDataStatus::ChunkDataOk {
    num_of_transactions,
    task,
} => {
    // Extract first transaction version from the actual data
    let first_transaction_version = /* extract from data */;
    
    // Validate version continuity
    if first_transaction_version != current_version {
        error!(
            expected_version = current_version,
            actual_version = first_transaction_version,
            "[Indexer Cache] Received chunk with non-sequential version"
        );
        ERROR_COUNT.with_label_values(&["version_mismatch"]).inc();
        break;
    }
    
    current_version += num_of_transactions;
    transaction_count += num_of_transactions;
    tps_calculator.tick_now(num_of_transactions);
    tasks_to_run.push(task);
},
```

The validation should occur in `process_transactions_from_node_response()` before spawning the async task, comparing the first transaction's version against the current expected version. Additionally, validate that all transactions within a chunk are sequential.

Alternatively, follow the state-sync pattern and pass `expected_version` to a validation function that resets the stream on mismatch.

## Proof of Concept

**Test Setup:**
1. Create a mock fullnode that implements the gRPC streaming interface
2. Send Init signal with starting_version=1000
3. Send chunk with transactions having versions 5000-5099 (instead of expected 1000-1099)
4. Send BatchEnd with start_version=1000, end_version=1099
5. Verify cache worker accepts the data without error
6. Query Redis cache and observe:
   - Versions 1000-1099 are missing (gap)
   - Versions 5000-5099 are present (wrong data)
   - `latest_version` is updated to 1100

**Expected (buggy) behavior:**
- Worker increments `current_version` to 1100
- BatchEnd check passes
- Cache is poisoned with wrong versions

**Expected (fixed) behavior:**
- Worker detects version mismatch (1000 ≠ 5000)
- Stream is reset with error
- Cache remains consistent

## Notes

This vulnerability specifically violates the State Consistency invariant: "State transitions must be atomic and verifiable via Merkle proofs." While the indexer cache doesn't use Merkle proofs, the principle of verifying data integrity before accepting state updates applies.

The issue is particularly concerning because the code comment explicitly acknowledges that "data chunks may be out of order" but fails to implement proper validation for this scenario. The cache worker should not trust fullnode data without verification, similar to how state-sync validates payload versions before processing.

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-cache-worker/src/worker.rs (L214-226)
```rust
                let first_transaction = data
                    .transactions
                    .first()
                    .context("There were unexpectedly no transactions in the response")?;
                let first_transaction_version = first_transaction.version;
                let last_transaction = data
                    .transactions
                    .last()
                    .context("There were unexpectedly no transactions in the response")?;
                let last_transaction_version = last_transaction.version;
                let start_version = first_transaction.version;
                let first_transaction_pb_timestamp = first_transaction.timestamp;
                let last_transaction_pb_timestamp = last_transaction.timestamp;
```

**File:** ecosystem/indexer-grpc/indexer-grpc-cache-worker/src/worker.rs (L395-404)
```rust
                GrpcDataStatus::ChunkDataOk {
                    num_of_transactions,
                    task,
                } => {
                    current_version += num_of_transactions;
                    transaction_count += num_of_transactions;
                    tps_calculator.tick_now(num_of_transactions);

                    tasks_to_run.push(task);
                },
```

**File:** ecosystem/indexer-grpc/indexer-grpc-cache-worker/src/worker.rs (L433-443)
```rust
                    if current_version != start_version + num_of_transactions {
                        error!(
                            current_version = current_version,
                            actual_current_version = start_version + num_of_transactions,
                            "[Indexer Cache] End signal received with wrong version."
                        );
                        ERROR_COUNT
                            .with_label_values(&["data_end_wrong_version"])
                            .inc();
                        break;
                    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/cache_operator.rs (L252-290)
```rust
    pub async fn update_cache_transactions(
        &mut self,
        transactions: Vec<Transaction>,
    ) -> anyhow::Result<()> {
        let start_version = transactions.first().unwrap().version;
        let end_version = transactions.last().unwrap().version;
        let num_transactions = transactions.len();
        let start_txn_timestamp = transactions.first().unwrap().timestamp;
        let end_txn_timestamp = transactions.last().unwrap().timestamp;
        let mut size_in_bytes = 0;
        let mut redis_pipeline = redis::pipe();
        let start_time = std::time::Instant::now();
        for transaction in transactions {
            let version = transaction.version;
            let cache_key = CacheEntry::build_key(version, self.storage_format).to_string();
            let timestamp_in_seconds = transaction.timestamp.map_or(0, |t| t.seconds as u64);
            let cache_entry: CacheEntry =
                CacheEntry::from_transaction(transaction, self.storage_format);
            let bytes = cache_entry.into_inner();
            size_in_bytes += bytes.len();
            redis_pipeline
                .cmd("SET")
                .arg(cache_key)
                .arg(bytes)
                .arg("EX")
                .arg(get_ttl_in_seconds(timestamp_in_seconds))
                .ignore();
            // Actively evict the expired cache. This is to avoid using Redis
            // eviction policy, which is probabilistic-based and may evict the
            // cache that is still needed.
            if version >= CACHE_SIZE_EVICTION_LOWER_BOUND {
                let key = CacheEntry::build_key(
                    version - CACHE_SIZE_EVICTION_LOWER_BOUND,
                    self.storage_format,
                )
                .to_string();
                redis_pipeline.cmd("DEL").arg(key).ignore();
            }
        }
```

**File:** state-sync/state-sync-driver/src/continuous_syncer.rs (L388-420)
```rust
    async fn verify_payload_start_version(
        &mut self,
        notification_id: NotificationId,
        payload_start_version: Option<Version>,
    ) -> Result<Version, Error> {
        // Compare the payload start version with the expected version
        let expected_version = self
            .get_speculative_stream_state()?
            .expected_next_version()?;
        if let Some(payload_start_version) = payload_start_version {
            if payload_start_version != expected_version {
                self.reset_active_stream(Some(NotificationAndFeedback::new(
                    notification_id,
                    NotificationFeedback::InvalidPayloadData,
                )))
                .await?;
                Err(Error::VerificationError(format!(
                    "The payload start version does not match the expected version! Start: {:?}, expected: {:?}",
                    payload_start_version, expected_version
                )))
            } else {
                Ok(payload_start_version)
            }
        } else {
            self.reset_active_stream(Some(NotificationAndFeedback::new(
                notification_id,
                NotificationFeedback::EmptyPayloadData,
            )))
            .await?;
            Err(Error::VerificationError(
                "The playload starting version is missing!".into(),
            ))
        }
```
