# Audit Report

## Title
NaN Propagation in Block Partitioner Threshold Causes Consensus Violation Through Non-Deterministic Execution Order

## Summary
The `cross_shard_dep_avoid_threshold` field in block partitioner configurations accepts `f32::NAN` without validation. When NaN is set, the early-exit optimization in `remove_cross_shard_dependencies()` never triggers due to NaN comparison semantics, causing different validators with different threshold values to produce different numbers of partitioning rounds. This leads to different transaction execution orders and different state roots, breaking consensus.

## Finding Description
The block partitioner's `cross_shard_dep_avoid_threshold` field is used to optimize partitioning by stopping early when enough transactions are partitioned. However, this field has no validation and accepts any `f32` value, including `f32::NAN`. [1](#0-0) 

When this threshold is NaN, the early-exit condition in the partitioning loop behaves unexpectedly: [2](#0-1) 

The comparison `num_remaining_txns < ((1.0 - state.cross_shard_dep_avoid_threshold) * state.num_txns() as f32) as usize` evaluates as follows when the threshold is NaN:
- `1.0 - f32::NAN = NaN`
- `NaN * num_txns as f32 = NaN`  
- `NaN as usize = 0` (Rust casts NaN to 0 for integers)
- `num_remaining_txns < 0` is always false for unsigned integers

This causes the loop to run for all `num_rounds_limit - 1` iterations instead of exiting early, resulting in a different number of rounds than nodes with valid threshold values.

The transaction execution order depends critically on the number of rounds through the flattening operation: [3](#0-2) 

The formula `ordered_blocks[round * num_shards + shard_id]` means transactions in different rounds occupy different positions in the final execution order. If two validators produce different numbers of rounds (e.g., 3 rounds vs 4 rounds), the same transaction ends up at different positions, leading to different execution orders.

Since Aptos consensus requires validators to collectively sign the **resulting state** (state root hash) of a block: [4](#0-3) 

Different execution orders produce different state roots, preventing consensus agreement.

## Impact Explanation
**Critical Severity - Consensus Violation**

This vulnerability breaks the fundamental **Deterministic Execution** invariant: "All validators must produce identical state roots for identical blocks." 

If even a single validator has `cross_shard_dep_avoid_threshold` set to NaN (through misconfiguration or malicious intent), while others use the default 0.9, they will:
1. Produce different numbers of partitioning rounds for the same block
2. Execute transactions in different orders
3. Compute different state root hashes
4. Fail to achieve consensus on block commits

This violates Aptos's consensus safety guarantees and could lead to:
- Network liveness failure (inability to commit blocks)
- Potential network partition requiring intervention
- Validators being unable to agree on ledger state

The impact severity aligns with Critical tier per the bug bounty: "Consensus/Safety violations" and "Non-recoverable network partition (requires hardfork)".

## Likelihood Explanation
**Low to Medium Likelihood**

While this requires validator operator access to set the configuration value to NaN, several realistic scenarios exist:

1. **Accidental Misconfiguration**: Operator could pass `--partitioner-cross-shard-dep-avoid-threshold NaN` via command line, which Rust's `f32` parsing accepts
2. **Configuration File Corruption**: Floating-point serialization/deserialization issues could introduce NaN
3. **Malicious Insider**: A compromised validator operator could intentionally set NaN to disrupt consensus

The likelihood is increased by:
- No validation exists to reject NaN values
- No runtime checks detect when NaN is in use
- The failure mode is silent until consensus breaks
- Difficult to diagnose (would appear as "validators can't agree on state")

## Recommendation
Add explicit validation to reject NaN, infinity, and out-of-range values for `cross_shard_dep_avoid_threshold`:

```rust
// In execution/block-partitioner/src/v2/config.rs
pub fn cross_shard_dep_avoid_threshold(mut self, val: f32) -> Self {
    assert!(
        val.is_finite() && val >= 0.0 && val <= 1.0,
        "cross_shard_dep_avoid_threshold must be a finite value between 0.0 and 1.0, got: {}",
        val
    );
    self.cross_shard_dep_avoid_threshold = val;
    self
}
```

Apply the same validation in:
- `PartitionerV1Config::cross_shard_dep_avoid_threshold()` in `execution/block-partitioner/src/sharded_block_partitioner/config.rs`
- `PartitionState::new()` in `execution/block-partitioner/src/v2/state.rs` (defensive check)

Additionally, add validation in the command-line argument parsing to provide clear error messages to operators.

## Proof of Concept

```rust
#[test]
fn test_nan_threshold_breaks_determinism() {
    use execution::block_partitioner::v2::config::PartitionerV2Config;
    use execution::block_partitioner::BlockPartitioner;
    
    // Create two partitioners: one with normal threshold, one with NaN
    let normal_partitioner = PartitionerV2Config::default()
        .cross_shard_dep_avoid_threshold(0.9)
        .build();
    
    let nan_partitioner = PartitionerV2Config::default()
        .cross_shard_dep_avoid_threshold(f32::NAN)
        .build();
    
    // Generate identical test transactions
    let block_gen = P2PBlockGenerator::new(100);
    let mut rng = thread_rng();
    let txns = block_gen.rand_block(&mut rng, 100);
    
    // Partition with both configurations
    let result_normal = normal_partitioner.partition(txns.clone(), 4);
    let result_nan = nan_partitioner.partition(txns.clone(), 4);
    
    // Extract execution order via flattening
    let order_normal = PartitionedTransactions::flatten(result_normal.sharded_txns().clone());
    let order_nan = PartitionedTransactions::flatten(result_nan.sharded_txns().clone());
    
    // Verify they produce DIFFERENT execution orders
    // (In a correct implementation, this should fail - they should be equal)
    assert_ne!(
        order_normal.iter().map(|t| t.hash()).collect::<Vec<_>>(),
        order_nan.iter().map(|t| t.hash()).collect::<Vec<_>>(),
        "NaN threshold produces different execution order, breaking consensus determinism"
    );
}
```

The test demonstrates that NaN produces a different transaction execution order than a normal threshold value, which would cause consensus failure when different validators use different configurations.

### Citations

**File:** execution/block-partitioner/src/v2/config.rs (L33-36)
```rust
    pub fn cross_shard_dep_avoid_threshold(mut self, val: f32) -> Self {
        self.cross_shard_dep_avoid_threshold = val;
        self
    }
```

**File:** execution/block-partitioner/src/v2/partition_to_matrix.rs (L43-47)
```rust
            if num_remaining_txns
                < ((1.0 - state.cross_shard_dep_avoid_threshold) * state.num_txns() as f32) as usize
            {
                break;
            }
```

**File:** types/src/block_executor/partitioner.rs (L378-394)
```rust
    pub fn flatten(block: Vec<SubBlocksForShard<T>>) -> Vec<T> {
        let num_shards = block.len();
        let mut flattened_txns = Vec::new();
        let num_rounds = block[0].num_sub_blocks();
        let mut ordered_blocks = vec![SubBlock::empty(); num_shards * num_rounds];
        for (shard_id, sub_blocks) in block.into_iter().enumerate() {
            for (round, sub_block) in sub_blocks.into_sub_blocks().into_iter().enumerate() {
                ordered_blocks[round * num_shards + shard_id] = sub_block;
            }
        }

        for sub_block in ordered_blocks.into_iter() {
            flattened_txns.extend(sub_block.into_txns());
        }

        flattened_txns
    }
```

**File:** consensus/README.md (L35-35)
```markdown
We reformulate the safety conditions and provide extended proofs of safety, liveness, and optimistic responsiveness. We also implement a number of additional features. First, we make the protocol more resistant to non-determinism bugs, by having validators collectively sign the resulting state of a block rather than just the sequence of transactions. This also allows clients to use quorum certificates to authenticate reads from the database. Second, we design a round_state that emits explicit timeouts, and validators rely on a quorum of those to move to the next round â€” without requiring synchronized clocks. Third, we intend to design an unpredictable leader election mechanism in which the leader of a round is determined by the proposer of the latest committed block using a verifiable rand ... (truncated)
```
