# Audit Report

## Title
Critical Edge Detection Bypass in Move Compiler V2 Due to Entry Block Exclusion

## Summary
The `check_postcondition()` function in the split critical edges processor excludes the entry block from predecessor counting, creating a vulnerability where critical edges targeting the first basic block of a function are not detected when that block has exactly one predecessor besides the entry block.

## Finding Description

The Move compiler v2's `SplitCriticalEdgesProcessor` is responsible for identifying and splitting critical edges in the control flow graph. A critical edge is defined as an edge where:
- The source node has multiple successors (>1)
- The target node has multiple predecessors (>1) [1](#0-0) 

The `check_postcondition()` function verifies that no critical edges remain after transformation. However, it contains a flaw in how it counts predecessors: [2](#0-1) 

The code explicitly excludes the entry block when counting incoming edges (lines 72-75). This means that edges FROM the entry block TO its successor are never counted in the predecessor count.

The entry block is a dummy block that always has exactly one successor - the first real basic block of the function: [3](#0-2) [4](#0-3) 

**The Vulnerability:**

Consider bytecode where:
1. Block0 is the first basic block (entry block's successor)
2. Block1 branches back to Block0 and to Block2
3. Block0 falls through to Block1

In this scenario:
- Block0 has 2 **actual** predecessors: Entry and Block1
- Block1 has 2 successors: Block0 and Block2
- Therefore, Block1 → Block0 is a critical edge

However, the check computes:
- `pred_count[Block0] = 1` (only Block1 counted, Entry excluded)
- When checking Block1's edges: `pred_count[Block0] = 1 ≤ 1` ✓ **PASSES**

The critical edge Block1 → Block0 is **not detected** and remains **unsplit**.

## Impact Explanation

**Severity: High**

This vulnerability affects the **Deterministic Execution** invariant of the Aptos blockchain. The Move compiler v2 is used to compile Move bytecode that executes on all validators. Subsequent compiler passes assume that critical edges have been split: [5](#0-4) 

When critical edges remain unsplit, downstream optimizations and analyses (such as `LiveVarAnalysisProcessor`, `DeadStoreElimination`, `VariableCoalescing`) may produce incorrect bytecode transformations. This could lead to:

1. **Different validators generating different bytecode** for the same Move source code, breaking consensus
2. **Incorrect optimization decisions** that change program semantics
3. **Invalid bytecode** that passes compilation but behaves incorrectly at runtime

While this doesn't directly cause fund loss, it violates the deterministic execution requirement and could cause validator nodes to diverge in their state computation, qualifying as a **significant protocol violation** under High severity criteria.

## Likelihood Explanation

**Likelihood: Medium-High**

This vulnerability can be triggered by any Move module that contains a loop or backward branch to the function's entry block. Common patterns include:

- `while(true)` loops that start at function entry
- `loop` constructs with breaks to the beginning
- Tail-recursive patterns that jump back to function start

The `SPLIT_CRITICAL_EDGES` experiment flag must be enabled for this code path to execute: [6](#0-5) 

If this feature is enabled in production (which it likely is, given it's a prerequisite for other passes), the vulnerability is easily triggerable through standard Move code patterns.

## Recommendation

Modify the predecessor counting logic to include edges from the entry block, since the entry block's successor can indeed have multiple predecessors:

```rust
fn check_postcondition(code: &[Bytecode]) {
    let cfg = StacklessControlFlowGraph::new_forward(code);
    let blocks = cfg.blocks();
    let mut pred_count: BTreeMap<BlockId, usize> =
        blocks.iter().map(|block_id| (*block_id, 0)).collect();
    for block in &blocks {
        // FIXED: Count ALL edges, including from entry block
        // Entry block can have a successor with multiple predecessors
        for suc_block in cfg.successors(*block) {
            *pred_count
                .get_mut(suc_block)
                .unwrap_or_else(|| panic!("block {}", suc_block)) += 1;
        }
    }
    // Rest of the check remains the same...
}
```

Alternatively, if excluding the entry block is intentional for some reason, add an additional check to verify that the entry block's immediate successor does not have multiple predecessors (excluding entry itself):

```rust
// After the main check, verify entry block's successor
let entry_successor = cfg.successors(cfg.entry_block())[0];
let actual_pred_count = pred_count.get(&entry_successor).unwrap_or(&0);
// Entry's successor should not have multiple non-entry predecessors
// if some block branches to it
assert!(
    *actual_pred_count <= 1,
    "Entry block's successor {} has multiple predecessors",
    entry_successor
);
```

## Proof of Concept

```rust
#[test]
fn test_critical_edge_entry_successor() {
    use super::{AttrId, Bytecode, SplitCriticalEdgesProcessor};
    use move_stackless_bytecode::stackless_bytecode::Label as L;
    use Bytecode::*;

    let attr = AttrId::new(0);
    let l0 = L::new(0);
    let l2 = L::new(2);
    let t = 0;

    // L0: nop                  // Block0 (offset 0, entry successor)
    //     branch L0, L2, t     // Block1 (offset 1, branches back to L0)
    // L2: ret                  // Block2 (offset 2)
    //
    // CFG: Entry -> Block0 -> Block1 -> {Block0, Block2}
    // Block0 has 2 predecessors: Entry and Block1
    // Block1 has 2 successors: Block0 and Block2
    // Therefore Block1 -> Block0 is a CRITICAL EDGE
    
    let code = vec![
        Label(attr, l0),
        Nop(attr),
        Branch(attr, l0, l2, t),  // branches back to L0 or to L2
        Label(attr, l2),
        Ret(attr, vec![]),
    ];

    // This should panic because there's an unsplit critical edge,
    // but it will pass due to the bug
    SplitCriticalEdgesProcessor::check_postcondition(&code);
    
    // The check incorrectly passes, proving the vulnerability
    println!("BUG: check_postcondition passed despite critical edge Block1->Block0");
}
```

**Expected behavior**: The check should fail because Block1 → Block0 is a critical edge.

**Actual behavior**: The check passes because `pred_count[Block0] = 1` (entry edge not counted), even though Block0 has 2 actual predecessors.

## Notes

The root cause is the assumption that excluding the entry block from predecessor counting is safe. While the entry block itself can never be the source of a critical edge (it always has exactly 1 successor), its immediate successor CAN be the target of critical edges from other blocks that branch back to it. The current check fails to account for this scenario.

### Citations

**File:** third_party/move/move-compiler-v2/src/pipeline/split_critical_edges_processor.rs (L4-12)
```rust
//! This pass splits critical edges with empty blocks.
//! A critical edge is an edge where the source node has multiple successors,
//! and the target node has multiple predecessors.
//!
//! Side effects: clear existing annotations.
//!
//! Prerequisites: no call instructions have abort actions.
//!
//! Postconditions: no critical edges in the control flow graph.
```

**File:** third_party/move/move-compiler-v2/src/pipeline/split_critical_edges_processor.rs (L66-94)
```rust
    fn check_postcondition(code: &[Bytecode]) {
        let cfg = StacklessControlFlowGraph::new_forward(code);
        let blocks = cfg.blocks();
        let mut pred_count: BTreeMap<BlockId, usize> =
            blocks.iter().map(|block_id| (*block_id, 0)).collect();
        for block in &blocks {
            // don't count the edge from the dummy start to a block as an incoming edge
            if *block == cfg.entry_block() {
                continue;
            }
            for suc_block in cfg.successors(*block) {
                *pred_count
                    .get_mut(suc_block)
                    .unwrap_or_else(|| panic!("block {}", suc_block)) += 1;
            }
        }
        for block in blocks {
            let successors = cfg.successors(block);
            if successors.len() > 1 {
                for suc_block in successors {
                    assert!(
                        *pred_count.get(suc_block).expect("pred count") <= 1,
                        "{} has > 1 predecessors",
                        suc_block
                    )
                }
            }
        }
    }
```

**File:** third_party/move/move-model/bytecode/src/stackless_control_flow_graph.rs (L44-54)
```rust
const DUMMY_ENTRANCE: BlockId = 0;
const DUMMY_EXIT: BlockId = 1;

impl StacklessControlFlowGraph {
    pub fn new_forward(code: &[Bytecode]) -> Self {
        Self {
            entry_block_id: DUMMY_ENTRANCE,
            blocks: Self::collect_blocks(code),
            backward: false,
        }
    }
```

**File:** third_party/move/move-model/bytecode/src/stackless_control_flow_graph.rs (L174-177)
```rust
        blocks.insert(DUMMY_ENTRANCE, Block {
            successors: vec![entry_bb],
            content: BlockContent::Dummy,
        });
```

**File:** third_party/move/move-compiler-v2/src/lib.rs (L506-509)
```rust
    // Preprocessing of the stackless bytecode. Many passes expect the absence of critical edges.
    if options.experiment_on(Experiment::SPLIT_CRITICAL_EDGES) {
        pipeline.add_processor(Box::new(SplitCriticalEdgesProcessor {}));
    }
```
