# Audit Report

## Title
Library Test Code Incorrectly Retained During Test Mode Compilation Due to Incomplete #[test_only] Filtering

## Summary
The `should_remove_node()` function in `filter_test_members.rs` contains a logic error that allows library code annotated with `#[test_only]` to remain in test mode compilations when it should be filtered out. This occurs because the filtering logic only checks for `TestingAttribute::Test` but not `TestingAttribute::TestOnly` when evaluating library code, creating a security boundary violation that could enable supply chain attacks.

## Finding Description

The `is_source_def` parameter is correctly propagated through all filtering calls. [1](#0-0) 

However, the filtering logic in `should_remove_node()` has a critical flaw in how it handles library code with `#[test_only]` attributes. [2](#0-1) 

The function uses a two-part condition to determine if code should be removed:
1. Remove if it has test attributes AND test functions should not be kept
2. Remove if it's library code AND has `#[test]` attribute

The bug is in the second condition - it only checks for `TestingAttribute::Test`, not `TestingAttribute::TestOnly`. [3](#0-2) 

The `TestingAttribute` enum has three variants. [4](#0-3) 

When `keep_testing_functions()` returns true (in test mode), the function returns `self.test || self.keep_testing_functions`. [5](#0-4) 

**Attack Scenario:**
1. Attacker publishes a Move library containing a module with `#[test_only]` functions that include malicious logic or security vulnerabilities
2. Victim project depends on this library as a dependency
3. When compiling in test mode (standard during development), the malicious library's `#[test_only]` code is incorrectly included
4. Victim's test code can call these library functions, executing the malicious logic
5. This could manipulate test results, exfiltrate information during testing, or create hidden dependencies on vulnerable code

## Impact Explanation

This qualifies as **Medium Severity** per Aptos bug bounty criteria because:

1. **Supply Chain Security Violation**: It enables malicious library authors to inject code that bypasses intended security boundaries
2. **Test Integrity Compromise**: Test results can be manipulated to hide bugs or vulnerabilities in the actual codebase
3. **State Inconsistency Risk**: Developers may write code that depends on library test functions, creating inconsistencies between test and production environments
4. **Limited Scope**: Impact is contained to test mode compilation, not production deployments (test poison mechanism provides additional protection)

While it doesn't directly lead to funds loss or consensus violations, it compromises the integrity of the development and testing process, which is a critical security boundary in the Move ecosystem where source dependencies are common.

## Likelihood Explanation

**Likelihood: Medium to High**

- Test mode compilation is standard practice during Move development
- The Move ecosystem encourages code reuse through dependencies
- Developers commonly include third-party libraries
- No special privileges or insider access required
- Exploitation requires only publishing a malicious library with `#[test_only]` functions
- The bug triggers automatically when library code with `#[test_only]` is compiled in test mode

## Recommendation

Fix the filtering logic to check for both `TestingAttribute::Test` AND `TestingAttribute::TestOnly` when filtering library code:

```rust
fn should_remove_node(env: &CompilationEnv, attrs: &[P::Attributes], is_source_def: bool) -> bool {
    use known_attributes::TestingAttribute;
    let flattened_attrs: Vec<_> = attrs.iter().flat_map(test_attributes).collect();
    let is_test_only = flattened_attrs
        .iter()
        .any(|attr| matches!(attr.1, TestingAttribute::Test | TestingAttribute::TestOnly));
    is_test_only && !env.flags().keep_testing_functions()
        || (!is_source_def
            && flattened_attrs
                .iter()
                .any(|attr| matches!(attr.1, TestingAttribute::Test | TestingAttribute::TestOnly)))
}
```

The fix changes line 234 from checking only `TestingAttribute::Test` to checking both `Test` and `TestOnly` variants using the `matches!` macro.

## Proof of Concept

**Scenario Setup:**

1. Create a malicious library module `lib_module.move`:
```move
module 0x1::MaliciousLib {
    #[test_only]
    public fun backdoor(): u64 {
        // This should be filtered out for library code
        // but currently remains in test mode
        999
    }
}
```

2. Create source module `source_module.move` that depends on it:
```move
module 0x2::VictimModule {
    use 0x1::MaliciousLib;
    
    #[test]
    fun test_functionality() {
        // This can call library test-only code
        let result = MaliciousLib::backdoor();
        assert!(result == 999, 0);
    }
}
```

3. Compile with test mode enabled and library code in `lib_definitions`

**Expected Behavior:** Library `#[test_only]` function should be filtered out, causing compilation error

**Actual Behavior:** Library `#[test_only]` function remains, compilation succeeds, test can call malicious code

**Verification Steps:**
1. Add debug logging to `should_remove_node()` to track return values
2. Compile with library containing `#[test_only]` in test mode
3. Observe that library `#[test_only]` members are not filtered
4. Apply the recommended fix
5. Verify that library `#[test_only]` members are correctly filtered

## Notes

The `is_source_def` parameter propagation itself is correct throughout the codebase. The vulnerability exists specifically in the filtering decision logic, not in parameter passing. The test poison mechanism (which adds a function that calls `create_signers_for_testing`) provides defense-in-depth against accidental production deployment, but does not prevent the execution of incorrect code during testing. [6](#0-5)

### Citations

**File:** third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/filter.rs (L134-179)
```rust
pub fn filter_program<T: FilterContext>(context: &mut T, prog: P::Program) -> P::Program {
    let P::Program {
        named_address_maps,
        source_definitions,
        lib_definitions,
    } = prog;

    let lib_definitions: Vec<_> = lib_definitions
        .into_iter()
        .filter_map(
            |P::PackageDefinition {
                 package,
                 named_address_map,
                 def,
             }| {
                Some(P::PackageDefinition {
                    package,
                    named_address_map,
                    def: filter_definition(context, def, false)?,
                })
            },
        )
        .collect();

    let source_definitions: Vec<_> = source_definitions
        .into_iter()
        .filter_map(
            |P::PackageDefinition {
                 package,
                 named_address_map,
                 def,
             }| {
                Some(P::PackageDefinition {
                    package,
                    named_address_map,
                    def: filter_definition(context, def, true)?,
                })
            },
        )
        .collect();

    P::Program {
        named_address_maps,
        source_definitions,
        lib_definitions,
    }
```

**File:** third_party/move/move-compiler-v2/legacy-move-compiler/src/unit_test/filter_test_members.rs (L165-219)
```rust
/// If a module is being compiled in test mode, create a dummy function that calls a native
/// function `0x1::UnitTest::create_signers_for_testing` that only exists if the VM is being run
/// with the "unit_test" feature flag set. This will then cause the module to fail to link if
/// an attempt is made to publish a module that has been compiled in test mode on a VM that is not
/// running in test mode.
fn create_test_poison(mloc: Loc) -> P::ModuleMember {
    let signature = P::FunctionSignature {
        type_parameters: vec![],
        parameters: vec![],
        return_type: sp(mloc, P::Type_::Unit),
    };

    let leading_name_access = sp(
        mloc,
        P::LeadingNameAccess_::Name(sp(mloc, STDLIB_ADDRESS_NAME.into())),
    );

    let mod_name = sp(mloc, UNIT_TEST_MODULE_NAME.into());
    let mod_addr_name = sp(mloc, (leading_name_access, mod_name));
    let fn_name = sp(mloc, "create_signers_for_testing".into());
    let args_ = vec![sp(
        mloc,
        P::Exp_::Value(sp(mloc, P::Value_::Num("0".into()))),
    )];
    let nop_call = P::Exp_::Call(
        sp(mloc, P::NameAccessChain_::Three(mod_addr_name, fn_name)),
        CallKind::Regular,
        None,
        sp(mloc, args_),
    );

    // fun unit_test_poison() { 0x1::UnitTest::create_signers_for_testing(0); () }
    P::ModuleMember::Function(P::Function {
        attributes: vec![],
        loc: mloc,
        visibility: P::Visibility::Internal,
        entry: None,
        access_specifiers: None,
        signature,
        inline: false,
        name: P::FunctionName(sp(mloc, "unit_test_poison".into())),
        body: sp(
            mloc,
            P::FunctionBody_::Defined((
                vec![],
                vec![sp(
                    mloc,
                    P::SequenceItem_::Seq(Box::new(sp(mloc, nop_call))),
                )],
                None,
                Box::new(Some(sp(mloc, P::Exp_::Unit))),
            )),
        ),
    })
}
```

**File:** third_party/move/move-compiler-v2/legacy-move-compiler/src/unit_test/filter_test_members.rs (L224-235)
```rust
fn should_remove_node(env: &CompilationEnv, attrs: &[P::Attributes], is_source_def: bool) -> bool {
    use known_attributes::TestingAttribute;
    let flattened_attrs: Vec<_> = attrs.iter().flat_map(test_attributes).collect();
    let is_test_only = flattened_attrs
        .iter()
        .any(|attr| matches!(attr.1, TestingAttribute::Test | TestingAttribute::TestOnly));
    is_test_only && !env.flags().keep_testing_functions()
        || (!is_source_def
            && flattened_attrs
                .iter()
                .any(|attr| attr.1 == TestingAttribute::Test))
}
```

**File:** third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/mod.rs (L478-480)
```rust
    pub fn keep_testing_functions(&self) -> bool {
        self.test || self.keep_testing_functions
    }
```

**File:** third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/mod.rs (L666-673)
```rust
    pub enum TestingAttribute {
        // Can be called by other testing code, and included in compilation in test mode
        TestOnly,
        // Is a test that will be run
        Test,
        // This test is expected to fail
        ExpectedFailure,
    }
```
