# Audit Report

## Title
Validator Network Address Hijacking via Unchecked Public Key Injection

## Summary
The `update_network_and_fullnode_addresses()` function in the staking module does not validate that the public key embedded in a validator's NetworkAddress corresponds to their actual identity. Combined with the lack of peer ID verification during outbound connection establishment, this allows a malicious validator to point their on-chain NetworkAddress to another validator's IP address with that validator's public key, causing peer identity confusion and denial-of-service attacks on the targeted validator.

## Finding Description

The vulnerability exists in the interaction between three components:

**1. Missing Validation in On-Chain NetworkAddress Update**

When a validator operator updates their network addresses, the `update_network_and_fullnode_addresses()` function accepts arbitrary byte vectors without validating their contents: [1](#0-0) 

The function only verifies operator authorization but does not validate that the NetworkAddress contains the correct public key for that validator.

**2. NetworkAddress Format and Public Key Extraction**

NetworkAddresses are expected to have the format `/ip4/<ip>/tcp/<port>/noise-ik/<pubkey>/handshake/<version>`. The `parse_dial_addr()` function extracts the embedded public key from the NetworkAddress: [2](#0-1) 

**3. Missing Peer ID Verification in Outbound Connection**

When establishing an outbound connection, the `upgrade_outbound()` function performs a Noise handshake with the extracted public key but never verifies that this public key corresponds to the intended `remote_peer_id`: [3](#0-2) 

The function creates ConnectionMetadata with the supplied `remote_peer_id` regardless of which public key was actually authenticated.

**4. PeerId Derivation Relationship**

In Aptos, PeerIds are derived from x25519 public keys using the last 16 bytes: [4](#0-3) 

This means each public key has a unique corresponding PeerId, but the system doesn't enforce this relationship during connection establishment.

**5. No Validation During Discovery Propagation**

The on-chain discovery mechanism extracts NetworkAddresses from the validator set without validation: [5](#0-4) 

**Attack Scenario:**

1. Malicious Validator A (peer_A, pubkey_A) and Legitimate Validator B (peer_B, pubkey_B) are both in the validator set
2. Validator A's operator calls `update_network_and_fullnode_addresses()` with a crafted NetworkAddress:
   ```
   /ip4/<B_ip_address>/tcp/<B_port>/noise-ik/<pubkey_B>/handshake/0
   ```
   Note: This contains Validator B's IP and public key, not A's!
3. This malicious NetworkAddress is stored on-chain and propagates to all validators via on-chain discovery
4. When any honest Validator C attempts to dial peer_A for consensus operations:
   - C extracts pubkey_B from the NetworkAddress
   - C dials to B's IP address
   - C performs Noise handshake expecting pubkey_B
   - Connection succeeds (B legitimately presents pubkey_B)
   - C creates ConnectionMetadata claiming connection to peer_A
   - But C is actually connected to peer_B

5. Result: Validator C believes it has a connection to peer_A but is actually connected to peer_B. From B's perspective, it just sees an inbound connection from C (which is legitimate), so B has no way to detect the attack: [6](#0-5) 

The inbound handshake on B's side only verifies that C is who C claims to be, not whether C's intention to connect to peer_A is correct.

## Impact Explanation

This vulnerability has **High Severity** impact:

**Denial of Service on Target Validator:**
- Validator A becomes completely unreachable as all connection attempts are redirected to Validator B
- Validator A cannot participate in consensus, causing liveness issues if enough validators are affected

**Consensus Protocol Violations:**
- Messages intended for peer_A are delivered to peer_B
- Duplicate connections to peer_B may cause protocol state confusion
- If the attacked validator is a leader, consensus rounds may fail

**Validator Set Disruption:**
- Multiple malicious validators could execute this attack simultaneously
- Could cause systemic network issues if enough validators are targeted
- Requires manual intervention to detect and remediate

This qualifies as **High Severity** per Aptos Bug Bounty criteria:
- Validator node slowdowns/disruption ✓
- Significant protocol violations ✓
- Could escalate to liveness issues affecting consensus

While not quite reaching Critical severity (no direct fund loss or permanent network partition), this represents a serious attack vector that could disrupt validator operations and consensus participation.

## Likelihood Explanation

**Likelihood: Medium**

**Prerequisites:**
- Requires a compromised validator operator account OR a malicious validator
- Requires on-chain transaction to update NetworkAddresses
- No complex timing or race conditions needed

**Ease of Exploitation:**
- Simple on-chain transaction with crafted NetworkAddress
- Attack is deterministic and reliable once executed
- No cryptographic breaks or complex setup required

**Detection Difficulty:**
- Affected validators would experience connection failures to the malicious validator
- Duplicate connections to the victim validator might raise alerts
- Connection metadata mismatch could be logged but not automatically detected
- Requires manual investigation to identify the root cause

**Mitigation Factors:**
- Validators are expected to be run by trusted operators
- Suspicious NetworkAddress updates could be monitored
- Impact is limited to redirecting specific peer connections

The attack is straightforward for a compromised operator but requires access to validator operator keys, placing it in the Medium likelihood category.

## Recommendation

Implement validation at multiple layers:

**1. On-Chain Validation in stake.move:**

Add validation in `update_network_and_fullnode_addresses()` to verify that all NetworkAddresses contain public keys that match the validator's expected identity:

```move
public entry fun update_network_and_fullnode_addresses(
    operator: &signer,
    pool_address: address,
    new_network_addresses: vector<u8>,
    new_fullnode_addresses: vector<u8>,
) acquires StakePool, ValidatorConfig {
    // ... existing checks ...
    
    // NEW: Validate that network addresses contain correct public keys
    validate_network_addresses_for_pool(pool_address, new_network_addresses);
    validate_network_addresses_for_pool(pool_address, new_fullnode_addresses);
    
    // ... rest of function ...
}

// New validation function
fun validate_network_addresses_for_pool(pool_address: address, encoded_addresses: vector<u8>) {
    // Decode addresses and verify each contains a public key that derives to pool_address
    // This requires adding native function support for x25519 pubkey to address derivation
    // Reject the transaction if any address contains an incorrect public key
}
```

**2. Off-Chain Verification in dial():**

Add a check in the transport layer to verify public key correspondence:

```rust
// In network/framework/src/transport/mod.rs, dial() function
pub fn dial(
    &self,
    peer_id: PeerId,
    addr: NetworkAddress,
) -> io::Result<impl Future<...>> {
    let (base_addr, pubkey, handshake_version) = Self::parse_dial_addr(&addr)?;
    
    // NEW: Verify that pubkey derives to peer_id
    let derived_peer_id = aptos_types::account_address::from_identity_public_key(pubkey);
    if derived_peer_id != peer_id {
        return Err(io::Error::new(
            io::ErrorKind::InvalidInput,
            format!(
                "Public key mismatch: NetworkAddress contains pubkey that derives to {}, but attempting to dial peer {}",
                derived_peer_id, peer_id
            ),
        ));
    }
    
    // ... rest of dial logic ...
}
```

**3. Additional Validation in ConnectivityManager:**

Validate addresses when they're added to the discovered peer set: [7](#0-6) 

Add validation in `handle_update_discovered_peers()` to filter out addresses with mismatched public keys before they're used for dialing.

## Proof of Concept

```rust
// Rust test demonstrating the vulnerability
#[cfg(test)]
mod test_network_address_hijacking {
    use super::*;
    use aptos_crypto::x25519;
    use aptos_types::{account_address::from_identity_public_key, network_address::NetworkAddress};
    
    #[test]
    fn test_public_key_mismatch_not_detected() {
        // Create two validators with different keys
        let validator_a_key = x25519::PrivateKey::generate_for_testing();
        let validator_a_pubkey = validator_a_key.public_key();
        let validator_a_peer_id = from_identity_public_key(validator_a_pubkey);
        
        let validator_b_key = x25519::PrivateKey::generate_for_testing();
        let validator_b_pubkey = validator_b_key.public_key();
        let validator_b_peer_id = from_identity_public_key(validator_b_pubkey);
        
        // Validator A creates a malicious NetworkAddress pointing to B's IP with B's pubkey
        let malicious_addr = NetworkAddress::from_str(
            &format!("/ip4/10.0.0.2/tcp/6180/noise-ik/{}/handshake/0", 
                    validator_b_pubkey)
        ).unwrap();
        
        // When parsing this address for dialing validator_a_peer_id
        let (base_addr, extracted_pubkey, _) = AptosNetTransport::parse_dial_addr(&malicious_addr).unwrap();
        
        // The extracted pubkey is B's, not A's
        assert_eq!(extracted_pubkey, validator_b_pubkey);
        
        // But there's no check that this pubkey derives to validator_a_peer_id!
        let derived_peer_id = from_identity_public_key(extracted_pubkey);
        assert_ne!(derived_peer_id, validator_a_peer_id); // MISMATCH NOT DETECTED!
        
        // The dial would proceed with mismatched peer_id and pubkey
        // Leading to connection to wrong peer
    }
}
```

This test demonstrates that the system does not detect when a NetworkAddress contains a public key that doesn't match the intended peer_id, allowing the identity confusion attack to succeed.

## Notes

The vulnerability exists because the system trusts that NetworkAddresses stored on-chain are correct and correspond to the validator's actual identity. While the Noise handshake provides strong authentication of the public key, it doesn't verify the semantic correctness of which peer that public key should belong to.

The inbound handshake does include peer ID verification for untrusted peers in MaybeMutual mode [8](#0-7) , but this only applies to inbound connections from peers outside the trusted set. For outbound connections to known validators, no such check exists.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L955-995)
```text
    public entry fun update_network_and_fullnode_addresses(
        operator: &signer,
        pool_address: address,
        new_network_addresses: vector<u8>,
        new_fullnode_addresses: vector<u8>,
    ) acquires StakePool, ValidatorConfig {
        check_stake_permission(operator);
        assert_reconfig_not_in_progress();
        assert_stake_pool_exists(pool_address);
        let stake_pool = borrow_global_mut<StakePool>(pool_address);
        assert!(signer::address_of(operator) == stake_pool.operator_address, error::unauthenticated(ENOT_OPERATOR));
        assert!(exists<ValidatorConfig>(pool_address), error::not_found(EVALIDATOR_CONFIG));
        let validator_info = borrow_global_mut<ValidatorConfig>(pool_address);
        let old_network_addresses = validator_info.network_addresses;
        validator_info.network_addresses = new_network_addresses;
        let old_fullnode_addresses = validator_info.fullnode_addresses;
        validator_info.fullnode_addresses = new_fullnode_addresses;

        if (std::features::module_event_migration_enabled()) {
            event::emit(
                UpdateNetworkAndFullnodeAddresses {
                    pool_address,
                    old_network_addresses,
                    new_network_addresses,
                    old_fullnode_addresses,
                    new_fullnode_addresses,
                },
            );
        } else {
            event::emit_event(
                &mut stake_pool.update_network_and_fullnode_addresses_events,
                UpdateNetworkAndFullnodeAddressesEvent {
                    pool_address,
                    old_network_addresses,
                    new_network_addresses,
                    old_fullnode_addresses,
                    new_fullnode_addresses,
                },
            );
        };
    }
```

**File:** network/framework/src/transport/mod.rs (L336-407)
```rust
pub async fn upgrade_outbound<T: TSocket>(
    ctxt: Arc<UpgradeContext>,
    fut_socket: impl Future<Output = io::Result<T>>,
    addr: NetworkAddress,
    remote_peer_id: PeerId,
    remote_pubkey: x25519::PublicKey,
) -> io::Result<Connection<NoiseStream<T>>> {
    let origin = ConnectionOrigin::Outbound;
    let socket = fut_socket.await?;

    // noise handshake
    let (mut socket, peer_role) = ctxt
        .noise
        .upgrade_outbound(
            socket,
            remote_peer_id,
            remote_pubkey,
            AntiReplayTimestamps::now,
        )
        .await
        .map_err(|err| {
            if err.should_security_log() {
                sample!(
                    SampleRate::Duration(Duration::from_secs(15)),
                    warn!(
                        SecurityEvent::NoiseHandshake,
                        NetworkSchema::new(&ctxt.noise.network_context)
                            .network_address(&addr)
                            .connection_origin(&origin),
                        error = %err,
                    )
                );
            }
            io::Error::other(err)
        })?;

    // sanity check: Noise IK should always guarantee this is true
    debug_assert_eq!(remote_pubkey, socket.get_remote_static());

    // exchange HandshakeMsg
    let handshake_msg = HandshakeMsg {
        supported_protocols: ctxt.supported_protocols.clone(),
        chain_id: ctxt.chain_id,
        network_id: ctxt.network_id,
    };
    let remote_handshake = exchange_handshake(&handshake_msg, &mut socket).await?;

    // try to negotiate common aptosnet version and supported application protocols
    let (messaging_protocol, application_protocols) = handshake_msg
        .perform_handshake(&remote_handshake)
        .map_err(|e| {
            let e = format!(
                "handshake negotiation with peer {} failed: {}",
                remote_peer_id, e
            );
            io::Error::other(e)
        })?;

    // return successful connection
    Ok(Connection {
        socket,
        metadata: ConnectionMetadata::new(
            remote_peer_id,
            CONNECTION_ID_GENERATOR.next(),
            addr,
            origin,
            messaging_protocol,
            application_protocols,
            peer_role,
        ),
    })
}
```

**File:** network/framework/src/transport/mod.rs (L471-513)
```rust
    fn parse_dial_addr(
        addr: &NetworkAddress,
    ) -> io::Result<(NetworkAddress, x25519::PublicKey, u8)> {
        use aptos_types::network_address::Protocol::*;

        let protos = addr.as_slice();

        // parse out the base transport protocol(s), which we will just ignore
        // and leave for the base_transport to actually parse and dial.
        // TODO(philiphayes): protos[..X] is kinda hacky. `Transport` trait
        // should handle this.
        let (base_transport_protos, base_transport_suffix) = parse_ip_tcp(protos)
            .map(|x| (&protos[..2], x.1))
            .or_else(|| parse_dns_tcp(protos).map(|x| (&protos[..2], x.1)))
            .or_else(|| parse_memory(protos).map(|x| (&protos[..1], x.1)))
            .ok_or_else(|| {
                io::Error::new(
                    io::ErrorKind::InvalidInput,
                    format!(
                        "Unexpected dialing network address: '{}', expected: \
                         memory, ip+tcp, or dns+tcp",
                        addr
                    ),
                )
            })?;

        // parse out the aptosnet protocols (noise ik and handshake)
        match base_transport_suffix {
            [NoiseIK(pubkey), Handshake(version)] => {
                let base_addr = NetworkAddress::try_from(base_transport_protos.to_vec())
                    .expect("base_transport_protos is always non-empty");
                Ok((base_addr, *pubkey, *version))
            },
            _ => Err(io::Error::new(
                io::ErrorKind::InvalidInput,
                format!(
                    "Unexpected dialing network address: '{}', expected: \
                     '/../noise-ik/<pubkey>/handshake/<version>'",
                    addr
                ),
            )),
        }
    }
```

**File:** types/src/account_address.rs (L140-146)
```rust
pub fn from_identity_public_key(identity_public_key: x25519::PublicKey) -> AccountAddress {
    let mut array = [0u8; AccountAddress::LENGTH];
    let pubkey_slice = identity_public_key.as_slice();
    // keep only the last 16 bytes
    array.copy_from_slice(&pubkey_slice[x25519::PUBLIC_KEY_SIZE - AccountAddress::LENGTH..]);
    AccountAddress::new(array)
}
```

**File:** network/discovery/src/validator_set.rs (L108-150)
```rust
pub(crate) fn extract_validator_set_updates(
    network_context: NetworkContext,
    node_set: ValidatorSet,
) -> PeerSet {
    let is_validator = network_context.network_id().is_validator_network();

    // Decode addresses while ignoring bad addresses
    node_set
        .into_iter()
        .map(|info| {
            let peer_id = *info.account_address();
            let config = info.into_config();

            let addrs = if is_validator {
                config
                    .validator_network_addresses()
                    .map_err(anyhow::Error::from)
            } else {
                config
                    .fullnode_network_addresses()
                    .map_err(anyhow::Error::from)
            }
            .map_err(|err| {
                inc_by_with_context(&DISCOVERY_COUNTS, &network_context, "read_failure", 1);

                warn!(
                    NetworkSchema::new(&network_context),
                    "OnChainDiscovery: Failed to parse any network address: peer: {}, err: {}",
                    peer_id,
                    err
                )
            })
            .unwrap_or_default();

            let peer_role = if is_validator {
                PeerRole::Validator
            } else {
                PeerRole::ValidatorFullNode
            };
            (peer_id, Peer::from_addrs(peer_role, addrs))
        })
        .collect()
}
```

**File:** network/framework/src/noise/handshake.rs (L320-366)
```rust
        // buffer to contain the client first message
        let mut client_message = [0; Self::CLIENT_MESSAGE_SIZE];

        // receive the prologue + first noise handshake message
        trace!("{} noise server: handshake read", self.network_context);
        socket
            .read_exact(&mut client_message)
            .await
            .map_err(NoiseHandshakeError::ServerReadFailed)?;

        // extract prologue (remote_peer_id | self_public_key)
        let (remote_peer_id, self_expected_public_key) =
            client_message[..Self::PROLOGUE_SIZE].split_at(PeerId::LENGTH);

        // parse the client's peer id
        // note: in mutual authenticated network, we could verify that their peer_id is in the trust peer set now.
        // We do this later in this function instead (to batch a number of checks) as there is no known attack here.
        let remote_peer_id = PeerId::try_from(remote_peer_id)
            .map_err(|_| NoiseHandshakeError::InvalidClientPeerId(hex::encode(remote_peer_id)))?;
        let remote_peer_short = remote_peer_id.short_str();

        // reject accidental self-dials
        // this situation could occur either as a result of our own discovery
        // mis-configuration or a potentially malicious discovery peer advertising
        // a (loopback ip or mirror proxy) and our public key.
        if remote_peer_id == self.network_context.peer_id() {
            return Err(NoiseHandshakeError::SelfDialDetected);
        }

        // verify that this is indeed our public key
        let actual_public_key = self.noise_config.public_key();
        if self_expected_public_key != actual_public_key.as_slice() {
            return Err(NoiseHandshakeError::ClientExpectingDifferentPubkey(
                remote_peer_short,
                hex::encode(self_expected_public_key),
                hex::encode(actual_public_key.as_slice()),
            ));
        }

        // parse it
        let (prologue, client_init_message) = client_message.split_at(Self::PROLOGUE_SIZE);
        let (remote_public_key, handshake_state, payload) = self
            .noise_config
            .parse_client_init_message(prologue, client_init_message)
            .map_err(|err| NoiseHandshakeError::ServerParseClient(remote_peer_short, err))?;

        // if mutual auth mode, verify the remote pubkey is in our set of trusted peers
```

**File:** network/framework/src/noise/handshake.rs (L391-405)
```rust
                    None => {
                        // The peer is not in the trusted peer set. Verify that the Peer ID is
                        // constructed correctly from the public key.
                        let derived_remote_peer_id =
                            aptos_types::account_address::from_identity_public_key(
                                remote_public_key,
                            );
                        if derived_remote_peer_id != remote_peer_id {
                            // The peer ID is not constructed correctly from the public key
                            Err(NoiseHandshakeError::ClientPeerIdMismatch(
                                remote_peer_short,
                                remote_peer_id,
                                derived_remote_peer_id,
                            ))
                        } else {
```

**File:** network/framework/src/connectivity_manager/mod.rs (L886-1002)
```rust
    fn handle_update_discovered_peers(
        &mut self,
        src: DiscoverySource,
        new_discovered_peers: PeerSet,
    ) {
        // Log the update event
        info!(
            NetworkSchema::new(&self.network_context),
            "{} Received updated list of discovered peers! Source: {:?}, num peers: {:?}",
            self.network_context,
            src,
            new_discovered_peers.len()
        );

        // Remove peers that no longer have relevant network information
        let mut keys_updated = false;
        let mut peers_to_check_remove = Vec::new();
        for (peer_id, peer) in self.discovered_peers.write().peer_set.iter_mut() {
            let new_peer = new_discovered_peers.get(peer_id);
            let check_remove = if let Some(new_peer) = new_peer {
                if new_peer.keys.is_empty() {
                    keys_updated |= peer.keys.clear_src(src);
                }
                if new_peer.addresses.is_empty() {
                    peer.addrs.clear_src(src);
                }
                new_peer.addresses.is_empty() && new_peer.keys.is_empty()
            } else {
                keys_updated |= peer.keys.clear_src(src);
                peer.addrs.clear_src(src);
                true
            };
            if check_remove {
                peers_to_check_remove.push(*peer_id);
            }
        }

        // Remove peers that no longer have state
        for peer_id in peers_to_check_remove {
            self.discovered_peers.write().remove_peer_if_empty(&peer_id);
        }

        // Make updates to the peers accordingly
        for (peer_id, discovered_peer) in new_discovered_peers {
            // Don't include ourselves, because we don't need to dial ourselves
            if peer_id == self.network_context.peer_id() {
                continue;
            }

            // Create the new `DiscoveredPeer`, role is set when a `Peer` is first discovered
            let mut discovered_peers = self.discovered_peers.write();
            let peer = discovered_peers
                .peer_set
                .entry(peer_id)
                .or_insert_with(|| DiscoveredPeer::new(discovered_peer.role));

            // Update the peer's pubkeys
            let mut peer_updated = false;
            if peer.keys.update(src, discovered_peer.keys) {
                info!(
                    NetworkSchema::new(&self.network_context)
                        .remote_peer(&peer_id)
                        .discovery_source(&src),
                    "{} pubkey sets updated for peer: {}, pubkeys: {}",
                    self.network_context,
                    peer_id.short_str(),
                    peer.keys
                );
                keys_updated = true;
                peer_updated = true;
            }

            // Update the peer's addresses
            if peer.addrs.update(src, discovered_peer.addresses) {
                info!(
                    NetworkSchema::new(&self.network_context).remote_peer(&peer_id),
                    network_addresses = &peer.addrs,
                    "{} addresses updated for peer: {}, update src: {:?}, addrs: {}",
                    self.network_context,
                    peer_id.short_str(),
                    src,
                    &peer.addrs,
                );
                peer_updated = true;
            }

            // If we're currently trying to dial this peer, we reset their
            // dial state. As a result, we will begin our next dial attempt
            // from the first address (which might have changed) and from a
            // fresh backoff (since the current backoff delay might be maxed
            // out if we can't reach any of their previous addresses).
            if peer_updated {
                if let Some(dial_state) = self.dial_states.get_mut(&peer_id) {
                    *dial_state = DialState::new(self.backoff_strategy.clone());
                }
            }
        }

        // update eligible peers accordingly
        if keys_updated {
            // For each peer, union all of the pubkeys from each discovery source
            // to generate the new eligible peers set.
            let new_eligible = self.discovered_peers.read().get_eligible_peers();

            // Swap in the new eligible peers set
            if let Err(error) = self
                .peers_and_metadata
                .set_trusted_peers(&self.network_context.network_id(), new_eligible)
            {
                error!(
                    NetworkSchema::new(&self.network_context),
                    error = %error,
                    "Failed to update trusted peers set"
                );
            }
        }
    }
```
