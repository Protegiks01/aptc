# Audit Report

## Title
Memory Exhaustion via Unbounded WebAuthn Authenticator Deserialization in BCS Transaction Submission

## Summary
The Aptos node API accepts BCS-encoded signed transactions up to 8 MB without validating the authenticator size. An attacker can submit transactions containing `PartialAuthenticatorAssertionResponse` structures with multi-megabyte `authenticator_data` and `client_data_json` fields, causing memory exhaustion through unbounded deserialization before the transaction is rejected.

## Finding Description

The vulnerability exists in the transaction submission flow where BCS-encoded transactions are deserialized without proper size validation on the authenticator component.

**Key Issue**: The transaction size check only validates the `raw_txn` size, not the `authenticator` size. [1](#0-0) 

The HTTP body size limit allows up to 8 MB: [2](#0-1) 

BCS deserialization uses only a **depth limit** (16 levels), not a size limit: [3](#0-2) [4](#0-3) 

The `PartialAuthenticatorAssertionResponse` contains unbounded `Vec<u8>` fields: [5](#0-4) 

While JSON submissions have a 1024-byte limit for WebAuthn signatures: [6](#0-5) [7](#0-6) 

**BCS submissions bypass this validation entirely.**

The gas check validates only the raw transaction size against 64 KB: [8](#0-7) [9](#0-8) 

**Attack Flow:**
1. Attacker crafts `SignedTransaction` with minimal `RawTransaction` (~100 bytes)
2. Adds `PartialAuthenticatorAssertionResponse` with 7 MB `authenticator_data` + 1 MB `client_data_json`
3. BCS-encodes to ~8 MB total
4. Submits via POST `/transactions` with `application/x.aptos.signed_transaction+bcs`
5. `PostSizeLimit` middleware accepts (â‰¤ 8 MB)
6. `bcs::from_bytes_with_limit` deserializes, allocating 8 MB for Vec<u8> fields
7. `TransactionMetadata::new()` calculates `raw_txn_bytes_len()` as ~100 bytes
8. `check_gas()` validates against 64 KB limit (PASSES for raw_txn)
9. **Authenticator size never validated**
10. Memory allocated but transaction eventually rejected during signature verification

By sending thousands of parallel requests, an attacker can exhaust node memory before transactions are rejected.

## Impact Explanation

**Severity: High** (per Aptos Bug Bounty criteria)

This vulnerability enables:
- **Validator node slowdowns**: Memory pressure degrades performance
- **API crashes**: Out-of-memory errors crash the REST API service
- **Resource exhaustion**: Violates invariant #9 (Resource Limits)

An attacker with modest resources can:
- Send 1000+ parallel 8 MB requests
- Allocate 8+ GB of memory on target node
- Sustain attack to cause persistent instability
- No authentication or special privileges required

This does NOT reach Critical severity because:
- No fund loss or consensus violation
- Node can recover by restarting
- Does not require hardfork

## Likelihood Explanation

**Likelihood: Medium-High**

The attack is practical because:
- No rate limiting observed in codebase for transaction submission
- Standard HTTP clients can send parallel requests
- 8 MB payload acceptable to most network infrastructure
- No authentication required for transaction submission endpoint
- Attack signature is difficult to distinguish from legitimate large transactions

Mitigating factors:
- Requires sustained connection to maintain memory pressure
- Node operators may have external rate limiting
- Network bandwidth required: ~8 GB/s for 1000 parallel requests

## Recommendation

**Immediate Fix**: Enforce authenticator size limits for BCS submissions matching JSON submission limits.

Add validation in `get_signed_transaction` after deserialization:

```rust
// In api/src/transactions.rs, after line 1232
let signed_transaction: SignedTransaction =
    bcs::from_bytes_with_limit(&data.0, Self::MAX_SIGNED_TRANSACTION_DEPTH)
        .context("Failed to deserialize input into SignedTransaction")
        .map_err(|err| { ... })?;

// Add authenticator size check
let authenticator_size = bcs::serialized_size(&signed_transaction.authenticator())
    .context("Failed to serialize authenticator")?;
if authenticator_size > MAX_WEBAUTHN_SIGNATURE_BYTES {
    return Err(SubmitTransactionError::bad_request_with_code(
        format!("Authenticator size {} exceeds maximum {}", 
                authenticator_size, MAX_WEBAUTHN_SIGNATURE_BYTES),
        AptosErrorCode::InvalidInput,
        ledger_info,
    ));
}
```

**Long-term Fix**: 
1. Use `bcs::from_bytes_with_limit_and_size()` if available to enforce total size during deserialization
2. Implement consistent authenticator size limits across all submission paths
3. Add rate limiting per IP address for transaction submission endpoints
4. Consider reducing DEFAULT_REQUEST_CONTENT_LENGTH_LIMIT to 1 MB for transaction endpoints

## Proof of Concept

```rust
// PoC demonstrating unbounded deserialization
// File: types/src/transaction/webauthn.rs (test section)

#[test]
fn test_unbounded_authenticator_memory_exhaustion() {
    use crate::transaction::{
        RawTransaction, SignedTransaction, TransactionPayload,
        authenticator::{TransactionAuthenticator, AccountAuthenticator, 
                       SingleKeyAuthenticator, AnySignature, AnyPublicKey},
        webauthn::{PartialAuthenticatorAssertionResponse, AssertionSignature},
    };
    use aptos_crypto::secp256r1_ecdsa;
    
    // Create minimal raw transaction (~100 bytes)
    let raw_txn = RawTransaction::new(
        AccountAddress::random(),
        0,
        TransactionPayload::Script(Script::new(vec![], vec![], vec![])),
        1000,
        0,
        0,
        ChainId::test(),
    );
    
    // Create oversized PartialAuthenticatorAssertionResponse (8 MB)
    let huge_authenticator_data = vec![0u8; 7 * 1024 * 1024]; // 7 MB
    let huge_client_data_json = vec![0u8; 1 * 1024 * 1024];   // 1 MB
    
    let paar = PartialAuthenticatorAssertionResponse::new(
        AssertionSignature::Secp256r1Ecdsa { 
            signature: secp256r1_ecdsa::Signature::from_bytes_unchecked(&[0u8; 64]).unwrap()
        },
        huge_authenticator_data,
        huge_client_data_json,
    );
    
    // Wrap in authenticator
    let authenticator = TransactionAuthenticator::SingleSender {
        sender: AccountAuthenticator::SingleKey {
            authenticator: SingleKeyAuthenticator {
                public_key: AnyPublicKey::secp256r1_ecdsa(
                    secp256r1_ecdsa::PublicKey::from_bytes_unchecked(&[0u8; 65]).unwrap()
                ),
                signature: AnySignature::WebAuthn { signature: paar },
            }
        }
    };
    
    let signed_txn = SignedTransaction::new(raw_txn, authenticator);
    
    // BCS serialize (this will create ~8 MB payload)
    let bcs_bytes = bcs::to_bytes(&signed_txn).unwrap();
    assert!(bcs_bytes.len() > 8 * 1024 * 1024 - 100_000); // ~8 MB
    
    // Deserialize (allocates 8 MB in memory)
    let deserialized: SignedTransaction = 
        bcs::from_bytes_with_limit(&bcs_bytes, 16).unwrap();
    
    // Transaction size check only sees raw_txn size
    assert!(deserialized.raw_txn_bytes_len() < 1000); // Small raw_txn
    
    // But authenticator consumed 8 MB during deserialization (VULNERABILITY)
    println!("Raw txn size: {} bytes", deserialized.raw_txn_bytes_len());
    println!("BCS payload size: {} bytes", bcs_bytes.len());
    println!("Memory exhaustion possible via parallel submissions");
}
```

**Notes:**
- This vulnerability breaks the **Resource Limits** invariant (#9)
- Impact is amplified when combined with parallel connection attacks
- The inconsistency between JSON (1024 byte limit) and BCS (no limit) paths indicates an overlooked validation gap
- Existing `MAX_WEBAUTHN_SIGNATURE_BYTES` constant suggests developers intended size limits but failed to enforce them for BCS submissions

### Citations

**File:** aptos-move/aptos-vm/src/transaction_metadata.rs (L63-63)
```rust
            transaction_size: (txn.raw_txn_bytes_len() as u64).into(),
```

**File:** config/src/config/api_config.rs (L97-97)
```rust
const DEFAULT_REQUEST_CONTENT_LENGTH_LIMIT: u64 = 8 * 1024 * 1024; // 8 MB
```

**File:** api/src/transactions.rs (L851-851)
```rust
    const MAX_SIGNED_TRANSACTION_DEPTH: usize = 16;
```

**File:** api/src/transactions.rs (L1224-1224)
```rust
                    bcs::from_bytes_with_limit(&data.0, Self::MAX_SIGNED_TRANSACTION_DEPTH)
```

**File:** types/src/transaction/webauthn.rs (L12-12)
```rust
pub const MAX_WEBAUTHN_SIGNATURE_BYTES: usize = 1024;
```

**File:** types/src/transaction/webauthn.rs (L78-96)
```rust
#[derive(Clone, Debug, Eq, Hash, PartialEq, Serialize, Deserialize)]
#[cfg_attr(feature = "fuzzing", derive(arbitrary::Arbitrary))]
pub struct PartialAuthenticatorAssertionResponse {
    /// This attribute contains the raw signature returned from the authenticator.
    /// NOTE: Many signatures returned from WebAuthn assertions are not raw signatures.
    /// As an example, Secp256r1 ECDSA signatures are encoded as an [ASN.1 DER Ecdsa-Sig_value](https://www.w3.org/TR/webauthn-3/#sctn-signature-attestation-types)
    /// If the signature is encoded, the client is expected to convert the encoded signature
    /// into a raw signature before including it in the transaction
    signature: AssertionSignature,
    /// This attribute contains the authenticator data returned by the authenticator.
    /// See [`AuthenticatorData`](passkey_types::ctap2::AuthenticatorData).
    #[serde(with = "serde_bytes")]
    authenticator_data: Vec<u8>,
    /// This attribute contains the JSON byte serialization of [`CollectedClientData`](CollectedClientData) passed to the
    /// authenticator by the client in order to generate this credential. The exact JSON serialization
    /// MUST be preserved, as the hash of the serialized client data has been computed over it.
    #[serde(with = "serde_bytes")]
    client_data_json: Vec<u8>,
}
```

**File:** api/types/src/transaction.rs (L1498-1502)
```rust
        } else if signature_len > MAX_WEBAUTHN_SIGNATURE_BYTES {
            bail!(
                "The WebAuthn signature length is greater than the maximum number of {} bytes: found {} bytes.",
                MAX_WEBAUTHN_SIGNATURE_BYTES, signature_len
            )
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L73-75)
```rust
            max_transaction_size_in_bytes: NumBytes,
            "max_transaction_size_in_bytes",
            64 * 1024
```

**File:** aptos-move/aptos-vm/src/gas.rs (L109-120)
```rust
    } else if txn_metadata.transaction_size > txn_gas_params.max_transaction_size_in_bytes {
        speculative_warn!(
            log_context,
            format!(
                "[VM] Transaction size too big {} (max {})",
                txn_metadata.transaction_size, txn_gas_params.max_transaction_size_in_bytes
            ),
        );
        return Err(VMStatus::error(
            StatusCode::EXCEEDED_MAX_TRANSACTION_SIZE,
            None,
        ));
```
