# Audit Report

## Title
Memory Exhaustion via Unbounded Delayed Field Change Set Growth Bypassing Write Operation Limits

## Summary
The `delayed_field_change_set` BTreeMap in `VMChangeSet` can grow unbounded during transaction execution, bypassing the `max_write_ops_per_transaction` limit. An attacker can create hundreds of thousands of delayed field entries by repeatedly calling aggregator v2 operations, consuming ~125 MB per transaction and causing validator memory exhaustion.

## Finding Description

The Aptos transaction execution system enforces a write operation limit to prevent resource exhaustion, but delayed field changes (aggregator v2) are explicitly excluded from this limit, creating a resource exhaustion vulnerability.

The `VMChangeSet` structure contains a `delayed_field_change_set` BTreeMap that stores all aggregator v2, snapshot, and derived value operations: [1](#0-0) 

During transaction execution, the `DelayedFieldData` accumulates delayed field changes without size constraints. Operations like `create_new_aggregator`, `snapshot`, and `derive_string_concat` each add entries to this BTreeMap: [2](#0-1) [3](#0-2) [4](#0-3) [5](#0-4) 

These operations charge minimal gas costs, allowing an attacker to create many entries: [6](#0-5) 

The critical vulnerability is in how write operations are counted. The `num_write_ops()` function explicitly excludes delayed field changes: [7](#0-6) 

The transaction limit check occurs AFTER the `VMChangeSet` is fully constructed with all delayed field entries in memory: [8](#0-7) 

The `max_write_ops_per_transaction` limit is set to 8,192 operations: [9](#0-8) 

With `max_execution_gas` of 920,000,000: [10](#0-9) 

**Attack Execution:**
1. Attacker submits transaction with 920M gas units
2. Repeatedly calls `create_aggregator`, `snapshot`, and `derive_string_concat`
3. Each operation costs ~1,102-1,838 gas, allowing ~500,000-835,000 entries
4. Each BTreeMap entry (DelayedFieldID + DelayedChange) consumes ~100-200 bytes
5. Total memory per transaction: ~75-125 MB
6. These entries bypass the 8,192 write operation limit
7. Multiple concurrent transactions multiply the impact (10 txns = 1.25 GB, 100 txns = 12.5 GB)
8. Validators experience memory pressure and performance degradation

The `MAX_DELAYED_FIELDS_PER_RESOURCE` limit of 10 only applies to delayed fields within a single resource during serialization, not to the total number of entries in the change set: [11](#0-10) 

## Impact Explanation

This qualifies as **HIGH severity** per Aptos bug bounty criteria under "Validator Node Slowdowns (High)":

- **Resource Exhaustion DoS**: Memory consumption of 125 MB per transaction, multiplying with concurrent execution to potentially gigabytes
- **Validator Performance Degradation**: Large in-memory BTreeMaps cause heap pressure, potential swap usage, and processing delays
- **Safety Limit Bypass**: Circumvents the `max_write_ops_per_transaction` limit specifically designed to prevent resource exhaustion
- **Consensus Impact**: Severe validator slowdowns can affect block production timing and network health

The vulnerability violates the security invariant that all operations must respect resource limits by allowing memory consumption far beyond what the write operation limits were designed to prevent.

## Likelihood Explanation

**High likelihood** of exploitation:

- **No Special Privileges**: Any transaction sender can exploit this
- **Simple Execution**: Just repeatedly call public aggregator v2 native functions
- **Low Cost**: Attacker only pays gas (~0.92 APT for maximum gas)
- **Difficult Detection**: Appears as legitimate aggregator v2 usage
- **Concurrent Amplification**: Multiple transactions in the execution pipeline multiply the impact
- **Production Code**: Affects all validators processing blocks with these transactions

## Recommendation

Implement one or more of the following mitigations:

1. **Include delayed field changes in write operation count**:
   - Modify `num_write_ops()` to include `delayed_field_change_set.len()`
   - This ensures delayed fields respect the existing safety limit

2. **Add separate limit for delayed field operations**:
   - Introduce `max_delayed_fields_per_transaction` gas parameter
   - Check this limit in `check_change_set()`

3. **Implement memory-proportional gas charging**:
   - Charge gas based on memory consumption, not just operation count
   - Add per-byte charges for delayed field change set growth

4. **Apply the existing TODO**: 
   The code already acknowledges this issue needs proper charges (value_serde.rs:50-53). Implement the deferred proper charging mechanism.

## Proof of Concept

```move
// PoC demonstrating memory exhaustion via delayed field operations
script {
    use aptos_framework::aggregator_v2;
    
    fun exhaust_memory(sender: &signer) {
        let i = 0;
        // Create as many aggregators and snapshots as gas allows
        while (i < 400000) {
            let agg = aggregator_v2::create_unbounded_aggregator<u64>();
            let snap = aggregator_v2::snapshot<u64>(&agg);
            // Each operation adds entry to delayed_field_change_set
            // Not counted against max_write_ops_per_transaction
            i = i + 1;
        };
        // Transaction consumes ~100+ MB memory during execution
        // Multiple concurrent transactions multiply the effect
    }
}
```

The PoC creates hundreds of thousands of delayed field entries, each consuming memory in the `delayed_field_change_set` BTreeMap, bypassing the write operation limit and causing validator memory exhaustion.

### Citations

**File:** aptos-move/aptos-vm-types/src/change_set.rs (L81-92)
```rust
pub struct VMChangeSet {
    resource_write_set: BTreeMap<StateKey, AbstractResourceWriteOp>,
    events: Vec<(ContractEvent, Option<MoveTypeLayout>)>,

    // Changes separated out from the writes, for better concurrency,
    // materialized back into resources when transaction output is computed.
    delayed_field_change_set: BTreeMap<DelayedFieldID, DelayedChange<DelayedFieldID>>,

    // TODO[agg_v1](cleanup) deprecate aggregator_v1 fields.
    aggregator_v1_write_set: BTreeMap<StateKey, WriteOp>,
    aggregator_v1_delta_set: BTreeMap<StateKey, DeltaOp>,
}
```

**File:** aptos-move/aptos-vm-types/src/change_set.rs (L856-860)
```rust
    fn num_write_ops(&self) -> usize {
        // Note: we only use resources and aggregators because they use write ops directly,
        // and deltas & events are not part of these.
        self.resource_write_set().len() + self.aggregator_v1_write_set().len()
    }
```

**File:** aptos-move/aptos-aggregator/src/delayed_field_extension.rs (L32-35)
```rust
pub struct DelayedFieldData {
    // All aggregator instances that exist in the current transaction.
    delayed_fields: BTreeMap<DelayedFieldID, DelayedChange<DelayedFieldID>>,
}
```

**File:** aptos-move/aptos-aggregator/src/delayed_field_extension.rs (L119-122)
```rust
    pub fn create_new_aggregator(&mut self, id: DelayedFieldID) {
        let aggregator = DelayedChange::Create(DelayedFieldValue::Aggregator(0));
        self.delayed_fields.insert(id, aggregator);
    }
```

**File:** aptos-move/aptos-aggregator/src/delayed_field_extension.rs (L217-219)
```rust
        let snapshot_id = resolver.generate_delayed_field_id(width);
        self.delayed_fields.insert(snapshot_id, change);
        Ok(snapshot_id)
```

**File:** aptos-move/aptos-aggregator/src/delayed_field_extension.rs (L307-309)
```rust
        let new_id = resolver.generate_delayed_field_id(width);
        self.delayed_fields.insert(new_id, change);
        Ok(new_id)
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/aptos_framework.rs (L335-348)
```rust
        [aggregator_v2_create_aggregator_base: InternalGas, {RELEASE_V1_9_SKIPPED.. => "aggregator_v2.create_aggregator.base"}, 1838],
        [aggregator_v2_try_add_base: InternalGas, {RELEASE_V1_9_SKIPPED.. => "aggregator_v2.try_add.base"}, 1102],
        [aggregator_v2_try_sub_base: InternalGas, {RELEASE_V1_9_SKIPPED.. => "aggregator_v2.try_sub.base"}, 1102],
        [aggregator_v2_is_at_least_base: InternalGas, {RELEASE_V1_14.. => "aggregator_v2.is_at_least.base"}, 500],

        [aggregator_v2_read_base: InternalGas, {RELEASE_V1_9_SKIPPED.. => "aggregator_v2.read.base"}, 2205],
        [aggregator_v2_snapshot_base: InternalGas, {RELEASE_V1_9_SKIPPED.. => "aggregator_v2.snapshot.base"}, 1102],

        [aggregator_v2_create_snapshot_base: InternalGas, {RELEASE_V1_8.. => "aggregator_v2.create_snapshot.base"}, 1102],
        [aggregator_v2_create_snapshot_per_byte: InternalGasPerByte, { RELEASE_V1_9_SKIPPED.. =>"aggregator_v2.create_snapshot.per_byte" }, 3],
        [aggregator_v2_copy_snapshot_base: InternalGas, {RELEASE_V1_8.. => "aggregator_v2.copy_snapshot.base"}, 1102],
        [aggregator_v2_read_snapshot_base: InternalGas, {RELEASE_V1_8.. => "aggregator_v2.read_snapshot.base"}, 2205],
        [aggregator_v2_string_concat_base: InternalGas, {RELEASE_V1_8.. => "aggregator_v2.string_concat.base"}, 1102],
        [aggregator_v2_string_concat_per_byte: InternalGasPerByte, { RELEASE_V1_9_SKIPPED.. =>"aggregator_v2.string_concat.per_byte" }, 3],
```

**File:** aptos-move/aptos-vm/src/move_vm_ext/session/user_transaction_sessions/session_change_sets.rs (L24-35)
```rust
    pub(crate) fn new(
        change_set: VMChangeSet,
        module_write_set: ModuleWriteSet,
        change_set_configs: &ChangeSetConfigs,
    ) -> Result<Self, VMStatus> {
        let user_session_change_set = Self {
            change_set,
            module_write_set,
        };
        change_set_configs.check_change_set(&user_session_change_set)?;
        Ok(user_session_change_set)
    }
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L174-177)
```rust
            max_write_ops_per_transaction: NumSlots,
            { 11.. => "max_write_ops_per_transaction" },
            8192,
        ],
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L211-214)
```rust
            max_execution_gas: InternalGas,
            { 7.. => "max_execution_gas" },
            920_000_000, // 92ms of execution at 10k gas per ms
        ],
```

**File:** third_party/move/move-vm/types/src/value_serde.rs (L50-65)
```rust
    // Temporarily limit the number of delayed fields per resource, until proper charges are
    // implemented.
    // TODO[agg_v2](clean):
    //   Propagate up, so this value is controlled by the gas schedule version.
    const MAX_DELAYED_FIELDS_PER_RESOURCE: usize = 10;

    /// Increments the delayed fields count, and checks if there are too many of them. If so, an
    /// error is returned.
    pub(crate) fn inc_and_check_delayed_fields_count(&self) -> PartialVMResult<()> {
        *self.delayed_fields_count.borrow_mut() += 1;
        if *self.delayed_fields_count.borrow() > Self::MAX_DELAYED_FIELDS_PER_RESOURCE {
            return Err(PartialVMError::new(StatusCode::TOO_MANY_DELAYED_FIELDS)
                .with_message("Too many Delayed fields in a single resource.".to_string()));
        }
        Ok(())
    }
```
