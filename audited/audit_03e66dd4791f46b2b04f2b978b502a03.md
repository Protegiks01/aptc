# Audit Report

## Title
Storage Service Request Handler Resource Exhaustion via Pre-Validation Task Spawning

## Summary
The storage service server spawns blocking tasks for ALL incoming requests before validating them, allowing malicious public network peers to exhaust the blocking thread pool by sending up to 500 invalid requests per peer before being ignored. This creates a critical window for resource exhaustion attacks that can degrade node performance and disrupt state synchronization.

## Finding Description

The vulnerability exists in the request handling architecture where blocking tasks are spawned **before** request validation occurs. [1](#0-0) 

The critical flow is:
1. Network request arrives
2. A blocking task is immediately spawned via `runtime.spawn_blocking()` 
3. Validation only occurs **inside** the spawned blocking task
4. Invalid request tracking and peer ignoring happens after validation fails [2](#0-1) 

Public network peers can send up to 500 invalid requests (the default `max_invalid_requests_per_peer` threshold) before being ignored: [3](#0-2) 

The blocking thread pool has a hard limit of 64 threads: [4](#0-3) 

**Attack Scenario:**
1. Attacker controls N malicious public network peers (e.g., 100 peers from different IPs)
2. Each peer rapidly sends 500 invalid storage service requests
3. Total: 100 Ã— 500 = 50,000 blocking tasks spawned
4. With only 64 blocking threads available, this creates a massive queue
5. Legitimate storage service requests from honest peers are delayed or rejected
6. State synchronization is disrupted across the network

The existing network-level byte rate limiting (100 KiB/s per IP) does not prevent this attack because:
- Invalid requests can be small in size
- Multiple IPs can be used
- Rate limiting is byte-based, not request-count based [5](#0-4) 

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos bug bounty criteria:
- **Validator node slowdowns**: The blocking thread pool exhaustion directly causes processing delays for all storage service operations
- **Significant protocol violations**: Disrupts the Resource Limits invariant stating "All operations must respect gas, storage, and computational limits"

The impact extends to:
- State synchronization failure for fullnodes trying to catch up to the chain
- Degraded performance for validators serving storage requests
- Potential cascade effects if enough nodes are affected simultaneously

This is NOT a simple network-level DoS (which is out of scope) but rather an **application-level resource exhaustion vulnerability** caused by architectural flaws in request handling.

## Likelihood Explanation

**Likelihood: High**

Attack requirements:
- Multiple public network peers (easily obtainable via cloud providers)
- Ability to send RPC requests (standard network capability)
- No special privileges required

The attack is:
- Easy to execute (just send invalid requests)
- Hard to mitigate in real-time (peers only ignored after 500 requests)
- Amplifiable (multiple peers multiply the effect)
- Low cost for attacker (requests are small)

The 500-request threshold is excessively high and provides a wide attack window before mitigation kicks in.

## Recommendation

**Immediate Fix:**
1. Move validation **before** task spawning to reject invalid requests early
2. Reduce `max_invalid_requests_per_peer` to a much lower value (e.g., 10-20)
3. Implement request-count rate limiting in addition to byte-count limiting

**Architectural Fix:**
```rust
// In lib.rs start() method, validate BEFORE spawning blocking task:
while let Some(network_request) = self.network_requests.next().await {
    // Validate request synchronously before spawning expensive task
    if let Err(error) = self.request_moderator.validate_request(
        &network_request.peer_network_id,
        &network_request.storage_service_request,
    ) {
        // Reject immediately without spawning task
        network_request.response_sender.send(Err(
            StorageServiceError::InvalidRequest(error.to_string())
        ));
        continue;
    }
    
    // Only spawn blocking task for validated requests
    self.runtime.spawn_blocking(move || {
        Handler::new(...)
            .process_request_and_respond(...)
    });
}
```

**Configuration Fix:**
```rust
// In state_sync_config.rs
max_invalid_requests_per_peer: 20,  // Reduced from 500
```

## Proof of Concept

```rust
// PoC: Demonstrate resource exhaustion via invalid requests
use aptos_config::config::StateSyncConfig;
use aptos_storage_service_types::requests::*;

#[tokio::test]
async fn test_request_flood_exhausts_thread_pool() {
    // Setup storage service server
    let mut config = StateSyncConfig::default();
    let server = StorageServiceServer::new(...);
    
    // Simulate 100 malicious public network peers
    let num_malicious_peers = 100;
    let requests_per_peer = 500; // Default threshold
    
    let mut handles = vec![];
    for peer_id in 0..num_malicious_peers {
        let handle = tokio::spawn(async move {
            // Each peer sends invalid requests rapidly
            for _ in 0..requests_per_peer {
                // Send invalid request (requesting non-existent version)
                let request = StorageServiceRequest {
                    data_request: DataRequest::GetTransactionsWithProof(
                        TransactionsWithProofRequest {
                            start_version: u64::MAX,
                            end_version: u64::MAX,
                            proof_version: u64::MAX,
                        }
                    ),
                    use_compression: false,
                };
                // Send to server (will spawn blocking task)
                send_request_to_server(peer_id, request).await;
            }
        });
        handles.push(handle);
    }
    
    // Wait for flood to complete
    for handle in handles {
        handle.await.unwrap();
    }
    
    // Verify: legitimate requests are now severely delayed
    let start = Instant::now();
    let response = send_legitimate_request().await;
    let latency = start.elapsed();
    
    // Assert degraded performance
    assert!(latency > Duration::from_secs(5), 
        "Thread pool exhaustion should cause significant delays");
}
```

## Notes

This vulnerability demonstrates a fundamental architectural flaw where expensive resource allocation (task spawning) occurs before cheap validation checks. The excessively high threshold of 500 invalid requests compounds the problem by providing attackers a large attack window before mitigation. The issue specifically affects **public network peers** as the code explicitly only ignores peers on public networks, creating an inconsistent security posture where private network peers (validators, VFNs) can send unlimited invalid requests without consequence.

### Citations

**File:** state-sync/storage-service/server/src/lib.rs (L389-419)
```rust
        while let Some(network_request) = self.network_requests.next().await {
            // All handler methods are currently CPU-bound and synchronous
            // I/O-bound, so we want to spawn on the blocking thread pool to
            // avoid starving other async tasks on the same runtime.
            let storage = self.storage.clone();
            let config = self.storage_service_config;
            let cached_storage_server_summary = self.cached_storage_server_summary.clone();
            let optimistic_fetches = self.optimistic_fetches.clone();
            let subscriptions = self.subscriptions.clone();
            let lru_response_cache = self.lru_response_cache.clone();
            let request_moderator = self.request_moderator.clone();
            let time_service = self.time_service.clone();
            self.runtime.spawn_blocking(move || {
                Handler::new(
                    cached_storage_server_summary,
                    optimistic_fetches,
                    lru_response_cache,
                    request_moderator,
                    storage,
                    subscriptions,
                    time_service,
                )
                .process_request_and_respond(
                    config,
                    network_request.peer_network_id,
                    network_request.protocol_id,
                    network_request.storage_service_request,
                    network_request.response_sender,
                );
            });
        }
```

**File:** state-sync/storage-service/server/src/moderator.rs (L50-69)
```rust
    pub fn increment_invalid_request_count(&mut self, peer_network_id: &PeerNetworkId) {
        // Increment the invalid request count
        self.invalid_request_count += 1;

        // If the peer is a PFN and has sent too many invalid requests, start ignoring it
        if self.ignore_start_time.is_none()
            && peer_network_id.network_id().is_public_network()
            && self.invalid_request_count >= self.max_invalid_requests
        {
            // TODO: at some point we'll want to terminate the connection entirely

            // Start ignoring the peer
            self.ignore_start_time = Some(self.time_service.now());

            // Log the fact that we're now ignoring the peer
            warn!(LogSchema::new(LogEntry::RequestModeratorIgnoredPeer)
                .peer_network_id(peer_network_id)
                .message("Ignoring peer due to too many invalid requests!"));
        }
    }
```

**File:** config/src/config/state_sync_config.rs (L201-201)
```rust
            max_invalid_requests_per_peer: 500,
```

**File:** crates/aptos-runtimes/src/lib.rs (L27-50)
```rust
    const MAX_BLOCKING_THREADS: usize = 64;

    // Verify the given name has an appropriate length
    if thread_name.len() > MAX_THREAD_NAME_LENGTH {
        panic!(
            "The given runtime thread name is too long! Max length: {}, given name: {}",
            MAX_THREAD_NAME_LENGTH, thread_name
        );
    }

    // Create the runtime builder
    let atomic_id = AtomicUsize::new(0);
    let thread_name_clone = thread_name.clone();
    let mut builder = Builder::new_multi_thread();
    builder
        .thread_name_fn(move || {
            let id = atomic_id.fetch_add(1, Ordering::SeqCst);
            format!("{}-{}", thread_name_clone, id)
        })
        .on_thread_start(on_thread_start)
        .disable_lifo_slot()
        // Limit concurrent blocking tasks from spawn_blocking(), in case, for example, too many
        // Rest API calls overwhelm the node.
        .max_blocking_threads(MAX_BLOCKING_THREADS)
```

**File:** config/src/config/network_config.rs (L368-387)
```rust
pub struct RateLimitConfig {
    /// Maximum number of bytes/s for an IP
    pub ip_byte_bucket_rate: usize,
    /// Maximum burst of bytes for an IP
    pub ip_byte_bucket_size: usize,
    /// Initial amount of tokens initially in the bucket
    pub initial_bucket_fill_percentage: u8,
    /// Allow for disabling the throttles
    pub enabled: bool,
}

impl Default for RateLimitConfig {
    fn default() -> Self {
        Self {
            ip_byte_bucket_rate: IP_BYTE_BUCKET_RATE,
            ip_byte_bucket_size: IP_BYTE_BUCKET_SIZE,
            initial_bucket_fill_percentage: 25,
            enabled: true,
        }
    }
```
