# Audit Report

## Title
Missing Runtime Validation in Sharded Block Executor Causes Panic on Inconsistent Shard Output

## Summary
The `ShardedBlockExecutor::execute_block()` function lacks runtime validation of the `sharded_output` structure returned from executor clients. While an assertion validates the input transaction count matches expected shards, no checks verify that the output has consistent structure across shards (same number of rounds) or matches the expected shard count. This missing validation can cause index out-of-bounds panics if executor clients return malformed data.

## Finding Description

The vulnerability exists in the sharded block execution aggregation logic. The function assumes structural invariants about `sharded_output` without runtime validation: [1](#0-0) 

This assertion only validates the **input** (`transactions.num_shards()`), not the output structure.

After execution, the code assumes `sharded_output[0]` exists and all shards have the same number of rounds: [2](#0-1) 

The index calculation `round * num_executor_shards + shard_id` at line 104 can exceed the `ordered_results` bounds if shards return different numbers of rounds. For example, if `num_executor_shards = 4`, `num_rounds = 2` (from shard 0), but shard 1 returns 3 rounds, then accessing round 2 of shard 1 would calculate index `2 * 4 + 1 = 9`, exceeding the vector size of 8.

The same pattern appears in the aggregation service: [3](#0-2) 

And in the flatten utility: [4](#0-3) 

Test validation confirms the invariant is expected but not enforced at runtime: [5](#0-4) 

## Impact Explanation

**Severity: Medium** - This constitutes a DoS vulnerability affecting validator node availability. If triggered, it causes immediate panic and node crash, impacting liveness. However, it requires a bug in internal components (partitioner or executor client) rather than direct external exploitation. The impact aligns with "state inconsistencies requiring intervention" under Medium severity criteria.

## Likelihood Explanation

**Likelihood: Low** - The vulnerability requires one of these scenarios:

1. **Bug in partitioner**: The `PartitionerV2` has a bug producing inconsistent `SubBlocksForShard` with different `num_sub_blocks()` values across shards
2. **Bug in executor client**: `LocalExecutorClient` or `RemoteExecutorClient` returns malformed output structure
3. **Malicious executor client**: A custom `ExecutorClient` implementation deliberately returns inconsistent data (requires code-level access)

The partitioner is designed to produce consistent output by construction: [6](#0-5) 

Each shard iterates through its `SubBlocksForShard.into_sub_blocks()`, so the output length matches input by design. External attackers cannot directly inject malformed `PartitionedTransactions` as it's created internally by the validator.

## Recommendation

Add runtime validation after receiving `sharded_output` from the executor client:

```rust
pub fn execute_block(
    &self,
    state_view: Arc<S>,
    transactions: PartitionedTransactions,
    concurrency_level_per_shard: usize,
    onchain_config: BlockExecutorConfigFromOnchain,
) -> Result<Vec<TransactionOutput>, VMStatus> {
    let _timer = SHARDED_BLOCK_EXECUTION_SECONDS.start_timer();
    let num_executor_shards = self.executor_client.num_shards();
    NUM_EXECUTOR_SHARDS.set(num_executor_shards as i64);
    assert_eq!(
        num_executor_shards,
        transactions.num_shards(),
        "Block must be partitioned into {} sub-blocks",
        num_executor_shards
    );
    
    let (sharded_output, global_output) = self
        .executor_client
        .execute_block(/* ... */)?.into_inner();
    
    // **NEW VALIDATION**
    // Validate sharded_output structure
    if sharded_output.is_empty() {
        return Err(VMStatus::error(
            StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR,
            Some("Sharded output is empty".to_string())
        ));
    }
    
    if sharded_output.len() != num_executor_shards {
        return Err(VMStatus::error(
            StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR,
            Some(format!(
                "Sharded output has {} shards, expected {}",
                sharded_output.len(),
                num_executor_shards
            ))
        ));
    }
    
    let num_rounds = sharded_output[0].len();
    for (shard_id, shard_result) in sharded_output.iter().enumerate() {
        if shard_result.len() != num_rounds {
            return Err(VMStatus::error(
                StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR,
                Some(format!(
                    "Shard {} has {} rounds, expected {}",
                    shard_id,
                    shard_result.len(),
                    num_rounds
                ))
            ));
        }
    }
    
    // ... rest of function
}
```

Apply similar validation in `aggregate_and_update_total_supply()`.

## Proof of Concept

```rust
#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    #[should_panic(expected = "index out of bounds")]
    fn test_inconsistent_rounds_causes_panic() {
        // Create a mock executor client that returns inconsistent rounds
        struct MaliciousExecutorClient;
        
        impl<S: StateView + Sync + Send + 'static> ExecutorClient<S> for MaliciousExecutorClient {
            fn num_shards(&self) -> usize { 2 }
            
            fn execute_block(
                &self,
                _: Arc<S>,
                _: PartitionedTransactions,
                _: usize,
                _: BlockExecutorConfigFromOnchain,
            ) -> Result<ShardedExecutionOutput, VMStatus> {
                // Shard 0: 2 rounds, Shard 1: 3 rounds (inconsistent!)
                let sharded_output = vec![
                    vec![vec![], vec![]],      // 2 rounds
                    vec![vec![], vec![], vec![]], // 3 rounds (extra!)
                ];
                Ok(ShardedExecutionOutput::new(sharded_output, vec![]))
            }
            
            fn shutdown(&mut self) {}
        }
        
        let executor = ShardedBlockExecutor::new(MaliciousExecutorClient);
        
        // Create matching partitioned transactions (2 shards)
        let transactions = PartitionedTransactions::new(
            vec![
                SubBlocksForShard::empty(0),
                SubBlocksForShard::empty(1),
            ],
            vec![]
        );
        
        // This will panic when aggregating results at line 104
        // Index calculation: round=2, shard_id=1 -> 2*2+1=5, but vector size is 2*2=4
        let _ = executor.execute_block(
            Arc::new(mock_state_view()),
            transactions,
            1,
            BlockExecutorConfigFromOnchain::default(),
        );
    }
}
```

## Notes

While this is a valid robustness issue, it has limited exploitability as it requires internal bugs rather than direct external attacks. The partitioner and executor clients are trusted components run by validators. However, defensive validation is a best practice to catch unexpected conditions and prevent cascading failures. The missing checks violate defense-in-depth principles and could mask bugs during development or cause unexpected crashes in production under rare conditions.

### Citations

**File:** aptos-move/aptos-vm/src/sharded_block_executor/mod.rs (L80-86)
```rust
        assert_eq!(
            num_executor_shards,
            transactions.num_shards(),
            "Block must be partitioned into {} sub-blocks",
            num_executor_shards
        );
        let (sharded_output, global_output) = self
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/mod.rs (L98-106)
```rust
        let num_rounds = sharded_output[0].len();
        let mut aggregated_results = vec![];
        let mut ordered_results = vec![vec![]; num_executor_shards * num_rounds];
        // Append the output from individual shards in the round order
        for (shard_id, results_from_shard) in sharded_output.into_iter().enumerate() {
            for (round, result) in results_from_shard.into_iter().enumerate() {
                ordered_results[round * num_executor_shards + shard_id] = result;
            }
        }
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/sharded_aggregator_service.rs (L174-175)
```rust
    let num_shards = sharded_output.len();
    let num_rounds = sharded_output[0].len();
```

**File:** types/src/block_executor/partitioner.rs (L381-385)
```rust
        let num_rounds = block[0].num_sub_blocks();
        let mut ordered_blocks = vec![SubBlock::empty(); num_shards * num_rounds];
        for (shard_id, sub_blocks) in block.into_iter().enumerate() {
            for (round, sub_block) in sub_blocks.into_sub_blocks().into_iter().enumerate() {
                ordered_blocks[round * num_shards + shard_id] = sub_block;
```

**File:** execution/block-partitioner/src/test_utils.rs (L165-172)
```rust
    let num_rounds = output
        .sharded_txns()
        .first()
        .map(|sbs| sbs.sub_blocks.len())
        .unwrap_or(0);
    for sub_block_list in output.sharded_txns().iter().take(num_shards).skip(1) {
        assert_eq!(num_rounds, sub_block_list.sub_blocks.len());
    }
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/sharded_executor_service.rs (L185-213)
```rust
    fn execute_block(
        &self,
        transactions: SubBlocksForShard<AnalyzedTransaction>,
        state_view: &S,
        config: BlockExecutorConfig,
    ) -> Result<Vec<Vec<TransactionOutput>>, VMStatus> {
        let mut result = vec![];
        for (round, sub_block) in transactions.into_sub_blocks().into_iter().enumerate() {
            let _timer = SHARDED_BLOCK_EXECUTION_BY_ROUNDS_SECONDS
                .timer_with(&[&self.shard_id.to_string(), &round.to_string()]);
            SHARDED_BLOCK_EXECUTOR_TXN_COUNT.observe_with(
                &[&self.shard_id.to_string(), &round.to_string()],
                sub_block.transactions.len() as f64,
            );
            info!(
                "executing sub block for shard {} and round {}, number of txns {}",
                self.shard_id,
                round,
                sub_block.transactions.len()
            );
            result.push(self.execute_sub_block(sub_block, round, state_view, config.clone())?);
            trace!(
                "Finished executing sub block for shard {} and round {}",
                self.shard_id,
                round
            );
        }
        Ok(result)
    }
```
