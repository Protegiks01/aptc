# Audit Report

## Title
Block Gas Limit Can Be Exceeded by Full Transaction Amount Causing Network Resource Exhaustion

## Summary
The block executor checks gas limits AFTER accumulating each transaction's gas consumption rather than before, allowing blocks to exceed the block gas limit by up to one full transaction's gas amount (2,000,000 gas units in production). With typical block gas limits around 80,000-100,000, this enables blocks to be 20-25x larger than intended, causing validator node slowdowns and network resource exhaustion.

## Finding Description

The `BlockOutput` structure wraps transaction execution results without any final gas limit validation. During block execution, the gas limit enforcement happens in a timing-sensitive order that allows limit violations: [1](#0-0) 

The critical flaw is at this commit point:
1. Line 356-360: Transaction N's gas is accumulated into the total
2. Line 362-363: The `should_end_block_parallel()` check happens AFTER accumulation
3. Line 369: If limit exceeded, mark as `SkipRest` (but transaction N is already counted)
4. Line 376: Transaction N is committed with its gas included

The gas limit check implementation confirms this allows exceeding the limit: [2](#0-1) 

The check at line 132 uses `>=` comparison, meaning it returns true when the accumulated gas equals OR exceeds the limit. However, this check occurs AFTER the transaction's gas has been added to the accumulator.

The `BlockOutput::new()` constructor performs no validation: [3](#0-2) 

There is no gas limit validation before wrapping transaction outputs in `BlockOutput`.

**Attack Scenario:**
1. Block has accumulated 99,999 gas with limit of 100,000
2. Transaction with 2,000,000 gas is executed
3. Gas accumulates to 2,099,999 (line 356-360 of txn_last_input_output.rs)
4. Check: 2,099,999 >= 100,000? Yes, skip remaining transactions
5. Block is committed with 2,099,999 gas (21x over limit)
6. `BlockOutput::new()` wraps this without validation
7. All validators must process this oversized block

The production transaction gas limit confirms the magnitude: [4](#0-3) 

With `MAX_GAS_AMOUNT = 2,000,000` in production and typical block gas limits around 80,000-100,000 based on example configurations, blocks can exceed their intended limit by 20-25x.

Example block gas limit configuration: [5](#0-4) 

A test explicitly demonstrates this behavior where a transaction consuming 10x the block gas limit is included: [6](#0-5) 

Lines 169-171 show transaction 0 (with 10 gas) is NOT skipped despite the block limit being 1, proving the transaction that exceeds the limit is committed.

**Invariant Violation:**
This breaks the documented invariant: "Resource Limits: All operations must respect gas, storage, and computational limits." The block gas limit is a resource limit that is systematically violated by up to 2,000,000 gas units.

## Impact Explanation

This qualifies as **HIGH Severity** under Aptos Bug Bounty criteria due to "Validator node slowdowns."

**Concrete Impacts:**

1. **Validator Node Slowdowns**: All validators must execute and validate blocks that are 20-25x larger than intended, causing:
   - Increased CPU/memory consumption during block execution
   - Slower block processing times
   - Degraded network throughput

2. **Network Resource Exhaustion**: 
   - Increased storage requirements (blocks permanently stored)
   - Higher network bandwidth consumption for block propagation
   - Potential cascade effects if multiple consecutive blocks exceed limits

3. **Denial of Service Vector**: While individual transactions are rate-limited by normal transaction throughput, sustained submission of high-gas transactions can consistently create oversized blocks, degrading network performance.

4. **Resource-Constrained Validator Failures**: Validators with tight resource constraints may experience crashes or severe performance degradation when processing blocks that are 25x their expected size.

The vulnerability affects ALL validator nodes since they must all execute the same block proposals from consensus. Unlike some attacks that only affect block proposers, this impacts the entire network's execution layer.

## Likelihood Explanation

**Likelihood: HIGH**

This vulnerability has high likelihood because:

1. **No Special Access Required**: Any user can submit transactions with high gas amounts (up to 2,000,000) through normal transaction submission
2. **Natural Occurrence**: High-gas transactions occur organically in normal network operation (complex DeFi operations, governance proposals, etc.)
3. **Inevitable Triggering**: Whenever a high-gas transaction is included near a block's gas limit, the overage occurs automatically
4. **No Coordination Needed**: Unlike attacks requiring validator collusion, any single transaction can trigger this issue
5. **Already Observed**: The test suite explicitly validates this behavior, confirming it occurs in practice

The attack complexity is minimal - simply submit a transaction with high gas usage when blocks are near their gas limits. This happens naturally during periods of high network activity.

## Recommendation

Implement validation BEFORE accumulating transaction gas, or add a final check before creating `BlockOutput`:

**Option 1: Pre-Accumulation Check (Preferred)**
Modify the commit flow to check if adding the transaction would exceed the limit BEFORE accumulating:

```rust
// In txn_last_input_output.rs::commit()
let fee_statement = output_before_guard.fee_statement();

// NEW: Check if adding this transaction would exceed limit BEFORE accumulating
let would_exceed_limit = if txn_idx < num_txns - 1 {
    block_limit_processor.would_exceed_limit_after_accumulation(
        fee_statement,
        maybe_read_write_summary.as_ref(),
        output_wrapper.maybe_approx_output_size,
    )
} else {
    false
};

if would_exceed_limit && !skips_rest {
    // Skip this transaction instead of including it
    output_wrapper.output_status_kind = OutputStatusKind::SkipRest;
    skips_rest = true;
    must_create_epilogue_txn = !output_before_guard.has_new_epoch_event();
    return Ok(()); // Don't commit this transaction
}

// For committed txns, calculate the accumulated gas costs.
block_limit_processor.accumulate_fee_statement(
    fee_statement,
    maybe_read_write_summary,
    output_wrapper.maybe_approx_output_size,
);
```

**Option 2: Post-Execution Validation**
Add validation in `BlockOutput::new()` to reject blocks exceeding limits:

```rust
pub fn new(transaction_outputs: Vec<Output>, block_epilogue_txn: Option<T>) -> Result<Self, BlockGasLimitError> {
    // Validate total gas doesn't exceed limits if limit checking is enabled
    validate_block_gas_limit(&transaction_outputs)?;
    
    Ok(Self {
        transaction_outputs,
        block_epilogue_txn,
    })
}
```

**Option 3: Tighter Per-Transaction Limit**
Cap individual transaction gas to ensure overages remain bounded (e.g., max transaction gas = 10% of block gas limit).

## Proof of Concept

The existing test demonstrates this vulnerability: [7](#0-6) 

This test explicitly shows:
- Block gas limit: 1
- Transaction gas: 10 (per transaction)
- Transaction 0 is executed and NOT skipped (line 170)
- Final block contains transaction 0 with gas = 10, exceeding limit by 10x

To demonstrate the production-scale impact, modify this test:

```rust
#[test]
fn test_block_gas_limit_production_scale_overage() {
    // Simulate production scenario:
    // - Block gas limit: 80,000 (typical)
    // - Transaction gas: 2,000,000 (max allowed)
    let high_gas_behavior = MockIncarnation::new(vec![], vec![], vec![], vec![], 2_000_000);
    let t_high_gas = MockTransaction::from_behavior(high_gas_behavior);
    let transactions = vec![t_high_gas];

    let block_executor = BlockExecutor::new(
        BlockExecutorConfig::new_maybe_block_limit(num_cpus::get(), Some(80_000)),
        // ... executor setup
    );
    
    let result = block_executor.execute_transactions_sequential(/* ... */).unwrap();
    let (output, _) = result.into_inner();
    
    // Vulnerability: Transaction with 2M gas is included despite 80K limit
    assert!(!output[0].skipped); // Transaction IS included
    // Block now has 2,000,000 gas vs 80,000 limit = 25x overage
}
```

This PoC proves blocks can exceed their gas limit by up to 25x in production configurations, causing the network resource exhaustion described in the impact section.

## Notes

- The block gas limit is configured on-chain via `OnChainExecutionConfig`, ensuring all validators use the same limit (preventing consensus divergence)
- While small overages might be acceptable by design, the unbounded nature allowing 25x overages is the security vulnerability
- This affects both parallel and sequential execution paths
- The `BlockGasLimitProcessor` tracks limits but cannot prevent the final transaction from exceeding them
- Similar logic applies to `block_output_limit` for approximate output size limits

### Citations

**File:** aptos-move/block-executor/src/txn_last_input_output.rs (L355-372)
```rust
        // For committed txns, calculate the accumulated gas costs.
        block_limit_processor.accumulate_fee_statement(
            fee_statement,
            maybe_read_write_summary,
            output_wrapper.maybe_approx_output_size,
        );

        if txn_idx < num_txns - 1
            && block_limit_processor.should_end_block_parallel()
            && !skips_rest
        {
            if output_wrapper.output_status_kind == OutputStatusKind::Success {
                must_create_epilogue_txn |= !output_before_guard.has_new_epoch_event();
                drop(output_before_guard);
                output_wrapper.output_status_kind = OutputStatusKind::SkipRest;
            }
            skips_rest = true;
        }
```

**File:** aptos-move/block-executor/src/limit_processor.rs (L127-140)
```rust
    fn should_end_block(&mut self, mode: &str) -> bool {
        if let Some(per_block_gas_limit) = self.block_gas_limit() {
            // When the accumulated block gas of the committed txns exceeds
            // PER_BLOCK_GAS_LIMIT, early halt BlockSTM.
            let accumulated_block_gas = self.get_effective_accumulated_block_gas();
            if accumulated_block_gas >= per_block_gas_limit {
                counters::EXCEED_PER_BLOCK_GAS_LIMIT_COUNT.inc_with(&[mode]);
                info!(
                    "[BlockSTM]: execution ({}) early halted due to \
                    accumulated_block_gas {} >= PER_BLOCK_GAS_LIMIT {}",
                    mode, accumulated_block_gas, per_block_gas_limit,
                );
                return true;
            }
```

**File:** types/src/transaction/block_output.rs (L24-29)
```rust
    pub fn new(transaction_outputs: Vec<Output>, block_epilogue_txn: Option<T>) -> Self {
        Self {
            transaction_outputs,
            block_epilogue_txn,
        }
    }
```

**File:** config/global-constants/src/lib.rs (L28-31)
```rust
#[cfg(any(test, feature = "testing"))]
pub const MAX_GAS_AMOUNT: u64 = 100_000_000;
#[cfg(not(any(test, feature = "testing")))]
pub const MAX_GAS_AMOUNT: u64 = 2_000_000;
```

**File:** aptos-move/aptos-release-builder/data/example-release-with-randomness-framework/output/2-execution-config.move (L11-12)
```text
//         block_gas_limit_type: ComplexLimitV1 {
//             effective_block_gas_limit: 80001,
```

**File:** aptos-move/block-executor/src/unit_tests/mod.rs (L124-192)
```rust
fn test_block_epilogue_block_gas_limit_reached() {
    let behaivor = MockIncarnation::new(vec![], vec![], vec![], vec![], 10);
    let t_0 = MockTransaction::from_behavior(behaivor.clone());
    let t_1 = MockTransaction::from_behavior(behaivor);
    let transactions = vec![t_0, t_1];

    let executor_thread_pool = Arc::new(
        rayon::ThreadPoolBuilder::new()
            .num_threads(num_cpus::get())
            .build()
            .unwrap(),
    );
    let block_executor = BlockExecutor::<
        MockTransaction<KeyType<u32>, MockEvent>,
        MockTask<KeyType<u32>, MockEvent>,
        MockStateView<KeyType<u32>>,
        NoOpTransactionCommitHook<usize>,
        DefaultTxnProvider<MockTransaction<KeyType<u32>, MockEvent>, AuxiliaryInfo>,
        AuxiliaryInfo,
    >::new(
        BlockExecutorConfig::new_maybe_block_limit(num_cpus::get(), Some(1)),
        executor_thread_pool,
        None,
    );
    let data_view = MockStateView::empty();

    let aux_info = vec![
        AuxiliaryInfo::auxiliary_info_at_txn_index(0),
        AuxiliaryInfo::auxiliary_info_at_txn_index(1),
    ];

    let txn_provider = DefaultTxnProvider::new(transactions, aux_info);
    {
        let mut guard = AptosModuleCacheManagerGuard::none();
        let result = block_executor
            .execute_transactions_sequential(
                &txn_provider,
                &data_view,
                &TransactionSliceMetadata::block_from_u64(0, 1),
                &mut guard,
                false,
            )
            .unwrap();
        let (output, block_epilogue_txn) = result.into_inner();
        assert!(block_epilogue_txn.is_some());
        assert_eq!(output.len(), 3);
        assert!(!output[0].skipped);
        assert!(output[1].skipped);
        assert!(!output[2].skipped);
    }

    {
        let mut guard = AptosModuleCacheManagerGuard::none();
        let result = block_executor
            .execute_transactions_parallel(
                &txn_provider,
                &data_view,
                &TransactionSliceMetadata::block_from_u64(0, 1),
                &mut guard,
            )
            .unwrap();
        let (output, block_epilogue_txn) = result.into_inner();
        assert!(block_epilogue_txn.is_some());
        assert_eq!(output.len(), 3);
        assert!(!output[0].skipped);
        assert!(output[1].skipped);
        assert!(!output[2].skipped);
    }
}
```
