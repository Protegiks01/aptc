# Audit Report

## Title
Missing PeerId-to-PublicKey Cryptographic Binding Validation in Seed Peer Configuration

## Summary
The `build_seed_peer()` function accepts arbitrary PeerId and x25519 PublicKey pairs without validating their cryptographic relationship. This allows mismatched identity mappings in seed peer configurations, enabling peer impersonation attacks when configurations are compromised or contain errors.

## Finding Description

The function `build_seed_peer()` creates seed peer entries by accepting a PeerId (account address) and an x25519 public key as separate parameters without validating their cryptographic binding. [1](#0-0) 

In Aptos networking, PeerId is a type alias for AccountAddress and should be cryptographically derived from the x25519 network public key for non-validator nodes: [2](#0-1) 

The canonical derivation function `from_identity_public_key()` exists and is used throughout the codebase: [3](#0-2) 

However, `build_seed_peer()` never calls this validation. The `verify_seeds()` function only checks for address validity and key presence, not cryptographic binding: [4](#0-3) 

During Noise handshake authentication, trusted peers (including seeds) bypass PeerId-to-PublicKey validation: [5](#0-4) 

This allows the following attack: If a seed peer is configured with PeerId A mapped to PublicKey B (where B does not cryptographically derive to A), a malicious node presenting PublicKey B will be authenticated and identified as PeerId A, achieving identity impersonation.

**Attack Path:**
1. Attacker compromises configuration distribution (supply chain attack) or exploits configuration management vulnerabilities
2. Injects malicious seed peer entry: PeerId = LegitimateValidator, PublicKey = AttackerControlledKey  
3. Victim node loads this configuration
4. Attacker's node connects presenting AttackerControlledKey
5. Victim accepts connection (key in trusted set) and identifies peer as LegitimateValidator
6. Attacker performs eclipse attack, feeds false blockchain data, or manipulates consensus information

## Impact Explanation

This qualifies as **High Severity** under Aptos bug bounty criteria due to:

- **Significant Protocol Violation**: Breaking the cryptographic identity binding that underpins network security
- **Peer Impersonation**: Allows attackers to masquerade as legitimate validators or seed nodes
- **Eclipse Attack Enablement**: Compromised nodes can be isolated from the honest network
- **Consensus Data Manipulation**: False block/transaction data can be fed to eclipsed nodes

The impact is contained to nodes with compromised configurations, but the lack of validation means:
- No defense-in-depth against configuration errors
- Configuration management systems become single points of failure
- Human errors can directly lead to security compromises

## Likelihood Explanation

**Moderate to High Likelihood** depending on deployment:

**Factors Increasing Likelihood:**
- Configuration management is a common attack vector
- Supply chain attacks on configuration distribution are realistic
- Human error in manual configuration is inevitable at scale
- No runtime detection of misconfiguration exists

**Factors Decreasing Likelihood:**
- Requires attacker to influence configuration (not direct code exploitation)
- Hardcoded seeds are source-controlled (but deployment configs may not be)

The vulnerability is more likely to manifest through:
1. Automated configuration generation bugs
2. Compromised configuration management tools
3. Man-in-the-middle attacks during config distribution
4. Insider threats with config access

## Recommendation

Add cryptographic validation in `build_seed_peer()` to verify PeerId matches the derived identity from each public key:

```rust
fn build_seed_peer(
    account_address_hex: &str,
    public_key_hex: &str,
    network_address_str: &str,
) -> Result<(PeerId, Peer), Error> {
    // Parse the account address
    let account_address = PeerId::from_hex(account_address_hex).map_err(|error| {
        Error::Unexpected(format!(
            "Failed to parse peer account address: {:?}. Error: {:?}",
            account_address_hex, error
        ))
    })?;

    // Parse the x25519 public key
    let public_key = x25519::PublicKey::from_encoded_string(public_key_hex).map_err(|error| {
        Error::Unexpected(format!(
            "Failed to parse peer public key: {:?}. Error: {:?}",
            public_key_hex, error
        ))
    })?;

    // **NEW: Validate PeerId matches the public key**
    let derived_peer_id = aptos_types::account_address::from_identity_public_key(public_key);
    if derived_peer_id != account_address {
        return Err(Error::InvariantViolation(format!(
            "PeerId mismatch: configured {} does not match derived {} from public key {}",
            account_address, derived_peer_id, public_key_hex
        )));
    }

    // Parse the network address string
    let network_address = NetworkAddress::from_str(network_address_str).map_err(|error| {
        Error::Unexpected(format!(
            "Failed to parse peer network address: {:?}. Error: {:?}",
            network_address_str, error
        ))
    })?;

    // Build the peer struct
    let peer = Peer {
        addresses: vec![network_address],
        keys: hashset! {public_key},
        role: PeerRole::Upstream,
    };

    Ok((account_address, peer))
}
```

Additionally, extend `verify_seeds()` to validate all seed peer PeerId-PublicKey bindings: [4](#0-3) 

## Proof of Concept

```rust
#[test]
fn test_seed_peer_identity_mismatch_detection() {
    use aptos_crypto::{x25519, Uniform};
    use aptos_types::account_address::from_identity_public_key;
    use rand::rngs::OsRng;
    
    // Generate a legitimate key pair
    let legitimate_key = x25519::PrivateKey::generate(&mut OsRng);
    let legitimate_pubkey = legitimate_key.public_key();
    let legitimate_peer_id = from_identity_public_key(legitimate_pubkey);
    
    // Generate an attacker's key pair
    let attacker_key = x25519::PrivateKey::generate(&mut OsRng);
    let attacker_pubkey = attacker_key.public_key();
    
    // Attempt to create a seed peer with mismatched identity
    // (legitimate peer ID but attacker's public key)
    let result = build_seed_peer(
        &legitimate_peer_id.to_hex(),
        &format!("0x{}", hex::encode(attacker_pubkey.to_bytes())),
        "/ip4/127.0.0.1/tcp/6180/noise-ik/0xaabbcc/handshake/0"
    );
    
    // Without the fix, this would succeed
    // With the fix, this should return an error
    assert!(result.is_err(), "Should reject mismatched PeerId and PublicKey");
}
```

**Notes**

This vulnerability represents a defense-in-depth failure where the system trusts configuration without cryptographic verification. While validators may legitimately use explicit account addresses different from their network-derived PeerIds (as shown in the IdentityBlob structure), seed peer configurations for public networks should enforce cryptographic binding to prevent identity confusion attacks. The lack of validation creates unnecessary attack surface in configuration management and deployment pipelines.

### Citations

**File:** config/src/config/config_optimizer.rs (L282-320)
```rust
fn build_seed_peer(
    account_address_hex: &str,
    public_key_hex: &str,
    network_address_str: &str,
) -> Result<(PeerId, Peer), Error> {
    // Parse the account address
    let account_address = PeerId::from_hex(account_address_hex).map_err(|error| {
        Error::Unexpected(format!(
            "Failed to parse peer account address: {:?}. Error: {:?}",
            account_address_hex, error
        ))
    })?;

    // Parse the x25519 public key
    let public_key = x25519::PublicKey::from_encoded_string(public_key_hex).map_err(|error| {
        Error::Unexpected(format!(
            "Failed to parse peer public key: {:?}. Error: {:?}",
            public_key_hex, error
        ))
    })?;

    // Parse the network address string
    let network_address = NetworkAddress::from_str(network_address_str).map_err(|error| {
        Error::Unexpected(format!(
            "Failed to parse peer network address: {:?}. Error: {:?}",
            network_address_str, error
        ))
    })?;

    // Build the peer struct
    let peer = Peer {
        addresses: vec![network_address],
        keys: hashset! {public_key},
        role: PeerRole::Upstream,
    };

    // Return the account address and peer
    Ok((account_address, peer))
}
```

**File:** types/src/lib.rs (L61-61)
```rust
pub use account_address::AccountAddress as PeerId;
```

**File:** types/src/account_address.rs (L140-146)
```rust
pub fn from_identity_public_key(identity_public_key: x25519::PublicKey) -> AccountAddress {
    let mut array = [0u8; AccountAddress::LENGTH];
    let pubkey_slice = identity_public_key.as_slice();
    // keep only the last 16 bytes
    array.copy_from_slice(&pubkey_slice[x25519::PUBLIC_KEY_SIZE - AccountAddress::LENGTH..]);
    AccountAddress::new(array)
}
```

**File:** config/src/config/network_config.rs (L319-340)
```rust
    pub fn verify_seeds(&self) -> Result<(), Error> {
        for (peer_id, addrs) in self.seed_addrs.iter() {
            for addr in addrs {
                Self::verify_address(peer_id, addr)?;
            }
        }

        for (peer_id, seed) in self.seeds.iter() {
            for addr in seed.addresses.iter() {
                Self::verify_address(peer_id, addr)?;
            }

            // Require there to be a pubkey somewhere, either in the address (assumed by `is_aptosnet_addr`)
            if seed.keys.is_empty() && seed.addresses.is_empty() {
                return Err(Error::InvariantViolation(format!(
                    "Seed peer {} has no pubkeys",
                    peer_id.short_str(),
                )));
            }
        }
        Ok(())
    }
```

**File:** network/framework/src/noise/handshake.rs (L488-500)
```rust
    fn authenticate_inbound(
        remote_peer_short: ShortHexStr,
        peer: &Peer,
        remote_public_key: &x25519::PublicKey,
    ) -> Result<PeerRole, NoiseHandshakeError> {
        if !peer.keys.contains(remote_public_key) {
            return Err(NoiseHandshakeError::UnauthenticatedClientPubkey(
                remote_peer_short,
                hex::encode(remote_public_key.as_slice()),
            ));
        }
        Ok(peer.role)
    }
```
