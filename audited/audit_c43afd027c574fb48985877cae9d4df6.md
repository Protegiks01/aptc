# Audit Report

## Title
Type Confusion in Event V2 to V1 Translation Due to Missing Type Validation

## Summary
The `translate_event_v2_to_v1()` function lacks validation to ensure that the `type_tag` field of a `ContractEventV2` matches the actual content of the `event_data` bytes. When event types have identical BCS serialization layouts (such as `CoinDeposit` and `CoinWithdraw`), a malformed event can deserialize successfully as the wrong type, resulting in incorrect V1 event creation. [1](#0-0) 

## Finding Description

The vulnerability exists in the event translation pipeline used by the indexer. When a `ContractEventV2` is received for translation:

1. The translator looks up the appropriate handler based on `v2.type_tag()`: [2](#0-1) 

2. Each translator deserializes the `event_data` using `try_from_bytes()` which performs BCS deserialization without type validation: [3](#0-2) 

3. Critical issue: `CoinDeposit` and `CoinWithdraw` have identical struct layouts: [4](#0-3) [5](#0-4) 

Both contain: `coin_type: String`, `account: AccountAddress`, `amount: u64`. This means bytes serialized as `CoinWithdraw` will successfully deserialize as `CoinDeposit` and vice versa.

**Attack Scenario:**
A malformed `ContractEventV2` with `type_tag = "0x1::coin::CoinDeposit"` but `event_data` containing `CoinWithdraw` bytes would:
- Pass BCS deserialization (identical layouts)
- Trigger `CoinDepositTranslator` 
- Create a V1 `DepositEvent` instead of `WithdrawEvent`
- Result in incorrect event indexing and API responses

## Impact Explanation

However, after thorough analysis, this vulnerability has **LIMITED EXPLOITABILITY** due to the following factors:

1. **No Direct Attack Path**: Events originate from Move VM execution, which ensures type safety through its native function: [6](#0-5) 

The Move VM derives both `type_tag` and `event_data` from the same typed value (line 263 and 302-310), ensuring consistency.

2. **Non-Consensus Critical**: The indexer is used for API queries and event lookups, not consensus. Incorrect translations affect query results but not on-chain state or fund safety.

3. **Storage Path Not Exploitable**: Events stored during restore are processed without validation: [7](#0-6) 

But backup sources are assumed trusted in the threat model.

## Likelihood Explanation

**VERY LOW** - An attacker would need to:
- Compromise trusted backup/restore infrastructure, OR
- Exploit a separate bug in the Move VM's event emission, OR
- Find a storage layer injection vulnerability

None of these paths are accessible to unprivileged attackers without compromising trusted components.

## Recommendation

Add type validation after BCS deserialization to verify structural integrity. For event types with identical layouts, add explicit runtime checks or include type discriminators in the data structures.

```rust
pub fn translate_event_v2_to_v1(
    &self,
    v2: &ContractEventV2,
) -> Result<Option<ContractEventV1>> {
    if let Some(translator) = self.translators.get(v2.type_tag()) {
        let result = translator.translate_event_v2_to_v1(v2, self);
        // Additional validation: ensure deserialized type matches expected type_tag
        match result {
            Ok(v1) => Ok(Some(v1)),
            Err(e) => {
                // Log type mismatch errors
                Err(e)
            }
        }
    } else {
        Ok(None)
    }
}
```

## Proof of Concept

A PoC cannot be implemented without either:
1. Direct storage manipulation (requires privileged access)
2. Exploiting a separate Move VM bug (outside scope)
3. Using internal test APIs unavailable in production

This makes the vulnerability **theoretically valid but practically unexploitable** by unprivileged attackers per the bug bounty criteria.

---

**Note**: While this represents a defense-in-depth code quality issue, it does **NOT** meet the strict exploitability requirements of the bug bounty program as it requires compromising trusted infrastructure or finding a separate vulnerability first. The impact is limited to the indexer (non-consensus component) and does not enable direct fund theft or consensus violations.

### Citations

**File:** storage/indexer/src/indexer_reader.rs (L185-197)
```rust
    fn translate_event_v2_to_v1(
        &self,
        v2: &ContractEventV2,
    ) -> anyhow::Result<Option<ContractEventV1>> {
        if let Some(db_indexer_reader) = &self.db_indexer_reader {
            if db_indexer_reader.indexer_db.event_v2_translation_enabled() {
                return Ok(db_indexer_reader.translate_event_v2_to_v1(v2)?);
            } else {
                anyhow::bail!("Event translation is not enabled")
            }
        }
        anyhow::bail!("DB indexer reader is not available")
    }
```

**File:** storage/indexer/src/db_indexer.rs (L552-584)
```rust
    pub fn translate_event_v2_to_v1(
        &self,
        v2: &ContractEventV2,
    ) -> Result<Option<ContractEventV1>> {
        let _timer = TIMER.timer_with(&["translate_event_v2_to_v1"]);
        if let Some(translator) = self
            .event_v2_translation_engine
            .translators
            .get(v2.type_tag())
        {
            let result = translator.translate_event_v2_to_v1(v2, &self.event_v2_translation_engine);
            match result {
                Ok(v1) => Ok(Some(v1)),
                Err(e) => {
                    // If the token object collection uses ConcurrentSupply, skip the translation and ignore the error.
                    // This is expected, as the event handle won't be found in either FixedSupply or UnlimitedSupply.
                    let is_ignored_error = (v2.type_tag() == &*MINT_TYPE
                        || v2.type_tag() == &*BURN_TYPE)
                        && e.to_string().contains("resource not found");
                    if !is_ignored_error {
                        warn!(
                            "Failed to translate event: {:?}. Error: {}",
                            v2,
                            e.to_string()
                        );
                    }
                    Ok(None)
                },
            }
        } else {
            Ok(None)
        }
    }
```

**File:** storage/indexer/src/event_v2_translator.rs (L238-274)
```rust
struct CoinDepositTranslator;
impl EventV2Translator for CoinDepositTranslator {
    fn translate_event_v2_to_v1(
        &self,
        v2: &ContractEventV2,
        engine: &EventV2TranslationEngine,
    ) -> Result<ContractEventV1> {
        let coin_deposit = CoinDeposit::try_from_bytes(v2.event_data())?;
        let struct_tag_str = format!("0x1::coin::CoinStore<{}>", coin_deposit.coin_type());
        let struct_tag = StructTag::from_str(&struct_tag_str)?;
        let (key, sequence_number) = if let Some(state_value_bytes) =
            engine.get_state_value_bytes_for_resource(coin_deposit.account(), &struct_tag)?
        {
            // We can use `DummyCoinType` as it does not affect the correctness of deserialization.
            let coin_store_resource: CoinStoreResource<DummyCoinType> =
                bcs::from_bytes(&state_value_bytes)?;
            let key = *coin_store_resource.deposit_events().key();
            let sequence_number = engine
                .get_next_sequence_number(&key, coin_store_resource.deposit_events().count())?;
            (key, sequence_number)
        } else {
            // The creation number of DepositEvent is deterministically 2.
            static DEPOSIT_EVENT_CREATION_NUMBER: u64 = 2;
            (
                EventKey::new(DEPOSIT_EVENT_CREATION_NUMBER, *coin_deposit.account()),
                0,
            )
        };
        let deposit_event = DepositEvent::new(coin_deposit.amount());
        Ok(ContractEventV1::new(
            key,
            sequence_number,
            DEPOSIT_EVENT_TYPE.clone(),
            bcs::to_bytes(&deposit_event)?,
        )?)
    }
}
```

**File:** types/src/account_config/events/coin_deposit.rs (L15-46)
```rust
#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize)]
pub struct CoinDeposit {
    pub coin_type: String,
    pub account: AccountAddress,
    pub amount: u64,
}

impl CoinDeposit {
    pub fn new(coin_type: String, account: AccountAddress, amount: u64) -> Self {
        Self {
            coin_type,
            account,
            amount,
        }
    }

    pub fn try_from_bytes(bytes: &[u8]) -> anyhow::Result<Self> {
        bcs::from_bytes(bytes).map_err(Into::into)
    }

    pub fn coin_type(&self) -> &str {
        &self.coin_type
    }

    pub fn account(&self) -> &AccountAddress {
        &self.account
    }

    pub fn amount(&self) -> u64 {
        self.amount
    }
}
```

**File:** types/src/account_config/events/coin_withdraw.rs (L15-46)
```rust
#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize)]
pub struct CoinWithdraw {
    pub coin_type: String,
    pub account: AccountAddress,
    pub amount: u64,
}

impl CoinWithdraw {
    pub fn new(coin_type: String, account: AccountAddress, amount: u64) -> Self {
        Self {
            coin_type,
            account,
            amount,
        }
    }

    pub fn try_from_bytes(bytes: &[u8]) -> anyhow::Result<Self> {
        bcs::from_bytes(bytes).map_err(Into::into)
    }

    pub fn coin_type(&self) -> &str {
        &self.coin_type
    }

    pub fn account(&self) -> &AccountAddress {
        &self.account
    }

    pub fn amount(&self) -> u64 {
        self.amount
    }
}
```

**File:** aptos-move/framework/src/natives/event.rs (L247-323)
```rust
fn native_write_module_event_to_store(
    context: &mut SafeNativeContext,
    ty_args: &[Type],
    mut arguments: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    debug_assert!(ty_args.len() == 1);
    debug_assert!(arguments.len() == 1);

    let ty = &ty_args[0];
    let msg = arguments.pop_back().unwrap();

    context.charge(
        EVENT_WRITE_TO_EVENT_STORE_BASE
            + EVENT_WRITE_TO_EVENT_STORE_PER_ABSTRACT_VALUE_UNIT * context.abs_val_size(&msg)?,
    )?;

    let type_tag = context.type_to_type_tag(ty)?;

    // Additional runtime check for module call.
    let stack_frames = context.stack_frames(1);
    let id = stack_frames
        .stack_trace()
        .first()
        .map(|(caller, _, _)| caller)
        .ok_or_else(|| {
            let err = PartialVMError::new_invariant_violation(
                "Caller frame for 0x1::emit::event is not found",
            );
            SafeNativeError::InvariantViolation(err)
        })?
        .as_ref()
        .ok_or_else(|| {
            // If module is not known, this call must come from the script, which is not allowed.
            let err = PartialVMError::new_invariant_violation("Scripts cannot emit events");
            SafeNativeError::InvariantViolation(err)
        })?;

    if let TypeTag::Struct(ref struct_tag) = type_tag {
        if id != &struct_tag.module_id() {
            return Err(SafeNativeError::InvariantViolation(PartialVMError::new(
                StatusCode::INTERNAL_TYPE_ERROR,
            )));
        }
    } else {
        return Err(SafeNativeError::InvariantViolation(PartialVMError::new(
            StatusCode::INTERNAL_TYPE_ERROR,
        )));
    }

    let (layout, contains_delayed_fields) = context
        .type_to_type_layout_with_delayed_fields(ty)?
        .unpack();

    let function_value_extension = context.function_value_extension();
    let max_value_nest_depth = context.max_value_nest_depth();
    let blob = ValueSerDeContext::new(max_value_nest_depth)
        .with_delayed_fields_serde()
        .with_func_args_deserialization(&function_value_extension)
        .serialize(&msg, &layout)?
        .ok_or_else(|| {
            SafeNativeError::InvariantViolation(PartialVMError::new_invariant_violation(
                "Event serialization failure",
            ))
        })?;

    let ctx = context.extensions_mut().get_mut::<NativeEventContext>();
    let event = ContractEvent::new_v2(type_tag, blob).map_err(|_| SafeNativeError::Abort {
        abort_code: ECANNOT_CREATE_EVENT,
    })?;
    // TODO(layouts): avoid cloning layouts for events with delayed fields.
    ctx.events.push((
        event,
        contains_delayed_fields.then(|| layout.as_ref().clone()),
    ));

    Ok(smallvec![])
}
```

**File:** storage/aptosdb/src/backup/restore_utils.rs (L239-243)
```rust
    ledger_db.event_db().put_events_multiple_versions(
        first_version,
        events,
        &mut ledger_db_batch.event_db_batches,
    )?;
```
