# Audit Report

## Title
Non-Atomic Key File Writes Can Corrupt Validator Identity Files Leading to Validator Unavailability

## Summary
The key file writing operations in Aptos Core use a non-atomic write pattern that truncates files before writing new content. If a system crash, power failure, or process termination occurs during the write operation, validator identity files can be left in a corrupted state (empty or partially written). This prevents validators from restarting, causing loss of consensus participation and potentially affecting network liveness.

## Finding Description
The vulnerability exists in the file writing implementation used throughout the Aptos CLI and genesis key generation tools. The `write_to_file_with_opts` function performs non-atomic writes by: [1](#0-0) 

The critical issue is that `.truncate(true)` immediately truncates the existing file to 0 bytes before `write_all()` writes the new content. This creates a vulnerability window where:
1. The existing file is truncated to empty
2. If a crash/power failure/kill signal occurs before or during `write_all()`
3. The file is left corrupted (empty or partially written)

This pattern is used for writing critical validator key files: [2](#0-1) 

When validators start, they load the `validator-identity.yaml` file which contains their consensus and network private keys: [3](#0-2) 

The file is parsed during consensus initialization: [4](#0-3) [5](#0-4) 

If the YAML parsing fails due to file corruption, the validator initialization panics: [6](#0-5) 

**Exploitation Scenario:**
1. Validator operator runs `aptos genesis generate-keys` or performs key rotation
2. During the write of `validator-identity.yaml`, the system experiences:
   - Power failure
   - Kernel panic  
   - Process killed (e.g., OOM killer, manual kill)
   - Storage failure
3. The key file is left corrupted (empty or truncated)
4. Validator attempts to restart and fails during safety rules initialization
5. Validator cannot participate in consensus until keys are manually restored from backup
6. If multiple validators are affected (e.g., coordinated maintenance window), network liveness may be impacted

## Impact Explanation
This issue qualifies as **Medium Severity** under the Aptos bug bounty program criteria: "State inconsistencies requiring intervention."

**Impact:**
- **Validator Unavailability**: Corrupted key files prevent validator nodes from starting, removing them from the active validator set
- **Consensus Liveness Risk**: If multiple validators are affected simultaneously (e.g., during coordinated maintenance or widespread power events), the network may fail to reach consensus quorum
- **Operational Burden**: Requires manual intervention to restore keys from backups or regenerate them, causing operational delays
- **No Direct Fund Loss**: Does not enable theft of funds or consensus safety violations, keeping it at Medium rather than High/Critical severity

The impact is limited by the fact that:
- It requires an external trigger (crash/power failure) during the specific write operation
- It's recoverable through backup restoration or key regeneration
- It doesn't compromise consensus safety or enable fund theft

However, validator availability is critical for network operation, and this vulnerability can cause extended downtime requiring manual intervention.

## Likelihood Explanation
The likelihood of this vulnerability manifesting is **Moderate to High** in production environments:

**Factors Increasing Likelihood:**
- **Key Generation/Rotation Operations**: Validators periodically rotate keys or regenerate them, creating regular exposure windows
- **Production Environment Realities**: Power failures, hardware failures, and system crashes occur in real-world datacenter operations
- **Process Management**: Container orchestration systems (Kubernetes) may forcefully terminate processes during scaling or updates
- **Storage Issues**: Network-attached storage failures or I/O errors can interrupt write operations

**Factors Decreasing Likelihood:**
- **Small Time Window**: The vulnerability window is milliseconds to seconds (the duration of the write operation)
- **Infrequent Operations**: Key generation typically happens during initial setup, not during normal operation
- **Backup Practices**: Well-managed validator operations maintain key backups

The likelihood is significant enough to warrant fixing because:
1. The consequences are severe (validator downtime)
2. Production environments inherently face crashes and failures
3. The fix is straightforward and adds minimal overhead

## Recommendation
Implement atomic file writes using the standard write-to-temporary-then-rename pattern. This is the industry-standard approach for ensuring file write atomicity on POSIX-compliant systems.

**Recommended Fix:**

```rust
use std::fs;
use std::io::Write;
use tempfile::NamedTempFile;

pub fn write_to_file_with_opts(
    path: &Path,
    name: &str,
    bytes: &[u8],
    opts: &mut OpenOptions,
) -> CliTypedResult<()> {
    // Create a temporary file in the same directory as the target
    let parent_dir = path.parent().unwrap_or_else(|| Path::new("."));
    let mut temp_file = NamedTempFile::new_in(parent_dir)
        .map_err(|e| CliError::IO(name.to_string(), e))?;
    
    // Write to temporary file
    temp_file.write_all(bytes)
        .map_err(|e| CliError::IO(name.to_string(), e))?;
    
    // Flush and sync to ensure data is on disk
    temp_file.flush()
        .map_err(|e| CliError::IO(name.to_string(), e))?;
    temp_file.as_file().sync_all()
        .map_err(|e| CliError::IO(name.to_string(), e))?;
    
    // Set permissions on Unix systems
    #[cfg(unix)]
    {
        use std::os::unix::fs::PermissionsExt;
        if let Some(mode) = opts.as_raw_fd().mode {
            fs::set_permissions(temp_file.path(), fs::Permissions::from_mode(mode))
                .map_err(|e| CliError::IO(name.to_string(), e))?;
        }
    }
    
    // Atomically rename temporary file to target (atomic on POSIX)
    temp_file.persist(path)
        .map_err(|e| CliError::IO(name.to_string(), e.error))?;
    
    Ok(())
}
```

This approach ensures that:
1. The original file remains intact until the new file is completely written and synced
2. The rename operation is atomic on POSIX systems (including Linux)
3. If a crash occurs during writing, the original file is preserved
4. The new file only becomes visible after being fully written to disk

**Additional Recommendations:**
1. Consider adding file integrity checks (checksums) to detect corruption
2. Implement automatic retry logic with exponential backoff for transient failures
3. Document backup and recovery procedures for validator operators
4. Consider storing key backups in multiple locations for disaster recovery

## Proof of Concept

```rust
// File: test_atomic_write_vulnerability.rs
// Compile with: rustc --edition 2021 test_atomic_write_vulnerability.rs
// Run with: ./test_atomic_write_vulnerability

use std::fs::{File, OpenOptions};
use std::io::{Write, Read};
use std::path::Path;
use std::process::{Command, Stdio};
use std::thread;
use std::time::Duration;

// Simulate the vulnerable write function from utils.rs
fn vulnerable_write(path: &Path, data: &[u8]) -> std::io::Result<()> {
    let mut file = OpenOptions::new()
        .write(true)
        .create(true)
        .truncate(true)  // VULNERABILITY: Truncates immediately
        .open(path)?;
    
    // Simulate slow write (network storage, etc.)
    thread::sleep(Duration::from_millis(100));
    file.write_all(data)?;
    Ok(())
}

fn main() {
    println!("=== Demonstrating Non-Atomic Write Vulnerability ===\n");
    
    let test_file = Path::new("/tmp/validator-identity-test.yaml");
    let original_data = b"account_address: 0x1234567890abcdef\nconsensus_private_key: original_key\nnetwork_private_key: original_network_key";
    
    // Step 1: Create initial key file
    println!("1. Creating initial validator identity file...");
    std::fs::write(test_file, original_data).unwrap();
    println!("   Original file size: {} bytes\n", test_file.metadata().unwrap().len());
    
    // Step 2: Simulate key rotation with simulated crash
    println!("2. Simulating key rotation with crash during write...");
    let test_file_clone = test_file.to_path_buf();
    
    // Start write in separate thread
    let write_thread = thread::spawn(move || {
        let new_data = b"account_address: 0xfedcba0987654321\nconsensus_private_key: new_rotated_key_that_is_longer\nnetwork_private_key: new_network_key";
        vulnerable_write(&test_file_clone, new_data)
    });
    
    // Simulate crash by killing process (in real test, would send SIGKILL)
    thread::sleep(Duration::from_millis(50)); // Crash during truncate-write window
    
    // In real scenario, process would be killed here
    // For demo, we let it complete but show the vulnerability window
    write_thread.join().unwrap().unwrap();
    
    // Step 3: Show vulnerability window
    println!("   During the window between truncate() and write_all():");
    println!("   - Original file is TRUNCATED TO 0 BYTES");
    println!("   - New data not yet written");
    println!("   - IF CRASH OCCURS HERE: File is CORRUPTED\n");
    
    // Step 4: Simulate validator restart with corrupted file
    println!("3. Simulating corrupted file (empty or truncated):");
    std::fs::write(test_file, b"").unwrap(); // Simulate corruption
    println!("   Corrupted file size: {} bytes\n", test_file.metadata().unwrap().len());
    
    // Step 5: Try to load like validator would
    println!("4. Attempting to parse corrupted file (as validator would):");
    match std::fs::read_to_string(test_file) {
        Ok(contents) => {
            if contents.is_empty() {
                println!("   ❌ ERROR: File is empty - YAML parsing would FAIL");
                println!("   Validator cannot start!");
            } else {
                // Try to parse as YAML
                println!("   File contents: {}", contents);
                println!("   ❌ YAML parsing would fail - Validator cannot start!");
            }
        },
        Err(e) => println!("   ❌ ERROR: Cannot read file: {}", e),
    }
    
    println!("\n5. Impact:");
    println!("   - Validator fails to initialize SafetyRules");
    println!("   - Consensus participation lost");
    println!("   - Manual intervention required to restore from backup");
    println!("   - If multiple validators affected: Network liveness at risk");
    
    // Cleanup
    let _ = std::fs::remove_file(test_file);
    
    println!("\n=== Vulnerability Demonstrated ===");
}
```

**To reproduce the actual vulnerability:**
1. Set up a test validator node
2. Generate initial keys using `aptos genesis generate-keys`
3. During key rotation, send SIGKILL to the process mid-write (e.g., using `kill -9`)
4. Attempt to restart the validator
5. Observe the validator failing to load the corrupted `validator-identity.yaml`

The validator will fail with a panic similar to:
```
thread 'main' panicked at 'No identity blob in initial safety rules config'
```

This prevents the validator from participating in consensus until the keys are manually restored from backup.

### Citations

**File:** crates/aptos/src/common/utils.rs (L232-246)
```rust
pub fn write_to_file_with_opts(
    path: &Path,
    name: &str,
    bytes: &[u8],
    opts: &mut OpenOptions,
) -> CliTypedResult<()> {
    let mut file = opts
        .write(true)
        .create(true)
        .truncate(true)
        .open(path)
        .map_err(|e| CliError::IO(name.to_string(), e))?;
    file.write_all(bytes)
        .map_err(|e| CliError::IO(name.to_string(), e))
}
```

**File:** crates/aptos/src/genesis/keys.rs (L82-97)
```rust
        write_to_user_only_file(
            private_keys_file.as_path(),
            PRIVATE_KEYS_FILE,
            to_yaml(&private_identity)?.as_bytes(),
        )?;
        write_to_user_only_file(
            public_keys_file.as_path(),
            PUBLIC_KEYS_FILE,
            to_yaml(&public_identity)?.as_bytes(),
        )?;
        write_to_user_only_file(
            validator_file.as_path(),
            VALIDATOR_FILE,
            to_yaml(&validator_blob)?.as_bytes(),
        )?;
        write_to_user_only_file(vfn_file.as_path(), VFN_FILE, to_yaml(&vfn_blob)?.as_bytes())?;
```

**File:** terraform/helm/aptos-node/files/configs/validator-base.yaml (L18-22)
```yaml
    initial_safety_rules_config:
      from_file:
        waypoint:
          from_file: /opt/aptos/genesis/waypoint.txt
        identity_blob_path: /opt/aptos/genesis/validator-identity.yaml
```

**File:** config/src/config/safety_rules_config.rs (L159-167)
```rust
    pub fn identity_blob(&self) -> anyhow::Result<IdentityBlob> {
        match self {
            InitialSafetyRulesConfig::FromFile {
                identity_blob_path, ..
            } => IdentityBlob::from_file(identity_blob_path),
            InitialSafetyRulesConfig::None => {
                bail!("loading identity blob failed with missing initial safety rules config")
            },
        }
```

**File:** config/src/config/identity_config.rs (L40-42)
```rust
    pub fn from_file(path: &Path) -> anyhow::Result<IdentityBlob> {
        Ok(serde_yaml::from_str(&fs::read_to_string(path)?)?)
    }
```

**File:** consensus/safety-rules/src/safety_rules_manager.rs (L54-77)
```rust
            let identity_blob = config
                .initial_safety_rules_config
                .identity_blob()
                .expect("No identity blob in initial safety rules config");
            let waypoint = config.initial_safety_rules_config.waypoint();

            let backend = &config.backend;
            let internal_storage: Storage = backend.into();
            PersistentSafetyStorage::initialize(
                internal_storage,
                identity_blob
                    .account_address
                    .expect("AccountAddress needed for safety rules"),
                identity_blob
                    .consensus_private_key
                    .expect("Consensus key needed for safety rules"),
                waypoint,
                config.enable_cached_safety_data,
            )
        } else {
            panic!(
                "Safety rules storage is not initialized, provide an initial safety rules config"
            )
        };
```
