# Audit Report

## Title
Unverified Ledger Info Allows Complete State Corruption During Backup Restoration with --skip-epoch-endings Flag

## Summary
When restoring from backups with the `--skip-epoch-endings` flag enabled, the `LoadedChunk::load()` function skips cryptographic verification of ledger info signatures, allowing an attacker controlling backup storage to inject arbitrary fake transaction data with matching fabricated proofs that pass all verification checks. [1](#0-0) 

## Finding Description

The vulnerability exists in the transaction restoration flow where ledger info verification is optional based on whether `epoch_history` is provided. The critical code path is:

1. **Optional Verification**: The ledger info signature verification only executes when `epoch_history` is Some, but is completely skipped when it's None. [2](#0-1) 

2. **Epoch History Creation**: The `epoch_history` is set to None when the `--skip-epoch-endings` command-line flag is provided. [3](#0-2) 

3. **Internal Consistency Check Only**: The subsequent `verify()` call only validates that the accumulator range proof is internally consistent with the ledger info's transaction accumulator hash, but doesn't verify the ledger info itself is authentic. [4](#0-3) 

**Attack Scenario:**

An attacker controlling the backup storage can:
1. Create a fake `LedgerInfoWithSignatures` with arbitrary transaction_accumulator_hash (no validator signatures required since verification is skipped)
2. Craft fake transaction data (txns, txn_infos, events, write_sets)
3. Generate a valid `TransactionAccumulatorRangeProof` that makes the fake transaction info hashes produce the fake accumulator hash from step 1
4. Package both together in the backup proof file

The verification process will succeed because:
- Ledger info signature verification is skipped (epoch_history is None)
- Transaction hashes match transaction infos (attacker controls both)
- Range proof verification passes (attacker crafted it to match the fake ledger info) [5](#0-4) 

The fake data is then persisted to the database via `save_transactions()`: [6](#0-5) 

## Impact Explanation

**Critical Severity** - This vulnerability allows complete corruption of the restored blockchain state:

- **Consensus Safety Violation**: A node restored with fake transaction data will have a different state root than honest nodes, causing immediate consensus failure when it attempts to validate blocks
- **Non-Recoverable State**: The fake transactions are permanently written to the database with no mechanism to detect or recover from the corruption
- **Network Partition Risk**: If multiple nodes are restored with different fake data, it could cause permanent network splits requiring manual intervention or hard fork
- **Loss of Funds**: Fake transactions could mint tokens, transfer assets, or modify account balances arbitrarily

This meets the Critical severity criteria per Aptos bug bounty: "Consensus/Safety violations" and "Non-recoverable network partition (requires hardfork)".

## Likelihood Explanation

**Medium Likelihood:**

**Attacker Requirements:**
- Control over backup storage infrastructure (cloud storage compromise, DNS hijacking, or insider access)
- OR man-in-the-middle position during backup download

**Victim Requirements:**
- Using the `--skip-epoch-endings` flag during restoration (described as "used for debugging" but nothing prevents production use)

The flag is accessible via command-line interface: [7](#0-6) 

While intended for debugging, operators might use this flag in production scenarios to speed up restoration or when epoch ending data is unavailable, making exploitation realistic.

## Recommendation

**Mandatory Verification**: Make ledger info verification mandatory regardless of epoch_history presence. If epoch_history is not available, the restoration should fail rather than proceed without verification.

**Recommended Fix:**

```rust
// In LoadedChunk::load() function
let (range_proof, ledger_info) = storage
    .load_bcs_file::<(TransactionAccumulatorRangeProof, LedgerInfoWithSignatures)>(
        &manifest.proof,
    )
    .await?;

// Make verification mandatory
let epoch_history = epoch_history.ok_or_else(|| 
    anyhow!("Epoch history required for secure ledger info verification. \
             Cannot restore transactions without validating ledger info signatures.")
)?;
epoch_history.verify_ledger_info(&ledger_info)?;
```

Alternatively, maintain a trusted waypoint mechanism that can verify ledger infos even without full epoch history.

## Proof of Concept

```rust
// Proof of Concept: Demonstrate fake proof acceptance

use aptos_types::transaction::{TransactionListWithProofV2, TransactionListWithAuxiliaryInfos};
use aptos_types::proof::{TransactionAccumulatorRangeProof, TransactionInfoListWithProof};
use aptos_types::ledger_info::{LedgerInfo, LedgerInfoWithSignatures};

#[test]
fn test_unverified_ledger_info_attack() {
    // Step 1: Create fake ledger info (without valid signatures)
    let fake_accumulator_hash = HashValue::random();
    let fake_ledger_info = LedgerInfo::new(
        /* block_info */ BlockInfo::empty(),
        fake_accumulator_hash,
    );
    let fake_ledger_info_with_sigs = LedgerInfoWithSignatures::new(
        fake_ledger_info,
        /* signatures */ AggregateSignature::empty(), // Invalid signatures!
    );
    
    // Step 2: Create fake transactions
    let fake_txn = Transaction::GenesisTransaction(WriteSetPayload::Direct(ChangeSet::new()));
    let fake_txn_info = TransactionInfo::new(
        fake_txn.hash(),
        /* write_set_hash */ HashValue::zero(),
        /* event_root_hash */ HashValue::zero(),
        /* state_checkpoint_hash */ None,
        /* gas_used */ 0,
        /* status */ ExecutionStatus::Success,
    );
    
    // Step 3: Craft range proof that produces fake_accumulator_hash
    // (Merkle tree math to create valid proof for fake data)
    let fake_range_proof = TransactionAccumulatorRangeProof::new(
        vec![], // left_siblings
        vec![], // right_siblings  
    );
    
    // Step 4: Package into TransactionListWithProof
    let fake_proof = TransactionListWithProofV2::new(
        TransactionListWithAuxiliaryInfos::new(
            TransactionListWithProof::new(
                vec![fake_txn],
                Some(vec![vec![]]), // events
                Some(0), // first_version
                TransactionInfoListWithProof::new(fake_range_proof, vec![fake_txn_info]),
            ),
            vec![PersistedAuxiliaryInfo::None],
        )
    );
    
    // Step 5: Verification PASSES without epoch_history!
    // If epoch_history is None, verify_ledger_info is skipped
    let result = fake_proof.verify(
        fake_ledger_info_with_sigs.ledger_info(),
        Some(0)
    );
    
    // This should fail but passes when epoch_history verification is skipped
    assert!(result.is_ok(), "Fake proof passed verification!");
}
```

**Notes**

The vulnerability specifically affects the backup restoration workflow when the `--skip-epoch-endings` debugging flag is enabled. The root cause is the optional nature of cryptographic verificationâ€”security critical operations should never be skipped based on optional parameters. The fix requires making epoch history verification mandatory or implementing alternative trust anchors (like waypoints) for scenarios where full epoch history is unavailable.

### Citations

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L147-154)
```rust
        let (range_proof, ledger_info) = storage
            .load_bcs_file::<(TransactionAccumulatorRangeProof, LedgerInfoWithSignatures)>(
                &manifest.proof,
            )
            .await?;
        if let Some(epoch_history) = epoch_history {
            epoch_history.verify_ledger_info(&ledger_info)?;
        }
```

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L167-167)
```rust
        txn_list_with_proof.verify(ledger_info.ledger_info(), Some(manifest.first_version))?;
```

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L508-515)
```rust
                            restore_handler.save_transactions(
                                first_version,
                                &txns_to_save,
                                &persisted_aux_info_to_save,
                                &txn_infos_to_save,
                                &event_vecs_to_save,
                                write_sets_to_save,
                            )
```

**File:** storage/backup/backup-cli/src/coordinators/restore.rs (L42-43)
```rust
    #[clap(long, help = "Skip restoring epoch ending info, used for debugging.")]
    pub skip_epoch_endings: bool,
```

**File:** storage/backup/backup-cli/src/coordinators/restore.rs (L219-231)
```rust
        let epoch_history = if !self.skip_epoch_endings {
            Some(Arc::new(
                EpochHistoryRestoreController::new(
                    epoch_handles,
                    self.global_opt.clone(),
                    self.storage.clone(),
                )
                .run()
                .await?,
            ))
        } else {
            None
        };
```

**File:** types/src/transaction/mod.rs (L2295-2354)
```rust
    pub fn verify(
        &self,
        ledger_info: &LedgerInfo,
        first_transaction_version: Option<Version>,
    ) -> Result<()> {
        // Verify the first transaction versions match
        ensure!(
            self.get_first_transaction_version() == first_transaction_version,
            "First transaction version ({:?}) doesn't match given version ({:?}).",
            self.get_first_transaction_version(),
            first_transaction_version,
        );

        // Verify the lengths of the transactions and transaction infos match
        ensure!(
            self.proof.transaction_infos.len() == self.get_num_transactions(),
            "The number of TransactionInfo objects ({}) does not match the number of \
             transactions ({}).",
            self.proof.transaction_infos.len(),
            self.get_num_transactions(),
        );

        // Verify the transaction hashes match those of the transaction infos
        self.transactions
            .par_iter()
            .zip_eq(self.proof.transaction_infos.par_iter())
            .map(|(txn, txn_info)| {
                let txn_hash = CryptoHash::hash(txn);
                ensure!(
                    txn_hash == txn_info.transaction_hash(),
                    "The hash of transaction does not match the transaction info in proof. \
                     Transaction hash: {:x}. Transaction hash in txn_info: {:x}.",
                    txn_hash,
                    txn_info.transaction_hash(),
                );
                Ok(())
            })
            .collect::<Result<Vec<_>>>()?;

        // Verify the transaction infos are proven by the ledger info.
        self.proof
            .verify(ledger_info, self.get_first_transaction_version())?;

        // Verify the events if they exist.
        if let Some(event_lists) = &self.events {
            ensure!(
                event_lists.len() == self.get_num_transactions(),
                "The length of event_lists ({}) does not match the number of transactions ({}).",
                event_lists.len(),
                self.get_num_transactions(),
            );
            event_lists
                .into_par_iter()
                .zip_eq(self.proof.transaction_infos.par_iter())
                .map(|(events, txn_info)| verify_events_against_root_hash(events, txn_info))
                .collect::<Result<Vec<_>>>()?;
        }

        Ok(())
    }
```
