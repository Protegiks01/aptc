# Audit Report

## Title
Module Upgrade Compatibility Bypass via TREAT_FRIEND_AS_PRIVATE Feature Allows Breaking Changes to Friend Function Interfaces

## Summary
When the `TREAT_FRIEND_AS_PRIVATE` feature flag is enabled (default on mainnet), the module upgrade compatibility checker skips validation of `public(friend)` functions. This allows module publishers to remove or change signatures of friend functions during "compatible" upgrades, causing unexpected runtime failures in already-deployed modules that depend on these functions.

## Finding Description

The Aptos module upgrade system is designed to validate compatibility when modules are upgraded with the `compat` policy. However, a critical gap exists in how friend function interfaces are validated. [1](#0-0) 

The `TREAT_FRIEND_AS_PRIVATE` feature flag is enabled by default, which sets `check_friend_linking` to FALSE: [2](#0-1) 

This causes the compatibility checker to skip validation of friend functions entirely: [3](#0-2) 

**Attack Scenario:**

1. **Setup Phase**: Attacker deploys Module A at address 0xAttacker containing:
   ```move
   module 0xAttacker::A {
       public(friend) fun critical_operation(x: u64): u64 { x * 2 }
   }
   ```

2. **Victim Deployment**: A victim deploys Module B that depends on Module A:
   ```move
   module 0xVictim::B {
       friend 0xAttacker::A;
       public fun process() {
           0xAttacker::A::critical_operation(100);
       }
   }
   ```

3. **Malicious Upgrade**: Attacker upgrades Module A with "compatible" policy, removing the friend function:
   ```move
   module 0xAttacker::A {
       // critical_operation removed!
   }
   ```

4. **Runtime Failure**: The upgrade succeeds because friend function validation is skipped. When Module B attempts to call `critical_operation`, it fails at runtime with an invariant violation error: [4](#0-3) 

The compatibility check explicitly allows this behavior as demonstrated in the test suite: [5](#0-4) [6](#0-5) 

## Impact Explanation

**Severity: HIGH**

This vulnerability breaks the fundamental compatibility guarantee of the Aptos module system. It causes:

1. **Unexpected Runtime Failures**: Deployed modules that successfully passed all validation checks will suddenly fail at runtime after a dependency upgrade
2. **Deterministic Execution Violation**: Different execution paths can occur depending on upgrade timing, potentially causing validator consensus issues if modules are used in system operations
3. **Breaking Change Disguised as Compatible**: The upgrade is marked as "compatible" but actually introduces breaking changes
4. **Denial of Service**: Victim modules become unusable without redeployment

This qualifies as **High Severity** under Aptos bug bounty criteria as it represents a "Significant protocol violation" that can cause "API crashes" and validator node issues if system modules are affected.

## Likelihood Explanation

**Likelihood: HIGH**

This vulnerability is highly likely to be exploited because:

1. **Default Configuration**: The `TREAT_FRIEND_AS_PRIVATE` feature is enabled by default on mainnet
2. **No Special Access Required**: Any account can deploy and upgrade modules
3. **Legitimate Use Cases**: Developers commonly use friend functions for inter-module access control
4. **No Warning**: The system provides no warning that friend functions lack compatibility protection
5. **Observable Behavior**: Tests explicitly validate this behavior as working "correctly"

## Recommendation

The system should enforce friend function compatibility checks even when `TREAT_FRIEND_AS_PRIVATE` is enabled, at minimum for friend entry functions. The fix should modify the compatibility checking logic:

**Option 1 (Recommended)**: Always check friend functions that are called by other deployed modules: [7](#0-6) 

Modify the logic to track which modules call each friend function and enforce compatibility for those with external callers.

**Option 2 (Stricter)**: Disable `TREAT_FRIEND_AS_PRIVATE` by default, or require explicit acknowledgment when upgrading modules that remove friend functions, warning about potential breakage of dependent modules.

**Option 3 (Documentation)**: At minimum, prominently document this behavior and provide tools to identify dependent modules before upgrading.

## Proof of Concept

The following Move test demonstrates the vulnerability:

```move
// Module A - Initial version with friend function
module 0xCAFE::ModuleA {
    friend 0xCAFE::ModuleB;
    
    public(friend) fun critical_function(x: u64): u64 {
        x * 2
    }
}

// Module B - Depends on Module A's friend function  
module 0xCAFE::ModuleB {
    use 0xCAFE::ModuleA;
    
    public entry fun user_operation(s: &signer) {
        let result = ModuleA::critical_function(100);
        // ... use result
    }
}

// Module A - Upgraded version removes friend function
module 0xCAFE::ModuleA {
    // critical_function removed - upgrade succeeds!
}

// Execution: Module B's user_operation now fails at runtime
// with INVARIANT_VIOLATION when calling removed function
```

The test at `aptos-move/e2e-move-tests/src/tests/upgrade_compatibility.rs` lines 29-30 explicitly validates this behavior succeeds, confirming the vulnerability is present.

## Notes

This vulnerability exists by design due to the `TREAT_FRIEND_AS_PRIVATE` feature, but it directly violates the module compatibility guarantees that developers rely on. The feature was likely intended to allow internal refactoring flexibility, but it inadvertently creates a mechanism for introducing breaking changes under the guise of "compatible" upgrades. This represents a fundamental flaw in the module upgrade validation system that undermines trust in the compatibility model.

### Citations

**File:** types/src/on_chain_config/aptos_features.rs (L171-174)
```rust
    pub fn default_features() -> Vec<Self> {
        vec![
            FeatureFlag::CODE_DEPENDENCY_CHECK,
            FeatureFlag::TREAT_FRIEND_AS_PRIVATE,
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1570-1573)
```rust
        let check_struct_layout = true;
        let check_friend_linking = !self
            .features()
            .is_enabled(FeatureFlag::TREAT_FRIEND_AS_PRIVATE);
```

**File:** third_party/move/move-binary-format/src/compatibility.rs (L162-208)
```rust
        for old_func in old_view.functions() {
            let old_is_persistent = old_func
                .attributes()
                .contains(&FunctionAttribute::Persistent);

            // private, non entry function doesn't need to follow any checks here, skip
            if old_func.visibility() == Visibility::Private
                && !old_func.is_entry()
                && !old_is_persistent
            {
                // Function not exposed, continue with next one
                continue;
            }
            let new_func = match new_view.function_definition(old_func.name()) {
                Some(new_func) => new_func,
                None => {
                    // Function has been removed
                    // Function is NOT a private, non entry function, or it is persistent.
                    if old_is_persistent
                        || !matches!(old_func.visibility(), Visibility::Friend)
                        // Above: Either Private Entry, or Public
                        || self.check_friend_linking
                        // Here we know that the old_function has to be Friend.
                        // And if friends are not considered private (self.check_friend_linking is
                        // true), we can't update.
                        || (old_func.is_entry() && self.treat_entry_as_public)
                    // Here we know that the old_func has to be Friend, and the
                    // check_friend_linking is set to false. We make sure that we don't allow
                    // any Entry functions to be deleted, when self.treat_entry_as_public is
                    // set (treats entry as public)
                    {
                        errors.push(format!("removed function `{}`", old_func.name()));
                    }
                    continue;
                },
            };

            if !old_is_persistent
                && matches!(old_func.visibility(), Visibility::Friend)
                && !self.check_friend_linking
                // Above: We want to skip linking checks for public(friend) if
                // self.check_friend_linking is set to false.
                && !(old_func.is_entry() && self.treat_entry_as_public)
            // However, public(friend) entry function still needs to be checked.
            {
                continue;
            }
```

**File:** third_party/move/move-vm/runtime/src/runtime_type_checks.rs (L960-978)
```rust
        if callee.is_friend() {
            let callee_module = callee.owner_as_module().map_err(|err| err.to_partial())?;
            if !caller
                .module_id()
                .is_some_and(|id| callee_module.friends.contains(id))
            {
                let msg = format!(
                    "Function {}::{} cannot be called because it has friend visibility, but {} \
                     is not {}'s friend",
                    callee.module_or_script_id(),
                    callee.name(),
                    caller.module_or_script_id(),
                    callee.module_or_script_id()
                );
                return Err(
                    PartialVMError::new_invariant_violation(msg).with_sub_status(EPARANOID_FAILURE)
                );
            }
        }
```

**File:** aptos-move/e2e-move-tests/src/tests/upgrade_compatibility.rs (L29-30)
```rust
    let result = check_upgrade("public(friend) fun f(){}", "");
    assert_success!(result);
```

**File:** aptos-move/e2e-move-tests/src/tests/upgrade_compatibility.rs (L50-51)
```rust
    let result = check_upgrade("public(friend) fun f(){}", "public(friend) fun f(u: u16){}");
    assert_success!(result);
```
