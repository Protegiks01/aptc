# Audit Report

## Title
Metadata Validation Bypass for Version 5 Modules via Inconsistent Attribute Clearing

## Summary
Module metadata validation can be bypassed for version 5 modules due to an inconsistency between two metadata extraction functions. `get_metadata_from_compiled_code()` clears attributes during validation while `get_metadata()` preserves them at runtime, allowing invalid metadata to be stored on-chain and used during execution.

## Finding Description

The vulnerability exists due to inconsistent handling of version 5 module metadata between validation and runtime phases.

During module publishing validation, `verify_module_metadata_for_module_publishing()` calls `get_metadata_from_compiled_code()` which contains special handling for version 5 modules: [1](#0-0) 

This code clears `struct_attributes` and `fun_attributes` for version 5 modules before validation occurs. As a result, the subsequent validation logic that checks attribute validity never executes: [2](#0-1) 

The module is stored on-chain with its original (potentially invalid) metadata intact.

At runtime, when metadata is accessed, the system uses `get_metadata()` which does NOT clear version 5 attributes: [3](#0-2) 

This inconsistency allows invalid metadata attributes to bypass validation and be used at runtime. For example, resource group member metadata is used to determine storage access paths: [4](#0-3) 

**Attack Scenario:**
1. Attacker creates a version 5 module with invalid metadata (e.g., marking a struct without the `Key` ability as a resource group member, or marking a non-returning function as a view function)
2. During publishing, `get_metadata_from_compiled_code()` clears the attributes
3. Validation in `verify_module_metadata_for_module_publishing()` finds no attributes to validate and passes
4. Module is stored on-chain with original invalid metadata
5. At runtime, `get_metadata()` extracts the invalid attributes without clearing
6. Invalid metadata influences execution behavior (resource access paths, view function determination, etc.)

## Impact Explanation

This qualifies as **Medium Severity** under the Aptos bug bounty program for the following reasons:

**State Inconsistencies:** Invalid resource group metadata could cause incorrect state access patterns, potentially leading to state inconsistencies that require manual intervention to resolve. Different nodes might handle invalid metadata differently, threatening deterministic execution.

**Validation Bypass:** The core security guarantee of metadata validation is circumvented. Structs can be marked as resource group members without meeting requirements checked by `is_valid_resource_group_member()`: [5](#0-4) 

**Potential Consensus Impact:** If invalid metadata causes different execution paths on different validators, this could lead to consensus divergence where validators produce different state roots for the same block.

The impact is limited to Medium rather than Critical because:
- Only affects version 5 modules (though version 5 is still supported as VERSION_MIN)
- Some runtime checks may still catch certain invalid metadata uses
- Does not directly enable fund theft or network partition

## Likelihood Explanation

**High Likelihood** - The vulnerability is easily exploitable:

1. **No special privileges required:** Any user can publish modules
2. **Version 5 is supported:** It remains the minimum version per `get_max_binary_format_version()`: [6](#0-5) 

3. **Simple to execute:** Attacker only needs to compile a module as version 5 with invalid metadata attributes
4. **No detection during publishing:** The validation will silently pass due to cleared attributes
5. **Guaranteed storage on-chain:** The invalid metadata will be stored and accessible at runtime

The only barrier is that networks with newer VM_BINARY_FORMAT flags enabled might default to higher versions, but version 5 remains explicitly supported.

## Recommendation

Fix the inconsistency by ensuring metadata handling is uniform across validation and runtime. The recommended solution is to remove the version 5 special case clearing from `get_metadata_from_compiled_code()`:

```rust
pub fn get_metadata_from_compiled_code(
    code: &impl CompiledCodeMetadata,
) -> Option<RuntimeModuleMetadataV1> {
    if let Some(data) = find_metadata(code.metadata(), APTOS_METADATA_KEY_V1) {
        let metadata = bcs::from_bytes::<RuntimeModuleMetadataV1>(&data.value).ok();
        // Remove the version 5 clearing logic:
        // if code.version() == 5 {
        //     if let Some(metadata) = metadata.as_mut() {
        //         metadata.struct_attributes.clear();
        //         metadata.fun_attributes.clear();
        //     }
        // }
        metadata
    } else if let Some(data) = find_metadata(code.metadata(), APTOS_METADATA_KEY) {
        let data_v0 = bcs::from_bytes::<RuntimeModuleMetadata>(&data.value).ok()?;
        Some(data_v0.upgrade())
    } else {
        None
    }
}
```

If version 5 modules should not have V1 metadata, enforce this during deserialization rather than silently clearing it: [7](#0-6) 

Alternatively, if version 5 support should be deprecated, update the minimum supported version and reject version 5 modules during deserialization.

## Proof of Concept

```rust
// Create a version 5 module with invalid resource group member metadata
// This would bypass validation and be stored on-chain

use move_binary_format::{
    file_format::{CompiledModule, Metadata},
    CompiledModule,
};
use aptos_types::vm::module_metadata::{
    RuntimeModuleMetadataV1, KnownAttribute, APTOS_METADATA_KEY_V1,
};

// Create a module at version 5
let mut module = create_test_module(); // Helper to create basic module
module.version = 5;

// Add invalid metadata - mark a struct as resource group member 
// without the Key ability
let mut metadata = RuntimeModuleMetadataV1::default();
metadata.struct_attributes.insert(
    "InvalidStruct".to_string(),
    vec![KnownAttribute::resource_group_member(
        "0x1::invalid::Container".to_string()
    )],
);

// Serialize and add to module
let serialized = bcs::to_bytes(&metadata).unwrap();
module.metadata.push(Metadata {
    key: APTOS_METADATA_KEY_V1.to_vec(),
    value: serialized,
});

// Publish this module - validation will clear attributes and pass
// At runtime, invalid metadata will be accessible via get_metadata()
```

This demonstrates that invalid metadata can bypass validation checks defined in `verify_module_metadata_for_module_publishing()` and be stored on-chain for version 5 modules.

## Notes

The vulnerability stems from an apparent cleanup attempt (the comment mentions "shouldn't have existed in the first place") that created a security hole. The inconsistency between validation-time and runtime metadata handling violates the principle that validation should accurately reflect runtime behavior.

### Citations

**File:** types/src/vm/module_metadata.rs (L199-230)
```rust
pub fn get_metadata(md: &[Metadata]) -> Option<Arc<RuntimeModuleMetadataV1>> {
    if let Some(data) = find_metadata(md, APTOS_METADATA_KEY_V1) {
        V1_METADATA_CACHE.with(|ref_cell| {
            let mut cache = ref_cell.borrow_mut();
            if let Some(meta) = cache.get(&data.value) {
                meta.clone()
            } else {
                let meta = bcs::from_bytes::<RuntimeModuleMetadataV1>(&data.value)
                    .ok()
                    .map(Arc::new);
                cache.put(data.value.clone(), meta.clone());
                meta
            }
        })
    } else if let Some(data) = find_metadata(md, APTOS_METADATA_KEY) {
        V0_METADATA_CACHE.with(|ref_cell| {
            let mut cache = ref_cell.borrow_mut();
            if let Some(meta) = cache.get(&data.value) {
                meta.clone()
            } else {
                let meta = bcs::from_bytes::<RuntimeModuleMetadata>(&data.value)
                    .ok()
                    .map(RuntimeModuleMetadata::upgrade)
                    .map(Arc::new);
                cache.put(data.value.clone(), meta.clone());
                meta
            }
        })
    } else {
        None
    }
}
```

**File:** types/src/vm/module_metadata.rs (L252-283)
```rust
/// Check if the metadata has unknown key/data types
fn check_metadata_format(module: &CompiledModule) -> Result<(), MalformedError> {
    let mut exist = false;
    let mut compilation_key_exist = false;
    for data in module.metadata.iter() {
        if data.key == *APTOS_METADATA_KEY || data.key == *APTOS_METADATA_KEY_V1 {
            if exist {
                return Err(MalformedError::DuplicateKey);
            }
            exist = true;

            if data.key == *APTOS_METADATA_KEY {
                bcs::from_bytes::<RuntimeModuleMetadata>(&data.value)
                    .map_err(|e| MalformedError::DeserializedError(data.key.clone(), e))?;
            } else if data.key == *APTOS_METADATA_KEY_V1 {
                bcs::from_bytes::<RuntimeModuleMetadataV1>(&data.value)
                    .map_err(|e| MalformedError::DeserializedError(data.key.clone(), e))?;
            }
        } else if data.key == *COMPILATION_METADATA_KEY {
            if compilation_key_exist {
                return Err(MalformedError::DuplicateKey);
            }
            compilation_key_exist = true;
            bcs::from_bytes::<CompilationMetadata>(&data.value)
                .map_err(|e| MalformedError::DeserializedError(data.key.clone(), e))?;
        } else {
            return Err(MalformedError::UnknownKey(data.key.clone()));
        }
    }

    Ok(())
}
```

**File:** types/src/vm/module_metadata.rs (L294-298)
```rust
        if code.version() == 5 {
            if let Some(metadata) = metadata.as_mut() {
                metadata.struct_attributes.clear();
                metadata.fun_attributes.clear();
            }
```

**File:** types/src/vm/module_metadata.rs (L423-432)
```rust
pub fn is_valid_resource_group_member(
    structs: &BTreeMap<&IdentStr, (&StructHandle, &StructDefinition)>,
    struct_: &str,
) -> Result<(), AttributeValidationError> {
    if let Ok(ident_struct) = Identifier::new(struct_) {
        if let Some((struct_handle, _struct_def)) = structs.get(ident_struct.as_ident_str()) {
            if struct_handle.abilities.has_ability(Ability::Key) {
                return Ok(());
            }
        }
```

**File:** types/src/vm/module_metadata.rs (L452-456)
```rust
    let metadata = if let Some(metadata) = get_metadata_from_compiled_code(module) {
        metadata
    } else {
        return Ok(());
    };
```

**File:** aptos-move/aptos-vm/src/data_cache.rs (L50-60)
```rust
pub fn get_resource_group_member_from_metadata(
    struct_tag: &StructTag,
    metadata: &[Metadata],
) -> Option<StructTag> {
    let metadata = get_metadata(metadata)?;
    metadata
        .struct_attributes
        .get(struct_tag.name.as_ident_str().as_str())?
        .iter()
        .find_map(|attr| attr.get_resource_group_member())
}
```

**File:** types/src/on_chain_config/aptos_features.rs (L485-499)
```rust
    pub fn get_max_binary_format_version(&self) -> u32 {
        if self.is_enabled(FeatureFlag::VM_BINARY_FORMAT_V10) {
            file_format_common::VERSION_10
        } else if self.is_enabled(FeatureFlag::VM_BINARY_FORMAT_V9) {
            file_format_common::VERSION_9
        } else if self.is_enabled(FeatureFlag::VM_BINARY_FORMAT_V8) {
            file_format_common::VERSION_8
        } else if self.is_enabled(FeatureFlag::VM_BINARY_FORMAT_V7) {
            file_format_common::VERSION_7
        } else if self.is_enabled(FeatureFlag::VM_BINARY_FORMAT_V6) {
            file_format_common::VERSION_6
        } else {
            file_format_common::VERSION_5
        }
    }
```
