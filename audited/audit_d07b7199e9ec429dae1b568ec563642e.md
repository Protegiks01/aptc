# Audit Report

## Title
Architecture-Dependent Type Cast Vulnerability in Bulletproofs Range Proof Verification Leading to Consensus Divergence

## Summary
The `native_verify_range_proof()` and `native_verify_batch_range_proof()` functions in the Bulletproofs native implementation contain unchecked `u64` to `usize` type casts that silently truncate values on 32-bit systems. This creates architecture-dependent behavior that violates the deterministic execution invariant, potentially causing consensus divergence if validators run on different architectures.

## Finding Description
The vulnerability exists at multiple locations where `u64` values are cast to `usize` without bounds checking: [1](#0-0) [2](#0-1) 

On 32-bit systems, `usize` is 32 bits (max: 4,294,967,295), while `u64` is 64 bits. When a `u64` value exceeds `u32::MAX`, the `as usize` cast silently truncates the upper 32 bits.

**Attack Scenario:**

An attacker crafts a transaction calling `verify_range_proof_internal` with `num_bits = 0x100000008` (4,294,967,304 in decimal):

1. **On 64-bit validators:**
   - `num_bits` remains `4294967304`
   - The validation check fails: `4294967304 ∉ {8, 16, 32, 64}` [3](#0-2) 
   - Transaction aborts with `NFE_RANGE_NOT_SUPPORTED` (code `0x01_0003`)

2. **On hypothetical 32-bit validators:**
   - `num_bits` truncates to `8` (only lower 32 bits retained)
   - The validation check passes: `8 ∈ {8, 16, 32, 64}`
   - Gas charging proceeds with the wrong value: [4](#0-3) 
   - Proof verification executes with `bit_length = 8` instead of rejecting: [5](#0-4) 

This breaks **Invariant #1: Deterministic Execution** - identical transactions produce different results on different architectures, causing:
- Different execution outcomes (abort vs. success)
- Different gas consumption
- Different state roots
- Consensus divergence and potential chain fork

The vulnerability also affects batch verification and test-only proving functions at the same pattern. [6](#0-5) [7](#0-6) 

## Impact Explanation
This vulnerability qualifies as **Medium severity** per Aptos bug bounty criteria:

- **Consensus Impact**: If exploited, validators on different architectures would produce different state roots for the same block, causing consensus failure and requiring manual intervention to resolve the fork.

- **State Inconsistencies**: The divergence in execution results would corrupt the blockchain state, requiring coordination among validators to reconcile.

While the impact is severe (consensus divergence typically qualifies as Critical), the Medium categorization is appropriate because:
1. Exploitation requires 32-bit validators to exist in the network
2. Modern blockchain infrastructure uses 64-bit systems exclusively
3. Aptos build configuration explicitly targets 64-bit architectures only [8](#0-7) 

However, this remains a valid security issue because blockchain consensus must be architecture-independent to ensure deterministic execution across all nodes.

## Likelihood Explanation
**Likelihood: LOW**

Current production Aptos validators almost certainly run on 64-bit systems. The build configuration explicitly targets `x86_64-unknown-linux-gnu` and `x86_64-pc-windows-msvc`, indicating no intention to support 32-bit deployments.

However, the code does not prevent 32-bit compilation, and edge cases could exist:
- Development/testing environments with different architectures
- Future embedded validator implementations
- Cross-compilation scenarios
- Legacy system integrations

The vulnerability represents a latent code correctness issue that violates the principle of deterministic execution regardless of current deployment practices.

## Recommendation
Add bounds checking before casting `u64` to `usize` to ensure the value fits within the target architecture's pointer size:

```rust
fn native_verify_range_proof(
    context: &mut SafeNativeContext,
    ty_args: &[Type],
    mut args: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    debug_assert!(ty_args.is_empty());
    debug_assert!(args.len() == 6);

    let dst = safely_pop_arg!(args, Vec<u8>);
    let num_bits_u64 = safely_pop_arg!(args, u64);
    
    // Validate that num_bits fits in usize before casting
    let num_bits = usize::try_from(num_bits_u64).map_err(|_| SafeNativeError::Abort {
        abort_code: abort_codes::NFE_RANGE_NOT_SUPPORTED,
    })?;
    
    // ... rest of function
}
```

Apply the same fix to `native_verify_batch_range_proof()` and the test-only proving functions. This ensures:
1. Values exceeding `usize::MAX` on any architecture are rejected consistently
2. All validators produce identical results regardless of architecture
3. The deterministic execution invariant is preserved

## Proof of Concept
```move
#[test(fx = @std)]
#[expected_failure(abort_code = 0x010003, location = aptos_std::ristretto255_bulletproofs)]
fun test_architecture_dependent_truncation(fx: signer) {
    use aptos_std::ristretto255_bulletproofs;
    use aptos_std::features;
    use aptos_std::ristretto255_pedersen as pedersen;
    use aptos_std::ristretto255;
    
    features::change_feature_flags_for_testing(
        &fx, 
        vector[features::get_bulletproofs_feature()], 
        vector[]
    );
    
    // Craft a num_bits value that would truncate to 8 on 32-bit systems
    // 0x100000008 = 4,294,967,304 (decimal)
    // On 32-bit: truncates to 8
    // On 64-bit: remains 4,294,967,304
    let malicious_num_bits: u64 = 0x100000008;
    
    let comm = pedersen::new_commitment_for_bulletproof(
        &ristretto255::scalar_one(),
        &ristretto255::new_scalar_from_sha2_512(b"test")
    );
    
    let proof = ristretto255_bulletproofs::range_proof_from_bytes(vector[]);
    
    // On 64-bit: aborts with NFE_RANGE_NOT_SUPPORTED (0x010003)
    // On 32-bit: would attempt verification with num_bits=8
    ristretto255_bulletproofs::verify_range_proof_pedersen(
        &comm, 
        &proof, 
        malicious_num_bits, 
        b"test"
    );
}
```

This test demonstrates the architecture-dependent behavior. On 64-bit systems, it correctly aborts with `NFE_RANGE_NOT_SUPPORTED`. On a hypothetical 32-bit system, the truncation would bypass validation, causing different execution behavior and consensus divergence.

### Citations

**File:** aptos-move/framework/src/natives/cryptography/bulletproofs.rs (L82-82)
```rust
    let num_bits = safely_pop_arg!(args, u64) as usize;
```

**File:** aptos-move/framework/src/natives/cryptography/bulletproofs.rs (L90-94)
```rust
    if !is_supported_number_of_bits(num_bits) {
        return Err(SafeNativeError::Abort {
            abort_code: abort_codes::NFE_RANGE_NOT_SUPPORTED,
        });
    }
```

**File:** aptos-move/framework/src/natives/cryptography/bulletproofs.rs (L122-122)
```rust
    let num_bits = safely_pop_arg!(args, u64) as usize;
```

**File:** aptos-move/framework/src/natives/cryptography/bulletproofs.rs (L174-174)
```rust
    let num_bits = safely_pop_arg!(args, u64) as usize;
```

**File:** aptos-move/framework/src/natives/cryptography/bulletproofs.rs (L240-240)
```rust
    let num_bits = safely_pop_arg!(args, u64) as usize;
```

**File:** aptos-move/framework/src/natives/cryptography/bulletproofs.rs (L344-344)
```rust
    context.charge(BULLETPROOFS_PER_BIT_RANGEPROOF_VERIFY * NumArgs::new(bit_length as u64))?;
```

**File:** aptos-move/framework/src/natives/cryptography/bulletproofs.rs (L348-356)
```rust
    let success = range_proof
        .verify_single(
            &BULLETPROOF_GENERATORS,
            pc_gens,
            &mut ver_trans,
            comm_point,
            bit_length,
        )
        .is_ok();
```

**File:** .cargo/config.toml (L28-43)
```text
[target.x86_64-unknown-linux-gnu]
# We also need to include `-C linker-plugin-lto` for performance builds to take
# full advantage of LTO, but we cannot add it here because it would affect dev
# and release builds as well, so we add it only when building docker images.
rustflags = [
  "--cfg",
  "tokio_unstable",
  "-C",
  "link-arg=-fuse-ld=lld",
  "-C",
  "force-frame-pointers=yes",
  "-C",
  "force-unwind-tables=yes",
  "-C",
  "target-cpu=x86-64-v3",
]
```
