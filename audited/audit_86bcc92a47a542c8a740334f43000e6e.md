# Audit Report

## Title
Resource Exhaustion via Unvalidated Transaction Signatures in Remote Batch Processing

## Summary
The Quorum Store batch coordinator accepts and stores batches from remote validators without validating transaction signatures, allowing malicious validators to waste storage quota, network bandwidth, and processing resources on honest nodes with cryptographically invalid transactions that are only rejected during the execution pipeline's prepare phase.

## Finding Description

The vulnerability exists in how the Quorum Store handles batches received from remote validators. The attack flow is:

1. **Batch Reception**: Remote batches arrive at `BatchCoordinator::handle_batches_msg()` [1](#0-0) 

2. **Insufficient Validation**: The batch coordinator only validates batch size limits and optionally applies transaction filters, but **never validates transaction signatures** [2](#0-1) 

3. **Batch Verification**: The `Batch::verify()` method checks metadata consistency (author, digest, transaction counts, gas prices) but explicitly **does not verify signatures** [3](#0-2) 

4. **Transaction Filter**: The `BatchTransactionFilter::allows_transaction()` only matches on batch metadata and transaction properties, **not cryptographic validity** [4](#0-3) 

5. **Resource Consumption**: Invalid batches are stored in the batch store, consuming per-peer storage quota via `QuotaManager::update_quota()` [5](#0-4) 

6. **Deferred Validation**: Signatures are only verified during the pipeline's `prepare` phase via `SIG_VERIFY_POOL` [6](#0-5) 

7. **Signature Verification**: The conversion to `SignatureVerifiedTransaction` calls `verify_signature()`, marking invalid transactions as `Invalid` [7](#0-6) 

8. **Execution Discard**: Invalid transactions are immediately discarded during execution with `INVALID_SIGNATURE` status [8](#0-7) 

**Attack Scenario**: A Byzantine validator crafts batches containing transactions with invalid signatures (random bytes) and broadcasts them. Honest validators:
- Store these batches (consuming quota)
- Gossip them to peers (wasting bandwidth) 
- Include them in block proposals (wasting consensus time)
- Only reject them during signature verification in the prepare phase

This violates the **Resource Limits** invariant: operations should respect storage and computational limits, but invalid signatures bypass early validation.

## Impact Explanation

**Severity: HIGH** per Aptos Bug Bounty criteria ("Validator node slowdowns").

**Resource Exhaustion Impact**:
1. **Storage Quota Depletion**: Each validator has per-peer quotas for batch storage. A Byzantine validator can fill these quotas with invalid batches, preventing legitimate batches from being stored
2. **Network Bandwidth Waste**: Invalid batches consume network resources during gossip across the validator network
3. **Consensus Processing Overhead**: Blocks containing invalid batches waste consensus round time during preparation and validation
4. **Database Write Amplification**: If memory quota is exceeded, invalid batches trigger unnecessary database writes

**Scope**: Affects all honest validators receiving batches from Byzantine peers. With N validators, a single Byzantine validator can amplify resource consumption N-1 times.

## Likelihood Explanation

**Likelihood: HIGH**

**Requirements**:
- Attacker must operate a validator node (or compromise one)
- Byzantine behavior within BFT tolerance (< 1/3 validators)
- No cryptographic cost (invalid signatures are cheap to generate)

**Ease of Exploitation**:
- Attack is trivial to execute: generate random signature bytes
- No complex timing or race conditions required
- Persistent effect: batches remain stored until expiration
- Amplification: one malicious batch affects multiple honest nodes

**Detection Difficulty**: The attack appears as normal batch traffic until the prepare phase, making it hard to distinguish from legitimate load.

## Recommendation

Add transaction signature validation in `BatchCoordinator::handle_batches_msg()` **before** persisting batches:

```rust
pub(crate) async fn handle_batches_msg(
    &mut self,
    author: PeerId,
    batches: Vec<Batch<BatchInfoExt>>,
) {
    // Existing size validation...
    if let Err(e) = self.ensure_max_limits(&batches) {
        // ...
    }

    // NEW: Validate transaction signatures BEFORE storage
    for batch in batches.iter() {
        for transaction in batch.txns() {
            if let Err(_) = transaction.verify_signature() {
                error!(
                    "Transaction {} in batch {} from {} has invalid signature",
                    transaction.committed_hash(),
                    batch.batch_info().batch_id(),
                    author.short_str()
                );
                counters::RECEIVED_BATCH_INVALID_SIGNATURE.inc();
                return; // Reject entire batch
            }
        }
    }

    // Existing filter and processing...
}
```

**Alternative**: Perform signature verification in parallel using a thread pool to minimize latency impact, similar to the prepare phase implementation.

## Proof of Concept

```rust
#[tokio::test]
async fn test_batch_with_invalid_signatures_consumes_resources() {
    use aptos_crypto::{ed25519::Ed25519PrivateKey, PrivateKey, Uniform};
    use aptos_types::transaction::{RawTransaction, SignedTransaction};
    use rand::SeedableRng;
    
    // Setup batch coordinator with quota tracking
    let (coordinator, quota_tracker) = setup_test_batch_coordinator();
    
    // Create transaction with INVALID signature (random bytes)
    let mut rng = rand::rngs::StdRng::from_seed([0u8; 32]);
    let sender_key = Ed25519PrivateKey::generate(&mut rng);
    let raw_txn = RawTransaction::new_script(
        AccountAddress::random(),
        0,
        Script::new(vec![], vec![], vec![]),
        1_000_000,
        1,
        0,
        ChainId::test(),
    );
    
    // Sign with one key but claim different sender (invalid signature)
    let wrong_key = Ed25519PrivateKey::generate(&mut rng);
    let invalid_txn = SignedTransaction::new(
        raw_txn.clone(),
        sender_key.public_key(),
        wrong_key.sign(&raw_txn).unwrap(), // Invalid: signed with wrong key
    );
    
    // Verify signature is indeed invalid
    assert!(invalid_txn.verify_signature().is_err());
    
    // Create batch with invalid transaction
    let batch = create_test_batch(vec![invalid_txn]);
    let initial_quota = quota_tracker.get_available_quota();
    
    // Send batch to coordinator
    coordinator.handle_batches_msg(PeerId::random(), vec![batch]).await;
    
    // VULNERABILITY: Quota was consumed despite invalid signature
    let final_quota = quota_tracker.get_available_quota();
    assert!(final_quota < initial_quota, "Storage quota consumed for invalid signature");
    
    // Invalid transaction only rejected during prepare phase (too late)
}
```

**Notes**:
- This vulnerability requires validator network access (Byzantine validator scenario within BFT tolerance)
- The resource exhaustion is bounded by per-peer quotas but still represents significant waste
- Early signature validation would prevent resource consumption without impacting legitimate traffic

### Citations

**File:** consensus/src/quorum_store/batch_coordinator.rs (L173-245)
```rust
    pub(crate) async fn handle_batches_msg(
        &mut self,
        author: PeerId,
        batches: Vec<Batch<BatchInfoExt>>,
    ) {
        if let Err(e) = self.ensure_max_limits(&batches) {
            error!("Batch from {}: {}", author, e);
            counters::RECEIVED_BATCH_MAX_LIMIT_FAILED.inc();
            return;
        }

        let Some(batch) = batches.first() else {
            error!("Empty batch received from {}", author.short_str().as_str());
            return;
        };

        // Filter the transactions in the batches. If any transaction is rejected,
        // the message will be dropped, and all batches will be rejected.
        if self.transaction_filter_config.is_enabled() {
            let transaction_filter = &self.transaction_filter_config.batch_transaction_filter();
            for batch in batches.iter() {
                for transaction in batch.txns() {
                    if !transaction_filter.allows_transaction(
                        batch.batch_info().batch_id(),
                        batch.author(),
                        batch.digest(),
                        transaction,
                    ) {
                        error!(
                            "Transaction {}, in batch {}, from {}, was rejected by the filter. Dropping {} batches!",
                            transaction.committed_hash(),
                            batch.batch_info().batch_id(),
                            author.short_str().as_str(),
                            batches.len()
                        );
                        counters::RECEIVED_BATCH_REJECTED_BY_FILTER.inc();
                        return;
                    }
                }
            }
        }

        let approx_created_ts_usecs = batch
            .info()
            .expiration()
            .saturating_sub(self.batch_expiry_gap_when_init_usecs);

        if approx_created_ts_usecs > 0 {
            observe_batch(
                approx_created_ts_usecs,
                batch.author(),
                BatchStage::RECEIVED,
            );
        }

        let mut persist_requests = vec![];
        for batch in batches.into_iter() {
            // TODO: maybe don't message batch generator if the persist is unsuccessful?
            if let Err(e) = self
                .sender_to_batch_generator
                .send(BatchGeneratorCommand::RemoteBatch(batch.clone()))
                .await
            {
                warn!("Failed to send batch to batch generator: {}", e);
            }
            persist_requests.push(batch.into());
        }
        counters::RECEIVED_BATCH_COUNT.inc_by(persist_requests.len() as u64);
        if author != self.my_peer_id {
            counters::RECEIVED_REMOTE_BATCH_COUNT.inc_by(persist_requests.len() as u64);
        }
        self.persist_and_send_digests(persist_requests, approx_created_ts_usecs);
    }
```

**File:** consensus/src/quorum_store/types.rs (L262-290)
```rust
    pub fn verify(&self) -> anyhow::Result<()> {
        ensure!(
            self.payload.author() == self.author(),
            "Payload author doesn't match the info"
        );
        ensure!(
            self.payload.hash() == *self.digest(),
            "Payload hash doesn't match the digest"
        );
        ensure!(
            self.payload.num_txns() as u64 == self.num_txns(),
            "Payload num txns doesn't match batch info"
        );
        ensure!(
            self.payload.num_bytes() as u64 == self.num_bytes(),
            "Payload num bytes doesn't match batch info"
        );
        for txn in self.payload.txns() {
            ensure!(
                txn.gas_unit_price() >= self.gas_bucket_start(),
                "Payload gas unit price doesn't match batch info"
            );
            ensure!(
                !txn.payload().is_encrypted_variant(),
                "Encrypted transaction is not supported yet"
            );
        }
        Ok(())
    }
```

**File:** crates/aptos-transaction-filters/src/batch_transaction_filter.rs (L30-58)
```rust
    pub fn allows_transaction(
        &self,
        batch_id: BatchId,
        batch_author: PeerId,
        batch_digest: &HashValue,
        signed_transaction: &SignedTransaction,
    ) -> bool {
        // If the filter is empty, allow the transaction by default
        if self.is_empty() {
            return true;
        }

        // Check if any rule matches the batch transaction
        for batch_transaction_rule in &self.batch_transaction_rules {
            if batch_transaction_rule.matches(
                batch_id,
                batch_author,
                batch_digest,
                signed_transaction,
            ) {
                return match batch_transaction_rule {
                    BatchTransactionRule::Allow(_) => true,
                    BatchTransactionRule::Deny(_) => false,
                };
            }
        }

        true // No rules match (allow the batch transaction by default)
    }
```

**File:** consensus/src/quorum_store/batch_store.rs (L64-84)
```rust
    pub(crate) fn update_quota(&mut self, num_bytes: usize) -> anyhow::Result<StorageMode> {
        if self.batch_balance == 0 {
            counters::EXCEEDED_BATCH_QUOTA_COUNT.inc();
            bail!("Batch quota exceeded ");
        }

        if self.db_balance >= num_bytes {
            self.batch_balance -= 1;
            self.db_balance -= num_bytes;

            if self.memory_balance >= num_bytes {
                self.memory_balance -= num_bytes;
                Ok(StorageMode::MemoryAndPersisted)
            } else {
                Ok(StorageMode::PersistedOnly)
            }
        } else {
            counters::EXCEEDED_STORAGE_QUOTA_COUNT.inc();
            bail!("Storage quota exceeded ");
        }
    }
```

**File:** consensus/src/pipeline/pipeline_builder.rs (L669-680)
```rust
        let sig_verification_start = Instant::now();
        let sig_verified_txns: Vec<SignatureVerifiedTransaction> = SIG_VERIFY_POOL.install(|| {
            let num_txns = input_txns.len();
            input_txns
                .into_par_iter()
                .with_min_len(optimal_min_len(num_txns, 32))
                .map(|t| Transaction::UserTransaction(t).into())
                .collect::<Vec<_>>()
        });
        counters::PREPARE_BLOCK_SIG_VERIFICATION_TIME
            .observe_duration(sig_verification_start.elapsed());
        Ok((Arc::new(sig_verified_txns), block_gas_limit))
```

**File:** types/src/transaction/signature_verified_transaction.rs (L129-139)
```rust
impl From<Transaction> for SignatureVerifiedTransaction {
    fn from(txn: Transaction) -> Self {
        match txn {
            Transaction::UserTransaction(txn) => match txn.verify_signature() {
                Ok(_) => SignatureVerifiedTransaction::Valid(Transaction::UserTransaction(txn)),
                Err(_) => SignatureVerifiedTransaction::Invalid(Transaction::UserTransaction(txn)),
            },
            _ => SignatureVerifiedTransaction::Valid(txn),
        }
    }
}
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L2881-2885)
```rust
        if let SignatureVerifiedTransaction::Invalid(_) = txn {
            let vm_status = VMStatus::error(StatusCode::INVALID_SIGNATURE, None);
            let discarded_output = discarded_output(vm_status.status_code());
            return Ok((vm_status, discarded_output));
        }
```
