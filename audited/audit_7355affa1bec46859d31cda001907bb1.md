# Audit Report

## Title
Use Case Spread Factor Bypass via Account Use Case Switching in Transaction Shuffler

## Summary
When an account in the delayed queue pops a transaction and its next transaction belongs to a previously unseen use case, the new use case is created with insufficient delay (`output_idx + 1`), bypassing the configured `use_case_spread_factor`. This creates an inconsistency with how new use cases are handled elsewhere in the system, allowing transactions to bypass fairness mechanisms.

## Finding Description

The transaction shuffler's `use_case_aware` module implements spread factors to enforce fairness between different use cases (contracts). When a new use case is encountered, it should be delayed by `output_idx + 1 + use_case_spread_factor` to prevent any single use case from dominating block space.

However, there is an inconsistency in how new use cases are created: [1](#0-0) 

In the `pop_head()` function, when an account switches to a different use case that hasn't been tracked before, the new use case is created with delay `self.output_idx + 1`, **without** applying the spread factor.

Compare this with the correct behavior in `update_delays_for_selected_txn()`: [2](#0-1) [3](#0-2) 

Here, new use cases correctly receive delay `output_idx + 1 + use_case_spread_factor`.

**Attack Path:**
1. Attacker creates a single account
2. Sends multiple transactions from this account to different contract addresses (creating different use cases)
3. When the first transaction is processed and delayed due to `sender_spread_factor`
4. Upon popping that transaction, if the next transaction targets a new contract, that use case is created without the spread factor
5. The new use case becomes ready at `output_idx + 1` instead of `output_idx + 5` (with default `user_use_case_spread_factor = 4`)
6. Attacker gains 4 positions of unfair priority per new use case

The default configuration shows the impact: [4](#0-3) 

With `user_use_case_spread_factor: 4`, the attacker bypasses 4 positions of intended delay per use case switch.

## Impact Explanation

This violates the fairness guarantees of the transaction shuffler, which is a **Medium Severity** issue under "State inconsistencies requiring intervention." While this doesn't cause consensus splits (the behavior is deterministic across all validators), it violates protocol-level fairness invariants:

1. **Protocol Violation**: The spread factors are on-chain configuration parameters. Bypassing them violates the intended protocol behavior.
2. **Fairness Compromise**: Attackers can gain unfair priority by cycling through multiple contracts from a single account.
3. **Resource Limit Bypass**: The spread factor serves as a resource limit mechanism (Invariant #9), preventing any single use case from monopolizing block space.
4. **Transaction Ordering Manipulation**: Could potentially be exploited for MEV or to front-run other users within the same block construction window.

The issue is deterministic and doesn't break consensus safety, but it does break the fairness policy that is explicitly configured and enforced elsewhere in the system.

## Likelihood Explanation

**Likelihood: Medium to High**

- **Easy to Execute**: Any user can send transactions from one account to multiple contracts
- **No Special Privileges Required**: Standard transaction submission capabilities suffice  
- **Realistic Scenario**: Multi-contract interactions from a single account are common in DeFi
- **Repeatable**: Attacker can continuously exploit this by cycling through many contracts
- **Currently Active**: The default genesis configuration has non-zero spread factors, making this exploitable on live networks

## Recommendation

Apply the use case spread factor consistently when creating new use cases in all code paths. Modify line 393 in `pop_head()`:

```rust
// Current (incorrect):
let new_use_case = entry.insert(UseCase::new_with_account(
    self.output_idx + 1,  // Missing spread factor
    address,
    account,
));

// Fixed (correct):
let new_use_case = entry.insert(UseCase::new_with_account(
    self.output_idx + 1 + self.config.use_case_spread_factor(&new_use_case_key),
    address,
    account,
));
```

This ensures new use cases created via account switching receive the same delay as new use cases created in other code paths, maintaining fairness guarantees.

## Proof of Concept

```rust
#[test]
fn test_use_case_switching_spread_factor_bypass() {
    use crate::transaction_shuffler::use_case_aware::{
        delayed_queue::DelayedQueue,
        Config,
    };
    
    // Setup with non-zero user_use_case_spread_factor
    let config = Config {
        sender_spread_factor: 2,
        platform_use_case_spread_factor: 0,
        user_use_case_spread_factor: 4,  // Should add 4 to delay
    };
    
    let mut queue = DelayedQueue::new(config);
    
    // Account A1 sends to Contract C1, then to Contract C2 (different use case)
    // Both transactions get delayed
    let txn1 = create_test_txn(Account(1), Contract::User(0xC1));
    let txn2 = create_test_txn(Account(1), Contract::User(0xC2));
    
    // Queue first transaction
    assert!(queue.queue_or_return(0, txn1).is_none());
    
    // Queue second transaction from same account, different use case
    assert!(queue.queue_or_return(1, txn2).is_none());
    
    // Pop first transaction (output_idx = 0)
    queue.bump_output_idx(0);
    let popped = queue.pop_head(false);
    assert!(popped.is_some());
    
    // Check internal state: Contract C2 use case should have delay = 0 + 1 + 4 = 5
    // But due to bug, it will have delay = 0 + 1 = 1
    
    // At output_idx = 1, C2 transaction should NOT be ready yet
    queue.bump_output_idx(1);
    let should_be_none = queue.pop_head(true);  // only_if_ready = true
    
    // BUG: This will return Some when it should return None
    // C2 transaction is ready at output_idx=1, but should only be ready at output_idx=5
    assert!(should_be_none.is_none(), "Use case C2 ready too early - spread factor bypassed!");
}
```

## Notes

The vulnerability exists specifically at the intersection of account-based spreading and use-case-based spreading. When an account that's already in the delayed queue switches to a new use case, the system fails to apply the use_case_spread_factor to that new use case. This creates an asymmetry where:

- New use cases from fresh transactions: Correctly delayed by `output_idx + 1 + spread_factor`
- New use cases from account switching: Incorrectly delayed by only `output_idx + 1`

The impact is limited by the magnitude of the spread factor (default: 4 positions), but the principle violation is clear and exploitable. The fix is straightforward and should be applied to maintain consistency across all code paths that create new use cases.

### Citations

**File:** consensus/src/transaction_shuffler/use_case_aware/delayed_queue.rs (L390-399)
```rust
                    hash_map::Entry::Vacant(entry) => {
                        // Use case not tracked previously, try_delay_till = output_idx + 1
                        let new_use_case = entry.insert(UseCase::new_with_account(
                            self.output_idx + 1,
                            address,
                            account,
                        ));
                        self.use_cases_by_delay
                            .strict_insert(new_use_case.delay_key(), new_use_case_key.clone());
                    },
```

**File:** consensus/src/transaction_shuffler/use_case_aware/delayed_queue.rs (L483-484)
```rust
        let use_case_try_delay_till =
            self.output_idx + 1 + self.config.use_case_spread_factor(&use_case_key);
```

**File:** consensus/src/transaction_shuffler/use_case_aware/delayed_queue.rs (L498-503)
```rust
            hash_map::Entry::Vacant(vacant) => {
                let use_case = UseCase::new_empty(use_case_try_delay_till, input_idx);
                self.use_case_placeholders_by_delay
                    .strict_insert(use_case.delay_key(), use_case_key);
                vacant.insert(use_case);
            },
```

**File:** types/src/on_chain_config/execution_config.rs (L244-249)
```rust
        TransactionShufflerType::UseCaseAware {
            sender_spread_factor: 32,
            platform_use_case_spread_factor: 0,
            user_use_case_spread_factor: 4,
        }
    }
```
