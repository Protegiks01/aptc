# Audit Report

## Title
Table Native Function Gas Bypass: Value Serialization Cost Not Charged in `native_add_box()`

## Summary
The `native_add_box()` function only charges gas for key serialization but not for value serialization, allowing attackers to force validators to perform expensive BCS serialization of large values while paying minimal gas during native function execution. The value serialization occurs later in `into_change_set()` after the gas meter is no longer accessible.

## Finding Description

The table native implementation contains a gas accounting flaw where CPU costs for value serialization are not properly charged during native function execution.

In `native_add_box()`, only the **key** is serialized and charged for gas: [1](#0-0) 

The value is stored as a `Value` object without serialization: [2](#0-1) 

The actual value serialization happens later when `into_change_set()` is called during session finalization: [3](#0-2) 

The critical issue is that `finish()` and subsequently `into_change_set()` have no access to a gas meter: [4](#0-3) [5](#0-4) 

The serialization work happens in `serialize_value()` using BCS serialization: [6](#0-5) 

This occurs in the execution flow after transaction execution but before gas charging for the change set: [7](#0-6) 

**Attack Scenario:**
1. Attacker creates a table with `Table<u8, vector<u8>>`
2. Calls `add_box()` with key = `1` (1 byte) and value = `vector::empty<u8>` filled with 1MB of data
3. Native function charges: BASE (4411) + 36 × 1 = 4,447 internal gas for key serialization
4. Validator must later serialize 1MB value during `into_change_set()`: expected cost of 36 × 1,048,576 = 37,748,736 internal gas, but **zero is charged**
5. Storage fees (charged separately) account for the stored size, not the CPU cost of BCS serialization

The gas parameter for BCS serialization is consistently 36 internal gas per byte: [8](#0-7) [9](#0-8) 

This creates an ~8,500x discrepancy between gas paid and CPU work performed for a 1MB value.

## Impact Explanation

**High Severity** - This qualifies as validator node slowdown per the Aptos bug bounty criteria:

- Attackers can craft transactions forcing disproportionate CPU work (BCS serialization of megabyte-scale values) while paying minimal native function gas
- The gas parameters show serialization should cost 36 internal gas per byte, but this only applies to keys, not values
- While storage fees eventually charge for stored bytes, the CPU serialization work occurs in a non-metered context before storage fees are applied
- Repeated exploitation could cause validator performance degradation through CPU exhaustion
- Transaction limits (1MB per write operation, 10MB per transaction) bound but do not prevent the attack
- Does not cause consensus failures or fund loss, but degrades network performance through resource exhaustion

## Likelihood Explanation

**High Likelihood:**
- Exploitable by any transaction sender with no special privileges
- Simple to execute: create table and call `add()` with small key and large value
- No prerequisites beyond transaction submission capability
- Attack is economically viable as storage fees don't fully compensate for CPU serialization cost discrepancy
- Can be repeated across multiple transactions to amplify impact
- No complex timing or state requirements

## Recommendation

Charge gas for value serialization in `native_add_box()` by either:

1. **Immediate serialization approach**: Serialize the value during native function execution and charge accordingly
2. **Deferred charging mechanism**: Pass a gas meter reference through `into_change_set()` to charge for serialization work when it occurs
3. **Pre-charge estimation**: Estimate serialization cost based on value size and charge upfront in the native function

The fix should ensure that the CPU cost of BCS serialization for table values is properly metered at 36 internal gas per byte, consistent with other serialization operations.

## Proof of Concept

The vulnerability can be demonstrated by creating a Move module that:
1. Creates a `Table<u8, vector<u8>>`
2. Adds an entry with a 1-byte key and 1MB value
3. Measures the gas charged in the native function (expected: ~4,447 internal gas)
4. Compares against the expected serialization cost (expected: ~37.7M internal gas)

The gas discrepancy can be observed through transaction profiling showing minimal native function gas consumption relative to validator CPU time spent in serialization.

## Notes

- A TODO comment exists in the code suggesting developers are aware of gas charging timing issues, though not specifically for value serialization bypass
- Storage fees are charged after serialization based on size, but these compensate for long-term storage costs, not CPU serialization work
- The issue affects all table operations that store values (`add_box`, `upsert_box`), not just additions
- The severity should be classified as **High** per Aptos bug bounty criteria for "Validator Node Slowdowns" rather than Medium as originally stated

### Citations

**File:** aptos-move/framework/table-natives/src/lib.rs (L145-148)
```rust
    pub fn into_change_set(
        self,
        function_value_extension: &impl FunctionValueExtension,
    ) -> PartialVMResult<TableChangeSet> {
```

**File:** aptos-move/framework/table-natives/src/lib.rs (L163-194)
```rust
            for (key, gv) in content {
                let op = match gv.into_effect() {
                    Some(op) => op,
                    None => continue,
                };

                match op {
                    Op::New(val) => {
                        entries.insert(
                            key,
                            Op::New(serialize_value(
                                function_value_extension,
                                &value_layout_info,
                                &val,
                            )?),
                        );
                    },
                    Op::Modify(val) => {
                        entries.insert(
                            key,
                            Op::Modify(serialize_value(
                                function_value_extension,
                                &value_layout_info,
                                &val,
                            )?),
                        );
                    },
                    Op::Delete => {
                        entries.insert(key, Op::Delete);
                    },
                }
            }
```

**File:** aptos-move/framework/table-natives/src/lib.rs (L411-412)
```rust
    let key_bytes = serialize_key(&function_value_extension, &table.key_layout, &key)?;
    let key_cost = ADD_BOX_PER_BYTE_SERIALIZED * NumBytes::new(key_bytes.len() as u64);
```

**File:** aptos-move/framework/table-natives/src/lib.rs (L428-428)
```rust
    let res = match gv.move_to(val) {
```

**File:** aptos-move/framework/table-natives/src/lib.rs (L680-702)
```rust
fn serialize_value(
    function_value_extension: &dyn FunctionValueExtension,
    layout_info: &LayoutInfo,
    val: &Value,
) -> PartialVMResult<(Bytes, Option<TriompheArc<MoveTypeLayout>>)> {
    let max_value_nest_depth = function_value_extension.max_value_nest_depth();
    let serialization_result = if layout_info.contains_delayed_fields {
        // Value contains delayed fields, so we should be able to serialize it.
        ValueSerDeContext::new(max_value_nest_depth)
            .with_delayed_fields_serde()
            .with_func_args_deserialization(function_value_extension)
            .serialize(val, layout_info.layout.as_ref())?
            .map(|bytes| (bytes.into(), Some(layout_info.layout.clone())))
    } else {
        // No delayed fields, make sure serialization fails if there are any
        // native values.
        ValueSerDeContext::new(max_value_nest_depth)
            .with_func_args_deserialization(function_value_extension)
            .serialize(val, layout_info.layout.as_ref())?
            .map(|bytes| (bytes.into(), None))
    };
    serialization_result.ok_or_else(|| partial_extension_error("cannot serialize table value"))
}
```

**File:** aptos-move/aptos-vm/src/move_vm_ext/session/mod.rs (L161-165)
```rust
    pub fn finish(
        self,
        configs: &ChangeSetConfigs,
        module_storage: &impl ModuleStorage,
    ) -> VMResult<VMChangeSet> {
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1081-1096)
```rust
        let user_session_change_set = self.resolve_pending_code_publish_and_finish_user_session(
            session,
            resolver,
            code_storage,
            gas_meter,
            traversal_context,
            change_set_configs,
        )?;

        let epilogue_session = self.charge_change_set_and_respawn_session(
            user_session_change_set,
            resolver,
            code_storage,
            gas_meter,
            txn_data,
        )?;
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/table.rs (L22-23)
```rust
        [add_box_base: InternalGas, "add_box.base", 4411],
        [add_box_per_byte_serialized: InternalGasPerByte, "add_box.per_byte_serialized", 36],
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/move_stdlib.rs (L20-20)
```rust
        [bcs_to_bytes_per_byte_serialized: InternalGasPerByte, "bcs.to_bytes.per_byte_serialized", 36],
```
