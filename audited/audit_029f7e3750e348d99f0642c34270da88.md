# Audit Report

## Title
Distance-from-Validators Spoofing Vulnerability in Peer Monitoring Service Enables Malicious Peer Prioritization

## Summary
The peer monitoring service validation logic allows untrusted peers (with `PeerRole::Unknown`) to report arbitrary distances from validators between 2-100 without verification. This false distance information is then used by critical components (consensus observer, mempool) for peer prioritization, enabling malicious peers to be preferentially selected over honest peers for consensus subscriptions and transaction broadcasting.

## Finding Description

The vulnerability exists in the distance validation logic where untrusted peers can claim false network distances. The validation in `NetworkInfoState` performs strict role-based checks for distances 0 and 1, but only performs a boundary check for distances ≥ 2. [1](#0-0) [2](#0-1) 

During the Noise handshake, untrusted peers that are not in the `trusted_peers` set are assigned `PeerRole::Unknown`: [3](#0-2) 

These untrusted peers can then report any distance from 2-100, which passes validation because the check at line 139 only verifies `distance_from_validators <= MAX_DISTANCE_FROM_VALIDATORS` without validating the claim's truthfulness.

**Attack Flow:**
1. Attacker runs malicious full nodes and connects to victim PFN/VFN on the public network
2. During handshake, attacker nodes receive `PeerRole::Unknown` (not in trusted set)
3. Attacker responds to `GetNetworkInformation` requests with false low distance (e.g., 2-5) instead of actual distance (e.g., 50-100)
4. Validation passes because distance ≥ 2 only checks the upper bound
5. Consensus observer prioritizes these malicious peers for subscriptions based on distance: [4](#0-3) 

The consensus observer explicitly prioritizes distance over latency (line 280-282), sorting peers by distance first in ascending order (lower distances first). This means malicious peers claiming distance=2 will be selected before honest peers with distance=10+.

6. Mempool also uses distance for peer prioritization: [5](#0-4) [6](#0-5) 

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos bug bounty program for the following reasons:

1. **Significant Protocol Violation**: The vulnerability undermines the network topology trust model by allowing malicious peers to manipulate their prioritization in consensus-critical components.

2. **Consensus Observer Impact**: The consensus observer is used by full nodes to efficiently follow consensus without participating directly. Malicious peers prioritized for subscriptions can:
   - Delay consensus updates causing synchronization lag
   - Provide stale consensus information
   - Cause affected nodes to fall behind the network

3. **Affected Nodes**: Public Full Nodes (PFNs) are most vulnerable as they accept connections from untrusted peers. This could affect:
   - Wallet backends relying on PFNs for transaction submission
   - API nodes serving blockchain data
   - Archive nodes maintaining historical state

4. **Liveness Degradation**: While not a consensus safety violation, this enables liveness attacks on affected nodes, fitting the "Validator node slowdowns" and "Significant protocol violations" categories of High severity issues.

## Likelihood Explanation

**Likelihood: HIGH**

This vulnerability is highly likely to be exploited because:

1. **Low Barrier to Entry**: Any attacker can run full nodes and connect to public networks without authentication requirements
2. **Simple Exploitation**: Requires only modifying the `GetNetworkInformation` response to report a false distance (2-5 lines of code)
3. **No Detection Mechanism**: No cross-validation exists to verify distance claims against network topology
4. **Immediate Impact**: Malicious peers are immediately prioritized upon connection
5. **Scalable Attack**: Attacker can run multiple malicious nodes to increase probability of selection

The attack requires no special privileges, insider knowledge, or complex setup—just running modified full node software.

## Recommendation

Implement distance claim verification through cross-validation:

**Option 1: Transitive Distance Verification**
When a peer reports distance N, verify that at least one of its connected peers reports distance N-1. This creates a chain of trust back to validators.

**Option 2: Role-Based Distance Bounds**
Extend strict validation to all distance values based on peer role:
```rust
// In network_info.rs, handle_monitoring_service_response
match network_info_response.distance_from_validators {
    0 => {
        // Existing validator check
    },
    1 => {
        // Existing VFN check
    },
    distance_from_validators => {
        // NEW: For Unknown peers, apply maximum distance or exclude from prioritization
        let max_untrusted_distance = if peer_metadata.get_connection_metadata().role == PeerRole::Unknown {
            // Deprioritize unknown peers by treating them as maximum distance
            MAX_DISTANCE_FROM_VALIDATORS
        } else {
            distance_from_validators
        };
        
        // Update validation to use adjusted distance
        distance_from_validators <= MAX_DISTANCE_FROM_VALIDATORS
    },
}
```

**Option 3: Exclude Untrusted Peers from Distance-Based Prioritization**
Modify consensus observer and mempool to ignore distance claims from `PeerRole::Unknown` peers, treating them as lowest priority regardless of reported distance.

## Proof of Concept

```rust
// Test demonstrating vulnerability
#[tokio::test]
async fn test_malicious_peer_distance_spoofing() {
    use aptos_config::config::{NodeConfig, PeerRole, RoleType};
    use aptos_network::application::metadata::PeerMetadata;
    use aptos_peer_monitoring_service_types::response::NetworkInformationResponse;
    use peer_monitoring_service_client::peer_states::network_info::NetworkInfoState;
    
    // Setup: Create a VFN node that will be the victim
    let mut node_config = NodeConfig::default();
    node_config.base.role = RoleType::FullNode;
    let time_service = TimeService::mock();
    let mut network_info_state = NetworkInfoState::new(node_config, time_service);
    
    // Attack: Malicious peer with PeerRole::Unknown reports distance=2
    let malicious_peer = PeerNetworkId::new(NetworkId::Public, PeerId::random());
    let malicious_peer_metadata = create_peer_metadata_with_role(PeerRole::Unknown);
    
    // Malicious response claiming distance=2 (actually should be ~50)
    let malicious_response = PeerMonitoringServiceResponse::NetworkInformation(
        NetworkInformationResponse {
            connected_peers: Default::default(),
            distance_from_validators: 2, // FALSE CLAIM
        }
    );
    
    // Process response - THIS SHOULD FAIL but currently PASSES
    network_info_state.handle_monitoring_service_response(
        &malicious_peer,
        malicious_peer_metadata,
        PeerMonitoringServiceRequest::GetNetworkInformation,
        malicious_response,
        0.0,
    );
    
    // Verify: Malicious peer's false distance is accepted
    let stored_distance = network_info_state
        .get_latest_network_info_response()
        .unwrap()
        .distance_from_validators;
    
    assert_eq!(stored_distance, 2); // FALSE DISTANCE ACCEPTED!
    
    // Impact: In consensus observer peer sorting, this malicious peer
    // will now be prioritized over honest peers with truthful distance=10+
}
```

**Notes**

The vulnerability specifically affects Public Full Nodes that accept untrusted inbound connections. Validators and VFNs using mutual authentication with configured trusted peers are not affected. However, the broader ecosystem of public infrastructure (RPC nodes, indexers, wallets) commonly runs PFNs and would be vulnerable to this attack vector.

The fix should balance security with network openness—overly restrictive validation could prevent legitimate new peers from joining, while insufficient validation enables the current exploit. A reputation-based approach that initially distrusts distance claims from new peers until they demonstrate consistency would provide defense in depth.

### Citations

**File:** peer-monitoring-service/types/src/lib.rs (L22-22)
```rust
pub const MAX_DISTANCE_FROM_VALIDATORS: u64 = 100; // Nodes that aren't connected to the network
```

**File:** peer-monitoring-service/client/src/peer_states/network_info.rs (L118-154)
```rust
        let is_valid_depth = match network_info_response.distance_from_validators {
            0 => {
                // Verify the peer is a validator and has the correct network id
                let peer_is_validator = peer_metadata.get_connection_metadata().role.is_validator();
                let peer_has_correct_network = match self.base_config.role {
                    RoleType::Validator => network_id.is_validator_network(), // We're a validator
                    RoleType::FullNode => network_id.is_vfn_network(),        // We're a VFN
                };
                peer_is_validator && peer_has_correct_network
            },
            1 => {
                // Verify the peer is a VFN and has the correct network id
                let peer_is_vfn = peer_metadata.get_connection_metadata().role.is_vfn();
                let peer_has_correct_network = match self.base_config.role {
                    RoleType::Validator => network_id.is_vfn_network(), // We're a validator
                    RoleType::FullNode => network_id.is_public_network(), // We're a VFN or PFN
                };
                peer_is_vfn && peer_has_correct_network
            },
            distance_from_validators => {
                // The distance must be less than or equal to the max
                distance_from_validators <= MAX_DISTANCE_FROM_VALIDATORS
            },
        };

        // If the depth did not pass our sanity checks, handle a failure
        if !is_valid_depth {
            warn!(LogSchema::new(LogEntry::NetworkInfoRequest)
                .event(LogEvent::InvalidResponse)
                .peer(peer_network_id)
                .message(&format!(
                    "Peer returned invalid depth from validators: {}",
                    network_info_response.distance_from_validators
                )));
            self.handle_request_failure();
            return;
        }
```

**File:** network/framework/src/noise/handshake.rs (L384-426)
```rust
            HandshakeAuthMode::MaybeMutual(peers_and_metadata) => {
                let trusted_peers = peers_and_metadata.get_trusted_peers(&network_id)?;
                let trusted_peer = trusted_peers.get(&remote_peer_id).cloned();
                match trusted_peer {
                    Some(peer) => {
                        Self::authenticate_inbound(remote_peer_short, &peer, &remote_public_key)
                    },
                    None => {
                        // The peer is not in the trusted peer set. Verify that the Peer ID is
                        // constructed correctly from the public key.
                        let derived_remote_peer_id =
                            aptos_types::account_address::from_identity_public_key(
                                remote_public_key,
                            );
                        if derived_remote_peer_id != remote_peer_id {
                            // The peer ID is not constructed correctly from the public key
                            Err(NoiseHandshakeError::ClientPeerIdMismatch(
                                remote_peer_short,
                                remote_peer_id,
                                derived_remote_peer_id,
                            ))
                        } else {
                            // Try to infer the role from the network context
                            if self.network_context.role().is_validator() {
                                if network_id.is_vfn_network() {
                                    // Inbound connections to validators on the VFN network must be VFNs
                                    Ok(PeerRole::ValidatorFullNode)
                                } else {
                                    // Otherwise, they're unknown. Validators will connect through
                                    // authenticated channels (on the validator network) so shouldn't hit
                                    // this, and PFNs will connect on public networks (which aren't common).
                                    Ok(PeerRole::Unknown)
                                }
                            } else {
                                // We're a VFN or PFN. VFNs get no inbound connections on the vfn network
                                // (so the peer won't be a validator). Thus, we're on the public network
                                // so mark the peer as unknown.
                                Ok(PeerRole::Unknown)
                            }
                        }
                    },
                }
            },
```

**File:** consensus/src/consensus_observer/observer/subscription_utils.rs (L275-349)
```rust
/// Sorts the peers by subscription optimality (in descending order of
/// optimality). This requires: (i) sorting the peers by distance from the
/// validator set and ping latency (lower values are more optimal); and (ii)
/// filtering out peers that don't support consensus observer.
///
/// Note: we prioritize distance over latency as we want to avoid close
/// but not up-to-date peers. If peers don't have sufficient metadata
/// for sorting, they are given a lower priority.
pub fn sort_peers_by_subscription_optimality(
    peers_and_metadata: &HashMap<PeerNetworkId, PeerMetadata>,
) -> Vec<PeerNetworkId> {
    // Group peers and latencies by validator distance, i.e., distance -> [(peer, latency)]
    let mut unsupported_peers = Vec::new();
    let mut peers_and_latencies_by_distance = BTreeMap::new();
    for (peer_network_id, peer_metadata) in peers_and_metadata {
        // Verify that the peer supports consensus observer
        if !supports_consensus_observer(peer_metadata) {
            unsupported_peers.push(*peer_network_id);
            continue; // Skip the peer
        }

        // Get the distance and latency for the peer
        let distance = get_distance_for_peer(peer_network_id, peer_metadata);
        let latency = get_latency_for_peer(peer_network_id, peer_metadata);

        // If the distance is not found, use the maximum distance
        let distance =
            distance.unwrap_or(aptos_peer_monitoring_service_types::MAX_DISTANCE_FROM_VALIDATORS);

        // If the latency is not found, use a large latency
        let latency = latency.unwrap_or(MAX_PING_LATENCY_SECS);

        // Add the peer and latency to the distance group
        peers_and_latencies_by_distance
            .entry(distance)
            .or_insert_with(Vec::new)
            .push((*peer_network_id, OrderedFloat(latency)));
    }

    // If there are peers that don't support consensus observer, log them
    if !unsupported_peers.is_empty() {
        info!(
            LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                "Found {} peers that don't support consensus observer! Peers: {:?}",
                unsupported_peers.len(),
                unsupported_peers
            ))
        );
    }

    // Sort the peers by distance and latency. Note: BTreeMaps are
    // sorted by key, so the entries will be sorted by distance in ascending order.
    let mut sorted_peers_and_latencies = Vec::new();
    for (_, mut peers_and_latencies) in peers_and_latencies_by_distance {
        // Sort the peers by latency
        peers_and_latencies.sort_by_key(|(_, latency)| *latency);

        // Add the peers to the sorted list (in sorted order)
        sorted_peers_and_latencies.extend(peers_and_latencies);
    }

    // Log the sorted peers and latencies
    info!(
        LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
            "Sorted {} peers by subscription optimality! Peers and latencies: {:?}",
            sorted_peers_and_latencies.len(),
            sorted_peers_and_latencies
        ))
    );

    // Only return the sorted peers (without the latencies)
    sorted_peers_and_latencies
        .into_iter()
        .map(|(peer, _)| peer)
        .collect()
```

**File:** mempool/src/shared_mempool/priority.rs (L103-109)
```rust
        // Otherwise, compare by peer distance from the validators.
        // This avoids badly configured/connected peers (e.g., broken VN-VFN connections).
        let distance_ordering =
            compare_validator_distance(monitoring_metadata_a, monitoring_metadata_b);
        if !distance_ordering.is_eq() {
            return distance_ordering; // Only return if it's not equal
        }
```

**File:** mempool/src/shared_mempool/priority.rs (L615-638)
```rust
fn compare_validator_distance(
    monitoring_metadata_a: &Option<&PeerMonitoringMetadata>,
    monitoring_metadata_b: &Option<&PeerMonitoringMetadata>,
) -> Ordering {
    // Get the validator distance from the monitoring metadata
    let validator_distance_a = get_distance_from_validators(monitoring_metadata_a);
    let validator_distance_b = get_distance_from_validators(monitoring_metadata_b);

    // Compare the distances
    match (validator_distance_a, validator_distance_b) {
        (Some(validator_distance_a), Some(validator_distance_b)) => {
            // Prioritize the peer with the lowest validator distance
            validator_distance_a.cmp(&validator_distance_b).reverse()
        },
        (Some(_), None) => {
            Ordering::Greater // Prioritize the peer with a validator distance
        },
        (None, Some(_)) => {
            Ordering::Less // Prioritize the peer with a validator distance
        },
        (None, None) => {
            Ordering::Equal // Neither peer has a validator distance
        },
    }
```
