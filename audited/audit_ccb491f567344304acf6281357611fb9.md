# Audit Report

## Title
Panic-Induced Denial of Service When Using Keyless/Abstraction Accounts as Multi-Agent Secondary Signers

## Summary
The `sign_multi_agent_with_transaction_builder()` and `sign_fee_payer_with_transaction_builder()` functions in the SDK will panic and crash when any secondary signer (or fee payer) uses a Keyless, FederatedKeyless, or Account Abstraction authenticator. This occurs because these functions unconditionally call `private_key()` on all signers, which contains unimplemented `todo!()` macros for non-PrivateKey authenticator types. [1](#0-0) 

## Finding Description

The vulnerability exists in the SDK's transaction signing infrastructure. The `LocalAccount` struct supports multiple authenticator types through the `LocalAccountAuthenticator` enum: [2](#0-1) 

However, the `sign_multi_agent_with_transaction_builder()` function attempts to extract private keys from all secondary signers: [3](#0-2) 

The `private_key()` method contains `todo!()` macros for all non-PrivateKey authenticator types: [4](#0-3) 

In Rust, the `todo!()` macro causes an **unrecoverable panic** that crashes the entire application. This means:

1. Any attempt to use a Keyless account as a secondary signer in a multi-agent transaction will panic
2. Any attempt to use a FederatedKeyless account as a secondary signer will panic  
3. Any attempt to use an Abstraction or DerivableAbstraction account as a secondary signer will panic

The same vulnerability exists in `sign_fee_payer_with_transaction_builder()`: [5](#0-4) 

This function calls `private_key()` on both secondary signers (line 418) and the fee payer (line 438), causing panics for non-PrivateKey authenticators.

**Protocol-Level Support Exists**: The Aptos protocol itself supports keyless accounts as secondary signers. The `multi_agent_common_prologue` validation function accepts any account type: [6](#0-5) 

The protocol checks only that the account exists and has the correct authentication key—it does not restrict authenticator types. This confirms that keyless secondary signers are a legitimate use case that the SDK fails to support.

## Impact Explanation

**Severity: High** per Aptos Bug Bounty criteria - "API crashes"

The SDK constitutes the primary API for building Aptos applications. When this vulnerability is triggered:

1. **Complete Application Crash**: The `todo!()` macro causes an unrecoverable panic that terminates the entire process
2. **No Error Recovery**: Unlike normal errors that can be caught and handled, panics in production code crash the application
3. **Denial of Service**: Any application using the SDK to build multi-agent transactions with keyless accounts will crash
4. **User Impact**: Keyless accounts are a production feature designed for improved user experience. Users attempting to use these accounts in multi-agent scenarios will experience application crashes

This meets the **High Severity** category: "API crashes" and "Significant protocol violations" (the SDK violates the protocol's support for any authenticator type in multi-agent transactions).

## Likelihood Explanation

**Likelihood: High**

This vulnerability is highly likely to be exploited (even unintentionally):

1. **Keyless Accounts Are Production Features**: Aptos actively promotes keyless accounts for improved UX. Code infrastructure exists throughout the codebase: [7](#0-6) 

2. **Multi-Agent Transactions Are Common**: Multi-agent transactions are a standard feature for scenarios like:
   - Escrow services requiring multiple parties
   - Multi-signature wallets
   - Cross-account operations

3. **No Warning or Documentation**: The SDK provides no warning that keyless accounts cannot be used as secondary signers. The functions accept `&LocalAccount` which includes keyless variants.

4. **Easy to Trigger**: Any developer who:
   - Creates a keyless account (legitimate use case)
   - Attempts to use it as a secondary signer in a multi-agent transaction
   - Triggers the panic immediately

## Recommendation

Implement proper support for keyless and account abstraction authenticators in multi-agent transactions. The SDK should either:

**Option 1 (Preferred)**: Extend the lower-level signing functions to support all authenticator types. Follow the pattern used in `sign_aa_transaction_with_transaction_builder()`: [8](#0-7) 

However, note that `auth()` also has `todo!()` for keyless: [9](#0-8) 

Full fix requires:
1. Implement `Auth` enum variants for keyless accounts in the types layer
2. Implement the `auth()` method for keyless accounts  
3. Extend `sign_multi_agent_with_transaction_builder()` to use `auth()` instead of `private_key()`
4. Update the lower-level `sign_multi_agent` to accept `Auth` parameters like `sign_aa_transaction` does

**Option 2 (Immediate)**: Add explicit validation that returns a proper error instead of panicking:

```rust
pub fn sign_multi_agent_with_transaction_builder(
    &self,
    secondary_signers: Vec<&Self>,
    builder: TransactionBuilder,
) -> Result<SignedTransaction> {
    // Validate all signers use PrivateKey authenticators
    for signer in &secondary_signers {
        if !matches!(signer.auth, LocalAccountAuthenticator::PrivateKey(_)) {
            return Err(anyhow::anyhow!(
                "Multi-agent transactions currently only support Ed25519 private key authenticators. \
                 Keyless and Account Abstraction authenticators are not yet supported."
            ));
        }
    }
    
    // Existing implementation...
}
```

## Proof of Concept

```rust
#[cfg(test)]
mod test {
    use super::*;
    use crate::transaction_builder::TransactionBuilder;
    use aptos_types::transaction::EntryFunction;
    
    #[test]
    #[should_panic(expected = "not yet implemented")]
    fn test_keyless_secondary_signer_panic() {
        // Create a regular account as primary signer
        let mut rng = rand::thread_rng();
        let primary = LocalAccount::generate(&mut rng);
        
        // Create a keyless account as secondary signer
        let keyless_secondary = LocalAccount::generate_for_testing(&mut rng, true);
        
        // Build a simple transaction
        let builder = TransactionBuilder::new(
            EntryFunction::new(
                ModuleId::new(AccountAddress::ONE, ident_str!("coin").to_owned()),
                ident_str!("transfer").to_owned(),
                vec![],
                vec![
                    bcs::to_bytes(&AccountAddress::random()).unwrap(),
                    bcs::to_bytes(&100u64).unwrap(),
                ],
            ),
            1_000_000,
            1,
        );
        
        // This will panic with "not yet implemented"
        // because keyless_secondary.private_key() hits the todo!() macro
        let _signed_txn = primary.sign_multi_agent_with_transaction_builder(
            vec![&keyless_secondary],
            builder,
        );
    }
}
```

**Expected Result**: Panic with message "not yet implemented"  
**Actual Result**: Application crashes due to unimplemented `private_key()` for keyless accounts

This PoC demonstrates that the SDK crashes when legitimate keyless accounts are used as secondary signers, confirming the denial of service vulnerability.

## Notes

The codebase shows clear intent to support these authenticator types—there's a complete `sign_aa_transaction_with_transaction_builder()` function designed for account abstraction. However, the implementation is incomplete, leaving `todo!()` markers that cause production crashes. The protocol layer fully supports keyless accounts as secondary signers, but the SDK layer fails to provide the necessary implementation.

### Citations

**File:** sdk/src/types.rs (L59-66)
```rust
#[derive(Debug)]
enum LocalAccountAuthenticator {
    PrivateKey(AccountKey),
    Keyless(KeylessAccount),
    FederatedKeyless(FederatedKeylessAccount),
    Abstraction(AbstractedAccount), // TODO: Add support for keyless authentication
    DerivableAbstraction(DomainAbstractedAccount), // TODO: Add support for keyless authentication
}
```

**File:** sdk/src/types.rs (L173-183)
```rust
    pub fn new_keyless(
        address: AccountAddress,
        keyless_account: KeylessAccount,
        sequence_number: u64,
    ) -> Self {
        Self {
            address,
            auth: LocalAccountAuthenticator::Keyless(keyless_account),
            sequence_number: AtomicU64::new(sequence_number),
        }
    }
```

**File:** sdk/src/types.rs (L370-404)
```rust
    pub fn sign_multi_agent_with_transaction_builder(
        &self,
        secondary_signers: Vec<&Self>,
        builder: TransactionBuilder,
    ) -> SignedTransaction {
        let secondary_signer_addresses = secondary_signers
            .iter()
            .map(|signer| signer.address())
            .collect();
        let secondary_signer_privkeys = secondary_signers
            .iter()
            .map(|signer| signer.private_key())
            .collect();

        let raw_txn = if builder.has_nonce() {
            // Do not increment sequence number for orderless transactions.
            builder
                .sender(self.address())
                .sequence_number(u64::MAX)
                .build()
        } else {
            builder
                .sender(self.address())
                .sequence_number(self.increment_sequence_number())
                .build()
        };
        raw_txn
            .sign_multi_agent(
                self.private_key(),
                secondary_signer_addresses,
                secondary_signer_privkeys,
            )
            .expect("Signing multi agent txn failed")
            .into_inner()
    }
```

**File:** sdk/src/types.rs (L406-442)
```rust
    pub fn sign_fee_payer_with_transaction_builder(
        &self,
        secondary_signers: Vec<&Self>,
        fee_payer_signer: &Self,
        builder: TransactionBuilder,
    ) -> SignedTransaction {
        let secondary_signer_addresses = secondary_signers
            .iter()
            .map(|signer| signer.address())
            .collect();
        let secondary_signer_privkeys = secondary_signers
            .iter()
            .map(|signer| signer.private_key())
            .collect();
        let raw_txn = if builder.has_nonce() {
            // Do not increment sequence number for orderless transactions.
            builder
                .sender(self.address())
                .sequence_number(u64::MAX)
                .build()
        } else {
            builder
                .sender(self.address())
                .sequence_number(self.increment_sequence_number())
                .build()
        };
        raw_txn
            .sign_fee_payer(
                self.private_key(),
                secondary_signer_addresses,
                secondary_signer_privkeys,
                fee_payer_signer.address(),
                fee_payer_signer.private_key(),
            )
            .expect("Signing multi agent txn failed")
            .into_inner()
    }
```

**File:** sdk/src/types.rs (L444-475)
```rust
    pub fn sign_aa_transaction_with_transaction_builder(
        &self,
        secondary_signers: Vec<&Self>,
        fee_payer_signer: Option<&Self>,
        builder: TransactionBuilder,
    ) -> SignedTransaction {
        let secondary_signer_addresses = secondary_signers
            .iter()
            .map(|signer| signer.address())
            .collect();
        let secondary_signer_auths = secondary_signers.iter().map(|a| a.auth()).collect();
        let raw_txn = if builder.has_nonce() {
            builder
                .sender(self.address())
                .sequence_number(u64::MAX)
                .build()
        } else {
            builder
                .sender(self.address())
                .sequence_number(self.increment_sequence_number())
                .build()
        };
        raw_txn
            .sign_aa_transaction(
                self.auth(),
                secondary_signer_addresses,
                secondary_signer_auths,
                fee_payer_signer.map(|fee_payer| (fee_payer.address(), fee_payer.auth())),
            )
            .expect("Signing aa txn failed")
            .into_inner()
    }
```

**File:** sdk/src/types.rs (L481-489)
```rust
    pub fn private_key(&self) -> &Ed25519PrivateKey {
        match &self.auth {
            LocalAccountAuthenticator::PrivateKey(key) => key.private_key(),
            LocalAccountAuthenticator::Keyless(_) => todo!(),
            LocalAccountAuthenticator::FederatedKeyless(_) => todo!(),
            LocalAccountAuthenticator::Abstraction(..) => todo!(),
            LocalAccountAuthenticator::DerivableAbstraction(..) => todo!(),
        }
    }
```

**File:** sdk/src/types.rs (L515-529)
```rust
    pub fn auth(&self) -> Auth<'_> {
        match &self.auth {
            LocalAccountAuthenticator::PrivateKey(key) => Auth::Ed25519(key.private_key()),
            LocalAccountAuthenticator::Keyless(_) => todo!(),
            LocalAccountAuthenticator::FederatedKeyless(_) => todo!(),
            LocalAccountAuthenticator::Abstraction(aa) => {
                Auth::Abstraction(aa.function_info.clone(), aa.sign_func.clone())
            },
            LocalAccountAuthenticator::DerivableAbstraction(aa) => Auth::DerivableAbstraction {
                function_info: aa.function_info.clone(),
                account_identity: aa.account_identity.clone(),
                sign_function: aa.sign_func.clone(),
            },
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/transaction_validation.move (L380-438)
```text
    fun multi_agent_common_prologue(
        secondary_signer_addresses: vector<address>,
        secondary_signer_public_key_hashes: vector<Option<vector<u8>>>,
        is_simulation: bool,
    ) {
        let num_secondary_signers = vector::length(&secondary_signer_addresses);
        assert!(
            vector::length(&secondary_signer_public_key_hashes) == num_secondary_signers,
            error::invalid_argument(PROLOGUE_ESECONDARY_KEYS_ADDRESSES_COUNT_MISMATCH),
        );

        let i = 0;
        while ({
            // spec {
            //     invariant i <= num_secondary_signers;
            //     invariant forall j in 0..i:
            //         account::exists_at(secondary_signer_addresses[j]);
            //     invariant forall j in 0..i:
            //         secondary_signer_public_key_hashes[j] == account::get_authentication_key(secondary_signer_addresses[j]) ||
            //             (features::spec_simulation_enhancement_enabled() && is_simulation && vector::is_empty(secondary_signer_public_key_hashes[j]));
            //         account::account_resource_exists_at(secondary_signer_addresses[j])
            //         && secondary_signer_public_key_hashes[j]
            //             == account::get_authentication_key(secondary_signer_addresses[j])
            //             || features::account_abstraction_enabled() && account_abstraction::using_native_authenticator(
            //             secondary_signer_addresses[j]
            //         ) && option::spec_some(secondary_signer_public_key_hashes[j]) == account_abstraction::native_authenticator(
            //         account::exists_at(secondary_signer_addresses[j])
            //         && secondary_signer_public_key_hashes[j]
            //             == account::spec_get_authentication_key(secondary_signer_addresses[j])
            //             || features::spec_account_abstraction_enabled() && account_abstraction::using_native_authenticator(
            //             secondary_signer_addresses[j]
            //         ) && option::spec_some(
            //             secondary_signer_public_key_hashes[j]
            //         ) == account_abstraction::spec_native_authenticator(
            //             secondary_signer_addresses[j]
            //         );
            // };
            (i < num_secondary_signers)
        }) {
            let secondary_address = *vector::borrow(&secondary_signer_addresses, i);
            assert!(account::exists_at(secondary_address), error::invalid_argument(PROLOGUE_EACCOUNT_DOES_NOT_EXIST));
            let signer_public_key_hash = *vector::borrow(&secondary_signer_public_key_hashes, i);
            if (!skip_auth_key_check(is_simulation, &signer_public_key_hash)) {
                if (option::is_some(&signer_public_key_hash)) {
                    assert!(
                        signer_public_key_hash == option::some(account::get_authentication_key(secondary_address)),
                        error::invalid_argument(PROLOGUE_EINVALID_ACCOUNT_AUTH_KEY)
                    );
                } else {
                    assert!(
                        allow_missing_txn_authentication_key(secondary_address),
                        error::invalid_argument(PROLOGUE_EINVALID_ACCOUNT_AUTH_KEY)
                    )
                };
            };

            i = i + 1;
        }
    }
```
