# Audit Report

## Title
DKG Transcript Deserialization DoS via Unbounded Vector Allocation

## Summary
A Byzantine validator can crash honest validator nodes by sending maliciously crafted DKG transcripts with inflated vector length claims in ULEB128 encoding. The vulnerability exists because BCS deserialization occurs without size limits before validation checks, allowing out-of-memory crashes during epoch transitions.

## Finding Description

The DKG (Distributed Key Generation) protocol exchanges `WeightedTranscript` structures containing vectors of elliptic curve points during epoch transitions. When a validator receives a DKG transcript from a peer, a critical two-level deserialization vulnerability exists:

**Level 1 (Network - Protected):** The outer `DKGMessage` is deserialized using `bcs::from_bytes_with_limit(bytes, 64)` with recursion depth limit and ~62 MiB decompressed size limit. [1](#0-0) [2](#0-1) 

**Level 2 (Application - Unprotected):** The inner `Transcript` deserialization uses `bcs::from_bytes()` WITHOUT any size limit: [3](#0-2) [4](#0-3) 

The `Transcript` structure contains multiple vector fields that are vulnerable: [5](#0-4) 

**Critical Issue:** Size validation via `check_sizes()` only occurs AFTER the transcript is fully deserialized and constructed: [6](#0-5) [7](#0-6) 

**Why RECURSION_LIMIT doesn't protect:** The recursion depth limit (64 levels) prevents deeply nested structures but does NOT prevent large flat vectors: [8](#0-7) 

A `Vec<G1Projective>` with 1 billion elements has recursion depth of only 1, bypassing this protection.

**Attack Execution:**
1. Byzantine validator crafts `transcript_bytes` with ULEB128-encoded vector length of 1,000,000,000 (5 bytes)
2. Adds minimal element data to stay under 62 MiB network limit
3. Sends `DKGMessage::TranscriptResponse` to target validators
4. Network layer deserializes outer message successfully
5. Application calls `bcs::from_bytes(transcript_bytes)` without limit
6. BCS attempts `Vec::with_capacity(1_000_000_000)` for G1Projective vectors
7. Memory allocation for ~48 GB fails, causing OOM crash
8. Node crashes before `check_sizes()` validation executes

## Impact Explanation

**High Severity** per Aptos bug bounty criteria:

**Validator Node Crashes:** A single Byzantine validator (< 1/3 threshold) can crash multiple honest validators by exploiting this deserialization bug during DKG protocol execution.

**DKG Protocol Disruption:** The DKG protocol is critical for on-chain randomness generation. Crashing validators during epoch transitions can:
- Delay epoch transitions
- Disrupt randomness beacon updates  
- Impact consensus liveness if sufficient validators crash simultaneously

**Within Threat Model:** The attack requires only a single Byzantine validator, well within AptosBFT's 1/3 Byzantine fault tolerance assumptions. No authentication bypass or collusion needed.

**Not Critical Severity:** The vulnerability doesn't cause permanent state corruption, fund theft, or consensus safety violations. The network can recover once the malicious validator stops sending crafted transcripts. This affects liveness, not safety.

## Likelihood Explanation

**High Likelihood** if a validator becomes Byzantine:

1. **Simple Execution:** Requires only crafting bytes with inflated ULEB128 length claimsâ€”no complex cryptographic attacks needed
2. **Critical Path Target:** DKG runs during every epoch transition, providing regular attack opportunities
3. **Deterministic Success:** Will reliably crash any node that deserializes the malicious transcript
4. **No Complex Timing:** Attack doesn't require precise timing or coordination
5. **Within Access Model:** Attacker must be a validator, but this is explicitly within the Byzantine fault model for consensus protocols

## Recommendation

Implement size-limited BCS deserialization for DKG transcripts:

**Fix 1:** Use `bcs::from_bytes_with_limit()` instead of `bcs::from_bytes()`:

```rust
// In types/src/dkg/mod.rs
pub(crate) fn verify(&self, verifier: &ValidatorVerifier) -> Result<()> {
    const MAX_TRANSCRIPT_SIZE: usize = 10 * 1024 * 1024; // 10 MiB limit
    let transcripts: Transcripts = bcs::from_bytes_with_limit(
        &self.transcript_bytes,
        MAX_TRANSCRIPT_SIZE
    ).context("Transcripts deserialization failed")?;
    RealDKG::verify_transcript_extra(&transcripts, verifier, true, None)
}
```

**Fix 2:** Add pre-deserialization size check:

```rust
// In dkg/src/transcript_aggregation/mod.rs
const MAX_TRANSCRIPT_BYTES: usize = 10 * 1024 * 1024;
ensure!(
    transcript_bytes.len() <= MAX_TRANSCRIPT_BYTES,
    "[DKG] transcript_bytes exceeds maximum allowed size"
);
```

**Fix 3:** Validate before allocation in the PVSS transcript implementation by checking length prefixes before constructing vectors.

## Proof of Concept

```rust
// Conceptual PoC - demonstrates the attack principle
use bcs;

fn craft_malicious_transcript() -> Vec<u8> {
    let mut bytes = Vec::new();
    
    // ULEB128 encode vector length: 1,000,000,000
    // This takes only ~5 bytes but claims gigabytes of allocation
    bytes.extend_from_slice(&[0x80, 0x94, 0xeb, 0xdc, 0x03]);
    
    // Add minimal element data to pass network size checks
    // (actual G1Projective elements would be 48 bytes each)
    bytes.extend_from_slice(&vec![0u8; 1000]); // Fake data
    
    bytes
}

// When honest validator receives and deserializes:
// let transcript = bcs::from_bytes::<Transcript>(&malicious_bytes);
// ^ This attempts Vec::with_capacity(1_000_000_000)
// ^ OOM crash occurs before size validation
```

## Notes

**Key Distinction:** This is NOT a traditional "network DoS" (excluded per bounty rules) but rather a **protocol-level deserialization vulnerability** causing validator process crashes. The Aptos framework explicitly includes "Validator node crashes" and "API Crashes" as valid High Severity impacts. The vulnerability exploits the gap between network-layer protections (which use size limits) and application-layer deserialization (which doesn't), allowing ULEB128-encoded length claims to trigger unbounded memory allocations before validation checks execute.

### Citations

**File:** network/framework/src/protocols/wire/handshake/v1/mod.rs (L38-39)
```rust
pub const USER_INPUT_RECURSION_LIMIT: usize = 32;
pub const RECURSION_LIMIT: usize = 64;
```

**File:** network/framework/src/protocols/wire/handshake/v1/mod.rs (L163-165)
```rust
            ProtocolId::DKGDirectSendCompressed | ProtocolId::DKGRpcCompressed => {
                Encoding::CompressedBcs(RECURSION_LIMIT)
            },
```

**File:** network/framework/src/protocols/wire/handshake/v1/mod.rs (L260-262)
```rust
    fn bcs_decode<T: DeserializeOwned>(&self, bytes: &[u8], limit: usize) -> anyhow::Result<T> {
        bcs::from_bytes_with_limit(bytes, limit).map_err(|e| anyhow!("{:?}", e))
    }
```

**File:** types/src/dkg/mod.rs (L83-87)
```rust
    pub(crate) fn verify(&self, verifier: &ValidatorVerifier) -> Result<()> {
        let transcripts: Transcripts = bcs::from_bytes(&self.transcript_bytes)
            .context("Transcripts deserialization failed")?;
        RealDKG::verify_transcript_extra(&transcripts, verifier, true, None)
    }
```

**File:** dkg/src/transcript_aggregation/mod.rs (L88-90)
```rust
        let transcript = bcs::from_bytes(transcript_bytes.as_slice()).map_err(|e| {
            anyhow!("[DKG] adding peer transcript failed with trx deserialization error: {e}")
        })?;
```

**File:** crates/aptos-dkg/src/pvss/das/weighted_protocol.rs (L50-72)
```rust
pub struct Transcript {
    /// Proofs-of-knowledge (PoKs) for the dealt secret committed in $c = g_2^{p(0)}$.
    /// Since the transcript could have been aggregated from other transcripts with their own
    /// committed secrets in $c_i = g_2^{p_i(0)}$, this is a vector of PoKs for all these $c_i$'s
    /// such that $\prod_i c_i = c$.
    ///
    /// Also contains BLS signatures from each player $i$ on that player's contribution $c_i$, the
    /// player ID $i$ and auxiliary information `aux[i]` provided during dealing.
    soks: Vec<SoK<G1Projective>>,
    /// Commitment to encryption randomness $g_1^{r_j} \in G_1, \forall j \in [W]$
    R: Vec<G1Projective>,
    /// Same as $R$ except uses $g_2$.
    R_hat: Vec<G2Projective>,
    /// First $W$ elements are commitments to the evaluations of $p(X)$: $g_1^{p(\omega^i)}$,
    /// where $i \in [W]$. Last element is $g_1^{p(0)}$ (i.e., the dealt public key).
    V: Vec<G1Projective>,
    /// Same as $V$ except uses $g_2$.
    V_hat: Vec<G2Projective>,
    /// ElGamal encryption of the $j$th share of player $i$:
    /// i.e., $C[s_i+j-1] = h_1^{p(\omega^{s_i + j - 1})} ek_i^{r_j}, \forall i \in [n], j \in [w_i]$.
    /// We sometimes denote $C[s_i+j-1]$ by C_{i, j}.
    C: Vec<G1Projective>,
}
```

**File:** crates/aptos-dkg/src/pvss/das/weighted_protocol.rs (L280-288)
```rust
    fn verify<A: Serialize + Clone>(
        &self,
        sc: &<Self as traits::Transcript>::SecretSharingConfig,
        pp: &Self::PublicParameters,
        spks: &[Self::SigningPubKey],
        eks: &[Self::EncryptPubKey],
        auxs: &[A],
    ) -> anyhow::Result<()> {
        self.check_sizes(sc)?;
```

**File:** crates/aptos-dkg/src/pvss/das/weighted_protocol.rs (L415-455)
```rust
    fn check_sizes(&self, sc: &WeightedConfigBlstrs) -> anyhow::Result<()> {
        let W = sc.get_total_weight();

        if self.V.len() != W + 1 {
            bail!(
                "Expected {} G_2 (polynomial) commitment elements, but got {}",
                W + 1,
                self.V.len()
            );
        }

        if self.V_hat.len() != W + 1 {
            bail!(
                "Expected {} G_2 (polynomial) commitment elements, but got {}",
                W + 1,
                self.V_hat.len()
            );
        }

        if self.R.len() != W {
            bail!(
                "Expected {} G_1 commitment(s) to ElGamal randomness, but got {}",
                W,
                self.R.len()
            );
        }

        if self.R_hat.len() != W {
            bail!(
                "Expected {} G_2 commitment(s) to ElGamal randomness, but got {}",
                W,
                self.R_hat.len()
            );
        }

        if self.C.len() != W {
            bail!("Expected C of length {}, but got {}", W, self.C.len());
        }

        Ok(())
    }
```
