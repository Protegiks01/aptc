# Audit Report

## Title
Resource Group Cache Memory Exhaustion Before Gas Charging Enables Validator Node OOM

## Summary
The `load_to_cache()` function in `ResourceGroupAdapter` deserializes entire resource groups into memory before gas is charged for the read operation. An attacker can create resource groups with many large members, and when transactions access these groups, the full deserialization occurs before gas limits are enforced, enabling memory exhaustion attacks against validator nodes.

## Finding Description

The vulnerability exists in the resource group loading mechanism where **deserialization precedes gas charging**, violating the **Move VM Safety** invariant that "bytecode execution must respect gas limits and memory constraints."

**Attack Flow:**

1. **Attacker Preparation**: Attacker creates resource groups with many large members (e.g., 1000 members Ã— 1MB each = 1GB per group) across multiple accounts, paying storage fees upfront.

2. **Deserialization Before Gas Charging**: When any transaction accesses a member of these resource groups, the following sequence occurs: [1](#0-0) 

The `get_any_resource_with_layout()` method calls `get_resource_from_group()`, which triggers: [2](#0-1) 

At line 174, the **entire** `BTreeMap<StructTag, Bytes>` is deserialized via `bcs::from_bytes(&group_data_blob)`, allocating potentially gigabytes of memory.

3. **Gas Charging Happens Later**: Only AFTER deserialization and caching does the system calculate the size and return it: [3](#0-2) 

The interpreter charges gas at line 1321 only after `load_resource_mut` returns: [4](#0-3) 

4. **Parallel Execution Amplification**: In the block executor, multiple transactions execute in parallel, each with its own resolver and cache: [5](#0-4) 

Each parallel transaction that accesses large resource groups deserializes them simultaneously, causing cumulative memory consumption.

5. **Memory Exhaustion**: Before any transaction runs out of gas and aborts, the total memory consumption across all parallel transactions can exceed available memory, causing validator node OOM.

**No Size Limits**: The codebase contains no `MAX_RESOURCE_GROUP_SIZE` or similar limits on:
- Number of members per resource group
- Size of individual members  
- Total cache size
- Number of groups that can be loaded simultaneously [6](#0-5) 

## Impact Explanation

**High Severity** - Validator Node Availability Impact

This vulnerability enables an attacker to cause validator node crashes through memory exhaustion:

1. **Validator Node Crashes**: When multiple transactions in a block access attacker-created large resource groups in parallel, cumulative memory consumption triggers OOM, crashing the validator process.

2. **Network Liveness Degradation**: If multiple validators are affected simultaneously, consensus participation drops, potentially causing liveness failures or transaction processing delays.

3. **Repeated Attack Vector**: Once large resource groups are created (one-time storage fee), the attack can be repeatedly triggered by any transaction accessing them, making it economically efficient for attackers.

4. **No Transaction Revert Protection**: Unlike gas exhaustion which cleanly aborts transactions, memory exhaustion during deserialization occurs before gas accounting, so there's no clean error path.

Per Aptos Bug Bounty criteria, this qualifies as **High Severity**: "Validator node slowdowns/API crashes."

## Likelihood Explanation

**High Likelihood** given:

1. **Low Attack Complexity**: Attacker only needs to:
   - Create resource groups with large members (standard Move operations)
   - Wait for transactions to naturally access them, OR
   - Submit transactions that read from multiple large groups

2. **Economic Feasibility**: While storage fees are required upfront, the attack is economically viable:
   - One-time cost to create malicious resource groups
   - Perpetual impact on all future reads
   - Can target high-value scenarios (DeFi protocols using resource groups)

3. **No Special Privileges Required**: Any account can create resource groups using standard `#[resource_group_member]` attributes.

4. **Parallel Execution Amplifies Impact**: Block executor's parallel execution (up to hundreds of threads) multiplies memory consumption as each thread deserializes its own copy.

## Recommendation

**Implement Size Limits and Pre-Deserialization Gas Charging:**

1. **Add Maximum Resource Group Size Limit**:
```rust
// In resource_group_adapter.rs
const MAX_RESOURCE_GROUP_SIZE: u64 = 10 * 1024 * 1024; // 10MB limit

fn load_to_cache(&self, group_key: &StateKey) -> PartialVMResult<bool> {
    let already_cached = self.group_cache.borrow().contains_key(group_key);
    if already_cached {
        return Ok(true);
    }

    let group_data = self.resource_view.get_resource_bytes(group_key, None)?;
    let (group_data, blob_len): (BTreeMap<StructTag, Bytes>, u64) = group_data.map_or_else(
        || Ok::<_, PartialVMError>((BTreeMap::new(), 0)),
        |group_data_blob| {
            // Check size BEFORE deserialization
            if group_data_blob.len() as u64 > MAX_RESOURCE_GROUP_SIZE {
                return Err(
                    PartialVMError::new(StatusCode::RESOURCE_LIMIT_VIOLATION).with_message(
                        format!("Resource group size {} exceeds maximum {}", 
                                group_data_blob.len(), MAX_RESOURCE_GROUP_SIZE)
                    )
                );
            }
            
            let group_data = bcs::from_bytes(&group_data_blob).map_err(|e| {
                PartialVMError::new(StatusCode::UNEXPECTED_DESERIALIZATION_ERROR).with_message(
                    format!("Failed to deserialize the resource group at {:?}: {:?}", group_key, e)
                )
            })?;
            Ok((group_data, group_data_blob.len() as u64))
        },
    )?;
    // ... rest of function
}
```

2. **Add Cache Size Tracking**:
```rust
pub struct ResourceGroupAdapter<'r> {
    maybe_resource_group_view: Option<&'r dyn ResourceGroupView>,
    resource_view: &'r dyn TResourceView<Key = StateKey, Layout = MoveTypeLayout>,
    group_size_kind: GroupSizeKind,
    group_cache: RefCell<HashMap<StateKey, (BTreeMap<StructTag, Bytes>, ResourceGroupSize)>>,
    total_cache_size: RefCell<usize>, // Track total memory
}

const MAX_TOTAL_CACHE_SIZE: usize = 100 * 1024 * 1024; // 100MB per transaction
```

3. **Enforce Limits During Storage Write**: Add validation in Move framework to reject resource group creations exceeding size limits.

## Proof of Concept

```move
// malicious_resource_group.move
module attacker::malicious_group {
    use std::vector;
    
    #[resource_group(scope = global)]
    struct LargeGroup has drop {}
    
    #[resource_group_member(group = attacker::malicious_group::LargeGroup)]
    struct LargeMember has key {
        data: vector<u8>
    }
    
    // Create resource group with 1000 members, each 1MB
    public entry fun create_large_group(account: &signer) {
        let i = 0;
        while (i < 1000) {
            let large_data = vector::empty<u8>();
            let j = 0;
            while (j < 1048576) { // 1MB
                vector::push_back(&mut large_data, 0xFF);
                j = j + 1;
            };
            
            move_to(account, LargeMember { data: large_data });
            i = i + 1;
        };
    }
    
    // Trigger deserialization of large group
    public entry fun read_from_group(addr: address) acquires LargeMember {
        // Just accessing any member triggers full group deserialization
        let _member = borrow_global<LargeMember>(addr);
    }
}
```

**Attack Scenario:**
1. Attacker deploys module and calls `create_large_group()` on multiple accounts (pays storage fees)
2. Block contains multiple transactions calling `read_from_group()` on different attacker accounts
3. Each transaction in parallel execution deserializes ~1GB into memory
4. With 10+ parallel transactions, validator node OOMs before gas limits abort any transaction

**Notes**

- This vulnerability specifically affects resource groups due to the "all-or-nothing" deserialization semantics where accessing any member requires deserializing the entire group
- Regular resources don't have this issue as they are deserialized individually
- The cache is per-transaction but parallel block execution means multiple transactions load simultaneously
- Storage fees provide some economic barrier but are paid once while the attack surface persists indefinitely

### Citations

**File:** aptos-move/aptos-vm/src/data_cache.rs (L98-129)
```rust
    fn get_any_resource_with_layout(
        &self,
        address: &AccountAddress,
        struct_tag: &StructTag,
        metadata: &[Metadata],
        maybe_layout: Option<&MoveTypeLayout>,
    ) -> PartialVMResult<(Option<Bytes>, usize)> {
        let resource_group = get_resource_group_member_from_metadata(struct_tag, metadata);
        if let Some(resource_group) = resource_group {
            let key = StateKey::resource_group(address, &resource_group);
            let buf =
                self.resource_group_view
                    .get_resource_from_group(&key, struct_tag, maybe_layout)?;

            let first_access = self.accessed_groups.borrow_mut().insert(key.clone());
            let group_size = if first_access {
                self.resource_group_view.resource_group_size(&key)?.get()
            } else {
                0
            };

            let buf_size = resource_size(&buf);
            Ok((buf, buf_size + group_size as usize))
        } else {
            let state_key = resource_state_key(address, struct_tag)?;
            let buf = self
                .executor_view
                .get_resource_bytes(&state_key, maybe_layout)?;
            let buf_size = resource_size(&buf);
            Ok((buf, buf_size))
        }
    }
```

**File:** aptos-move/aptos-vm-types/src/resource_group_adapter.rs (L114-119)
```rust
pub struct ResourceGroupAdapter<'r> {
    maybe_resource_group_view: Option<&'r dyn ResourceGroupView>,
    resource_view: &'r dyn TResourceView<Key = StateKey, Layout = MoveTypeLayout>,
    group_size_kind: GroupSizeKind,
    group_cache: RefCell<HashMap<StateKey, (BTreeMap<StructTag, Bytes>, ResourceGroupSize)>>,
}
```

**File:** aptos-move/aptos-vm-types/src/resource_group_adapter.rs (L164-197)
```rust
    fn load_to_cache(&self, group_key: &StateKey) -> PartialVMResult<bool> {
        let already_cached = self.group_cache.borrow().contains_key(group_key);
        if already_cached {
            return Ok(true);
        }

        let group_data = self.resource_view.get_resource_bytes(group_key, None)?;
        let (group_data, blob_len): (BTreeMap<StructTag, Bytes>, u64) = group_data.map_or_else(
            || Ok::<_, PartialVMError>((BTreeMap::new(), 0)),
            |group_data_blob| {
                let group_data = bcs::from_bytes(&group_data_blob).map_err(|e| {
                    PartialVMError::new(StatusCode::UNEXPECTED_DESERIALIZATION_ERROR).with_message(
                        format!(
                            "Failed to deserialize the resource group at {:? }: {:?}",
                            group_key, e
                        ),
                    )
                })?;
                Ok((group_data, group_data_blob.len() as u64))
            },
        )?;

        let group_size = match self.group_size_kind {
            GroupSizeKind::None => ResourceGroupSize::Concrete(0),
            GroupSizeKind::AsBlob => ResourceGroupSize::Concrete(blob_len),
            GroupSizeKind::AsSum => {
                group_size_as_sum(group_data.iter().map(|(t, v)| (t, v.len())))?
            },
        };
        self.group_cache
            .borrow_mut()
            .insert(group_key.clone(), (group_data, group_size));
        Ok(false)
    }
```

**File:** third_party/move/move-vm/runtime/src/data_cache.rs (L255-327)
```rust
    fn create_data_cache_entry(
        metadata_loader: &impl ModuleMetadataLoader,
        layout_converter: &LayoutConverter<impl StructDefinitionLoader>,
        gas_meter: &mut impl DependencyGasMeter,
        traversal_context: &mut TraversalContext,
        module_storage: &dyn ModuleStorage,
        resource_resolver: &dyn ResourceResolver,
        addr: &AccountAddress,
        ty: &Type,
    ) -> PartialVMResult<(DataCacheEntry, NumBytes)> {
        let struct_tag = match module_storage.runtime_environment().ty_to_ty_tag(ty)? {
            TypeTag::Struct(struct_tag) => *struct_tag,
            _ => {
                // Since every resource is a struct, the tag must be also a struct tag.
                return Err(PartialVMError::new(StatusCode::INTERNAL_TYPE_ERROR));
            },
        };

        let layout_with_delayed_fields = layout_converter.type_to_type_layout_with_delayed_fields(
            gas_meter,
            traversal_context,
            ty,
            false,
        )?;

        let (data, bytes_loaded) = {
            let module = metadata_loader.load_module_for_metadata(
                gas_meter,
                traversal_context,
                &struct_tag.module_id(),
            )?;

            // If we need to process delayed fields, we pass type layout to remote storage. Remote
            // storage, in turn ensures that all delayed field values are pre-processed.
            resource_resolver.get_resource_bytes_with_metadata_and_layout(
                addr,
                &struct_tag,
                &module.metadata,
                layout_with_delayed_fields.layout_when_contains_delayed_fields(),
            )?
        };

        let function_value_extension = FunctionValueExtensionAdapter { module_storage };
        let (layout, contains_delayed_fields) = layout_with_delayed_fields.unpack();
        let value = match data {
            Some(blob) => {
                let max_value_nest_depth = function_value_extension.max_value_nest_depth();
                let val = ValueSerDeContext::new(max_value_nest_depth)
                    .with_func_args_deserialization(&function_value_extension)
                    .with_delayed_fields_serde()
                    .deserialize(&blob, &layout)
                    .ok_or_else(|| {
                        let msg = format!(
                            "Failed to deserialize resource {} at {}!",
                            struct_tag.to_canonical_string(),
                            addr
                        );
                        PartialVMError::new(StatusCode::FAILED_TO_DESERIALIZE_RESOURCE)
                            .with_message(msg)
                    })?;
                GlobalValue::cached(val)?
            },
            None => GlobalValue::none(),
        };

        let entry = DataCacheEntry {
            struct_tag,
            layout,
            contains_delayed_fields,
            value,
        };
        Ok((entry, NumBytes::new(bytes_loaded as u64)))
    }
```

**File:** third_party/move/move-vm/runtime/src/interpreter.rs (L1310-1333)
```rust
    fn load_resource_mut<'cache>(
        &self,
        data_cache: &'cache mut impl MoveVmDataCache,
        gas_meter: &mut impl GasMeter,
        traversal_context: &mut TraversalContext,
        addr: AccountAddress,
        ty: &Type,
    ) -> PartialVMResult<&'cache mut GlobalValue> {
        let (gv, bytes_loaded) =
            data_cache.load_resource_mut(gas_meter, traversal_context, &addr, ty)?;
        if let Some(bytes_loaded) = bytes_loaded {
            gas_meter.charge_load_resource(
                addr,
                TypeWithRuntimeEnvironment {
                    ty,
                    runtime_environment: self.loader.runtime_environment(),
                },
                gv.view(),
                bytes_loaded,
            )?;
        }

        Ok(gv)
    }
```

**File:** aptos-move/aptos-vm/src/block_executor/vm_wrapper.rs (L48-67)
```rust
    fn execute_transaction(
        &self,
        view: &(impl ExecutorView
              + ResourceGroupView
              + AptosCodeStorage
              + BlockSynchronizationKillSwitch),
        txn: &SignatureVerifiedTransaction,
        auxiliary_info: &Self::AuxiliaryInfo,
        txn_idx: TxnIndex,
    ) -> ExecutionStatus<AptosTransactionOutput, VMStatus> {
        fail_point!("aptos_vm::vm_wrapper::execute_transaction", |_| {
            ExecutionStatus::DelayedFieldsCodeInvariantError("fail points error".into())
        });

        let log_context = AdapterLogSchema::new(self.id, txn_idx as usize);
        let resolver = self.vm.as_move_resolver_with_group_view(view);
        match self
            .vm
            .execute_single_transaction(txn, &resolver, view, &log_context, auxiliary_info)
        {
```
