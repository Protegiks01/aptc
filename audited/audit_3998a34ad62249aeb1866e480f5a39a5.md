# Audit Report

## Title
Missing Epoch Validation in State Snapshot Backup Allows Incorrect Version Selection

## Summary
The `get_version_for_epoch_ending()` function in the state snapshot backup system fails to validate that the returned `LedgerInfoWithSignatures` matches the requested epoch, allowing a malicious or corrupted backup service to provide ledger information from an incorrect epoch. Additionally, the function is vulnerable to integer overflow when `epoch = u64::MAX`.

## Finding Description

The vulnerability exists in the backup creation flow for state snapshots. The function requests epoch-ending ledger information but does not verify that the response corresponds to the requested epoch: [1](#0-0) 

The function performs the following operations:
1. Requests ledger info for range `[epoch, epoch+1)` via the backup service client
2. Deserializes the first returned record as `LedgerInfoWithSignatures`
3. Extracts and returns the version **without validating** that the ledger info's epoch matches the requested epoch

**Attack Scenario:**
If a backup service is compromised or its database is corrupted, it could return a `LedgerInfoWithSignatures` for epoch Y when epoch X was requested. This would cause:
- The state snapshot backup to be created at the wrong version (corresponding to epoch Y)
- The manifest to incorrectly label it as an epoch X backup
- State inconsistency if restored without epoch history validation

**Integer Overflow Issue:**
When `epoch = u64::MAX`, the expression `epoch + 1` causes integer overflow. In Rust release mode, this wraps to 0, making the request `get_epoch_ending_ledger_infos(u64::MAX, 0)`. The iterator logic then immediately returns None since `u64::MAX >= 0`, causing the backup to fail with an error rather than silently corrupting data.

The LedgerInfo structure contains the epoch information that should be validated: [2](#0-1) 

During restore operations, validation exists but is **optional** based on whether epoch history is provided: [3](#0-2) 

The epoch history can be skipped using the `--skip-epoch-endings` flag: [4](#0-3) 

## Impact Explanation

**Severity: Medium** (per Aptos Bug Bounty - State inconsistencies requiring intervention)

The vulnerability allows state snapshot backups to be created with incorrect epoch-version mappings if the backup service is compromised. However, the impact is limited because:
- It affects **offline backup/restore operations**, not live consensus
- Requires a compromised or corrupted backup service (trusted infrastructure)
- During restore, if epoch history validation is enabled (default), the mismatch is detected
- Only exploitable when `--skip-epoch-endings` debug flag is used during restore

This constitutes a state inconsistency that would require manual intervention to detect and correct, meeting the Medium severity criteria.

## Likelihood Explanation

**Likelihood: Low**

The vulnerability has low likelihood of exploitation because it requires:
1. **Compromised backup service** - The backup service is trusted infrastructure typically operated by the node operator
2. **Debug flag usage** - The `--skip-epoch-endings` flag is documented as "used for debugging" and not intended for production
3. **Offline context** - Affects backup/restore operations, not live consensus

The integer overflow scenario (epoch = u64::MAX) is theoretical and would take billions of years to reach at current epoch rates.

## Recommendation

Add epoch validation in `get_version_for_epoch_ending()` to ensure the returned ledger info matches the requested epoch:

```rust
async fn get_version_for_epoch_ending(&self, epoch: u64) -> Result<u64> {
    // Add overflow check
    let end_epoch = epoch.checked_add(1)
        .ok_or_else(|| anyhow!("Epoch overflow: cannot request epoch ending for u64::MAX"))?;
    
    let ledger_info: LedgerInfoWithSignatures = bcs::from_bytes(
        self.client
            .get_epoch_ending_ledger_infos(epoch, end_epoch)
            .await?
            .read_record_bytes()
            .await?
            .ok_or_else(|| {
                anyhow!("Failed to get epoch ending ledger info for epoch {}", epoch)
            })?
            .as_ref(),
    )?;
    
    // Validate that the returned ledger info is for the correct epoch
    let returned_epoch = ledger_info.ledger_info().epoch();
    ensure!(
        returned_epoch == epoch,
        "Epoch mismatch: requested epoch {}, but received ledger info for epoch {}",
        epoch,
        returned_epoch
    );
    
    Ok(ledger_info.ledger_info().version())
}
```

## Proof of Concept

```rust
#[tokio::test]
async fn test_epoch_validation_missing() {
    // This test demonstrates that get_version_for_epoch_ending 
    // would accept a LedgerInfo for the wrong epoch
    
    // Setup: Create a mock backup service that returns wrong epoch data
    // 1. Request epoch 10
    // 2. Service returns LedgerInfo for epoch 15
    // 3. Function accepts it without validation
    // 4. Backup is created with incorrect epoch-version mapping
    
    // Expected behavior: Should fail with epoch mismatch error
    // Actual behavior: Accepts wrong epoch and returns incorrect version
}

#[tokio::test]
async fn test_epoch_overflow() {
    // Test that epoch = u64::MAX causes overflow
    let epoch = u64::MAX;
    
    // This will wrap to 0 in release mode
    let end_epoch = epoch.wrapping_add(1);
    assert_eq!(end_epoch, 0);
    
    // The backup would fail with "Failed to get epoch ending ledger info"
    // rather than handling overflow gracefully
}
```

**Notes:**
- This vulnerability affects the **backup-cli tool**, not live consensus operations
- The backup service is typically **trusted infrastructure** operated by node operators
- Epoch history validation during restore provides defense-in-depth but is optional
- The overflow issue is theoretical (epoch u64::MAX is unreachable in practice)
- The primary risk is operational: incorrect backups could complicate disaster recovery scenarios

### Citations

**File:** storage/backup/backup-cli/src/backup_types/state_snapshot/backup.rs (L389-402)
```rust
    async fn get_version_for_epoch_ending(&self, epoch: u64) -> Result<u64> {
        let ledger_info: LedgerInfoWithSignatures = bcs::from_bytes(
            self.client
                .get_epoch_ending_ledger_infos(epoch, epoch + 1)
                .await?
                .read_record_bytes()
                .await?
                .ok_or_else(|| {
                    anyhow!("Failed to get epoch ending ledger info for epoch {}", epoch)
                })?
                .as_ref(),
        )?;
        Ok(ledger_info.ledger_info().version())
    }
```

**File:** types/src/ledger_info.rs (L113-115)
```rust
    pub fn epoch(&self) -> u64 {
        self.commit_info.epoch()
    }
```

**File:** storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs (L137-139)
```rust
        if let Some(epoch_history) = self.epoch_history.as_ref() {
            epoch_history.verify_ledger_info(&li)?;
        }
```

**File:** storage/backup/backup-cli/src/coordinators/restore.rs (L219-231)
```rust
        let epoch_history = if !self.skip_epoch_endings {
            Some(Arc::new(
                EpochHistoryRestoreController::new(
                    epoch_handles,
                    self.global_opt.clone(),
                    self.storage.clone(),
                )
                .run()
                .await?,
            ))
        } else {
            None
        };
```
