# Audit Report

## Title
Module Complexity Budget Manipulation via Bytecode Inflation

## Summary
The `check_module_complexity()` function uses a budget calculated from module bytecode size (`2048 + blob.code().len() * 20`), which attackers can manipulate by controlling their module's bytecode length. This allows publishing modules with disproportionately high total type complexity that could stress validator resources.

## Finding Description

The budget parameter for module complexity checking originates from the module's bytecode size and can be directly manipulated by attackers: [1](#0-0) 

The budget calculation scales linearly with bytecode size (20 units per byte), allowing an attacker to inflate their complexity budget by padding modules with dummy bytecode. With the maximum package size limit of 60,000 bytes: [2](#0-1) 

An attacker obtains a budget of `2048 + 60000 * 20 = 1,202,048`, permitting approximately 150,256 type nodes total (at 8 cost per node): [3](#0-2) 

The complexity meter charges for all module components: [4](#0-3) 

Critically, the production verifier configuration imposes NO limits on the number of functions or struct definitions: [5](#0-4) 

While per-signature type complexity is limited to 128 nodes: [6](#0-5) 

This creates a scenario where total module complexity is only bounded by the manipulable budget from `check_module_complexity`, not by fixed verifier limits.

## Impact Explanation

**Severity Assessment: Medium**

This qualifies as Medium severity under "State inconsistencies requiring intervention" because:

1. **Resource Exhaustion Vector**: An attacker can force all validators to process modules with ~150K type nodes, consuming significant memory (4-5MB per module) and CPU during verification
2. **Bounded but Exploitable**: While capped by package size, multiple attackers could deploy many such modules, accumulating validator resource strain
3. **Deterministic Impact**: All validators process identical bytecode, preventing consensus splits but ensuring network-wide resource consumption

The TODO comment acknowledges this as a known design issue: [7](#0-6) 

## Likelihood Explanation

**Likelihood: High**

- **Low Attack Complexity**: Attacker needs only to publish a transaction with a specially crafted module
- **No Privilege Required**: Any account can publish modules
- **Economic Barrier**: Attacker pays gas for 60KB module, but this is affordable for determined adversaries
- **Scalable**: Multiple attackers or repeated attacks amplify impact

## Recommendation

Replace the bytecode-size-based budget with a fixed constant from the verifier configuration:

```rust
// In aptos-move/aptos-vm-environment/src/prod_configs.rs
pub const MODULE_COMPLEXITY_BUDGET: u64 = 100_000; // Fixed budget

// In aptos-move/aptos-vm/src/aptos_vm.rs
for (module, blob) in modules.iter().zip(bundle.iter()) {
    let budget = MODULE_COMPLEXITY_BUDGET; // Use fixed budget instead
    move_binary_format::check_complexity::check_module_complexity(module, budget)
        .map_err(|err| err.finish(Location::Undefined))?;
}
```

Additionally, add total module complexity limits to the production verifier config:

```rust
max_function_definitions: Some(1000),
max_struct_definitions: Some(200),
```

## Proof of Concept

```rust
// Create a module with maximum bytecode to maximize budget
use move_binary_format::file_format::*;

fn create_complexity_attack_module() -> CompiledModule {
    let mut module = empty_module();
    
    // Add many dummy functions to inflate bytecode size
    for i in 0..1000 {
        module.identifiers.push(Identifier::new(format!("func_{}", i)).unwrap());
        module.function_handles.push(FunctionHandle {
            module: ModuleHandleIndex(0),
            name: IdentifierIndex((i + 1) as u16),
            parameters: SignatureIndex(0),
            return_: SignatureIndex(0),
            type_parameters: vec![],
            access_specifiers: None,
            attributes: vec![],
        });
        
        // Add dummy bytecode to increase module size
        let mut code = vec![Bytecode::Ret];
        for _ in 0..50 {
            code.insert(0, Bytecode::Nop); // Pad with NOPs
        }
        
        module.function_defs.push(FunctionDefinition {
            function: FunctionHandleIndex((i + 1) as u16),
            visibility: Public,
            is_entry: false,
            acquires_global_resources: vec![],
            code: Some(CodeUnit {
                locals: SignatureIndex(0),
                code,
            }),
        });
    }
    
    // Each function now has complex type signatures (up to limit)
    for i in 0..1000 {
        let mut complex_type = SignatureToken::Bool;
        for _ in 0..20 { // Create nested vectors
            complex_type = SignatureToken::Vector(Box::new(complex_type));
        }
        module.signatures.push(Signature(vec![complex_type]));
    }
    
    module
}

// This module would:
// - Have ~60KB of bytecode (1000 functions * ~60 bytes each)
// - Get budget: 2048 + 60000 * 20 = 1,202,048
// - Have ~120,000 type nodes total (1000 sigs * 20 levels * 6 nodes per level)
// - Pass check_module_complexity (cost ~960,000 < budget)
// - Pass LimitsVerifier (each signature has depth 20, under limit)
// - Consume significant validator resources
```

## Notes

This vulnerability exploits the mismatch between module-level complexity budgets (attacker-controlled via bytecode size) and per-signature limits (fixed by verifier config). The absence of limits on function/struct counts in production allows unbounded module complexity growth within the inflated budget.

### Citations

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1554-1559)
```rust
        for (module, blob) in modules.iter().zip(bundle.iter()) {
            // TODO(Gas): Make budget configurable.
            let budget = 2048 + blob.code().len() as u64 * 20;
            move_binary_format::check_complexity::check_module_complexity(module, budget)
                .map_err(|err| err.finish(Location::Undefined))?;
        }
```

**File:** crates/aptos/src/move_tool/mod.rs (L984-984)
```rust
pub const MAX_PUBLISH_PACKAGE_SIZE: usize = 60_000;
```

**File:** third_party/move/move-binary-format/src/check_complexity.rs (L20-20)
```rust
const COST_PER_TYPE_NODE: u64 = 8;
```

**File:** third_party/move/move-binary-format/src/check_complexity.rs (L408-417)
```rust
    meter.meter_signatures()?;
    meter.meter_function_instantiations()?;
    meter.meter_struct_def_instantiations()?;
    meter.meter_field_instantiations()?;

    meter.meter_function_handles()?;
    meter.meter_struct_handles()?;
    meter.meter_function_defs()?;
    meter.meter_struct_defs()?;

```

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L162-166)
```rust
        max_type_nodes: if enable_function_values {
            Some(128)
        } else {
            Some(256)
        },
```

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L168-171)
```rust
        max_struct_definitions: None,
        max_struct_variants: None,
        max_fields_in_struct: None,
        max_function_definitions: None,
```
