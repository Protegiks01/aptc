# Audit Report

## Title
State Sync `sync_for_duration()` Returns Stale Ledger Info Without Forward Progress Validation

## Summary
The `sync_for_duration()` function in state sync can return a ledger info with the same or older version than when synchronization started, violating the expectation that sync makes forward progress. Unlike `sync_to_target()` which validates version bounds, `sync_for_duration()` only checks that the time duration has elapsed without verifying that the returned ledger info represents a newer blockchain state.

## Finding Description

The state sync driver's handling of duration-based sync requests lacks forward progress validation. When consensus or consensus observer calls `sync_for_duration()`, the following sequence occurs:

1. **Request Initialization**: State sync captures only the start **time**, not the starting ledger info version. [1](#0-0) 

2. **Satisfaction Check**: The request is considered satisfied when the time duration has passed, regardless of whether the ledger version has increased. [2](#0-1) 

3. **Response Without Validation**: When responding to a duration request, state sync returns whatever ledger info exists in storage without checking if it's newer than the starting version. [3](#0-2) 

4. **Unconditional Acceptance**: Consensus observer unconditionally updates its root with the returned ledger info. [4](#0-3) 

In contrast, `sync_to_target()` properly validates version bounds and returns an error if syncing beyond the target: [5](#0-4) 

**Attack Scenario:**

A consensus observer at version 1000 enters fallback mode and calls `sync_for_duration(5 seconds)`:
- State sync records start_time but not start_version
- During the 5 seconds, no peers are available or network experiences issues
- No new blocks are received, storage remains at version 1000
- After 5 seconds elapse, sync returns version 1000 (same as start)
- Consensus observer updates its root to version 1000, thinking it successfully synced
- Fallback manager's progress tracking resets with the same version
- Observer may repeatedly enter fallback mode without making actual progress

The `ConsensusSyncRequest` enum stores only the start time for duration requests: [6](#0-5) 

The final ledger info is fetched from storage without comparing to any baseline: [7](#0-6) 

## Impact Explanation

This vulnerability meets **High Severity** criteria per the Aptos bug bounty program:

1. **Validator Node Slowdowns**: Consensus observers can get stuck in a loop of entering fallback mode, syncing without progress, and re-entering fallback mode. This degrades node performance and slows down block processing.

2. **Significant Protocol Violation**: The function violates its implicit contract that synchronization produces forward progress. This breaks the expectation documented in the interface. [8](#0-7) 

3. **Liveness Impact**: While not total liveness loss, observers stuck without progress cannot properly track consensus, potentially affecting network health during adverse conditions (network partitions, peer unavailability).

The regular consensus execution proxy also uses this function and updates its logical time based on the returned ledger info: [9](#0-8) 

If stale ledger info is returned, consensus could regress its logical time tracking, causing subtle timing issues.

## Likelihood Explanation

**Likelihood: High** - This can occur in realistic network conditions:

1. **Network Partitions**: During network instability, a node may have no peers to sync from, causing sync to complete with no progress.

2. **Peer Unavailability**: If all available peers are at the same version or behind, sync cannot make forward progress.

3. **Bootstrap Scenarios**: Nodes bootstrapping with limited peer connectivity may repeatedly call `sync_for_duration()` without access to newer data.

4. **No Special Privileges Required**: This occurs naturally during adverse network conditions without requiring attacker action.

5. **Observer Fallback is Common**: Consensus observers regularly enter fallback mode when falling behind, making this code path frequently exercised. [10](#0-9) 

## Recommendation

**Fix**: Store the starting ledger info version when initializing a sync duration request and validate forward progress when responding:

1. Modify `ConsensusSyncRequest::SyncDuration` to store the starting version:
```rust
SyncDuration(Instant, Version, ConsensusSyncDurationNotification)
```

2. In `initialize_sync_duration_request()`, capture the current ledger info version:
```rust
let starting_version = utils::fetch_latest_synced_ledger_info(storage)?.ledger_info().version();
let consensus_sync_request = ConsensusSyncRequest::new_with_duration(
    start_time, 
    starting_version, 
    sync_duration_notification
);
```

3. In `handle_satisfied_sync_request()`, validate forward progress for duration requests:
```rust
Some(ConsensusSyncRequest::SyncDuration(_, starting_version, sync_duration_notification)) => {
    let latest_version = latest_synced_ledger_info.ledger_info().version();
    
    // Verify forward progress was made
    if latest_version <= starting_version {
        let error = Err(Error::NoSyncProgress(latest_version, starting_version));
        self.respond_to_sync_duration_notification(
            sync_duration_notification,
            error.clone(),
            None,
        )?;
        return error;
    }
    
    // Progress was made, respond successfully
    self.respond_to_sync_duration_notification(
        sync_duration_notification,
        Ok(()),
        Some(latest_synced_ledger_info),
    )?;
}
```

4. Add a new error variant `NoSyncProgress(Version, Version)` to track this condition.

This approach mirrors the validation already performed for `sync_to_target()` requests and ensures the minimum guarantee that synchronization produces forward progress.

## Proof of Concept

```rust
#[tokio::test]
async fn test_sync_for_duration_no_progress() {
    use aptos_consensus_notifications::{
        new_consensus_notifier_listener_pair, 
        ConsensusNotificationSender
    };
    use std::time::Duration;
    
    // Setup: Create a consensus notifier and listener
    let (consensus_notifier, mut consensus_listener) = 
        new_consensus_notifier_listener_pair(5000);
    
    // Spawn a task to handle the notification but NOT make any progress
    tokio::spawn(async move {
        if let Some(notification) = consensus_listener.next().await {
            match notification {
                ConsensusNotification::SyncForDuration(sync_notification) => {
                    // Create a ledger info at version 100
                    let ledger_info = create_ledger_info_at_version(100);
                    
                    // Simulate: sync completes but returns same version
                    // (In real scenario: no peers available, network issues)
                    tokio::time::sleep(sync_notification.get_duration()).await;
                    
                    // Return the SAME ledger info (no progress made)
                    let _ = consensus_listener.respond_to_sync_duration_notification(
                        sync_notification,
                        Ok(()),
                        Some(ledger_info), // Same version 100!
                    );
                }
                _ => {}
            }
        }
    });
    
    // Call sync_for_duration expecting forward progress
    let result = consensus_notifier.sync_for_duration(Duration::from_millis(100)).await;
    
    // BUG: This succeeds even though no progress was made!
    assert!(result.is_ok());
    let returned_ledger_info = result.unwrap();
    assert_eq!(returned_ledger_info.ledger_info().version(), 100);
    
    // Expected behavior: Should return error indicating no forward progress
    // or should capture starting version and validate it increased
}
```

This test demonstrates that `sync_for_duration()` successfully returns a ledger info at the same version without validation, violating the forward progress guarantee that consensus and consensus observer rely upon.

### Citations

**File:** state-sync/state-sync-driver/src/notification_handlers.rs (L149-166)
```rust
pub enum ConsensusSyncRequest {
    SyncDuration(Instant, ConsensusSyncDurationNotification), // The start time and duration to sync for
    SyncTarget(ConsensusSyncTargetNotification),              // The target ledger info to sync to
}

impl ConsensusSyncRequest {
    /// Returns a new sync target request
    pub fn new_with_target(sync_target_notification: ConsensusSyncTargetNotification) -> Self {
        ConsensusSyncRequest::SyncTarget(sync_target_notification)
    }

    /// Returns a new sync duration request
    pub fn new_with_duration(
        start_time: Instant,
        sync_duration_notification: ConsensusSyncDurationNotification,
    ) -> Self {
        ConsensusSyncRequest::SyncDuration(start_time, sync_duration_notification)
    }
```

**File:** state-sync/state-sync-driver/src/notification_handlers.rs (L190-196)
```rust
            ConsensusSyncRequest::SyncDuration(start_time, sync_duration_notification) => {
                // Get the duration and the current time
                let sync_duration = sync_duration_notification.get_duration();
                let current_time = time_service.now();

                // Check if the duration has been reached
                current_time.duration_since(*start_time) >= sync_duration
```

**File:** state-sync/state-sync-driver/src/notification_handlers.rs (L246-259)
```rust
    pub async fn initialize_sync_duration_request(
        &mut self,
        sync_duration_notification: ConsensusSyncDurationNotification,
    ) -> Result<(), Error> {
        // Get the current time
        let start_time = self.time_service.now();

        // Save the request so we can notify consensus once we've hit the duration
        let consensus_sync_request =
            ConsensusSyncRequest::new_with_duration(start_time, sync_duration_notification);
        self.consensus_sync_request = Arc::new(Mutex::new(Some(consensus_sync_request)));

        Ok(())
    }
```

**File:** state-sync/state-sync-driver/src/notification_handlers.rs (L332-337)
```rust
            Some(ConsensusSyncRequest::SyncDuration(_, sync_duration_notification)) => {
                self.respond_to_sync_duration_notification(
                    sync_duration_notification,
                    Ok(()),
                    Some(latest_synced_ledger_info),
                )?;
```

**File:** state-sync/state-sync-driver/src/notification_handlers.rs (L345-356)
```rust
                // Check if we've synced beyond the target. If so, notify consensus with an error.
                if latest_synced_version > sync_target_version {
                    let error = Err(Error::SyncedBeyondTarget(
                        latest_synced_version,
                        sync_target_version,
                    ));
                    self.respond_to_sync_target_notification(
                        sync_target_notification,
                        error.clone(),
                    )?;
                    return error;
                }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L943-950)
```rust
        // Reset the fallback manager state
        self.observer_fallback_manager
            .reset_syncing_progress(&latest_synced_ledger_info);

        // Update the root with the latest synced ledger info
        self.observer_block_data
            .lock()
            .update_root(latest_synced_ledger_info);
```

**File:** state-sync/state-sync-driver/src/driver.rs (L594-599)
```rust
        // Handle the satisfied sync request
        let latest_synced_ledger_info =
            utils::fetch_latest_synced_ledger_info(self.storage.clone())?;
        self.consensus_notification_handler
            .handle_satisfied_sync_request(latest_synced_ledger_info)
            .await?;
```

**File:** state-sync/inter-component/consensus-notifications/src/lib.rs (L45-51)
```rust
    /// Notifies state sync to synchronize storage for at least the specified duration,
    /// and returns the latest synced ledger info. Note that state sync may synchronize
    /// for much longer than the specified duration, e.g., if the node is very far behind.
    async fn sync_for_duration(
        &self,
        duration: Duration,
    ) -> Result<LedgerInfoWithSignatures, Error>;
```

**File:** consensus/src/state_computer.rs (L159-163)
```rust
        if let Ok(latest_synced_ledger_info) = &result {
            let ledger_info = latest_synced_ledger_info.ledger_info();
            let synced_logical_time = LogicalTime::new(ledger_info.epoch(), ledger_info.round());
            *latest_logical_time = synced_logical_time;
        }
```

**File:** consensus/src/consensus_observer/observer/state_sync_manager.rs (L146-161)
```rust
                let fallback_duration =
                    Duration::from_millis(consensus_observer_config.observer_fallback_duration_ms);

                // Sync for the fallback duration
                let latest_synced_ledger_info = match execution_client
                    .clone()
                    .sync_for_duration(fallback_duration)
                    .await
                {
                    Ok(latest_synced_ledger_info) => latest_synced_ledger_info,
                    Err(error) => {
                        error!(LogSchema::new(LogEntry::ConsensusObserver)
                            .message(&format!("Failed to sync for fallback! Error: {:?}", error)));
                        return;
                    },
                };
```
