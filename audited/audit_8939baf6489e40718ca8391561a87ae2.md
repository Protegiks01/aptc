# Audit Report

## Title
ReplayProtector Type Confusion Allows Duplicate Transaction Execution Bypass

## Summary
The transaction deduper in consensus uses `(sender, replay_protector)` as the deduplication key, but `ReplayProtector::SequenceNumber(n)` and `ReplayProtector::Nonce(n)` are considered distinct values even with the same numeric parameter. An attacker can create two transactions with identical payloads but different replay protector types that bypass deduplication and execute twice, causing double-spending and consensus violations.

## Finding Description

The `TxnHashAndAuthenticatorDeduper` identifies potential duplicate transactions by checking if multiple transactions share the same `(sender, replay_protector)` pair. [1](#0-0) 

However, the `ReplayProtector` enum has two variants that are treated as distinct even when carrying the same numeric value: [2](#0-1) 

The ordering test confirms these are considered different values: [3](#0-2) 

When creating transactions, the `ReplayProtector` type determines the internal structure: [4](#0-3) 

The replay protector is determined at runtime from the payload structure: [5](#0-4) 

The nonce is stored in the payload's extra configuration: [6](#0-5) 

During validation, sequence number and nonce checks are completely independent with separate storage: [7](#0-6) 

Sequence number validation checks against the account's sequence number: [8](#0-7) 

Nonce validation checks against a separate nonce history table: [9](#0-8) 

The nonce history is stored independently: [10](#0-9) 

**Attack Path:**

1. Attacker creates Transaction A: `sender=Alice, sequence_number=5, payload=Transfer(Bob, 100 coins), replay_protection_nonce=None` → `ReplayProtector::SequenceNumber(5)`

2. Attacker creates Transaction B: `sender=Alice, sequence_number=u64::MAX, payload=Transfer(Bob, 100 coins), replay_protection_nonce=Some(999)` → `ReplayProtector::Nonce(999)`

3. Both transactions are submitted to mempool/consensus

4. Deduper compares: `(Alice, SequenceNumber(5)) ≠ (Alice, Nonce(999))` → NOT considered duplicates

5. Both transactions included in block(s)

6. Transaction A validates: `account_sequence_number == 5` → Passes, executes, increments sequence to 6

7. Transaction B validates: `nonce 999 not in nonce_history` → Passes, executes, records nonce

8. Bob receives 200 coins instead of 100 (double execution)

## Impact Explanation

**Severity: Critical** (Consensus Safety Violation)

This vulnerability breaks multiple critical invariants:

1. **Deterministic Execution**: The same logical transaction executes twice with different replay protector types, violating the guarantee that identical transactions produce identical state transitions.

2. **Consensus Safety**: Different validators may receive these transactions in different orders or only receive one of them, potentially causing state divergence and chain splits.

3. **Transaction Validation**: The replay protection mechanism is completely bypassed, allowing duplicate execution of the same logical operation.

**Concrete Impacts:**
- **Double-spending**: Transfer transactions execute twice, draining double the intended amount
- **State manipulation**: Any state-changing transaction (voting, staking, governance) can be executed multiple times
- **Consensus divergence**: Validators may disagree on final state if transactions arrive in different orders
- **Fund loss**: Users lose additional funds through unintended duplicate executions

This meets **Critical Severity** criteria: "Consensus/Safety violations" and potential "Loss of Funds".

## Likelihood Explanation

**Likelihood: High**

The attack is straightforward to execute:

1. **No special privileges required**: Any account holder can exploit this with their own account
2. **Simple to craft**: Standard transaction creation APIs support both ReplayProtector types
3. **No timing constraints**: Attacker fully controls when to submit both transactions
4. **Low cost**: Only requires two transaction submissions
5. **Detection difficulty**: Appears as two legitimate transactions to the deduper

The only requirement is that the attacker controls the private key of the sender account, which is always true for the account owner. The attacker can precisely time when their account's sequence number reaches the target value.

## Recommendation

The deduper should use a content-based key that is invariant to the replay protector type. The fix should:

1. **Normalize the replay protector value**: Extract the numeric value (sequence number or nonce) and use it along with sender and payload hash for deduplication, OR

2. **Use canonical transaction hash**: Deduplicate based on the hash of the transaction's logical content (sender, payload, gas parameters) excluding the replay protector encoding, OR

3. **Enhance possible duplicate detection**: When marking possible duplicates, also check if two transactions have the same sender and executable, regardless of replay protector type.

**Recommended Fix (Option 1 - Most straightforward):**

```rust
// In txn_hash_and_authenticator_deduper.rs, line 44-54
for (i, txn) in transactions.iter().enumerate() {
    // Use sender + payload hash as key, ignoring replay protector type
    let payload_hash = txn.raw_txn().payload_ref().hash(); // hypothetical
    let dedup_key = (txn.sender(), payload_hash);
    
    match seen.get(&dedup_key) {
        None => {
            seen.insert(dedup_key, i);
        },
        Some(first_index) => {
            is_possible_duplicate = true;
            possible_duplicates[*first_index] = true;
            possible_duplicates[i] = true;
        },
    }
}
```

Alternatively, add an additional check specifically for cross-ReplayProtector duplicates before the existing logic.

## Proof of Concept

```rust
#[test]
fn test_replay_protector_type_confusion_bypass() {
    use crate::{
        transaction_deduper::TransactionDeduper,
        txn_hash_and_authenticator_deduper::TxnHashAndAuthenticatorDeduper,
    };
    use aptos_crypto::ed25519::{Ed25519PrivateKey, Ed25519PublicKey};
    use aptos_keygen::KeyGen;
    use aptos_types::{
        chain_id::ChainId,
        transaction::{
            EntryFunction, RawTransaction, ReplayProtector, SignedTransaction,
            TransactionExecutable,
        },
        utility_coin::AptosCoinType,
        CoinType,
    };
    use move_core_types::{account_address::AccountAddress, ident_str, language_storage::ModuleId};

    let deduper = TxnHashAndAuthenticatorDeduper::new();
    
    // Create sender and receiver accounts
    let (sender_privkey, sender_pubkey) = KeyGen::from_os_rng().generate_ed25519_keypair();
    let sender_addr = aptos_types::account_address::from_public_key(&sender_pubkey);
    let receiver_addr = AccountAddress::random();
    
    // Create identical transfer payload
    let entry_func = EntryFunction::new(
        ModuleId::new(AccountAddress::ONE, ident_str!("coin").to_owned()),
        ident_str!("transfer").to_owned(),
        vec![AptosCoinType::type_tag()],
        vec![
            bcs::to_bytes(&receiver_addr).unwrap(),
            bcs::to_bytes(&100u64).unwrap(),
        ],
    );
    let executable = TransactionExecutable::EntryFunction(entry_func.clone());
    
    // Transaction A: Uses SequenceNumber(5)
    let raw_txn_a = RawTransaction::new_txn(
        sender_addr,
        ReplayProtector::SequenceNumber(5),
        executable.clone(),
        None,
        500_000,
        100,
        0,
        ChainId::new(10),
    );
    let txn_a = raw_txn_a
        .sign(&sender_privkey, sender_pubkey.clone())
        .unwrap()
        .into_inner();
    
    // Transaction B: Uses Nonce(999) - SAME payload, DIFFERENT replay protector type
    let raw_txn_b = RawTransaction::new_txn(
        sender_addr,
        ReplayProtector::Nonce(999),
        executable,
        None,
        500_000,
        100,
        0,
        ChainId::new(10),
    );
    let txn_b = raw_txn_b
        .sign(&sender_privkey, sender_pubkey)
        .unwrap()
        .into_inner();
    
    // Verify they have different replay protectors
    assert_ne!(txn_a.replay_protector(), txn_b.replay_protector());
    
    // Submit both to deduper
    let txns = vec![txn_a.clone(), txn_b.clone()];
    let deduped = deduper.dedup(txns);
    
    // VULNERABILITY: Both transactions pass through deduplication!
    // Expected: Only 1 transaction (they should be considered duplicates)
    // Actual: 2 transactions (deduper doesn't catch them)
    assert_eq!(deduped.len(), 2, "VULNERABILITY: Deduper failed to catch duplicate transactions with different ReplayProtector types");
    
    // Both transactions would execute in the VM:
    // - txn_a checks sequence_number == 5
    // - txn_b checks nonce 999 not used
    // These are INDEPENDENT checks -> BOTH execute -> DOUBLE TRANSFER
}
```

This test demonstrates that two transactions with identical payloads but different `ReplayProtector` types bypass the deduplication logic, enabling double execution attacks.

### Citations

**File:** consensus/src/txn_hash_and_authenticator_deduper.rs (L44-54)
```rust
        for (i, txn) in transactions.iter().enumerate() {
            match seen.get(&(txn.sender(), txn.replay_protector())) {
                None => {
                    seen.insert((txn.sender(), txn.replay_protector()), i);
                },
                Some(first_index) => {
                    is_possible_duplicate = true;
                    possible_duplicates[*first_index] = true;
                    possible_duplicates[i] = true;
                },
            }
```

**File:** types/src/transaction/mod.rs (L112-116)
```rust
#[derive(Debug, Copy, Clone, Eq, PartialEq, PartialOrd, Ord, Hash, Serialize, Deserialize)]
pub enum ReplayProtector {
    Nonce(u64),
    SequenceNumber(u64),
}
```

**File:** types/src/transaction/mod.rs (L159-167)
```rust
    #[test]
    fn test_replay_protector_order() {
        let nonce = ReplayProtector::Nonce(1);
        let sequence_number = ReplayProtector::SequenceNumber(1);
        assert!(nonce < sequence_number);

        let nonce = ReplayProtector::Nonce(2);
        let sequence_number = ReplayProtector::SequenceNumber(1);
        assert!(nonce < sequence_number);
```

**File:** types/src/transaction/mod.rs (L313-344)
```rust
        match replay_protector {
            ReplayProtector::SequenceNumber(sequence_number) => RawTransaction {
                sender,
                sequence_number,
                payload: TransactionPayload::Payload(TransactionPayloadInner::V1 {
                    executable,
                    extra_config: TransactionExtraConfig::V1 {
                        multisig_address,
                        replay_protection_nonce: None,
                    },
                }),
                max_gas_amount,
                gas_unit_price,
                expiration_timestamp_secs,
                chain_id,
            },
            ReplayProtector::Nonce(nonce) => RawTransaction {
                sender,
                sequence_number: u64::MAX,
                payload: TransactionPayload::Payload(TransactionPayloadInner::V1 {
                    executable,
                    extra_config: TransactionExtraConfig::V1 {
                        multisig_address,
                        replay_protection_nonce: Some(nonce),
                    },
                }),
                max_gas_amount,
                gas_unit_price,
                expiration_timestamp_secs,
                chain_id,
            },
        }
```

**File:** types/src/transaction/mod.rs (L579-585)
```rust
    pub fn replay_protector(&self) -> ReplayProtector {
        if let Some(nonce) = self.payload.replay_protection_nonce() {
            ReplayProtector::Nonce(nonce)
        } else {
            ReplayProtector::SequenceNumber(self.sequence_number)
        }
    }
```

**File:** types/src/transaction/mod.rs (L768-776)
```rust
#[derive(Clone, Debug, Hash, Eq, PartialEq, Serialize, Deserialize)]
pub enum TransactionExtraConfig {
    V1 {
        multisig_address: Option<AccountAddress>,
        // None for regular transactions
        // Some(nonce) for orderless transactions
        replay_protection_nonce: Option<u64>,
    },
}
```

**File:** aptos-move/framework/aptos-framework/sources/transaction_validation.move (L169-185)
```text
        // Check for replay protection
        match (replay_protector) {
            SequenceNumber(txn_sequence_number) => {
                check_for_replay_protection_regular_txn(
                    sender_address,
                    gas_payer_address,
                    txn_sequence_number,
                );
            },
            Nonce(nonce) => {
                check_for_replay_protection_orderless_txn(
                    sender_address,
                    nonce,
                    txn_expiration_time,
                );
            }
        };
```

**File:** aptos-move/framework/aptos-framework/sources/transaction_validation.move (L215-250)
```text
    fun check_for_replay_protection_regular_txn(
        sender_address: address,
        gas_payer_address: address,
        txn_sequence_number: u64,
    ) {
        if (
            sender_address == gas_payer_address
                || account::exists_at(sender_address)
                || !features::sponsored_automatic_account_creation_enabled()
                || txn_sequence_number > 0
        ) {
            assert!(account::exists_at(sender_address), error::invalid_argument(PROLOGUE_EACCOUNT_DOES_NOT_EXIST));
            let account_sequence_number = account::get_sequence_number(sender_address);
            assert!(
                txn_sequence_number < (1u64 << 63),
                error::out_of_range(PROLOGUE_ESEQUENCE_NUMBER_TOO_BIG)
            );

            assert!(
                txn_sequence_number >= account_sequence_number,
                error::invalid_argument(PROLOGUE_ESEQUENCE_NUMBER_TOO_OLD)
            );

            assert!(
                txn_sequence_number == account_sequence_number,
                error::invalid_argument(PROLOGUE_ESEQUENCE_NUMBER_TOO_NEW)
            );
        } else {
            // In this case, the transaction is sponsored and the account does not exist, so ensure
            // the default values match.
            assert!(
                txn_sequence_number == 0,
                error::invalid_argument(PROLOGUE_ESEQUENCE_NUMBER_TOO_NEW)
            );
        };
    }
```

**File:** aptos-move/framework/aptos-framework/sources/transaction_validation.move (L252-263)
```text
    fun check_for_replay_protection_orderless_txn(
        sender: address,
        nonce: u64,
        txn_expiration_time: u64,
    ) {
        // prologue_common already checks that the current_time > txn_expiration_time
        assert!(
            txn_expiration_time <= timestamp::now_seconds() + MAX_EXP_TIME_SECONDS_FOR_ORDERLESS_TXNS,
            error::invalid_argument(PROLOGUE_ETRANSACTION_EXPIRATION_TOO_FAR_IN_FUTURE),
        );
        assert!(nonce_validation::check_and_insert_nonce(sender, nonce, txn_expiration_time), error::invalid_argument(PROLOGUE_ENONCE_ALREADY_USED));
    }
```

**File:** aptos-move/framework/aptos-framework/sources/nonce_validation.move (L39-47)
```text
    struct NonceHistory has key {
        // Key = sip_hash(NonceKey) % NUM_BUCKETS
        // Value = Bucket
        nonce_table: Table<u64, Bucket>,
        // Used to facilitate prefill the nonce_table with empty buckets
        // one by one using `add_nonce_bucket` method.
        // This is the next_key to prefill with an empty bucket
        next_key: u64,
    }
```
