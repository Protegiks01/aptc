# Audit Report

## Title
Integer Underflow in Validator Transaction Accounting Allows Violation of Soft Transaction Limits

## Summary
The `pull_payload()` function in `MixedPayloadClient` performs unchecked subtraction when adjusting the soft transaction limit after pulling validator transactions. When governance-controlled validator transaction limits exceed backpressure-reduced soft limits, this causes integer underflow leading to either validator node panics (debug mode) or excessive user transaction inclusion (release mode).

## Finding Description

The vulnerability exists in the payload pulling logic where validator transactions are prioritized before user transactions. [1](#0-0) 

The code performs direct u64 subtraction without bounds checking. The `soft_max_txns_after_filtering` parameter can be reduced to as low as 5 transactions under extreme backpressure conditions. [2](#0-1) 

Meanwhile, the validator transaction limit is controlled by on-chain governance through `ValidatorTxnConfig`. [3](#0-2) 

The default validator transaction limit is 2, but governance can increase this value through on-chain configuration updates. [4](#0-3) 

When pulling validator transactions, the limit is computed as the minimum of the block transaction count and the governance-configured limit. [5](#0-4) 

**Attack Scenario:**
1. Governance legitimately increases `per_block_limit_txn_count` to 10 to accommodate more validator transactions (DKG, randomness, etc.)
2. Network experiences high load, triggering extreme backpressure
3. Backpressure reduces `soft_max_txns_after_filtering` to 5 via execution backpressure mechanisms [6](#0-5) 
4. The soft limit is set to the reduced value [7](#0-6) 
5. When pulling payload, 10 validator transactions are available and pulled (min(large_value, 10) = 10)
6. Subtraction `5 - 10` underflows:
   - **Debug mode**: Panic, validator node crash
   - **Release mode**: Wraps to `18,446,744,073,709,551,611`, allowing virtually unlimited user transactions

The system lacks validation to ensure validator transaction limits are compatible with potential backpressure values. [8](#0-7) 

## Impact Explanation

**Medium to High Severity:**

**Debug Mode Impact (High):**
- Validator node panics and crashes
- Affects consensus participation and network liveness
- Qualifies as "Validator node slowdowns" and "API crashes" per High severity criteria

**Release Mode Impact (Medium to High):**
- Soft transaction limit violated by orders of magnitude
- Could pull excessive user transactions beyond intended backpressure constraints
- Potential memory exhaustion or block size violations
- May cause "State inconsistencies requiring intervention" (Medium severity)
- Could escalate to "Significant protocol violations" (High severity) if excessive transactions cause consensus divergence

The vulnerability breaks **Resource Limits** invariant (Critical Invariant #9): "All operations must respect gas, storage, and computational limits."

## Likelihood Explanation

**Moderate to High Likelihood:**

The vulnerability occurs through the interaction of two legitimate system behaviors:
1. **Governance configuration**: Increasing validator transaction limits is reasonable for supporting more protocol features
2. **Backpressure activation**: Automatically triggered under high load/latency conditions

The extreme backpressure configuration values (reduction to 5 transactions) are present in the default production configuration. [9](#0-8) 

No validation prevents governance from setting validator transaction limits that exceed minimum backpressure thresholds. Any validator transaction limit above 5 creates the vulnerability window, and limits of 6-20 are plausibly reasonable for protocol evolution.

The vulnerability is more likely in release builds where underflow wraps silently rather than panicking, making it harder to detect until it causes downstream effects.

## Recommendation

Implement validation and safe arithmetic:

1. **Add configuration validation** - Ensure `per_block_limit_txn_count` cannot exceed `min_max_txns_in_block_after_filtering_from_backpressure`:

```rust
// In consensus_config.rs sanitize method
if let ValidatorTxnConfig::V1 { per_block_limit_txn_count, .. } = &vtxn_config {
    ensure!(
        *per_block_limit_txn_count <= consensus_config.min_max_txns_in_block_after_filtering_from_backpressure,
        "per_block_limit_txn_count ({}) exceeds minimum backpressure limit ({})",
        per_block_limit_txn_count,
        consensus_config.min_max_txns_in_block_after_filtering_from_backpressure
    );
}
```

2. **Use saturating subtraction** in mixed.rs:

```rust
user_txn_pull_params.soft_max_txns_after_filtering = 
    user_txn_pull_params.soft_max_txns_after_filtering
        .saturating_sub(validator_txns.len() as u64);
```

3. **Add runtime assertion** before subtraction:

```rust
debug_assert!(
    validator_txns.len() as u64 <= user_txn_pull_params.soft_max_txns_after_filtering,
    "Validator transaction count {} exceeds soft limit {}",
    validator_txns.len(),
    user_txn_pull_params.soft_max_txns_after_filtering
);
```

## Proof of Concept

```rust
// Rust unit test demonstrating the underflow
#[test]
fn test_validator_txn_soft_limit_underflow() {
    // Simulate extreme backpressure scenario
    let soft_max_txns_after_filtering: u64 = 5; // From extreme backpressure
    let validator_txn_count: u64 = 10; // Governance set per_block_limit_txn_count = 10
    
    // This will underflow in release mode
    let result = soft_max_txns_after_filtering.wrapping_sub(validator_txn_count);
    
    assert_eq!(result, 18_446_744_073_709_551_611_u64); // u64::MAX - 5
    
    // In production, this massive value would be passed to user transaction pull,
    // potentially causing memory exhaustion or protocol violations
}

// Integration test scenario:
// 1. Deploy network with ValidatorTxnConfig::V1 { per_block_limit_txn_count: 10, .. }
// 2. Inject 10 validator transactions into validator transaction pool
// 3. Trigger extreme backpressure (high pipeline latency or low voting power)
// 4. Propose block - will crash in debug mode or exhibit undefined behavior in release mode
```

**Notes:**

The vulnerability represents a failure to validate the interaction between two independent configuration parameters. While the default configuration (validator limit = 2, minimum backpressure limit = 5) is safe, the system permits governance to create unsafe configurations without validation. This is a classic example of parameter interdependency bugs in distributed systems where local validation of each parameter is insufficient without cross-parameter constraint checking.

### Citations

**File:** consensus/src/payload_client/mixed.rs (L65-79)
```rust
        let mut validator_txns = self
            .validator_txn_pool_client
            .pull(
                params.max_poll_time,
                min(
                    params.max_txns.count(),
                    self.validator_txn_config.per_block_limit_txn_count(),
                ),
                min(
                    params.max_txns.size_in_bytes(),
                    self.validator_txn_config.per_block_limit_total_bytes(),
                ),
                validator_txn_filter,
            )
            .await;
```

**File:** consensus/src/payload_client/mixed.rs (L92-95)
```rust
        let mut user_txn_pull_params = params;
        user_txn_pull_params.max_txns -= vtxn_size;
        user_txn_pull_params.max_txns_after_filtering -= validator_txns.len() as u64;
        user_txn_pull_params.soft_max_txns_after_filtering -= validator_txns.len() as u64;
```

**File:** config/src/config/consensus_config.rs (L258-263)
```rust
            min_max_txns_in_block_after_filtering_from_backpressure: MIN_BLOCK_TXNS_AFTER_FILTERING,
            execution_backpressure: Some(ExecutionBackpressureConfig {
                txn_limit: Some(ExecutionBackpressureTxnLimitConfig::default()),
                gas_limit: Some(ExecutionBackpressureGasLimitConfig::default()),
            }),
            pipeline_backpressure: vec![
```

**File:** config/src/config/consensus_config.rs (L309-316)
```rust
                PipelineBackpressureValues {
                    back_pressure_pipeline_latency_limit_ms: 6000,
                    // in practice, latencies and delay make it such that ~2 blocks/s is max,
                    // meaning that most aggressively we limit to ~10 TPS
                    // For transactions that are more expensive than that, we should
                    // instead rely on max gas per block to limit latency.
                    max_sending_block_txns_after_filtering_override: 5,
                    max_sending_block_bytes_override: MIN_BLOCK_BYTES_OVERRIDE,
```

**File:** config/src/config/consensus_config.rs (L503-532)
```rust
impl ConfigSanitizer for ConsensusConfig {
    fn sanitize(
        node_config: &NodeConfig,
        node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();

        // Verify that the safety rules and quorum store configs are valid
        SafetyRulesConfig::sanitize(node_config, node_type, chain_id)?;
        QuorumStoreConfig::sanitize(node_config, node_type, chain_id)?;

        // Verify that the consensus-only feature is not enabled in mainnet
        if let Some(chain_id) = chain_id {
            if chain_id.is_mainnet() && is_consensus_only_perf_test_enabled() {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "consensus-only-perf-test should not be enabled in mainnet!".to_string(),
                ));
            }
        }

        // Sender block limits must be <= receiver block limits
        Self::sanitize_send_recv_block_limits(&sanitizer_name, &node_config.consensus)?;

        // Quorum store batches must be <= consensus blocks
        Self::sanitize_batch_block_limits(&sanitizer_name, &node_config.consensus)?;

        Ok(())
    }
```

**File:** types/src/on_chain_config/consensus_config.rs (L125-126)
```rust
const VTXN_CONFIG_PER_BLOCK_LIMIT_TXN_COUNT_DEFAULT: u64 = 2;
const VTXN_CONFIG_PER_BLOCK_LIMIT_TOTAL_BYTES_DEFAULT: u64 = 2097152; //2MB
```

**File:** types/src/on_chain_config/consensus_config.rs (L128-137)
```rust
#[derive(Clone, Debug, Deserialize, PartialEq, Eq, Serialize)]
pub enum ValidatorTxnConfig {
    /// Disabled. In Jolteon, it also means to not use `BlockType::ProposalExt`.
    V0,
    /// Enabled. Per-block vtxn count and their total bytes are limited.
    V1 {
        per_block_limit_txn_count: u64,
        per_block_limit_total_bytes: u64,
    },
}
```

**File:** consensus/src/liveness/proposal_generator.rs (L659-660)
```rust
                    soft_max_txns_after_filtering: max_txns_from_block_to_execute
                        .unwrap_or(max_block_txns_after_filtering),
```

**File:** consensus/src/liveness/proposal_generator.rs (L827-837)
```rust
        let (max_block_txns_after_filtering, max_txns_from_block_to_execute) = if self
            .min_max_txns_in_block_after_filtering_from_backpressure
            > max_block_txns_after_filtering
        {
            (
                self.min_max_txns_in_block_after_filtering_from_backpressure,
                Some(max_block_txns_after_filtering),
            )
        } else {
            (max_block_txns_after_filtering, None)
        };
```
