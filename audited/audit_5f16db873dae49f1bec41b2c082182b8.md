# Audit Report

## Title
Consensus Divergence Risk from Unvalidated Invariant Assumption in Delayed Field Delta Checks

## Summary
The `delayed_field_try_add_delta_outcome()` function in `ExecutorViewWithChangeSet` uses `expect_ok()` to wrap a delta addition operation that could fail due to overflow/underflow. This assumes a critical invariant: that `base_delta` has been pre-validated against the current value. If this invariant is violated due to bugs elsewhere in the system, different validators could experience different error paths, causing consensus divergence.

## Finding Description

The code at line 180 in `view_with_change_set.rs` performs the following operation: [1](#0-0) 

The `expect_ok()` function converts `BoundedMathError` (Overflow/Underflow) into a `PanicError`, treating it as a code invariant violation: [2](#0-1) 

The invariant being assumed is documented in the trait definition: [3](#0-2) 

**The vulnerability**: If validators somehow have different input states—either different `value` in their `VMChangeSet` or different `base_delta` values—the bounded math operation will produce different outcomes:
- Validators with `value + base_delta > max_value`: Overflow → `PanicError` → transaction fails
- Validators with `value + base_delta ≤ max_value`: Success → transaction continues
- **Result: Consensus divergence (Critical Severity)**

The same pattern exists in the parallel execution path: [4](#0-3) 

**Root Cause Analysis**: The code assumes perfect state consistency across validators. However, this assumption is fragile:

1. **Respawned Sessions**: When epilogue code runs with `ExecutorViewWithChangeSet` overlaying a previous session's change set, if the epilogue attempts delta operations with non-zero `base_delta`, it must trust that `base_delta` was validated against the same `value` stored in the change set.

2. **No Runtime Validation**: There is no check that `base_delta` is consistent with the stored `value`. The code trusts that the caller correctly accumulated `base_delta`.

3. **Error Handling**: Using `expect_ok` treats overflow/underflow as a code bug rather than a recoverable error, making the system fragile to any state inconsistencies.

## Impact Explanation

**Critical Severity - Consensus/Safety Violation**

If this code path produces different outcomes on different validators:
- **Consensus breaks immediately**: Validators produce different state roots for the same block
- **Chain split**: Network partitions into validators that succeeded vs. failed the transaction
- **Requires hard fork**: No automatic recovery mechanism exists
- **Total loss of liveness**: Network cannot make progress until manual intervention

This directly violates **Critical Invariant #1: Deterministic Execution** - "All validators must produce identical state roots for identical blocks."

Per Aptos Bug Bounty criteria, consensus/safety violations are Critical Severity (up to $1,000,000).

## Likelihood Explanation

**Likelihood: LOW (requires pre-existing bug)**

Under normal operation, this vulnerability **should not** trigger because:
1. Block-STM ensures deterministic execution through validation and re-execution
2. All validators execute identical transaction sequences
3. VMChangeSets should be identical across validators
4. `base_delta` accumulation follows deterministic rules

**However**, the vulnerability becomes exploitable IF:
- Bug in Block-STM parallel execution causes state divergence
- Race condition in delta accumulation logic
- Bug in VMChangeSet merging during respawned sessions
- Non-deterministic native function behavior
- Memory corruption or hardware errors

The vulnerability is a **latent time bomb**: it doesn't cause problems until some other bug triggers state divergence, at which point it amplifies the divergence into catastrophic consensus failure.

## Recommendation

**Replace `expect_ok` with proper error handling**:

```rust
fn delayed_field_try_add_delta_outcome(
    &self,
    id: &Self::Identifier,
    base_delta: &SignedU128,
    delta: &SignedU128,
    max_value: u128,
) -> Result<bool, PanicOr<DelayedFieldsSpeculativeError>> {
    use DelayedChange::*;

    let math = BoundedMath::new(max_value);
    match self.change_set.delayed_field_change_set().get(id) {
        Some(Create(value)) => {
            // FIX: Handle overflow/underflow as a normal error, not code invariant violation
            let prev_value = match math.unsigned_add_delta(
                value.clone().into_aggregator_value()?, 
                base_delta
            ) {
                Ok(v) => v,
                Err(_) => {
                    // Log warning about unexpected base_delta
                    return Err(code_invariant_error(format!(
                        "base_delta {:?} cannot be applied to Create(value={:?}) for id {:?} with max {}",
                        base_delta, value, id, max_value
                    )).into());
                }
            };
            Ok(math.unsigned_add_delta(prev_value, delta).is_ok())
        }
        // ... rest of implementation
    }
}
```

**Better yet, validate the invariant**:

```rust
// Add validation that base_delta is zero for Create entries
Some(Create(value)) => {
    if !base_delta.is_zero() {
        return Err(code_invariant_error(format!(
            "Non-zero base_delta {:?} passed for Create entry, this violates the calling convention",
            base_delta
        )).into());
    }
    let aggregator_value = value.clone().into_aggregator_value()?;
    Ok(math.unsigned_add_delta(aggregator_value, delta).is_ok())
}
```

Apply the same fix to the parallel execution path: [5](#0-4) 

## Proof of Concept

This vulnerability cannot be directly exploited without first triggering a state divergence bug. Here's a **conceptual** PoC showing how state divergence would lead to consensus failure:

```rust
// Hypothetical scenario demonstrating the issue
// (requires simulating a state divergence bug)

fn test_consensus_divergence_via_expect_ok() {
    // Setup: Two validators with artificially divergent state
    
    // Validator A's state
    let mut change_set_a = VMChangeSet::new();
    change_set_a.add_delayed_field_change(
        field_id,
        DelayedChange::Create(DelayedFieldValue::Aggregator(100))
    );
    let view_a = ExecutorViewWithChangeSet::new(&base_view, &group_view, change_set_a);
    
    // Validator B's state (DIFFERENT due to hypothetical bug)
    let mut change_set_b = VMChangeSet::new();
    change_set_b.add_delayed_field_change(
        field_id,
        DelayedChange::Create(DelayedFieldValue::Aggregator(150)) // Different!
    );
    let view_b = ExecutorViewWithChangeSet::new(&base_view, &group_view, change_set_b);
    
    // Both try the same operation with base_delta=60, max_value=140
    let base_delta = SignedU128::Positive(60);
    let delta = SignedU128::Positive(5);
    let max_value = 140;
    
    // Validator A: 100 + 60 = 160 > 140 → Overflow → PanicError
    let result_a = view_a.delayed_field_try_add_delta_outcome(
        &field_id, &base_delta, &delta, max_value
    );
    assert!(result_a.is_err()); // Gets PanicError
    
    // Validator B: 150 + 60 would overflow, but let's say base_delta was different
    // This demonstrates how state divergence leads to consensus failure
}
```

**Note**: A real PoC would require:
1. Identifying an actual bug that causes state divergence
2. Demonstrating that it leads to this specific code path
3. Showing different validators get different results

Without such a bug, this remains a theoretical vulnerability.

## Notes

This is fundamentally a **defensive programming issue** that becomes a **consensus vulnerability** only when combined with other bugs. The `expect_ok` usage makes the system brittle and non-resilient to state inconsistencies that might arise from bugs elsewhere.

**Key observations**:
1. The documented invariant (base_delta is pre-validated) is assumed but not enforced at runtime
2. The error handling converts normal errors (overflow/underflow) into code invariant violations
3. Under correct execution, all validators should behave identically
4. If execution diverges for any reason, this code amplifies the divergence into consensus failure

**Recommended additional hardening**:
- Add runtime validation that `base_delta` is appropriate for the stored value
- Add telemetry/alerts when this code path is hit
- Consider fallback logic if validation fails
- Audit all callers to ensure they correctly compute `base_delta`

### Citations

**File:** aptos-move/aptos-vm/src/move_vm_ext/session/view_with_change_set.rs (L179-181)
```rust
            Some(Create(value)) => {
                let prev_value = expect_ok(math.unsigned_add_delta(value.clone().into_aggregator_value()?, base_delta))?;
                Ok(math.unsigned_add_delta(prev_value, delta).is_ok())
```

**File:** types/src/error.rs (L33-35)
```rust
pub fn expect_ok<V, E: std::fmt::Debug>(value: Result<V, E>) -> Result<V, PanicError> {
    value.map_err(|e| code_invariant_error(format!("Expected Ok, got Err({:?})", e)))
}
```

**File:** aptos-move/aptos-aggregator/src/resolver.rs (L145-157)
```rust
    /// Fetch an outcome of whether additional delta can be applied.
    /// `base_delta` argument represents a cumulative value that we previously checked,
    /// and `delta` argument represents a new increment.
    /// (This allows method to be stateless, and not require it to store previous calls,
    /// i.e. for sequential execution)
    ///
    /// For example, calls would go like this:
    /// try_add_delta_outcome(base_delta = 0, delta = 5) -> true
    /// try_add_delta_outcome(base_delta = 5, delta = 3) -> true
    /// try_add_delta_outcome(base_delta = 8, delta = 2) -> false
    /// try_add_delta_outcome(base_delta = 8, delta = 3) -> false
    /// try_add_delta_outcome(base_delta = 8, delta = -3) -> true
    /// try_add_delta_outcome(base_delta = 5, delta = 2) -> true
```

**File:** aptos-move/block-executor/src/view.rs (L405-411)
```rust
        Some(DelayedFieldRead::Value { value }) => {
            let math = BoundedMath::new(max_value);
            let before = expect_ok(
                math.unsigned_add_delta(value.clone().into_aggregator_value()?, base_delta),
            )?;
            Ok(math.unsigned_add_delta(before, delta).is_ok())
        },
```
