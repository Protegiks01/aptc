# Audit Report

## Title
Vault Authentication Token Exposure in Node Configuration Logging

## Summary
The `Token` enum in `aptos_config` derives `Debug` and can contain plaintext authentication tokens via the `FromConfig` variant. When node configuration is logged at startup, these tokens are exposed in plaintext logs, allowing attackers with log access to compromise secure storage backends.

## Finding Description

The vulnerability exists in the token handling configuration system. The `Token` enum is defined with automatic `Debug` derivation: [1](#0-0) 

This Token type is embedded in `VaultConfig`, which also derives `Debug`: [2](#0-1) 

The VaultConfig is part of the `SecureBackend` enum used in critical security configurations: [3](#0-2) 

This SecureBackend is used in SafetyRulesConfig for consensus security: [4](#0-3) 

When a node starts, the configuration is logged with debug formatting: [5](#0-4) 

While the logger masks postgres passwords, **it does not mask Vault tokens**. When `Token::FromConfig` is used (storing the token directly in configuration), the `Debug` implementation will print the plaintext token value in the logs.

The attack path:
1. Validator operator configures Vault backend with `Token::FromConfig` containing plaintext token
2. Node starts and logs configuration using `{:?}` format
3. Logs contain: `token: FromConfig("hvs.CAES[...]plaintext_token")`
4. Attacker with log access (via compromised monitoring, log aggregation, or filesystem access) obtains the Vault token
5. Attacker uses token to access secure storage, potentially compromising consensus keys, validator identity, or waypoint data

## Impact Explanation

This is **HIGH severity** under the Aptos bug bounty criteria for the following reasons:

1. **Credential Exposure**: Vault tokens provide authentication to secure storage containing consensus safety rules, validator keys, and critical security data
2. **Validator Compromise**: An attacker with vault access can read/modify validator keys, potentially leading to equivocation or consensus manipulation
3. **Broad Attack Surface**: Any system with access to node logs (monitoring tools, log aggregation, backup systems) becomes an attack vector
4. **Persistent Vulnerability**: Tokens remain valid until explicitly revoked, giving attackers an extended window for exploitation

While not reaching CRITICAL severity (which requires direct fund loss or consensus breaks), it enables significant protocol violations and validator node compromise, qualifying as HIGH severity.

## Likelihood Explanation

**Likelihood: MEDIUM to HIGH**

This vulnerability will materialize when:
- Operators use `Token::FromConfig` instead of `Token::FromDisk` (configuration choice)
- Node logs are accessible to unauthorized parties (common in production environments)
- Logs are retained or transmitted insecurely (logging aggregation, monitoring systems)

Many production systems use centralized logging, making log access a realistic attack vector. The codebase shows awareness of similar issues (postgres password masking), but this specific case was overlooked.

## Recommendation

Implement custom `Debug` formatting for the `Token` enum to redact sensitive data:

```rust
// In config/src/config/secure_backend_config.rs

// Remove Debug from derive macro on line 100
#[derive(Clone, Deserialize, PartialEq, Eq, Serialize)]
#[serde(rename_all = "snake_case")]
pub enum Token {
    FromConfig(String),
    FromDisk(PathBuf),
}

// Add custom Debug implementation
impl std::fmt::Debug for Token {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Token::FromConfig(_) => write!(f, "FromConfig(***REDACTED***)"),
            Token::FromDisk(path) => write!(f, "FromDisk({:?})", path),
        }
    }
}
```

Additionally, consider implementing a `SilentDisplay` pattern similar to the existing pattern used elsewhere in the codebase for other secrets.

Secondary recommendations:
1. Audit all configuration structures containing secrets for similar Debug exposure
2. Add lint rules to prevent Debug derivation on types containing secrets
3. Document security requirements for Token usage in configuration
4. Prefer `Token::FromDisk` in production documentation and examples

## Proof of Concept

```rust
// Reproduction demonstrating token exposure
use aptos_config::config::{Token, VaultConfig, SecureBackend, SafetyRulesConfig};
use std::path::PathBuf;

fn main() {
    // Create a VaultConfig with Token::FromConfig containing sensitive data
    let vault_config = VaultConfig {
        ca_certificate: None,
        namespace: Some("test".to_string()),
        renew_ttl_secs: None,
        server: "http://vault:8200".to_string(),
        token: Token::FromConfig("hvs.CAESIR0P8zy9sensitive_token_here".to_string()),
        disable_cas: None,
        connection_timeout_ms: None,
        response_timeout_ms: None,
    };
    
    let backend = SecureBackend::Vault(vault_config);
    let safety_config = SafetyRulesConfig {
        backend,
        ..Default::default()
    };
    
    // This is what happens in aptos-node/src/logger.rs:101
    println!("Config: {:?}", safety_config);
    
    // Output will contain:
    // backend: Vault(VaultConfig { token: FromConfig("hvs.CAESIR0P8zy9sensitive_token_here"), ... })
    // The token is exposed in plaintext!
}
```

To verify:
1. Configure a test node with Vault backend using `Token::FromConfig`
2. Start the node and check logs
3. Grep for "token:" or "FromConfig" in logs
4. Observe plaintext token exposure

## Notes

This vulnerability demonstrates a systemic issue where sensitive configuration data lacks proper protection in logging contexts. The codebase shows awareness of this pattern (postgres password masking at line 93-96 of logger.rs), but the protection was not applied consistently to all credential types.

The issue specifically affects deployments using `Token::FromConfig`. Deployments using `Token::FromDisk` are less affected as only the file path is logged, not the token content. However, the path itself may still leak sensitive directory structure information.

### Citations

**File:** config/src/config/secure_backend_config.rs (L16-22)
```rust
#[derive(Clone, Debug, Deserialize, PartialEq, Eq, Serialize)]
#[serde(rename_all = "snake_case", tag = "type")]
pub enum SecureBackend {
    InMemoryStorage,
    Vault(VaultConfig),
    OnDiskStorage(OnDiskStorageConfig),
}
```

**File:** config/src/config/secure_backend_config.rs (L51-74)
```rust
#[derive(Clone, Debug, Deserialize, PartialEq, Eq, Serialize)]
#[serde(deny_unknown_fields)]
pub struct VaultConfig {
    /// Optional SSL Certificate for the vault host, this is expected to be a full path.
    pub ca_certificate: Option<PathBuf>,
    /// A namespace is an optional portion of the path to a key stored within Vault. For example,
    /// a secret, S, without a namespace would be available in secret/data/S, with a namespace, N, it
    /// would be in secret/data/N/S.
    pub namespace: Option<String>,
    /// Vault leverages leases on many tokens, specify this to automatically have your lease
    /// renewed up to that many seconds more. If this is not specified, the lease will not
    /// automatically be renewed.
    pub renew_ttl_secs: Option<u32>,
    /// Vault's URL, note: only HTTP is currently supported.
    pub server: String,
    /// The authorization token for accessing secrets
    pub token: Token,
    /// Disable check-and-set when writing secrets to Vault
    pub disable_cas: Option<bool>,
    /// Timeout for new vault socket connections, in milliseconds.
    pub connection_timeout_ms: Option<u64>,
    /// Timeout for generic vault operations (e.g., reads and writes), in milliseconds.
    pub response_timeout_ms: Option<u64>,
}
```

**File:** config/src/config/secure_backend_config.rs (L100-106)
```rust
#[derive(Clone, Debug, Deserialize, PartialEq, Eq, Serialize)]
#[serde(rename_all = "snake_case")]
pub enum Token {
    FromConfig(String),
    /// This is an absolute path and not relative to data_dir
    FromDisk(PathBuf),
}
```

**File:** config/src/config/safety_rules_config.rs (L23-34)
```rust
#[derive(Clone, Debug, Deserialize, PartialEq, Serialize)]
#[serde(default, deny_unknown_fields)]
pub struct SafetyRulesConfig {
    pub backend: SecureBackend,
    pub logger: LoggerConfig,
    pub service: SafetyRulesService,
    pub test: Option<SafetyRulesTestConfig>,
    // Read/Write/Connect networking operation timeout in milliseconds.
    pub network_timeout_ms: u64,
    pub enable_cached_safety_data: bool,
    pub initial_safety_rules_config: InitialSafetyRulesConfig,
}
```

**File:** aptos-node/src/logger.rs (L90-101)
```rust
    let mut masked_config;
    if let Some(u) = &node_config.indexer.postgres_uri {
        let mut parsed_url = url::Url::parse(u).expect("Invalid postgres uri");
        if parsed_url.password().is_some() {
            masked_config = node_config.clone();
            parsed_url.set_password(Some("*")).unwrap();
            masked_config.indexer.postgres_uri = Some(parsed_url.to_string());
            config = &masked_config;
        }
    }

    info!("Loaded node config: {:?}", config);
```
