# Audit Report

## Title
Missing Equivocation Detection in Order Vote Aggregation Enables Consensus Safety Violation

## Summary
The order vote aggregation system lacks equivocation detection, allowing a single malicious validator to sign multiple conflicting order votes for different blocks at the same round. This enables consensus safety violations by causing different subsets of validators to commit different blocks, breaking the fundamental BFT safety guarantee.

## Finding Description

The Aptos consensus protocol has a critical gap in order vote processing: unlike regular votes, order votes have no equivocation detection mechanism. This breaks the consensus safety invariant that prevents chain splits under < 1/3 Byzantine validators.

**Structural Deficiency in Order Vote Processing:**

The `PendingOrderVotes` structure only tracks votes by ledger info digest, with no author tracking: [1](#0-0) 

In contrast, regular votes in `PendingVotes` maintain an `author_to_vote` HashMap to detect equivocation: [2](#0-1) 

Regular votes explicitly detect equivocation: [3](#0-2) 

But order votes have NO such check - they simply add votes to the signature aggregator without author tracking: [4](#0-3) 

**Evidence from Test Suite:**

The test suite explicitly documents this missing functionality. The comment states equivocation should be detected, but the actual assertion shows it is NOT: [5](#0-4) 

**Safety Rules Gap:**

The safety rules for order votes also lack the critical `last_voted_round` check present in regular votes. Order voting only verifies the round is above the timeout round: [6](#0-5) 

Compare this to regular votes which strictly prevent double-voting: [7](#0-6) [8](#0-7) 

**Attack Scenario:**

1. Malicious validator V₁ receives QC for Block A at round R
2. V₁ creates OrderVoteProposal for Block A, passes through safety rules (no `last_voted_round` check), obtains validly signed OrderVote_A
3. V₁ also receives/creates QC for Block B at round R (equivocating block)
4. V₁ creates OrderVoteProposal for Block B, passes through safety rules again (no double-vote prevention), obtains validly signed OrderVote_B
5. V₁ sends OrderVote_A to validators {V₂, V₃} and OrderVote_B to validators {V₂, V₄}
6. V₂ receives both votes, both are accepted (no equivocation detection)
7. If V₂, V₃ vote for Block A: they form OrderCert_A with V₁'s signature
8. If V₂, V₄ vote for Block B: they form OrderCert_B with V₁'s signature
9. Result: Different validators commit different blocks at round R, violating consensus safety

## Impact Explanation

**Severity: Critical** (Consensus Safety Violation)

This vulnerability directly violates the core consensus safety guarantee: "AptosBFT must prevent double-spending and chain splits under < 1/3 Byzantine validators."

With only a single Byzantine validator (well under the 1/3 threshold), an attacker can:
- Create divergent blockchain states across the validator set
- Enable double-spending by committing conflicting transactions in different forks
- Cause permanent chain split requiring hard fork to resolve
- Break state consensus across the network

This meets the Critical severity criteria per Aptos Bug Bounty:
- **Consensus/Safety violations**: Direct breach of BFT safety
- **Non-recoverable network partition**: Different validators have irreconcilable states
- **Potential loss of funds**: Double-spending through conflicting order certificates

## Likelihood Explanation

**Likelihood: High**

The vulnerability is highly likely to be exploitable because:

1. **Low barrier to entry**: Requires only a single Byzantine validator (no collusion needed)
2. **No detection mechanisms**: Neither safety rules nor pending vote aggregation detect the attack
3. **Normal protocol operation**: Occurs during standard order vote processing
4. **Multiple attack vectors**: Can exploit during network partitions, equivocating leaders, or fork scenarios
5. **Persistent state divergence**: Once triggered, creates permanent inconsistency

The attack is especially likely during:
- Network instability or partitions where different blocks exist at the same round
- Epoch transitions where multiple valid blocks might be proposed
- Any scenario with equivocating block proposers

## Recommendation

Implement equivocation detection for order votes matching the mechanism used for regular votes:

**Step 1:** Add author tracking to `PendingOrderVotes`:

```rust
pub struct PendingOrderVotes {
    li_digest_to_votes: HashMap<HashValue, (QuorumCert, OrderVoteStatus)>,
    // Add author tracking to detect equivocation
    author_to_vote: HashMap<Author, (OrderVote, HashValue)>,
}
```

**Step 2:** Implement equivocation detection in `insert_order_vote`:

```rust
pub fn insert_order_vote(
    &mut self,
    order_vote: &OrderVote,
    validator_verifier: &ValidatorVerifier,
    verified_quorum_cert: Option<QuorumCert>,
) -> OrderVoteReceptionResult {
    let li_digest = order_vote.ledger_info().hash();
    
    // Check for equivocation
    if let Some((previous_vote, previous_li_digest)) = 
        self.author_to_vote.get(&order_vote.author())
    {
        if &li_digest != previous_li_digest {
            error!(
                SecurityEvent::ConsensusEquivocatingOrderVote,
                author = order_vote.author(),
                order_vote = order_vote,
                previous_vote = previous_vote
            );
            return OrderVoteReceptionResult::EquivocateVote(order_vote.author());
        }
    }
    
    // Store vote for equivocation detection
    self.author_to_vote.insert(
        order_vote.author(), 
        (order_vote.clone(), li_digest)
    );
    
    // ... rest of existing logic
}
```

**Step 3:** Add `EquivocateVote` variant to `OrderVoteReceptionResult`:

```rust
pub enum OrderVoteReceptionResult {
    VoteAdded(u128),
    NewLedgerInfoWithSignatures((Arc<QuorumCert>, LedgerInfoWithSignatures)),
    EquivocateVote(Author),  // Add this variant
    ErrorAddingVote(VerifyError),
    // ... existing variants
}
```

**Step 4:** Consider adding `last_ordered_vote_round` tracking in safety rules to prevent creating multiple order votes per round locally.

## Proof of Concept

```rust
#[test]
fn test_order_vote_equivocation_detection() {
    use aptos_consensus_types::{order_vote::OrderVote, quorum_cert::QuorumCert};
    use aptos_types::{
        block_info::BlockInfo, 
        ledger_info::LedgerInfo,
        validator_verifier::random_validator_verifier,
    };
    use aptos_crypto::HashValue;
    
    let (signers, verifier) = random_validator_verifier(4, Some(2), false);
    let mut pending_order_votes = PendingOrderVotes::new();
    
    // Create two different ledger infos for same round
    let li1 = LedgerInfo::new(
        BlockInfo::new(1, 0, HashValue::random(), HashValue::random(), 0, 0, None),
        HashValue::random(),
    );
    let li2 = LedgerInfo::new(
        BlockInfo::new(1, 0, HashValue::random(), HashValue::random(), 0, 0, None),
        HashValue::random(),
    );
    
    let qc = QuorumCert::dummy();
    
    // Same author votes for first block
    let vote1 = OrderVote::new_with_signature(
        signers[0].author(),
        li1.clone(),
        signers[0].sign(&li1).unwrap(),
    );
    
    assert_eq!(
        pending_order_votes.insert_order_vote(&vote1, &verifier, Some(qc.clone())),
        OrderVoteReceptionResult::VoteAdded(1)
    );
    
    // VULNERABILITY: Same author votes for different block - should detect equivocation!
    let vote2 = OrderVote::new_with_signature(
        signers[0].author(),
        li2.clone(),
        signers[0].sign(&li2).unwrap(),
    );
    
    // Currently returns VoteAdded(1) - SHOULD return EquivocateVote!
    let result = pending_order_votes.insert_order_vote(&vote2, &verifier, Some(qc.clone()));
    
    // This assertion PASSES with current code - proving the vulnerability
    assert_eq!(result, OrderVoteReceptionResult::VoteAdded(1));
    
    // This assertion SHOULD pass after fix
    // assert_eq!(result, OrderVoteReceptionResult::EquivocateVote(signers[0].author()));
}
```

## Notes

This vulnerability represents a fundamental gap in the order vote protocol's security implementation. While regular votes have comprehensive equivocation detection matching BFT safety requirements, order votes lack this critical protection. The evidence in the test suite (comment vs assertion mismatch) suggests this may be an incomplete implementation rather than an intentional design choice. The fix should align order vote security with regular vote security to maintain consensus safety guarantees under Byzantine conditions.

### Citations

**File:** consensus/src/pending_order_votes.rs (L39-45)
```rust
pub struct PendingOrderVotes {
    /// Maps LedgerInfo digest to associated signatures.
    /// Order vote status stores caches the information on whether the votes are enough to form a QC.
    /// We also store the QC that the order votes certify.
    li_digest_to_votes:
        HashMap<HashValue /* LedgerInfo digest */, (QuorumCert, OrderVoteStatus)>,
}
```

**File:** consensus/src/pending_order_votes.rs (L61-81)
```rust
    pub fn insert_order_vote(
        &mut self,
        order_vote: &OrderVote,
        validator_verifier: &ValidatorVerifier,
        verified_quorum_cert: Option<QuorumCert>,
    ) -> OrderVoteReceptionResult {
        // derive data from order vote
        let li_digest = order_vote.ledger_info().hash();

        // obtain the ledger info with signatures associated to the order vote's ledger info
        let (quorum_cert, status) = self.li_digest_to_votes.entry(li_digest).or_insert_with(|| {
            // if the ledger info with signatures doesn't exist yet, create it
            (
                verified_quorum_cert.expect(
                    "Quorum Cert is expected when creating a new entry in pending order votes",
                ),
                OrderVoteStatus::NotEnoughVotes(SignatureAggregator::new(
                    order_vote.ledger_info().clone(),
                )),
            )
        });
```

**File:** consensus/src/pending_order_votes.rs (L233-247)
```rust
        // same author voting for a different result -> EquivocateVote
        let li2 = random_ledger_info();
        let order_vote_2_author_1 = OrderVote::new_with_signature(
            signers[1].author(),
            li2.clone(),
            signers[1].sign(&li2).expect("Unable to sign ledger info"),
        );
        assert_eq!(
            pending_order_votes.insert_order_vote(
                &order_vote_2_author_1,
                &verifier,
                Some(qc.clone())
            ),
            OrderVoteReceptionResult::VoteAdded(1)
        );
```

**File:** consensus/src/pending_votes.rs (L164-176)
```rust
/// A PendingVotes structure keep track of votes
pub struct PendingVotes {
    /// Maps LedgerInfo digest to associated signatures.
    /// This might keep multiple LedgerInfos for the current round: either due to different proposals (byzantine behavior)
    /// or due to different NIL proposals (clients can have a different view of what block to extend).
    li_digest_to_votes: HashMap<HashValue /* LedgerInfo digest */, (usize, VoteStatus)>,
    /// Tracks all the signatures of the 2-chain timeout for the given round.
    maybe_2chain_timeout_votes: Option<TwoChainTimeoutVotes>,
    /// Map of Author to (vote, li_digest). This is useful to discard multiple votes.
    author_to_vote: HashMap<Author, (Vote, HashValue)>,
    /// Whether we have echoed timeout for this round.
    echo_timeout: bool,
}
```

**File:** consensus/src/pending_votes.rs (L287-309)
```rust
        if let Some((previously_seen_vote, previous_li_digest)) =
            self.author_to_vote.get(&vote.author())
        {
            // is it the same vote?
            if &li_digest == previous_li_digest {
                // we've already seen an equivalent vote before
                let new_timeout_vote = vote.is_timeout() && !previously_seen_vote.is_timeout();
                if !new_timeout_vote {
                    // it's not a new timeout vote
                    return VoteReceptionResult::DuplicateVote;
                }
            } else {
                // we have seen a different vote for the same round
                error!(
                    SecurityEvent::ConsensusEquivocatingVote,
                    remote_peer = vote.author(),
                    vote = vote,
                    previous_vote = previously_seen_vote
                );

                return VoteReceptionResult::EquivocateVote;
            }
        }
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L77-80)
```rust
        self.verify_and_update_last_vote_round(
            proposed_block.block_data().round(),
            &mut safety_data,
        )?;
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L168-178)
```rust
    fn safe_for_order_vote(&self, block: &Block, safety_data: &SafetyData) -> Result<(), Error> {
        let round = block.round();
        if round > safety_data.highest_timeout_round {
            Ok(())
        } else {
            Err(Error::NotSafeForOrderVote(
                round,
                safety_data.highest_timeout_round,
            ))
        }
    }
```

**File:** consensus/safety-rules/src/safety_rules.rs (L213-230)
```rust
    pub(crate) fn verify_and_update_last_vote_round(
        &self,
        round: Round,
        safety_data: &mut SafetyData,
    ) -> Result<(), Error> {
        if round <= safety_data.last_voted_round {
            return Err(Error::IncorrectLastVotedRound(
                round,
                safety_data.last_voted_round,
            ));
        }

        safety_data.last_voted_round = round;
        trace!(
            SafetyLogSchema::new(LogEntry::LastVotedRound, LogEvent::Update)
                .last_voted_round(safety_data.last_voted_round)
        );

```
