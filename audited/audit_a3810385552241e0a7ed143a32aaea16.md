# Audit Report

## Title
Insufficient Sanitizer Validation Allows Test Configuration with Persistent Storage on Non-Mainnet Chains

## Summary
The `SafetyRulesConfig` sanitizer only prevents test configuration from being used on mainnet, allowing test consensus keys to be persisted to `OnDiskStorage` or `Vault` backends on testnet/devnet validators. This creates a security risk if test configurations are mistakenly deployed to production non-mainnet environments.

## Finding Description
The configuration sanitizer validates that test configurations cannot be used on mainnet validators, but fails to enforce this restriction for other production chains (testnet, devnet). The sanitizer check is overly narrow: [1](#0-0) 

When a `SafetyRulesTestConfig` is present with a persistent storage backend (OnDiskStorage or Vault), the consensus private keys from the test configuration are written directly to the storage backend: [2](#0-1) 

The test keys are then persisted to the storage backend through `PersistentSafetyStorage::initialize()`: [3](#0-2) 

**Security Invariant Broken**: The system fails to prevent weak/test cryptographic keys from being persisted to production storage backends on non-mainnet chains, violating the **Cryptographic Correctness** invariant that requires proper key management across all production environments.

**Attack Scenario**:
1. Validator operator deploys a testnet/devnet validator using configuration with both `test: Some(SafetyRulesTestConfig {...})` and `backend: OnDiskStorage`
2. Sanitizer allows this configuration (only checks mainnet)
3. Test consensus keys (potentially weak, predictable, or shared across multiple deployments) are persisted to disk in `secure-data.json`
4. If storage files are exposed, backed up insecurely, or the test keys are known, consensus security is compromised

## Impact Explanation
This is rated **Medium Severity** based on:
- **Limited scope**: Only affects non-mainnet chains where operators explicitly use test configurations
- **Operator error required**: Requires misconfiguration rather than remote exploitation
- **State inconsistency**: Weak keys persisted to production storage requiring intervention to remediate
- **No direct fund loss**: Does not directly cause fund theft but enables future attacks if keys are compromised

While the impact of compromised consensus keys would be severe, the likelihood is limited by the requirement for explicit operator misconfiguration.

## Likelihood Explanation
**Low to Medium Likelihood**:
- Production validator configurations use `initial_safety_rules_config` with identity blobs, not test configs: [4](#0-3) 
- Test configurations are used in test utilities: [5](#0-4) 
- However, no technical barrier prevents deployment of test configs to testnet/devnet
- Genesis builder explicitly uses OnDiskStorage: [6](#0-5) 

## Recommendation
Extend the sanitizer to prevent test configurations with ANY persistent storage backend (OnDiskStorage or Vault), regardless of chain ID. Test configurations should only be permitted with InMemoryStorage:

```rust
// In SafetyRulesConfig::sanitize()
if let Some(chain_id) = chain_id {
    // Existing mainnet checks...
    
    // NEW: Prevent test config with persistent storage on any chain
    if safety_rules_config.test.is_some() 
        && !safety_rules_config.backend.is_in_memory() 
    {
        return Err(Error::ConfigSanitizerFailed(
            sanitizer_name,
            "Test configuration cannot be used with persistent storage backends (OnDiskStorage or Vault). Use InMemoryStorage for testing.".to_string(),
        ));
    }
    
    // Existing mainnet-specific test config check can be removed as redundant
}
```

This enforces defense-in-depth by preventing test keys from ever reaching persistent storage, regardless of deployment environment.

## Proof of Concept
```rust
#[test]
fn test_sanitize_test_config_with_ondisk_storage_on_testnet() {
    use aptos_types::PeerId;
    use aptos_config::config::{
        NodeConfig, ConsensusConfig, SafetyRulesConfig, 
        SafetyRulesTestConfig, SecureBackend, OnDiskStorageConfig
    };
    
    // Create a testnet validator config with test config + OnDiskStorage
    let node_config = NodeConfig {
        consensus: ConsensusConfig {
            safety_rules: SafetyRulesConfig {
                backend: SecureBackend::OnDiskStorage(OnDiskStorageConfig::default()),
                test: Some(SafetyRulesTestConfig::new(PeerId::random())),
                ..Default::default()
            },
            ..Default::default()
        },
        ..Default::default()
    };
    
    // This SHOULD fail but currently passes for non-mainnet chains
    let result = SafetyRulesConfig::sanitize(
        &node_config,
        NodeType::Validator,
        Some(ChainId::testnet()), // Not mainnet
    );
    
    // Currently passes - should fail with proper validation
    assert!(result.is_ok()); // Demonstrates the gap
}
```

**Notes**
- This is a configuration validation gap rather than a remotely exploitable vulnerability
- Requires explicit operator error to manifest
- Testnet and devnet are production networks that deserve the same key management protections as mainnet
- The sanitizer should enforce consistent security policies across all chain environments

### Citations

**File:** config/src/config/safety_rules_config.rs (L107-112)
```rust
            if chain_id.is_mainnet() && safety_rules_config.test.is_some() {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "The safety rules test config should not be used in mainnet!".to_string(),
                ));
            }
```

**File:** consensus/safety-rules/src/safety_rules_manager.rs (L28-43)
```rust
    if let Some(test_config) = &config.test {
        let author = test_config.author;
        let consensus_private_key = test_config
            .consensus_key
            .as_ref()
            .expect("Missing consensus key in test config")
            .private_key();
        let waypoint = test_config.waypoint.expect("No waypoint in config");

        PersistentSafetyStorage::initialize(
            internal_storage,
            author,
            consensus_private_key,
            waypoint,
            config.enable_cached_safety_data,
        )
```

**File:** consensus/safety-rules/src/persistent_safety_storage.rs (L63-81)
```rust
    fn initialize_keys_and_accounts(
        internal_store: &mut Storage,
        author: Author,
        consensus_private_key: bls12381::PrivateKey,
    ) -> Result<(), Error> {
        let result = internal_store.set(CONSENSUS_KEY, consensus_private_key);
        // Attempting to re-initialize existing storage. This can happen in environments like
        // forge. Rather than be rigid here, leave it up to the developer to detect
        // inconsistencies or why they did not reset storage between rounds. Do not repeat the
        // checks again below, because it is just too strange to have a partially configured
        // storage.
        if let Err(aptos_secure_storage::Error::KeyAlreadyExists(_)) = result {
            warn!("Attempted to re-initialize existing storage");
            return Ok(());
        }

        internal_store.set(OWNER_ACCOUNT, author)?;
        Ok(())
    }
```

**File:** testsuite/pangu_lib/template_testnet_files/validator.yaml (L15-19)
```yaml
    initial_safety_rules_config:
      from_file:
        waypoint:
          from_file: /opt/aptos/genesis/waypoint.txt
        identity_blob_path: /opt/aptos/identites/validator-identity.yaml
```

**File:** crates/aptos-genesis/src/test_utils.rs (L54-56)
```rust
    let mut sr_test = aptos_config::config::SafetyRulesTestConfig::new(account_address.unwrap());
    sr_test.consensus_key(consensus_private_key.unwrap());
    config.consensus.safety_rules.test = Some(sr_test);
```

**File:** crates/aptos-genesis/src/builder.rs (L620-623)
```rust
        // Use a file based storage backend for safety rules
        let mut storage = OnDiskStorageConfig::default();
        storage.set_data_dir(validator.dir.clone());
        config.consensus.safety_rules.backend = SecureBackend::OnDiskStorage(storage);
```
