# Audit Report

## Title
Missing Environment Validation for `is_testnet` Flag in Governance Proposal Generation Causes Mainnet Proposal Execution Failures

## Summary
The `is_testnet` flag in the JWK consensus config proposal generation (and all other governance proposals) is derived solely from the `ExecutionMode` enum in the YAML configuration without any validation against the actual deployment environment. This can cause governance proposals to fail on-chain after voting has completed if the wrong execution mode is specified.

## Finding Description

The vulnerability exists in the governance proposal generation flow where the `is_testnet` boolean flag determines which Move function will be called for signer resolution: [1](#0-0) 

When `ExecutionMode::RootSigner` is used, `is_testnet` is set to `true`, causing the generated Move script to use `aptos_governance::get_signer_testnet_only`: [2](#0-1) [3](#0-2) 

The critical issue is that `get_signer_testnet_only` requires the core resources account to have mint capability: [4](#0-3) 

On mainnet, the mint capability is permanently destroyed during genesis after validator initialization: [5](#0-4) 

**The vulnerability:** There is NO validation in the proposal generation flow to verify that the `is_testnet` flag (derived from `ExecutionMode`) matches the actual target network: [6](#0-5) 

**Attack/Error Scenario:**
1. A governance proposer creates a release config with `ExecutionMode::RootSigner` intended for mainnet (either by mistake or misunderstanding)
2. The proposal generation succeeds without warnings
3. The proposal is submitted to mainnet governance and goes through the voting process
4. After voting completes, execution is attempted
5. The script calls `get_signer_testnet_only`, which checks for mint capability
6. The check fails because mainnet destroyed the mint capability during genesis
7. The proposal aborts with `EUNAUTHORIZED` error
8. Critical chain upgrades (JWK consensus config, framework updates, etc.) are blocked

## Impact Explanation

This is a **High severity** issue per Aptos bug bounty criteria for the following reasons:

1. **Significant Protocol Violation**: Governance proposals that successfully pass voting can fail during execution, violating the expectation that approved proposals execute successfully

2. **Availability Impact**: Critical chain upgrades could be blocked, requiring:
   - Re-submission of the proposal
   - Another voting period (potentially weeks)
   - Wasted validator voting power and governance resources
   - Delayed security patches or protocol improvements

3. **Production Risk**: The error only manifests at execution time on-chain, not during:
   - Proposal generation (no validation in CLI)
   - Simulation (simulation only handles multi-step proposals, not RootSigner mode)
   - Pre-flight checks (none exist)

4. **Cascading Effects**: For multi-step proposals or time-sensitive upgrades, the failure could cause:
   - Missed epoch transitions
   - Coordination failures between validators
   - Security vulnerabilities remaining unpatched

This does not reach Critical severity because it doesn't directly cause loss of funds, consensus violations, or permanent network damage, but it does constitute a "significant protocol violation" warranting High severity classification.

## Likelihood Explanation

**Likelihood: Medium-High**

This vulnerability is likely to occur because:

1. **Human Error-Prone**: The configuration requires manual YAML editing where `ExecutionMode::RootSigner` vs `ExecutionMode::MultiStep` must be chosen correctly

2. **No Guardrails**: There are zero validation checks to prevent this misconfiguration:
   - No CLI warnings when generating for a specific network
   - No simulation coverage for RootSigner mode
   - No pre-execution validation

3. **Confusing Naming**: The execution mode naming doesn't clearly indicate testnet vs mainnet, leading to potential confusion

4. **Production Pressure**: During critical upgrades, operators may rush and select the wrong mode

5. **Testing Gaps**: Testnet and devnet both use `RootSigner` mode, so testing there won't reveal the issue for mainnet deployment

## Recommendation

Add validation to check that the `ExecutionMode` matches the target network environment. Implement this in multiple layers:

**Layer 1: Add validation in proposal generation**

In `aptos-move/aptos-release-builder/src/main.rs`, add a check when the `--simulate` flag is provided with a network:

```rust
// In GenerateProposals command handler
if let Some(network) = &simulate {
    let is_mainnet = matches!(network, NetworkSelection::Mainnet);
    
    // Load and validate the config
    let config = aptos_release_builder::ReleaseConfig::load_config(release_config.as_path())?;
    
    // Validate execution modes match network
    for proposal in &config.proposals {
        match (is_mainnet, &proposal.execution_mode) {
            (true, ExecutionMode::RootSigner) => {
                bail!("Cannot use ExecutionMode::RootSigner for mainnet. Use ExecutionMode::MultiStep instead.");
            },
            (false, ExecutionMode::MultiStep) => {
                println!("WARNING: Using ExecutionMode::MultiStep for testnet/devnet. Consider using ExecutionMode::RootSigner for faster testing.");
            },
            _ => {}
        }
    }
}
```

**Layer 2: Add runtime validation in proposal generation**

In `aptos-move/aptos-release-builder/src/components/mod.rs`, add an optional environment check:

```rust
pub async fn generate_release_script(
    &self,
    client: Option<&Client>,
    result: &mut Vec<(String, String)>,
    execution_mode: ExecutionMode,
) -> Result<()> {
    // If client is provided, validate execution mode matches network
    if let Some(client) = client {
        let chain_id = client.get_ledger_information().await?.inner().chain_id;
        let is_mainnet = chain_id == ChainId::mainnet().id();
        
        if is_mainnet && execution_mode == ExecutionMode::RootSigner {
            bail!("ExecutionMode::RootSigner cannot be used on mainnet (chain_id: {}). The mint capability has been destroyed during genesis.", chain_id);
        }
    }
    
    // ... rest of function
}
```

**Layer 3: Add documentation and warnings**

Add clear comments in the YAML configuration examples explaining when to use each mode.

## Proof of Concept

**Step 1: Create a malicious/incorrect YAML config for mainnet**

```yaml
name: "MainnetJWKUpdate"
remote_endpoint: "https://fullnode.mainnet.aptoslabs.com"
proposals:
  - name: "jwk_consensus"
    execution_mode: RootSigner  # WRONG - should be MultiStep for mainnet
    metadata:
      title: "Update JWK Consensus Config"
      description: "Update JWK consensus configuration"
    update_sequence:
      - JwkConsensus:
          V1:
            oidc_providers:
              - name: "https://accounts.google.com"
                config_url: "https://accounts.google.com/.well-known/openid-configuration"
```

**Step 2: Generate the proposal**

```bash
cargo run --bin aptos-release-builder -- generate-proposals \
    --release-config malicious_config.yaml \
    --output-dir ./output
```

This succeeds without any warnings or errors.

**Step 3: Examine the generated Move script**

The generated script will contain:

```move
fun main(core_resources: &signer) {
    let framework_signer = aptos_governance::get_signer_testnet_only(core_resources, @0x1);
    // ... rest of JWK config update
}
```

**Step 4: Attempt execution on mainnet**

If this proposal is submitted to mainnet governance, voted through, and executed:

```bash
# After voting completes
aptos governance execute-proposal \
    --proposal-id <ID> \
    --url https://fullnode.mainnet.aptoslabs.com
```

**Result:** The transaction will abort with error code `EUNAUTHORIZED` (error code 11) because:
- `get_signer_testnet_only` calls `has_mint_capability(core_resources)`
- `has_mint_capability` checks `exists<MintCapStore>(signer::address_of(account))`
- On mainnet, this resource was destroyed during genesis via `destroy_mint_cap`
- The assertion fails: `assert!(aptos_coin::has_mint_capability(core_resources), error::unauthenticated(EUNAUTHORIZED))`

**Expected behavior:** The CLI should reject the configuration during generation or provide a clear warning that RootSigner mode is incompatible with mainnet.

---

**Notes:**

This vulnerability affects ALL governance proposal types generated by the release builder, not just JWK consensus config. The same flow is used for framework upgrades, gas schedule updates, consensus config changes, and all other governance operations. The lack of environment validation is a systemic issue in the proposal generation tooling.

### Citations

**File:** aptos-move/aptos-release-builder/src/components/mod.rs (L224-227)
```rust
        let (is_testnet, is_multi_step) = match execution_mode {
            ExecutionMode::MultiStep => (false, true),
            ExecutionMode::RootSigner => (true, false),
        };
```

**File:** aptos-move/aptos-release-builder/src/utils.rs (L38-57)
```rust
pub(crate) fn generate_testnet_header(writer: &CodeWriter, deps_names: &[&str]) {
    emitln!(writer, "script {");
    writer.indent();

    emitln!(writer, "use aptos_framework::aptos_governance;");
    for deps_name in deps_names {
        emitln!(writer, "use {};", deps_name);
    }
    emitln!(writer);

    emitln!(writer, "fun main(core_resources: &signer) {");
    writer.indent();

    emitln!(
        writer,
        "let core_signer = aptos_governance::get_signer_testnet_only(core_resources, @{});\n",
        AccountAddress::ONE,
    );
    emitln!(writer, "let framework_signer = &core_signer;\n");
}
```

**File:** aptos-move/aptos-release-builder/src/utils.rs (L87-90)
```rust
    } else if is_testnet {
        generate_testnet_header(writer, deps_names);
    } else {
        generate_governance_proposal_header(writer, deps_names, false, None);
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L721-727)
```text
    public fun get_signer_testnet_only(
        core_resources: &signer, signer_address: address): signer acquires GovernanceResponsbility {
        system_addresses::assert_core_resource(core_resources);
        // Core resources account only has mint capability in tests/testnets.
        assert!(aptos_coin::has_mint_capability(core_resources), error::unauthenticated(EUNAUTHORIZED));
        get_signer(signer_address)
    }
```

**File:** aptos-move/framework/aptos-framework/sources/genesis.move (L307-309)
```text
        // Destroy the aptos framework account's ability to mint coins now that we're done with setting up the initial
        // validators.
        aptos_coin::destroy_mint_cap(aptos_framework);
```

**File:** aptos-move/aptos-release-builder/src/main.rs (L226-258)
```rust
        Commands::GenerateProposals {
            release_config,
            output_dir,
            simulate,
            profile_gas,
            node_api_key,
        } => {
            aptos_release_builder::ReleaseConfig::load_config(release_config.as_path())
                .with_context(|| "Failed to load release config".to_string())?
                .generate_release_proposal_scripts(output_dir.as_path())
                .await
                .with_context(|| "Failed to generate release proposal scripts".to_string())?;

            match simulate {
                Some(network) => {
                    let profile_gas = profile_gas.unwrap_or(false);
                    let remote_endpoint = network.to_url()?;
                    simulate_all_proposals(
                        remote_endpoint,
                        output_dir.as_path(),
                        profile_gas,
                        node_api_key,
                    )
                    .await?;
                },
                None => {
                    if profile_gas.is_some() {
                        bail!("--profile-gas can only be set in combination with --simulate")
                    }
                },
            }

            Ok(())
```
