# Audit Report

## Title
Transaction Filter DoS via MultiKey Authenticator Public Key Enumeration

## Summary
An attacker can craft transactions with multiple MultiKey authenticators containing maximum public keys (32 each) but minimum signatures (1 each) to cause CPU exhaustion during transaction filtering when PublicKey or AccountAddress matchers are configured. The validation logic limits total signatures to 32, but the filtering logic iterates through all public keys, creating an exploitable asymmetry that allows up to 1024 public keys per transaction to be checked against each filter matcher.

## Finding Description
The vulnerability exists in the mismatch between transaction validation and filter matching complexity:

**Validation Logic** limits the total number of **signatures** across all authenticators to 32: [1](#0-0) 

For MultiKey authenticators, `number_of_signatures()` returns only the signature count, not the public key count: [2](#0-1) 

**Filter Matching Logic** iterates through **all public keys** in MultiKey authenticators when checking PublicKey matchers: [3](#0-2) 

Similarly, AccountAddress matchers iterate all public keys: [4](#0-3) 

For FeePayer transactions, the filter checks sender + all secondary_signers + fee_payer_signer: [5](#0-4) 

Each MultiKey can have up to 32 public keys: [6](#0-5) 

**Attack Path:**
1. Operator configures transaction filters with PublicKey or AccountAddress matchers (legitimate use case for regulatory compliance or access control)
2. Attacker crafts a FeePayer transaction with 32 AccountAuthenticators (31 secondary + sender + fee_payer), each being MultiKey with 32 public keys and 1 signature
3. Total signatures: 32 (passes validation at MAX_NUM_OF_SIGS limit)
4. Total public keys: 32 authenticators × 32 keys = 1024 keys
5. Filter checking iterates through all 1024 keys for each PublicKey/AccountAddress matcher
6. With N matchers in M rules, complexity becomes O(1024 × N × M) per transaction
7. Attacker submits multiple such transactions concurrently to exhaust CPU

The filter is applied synchronously in mempool without timeout or computational budget: [7](#0-6) 

This breaks the **Resource Limits** invariant: "All operations must respect gas, storage, and computational limits."

## Impact Explanation
**Severity: Medium** (up to $10,000 per Aptos bug bounty)

This qualifies as Medium severity because:
- Causes validator node slowdowns through CPU exhaustion in mempool transaction processing
- Blocks legitimate transaction processing during attack
- Does not directly cause fund loss or consensus violations
- Requires operator to configure filters (not default), but this is a legitimate operational need

The impact is constrained by:
- Only affects nodes with filters enabled and configured with PublicKey/AccountAddress matchers
- Default configuration has filters disabled
- Attack surface depends on specific filter configuration

However, if filters ARE enabled (reasonable for compliance/security), this becomes an effective DoS vector requiring minimal attacker resources.

## Likelihood Explanation
**Likelihood: Medium**

Factors increasing likelihood:
- Attack is straightforward once filters are configured
- No special privileges required beyond transaction submission
- Attacker can craft malicious transactions using standard Aptos SDK
- Each transaction is valid (passes all validation checks)
- Can submit multiple transactions concurrently for amplification

Factors decreasing likelihood:
- Requires operator to enable filters (not default)
- Specifically requires PublicKey or AccountAddress matchers to be configured
- Some deployments may not use transaction filters at all

The vulnerability becomes highly exploitable in environments where filters are legitimately deployed for access control or regulatory compliance.

## Recommendation
Implement one or more of the following mitigations:

**Option 1: Limit Total Public Keys**
Add validation to limit the total number of public keys across all authenticators, not just signatures:

```rust
pub fn verify(&self, raw_txn: &RawTransaction) -> Result<()> {
    let num_sigs: usize = self.sender().number_of_signatures()
        + self.secondary_signers().iter()
            .map(|auth| auth.number_of_signatures())
            .sum::<usize>();
    
    // NEW: Also limit total public keys
    let num_public_keys: usize = self.sender().number_of_public_keys()
        + self.secondary_signers().iter()
            .map(|auth| auth.number_of_public_keys())
            .sum::<usize>();
    
    if num_sigs > MAX_NUM_OF_SIGS {
        return Err(Error::new(AuthenticationError::MaxSignaturesExceeded));
    }
    
    if num_public_keys > MAX_NUM_OF_PUBLIC_KEYS {
        return Err(Error::new(AuthenticationError::MaxPublicKeysExceeded));
    }
    // ... rest of verification
}
```

**Option 2: Add Computational Budget to Filtering**
Implement a maximum iteration count or timeout for filter execution to prevent unbounded computation.

**Option 3: Optimize Filter Matching**
Use hash sets for O(1) public key lookups instead of O(N) iteration when checking against multiple filter rules.

**Recommended:** Implement Option 1 as it provides defense-in-depth and aligns validation complexity with filtering complexity.

## Proof of Concept

```rust
#[cfg(test)]
mod filter_dos_test {
    use aptos_crypto::ed25519::Ed25519PrivateKey;
    use aptos_types::transaction::{
        authenticator::{AccountAuthenticator, AnyPublicKey, MultiKey, MultiKeyAuthenticator, TransactionAuthenticator},
        RawTransaction, SignedTransaction, TransactionPayload, Script,
    };
    use aptos_types::account_address::AccountAddress;
    use aptos_types::chain_id::ChainId;
    use crate::transaction_filter::{TransactionFilter, TransactionMatcher};
    use std::time::Instant;
    
    #[test]
    fn test_multikey_filter_dos() {
        // Create a filter with PublicKey matcher
        let target_key = AnyPublicKey::ed25519(Ed25519PrivateKey::generate_for_testing().public_key());
        let filter = TransactionFilter::empty()
            .add_public_key_filter(false, target_key); // Deny this key
        
        // Create malicious transaction with max public keys
        let mut authenticators = vec![];
        for _ in 0..32 {
            // Each MultiKey has 32 public keys but only 1 signature
            let mut public_keys = vec![];
            for _ in 0..32 {
                let key = AnyPublicKey::ed25519(Ed25519PrivateKey::generate_for_testing().public_key());
                public_keys.push(key);
            }
            let multi_key = MultiKey::new(public_keys, 1).unwrap();
            
            // Create authenticator with 1 signature
            let sig = // ... create signature
            let auth = AccountAuthenticator::MultiKey {
                authenticator: MultiKeyAuthenticator::new(multi_key, vec![(0, sig)]).unwrap()
            };
            authenticators.push(auth);
        }
        
        // Create FeePayer transaction with all authenticators
        let raw_txn = RawTransaction::new(
            AccountAddress::random(),
            0,
            TransactionPayload::Script(Script::new(vec![], vec![], vec![])),
            0, 0, 0,
            ChainId::new(10),
        );
        
        let signed_txn = SignedTransaction::new_fee_payer(
            raw_txn,
            authenticators[0].clone(), // sender
            vec![AccountAddress::random(); 30], // secondary signers
            authenticators[1..31].to_vec(), // secondary authenticators
            AccountAddress::random(),
            authenticators[31].clone(), // fee payer
        );
        
        // Measure filter execution time
        let start = Instant::now();
        let result = filter.allows_transaction(&signed_txn);
        let elapsed = start.elapsed();
        
        println!("Filter check took: {:?} for 1024 public keys", elapsed);
        println!("Result: {}", result);
        
        // With 1024 keys checked, this will be significantly slower
        // than a normal transaction with 1-2 keys
    }
}
```

**Notes:**
- The vulnerability is conditional on filter configuration but represents a real design flaw
- The asymmetry between validation (signature count) and filtering (public key count) creates exploitable computational complexity
- Operators who deploy filters for legitimate security/compliance reasons become vulnerable to this DoS vector
- Fix should align validation and filtering complexity bounds to prevent exploitation

### Citations

**File:** types/src/transaction/authenticator.rs (L160-169)
```rust
    pub fn verify(&self, raw_txn: &RawTransaction) -> Result<()> {
        let num_sigs: usize = self.sender().number_of_signatures()
            + self
                .secondary_signers()
                .iter()
                .map(|auth| auth.number_of_signatures())
                .sum::<usize>();
        if num_sigs > MAX_NUM_OF_SIGS {
            return Err(Error::new(AuthenticationError::MaxSignaturesExceeded));
        }
```

**File:** types/src/transaction/authenticator.rs (L838-847)
```rust
    pub fn number_of_signatures(&self) -> usize {
        match self {
            Self::Ed25519 { .. } => 1,
            Self::MultiEd25519 { signature, .. } => signature.signatures().len(),
            Self::SingleKey { .. } => 1,
            Self::MultiKey { authenticator } => authenticator.signatures.len(),
            Self::NoAccountAuthenticator => 0,
            Self::Abstract { .. } => 0,
        }
    }
```

**File:** types/src/transaction/authenticator.rs (L1154-1164)
```rust
    pub fn new(public_keys: Vec<AnyPublicKey>, signatures_required: u8) -> Result<Self> {
        ensure!(
            signatures_required > 0,
            "The number of required signatures is 0."
        );

        ensure!(
            public_keys.len() <= MAX_NUM_OF_SIGS, // This max number of signatures is also the max number of public keys.
            "The number of public keys is greater than {}.",
            MAX_NUM_OF_SIGS
        );
```

**File:** crates/aptos-transaction-filters/src/transaction_filter.rs (L271-275)
```rust
        AccountAuthenticator::MultiKey { authenticator } => authenticator
            .public_keys()
            .public_keys()
            .iter()
            .any(|any_public_key| matches_any_public_key_address(any_public_key, address)),
```

**File:** crates/aptos-transaction-filters/src/transaction_filter.rs (L303-308)
```rust
        AccountAuthenticator::MultiKey { authenticator } => authenticator
            .public_keys()
            .public_keys()
            .iter()
            .any(|key| key == any_public_key),
    }
```

**File:** crates/aptos-transaction-filters/src/transaction_filter.rs (L558-569)
```rust
        TransactionAuthenticator::FeePayer {
            sender,
            secondary_signers,
            fee_payer_signer,
            ..
        } => {
            matches_account_authenticator_public_key(sender, any_public_key)
                || secondary_signers
                    .iter()
                    .any(|signer| matches_account_authenticator_public_key(signer, any_public_key))
                || matches_account_authenticator_public_key(fee_payer_signer, any_public_key)
        },
```

**File:** mempool/src/shared_mempool/tasks.rs (L432-460)
```rust
    let transactions = transactions
        .into_iter()
        .filter_map(|(transaction, account_sequence_number, priority)| {
            if transaction_filter_config
                .transaction_filter()
                .allows_transaction(&transaction)
            {
                Some((transaction, account_sequence_number, priority))
            } else {
                info!(LogSchema::event_log(
                    LogEntry::TransactionFilter,
                    LogEvent::TransactionRejected
                )
                .message(&format!(
                    "Transaction {} rejected by filter",
                    transaction.committed_hash()
                )));

                statuses.push((
                    transaction.clone(),
                    (
                        MempoolStatus::new(MempoolStatusCode::RejectedByFilter),
                        None,
                    ),
                ));
                None
            }
        })
        .collect();
```
