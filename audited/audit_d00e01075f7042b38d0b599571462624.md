# Audit Report

## Title
Integer Overflow Vulnerabilities in Database Metadata Deserialization Leading to Node Crashes

## Summary
The database metadata schema lacks validation of extreme values after BCS deserialization, combined with unchecked arithmetic operations. This allows corrupted or malicious database entries with edge case values (`u64::MAX` versions, `usize::MAX` storage usage) to cause integer overflow panics in debug mode or incorrect behavior in release mode, resulting in validator node crashes and state inconsistencies.

## Finding Description

The `DbMetadataSchema` deserializes metadata values using BCS without validating bounds on critical fields. Two distinct attack paths exploit this lack of validation:

**Vulnerability 1: StateStorageUsage Arithmetic Overflow** [1](#0-0) 

The `DbMetadataValue::StateSnapshotProgress` variant contains `StateStorageUsage` with unchecked arithmetic: [2](#0-1) 

When `StateSnapshotProgress` is loaded from the database during state restoration, the `usage` field is extracted without validation: [3](#0-2) 

This usage value is then used in arithmetic operations during chunk processing: [4](#0-3) 

If the database contains `StateStorageUsage { items: usize::MAX, bytes: usize::MAX }`, calling `add_item()` will overflow, causing a panic in debug mode or wraparound in release mode.

**Vulnerability 2: Version Arithmetic Overflow**

The `OverallCommitProgress` version is deserialized and used in truncation operations: [5](#0-4) 

The truncation function performs unchecked addition: [6](#0-5) 

If `target_version` is `u64::MAX`, the expression `target_version + 1` will overflow, causing a panic in debug mode or wrap to 0 in release mode, leading to incorrect database truncation.

**Attack Vector:**
1. Attacker corrupts database files (via backup manipulation, filesystem access, or upstream bug)
2. Database contains edge case values: `u64::MAX` or `usize::MAX`
3. Node restarts and attempts to load/use metadata
4. Unchecked arithmetic operations trigger overflow
5. Debug mode: Node crashes with panic
6. Release mode: Integer wraparound causes state corruption

The proptest fuzzing mentioned in the security question only tests encode/decode roundtrips but does not test the actual usage of deserialized values in arithmetic contexts, leaving these edge cases undetected. [7](#0-6) 

## Impact Explanation

This vulnerability has **High to Medium severity** impact:

**Availability Impact:** Validator nodes crash during startup or state restoration when processing corrupted metadata, resulting in network availability degradation. Multiple nodes affected simultaneously could approach the consensus threshold.

**State Consistency Impact:** In release mode, integer wraparound causes incorrect state tracking. For example:
- `usize::MAX + 1 = 0` causes storage usage to reset to zero
- `u64::MAX + 1 = 0` causes truncation to delete all ledger data

This breaks the **State Consistency** invariant: "State transitions must be atomic and verifiable via Merkle proofs."

This qualifies as **Medium Severity** per the bug bounty program: "State inconsistencies requiring intervention" and potentially **High Severity** due to "Validator node slowdowns" and "API crashes."

## Likelihood Explanation

**Likelihood: Medium**

While this requires database manipulation, several realistic scenarios exist:

1. **Backup/Restore Operations:** Corrupted backups restored to production validators
2. **Database Migration Bugs:** Errors during database format changes could write invalid values
3. **Filesystem Vulnerabilities:** Direct database file manipulation via file system access
4. **Upstream Bugs:** Bugs in database write operations that accidentally write extreme values
5. **Supply Chain Attacks:** Compromised database snapshots distributed to validators

The Aptos coding guidelines explicitly require checked arithmetic to prevent these issues, indicating this is a recognized attack vector: [8](#0-7) 

Note that proper validation exists elsewhere (e.g., checking `version > 0` before `version - 1`), but is missing for these metadata edge cases.

## Recommendation

**Immediate Fix: Add Checked Arithmetic**

Replace unchecked arithmetic with checked operations:

```rust
// In types/src/state_store/state_storage_usage.rs
pub fn add_item(&mut self, bytes_delta: usize) -> Result<(), String> {
    match self {
        Self::Tracked { items, bytes } => {
            *items = items.checked_add(1)
                .ok_or("StateStorageUsage items overflow")?;
            *bytes = bytes.checked_add(bytes_delta)
                .ok_or("StateStorageUsage bytes overflow")?;
            Ok(())
        },
        Self::Untracked => Ok(()),
    }
}

pub fn remove_item(&mut self, bytes_delta: usize) -> Result<(), String> {
    match self {
        Self::Tracked { items, bytes } => {
            *items = items.checked_sub(1)
                .ok_or("StateStorageUsage items underflow")?;
            *bytes = bytes.checked_sub(bytes_delta)
                .ok_or("StateStorageUsage bytes underflow")?;
            Ok(())
        },
        Self::Untracked => Ok(()),
    }
}

// In storage/aptosdb/src/utils/truncation_helper.rs
pub(crate) fn truncate_ledger_db(ledger_db: Arc<LedgerDb>, target_version: Version) -> Result<()> {
    let transaction_store = TransactionStore::new(Arc::clone(&ledger_db));
    
    let start_version = target_version.checked_add(1)
        .ok_or_else(|| anyhow::anyhow!("Version overflow in truncate_ledger_db"))?;
    truncate_ledger_db_single_batch(&ledger_db, &transaction_store, start_version)?;
    Ok(())
}
```

**Defense-in-Depth: Add Post-Deserialization Validation**

Add bounds checking after BCS deserialization:

```rust
impl DbMetadataValue {
    pub fn validate(&self) -> Result<()> {
        match self {
            Self::StateSnapshotProgress(progress) => {
                match progress.usage {
                    StateStorageUsage::Tracked { items, bytes } => {
                        // Reserve headroom for arithmetic operations
                        ensure!(items < usize::MAX / 2, "Invalid items count");
                        ensure!(bytes < usize::MAX / 2, "Invalid bytes count");
                    }
                    _ => {}
                }
                Ok(())
            }
            Self::Version(v) => {
                ensure!(*v < u64::MAX / 2, "Invalid version");
                Ok(())
            }
        }
    }
}
```

**Enhanced Testing: Extend Proptest Coverage**

Add explicit edge case tests to `test.rs`:

```rust
#[test]
fn test_edge_case_versions() {
    let edge_cases = vec![0u64, 1, u64::MAX / 2, u64::MAX - 1, u64::MAX];
    for version in edge_cases {
        let value = DbMetadataValue::Version(version);
        assert_encode_decode::<DbMetadataSchema>(&DbMetadataKey::LedgerPrunerProgress, &value);
    }
}

#[test]
fn test_edge_case_storage_usage() {
    let edge_cases = vec![
        StateStorageUsage::new(0, 0),
        StateStorageUsage::new(usize::MAX / 2, usize::MAX / 2),
        StateStorageUsage::Untracked,
    ];
    for usage in edge_cases {
        let progress = StateSnapshotProgress::new(HashValue::zero(), usage);
        let value = DbMetadataValue::StateSnapshotProgress(progress);
        assert_encode_decode::<DbMetadataSchema>(&DbMetadataKey::StateSnapshotKvRestoreProgress(0), &value);
    }
}
```

## Proof of Concept

```rust
// Rust unit test demonstrating the vulnerability
#[cfg(test)]
mod overflow_poc {
    use super::*;
    use aptos_types::state_store::state_storage_usage::StateStorageUsage;
    
    #[test]
    #[should_panic(expected = "attempt to add with overflow")]
    fn test_storage_usage_overflow() {
        let mut usage = StateStorageUsage::new(usize::MAX, usize::MAX - 100);
        // This will panic in debug mode
        usage.add_item(100);
    }
    
    #[test]
    #[should_panic(expected = "attempt to subtract with overflow")]
    fn test_storage_usage_underflow() {
        let mut usage = StateStorageUsage::new(0, 0);
        // This will panic in debug mode
        usage.remove_item(100);
    }
    
    #[test]
    #[should_panic(expected = "attempt to add with overflow")]
    fn test_version_overflow() {
        let version: u64 = u64::MAX;
        // This will panic in debug mode
        let _ = version + 1;
    }
}
```

To trigger the vulnerability in a live system:
1. Stop a validator node
2. Manually corrupt the database metadata file with edge case values
3. Restart the node
4. Observe crash during state restoration or commit progress sync

## Notes

This vulnerability highlights the importance of defensive programming practices:
1. **Always validate deserialized data** from untrusted or potentially corrupted sources
2. **Use checked arithmetic** for all operations on external values (per Aptos coding guidelines)
3. **Extend fuzzing coverage** to test actual usage patterns, not just serialization roundtrips
4. **Add bounds checking** as a defense-in-depth measure even when extreme values seem unlikely

The current proptest fuzzing only validates that `encode(decode(x)) == x`, but doesn't catch vulnerabilities in how the decoded values are subsequently used in arithmetic operations.

### Citations

**File:** storage/aptosdb/src/schema/db_metadata/mod.rs (L91-99)
```rust
impl ValueCodec<DbMetadataSchema> for DbMetadataValue {
    fn encode_value(&self) -> Result<Vec<u8>> {
        Ok(bcs::to_bytes(self)?)
    }

    fn decode_value(data: &[u8]) -> Result<Self> {
        Ok(bcs::from_bytes(data)?)
    }
}
```

**File:** types/src/state_store/state_storage_usage.rs (L44-62)
```rust
    pub fn add_item(&mut self, bytes_delta: usize) {
        match self {
            Self::Tracked { items, bytes } => {
                *items += 1;
                *bytes += bytes_delta;
            },
            Self::Untracked => (),
        }
    }

    pub fn remove_item(&mut self, bytes_delta: usize) {
        match self {
            Self::Tracked { items, bytes } => {
                *items -= 1;
                *bytes -= bytes_delta;
            },
            Self::Untracked => (),
        }
    }
```

**File:** storage/aptosdb/src/state_store/mod.rs (L417-448)
```rust
        if let Some(overall_commit_progress) = ledger_metadata_db
            .get_synced_version()
            .expect("DB read failed.")
        {
            info!(
                overall_commit_progress = overall_commit_progress,
                "Start syncing databases..."
            );
            let ledger_commit_progress = ledger_metadata_db
                .get_ledger_commit_progress()
                .expect("Failed to read ledger commit progress.");
            assert_ge!(ledger_commit_progress, overall_commit_progress);

            let state_kv_commit_progress = state_kv_db
                .metadata_db()
                .get::<DbMetadataSchema>(&DbMetadataKey::StateKvCommitProgress)
                .expect("Failed to read state K/V commit progress.")
                .expect("State K/V commit progress cannot be None.")
                .expect_version();
            assert_ge!(state_kv_commit_progress, overall_commit_progress);

            // LedgerCommitProgress was not guaranteed to commit after all ledger changes finish,
            // have to attempt truncating every column family.
            info!(
                ledger_commit_progress = ledger_commit_progress,
                "Attempt ledger truncation...",
            );
            let difference = ledger_commit_progress - overall_commit_progress;
            if crash_if_difference_is_too_large {
                assert_le!(difference, MAX_COMMIT_PROGRESS_DIFFERENCE);
            }
            truncate_ledger_db(ledger_db.clone(), overall_commit_progress)
```

**File:** storage/aptosdb/src/state_store/mod.rs (L1284-1289)
```rust
            if version > 0 {
                let mut batch = SchemaBatch::new();
                batch.put::<InternalIndexerMetadataSchema>(
                    &MetadataKey::LatestVersion,
                    &MetadataValue::Version(version - 1),
                )?;
```

**File:** storage/aptosdb/src/state_store/mod.rs (L1317-1322)
```rust
    fn get_progress(&self, version: Version) -> Result<Option<StateSnapshotProgress>> {
        let main_db_progress = self
            .state_kv_db
            .metadata_db()
            .get::<DbMetadataSchema>(&DbMetadataKey::StateSnapshotKvRestoreProgress(version))?
            .map(|v| v.expect_state_snapshot_progress());
```

**File:** storage/aptosdb/src/state_restore/mod.rs (L88-114)
```rust
    pub fn add_chunk(&mut self, mut chunk: Vec<(K, V)>) -> Result<()> {
        // load progress
        let progress_opt = self.db.get_progress(self.version)?;

        // skip overlaps
        if let Some(progress) = progress_opt {
            let idx = chunk
                .iter()
                .position(|(k, _v)| CryptoHash::hash(k) > progress.key_hash)
                .unwrap_or(chunk.len());
            chunk = chunk.split_off(idx);
        }

        // quit if all skipped
        if chunk.is_empty() {
            return Ok(());
        }

        // save
        let mut usage = progress_opt.map_or(StateStorageUsage::zero(), |p| p.usage);
        let (last_key, _last_value) = chunk.last().unwrap();
        let last_key_hash = CryptoHash::hash(last_key);

        // In case of TreeOnly Restore, we only restore the usage of KV without actually writing KV into DB
        for (k, v) in chunk.iter() {
            usage.add_item(k.key_size() + v.value_size());
        }
```

**File:** storage/aptosdb/src/utils/truncation_helper.rs (L73-78)
```rust
pub(crate) fn truncate_ledger_db(ledger_db: Arc<LedgerDb>, target_version: Version) -> Result<()> {
    let transaction_store = TransactionStore::new(Arc::clone(&ledger_db));

    let start_version = target_version + 1;
    truncate_ledger_db_single_batch(&ledger_db, &transaction_store, start_version)?;
    Ok(())
```

**File:** storage/aptosdb/src/schema/db_metadata/test.rs (L8-16)
```rust
proptest! {
    #[test]
    fn test_encode_decode(
        tag in any::<DbMetadataKey>(),
        data in any::<DbMetadataValue>(),
    ) {
        assert_encode_decode::<DbMetadataSchema>(&tag, &data);
    }
}
```
