# Audit Report

## Title
Low-Priority Transaction Starvation via Reverse Bucket Iteration During High Load

## Summary
The `bucket_into_batches()` function processes gas price buckets in reverse order (highest to lowest), combined with a hard limit on batches per pull (`sender_max_num_batches`), creates a vulnerability where low-gas transactions can be indefinitely starved during sustained high load. When high-gas transactions exhaust the batch quota, low-gas transactions remain unbatched and must be re-pulled repeatedly, never making it into consensus blocks.

## Finding Description

The vulnerability exists in the batch generation logic that processes transactions pulled from mempool. The attack vector operates through the following mechanism:

**Step 1: Bucket Reversal Creates Processing Bias**

The `bucket_into_batches()` function reverses the gas price buckets, excluding bucket 0: [1](#0-0) 

This creates a reversed bucket list (e.g., `[1000000, 100000, 10000, ..., 150]`) that is then iterated in the main loop: [2](#0-1) 

**Step 2: Hard Batch Limit Creates Exhaustion Point**

There is a hard limit on batches per pull cycle: [3](#0-2) 

The default configuration sets this to 10 batches: [4](#0-3) 

**Step 3: Early Exit Prevents Low-Gas Batching**

When `max_batches_remaining` reaches 0, the loop exits immediately: [5](#0-4) 

**Step 4: Fallback Bucket 0 Processing Skipped**

The fallback logic that would process remaining low-gas transactions (bucket 0) only executes if batches are still available: [6](#0-5) 

If `max_batches_remaining == 0`, this block never executes, leaving low-gas transactions unbatched.

**Step 5: Mempool Prioritization Amplifies Bias**

Mempool already returns transactions ordered by gas price (highest first): [7](#0-6) 

This means the batch generator receives transactions already biased toward high-gas, and the reverse bucket iteration further ensures they fill batches first.

**Step 6: Default Bucket Configuration**

The default bucket thresholds are: [8](#0-7) 

Transactions with gas < 150 fall into bucket 0, which is processed last and only if batches remain available.

**Exploitation Scenario:**

1. Attacker continuously submits 500+ transactions with gas â‰¥ 150 (high-gas)
2. Regular users submit transactions with gas < 150 (low-gas)
3. Batch generator pulls 1500 transactions (default `sender_max_total_txns`)
4. Reverse iteration processes high-gas buckets first
5. With 10 batch limit and 50 txns/batch, only 500 high-gas transactions get batched
6. Low-gas transactions remain in `pulled_txns` but are never batched
7. These transactions stay in mempool and get pulled again next cycle
8. Under sustained attack, low-gas transactions experience indefinite starvation

## Impact Explanation

**Severity: Medium** per Aptos bug bounty criteria

This vulnerability constitutes **"State inconsistencies requiring intervention"** and affects transaction fairness and liveness:

1. **Transaction Ordering Bias**: The system systematically excludes low-fee transactions during high load, violating fairness expectations
2. **Liveness Impact**: Low-fee users cannot get transactions confirmed under sustained high-gas transaction load
3. **Denial of Service**: Economic DoS against users unwilling or unable to pay premium gas prices
4. **No Consensus Safety Violation**: All validators agree on which transactions are batched (deterministic behavior)
5. **No Fund Loss**: Transactions are not lost permanently, but experience indefinite delays

The impact is limited to Medium severity because:
- Does not violate consensus safety (Invariant #2)
- Does not cause validator crashes or network partitions
- Does not result in permanent fund loss
- Requires sustained attack with economic cost (high-gas transactions)

However, it represents a significant fairness and availability issue that could require operational intervention to restore service to affected users.

## Likelihood Explanation

**Likelihood: HIGH during network congestion**

1. **Attack Complexity**: LOW - attacker only needs to submit many high-gas transactions
2. **Attack Cost**: MEDIUM - requires funds to pay for high-gas transactions, but attacker's transactions are executed normally
3. **No Special Privileges**: Any account can submit high-gas transactions
4. **Natural Occurrence**: This can happen organically during network congestion without malicious intent
5. **Sustained Impact**: Once triggered, continues as long as high-gas transaction volume remains high

The vulnerability is particularly concerning because:
- It amplifies natural network congestion effects
- Can be weaponized deliberately to exclude specific users or transaction types
- Default configuration values (10 batches, bucket threshold 150) make it easily triggerable
- No monitoring or mitigation mechanisms are in place

## Recommendation

**Immediate Fix: Implement Fair Batch Quota Allocation**

Modify `bucket_into_batches()` to reserve batch quota for lower-priority buckets:

```rust
fn bucket_into_batches(
    &mut self,
    pulled_txns: &mut Vec<SignedTransaction>,
    expiry_time: u64,
) -> Vec<Batch<BatchInfoExt>> {
    pulled_txns.sort_by_key(|txn| u64::MAX - txn.gas_unit_price());

    let reverse_buckets_excluding_zero: Vec<_> = self
        .config
        .batch_buckets
        .iter()
        .skip(1)
        .rev()
        .cloned()
        .collect();

    // Reserve at least 20% of batch quota for bucket 0 (low-gas transactions)
    let reserved_batches_for_bucket_0 = (self.config.sender_max_num_batches / 5).max(1);
    let mut max_batches_remaining = 
        (self.config.sender_max_num_batches as u64).saturating_sub(reserved_batches_for_bucket_0);
    
    let mut batches = vec![];
    for bucket_start in &reverse_buckets_excluding_zero {
        if pulled_txns.is_empty() || max_batches_remaining == 0 {
            break;
        }

        let num_txns_in_bucket = match pulled_txns
            .binary_search_by_key(&(u64::MAX - (*bucket_start - 1), PeerId::ZERO), |txn| {
                (u64::MAX - txn.gas_unit_price(), txn.sender())
            }) {
            Ok(index) => index,
            Err(index) => index,
        };
        if num_txns_in_bucket == 0 {
            continue;
        }

        self.push_bucket_to_batches(
            &mut batches,
            pulled_txns,
            num_txns_in_bucket,
            expiry_time,
            *bucket_start,
            &mut max_batches_remaining,
        );
    }
    
    // Now add reserved_batches_for_bucket_0 back for bucket 0 processing
    max_batches_remaining = max_batches_remaining.saturating_add(reserved_batches_for_bucket_0);
    
    if !pulled_txns.is_empty() && max_batches_remaining > 0 {
        self.push_bucket_to_batches(
            &mut batches,
            pulled_txns,
            pulled_txns.len(),
            expiry_time,
            0,
            &mut max_batches_remaining,
        );
    }
    batches
}
```

**Additional Mitigations:**

1. **Add monitoring**: Track bucket 0 transaction starvation metrics
2. **Dynamic adjustment**: Adjust reserved quota based on bucket 0 backlog
3. **Configuration tuning**: Increase `sender_max_num_batches` for high-throughput networks
4. **Round-robin bucket processing**: Alternate between high and low buckets to ensure fairness

## Proof of Concept

```rust
#[tokio::test]
async fn test_low_gas_transaction_starvation() {
    use crate::quorum_store::{batch_generator::BatchGenerator, quorum_store_db::MockQuorumStoreDB};
    use aptos_config::config::QuorumStoreConfig;
    use aptos_mempool::{QuorumStoreRequest, QuorumStoreResponse};
    use futures::channel::mpsc::channel;
    use move_core_types::account_address::AccountAddress;
    use std::sync::Arc;

    let (quorum_store_to_mempool_tx, mut quorum_store_to_mempool_rx) = channel(1_024);

    // Configure with default limits to demonstrate vulnerability
    let config = QuorumStoreConfig {
        sender_max_num_batches: 10,  // Default: only 10 batches per pull
        sender_max_batch_txns: 50,   // Default: 50 txns per batch
        ..Default::default()
    };

    let author = AccountAddress::random();
    let mut batch_generator = BatchGenerator::new(
        0,
        author,
        config.clone(),
        Arc::new(MockQuorumStoreDB::new()),
        Arc::new(MockBatchWriter::new()),
        quorum_store_to_mempool_tx,
        1000,
    );

    // Spawn mempool responder that simulates high-load scenario
    let join_handle = tokio::spawn(async move {
        if let QuorumStoreRequest::GetBatchRequest(_, _, _, _, callback) = 
            quorum_store_to_mempool_rx.select_next_some().await
        {
            // Simulate high load: 500 high-gas txns (gas=1000) + 100 low-gas txns (gas=50)
            let mut all_txns = vec![];
            
            // 500 high-gas transactions (will fill 10 batches exactly: 500/50 = 10)
            let high_gas_txns = create_vec_signed_transactions_with_gas(500, 1000);
            all_txns.extend(high_gas_txns);
            
            // 100 low-gas transactions (gas < 150, fall into bucket 0)
            let low_gas_txns = create_vec_signed_transactions_with_gas(100, 50);
            all_txns.extend(low_gas_txns);
            
            callback.send(Ok(QuorumStoreResponse::GetBatchResponse(all_txns))).unwrap();
        }
    });

    // Pull transactions and create batches
    let batches = batch_generator.handle_scheduled_pull(600).await;
    
    // Vulnerability demonstrated: Only high-gas transactions are batched
    assert_eq!(batches.len(), 10, "Should create exactly 10 batches (limit reached)");
    
    // All batches should be from high-gas bucket (gas=1000)
    for batch in &batches {
        assert_eq!(batch.gas_bucket_start(), 1000, 
            "All batches should be from high-gas bucket due to reverse iteration bias");
        assert_eq!(batch.num_txns(), 50, 
            "Each batch should have 50 transactions");
    }
    
    // Total batched: 10 batches * 50 txns = 500 high-gas transactions
    // Low-gas transactions (100 txns) were NEVER batched despite being pulled from mempool
    // They remain in mempool and will experience starvation under sustained high load
    
    join_handle.await.unwrap();
    
    println!("VULNERABILITY CONFIRMED:");
    println!("- 500 high-gas transactions batched");
    println!("- 100 low-gas transactions STARVED (not batched)");
    println!("- Under sustained high-gas load, low-gas txns never reach consensus");
}
```

**Notes:**
- The vulnerability is exacerbated by the default configuration where `sender_max_num_batches=10` and `sender_max_batch_txns=50`, allowing only 500 transactions per pull to be batched
- The bucket threshold of 150 (first non-zero bucket) means any transaction with gas < 150 is relegated to bucket 0, which is processed last
- During legitimate network congestion, this behavior naturally occurs without malicious intent
- The economic cost to the attacker is moderate as they must pay for high-gas transactions, but those transactions execute normally
- Mitigation requires either fair quota allocation, increased batch limits, or round-robin bucket processing

### Citations

**File:** consensus/src/quorum_store/batch_generator.rs (L264-271)
```rust
        let reverse_buckets_excluding_zero: Vec<_> = self
            .config
            .batch_buckets
            .iter()
            .skip(1)
            .rev()
            .cloned()
            .collect();
```

**File:** consensus/src/quorum_store/batch_generator.rs (L273-273)
```rust
        let mut max_batches_remaining = self.config.sender_max_num_batches as u64;
```

**File:** consensus/src/quorum_store/batch_generator.rs (L275-300)
```rust
        for bucket_start in &reverse_buckets_excluding_zero {
            if pulled_txns.is_empty() || max_batches_remaining == 0 {
                return batches;
            }

            // Search for key in descending gas order
            let num_txns_in_bucket = match pulled_txns
                .binary_search_by_key(&(u64::MAX - (*bucket_start - 1), PeerId::ZERO), |txn| {
                    (u64::MAX - txn.gas_unit_price(), txn.sender())
                }) {
                Ok(index) => index,
                Err(index) => index,
            };
            if num_txns_in_bucket == 0 {
                continue;
            }

            self.push_bucket_to_batches(
                &mut batches,
                pulled_txns,
                num_txns_in_bucket,
                expiry_time,
                *bucket_start,
                &mut max_batches_remaining,
            );
        }
```

**File:** consensus/src/quorum_store/batch_generator.rs (L301-310)
```rust
        if !pulled_txns.is_empty() && max_batches_remaining > 0 {
            self.push_bucket_to_batches(
                &mut batches,
                pulled_txns,
                pulled_txns.len(),
                expiry_time,
                0,
                &mut max_batches_remaining,
            );
        }
```

**File:** config/src/config/quorum_store_config.rs (L14-14)
```rust
const DEFAULT_MAX_NUM_BATCHES: usize = 10;
```

**File:** mempool/src/core_mempool/mempool.rs (L448-449)
```rust
        // iterate over the queue of transactions based on gas price
        'main: for txn in self.transactions.iter_queue() {
```

**File:** config/global-constants/src/lib.rs (L36-36)
```rust
pub const DEFAULT_BUCKETS: &[u64] = &[0, 150, 300, 500, 1000, 3000, 5000, 10000, 100000, 1000000];
```
