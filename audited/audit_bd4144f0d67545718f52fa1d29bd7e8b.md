# Audit Report

## Title
Missing Validation Allows Governance to Set Degenerate Groth16 Verification Key in Keyless Authentication System

## Summary
The Aptos keyless account system lacks validation to prevent governance from setting a mathematically degenerate Groth16 verification key where `delta_g2` equals `beta_g2` or `gamma_g2`. While a `validate_groth16_vk()` function exists, it only checks point deserialization and is never called by the VK-setting functions. This could allow a compromised governance process to set a verification key that breaks the soundness of zero-knowledge proof verification, enabling complete compromise of all keyless accounts.

## Finding Description

The Groth16 verification key used for keyless account authentication consists of five components: `alpha_g1`, `beta_g2`, `gamma_g2`, `delta_g2`, and `gamma_abc_g1`. For the proof system to be cryptographically sound, the scalar values α, β, γ, and δ must be independently random. [1](#0-0) 

A validation function exists that should prevent incorrect VKs: [2](#0-1) 

However, this function **only checks point deserialization** and **never verifies that beta_g2, gamma_g2, and delta_g2 are distinct**. More critically, this validation function is never called by the functions that actually set the verification key: [3](#0-2) [4](#0-3) 

The Rust deserialization code similarly lacks distinctness checks: [5](#0-4) 

If `delta_g2 = beta_g2`, the Groth16 verification equation degenerates from:
```
e(A, B) = e([α]₁, [β]₂) · e(L, [γ]₂) · e(C, [δ]₂)
```
to:
```
e(A, B) = e([α]₁ + C, [β]₂) · e(L, [γ]₂)
```

This is a fundamentally different equation. An attacker who generates such a VK knows the trapdoor values and can forge arbitrary proofs, as demonstrated in the proof simulation code: [6](#0-5) [7](#0-6) 

## Impact Explanation

**Severity Assessment: High → Critical (conditional on governance compromise)**

If successfully exploited, this vulnerability would result in:

1. **Complete Keyless Account Compromise**: An attacker with the trapdoor can forge proofs to authenticate as any keyless account
2. **Total Loss of Funds**: All assets in keyless accounts could be stolen
3. **Consensus Safety Violation**: Different validators would accept different transactions as valid, breaking deterministic execution

The code itself acknowledges this risk: [8](#0-7) 

This meets **Critical Severity** criteria under the bug bounty program (Loss of Funds, Consensus/Safety violations).

## Likelihood Explanation

**Likelihood: Low to Medium**

**Barriers to exploitation:**
- Requires governance proposal approval (significant stake and voting power)
- Governance participants are generally trusted actors
- The warning documentation is explicit about the risk

**Factors increasing likelihood:**
- The validation function exists but is **never called** (clear implementation gap)
- No technical enforcement prevents this attack
- Compromised governance keys or insider threat could exploit this
- Accidental misuse during emergency VK rotation could occur

**Critical observation**: The existence of an unused `validate_groth16_vk()` function suggests this validation was intended but not implemented in the execution path, representing a defense-in-depth failure.

## Recommendation

**Immediate Fix**: Call the validation function and add distinctness checks.

```move
fun validate_groth16_vk(vk: &Groth16VerificationKey) {
    // Existing point validation
    assert!(option::is_some(&crypto_algebra::deserialize<bn254_algebra::G1, bn254_algebra::FormatG1Compr>(&vk.alpha_g1)), E_INVALID_BN254_G1_SERIALIZATION);
    assert!(option::is_some(&crypto_algebra::deserialize<bn254_algebra::G2, bn254_algebra::FormatG2Compr>(&vk.beta_g2)), E_INVALID_BN254_G2_SERIALIZATION);
    assert!(option::is_some(&crypto_algebra::deserialize<bn254_algebra::G2, bn254_algebra::FormatG2Compr>(&vk.gamma_g2)), E_INVALID_BN254_G2_SERIALIZATION);
    assert!(option::is_some(&crypto_algebra::deserialize<bn254_algebra::G2, bn254_algebra::FormatG2Compr>(&vk.delta_g2)), E_INVALID_BN254_G2_SERIALIZATION);
    
    // ADD: Distinctness checks
    const E_DUPLICATE_G2_ELEMENTS: u64 = 4;
    assert!(vk.beta_g2 != vk.gamma_g2, E_DUPLICATE_G2_ELEMENTS);
    assert!(vk.beta_g2 != vk.delta_g2, E_DUPLICATE_G2_ELEMENTS);
    assert!(vk.gamma_g2 != vk.delta_g2, E_DUPLICATE_G2_ELEMENTS);
    
    // Existing gamma_abc_g1 validation...
}

public fun set_groth16_verification_key_for_next_epoch(fx: &signer, vk: Groth16VerificationKey) {
    system_addresses::assert_aptos_framework(fx);
    validate_groth16_vk(&vk); // ADD THIS CALL
    config_buffer::upsert<Groth16VerificationKey>(vk);
}

public fun update_groth16_verification_key(fx: &signer, vk: Groth16VerificationKey) {
    system_addresses::assert_aptos_framework(fx);
    chain_status::assert_genesis();
    validate_groth16_vk(&vk); // ADD THIS CALL
    move_to(fx, vk);
}
```

## Proof of Concept

```move
#[test_only]
module test_addr::degenerate_vk_poc {
    use aptos_framework::keyless_account;
    use std::vector;
    
    #[test(framework = @aptos_framework)]
    #[expected_failure] // Should fail once validation is added
    fun test_duplicate_delta_beta(framework: &signer) {
        // Create a VK where delta_g2 = beta_g2 (same bytes)
        let duplicate_g2 = x"8d3ac832f2508af6f01872ada87ea66d2fb5b099d34c5bac81e7482c956276dfc234c8d2af5fd2394b5440d0708a2c9f124a53c0755e9595cf9f8adade5deefcb8a574a67debd3b74d08c49c23ddc14cd6d48b65dce500c8a5d330e760fe85bb";
        
        let alpha_g1 = x"9819f632fa8d724e351d25081ea31ccf379991ac25c90666e07103fffb042ed91c76351cd5a24041b40e26d231a5087e";
        let gamma_g2 = x"96750d8445596af8d679487c7267ae9734aeac584ace191d225680a18ecff8ebae6dd6a5fd68e4414b1611164904ee120363c2b49f33a873d6cfc26249b66327a0de03e673b8139f79809e8b641586cde9943fa072ee5ed701c81b3fd426c220";
        
        let gamma_abc_g1 = vector[
            x"b0df760d0f2d67fdff69d0ed3a0653dd8808df3c407ea4d0e27f8612c3fbb748cb4372d33cac512ee5ef4ee1683c3fe5",
            x"96ec80d6b1050bbfc209f727678acce8788c05475771daffdd444ad8786c7a40195d859850fe2e72be3054e9fb8ce805"
        ];
        
        // This should fail validation but currently doesn't
        let degenerate_vk = keyless_account::new_groth16_verification_key(
            alpha_g1,
            duplicate_g2,  // beta_g2
            gamma_g2,
            duplicate_g2,  // delta_g2 = beta_g2 (DEGENERATE!)
            gamma_abc_g1
        );
        
        // Currently this succeeds without validation
        keyless_account::update_groth16_verification_key(framework, degenerate_vk);
    }
}
```

## Notes

While this vulnerability requires governance compromise to exploit (placing it outside the primary threat model of "unprivileged attacker"), the missing validation represents a critical **defense-in-depth failure**. The existence of an unused `validate_groth16_vk()` function indicates this protection was intended but not implemented. Given the explicit warning that "a malicious key would lead to stolen funds," technical enforcement should exist to prevent this class of attack, especially considering insider threats and potential governance key compromises.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/keyless_account.move (L33-45)
```text
    struct Groth16VerificationKey has key, store, drop {
        /// 32-byte serialization of `alpha * G`, where `G` is the generator of `G1`.
        alpha_g1: vector<u8>,
        /// 64-byte serialization of `alpha * H`, where `H` is the generator of `G2`.
        beta_g2: vector<u8>,
        /// 64-byte serialization of `gamma * H`, where `H` is the generator of `G2`.
        gamma_g2: vector<u8>,
        /// 64-byte serialization of `delta * H`, where `H` is the generator of `G2`.
        delta_g2: vector<u8>,
        /// `\forall i \in {0, ..., \ell}, 64-byte serialization of gamma^{-1} * (beta * a_i + alpha * b_i + c_i) * H`, where
        /// `H` is the generator of `G1` and `\ell` is 1 for the ZK relation.
        gamma_abc_g1: vector<vector<u8>>,
    }
```

**File:** aptos-move/framework/aptos-framework/sources/keyless_account.move (L182-192)
```text
    /// Pre-validate the VK to actively-prevent incorrect VKs from being set on-chain.
    fun validate_groth16_vk(vk: &Groth16VerificationKey) {
        // Could be leveraged to speed up the VM deserialization of the VK by 2x, since it can assume the points are valid.
        assert!(option::is_some(&crypto_algebra::deserialize<bn254_algebra::G1, bn254_algebra::FormatG1Compr>(&vk.alpha_g1)), E_INVALID_BN254_G1_SERIALIZATION);
        assert!(option::is_some(&crypto_algebra::deserialize<bn254_algebra::G2, bn254_algebra::FormatG2Compr>(&vk.beta_g2)), E_INVALID_BN254_G2_SERIALIZATION);
        assert!(option::is_some(&crypto_algebra::deserialize<bn254_algebra::G2, bn254_algebra::FormatG2Compr>(&vk.gamma_g2)), E_INVALID_BN254_G2_SERIALIZATION);
        assert!(option::is_some(&crypto_algebra::deserialize<bn254_algebra::G2, bn254_algebra::FormatG2Compr>(&vk.delta_g2)), E_INVALID_BN254_G2_SERIALIZATION);
        for (i in 0..vector::length(&vk.gamma_abc_g1)) {
            assert!(option::is_some(&crypto_algebra::deserialize<bn254_algebra::G1, bn254_algebra::FormatG1Compr>(vector::borrow(&vk.gamma_abc_g1, i))), E_INVALID_BN254_G1_SERIALIZATION);
        };
    }
```

**File:** aptos-move/framework/aptos-framework/sources/keyless_account.move (L198-203)
```text
    public fun update_groth16_verification_key(fx: &signer, vk: Groth16VerificationKey) {
        system_addresses::assert_aptos_framework(fx);
        chain_status::assert_genesis();
        // There should not be a previous resource set here.
        move_to(fx, vk);
    }
```

**File:** aptos-move/framework/aptos-framework/sources/keyless_account.move (L262-262)
```text
    /// WARNING: If a malicious key is set, this would lead to stolen funds.
```

**File:** aptos-move/framework/aptos-framework/sources/keyless_account.move (L263-266)
```text
    public fun set_groth16_verification_key_for_next_epoch(fx: &signer, vk: Groth16VerificationKey) {
        system_addresses::assert_aptos_framework(fx);
        config_buffer::upsert<Groth16VerificationKey>(vk);
    }
```

**File:** types/src/keyless/groth16_vk.rs (L62-91)
```rust
impl TryFrom<&Groth16VerificationKey> for PreparedVerifyingKey<Bn254> {
    type Error = CryptoMaterialError;

    fn try_from(vk: &Groth16VerificationKey) -> Result<Self, Self::Error> {
        if vk.gamma_abc_g1.len() != 2 {
            return Err(CryptoMaterialError::DeserializationError);
        }

        // NOTE: Technically, we already validate the points when we set the VK in Move, so we could
        // make this 2x faster by avoiding the point validation checks  via
        // `deserialize_with_mode(..., Compress::Yes, Validate::No)`. Due to paranoia, will not
        // optimize this for now.
        Ok(Self::from(VerifyingKey {
            alpha_g1: G1Affine::deserialize_compressed(vk.alpha_g1.as_slice())
                .map_err(|_| CryptoMaterialError::DeserializationError)?,
            beta_g2: G2Affine::deserialize_compressed(vk.beta_g2.as_slice())
                .map_err(|_| CryptoMaterialError::DeserializationError)?,
            gamma_g2: G2Affine::deserialize_compressed(vk.gamma_g2.as_slice())
                .map_err(|_| CryptoMaterialError::DeserializationError)?,
            delta_g2: G2Affine::deserialize_compressed(vk.delta_g2.as_slice())
                .map_err(|_| CryptoMaterialError::DeserializationError)?,
            gamma_abc_g1: vec![
                G1Affine::deserialize_compressed(vk.gamma_abc_g1[0].as_slice())
                    .map_err(|_| CryptoMaterialError::DeserializationError)?,
                G1Affine::deserialize_compressed(vk.gamma_abc_g1[1].as_slice())
                    .map_err(|_| CryptoMaterialError::DeserializationError)?,
            ],
        }))
    }
}
```

**File:** types/src/keyless/proof_simulation.rs (L67-86)
```rust
    pub fn circuit_agnostic_setup_with_trapdoor<R: RngCore>(
        rng: &mut R,
        num_public_inputs: u32,
    ) -> Result<(Trapdoor<E>, VerifyingKey<E>), SynthesisError> {
        let alpha = Self::generate_random_scalar(rng);
        let beta = Self::generate_random_scalar(rng);
        let gamma = Self::generate_random_scalar(rng);
        let delta = Self::generate_random_scalar(rng);

        let g1_generator = Self::generate_random_g1_elem(rng);

        let g2_generator_base = E::G2::generator();
        let g2_generator_scalar = Self::generate_random_scalar(rng);
        let g2_generator = g2_generator_base * g2_generator_scalar;

        let alpha_g1 = g1_generator * alpha;
        let beta_g2 = g2_generator * beta;
        let gamma_g2 = g2_generator * gamma;
        let delta_g2 = g2_generator * delta;

```

**File:** types/src/keyless/proof_simulation.rs (L152-181)
```rust
    pub fn create_proof_with_trapdoor(
        pk: &Trapdoor<E>,
        a: E::ScalarField,
        b: E::ScalarField,
        public_inputs: &[E::ScalarField],
    ) -> Result<Proof<E>, SynthesisError> {
        let mut g_ic = pk.gamma_abc_g1[0].into_group();
        for (i, b) in public_inputs.iter().zip(pk.gamma_abc_g1.iter().skip(1)) {
            g_ic.add_assign(&b.mul_bigint(i.into_bigint()));
        }
        g_ic *= pk.gamma;

        let delta_inverse = pk.delta.inverse().unwrap();
        let ab = a * b;
        let alpha_beta = pk.alpha * pk.beta;

        let g1_ab = pk.g1 * ab;
        let g1_alpha_beta = pk.g1 * alpha_beta;

        let g1_a = pk.g1 * a;
        let g2_b = pk.g2 * b;

        let g1_c = (g1_ab - g1_alpha_beta - g_ic) * delta_inverse;

        Ok(Proof {
            a: g1_a.into_affine(),
            b: g2_b.into_affine(),
            c: g1_c.into_affine(),
        })
    }
```
