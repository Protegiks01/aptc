# Audit Report

## Title
Insufficient Manifest Authentication Enables Consensus Safety Violation Through Backup Injection

## Summary
Backup manifests are not cryptographically authenticated before restoration begins. When performing one-shot restores without trusted waypoints, LedgerInfo signatures are not verified, allowing an attacker with backup storage access to inject malicious manifests that restore nodes to incorrect states, violating consensus safety.

## Finding Description

The restore system fails to cryptographically authenticate backup manifests before using them, and cryptographic verification of backup data is insufficient in multiple scenarios:

**1. Manifest Loading Without Authentication:** [1](#0-0) 

Manifests are loaded via `load_json_file()` which simply deserializes JSON without any signature verification or integrity checking. An attacker with write access to backup storage can inject arbitrary manifest files.

**2. One-Shot State Snapshot Restore Without Signature Verification:** [2](#0-1) 

The `StateSnapshot` one-shot restore hardcodes `epoch_history` to `None`, preventing signature verification: [3](#0-2) 

When `epoch_history` is `None`, the critical `verify_ledger_info()` check is skipped, meaning the LedgerInfoWithSignatures is never validated. Only the Merkle proof is checked, not the validator signatures.

**3. One-Shot Transaction Restore Without Signature Verification:** [4](#0-3) 

Similarly, transaction restores pass `None` for epoch_history: [5](#0-4) 

The signature verification is conditional and skipped when epoch_history is None.

**4. Epoch History Bootstrap Without Initial Trust Anchor:** [6](#0-5) 

For the first epoch, if no trusted waypoint exists and there's no previous LedgerInfo, neither condition (lines 129 nor 136) is satisfied, so signature verification at line 146 never executes. The entire epoch history chain is built on an unverified foundation.

**5. Trusted Waypoints Are Optional:** [7](#0-6) 

The `trust_waypoint` field is a `Vec<Waypoint>` with no enforcement that it must be non-empty, and the comment explicitly states signatures are "NOT checked" when waypoints are provided.

## Impact Explanation

This vulnerability meets **Critical Severity** criteria per the Aptos bug bounty program:

**Consensus/Safety Violation**: Multiple validators restoring from compromised backups could restore to different states, breaking the fundamental "Deterministic Execution" and "Consensus Safety" invariants. If validators commit different state roots for the same version, the network experiences a consensus failure requiring manual intervention or hard fork.

**State Consistency Violation**: Nodes could restore to incorrect blockchain states that appear valid (Merkle proofs check out) but represent a forked or historical chain, violating "State Consistency" invariant.

**Network Partition Risk**: If a subset of validators restore from malicious backups while others restore from legitimate sources, the network could partition into incompatible chains.

## Likelihood Explanation

**Likelihood: Medium to High**

**Attacker Requirements:**
- Write access to backup storage (e.g., compromised cloud storage credentials, insider access)
- Knowledge of backup format and manifest structure
- Ability to construct valid Merkle proofs (can use legitimate backup data)

**Realistic Scenarios:**
1. **Cloud Credential Compromise**: Common attack vector against cloud storage (S3, GCS, Azure)
2. **Insider Threat**: Malicious operator with backup access
3. **Supply Chain Attack**: Compromised backup tooling
4. **Misconfigured Access Controls**: Overly permissive backup storage permissions

**Exploitation Feasibility:**
- No validator key compromise required
- No consensus protocol exploitation needed
- Standard restore operations trigger the vulnerability
- Many operators may skip trusted waypoints for convenience

## Recommendation

**Immediate Mitigations:**

1. **Enforce Trusted Waypoints for Production Restores:**
```rust
impl TrustedWaypointOpt {
    pub fn verify(self) -> Result<HashMap<Version, Waypoint>> {
        // Add check: ensure at least genesis waypoint is provided
        ensure!(!self.trust_waypoint.is_empty(), 
            "At least one trusted waypoint must be provided for secure restoration");
        
        let mut trusted_waypoints = HashMap::new();
        for w in self.trust_waypoint {
            trusted_waypoints
                .insert(w.version(), w)
                .map_or(Ok(()), |w| {
                    Err(AptosDbError::Other(format!(
                        "Duplicated waypoints at version {}",
                        w.version()
                    )))
                })?;
        }
        Ok(trusted_waypoints)
    }
}
```

2. **Sign Manifest Files:**
Add manifest signing using validator keys or dedicated backup service keys:
```rust
#[derive(Deserialize, Serialize)]
pub struct AuthenticatedManifest<T> {
    pub manifest: T,
    pub signature: Signature,
    pub signer_public_key: PublicKey,
}

impl<T: Serialize> AuthenticatedManifest<T> {
    pub fn verify(&self, trusted_keys: &[PublicKey]) -> Result<()> {
        ensure!(
            trusted_keys.contains(&self.signer_public_key),
            "Manifest signed by untrusted key"
        );
        let message = bcs::to_bytes(&self.manifest)?;
        self.signature.verify(&message, &self.signer_public_key)
    }
}
```

3. **Always Build Epoch History:**
Modify one-shot restores to build epoch history rather than passing None: [8](#0-7) 

Change to load epoch ending backups and build epoch_history before state snapshot restore.

4. **Add Integrity Checks:**
Include content hash in metadata that is verified against manifest contents:
```rust
#[derive(Deserialize, Serialize)]
pub struct StateSnapshotBackupMeta {
    pub epoch: u64,
    pub version: Version,
    pub manifest: FileHandle,
    pub manifest_hash: HashValue,  // Add this
}
```

## Proof of Concept

**Attack Simulation Steps:**

1. **Setup Malicious Backup Storage:**
```bash
# Attacker gains access to backup storage credentials
export BACKUP_STORAGE="s3://compromised-bucket"

# Create malicious manifest pointing to old backup data
cat > malicious_snapshot.json <<EOF
{
  "version": 1000000,
  "epoch": 100,
  "root_hash": "0xABCD...",  # From old legitimate backup
  "chunks": [...],           # Point to old chunks
  "proof": "old_proof.bcs"   # Old but validly signed proof
}
EOF
```

2. **Inject Malicious Manifest:**
```bash
# Upload malicious manifest to backup storage
aws s3 cp malicious_snapshot.json s3://compromised-bucket/state_snapshot_ver_1000000.meta

# Modify metadata to reference malicious manifest
cat > metadata.json <<EOF
{"StateSnapshotBackup":{"epoch":100,"version":1000000,"manifest":"s3://compromised-bucket/malicious_snapshot.json"}}
EOF
aws s3 cp metadata.json s3://compromised-bucket/metadata/
```

3. **Victim Performs One-Shot Restore:**
```bash
# Validator performs restore WITHOUT trusted waypoints
aptos-db-tool restore oneoff state-snapshot \
  --state-manifest s3://compromised-bucket/malicious_snapshot.json \
  --state-into-version 1000000 \
  --target-db-dir /opt/aptos/data \
  --command-adapter-config backup_config.yaml
  # NO --trust-waypoint provided!
```

4. **Result:**
    - Manifest loaded without authentication check
    - `epoch_history` is `None` (hardcoded in restore.rs:92)
    - LedgerInfo signatures NOT verified (restore.rs:137-139)
    - Node restores to state from old backup (replay attack)
    - If multiple validators do this, different states â†’ consensus break

**Expected Behavior vs Actual:**
- **Expected**: Manifest signature verified, LedgerInfo signatures verified, restoration rejected
- **Actual**: Manifest accepted, signatures skipped, restoration succeeds with incorrect state

## Notes

The vulnerability is particularly dangerous because:

1. **Silent Failure**: No warnings issued when restoring without trusted waypoints
2. **Documentation Gap**: The security risk of skipping waypoints is not prominently documented
3. **Default Unsafe**: One-shot restores default to unsafe behavior (None epoch_history)
4. **Chain of Trust Broken**: First epoch in bootstrap can be unverified

The mitigation requires both code changes (enforce waypoints, add signing) and operational guidance (always use trusted waypoints in production).

### Citations

**File:** storage/backup/backup-cli/src/utils/storage_ext.rs (L35-37)
```rust
    async fn load_json_file<T: DeserializeOwned>(&self, file_handle: &FileHandleRef) -> Result<T> {
        Ok(serde_json::from_slice(&self.read_all(file_handle).await?)?)
    }
```

**File:** storage/db-tool/src/restore.rs (L83-96)
```rust
                    Oneoff::StateSnapshot {
                        storage,
                        opt,
                        global,
                    } => {
                        StateSnapshotRestoreController::new(
                            opt,
                            global.try_into()?,
                            storage.init_storage().await?,
                            None, /* epoch_history */
                        )
                        .run()
                        .await?;
                    },
```

**File:** storage/db-tool/src/restore.rs (L97-111)
```rust
                    Oneoff::Transaction {
                        storage,
                        opt,
                        global,
                    } => {
                        TransactionRestoreController::new(
                            opt,
                            global.try_into()?,
                            storage.init_storage().await?,
                            None, /* epoch_history */
                            VerifyExecutionMode::NoVerify,
                        )
                        .run()
                        .await?;
                    },
```

**File:** storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs (L137-139)
```rust
        if let Some(epoch_history) = self.epoch_history.as_ref() {
            epoch_history.verify_ledger_info(&li)?;
        }
```

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L152-154)
```rust
        if let Some(epoch_history) = epoch_history {
            epoch_history.verify_ledger_info(&ledger_info)?;
        }
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L129-147)
```rust
                if let Some(wp_trusted) = self.trusted_waypoints.get(&wp_li.version()) {
                    ensure!(
                        *wp_trusted == wp_li,
                        "Waypoints don't match. In backup: {}, trusted: {}",
                        wp_li,
                        wp_trusted,
                    );
                } else if let Some(pre_li) = previous_li {
                    pre_li
                        .ledger_info()
                        .next_epoch_state()
                        .ok_or_else(|| {
                            anyhow!(
                                "Next epoch state not found from LI at epoch {}.",
                                pre_li.ledger_info().epoch()
                            )
                        })?
                        .verify(&li)?;
                }
```

**File:** storage/backup/backup-cli/src/utils/mod.rs (L332-346)
```rust
pub struct TrustedWaypointOpt {
    #[clap(
        long,
        help = "(multiple) When provided, an epoch ending LedgerInfo at the waypoint version will be \
        checked against the hash in the waypoint, but signatures on it are NOT checked. \
        Use this for two purposes: \
        1. set the genesis or the latest waypoint to confirm the backup is compatible. \
        2. set waypoints at versions where writeset transactions were used to overwrite the \
        validator set, so that the signature check is skipped. \
        N.B. LedgerInfos are verified only when restoring / verifying the epoch ending backups, \
        i.e. they are NOT checked at all when doing one-shot restoring of the transaction \
        and state backups."
    )]
    pub trust_waypoint: Vec<Waypoint>,
}
```
