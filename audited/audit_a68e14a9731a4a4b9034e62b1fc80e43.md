# Audit Report

## Title
Connection Flooding Vulnerability Through Unauthenticated Diffie-Hellman Operations in Noise Handshake

## Summary
An attacker can exhaust validator CPU resources by opening many TCP connections simultaneously, forcing the server to perform expensive Diffie-Hellman (DH) cryptographic operations during the Noise handshake before any authentication or connection limit checks occur. This can cause validator node slowdowns and impact consensus performance.

## Finding Description

The Aptos network layer uses the Noise IK handshake protocol to establish authenticated connections between validators. During the inbound connection upgrade process, the server performs two expensive X25519 Diffie-Hellman operations **before** checking whether the connecting peer is authenticated or whether connection limits have been exceeded.

The vulnerable execution flow is:

1. TCP connection arrives and is accepted by the listener [1](#0-0) 

2. An async upgrade future is created for the Noise handshake [2](#0-1) 

3. The `upgrade_inbound` function performs the Noise handshake [3](#0-2) 

4. Inside `NoiseUpgrader::upgrade_inbound`, the function calls `parse_client_init_message` [4](#0-3) 

5. `parse_client_init_message` performs **two expensive DH operations** (es and ss) to decrypt the client's static public key and payload: [5](#0-4) 


6. **Only after** these DH operations does the code check if the peer is in the trusted peers set [6](#0-5) 

7. Connection limits are checked even later, after the entire handshake completes successfully [7](#0-6) 

An attacker can exploit this by:
- Opening many simultaneous TCP connections to a validator node
- Each connection forces the server to perform expensive cryptographic operations
- The operations occur before authentication or rate limiting
- If connections are opened faster than they can be processed, CPU resources are exhausted
- This causes validator slowdown and impacts consensus participation

The code comments acknowledge this design concern but claim it's acceptable for mutual auth scenarios: [8](#0-7) 

However, the lack of rate limiting on pending connection upgrades means an attacker can still cause resource exhaustion.

## Impact Explanation

This vulnerability qualifies as **Medium Severity** per the Aptos bug bounty criteria:
- **Validator node slowdowns**: Sustained connection flooding can exhaust CPU resources, causing validators to fall behind in consensus rounds
- **Impacts availability/liveness**: While not causing total network unavailability, degraded validator performance affects consensus progress
- **Resource exhaustion**: Violates the invariant that "All operations must respect gas, storage, and computational limits" - here, no limits are enforced on expensive crypto operations before authentication

The impact is limited by:
- HAProxy provides partial mitigation (maxconn 500, maxconnrate 300) in production deployments
- TCP backlog limits (256) provide OS-level protection
- 30-second transport timeout eventually terminates slow connections

However, direct connections to validators or misconfigurations can bypass these protections.

## Likelihood Explanation

**Likelihood: Medium-High**

The attack is straightforward to execute:
- Attacker needs only network access (no special privileges)
- No authentication required to trigger expensive operations
- Standard tools can open many simultaneous connections
- X25519 DH operations are CPU-intensive (microseconds each, but multiplicative with many connections)

Mitigating factors:
- Production deployments typically use HAProxy for connection limiting
- Validator nodes are not always directly exposed to public internet
- OS-level limits on file descriptors/connections provide some protection

## Recommendation

Implement connection rate limiting **before** performing expensive cryptographic operations:

**Option 1: Limit pending connection upgrades**
Add a check before starting the handshake to reject connections when too many are in progress:

```rust
// In TransportHandler::upgrade_inbound_connection
if pending_inbound_connections.len() >= MAX_PENDING_UPGRADES {
    // Reject connection without performing handshake
    return None;
}
```

**Option 2: Add early authentication check**
For mutual auth mode, verify the peer is in the trusted set before performing DH operations. This requires refactoring the Noise handshake to expose the client's static public key earlier.

**Option 3: Rate limiting per source IP**
Track connection attempts per source IP address and reject connections from IPs exceeding a rate limit.

**Recommended Fix**: Implement Option 1 combined with per-IP rate limiting. Add a configuration parameter `max_pending_connection_upgrades` (e.g., 100) and reject new inbound connections when this limit is reached.

## Proof of Concept

```rust
// Rust PoC to demonstrate connection flooding
use tokio::net::TcpStream;
use futures::future::join_all;

#[tokio::main]
async fn main() {
    let target = "validator_ip:6180"; // Validator node address
    let num_connections = 1000;
    
    println!("Opening {} connections to {}", num_connections, target);
    
    let mut handles = vec![];
    for i in 0..num_connections {
        let handle = tokio::spawn(async move {
            match TcpStream::connect(target).await {
                Ok(mut stream) => {
                    // Send partial handshake to trigger DH operations
                    let malformed_handshake = vec![0u8; 96];
                    let _ = tokio::io::AsyncWriteExt::write_all(&mut stream, &malformed_handshake).await;
                    // Keep connection open
                    tokio::time::sleep(tokio::time::Duration::from_secs(30)).await;
                },
                Err(e) => println!("Connection {} failed: {}", i, e),
            }
        });
        handles.push(handle);
        
        // Slight delay to avoid local port exhaustion
        tokio::time::sleep(tokio::time::Duration::from_millis(10)).await;
    }
    
    join_all(handles).await;
}
```

**Expected behavior**: Without rate limiting, the validator node's CPU usage spikes due to processing many concurrent Noise handshakes, potentially causing consensus timeouts and degraded performance.

**Notes**
- The `anti_replay_timestamps` HashMap itself is **not** vulnerable in mutual auth mode, as it's bounded by the trusted peer set size
- The core issue is the lack of rate limiting on expensive cryptographic operations before authentication
- This is an application-layer vulnerability, not a network-layer DoS
- Production deployments with properly configured HAProxy have partial mitigation but remain vulnerable to direct connections

### Citations

**File:** network/netcore/src/transport/tcp.rs (L127-127)
```rust
        let listener = socket.listen(256)?;
```

**File:** network/framework/src/peer_manager/transport.rs (L141-155)
```rust
        match incoming_connection {
            Ok((upgrade, addr)) => {
                debug!(
                    NetworkSchema::new(&self.network_context).network_address(&addr),
                    "{} Incoming connection from {}", self.network_context, addr
                );

                counters::pending_connection_upgrades(
                    &self.network_context,
                    ConnectionOrigin::Inbound,
                )
                .inc();

                let start_time = self.time_service.now();
                Some(upgrade.map(move |out| (out, addr, start_time)).boxed())
```

**File:** network/framework/src/transport/mod.rs (L277-278)
```rust
    let (mut socket, remote_peer_id, peer_role) =
        ctxt.noise.upgrade_inbound(socket).await.map_err(|err| {
```

**File:** network/framework/src/noise/handshake.rs (L86-91)
```rust
        // Only use anti replay protection in mutual-auth scenarios. In theory,
        // this is applicable everywhere; however, we would need to spend some
        // time making this more sophisticated so it garbage collects old
        // timestamps and doesn't use unbounded space. These are not problems in
        // mutual-auth scenarios because we have a bounded set of trusted peers
        // that rarely changes.
```

**File:** network/framework/src/noise/handshake.rs (L361-364)
```rust
        let (remote_public_key, handshake_state, payload) = self
            .noise_config
            .parse_client_init_message(prologue, client_init_message)
            .map_err(|err| NoiseHandshakeError::ServerParseClient(remote_peer_short, err))?;
```

**File:** network/framework/src/noise/handshake.rs (L368-382)
```rust
        let peer_role = match &self.auth_mode {
            HandshakeAuthMode::Mutual {
                peers_and_metadata, ..
            } => {
                let trusted_peers = peers_and_metadata.get_trusted_peers(&network_id)?;
                let trusted_peer = trusted_peers.get(&remote_peer_id).cloned();
                match trusted_peer {
                    Some(peer) => {
                        Self::authenticate_inbound(remote_peer_short, &peer, &remote_public_key)
                    },
                    None => Err(NoiseHandshakeError::UnauthenticatedClient(
                        remote_peer_short,
                        remote_peer_id,
                    )),
                }
```

**File:** crates/aptos-crypto/src/noise.rs (L448-450)
```rust
        // <- es
        let dh_output = self.private_key.diffie_hellman(&re);
        let k = mix_key(&mut ck, &dh_output)?;
```

**File:** network/framework/src/peer_manager/mod.rs (L372-388)
```rust
                if !self
                    .active_peers
                    .contains_key(&conn.metadata.remote_peer_id)
                    && unknown_inbound_conns + 1 > self.inbound_connection_limit
                {
                    info!(
                        NetworkSchema::new(&self.network_context)
                            .connection_metadata_with_address(&conn.metadata),
                        "{} Connection rejected due to connection limit: {}",
                        self.network_context,
                        conn.metadata
                    );
                    counters::connections_rejected(&self.network_context, conn.metadata.origin)
                        .inc();
                    self.disconnect(conn);
                    return;
                }
```
