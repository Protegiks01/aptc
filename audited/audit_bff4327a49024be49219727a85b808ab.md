# Audit Report

## Title
RwLock Poisoning Vulnerability in TokenBucketRateLimiter Due to Missing Constructor Validation

## Summary
The `TokenBucketRateLimiter` constructor fails to validate that `default_bucket_size >= default_fill_rate`, allowing creation of a rate limiter with invalid parameters. When `bucket()` is first called, a panic occurs while holding the write lock, poisoning the `aptos_infallible::RwLock` and permanently disabling the rate limiter for all subsequent operations.

## Finding Description

The vulnerability exists in the interaction between three code locations:

1. **Constructor validation** [1](#0-0) 
   The constructor only validates that both values are greater than zero, but does not enforce the invariant that `default_bucket_size >= default_fill_rate`.

2. **Write lock acquisition** [2](#0-1) 
   When `bucket()` is called, the write lock is acquired at line 148 and held through the entire expression chain.

3. **Bucket::new assertion** [3](#0-2) 
   The `Bucket::new()` method asserts that `size >= rate`, which will panic if invalid parameters were allowed through the constructor.

The critical issue is that `aptos_infallible::RwLock` wraps the standard library `RwLock` and calls `.expect()` on lock operations [4](#0-3) . When a lock becomes poisoned, all subsequent lock acquisition attempts panic with "Cannot currently handle a poisoned lock".

**Attack Flow:**
1. A `TokenBucketRateLimiter` is instantiated with `default_bucket_size=5, default_fill_rate=10`
2. Constructor succeeds (both values > 0)
3. First call to `bucket(key)` acquires write lock at line 148
4. Inside `or_insert_with` closure, `Bucket::new()` is called at line 121
5. `Bucket::new()` asserts `size >= rate`, which fails (5 < 10)
6. Panic occurs while write lock is held, poisoning the RwLock
7. All subsequent calls to `bucket()` or `try_garbage_collect_key()` panic at lock acquisition
8. The rate limiter becomes permanently unusable

This rate limiter is used for network inbound/outbound rate limiting [5](#0-4) , making it critical for validator node operations.

## Impact Explanation

This qualifies as **Medium Severity** rather than Critical or High because:

**Against Critical**: While the rate limiter is used in network operations, this is NOT exploitable by an unprivileged attacker. Network configuration is controlled by node operators, not external actors. An attacker cannot directly set the rate limiter parameters.

**Against High**: This is a configuration error that would occur during node setup/initialization, not during runtime from external input. It requires operator error rather than attacker exploitation.

**For Medium**: If this configuration error occurs (operator sets invalid parameters), it causes a permanent DoS condition for that node's rate limiting functionality, requiring node restart with corrected configuration. This is a state inconsistency requiring intervention.

## Likelihood Explanation

**Likelihood: Low**

This issue would only occur if:
1. A node operator misconfigures the rate limiter with `bucket_size < fill_rate`
2. The misconfiguration passes any external validation
3. The node is started and the first rate-limited connection is attempted

The likelihood is reduced by:
- Configuration is typically set via structured config files with schemas
- Operators would likely catch this during testing
- The error message from the assertion is clear when it occurs

However, the impact is severe when it does occur - the node's rate limiting becomes permanently broken.

## Recommendation

Add validation to the `TokenBucketRateLimiter::new()` constructor to enforce the invariant that must hold in `Bucket::new()`:

```rust
pub fn new(
    label: &'static str,
    log_info: String,
    new_bucket_start_percentage: u8,
    default_bucket_size: usize,
    default_fill_rate: usize,
    metrics: Option<HistogramVec>,
) -> Self {
    // Ensure that we can actually use the rate limiter
    assert!(new_bucket_start_percentage <= 100);
    assert!(default_bucket_size > 0);
    assert!(default_fill_rate > 0);
    assert!(
        default_bucket_size >= default_fill_rate,
        "Bucket size ({}) must be greater than or equal to fill rate ({})",
        default_bucket_size,
        default_fill_rate
    );
    
    // ... rest of constructor
}
```

This ensures fail-fast behavior at construction time rather than deferred failure when the write lock is held.

## Proof of Concept

```rust
#[test]
#[should_panic(expected = "Bucket size (5) must be greater than or equal to fill rate (10)")]
fn test_invalid_bucket_configuration() {
    // This should panic at construction time with the fix
    let rate_limiter = TokenBucketRateLimiter::<&str>::new(
        "test",
        "test".to_string(),
        100,
        5,   // bucket_size < fill_rate
        10,  // fill_rate > bucket_size
        None,
    );
    
    // Without the fix, this would succeed and the panic would occur here:
    let _bucket = rate_limiter.bucket("key");
    // At this point, the RwLock would be poisoned and the rate limiter permanently broken
}

#[test]
fn test_rwlock_poisoning_propagates() {
    use std::panic::{catch_unwind, AssertUnwindSafe};
    
    // Create rate limiter with invalid params (requires removing the fix)
    let rate_limiter = TokenBucketRateLimiter::<&str>::new(
        "test",
        "test".to_string(),
        100,
        5,
        10,
        None,
    );
    
    // First call panics while holding write lock, poisoning it
    let _ = catch_unwind(AssertUnwindSafe(|| {
        rate_limiter.bucket("key1");
    }));
    
    // Second call panics immediately at lock acquisition due to poisoned lock
    let result = catch_unwind(AssertUnwindSafe(|| {
        rate_limiter.bucket("key2");
    }));
    
    assert!(result.is_err());
    // The error would be "Cannot currently handle a poisoned lock"
}
```

**Notes:**

Regarding **line 140 specifically**: The read lock is acquired and released within the block on line 139 [6](#0-5) . By the time execution reaches line 140, the lock is no longer held, so panics at line 140 itself do NOT poison the lock.

Regarding **line 148 specifically**: The write lock is acquired at line 148 and held through the method chain until line 161. Panics occurring during this time (particularly in `Bucket::new()` called from the closure) DO poison the lock, making the rate limiter permanently unusable.

### Citations

**File:** crates/aptos-rate-limiter/src/rate_limit.rs (L74-77)
```rust
        // Ensure that we can actually use the rate limiter
        assert!(new_bucket_start_percentage <= 100);
        assert!(default_bucket_size > 0);
        assert!(default_fill_rate > 0);
```

**File:** crates/aptos-rate-limiter/src/rate_limit.rs (L139-140)
```rust
        let maybe_bucket = { self.buckets.read().get(&key).cloned() };
        if let Some(bucket) = maybe_bucket {
```

**File:** crates/aptos-rate-limiter/src/rate_limit.rs (L147-161)
```rust
            self.buckets
                .write()
                .entry(key.clone())
                .or_insert_with(|| {
                    bucket_create(
                        self.label.to_string(),
                        self.log_info.clone(),
                        format!("{:?}", key),
                        size.saturating_mul(self.new_bucket_start_percentage as usize) / 100,
                        size,
                        rate,
                        self.metrics.clone(),
                    )
                })
                .clone()
```

**File:** crates/aptos-rate-limiter/src/rate_limit.rs (L216-219)
```rust
        assert!(
            size >= rate,
            "Bucket size must be greater than or equal to fill rate"
        );
```

**File:** crates/aptos-infallible/src/rwlock.rs (L19-29)
```rust
    pub fn read(&self) -> RwLockReadGuard<'_, T> {
        self.0
            .read()
            .expect("Cannot currently handle a poisoned lock")
    }

    /// lock the rwlock in write mode
    pub fn write(&self) -> RwLockWriteGuard<'_, T> {
        self.0
            .write()
            .expect("Cannot currently handle a poisoned lock")
```

**File:** config/src/config/network_config.rs (L117-119)
```rust
    pub inbound_rate_limit_config: Option<RateLimitConfig>,
    /// Outbound rate limiting configuration, if not specified, no rate limiting
    pub outbound_rate_limit_config: Option<RateLimitConfig>,
```
