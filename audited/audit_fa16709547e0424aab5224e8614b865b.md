# Audit Report

## Title
JWK Consensus Issuer Validation Bypass - Mislabeled JWKs Enable Authentication Bypass

## Summary
The JWK consensus system fails to validate that fetched JWKs actually belong to the claimed issuer. An attacker who can manipulate OpenID configuration responses (via MITM, DNS hijacking, or malicious on-chain configuration) can supply JWKs from one provider while labeling them as belonging to a different provider, enabling complete authentication bypass for keyless accounts.

## Finding Description

The vulnerability exists across multiple components in the JWK observation and consensus flow:

**1. Missing Issuer Validation in OpenID Configuration Fetch**

The `fetch_jwks_uri_from_openid_config()` function fetches the OpenID configuration but discards the `issuer` field from the response: [1](#0-0) 

The OpenID configuration includes an `issuer` field that should be validated against the expected issuer, but it is completely ignored in the destructuring pattern.

**2. JWKObserver Labels JWKs Without Validation**

The JWKObserver uses the issuer from its initialization parameter rather than validating it against the fetched data: [2](#0-1) 

At line 80, the issuer from the function parameter is used to label the fetched JWKs without any validation that these JWKs actually belong to that issuer.

**3. Request Creation Preserves Unvalidated Issuer**

The `new_rb_request()` function extracts the issuer from the payload without any additional validation: [3](#0-2) 

The issuer extracted via `try_from_issuer_level_repr()` comes directly from the payload's issuer field, which was set by the JWKObserver without validation.

**4. Extraction Logic Trusts Payload Structure**

The `try_from_issuer_level_repr()` function directly copies the issuer from the payload: [4](#0-3) 

At line 372, the issuer is cloned directly from `repr.issuer` with no validation that it matches the actual source of the JWKs.

**Attack Scenario:**

1. On-chain configuration has: `issuer="https://accounts.google.com"`, `config_url="https://evil-proxy.com/.well-known/openid-configuration"`
2. Attacker's proxy returns: `{"issuer": "https://evil.com", "jwks_uri": "https://evil.com/jwks"}`
3. `fetch_jwks_uri_from_openid_config()` ignores the mismatched issuer
4. Evil JWKs are fetched and labeled as `"https://accounts.google.com"`
5. All validators observe and reach consensus on these mislabeled JWKs
6. The evil JWKs are stored on-chain under Google's issuer
7. Attacker can now forge JWT tokens claiming to be from Google using their own keys
8. All keyless accounts using Google authentication are compromised

**Broken Invariants:**
- **Consensus Safety**: Validators reach consensus on incorrect/malicious data
- **Cryptographic Correctness**: Authentication mechanism is fundamentally compromised
- **State Consistency**: On-chain state contains JWKs attributed to the wrong issuer

## Impact Explanation

**Severity: CRITICAL**

This vulnerability meets multiple Critical severity criteria from the Aptos bug bounty program:

1. **Loss of Funds**: An attacker can impersonate any user of the affected OIDC provider by forging JWT tokens with their malicious keys. This enables theft from keyless accounts.

2. **Consensus/Safety Violation**: All honest validators, fetching from the same malicious source, will reach consensus on incorrect JWK data, violating the fundamental guarantee that consensus should only be achieved on valid data.

3. **Non-recoverable State Corruption**: Once malicious JWKs are committed on-chain with the wrong issuer label, the authentication system is compromised until a hard fork or governance intervention removes the malicious data.

The impact is particularly severe because:
- It affects all keyless accounts using the targeted OIDC provider
- The attack persists across epochs once malicious JWKs are on-chain
- Detection is difficult since validators agree on the malicious data
- Requires chain-wide intervention to remediate

## Likelihood Explanation

**Likelihood: Medium to High**

The attack requires one of the following conditions:

1. **MITM Attack** (Medium difficulty): Attacker intercepts traffic between validators and OpenID configuration endpoints. This is feasible if:
   - Validators don't use proper TLS certificate validation
   - Network infrastructure is compromised
   - DNS hijacking redirects configuration URLs

2. **Malicious On-Chain Configuration** (Lower difficulty if governance is compromised): If an attacker can influence governance to set a malicious `config_url` for an OIDC provider, the attack becomes trivial.

3. **Compromised OpenID Provider** (Low likelihood but catastrophic): If the actual OIDC provider's infrastructure is compromised, attackers control the response directly.

The vulnerability is more likely to occur than typical consensus attacks because:
- It doesn't require validator collusion
- All validators are affected simultaneously if they share the same network path
- The missing validation is a systematic flaw, not a race condition
- No cryptographic breaking is required

## Recommendation

Implement strict issuer validation at multiple layers:

**1. Validate Issuer in OpenID Configuration Response:**

```rust
// In crates/jwk-utils/src/lib.rs
pub async fn fetch_jwks_uri_from_openid_config(
    expected_issuer: &str,
    config_url: &str
) -> Result<String> {
    let client = reqwest::Client::new();
    let OpenIDConfiguration { issuer, jwks_uri } = client
        .get(config_url)
        .send()
        .await?
        .json()
        .await?;
    
    // CRITICAL: Validate issuer matches expected value
    ensure!(
        issuer == expected_issuer,
        "Issuer mismatch: expected '{}', got '{}' from OpenID config",
        expected_issuer,
        issuer
    );
    
    Ok(jwks_uri)
}
```

**2. Update JWKObserver to Pass Expected Issuer:**

```rust
// In crates/aptos-jwk-consensus/src/jwk_observer.rs
async fn fetch_jwks(
    expected_issuer: &str,
    open_id_config_url: &str,
    my_addr: Option<AccountAddress>
) -> Result<Vec<JWK>> {
    let jwks_uri = fetch_jwks_uri_from_openid_config(expected_issuer, open_id_config_url)
        .await
        .map_err(|e| anyhow!("fetch_jwks failed with issuer validation: {e}"))?;
    // ... rest of function
}
```

**3. Add Runtime Assertion in try_from_issuer_level_repr:**

```rust
// Additional validation could be added to verify JWK metadata
// if the JWK specification includes issuer information
```

**4. On-Chain Validation:**

Consider adding Move-level validation that checks the issuer field against a whitelist of approved issuers before accepting JWK updates.

## Proof of Concept

**Test Setup:**

```rust
#[tokio::test]
async fn test_issuer_mismatch_vulnerability() {
    use httpmock::prelude::*;
    
    // Start mock server
    let server = MockServer::start();
    
    // Mock malicious OpenID configuration
    let evil_config_mock = server.mock(|when, then| {
        when.method(GET).path("/.well-known/openid-configuration");
        then.status(200)
            .header("content-type", "application/json")
            .json_body(json!({
                "issuer": "https://evil.com",  // Different issuer!
                "jwks_uri": format!("{}/evil-jwks", server.base_url())
            }));
    });
    
    // Mock malicious JWKs endpoint
    let evil_jwks_mock = server.mock(|when, then| {
        when.method(GET).path("/evil-jwks");
        then.status(200)
            .header("content-type", "application/json")
            .json_body(json!({
                "keys": [{
                    "kty": "RSA",
                    "kid": "evil-key-1",
                    "n": "malicious_modulus",
                    "e": "AQAB"
                }]
            }));
    });
    
    // Attempt to fetch JWKs claiming to be from Google
    let expected_issuer = "https://accounts.google.com";
    let malicious_config_url = format!("{}/.well-known/openid-configuration", server.base_url());
    
    // Current implementation SUCCEEDS (vulnerability)
    let result = fetch_jwks_uri_from_openid_config(&malicious_config_url).await;
    assert!(result.is_ok());  // Vulnerability: accepts mismatched issuer
    
    // Fixed implementation should FAIL
    // let result = fetch_jwks_uri_from_openid_config(expected_issuer, &malicious_config_url).await;
    // assert!(result.is_err());  // Should reject mismatched issuer
    
    evil_config_mock.assert();
}
```

**Demonstration of Impact:**

```rust
#[tokio::test]
async fn demonstrate_authentication_bypass() {
    // 1. Attacker sets up malicious OpenID config that returns evil JWKs
    // 2. JWKObserver fetches and labels them as "https://accounts.google.com"
    // 3. Consensus is reached on these mislabeled JWKs
    // 4. On-chain state now has evil JWKs under Google's issuer
    // 5. Attacker creates JWT with evil key:
    //    Header: {"alg": "RS256", "kid": "evil-key-1"}
    //    Payload: {"iss": "https://accounts.google.com", "sub": "victim@gmail.com"}
    //    Signature: <signed with attacker's evil private key>
    // 6. AptosVM validates JWT against on-chain JWKs for Google
    // 7. Validation succeeds because evil JWK is stored under Google's issuer
    // 8. Attacker gains access to victim's keyless account
}
```

## Notes

This vulnerability is particularly insidious because:
1. It affects the entire network simultaneously if all validators fetch from the same compromised source
2. The consensus mechanism correctly aggregates signatures, making detection difficult
3. The malicious data appears legitimate to the consensus layer
4. Standard cryptographic verification (multi-signatures) all pass correctly
5. The issue is a missing semantic validation, not a cryptographic failure

The fix must be implemented at the fetching layer (`jwk-utils`) to prevent malicious data from entering the consensus pipeline in the first place.

### Citations

**File:** crates/jwk-utils/src/lib.rs (L40-44)
```rust
pub async fn fetch_jwks_uri_from_openid_config(config_url: &str) -> Result<String> {
    let client = reqwest::Client::new();
    let OpenIDConfiguration { jwks_uri, .. } = client.get(config_url).send().await?.json().await?;
    Ok(jwks_uri)
}
```

**File:** crates/aptos-jwk-consensus/src/jwk_observer.rs (L70-84)
```rust
        loop {
            tokio::select! {
                _ = interval.tick().fuse() => {
                    let timer = Instant::now();
                    let result = fetch_jwks(open_id_config_url.as_str(), my_addr).await;
                    debug!(issuer = issuer, "observe_result={:?}", result);
                    let secs = timer.elapsed().as_secs_f64();
                    if let Ok(mut jwks) = result {
                        OBSERVATION_SECONDS.with_label_values(&[issuer.as_str(), "ok"]).observe(secs);
                        jwks.sort();
                        let _ = observation_tx.push((), (issuer.as_bytes().to_vec(), jwks));
                    } else {
                        OBSERVATION_SECONDS.with_label_values(&[issuer.as_str(), "err"]).observe(secs);
                    }
                },
```

**File:** crates/aptos-jwk-consensus/src/mode/per_key.rs (L32-40)
```rust
    fn new_rb_request(
        epoch: u64,
        payload: &ProviderJWKs,
    ) -> anyhow::Result<ObservedKeyLevelUpdateRequest> {
        let KeyLevelUpdate { issuer, kid, .. } =
            KeyLevelUpdate::try_from_issuer_level_repr(payload)
                .context("new_rb_request failed with repr translation")?;
        Ok(ObservedKeyLevelUpdateRequest { epoch, issuer, kid })
    }
```

**File:** types/src/jwks/mod.rs (L360-384)
```rust
    pub fn try_from_issuer_level_repr(repr: &ProviderJWKs) -> anyhow::Result<Self> {
        ensure!(
            repr.jwks.len() == 1,
            "wrapped repr of a key-level update should have exactly 1 jwk"
        );
        let jwk =
            JWK::try_from(&repr.jwks[0]).context("try_from_issuer_level_repr failed on JWK")?;
        let base_version = repr
            .version
            .checked_sub(1)
            .context("try_from_issuer_level_repr on version")?;
        Ok(Self {
            issuer: repr.issuer.clone(),
            base_version,
            kid: jwk.id(),
            to_upsert: match jwk {
                JWK::Unsupported(unsupported)
                    if unsupported.payload.as_slice() == DELETE_COMMAND_INDICATOR.as_bytes() =>
                {
                    None
                },
                _ => Some(jwk),
            },
        })
    }
```
