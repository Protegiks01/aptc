# Audit Report

## Title
Validator Consensus Private Keys Stored in Plaintext via OnDiskStorage Backend - No Encryption Protection

## Summary
The Aptos consensus layer allows validators to use `OnDiskStorage` as a secure storage backend for consensus private keys. This backend stores BLS12-381 private keys in plaintext JSON format without encryption, violating the "Cryptographic Correctness" invariant. While explicitly documented as unsuitable for production, the configuration sanitizer permits OnDiskStorage for mainnet validators, creating a critical architectural vulnerability where filesystem access leads to complete validator key compromise.

## Finding Description
The consensus safety rules system requires persistent storage of validator consensus private keys. The codebase provides multiple backend implementations through the `SecureBackend` enum, including `OnDiskStorage`, `VaultStorage`, and `InMemoryStorage`. [1](#0-0) 

The `OnDiskStorage` implementation stores all key-value data in a single JSON file with no encryption. When a validator's consensus private key is initialized, it is stored via: [2](#0-1) 

The BLS12-381 private key is serialized using the `SerializeKey` derive macro, which for JSON serialization (used by `OnDiskStorage`) converts the raw 32-byte private key to hex format: [3](#0-2) [4](#0-3) 

The critical vulnerability exists in the configuration layer: while the `SafetyRulesConfig` sanitizer prevents `InMemoryStorage` on mainnet validators, it **permits OnDiskStorage**: [5](#0-4) 

Production configurations (e.g., Docker Compose) explicitly use OnDiskStorage with a plaintext JSON file: [6](#0-5) 

With default configuration, the file resides at `/opt/aptos/data/secure-data.json` alongside the consensus database. The README acknowledges this lacks security: [7](#0-6) 

**Attack Scenario:**
1. Validator configures OnDiskStorage backend (permitted by sanitizer)
2. Consensus private key stored at `/opt/aptos/data/secure-data.json` in hex format: `{"CONSENSUS_KEY":{"value":"0x<64_hex_chars>","last_update":...}}`
3. Attacker gains filesystem read access through any means (container escape, supply chain attack, misconfigured permissions, insider threat, etc.)
4. Attacker reads JSON file and extracts hex-encoded private key
5. Attacker uses private key to sign consensus votes, creating equivocation and breaking consensus safety

This breaks the **Cryptographic Correctness** invariant: validator private keys must be protected, not stored in plaintext.

## Impact Explanation
This qualifies as **Critical Severity** under Aptos Bug Bounty criteria:

**Consensus/Safety Violations**: With the validator's consensus private key, an attacker can:
- Sign conflicting votes (equivocation) to break BFT safety assumptions
- Participate in consensus as the compromised validator
- Cause network splits if multiple validators are compromised this way
- Trigger slashing conditions for the legitimate validator

**Remote Code Execution on validator node**: While not direct RCE, key compromise enables consensus-level attacks equivalent to node compromise.

The vulnerability affects all validators using OnDiskStorage, which includes Docker Compose deployments and potentially custom configurations that follow the documented examples.

## Likelihood Explanation
**High Likelihood** due to:

1. **Configuration Precedent**: Docker Compose example explicitly uses OnDiskStorage, setting a dangerous pattern for operators
2. **Sanitizer Gap**: Configuration validation permits OnDiskStorage for mainnet, contradicting code documentation
3. **Filesystem Access Vectors**: Multiple paths to filesystem access exist:
   - Container vulnerabilities (e.g., Docker escape)
   - Supply chain attacks (compromised images/dependencies)
   - Backup systems with insufficient access controls
   - Log aggregation systems reading `/opt/aptos/data`
   - Debugging tools (like `db_tool.rs`) running with read access
   - Insider threats (malicious operators/administrators)

4. **Defense-in-Depth Failure**: Even if filesystem access is obtained through another vulnerability, private keys should remain protected (encrypted at rest). This violation makes any filesystem compromise catastrophic.

## Recommendation

**Immediate Fix**: Update the configuration sanitizer to enforce Vault storage for mainnet validators:

```rust
// In config/src/config/safety_rules_config.rs
impl ConfigSanitizer for SafetyRulesConfig {
    fn sanitize(
        node_config: &NodeConfig,
        node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();
        let safety_rules_config = &node_config.consensus.safety_rules;

        if !node_type.is_validator() {
            return Ok(());
        }

        if let Some(chain_id) = chain_id {
            if chain_id.is_mainnet() && node_type.is_validator() {
                // NEW CHECK: Enforce Vault for mainnet validators
                match &safety_rules_config.backend {
                    SecureBackend::InMemoryStorage => {
                        return Err(Error::ConfigSanitizerFailed(
                            sanitizer_name,
                            "In-memory storage prohibited on mainnet".to_string(),
                        ));
                    },
                    SecureBackend::OnDiskStorage(_) => {
                        return Err(Error::ConfigSanitizerFailed(
                            sanitizer_name,
                            "OnDiskStorage stores keys without encryption - use Vault for mainnet".to_string(),
                        ));
                    },
                    SecureBackend::Vault(_) => {}, // OK
                }
            }
            // ... rest of validation
        }
        Ok(())
    }
}
```

**Long-term Fix**: Implement encryption for OnDiskStorage or deprecate it entirely for production use.

## Proof of Concept

```rust
// PoC: Extract consensus private key from OnDiskStorage
use std::fs;
use serde_json::Value;

fn extract_consensus_key(data_dir: &str) -> Result<String, Box<dyn std::error::Error>> {
    let secure_data_path = format!("{}/secure-data.json", data_dir);
    
    // Step 1: Read the plaintext JSON file (no encryption barrier)
    let contents = fs::read_to_string(secure_data_path)?;
    
    // Step 2: Parse JSON
    let data: Value = serde_json::from_str(&contents)?;
    
    // Step 3: Extract the consensus key (stored in plaintext hex)
    let consensus_key = data["CONSENSUS_KEY"]["value"]
        .as_str()
        .ok_or("Key not found")?
        .to_string();
    
    println!("Extracted consensus private key: {}", consensus_key);
    
    // Step 4: Attacker can now use this key to sign consensus messages
    // Breaking the "Cryptographic Correctness" invariant
    Ok(consensus_key)
}

// Demonstration:
// 1. Run validator with OnDiskStorage config
// 2. Execute: extract_consensus_key("/opt/aptos/data")
// 3. Result: 0x<32-byte hex private key> extracted in plaintext
// 4. Validator is now fully compromised
```

**Notes**

The core issue is an architectural defense-in-depth failure: while the `db_tool.rs` itself doesn't directly read private keys from ConsensusDB/QuorumStoreDB (those only contain signatures), the configuration system permits storing consensus private keys in plaintext JSON files in the same directory structure. The README documentation warns against production use of OnDiskStorage, but the configuration sanitizer fails to enforce this critical security requirement for mainnet validators. This creates a situation where following documented configuration examples (like the Docker Compose setup) results in validators storing their most sensitive cryptographic material without encryption.

### Citations

**File:** secure/storage/src/on_disk.rs (L16-22)
```rust
/// OnDiskStorage represents a key value store that is persisted to the local filesystem and is
/// intended for single threads (or must be wrapped by a Arc<RwLock<>>). This provides no permission
/// checks and simply offers a proof of concept to unblock building of applications without more
/// complex data stores. Internally, it reads and writes all data to a file, which means that it
/// must make copies of all key material which violates the code base. It violates it because
/// the anticipation is that data stores would securely handle key material. This should not be used
/// in production.
```

**File:** consensus/safety-rules/src/persistent_safety_storage.rs (L63-68)
```rust
    fn initialize_keys_and_accounts(
        internal_store: &mut Storage,
        author: Author,
        consensus_private_key: bls12381::PrivateKey,
    ) -> Result<(), Error> {
        let result = internal_store.set(CONSENSUS_KEY, consensus_private_key);
```

**File:** crates/aptos-crypto-derive/src/lib.rs (L191-200)
```rust
        impl ::serde::Serialize for #name {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: ::serde::Serializer,
            {
                if serializer.is_human_readable() {
                    self.to_encoded_string()
                        .map_err(<S::Error as ::serde::ser::Error>::custom)
                        .and_then(|str| serializer.serialize_str(&str[..]))
                } else {
```

**File:** crates/aptos-crypto/src/traits/mod.rs (L102-104)
```rust
    fn to_encoded_string(&self) -> Result<String> {
        Ok(format!("0x{}", ::hex::encode(self.to_bytes())))
    }
```

**File:** config/src/config/safety_rules_config.rs (L85-96)
```rust
        if let Some(chain_id) = chain_id {
            // Verify that the secure backend is appropriate for mainnet validators
            if chain_id.is_mainnet()
                && node_type.is_validator()
                && safety_rules_config.backend.is_in_memory()
            {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "The secure backend should not be set to in memory storage in mainnet!"
                        .to_string(),
                ));
            }
```

**File:** docker/compose/aptos-node/validator.yaml (L11-14)
```yaml
    backend:
      type: "on_disk_storage"
      path: secure-data.json
      namespace: ~
```

**File:** secure/storage/README.md (L37-42)
```markdown
- `OnDisk`: Similar to InMemory, the OnDisk secure storage implementation provides another
useful testing implementation: an on-disk storage engine, where the storage backend is
implemented using a single file written to local disk. In a similar fashion to the in-memory
storage, on-disk should not be used in production environments as it provides no security
guarantees (e.g., encryption before writing to disk). Moreover, OnDisk storage does not
currently support concurrent data accesses.
```
