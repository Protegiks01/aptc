# Audit Report

## Title
Unbounded Memory Exhaustion via Byzantine RequestSecretShare Flood Attack

## Summary
Byzantine validators can exploit an unbounded channel in the secret sharing subsystem to cause memory exhaustion and validator node crashes through coordinated message flooding. The vulnerability stems from a protocol design flaw where verified messages accumulate without backpressure in an internal unbounded channel.

## Finding Description

The secret sharing subsystem contains a critical design flaw in its message processing pipeline that allows Byzantine validators to cause resource exhaustion on honest validators.

**1. Minimal Message Validation**

`RequestSecretShare` messages only undergo epoch validation, with no rate limiting or round-based checks: [1](#0-0) 

The verification for `RequestShare` variant immediately returns `Ok(())` after checking the epoch matches, providing no protection against flooding with requests for many different rounds.

**2. Unbounded Internal Channel**

The verification task creates an unbounded channel to queue all verified messages: [2](#0-1) 

This channel has no capacity limit and no backpressure mechanism.

**3. Message Processing Pipeline Architecture**

Messages flow through multiple rate-limiting stages, but the unbounded channel undermines these protections:

- **KLAST Queue**: Incoming messages are limited to 10 per sender using KLAST-style channels: [3](#0-2) [4](#0-3) 

- **Bounded Executor**: Verification spawns a bounded number of concurrent tasks (default 16): [5](#0-4) [6](#0-5) 

However, the `BoundedExecutor` implementation only limits concurrent task spawning, not message accumulation: [7](#0-6) 

Once a task acquires a permit and begins executing, it immediately sends the verified message to the unbounded channel at line 221, then releases the permit. This allows rapid accumulation in the unbounded channel while the main loop processes messages sequentially.

**4. Lock Contention Amplifies Impact**

Each message processed by the main loop requires acquiring a lock on `secret_share_store`: [8](#0-7) [9](#0-8) 

This lock contention slows message processing, exacerbating the accumulation in the unbounded channel.

**Attack Execution:**

1. Byzantine validators (up to 1/3 of validator set) coordinate to flood `RequestSecretShare` messages for many different rounds
2. Messages pass through network RPC limits (100 concurrent) and KLAST queues (10 per sender)
3. Bounded executor processes 16 messages concurrently, quickly verifying them (epoch-only check)
4. Verified messages accumulate in the unbounded `verified_msg_tx` channel
5. Main loop processes messages one at a time with lock contention on `secret_share_store`
6. If message arrival rate exceeds processing rate, the unbounded channel grows indefinitely
7. Memory exhaustion leads to OOM kills and validator crashes

**Invariant Violation:**

This breaks the resource limits invariant that all operations must respect computational and memory constraints. The unbounded channel allows unlimited memory growth without any resource bounds.

## Impact Explanation

**Severity: High** (per Aptos Bug Bounty criteria)

This vulnerability enables "Validator node slowdowns" through "DoS via resource exhaustion," which is explicitly categorized as **High Severity** in the Aptos bug bounty program.

**Concrete Impact:**
- **Memory Exhaustion**: The unbounded channel can grow to gigabytes, eventually triggering OOM kills
- **Validator Node Crashes**: OOM conditions force validator termination, removing honest validators from consensus
- **Consensus Degradation**: Multiple simultaneous crashes reduce the effective honest validator set
- **Lock Contention**: High message volume causes severe performance degradation in all secret sharing operations

**Affected Systems:**
- All validator nodes with secret sharing enabled (standard configuration)
- Impacts network liveness if enough honest validators crash simultaneously

## Likelihood Explanation

**Likelihood: High**

The attack is highly practical and requires minimal sophistication:

**Attacker Requirements:**
- Control of Byzantine validators (realistic up to 1/3 per BFT assumptions)
- Standard RPC capabilities (all validators possess this)
- Knowledge of current epoch number (publicly observable)

**Attack Complexity: Low**
- No cryptographic operations or complex protocol manipulation required
- Simple message flooding with varying round numbers
- Validation trivially passes (epoch check only)
- Default configuration enables the attack (10 message KLAST queue, 16 concurrent tasks, unbounded internal channel)

**Detection Difficulty:**
- Messages appear legitimate (valid epoch, authorized sender)
- No anomaly until memory exhaustion manifests
- Gradual degradation makes real-time attribution difficult

## Recommendation

Implement multiple layers of protection:

1. **Replace unbounded channel with bounded channel**: Limit the `verified_msg_tx` channel capacity and apply backpressure
2. **Add per-round rate limiting**: Track and limit requests per round to prevent flooding for many different rounds
3. **Implement adaptive backpressure**: When the verified message queue grows beyond threshold, reject new verification tasks
4. **Add round window validation**: Only accept `RequestSecretShare` for rounds within a limited window of the current highest known round

**Example fix** for the unbounded channel:
```rust
// Replace line 333 with bounded channel
let (verified_msg_tx, mut verified_msg_rx) = mpsc::channel(100); // bounded capacity
```

## Proof of Concept

A Byzantine validator can trigger this vulnerability by:

```rust
// Pseudocode for attack
for round in current_round..(current_round + 10000) {
    let metadata = SecretShareMetadata {
        epoch: current_epoch,
        round: round,
        // ... other fields
    };
    let request = RequestSecretShare::new(metadata);
    network.send_rpc(honest_validator, request);
}
```

This floods honest validators with 10,000 `RequestSecretShare` messages for future rounds. Each message:
1. Passes epoch validation
2. Gets verified and queued in the unbounded channel
3. Accumulates while the main loop processes them slowly with lock contention
4. Eventually exhausts available memory

The attack succeeds because the unbounded channel has no capacity limit and the KLAST queue continuously accepts new messages while dropping old ones, maintaining a constant inflow that exceeds the processing rate.

## Notes

This vulnerability represents a **protocol-level resource exhaustion bug**, distinct from network-layer DoS attacks. The flaw is in the internal message processing architecture (unbounded channel after bounded executor), which allows verified messages to accumulate without limit. While the attack vector involves message flooding, it exploits a specific design flaw in the consensus secret sharing implementation rather than overwhelming network infrastructure.

### Citations

**File:** consensus/src/rand/secret_sharing/network_messages.rs (L28-38)
```rust
    pub fn verify(
        &self,
        epoch_state: &EpochState,
        config: &SecretShareConfig,
    ) -> anyhow::Result<()> {
        ensure!(self.epoch() == epoch_state.epoch);
        match self {
            SecretShareMessage::RequestShare(_) => Ok(()),
            SecretShareMessage::Share(share) => share.verify(config),
        }
    }
```

**File:** consensus/src/rand/secret_sharing/secret_share_manager.rs (L216-233)
```rust
            bounded_executor
                .spawn(async move {
                    match bcs::from_bytes::<SecretShareMessage>(dec_msg.req.data()) {
                        Ok(msg) => {
                            if msg.verify(&epoch_state_clone, &config_clone).is_ok() {
                                let _ = tx.unbounded_send(SecretShareRpc {
                                    msg,
                                    protocol: dec_msg.protocol,
                                    response_sender: dec_msg.response_sender,
                                });
                            }
                        },
                        Err(e) => {
                            warn!("Invalid dec message: {}", e);
                        },
                    }
                })
                .await;
```

**File:** consensus/src/rand/secret_sharing/secret_share_manager.rs (L286-290)
```rust
            SecretShareMessage::RequestShare(request) => {
                let result = self
                    .secret_share_store
                    .lock()
                    .get_self_share(request.metadata());
```

**File:** consensus/src/rand/secret_sharing/secret_share_manager.rs (L317-319)
```rust
                if let Err(e) = self.secret_share_store.lock().add_share(share) {
                    warn!("[SecretShareManager] Failed to add share: {}", e);
                }
```

**File:** consensus/src/rand/secret_sharing/secret_share_manager.rs (L333-333)
```rust
        let (verified_msg_tx, mut verified_msg_rx) = unbounded();
```

**File:** config/src/config/consensus_config.rs (L242-242)
```rust
            internal_per_key_channel_size: 10,
```

**File:** config/src/config/consensus_config.rs (L379-379)
```rust
            num_bounded_executor_tasks: 16,
```

**File:** consensus/src/epoch_manager.rs (L1285-1290)
```rust
        let (secret_share_manager_tx, secret_share_manager_rx) =
            aptos_channel::new::<AccountAddress, IncomingSecretShareRequest>(
                QueueStyle::KLAST,
                self.config.internal_per_key_channel_size,
                None,
            );
```

**File:** crates/bounded-executor/src/executor.rs (L41-52)
```rust
    /// Spawn a [`Future`] on the `BoundedExecutor`. This function is async and
    /// will block if the executor is at capacity until one of the other spawned
    /// futures completes. This function returns a [`JoinHandle`] that the caller
    /// can `.await` on for the results of the [`Future`].
    pub async fn spawn<F>(&self, future: F) -> JoinHandle<F::Output>
    where
        F: Future + Send + 'static,
        F::Output: Send + 'static,
    {
        let permit = self.acquire_permit().await;
        self.executor.spawn(future_with_permit(future, permit))
    }
```
