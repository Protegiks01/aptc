# Audit Report

## Title
Cross-Shard State Value Equivocation Enabling Intra-Validator Execution Divergence

## Summary
The `RemoteStateValue::set_value()` function lacks idempotency protection, allowing it to be called multiple times with different values. A Byzantine shard in distributed sharded execution can exploit this by sending multiple cross-shard messages with conflicting state values for the same key. Different execution threads within the same honest validator will observe different values based on timing, causing non-deterministic execution and violating the Deterministic Execution invariant.

## Finding Description

The sharded block executor uses `RemoteStateValue` to synchronize cross-shard state dependencies. When a transaction in Shard A writes to state key K, it sends the new value to dependent Shard B via a `CrossShardMsg`. The receiving shard's `CrossShardCommitReceiver` calls `set_value()` to unblock waiting execution threads. [1](#0-0) 

The `set_value()` function unconditionally overwrites the stored value without checking if it has already been set. There is no protection against multiple invocations. [2](#0-1) 

The `CrossShardCommitReceiver` processes all incoming messages in a loop without deduplication or validation. [3](#0-2) 

In distributed execution via `RemoteCrossShardClient`, messages arrive from the network without content validation. [4](#0-3) 

**Attack Scenario:**

1. Validator V executes a block with sharded execution across multiple machines/processes
2. Byzantine Shard A (controlled by malicious validator) sends to honest Shard B:
   - `RemoteTxnWriteMsg(StateKey="account::balance", Value=100)`
   - `RemoteTxnWriteMsg(StateKey="account::balance", Value=200)`
3. Shard B's `CrossShardCommitReceiver` processes both messages sequentially
4. First message: `set_value()` sets `RemoteStateValue` to `Ready(100)`
5. Execution Thread T1 calls `get_value()`, receives 100, begins executing transaction TX1
6. Second message arrives: `set_value()` **overwrites** to `Ready(200)`
7. Execution Thread T2 calls `get_value()` (either starting a new transaction or restarting due to conflict), receives 200
8. TX1 and TX2 execute with **different values** for the same cross-shard state key [5](#0-4) 

Multiple execution threads share the same `CrossShardStateView` instance. The race condition allows different threads to observe different values for identical state keys, violating deterministic execution.

## Impact Explanation

**Critical Severity** - This vulnerability breaks the **Deterministic Execution** invariant: "All validators must produce identical state roots for identical blocks."

Within a single honest validator:
- Different execution threads observe different cross-shard state values
- Transactions execute non-deterministically based on timing
- The validator may produce an internally inconsistent state
- Different transaction outputs for the same inputs violate execution determinism
- If threads complete execution in different orders, the final state root becomes unpredictable

This constitutes a **Consensus/Safety violation** (Critical per bug bounty rules). A Byzantine shard can cause honest validators to:
- Produce incorrect state roots
- Fail consensus on blocks
- Generate divergent execution results that break network consistency

The attack requires only a single Byzantine shard in distributed execution and affects all dependent honest shards.

## Likelihood Explanation

**Medium-High Likelihood:**

**Requirements:**
- Sharded block execution must be enabled (currently in deployment)
- At least one Byzantine validator in the validator set controlling a shard (realistic under BFT assumptions of <1/3 Byzantine tolerance)
- Distributed execution mode using `RemoteCrossShardClient` (production configuration)

**Attack Complexity:** Low
- Byzantine shard simply sends duplicate messages with different values
- No signature forgery or cryptographic breaks required
- Network layer doesn't validate message content semantics
- Exploit is deterministic once messages are sent

**Detection:** Difficult
- Manifests as intermittent execution inconsistencies
- Timing-dependent, may not reproduce consistently
- Could be mistaken for implementation bugs or network issues

## Recommendation

**Primary Fix:** Add idempotency check to prevent multiple `set_value()` calls:

```rust
pub fn set_value(&self, value: Option<StateValue>) {
    let (lock, cvar) = &*self.value_condition;
    let mut status = lock.lock().unwrap();
    
    // Verify this is the first and only set_value() call
    if !matches!(*status, RemoteValueStatus::Waiting) {
        panic!(
            "RemoteStateValue::set_value() called multiple times. \
             This indicates a Byzantine shard equivocation attack or implementation bug."
        );
    }
    
    *status = RemoteValueStatus::Ready(value);
    cvar.notify_all();
}
```

**Additional Defenses:**
1. Add message authentication/signatures to cross-shard messages
2. Implement sender-based deduplication in `CrossShardCommitReceiver`
3. Add metrics/logging for multiple `set_value()` attempts to detect attacks
4. Consider cryptographic commitments to cross-shard values in consensus

**Alternative:** Make `RemoteValueStatus` track the setter identity and reject conflicting sets from different sources.

## Proof of Concept

```rust
#[cfg(test)]
mod test_equivocation_attack {
    use super::*;
    use std::thread;
    use std::time::Duration;
    use aptos_types::state_store::state_value::StateValue;

    #[test]
    #[should_panic(expected = "different values")]
    fn test_remote_state_value_equivocation() {
        let remote_value = Arc::new(RemoteStateValue::waiting());
        let remote_value_clone1 = remote_value.clone();
        let remote_value_clone2 = remote_value.clone();
        
        let mut observed_values = Arc::new(Mutex::new(Vec::new()));
        let observed_clone1 = observed_values.clone();
        let observed_clone2 = observed_values.clone();
        
        // Thread 1: Reads the value (simulates execution thread)
        let t1 = thread::spawn(move || {
            let value = remote_value_clone1.get_value();
            observed_clone1.lock().unwrap().push(value);
        });
        
        // Simulates Byzantine shard sending first value
        thread::sleep(Duration::from_millis(10));
        remote_value.set_value(Some(StateValue::from(vec![1, 0, 0])));
        
        // Wait for thread 1 to read
        thread::sleep(Duration::from_millis(10));
        
        // ATTACK: Byzantine shard sends different value for same key
        remote_value.set_value(Some(StateValue::from(vec![2, 0, 0])));
        
        // Thread 2: Reads the value later (simulates another execution thread)
        let t2 = thread::spawn(move || {
            let value = remote_value_clone2.get_value();
            observed_clone2.lock().unwrap().push(value);
        });
        
        t1.join().unwrap();
        t2.join().unwrap();
        
        let values = observed_values.lock().unwrap();
        assert_eq!(values.len(), 2);
        
        // VULNERABILITY: Different threads observed different values!
        if values[0] != values[1] {
            panic!(
                "Equivocation detected: Thread 1 saw {:?}, Thread 2 saw {:?}",
                values[0], values[1]
            );
        }
    }
}
```

## Notes

- The vulnerability exists in both `RemoteStateValue` usages: cross-shard communication (`CrossShardStateView`) and coordinator-to-shard communication (`RemoteStateView`)
- The attack is only feasible in distributed execution where shards run on separate machines and a Byzantine validator controls at least one shard
- Local single-process execution using `LocalCrossShardClient` is not vulnerable unless there's a bug in the sending logic
- The recommended fix (panic on duplicate set) provides fail-safe behavior that halts execution rather than silently accepting equivocation
- Production deployment should include monitoring for panic occurrences to detect attempted attacks

### Citations

**File:** aptos-move/aptos-vm/src/sharded_block_executor/remote_state_value.rs (L22-27)
```rust
    pub fn set_value(&self, value: Option<StateValue>) {
        let (lock, cvar) = &*self.value_condition;
        let mut status = lock.lock().unwrap();
        *status = RemoteValueStatus::Ready(value);
        cvar.notify_all();
    }
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/cross_shard_client.rs (L31-45)
```rust
        loop {
            let msg = cross_shard_client.receive_cross_shard_msg(round);
            match msg {
                RemoteTxnWriteMsg(txn_commit_msg) => {
                    let (state_key, write_op) = txn_commit_msg.take();
                    cross_shard_state_view
                        .set_value(&state_key, write_op.and_then(|w| w.as_state_value()));
                },
                CrossShardMsg::StopMsg => {
                    trace!("Cross shard commit receiver stopped for round {}", round);
                    break;
                },
            }
        }
    }
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/cross_shard_state_view.rs (L49-56)
```rust
    pub fn set_value(&self, state_key: &StateKey, state_value: Option<StateValue>) {
        self.cross_shard_data
            .get(state_key)
            .unwrap()
            .set_value(state_value);
        // uncomment the following line to debug waiting count
        // trace!("waiting count for shard id {} is {}", self.shard_id, self.waiting_count());
    }
```

**File:** execution/executor-service/src/remote_cross_shard_client.rs (L61-66)
```rust
    fn receive_cross_shard_msg(&self, current_round: RoundId) -> CrossShardMsg {
        let rx = self.message_rxs[current_round].lock().unwrap();
        let message = rx.recv().unwrap();
        let msg: CrossShardMsg = bcs::from_bytes(&message.to_bytes()).unwrap();
        msg
    }
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/sharded_executor_service.rs (L115-141)
```rust
        let cross_shard_state_view = Arc::new(CrossShardStateView::create_cross_shard_state_view(
            state_view,
            &transactions,
        ));

        let cross_shard_state_view_clone = cross_shard_state_view.clone();
        let cross_shard_client_clone = cross_shard_client.clone();

        let aggr_overridden_state_view = Arc::new(AggregatorOverriddenStateView::new(
            cross_shard_state_view.as_ref(),
            TOTAL_SUPPLY_AGGR_BASE_VAL,
        ));

        let signature_verified_transactions: Vec<SignatureVerifiedTransaction> = transactions
            .into_iter()
            .map(|txn| txn.into_txn().into_txn())
            .collect();
        let executor_thread_pool_clone = executor_thread_pool.clone();

        executor_thread_pool.clone().scope(|s| {
            s.spawn(move |_| {
                CrossShardCommitReceiver::start(
                    cross_shard_state_view_clone,
                    cross_shard_client,
                    round,
                );
            });
```
