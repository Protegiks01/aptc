# Audit Report

## Title
Cyclic Module Dependencies Bypass in Lazy Loading Mode Violates Move VM Safety Invariants

## Summary
The lazy loading verification path in `StagingModuleStorage::create_with_compat_config()` explicitly skips cyclic dependency checks, allowing modules with circular dependencies to be published on-chain. This violates the fundamental Move VM invariant that "the module dependency graph is acyclic by construction" and undermines security assumptions in the bytecode verifier. [1](#0-0) 

## Finding Description

The Move VM bytecode verifier contains a critical security assumption documented in `RecursiveStructDefChecker`: "Since the module dependency graph is acyclic by construction, applying this checker to each module in isolation guarantees that there is no structural recursion globally." [2](#0-1) 

However, when `enable_lazy_loading` is enabled via the on-chain feature flag, the module publishing verification path explicitly bypasses cyclic dependency detection: [3](#0-2) 

In contrast, the eager loading path performs full transitive dependency verification with cycle detection: [4](#0-3) 

The eager verification calls `unmetered_get_eagerly_verified_module`, which invokes `visit_dependencies_and_verify` that detects cycles by maintaining a visited set: [5](#0-4) 

**Attack Scenario:**

An attacker can publish two modules with mutually recursive struct definitions:

- Module A at address 0x1: `struct S { field: 0x2::B::T }`
- Module B at address 0x2: `struct T { field: 0x1::A::S }`

When lazy loading is enabled:
1. Each module passes `RecursiveStructDefChecker` individually (no recursion within each module)
2. Lazy verification skips module dependency cycle checks
3. Both modules are successfully published to the blockchain
4. The global invariant "module dependency graph is acyclic" is violated

While runtime protection exists via `TypeDepthChecker`, which detects cycles when struct types are instantiated: [6](#0-5) 

This creates a state where **invalid modules that violate fundamental Move VM invariants are permanently stored on-chain**, even though they will fail deterministically when executed.

## Impact Explanation

This qualifies as **High Severity** under the Aptos bug bounty program as a "Significant protocol violation":

1. **Breaks Fundamental Security Invariant**: The Move VM's safety guarantees rely on the acyclic module dependency property. The bytecode verifier explicitly documents this assumption. [2](#0-1) 

2. **Undermines Verification Guarantees**: Allows permanently invalid code on-chain that should never pass verification, degrading the security posture of the blockchain.

3. **Enables Griefing Attacks**: Attackers can publish modules that waste blockchain storage and always fail at runtime, causing unexpected transaction failures for users who attempt to interact with them.

4. **Resource Exhaustion**: Storage space is permanently consumed by invalid modules, and computation resources are wasted when these modules are loaded.

While this does NOT cause consensus splits (all validators use the same on-chain feature flag and agree on outcomes), it represents a significant deviation from Move VM security principles.

## Likelihood Explanation

**Likelihood: High**

The attack is trivially executable when lazy loading is enabled: [7](#0-6) 

According to the production VM configuration, `enable_lazy_loading` is controlled by the `ENABLE_LAZY_LOADING` feature flag (FeatureFlag #95): [8](#0-7) 

The test suite explicitly validates this behavior: [9](#0-8) 

Requirements for exploitation:
- No special privileges required
- Simple module code construction
- Only requires lazy loading feature flag to be enabled
- Attack succeeds deterministically

## Recommendation

Enforce cyclic dependency detection in BOTH eager and lazy loading modes during module publishing. The runtime check should be a safety net, not the primary defense.

**Option 1: Add cycle detection to lazy loading path**

Modify the lazy loading verification at lines 245-275 to perform cycle detection on immediate dependencies before accepting modules. This maintains the performance benefit of lazy loading while preventing invalid modules from being published.

**Option 2: Make cycle detection mandatory**

Move cycle detection before the lazy/eager branch, ensuring it runs regardless of loading mode:

```rust
// Before lines 245, add mandatory cycle check
for (addr, name, bytes, compiled_module) in /* iterate staged modules */ {
    // Check for cycles in immediate dependencies
    let mut visited = HashSet::new();
    visited.insert(ModuleId::new(*addr, name.to_owned()));
    check_no_dependency_cycles(&compiled_module, &staged_module_storage, &mut visited)?;
    
    // Then proceed with lazy or eager verification
    if is_lazy_loading_enabled {
        // ... existing lazy path
    } else {
        // ... existing eager path
    }
}
```

## Proof of Concept

```move
// Module A - published first
module 0x1::A {
    use 0x2::B;
    
    struct S has drop {
        field: B::T
    }
    
    public fun create(): S {
        // Will fail at runtime with RUNTIME_CYCLIC_MODULE_DEPENDENCY
        S { field: B::create_t() }
    }
}

// Module B - published second
module 0x2::B {
    use 0x1::A;
    
    struct T has drop {
        field: A::S
    }
    
    public fun create_t(): T {
        // Will fail at runtime with RUNTIME_CYCLIC_MODULE_DEPENDENCY
        T { field: A::create() }
    }
}
```

**Expected behavior with lazy loading enabled:**
1. Both modules pass verification and are published successfully
2. Any transaction calling `A::create()` or `B::create_t()` fails with `RUNTIME_CYCLIC_MODULE_DEPENDENCY`
3. Invalid modules remain permanently on-chain

**Expected behavior with eager loading enabled:**
1. Module A publishes successfully (depends on B which doesn't exist yet)
2. Module B publishing fails with `CYCLIC_MODULE_DEPENDENCY` during verification
3. Invalid cycle is prevented at publish time

The verification difference demonstrates the bypass, violating the Move VM invariant that the module dependency graph must be acyclic.

## Notes

The lazy loading feature flag is controlled on-chain and changes at epoch boundaries via the reconfiguration mechanism, ensuring all validators have consistent behavior: [10](#0-9) 

Therefore, this vulnerability does NOT cause consensus splits, as all validators process transactions identically. However, it still represents a significant protocol violation by allowing fundamentally invalid code on-chain.

### Citations

**File:** third_party/move/move-vm/runtime/src/storage/publishing.rs (L245-275)
```rust
            if is_lazy_loading_enabled {
                // Local bytecode verification.
                staged_runtime_environment.paranoid_check_module_address_and_name(
                    compiled_module,
                    compiled_module.self_addr(),
                    compiled_module.self_name(),
                )?;
                let locally_verified_code = staged_runtime_environment
                    .build_locally_verified_module(
                        compiled_module.clone(),
                        bytes.len(),
                        &sha3_256(bytes),
                    )?;

                // Linking checks to immediate dependencies. Note that we do not check cyclic
                // dependencies here.
                let mut verified_dependencies = vec![];
                for (dep_addr, dep_name) in locally_verified_code.immediate_dependencies_iter() {
                    // INVARIANT:
                    //   Immediate dependency of the module in a bundle must be metered at the
                    //   caller side.
                    let dependency =
                        staged_module_storage.unmetered_get_existing_lazily_verified_module(
                            &ModuleId::new(*dep_addr, dep_name.to_owned()),
                        )?;
                    verified_dependencies.push(dependency);
                }
                staged_runtime_environment.build_verified_module_with_linking_checks(
                    locally_verified_code,
                    &verified_dependencies,
                )?;
```

**File:** third_party/move/move-vm/runtime/src/storage/publishing.rs (L276-289)
```rust
            } else {
                // Verify the module and its dependencies, and that they do not form a cycle.
                staged_module_storage
                    .unmetered_get_eagerly_verified_module(addr, name)?
                    .ok_or_else(|| {
                        PartialVMError::new(StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR)
                            .with_message(format!(
                                "Staged module {}::{} must always exist",
                                compiled_module.self_addr(),
                                compiled_module.self_name()
                            ))
                            .finish(Location::Undefined)
                    })?;
            }
```

**File:** third_party/move/move-bytecode-verifier/src/struct_defs.rs (L5-7)
```rust
//! This module provides a checker for verifying that struct definitions in a module are not
//! recursive. Since the module dependency graph is acylic by construction, applying this checker to
//! each module in isolation guarantees that there is no structural recursion globally.
```

**File:** third_party/move/move-vm/runtime/src/storage/module_storage.rs (L399-415)
```rust
        if visited.insert(dependency_id.clone()) {
            // Dependency is not verified, and we have not visited it yet.
            let verified_dependency = visit_dependencies_and_verify(
                dependency_id.clone(),
                dependency,
                dependency_version,
                visited,
                module_cache_with_context,
            )?;
            verified_dependencies.push(verified_dependency);
        } else {
            // We must have found a cycle otherwise.
            return Err(module_cyclic_dependency_error!(
                dependency_id.address(),
                dependency_id.name()
            ));
        }
```

**File:** third_party/move/move-vm/runtime/src/storage/ty_depth_checker.rs (L219-229)
```rust
        // If the struct is being visited, we found a recursive definition.
        if currently_visiting.contains(idx) {
            let struct_name = self.get_struct_name(idx)?;
            let msg = format!(
                "Definition of struct {}::{}::{} is recursive: failed to construct its depth formula",
                struct_name.module().address, struct_name.module().name, struct_name.name()
            );
            return Err(
                PartialVMError::new(StatusCode::RUNTIME_CYCLIC_MODULE_DEPENDENCY).with_message(msg),
            );
        }
```

**File:** types/src/on_chain_config/aptos_features.rs (L145-148)
```rust
    /// With lazy loading, modules are loaded lazily (as opposed to loading the transitive closure
    /// of dependencies). For more details, see:
    ///   AIP-127 (https://github.com/aptos-foundation/AIPs/blob/main/aips/aip-127.md)
    ENABLE_LAZY_LOADING = 95,
```

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L255-255)
```rust
        enable_lazy_loading: features.is_lazy_loading_enabled(),
```

**File:** third_party/move/move-vm/integration-tests/src/tests/module_storage_tests.rs (L228-239)
```rust
    if enable_lazy_loading {
        // With lazy loading, cyclic dependencies are allowed to be published (but not called).
        assert_ok!(module_storage.unmetered_get_lazily_verified_module(&c_id));
        module_storage.assert_cached_state(vec![], vec![&c_id]);
    } else {
        let result =
            module_storage.unmetered_get_eagerly_verified_module(c_id.address(), c_id.name());
        assert_eq!(
            assert_err!(result).major_status(),
            StatusCode::CYCLIC_MODULE_DEPENDENCY
        );
    }
```

**File:** aptos-move/framework/aptos-framework/sources/reconfiguration.move (L115-121)
```text
        // Do not do anything if a reconfiguration event is already emitted within this transaction.
        //
        // This is OK because:
        // - The time changes in every non-empty block
        // - A block automatically ends after a transaction that emits a reconfiguration event, which is guaranteed by
        //   VM spec that all transactions comming after a reconfiguration transaction will be returned as Retry
        //   status.
```
