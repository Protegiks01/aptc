# Audit Report

## Title
Database Immutability Violation: Same Digest Batch Overwrites Allow Consensus Metadata Inconsistency

## Summary
The BatchV2Schema implementation allows multiple `PersistedValue<BatchInfoExt>` entries with identical digests but different metadata (expiration, epoch, batch_id) to overwrite each other in persistent storage, violating the expected immutability of persisted batch data and creating potential consensus divergence across validator nodes.

## Finding Description
The quorum store uses a digest (HashValue) as the primary database key in BatchV2Schema. When multiple batches share the same transaction payload (and thus the same digest), but have different metadata fields, the database persistence layer allows later writes to completely overwrite earlier entries. [1](#0-0) 

The vulnerability manifests through the `insert_to_cache()` method, which explicitly allows replacement when a batch with the same digest arrives with a higher expiration time: [2](#0-1) 

When replacement occurs, the cache entry is overwritten: [3](#0-2) 

Subsequently, the database is updated via `save_batch_v2()`, which performs an unconditional overwrite using the same digest key: [4](#0-3) [5](#0-4) 

The `put()` operation performs a standard database write without checking for existing entries or validating metadata consistency: [6](#0-5) 

**Attack Scenario**: A Byzantine validator within the 1/3 fault tolerance threshold can create two batches B1 and B2 with identical transaction payloads (yielding the same digest D) but different expiration times E1 and E2. By broadcasting B1 to some nodes and B2 to others, different validators end up with inconsistent persisted metadata for digest D, potentially causing divergent behavior during batch expiration, garbage collection, and proof validation.

## Impact Explanation
This vulnerability achieves **High Severity** under the Aptos Bug Bounty criteria as it constitutes a "Significant protocol violation" that can cause:

1. **Consensus Metadata Inconsistency**: Different validators maintain different expiration times, epochs, or batch IDs for the same digest, violating Critical Invariant #1 (Deterministic Execution) as nodes may make different decisions based on divergent metadata.

2. **Batch Lifetime Manipulation**: Malicious validators can artificially extend batch expiration times by repeatedly sending higher-expiration versions, keeping batches alive beyond their intended lifetime and potentially affecting network resource management.

3. **Proof Aggregation Failures**: While ProofCoordinator validates exact BatchInfo matches during signature aggregation, nodes with different persisted metadata will reject valid signatures, potentially causing liveness issues. [7](#0-6) 

4. **Payload Data Loss Risk**: When quota is exceeded, replacements may store metadata-only versions (payload = None), potentially losing transaction data: [8](#0-7) 

## Likelihood Explanation
**Medium-High Likelihood**: This vulnerability is exploitable by any Byzantine validator (within the assumed 1/3 fault tolerance). The attack requires:
- Validator privileges to create and sign batches
- Ability to broadcast different batch versions to different nodes
- No collusion with other validators needed

The existing test suite demonstrates this behavior is intentional for "expiration extension": [9](#0-8) 

However, there are no safeguards against malicious exploitation of this mechanism.

## Recommendation
Implement immutability enforcement for persisted batches by preventing overwrites when a digest already exists:

```rust
// In QuorumStoreDB::save_batch_v2
pub fn save_batch_v2(&self, batch: PersistedValue<BatchInfoExt>) -> Result<(), DbError> {
    let digest = batch.digest();
    
    // Check if batch with this digest already exists
    if let Ok(Some(existing)) = self.db.get::<BatchV2Schema>(digest) {
        // Only allow if metadata is identical
        if existing.batch_info() != batch.batch_info() {
            return Err(DbError::from(anyhow::anyhow!(
                "Attempted to overwrite batch {} with different metadata",
                digest
            )));
        }
        // If metadata matches, allow payload update for quota optimization
    }
    
    trace!("QS: db persists digest {} expiration {:?}", digest, batch.expiration());
    self.put::<BatchV2Schema>(digest, &batch)
}
```

Additionally, add validation in `insert_to_cache()` to reject batches with mismatched metadata:

```rust
// In BatchStore::insert_to_cache, after line 370
if let Occupied(entry) = &cache_entry {
    let existing = entry.get();
    // Allow only if all critical metadata matches
    if existing.digest() == &digest && 
       (existing.epoch() != value.epoch() || 
        existing.batch_id() != value.batch_id()) {
        bail!("Cannot replace batch {} with different epoch or batch_id", digest);
    }
    // ... rest of expiration comparison logic
}
```

## Proof of Concept
```rust
// consensus/src/quorum_store/tests/batch_immutability_test.rs
#[tokio::test]
async fn test_batch_metadata_mutation_attack() {
    let batch_store = batch_store_for_test(1000);
    let digest = HashValue::random();
    let payload = Some(vec![]); // Same payload
    
    // Create batch B1 with expiration 100, epoch 1
    let batch1 = PersistedValue::new(
        BatchInfo::new(
            AccountAddress::random(),
            BatchId::new_for_test(1),
            1,  // epoch
            100, // expiration
            digest,
            10, 10, 0
        ).into(),
        payload.clone()
    );
    
    // Create batch B2 with SAME digest but expiration 200, DIFFERENT epoch 2
    let batch2 = PersistedValue::new(
        BatchInfo::new(
            AccountAddress::random(),
            BatchId::new_for_test(1),
            2,  // DIFFERENT epoch
            200, // higher expiration
            digest, // SAME digest
            10, 10, 0
        ).into(),
        payload
    );
    
    // Store B1
    assert!(batch_store.persist(vec![batch1]).len() > 0);
    
    // Verify B1 stored with epoch 1
    let stored1 = batch_store.get_batch_from_local(&digest).unwrap();
    assert_eq!(stored1.epoch(), 1);
    
    // Malicious: Store B2 with same digest but different epoch
    assert!(batch_store.persist(vec![batch2]).len() > 0);
    
    // DATABASE MUTATION: Now digest maps to B2 with epoch 2
    let stored2 = batch_store.get_batch_from_local(&digest).unwrap();
    assert_eq!(stored2.epoch(), 2); // DIFFERENT epoch for same digest!
    
    // This violates immutability: same digest now has different metadata
}
```

## Notes
This vulnerability is particularly concerning because the test suite explicitly validates the replacement behavior without considering malicious scenarios. The feature appears designed for legitimate expiration extension but lacks protection against Byzantine validators exploiting it for consensus manipulation.

### Citations

**File:** consensus/src/quorum_store/schema.rs (L49-56)
```rust
pub(crate) struct BatchV2Schema;

impl Schema for BatchV2Schema {
    type Key = HashValue;
    type Value = PersistedValue<BatchInfoExt>;

    const COLUMN_FAMILY_NAME: aptos_schemadb::ColumnFamilyName = BATCH_V2_CF_NAME;
}
```

**File:** consensus/src/quorum_store/batch_store.rs (L370-382)
```rust
            if let Occupied(entry) = &cache_entry {
                match entry.get().expiration().cmp(&expiration_time) {
                    std::cmp::Ordering::Equal => return Ok(false),
                    std::cmp::Ordering::Greater => {
                        debug!(
                            "QS: already have the digest with higher expiration {}",
                            digest
                        );
                        return Ok(false);
                    },
                    std::cmp::Ordering::Less => {},
                }
            };
```

**File:** consensus/src/quorum_store/batch_store.rs (L383-397)
```rust
            let value_to_be_stored = if self
                .peer_quota
                .entry(author)
                .or_insert(QuotaManager::new(
                    self.db_quota,
                    self.memory_quota,
                    self.batch_quota,
                ))
                .update_quota(value.num_bytes() as usize)?
                == StorageMode::PersistedOnly
            {
                PersistedValue::new(value.batch_info().clone(), None)
            } else {
                value.clone()
            };
```

**File:** consensus/src/quorum_store/batch_store.rs (L399-408)
```rust
            match cache_entry {
                Occupied(entry) => {
                    let (k, prev_value) = entry.replace_entry(value_to_be_stored);
                    debug_assert!(k == digest);
                    self.free_quota(prev_value);
                },
                Vacant(slot) => {
                    slot.insert(value_to_be_stored);
                },
            }
```

**File:** consensus/src/quorum_store/batch_store.rs (L509-513)
```rust
                        #[allow(clippy::unwrap_in_result)]
                        self.db
                            .save_batch_v2(persist_request)
                            .expect("Could not write to DB")
                    }
```

**File:** consensus/src/quorum_store/quorum_store_db.rs (L83-89)
```rust
    pub fn put<S: Schema>(&self, key: &S::Key, value: &S::Value) -> Result<(), DbError> {
        // Not necessary to use a batch, but we'd like a central place to bump counters.
        let mut batch = self.db.new_native_batch();
        batch.put::<S>(key, value)?;
        self.db.write_schemas_relaxed(batch)?;
        Ok(())
    }
```

**File:** consensus/src/quorum_store/quorum_store_db.rs (L140-147)
```rust
    fn save_batch_v2(&self, batch: PersistedValue<BatchInfoExt>) -> Result<(), DbError> {
        trace!(
            "QS: db persists digest {} expiration {:?}",
            batch.digest(),
            batch.expiration()
        );
        self.put::<BatchV2Schema>(batch.digest(), &batch)
    }
```

**File:** consensus/src/quorum_store/proof_coordinator.rs (L150-155)
```rust
        if signed_batch_info.batch_info() != &self.signature_aggregator.data() {
            return Err(SignedBatchInfoError::WrongInfo((
                signed_batch_info.batch_info().batch_id().id,
                self.signature_aggregator.data().batch_id().id,
            )));
        }
```

**File:** consensus/src/quorum_store/tests/batch_store_test.rs (L67-89)
```rust
async fn test_insert_expire() {
    let batch_store = batch_store_for_test(30);

    let digest = HashValue::random();

    assert_ok_eq!(
        batch_store.insert_to_cache(&request_for_test(&digest, 15, 10, None)),
        true
    );
    assert_ok_eq!(
        batch_store.insert_to_cache(&request_for_test(&digest, 30, 10, None)),
        true
    );
    assert_ok_eq!(
        batch_store.insert_to_cache(&request_for_test(&digest, 25, 10, None)),
        false
    );
    let expired = batch_store.clear_expired_payload(27);
    assert!(expired.is_empty());
    let expired = batch_store.clear_expired_payload(29);
    assert!(expired.is_empty());
    assert_eq!(batch_store.clear_expired_payload(30), vec![digest]);
}
```
