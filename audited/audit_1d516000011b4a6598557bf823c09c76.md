# Audit Report

## Title
Unbounded Prometheus Metric Cardinality Explosion via User-Controlled Module/Function Names in Detailed Transaction Counters

## Summary
When `processed_transactions_detailed_counters` is enabled (non-default configuration), attackers can exhaust validator node memory by submitting transactions that call entry functions with unique module/function name combinations. Each unique combination creates a new Prometheus metric label via `inc_with_by()`, leading to unbounded memory growth without garbage collection.

## Finding Description

The vulnerability exists in the transaction metrics collection system when detailed counters are enabled. The attack chain is:

1. **Configuration Precondition**: Node operators must enable `processed_transactions_detailed_counters` in their node configuration (defaults to `false`). [1](#0-0) 

2. **User-Controlled Labels**: When processing transactions with detailed counters enabled, module and function names from entry function calls are used directly as metric labels: [2](#0-1) 

3. **Unbounded Label Creation**: These user-controlled strings flow into `with_label_values()` which creates new metric entries for each unique combination: [3](#0-2) 

4. **No Garbage Collection**: Prometheus metrics in the rust-prometheus library do not have automatic garbage collection. Once a label combination is created via `with_label_values()`, it persists in memory indefinitely.

5. **Known Cardinality Concern**: The codebase monitors for high cardinality (>2000 dimensions) but provides no enforcement: [4](#0-3) 

**Attack Execution:**
- Attacker deploys multiple Move modules with different names OR calls diverse entry functions across existing modules
- Each transaction creates new metric label combinations: `[detailed_counters_label, process_type, module_name, function_name, state]`
- With thousands of module/function combinations possible on Aptos, memory grows unboundedly
- Event creation numbers also contribute to cardinality explosion [5](#0-4) 

This violates **Invariant #9**: "Resource Limits: All operations must respect gas, storage, and computational limits" - memory usage is not properly bounded for metric collection.

## Impact Explanation

**Severity: High** (with significant caveats)

This qualifies as **High Severity** under Aptos bug bounty criteria: "Validator node slowdowns" leading to potential node crashes.

**Impact when exploitable:**
- Memory exhaustion on validator nodes running with detailed counters enabled
- Degraded node performance affecting consensus participation
- Potential node crashes requiring restart
- If multiple validators enable detailed counters, could affect network liveness

**Critical Limitation:**
The vulnerability is **NOT exploitable by default**. It requires node operators to explicitly enable `processed_transactions_detailed_counters`, which:
- Defaults to `false` in production
- Is only enabled in test/benchmark scenarios in the codebase
- Requires explicit configuration change by operators

This significantly reduces the real-world impact compared to a default-exploitable vulnerability.

## Likelihood Explanation

**Likelihood: Low to Medium (conditional)**

**Factors reducing likelihood:**
- Requires non-default configuration (`processed_transactions_detailed_counters = true`)
- Only observed enabled in test environments, not production
- Operators enabling detailed counters likely monitor metric cardinality
- Attack requires sustained transaction submission (costs gas)

**Factors increasing likelihood (if enabled):**
- Attack is straightforward - just submit transactions calling different functions
- No rate limiting on unique label creation
- No cardinality caps enforced
- Existing framework modules provide hundreds of function combinations
- User module deployment adds unlimited possibilities

**Realistic scenario:** An operator enables detailed counters temporarily for debugging/monitoring and forgets to disable it, or runs it in a staging environment with production-level traffic.

## Recommendation

Implement multi-layered protection:

**1. Add Cardinality Limits:**
```rust
// In execution/executor/src/metrics.rs
const MAX_METRIC_LABEL_COMBINATIONS: usize = 10_000;
static LABEL_COMBINATION_COUNT: AtomicUsize = AtomicUsize::new(0);

fn update_counters_for_processed_chunk<T>(
    transactions: &[T],
    transaction_outputs: &[TransactionOutput],
    process_type: &str,
) where T: TransactionProvider {
    let detailed_counters = AptosVM::get_processed_transactions_detailed_counters();
    
    // Check cardinality before creating new labels
    if detailed_counters {
        if LABEL_COMBINATION_COUNT.load(Ordering::Relaxed) > MAX_METRIC_LABEL_COMBINATIONS {
            // Disable detailed counters or use aggregated labels
            detailed_counters = false;
            warn!("Metric cardinality limit exceeded, disabling detailed counters");
        }
    }
    // ... rest of function
}
```

**2. Use Bounded Label Sets:**
Instead of raw module/function names, hash or map them to fixed buckets when detailed counters are enabled.

**3. Add Documentation Warning:**
Document in node configuration that enabling `processed_transactions_detailed_counters` can cause memory exhaustion under high cardinality scenarios.

**4. Implement Metric Rotation:**
Periodically reset metrics or implement a sliding window to prevent unbounded growth.

## Proof of Concept

```rust
// Conceptual PoC - requires node with detailed_counters=true

// Step 1: Deploy multiple modules with different names
// In Move:
module attacker::module_00001 {
    public entry fun exploit() {}
}
module attacker::module_00002 {
    public entry fun exploit() {}
}
// ... repeat for module_00003 through module_10000

// Step 2: Submit transactions calling each unique module
// Each creates new metric labels:
// PROCESSED_USER_TXNS_ENTRY_FUNCTION_BY_MODULE
//   .with_label_values(&["true", "execution", "user", "module_00001", "keep_success"])
//   .inc();

// After 10,000 unique modules × functions × states:
// Memory consumed = 10,000 × (metric_entry_size + label_storage)
// Estimated: ~10-50 MB per 10,000 combinations
// Sustained attack over hours: Gigabytes of metric memory

// Monitoring would show:
// families_over_2000 counter incrementing
// Total memory usage growing without bounds
// Node performance degrading
```

**Validation Steps:**
1. Start validator node with `processed_transactions_detailed_counters = true`
2. Monitor `/metrics` endpoint and memory usage
3. Submit 10,000 transactions calling different entry functions
4. Observe unbounded metric cardinality growth
5. Measure memory consumption and performance degradation

## Notes

This vulnerability represents a **conditional security issue** - the code contains the vulnerability, but exploitation requires non-default configuration. While this reduces real-world risk, it remains a valid finding because:

1. The configuration option exists and may be enabled for legitimate monitoring purposes
2. No warnings exist about the cardinality explosion risk
3. No protective measures (rate limits, cardinality caps) are implemented
4. The codebase demonstrates awareness of cardinality concerns but doesn't address this specific case

Organizations running Aptos nodes should avoid enabling detailed transaction counters in production, or implement the recommended protections before doing so.

### Citations

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L507-513)
```rust
    /// Get whether we should capture additional details in counters
    pub fn get_processed_transactions_detailed_counters() -> bool {
        match PROCESSED_TRANSACTIONS_DETAILED_COUNTERS.get() {
            Some(value) => *value,
            None => false,
        }
    }
```

**File:** execution/executor/src/metrics.rs (L456-485)
```rust
            if let Ok(TransactionExecutableRef::EntryFunction(function)) =
                user_txn.payload().executable_ref()
            {
                let is_core = function.module().address() == &CORE_CODE_ADDRESS;
                PROCESSED_USER_TXNS_ENTRY_FUNCTION_BY_MODULE
                    .with_label_values(&[
                        detailed_counters_label,
                        process_type,
                        if is_core { "core" } else { "user" },
                        if detailed_counters {
                            function.module().name().as_str()
                        } else if is_core {
                            "core_module"
                        } else {
                            "user_module"
                        },
                        state,
                    ])
                    .inc();
                if is_core && detailed_counters {
                    PROCESSED_USER_TXNS_ENTRY_FUNCTION_BY_CORE_METHOD
                        .with_label_values(&[
                            process_type,
                            function.module().name().as_str(),
                            function.function().as_str(),
                            state,
                        ])
                        .inc();
                }
            };
```

**File:** execution/executor/src/metrics.rs (L488-508)
```rust
        for event in output.events() {
            let (is_core, creation_number) = match event {
                ContractEvent::V1(v1) => (
                    v1.key().get_creator_address() == CORE_CODE_ADDRESS,
                    if detailed_counters {
                        v1.key().get_creation_number().to_string()
                    } else {
                        "event".to_string()
                    },
                ),
                ContractEvent::V2(_v2) => (false, "event".to_string()),
            };
            PROCESSED_USER_TXNS_CORE_EVENTS
                .with_label_values(&[
                    detailed_counters_label,
                    process_type,
                    if is_core { "core" } else { "user" },
                    &creation_number,
                ])
                .inc();
        }
```

**File:** crates/aptos-metrics-core/src/thread_local.rs (L84-89)
```rust
    fn inc_with_by(&'static self, labels: &[&str], v: Self::IntType) {
        self.with_borrow_mut(|x| {
            x.inner.with_label_values(labels).inc_by(v);
            x.maybe_flush();
        });
    }
```

**File:** crates/aptos-faucet/metrics-server/src/gather_metrics.rs (L15-44)
```rust
pub fn gather_metrics() -> Vec<prometheus::proto::MetricFamily> {
    let metric_families = aptos_metrics_core::gather();
    let mut total: u64 = 0;
    let mut families_over_2000: u64 = 0;

    // Take metrics of metric gathering so we know possible overhead of this process
    for metric_family in &metric_families {
        let family_count = metric_family.get_metric().len();
        if family_count > 2000 {
            families_over_2000 = families_over_2000.saturating_add(1);
            let name = metric_family.get_name();
            warn!(
                count = family_count,
                metric_family = name,
                "Metric Family '{}' over 2000 dimensions '{}'",
                name,
                family_count
            );
        }
        total = total.saturating_add(family_count as u64);
    }

    // These metrics will be reported on the next pull, rather than create a new family
    NUM_METRICS.with_label_values(&["total"]).inc_by(total);
    NUM_METRICS
        .with_label_values(&["families_over_2000"])
        .inc_by(families_over_2000);

    metric_families
}
```
