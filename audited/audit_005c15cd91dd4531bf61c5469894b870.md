# Audit Report

## Title
JWK Poisoning via Governance Compromise Enables Keyless Account Takeover

## Summary
The keyless authentication system lacks cryptographic binding between on-chain JWKs and legitimate OIDC providers. If governance is compromised to insert malicious JWK patches via `set_patches()`, attackers controlling the corresponding private keys can forge JWT signatures that validate correctly, enabling complete takeover of keyless accounts and theft of funds. [1](#0-0) 

## Finding Description

The vulnerability exists in the keyless signature validation flow where `get_jwks_onchain()` fetches `PatchedJWKs` from on-chain storage without any cryptographic proof that these JWKs originated from legitimate OIDC providers.

**Attack Flow:**

1. **JWK Insertion via Governance**: An attacker who compromises governance calls `set_patches()` to insert a malicious `PatchUpsertJWK` patch containing their own RSA public key: [2](#0-1) 

2. **Patch Application**: The `regenerate_patched_jwks()` function applies patches to create the final `PatchedJWKs` resource, which now contains the attacker's malicious JWK: [3](#0-2) 

3. **Signature Validation Against Malicious JWK**: When a keyless transaction is submitted, the validation retrieves the poisoned JWK and verifies the JWT signature: [4](#0-3) 

4. **RSA Verification with Attacker's Key**: The RSA signature verification uses the malicious JWK's public key components (n, e): [5](#0-4) 

5. **Transaction Acceptance**: Since the attacker signed the JWT with their private key matching the malicious public key, verification succeeds: [6](#0-5) 

**Root Cause**: The system has no mechanism to verify that on-chain JWKs correspond to keys actually published by legitimate OIDC providers (Google, Facebook, etc.). It relies entirely on:
- Honest validators fetching from real OIDC endpoints when creating `ObservedJWKs`
- Honest governance not approving malicious patches

There is no out-of-band verification, no timelock on governance JWK changes, and no cryptographic proof linking on-chain JWKs to OIDC provider signatures.

## Impact Explanation

**Critical Severity** - This meets the highest bug bounty category:

1. **Loss of Funds**: Attackers can create keyless transactions for arbitrary identities, stealing funds from any keyless account
2. **Account Takeover**: Complete control over keyless accounts without compromising the user's Google/Facebook/etc credentials
3. **Bypasses All OIDC Security**: The entire security model of keyless accounts (delegating authentication to trusted OIDC providers) is circumvented

Once a malicious JWK is inserted:
- Attacker generates arbitrary JWTs with any `iss` (issuer), `sub` (subject), `aud` (audience), and `nonce` values
- Signs JWTs with their private key
- Creates keyless transactions that pass all validation checks
- Can impersonate any identity and drain accounts

**Affected Scope**: All keyless accounts on the network become vulnerable simultaneously once PatchedJWKs is poisoned.

## Likelihood Explanation

**Likelihood: Low to Medium** (but impact is Critical)

**Prerequisites for Exploitation:**
1. Governance compromise requiring >50% voting power to approve malicious proposal calling `set_patches()`
2. Attacker must generate their own RSA keypair and create appropriate patches

**Mitigating Factors:**
- Requires governance compromise (high threshold)
- Governance actions are public and transparent
- Community could potentially detect malicious proposals

**Aggravating Factors:**
- Once executed, attack is immediate and irreversible without hard fork
- No technical safeguards beyond governance voting
- Single malicious proposal compromises entire keyless account system
- Silent exploitation possible if attacker submits transactions that appear legitimate

The security question explicitly scopes this to "governance attack" scenarios, indicating this threat model is considered relevant for Aptos security.

## Recommendation

Implement multiple defense layers:

**1. JWK Provenance Verification**: Add cryptographic proof that JWKs came from legitimate OIDC providers:
```
// Add to PatchedJWKs or maintain separate provenance tracking
struct JWKProvenance {
    jwk_hash: vector<u8>,
    oidc_provider_signature: vector<u8>,  // OIDC provider signs the JWK
    validator_attestations: vector<ValidatorAttestation>,  // Validators attest they fetched it
}
```

**2. Governance Timelock for JWK Changes**: Enforce delay between proposal passage and execution:
```move
public fun set_patches(fx: &signer, patches: vector<Patch>) {
    system_addresses::assert_aptos_framework(fx);
    // Add 7-day timelock before patches take effect
    let execution_time = timestamp::now_seconds() + (7 * 24 * 60 * 60);
    pending_patches = PendingPatches { patches, execution_time };
    // Separate function to apply after timelock expires
}
```

**3. Emergency JWK Freeze**: Allow rapid response to suspected poisoning:
```move
public fun emergency_freeze_jwks(fx: &signer) {
    // Requires validator supermajority, freezes JWK updates
    system_addresses::assert_aptos_framework(fx);
    freeze_jwk_updates = true;
}
```

**4. Out-of-Band JWK Verification**: Validators should verify `set_patches` proposals against actual OIDC provider endpoints before voting.

## Proof of Concept

```move
#[test(aptos_framework = @aptos_framework)]
fun test_jwk_poisoning_attack(aptos_framework: &signer) {
    // Initialize JWK system
    jwks::initialize(aptos_framework);
    
    // Attacker generates their own RSA keypair (private key kept secret)
    // Public key components (this is the attacker's key, NOT from Google)
    let malicious_kid = utf8(b"attacker_key_123");
    let malicious_n = utf8(b"xVHh8K9Zt..."); // Attacker's RSA modulus
    let malicious_e = utf8(b"AQAB");
    let malicious_alg = utf8(b"RS256");
    
    // Create malicious JWK
    let malicious_jwk = jwks::new_rsa_jwk(
        malicious_kid,
        malicious_alg, 
        malicious_e,
        malicious_n
    );
    
    // Attacker (via compromised governance) inserts malicious JWK
    let malicious_patch = jwks::new_patch_upsert_jwk(
        b"https://accounts.google.com", // Pretends to be Google
        malicious_jwk
    );
    
    // This call would normally require governance proposal to pass
    jwks::set_patches(aptos_framework, vector[malicious_patch]);
    
    // Now PatchedJWKs contains attacker's key
    let retrieved_jwk = jwks::get_patched_jwk(
        b"https://accounts.google.com",
        b"attacker_key_123"
    );
    
    // Attacker can now:
    // 1. Generate JWT with arbitrary claims (iss, sub, aud, nonce)
    // 2. Sign with their private key
    // 3. Submit keyless transaction
    // 4. Signature verification succeeds against malicious JWK
    // 5. Drain any keyless account
    
    assert!(retrieved_jwk == malicious_jwk, 1);
}
```

**Notes**

This vulnerability demonstrates a critical gap in the keyless authentication security model: the lack of cryptographic binding between on-chain JWKs and legitimate OIDC providers. While validator consensus provides some protection through distributed JWK observation, governance patches can bypass this entirely. The attack requires significant privilege (governance compromise), but the impact is total compromise of the keyless account system, warranting Critical severity classification per the Aptos bug bounty program.

### Citations

**File:** aptos-move/aptos-vm/src/keyless_validation.rs (L91-94)
```rust
fn get_jwks_onchain(resolver: &impl AptosMoveResolver) -> anyhow::Result<PatchedJWKs, VMStatus> {
    PatchedJWKs::fetch_config(resolver)
        .ok_or_else(|| value_deserialization_error!("could not deserialize PatchedJWKs"))
}
```

**File:** aptos-move/aptos-vm/src/keyless_validation.rs (L220-220)
```rust
    let patched_jwks = get_jwks_onchain(resolver)?;
```

**File:** aptos-move/aptos-vm/src/keyless_validation.rs (L391-395)
```rust
                    openid_sig
                        .verify_jwt_signature(rsa_jwk, &signature.jwt_header_json)
                        .map_err(|_| {
                            invalid_signature!("RSA signature verification failed for OpenIdSig")
                        })?;
```

**File:** aptos-move/framework/aptos-framework/sources/jwks.move (L379-383)
```text
    public fun set_patches(fx: &signer, patches: vector<Patch>) acquires Patches, PatchedJWKs, ObservedJWKs {
        system_addresses::assert_aptos_framework(fx);
        borrow_global_mut<Patches>(@aptos_framework).patches = patches;
        regenerate_patched_jwks();
    }
```

**File:** aptos-move/framework/aptos-framework/sources/jwks.move (L523-531)
```text
    fun regenerate_patched_jwks() acquires PatchedJWKs, Patches, ObservedJWKs {
        let jwks = borrow_global<ObservedJWKs>(@aptos_framework).jwks;
        let patches = borrow_global<Patches>(@aptos_framework);
        vector::for_each_ref(&patches.patches, |obj|{
            let patch: &Patch = obj;
            apply_patch(&mut jwks, *patch);
        });
        *borrow_global_mut<PatchedJWKs>(@aptos_framework) = PatchedJWKs { jwks };
    }
```

**File:** types/src/jwks/rsa/mod.rs (L89-95)
```rust
    pub fn verify_signature_without_exp_check(&self, jwt_token: &str) -> Result<TokenData<Claims>> {
        let mut validation = Validation::new(Algorithm::RS256);
        validation.validate_exp = false;
        let key = &DecodingKey::from_rsa_components(&self.n, &self.e)?;
        let claims = jsonwebtoken::decode::<Claims>(jwt_token, key, &validation)?;
        Ok(claims)
    }
```
