# Audit Report

## Title
Timing Side-Channel Vulnerability in DKG Multi-Scalar Multiplication Operations

## Summary
The `msm_eval()` function implementations in the DKG (Distributed Key Generation) module use variable-time multi-scalar multiplication (MSM) algorithms from arkworks and blstrs libraries when processing secret scalars. This creates a timing side-channel that could theoretically leak information about secret shares and randomness values during DKG transcript generation, potentially compromising validator key generation.

## Finding Description

The vulnerability exists in multiple implementations of the `msm_eval()` function within the DKG module. All implementations delegate to underlying cryptographic libraries (arkworks `VariableBaseMSM::msm()` or blstrs `G1Projective::multi_exp()`) that use the Pippenger algorithm for multi-scalar multiplication. This algorithm is optimized for performance rather than constant-time execution. [1](#0-0) 

The trait defines `msm_eval()` as the core operation for evaluating MSM terms. Concrete implementations show the vulnerability: [2](#0-1) [3](#0-2) 

During DKG transcript dealing, secret share values are used directly in MSM operations. In the weighted DAS PVSS protocol: [4](#0-3) 

The critical operations occur at lines 165-169 where `g1_multi_exp()` is called with:
- `f_evals[k]`: Secret share values derived from Shamir secret sharing
- `r[k]`: Randomness values for ElGamal encryption [5](#0-4) 

The `g1_multi_exp()` function delegates to `G1Projective::multi_exp()` from blstrs, which uses variable-time operations.

**Attack Path:**
1. During epoch transitions, validators generate DKG transcripts
2. The `deal()` function computes ElGamal encryptions of secret shares using MSM
3. MSM execution time varies based on scalar bit patterns (Hamming weight, distribution)
4. An attacker with timing measurement capability could observe these variations
5. Statistical analysis across multiple DKG sessions could extract scalar bit information
6. Sufficient information leakage could compromise the secrecy of DKG shares

**Evidence of Security Awareness:**
The codebase includes constant-time verification for scalar multiplication operations: [6](#0-5) [7](#0-6) 

However, no equivalent constant-time verification exists for MSM operations used in DKG, despite these operations processing secret data.

## Impact Explanation

**Theoretical Impact: HIGH**
If successfully exploited, this vulnerability could lead to:
- **Compromise of DKG Secrets**: Leakage of secret share information
- **Validator Key Compromise**: DKG is used to generate validator threshold keys
- **Consensus Security**: Compromised validator keys threaten consensus integrity

This breaks the **Cryptographic Correctness** invariant: "BLS signatures, VRF, and hash operations must be secure."

**Practical Impact: LOW-MEDIUM**
However, the practical exploitability is severely limited:
1. **Timing Measurement Requirements**: Attacker needs precise timing of DKG operations
2. **Noise Levels**: Network timing measurements are extremely noisy
3. **Limited Observations**: DKG runs infrequently (epoch transitions only)
4. **Attack Complexity**: Requires sophisticated statistical analysis
5. **Access Requirements**: Most feasible attacks require co-location with validators

Per Aptos bug bounty criteria, this falls into **High Severity** category ("Significant protocol violations") based on theoretical impact, but with significant practical exploitation barriers.

## Likelihood Explanation

**Likelihood: LOW**

The attack faces multiple practical barriers:

1. **Measurement Difficulty**: DKG operations occur on validators during epoch transitions. An external attacker would need:
   - Network timing measurements (very noisy, ~1-100ms variance)
   - Or co-location on same machine (requires privileged access)
   - Or cache timing attacks (requires local access)

2. **Limited Observations**: DKG transcripts are generated during epoch transitions, which occur infrequently (hours/days apart), limiting the number of observations available for statistical analysis

3. **Signal Extraction Complexity**: Extracting meaningful scalar information from timing variations requires:
   - Thousands of observations
   - Advanced statistical techniques
   - Filtering out environmental noise
   - Compensating for other operations

4. **Attack Prerequisites**: The attacker would need either:
   - Privileged access to validator infrastructure (contradicts trust model)
   - Or extremely sophisticated remote timing analysis capability

The codebase's trust model states: "Focus on bugs exploitable without requiring privileged validator access or collusion." This vulnerability is difficult to exploit without such access.

## Recommendation

**Short-term Mitigation:**
Implement constant-time MSM verification similar to existing scalar multiplication tests:

1. Create `crates/aptos-crypto/src/constant_time/arkworks_msm.rs` and `blstrs_msm.rs`
2. Use dudect statistical framework to verify MSM operations are constant-time
3. Run verification in production validator startup (similar to pepper service)

**Long-term Solution:**
Replace variable-time MSM with constant-time implementations:

1. Investigate arkworks/blstrs constant-time MSM options
2. Consider implementing dedicated constant-time MSM for DKG operations
3. Add compiler-level constant-time verification

**Code Structure Recommendation:**
```rust
// In crates/aptos-crypto/src/constant_time/mod.rs
pub mod arkworks_msm;
pub mod blstrs_msm;

// Add verification function
pub fn verify_constant_time_msm() -> Result<()> {
    // Similar to verify_constant_time_scalar_multiplication
}

// In validator startup
verify_constant_time_msm()
    .expect("MSM operations must be constant-time for DKG security");
```

## Proof of Concept

A complete PoC would require implementing a statistical timing attack framework, which is beyond the scope of this report. However, the vulnerability can be demonstrated conceptually:

```rust
// Conceptual PoC - NOT executable production code
// This demonstrates the timing variation exists

use std::time::Instant;
use blstrs::{G1Projective, Scalar};
use group::Group;

fn measure_msm_timing(scalar: Scalar) -> Duration {
    let base = G1Projective::generator();
    let bases = vec![base; 100];
    let scalars = vec![scalar; 100];
    
    let start = Instant::now();
    let _ = G1Projective::multi_exp(&bases, &scalars);
    start.elapsed()
}

// Test with different Hamming weights
fn demonstrate_timing_variance() {
    // Low Hamming weight scalar (few bits set)
    let scalar_low = /* scalar with 5 bits set */;
    
    // High Hamming weight scalar (many bits set)
    let scalar_high = /* scalar with 200 bits set */;
    
    let time_low = measure_msm_timing(scalar_low);
    let time_high = measure_msm_timing(scalar_high);
    
    // Timing difference exists and is measurable
    println!("Timing variance: {:?}", time_high - time_low);
}
```

The existing constant-time test infrastructure demonstrates the framework that should be extended to MSM: [8](#0-7) 

**Notes:**

1. **Exploitability Constraint**: This vulnerability is primarily theoretical. Practical exploitation requires either privileged access (co-location with validators) or extremely sophisticated remote timing analysis that may not be feasible given network noise and limited observations.

2. **Defense-in-Depth Gap**: While the codebase includes constant-time verification for scalar multiplication, the lack of equivalent verification for MSM operations represents a gap in defense-in-depth, especially given that DKG operations explicitly process secret data.

3. **Industry Best Practice**: Modern cryptographic implementations should use constant-time operations for all secret-dependent computations. The use of variable-time MSM for DKG represents a deviation from this best practice.

4. **Scope Consideration**: The vulnerability falls into a gray area regarding the stated exclusion "Cryptographic primitives (Rust crypto crates, BLS implementations) are assumed secure." While the underlying libraries are secure against direct cryptanalysis, their use in a non-constant-time manner for secret data processing creates an implementation-level vulnerability.

### Citations

**File:** crates/aptos-dkg/src/sigma_protocol/homomorphism/fixed_base_msms.rs (L78-78)
```rust
    fn msm_eval(input: Self::MsmInput) -> Self::MsmOutput;
```

**File:** crates/aptos-dkg/src/pcs/univariate_kzg.rs (L65-67)
```rust
    fn msm_eval(input: Self::MsmInput) -> Self::MsmOutput {
        E::G1::msm(input.bases(), input.scalars()).expect("MSM failed in univariate KZG")
    }
```

**File:** crates/aptos-dkg/src/pvss/chunky/chunked_elgamal.rs (L262-264)
```rust
    fn msm_eval(input: Self::MsmInput) -> Self::MsmOutput {
        C::msm(input.bases(), input.scalars()).expect("MSM failed in ChunkedElgamal")
    }
```

**File:** crates/aptos-dkg/src/pvss/das/weighted_protocol.rs (L114-170)
```rust
    fn deal<A: Serialize + Clone, R: rand_core::RngCore + rand_core::CryptoRng>(
        sc: &Self::SecretSharingConfig,
        pp: &Self::PublicParameters,
        ssk: &Self::SigningSecretKey,
        _spk: &Self::SigningPubKey,
        eks: &[Self::EncryptPubKey],
        s: &Self::InputSecret,
        aux: &A,
        dealer: &Player,
        mut rng: &mut R,
    ) -> Self {
        let n = sc.get_total_num_players();
        assert_eq!(eks.len(), n);

        // f_evals[k] = f(\omega^k), \forall k \in [0, W-1]
        let W = sc.get_total_weight();
        let (f_coeff, f_evals) = shamir_secret_share(sc.get_threshold_config(), s, rng);
        assert_eq!(f_coeff.len(), sc.get_threshold_weight());
        assert_eq!(f_evals.len(), W);

        // Pick ElGamal randomness r_j, \forall j \in [W]
        // r[j] = r_{j+1}, \forall j \in [0, W-1]
        let r = random_scalars(W, &mut rng);
        let g_1 = pp.get_encryption_public_params().pubkey_base();
        let g_2 = pp.get_commitment_base();
        let h = *pp.get_encryption_public_params().message_base();

        // NOTE: Recall s_i is the starting index of player i in the vector of shares
        //  - V[s_i + j - 1] = g_2^{f(s_i + j - 1)}
        //  - V[W] = g_2^{f(0)}
        let V = (0..W)
            .map(|k| g_1.mul(f_evals[k]))
            .chain([g_1.mul(f_coeff[0])])
            .collect::<Vec<G1Projective>>();
        let V_hat = (0..W)
            .map(|k| g_2.mul(f_evals[k]))
            .chain([g_2.mul(f_coeff[0])])
            .collect::<Vec<G2Projective>>();

        // R[j] = g_1^{r_{j + 1}},  \forall j \in [0, W-1]
        let R = (0..W).map(|j| g_1.mul(r[j])).collect::<Vec<G1Projective>>();
        let R_hat = (0..W).map(|j| g_2.mul(r[j])).collect::<Vec<G2Projective>>();

        let mut C = Vec::with_capacity(W);
        for i in 0..n {
            let w_i = sc.get_player_weight(&sc.get_player(i));

            let bases = vec![h, Into::<G1Projective>::into(&eks[i])];
            for j in 0..w_i {
                let k = sc.get_share_index(i, j).unwrap();

                C.push(g1_multi_exp(
                    bases.as_slice(),
                    [f_evals[k], r[k]].as_slice(),
                ))
            }
        }
```

**File:** crates/aptos-dkg/src/utils/mod.rs (L58-71)
```rust
pub fn g1_multi_exp(bases: &[G1Projective], scalars: &[blstrs::Scalar]) -> G1Projective {
    if bases.len() != scalars.len() {
        panic!(
            "blstrs's multiexp has heisenbugs when the # of bases != # of scalars ({} != {})",
            bases.len(),
            scalars.len()
        );
    }

    match bases.len() {
        0 => G1Projective::identity(),
        1 => bases[0].mul(scalars[0]),
        _ => G1Projective::multi_exp(bases, scalars),
    }
```

**File:** crates/aptos-crypto/src/constant_time/mod.rs (L1-10)
```rust
// Copyright (c) Aptos Foundation
// Licensed pursuant to the Innovation-Enabling Source Code License, available at https://github.com/aptos-labs/aptos-core/blob/main/LICENSE

//! This module provides implementations of "dudect" statistical tests to check some of our code
//! is constant-time (e.g., like scalar multiplication).

/// Module for testing that blstrs scalar multiplication is constant-time
pub mod blstrs_scalar_mul;
/// Module for testing that zkcrypto scalar multiplication is constant-time
pub mod zkcrypto_scalar_mul;
```

**File:** crates/aptos-crypto/src/constant_time/blstrs_scalar_mul.rs (L16-26)
```rust
/// Runs a statistical test to check that blst's scalar multiplication on G1 is constant time
/// This function pick random bases for all scalar multiplications.
pub fn run_bench_with_random_bases(runner: &mut CtRunner, rng: &mut BenchRng) {
    build_and_run_bench(runner, rng, true, N);
}

/// Runs a statistical test to check that blst's scalar multiplication on G1 is constant time
/// This function keeps the multiplied base the same: the generator of G1.
pub fn run_bench_with_fixed_bases(runner: &mut CtRunner, rng: &mut BenchRng) {
    build_and_run_bench(runner, rng, false, N);
}
```

**File:** crates/aptos-crypto/src/constant_time/blstrs_scalar_mul.rs (L71-124)
```rust
pub fn build_and_run_bench(
    runner: &mut CtRunner,
    rng: &mut BenchRng,
    random_bases: bool,
    num_iters: usize,
) {
    let mut inputs: Vec<(Class, usize, Scalar, G1Projective)> = Vec::with_capacity(N);

    let min_num_bits_left = 1;
    let max_num_bits_left = 4;
    let num_bits_right = 200; //BIT_SIZE.div_ceil(2) + 1;
    eprintln!();
    eprintln!(
        "# of 1 bits in scalars for \"left\" class is in [{}, {})",
        min_num_bits_left, max_num_bits_left
    );
    eprintln!(
        "# of 1 bits in scalars for \"right\" class is always {}",
        num_bits_right
    );

    for _ in 0..num_iters {
        let base = if random_bases {
            G1Projective::random(&mut *rng)
        } else {
            G1Projective::generator()
        };
        let choice = rng.r#gen::<bool>();

        if choice {
            // WARNING: `blstrs` is faster when the scalar is exactly 0!
            let num_bits_left = rng.gen_range(min_num_bits_left..max_num_bits_left);
            inputs.push((
                Class::Left,
                num_bits_left,
                random_scalar_with_k_bits_set(rng, num_bits_left),
                base,
            ));
        } else {
            inputs.push((
                Class::Right,
                num_bits_right,
                random_scalar_with_k_bits_set(rng, num_bits_right),
                base,
            ));
        }
    }

    for (class, _k, sk, base) in inputs {
        runner.run_one(class, || {
            let _ = black_box(base.mul(&sk));
        })
    }
}
```
