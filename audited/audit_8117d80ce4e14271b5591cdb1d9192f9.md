# Audit Report

## Title
Incorrect first_transaction_version in Empty TransactionListWithProof Causes State Sync Stalls

## Summary
The `get_transactions_with_proof_by_size()` function incorrectly sets `first_transaction_version = Some(start_version)` when returning an empty transaction list, violating the documented semantic contract. This causes state sync clients to incorrectly calculate their synced version, leading to infinite retry loops and state sync stalls.

## Finding Description

The storage service violates a critical invariant when constructing `TransactionListWithProof` responses. The documented contract states: "If `first_transaction_version` is None, the transaction list is empty. Otherwise, the transaction list starts at `first_transaction_version`." [1](#0-0) 

However, in `get_transactions_with_proof_by_size()`, the function always passes `Some(start_version)` as `first_transaction_version`, regardless of whether the transactions list is empty: [2](#0-1) 

This occurs when the database iterator returns no data (e.g., missing transactions at the requested version), causing the fetch loop to break with zero transactions: [3](#0-2) 

**Client-Side Impact:**

When a state sync client receives this malformed response, it extracts the `payload_start_version`: [4](#0-3) 

The client then calculates its new synced version as: `synced_version = payload_start_version + num_transactions - 1`. With zero transactions, this becomes: `synced_version = start_version + 0 - 1 = start_version - 1` [5](#0-4) 

This means the client makes no progress and will request the same `start_version` again in the next iteration, causing an infinite loop.

**Correct Behavior:**

The correct implementation (used in legacy code and the database reader) properly returns `None` as `first_transaction_version` for empty lists: [6](#0-5) 

The database reader also correctly handles empty responses: [7](#0-6) 

The same vulnerability exists in `get_transaction_outputs_with_proof_by_size()` at line 713: [8](#0-7) 

## Impact Explanation

**Severity: Medium** (qualifies for up to $10,000 per Aptos Bug Bounty)

This vulnerability causes **state sync liveness failures** and **state inconsistencies requiring intervention**:

1. **State Sync Stalls**: Clients enter infinite retry loops when receiving empty transaction lists, unable to make sync progress
2. **Network Degradation**: Multiple nodes experiencing this issue simultaneously degrades overall network health
3. **Operational Impact**: Requires manual intervention to diagnose and restart affected nodes
4. **Semantic Contract Violation**: Breaks documented invariants that other system components depend on

While this doesn't directly cause consensus violations or fund loss (thus not Critical), it significantly impacts availability and requires intervention to resolve, meeting Medium severity criteria.

## Likelihood Explanation

**Likelihood: Medium-High**

This vulnerability triggers under realistic conditions:

1. **Database Iterator Returns No Data**: Occurs when:
   - Requested transactions are pruned but metadata isn't updated
   - Database corruption or inconsistency
   - Race conditions during pruning operations
   - Missing data due to incomplete state sync on the server

2. **Size-Aware Chunking Enabled**: The new implementation with `enable_size_and_time_aware_chunking = true` uses this code path

3. **No Guards Exist**: The code has no checks to prevent empty transaction lists from being returned with incorrect metadata

The probability increases during:
- Network partitions causing data unavailability
- Database pruning operations
- Node startup/recovery scenarios
- High transaction volumes with aggressive pruning

## Recommendation

**Fix**: Check if the transaction list is empty and set `first_transaction_version = None` accordingly.

```rust
// Create the transaction list with proof
let transaction_events = if include_events {
    Some(transaction_events)
} else {
    None
};

// Set first_transaction_version correctly based on list emptiness
let first_transaction_version = if transactions.is_empty() {
    None
} else {
    Some(start_version)
};

let transaction_list_with_proof = TransactionListWithProof::new(
    transactions,
    transaction_events,
    first_transaction_version,  // Changed from always Some(start_version)
    info_list_with_proof,
);
```

Apply the same fix to `get_transaction_outputs_with_proof_by_size()` around line 711-715.

**Additional Safeguard**: Consider adding a validation assertion:
```rust
debug_assert!(
    transactions.is_empty() == first_transaction_version.is_none(),
    "Transaction list emptiness must match first_transaction_version None-ness"
);
```

## Proof of Concept

```rust
#[cfg(test)]
mod test_empty_transaction_list_bug {
    use super::*;
    use aptos_types::transaction::{TransactionListWithProof, TransactionInfoListWithProof};
    
    #[test]
    fn test_empty_list_violates_invariant() {
        // Simulate what get_transactions_with_proof_by_size() does
        let start_version = 1000u64;
        let transactions = vec![]; // Empty list
        let events = None;
        let info_list_with_proof = TransactionInfoListWithProof::new_empty();
        
        // BUG: Creating with Some(start_version) when list is empty
        let txn_list = TransactionListWithProof::new(
            transactions,
            events,
            Some(start_version), // WRONG! Should be None
            info_list_with_proof,
        );
        
        // This violates the invariant
        assert_eq!(txn_list.get_first_transaction_version(), Some(1000));
        assert_eq!(txn_list.get_num_transactions(), 0);
        // Invariant violation: first_version is Some but list is empty!
        
        // Client calculation simulation
        let payload_start_version = txn_list.get_first_transaction_version().unwrap();
        let num_transactions = txn_list.get_num_transactions() as u64;
        let synced_version = payload_start_version + num_transactions - 1;
        
        // Client expected to sync version 1000, but calculated 999
        assert_eq!(synced_version, 999); // No progress made!
        
        // Correct behavior:
        let correct_txn_list = TransactionListWithProof::new_empty();
        assert_eq!(correct_txn_list.get_first_transaction_version(), None);
        assert_eq!(correct_txn_list.get_num_transactions(), 0);
        // This correctly signals "no data" to the client
    }
}
```

**Notes**

This vulnerability exists specifically in the new size-and-time-aware chunking implementation introduced for performance optimization. The legacy implementation has different (though imperfect) handling. The root cause is a missing emptiness check when constructing the `TransactionListWithProof`, causing a violation of the documented semantic contract that client code relies upon for correct version tracking during state synchronization.

### Citations

**File:** types/src/transaction/mod.rs (L2269-2276)
```rust
    pub fn new_empty() -> Self {
        Self::new(
            vec![],
            None,
            None,
            TransactionInfoListWithProof::new_empty(),
        )
    }
```

**File:** types/src/transaction/mod.rs (L2292-2293)
```rust
    /// 3. If `first_transaction_version` is None, the transaction list is empty.
    ///    Otherwise, the transaction list starts at `first_transaction_version`.
```

**File:** state-sync/storage-service/server/src/storage.rs (L457-469)
```rust
                None => {
                    // Log a warning that the iterators did not contain all the expected data
                    warn!(
                        "The iterators for transactions, transaction infos, events and \
                        persisted auxiliary infos are missing data! Start version: {:?}, \
                        end version: {:?}, num transactions to fetch: {:?}, num fetched: {:?}.",
                        start_version,
                        end_version,
                        num_transactions_to_fetch,
                        transactions.len()
                    );
                    break;
                },
```

**File:** state-sync/storage-service/server/src/storage.rs (L488-493)
```rust
        let transaction_list_with_proof = TransactionListWithProof::new(
            transactions,
            transaction_events,
            Some(start_version),
            info_list_with_proof,
        );
```

**File:** state-sync/storage-service/server/src/storage.rs (L711-715)
```rust
        let transaction_output_list_with_proof = TransactionOutputListWithProof::new(
            transactions_and_outputs,
            Some(start_version),
            transaction_info_list_with_proof,
        );
```

**File:** state-sync/state-sync-driver/src/bootstrapper.rs (L622-623)
```rust
                    let payload_start_version =
                        transactions_with_proof.get_first_transaction_version();
```

**File:** state-sync/state-sync-driver/src/bootstrapper.rs (L1255-1258)
```rust
        let synced_version = payload_start_version
            .checked_add(num_transactions_or_outputs as u64)
            .and_then(|version| version.checked_sub(1)) // synced_version = start + num txns/outputs - 1
            .ok_or_else(|| Error::IntegerOverflow("The synced version has overflown!".into()))?;
```

**File:** storage/aptosdb/src/db/aptosdb_reader.rs (L277-279)
```rust
            if start_version > ledger_version || limit == 0 {
                return Ok(TransactionListWithProofV2::new_empty());
            }
```
