# Audit Report

## Title
Unbounded Heap Allocation in ThresholdConfigBlstrs Deserialization Enables Validator DoS Attack

## Summary
The `ThresholdConfigBlstrs::new()` function lacks upper bounds validation on the `n` parameter, allowing construction of threshold configurations with arbitrarily large player counts. During deserialization of DKG transcripts from validator transactions, a malicious validator can craft a transcript with an extremely large `n` value, triggering multi-gigabyte heap allocations in `BatchEvaluationDomain::new()` that cause out-of-memory crashes before transcript verification can reject the malicious input.

## Finding Description
The vulnerability exists in the threshold secret sharing configuration initialization chain: [1](#0-0) 

The `ThresholdConfigBlstrs::new()` function validates that `t > 0`, `n > 0`, and `t <= n`, but critically lacks any upper bound check on `n`. It then calls `BatchEvaluationDomain::new(n)`: [2](#0-1) 

The `BatchEvaluationDomain::new()` function computes `N` as the next power-of-2 greater than or equal to `n`, then allocates a vector with capacity `N` for storing all N-th roots of unity. Each `Scalar` element is 32 bytes. For `n = 2^30`, this allocates `2^30 * 32 bytes = 32 GB`.

The attack vector is through DKG transcript deserialization. The custom `Deserialize` implementation reconstructs the threshold configuration from untrusted input: [3](#0-2) 

When a validator submits a DKG transaction, the VM deserializes the transcript before verification: [4](#0-3) 

The OOM occurs at line 106 during `bcs::from_bytes`, before the verification at line 111 can reject the malicious transcript.

Additionally, if such a malicious configuration somehow persists, the `reconstruct()` function would allocate unbounded vectors: [5](#0-4) 

When `shares.len()` approaches `sc.get_total_num_players()` (which equals the unchecked `n`), the `ids` and `shares` vectors (lines 25 and 31-34) could consume excessive memory.

## Impact Explanation
This is a **Low severity** denial-of-service vulnerability as indicated in the security question classification. A malicious validator can crash validator nodes by submitting a specially-crafted DKG transcript, but:

- No funds are at risk
- No consensus safety violation occurs
- Nodes can recover by restarting
- Requires Byzantine validator behavior (within BFT threat model but still privileged access)
- Does not affect network liveness permanently

Per Aptos bug bounty criteria, this falls under Low severity: "Minor information leaks / Non-critical implementation bugs" as it's a DoS requiring validator privileges.

## Likelihood Explanation
**Moderate likelihood** for attempted exploitation:
- Requires malicious validator access (Byzantine actor within <1/3 threshold)
- Attack is trivial to execute once validator access is obtained (craft malicious transcript with large `n`)
- Detection is straightforward (node crashes during DKG transaction processing)
- No stealth or persistence - immediate crash makes it obvious

The Aptos network should be resilient to Byzantine validators, making this a valid concern despite requiring validator privileges.

## Recommendation
Add upper bound validation to `ThresholdConfigBlstrs::new()`:

```rust
pub fn new(t: usize, n: usize) -> anyhow::Result<Self> {
    if t == 0 {
        return Err(anyhow!("expected the reconstruction threshold to be > 0"));
    }

    if n == 0 {
        return Err(anyhow!("expected the number of shares to be > 0"));
    }

    if t > n {
        return Err(anyhow!(
            "expected the reconstruction threshold {t} to be < than the number of shares {n}"
        ));
    }

    // NEW: Add upper bound based on BLS12-381 scalar field 2-adicity and reasonable limits
    const MAX_PLAYERS: usize = 1 << 20; // 1M players, ~32MB allocation
    if n > MAX_PLAYERS {
        return Err(anyhow!(
            "number of players {n} exceeds maximum allowed {MAX_PLAYERS}"
        ));
    }

    let batch_dom = BatchEvaluationDomain::new(n);
    let dom = batch_dom.get_subdomain(n);
    Ok(ThresholdConfigBlstrs {
        t,
        n,
        dom,
        batch_dom,
    })
}
```

Additionally, consider bounds checking in `BatchEvaluationDomain::new()` similar to `EvaluationDomain::new()`: [6](#0-5) 

## Proof of Concept
```rust
use aptos_crypto::blstrs::threshold_config::ThresholdConfigBlstrs;
use aptos_crypto::traits::ThresholdConfig;

#[test]
#[should_panic] // Will OOM before panic
fn test_oom_with_large_n() {
    // Attempt to create threshold config with 2^30 players
    // This will allocate ~32 GB in BatchEvaluationDomain::new()
    let huge_n = 1 << 30; // 1,073,741,824
    let result = ThresholdConfigBlstrs::new(1, huge_n);
    
    // This line is never reached - OOM occurs during BatchEvaluationDomain allocation
    assert!(result.is_ok());
}

#[test]
fn test_deserialize_malicious_config() {
    use serde::{Serialize, Deserialize};
    
    // Malicious serialized config with huge n
    #[derive(Serialize, Deserialize)]
    struct MaliciousConfig {
        t: usize,
        n: usize,
    }
    
    let malicious = MaliciousConfig {
        t: 1,
        n: 1 << 30,
    };
    
    let bytes = bcs::to_bytes(&malicious).unwrap();
    
    // Attempting to deserialize triggers OOM
    let _result: Result<ThresholdConfigBlstrs, _> = bcs::from_bytes(&bytes);
    // Node crashes with OOM before this returns
}
```

## Notes
While the validator set is bounded by `MAX_VALIDATOR_SET_SIZE = 65536` [7](#0-6)  and individual stakes have configurable limits [8](#0-7) , the deserialization path bypasses these on-chain constraints, allowing arbitrary `n` values in threshold configurations submitted through DKG transcripts.

### Citations

**File:** crates/aptos-crypto/src/blstrs/threshold_config.rs (L37-54)
```rust
impl<'de> Deserialize<'de> for ThresholdConfigBlstrs {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        // Deserialize only the serializable fields (t, n)
        #[derive(Deserialize)]
        struct SerializedFields {
            t: usize,
            n: usize,
        }

        let serialized = SerializedFields::deserialize(deserializer)?;

        // Rebuild the skipped fields using `new`
        ThresholdConfigBlstrs::new(serialized.t, serialized.n).map_err(serde::de::Error::custom)
    }
}
```

**File:** crates/aptos-crypto/src/blstrs/threshold_config.rs (L109-132)
```rust
    fn new(t: usize, n: usize) -> anyhow::Result<Self> {
        if t == 0 {
            return Err(anyhow!("expected the reconstruction threshold to be > 0"));
        }

        if n == 0 {
            return Err(anyhow!("expected the number of shares to be > 0"));
        }

        if t > n {
            return Err(anyhow!(
                "expected the reconstruction threshold {t} to be < than the number of shares {n}"
            ));
        }

        let batch_dom = BatchEvaluationDomain::new(n);
        let dom = batch_dom.get_subdomain(n);
        Ok(ThresholdConfigBlstrs {
            t,
            n,
            dom,
            batch_dom,
        })
    }
```

**File:** crates/aptos-crypto/src/blstrs/evaluation_domain.rs (L73-95)
```rust
    pub fn new(n: usize) -> Result<EvaluationDomain, CryptoMaterialError> {
        // Compute the size of our evaluation domain
        let (N, log_N) = smallest_power_of_2_greater_than_or_eq(n);

        // The pairing-friendly curve may not be able to support
        // large enough (radix2) evaluation domains.
        if log_N >= Scalar::S as usize {
            return Err(CryptoMaterialError::WrongLengthError);
        }

        // Compute $\omega$, the $N$th primitive root of unity
        let omega = Self::get_Nth_root_of_unity(log_N);

        Ok(EvaluationDomain {
            n,
            N,
            log_N,
            omega,
            omega_inverse: omega.invert().unwrap(),
            // geninv: Scalar::multiplicative_generator().invert().unwrap(),
            N_inverse: Scalar::from(N as u64).invert().unwrap(),
        })
    }
```

**File:** crates/aptos-crypto/src/blstrs/evaluation_domain.rs (L120-153)
```rust
    pub fn new(n: usize) -> Self {
        let (N, log_N) = smallest_power_of_2_greater_than_or_eq(n);
        let omega = EvaluationDomain::get_Nth_root_of_unity(log_N);

        let mut omegas = Vec::with_capacity(N);
        omegas.push(Scalar::ONE);

        let mut acc = omega;
        for _ in 1..N {
            omegas.push(acc);
            acc *= omega; // $\omega^i$
        }

        debug_assert_eq!(omegas.len(), N);

        let mut N_inverses = Vec::with_capacity(log_N);
        let mut i = 1u64;
        for _ in 0..=log_N {
            N_inverses.push(Scalar::from(i).invert().unwrap());

            i *= 2;
        }

        debug_assert_eq!(
            N_inverses.last().unwrap().invert().unwrap(),
            Scalar::from(N as u64)
        );

        BatchEvaluationDomain {
            log_N,
            omegas,
            N_inverses,
        }
    }
```

**File:** aptos-move/aptos-vm/src/validator_txns/dkg.rs (L104-112)
```rust
        // Deserialize transcript and verify it.
        let pub_params = DefaultDKG::new_public_params(&in_progress_session_state.metadata);
        let transcript = bcs::from_bytes::<<DefaultDKG as DKGTrait>::Transcript>(
            dkg_node.transcript_bytes.as_slice(),
        )
        .map_err(|_| Expected(TranscriptDeserializationFailed))?;

        DefaultDKG::verify_transcript(&pub_params, &transcript)
            .map_err(|_| Expected(TranscriptVerificationFailed))?;
```

**File:** crates/aptos-crypto/src/blstrs/scalar_secret_key.rs (L18-44)
```rust
    fn reconstruct(
        sc: &ThresholdConfigBlstrs,
        shares: &[ShamirShare<Self::ShareValue>],
    ) -> anyhow::Result<Self> {
        assert_ge!(shares.len(), sc.get_threshold());
        assert_le!(shares.len(), sc.get_total_num_players());

        let ids = shares.iter().map(|(p, _)| p.id).collect::<Vec<usize>>();
        let lagr = lagrange_coefficients(
            sc.get_batch_evaluation_domain(),
            ids.as_slice(),
            &Scalar::ZERO,
        );
        let shares = shares
            .iter()
            .map(|(_, share)| *share)
            .collect::<Vec<Scalar>>();

        // TODO should this return a
        assert_eq!(lagr.len(), shares.len());

        Ok(shares
            .iter()
            .zip(lagr.iter())
            .map(|(&share, &lagr)| share * lagr)
            .sum::<Scalar>())
    }
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L100-100)
```text
    const MAX_VALIDATOR_SET_SIZE: u64 = 65536;
```

**File:** aptos-move/framework/aptos-framework/sources/configs/staking_config.move (L49-72)
```text
    struct StakingConfig has copy, drop, key {
        // A validator needs to stake at least this amount to be able to join the validator set.
        // If after joining the validator set and at the start of any epoch, a validator's stake drops below this amount
        // they will be removed from the set.
        minimum_stake: u64,
        // A validator can only stake at most this amount. Any larger stake will be rejected.
        // If after joining the validator set and at the start of any epoch, a validator's stake exceeds this amount,
        // their voting power and rewards would only be issued for the max stake amount.
        maximum_stake: u64,
        recurring_lockup_duration_secs: u64,
        // Whether validators are allow to join/leave post genesis.
        allow_validator_set_change: bool,
        // DEPRECATING: staking reward configurations will be in StakingRewardsConfig once REWARD_RATE_DECREASE flag is enabled.
        // The maximum rewards given out every epoch. This will be divided by the rewards rate denominator.
        // For example, 0.001% (0.00001) can be represented as 10 / 1000000.
        rewards_rate: u64,
        // DEPRECATING: staking reward configurations will be in StakingRewardsConfig once REWARD_RATE_DECREASE flag is enabled.
        rewards_rate_denominator: u64,
        // Only this % of current total voting power is allowed to join the validator set in each epoch.
        // This is necessary to prevent a massive amount of new stake from joining that can potentially take down the
        // network if corresponding validators are not ready to participate in consensus in time.
        // This value is within (0, 50%), not inclusive.
        voting_power_increase_limit: u64,
    }
```
