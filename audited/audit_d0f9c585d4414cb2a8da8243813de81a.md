# Audit Report

## Title
Version Upgrade Proposal Generation Bypasses Validation When Remote Endpoint Is Not Configured

## Summary
The `generate_version_upgrade_proposal()` function can generate governance proposals with invalid version numbers (equal to or less than current on-chain version) when the ReleaseConfig lacks a `remote_endpoint`, causing these proposals to fail on-chain with `EINVALID_MAJOR_VERSION_NUMBER` and wasting governance resources.

## Finding Description
The release builder tool has a two-tier validation system with a critical gap:

1. **Upper-level check** exists in `ReleaseEntry::Version` processing: [1](#0-0) 

2. **This check depends on** `fetch_and_equals()` which returns `Ok(false)` when no client is available: [2](#0-1) 

3. **The ReleaseConfig allows** `remote_endpoint` to be `None`: [3](#0-2) 

4. **The function itself has NO validation**: [4](#0-3) 

When `remote_endpoint` is `None`, `fetch_and_equals` returns `false`, making the condition `if !fetch_and_equals...` evaluate to `true`, causing proposal generation even when `version.major` equals or is less than the current on-chain version.

The generated proposal will fail on-chain because `set_for_next_epoch()` validates: [5](#0-4) 

This breaks **Governance Integrity** by allowing proposals that waste voting power, gas, and governance bandwidth.

## Impact Explanation
**Medium Severity** - This qualifies as "State inconsistencies requiring intervention" per the bug bounty program:

- Governance proposals consume significant resources: validator voting power, community attention, gas costs for execution attempts
- Failed proposals create confusion and delay legitimate upgrades
- The approved execution hash remains in `ApprovedExecutionHashes` while the proposal cannot complete
- Unlike gas schedule generation which warns about missing endpoints (lines 264-267), version upgrades provide no such warning
- Reduces confidence in the governance process when proposals mysteriously fail

## Likelihood Explanation
**Medium-High likelihood** in specific scenarios:

1. **Developer error**: Using default ReleaseConfig or testing configurations without `remote_endpoint`
2. **Offline proposal generation**: When generating proposals without network access
3. **Configuration mistakes**: Forgetting to set `remote_endpoint` in production configs
4. **Version rollback attempts**: Accidentally setting version equal to current during emergency responses

The default configuration uses `None`: [6](#0-5) 

## Recommendation
Add explicit validation in `generate_version_upgrade_proposal()` or require `remote_endpoint` for version proposals:

```rust
pub fn generate_version_upgrade_proposal(
    version: &AptosVersion,
    is_testnet: bool,
    next_execution_hash: Option<HashValue>,
    is_multi_step: bool,
) -> Result<Vec<(String, String)>> {
    // Add validation warning
    println!("!!! WARNING !!!");
    println!("Generating version upgrade proposal without on-chain validation.");
    println!("Ensure version.major > current on-chain version to avoid governance resource waste.");
    println!("Consider specifying remote_endpoint for automatic validation.");
    println!("!!! WARNING !!!");
    
    let signer_arg = get_signer_arg(is_testnet, &next_execution_hash);
    // ... rest of function
}
```

Better solution: Make the check mandatory at the call site in `mod.rs` by requiring `client` for Version entries.

## Proof of Concept

```rust
// Reproduction steps:
// 1. Create ReleaseConfig without remote_endpoint
let config = ReleaseConfig {
    name: "test".to_string(),
    remote_endpoint: None,  // No validation will occur
    proposals: vec![
        Proposal {
            name: "invalid_version".to_string(),
            execution_mode: ExecutionMode::MultiStep,
            metadata: ProposalMetadata::default(),
            update_sequence: vec![
                ReleaseEntry::Version(AptosVersion { major: 61 })  // Assume current on-chain is also 61
            ],
        }
    ],
};

// 2. Generate proposals - this will succeed despite invalid version
config.generate_release_proposal_scripts(Path::new("./test_output")).await?;

// 3. The generated proposal, when executed on-chain, will abort:
// Script calls: version::set_for_next_epoch(&framework_signer, 61)
// On-chain validation fails: assert!(old_major < major, ...) 
// Where old_major = 61, major = 61, causing EINVALID_MAJOR_VERSION_NUMBER
```

## Notes
The on-chain validation is correct and secure. [7](#0-6)  The vulnerability exists in the off-chain tooling that generates proposals, making it a developer footgun rather than a protocol-level exploit. However, it can waste significant governance resources when triggered, qualifying as Medium severity under "state inconsistencies requiring intervention."

### Citations

**File:** aptos-move/aptos-release-builder/src/components/mod.rs (L53-58)
```rust
#[derive(Serialize, Deserialize, Clone, Eq, PartialEq)]
pub struct ReleaseConfig {
    pub name: String,
    pub remote_endpoint: Option<Url>,
    pub proposals: Vec<Proposal>,
}
```

**File:** aptos-move/aptos-release-builder/src/components/mod.rs (L292-304)
```rust
            ReleaseEntry::Version(version) => {
                if !fetch_and_equals::<AptosVersion>(client, version)? {
                    result.append(&mut version::generate_version_upgrade_proposal(
                        version,
                        is_testnet,
                        if is_multi_step {
                            get_execution_hash(result)
                        } else {
                            None
                        },
                        is_multi_step,
                    )?);
                }
```

**File:** aptos-move/aptos-release-builder/src/components/mod.rs (L531-543)
```rust
fn fetch_and_equals<T: OnChainConfig + PartialEq>(
    client: Option<&Client>,
    expected: &T,
) -> Result<bool> {
    match client {
        Some(client) => {
            let config = fetch_config::<T>(client)?;

            Ok(&config == expected)
        },
        None => Ok(false),
    }
}
```

**File:** aptos-move/aptos-release-builder/src/components/mod.rs (L769-769)
```rust
            remote_endpoint: None,
```

**File:** aptos-move/aptos-release-builder/src/components/version.rs (L10-40)
```rust
pub fn generate_version_upgrade_proposal(
    version: &AptosVersion,
    is_testnet: bool,
    next_execution_hash: Option<HashValue>,
    is_multi_step: bool,
) -> Result<Vec<(String, String)>> {
    let signer_arg = get_signer_arg(is_testnet, &next_execution_hash);
    let mut result = vec![];

    let writer = CodeWriter::new(Loc::default());

    let proposal = generate_governance_proposal(
        &writer,
        is_testnet,
        next_execution_hash,
        is_multi_step,
        &["aptos_framework::version"],
        |writer| {
            emitln!(
                writer,
                "version::set_for_next_epoch({}, {});",
                signer_arg,
                version.major,
            );
            emitln!(writer, "aptos_governance::reconfigure({});", signer_arg);
        },
    );

    result.push(("version".to_string(), proposal));
    Ok(result)
}
```

**File:** aptos-move/framework/aptos-framework/sources/configs/version.move (L59-63)
```text
    public entry fun set_for_next_epoch(account: &signer, major: u64) acquires Version {
        assert!(exists<SetVersionCapability>(signer::address_of(account)), error::permission_denied(ENOT_AUTHORIZED));
        let old_major = borrow_global<Version>(@aptos_framework).major;
        assert!(old_major < major, error::invalid_argument(EINVALID_MAJOR_VERSION_NUMBER));
        config_buffer::upsert(Version {major});
```
