# Audit Report

## Title
Case-Insensitive Git URL Canonicalization Enables Repository Substitution Attack on Case-Sensitive Servers

## Summary
The `CanonicalGitIdentity` implementation converts Git URLs to lowercase for canonical identity comparison, but Git repository URLs are case-sensitive on Linux filesystems. This allows an attacker to create a malicious repository with different casing that gets treated as identical to a legitimate repository, enabling supply chain attacks through dependency confusion.

## Finding Description

The vulnerability exists in the URL canonicalization logic and its interaction with the Git package cache system. [1](#0-0) 

The canonicalization aggressively normalizes URLs by converting both host and path to lowercase. However, Git URLs are case-sensitive when repositories are hosted on case-sensitive filesystems (standard on Linux servers).

The canonical identity is used for two critical purposes:

1. **Repository cache directory naming** - determines where the Git repository is cloned locally: [2](#0-1) 

2. **Package lock file keys** - determines how dependencies are tracked across builds: [3](#0-2) 

3. **Package identity deduplication** - determines if two dependencies are considered the same: [4](#0-3) 

**Attack Path:**

1. Legitimate repository exists at `https://git.example.com/TrustedOrg/Framework.git` (safe code)
2. Attacker creates `https://git.example.com/trustedorg/framework.git` on a case-sensitive server (malicious code)
3. Both URLs canonicalize to identical string: `git.example.com/trustedorg/framework`
4. Package A declares dependency on attacker's URL (lowercase)
5. Package B declares dependency on legitimate URL (correct casing)  
6. During dependency resolution:
   - If A resolves first: clones attacker's repo, stores commit hash in lock file with canonical key
   - When B resolves: finds existing lock entry, retrieves commit hash, uses cached malicious repository
   - B compiles with attacker's code instead of legitimate dependency

When the cached repository exists, it's reused without validating the URL matches: [5](#0-4) 

The existing repository's "origin" remote (set during initial clone) is used for all subsequent fetches, regardless of which URL triggered the operation.

**Invariant Violation:**

This breaks the **Deterministic Execution** invariant. Different resolution orders or different lock file states cause different package contents to be used for the same dependency declaration. If this affects Move packages used in transaction execution, different validators could compile and execute different bytecode, causing consensus divergence.

## Impact Explanation

**Severity: HIGH** (up to $50,000 per bug bounty program)

This vulnerability enables:

1. **Supply Chain Attack**: Attackers can inject malicious code into packages by exploiting case sensitivity confusion. Developers believing they're using a trusted repository get malicious code.

2. **Non-Deterministic Builds**: Resolution order dependency means the same project can build differently on different machines or at different times, violating reproducibility guarantees.

3. **Consensus Risk**: If Aptos validators use Move packages with Git dependencies for any consensus-critical code and have different resolution orders or lock files, they would compile different bytecode and produce different state roots, breaking consensus safety.

4. **Lock File Poisoning**: Once a malicious commit enters the lock file under the canonical key, all subsequent builds using that lock file will use the malicious code, even if they specify the legitimate URL.

While this doesn't directly cause "Loss of Funds" or "Consensus/Safety violations" in the core Aptos protocol (which doesn't appear to use Git dependencies for framework code), it represents a **significant protocol violation** affecting the Move package ecosystem's security guarantees.

## Likelihood Explanation

**Likelihood: MEDIUM**

Required conditions:
- Git repositories hosted on case-sensitive server (Linux) - **feasible but less common than GitHub**
- Attacker can create repository with different casing - **trivial on self-hosted servers**
- Target project uses Git dependencies from such servers - **possible for third-party Move packages**
- Resolution order favors attacker's dependency or shared lock file - **depends on build setup**

Mitigating factors:
- Popular Git hosts (GitHub, GitLab, Bitbucket) are case-insensitive
- Aptos framework appears to use local dependencies primarily
- Many projects use lock files which provide some consistency (though still vulnerable to initial poisoning)

However, the increasing use of self-hosted Git servers, private infrastructure, and the potential for this to affect validator deployments makes this a realistic threat vector.

## Recommendation

**Immediate Fix:** Preserve original URL casing in canonical identity or validate URL matches before reusing cached repositories.

**Option 1 - Store and validate original URL:**

```rust
pub struct CanonicalGitIdentity {
    canonical: String,
    original_url: String,  // Preserve exact URL
}

impl CanonicalGitIdentity {
    pub fn new(git_url: &Url) -> Result<Self> {
        // Keep existing canonicalization logic
        let host = git_url.host_str()...to_ascii_lowercase();
        let path = git_url.path().to_ascii_lowercase();
        // ... existing logic ...
        
        Ok(Self {
            canonical: format!("{}{}{}", host, port, path),
            original_url: git_url.to_string(),
        })
    }
}
```

Then in `clone_or_update_git_repo`, validate the cached repository's remote URL matches:

```rust
if repo_path.exists() {
    let repo = Repository::open_bare(&repo_path)?;
    let remote = repo.find_remote("origin")?;
    
    // Validate URL matches
    if remote.url() != Some(git_url.as_str()) {
        // URL mismatch - remove and re-clone
        remove_dir_if_exists(&repo_path)?;
        // Fall through to clone logic
    } else {
        // Safe to reuse and update
        remote.fetch(...)?;
    }
}
```

**Option 2 - Include URL hash in cache path:**

```rust
let url_hash = sha256(git_url.as_str());
let repo_path = repos_path.join(format!("{}_{}", repo_dir_name, &url_hash[..8]));
```

This ensures different URLs (even with same canonical identity) use separate cache directories.

**Option 3 - Case-sensitive canonicalization with explicit case preservation:**

Only normalize when URLs are truly equivalent (e.g., scheme normalization) but preserve path casing:

```rust
let host = git_url.host_str()...to_ascii_lowercase();  // Host is case-insensitive
let path = git_url.path();  // Preserve case!
```

## Proof of Concept

**Rust Test Demonstrating Vulnerability:**

```rust
#[tokio::test]
async fn test_case_sensitivity_vulnerability() {
    use tempfile::TempDir;
    use move_package_cache::{CanonicalGitIdentity, PackageCache};
    use url::Url;
    
    // Setup: Two URLs with different casing
    let url1 = Url::parse("https://git.example.com/Owner/Repo.git").unwrap();
    let url2 = Url::parse("https://git.example.com/owner/repo.git").unwrap();
    
    // Both canonicalize to the same identity
    let canonical1 = CanonicalGitIdentity::new(&url1).unwrap();
    let canonical2 = CanonicalGitIdentity::new(&url2).unwrap();
    
    assert_eq!(canonical1.to_string(), canonical2.to_string(), 
        "Different URLs produce same canonical identity");
    
    // This means they would:
    // 1. Use the same cache directory
    // 2. Create same lock file entry  
    // 3. Be considered the same package
    // 4. But potentially point to different repositories on case-sensitive servers!
    
    println!("VULNERABILITY: URLs with different casing are treated as identical:");
    println!("  URL 1: {}", url1);
    println!("  URL 2: {}", url2);
    println!("  Canonical: {}", canonical1);
    println!("  Both would use cache directory: git/repos/{}", 
        percent_encode(&canonical1.to_string()));
}

fn percent_encode(s: &str) -> String {
    // Simplified encoding for demonstration
    s.replace("/", "%2F")
}
```

**Expected Output:**
```
VULNERABILITY: URLs with different casing are treated as identical:
  URL 1: https://git.example.com/Owner/Repo.git
  URL 2: https://git.example.com/owner/repo.git
  Canonical: git.example.com/owner/repo
  Both would use cache directory: git/repos/git.example.com%2Fowner%2Frepo
```

This demonstrates that two URLs pointing to potentially different repositories on a case-sensitive Git server are treated as identical by the caching system, enabling repository substitution attacks.

## Notes

- While GitHub/GitLab are case-insensitive, many self-hosted Git servers preserve case sensitivity
- The vulnerability affects any Move package using Git dependencies, not just Aptos core
- Lock files provide consistency *within* a build environment but are vulnerable to initial poisoning
- This is a supply chain security issue affecting the Move ecosystem's trust model
- The issue exists in the design of canonical identity, not just implementation

### Citations

**File:** third_party/move/tools/move-package-cache/src/canonical.rs (L20-38)
```rust
    pub fn new(git_url: &Url) -> Result<Self> {
        let host = git_url
            .host_str()
            .ok_or_else(|| anyhow!("invalid git URL, unable to extract host: {}", git_url))?
            .to_ascii_lowercase();

        let port = match git_url.port() {
            Some(port) => match (git_url.scheme(), port) {
                ("http", 80) | ("https", 443) | ("ssh", 22) => "".to_string(),
                _ => format!(":{}", port),
            },
            None => "".to_string(),
        };

        let path = git_url.path().to_ascii_lowercase();
        let path = path.trim_end_matches("/").trim_end_matches(".git");

        Ok(Self(format!("{}{}{}", host, port, path)))
    }
```

**File:** third_party/move/tools/move-package-cache/src/package_cache.rs (L97-99)
```rust
        let repo_dir_name = percent_encode_for_filename(&CanonicalGitIdentity::new(git_url)?);
        let repos_path = self.root.join("git").join("repos");
        let repo_path = repos_path.join(&repo_dir_name);
```

**File:** third_party/move/tools/move-package-cache/src/package_cache.rs (L137-158)
```rust
        let repo = if repo_path.exists() {
            // If the repo already exists, update it.
            self.listener.on_repo_update_start(git_url.as_str());

            let repo = Repository::open_bare(&repo_path)?;
            {
                let mut remote = repo.find_remote("origin")?;
                // Fetch all remote branches and map them to local remote-tracking branches
                // - refs/heads/*: fetch all remote branches
                // - refs/remotes/origin/*: store them as local remote-tracking branches under origin/
                remote
                    .fetch(
                        &["refs/heads/*:refs/remotes/origin/*"],
                        Some(&mut fetch_options),
                        None,
                    )
                    .map_err(|err| anyhow!("Failed to update git repo at {}: {}", git_url, err))?;
            }

            self.listener.on_repo_update_complete(git_url.as_str());

            repo
```

**File:** third_party/move/tools/move-package-resolver/src/lock.rs (L71-73)
```rust
        let git_identity = CanonicalGitIdentity::new(git_url)?;

        let repo_loc_and_rev = format!("{}@{}", git_identity, rev);
```

**File:** third_party/move/tools/move-package-resolver/src/identity.rs (L23-27)
```rust
    Git {
        repo: CanonicalGitIdentity,
        commit_id: Oid,
        subdir: NormalizedPath,
    },
```
