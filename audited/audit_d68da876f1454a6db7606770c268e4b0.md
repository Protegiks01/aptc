# Audit Report

## Title
Signature Malleability in QuorumCertifiedUpdate Causes Consensus Liveness Failure

## Summary
The `QuorumCertifiedUpdate` struct derives `CryptoHasher` and includes both the `update` and `multi_sig` fields in its hash computation, but the multi-signature only signs the `update` field. This allows an attacker to create multiple valid `QuorumCertifiedUpdate` objects with identical update content but different signatures (using different validator quorums), resulting in different hashes. When these variants are included in consensus blocks, they produce different block IDs, causing validators to vote on different blocks and leading to consensus liveness failure.

## Finding Description

The vulnerability exists in the design of the `QuorumCertifiedUpdate` structure and how it integrates with the consensus protocol.

**Root Cause:** [1](#0-0) 

The `QuorumCertifiedUpdate` struct derives both `CryptoHasher` and `BCSCryptoHash`, meaning its hash includes both the `update: ProviderJWKs` field and the `multi_sig: AggregateSignature` field.

However, during signature verification, only the `update` field is signed: [2](#0-1) 

The verification explicitly checks `verifier.verify_multi_signatures(&observed, &multi_sig)` where `observed` is just the `ProviderJWKs` update, not the entire `QuorumCertifiedUpdate` structure.

This is confirmed in the signature aggregation flow: [3](#0-2) 

Individual validator signatures are verified against `peer_view` (the `ProviderJWKs`), and then aggregated: [4](#0-3) 

**Attack Path:**

1. Multiple validators sign the same JWK update (e.g., 5 validators A, B, C, D, E sign, with quorum requiring 3 signatures)
2. An attacker (any network observer) collects these broadcast signatures
3. The attacker creates multiple valid `QuorumCertifiedUpdate` variants:
   - Variant 1: signatures from {A, B, C}
   - Variant 2: signatures from {A, B, D}
   - Variant 3: signatures from {B, C, D}
   - etc.
4. Each variant has the same `update` content but different `multi_sig` values, resulting in different hashes
5. The attacker distributes different variants to different validator nodes via the P2P network
6. Each validator's transaction pool accepts one variant (topic-based, last-write-wins): [5](#0-4) 

7. When different validators become block proposers, they include their locally stored variant in their proposals

**Consensus Impact:**

The validator transaction is embedded in block proposals: [6](#0-5) 

The block hash computation includes the full validator transactions: [7](#0-6) 

When validators vote on blocks, they vote on the `BlockInfo.id`: [8](#0-7) 

Since different variants produce different block IDs, validators will vote on different blocks even though the underlying JWK update is identical. This splits the voting power across multiple valid blocks, preventing any block from reaching the 2/3+ quorum required for consensus.

**Invariant Violations:**

1. **Consensus Safety**: Different validators may vote on different blocks for the same round, breaking consensus agreement
2. **Deterministic Execution**: The same logical update produces different block hashes depending on which signature variant is included

## Impact Explanation

This vulnerability has **CRITICAL** severity according to the Aptos bug bounty criteria:

- **Non-recoverable network partition requiring hardfork**: Once validators have diverged on which variant to include, there is no automatic recovery mechanism. Different validators will continue proposing blocks with their locally stored variant, perpetually failing to reach consensus.

- **Total loss of liveness/network availability**: No blocks can be finalized as long as voting power is split across different valid block proposals containing different QuorumCertifiedUpdate variants. The network effectively halts.

The attack breaks the fundamental consensus invariant that all honest validators must agree on block proposals. While both blocks are "valid" in isolation (correct signatures, correct version checks, correct quorum), they have different hashes and therefore split validator votes.

## Likelihood Explanation

This vulnerability has **HIGH** likelihood:

**Attacker Requirements:**
- No validator private keys needed
- No privileged access required
- Only requires observing the P2P network to collect broadcast JWK update signatures
- Any network peer can execute this attack

**Attack Complexity:**
- Low - simply collect broadcast signatures and create multiple valid combinations
- BLS signature aggregation is order-independent and publicly verifiable
- Easy to distribute variants to different nodes via standard P2P protocols

**Triggering Conditions:**
- Occurs naturally whenever more validators sign a JWK update than the minimum quorum requirement
- Common scenario: 5 validators sign, only 3 needed for quorum → attacker can create C(5,3) = 10 different valid variants
- JWK updates happen regularly as part of keyless account operations

## Recommendation

**Fix: Include the multi-signature in what gets signed**

Change the signature scheme so that validators sign a commitment that includes both the update content and the signature metadata (validator set). This prevents creating multiple valid signatures for the same logical update.

**Option 1: Sign a commitment to the validator set**
```rust
// Modify ProviderJWKs to include signer commitment
#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize, CryptoHasher, BCSCryptoHash)]
pub struct ProviderJWKsWithSignerCommitment {
    pub jwks: ProviderJWKs,
    pub signer_addresses: Vec<AccountAddress>, // Deterministically ordered
}
```

Validators would sign this extended structure, committing to which validators are participating. This prevents reusing signatures with different validator sets.

**Option 2: Remove CryptoHasher derivation from QuorumCertifiedUpdate**

Remove the `CryptoHasher` and `BCSCryptoHash` derivations from `QuorumCertifiedUpdate` and implement a custom hash that only includes the `update` field:

```rust
#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize)]
pub struct QuorumCertifiedUpdate {
    pub update: ProviderJWKs,
    pub multi_sig: AggregateSignature,
}

impl CryptoHash for QuorumCertifiedUpdate {
    type Hasher = QuorumCertifiedUpdateHasher;
    
    fn hash(&self) -> HashValue {
        self.update.hash() // Only hash the update, not the signature
    }
}
```

This ensures that all valid variants of the same update produce the same hash, preventing consensus splits.

**Option 3: Canonical signature requirement**

Require that the `AggregateSignature` use a canonical validator set (e.g., the lexicographically smallest set that meets quorum). Reject any QuorumCertifiedUpdate that doesn't use the canonical set.

**Recommended Approach: Option 2**

Option 2 is cleanest as it aligns the hash semantics with the signature semantics - both should be based solely on the update content, not the proof of that content. The signature is metadata proving authenticity; it shouldn't affect the identity of the update itself.

## Proof of Concept

```rust
#[test]
fn test_quorum_certified_update_hash_malleability() {
    use aptos_crypto::{bls12381, HashValue, Uniform};
    use aptos_types::{
        aggregate_signature::AggregateSignature,
        jwks::{ProviderJWKs, QuorumCertifiedUpdate},
        validator_verifier::ValidatorVerifier,
    };
    use aptos_bitvec::BitVec;
    use aptos_crypto::hash::CryptoHash;
    
    // Create validator signers
    let mut rng = rand::thread_rng();
    let validators: Vec<_> = (0..5)
        .map(|_| bls12381::PrivateKey::generate(&mut rng))
        .collect();
    
    // Create a JWK update
    let update = ProviderJWKs {
        issuer: b"https://accounts.google.com".to_vec(),
        version: 1,
        jwks: vec![],
    };
    
    // All validators sign the update
    let signatures: Vec<_> = validators
        .iter()
        .map(|sk| sk.sign(&update).unwrap())
        .collect();
    
    // Create two different multi-signatures using different quorums (3 out of 5)
    // Variant 1: validators 0, 1, 2
    let mut bitvec1 = BitVec::with_num_bits(5);
    bitvec1.set(0);
    bitvec1.set(1);
    bitvec1.set(2);
    let agg_sig1 = bls12381::Signature::aggregate(vec![
        signatures[0].clone(),
        signatures[1].clone(),
        signatures[2].clone(),
    ]).unwrap();
    let multi_sig1 = AggregateSignature::new(bitvec1, Some(agg_sig1));
    
    // Variant 2: validators 0, 1, 3
    let mut bitvec2 = BitVec::with_num_bits(5);
    bitvec2.set(0);
    bitvec2.set(1);
    bitvec2.set(3);
    let agg_sig2 = bls12381::Signature::aggregate(vec![
        signatures[0].clone(),
        signatures[1].clone(),
        signatures[3].clone(),
    ]).unwrap();
    let multi_sig2 = AggregateSignature::new(bitvec2, Some(agg_sig2));
    
    // Create two QuorumCertifiedUpdate objects
    let qc_update1 = QuorumCertifiedUpdate {
        update: update.clone(),
        multi_sig: multi_sig1,
    };
    
    let qc_update2 = QuorumCertifiedUpdate {
        update: update.clone(),
        multi_sig: multi_sig2,
    };
    
    // Compute hashes
    let hash1 = qc_update1.hash();
    let hash2 = qc_update2.hash();
    
    // VULNERABILITY: Different hashes for the same logical update!
    assert_ne!(hash1, hash2, "Signature malleability: same update produces different hashes");
    
    // Both variants have the same update content
    assert_eq!(qc_update1.update, qc_update2.update);
    
    // This causes consensus split when included in blocks:
    // - Block A includes qc_update1 → produces block_hash_A
    // - Block B includes qc_update2 → produces block_hash_B
    // - block_hash_A ≠ block_hash_B
    // - Validators vote on different block IDs
    // - No block reaches 2/3+ quorum → LIVENESS FAILURE
}
```

**Notes**

This vulnerability demonstrates a critical design flaw where the authentication mechanism (multi-signature) is included in the identity hash of the authenticated object. The correct design pattern is to separate the content hash (what is authenticated) from the authentication metadata (the signature proving authenticity). The multi-signature proves that a quorum agreed on the update content, but different valid proofs of the same fact should not change the identity of that fact.

The issue is particularly severe because it can be exploited by passive network observers without any special privileges, and the resulting consensus failure requires manual intervention (hardfork) to resolve.

### Citations

**File:** types/src/jwks/mod.rs (L303-307)
```rust
#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize, CryptoHasher, BCSCryptoHash)]
pub struct QuorumCertifiedUpdate {
    pub update: ProviderJWKs,
    pub multi_sig: AggregateSignature,
}
```

**File:** aptos-move/aptos-vm/src/validator_txns/jwk.rs (L139-142)
```rust
        // Verify multi-sig.
        verifier
            .verify_multi_signatures(&observed, &multi_sig)
            .map_err(|_| Expected(MultiSigVerificationFailed))?;
```

**File:** crates/aptos-jwk-consensus/src/observation_aggregation/mod.rs (L86-89)
```rust
        // Verify peer signature.
        self.epoch_state
            .verifier
            .verify(sender, &peer_view, &signature)?;
```

**File:** crates/aptos-jwk-consensus/src/observation_aggregation/mod.rs (L118-123)
```rust
        let multi_sig = self.epoch_state.verifier.aggregate_signatures(partial_sigs.signatures_iter()).map_err(|e|anyhow!("adding peer observation failed with partial-to-aggregated conversion error: {e}"))?;

        Ok(Some(QuorumCertifiedUpdate {
            update: peer_view,
            multi_sig,
        }))
```

**File:** crates/validator-transaction-pool/src/lib.rs (L74-76)
```rust
        if let Some(old_seq_num) = pool.seq_nums_by_topic.insert(topic.clone(), seq_num) {
            pool.txn_queue.remove(&old_seq_num);
        }
```

**File:** consensus/consensus-types/src/proposal_ext.rs (L51-63)
```rust
pub enum ProposalExt {
    V0 {
        validator_txns: Vec<ValidatorTransaction>,
        /// T of the block (e.g. one or more transaction(s)
        payload: Payload,
        /// Author of the block that can be validated by the author's public key and the signature
        author: Author,
        /// Failed authors from the parent's block to this block.
        /// I.e. the list of consecutive proposers from the
        /// immediately preceeding rounds that didn't produce a successful block.
        failed_authors: Vec<(Round, Author)>,
    },
}
```

**File:** consensus/consensus-types/src/block_data.rs (L105-133)
```rust
impl CryptoHash for BlockData {
    type Hasher = BlockDataHasher;

    fn hash(&self) -> HashValue {
        let mut state = Self::Hasher::default();
        if self.is_opt_block() {
            #[derive(Serialize)]
            struct OptBlockDataForHash<'a> {
                epoch: u64,
                round: Round,
                timestamp_usecs: u64,
                quorum_cert_vote_data: &'a VoteData,
                block_type: &'a BlockType,
            }

            let opt_block_data_for_hash = OptBlockDataForHash {
                epoch: self.epoch,
                round: self.round,
                timestamp_usecs: self.timestamp_usecs,
                quorum_cert_vote_data: self.quorum_cert.vote_data(),
                block_type: &self.block_type,
            };
            bcs::serialize_into(&mut state, &opt_block_data_for_hash)
                .expect("OptBlockDataForHash must be serializable");
        } else {
            bcs::serialize_into(&mut state, &self).expect("BlockData must be serializable");
        }
        state.finish()
    }
```

**File:** types/src/block_info.rs (L29-44)
```rust
pub struct BlockInfo {
    /// The epoch to which the block belongs.
    epoch: u64,
    /// The consensus protocol is executed in rounds, which monotonically increase per epoch.
    round: Round,
    /// The identifier (hash) of the block.
    id: HashValue,
    /// The accumulator root hash after executing this block.
    executed_state_id: HashValue,
    /// The version of the latest transaction after executing this block.
    version: Version,
    /// The timestamp this block was proposed by a proposer.
    timestamp_usecs: u64,
    /// An optional field containing the next epoch info
    next_epoch_state: Option<EpochState>,
}
```
