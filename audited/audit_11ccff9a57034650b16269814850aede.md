# Audit Report

## Title
Missing Path Validation in SafetyRules OnDiskStorage Configuration Enabling Safety Data Manipulation

## Summary
The `SafetyRulesConfig` lacks path validation for its `OnDiskStorage` backend, allowing absolute paths and relative path traversal (using `../`) to bypass the intended `data_dir` restriction. This enables loading arbitrary `secure-data.json` files containing manipulated `SafetyData`, which can bypass consensus safety checks and allow double-signing or equivocation.

## Finding Description

The `OnDiskStorageConfig::path()` method in the safety rules backend allows both absolute paths and relative paths without proper validation or sanitization: [1](#0-0) 

When the path is absolute, it completely bypasses the `data_dir` restriction by returning the path as-is. When the path is relative, it joins with `data_dir` but doesn't prevent path traversal components like `../`.

The `SafetyRulesConfig::sanitize()` method fails to validate these paths, unlike `StorageConfig` which explicitly enforces absolute path requirements: [2](#0-1) 

Compare this to the proper validation in `StorageConfig`: [3](#0-2) 

**Attack Flow:**

1. An attacker who can influence the validator configuration (via compromised deployment pipelines, config template injection, or supply chain attacks) modifies the `validator.yaml`:
```yaml
consensus:
  safety_rules:
    backend:
      type: "on_disk_storage"
      path: /tmp/malicious-secure-data.json  # Absolute path
      # OR: path: ../../../tmp/malicious-secure-data.json  # Path traversal
```

2. The attacker creates `/tmp/malicious-secure-data.json` containing:
   - Current epoch (e.g., 5) matching the network's epoch
   - Low `last_voted_round` (e.g., 0 or any value lower than previously voted rounds)
   - Valid consensus private key

3. When the validator restarts, it loads this malicious storage via: [4](#0-3) [5](#0-4) 

4. The manipulated `SafetyData` bypasses the first voting rule: [6](#0-5) 

Since `last_voted_round` is artificially low (e.g., 0), the validator can vote again on rounds it previously voted on, causing **equivocation** and **double-signing** - critical consensus safety violations. [7](#0-6) 

## Impact Explanation

**Critical Severity** - This vulnerability violates the **Consensus Safety** invariant and enables:

1. **Double-signing**: A validator can sign multiple conflicting blocks at the same round, violating BFT consensus assumptions
2. **Equivocation**: The validator can vote for different proposals in the same round, potentially causing chain splits
3. **Safety break**: Under Byzantine fault tolerance, equivocation from even a single validator can contribute to consensus safety violations if combined with other malicious behavior

This directly threatens the integrity of the AptosBFT consensus protocol and could lead to:
- Chain splits requiring manual intervention or hardforks
- Loss of funds if conflicting transactions are committed on different forks
- Network partition if validators diverge on which blocks to commit

This meets the **Critical Severity** criteria per the Aptos bug bounty program as a "Consensus/Safety violation".

## Likelihood Explanation

**Likelihood: Medium-to-Low** - The vulnerability requires the attacker to:

1. Influence or modify the validator's configuration file (either through compromised deployment pipelines, config template injection, or supply chain attacks)
2. Know the current epoch to craft matching `SafetyData`
3. Trigger a validator restart to load the malicious configuration

While the vulnerability exists in the code, exploitation requires additional access beyond that of an unprivileged external attacker. However:

- Modern deployment practices use automated config generation (Helm, Terraform) which may be vulnerable to injection attacks
- Supply chain compromises of config management tools are increasingly common
- The code itself provides no defense against this attack, violating defense-in-depth principles
- The inconsistency with `StorageConfig` validation suggests this was an oversight rather than a deliberate design decision

## Recommendation

Add path validation in `SafetyRulesConfig::sanitize()` to enforce security constraints on the `OnDiskStorage` backend path:

```rust
impl ConfigSanitizer for SafetyRulesConfig {
    fn sanitize(
        node_config: &NodeConfig,
        node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();
        let safety_rules_config = &node_config.consensus.safety_rules;

        // If the node is not a validator, there's nothing to be done
        if !node_type.is_validator() {
            return Ok(());
        }

        // Validate OnDiskStorage path configuration
        if let SecureBackend::OnDiskStorage(config) = &safety_rules_config.backend {
            // Reject absolute paths - force use of data_dir
            if config.path.is_absolute() {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    format!(
                        "Safety rules backend path {:?} must be relative to data_dir, not absolute",
                        config.path
                    ),
                ));
            }
            
            // Reject path traversal attempts
            if config.path.components().any(|c| matches!(c, std::path::Component::ParentDir)) {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    format!(
                        "Safety rules backend path {:?} contains path traversal components (..)",
                        config.path
                    ),
                ));
            }
        }

        // Existing validations...
        if let Some(chain_id) = chain_id {
            // ... rest of existing code
        }

        Ok(())
    }
}
```

Additionally, normalize the resolved path in `OnDiskStorageConfig::path()` to prevent any bypasses:

```rust
pub fn path(&self) -> PathBuf {
    let resolved = if self.path.is_relative() {
        self.data_dir.join(&self.path)
    } else {
        self.path.clone()
    };
    
    // Canonicalize to resolve any symlinks or path traversal
    resolved.canonicalize().unwrap_or(resolved)
}
```

## Proof of Concept

```rust
// File: config/src/config/test_safety_rules_path_validation.rs
#[cfg(test)]
mod tests {
    use crate::config::{
        NodeConfig, SafetyRulesConfig, SecureBackend, OnDiskStorageConfig,
        SafetyRulesService, ConfigSanitizer, node_config_loader::NodeType,
        ConsensusConfig, Error,
    };
    use aptos_types::chain_id::ChainId;
    use std::path::PathBuf;

    #[test]
    fn test_absolute_path_rejected_in_safety_rules() {
        // Create a validator config with absolute path in safety rules backend
        let node_config = NodeConfig {
            consensus: ConsensusConfig {
                safety_rules: SafetyRulesConfig {
                    backend: SecureBackend::OnDiskStorage(OnDiskStorageConfig {
                        path: PathBuf::from("/tmp/malicious-secure-data.json"),
                        namespace: None,
                        data_dir: PathBuf::from("/opt/aptos/data"),
                    }),
                    service: SafetyRulesService::Local,
                    ..Default::default()
                },
                ..Default::default()
            },
            ..Default::default()
        };

        // This should fail with the fix
        let result = SafetyRulesConfig::sanitize(
            &node_config,
            NodeType::Validator,
            Some(ChainId::test()),
        );

        // Currently this PASSES (vulnerability), should FAIL with fix
        assert!(result.is_err(), "Absolute paths should be rejected");
        if let Err(Error::ConfigSanitizerFailed(_, msg)) = result {
            assert!(msg.contains("absolute"));
        }
    }

    #[test]
    fn test_path_traversal_rejected_in_safety_rules() {
        // Create a validator config with path traversal in safety rules backend
        let node_config = NodeConfig {
            consensus: ConsensusConfig {
                safety_rules: SafetyRulesConfig {
                    backend: SecureBackend::OnDiskStorage(OnDiskStorageConfig {
                        path: PathBuf::from("../../../tmp/malicious-secure-data.json"),
                        namespace: None,
                        data_dir: PathBuf::from("/opt/aptos/data"),
                    }),
                    service: SafetyRulesService::Local,
                    ..Default::default()
                },
                ..Default::default()
            },
            ..Default::default()
        };

        // This should fail with the fix
        let result = SafetyRulesConfig::sanitize(
            &node_config,
            NodeType::Validator,
            Some(ChainId::test()),
        );

        // Currently this PASSES (vulnerability), should FAIL with fix
        assert!(result.is_err(), "Path traversal should be rejected");
        if let Err(Error::ConfigSanitizerFailed(_, msg)) = result {
            assert!(msg.contains("traversal") || msg.contains(".."));
        }
    }
}
```

## Notes

- This vulnerability exists due to **inconsistent path validation** across the codebase - `StorageConfig` properly validates paths while `SafetyRulesConfig` does not
- The `RootPath` utility has a similar pattern but is not directly used in safety rules configuration
- The vulnerability requires either filesystem access or a separate config injection vulnerability to exploit, making it more of a **defense-in-depth issue** than a directly exploitable remote vulnerability
- However, it represents a **critical security weakness** in the consensus layer that could be exploited through supply chain attacks or deployment pipeline compromises
- The fix aligns safety rules path validation with the existing security practices in `StorageConfig`

### Citations

**File:** config/src/config/secure_backend_config.rs (L140-146)
```rust
    pub fn path(&self) -> PathBuf {
        if self.path.is_relative() {
            self.data_dir.join(&self.path)
        } else {
            self.path.clone()
        }
    }
```

**File:** config/src/config/secure_backend_config.rs (L162-173)
```rust
impl From<&SecureBackend> for Storage {
    fn from(backend: &SecureBackend) -> Self {
        match backend {
            SecureBackend::InMemoryStorage => Storage::from(InMemoryStorage::new()),
            SecureBackend::OnDiskStorage(config) => {
                let storage = Storage::from(OnDiskStorage::new(config.path()));
                if let Some(namespace) = &config.namespace {
                    Storage::from(Namespaced::new(namespace, Box::new(storage)))
                } else {
                    storage
                }
            },
```

**File:** config/src/config/safety_rules_config.rs (L71-117)
```rust
impl ConfigSanitizer for SafetyRulesConfig {
    fn sanitize(
        node_config: &NodeConfig,
        node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();
        let safety_rules_config = &node_config.consensus.safety_rules;

        // If the node is not a validator, there's nothing to be done
        if !node_type.is_validator() {
            return Ok(());
        }

        if let Some(chain_id) = chain_id {
            // Verify that the secure backend is appropriate for mainnet validators
            if chain_id.is_mainnet()
                && node_type.is_validator()
                && safety_rules_config.backend.is_in_memory()
            {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "The secure backend should not be set to in memory storage in mainnet!"
                        .to_string(),
                ));
            }

            // Verify that the safety rules service is set to local for optimal performance
            if chain_id.is_mainnet() && !safety_rules_config.service.is_local() {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    format!("The safety rules service should be set to local in mainnet for optimal performance! Given config: {:?}", &safety_rules_config.service)
                ));
            }

            // Verify that the safety rules test config is not enabled in mainnet
            if chain_id.is_mainnet() && safety_rules_config.test.is_some() {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "The safety rules test config should not be used in mainnet!".to_string(),
                ));
            }
        }

        Ok(())
    }
}
```

**File:** config/src/config/storage_config.rs (L738-746)
```rust
            if let Some(ledger_db_path) = db_path_overrides.ledger_db_path.as_ref() {
                if !ledger_db_path.is_absolute() {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name,
                        format!(
                            "Path {ledger_db_path:?} in db_path_overrides is not an absolute path."
                        ),
                    ));
                }
```

**File:** consensus/safety-rules/src/safety_rules_manager.rs (L21-26)
```rust
pub fn storage(config: &SafetyRulesConfig) -> PersistentSafetyStorage {
    let backend = &config.backend;
    let internal_storage: Storage = backend.into();
    if let Err(error) = internal_storage.available() {
        panic!("Storage is not available: {:?}", error);
    }
```

**File:** consensus/safety-rules/src/safety_rules.rs (L213-232)
```rust
    pub(crate) fn verify_and_update_last_vote_round(
        &self,
        round: Round,
        safety_data: &mut SafetyData,
    ) -> Result<(), Error> {
        if round <= safety_data.last_voted_round {
            return Err(Error::IncorrectLastVotedRound(
                round,
                safety_data.last_voted_round,
            ));
        }

        safety_data.last_voted_round = round;
        trace!(
            SafetyLogSchema::new(LogEntry::LastVotedRound, LogEvent::Update)
                .last_voted_round(safety_data.last_voted_round)
        );

        Ok(())
    }
```

**File:** consensus/consensus-types/src/safety_data.rs (L8-21)
```rust
/// Data structure for safety rules to ensure consensus safety.
#[derive(Debug, Deserialize, Eq, PartialEq, Serialize, Clone, Default)]
pub struct SafetyData {
    pub epoch: u64,
    pub last_voted_round: u64,
    // highest 2-chain round, used for 3-chain
    pub preferred_round: u64,
    // highest 1-chain round, used for 2-chain
    #[serde(default)]
    pub one_chain_round: u64,
    pub last_vote: Option<Vote>,
    #[serde(default)]
    pub highest_timeout_round: u64,
}
```
