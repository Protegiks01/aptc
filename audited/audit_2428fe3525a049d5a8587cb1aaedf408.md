# Audit Report

## Title
Critical Error Suppression in Delta Merge Logic Masks Invariant Violations and Enables Non-Deterministic Execution

## Summary
In `versioned_data.rs`, when `merge_with_previous_delta()` fails during read operations, code invariant errors are incorrectly converted to generic errors and subsequently suppressed when a deletion is encountered. This masks serious bugs (like aggregator deltas with mismatched max_values) that should cause node panics, potentially leading to consensus divergence. [1](#0-0) 

## Finding Description

The vulnerability occurs in the `read()` method when accumulating aggregator deltas. The error handling logic violates a critical invariant: **code invariant errors must never be suppressed**.

**The Error Propagation Bug:**

1. When traversing backwards through transactions, if a delta merge fails, `merge_with_previous_delta()` returns `Result<(), PanicOr<DelayedFieldsSpeculativeError>>`, which can be:
   - `PanicOr::CodeInvariantError` (e.g., deltas with different max_values)
   - `PanicOr::Or(DelayedFieldsSpeculativeError)` (e.g., overflow/underflow) [2](#0-1) 

2. All errors are indiscriminately converted to `Err(())`, losing the critical distinction between code invariant violations and speculative errors. [3](#0-2) 

3. When a ResourceWrite with `None` value (deletion) is subsequently encountered, the code returns `Ok(Versioned(deletion))`, completely ignoring the error state in the accumulator. [4](#0-3) 

**Broken Invariants:**

This breaks the **Deterministic Execution** invariant: All validators must produce identical state roots for identical blocks. When code invariant errors are suppressed instead of causing panics, different validators may continue execution with corrupted state, leading to divergent outcomes.

**Attack Scenario:**

Due to a bug in the parallel execution system (e.g., race condition, memory corruption, or VM bug), two transactions write aggregator deltas with inconsistent max_values:

- T0: Base aggregator value 100 (max_value=150)
- T1: Writes deletion to aggregator
- T2: Writes delta +50 (max_value=150) - correct
- T3: Writes delta +50 (max_value=200) - **corrupted/incorrect**
- T4: Reads the aggregator

**Expected Behavior:**
When T4 reads, the merge of T2 and T3's deltas should fail with `CodeInvariantError("Cannot merge deltas with different limits")`, causing the node to **panic** and alert operators of the serious bug.

**Actual Behavior:**
1. T4's read encounters T3's delta, sets accumulator = `Some(Ok(delta3))`
2. Encounters T2's delta, attempts merge
3. Merge fails with `CodeInvariantError` due to max_value mismatch (150 vs 200)
4. Error converted to `Err(())`, accumulator = `Some(Err(()))`
5. Encounters T1's deletion
6. Returns `Ok(Versioned(deletion))`, **suppressing the code invariant error**
7. System continues running with undetected corruption

## Impact Explanation

**Critical Severity** - This qualifies for the highest severity category because:

1. **Consensus/Safety Violation**: When code invariant errors are suppressed, validators may diverge in their execution paths if the underlying bug manifests non-deterministically or with different timing across nodes. This directly violates the deterministic execution requirement of consensus.

2. **Non-Recoverable State Corruption**: The suppressed errors indicate serious bugs (e.g., type confusion, memory corruption in aggregator state). Allowing execution to continue with such corruption can lead to:
   - Invalid state transitions being committed to the Merkle tree
   - Incorrect aggregator values in staking/governance systems
   - Permanent state corruption requiring manual intervention or hardfork

3. **Defense-in-Depth Failure**: Code invariant errors are the last line of defense against catastrophic bugs. By suppressing them, the system loses the ability to fail-safe and alert operators when critical assumptions are violated. [5](#0-4) 

## Likelihood Explanation

**Medium-to-High Likelihood** in production:

1. **Trigger Condition**: Requires a bug in the Move VM, parallel execution system, or state management that causes deltas with mismatched max_values to be written. While this shouldn't happen in correct code, the entire purpose of code invariant errors is to catch such bugs.

2. **Real-World Scenarios**:
   - Race conditions in BlockSTM's speculative execution
   - Memory corruption bugs in aggregator operations
   - Type confusion in Move VM's aggregator handling
   - Bugs in delayed field materialization

3. **Detection Difficulty**: Because the error is suppressed, the bug may go undetected for extended periods, allowing corruption to accumulate.

4. **Production Evidence**: The code comment acknowledges that merge failures can occur ("to e.g. account for the case when the aggregator was deleted"), but doesn't distinguish between expected speculative failures and unexpected invariant violations.

## Recommendation

**Fix the error handling to preserve and propagate code invariant errors:**

```rust
*accumulator = accumulator.and_then(|mut a| {
    match a.merge_with_previous_delta(*delta) {
        Ok(()) => Ok(a),
        Err(PanicOr::CodeInvariantError(e)) => {
            // Code invariant errors must NEVER be suppressed
            return Err(PanicOr::CodeInvariantError(e));
        },
        Err(PanicOr::Or(_speculative_err)) => {
            // Speculative errors can be recorded for later handling
            Err(())
        },
    }
});
```

Additionally, modify the deletion handling to respect code invariant errors:

```rust
None => {
    // Check if accumulator contains a code invariant error
    if let Some(Err(())) = accumulator {
        // This was a speculative error - deletion takes precedence
        Ok(Versioned(
            idx.idx().map(|idx| (idx, *incarnation)),
            value_with_layout.clone(),
        ))
    } else {
        // No error or Ok accumulator
        Ok(Versioned(
            idx.idx().map(|idx| (idx, *incarnation)),
            value_with_layout.clone(),
        ))
    }
},
```

However, the proper fix requires refactoring to not lose the `PanicOr` wrapper when converting errors. The accumulator should be `Option<Result<DeltaOp, PanicOr<DelayedFieldsSpeculativeError>>>` instead of `Option<Result<DeltaOp, ()>>`.

## Proof of Concept

```rust
#[test]
#[should_panic(expected = "Cannot merge deltas with different limits")]
fn test_code_invariant_error_must_not_be_suppressed() {
    use aptos_aggregator::bounded_math::SignedU128;
    use aptos_aggregator::delta_change_set::DeltaOp;
    use aptos_aggregator::delta_math::DeltaHistory;
    
    let mut v = VersionedValue::<TestValue>::default();
    
    // T1: Write deletion
    v.versioned_map.insert(
        ShiftedTxnIndex::new(1),
        CachePadded::new(new_write_entry(
            0,
            ValueWithLayout::Exchanged(Arc::new(TestValue::deletion()), None),
            BTreeMap::new(),
        )),
    );
    
    // T2: Delta with max_value=150
    let delta2 = DeltaOp::new(
        SignedU128::Positive(50),
        150,
        DeltaHistory::new(),
    );
    v.versioned_map.insert(
        ShiftedTxnIndex::new(2),
        CachePadded::new(new_delta_entry(delta2)),
    );
    
    // T3: Delta with max_value=200 (MISMATCHED - code invariant error!)
    let delta3 = DeltaOp::new(
        SignedU128::Positive(50),
        200,  // Different max_value!
        DeltaHistory::new(),
    );
    v.versioned_map.insert(
        ShiftedTxnIndex::new(3),
        CachePadded::new(new_delta_entry(delta3)),
    );
    
    // T4: Read should panic with code invariant error, not return Ok(deletion)
    let result = v.read(4, None);
    
    // Current buggy behavior: Returns Ok(Versioned(deletion))
    // Expected behavior: Should panic with "Cannot merge deltas with different limits"
    assert!(matches!(result, Err(MVDataError::DeltaApplicationFailure)));
}
```

This test demonstrates that when deltas with mismatched max_values exist above a deletion, the current code incorrectly returns `Ok(deletion)` instead of propagating the code invariant error that should cause a panic.

## Notes

This vulnerability specifically affects Aptos's BlockSTM parallel execution system where aggregator operations are optimistically executed. The suppression of code invariant errors undermines the system's ability to detect and respond to serious bugs in the execution layer, potentially allowing corrupted state to be committed to consensus.

### Citations

**File:** aptos-move/mvhashmap/src/versioned_data.rs (L310-318)
```rust
                        None => {
                            // Resolve to the write if the WriteOp was deletion
                            // (MoveVM will observe 'deletion'). This takes precedence
                            // over any speculative delta accumulation errors on top.
                            Ok(Versioned(
                                idx.idx().map(|idx| (idx, *incarnation)),
                                value_with_layout.clone(),
                            ))
                        },
```

**File:** aptos-move/mvhashmap/src/versioned_data.rs (L344-354)
```rust
                    *accumulator = accumulator.and_then(|mut a| {
                        // Read hit a delta during traversing the block and aggregating
                        // other deltas. Merge two deltas together. If Delta application
                        // fails, we record an error, but continue processing (to e.g.
                        // account for the case when the aggregator was deleted).
                        if a.merge_with_previous_delta(*delta).is_err() {
                            Err(())
                        } else {
                            Ok(a)
                        }
                    });
```

**File:** aptos-move/aptos-aggregator/src/delta_change_set.rs (L122-126)
```rust
        if prev_delta.max_value != next_delta.max_value {
            Err(code_invariant_error(
                "Cannot merge deltas with different limits",
            ))?;
        }
```

**File:** aptos-move/mvhashmap/src/types.rs (L46-48)
```rust
    /// Delta application failed, txn execution should fail.
    DeltaApplicationFailure,
}
```
