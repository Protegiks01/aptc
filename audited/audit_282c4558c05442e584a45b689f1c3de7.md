# Audit Report

## Title
File Descriptor Exhaustion via Untracked Pending Connection Attempts in PeerManager

## Summary
The PeerManager's `dial_peer()` function lacks tracking of pending outbound connection attempts, allowing multiple concurrent dial operations to the same peer to exhaust operating system file descriptors and cause validator node crashes.

## Finding Description

The vulnerability exists in the connection management layer of Aptos validators. When `ConnectionRequestSender::dial_peer()` is called, the request flows through PeerManager's `handle_outbound_connection_request()` function, which only checks if a peer is **already connected** before initiating a new connection attempt. [1](#0-0) 

The critical flaw is that PeerManager does not maintain an `outstanding_dial_requests` map (unlike disconnect operations which have `outstanding_disconnect_requests`). This means: [2](#0-1) 

When multiple rapid `dial_peer()` calls target the same peer before any connection completes:
1. All requests pass the "already connected" check at line 434
2. Each creates a `TransportRequest::DialPeer` sent to TransportHandler
3. TransportHandler calls `transport.dial()` for each request
4. Each dial immediately allocates a TCP socket (file descriptor) [3](#0-2) 

The TCP socket creation happens synchronously in `TcpSocket::new_v4()` or `new_v6()`, consuming a file descriptor for each attempt. With the connection request channel having a default capacity of 1024: [4](#0-3) [5](#0-4) 

An attacker can queue up to 1024 dial requests. Each allocates a file descriptor that remains open for the 30-second transport timeout: [6](#0-5) 

**Attack Scenario**: While the `ConnectionRequestSender` API is internal, a logic bug in a network component (such as a peer discovery protocol race condition or message handling error) could trigger rapid dial attempts. If 1000+ dial requests are processed targeting slow or unreachable peers, the validator exhausts its file descriptor limit (typically 1024-65536 per process), causing:
- Inability to accept new connections
- Failure to open files for consensus operations
- Validator crash or freeze

## Impact Explanation

**Severity: High** (Validator node slowdowns/crashes)

This vulnerability can cause **validator node unavailability**, which directly impacts network liveness. While it doesn't violate consensus safety (blocks already committed remain valid), it breaks the availability guarantee critical for AptosBFT consensus. A validator unable to open connections cannot:
- Participate in consensus voting
- Receive blocks from other validators  
- Respond to state sync requests

The impact is **High** rather than Critical because:
- It requires triggering rapid internal dial_peer() calls (not directly accessible to external attackers)
- Only affects individual validators, not the entire network
- Recovery is possible by restarting the node

However, if exploitable during critical network operations (epoch changes, governance votes), this could cause significant disruption.

## Likelihood Explanation

**Likelihood: Medium-Low**

While the vulnerability exists in production code, exploitation requires:
1. A component bug or race condition that bypasses ConnectivityManager's rate limiting
2. Or a compromised internal component with access to ConnectionRequestSender

The ConnectivityManager, which is the primary dial_peer() caller, implements time-based backoff protection that partially mitigates this issue. However, the PeerManager layer lacks defensive protections, violating the principle of defense-in-depth.

Edge cases that could trigger this:
- Peer discovery protocol bugs causing duplicate dial attempts
- Race conditions in connection state management
- Malicious or buggy network middleware components

## Recommendation

Implement pending dial request tracking in PeerManager to prevent duplicate concurrent dials to the same peer:

```rust
// In PeerManager struct, add:
outstanding_dial_requests: HashMap<PeerId, oneshot::Sender<Result<(), PeerManagerError>>>,

// In handle_outbound_connection_request():
ConnectionRequest::DialPeer(requested_peer_id, addr, response_tx) => {
    // Check if already connected OR dial in progress
    if let Some((curr_connection, _)) = self.active_peers.get(&requested_peer_id) {
        let error = PeerManagerError::AlreadyConnected(curr_connection.addr.clone());
        // ... existing error handling ...
    } else if self.outstanding_dial_requests.contains_key(&requested_peer_id) {
        // Dial already in progress
        let error = PeerManagerError::DialInProgress(requested_peer_id);
        if let Err(_) = response_tx.send(Err(error)) {
            // Log error
        }
    } else {
        // Track this dial attempt
        self.outstanding_dial_requests.insert(requested_peer_id, response_tx.clone());
        
        // Send dial request
        let request = TransportRequest::DialPeer(requested_peer_id, addr, response_tx);
        self.transport_reqs_tx.send(request).await.unwrap();
    }
}

// Clean up on connection completion or failure
// In handle_connection_event(), remove from outstanding_dial_requests when connection succeeds/fails
```

Additionally, implement a global limit on concurrent outbound dial attempts (e.g., max 100 concurrent dials) to prevent resource exhaustion even with different target peers.

## Proof of Concept

```rust
// Reproduction steps (requires access to internal APIs in test environment):

#[tokio::test]
async fn test_dial_peer_fd_exhaustion() {
    // Setup test PeerManager
    let (connection_reqs_tx, mut connection_reqs_rx) = 
        aptos_channel::new(QueueStyle::FIFO, 1024, None);
    let sender = ConnectionRequestSender::new(connection_reqs_tx);
    
    // Target an unreachable peer
    let target_peer = PeerId::random();
    let unreachable_addr = NetworkAddress::from_str("/ip4/192.0.2.1/tcp/6180").unwrap();
    
    // Spawn 1000 concurrent dial attempts
    let mut handles = vec![];
    for _ in 0..1000 {
        let sender = sender.clone();
        let peer = target_peer;
        let addr = unreachable_addr.clone();
        
        let handle = tokio::spawn(async move {
            sender.dial_peer(peer, addr).await
        });
        handles.push(handle);
    }
    
    // All dials will attempt to open TCP sockets concurrently
    // This would exhaust file descriptors in a real scenario
    
    // Monitor /proc/self/fd/ or ulimit to observe FD exhaustion
    // Expected: Node crashes or becomes unresponsive
}
```

**Notes:**
- This vulnerability exists but requires specific conditions to exploit
- ConnectivityManager's rate limiting provides partial protection for normal operations
- The lack of defensive checks at the PeerManager layer violates defense-in-depth principles
- Production validators should monitor file descriptor usage and set appropriate ulimits as mitigation

### Citations

**File:** network/framework/src/peer_manager/mod.rs (L106-108)
```rust
    /// A map of outstanding disconnect requests.
    outstanding_disconnect_requests:
        HashMap<ConnectionId, oneshot::Sender<Result<(), PeerManagerError>>>,
```

**File:** network/framework/src/peer_manager/mod.rs (L432-466)
```rust
            ConnectionRequest::DialPeer(requested_peer_id, addr, response_tx) => {
                // Only dial peers which we aren't already connected with
                if let Some((curr_connection, _)) = self.active_peers.get(&requested_peer_id) {
                    let error = PeerManagerError::AlreadyConnected(curr_connection.addr.clone());
                    debug!(
                        NetworkSchema::new(&self.network_context)
                            .connection_metadata_with_address(curr_connection),
                        "{} Already connected to Peer {} with connection {:?}. Not dialing address {}",
                        self.network_context,
                        requested_peer_id.short_str(),
                        curr_connection,
                        addr
                    );
                    if let Err(send_err) = response_tx.send(Err(error)) {
                        info!(
                            NetworkSchema::new(&self.network_context)
                                .remote_peer(&requested_peer_id),
                            "{} Failed to notify that peer is already connected for Peer {}: {:?}",
                            self.network_context,
                            requested_peer_id.short_str(),
                            send_err
                        );
                    }
                } else {
                    // Update the connection dial metrics
                    counters::update_network_connection_operation_metrics(
                        &self.network_context,
                        counters::DIAL_LABEL.into(),
                        counters::DIAL_PEER_LABEL.into(),
                    );

                    // Send a transport request to dial the peer
                    let request = TransportRequest::DialPeer(requested_peer_id, addr, response_tx);
                    self.transport_reqs_tx.send(request).await.unwrap();
                };
```

**File:** network/netcore/src/transport/tcp.rs (L206-210)
```rust
    let socket = if addr.is_ipv4() {
        tokio::net::TcpSocket::new_v4()?
    } else {
        tokio::net::TcpSocket::new_v6()?
    };
```

**File:** config/src/config/network_config.rs (L37-37)
```rust
pub const NETWORK_CHANNEL_SIZE: usize = 1024;
```

**File:** network/framework/src/peer_manager/builder.rs (L183-184)
```rust
        let (connection_reqs_tx, connection_reqs_rx) =
            aptos_channel::new(QueueStyle::FIFO, channel_size, None);
```

**File:** network/framework/src/transport/mod.rs (L40-41)
```rust
/// A timeout for the connection to open and complete all of the upgrade steps.
pub const TRANSPORT_TIMEOUT: Duration = Duration::from_secs(30);
```
