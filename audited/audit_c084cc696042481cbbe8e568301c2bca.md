# Audit Report

## Title
Time-of-Check-Time-of-Use (TOCTOU) Vulnerability in Noise Handshake Authentication Allows Stale Peer Connections

## Summary
A race condition exists between reading trusted peers during handshake authentication and updating the trusted peer set. This allows peers who have been removed from the trusted peer set (due to validator removal, key rotation, or epoch changes) to establish connections that persist for up to 5 seconds before being detected and closed.

## Finding Description

The Aptos network layer uses Noise protocol handshakes with trusted peer authentication. During the inbound handshake process, the authenticating node reads a snapshot of the trusted peers from `PeersAndMetadata` to validate the connecting peer's credentials. [1](#0-0) 

The trusted peers are stored using `ArcSwap` for lock-free atomic reads: [2](#0-1) 

When trusted peers are updated (e.g., during epoch changes or validator set updates), the connectivity manager calls `set_trusted_peers()` followed by periodic `close_stale_connections()` checks: [3](#0-2) 

However, `close_stale_connections()` runs on a periodic timer with a default interval of 5 seconds: [4](#0-3) [5](#0-4) 

**The Race Condition**:

1. **T0**: Handshake begins, node reads trusted peers snapshot (peer X is included)
2. **T1**: Trusted peers are updated via `set_trusted_peers()` (peer X is removed)
3. **T2**: Handshake authentication completes using the stale snapshot from T0 (X passes authentication)
4. **T3**: Connection is established, NewPeer notification sent
5. **T4**: Connectivity manager's periodic check hasn't run yet
6. **T5**: Up to 5 seconds elapse before next `close_stale_connections()` call
7. **T6**: Connection is finally detected as stale and closed

During the window between T3 and T6, the removed peer can send network messages despite no longer being in the trusted peer set.

**Attack Scenario**:

An attacker who knows their validator is being removed (by monitoring on-chain epoch changes) or whose key is being rotated can:

1. Initiate multiple concurrent handshakes to victim validators immediately before the trusted peer update
2. Time the handshakes to complete during/after the trusted peer update but before `close_stale_connections()` runs
3. Gain 0-5 seconds of authenticated network access per victim node
4. Send malicious or resource-intensive messages during this window

While consensus messages are protected by separate cryptographic verification via `ValidatorVerifier`: [6](#0-5) 

Non-consensus network messages are routed to upstream handlers without re-checking current trusted peer status: [7](#0-6) 

## Impact Explanation

**Severity: High**

This vulnerability enables:

1. **Temporary Authentication Bypass**: Removed validators or peers with rotated keys can maintain brief authenticated connections
2. **Resource Exhaustion**: An attacker can flood victims with messages during the 0-5 second window, causing CPU/memory/bandwidth exhaustion
3. **Protocol Violation**: The network layer's security invariant that "only currently trusted peers can maintain connections" is violated
4. **Amplification Attack**: An attacker can target multiple validators simultaneously, amplifying the impact

While consensus safety is protected by defense-in-depth (ValidatorVerifier), the network layer authentication bypass can cause:
- **Validator node slowdowns** (High severity per bug bounty)
- Processing overhead from handling and rejecting malicious messages
- Potential triggering of edge cases in message handling code
- Network bandwidth exhaustion

The 5-second window is significant in a high-performance blockchain context where thousands of messages can be exchanged. An attacker with timing knowledge (monitoring on-chain state) can reliably exploit this window.

## Likelihood Explanation

**Likelihood: Medium-High**

The attack requires:
- **Timing knowledge**: Attacker must monitor on-chain state to detect epoch changes or key rotations (publicly observable)
- **Network access**: Attacker must be able to initiate handshakes (available to any removed validator)
- **Concurrent handshakes**: Attacker can improve success rate by initiating multiple handshakes

The attack is **practically feasible** because:
- Epoch changes are predictable and publicly observable on-chain
- The 5-second connectivity check interval provides a reliable exploitation window
- No special privileges are required beyond having previously been a trusted peer
- The attack can target multiple nodes simultaneously

## Recommendation

**Immediate Fix**: Synchronize trusted peer updates with active connection validation.

**Option 1 - Atomic Close on Update** (Recommended):
Modify `set_trusted_peers()` to immediately trigger `close_stale_connections()` synchronously before returning:

```rust
pub fn set_trusted_peers(
    &self,
    network_id: &NetworkId,
    trusted_peer_set: PeerSet,
) -> Result<(), Error> {
    let trusted_peers = self.get_trusted_peer_set_for_network(network_id)?;
    trusted_peers.store(Arc::new(trusted_peer_set));
    
    // Immediately notify connectivity manager to close stale connections
    // This requires adding a callback mechanism or event
    self.notify_trusted_peers_updated(network_id)?;
    
    Ok(())
}
```

**Option 2 - Double-Check on Connection Establishment**:
Add a verification step when establishing connections to re-check trusted peers:

```rust
// In upgrade_inbound() after authentication but before returning
let current_trusted_peers = peers_and_metadata.get_trusted_peers(&network_id)?;
if !current_trusted_peers.contains_key(&remote_peer_id) {
    return Err(NoiseHandshakeError::PeerRemovedDuringHandshake(remote_peer_short));
}
```

**Option 3 - Versioned Trusted Peers**:
Add a version counter to trusted peers and verify it hasn't changed during the handshake:

```rust
let (trusted_peers, version) = peers_and_metadata.get_trusted_peers_with_version(&network_id)?;
// ... perform authentication ...
if !peers_and_metadata.verify_version(&network_id, version)? {
    return Err(NoiseHandshakeError::TrustedPeersChangedDuringHandshake(remote_peer_short));
}
```

## Proof of Concept

```rust
#[tokio::test]
async fn test_stale_peer_connection_race() {
    use std::sync::Arc;
    use std::time::Duration;
    use tokio::time::sleep;
    
    // Setup: Create two nodes with mutual authentication
    let network_ids = vec![NetworkId::Validator];
    let peers_and_metadata = PeersAndMetadata::new(&network_ids);
    
    // Add validator X to trusted peers
    let mut trusted_peers = PeerSet::new();
    let validator_x_key = x25519::PrivateKey::generate(&mut rand::rngs::OsRng);
    let validator_x_pubkey = validator_x_key.public_key();
    let validator_x_peer_id = PeerId::random();
    
    trusted_peers.insert(
        validator_x_peer_id,
        Peer::new(vec![], [validator_x_pubkey].into_iter().collect(), PeerRole::Validator)
    );
    peers_and_metadata.set_trusted_peers(&NetworkId::Validator, trusted_peers.clone()).unwrap();
    
    // Create victim node
    let victim_key = x25519::PrivateKey::generate(&mut rand::rngs::OsRng);
    let victim_context = NetworkContext::mock();
    let victim_upgrader = NoiseUpgrader::new(
        victim_context,
        victim_key,
        HandshakeAuthMode::mutual(peers_and_metadata.clone())
    );
    
    // Start handshake from validator X
    let (dialer_socket, listener_socket) = MemorySocket::new_pair();
    
    let handshake_task = tokio::spawn(async move {
        victim_upgrader.upgrade_inbound(listener_socket).await
    });
    
    // Simulate small delay for handshake to progress
    sleep(Duration::from_millis(10)).await;
    
    // REMOVE validator X from trusted peers while handshake is in progress
    let empty_peers = PeerSet::new();
    peers_and_metadata.set_trusted_peers(&NetworkId::Validator, empty_peers).unwrap();
    
    // Complete the handshake from validator X's side
    let client_upgrader = NoiseUpgrader::new(
        NetworkContext::mock_with_peer_id(validator_x_peer_id),
        validator_x_key,
        HandshakeAuthMode::mutual(peers_and_metadata.clone())
    );
    
    let client_result = client_upgrader.upgrade_outbound(
        dialer_socket,
        victim_context.peer_id(),
        victim_upgrader.noise_config.public_key(),
        AntiReplayTimestamps::now
    ).await;
    
    let server_result = handshake_task.await.unwrap();
    
    // VULNERABILITY: Handshake succeeds even though X was removed from trusted peers
    assert!(client_result.is_ok(), "Client handshake should succeed");
    assert!(server_result.is_ok(), "Server handshake should succeed despite peer removal");
    
    // The connection is now established with a peer that's no longer trusted
    // It will remain connected for up to 5 seconds until close_stale_connections() runs
    println!("VULNERABILITY DEMONSTRATED: Removed validator successfully connected!");
}
```

## Notes

This vulnerability represents a **synchronization failure between security layers**. While the defense-in-depth approach (ValidatorVerifier for consensus, proofs for state sync) prevents the most severe impacts, the network layer authentication bypass still enables resource exhaustion attacks and protocol violations during validator set transitions.

The 5-second connectivity check interval provides a reliable exploitation window that attackers can target during predictable on-chain events (epoch changes, key rotations). The fix requires either synchronous validation on trusted peer updates or re-verification during connection establishment.

### Citations

**File:** network/framework/src/noise/handshake.rs (L368-427)
```rust
        let peer_role = match &self.auth_mode {
            HandshakeAuthMode::Mutual {
                peers_and_metadata, ..
            } => {
                let trusted_peers = peers_and_metadata.get_trusted_peers(&network_id)?;
                let trusted_peer = trusted_peers.get(&remote_peer_id).cloned();
                match trusted_peer {
                    Some(peer) => {
                        Self::authenticate_inbound(remote_peer_short, &peer, &remote_public_key)
                    },
                    None => Err(NoiseHandshakeError::UnauthenticatedClient(
                        remote_peer_short,
                        remote_peer_id,
                    )),
                }
            },
            HandshakeAuthMode::MaybeMutual(peers_and_metadata) => {
                let trusted_peers = peers_and_metadata.get_trusted_peers(&network_id)?;
                let trusted_peer = trusted_peers.get(&remote_peer_id).cloned();
                match trusted_peer {
                    Some(peer) => {
                        Self::authenticate_inbound(remote_peer_short, &peer, &remote_public_key)
                    },
                    None => {
                        // The peer is not in the trusted peer set. Verify that the Peer ID is
                        // constructed correctly from the public key.
                        let derived_remote_peer_id =
                            aptos_types::account_address::from_identity_public_key(
                                remote_public_key,
                            );
                        if derived_remote_peer_id != remote_peer_id {
                            // The peer ID is not constructed correctly from the public key
                            Err(NoiseHandshakeError::ClientPeerIdMismatch(
                                remote_peer_short,
                                remote_peer_id,
                                derived_remote_peer_id,
                            ))
                        } else {
                            // Try to infer the role from the network context
                            if self.network_context.role().is_validator() {
                                if network_id.is_vfn_network() {
                                    // Inbound connections to validators on the VFN network must be VFNs
                                    Ok(PeerRole::ValidatorFullNode)
                                } else {
                                    // Otherwise, they're unknown. Validators will connect through
                                    // authenticated channels (on the validator network) so shouldn't hit
                                    // this, and PFNs will connect on public networks (which aren't common).
                                    Ok(PeerRole::Unknown)
                                }
                            } else {
                                // We're a VFN or PFN. VFNs get no inbound connections on the vfn network
                                // (so the peer won't be a validator). Thus, we're on the public network
                                // so mark the peer as unknown.
                                Ok(PeerRole::Unknown)
                            }
                        }
                    },
                }
            },
        }?;
```

**File:** network/framework/src/application/storage.rs (L42-54)
```rust
pub struct PeersAndMetadata {
    peers_and_metadata: RwLock<HashMap<NetworkId, HashMap<PeerId, PeerMetadata>>>,
    trusted_peers: HashMap<NetworkId, Arc<ArcSwap<PeerSet>>>,

    // We maintain a cached copy of the peers and metadata. This is useful to
    // reduce lock contention, as we expect very heavy and frequent reads,
    // but infrequent writes. The cache is updated on all underlying updates.
    //
    // TODO: should we remove this when generational versioning is supported?
    cached_peers_and_metadata: Arc<ArcSwap<HashMap<NetworkId, HashMap<PeerId, PeerMetadata>>>>,

    subscribers: Mutex<Vec<tokio::sync::mpsc::Sender<ConnectionNotification>>>,
}
```

**File:** network/framework/src/connectivity_manager/mod.rs (L484-531)
```rust
    async fn close_stale_connections(&mut self) {
        if let Some(trusted_peers) = self.get_trusted_peers() {
            // Identify stale peer connections
            let stale_peers = self
                .connected
                .iter()
                .filter(|(peer_id, _)| !trusted_peers.contains_key(peer_id))
                .filter_map(|(peer_id, metadata)| {
                    // If we're using server only auth, we need to not evict unknown peers
                    // TODO: We should prevent `Unknown` from discovery sources
                    if !self.mutual_authentication
                        && metadata.origin == ConnectionOrigin::Inbound
                        && (metadata.role == PeerRole::ValidatorFullNode
                            || metadata.role == PeerRole::Unknown)
                    {
                        None
                    } else {
                        Some(*peer_id) // The peer is stale
                    }
                });

            // Close existing connections to stale peers
            for stale_peer in stale_peers {
                info!(
                    NetworkSchema::new(&self.network_context).remote_peer(&stale_peer),
                    "{} Closing stale connection to peer {}",
                    self.network_context,
                    stale_peer.short_str()
                );

                if let Err(disconnect_error) = self
                    .connection_reqs_tx
                    .disconnect_peer(stale_peer, DisconnectReason::StaleConnection)
                    .await
                {
                    info!(
                        NetworkSchema::new(&self.network_context)
                            .remote_peer(&stale_peer),
                        error = %disconnect_error,
                        "{} Failed to close stale connection to peer {}, error: {}",
                        self.network_context,
                        stale_peer.short_str(),
                        disconnect_error
                    );
                }
            }
        }
    }
```

**File:** network/framework/src/connectivity_manager/mod.rs (L991-1001)
```rust
            if let Err(error) = self
                .peers_and_metadata
                .set_trusted_peers(&self.network_context.network_id(), new_eligible)
            {
                error!(
                    NetworkSchema::new(&self.network_context),
                    error = %error,
                    "Failed to update trusted peers set"
                );
            }
        }
```

**File:** config/src/config/network_config.rs (L41-41)
```rust
pub const CONNECTIVITY_CHECK_INTERVAL_MS: u64 = 5000;
```

**File:** consensus/consensus-types/src/vote_msg.rs (L56-81)
```rust
    pub fn verify(&self, sender: Author, validator: &ValidatorVerifier) -> anyhow::Result<()> {
        ensure!(
            self.vote().author() == sender,
            "Vote author {:?} is different from the sender {:?}",
            self.vote().author(),
            sender,
        );
        ensure!(
            self.vote().epoch() == self.sync_info.epoch(),
            "VoteMsg has different epoch"
        );
        ensure!(
            self.vote().vote_data().proposed().round() > self.sync_info.highest_round(),
            "Vote Round should be higher than SyncInfo"
        );
        if let Some((timeout, _)) = self.vote().two_chain_timeout() {
            ensure!(
                timeout.hqc_round() <= self.sync_info.highest_certified_round(),
                "2-chain Timeout hqc should be less or equal than the sync info hqc"
            );
        }
        // We're not verifying SyncInfo here yet: we are going to verify it only in case we need
        // it. This way we avoid verifying O(n) SyncInfo messages while aggregating the votes
        // (O(n^2) signature verifications).
        self.vote().verify(validator)
    }
```

**File:** network/framework/src/peer/mod.rs (L447-492)
```rust
    fn handle_inbound_network_message(
        &mut self,
        message: NetworkMessage,
    ) -> Result<(), PeerManagerError> {
        match &message {
            NetworkMessage::DirectSendMsg(direct) => {
                let data_len = direct.raw_msg.len();
                network_application_inbound_traffic(
                    self.network_context,
                    direct.protocol_id,
                    data_len as u64,
                );
                match self.upstream_handlers.get(&direct.protocol_id) {
                    None => {
                        counters::direct_send_messages(&self.network_context, UNKNOWN_LABEL).inc();
                        counters::direct_send_bytes(&self.network_context, UNKNOWN_LABEL)
                            .inc_by(data_len as u64);
                    },
                    Some(handler) => {
                        let key = (self.connection_metadata.remote_peer_id, direct.protocol_id);
                        let sender = self.connection_metadata.remote_peer_id;
                        let network_id = self.network_context.network_id();
                        let sender = PeerNetworkId::new(network_id, sender);
                        match handler.push(key, ReceivedMessage::new(message, sender)) {
                            Err(_err) => {
                                // NOTE: aptos_channel never returns other than Ok(()), but we might switch to tokio::sync::mpsc and then this would work
                                counters::direct_send_messages(
                                    &self.network_context,
                                    DECLINED_LABEL,
                                )
                                .inc();
                                counters::direct_send_bytes(&self.network_context, DECLINED_LABEL)
                                    .inc_by(data_len as u64);
                            },
                            Ok(_) => {
                                counters::direct_send_messages(
                                    &self.network_context,
                                    RECEIVED_LABEL,
                                )
                                .inc();
                                counters::direct_send_bytes(&self.network_context, RECEIVED_LABEL)
                                    .inc_by(data_len as u64);
                            },
                        }
                    },
                }
```
