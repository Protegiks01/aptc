# Audit Report

## Title
Storage Pricing Bypass via Key Size Manipulation After Price Increases (V2 DiskSpacePricing)

## Summary
The V2 storage pricing mechanism contains a critical flaw where users can lock in low storage prices for the key portion of state items when `storage_fee_per_state_byte` is low, then retain that subsidized storage even after governance increases prices. This allows users to hold storage at significantly below-market rates, violating the protocol's storage pricing invariants.

## Finding Description

The vulnerability exists in the `charge_refund_write_op_v2` function's modification logic. [1](#0-0) 

The bytes deposit calculation includes both key size and value size: [2](#0-1) 

However, when calculating charges for modifications, only the value size delta is considered: [3](#0-2) 

**Attack Path:**

1. **Attacker creates state items with large keys when storage price is LOW** (e.g., `storage_fee_per_state_byte = 1`)
   - Example: Create TableItem with 1000-byte key and 10-byte value
   - Initial deposit: (1000 + 10) × 1 = 1,010 units

2. **Governance increases storage price** (e.g., `storage_fee_per_state_byte = 100`)
   - This happens through the storage gas configuration system [4](#0-3) 

3. **Attacker grows value incrementally**
   - Grow value from 10 to 20 bytes:
     - `target_bytes_deposit` = (1000 + 20) × 100 = 102,000
     - `charge_by_increase` = (20 - 10) × 100 = 1,000
     - `gap_from_target` = 102,000 - 1,010 = 100,990
     - `actual_charge` = min(1,000, 100,990) = 1,000
     - New deposit: 1,010 + 1,000 = 2,010

4. **Result:** Attacker occupies 1,020 bytes (1000 key + 20 value) but has only paid 2,010 units instead of the fair market rate of 102,000 units - a **98% discount**.

The key insight is that `charge_by_increase` only accounts for `(write_len - prev_size)`, which is the value size delta, and never reprices the immutable key portion when prices increase. [5](#0-4) 

StateKeys can be large (up to several KB for table items and access paths), making this attack practical. [6](#0-5) 

## Impact Explanation

**Medium Severity** - This vulnerability enables:

1. **Storage Pricing Manipulation:** Users can circumvent the intended storage pricing mechanism by locking in low prices for large portions of their state items (the key component).

2. **Resource Exhaustion Vector:** Attackers can occupy large amounts of blockchain storage at heavily subsidized rates, violating the "Resource Limits" invariant that all operations must respect storage costs.

3. **Economic Imbalance:** Creates unfair advantage where early users who created state before price increases pay dramatically less than current users for equivalent storage.

4. **Governance Effectiveness Reduced:** When governance increases storage prices to reduce usage or cover costs, the change only partially affects existing state holders.

While this doesn't result in direct fund theft or consensus violations, it represents a significant protocol-level economic vulnerability that undermines storage pricing mechanisms and allows storage squatting. Per Aptos bug bounty criteria, this qualifies as "State inconsistencies requiring intervention" and "Limited funds manipulation" (Medium Severity).

## Likelihood Explanation

**HIGH Likelihood:**

1. **No special privileges required:** Any user can create state items with arbitrary keys
2. **Price increases are expected:** Governance will naturally adjust `storage_fee_per_state_byte` based on network conditions
3. **Attack is persistent:** Once state is created at low prices, the discount persists indefinitely
4. **Economically rational:** Users are incentivized to create state with large keys when prices are low
5. **No detection mechanism:** The system has no way to identify or prevent this pricing bypass

The attack is straightforward to execute and requires only:
- Creating state items (tables, resources) with large keys during low-price periods
- Waiting for governance to increase prices (which happens naturally)
- Continuing to use the storage at subsidized rates

## Recommendation

Implement key size repricing on modifications when prices increase. Modify the `charge_refund_write_op_v2` function to charge for key size repricing:

```rust
Modification { write_len } => {
    let old_bytes_deposit = op.metadata_mut.bytes_deposit();
    let current_fair_deposit = num_bytes * u64::from(params.storage_fee_per_state_byte);
    
    let state_bytes_charge = if current_fair_deposit > old_bytes_deposit {
        // Charge to bring deposit up to fair market value
        current_fair_deposit - old_bytes_deposit
    } else {
        0
    };
    
    op.metadata_mut.maybe_upgrade();
    op.metadata_mut.set_bytes_deposit(old_bytes_deposit + state_bytes_charge);
    
    ChargeAndRefund {
        charge: state_bytes_charge.into(),
        refund: 0.into(),
    }
}
```

**Alternative approach:** Maintain historical price paid per byte in metadata and only charge the delta when prices increase, ensuring fair repricing of all bytes (including keys) without overcharging users.

## Proof of Concept

```move
#[test(account = @0x1)]
fun test_storage_price_bypass(account: signer) {
    use aptos_framework::table;
    use aptos_framework::storage_gas;
    
    // Step 1: Set low storage price
    storage_gas::set_config(&account, /* low price config */);
    
    // Step 2: Create table item with large key (1000 bytes) and small value (10 bytes)
    let t = table::new<vector<u8>, u64>();
    let large_key = vector::empty<u8>();
    let i = 0;
    while (i < 1000) {
        vector::push_back(&mut large_key, (i as u8));
        i = i + 1;
    };
    table::add(&mut t, large_key, 42);
    
    // Step 3: Governance increases price by 100x
    storage_gas::set_config(&account, /* high price config */);
    
    // Step 4: Modify the value (grow slightly)
    let key_ref = &large_key;
    table::upsert(&mut t, *key_ref, 999);
    
    // Result: Holding 1010 bytes of storage while only paying for 
    // ~20 bytes at high price + initial low-price deposit
    // Expected: Should pay for all 1010 bytes at high price
    
    table::destroy_empty(t);
}
```

The PoC demonstrates that after a price increase, modifying state items only charges for the value delta, not for repricing the key portion at the new higher rate.

### Citations

**File:** aptos-move/aptos-vm-types/src/storage/space_pricing.rs (L163-213)
```rust
    fn charge_refund_write_op_v2(
        params: &TransactionGasParameters,
        op: WriteOpInfo,
    ) -> ChargeAndRefund {
        use WriteOpSize::*;

        let key_size = op.key.size() as u64;
        let num_bytes = key_size + op.op_size.write_len().unwrap_or(0);
        let target_bytes_deposit: u64 = num_bytes * u64::from(params.storage_fee_per_state_byte);

        match op.op_size {
            Creation { .. } => {
                // permanent storage fee
                let slot_deposit = u64::from(params.storage_fee_per_state_slot);

                op.metadata_mut.maybe_upgrade();
                op.metadata_mut.set_slot_deposit(slot_deposit);
                op.metadata_mut.set_bytes_deposit(target_bytes_deposit);

                ChargeAndRefund {
                    charge: (slot_deposit + target_bytes_deposit).into(),
                    refund: 0.into(),
                }
            },
            Modification { write_len } => {
                // Change of slot size or per byte price can result in a charge or refund of the bytes fee.
                let old_bytes_deposit = op.metadata_mut.bytes_deposit();
                let state_bytes_charge =
                    if write_len > op.prev_size && target_bytes_deposit > old_bytes_deposit {
                        let charge_by_increase: u64 = (write_len - op.prev_size)
                            * u64::from(params.storage_fee_per_state_byte);
                        let gap_from_target = target_bytes_deposit - old_bytes_deposit;
                        std::cmp::min(charge_by_increase, gap_from_target)
                    } else {
                        0
                    };
                op.metadata_mut.maybe_upgrade();
                op.metadata_mut
                    .set_bytes_deposit(old_bytes_deposit + state_bytes_charge);

                ChargeAndRefund {
                    charge: state_bytes_charge.into(),
                    refund: 0.into(),
                }
            },
            Deletion => ChargeAndRefund {
                charge: 0.into(),
                refund: op.metadata_mut.total_deposit().into(),
            },
        }
    }
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L1-50)
```rust
// Copyright (c) Aptos Foundation
// Licensed pursuant to the Innovation-Enabling Source Code License, available at https://github.com/aptos-labs/aptos-core/blob/main/LICENSE

//! This module defines all the gas parameters for transactions, along with their initial values
//! in the genesis and a mapping between the Rust representation and the on-chain gas schedule.

use crate::{
    gas_schedule::VMGasParameters,
    ver::gas_feature_versions::{
        RELEASE_V1_10, RELEASE_V1_11, RELEASE_V1_12, RELEASE_V1_13, RELEASE_V1_15, RELEASE_V1_26,
        RELEASE_V1_41,
    },
};
use aptos_gas_algebra::{
    AbstractValueSize, Fee, FeePerByte, FeePerGasUnit, FeePerSlot, Gas, GasExpression,
    GasScalingFactor, GasUnit, NumModules, NumSlots, NumTypeNodes,
};
use move_core_types::gas_algebra::{
    InternalGas, InternalGasPerArg, InternalGasPerByte, InternalGasUnit, NumBytes, ToUnitWithParams,
};

const GAS_SCALING_FACTOR: u64 = 1_000_000;

crate::gas_schedule::macros::define_gas_parameters!(
    TransactionGasParameters,
    "txn",
    VMGasParameters => .txn,
    [
        // The flat minimum amount of gas required for any transaction.
        // Charged at the start of execution.
        // It is variable to charge more for more expensive authenticators, e.g., keyless
        [
            min_transaction_gas_units: InternalGas,
            "min_transaction_gas_units",
            2_760_000
        ],
        // Any transaction over this size will be charged an additional amount per byte.
        [
            large_transaction_cutoff: NumBytes,
            "large_transaction_cutoff",
            600
        ],
        // The units of gas that to be charged per byte over the `large_transaction_cutoff` in addition to
        // `min_transaction_gas_units` for transactions whose size exceeds `large_transaction_cutoff`.
        [
            intrinsic_gas_per_byte: InternalGasPerByte,
            "intrinsic_gas_per_byte",
            1_158
        ],
        // ~5 microseconds should equal one unit of computational gas. We bound the maximum
```

**File:** types/src/state_store/state_key/mod.rs (L1-50)
```rust
// Copyright (c) Aptos Foundation
// Licensed pursuant to the Innovation-Enabling Source Code License, available at https://github.com/aptos-labs/aptos-core/blob/main/LICENSE

#![allow(clippy::non_canonical_partial_ord_impl)]

pub mod inner;
pub mod prefix;
pub mod registry;
#[cfg(test)]
mod tests;

use crate::{
    access_path,
    access_path::AccessPath,
    on_chain_config::OnChainConfig,
    state_store::{
        state_key::{
            inner::{StateKeyDecodeErr, StateKeyTag},
            registry::{Entry, REGISTRY},
        },
        table::TableHandle,
    },
};
use anyhow::Result;
use aptos_crypto::{
    hash::{CryptoHash, DummyHasher},
    HashValue,
};
use bytes::Bytes;
use inner::StateKeyInner;
use move_core_types::{
    account_address::AccountAddress,
    identifier::IdentStr,
    language_storage::{ModuleId, StructTag},
    move_resource::MoveResource,
};
use num_traits::FromPrimitive;
use serde::{de::Error, Deserialize, Deserializer, Serialize, Serializer};
use std::{
    cmp::Ordering,
    fmt,
    fmt::{Debug, Formatter},
    hash::Hash,
    sync::Arc,
};

#[derive(Clone)]
pub struct StateKey(Arc<Entry>);

impl Debug for StateKey {
```
