# Audit Report

## Title
Verified Module Cache Not Flushed on Verifier Configuration Changes Below Gas Feature Version 38

## Summary
The Move VM's verified module cache fails to flush when bytecode verifier configuration changes on networks running with `gas_feature_version < RELEASE_V1_34 (38)`, allowing previously cached modules that violate updated verification rules to continue executing and potentially breaking consensus determinism.

## Finding Description

The vulnerability exists in the cache flush logic that protects against stale module verification results when security policies change. [1](#0-0) 

The cache uses only the module hash as the key, with no consideration for the verifier configuration used during verification. [2](#0-1) 

When modules are verified, if their hash is already in the cache, re-verification is skipped entirely. The cache flush mechanism exists but has a critical conditional gate: [3](#0-2) 

**The vulnerability:** When `gas_feature_version < 38`, the verifier cache is **never flushed** even when the verifier configuration changes through governance (feature flag modifications).

The verifier configuration depends on multiple factors that can change via on-chain governance: [4](#0-3) 

Changes to feature flags like `ENABLE_FUNCTION_VALUES`, `ENABLE_ENUM_TYPES`, `ENABLE_RESOURCE_ACCESS_CONTROL` alter verification limits (`max_type_nodes`, `max_type_depth`, `max_function_return_values`). On networks with `gas_feature_version < 38`, these changes don't trigger cache flushes, allowing modules that violate the new stricter limits to continue executing.

**Attack Scenario:**
1. Attacker deploys a module on a network with `gas_feature_version = 37` and `ENABLE_FUNCTION_VALUES = false` (max_type_nodes = 256)
2. Module contains deeply nested types that barely pass verification under current limits
3. Module's hash is cached in `VERIFIED_MODULES_CACHE`
4. Governance enables `ENABLE_FUNCTION_VALUES` feature flag, reducing `max_type_nodes` to 128
5. Since `gas_feature_version (37) < RELEASE_V1_34 (38)`, cache is NOT flushed
6. Attacker's module continues executing, violating the updated security policy
7. If different validators have different cache states (e.g., some restarted, some didn't), this breaks **Deterministic Execution** invariant, potentially causing consensus splits

## Impact Explanation

**Severity: CRITICAL** (Consensus/Safety violation)

This vulnerability breaks the **Deterministic Execution** invariant: "All validators must produce identical state roots for identical blocks."

If validators have inconsistent cache states after a verifier configuration change on a network with `gas_feature_version < 38`:
- Validators with cached modules execute without re-verification
- Validators with flushed caches (e.g., after restart) re-verify modules and may reject them under new rules
- Different execution paths lead to different state roots
- Consensus safety is violated, potentially requiring hard fork to resolve

The impact qualifies as **Critical Severity** per bug bounty criteria: "Consensus/Safety violations" and "Non-recoverable network partition (requires hardfork)."

## Likelihood Explanation

**Current Likelihood: LOW to NONE** [5](#0-4) 

Current production networks (mainnet/testnet) use `LATEST_GAS_FEATURE_VERSION = 45`, which is well above the threshold of 38, making them **not currently vulnerable**.

**Historical Likelihood: MEDIUM**

The vulnerability was exploitable during the network upgrade from `gas_feature_version 37 → 38` if:
- Modules were cached under v37 rules
- Verifier configuration changed at v38
- Cache wasn't manually flushed during upgrade

**Future Likelihood: LOW**

Could resurface if:
- A test/development network is configured with `gas_feature_version < 38`
- A network rollback scenario forces use of older versions
- New networks are initialized with outdated configurations

## Recommendation

The fix should ensure cache flushing occurs whenever verifier configuration changes, regardless of gas feature version. The version check should be removed as it creates an unsafe fallback:

```rust
// In code_cache_global_manager.rs, remove the version check:
let environment_requires_update = self.environment.as_ref() != Some(&storage_environment);
if environment_requires_update {
    // Always check verifier config changes, not just for gas_feature_version >= RELEASE_V1_34
    let flush_verifier_cache = self.environment.as_ref().is_none_or(|e| {
        e.verifier_config_bytes() != storage_environment.verifier_config_bytes()
    });
    if flush_verifier_cache {
        RuntimeEnvironment::flush_verified_module_cache();
    }
    
    self.environment = Some(storage_environment);
    self.module_cache.flush();
}
```

Additionally, consider including the verifier configuration hash in the cache key to make it inherently safe:

```rust
// In verified_module_cache.rs, change cache key from [u8; 32] to ([u8; 32], [u8; 32])
// where the second hash represents the verifier configuration
pub(crate) struct VerifiedModuleCache(Mutex<lru::LruCache<([u8; 32], [u8; 32]), ()>>);
```

## Proof of Concept

```rust
// Conceptual PoC - requires test environment with gas_feature_version < 38
// This demonstrates the cache inconsistency scenario

#[test]
fn test_verifier_cache_not_flushed_below_v34() {
    // 1. Create state view with gas_feature_version = 37
    let mut state_view = MockStateView::new(HashMap::from([(
        StateKey::resource(GasScheduleV2::address(), &GasScheduleV2::struct_tag()).unwrap(),
        StateValue::new_legacy(bcs::to_bytes(&GasScheduleV2 {
            feature_version: 37,
            entries: vec![],
        }).unwrap().into()),
    )]));
    
    // 2. Create environment and cache manager
    let manager = AptosModuleCacheManager::new();
    let config = BlockExecutorModuleCacheLocalConfig::default();
    let metadata_1 = TransactionSliceMetadata::block_from_u64(0, 1);
    
    // 3. Verify and cache a module with ENABLE_FUNCTION_VALUES = false
    // (max_type_nodes = 256)
    // [Module deployment and caching logic]
    
    // 4. Change feature flags to enable ENABLE_FUNCTION_VALUES
    // (max_type_nodes now = 128)
    let mut features = Features::default();
    features.enable(FeatureFlag::ENABLE_FUNCTION_VALUES);
    state_view.add_config(features);
    
    // 5. Execute next block
    let metadata_2 = TransactionSliceMetadata::block_from_u64(1, 2);
    let guard = manager.try_lock(&state_view, &config, metadata_2).unwrap();
    
    // BUG: Cache was NOT flushed because gas_feature_version (37) < RELEASE_V1_34 (38)
    // The module with 256 type nodes continues to execute despite new limit of 128
    
    // 6. Different validators may have different cache states:
    //    - Some may have restarted (empty cache, will re-verify and reject)
    //    - Some may have cached module (will execute without re-verification)
    // Result: CONSENSUS BREAK - different state roots
}
```

## Notes

While this vulnerability exists in the codebase and represents a genuine security flaw in the cache invalidation logic, **current production networks are not vulnerable** because they operate with `gas_feature_version = 45`, which is above the threshold of 38 where the fix is active.

The issue is primarily:
1. A **historical vulnerability** during the v37→v38 upgrade period
2. A **design weakness** that creates unnecessary risk in test/development environments
3. A **defense-in-depth failure** where safety depends on configuration versioning rather than being inherent

The fix should be applied to ensure future-proof security regardless of gas feature version configuration.

### Citations

**File:** third_party/move/move-vm/runtime/src/storage/verified_module_cache.rs (L13-49)
```rust
pub(crate) struct VerifiedModuleCache(Mutex<lru::LruCache<[u8; 32], ()>>);

impl VerifiedModuleCache {
    /// Maximum size of the cache. When modules are cached, they can skip re-verification.
    const VERIFIED_CACHE_SIZE: NonZeroUsize = NonZeroUsize::new(100_000).unwrap();

    /// Returns new empty verified module cache.
    pub(crate) fn empty() -> Self {
        Self(Mutex::new(lru::LruCache::new(Self::VERIFIED_CACHE_SIZE)))
    }

    /// Returns true if the module hash is contained in the cache. For tests, the cache is treated
    /// as empty at all times.
    pub(crate) fn contains(&self, module_hash: &[u8; 32]) -> bool {
        // Note: need to use get to update LRU queue.
        verifier_cache_enabled() && self.0.lock().get(module_hash).is_some()
    }

    /// Inserts the hash into the cache, marking the corresponding as locally verified. For tests,
    /// entries are not added to the cache.
    pub(crate) fn put(&self, module_hash: [u8; 32]) {
        if verifier_cache_enabled() {
            let mut cache = self.0.lock();
            cache.put(module_hash, ());
        }
    }

    /// Flushes the verified modules cache.
    pub(crate) fn flush(&self) {
        self.0.lock().clear();
    }

    /// Returns the number of verified modules in the cache.
    pub(crate) fn size(&self) -> usize {
        self.0.lock().len()
    }
}
```

**File:** third_party/move/move-vm/runtime/src/storage/environment.rs (L184-197)
```rust
        if !VERIFIED_MODULES_CACHE.contains(module_hash) {
            let _timer =
                VM_TIMER.timer_with_label("move_bytecode_verifier::verify_module_with_config");

            // For regular execution, we cache already verified modules. Note that this even caches
            // verification for the published modules. This should be ok because as long as the
            // hash is the same, the deployed bytecode and any dependencies are the same, and so
            // the cached verification result can be used.
            move_bytecode_verifier::verify_module_with_config(
                &self.vm_config().verifier_config,
                compiled_module.as_ref(),
            )?;
            check_natives(compiled_module.as_ref())?;
            VERIFIED_MODULES_CACHE.put(*module_hash);
```

**File:** aptos-move/block-executor/src/code_cache_global_manager.rs (L117-126)
```rust
            if storage_environment.gas_feature_version() >= RELEASE_V1_34 {
                let flush_verifier_cache = self.environment.as_ref().is_none_or(|e| {
                    e.verifier_config_bytes() != storage_environment.verifier_config_bytes()
                });
                if flush_verifier_cache {
                    // Additionally, if the verifier config changes, we flush static verifier cache
                    // as well.
                    RuntimeEnvironment::flush_verified_module_cache();
                }
            }
```

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L145-194)
```rust
pub fn aptos_prod_verifier_config(gas_feature_version: u64, features: &Features) -> VerifierConfig {
    let sig_checker_v2_fix_script_ty_param_count =
        features.is_enabled(FeatureFlag::SIGNATURE_CHECKER_V2_SCRIPT_FIX);
    let sig_checker_v2_fix_function_signatures = gas_feature_version >= RELEASE_V1_34;
    let enable_enum_types = features.is_enabled(FeatureFlag::ENABLE_ENUM_TYPES);
    let enable_resource_access_control =
        features.is_enabled(FeatureFlag::ENABLE_RESOURCE_ACCESS_CONTROL);
    let enable_function_values = features.is_enabled(FeatureFlag::ENABLE_FUNCTION_VALUES);
    // Note: we reuse the `enable_function_values` flag to set various stricter limits on types.

    VerifierConfig {
        scope: VerificationScope::Everything,
        max_loop_depth: Some(5),
        max_generic_instantiation_length: Some(32),
        max_function_parameters: Some(128),
        max_basic_blocks: Some(1024),
        max_value_stack_size: 1024,
        max_type_nodes: if enable_function_values {
            Some(128)
        } else {
            Some(256)
        },
        max_push_size: Some(10000),
        max_struct_definitions: None,
        max_struct_variants: None,
        max_fields_in_struct: None,
        max_function_definitions: None,
        max_back_edges_per_function: None,
        max_back_edges_per_module: None,
        max_basic_blocks_in_script: None,
        max_per_fun_meter_units: Some(1000 * 80000),
        max_per_mod_meter_units: Some(1000 * 80000),
        _use_signature_checker_v2: true,
        sig_checker_v2_fix_script_ty_param_count,
        sig_checker_v2_fix_function_signatures,
        enable_enum_types,
        enable_resource_access_control,
        enable_function_values,
        max_function_return_values: if enable_function_values {
            Some(128)
        } else {
            None
        },
        max_type_depth: if enable_function_values {
            Some(20)
        } else {
            None
        },
    }
}
```

**File:** aptos-move/vm-genesis/src/lib.rs (L128-133)
```rust
pub fn default_gas_schedule() -> GasScheduleV2 {
    GasScheduleV2 {
        feature_version: LATEST_GAS_FEATURE_VERSION,
        entries: AptosGasParameters::initial().to_on_chain_gas_schedule(LATEST_GAS_FEATURE_VERSION),
    }
}
```
