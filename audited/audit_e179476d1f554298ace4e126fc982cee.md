# Audit Report

## Title
Thread Pool Exhaustion via Blocking Sleep in Async Indexer Context

## Summary
The `is_address_token()` function in the indexer uses `std::thread::sleep()` within an async execution context, which can block Tokio worker threads and cause indexer performance degradation or complete stalling. This violates async Rust best practices and can be exploited to cause denial of service.

## Finding Description

The vulnerability exists in the retry logic of `is_address_token()` function. [1](#0-0) 

This function is called from an async context through the following call chain:

1. The `TokenTransactionProcessor` implements an async `process_transactions()` method [2](#0-1) 

2. This async function calls `TokenActivityV2::get_ft_v2_from_parsed_event()` [3](#0-2) 

3. Which in turn calls `TokenDataV2::is_address_token()` to check if a fungible asset is actually a token [4](#0-3) 

The indexer runs on a Tokio multi-threaded runtime created with limited worker threads (typically equal to CPU core count). [5](#0-4)  The runtime configuration limits the thread pool size. [6](#0-5) 

The retry constants allow up to 5 retries with 500ms delays: [7](#0-6) 

This means a single call can block a worker thread for up to 2.5 seconds (5 × 500ms). The indexer processes transactions concurrently using multiple tasks [8](#0-7) , which means multiple worker threads can be blocked simultaneously.

**Attack Vector:**
1. Attacker creates fungible token contracts or fungible assets
2. Generates many transactions with fungible asset withdraw/deposit events
3. When these events are processed, `get_ft_v2_from_parsed_event()` checks if the asset is a token
4. If the token isn't found in the in-memory cache, it falls back to database lookup
5. Database queries may fail due to race conditions or intentionally created timing issues
6. Each failure triggers retry with blocking `std::thread::sleep()`, exhausting worker threads
7. With all worker threads blocked, the indexer stalls and cannot process any transactions

## Impact Explanation

This qualifies as **Medium severity** per the Aptos bug bounty program:
- **Performance Degradation**: The indexer processes blockchain transactions and indexes them into PostgreSQL. When worker threads are blocked, processing throughput drops significantly, causing the indexer to fall behind the blockchain tip.
- **Temporary DoS**: If enough concurrent transactions trigger this code path, all worker threads can become blocked, causing complete indexer stalling.
- **Ecosystem Impact**: Applications, wallets, and explorers rely on the indexer for querying blockchain data. Indexer stalling affects user experience across the entire ecosystem.

While this doesn't directly affect consensus or validator operations (the indexer is separate infrastructure), it impacts the availability and reliability of critical blockchain data services, which aligns with "State inconsistencies requiring intervention" under Medium severity.

## Likelihood Explanation

**Likelihood: Medium to High**

The vulnerability is likely to occur because:
1. **Common Pattern**: The same blocking sleep pattern appears in multiple indexer model files, indicating this is a systemic issue
2. **Natural Triggers**: Database race conditions can naturally occur during high transaction volume, triggering retries
3. **Attacker Control**: Malicious actors can deliberately craft transactions with fungible token events to trigger this code path
4. **Limited Mitigation**: No rate limiting or circuit breaker prevents repeated triggering
5. **Concurrent Processing**: The indexer uses concurrent task processing (`processor_tasks`), amplifying the impact

An attacker doesn't need privileged access—any transaction sender can create fungible tokens and generate events that flow through this vulnerable code path.

## Recommendation

Replace `std::thread::sleep()` with `tokio::time::sleep()` to properly yield control back to the async runtime instead of blocking the worker thread:

```rust
pub fn is_address_token(conn: &mut PgPoolConnection, address: &str) -> bool {
    let mut retried = 0;
    while retried < QUERY_RETRIES {
        retried += 1;
        match Self::get_by_token_data_id(conn, address) {
            Ok(_) => return true,
            Err(_) => {
                // Use tokio::time::sleep instead of std::thread::sleep
                tokio::time::sleep(std::time::Duration::from_millis(QUERY_RETRY_DELAY_MS)).await;
            },
        }
    }
    false
}
```

However, since this function is not async, the better solution is to:

1. **Make the function async**:
```rust
pub async fn is_address_token(conn: &mut PgPoolConnection, address: &str) -> bool {
    let mut retried = 0;
    while retried < QUERY_RETRIES {
        retried += 1;
        match Self::get_by_token_data_id(conn, address) {
            Ok(_) => return true,
            Err(_) => {
                tokio::time::sleep(std::time::Duration::from_millis(QUERY_RETRY_DELAY_MS)).await;
            },
        }
    }
    false
}
```

2. **Update all call sites** to await the function

3. **Apply the same fix** to all similar patterns in other indexer model files:
   - `crates/indexer/src/models/stake_models/delegator_balances.rs`
   - `crates/indexer/src/models/token_models/collection_datas.rs`
   - `crates/indexer/src/models/token_models/v2_collections.rs`
   - `crates/indexer/src/models/token_models/v2_token_ownerships.rs`
   - `crates/indexer/src/models/v2_objects.rs`

Alternatively, use `tokio::task::spawn_blocking()` to offload blocking operations to a dedicated blocking thread pool, though making the function async is the cleaner solution.

## Proof of Concept

```rust
// Reproduction test demonstrating thread pool exhaustion
#[tokio::test(flavor = "multi_thread", worker_threads = 2)]
async fn test_thread_pool_exhaustion() {
    use std::sync::Arc;
    use std::sync::atomic::{AtomicUsize, Ordering};
    
    // Simulate the indexer runtime with limited worker threads
    let counter = Arc::new(AtomicUsize::new(0));
    let mut handles = vec![];
    
    // Spawn 4 tasks (more than worker threads) that call blocking sleep
    for _ in 0..4 {
        let counter_clone = counter.clone();
        let handle = tokio::spawn(async move {
            // Simulate the blocking behavior in is_address_token()
            for _ in 0..5 {
                // This blocks the worker thread
                std::thread::sleep(std::time::Duration::from_millis(500));
            }
            counter_clone.fetch_add(1, Ordering::SeqCst);
        });
        handles.push(handle);
    }
    
    // Try to do work while threads are blocked
    let start = std::time::Instant::now();
    futures::future::join_all(handles).await;
    let elapsed = start.elapsed();
    
    // With only 2 worker threads, blocking sleep causes serialization
    // Expected: ~2.5s per task * 2 batches = ~5s total
    // Without blocking: All tasks could run concurrently, ~2.5s total
    println!("Elapsed time: {:?}", elapsed);
    assert!(elapsed.as_secs() >= 5, "Thread pool was blocked, not concurrent");
    assert_eq!(counter.load(Ordering::SeqCst), 4);
}
```

To reproduce in the actual indexer:
1. Deploy multiple fungible token contracts
2. Generate high volume of withdraw/deposit events across multiple transactions
3. Configure the indexer with `processor_tasks` > CPU core count
4. Trigger scenarios where database lookups fail (e.g., query tokens before they're indexed)
5. Monitor indexer metrics to observe thread pool exhaustion and processing stall

## Notes

This vulnerability represents a common anti-pattern in async Rust where blocking operations are called from async contexts. The same pattern appears systematically across the indexer codebase, indicating this should be addressed comprehensively rather than as an isolated fix.

### Citations

**File:** crates/indexer/src/models/token_models/v2_token_datas.rs (L239-251)
```rust
    pub fn is_address_token(conn: &mut PgPoolConnection, address: &str) -> bool {
        let mut retried = 0;
        while retried < QUERY_RETRIES {
            retried += 1;
            match Self::get_by_token_data_id(conn, address) {
                Ok(_) => return true,
                Err(_) => {
                    std::thread::sleep(std::time::Duration::from_millis(QUERY_RETRY_DELAY_MS));
                },
            }
        }
        false
    }
```

**File:** crates/indexer/src/processors/token_processor.rs (L846-857)
```rust
#[async_trait]
impl TransactionProcessor for TokenTransactionProcessor {
    fn name(&self) -> &'static str {
        NAME
    }

    async fn process_transactions(
        &self,
        transactions: Vec<Transaction>,
        start_version: u64,
        end_version: u64,
    ) -> Result<ProcessingResult, TransactionProcessingError> {
```

**File:** crates/indexer/src/processors/token_processor.rs (L1212-1224)
```rust
                if let Some(event) = TokenActivityV2::get_ft_v2_from_parsed_event(
                    event,
                    txn_version,
                    txn_timestamp,
                    index as i64,
                    &entry_function_id_str,
                    &token_v2_metadata_helper,
                    conn,
                )
                .unwrap()
                {
                    token_activities_v2.push(event);
                }
```

**File:** crates/indexer/src/models/token_models/v2_token_activities.rs (L90-95)
```rust
                let is_token = if token_v2_metadata.get(&maybe_token_data_id).is_some() {
                    true
                } else {
                    // Look up in the db
                    TokenDataV2::is_address_token(conn, &maybe_token_data_id)
                };
```

**File:** crates/indexer/src/runtime.rs (L87-87)
```rust
    let runtime = aptos_runtimes::spawn_named_runtime("indexer".into(), None);
```

**File:** crates/indexer/src/runtime.rs (L210-215)
```rust
        let mut tasks = vec![];
        for _ in 0..processor_tasks {
            let other_tailer = tailer.clone();
            let task = tokio::spawn(async move { other_tailer.process_next_batch().await });
            tasks.push(task);
        }
```

**File:** crates/aptos-runtimes/src/lib.rs (L27-54)
```rust
    const MAX_BLOCKING_THREADS: usize = 64;

    // Verify the given name has an appropriate length
    if thread_name.len() > MAX_THREAD_NAME_LENGTH {
        panic!(
            "The given runtime thread name is too long! Max length: {}, given name: {}",
            MAX_THREAD_NAME_LENGTH, thread_name
        );
    }

    // Create the runtime builder
    let atomic_id = AtomicUsize::new(0);
    let thread_name_clone = thread_name.clone();
    let mut builder = Builder::new_multi_thread();
    builder
        .thread_name_fn(move || {
            let id = atomic_id.fetch_add(1, Ordering::SeqCst);
            format!("{}-{}", thread_name_clone, id)
        })
        .on_thread_start(on_thread_start)
        .disable_lifo_slot()
        // Limit concurrent blocking tasks from spawn_blocking(), in case, for example, too many
        // Rest API calls overwhelm the node.
        .max_blocking_threads(MAX_BLOCKING_THREADS)
        .enable_all();
    if let Some(num_worker_threads) = num_worker_threads {
        builder.worker_threads(num_worker_threads);
    }
```

**File:** crates/indexer/src/models/token_models/collection_datas.rs (L23-24)
```rust
pub const QUERY_RETRIES: u32 = 5;
pub const QUERY_RETRY_DELAY_MS: u64 = 500;
```
