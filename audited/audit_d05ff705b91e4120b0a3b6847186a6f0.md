# Audit Report

## Title
Multisig Transaction Payload Mismatch Between API Display and Actual Execution

## Summary
The API conversion function `try_into_transaction_payload()` displays multisig transaction payloads based solely on the transaction's embedded `transaction_payload` field, without checking for stored on-chain payloads. When a multisig transaction is executed with an empty `transaction_payload` field, the API shows `null` but the VM executes the payload stored on-chain, creating a critical information disclosure vulnerability that breaks transaction transparency.

## Finding Description
The vulnerability exists in the interaction between three components:

1. **API Display Layer**: [1](#0-0) 

The `try_into_transaction_payload()` function converts multisig transactions for API responses by only examining the transaction's embedded `transaction_payload` field. If this field is `None`, the API returns `transaction_payload: null` without querying on-chain storage for any stored payload.

2. **Execution Layer**: [2](#0-1) 

During execution, the VM calls `get_next_transaction_payload()` which returns the stored on-chain payload if it exists, regardless of what was provided in the transaction.

3. **Validation Layer**: [3](#0-2) 

The validation logic only checks payload consistency when ALL three conditions are met: feature flag enabled AND stored payload exists AND provided payload is NOT empty. When an empty payload is provided (`vec![]`), the validation is completely skipped despite a stored payload existing and being executed.

**Attack Flow:**
1. Attacker (multisig owner) creates a transaction on-chain with malicious payload A stored using `create_transaction()`
2. Attacker obtains required approvals from other owners
3. Attacker executes the transaction with `transaction_payload: None`
4. API displays to wallets/explorers: `"transaction_payload": null`
5. VM retrieves stored payload A from on-chain storage: [4](#0-3) 
6. Payload A is deserialized and executed
7. Historical transaction records show `null` payload but payload A was executed

This creates a permanent mismatch where executed transactions appear to have no payload in API responses, block explorers, and wallet interfaces, while the actual on-chain execution performed actions specified in the stored payload.

## Impact Explanation
**Severity: Medium to High**

This vulnerability breaks multiple critical security invariants:

1. **Transaction Transparency Violation**: Users cannot determine what was executed by inspecting API responses. This violates the fundamental blockchain principle that all transactions should be transparent and auditable.

2. **Information Disclosure**: The actual executed payload is hidden from standard API queries, requiring direct on-chain state access to discover what was executed.

3. **Social Engineering Vector**: Attackers can show other multisig owners or auditors "empty" transactions via wallets/explorers while executing stored malicious payloads.

4. **Audit Trail Corruption**: Historical transaction analysis via API shows incomplete/incorrect data, breaking compliance and forensic capabilities.

Per Aptos bug bounty criteria, this qualifies as **Medium Severity** ("State inconsistencies requiring intervention") because API state critically misrepresents execution state, potentially **High Severity** if it enables funds loss through social engineering.

## Likelihood Explanation
**Likelihood: High**

This vulnerability is highly likely to be exploited because:

1. **Standard Workflow**: Executing multisig transactions with empty `transaction_payload` is the intended workflow for gas optimization, as shown in the test helper: [5](#0-4) 

2. **No Special Privileges Required**: Any multisig account owner can exploit this with normal transaction submission.

3. **Affects All API Consumers**: Every wallet, block explorer, and dapp relying on the REST API is affected.

4. **Already Enabled**: The feature flag is enabled by default: [6](#0-5) 

5. **No Detection**: The validation explicitly skips checking when payload is empty, so there's no error or warning.

## Recommendation

**Fix 1: Enhance API conversion to fetch stored payloads**

Modify `try_into_transaction_payload()` to query on-chain storage when `transaction_payload` is `None` and retrieve the stored payload for display:

```rust
Multisig(multisig) => {
    let transaction_payload = if let Some(payload) = multisig.transaction_payload {
        // Use provided payload
        match payload { /* ... */ }
    } else {
        // Query on-chain storage for stored payload
        let stored_payload = self.get_stored_multisig_payload(
            multisig.multisig_address
        )?;
        stored_payload.map(|p| /* convert to API format */)
    };
    TransactionPayload::MultisigPayload(MultisigPayload {
        multisig_address: multisig.multisig_address.into(),
        transaction_payload,
    })
}
```

**Fix 2: Strengthen validation to require payload match**

Remove the empty payload exemption from validation: [7](#0-6) 

Change the condition from:
```move
&& !vector::is_empty(&payload)
```

To:
```move
// Always validate when stored payload exists
```

This ensures that if a stored payload exists, either it must match the provided payload OR the provided payload encoding must explicitly signal "use stored payload" rather than ambiguous empty bytes.

## Proof of Concept

```rust
#[tokio::test]
async fn test_multisig_payload_mismatch_vulnerability() {
    let mut context = TestContext::new().await;
    let owner1 = &mut context.create_account().await;
    let owner2 = &mut context.create_account().await;
    
    // Create 2-of-2 multisig account
    let multisig_addr = context.create_multisig_account(
        owner1, vec![owner2.address()], 2, 1000
    ).await;
    
    // Create transaction with malicious payload stored on-chain
    let malicious_payload = construct_transfer_payload(owner1.address(), 1000);
    context.create_multisig_transaction(owner1, multisig_addr, malicious_payload).await;
    
    // Get approvals
    context.approve_multisig_transaction(owner2, multisig_addr, 1).await;
    
    // Execute with EMPTY transaction_payload
    context.execute_multisig_transaction(owner1, multisig_addr, 202).await;
    
    // Query API for executed transaction
    let txn = context.get_transaction_by_version(/* version */).await;
    
    // VULNERABILITY: API shows transaction_payload as null
    assert_eq!(txn.transaction_payload, None);
    
    // But 1000 APT was transferred (malicious payload executed)
    assert_eq!(context.get_apt_balance(multisig_addr).await, 0);
    
    // The stored payload is invisible via API queries!
}
```

**Notes:**
- This vulnerability affects transaction transparency, a critical security property for blockchain systems
- While the feature flag `ABORT_IF_MULTISIG_PAYLOAD_MISMATCH` is enabled by default, its validation logic has a gap for empty payloads
- The issue impacts historical transaction auditability, API correctness, and user trust
- All wallets and block explorers consuming the REST API are affected

### Citations

**File:** api/types/src/convert.rs (L333-352)
```rust
            Multisig(multisig) => {
                let transaction_payload = if let Some(payload) = multisig.transaction_payload {
                    match payload {
                        aptos_types::transaction::MultisigTransactionPayload::EntryFunction(
                            entry_function,
                        ) => {
                            let entry_function_payload =
                                try_into_entry_function_payload(entry_function)?;
                            Some(MultisigTransactionPayload::EntryFunctionPayload(
                                entry_function_payload,
                            ))
                        },
                    }
                } else {
                    None
                };
                TransactionPayload::MultisigPayload(MultisigPayload {
                    multisig_address: multisig.multisig_address.into(),
                    transaction_payload,
                })
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1241-1254)
```rust
        let payload_bytes: Vec<Vec<u8>> = session
            .execute(|session| {
                session.execute_function_bypass_visibility(
                    &MULTISIG_ACCOUNT_MODULE,
                    GET_NEXT_TRANSACTION_PAYLOAD,
                    vec![],
                    serialize_values(&vec![
                        MoveValue::Address(multisig_address),
                        MoveValue::vector_u8(provided_payload),
                    ]),
                    gas_meter,
                    traversal_context,
                    module_storage,
                )
```

**File:** aptos-move/framework/aptos-framework/sources/multisig_account.move (L399-403)
```text
        if (option::is_some(&transaction.payload)) {
            *option::borrow(&transaction.payload)
        } else {
            provided_payload
        }
```

**File:** aptos-move/framework/aptos-framework/sources/multisig_account.move (L1171-1182)
```text
        // If the transaction payload is stored on chain and there is a provided payload,
        // verify that the provided payload matches the stored payload.
        if (features::abort_if_multisig_payload_mismatch_enabled()
            && option::is_some(&transaction.payload)
            && !vector::is_empty(&payload)
        ) {
            let stored_payload = option::borrow(&transaction.payload);
            assert!(
                payload == *stored_payload,
                error::invalid_argument(EPAYLOAD_DOES_NOT_MATCH),
            );
        }
```

**File:** api/test-context/src/test_context.rs (L562-577)
```rust
    pub async fn execute_multisig_transaction(
        &mut self,
        owner: &mut LocalAccount,
        multisig_account: AccountAddress,
        expected_status_code: u16,
    ) {
        self.api_execute_txn_expecting(
            owner,
            json!({
                "type": "multisig_payload",
                "multisig_address": multisig_account.to_hex_literal(),
            }),
            expected_status_code,
        )
        .await;
    }
```

**File:** types/src/on_chain_config/aptos_features.rs (L240-240)
```rust
            FeatureFlag::ABORT_IF_MULTISIG_PAYLOAD_MISMATCH,
```
