# Audit Report

## Title
Illegal ConsensusState Transition Allows Dropping Quorum-Certified Validator Transactions from Pool

## Summary
The `IssuerLevelConsensusManager` in the JWK consensus subsystem allows illegal state transitions from `ConsensusState::Finished` back to `ConsensusState::InProgress` when processing new observations. This causes the `TxnGuard` holding quorum-certified validator transactions to be dropped, removing them from the validator transaction pool before they can be included in blocks, corrupting consensus state.

## Finding Description

The vulnerability exists in the `process_new_observation` method [1](#0-0) 

The method unconditionally overwrites `consensus_state` when a new observation differs from the on-chain state, without checking the current state: [2](#0-1) 

When the state machine is in `ConsensusState::Finished`, it holds a `vtxn_guard` that keeps a quorum-certified validator transaction in the pool: [3](#0-2) 

When this `Finished` state is overwritten with a new `InProgress` state, the `TxnGuard` is dropped. The `TxnGuard::drop` implementation automatically removes the transaction from the pool: [4](#0-3) 

The `try_delete` method removes the transaction from both the queue and topic index: [5](#0-4) 

**Attack Scenario:**

1. Validator's `JWKObserver` fetches JWK set A from OIDC provider → `process_new_observation` transitions state to `InProgress` with proposal A
2. Update certifier reaches quorum → `process_quorum_certified_update` transitions state to `Finished` with `vtxn_guard` holding transaction A in pool [6](#0-5) 
3. **BEFORE** transaction A is proposed in a block and committed on-chain, the observer polls again (every 10 seconds) [7](#0-6) 
4. The OIDC provider returns different JWKs (set B) - either legitimate key rotation or attacker-controlled if provider is compromised
5. `process_new_observation` is called with JWK set B
6. Since on-chain state hasn't been updated yet (still reflects pre-A state), the condition `state.observed != state.on_chain` passes [8](#0-7) 
7. State transitions **illegally** from `Finished` → `InProgress` (line 216)
8. `vtxn_guard` is dropped → transaction A is **removed from pool**
9. Consensus has already agreed on transaction A, but it's now gone from the pool and may never commit on-chain

**Contrast with Per-Key Implementation:**

The per-key variant correctly implements state checking in `maybe_start_consensus`: [9](#0-8) 

This checks if consensus is already in `InProgress` or `Finished` and returns early, preventing the illegal transition.

## Impact Explanation

**Critical Severity** - This vulnerability breaks fundamental consensus integrity:

1. **Consensus Safety Violation**: Validators reach quorum on update A, but the transaction is removed from the pool before commitment, causing consensus state corruption
2. **Non-Recoverable State Inconsistency**: Some validators may have included transaction A in proposals while others have it removed, creating divergent views
3. **Validator Transaction Loss**: Quorum-certified updates that passed through the complete consensus protocol are lost, violating the consensus safety guarantee that agreed-upon transactions must eventually commit

This meets the **Critical Severity** criteria per Aptos Bug Bounty: "Consensus/Safety violations" worth up to $1,000,000.

## Likelihood Explanation

**High Likelihood**:

1. **Natural Occurrence**: The vulnerability can trigger through normal operation when OIDC providers legitimately rotate their keys during the consensus window (10-second polling interval creates natural race condition)
2. **Attacker-Controlled**: If an attacker compromises or controls an OIDC provider endpoint, they can deliberately return varying JWK sets to force the state transition
3. **No Special Privileges Required**: Requires no validator access or consensus participation - only ability to influence OIDC provider responses or exploit natural key rotation timing
4. **Race Window**: The window between reaching `Finished` state and on-chain commitment creates predictable exploitation opportunities

## Recommendation

Implement state checking before initiating new consensus, matching the per-key implementation:

```rust
pub fn process_new_observation(
    &mut self,
    issuer: Issuer,
    jwks: Vec<JWKMoveStruct>,
) -> Result<()> {
    debug!(
        epoch = self.epoch_state.epoch,
        issuer = String::from_utf8(issuer.clone()).ok(),
        "Processing new observation."
    );
    let state = self.states_by_issuer.entry(issuer.clone()).or_default();
    state.observed = Some(jwks.clone());
    
    // Check if consensus is already in progress or finished with the same observation
    let consensus_already_started = match &state.consensus_state {
        ConsensusState::InProgress { my_proposal, .. }
        | ConsensusState::Finished { my_proposal, .. } => {
            let current_jwks = &my_proposal.observed.jwks;
            current_jwks == &jwks
        },
        _ => false,
    };
    
    if consensus_already_started {
        return Ok(());
    }
    
    if state.observed.as_ref() != state.on_chain.as_ref().map(ProviderJWKs::jwks) {
        // ... existing logic to start new consensus ...
    }
    
    Ok(())
}
```

Alternatively, only allow state transitions from `NotStarted` to `InProgress`:

```rust
// Only start consensus if not already in progress or finished
if !matches!(
    &state.consensus_state,
    ConsensusState::InProgress { .. } | ConsensusState::Finished { .. }
) && state.observed.as_ref() != state.on_chain.as_ref().map(ProviderJWKs::jwks) {
    // ... start new consensus ...
}
```

## Proof of Concept

```rust
#[tokio::test]
async fn test_illegal_finished_to_inprogress_transition() {
    // Setup: Create a validator with epoch state and JWK manager
    let private_key = Arc::new(PrivateKey::generate_for_testing());
    let addr = AccountAddress::random();
    let epoch_state = Arc::new(create_test_epoch_state(4));
    let update_certifier = Arc::new(DummyUpdateCertifier::default());
    let vtxn_pool = VTxnPoolState::default();
    
    let mut jwk_manager = IssuerLevelConsensusManager::new(
        private_key.clone(),
        addr,
        epoch_state.clone(),
        update_certifier.clone(),
        vtxn_pool.clone(),
    );
    
    let issuer = issuer_from_str("https://test.com");
    let jwks_v1 = vec![JWK::Unsupported(UnsupportedJWK::new_for_testing("key1", "payload1")).into()];
    let jwks_v2 = vec![JWK::Unsupported(UnsupportedJWK::new_for_testing("key2", "payload2")).into()];
    
    // Initialize with on-chain state
    jwk_manager.reset_with_on_chain_state(AllProvidersJWKs {
        entries: vec![ProviderJWKs {
            issuer: issuer.clone(),
            version: 0,
            jwks: vec![],
        }],
    }).unwrap();
    
    // Step 1: Observer fetches jwks_v1 -> transitions to InProgress
    jwk_manager.process_new_observation(issuer.clone(), jwks_v1.clone()).unwrap();
    assert!(matches!(
        jwk_manager.states_by_issuer.get(&issuer).unwrap().consensus_state,
        ConsensusState::InProgress { .. }
    ));
    
    // Step 2: Consensus reaches quorum -> transitions to Finished
    let quorum_cert = create_test_quorum_cert(issuer.clone(), jwks_v1.clone(), 1);
    jwk_manager.process_quorum_certified_update(quorum_cert).unwrap();
    
    // Verify we're in Finished state with vtxn_guard holding transaction
    assert!(matches!(
        jwk_manager.states_by_issuer.get(&issuer).unwrap().consensus_state,
        ConsensusState::Finished { .. }
    ));
    
    // Verify transaction is in pool
    let txns_in_pool = vtxn_pool.pull(
        Instant::now() + Duration::from_secs(10),
        100,
        1000000,
        TransactionFilter::empty(),
    );
    assert_eq!(txns_in_pool.len(), 1);
    
    // Step 3: VULNERABILITY - Observer fetches jwks_v2 before on-chain commit
    // This should NOT overwrite Finished state, but it does!
    jwk_manager.process_new_observation(issuer.clone(), jwks_v2.clone()).unwrap();
    
    // BUG: State illegally transitioned from Finished back to InProgress
    assert!(matches!(
        jwk_manager.states_by_issuer.get(&issuer).unwrap().consensus_state,
        ConsensusState::InProgress { .. }
    ));
    
    // CRITICAL: Transaction was removed from pool due to vtxn_guard drop!
    let txns_in_pool_after = vtxn_pool.pull(
        Instant::now() + Duration::from_secs(10),
        100,
        1000000,
        TransactionFilter::empty(),
    );
    assert_eq!(txns_in_pool_after.len(), 0); // Transaction is GONE!
    
    // Consensus corruption: Quorum was reached on v1, but transaction is lost
}
```

**Notes:**

The vulnerability is in the per-issuer consensus implementation only. The per-key implementation (`KeyLevelConsensusManager`) correctly guards against this with proper state checking before starting new consensus. The illegal state transition violates the fundamental invariant that once consensus reaches `Finished` with a quorum-certified update, that update must eventually commit on-chain. This is a critical consensus safety violation.

### Citations

**File:** crates/aptos-jwk-consensus/src/jwk_manager/mod.rs (L184-228)
```rust
    pub fn process_new_observation(
        &mut self,
        issuer: Issuer,
        jwks: Vec<JWKMoveStruct>,
    ) -> Result<()> {
        debug!(
            epoch = self.epoch_state.epoch,
            issuer = String::from_utf8(issuer.clone()).ok(),
            "Processing new observation."
        );
        let state = self.states_by_issuer.entry(issuer.clone()).or_default();
        state.observed = Some(jwks.clone());
        if state.observed.as_ref() != state.on_chain.as_ref().map(ProviderJWKs::jwks) {
            let observed = ProviderJWKs {
                issuer: issuer.clone(),
                version: state.on_chain_version() + 1,
                jwks,
            };
            let signature = self
                .consensus_key
                .sign(&observed)
                .context("process_new_observation failed with signing error")?;
            let abort_handle = self
                .update_certifier
                .start_produce(
                    self.epoch_state.clone(),
                    observed.clone(),
                    self.qc_update_tx.clone(),
                )
                .context(
                    "process_new_observation failed with update_certifier.start_produce failure",
                )?;
            state.consensus_state = ConsensusState::InProgress {
                my_proposal: ObservedUpdate {
                    author: self.my_addr,
                    observed: observed.clone(),
                    signature,
                },
                abort_handle_wrapper: QuorumCertProcessGuard::new(abort_handle),
            };
            info!("[JWK] update observed, update={:?}", observed);
        }

        Ok(())
    }
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager/mod.rs (L332-343)
```rust
        match &state.consensus_state {
            ConsensusState::InProgress { my_proposal, .. } => {
                //TODO: counters
                let txn = ValidatorTransaction::ObservedJWKUpdate(update.clone());
                let vtxn_guard =
                    self.vtxn_pool
                        .put(Topic::JWK_CONSENSUS(issuer.clone()), Arc::new(txn), None);
                state.consensus_state = ConsensusState::Finished {
                    vtxn_guard,
                    my_proposal: my_proposal.clone(),
                    quorum_certified: update.clone(),
                };
```

**File:** crates/aptos-jwk-consensus/src/types.rs (L110-114)
```rust
    Finished {
        vtxn_guard: TxnGuard,
        my_proposal: T,
        quorum_certified: QuorumCertifiedUpdate,
    },
```

**File:** crates/validator-transaction-pool/src/lib.rs (L145-150)
```rust
    fn try_delete(&mut self, seq_num: u64) {
        if let Some(item) = self.txn_queue.remove(&seq_num) {
            let seq_num_another = self.seq_nums_by_topic.remove(&item.topic);
            assert_eq!(Some(seq_num), seq_num_another);
        }
    }
```

**File:** crates/validator-transaction-pool/src/lib.rs (L202-206)
```rust
impl Drop for TxnGuard {
    fn drop(&mut self) {
        self.pool.lock().try_delete(self.seq_num);
    }
}
```

**File:** crates/aptos-jwk-consensus/src/jwk_observer.rs (L59-84)
```rust
        let mut interval = tokio::time::interval(fetch_interval);
        interval.set_missed_tick_behavior(MissedTickBehavior::Delay);
        let mut close_rx = close_rx.into_stream();
        let my_addr = if cfg!(feature = "smoke-test") {
            // Include self validator address in JWK request,
            // so dummy OIDC providers in smoke tests can do things like "key A for validator 1, key B for validator 2".
            Some(my_addr)
        } else {
            None
        };

        loop {
            tokio::select! {
                _ = interval.tick().fuse() => {
                    let timer = Instant::now();
                    let result = fetch_jwks(open_id_config_url.as_str(), my_addr).await;
                    debug!(issuer = issuer, "observe_result={:?}", result);
                    let secs = timer.elapsed().as_secs_f64();
                    if let Ok(mut jwks) = result {
                        OBSERVATION_SECONDS.with_label_values(&[issuer.as_str(), "ok"]).observe(secs);
                        jwks.sort();
                        let _ = observation_tx.push((), (issuer.as_bytes().to_vec(), jwks));
                    } else {
                        OBSERVATION_SECONDS.with_label_values(&[issuer.as_str(), "err"]).observe(secs);
                    }
                },
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager_per_key.rs (L179-194)
```rust
    fn maybe_start_consensus(&mut self, update: KeyLevelUpdate) -> Result<()> {
        let consensus_already_started = match self
            .states_by_key
            .get(&(update.issuer.clone(), update.kid.clone()))
            .cloned()
        {
            Some(ConsensusState::InProgress { my_proposal, .. })
            | Some(ConsensusState::Finished { my_proposal, .. }) => {
                my_proposal.observed.to_upsert == update.to_upsert
            },
            _ => false,
        };

        if consensus_already_started {
            return Ok(());
        }
```
