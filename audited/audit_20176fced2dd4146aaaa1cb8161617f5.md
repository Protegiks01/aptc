# Audit Report

## Title
Missing Identifier Length Validation in API Parsing Enables Memory Exhaustion DoS on API Nodes

## Summary
The `IdentifierWrapper::from_str()` function in the Aptos API layer does not enforce identifier length limits when parsing path parameters, allowing attackers to cause memory allocation for identifiers up to HTTP URL length limits (typically 2-8KB), which is orders of magnitude larger than the intended 255-byte limit enforced by the Move bytecode deserializer.

## Finding Description

The Aptos codebase enforces identifier length limits inconsistently between two critical layers:

**Bytecode Deserialization (Correct):** When deserializing Move modules, the system enforces a maximum identifier size of 255 bytes (or 65,535 bytes legacy) by checking the length BEFORE memory allocation. [1](#0-0) [2](#0-1) [3](#0-2) 

**API Parsing (Vulnerable):** When parsing identifiers from API path parameters, the system allocates memory FIRST, then only validates character composition (not length). [4](#0-3) [5](#0-4) [6](#0-5) 

The `is_valid()` function only checks that characters are valid (alphanumeric, underscore, dollar), but performs NO length validation.

**Attack Path:**

1. Attacker sends GET requests to API endpoints that accept identifier path parameters:
   - `/v1/accounts/{address}/module/{module_name}` 
   - `/v1/accounts/{address}/events/{event_handle}/{field_name}` [7](#0-6) [8](#0-7) 

2. The identifier is parsed through the Poem framework's parameter parsing: [9](#0-8) 

3. Memory is allocated for the full identifier string before any length check: [5](#0-4) 

4. Only character validity (not length) is checked, and the validation functions used by API endpoints also don't check length: [10](#0-9) 

This violates the **Resource Limits** invariant (#9): "All operations must respect gas, storage, and computational limits."

## Impact Explanation

**Severity: Low ($1,000 per Aptos Bug Bounty)**

This issue enables a limited DoS attack on API nodes:

- **Affected Component:** API nodes only (not consensus, execution, or storage layers)
- **Exploitability:** Limited by HTTP URL length limits (typically 2-8KB max)
- **Impact:** Memory allocation for identifiers up to 30x larger than intended (8KB vs 255 bytes)
- **Consequence:** With many concurrent requests, can cause API node memory exhaustion and performance degradation

This does NOT affect:
- Blockchain consensus or safety
- Transaction execution or state transitions  
- Validator operations or funds
- Any consensus-critical components

The impact is classified as **Low severity** because:
1. Only API infrastructure is affected, not core blockchain functionality
2. HTTP URL limits cap the maximum exploitation potential
3. Requires sustained attack traffic to cause significant degradation
4. No loss of funds, consensus violations, or state corruption

## Likelihood Explanation

**Likelihood: Medium**

The vulnerability is easy to exploit:
- No authentication required
- Simple HTTP GET requests sufficient
- No special privileges needed

However, practical impact is limited:
- HTTP servers typically enforce 2-8KB URL length limits
- Would require many concurrent requests for serious impact
- API nodes can be isolated from consensus/validator infrastructure
- Standard DoS mitigation (rate limiting, load balancing) applies

## Recommendation

Add identifier length validation in the API parsing layer to match the bytecode layer's enforcement:

```rust
// In api/types/src/wrappers.rs
impl FromStr for IdentifierWrapper {
    type Err = anyhow::Error;

    fn from_str(s: &str) -> anyhow::Result<Self, anyhow::Error> {
        // Add length check before parsing
        const MAX_IDENTIFIER_LENGTH: usize = 255; // Match IDENTIFIER_SIZE_MAX
        if s.len() > MAX_IDENTIFIER_LENGTH {
            bail!("Identifier exceeds maximum length of {} bytes: {}", 
                  MAX_IDENTIFIER_LENGTH, s.len());
        }
        Ok(IdentifierWrapper(Identifier::from_str(s)?))
    }
}
```

Alternatively, modify `Identifier::new()` to check length before allocation:

```rust
// In third_party/move/move-core/types/src/identifier.rs  
pub fn new(s: impl Into<Box<str>>) -> Result<Self> {
    let s_str = s.as_ref(); // Get reference first
    if s_str.len() > IDENTIFIER_SIZE_MAX as usize {
        bail!("Identifier exceeds maximum length");
    }
    let s = s.into();
    if Self::is_valid(&s) {
        Ok(Self(s))
    } else {
        bail!("Invalid identifier '{}'", s);
    }
}
```

## Proof of Concept

```bash
# Generate identifier with 5000 'a' characters (exceeds 255 byte limit)
LONG_IDENTIFIER=$(python3 -c "print('a' * 5000)")

# Send request to API endpoint (will allocate 5KB for identifier)
curl -v "http://localhost:8080/v1/accounts/0x1/module/${LONG_IDENTIFIER}"

# For DoS test, send many concurrent requests:
for i in {1..1000}; do
    curl "http://localhost:8080/v1/accounts/0x1/module/$(python3 -c 'print("a"*5000)')" &
done

# Monitor API node memory usage - should see significant increase
```

**Expected Behavior:** Request should be rejected with "Identifier exceeds maximum length" error before memory allocation.

**Actual Behavior:** Memory is allocated for the full 5KB identifier, only to fail validation later (if it contains "::") or succeed with an oversized identifier.

---

**Notes:**
- This is marked as Low severity consistent with the security question's classification
- While technically exploitable, practical impact is limited by HTTP infrastructure constraints
- The core issue is an implementation inconsistency between bytecode and API layers
- Fix is straightforward: add length validation before memory allocation in API parsing path

### Citations

**File:** third_party/move/move-binary-format/src/file_format_common.rs (L66-67)
```rust
pub const LEGACY_IDENTIFIER_SIZE_MAX: u64 = 65535;
pub const IDENTIFIER_SIZE_MAX: u64 = 255;
```

**File:** third_party/move/move-binary-format/src/deserializer.rs (L394-396)
```rust
fn load_identifier_size(cursor: &mut VersionedCursor) -> BinaryLoaderResult<usize> {
    read_uleb_internal(cursor, cursor.max_identifier_size())
}
```

**File:** third_party/move/move-binary-format/src/deserializer.rs (L979-988)
```rust
fn load_identifier(cursor: &mut VersionedCursor) -> BinaryLoaderResult<Identifier> {
    let size = load_identifier_size(cursor)?;
    let mut buffer: Vec<u8> = vec![0u8; size];
    if !cursor.read(&mut buffer).map(|count| count == size).unwrap() {
        Err(PartialVMError::new(StatusCode::MALFORMED)
            .with_message("Bad Identifier pool size".to_string()))?;
    }
    let ident = Identifier::from_utf8(buffer).map_err(|_| {
        PartialVMError::new(StatusCode::MALFORMED).with_message("Invalid Identifier".to_string())
    })?;
```

**File:** api/types/src/wrappers.rs (L35-41)
```rust
impl FromStr for IdentifierWrapper {
    type Err = anyhow::Error;

    fn from_str(s: &str) -> anyhow::Result<Self, anyhow::Error> {
        Ok(IdentifierWrapper(Identifier::from_str(s)?))
    }
}
```

**File:** third_party/move/move-core/types/src/identifier.rs (L82-94)
```rust
pub const fn is_valid(s: &str) -> bool {
    // Rust const fn's don't currently support slicing or indexing &str's, so we
    // have to operate on the underlying byte slice. This is not a problem as
    // valid identifiers are (currently) ASCII-only.
    let b = s.as_bytes();
    match b {
        b"<SELF>" => true,
        [b'<', b'S', b'E', b'L', b'F', b'>', b'_', ..] if b.len() > 7 => all_bytes_numeric(b, 7),
        [b'a'..=b'z', ..] | [b'A'..=b'Z', ..] => all_bytes_valid(b, 1),
        [b'_', ..] | [b'$', ..] if b.len() > 1 => all_bytes_valid(b, 1),
        _ => false,
    }
}
```

**File:** third_party/move/move-core/types/src/identifier.rs (L119-126)
```rust
    pub fn new(s: impl Into<Box<str>>) -> Result<Self> {
        let s = s.into();
        if Self::is_valid(&s) {
            Ok(Self(s))
        } else {
            bail!("Invalid identifier '{}'", s);
        }
    }
```

**File:** api/src/state.rs (L105-105)
```rust
        module_name: Path<IdentifierWrapper>,
```

**File:** api/src/events.rs (L112-112)
```rust
        field_name: Path<IdentifierWrapper>,
```

**File:** crates/aptos-openapi/src/helpers.rs (L151-158)
```rust
        impl ::poem_openapi::types::ParseFromParameter for $ty {
            fn parse_from_parameter(value: &str) -> ::poem_openapi::types::ParseResult<Self> {
                $crate::percent_encoding::percent_decode_str(value)
                    .decode_utf8()
                    .map_err(::poem_openapi::types::ParseError::custom)?
                    .parse()
                    .map_err(::poem_openapi::types::ParseError::custom)
            }
```

**File:** api/types/src/move_types.rs (L1468-1477)
```rust
pub fn verify_identifier(identifier: &str) -> anyhow::Result<()> {
    if identifier.contains("::") {
        Err(format_err!(
            "Identifier should not contain '::' {}",
            identifier
        ))
    } else {
        Ok(())
    }
}
```
