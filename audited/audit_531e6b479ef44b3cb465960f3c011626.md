# Audit Report

## Title
Ignored Peers Can Rehabilitate Through Storage Summary Bypass, Undermining Peer Reputation System

## Summary
The `can_service_request()` function in `peer_states.rs` contains a bypass that allows ignored peers (those with scores below the ignore threshold) to continue serving storage summary and protocol version requests. This bypass enables malicious peers to rehabilitate their reputation scores and re-enter the trusted peer set, undermining the peer scoring system's security guarantees.

## Finding Description

The Aptos data client implements a peer scoring system to protect against malicious or unreliable peers. When a peer's score drops below `IGNORE_PEER_THRESHOLD` (25.0), they should be excluded from serving requests. However, a bypass exists that allows ignored peers to continue participating in certain operations. [1](#0-0) 

This bypass at line 209 allows storage summary and protocol version requests to always return `true`, completely skipping the ignore check. In contrast, all other request types properly check if the peer is ignored: [2](#0-1) 

**Attack Flow:**

1. A malicious peer sends invalid proofs, triggering malicious error handling: [3](#0-2) 

2. After multiple malicious responses (MALICIOUS_MULTIPLIER = 0.8), the peer's score drops below 25.0 and becomes ignored: [4](#0-3) 

3. Despite being ignored, the peer continues receiving storage summary requests from the poller due to the bypass, and successfully responds to them.

4. Each successful response increases the peer's score: [5](#0-4) 

5. The score increase function adds 1.0 per successful response: [6](#0-5) 

6. After approximately 6 successful storage summary responses, the peer's score rises above 25.0, removing them from the ignored state: [7](#0-6) 

7. Once no longer ignored, the peer's storage summary is included in the global data summary calculation: [8](#0-7) 

8. The rehabilitated peer can now serve data requests again and potentially resume malicious behavior.

## Impact Explanation

This vulnerability meets **Medium Severity** criteria per the Aptos bug bounty program:

- **State Inconsistencies**: The peer reputation system maintains incorrect state about which peers should be trusted, requiring potential manual intervention to identify and ban persistently malicious peers.

- **Resource Waste**: Malicious peers can force the network to repeatedly attempt requests to them, wasting bandwidth and delaying state synchronization.

- **Defense Mechanism Bypass**: The peer scoring system is a critical defense against malicious network participants. This bypass allows attackers to circumvent this protection indefinitely through a simple "respond to storage summaries" strategy.

While this does not directly lead to consensus violations or fund loss, it undermines a core security mechanism designed to protect network health and reliability.

## Likelihood Explanation

**Likelihood: High**

This vulnerability is highly likely to occur because:

1. **Automatic Triggering**: The data client poller automatically sends storage summary requests to all connected peers every few seconds, including ignored peers due to the bypass.

2. **No Special Setup Required**: Any peer on the network can exploit this by simply responding to storage summary requests after being ignored.

3. **Natural Occurrence**: Even non-malicious peers that temporarily behave poorly can accidentally exploit this to avoid proper penalty duration.

4. **Repeatable**: A malicious peer can cycle between sending invalid data → getting ignored → responding to summaries → rehabilitation → sending invalid data again.

## Recommendation

Remove the unconditional bypass for storage summary requests when checking ignored peers. The bypass should only apply to peers that don't yet have a peer state entry (new peers), not to ignored peers.

**Fixed code for `can_service_request()`:**

```rust
pub fn can_service_request(
    &self,
    peer: &PeerNetworkId,
    time_service: TimeService,
    request: &StorageServiceRequest,
) -> bool {
    // Check if we have a peer state for this peer
    if let Some(peer_state) = self.peer_to_state.get(peer) {
        // For existing peers, check if they're ignored first
        let storage_summary = peer_state.get_storage_summary_if_not_ignored();
        
        // Storage summary and protocol version requests can be served
        // if the peer is not ignored, OR if we don't have their summary yet
        if request.data_request.is_storage_summary_request()
            || request.data_request.is_protocol_version_request()
        {
            return storage_summary.is_some() || peer_state.get_storage_summary().is_none();
        }
        
        // For other requests, check if the peer can service them
        return match storage_summary {
            Some(summary) => {
                summary.can_service(&self.data_client_config, time_service, request)
            },
            None => false, // The peer is temporarily ignored
        };
    }
    
    // New peers (no peer state yet) can respond to storage summary
    // and protocol version requests to establish their state
    request.data_request.is_storage_summary_request()
        || request.data_request.is_protocol_version_request()
}
```

## Proof of Concept

```rust
#[cfg(test)]
mod test {
    use super::*;
    use aptos_config::config::AptosDataClientConfig;
    use aptos_storage_service_types::requests::{DataRequest, StorageServiceRequest};
    use aptos_time_service::TimeService;
    use std::sync::Arc;

    #[test]
    fn test_ignored_peer_bypass_vulnerability() {
        // Create peer states with ignore enabled
        let mut config = AptosDataClientConfig::default();
        config.ignore_low_score_peers = true;
        let peer_states = PeerStates::new(Arc::new(config));
        
        // Create a test peer
        let peer = PeerNetworkId::random();
        
        // Initialize peer with a storage summary
        let summary = StorageServerSummary::default();
        peer_states.update_summary(peer, summary);
        
        // Lower the peer's score to below ignore threshold through malicious errors
        for _ in 0..10 {
            peer_states.update_score_error(peer, ErrorType::Malicious);
        }
        
        // Verify the peer is ignored (score < 25.0)
        let peer_state = peer_states.peer_to_state.get(&peer).unwrap();
        assert!(peer_state.score < IGNORE_PEER_THRESHOLD);
        
        // Create a storage summary request
        let storage_request = StorageServiceRequest::new(
            DataRequest::GetStorageServerSummary,
            false,
        );
        
        // BUG: Ignored peer CAN still service storage summary requests due to bypass
        assert!(peer_states.can_service_request(
            &peer,
            TimeService::mock(),
            &storage_request
        ));
        
        // Create a different request (transactions)
        let tx_request = StorageServiceRequest::new(
            DataRequest::GetTransactionsWithProof(TransactionsWithProofRequest {
                start_version: 0,
                end_version: 100,
                proof_version: 100,
                include_events: false,
            }),
            false,
        );
        
        // EXPECTED: Ignored peer CANNOT service other requests
        assert!(!peer_states.can_service_request(
            &peer,
            TimeService::mock(),
            &tx_request
        ));
        
        // Simulate rehabilitation through storage summary responses
        for _ in 0..10 {
            peer_states.update_score_success(peer);
        }
        
        // Verify the peer is no longer ignored
        let peer_state = peer_states.peer_to_state.get(&peer).unwrap();
        assert!(peer_state.score > IGNORE_PEER_THRESHOLD);
        
        // BUG: Rehabilitated malicious peer can now serve all requests again
        assert!(peer_states.can_service_request(
            &peer,
            TimeService::mock(),
            &tx_request
        ));
    }
}
```

## Notes

The original design intent of the bypass was likely to allow new peers (those without peer state entries) to respond to storage summary requests so the system can learn about their capabilities. However, the implementation incorrectly applies this bypass to ALL peers, including those that have been explicitly ignored due to malicious behavior. This creates a loophole in the peer reputation system that attackers can exploit to maintain persistent presence in the network despite repeated malicious actions.

### Citations

**File:** state-sync/aptos-data-client/src/peer_states.rs (L152-160)
```rust
    fn is_ignored(&self) -> bool {
        // Only ignore peers if the config allows it
        if !self.data_client_config.ignore_low_score_peers {
            return false;
        }

        // Otherwise, ignore peers with a low score
        self.score <= IGNORE_PEER_THRESHOLD
    }
```

**File:** state-sync/aptos-data-client/src/peer_states.rs (L163-165)
```rust
    fn update_score_success(&mut self) {
        self.score = f64::min(self.score + SUCCESSFUL_RESPONSE_DELTA, MAX_SCORE);
    }
```

**File:** state-sync/aptos-data-client/src/peer_states.rs (L168-174)
```rust
    fn update_score_error(&mut self, error: ErrorType) {
        let multiplier = match error {
            ErrorType::NotUseful => NOT_USEFUL_MULTIPLIER,
            ErrorType::Malicious => MALICIOUS_MULTIPLIER,
        };
        self.score = f64::max(self.score * multiplier, MIN_SCORE);
    }
```

**File:** state-sync/aptos-data-client/src/peer_states.rs (L209-212)
```rust
        if request.data_request.is_storage_summary_request()
            || request.data_request.is_protocol_version_request()
        {
            return true;
```

**File:** state-sync/aptos-data-client/src/peer_states.rs (L217-222)
```rust
            return match peer_state.get_storage_summary_if_not_ignored() {
                Some(storage_summary) => {
                    storage_summary.can_service(&self.data_client_config, time_service, request)
                },
                None => false, // The peer is temporarily ignored
            };
```

**File:** state-sync/aptos-data-client/src/peer_states.rs (L281-299)
```rust
    pub fn update_score_success(&self, peer: PeerNetworkId) {
        if let Some(mut entry) = self.peer_to_state.get_mut(&peer) {
            // Get the peer's old score
            let old_score = entry.score;

            // Update the peer's score with a successful operation
            entry.update_score_success();

            // Log if the peer is no longer ignored
            let new_score = entry.score;
            if old_score <= IGNORE_PEER_THRESHOLD && new_score > IGNORE_PEER_THRESHOLD {
                info!(
                    (LogSchema::new(LogEntry::PeerStates)
                        .event(LogEvent::PeerNoLongerIgnored)
                        .message("Peer will no longer be ignored")
                        .peer(&peer))
                );
            }
        }
```

**File:** state-sync/aptos-data-client/src/peer_states.rs (L339-350)
```rust
    pub fn calculate_global_data_summary(&self) -> GlobalDataSummary {
        // Gather all storage summaries, but exclude peers that are ignored
        let storage_summaries: Vec<StorageServerSummary> = self
            .peer_to_state
            .iter()
            .filter_map(|peer_state| {
                peer_state
                    .value()
                    .get_storage_summary_if_not_ignored()
                    .cloned()
            })
            .collect();
```

**File:** state-sync/aptos-data-client/src/client.rs (L817-817)
```rust
                self.peer_states.update_score_success(peer);
```
