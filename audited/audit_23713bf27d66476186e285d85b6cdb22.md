# Audit Report

## Title
Unvalidated Cross-Shard Message Parameters Enable Remote Validator Node Crash via Panic

## Summary
The `RemoteTxnWrite::new()` function accepts `state_key` and `write_op` parameters without any validation. When cross-shard messages are received over the network and processed, unexpected state keys trigger a panic in `CrossShardStateView::set_value()` due to an unchecked `.unwrap()` call, causing the entire validator node process to terminate via the panic handler. [1](#0-0) 

## Finding Description

The sharded block executor implements parallel execution across multiple shards that communicate via cross-shard messages. The vulnerability exists in the message handling pipeline:

**1. No Parameter Validation at Message Creation:**
The `RemoteTxnWrite::new()` function blindly accepts any `StateKey` and `WriteOp` without validation. This creates a data structure that can contain semantically invalid or unexpected values. [2](#0-1) 

**2. Network-Based Message Transmission:**
In distributed execution mode, messages are transmitted over the network between validator executor shards using `RemoteCrossShardClient`, which serializes/deserializes messages using BCS without semantic validation: [3](#0-2) 

**3. Unchecked HashMap Lookup Leading to Panic:**
When the receiver processes incoming messages, `CrossShardStateView::set_value()` performs a HashMap lookup with `.unwrap()`, which panics if the `state_key` is not in the expected set: [4](#0-3) 

**4. Process Termination on Panic:**
The global panic handler terminates the entire validator node process when a panic occurs (except for verifier/deserializer contexts): [5](#0-4) 

**Attack Scenario:**

A malicious or compromised validator (Byzantine actor within the < 1/3 tolerance) can:
1. Craft a `RemoteTxnWrite` message with a `StateKey` that is valid but not expected by the target shard's cross-shard dependency set
2. Serialize and send this message via the network to another validator's executor shard
3. The victim shard deserializes the message without semantic validation
4. The receiver thread calls `set_value()` which panics on the `.unwrap()`
5. The panic handler terminates the validator node process with exit code 12

This breaks the **liveness invariant** - validator nodes should handle malformed messages gracefully without crashing.

## Impact Explanation

**High Severity** per Aptos bug bounty criteria:
- **Validator node crashes**: The attack directly causes validator node termination
- **Significant protocol violations**: Violates liveness guarantees of the consensus protocol
- **Network availability impact**: If multiple validators are targeted, network liveness degrades

While not reaching Critical severity (which requires consensus safety violations or fund loss), this vulnerability enables a remote denial-of-service attack against validator nodes participating in sharded execution, compromising network availability and stability.

## Likelihood Explanation

**Likelihood: Medium to High**

**Enabling Factors:**
- The sharded executor with remote cross-shard client is production code designed for distributed execution
- Byzantine validators (up to 1/3 of the network) are within the threat model for BFT consensus
- No authentication or validation mechanisms prevent malicious message injection in the NetworkController
- The attack requires only the ability to send network messages, which any participating validator shard can do

**Mitigating Factors:**
- Requires the sharded execution mode to be active (deployment-dependent)
- Attacker must be a validator or compromise a validator node
- May be detectable through monitoring of abnormal validator crashes

The attack is realistic because the system is explicitly designed to tolerate Byzantine actors, yet this code path lacks defensive validation that would prevent a Byzantine validator from crashing honest validators.

## Recommendation

Implement defensive validation at multiple layers:

**1. Validate parameters in `RemoteTxnWrite::new()`:**
```rust
impl RemoteTxnWrite {
    pub fn new(state_key: StateKey, write_op: Option<WriteOp>) -> Result<Self, String> {
        // Add validation logic here
        // For example, check state_key format, write_op consistency, etc.
        Ok(Self {
            state_key,
            write_op,
        })
    }
}
```

**2. Handle unexpected keys gracefully in `CrossShardStateView::set_value()`:**
```rust
pub fn set_value(&self, state_key: &StateKey, state_value: Option<StateValue>) -> Result<(), String> {
    match self.cross_shard_data.get(state_key) {
        Some(remote_value) => {
            remote_value.set_value(state_value);
            Ok(())
        },
        None => {
            error!("Received unexpected cross-shard key: {:?}", state_key);
            Err(format!("Unexpected cross-shard state key: {:?}", state_key))
        }
    }
}
```

**3. Add error handling in the receiver loop:**
```rust
RemoteTxnWriteMsg(txn_commit_msg) => {
    let (state_key, write_op) = txn_commit_msg.take();
    if let Err(e) = cross_shard_state_view
        .set_value(&state_key, write_op.and_then(|w| w.as_state_value())) {
        error!("Failed to set cross-shard value: {}", e);
        // Continue processing instead of crashing
    }
}
``` [6](#0-5) 

## Proof of Concept

```rust
#[cfg(test)]
mod test {
    use super::*;
    use aptos_types::state_store::state_key::StateKey;
    use aptos_types::write_set::WriteOp;
    
    #[test]
    #[should_panic(expected = "called `Option::unwrap()` on a `None` value")]
    fn test_panic_on_unexpected_state_key() {
        // Setup: Create a CrossShardStateView with expected keys
        let expected_key = StateKey::raw(b"expected_key");
        let mut expected_keys = std::collections::HashSet::new();
        expected_keys.insert(expected_key.clone());
        
        let empty_view = EmptyStateView;
        let cross_shard_view = CrossShardStateView::new(expected_keys, &empty_view);
        
        // Attack: Create a RemoteTxnWrite with an UNEXPECTED key
        let unexpected_key = StateKey::raw(b"malicious_key");
        let malicious_write = RemoteTxnWrite::new(
            unexpected_key.clone(), 
            Some(WriteOp::Deletion)
        );
        
        // Trigger: Process the malicious message
        let (state_key, write_op) = malicious_write.take();
        
        // This will panic with "called `Option::unwrap()` on a `None` value"
        // because unexpected_key is not in cross_shard_data
        cross_shard_view.set_value(&state_key, write_op.and_then(|w| w.as_state_value()));
        
        // In production, this panic triggers the crash handler which calls process::exit(12)
    }
    
    struct EmptyStateView;
    impl aptos_types::state_store::TStateView for EmptyStateView {
        type Key = StateKey;
        fn get_state_value(&self, _: &StateKey) -> Result<Option<aptos_types::state_store::state_value::StateValue>, aptos_types::state_store::errors::StateViewError> {
            Ok(None)
        }
        fn get_usage(&self) -> Result<aptos_types::state_store::state_storage_usage::StateStorageUsage, aptos_types::state_store::errors::StateViewError> {
            Ok(aptos_types::state_store::state_storage_usage::StateStorageUsage::new_untracked())
        }
    }
}
```

This test demonstrates that passing an unexpected `state_key` to `set_value()` causes a panic. In the production distributed executor service, this panic would terminate the validator node process.

### Citations

**File:** aptos-move/aptos-vm/src/sharded_block_executor/messages.rs (L20-26)
```rust
impl RemoteTxnWrite {
    pub fn new(state_key: StateKey, write_op: Option<WriteOp>) -> Self {
        Self {
            state_key,
            write_op,
        }
    }
```

**File:** execution/executor-service/src/remote_cross_shard_client.rs (L61-66)
```rust
    fn receive_cross_shard_msg(&self, current_round: RoundId) -> CrossShardMsg {
        let rx = self.message_rxs[current_round].lock().unwrap();
        let message = rx.recv().unwrap();
        let msg: CrossShardMsg = bcs::from_bytes(&message.to_bytes()).unwrap();
        msg
    }
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/cross_shard_state_view.rs (L49-56)
```rust
    pub fn set_value(&self, state_key: &StateKey, state_value: Option<StateValue>) {
        self.cross_shard_data
            .get(state_key)
            .unwrap()
            .set_value(state_value);
        // uncomment the following line to debug waiting count
        // trace!("waiting count for shard id {} is {}", self.shard_id, self.waiting_count());
    }
```

**File:** crates/crash-handler/src/lib.rs (L52-57)
```rust
    if state::get_state() == VMState::VERIFIER || state::get_state() == VMState::DESERIALIZER {
        return;
    }

    // Kill the process
    process::exit(12);
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/cross_shard_client.rs (L34-38)
```rust
                RemoteTxnWriteMsg(txn_commit_msg) => {
                    let (state_key, write_op) = txn_commit_msg.take();
                    cross_shard_state_view
                        .set_value(&state_key, write_op.and_then(|w| w.as_state_value()));
                },
```
