# Audit Report

## Title
Inbound RPC Timeout Bypass for Unknown Protocol IDs Enables Resource Exhaustion Attack

## Summary
The inbound RPC timeout mechanism is bypassed for RPC requests with unregistered protocol IDs. When a peer receives an RPC request for a protocol without an upstream handler, the request is silently dropped without enforcing the `inbound_rpc_timeout` and without sending an error response back to the sender. This violates the RPC protocol contract and leaves the remote peer waiting indefinitely until their own outbound timeout expires.

## Finding Description

The `inbound_rpc_timeout` is properly initialized and passed to the `InboundRpcs` handler during peer setup: [1](#0-0) 

The timeout is correctly enforced when `InboundRpcs::handle_inbound_request()` is called, wrapping the response channel in a time-bounded future: [2](#0-1) 

**However**, the critical vulnerability occurs in the message routing logic. When an inbound RPC request is received, the code checks if an upstream handler is registered for the protocol ID: [3](#0-2) 

When no handler exists (`None` case at lines 507-511), the code only increments metrics counters and **does nothing else**. Crucially:
1. `handle_inbound_request()` is **never called**, so the timeout is **never created**
2. No error response is sent back to the remote peer
3. The remote peer's RPC request remains pending until their own outbound timeout expires

The AptosNet protocol defines an `ErrorCode::NotSupported` mechanism specifically for this scenario: [4](#0-3) 

This error type exists but is **never used** anywhere in the codebase for RPC requests. In contrast, when parsing errors occur, the code properly sends error messages back: [5](#0-4) 

**Attack Scenario:**
1. Attacker identifies or guesses invalid protocol IDs
2. Attacker sends RPC requests with unknown protocol IDs to victim nodes
3. Victim nodes receive the requests, parse them successfully, but silently drop them
4. Victim nodes **never enforce the inbound_rpc_timeout** (since `handle_inbound_request()` is not called)
5. Victim nodes **never send error responses** back to the attacker
6. Attacker's outbound RPC tasks remain pending, consuming resources until the attacker's own outbound timeout expires (which could be set arbitrarily high)
7. By repeatedly sending such requests, attacker can tie up network resources on both sides

## Impact Explanation

**Severity: HIGH** (per Aptos Bug Bounty classification)

This vulnerability qualifies as **High Severity** because it represents a **significant protocol violation** that affects the network layer:

1. **Timeout Enforcement Bypass**: The `inbound_rpc_timeout` security control is completely bypassed for unknown protocol IDs, violating the intended security guarantee that all inbound RPCs have bounded processing time.

2. **Network Layer Compromise**: This affects ALL network communication, including consensus-critical messages. While consensus messages use known protocol IDs under normal operation, a malicious peer can exploit this to:
   - Probe for unknown/debugging protocol IDs
   - Cause resource exhaustion on the remote peer's side
   - Violate the RPC protocol contract expectations

3. **Resource Exhaustion Vector**: Although the victim node doesn't allocate resources for the dropped request, the remote peer's outbound RPC task remains active and consumes resources until timeout, enabling a low-rate resource exhaustion attack.

4. **Protocol Invariant Violation**: The RPC protocol guarantees that every request receives either a response or an error. This guarantee is broken for unknown protocols, leading to unpredictable network behavior.

This meets the High Severity criteria of "Significant protocol violations" and "Validator node slowdowns" (if exploited against validator nodes).

## Likelihood Explanation

**Likelihood: HIGH**

This vulnerability is highly likely to be exploitable:

1. **No Authentication Required**: Any network peer can send RPC requests with arbitrary protocol IDs
2. **Trivial to Execute**: Attacker only needs to send malformed RPC requests with invalid protocol IDs
3. **No Special Privileges**: Does not require validator access or any privileged position
4. **Easy to Discover**: Protocol ID enumeration is straightforward through network observation or code inspection
5. **Affects All Nodes**: Every node running the Aptos network framework is vulnerable
6. **Persistent Issue**: The vulnerability exists in the core message routing logic and will persist until patched

## Recommendation

**Immediate Fix**: Send `ErrorCode::NotSupported` responses for RPC requests with unregistered protocol IDs.

Modify the RPC request handling in `network/framework/src/peer/mod.rs`:

```rust
NetworkMessage::RpcRequest(request) => {
    match self.upstream_handlers.get(&request.protocol_id) {
        None => {
            // Increment metrics
            counters::direct_send_messages(&self.network_context, UNKNOWN_LABEL).inc();
            counters::direct_send_bytes(&self.network_context, UNKNOWN_LABEL)
                .inc_by(request.raw_request.len() as u64);
            
            // Send error response to remote peer
            let error_code = ErrorCode::NotSupported(
                NotSupportedType::RpcRequest(request.protocol_id)
            );
            let error_msg = NetworkMessage::Error(error_code);
            
            // Push error message to write queue
            if let Err(e) = write_reqs_tx.push((), error_msg) {
                warn!(
                    NetworkSchema::new(&self.network_context)
                        .connection_metadata(&self.connection_metadata),
                    error = ?e,
                    "Failed to send NotSupported error for unknown protocol {} to peer {}",
                    request.protocol_id,
                    self.remote_peer_id().short_str(),
                );
            }
        },
        Some(handler) => {
            // Existing handler logic remains unchanged
            let sender = self.connection_metadata.remote_peer_id;
            let network_id = self.network_context.network_id();
            let sender = PeerNetworkId::new(network_id, sender);
            if let Err(err) = self
                .inbound_rpcs
                .handle_inbound_request(handler, ReceivedMessage::new(message, sender))
            {
                warn!(
                    NetworkSchema::new(&self.network_context)
                        .connection_metadata(&self.connection_metadata),
                    error = %err,
                    "{} Error handling inbound rpc request: {}",
                    self.network_context,
                    err
                );
            }
        },
    }
},
```

**Additional Improvements**:
1. Consider implementing rate limiting for unknown protocol ID requests
2. Add monitoring/alerting for excessive unknown protocol requests
3. Document the expected behavior for unsupported protocols in the network specification

## Proof of Concept

```rust
// File: network/framework/src/peer/test_rpc_unknown_protocol.rs
// This test demonstrates the timeout bypass vulnerability

#[tokio::test]
async fn test_unknown_protocol_timeout_bypass() {
    use crate::protocols::wire::messaging::v1::{NetworkMessage, RpcRequest};
    use crate::ProtocolId;
    use aptos_config::network_id::NetworkContext;
    use aptos_time_service::MockTimeService;
    use futures::StreamExt;
    use std::time::Duration;

    // Setup test peers with mock time service
    let mock_time = MockTimeService::new();
    let inbound_rpc_timeout = Duration::from_secs(10);
    
    // Create a peer with a specific set of registered handlers
    // (intentionally not registering all possible protocol IDs)
    let mut upstream_handlers = HashMap::new();
    upstream_handlers.insert(
        ProtocolId::ConsensusRpcBcs,
        /* handler channel */
    );
    
    // Peer is initialized with inbound_rpc_timeout = 10 seconds
    let peer = Peer::new(
        NetworkContext::mock(),
        executor,
        mock_time.clone(),
        connection,
        connection_notifs_tx,
        peer_reqs_rx,
        Arc::new(upstream_handlers),
        inbound_rpc_timeout,  // 10 second timeout
        max_concurrent_inbound_rpcs,
        max_concurrent_outbound_rpcs,
        max_frame_size,
        max_message_size,
    );
    
    // Attacker sends RPC request with UNKNOWN protocol ID
    let unknown_protocol = ProtocolId::MempoolDirectSend; // Not in handlers
    let malicious_rpc = NetworkMessage::RpcRequest(RpcRequest {
        protocol_id: unknown_protocol,
        request_id: 1,
        priority: 0,
        raw_request: vec![0u8; 100],
    });
    
    // Send the malicious RPC through the peer's reader
    writer.send(&MultiplexMessage::Message(malicious_rpc)).await.unwrap();
    
    // Advance time by 15 seconds (past the inbound_rpc_timeout)
    mock_time.advance_secs(15);
    
    // VULNERABILITY: No timeout is enforced because handle_inbound_request() 
    // was never called. The request was silently dropped.
    
    // The sender's side is still waiting for a response...
    // No error message was sent back.
    
    // Verify that no RpcResponse or Error message was sent
    let response = timeout(Duration::from_secs(1), reader.next()).await;
    assert!(response.is_err(), "Expected no response for unknown protocol");
    
    // Verify metrics show the request was counted as UNKNOWN
    assert_eq!(
        counters::direct_send_messages(&network_context, UNKNOWN_LABEL).get(),
        1
    );
    
    // EXPECTED BEHAVIOR: Should have sent ErrorCode::NotSupported
    // ACTUAL BEHAVIOR: Silent drop, timeout bypass, no error response
}
```

**To reproduce in a live network:**
1. Connect to an Aptos validator or fullnode
2. Send RPC requests with protocol IDs not in the standard set (e.g., protocol_id = 255)
3. Observe that no error response is received
4. Monitor your outbound RPC timeout (set to a high value to demonstrate the issue)
5. Confirm the request stays pending until your own timeout expires
6. On the victim node, verify `UNKNOWN_LABEL` metrics increment but no timeout enforcement occurs

### Citations

**File:** network/framework/src/peer/mod.rs (L178-184)
```rust
            inbound_rpcs: InboundRpcs::new(
                network_context,
                time_service.clone(),
                remote_peer_id,
                inbound_rpc_timeout,
                max_concurrent_inbound_rpcs,
            ),
```

**File:** network/framework/src/peer/mod.rs (L505-531)
```rust
            NetworkMessage::RpcRequest(request) => {
                match self.upstream_handlers.get(&request.protocol_id) {
                    None => {
                        counters::direct_send_messages(&self.network_context, UNKNOWN_LABEL).inc();
                        counters::direct_send_bytes(&self.network_context, UNKNOWN_LABEL)
                            .inc_by(request.raw_request.len() as u64);
                    },
                    Some(handler) => {
                        let sender = self.connection_metadata.remote_peer_id;
                        let network_id = self.network_context.network_id();
                        let sender = PeerNetworkId::new(network_id, sender);
                        if let Err(err) = self
                            .inbound_rpcs
                            .handle_inbound_request(handler, ReceivedMessage::new(message, sender))
                        {
                            warn!(
                                NetworkSchema::new(&self.network_context)
                                    .connection_metadata(&self.connection_metadata),
                                error = %err,
                                "{} Error handling inbound rpc request: {}",
                                self.network_context,
                                err
                            );
                        }
                    },
                }
            },
```

**File:** network/framework/src/peer/mod.rs (L576-586)
```rust
                ReadError::DeserializeError(_, _, ref frame_prefix) => {
                    // DeserializeError's are recoverable so we'll let the other
                    // peer know about the error and log the issue, but we won't
                    // close the connection.
                    let message_type = frame_prefix.as_ref().first().unwrap_or(&0);
                    let protocol_id = frame_prefix.as_ref().get(1).unwrap_or(&0);
                    let error_code = ErrorCode::parsing_error(*message_type, *protocol_id);
                    let message = NetworkMessage::Error(error_code);

                    write_reqs_tx.push((), message)?;
                    return Err(err.into());
```

**File:** network/framework/src/protocols/rpc/mod.rs (L256-281)
```rust
        let inbound_rpc_task = self
            .time_service
            .timeout(self.inbound_rpc_timeout, response_rx)
            .map(move |result| {
                // Flatten the errors
                let maybe_response = match result {
                    Ok(Ok(Ok(response_bytes))) => {
                        let rpc_response = RpcResponse {
                            request_id,
                            priority,
                            raw_response: Vec::from(response_bytes.as_ref()),
                        };
                        Ok((rpc_response, protocol_id))
                    },
                    Ok(Ok(Err(err))) => Err(err),
                    Ok(Err(oneshot::Canceled)) => Err(RpcError::UnexpectedResponseChannelCancel),
                    Err(timeout::Elapsed) => Err(RpcError::TimedOut),
                };
                // Only record latency of successful requests
                match maybe_response {
                    Ok(_) => timer.stop_and_record(),
                    Err(_) => timer.stop_and_discard(),
                };
                maybe_response
            })
            .boxed();
```

**File:** network/framework/src/protocols/wire/messaging/v1/mod.rs (L90-97)
```rust
/// Flags an unsupported network message.  This is a message that a peer can parse its header
/// information but does not have a handler.
#[derive(Clone, Debug, PartialEq, Eq, Deserialize, Serialize)]
#[cfg_attr(any(test, feature = "fuzzing"), derive(Arbitrary))]
pub enum NotSupportedType {
    RpcRequest(ProtocolId),
    DirectSendMsg(ProtocolId),
}
```
