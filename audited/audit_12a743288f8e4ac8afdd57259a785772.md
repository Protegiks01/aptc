# Audit Report

## Title
Abort Hook Session Spam Enables Validator DoS via Stateless Account Creation Bypass

## Summary
Attackers can exploit the lazy account creation mechanism to spam `AbortHookSession` creation by repeatedly sending transactions from unique non-existent addresses that intentionally abort. This bypasses per-account mempool limits and amplifies validator resource consumption beyond the gas fees paid, potentially causing validator slowdowns.

## Finding Description

The vulnerability exists in the interaction between the `DEFAULT_ACCOUNT_RESOURCE` feature (enabled by default) and the abort hook mechanism for lazy account creation. [1](#0-0) 

When `DEFAULT_ACCOUNT_RESOURCE` is enabled, Aptos treats all addresses as valid "stateless" accounts, allowing transactions from non-existent accounts with sequence number 0 to pass prologue validation. [2](#0-1) 

When such transactions abort during execution, `finish_aborted_transaction` checks `should_create_account_resource` which returns true for sequence number 0 transactions from addresses without existing `AccountResource`: [3](#0-2) 

This triggers creation of an `AbortHookSession`, which spawns a new `RespawnedSession`: [4](#0-3) [5](#0-4) 

The `RespawnedSession` allocates significant resources including `ExecutorViewWithChangeSet`, `StorageAdapter`, and a new VM session: [6](#0-5) 

**Attack Path:**

1. Attacker generates N unique addresses (computationally trivial)
2. For each address, submits a transaction with sequence number 0 that intentionally aborts (e.g., `assert!(false, 1)`)
3. Each transaction passes mempool validation since `get_account_sequence_number` returns 0 for non-existent accounts: [7](#0-6) 

4. Mempool per-account limits are ineffective since each sender address only submits one transaction: [8](#0-7) 

5. Each abort triggers expensive `AbortHookSession` creation, amplifying resource consumption beyond gas fees paid
6. Validator experiences memory pressure from session allocations and CPU overhead from account creation operations

## Impact Explanation

This vulnerability enables **Validator node slowdowns**, which qualifies as **High Severity** per the Aptos bug bounty criteria (up to $50,000).

The attack amplifies resource consumption through:
- **Memory amplification**: Each `AbortHookSession` allocates nested structures (`ExecutorViewWithChangeSet`, `StorageAdapter`, `SessionExt`) holding change sets and state views
- **CPU amplification**: Account creation execution, change set squashing, and session management operations occur for each abort
- **Storage writes**: New account resources are created, consuming database resources

The resource consumption significantly exceeds what normal transaction processing would require, violating the invariant that "all operations must respect gas, storage, and computational limits."

## Likelihood Explanation

**Likelihood: High**

Attack requirements:
- One funded account to pay gas fees (minimal capital requirement)
- Ability to generate unique addresses (trivially achievable)
- Network access to submit transactions (standard)

The attack is:
- **Simple to execute**: Straightforward transaction generation loop
- **Difficult to mitigate**: Per-account mempool limits don't apply when using unique senders
- **Economically viable**: Gas fees may not fully compensate for amplified validator resource consumption
- **Repeatable**: Can continuously submit new transactions as mempool processes them

## Recommendation

Implement one or more of the following mitigations:

**Option 1: Fee Payer-Based Rate Limiting**
Track mempool limits by fee payer address in addition to sender address for sponsored transactions. This prevents an attacker from bypassing limits by using different sender addresses with the same fee payer.

```rust
// In transaction_store.rs insert method
let rate_limit_address = match (&txn.fee_payer(), txn_replay_protector) {
    (Some(fee_payer), ReplayProtector::SequenceNumber(0)) => fee_payer,
    _ => &address,
};

if let Some(txns) = self.transactions.get_mut(rate_limit_address) {
    if txns.seq_num_txns_len() >= self.capacity_per_user {
        return MempoolStatus::new(MempoolStatusCode::TooManyTransactions);
    }
}
```

**Option 2: Require Minimum Gas for Sequence Number 0 Transactions**
Increase minimum gas requirements for transactions that will trigger abort hook session creation to properly compensate for the amplified resource usage.

**Option 3: Defer Account Creation**
Only create accounts during abort hook for transactions that have sufficient gas prepaid (e.g., above a threshold) to cover the additional resource overhead.

## Proof of Concept

```move
// File: test_abort_hook_spam.move
script {
    use std::signer;
    
    fun abort_spam_transaction(_sender: &signer) {
        // Intentionally abort to trigger abort hook
        assert!(false, 1);
    }
}
```

```rust
// Rust PoC for submitting spam transactions
use aptos_types::transaction::{SignedTransaction, TransactionPayload};
use aptos_crypto::{ed25519::Ed25519PrivateKey, PrivateKey, Uniform};

// Generate unique sender addresses and submit transactions
for i in 0..10000 {
    let sender_key = Ed25519PrivateKey::generate_for_testing();
    let sender_address = aptos_types::account_address::from_public_key(&sender_key.public_key());
    
    let txn = SignedTransaction::new_with_fee_payer(
        RawTransaction::new(
            sender_address,
            0, // sequence number 0
            TransactionPayload::Script(abort_spam_script),
            100000, // max gas
            1, // gas price
            expiration_time,
            chain_id,
        ),
        sender_key,
        fee_payer_key, // Same fee payer for all transactions
    );
    
    // Submit to mempool - each creates AbortHookSession on abort
    mempool.add_txn(txn);
}
```

Each transaction aborts and triggers `AbortHookSession` creation, amplifying validator resource consumption while bypassing per-account mempool limits.

## Notes

This vulnerability is particularly concerning because:

1. **Enabled by default**: Both `DEFAULT_ACCOUNT_RESOURCE` and `SPONSORED_AUTOMATIC_ACCOUNT_V1_CREATION` features are in the default feature set, making this attack surface active on mainnet.

2. **Mempool limit bypass**: The design assumption that per-account limits prevent spam is violated when attackers can use unlimited sender addresses.

3. **Resource amplification**: The abort hook session creation overhead (new VM session, change set management, account creation) is significantly more expensive than simple transaction rejection, creating an economic imbalance where gas fees may not cover validator costs.

4. **No upper bound on abort hooks**: Unlike normal transaction execution which is bounded by block gas limits, abort hook creation can occur for every aborted transaction up to mempool capacity (2 million transactions).

### Citations

**File:** types/src/on_chain_config/aptos_features.rs (L260-260)
```rust
            FeatureFlag::DEFAULT_ACCOUNT_RESOURCE,
```

**File:** aptos-move/framework/aptos-framework/sources/transaction_validation.move (L215-250)
```text
    fun check_for_replay_protection_regular_txn(
        sender_address: address,
        gas_payer_address: address,
        txn_sequence_number: u64,
    ) {
        if (
            sender_address == gas_payer_address
                || account::exists_at(sender_address)
                || !features::sponsored_automatic_account_creation_enabled()
                || txn_sequence_number > 0
        ) {
            assert!(account::exists_at(sender_address), error::invalid_argument(PROLOGUE_EACCOUNT_DOES_NOT_EXIST));
            let account_sequence_number = account::get_sequence_number(sender_address);
            assert!(
                txn_sequence_number < (1u64 << 63),
                error::out_of_range(PROLOGUE_ESEQUENCE_NUMBER_TOO_BIG)
            );

            assert!(
                txn_sequence_number >= account_sequence_number,
                error::invalid_argument(PROLOGUE_ESEQUENCE_NUMBER_TOO_OLD)
            );

            assert!(
                txn_sequence_number == account_sequence_number,
                error::invalid_argument(PROLOGUE_ESEQUENCE_NUMBER_TOO_NEW)
            );
        } else {
            // In this case, the transaction is sponsored and the account does not exist, so ensure
            // the default values match.
            assert!(
                txn_sequence_number == 0,
                error::invalid_argument(PROLOGUE_ESEQUENCE_NUMBER_TOO_NEW)
            );
        };
    }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L708-743)
```rust
        let (previous_session_change_set, fee_statement) = if should_create_account_resource {
            let mut abort_hook_session =
                AbortHookSession::new(self, txn_data, resolver, prologue_session_change_set);

            abort_hook_session.execute(|session| {
                create_account_if_does_not_exist(
                    session,
                    module_storage,
                    gas_meter,
                    txn_data.sender(),
                    traversal_context,
                )
                // If this fails, it is likely due to out of gas, so we try again without metering
                // and then validate below that we charged sufficiently.
                .or_else(|_err| {
                    create_account_if_does_not_exist(
                        session,
                        module_storage,
                        &mut UnmeteredGasMeter,
                        txn_data.sender(),
                        traversal_context,
                    )
                })
                .map_err(expect_no_verification_errors)
                .or_else(|err| {
                    expect_only_successful_execution(
                        err,
                        &format!("{:?}::{}", ACCOUNT_MODULE, CREATE_ACCOUNT_IF_DOES_NOT_EXIST),
                        log_context,
                    )
                })
            })?;

            let mut abort_hook_session_change_set =
                abort_hook_session.finish(change_set_configs, module_storage)?;
            if let Err(err) = self.charge_change_set(
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L3451-3484)
```rust
pub(crate) fn should_create_account_resource(
    txn_data: &TransactionMetadata,
    features: &Features,
    resolver: &impl AptosMoveResolver,
    module_storage: &impl ModuleStorage,
) -> VMResult<bool> {
    if (features.is_enabled(FeatureFlag::DEFAULT_ACCOUNT_RESOURCE)
        || (features.is_enabled(FeatureFlag::SPONSORED_AUTOMATIC_ACCOUNT_V1_CREATION)
            && txn_data.fee_payer.is_some()))
        && txn_data.replay_protector == ReplayProtector::SequenceNumber(0)
    {
        let account_tag = AccountResource::struct_tag();

        // INVARIANT:
        //   Account lives at a special address, so we should not be charging for it and unmetered
        //   access is safe. There are tests that ensure that address is always special.
        assert!(account_tag.address.is_special());
        let module = module_storage.unmetered_get_existing_deserialized_module(
            &account_tag.address,
            &account_tag.module,
        )?;

        let (maybe_bytes, _) = resolver
            .get_resource_bytes_with_metadata_and_layout(
                &txn_data.sender(),
                &account_tag,
                &module.metadata,
                None,
            )
            .map_err(|e| e.finish(Location::Undefined))?;
        return Ok(maybe_bytes.is_none());
    }
    Ok(false)
}
```

**File:** aptos-move/aptos-vm/src/move_vm_ext/session/user_transaction_sessions/abort_hook.rs (L30-47)
```rust
    pub fn new(
        vm: &AptosVM,
        txn_meta: &TransactionMetadata,
        resolver: &'r impl AptosMoveResolver,
        prologue_session_change_set: SystemSessionChangeSet,
    ) -> Self {
        let session_id = SessionId::run_on_abort(txn_meta);

        let session = RespawnedSession::spawn(
            vm,
            session_id,
            resolver,
            prologue_session_change_set.unpack(),
            Some(txn_meta.as_user_transaction_context()),
        );

        Self { session }
    }
```

**File:** aptos-move/aptos-vm/src/move_vm_ext/session/respawned_session.rs (L38-59)
```rust
    pub fn spawn(
        vm: &AptosVM,
        session_id: SessionId,
        base: &'r impl AptosMoveResolver,
        previous_session_change_set: VMChangeSet,
        user_transaction_context_opt: Option<UserTransactionContext>,
    ) -> RespawnedSession<'r> {
        let executor_view = ExecutorViewWithChangeSet::new(
            base.as_executor_view(),
            base.as_resource_group_view(),
            previous_session_change_set,
        );

        RespawnedSessionBuilder {
            executor_view,
            resolver_builder: |executor_view| vm.as_move_resolver_with_group_view(executor_view),
            session_builder: |resolver| {
                Some(vm.new_session(resolver, session_id, user_transaction_context_opt))
            },
        }
        .build()
    }
```

**File:** vm-validator/src/vm_validator.rs (L103-117)
```rust
pub fn get_account_sequence_number(
    state_view: &DbStateView,
    address: AccountAddress,
) -> Result<u64> {
    fail_point!("vm_validator::get_account_sequence_number", |_| {
        Err(anyhow::anyhow!(
            "Injected error in get_account_sequence_number"
        ))
    });

    match AccountResource::fetch_move_resource(state_view, &address)? {
        Some(account_resource) => Ok(account_resource.sequence_number()),
        None => Ok(0),
    }
}
```

**File:** mempool/src/core_mempool/transaction_store.rs (L234-345)
```rust
    pub(crate) fn insert(
        &mut self,
        txn: MempoolTransaction,
        // For orderless transactions, account_sequence_number is None
        // For sequence number transactions, account_sequence_number is Some(u64)
        account_sequence_number: Option<u64>,
    ) -> MempoolStatus {
        let address = txn.get_sender();
        let txn_replay_protector = txn.get_replay_protector();

        let account_sequence_number = account_sequence_number.map(|seq_num| {
            max(
                seq_num,
                self.get_account_sequence_number(&address).map_or(0, |v| *v),
            )
        });

        // If the transaction is already in Mempool, we only allow the user to
        // increase the gas unit price to speed up a transaction, but not the max gas.
        //
        // Transactions with all the same inputs (but possibly signed differently) are idempotent
        // since the raw transaction is the same
        if let Some(txns) = self.transactions.get_mut(&address) {
            if let Some(current_version) = txns.get_mut(&txn_replay_protector) {
                if current_version.txn.payload() != txn.txn.payload() {
                    return MempoolStatus::new(MempoolStatusCode::InvalidUpdate).with_message(
                        "Transaction already in mempool with a different payload".to_string(),
                    );
                } else if current_version.txn.expiration_timestamp_secs()
                    != txn.txn.expiration_timestamp_secs()
                {
                    return MempoolStatus::new(MempoolStatusCode::InvalidUpdate).with_message(
                        "Transaction already in mempool with a different expiration timestamp"
                            .to_string(),
                    );
                } else if current_version.txn.max_gas_amount() != txn.txn.max_gas_amount() {
                    return MempoolStatus::new(MempoolStatusCode::InvalidUpdate).with_message(
                        "Transaction already in mempool with a different max gas amount"
                            .to_string(),
                    );
                } else if current_version.get_gas_price() < txn.get_gas_price() {
                    // Update txn if gas unit price is a larger value than before
                    if let Some(txn) = txns.remove(&txn_replay_protector) {
                        self.index_remove(&txn);
                    };
                    counters::CORE_MEMPOOL_GAS_UPGRADED_TXNS.inc();
                } else if current_version.get_gas_price() > txn.get_gas_price() {
                    return MempoolStatus::new(MempoolStatusCode::InvalidUpdate).with_message(
                        "Transaction already in mempool with a higher gas price".to_string(),
                    );
                } else {
                    // If the transaction is the same, it's an idempotent call
                    // Updating signers is not supported, the previous submission must fail
                    counters::CORE_MEMPOOL_IDEMPOTENT_TXNS.inc();
                    if let Some(acc_seq_num) = account_sequence_number {
                        self.process_ready_seq_num_based_transactions(&address, acc_seq_num);
                    }
                    return MempoolStatus::new(MempoolStatusCode::Accepted);
                }
            }
        }

        if let ReplayProtector::SequenceNumber(txn_seq_num) = txn.get_replay_protector() {
            let acc_seq_num = account_sequence_number.expect(
                "Account sequence number is always provided for transactions with sequence number",
            );
            self.clean_committed_transactions_below_account_seq_num(&address, acc_seq_num);
            if txn_seq_num < acc_seq_num {
                return MempoolStatus::new(MempoolStatusCode::InvalidSeqNumber).with_message(
                    format!(
                        "transaction sequence number is {}, current sequence number is  {}",
                        txn_seq_num, acc_seq_num,
                    ),
                );
            }
        }

        if self.check_is_full_after_eviction(&txn, account_sequence_number) {
            return MempoolStatus::new(MempoolStatusCode::MempoolIsFull).with_message(format!(
                "Mempool is full. Mempool size: {}, Capacity: {}",
                self.system_ttl_index.size(),
                self.capacity,
            ));
        }

        self.transactions.entry(address).or_default();
        if let Some(txns) = self.transactions.get_mut(&address) {
            // capacity check
            match txn_replay_protector {
                ReplayProtector::SequenceNumber(_) => {
                    if txns.seq_num_txns_len() >= self.capacity_per_user {
                        return MempoolStatus::new(MempoolStatusCode::TooManyTransactions).with_message(
                            format!(
                                "Mempool over capacity for account. Number of seq number transactions from account: {} Capacity per account: {}",
                                txns.seq_num_txns_len() ,
                                self.capacity_per_user,
                            ),
                        );
                    }
                },
                ReplayProtector::Nonce(_) => {
                    if txns.orderless_txns_len() >= self.orderless_txn_capacity_per_user {
                        return MempoolStatus::new(MempoolStatusCode::TooManyTransactions).with_message(
                            format!(
                                "Mempool over capacity for account. Number of orderless transactions from account: {} Capacity per account: {}",
                                txns.orderless_txns_len(),
                                self.orderless_txn_capacity_per_user,
                            ),
                        );
                    }
                },
            }
```
