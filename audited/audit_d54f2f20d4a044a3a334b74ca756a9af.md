# Audit Report

## Title
Test-Compiled Modules Can Be Deployed and Executed in Production Due to Ineffective Poison Mechanism

## Summary
Move modules compiled with the `--test` flag can be published to production blockchains and their `#[test]` functions executed as entry points, completely bypassing the intended isolation between test and production code. The "poison function" mechanism designed to prevent this fails due to lazy native function binding.

## Finding Description

The Move compiler includes a safety mechanism to prevent test-compiled modules from being deployed to production: when compiling with the test flag, it injects a `unit_test_poison()` function that calls the test-only native `create_signers_for_testing()`. [1](#0-0) 

However, this mechanism is fundamentally broken due to three critical flaws:

**Flaw 1: Test functions can have public/entry visibility**

The compiler allows `#[test]` functions to be declared with `public` or `entry` modifiers. [2](#0-1) 

**Flaw 2: Test attributes are not preserved in bytecode**

The `#[test]` attribute is purely a compile-time construct and is NOT encoded in the bytecode's `FunctionAttribute` enum, which only contains `Persistent` and `ModuleLock`. [3](#0-2) 

Once compiled, there is no runtime mechanism to distinguish test functions from regular functions.

**Flaw 3: The poison function is never called**

The `unit_test_poison` function is created with internal visibility and has no callers. [4](#0-3) 

It only serves as a dependency declaration, not an execution barrier.

**Flaw 4: Lazy native binding allows publication**

The Move VM uses lazy binding for native functions - modules with undefined natives can be published and executed successfully, failing only when the undefined native is actually called. [5](#0-4) 

The `unit_test` native module is conditionally compiled only in test mode. [6](#0-5) 

**Attack Scenario:**

1. Attacker writes a malicious Move module:
   ```move
   module attacker::exploit {
       #[test]
       public entry fun drain_funds(victim: &signer) {
           // Test code with minimal security checks
           // Assumes test environment, no production validation
       }
   }
   ```

2. Compiles with `--test` flag - the `unit_test_poison` function is injected but never called

3. Publishes the module to production blockchain - succeeds because native functions use lazy binding

4. Calls `drain_funds` as an entry function - executes successfully because:
   - The function is a valid public entry function in the bytecode
   - The poison function is never invoked
   - No runtime check validates the absence of test attributes

This breaks the **Access Control** and **Transaction Validation** invariants, as test code meant only for development can execute in production with potentially relaxed security assumptions.

## Impact Explanation

**Critical Severity** - This vulnerability enables:

1. **Consensus Safety Violations**: Test code may have non-deterministic behavior or bypass state validation checks, potentially causing validators to produce different state roots for identical transactions, violating the Deterministic Execution invariant.

2. **Access Control Bypass**: Test functions often assume test-only privileges or relaxed security checks. Deploying such code to production allows attackers to exploit functions that were never intended to be production-hardened.

3. **State Manipulation**: Test code may directly manipulate state without proper validation, assuming a safe test environment. In production, this could corrupt critical system state.

The comment in the filter code explicitly states the design intent: "This will then cause the module to fail to link if an attempt is made to publish a module that has been compiled in test mode on a VM that is not running in test mode." [1](#0-0) 

This security guarantee is completely violated.

## Likelihood Explanation

**High Likelihood**:

- No technical barrier prevents compilation with `--test` flag
- Publishing test-compiled modules succeeds silently without warnings
- Developers may accidentally use test builds, or attackers can intentionally exploit this
- The test filtering mechanism explicitly documents its purpose but fails to achieve it [7](#0-6) 

## Recommendation

**Immediate Fix: Enforce eager native validation during module publication**

Modify the bytecode verifier to check that all declared native functions exist in the runtime environment during module publication, not just at call time.

In `check_natives()`, add validation for native function declarations: [8](#0-7) 

Extend this function to iterate through all function definitions and verify that functions marked as `native` have corresponding implementations registered in the `NativeFunctions` table.

**Alternative Fix: Add bytecode-level test marker**

Extend the `FunctionAttribute` enum to include a `TestOnly` variant that is preserved in bytecode, then add runtime checks to prevent calling such functions in production.

**Defense in Depth: Publication-time metadata validation**

Add checks during module publishing to detect and reject modules containing the `unit_test_poison` function signature as a signal of test compilation.

## Proof of Concept

```move
// Save as test_exploit.move
module 0xCAFE::exploit {
    use std::signer;
    
    #[test]
    public entry fun test_only_exploit(account: &signer) {
        // This should only run in tests but will execute in production
        // Test code often has relaxed security assumptions
        let addr = signer::address_of(account);
        // Malicious logic here
    }
}
```

Compilation and deployment steps:
```bash
# Compile with test flag
aptos move compile --test

# Publish to production network - SUCCEEDS
aptos move publish --assume-yes

# Call the test function in production - SUCCEEDS  
aptos move run \
  --function-id 0xCAFE::exploit::test_only_exploit \
  --assume-yes
```

Expected behavior: Module publication or function execution should fail.
Actual behavior: Both succeed, test function executes in production.

## Notes

The lazy native binding test explicitly demonstrates that modules with undefined natives can be published and partially executed. [9](#0-8) 

The native functions are conditionally compiled with `#[cfg(feature = "testing")]`, making them unavailable in production. [10](#0-9) 

However, the check for native functions only validates native structs, not native function declarations. [11](#0-10)

### Citations

**File:** third_party/move/move-compiler-v2/legacy-move-compiler/src/unit_test/filter_test_members.rs (L105-107)
```rust
// This filters out all test, and test-only annotated module member from `prog` if the `test` flag
// in `compilation_env` is not set. If the test flag is set, no filtering is performed, and instead
// a test plan is created for use by the testing framework.
```

**File:** third_party/move/move-compiler-v2/legacy-move-compiler/src/unit_test/filter_test_members.rs (L165-169)
```rust
/// If a module is being compiled in test mode, create a dummy function that calls a native
/// function `0x1::UnitTest::create_signers_for_testing` that only exists if the VM is being run
/// with the "unit_test" feature flag set. This will then cause the module to fail to link if
/// an attempt is made to publish a module that has been compiled in test mode on a VM that is not
/// running in test mode.
```

**File:** third_party/move/move-compiler-v2/legacy-move-compiler/src/unit_test/filter_test_members.rs (L197-205)
```rust
    P::ModuleMember::Function(P::Function {
        attributes: vec![],
        loc: mloc,
        visibility: P::Visibility::Internal,
        entry: None,
        access_specifiers: None,
        signature,
        inline: false,
        name: P::FunctionName(sp(mloc, "unit_test_poison".into())),
```

**File:** third_party/move/move-compiler-v2/tests/unit_test/notest/valid_test_module.move (L14-15)
```text
    #[test]
    public fun go() { }
```

**File:** third_party/move/move-binary-format/src/file_format.rs (L366-371)
```rust
pub enum FunctionAttribute {
    /// The function is treated like a public function on upgrade.
    Persistent,
    /// During execution of the function, a module reentrancy lock is established.
    ModuleLock,
}
```

**File:** aptos-move/e2e-move-tests/src/tests/lazy_natives.rs (L8-45)
```rust
#[test]
fn lazy_natives() {
    let mut h = MoveHarness::new();
    let acc = h.aptos_framework_account();
    let mut builder = PackageBuilder::new("LazyNatives");
    builder.add_source(
        "test",
        "
            module 0x1::test {
                native fun undefined();

                public entry fun nothing() {}
                public entry fun something() { undefined() }
            }
            ",
    );
    let dir = builder.write_to_temp().unwrap();

    // Should be able to publish with unbound native.
    assert_success!(h.publish_package(&acc, dir.path()));

    // Should be able to call nothing entry
    assert_success!(h.run_entry_function(
        &acc,
        str::parse("0x1::test::nothing").unwrap(),
        vec![],
        vec![]
    ));

    // Should not be able to call something entry
    let status = h.run_entry_function(
        &acc,
        str::parse("0x1::test::something").unwrap(),
        vec![],
        vec![],
    );
    assert_vm_status!(status, StatusCode::MISSING_DEPENDENCY)
}
```

**File:** aptos-move/framework/move-stdlib/src/natives/mod.rs (L16-17)
```rust
#[cfg(feature = "testing")]
pub mod unit_test;
```

**File:** aptos-move/framework/move-stdlib/src/natives/mod.rs (L47-50)
```rust
        #[cfg(feature = "testing")]
        {
            add_natives!("unit_test", unit_test::make_all(builder));
        }
```

**File:** third_party/move/move-vm/runtime/src/storage/environment.rs (L196-196)
```rust
            check_natives(compiled_module.as_ref())?;
```

**File:** third_party/move/move-vm/runtime/src/storage/environment.rs (L478-492)
```rust
fn check_natives(module: &CompiledModule) -> VMResult<()> {
    // TODO: fix check and error code if we leave something around for native structs.
    // For now this generates the only error test cases care about...
    for (idx, struct_def) in module.struct_defs().iter().enumerate() {
        if struct_def.field_information == StructFieldInformation::Native {
            return Err(verification_error(
                StatusCode::MISSING_DEPENDENCY,
                IndexKind::FunctionHandle,
                idx as TableIndex,
            )
            .finish(Location::Module(module.self_id())));
        }
    }
    Ok(())
}
```
