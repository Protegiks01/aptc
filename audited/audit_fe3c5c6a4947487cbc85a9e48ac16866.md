# Audit Report

## Title
Windows Platform File Permission Vulnerability Exposes Validator and User Private Keys to Local Attackers

## Summary
The `write_to_user_only_file()` function in `crates/aptos/src/common/utils.rs` only sets restrictive file permissions (mode 0o600) on Unix systems due to conditional compilation. On Windows platforms, the function creates files with default Windows ACLs, potentially allowing other users on the system to read sensitive cryptographic material including validator private keys and user account private keys. [1](#0-0) 

## Finding Description
The vulnerability exists in the platform-specific implementation of file permission settings. The `write_to_user_only_file()` function uses `#[cfg(unix)]` to conditionally compile the `opts.mode(0o600)` call, which restricts file access to the owner only on Unix systems. However, no equivalent Windows-specific permission setting is implemented, causing files to be created with default Windows ACLs.

This function is used throughout the codebase to write highly sensitive cryptographic material:

**1. Validator Genesis Keys** - Used to write validator private keys during genesis key generation: [2](#0-1) 

**2. CLI Configuration with Private Keys** - Used to save user account private keys in the CLI config file: [3](#0-2) 

The CLI config contains an Ed25519PrivateKey field: [4](#0-3) 

**3. Cryptographic Key Material** - A similar function `save_to_file_confidential()` exhibits the same vulnerability: [5](#0-4) 

This is used to save Ed25519 and BLS12381 private keys: [6](#0-5) 

On Windows, default file creation permissions typically inherit ACLs from the parent directory and grant access to:
- The file owner (Full Control)
- Administrators group (Full Control)  
- SYSTEM account (Full Control)
- Potentially other users if parent directory has permissive ACLs

**Attack Scenario:**
1. A validator operator generates genesis keys on a Windows server using `aptos genesis generate-keys`
2. The private-keys.yaml file is created with default Windows permissions
3. An attacker with Administrator privileges (common on Windows) or malware running on the system reads the file
4. The attacker extracts the validator's consensus private key, account private key, and network keys
5. The attacker can now impersonate the validator in the consensus protocol, potentially signing conflicting blocks or participating in equivocation attacks

Similarly, end users running `aptos init` on Windows have their account private keys stored in `.aptos/config.yaml` with overly permissive access rights, allowing local attackers or malware to steal funds.

## Impact Explanation
This vulnerability qualifies as **High Severity** per the Aptos Bug Bounty program criteria:

**High Severity Impacts:**
- **Validator Node Compromise**: Stolen validator private keys allow attackers to impersonate validators, potentially causing consensus disruptions
- **Significant Protocol Violations**: Breaks the cryptographic correctness invariant - private keys must remain confidential for the security model to hold
- **Funds Theft**: User account private keys can be stolen, leading to direct loss of funds

**Potential Critical Severity Path:**
While not automatically Critical, this could escalate to Critical severity if:
- Multiple validators on Windows systems are compromised (>1/3 Byzantine threshold)
- This enables consensus safety violations or network partitions
- However, this requires the additional condition that enough validators run on Windows in production

The impact is clearly High because:
1. It directly compromises validator security infrastructure
2. It enables unauthorized access to user funds
3. It breaks the fundamental cryptographic security assumption that private keys remain private

## Likelihood Explanation
**Likelihood: Medium to High**

**Factors Increasing Likelihood:**
1. **Windows Usage**: While production validators likely run Linux, development, testing, and some operational environments use Windows
2. **CLI Usage**: Many users interact with Aptos through the CLI on Windows workstations
3. **Default Administrator Privileges**: Most Windows users run with Administrator privileges by default
4. **Malware Prevalence**: Windows systems are common targets for malware that scans for cryptocurrency-related files
5. **Multi-User Systems**: Enterprise environments, cloud Windows instances, and shared development machines have multiple users

**Factors Decreasing Likelihood:**
1. **Production Deployment**: Most production validators likely run on Linux servers
2. **Local Access Required**: Attacker needs local system access (not remotely exploitable)

**Realistic Attack Vectors:**
- Malware specifically targeting cryptocurrency keys on Windows systems
- Insider threats in organizations running validators on Windows
- Compromised development/testing environments where real keys are used
- Multi-tenant cloud Windows instances
- Enterprise workstations where multiple employees have administrator access

The combination of Windows being a common development platform and the ease of exploitation (simply read a file as admin/malware) makes this a realistic and exploitable vulnerability.

## Recommendation
Implement Windows-specific file permission restrictions using Windows ACLs. The fix should use the `windows-acl` crate or similar to set DACL (Discretionary Access Control List) that grants access only to the current user.

**Recommended Fix:**

```rust
pub fn write_to_user_only_file(path: &Path, name: &str, bytes: &[u8]) -> CliTypedResult<()> {
    let mut opts = OpenOptions::new();
    
    #[cfg(unix)]
    {
        use std::os::unix::fs::OpenOptionsExt;
        opts.mode(0o600);
    }
    
    #[cfg(windows)]
    {
        // Set Windows ACL to grant access only to the current user
        // This should be implemented before opening the file
        // Consider using windows-acl crate or native Windows APIs
        use windows::Win32::Security::*;
        // Implementation would set DACL to allow only current user SID
    }
    
    write_to_file_with_opts(path, name, bytes, &mut opts)
}
```

**Alternative Immediate Mitigation:**
Add clear documentation warning Windows users about this security issue and recommend:
1. Using WSL (Windows Subsystem for Linux) for production key generation
2. Manually setting file permissions after key generation
3. Using disk encryption for directories containing keys
4. Avoiding Windows for production validator operations

## Proof of Concept

**Steps to Reproduce:**

1. **Setup Windows Environment:**
   - Install Aptos CLI on Windows
   - Ensure you're on a multi-user Windows system or have test users

2. **Generate Validator Keys:**
   ```cmd
   aptos genesis generate-keys --output-dir validator-keys
   ```

3. **Check File Permissions:**
   ```cmd
   cd validator-keys
   icacls private-keys.yaml
   ```
   
   **Expected Insecure Output:**
   ```
   private-keys.yaml BUILTIN\Administrators:(F)
                     NT AUTHORITY\SYSTEM:(F)
                     DOMAIN\User:(F)
   ```
   This shows Full Control (F) for Administrators and SYSTEM, not just the current user.

4. **Demonstrate Unauthorized Access:**
   - Log in as a different administrator user or run as SYSTEM
   - Read the private-keys.yaml file:
   ```cmd
   type C:\Users\VictimUser\validator-keys\private-keys.yaml
   ```
   - The file contents are accessible, including all private keys

5. **Verify User Account Keys:**
   ```cmd
   aptos init
   icacls %USERPROFILE%\.aptos\config.yaml
   ```
   - The config.yaml containing private_key field has the same overly-permissive ACLs

**Expected Secure Behavior (Unix):**
On Linux/Unix systems, the same commands would show:
```bash
$ ls -la private-keys.yaml
-rw------- 1 user user 1234 Jan 1 12:00 private-keys.yaml
```
Only the owner has read/write permissions (600).

**Impact Demonstration:**
Extract the private key from the compromised file and use it to sign a transaction, demonstrating that the compromised key has full control over the account/validator.

## Notes
- This vulnerability affects all Windows users of the Aptos CLI and any validators running on Windows systems
- The same pattern exists in both `write_to_user_only_file()` and `save_to_file_confidential()` functions
- The fix should be applied consistently across all functions that handle sensitive cryptographic material
- Consider adding automated tests that verify file permissions on both Unix and Windows platforms
- The Aptos documentation should explicitly recommend against using Windows for production validator operations until this is fixed

### Citations

**File:** crates/aptos/src/common/utils.rs (L224-229)
```rust
pub fn write_to_user_only_file(path: &Path, name: &str, bytes: &[u8]) -> CliTypedResult<()> {
    let mut opts = OpenOptions::new();
    #[cfg(unix)]
    opts.mode(0o600);
    write_to_file_with_opts(path, name, bytes, &mut opts)
}
```

**File:** crates/aptos/src/genesis/keys.rs (L82-86)
```rust
        write_to_user_only_file(
            private_keys_file.as_path(),
            PRIVATE_KEYS_FILE,
            to_yaml(&private_identity)?.as_bytes(),
        )?;
```

**File:** crates/aptos/src/common/types.rs (L275-282)
```rust
    /// Private key for commands.
    #[serde(
        skip_serializing_if = "Option::is_none",
        default,
        serialize_with = "serialize_material_with_prefix",
        deserialize_with = "deserialize_material_with_prefix"
    )]
    pub private_key: Option<Ed25519PrivateKey>,
```

**File:** crates/aptos/src/common/types.rs (L433-445)
```rust
            write_to_user_only_file(
                aptos_folder.join(GIT_IGNORE).as_path(),
                GIT_IGNORE,
                APTOS_FOLDER_GIT_IGNORE.as_bytes(),
            )?;
        }

        // Save over previous config file
        let config_file = aptos_folder.join(CONFIG_FILE);
        let config_bytes = serde_yaml::to_string(&self).map_err(|err| {
            CliError::UnexpectedError(format!("Failed to serialize config {}", err))
        })?;
        write_to_user_only_file(&config_file, CONFIG_FILE, config_bytes.as_bytes())?;
```

**File:** crates/aptos/src/common/types.rs (L1084-1089)
```rust
    pub fn save_to_file_confidential(&self, name: &str, bytes: &[u8]) -> CliTypedResult<()> {
        let mut opts = OpenOptions::new();
        #[cfg(unix)]
        opts.mode(0o600);
        write_to_file_with_opts(self.output_file.as_path(), name, bytes, &mut opts)
    }
```

**File:** crates/aptos/src/op/key.rs (L438-441)
```rust
        let public_key_file = self.public_key_file()?;
        self.file_options
            .save_to_file_confidential(key_name, &encoded_private_key)?;
        write_to_file(&public_key_file, key_name, &encoded_public_key)?;
```
