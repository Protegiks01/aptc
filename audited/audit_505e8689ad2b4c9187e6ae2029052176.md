# Audit Report

## Title
Complete Validator Network Isolation via Empty Discovery Configuration Leading to Total Loss of Liveness

## Summary
A critical misconfiguration scenario exists where validators using `DiscoveryMethod::None` with an empty seed set become completely isolated from the network, unable to establish any peer connections, resulting in total loss of consensus liveness and network partition.

## Finding Description
The vulnerability arises from insufficient validation in the network configuration subsystem. When a validator is configured with `DiscoveryMethod::None` and an empty `seeds` set, the following catastrophic sequence occurs:

1. **No Outbound Connection Capability**: In `setup_discovery()`, when `DiscoveryMethod::None` is encountered, the function simply continues without adding any discovery listeners. [1](#0-0) 

2. **Empty Peer Discovery**: The `ConnectivityManager` is initialized with the empty seeds via `handle_update_discovered_peers()`. Since no peers exist in the discovered set, `choose_peers_to_dial()` returns an empty list, preventing any outbound connections. [2](#0-1) 

3. **Empty Trusted Peers Set**: With no discovered peers containing keys, `get_eligible_peers()` returns an empty set, which is then used to populate the trusted peers set. [3](#0-2) 

4. **Rejection of All Inbound Connections**: In mutual authentication mode (mandatory for validators), `upgrade_inbound()` checks if the connecting peer exists in the trusted peers set. With an empty trusted set, ALL inbound connection attempts are rejected with `UnauthenticatedClient` error. [4](#0-3) 

5. **No Configuration Validation**: The config sanitizer validates that mutual authentication is enabled and the network ID is correct, but does NOT validate that either discovery methods exist OR seeds are non-empty. [5](#0-4) 

The validator becomes **permanently isolated** with no mechanism for automatic recovery, causing complete consensus liveness failure.

## Impact Explanation
This vulnerability meets **Critical Severity** criteria under the Aptos Bug Bounty program:

- **Total loss of liveness/network availability**: An isolated validator cannot participate in consensus, directly violating the fundamental liveness guarantee of AptosBFT. If multiple validators are misconfigured similarly, the network could lose quorum (>1/3 of stake), resulting in complete consensus halting.

- **Non-recoverable network partition (requires manual intervention)**: The validator remains isolated indefinitely until manually restarted with corrected configuration. There is no automatic recovery mechanism.

- **Consensus Safety Risk**: If this affects enough validators to prevent quorum formation, the blockchain cannot make progress, freezing all transactions and state transitions.

The vulnerability directly breaks the critical invariant: **Validators must maintain connectivity to participate in consensus**.

## Likelihood Explanation
**Likelihood: Medium to High**

This vulnerability can occur through:

1. **Configuration Errors**: Operators manually editing validator configs could accidentally set `discovery_method: None` while clearing seeds during troubleshooting or migration.

2. **Incomplete Configuration Templates**: Deployment scripts or infrastructure-as-code templates that don't properly initialize discovery settings.

3. **Migration Issues**: When migrating from one discovery method to another (e.g., from file-based to onchain), an operator might temporarily disable discovery without realizing the catastrophic consequences.

The issue is particularly insidious because:
- No runtime warnings or errors are logged when the configuration is detected
- The validator appears to start successfully but silently fails to connect
- The config sanitizer provides false confidence by passing validation

## Recommendation

**Immediate Fix**: Add validation in the config sanitizer to ensure validators have at least one viable peer discovery mechanism:

```rust
fn sanitize_validator_network_config(
    node_config: &NodeConfig,
    node_type: NodeType,
    _chain_id: Option<ChainId>,
) -> Result<(), Error> {
    let sanitizer_name = VALIDATOR_NETWORK_SANITIZER_NAME.to_string();
    let validator_network = &node_config.validator_network;

    // ... existing checks ...

    if let Some(validator_network_config) = validator_network {
        // ... existing checks ...

        // NEW CHECK: Ensure validators have peer discovery capability
        let has_discovery = validator_network_config
            .discovery_methods()
            .iter()
            .any(|method| !matches!(method, DiscoveryMethod::None));
        
        let has_seeds = !validator_network_config.seeds.is_empty() 
            || !validator_network_config.seed_addrs.is_empty();

        if !has_discovery && !has_seeds {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "Validator network must have either active discovery methods or seed peers configured!".into(),
            ));
        }
    }

    Ok(())
}
```

**Additional Runtime Protection**: Add early warning in `ConnectivityManager::new()`:

```rust
// After line 401 in connectivity_manager/mod.rs
if seeds.is_empty() && network_context.network_id().is_validator_network() {
    warn!(
        NetworkSchema::new(&network_context),
        "{} WARNING: Validator initialized with no seed peers! Ensure discovery is properly configured.",
        network_context
    );
}
```

## Proof of Concept

Create a test demonstrating the isolation scenario:

```rust
#[cfg(test)]
mod test_validator_isolation {
    use super::*;
    use aptos_config::config::{NetworkConfig, DiscoveryMethod};
    use aptos_config::network_id::NetworkId;
    use std::collections::HashMap;

    #[test]
    #[should_panic(expected = "discovery methods or seed peers")]
    fn test_validator_with_no_discovery_fails_sanitization() {
        let mut node_config = NodeConfig::default();
        
        // Configure as validator with no discovery and no seeds
        node_config.validator_network = Some(NetworkConfig {
            network_id: NetworkId::Validator,
            mutual_authentication: true,
            discovery_methods: vec![DiscoveryMethod::None],
            seeds: HashMap::new(),
            seed_addrs: HashMap::new(),
            ..Default::default()
        });

        // This should fail with the fix in place
        NodeConfig::sanitize(&node_config, NodeType::Validator, None).unwrap();
    }

    #[tokio::test]
    async fn test_validator_isolation_scenario() {
        // Create two validators with proper discovery
        let (mut validator1_config, mut validator2_config) = create_test_validators();
        
        // Misconfigure validator1: no discovery, no seeds
        validator1_config.validator_network.as_mut().unwrap().discovery_methods = vec![DiscoveryMethod::None];
        validator1_config.validator_network.as_mut().unwrap().seeds.clear();
        
        // Start validator1 - it should be isolated
        let validator1 = start_validator(validator1_config).await;
        let validator2 = start_validator(validator2_config).await;
        
        // Wait for connection attempts
        tokio::time::sleep(Duration::from_secs(10)).await;
        
        // Verify validator1 has no connections
        let (tx, rx) = oneshot::channel();
        validator1.conn_mgr_reqs_tx
            .send(ConnectivityRequest::GetConnectedSize(tx))
            .await
            .unwrap();
        
        let connected_size = rx.await.unwrap();
        assert_eq!(connected_size, 0, "Validator1 should be completely isolated");
        
        // Verify validator2 could not connect to validator1
        let (tx, rx) = oneshot::channel();
        validator2.conn_mgr_reqs_tx
            .send(ConnectivityRequest::GetConnectedSize(tx))
            .await
            .unwrap();
        
        let connected_size = rx.await.unwrap();
        assert_eq!(connected_size, 0, "Validator2 should not connect to isolated validator1");
    }
}
```

This vulnerability represents a critical gap in configuration validation that can lead to complete network liveness failure for affected validators.

### Citations

**File:** network/builder/src/builder.rs (L386-388)
```rust
                DiscoveryMethod::None => {
                    continue;
                },
```

**File:** network/framework/src/connectivity_manager/mod.rs (L401-401)
```rust
        connmgr.handle_update_discovered_peers(DiscoverySource::Config, seeds);
```

**File:** network/framework/src/connectivity_manager/mod.rs (L988-1000)
```rust
            let new_eligible = self.discovered_peers.read().get_eligible_peers();

            // Swap in the new eligible peers set
            if let Err(error) = self
                .peers_and_metadata
                .set_trusted_peers(&self.network_context.network_id(), new_eligible)
            {
                error!(
                    NetworkSchema::new(&self.network_context),
                    error = %error,
                    "Failed to update trusted peers set"
                );
            }
```

**File:** network/framework/src/noise/handshake.rs (L368-383)
```rust
        let peer_role = match &self.auth_mode {
            HandshakeAuthMode::Mutual {
                peers_and_metadata, ..
            } => {
                let trusted_peers = peers_and_metadata.get_trusted_peers(&network_id)?;
                let trusted_peer = trusted_peers.get(&remote_peer_id).cloned();
                match trusted_peer {
                    Some(peer) => {
                        Self::authenticate_inbound(remote_peer_short, &peer, &remote_public_key)
                    },
                    None => Err(NoiseHandshakeError::UnauthenticatedClient(
                        remote_peer_short,
                        remote_peer_id,
                    )),
                }
            },
```

**File:** config/src/config/config_sanitizer.rs (L191-197)
```rust
        // Ensure that mutual authentication is enabled
        if !validator_network_config.mutual_authentication {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "Mutual authentication must be enabled for the validator network!".into(),
            ));
        }
```
