# Audit Report

## Title
Inadequate Peer Isolation for Proof Verification Failures in State-Sync Causes Inefficient Malicious Peer Handling

## Summary
When a peer sends cryptographically valid but semantically invalid data (e.g., transactions with incorrect Merkle proofs), the state-sync driver incorrectly classifies proof verification failures as `InvalidPayloadData` instead of `PayloadProofFailed`. This causes malicious peers providing invalid proofs to be penalized too lightly (score multiplied by 0.95 instead of 0.8), allowing them to remain active longer and slowing down state synchronization.

## Finding Description
The vulnerability exists in the error notification handling flow of the state-sync driver. When proof verification fails in the chunk executor, the error propagates back to the driver, which always classifies all storage synchronizer errors uniformly as `InvalidPayloadData` feedback, regardless of whether the error was due to proof verification failure or other causes.

**Attack Flow:**
1. Malicious peer advertises availability of transaction data
2. Honest node requests transactions from malicious peer
3. Malicious peer sends transactions with cryptographically valid signatures but incorrect Merkle proofs
4. Chunk executor verifies the proof and detects it's invalid [1](#0-0) 
5. Error propagates to storage synchronizer [2](#0-1) 
6. **BUG**: Driver handles all storage errors uniformly as `InvalidPayloadData` [3](#0-2) 
7. Data streaming service maps this to `ResponseError::InvalidData` [4](#0-3) 
8. Peer states module treats this as `ErrorType::NotUseful` (0.95 multiplier) instead of `ErrorType::Malicious` (0.8 multiplier) [5](#0-4) 

The system has the infrastructure to properly classify proof failures (`PayloadProofFailed` → `ProofVerificationError` → `Malicious`), but the driver fails to use it when handling storage synchronizer errors.

**Impact:** A malicious peer sending invalid proofs will have their score reduced by only 5% per failure instead of 20%, taking significantly longer to reach the ignore threshold of 25.0. With starting score of 50.0, reaching the threshold requires:
- **Current (buggy)**: ~14 failures (50 × 0.95^14 ≈ 24.4)
- **Expected (fixed)**: ~4 failures (50 × 0.8^4 = 20.48)

This 3.5x difference means malicious peers remain active much longer, causing the node to waste resources retrying invalid data and significantly slowing state synchronization.

## Impact Explanation
**High Severity** - This qualifies as "Validator node slowdowns" per the Aptos bug bounty program. 

In scenarios with multiple malicious peers:
- Nodes waste computational resources verifying invalid proofs repeatedly
- State-sync takes significantly longer to complete as it cycles through bad peers
- In extreme cases with many malicious peers, state-sync could effectively stall

Could escalate to **Critical Severity** if combined with a coordinated attack where a large portion of the peer network provides invalid proofs, potentially causing "Total loss of liveness" for newly joining nodes that cannot complete state-sync.

## Likelihood Explanation
**Medium to High Likelihood:**
- Requires attacker to control peer nodes (feasible - anyone can join the network)
- No special privileges or stake required
- Attack is detectable but persists longer than designed
- Economic incentive exists: delaying state-sync for competitors or disrupting network onboarding

## Recommendation
Modify the error notification handling in the driver to distinguish proof verification failures from other errors. The storage synchronizer should include error type information in `ErrorNotification`, and the driver should map proof verification errors to `PayloadProofFailed` feedback.

**Fix in driver.rs:**
```rust
async fn handle_error_notification(&mut self, error_notification: ErrorNotification) {
    // ... existing logging ...
    
    let notification_id = error_notification.notification_id;
    
    // Determine feedback based on error type
    let notification_feedback = if is_proof_verification_error(&error_notification.error) {
        NotificationFeedback::PayloadProofFailed  // Maps to Malicious
    } else {
        NotificationFeedback::InvalidPayloadData  // Maps to NotUseful
    };
    
    // ... rest of function ...
}
```

Alternatively, have the storage synchronizer directly identify proof verification errors and pass that information in the `ErrorNotification` structure, or have the chunk executor errors propagate with sufficient type information to distinguish proof failures.

## Proof of Concept
```rust
// Simulation showing the vulnerability impact
#[test]
fn test_malicious_peer_isolation_delay() {
    // Initial peer score
    let mut peer_score = 50.0;
    let ignore_threshold = 25.0;
    
    // Current buggy behavior: NotUseful (0.95 multiplier)
    let mut buggy_failures = 0;
    let mut buggy_score = peer_score;
    while buggy_score > ignore_threshold {
        buggy_score *= 0.95;
        buggy_failures += 1;
    }
    
    // Expected correct behavior: Malicious (0.8 multiplier)
    let mut correct_failures = 0;
    let mut correct_score = peer_score;
    while correct_score > ignore_threshold {
        correct_score *= 0.8;
        correct_failures += 1;
    }
    
    println!("Buggy: {} failures needed (final score: {})", buggy_failures, buggy_score);
    println!("Correct: {} failures needed (final score: {})", correct_failures, correct_score);
    
    assert!(buggy_failures > correct_failures * 3, 
            "Malicious peer remains active 3.5x longer than intended");
    
    // Output:
    // Buggy: 14 failures needed (final score: 24.38)
    // Correct: 4 failures needed (final score: 20.48)
}
```

**Notes:**
- The vulnerability is specifically in the error classification at [6](#0-5) 
- The correct mapping infrastructure exists but is unused for storage synchronizer errors
- The `continuous_syncer.rs` correctly uses `PayloadProofFailed` for ledger info verification failures [7](#0-6) , showing the intended design pattern
- This affects both transaction and transaction output synchronization paths

### Citations

**File:** execution/executor/src/chunk_executor/mod.rs (L128-131)
```rust
            txn_list_with_proof.verify(
                verified_target_li.ledger_info(),
                txn_list_with_proof.get_first_transaction_version(),
            )?;
```

**File:** state-sync/state-sync-driver/src/storage_synchronizer.rs (L572-586)
```rust
                Err(error) => {
                    // Send an error notification to the driver (we failed to execute/apply the chunk)
                    let error = if executed_chunk {
                        format!("Failed to execute the data chunk! Error: {:?}", error)
                    } else {
                        format!("Failed to apply the data chunk! Error: {:?}", error)
                    };
                    handle_storage_synchronizer_error(
                        notification_metadata,
                        error,
                        &error_notification_sender,
                        &pending_data_chunks,
                    )
                    .await;
                },
```

**File:** state-sync/state-sync-driver/src/driver.rs (L495-533)
```rust
    async fn handle_error_notification(&mut self, error_notification: ErrorNotification) {
        warn!(LogSchema::new(LogEntry::SynchronizerNotification)
            .error_notification(error_notification.clone())
            .message("Received an error notification from the storage synchronizer!"));

        // Terminate the currently active streams
        let notification_id = error_notification.notification_id;
        let notification_feedback = NotificationFeedback::InvalidPayloadData;
        if self.bootstrapper.is_bootstrapped() {
            if let Err(error) = self
                .continuous_syncer
                .handle_storage_synchronizer_error(NotificationAndFeedback::new(
                    notification_id,
                    notification_feedback,
                ))
                .await
            {
                error!(LogSchema::new(LogEntry::SynchronizerNotification)
                    .message(&format!(
                        "Failed to terminate the active stream for the continuous syncer! Error: {:?}",
                        error
                    )));
            }
        } else if let Err(error) = self
            .bootstrapper
            .handle_storage_synchronizer_error(NotificationAndFeedback::new(
                notification_id,
                notification_feedback,
            ))
            .await
        {
            error!(
                LogSchema::new(LogEntry::SynchronizerNotification).message(&format!(
                    "Failed to terminate the active stream for the bootstrapper! Error: {:?}",
                    error
                ))
            );
        };
    }
```

**File:** state-sync/data-streaming-service/src/data_stream.rs (L1383-1394)
```rust
fn extract_response_error(
    notification_feedback: &NotificationFeedback,
) -> Result<ResponseError, Error> {
    match notification_feedback {
        NotificationFeedback::InvalidPayloadData => Ok(ResponseError::InvalidData),
        NotificationFeedback::PayloadTypeIsIncorrect => Ok(ResponseError::InvalidPayloadDataType),
        NotificationFeedback::PayloadProofFailed => Ok(ResponseError::ProofVerificationError),
        _ => Err(Error::UnexpectedErrorEncountered(format!(
            "Invalid notification feedback given: {:?}",
            notification_feedback
        ))),
    }
```

**File:** state-sync/aptos-data-client/src/peer_states.rs (L54-62)
```rust
impl From<ResponseError> for ErrorType {
    fn from(error: ResponseError) -> Self {
        match error {
            ResponseError::InvalidData | ResponseError::InvalidPayloadDataType => {
                ErrorType::NotUseful
            },
            ResponseError::ProofVerificationError => ErrorType::Malicious,
        }
    }
```

**File:** state-sync/state-sync-driver/src/continuous_syncer.rs (L440-443)
```rust
                self.reset_active_stream(Some(NotificationAndFeedback::new(
                    notification_id,
                    NotificationFeedback::PayloadProofFailed,
                )))
```
