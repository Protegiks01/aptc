# Audit Report

## Title
Resource Group Conflict Collapsing Enables Block Throughput Griefing Attack via False Conflict Inflation

## Summary
The `collapse_resource_group_conflicts()` function in the block executor creates false conflicts by collapsing all resource group tag accesses to the resource level when `use_granular_resource_group_conflicts` is disabled (the default). This artificially inflates the conflict penalty multiplier, causing blocks to hit gas limits prematurely and enabling griefing attacks that reduce network throughput without proportional cost to the attacker.

## Finding Description

The block executor uses a conflict penalty system to account for transaction dependencies during parallel execution. When transactions have read-write conflicts within a configurable window (default 9 transactions), a conflict multiplier is applied to their gas consumption for block limit calculations. [1](#0-0) 

The `collapse_resource_group_conflicts()` function converts all `InputOutputKey::Group(k, tag)` entries to `InputOutputKey::Resource(k)`, discarding tag information. This means transactions accessing different tags within the same resource group (e.g., one accessing `ObjectCore` and another accessing `FungibleStore` at the same address) are treated as conflicting for gas calculation purposes. [2](#0-1) 

When `use_granular_resource_group_conflicts` is false (the default configuration), this collapsed version is used to compute conflict multipliers: [3](#0-2) 

The conflict multiplier directly amplifies the effective block gas consumption: [4](#0-3) 

The multiplier calculation counts conflicts within a window: [5](#0-4) 

**Attack Scenario:**

ObjectGroup is extensively used across the Aptos framework (37 source files), particularly for fungible assets and tokens: [6](#0-5) 

Multiple resources belong to ObjectGroup: [7](#0-6) 

An attacker can craft transactions that:
1. Access different tags within the same popular resource group (e.g., USDT metadata object)
2. Use minimal gas but create maximum false conflicts
3. Submit transactions with consecutive sequence numbers to ensure sequential block inclusion
4. Each subsequent transaction in the window gets an incrementally higher conflict multiplier (up to 9x)

The attacker pays only for actual gas used, but these transactions count for much more toward the block limit, causing the block to fill prematurely and excluding legitimate transactions.

## Impact Explanation

This constitutes a **Medium Severity** vulnerability under the Aptos bug bounty criteria because it enables a DoS/griefing attack that reduces network throughput. While it doesn't involve fund loss, consensus violations, or permanent damage, it allows an attacker to artificially congest the network and degrade performance for all users at disproportionately low cost.

The attack does not prevent parallel execution (the MVHashMap still uses granular conflict detection), but it manipulates the gas accounting system to cause premature block termination, effectively reducing the number of transactions that can be included per block.

## Likelihood Explanation

**HIGH likelihood** of exploitation:
- The vulnerable configuration is the default (`use_granular_resource_group_conflicts: false`)
- ObjectGroup is ubiquitously used throughout the ecosystem
- Many legitimate transactions naturally create these false conflicts
- An attacker requires no special privileges, only the ability to submit transactions
- Attack cost is asymmetric: attacker pays normal gas but causes outsized impact on block capacity
- With a conflict window of 9 and multiplier up to 9x, a single attacker can effectively reduce block capacity by filling it with low-gas transactions that count as high-gas due to false conflicts

## Recommendation

Enable granular resource group conflict detection by default to eliminate false conflicts while maintaining accurate gas accounting:

```rust
// In types/src/on_chain_config/execution_config.rs
impl BlockGasLimitType {
    pub fn default_for_genesis() -> Self {
        BlockGasLimitType::ComplexLimitV1 {
            effective_block_gas_limit: 20000,
            execution_gas_effective_multiplier: 1,
            io_gas_effective_multiplier: 1,
            conflict_penalty_window: 9,
            use_granular_resource_group_conflicts: true, // Changed from false
            use_module_publishing_block_conflict: true,
            block_output_limit: Some(4 * 1024 * 1024),
            include_user_txn_size_in_block_output: true,
            add_block_limit_outcome_onchain: true,
        }
    }
}
```

Alternatively, if conservative mode must remain the default for other reasons, implement conflict multiplier caps or adjust the penalty formula to prevent excessive inflation from false conflicts.

## Proof of Concept

The existing test suite already demonstrates the behavior difference: [8](#0-7) 

This test shows that with `use_granular_resource_group_conflicts: false`, accessing `Group(2,1)` followed by `Group(2,2)` produces a conflict multiplier of 2, while with granular mode enabled: [9](#0-8) 

The same operations produce a conflict multiplier of 1 for each transaction.

To demonstrate the griefing attack, an adversary would:
1. Identify a heavily-used ObjectGroup address (e.g., popular fungible asset metadata)
2. Submit 9 transactions from the same account with consecutive sequence numbers
3. Each transaction accesses a different ObjectGroup member at that address
4. Each transaction uses minimal gas (e.g., simple reads)
5. The effective block gas accumulates as: 1x + 2x + 3x + ... + 9x = 45x the raw gas
6. The block reaches its limit with far fewer total transactions than intended

**Notes:**
The vulnerability exists because the conflict detection for gas accounting purposes is overly conservative and can be exploited for network-wide throughput reduction. While actual parallel execution remains unaffected by the MVHashMap's granular tracking, the artificial gas inflation creates an economic attack vector where attackers can congest the network at asymmetric cost.

### Citations

**File:** aptos-move/block-executor/src/types.rs (L44-54)
```rust
    pub fn collapse_resource_group_conflicts(self) -> Self {
        let collapse = |k: InputOutputKey<T::Key, T::Tag>| match k {
            InputOutputKey::Resource(k) => InputOutputKey::Resource(k),
            InputOutputKey::Group(k, _) => InputOutputKey::Resource(k),
            InputOutputKey::DelayedField(id) => InputOutputKey::DelayedField(id),
        };
        Self {
            reads: self.reads.into_iter().map(collapse).collect(),
            writes: self.writes.into_iter().map(collapse).collect(),
        }
    }
```

**File:** aptos-move/block-executor/src/limit_processor.rs (L82-89)
```rust
            let rw_summary = if self
                .block_gas_limit_type
                .use_granular_resource_group_conflicts()
            {
                txn_read_write_summary
            } else {
                txn_read_write_summary.collapse_resource_group_conflicts()
            };
```

**File:** aptos-move/block-executor/src/limit_processor.rs (L100-109)
```rust
        // When the accumulated execution and io gas of the committed txns exceeds
        // PER_BLOCK_GAS_LIMIT, early halt BlockSTM. Storage fee does not count towards
        // the per block gas limit, as we measure execution related cost here.
        let raw_gas_used = fee_statement.execution_gas_used()
            * self
                .block_gas_limit_type
                .execution_gas_effective_multiplier()
            + fee_statement.io_gas_used() * self.block_gas_limit_type.io_gas_effective_multiplier();
        self.accumulated_raw_block_gas += raw_gas_used;
        self.accumulated_effective_block_gas += conflict_multiplier * raw_gas_used;
```

**File:** aptos-move/block-executor/src/limit_processor.rs (L175-203)
```rust
    fn compute_conflict_multiplier(&self, conflict_overlap_length: usize) -> u64 {
        let start = self
            .txn_read_write_summaries
            .len()
            .saturating_sub(conflict_overlap_length);
        let end = self.txn_read_write_summaries.len() - 1;

        let mut conflict_count = 0;
        let current = &self.txn_read_write_summaries[end];
        for prev in &self.txn_read_write_summaries[start..end] {
            if current.conflicts_with_previous(prev) {
                if self.print_conflicts_info {
                    println!(
                        "Conflicts with previous: {:?}",
                        current.find_conflicts(prev)
                    );
                }
                conflict_count += 1;
            }
        }
        if self.print_conflicts_info {
            println!(
                "Number of conflicts: {} out of {}",
                conflict_count, conflict_overlap_length
            );
        }
        assert_le!(conflict_count + 1, conflict_overlap_length);
        (conflict_count + 1) as u64
    }
```

**File:** aptos-move/block-executor/src/limit_processor.rs (L410-469)
```rust
    fn test_conflict_limit_coarse_resource_groups() {
        let block_gas_limit = BlockGasLimitType::ComplexLimitV1 {
            effective_block_gas_limit: 1000,
            execution_gas_effective_multiplier: 1,
            io_gas_effective_multiplier: 1,
            conflict_penalty_window: 8,
            use_module_publishing_block_conflict: false,
            block_output_limit: None,
            include_user_txn_size_in_block_output: true,
            add_block_limit_outcome_onchain: false,
            use_granular_resource_group_conflicts: false,
        };

        let mut processor = TestProcessor::new(block_gas_limit, None, 10);

        processor.accumulate_fee_statement(
            execution_fee(10),
            Some(ReadWriteSummary::new(
                to_map(&[InputOutputKey::Resource(1)]),
                to_map(&[InputOutputKey::Resource(1)]),
            )),
            None,
        );
        assert_eq!(1, processor.compute_conflict_multiplier(8));
        assert_eq!(processor.accumulated_effective_block_gas, 10);
        assert!(!processor.should_end_block_parallel());
        processor.accumulate_fee_statement(
            execution_fee(10),
            Some(ReadWriteSummary::new(
                to_map(&[InputOutputKey::Resource(1)]),
                to_map(&[InputOutputKey::Group(1, 1)]),
            )),
            None,
        );
        assert_eq!(2, processor.compute_conflict_multiplier(8));
        assert_eq!(processor.accumulated_effective_block_gas, 30);
        assert!(!processor.should_end_block_parallel());
        processor.accumulate_fee_statement(
            execution_fee(10),
            Some(ReadWriteSummary::new(
                to_map(&[InputOutputKey::Group(2, 1)]),
                to_map(&[InputOutputKey::Group(2, 1)]),
            )),
            None,
        );
        assert_eq!(1, processor.compute_conflict_multiplier(8));
        assert_eq!(processor.accumulated_effective_block_gas, 40);
        assert!(!processor.should_end_block_parallel());
        processor.accumulate_fee_statement(
            execution_fee(10),
            Some(ReadWriteSummary::new(
                to_map(&[InputOutputKey::Group(2, 2)]),
                to_map(&[InputOutputKey::Group(2, 2)]),
            )),
            None,
        );
        assert_eq!(2, processor.compute_conflict_multiplier(8));
        assert_eq!(processor.accumulated_effective_block_gas, 60);
        assert!(!processor.should_end_block_parallel());
    }
```

**File:** aptos-move/block-executor/src/limit_processor.rs (L472-510)
```rust
    fn test_conflict_limit_granular_resource_groups() {
        let block_gas_limit = BlockGasLimitType::ComplexLimitV1 {
            effective_block_gas_limit: 1000,
            execution_gas_effective_multiplier: 1,
            io_gas_effective_multiplier: 1,
            conflict_penalty_window: 8,
            use_module_publishing_block_conflict: false,
            block_output_limit: None,
            include_user_txn_size_in_block_output: true,
            add_block_limit_outcome_onchain: false,
            use_granular_resource_group_conflicts: true,
        };

        let mut processor = TestProcessor::new(block_gas_limit, None, 10);

        assert!(!processor.should_end_block_parallel());
        processor.accumulate_fee_statement(
            execution_fee(10),
            Some(ReadWriteSummary::new(
                to_map(&[InputOutputKey::Group(2, 1)]),
                to_map(&[InputOutputKey::Group(2, 1)]),
            )),
            None,
        );
        assert_eq!(1, processor.compute_conflict_multiplier(8));
        assert_eq!(processor.accumulated_effective_block_gas, 10);
        assert!(!processor.should_end_block_parallel());
        processor.accumulate_fee_statement(
            execution_fee(10),
            Some(ReadWriteSummary::new(
                to_map(&[InputOutputKey::Group(2, 2)]),
                to_map(&[InputOutputKey::Group(2, 2)]),
            )),
            None,
        );
        assert_eq!(1, processor.compute_conflict_multiplier(8));
        assert_eq!(processor.accumulated_effective_block_gas, 20);
        assert!(!processor.should_end_block_parallel());
    }
```

**File:** types/src/on_chain_config/execution_config.rs (L143-155)
```rust
    pub fn default_for_genesis() -> Self {
        BlockGasLimitType::ComplexLimitV1 {
            effective_block_gas_limit: 20000,
            execution_gas_effective_multiplier: 1,
            io_gas_effective_multiplier: 1,
            conflict_penalty_window: 9,
            use_granular_resource_group_conflicts: false,
            use_module_publishing_block_conflict: true,
            block_output_limit: Some(4 * 1024 * 1024),
            include_user_txn_size_in_block_output: true,
            add_block_limit_outcome_onchain: true,
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/object.move (L121-123)
```text
    #[resource_group(scope = global)]
    /// A shared resource group for storing object resources together in storage.
    struct ObjectGroup {}
```

**File:** aptos-move/framework/aptos-framework/sources/fungible_asset.move (L110-174)
```text
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct Supply has key {
        current: u128,
        // option::none() means unlimited supply.
        maximum: Option<u128>
    }

    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct ConcurrentSupply has key {
        current: Aggregator<u128>
    }

    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    /// Metadata of a Fungible asset
    struct Metadata has key, copy, drop {
        /// Name of the fungible metadata, i.e., "USDT".
        name: String,
        /// Symbol of the fungible metadata, usually a shorter version of the name.
        /// For example, Singapore Dollar is SGD.
        symbol: String,
        /// Number of decimals used for display purposes.
        /// For example, if `decimals` equals `2`, a balance of `505` coins should
        /// be displayed to a user as `5.05` (`505 / 10 ** 2`).
        decimals: u8,
        /// The Uniform Resource Identifier (uri) pointing to an image that can be used as the icon for this fungible
        /// asset.
        icon_uri: String,
        /// The Uniform Resource Identifier (uri) pointing to the website for the fungible asset.
        project_uri: String
    }

    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    /// Defines a `FungibleAsset`, such that all `FungibleStore`s stores are untransferable at
    /// the object layer.
    struct Untransferable has key {}

    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    /// The store object that holds fungible assets of a specific type associated with an account.
    struct FungibleStore has key {
        /// The address of the base metadata object.
        metadata: Object<Metadata>,
        /// The balance of the fungible metadata.
        balance: u64,
        /// If true, owner transfer is disabled that only `TransferRef` can move in/out from this store.
        frozen: bool
    }

    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct DispatchFunctionStore has key {
        withdraw_function: Option<FunctionInfo>,
        deposit_function: Option<FunctionInfo>,
        derived_balance_function: Option<FunctionInfo>
    }

    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct DeriveSupply has key {
        dispatch_function: Option<FunctionInfo>
    }

    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    /// The store object that holds concurrent fungible asset balance.
    struct ConcurrentFungibleBalance has key {
        /// The balance of the fungible metadata.
        balance: Aggregator<u64>
    }
```
