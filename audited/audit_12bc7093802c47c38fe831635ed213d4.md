# Audit Report

## Title
TransactionMatcher::Sender Filter Bypass via FeePayer Transaction Role Shifting

## Summary
The `TransactionMatcher::Sender` filter only validates the primary sender address from `RawTransaction.sender`, allowing attackers to bypass sender-based filters by shifting a blocked address into the `fee_payer_address` or `secondary_signer_addresses` roles in FeePayer transactions. This enables policy circumvention in mempool, consensus, execution, and quorum store filtering layers.

## Finding Description

The transaction filtering system provides two address-matching strategies: `TransactionMatcher::Sender` and `TransactionMatcher::AccountAddress`. While `AccountAddress` comprehensively checks all participant addresses, `Sender` only validates the primary sender field. [1](#0-0) 

The `Sender` matcher implementation exclusively checks `signed_transaction.sender()`: [2](#0-1) 

This method returns only the primary sender from the raw transaction: [3](#0-2) 

However, FeePayer transactions contain multiple address roles that are not checked by the `Sender` matcher: [4](#0-3) 

**Attack Scenario:**

1. Node operator configures filter to block suspicious address `0xBAD`:
   ```rust
   Deny(vec![TransactionMatcher::Sender(0xBAD)])
   ```

2. Attacker creates FeePayer transaction with:
   - `sender` = `0xCLEAN` (passes filter check)
   - `fee_payer_address` = `0xBAD` (unchecked by Sender matcher)
   - `secondary_signer_addresses` = `[0xANOTHER_BAD]` (unchecked)

3. Transaction bypasses filter despite `0xBAD` paying all gas fees and being economically responsible for the transaction.

The `AccountAddress` matcher does check all roles, but operators using the more intuitive "Sender" filter name are vulnerable: [5](#0-4) 

For FeePayer transactions specifically, only `AccountAddress` validates all participants: [6](#0-5) 

## Impact Explanation

**Severity: HIGH** (up to $50,000 per Aptos Bug Bounty)

This constitutes a **significant protocol violation** affecting critical security controls:

1. **Mempool Filtering Bypass**: Operators filtering malicious addresses from the mempool can be bypassed, allowing blocked addresses to submit transactions indirectly.

2. **Consensus Policy Violation**: Validators using `Sender` filters to reject transactions from specific addresses during block proposal/voting can be circumvented.

3. **Execution Layer Bypass**: Transaction execution filters intended to block specific addresses fail silently.

4. **Regulatory Compliance Failure**: Operators attempting to comply with sanctions or regulatory requirements by blocking specific addresses face compliance violations.

The filtering system is deployed at four critical points: [7](#0-6) 

All four filter points are vulnerable if operators use the `Sender` matcher instead of `AccountAddress`.

## Likelihood Explanation

**Likelihood: HIGH**

The vulnerability is highly likely to be exploited because:

1. **Intuitive Naming Trap**: "Sender" naturally suggests "the entity sending/initiating the transaction", which in FeePayer transactions includes the fee payer role. Operators naturally gravitate toward `Sender` over the more technical `AccountAddress`.

2. **Zero Exploitation Barrier**: Any user can create FeePayer transactions without special permissions.

3. **No Validation Warnings**: The system accepts `Sender` filters without warnings about incomplete coverage.

4. **Silent Failure**: Bypassed filters fail silently with no operator notification.

5. **Existing Test Coverage Gap**: Test suite includes `test_sender_filter` but only validates regular transactions, not FeePayer bypass scenarios: [8](#0-7) 

## Recommendation

**Immediate Fix: Expand Sender Matcher Scope**

Modify `TransactionMatcher::Sender` to check all signing roles in multi-party transactions, making it equivalent to `AccountAddress` for address matching but preserving semantic meaning:

```rust
TransactionMatcher::Sender(sender) => {
    matches_sender_address(signed_transaction, sender)
        || matches_transaction_authenticator_address(signed_transaction, sender)
}
```

This change would be implemented at: [2](#0-1) 

**Alternative Fix: Add Deprecation Warning**

If maintaining separate semantics is required, add prominent documentation and runtime warnings when `Sender` is used, directing operators to `AccountAddress` for comprehensive coverage.

**Long-term: Enhanced Filter Validation**

Implement filter validation that warns operators when using potentially incomplete matchers for security-critical filtering.

## Proof of Concept

```rust
#[cfg(test)]
mod exploit_test {
    use super::*;
    use crate::tests::utils;
    
    #[test]
    fn test_sender_filter_bypass_via_fee_payer() {
        // Create a suspicious address that should be blocked
        let suspicious_address = AccountAddress::random();
        
        // Operator configures filter to block suspicious address as sender
        let filter = TransactionFilter::empty()
            .add_sender_filter(false, suspicious_address)  // Deny suspicious sender
            .add_all_filter(true);  // Allow all others
        
        // Create regular transaction with suspicious address as sender
        let regular_txn = create_signed_transaction(
            TransactionPayload::EntryFunction(
                create_entry_function(str::parse("0x1::test::exploit").unwrap())
            ),
            false,  // not fee payer
        );
        // Manually set sender to suspicious_address in production code
        
        // Verify regular transaction is correctly blocked
        assert!(!filter.allows_transaction(&regular_txn), 
            "Regular transaction with suspicious sender should be blocked");
        
        // EXPLOIT: Create FeePayer transaction where suspicious address pays fees
        let exploit_txn = SignedTransaction::new_fee_payer(
            RawTransaction::new(
                AccountAddress::random(),  // Clean sender (passes filter!)
                0,
                TransactionPayload::EntryFunction(
                    create_entry_function(str::parse("0x1::test::exploit").unwrap())
                ),
                0, 0, 0,
                ChainId::new(10),
            ),
            AccountAuthenticator::NoAccountAuthenticator,
            vec![],  // No secondary signers
            vec![],
            suspicious_address,  // SUSPICIOUS ADDRESS AS FEE PAYER (unchecked!)
            AccountAuthenticator::NoAccountAuthenticator,
        );
        
        // VULNERABILITY: Transaction bypasses filter even though suspicious address pays
        assert!(filter.allows_transaction(&exploit_txn), 
            "EXPLOIT: FeePayer transaction with suspicious fee payer bypasses Sender filter!");
        
        // CORRECT APPROACH: Using AccountAddress matcher catches both cases
        let correct_filter = TransactionFilter::empty()
            .add_account_address_filter(false, suspicious_address)
            .add_all_filter(true);
        
        assert!(!correct_filter.allows_transaction(&exploit_txn),
            "AccountAddress matcher correctly blocks fee payer role");
    }
}
```

**Notes:**

The vulnerability exploits a semantic gap between operator expectations and implementation behavior. While `TransactionMatcher::AccountAddress` provides comprehensive coverage, the existence of a separate `Sender` matcher with incomplete coverage creates a security pitfall. The naming strongly suggests "sender" encompasses all transaction initiators, but the implementation narrowly interprets it as only the primary `RawTransaction.sender` field, ignoring fee payers and secondary signers in multi-party transactions.

### Citations

**File:** crates/aptos-transaction-filters/src/transaction_filter.rs (L174-174)
```rust
    Sender(AccountAddress), // Matches any transaction sent by a specific account address
```

**File:** crates/aptos-transaction-filters/src/transaction_filter.rs (L188-190)
```rust
            TransactionMatcher::Sender(sender) => {
                matches_sender_address(signed_transaction, sender)
            },
```

**File:** crates/aptos-transaction-filters/src/transaction_filter.rs (L197-203)
```rust
            TransactionMatcher::AccountAddress(address) => {
                matches_sender_address(signed_transaction, address)
                    || matches_entry_function_module_address(signed_transaction, address)
                    || matches_multisig_address(signed_transaction, address)
                    || matches_script_argument_address(signed_transaction, address)
                    || matches_transaction_authenticator_address(signed_transaction, address)
            },
```

**File:** crates/aptos-transaction-filters/src/transaction_filter.rs (L512-526)
```rust
        TransactionAuthenticator::FeePayer {
            sender,
            secondary_signer_addresses,
            secondary_signers,
            fee_payer_address,
            fee_payer_signer,
        } => {
            matches_account_authenticator_address(sender, address)
                || secondary_signer_addresses.contains(address)
                || secondary_signers
                    .iter()
                    .any(|signer| matches_account_authenticator_address(signer, address))
                || fee_payer_address == address
                || matches_account_authenticator_address(fee_payer_signer, address)
        },
```

**File:** types/src/transaction/mod.rs (L1242-1244)
```rust
    pub fn sender(&self) -> AccountAddress {
        self.raw_txn.sender
    }
```

**File:** types/src/transaction/authenticator.rs (L92-98)
```rust
    FeePayer {
        sender: AccountAuthenticator,
        secondary_signer_addresses: Vec<AccountAddress>,
        secondary_signers: Vec<AccountAuthenticator>,
        fee_payer_address: AccountAddress,
        fee_payer_signer: AccountAuthenticator,
    },
```

**File:** config/src/config/transaction_filters_config.rs (L12-18)
```rust
pub struct TransactionFiltersConfig {
    pub api_filter: TransactionFilterConfig, // Filter for the API (e.g., txn simulation)
    pub consensus_filter: BlockTransactionFilterConfig, // Filter for consensus (e.g., proposal voting)
    pub execution_filter: BlockTransactionFilterConfig, // Filter for execution (e.g., block execution)
    pub mempool_filter: TransactionFilterConfig,        // Filter for mempool (e.g., txn submission)
    pub quorum_store_filter: BatchTransactionFilterConfig, // Filter for quorum store (e.g., batch voting)
}
```

**File:** crates/aptos-transaction-filters/src/tests/transaction_filter.rs (L323-346)
```rust
fn test_sender_filter() {
    for use_new_txn_payload_format in [false, true] {
        // Create a filter that only allows transactions from a specific sender (txn 0 and txn 1)
        let transactions = utils::create_entry_function_transactions(use_new_txn_payload_format);
        let filter = TransactionFilter::empty()
            .add_sender_filter(true, transactions[0].sender())
            .add_sender_filter(true, transactions[1].sender())
            .add_all_filter(false);

        // Verify that the filter returns only transactions from the specified senders
        let filtered_transactions = filter.filter_transactions(transactions.clone());
        assert_eq!(filtered_transactions, transactions[0..2].to_vec());

        // Create a filter that denies transactions from a specific sender (txn 0 and txn 1)
        let filter = TransactionFilter::empty()
            .add_sender_filter(false, transactions[0].sender())
            .add_sender_filter(false, transactions[1].sender())
            .add_all_filter(true);

        // Verify that the filter returns all transactions except those from the specified senders
        let filtered_transactions = filter.filter_transactions(transactions.clone());
        assert_eq!(filtered_transactions, transactions[2..].to_vec());
    }
}
```
