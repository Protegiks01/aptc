# Audit Report

## Title
Payload Empty Check Bypass Leading to Temporary Block Execution Failures

## Summary
The `pull()` function in `QuorumStoreClient` uses `payload.is_empty()` to determine whether to retry payload fetching. However, `is_empty()` only checks structural emptiness (whether proof vectors are empty) rather than semantic validity (whether proofs reference retrievable transaction batches). This allows payloads with valid ProofOfStore objects but unretrievable batch data to bypass retry logic, causing block execution failures.

## Finding Description

The vulnerability exists in the payload retrieval retry logic: [1](#0-0) 

The `is_empty()` implementation only checks if proof vectors are structurally empty: [2](#0-1) 

When a proposer calls `pull()`, if it receives a `Payload::InQuorumStore` with non-empty `proofs` vector, the retry logic is bypassed immediately, even if those proofs reference batches that don't exist or cannot be retrieved.

During block execution, the system attempts to fetch actual transaction data: [3](#0-2) 

If batch data cannot be retrieved after retry attempts, execution returns `ExecutorError::CouldNotGetData`: [4](#0-3) 

When execution fails, the block is not advanced and consensus stalls on that proposal: [5](#0-4) 

**Attack scenarios:**
1. **Network partition**: Validator receives ProofOfStore but batch data is delayed/dropped
2. **Storage issues**: Batch data is corrupted or prematurely garbage collected
3. **Race conditions**: Timing issues between proof propagation and batch availability
4. **Byzantine behavior**: Malicious validators create valid ProofOfStore for non-existent batches (requires >1/3 collusion)

## Impact Explanation

This issue causes **temporary liveness degradation** (Medium severity):

- **Liveness Impact**: Proposers create blocks that fail to execute, wasting consensus rounds and delaying transaction finality
- **Resource Waste**: The batch requester makes multiple network requests attempting to fetch non-existent batches
- **Self-Healing**: The issue resolves when the next proposer creates a valid block
- **No Safety Violation**: Consensus safety is maintained; no double-spending or state corruption occurs
- **No Fund Loss**: No assets are at risk

This aligns with **Medium Severity** under "State inconsistencies requiring intervention" from the Aptos bug bounty program, though the intervention is minimal (waiting for next proposal round).

## Likelihood Explanation

**Likelihood: Low to Medium**

- **Natural occurrence**: Possible under network delays or storage issues without Byzantine behavior
- **Deliberate exploitation**: Requires >1/3 Byzantine validators to create invalid ProofOfStore objects
- **Frequency**: Limited by normal network conditions and ProofOfStore verification mechanisms
- **Detection**: Failures are logged and visible in metrics

The vulnerability is more likely to manifest as an operational issue during network stress rather than a targeted attack vector.

## Recommendation

Add semantic validation to the payload retry logic. The `is_empty()` check should be complemented with a verification that proofs reference retrievable batches:

```rust
// In quorum_store_client.rs pull() function
let payload = loop {
    let done = start_time.elapsed() >= params.max_poll_time;
    let payload = self.pull_internal(...).await?;
    
    // Enhanced check: verify payload is both non-empty AND executable
    let is_potentially_executable = !payload.is_empty() && 
        self.verify_payload_batches_exist(&payload);
    
    if !is_potentially_executable && !return_empty && !done {
        sleep(Duration::from_millis(NO_TXN_DELAY)).await;
        continue;
    }
    break payload;
};
```

Implement `verify_payload_batches_exist()` to check with BatchStore whether referenced batches are locally available before returning the payload to the proposer.

## Proof of Concept

```rust
// Rust test demonstrating the vulnerability
#[tokio::test]
async fn test_empty_check_bypass_with_unretrievable_batches() {
    // Setup: Create a ProofOfStore with valid signatures but non-existent batch
    let batch_info = BatchInfo::new(
        author,
        batch_id,
        epoch,
        expiration,
        HashValue::random(), // Random digest - batch doesn't exist
        100, // num_txns > 0 (reports non-empty)
        1000,
        0,
    );
    
    let proof = ProofOfStore::new(batch_info, aggregate_signature);
    let payload = Payload::InQuorumStore(ProofWithData::new(vec![proof]));
    
    // Verify: is_empty() returns false despite batch being unretrievable
    assert!(!payload.is_empty()); // Bypass condition met
    
    // Execute: Attempt to retrieve batches will fail
    let result = batch_reader.get_batch(batch_info, responders).await;
    assert!(matches!(result, Err(ExecutorError::CouldNotGetData)));
    
    // Impact: Block execution fails, consensus round wasted
}
```

---

**Note**: While this report identifies a legitimate semantic gap in the payload validation logic, the practical security impact is limited. The issue primarily affects liveness temporarily rather than causing permanent damage or fund loss. The extremely high bar for vulnerability validity suggests this may be better classified as an operational reliability concern rather than a critical security vulnerability.

### Citations

**File:** consensus/src/payload_client/user/quorum_store_client.rs (L124-128)
```rust
            if payload.is_empty() && !return_empty && !done {
                sleep(Duration::from_millis(NO_TXN_DELAY)).await;
                continue;
            }
            break payload;
```

**File:** consensus/consensus-types/src/common.rs (L342-355)
```rust
    pub fn is_empty(&self) -> bool {
        match self {
            Payload::DirectMempool(txns) => txns.is_empty(),
            Payload::InQuorumStore(proof_with_status) => proof_with_status.proofs.is_empty(),
            Payload::InQuorumStoreWithLimit(proof_with_status) => {
                proof_with_status.proof_with_data.proofs.is_empty()
            },
            Payload::QuorumStoreInlineHybrid(inline_batches, proof_with_data, _)
            | Payload::QuorumStoreInlineHybridV2(inline_batches, proof_with_data, _) => {
                proof_with_data.proofs.is_empty() && inline_batches.is_empty()
            },
            Payload::OptQuorumStore(opt_qs_payload) => opt_qs_payload.is_empty(),
        }
    }
```

**File:** consensus/src/payload_manager/quorum_store_payload_manager.rs (L641-662)
```rust
async fn process_qs_payload(
    proof_with_data: &ProofWithData,
    batch_reader: Arc<dyn BatchReader>,
    block: &Block,
    ordered_authors: &[PeerId],
) -> ExecutorResult<Vec<SignedTransaction>> {
    QuorumStorePayloadManager::request_and_wait_transactions(
        proof_with_data
            .proofs
            .iter()
            .map(|proof| {
                (
                    proof.info().clone(),
                    proof.shuffled_signers(ordered_authors),
                )
            })
            .collect(),
        block.timestamp_usecs(),
        batch_reader,
    )
    .await
}
```

**File:** consensus/src/quorum_store/batch_requester.rs (L176-179)
```rust
            counters::RECEIVED_BATCH_REQUEST_TIMEOUT_COUNT.inc();
            debug!("QS: batch request timed out, digest:{}", digest);
            Err(ExecutorError::CouldNotGetData)
        })
```

**File:** consensus/src/pipeline/buffer_manager.rs (L617-627)
```rust
        let executed_blocks = match inner {
            Ok(result) => result,
            Err(e) => {
                log_executor_error_occurred(
                    e,
                    &counters::BUFFER_MANAGER_RECEIVED_EXECUTOR_ERROR_COUNT,
                    block_id,
                );
                return;
            },
        };
```
