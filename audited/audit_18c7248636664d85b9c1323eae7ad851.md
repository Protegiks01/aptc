# Audit Report

## Title
SafetyRules Remote Service CPU Exhaustion DoS via Unbounded Message Processing

## Summary
The `execute()` function in `consensus/safety-rules/src/remote_service.rs` processes messages synchronously without timeout protection, allowing an attacker to send computationally expensive messages that consume significant CPU time while blocking the service loop, degrading validator performance.

## Finding Description

The SafetyRules remote service implements an infinite loop that processes incoming network messages synchronously: [1](#0-0) 

The `process_one_message()` function calls `handle_message()` without any timeout: [2](#0-1) 

While network read/write operations have timeout protection configured via `NetworkStream`, the message processing logic itself has no timeout: [3](#0-2) 

The `handle_message()` function deserializes and processes messages synchronously: [4](#0-3) 

An attacker can exploit this by:

1. **Large EpochChangeProof Attack**: Sending an `Initialize` message containing an `EpochChangeProof` with thousands of `LedgerInfoWithSignatures`. The `verify()` method iterates through all entries performing expensive BLS signature verification: [5](#0-4) 

Each signature verification involves cryptographic operations: [6](#0-5) 

2. **Large JSON Deserialization**: Sending extremely large (up to 4GB per u32 length prefix) but syntactically valid JSON that consumes significant CPU during deserialization.

The `NetworkStream` accepts messages up to `u32::MAX` size without application-level validation: [7](#0-6) 

**Critical Issue**: The SafetyRules remote service has **no authentication mechanism**, unlike other Aptos services. Any network peer can connect and send malicious messages.

## Impact Explanation

This qualifies as **High Severity** per Aptos bug bounty criteria ("Validator node slowdowns"). However, the practical impact is **significantly limited** because:

The configuration sanitizer explicitly **prevents** remote service mode in mainnet: [8](#0-7) 

This vulnerability only affects:
- Non-mainnet test networks
- Development environments
- Validators that deliberately misconfigure against sanitizer warnings

The attack causes the SafetyRules service loop to block during expensive message processing, preventing legitimate consensus operations (signing proposals, constructing votes) from being processed promptly, degrading validator participation in consensus.

## Likelihood Explanation

**Low likelihood in production** due to config sanitizer enforcement. Exploitation requires:
1. Network access to SafetyRules remote service endpoint
2. Validator operator deliberately using Process mode despite mainnet restrictions
3. No authentication allows trivial exploitation once accessible

## Recommendation

1. **Add processing timeout** to `handle_message()` call:

```rust
fn process_one_message(
    network_server: &mut NetworkServer,
    serializer_service: &mut SerializerService,
) -> Result<(), Error> {
    let request = network_server.read()?;
    
    // Add timeout for message processing
    let timeout = Duration::from_millis(network_timeout_ms);
    let response = timeout::timeout(timeout, async {
        serializer_service.handle_message(request)
    }).await??;
    
    network_server.write(&response)?;
    Ok(())
}
```

2. **Add message size limits** before deserialization:

```rust
const MAX_MESSAGE_SIZE: usize = 10 * 1024 * 1024; // 10MB limit
if request.len() > MAX_MESSAGE_SIZE {
    return Err(Error::DataTooLarge(request.len()));
}
```

3. **Add authentication** to remote service (mutual TLS, token-based auth)

4. **Add rate limiting** per client connection

## Proof of Concept

```rust
#[test]
fn test_cpu_exhaustion_via_large_epoch_change_proof() {
    use aptos_types::epoch_change::EpochChangeProof;
    use aptos_types::ledger_info::LedgerInfoWithSignatures;
    
    // Start SafetyRules remote service in background thread
    let listen_addr = "127.0.0.1:9999".parse().unwrap();
    std::thread::spawn(move || {
        let storage = PersistentSafetyStorage::in_memory(...);
        execute(storage, listen_addr, 30_000);
    });
    
    // Create malicious message with 10,000 ledger infos
    let mut large_proof_ledger_infos = vec![];
    for _ in 0..10000 {
        // Create LedgerInfoWithSignatures with invalid but expensive-to-verify signatures
        large_proof_ledger_infos.push(create_ledger_info_with_signatures());
    }
    
    let malicious_proof = EpochChangeProof::new(large_proof_ledger_infos, false);
    let malicious_input = SafetyRulesInput::Initialize(Box::new(malicious_proof));
    
    // Serialize and send to remote service
    let message = serde_json::to_vec(&malicious_input).unwrap();
    
    // Connect and send - will block service for extended period
    let mut client = NetworkClient::new("attacker".to_string(), listen_addr, 30_000);
    
    let start = Instant::now();
    client.write(&message).unwrap();
    let _ = client.read(); // Will eventually timeout or fail, but CPU damage done
    
    println!("Service blocked for: {:?}", start.elapsed());
    // Legitimate consensus messages cannot be processed during this time
}
```

---

**Notes**

While this is a valid technical vulnerability (unbounded synchronous processing without timeout), its **practical exploitability is severely limited** by the configuration sanitizer that prevents remote service mode in mainnet. The vulnerability only affects non-production environments where operators deliberately use Process mode configuration. Given the "EXTREMELY high" bar for validity and requirement for "realistic" attack paths, this finding may not qualify for bug bounty rewards focused on mainnet security, but represents important defense-in-depth hardening for test environments and private networks.

### Citations

**File:** consensus/safety-rules/src/remote_service.rs (L40-44)
```rust
    loop {
        if let Err(e) = process_one_message(&mut network_server, &mut serializer_service) {
            warn!("Failed to process message: {}", e);
        }
    }
```

**File:** consensus/safety-rules/src/remote_service.rs (L47-55)
```rust
fn process_one_message(
    network_server: &mut NetworkServer,
    serializer_service: &mut SerializerService,
) -> Result<(), Error> {
    let request = network_server.read()?;
    let response = serializer_service.handle_message(request)?;
    network_server.write(&response)?;
    Ok(())
}
```

**File:** secure/net/src/lib.rs (L415-427)
```rust
    pub fn new(stream: TcpStream, remote: SocketAddr, timeout_ms: u64) -> Self {
        let timeout = Some(std::time::Duration::from_millis(timeout_ms));
        // These only fail if a duration of 0 is passed in.
        stream.set_read_timeout(timeout).unwrap();
        stream.set_write_timeout(timeout).unwrap();

        Self {
            stream,
            remote,
            buffer: Vec::new(),
            temp_buffer: [0; 1024],
        }
    }
```

**File:** secure/net/src/lib.rs (L479-496)
```rust
    fn read_buffer(&mut self) -> Vec<u8> {
        if self.buffer.len() < 4 {
            return Vec::new();
        }

        let mut u32_bytes = [0; 4];
        u32_bytes.copy_from_slice(&self.buffer[..4]);
        let data_size = u32::from_le_bytes(u32_bytes) as usize;

        let remaining_data = &self.buffer[4..];
        if remaining_data.len() < data_size {
            return Vec::new();
        }

        let returnable_data = remaining_data[..data_size].to_vec();
        self.buffer = remaining_data[data_size..].to_vec();
        returnable_data
    }
```

**File:** consensus/safety-rules/src/serializer.rs (L45-82)
```rust
    pub fn handle_message(&mut self, input_message: Vec<u8>) -> Result<Vec<u8>, Error> {
        let input = serde_json::from_slice(&input_message)?;

        let output = match input {
            SafetyRulesInput::ConsensusState => {
                serde_json::to_vec(&self.internal.consensus_state())
            },
            SafetyRulesInput::Initialize(li) => serde_json::to_vec(&self.internal.initialize(&li)),
            SafetyRulesInput::SignProposal(block_data) => {
                serde_json::to_vec(&self.internal.sign_proposal(&block_data))
            },
            SafetyRulesInput::SignTimeoutWithQC(timeout, maybe_tc) => serde_json::to_vec(
                &self
                    .internal
                    .sign_timeout_with_qc(&timeout, maybe_tc.as_ref().as_ref()),
            ),
            SafetyRulesInput::ConstructAndSignVoteTwoChain(vote_proposal, maybe_tc) => {
                serde_json::to_vec(
                    &self.internal.construct_and_sign_vote_two_chain(
                        &vote_proposal,
                        maybe_tc.as_ref().as_ref(),
                    ),
                )
            },
            SafetyRulesInput::ConstructAndSignOrderVote(order_vote_proposal) => serde_json::to_vec(
                &self
                    .internal
                    .construct_and_sign_order_vote(&order_vote_proposal),
            ),
            SafetyRulesInput::SignCommitVote(ledger_info, new_ledger_info) => serde_json::to_vec(
                &self
                    .internal
                    .sign_commit_vote(*ledger_info, *new_ledger_info),
            ),
        };

        Ok(output?)
    }
```

**File:** types/src/epoch_change.rs (L66-118)
```rust
    pub fn verify(&self, verifier: &dyn Verifier) -> Result<&LedgerInfoWithSignatures> {
        ensure!(
            !self.ledger_info_with_sigs.is_empty(),
            "The EpochChangeProof is empty"
        );
        ensure!(
            !verifier
                .is_ledger_info_stale(self.ledger_info_with_sigs.last().unwrap().ledger_info()),
            "The EpochChangeProof is stale as our verifier is already ahead \
             of the entire EpochChangeProof"
        );
        let mut verifier_ref = verifier;

        for ledger_info_with_sigs in self
            .ledger_info_with_sigs
            .iter()
            // Skip any stale ledger infos in the proof prefix. Note that with
            // the assertion above, we are guaranteed there is at least one
            // non-stale ledger info in the proof.
            //
            // It's useful to skip these stale ledger infos to better allow for
            // concurrent client requests.
            //
            // For example, suppose the following:
            //
            // 1. My current trusted state is at epoch 5.
            // 2. I make two concurrent requests to two validators A and B, who
            //    live at epochs 9 and 11 respectively.
            //
            // If A's response returns first, I will ratchet my trusted state
            // to epoch 9. When B's response returns, I will still be able to
            // ratchet forward to 11 even though B's EpochChangeProof
            // includes a bunch of stale ledger infos (for epochs 5, 6, 7, 8).
            //
            // Of course, if B's response returns first, we will reject A's
            // response as it's completely stale.
            .skip_while(|&ledger_info_with_sigs| {
                verifier.is_ledger_info_stale(ledger_info_with_sigs.ledger_info())
            })
        {
            // Try to verify each (epoch -> epoch + 1) jump in the EpochChangeProof.
            verifier_ref.verify(ledger_info_with_sigs)?;
            // While the original verification could've been via waypoints,
            // all the next epoch changes are verified using the (already
            // trusted) validator sets.
            verifier_ref = ledger_info_with_sigs
                .ledger_info()
                .next_epoch_state()
                .ok_or_else(|| format_err!("LedgerInfo doesn't carry a ValidatorSet"))?;
        }

        Ok(self.ledger_info_with_sigs.last().unwrap())
    }
```

**File:** types/src/epoch_state.rs (L40-50)
```rust
impl Verifier for EpochState {
    fn verify(&self, ledger_info: &LedgerInfoWithSignatures) -> anyhow::Result<()> {
        ensure!(
            self.epoch == ledger_info.ledger_info().epoch(),
            "LedgerInfo has unexpected epoch {}, expected {}",
            ledger_info.ledger_info().epoch(),
            self.epoch
        );
        ledger_info.verify_signatures(&self.verifier)?;
        Ok(())
    }
```

**File:** config/src/config/safety_rules_config.rs (L98-104)
```rust
            // Verify that the safety rules service is set to local for optimal performance
            if chain_id.is_mainnet() && !safety_rules_config.service.is_local() {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    format!("The safety rules service should be set to local in mainnet for optimal performance! Given config: {:?}", &safety_rules_config.service)
                ));
            }
```
