# Audit Report

## Title
Error Code Collision in Rosetta API Causing Exchange Mishandling of Transaction Update Failures

## Summary
The Aptos Rosetta implementation contains an error code collision where `AptosErrorCode::InvalidTransactionUpdate` from the REST API is incorrectly mapped to `ApiError::InvalidInput` (code 28) instead of `ApiError::InvalidTransactionUpdate` (code 29). This causes exchanges to receive the wrong error code when transaction updates fail, potentially leading to incorrect retry logic and improper handling of user funds.

## Finding Description
The Rosetta API serves as a standardized interface for cryptocurrency exchanges to integrate with Aptos blockchain. According to the Rosetta specification and implementation requirements, all error codes must be static, unique, and properly documented in the `/network/options` endpoint. [1](#0-0) 

The vulnerability occurs in the error conversion logic where REST API errors are mapped to Rosetta API errors: [2](#0-1) 

This mapping incorrectly converts `AptosErrorCode::InvalidTransactionUpdate` to `ApiError::InvalidInput` instead of `ApiError::InvalidTransactionUpdate`. The consequence is that both REST API error conditions map to the same Rosetta error code 28: [3](#0-2) 

**Attack Scenario:**

1. Exchange queries `/network/options` and receives error catalog showing:
   - Code 28: "Invalid input"  
   - Code 29: "Invalid transaction update. Can only update gas unit price"

2. User submits a transaction to the exchange for a withdrawal

3. Exchange attempts to update the transaction (e.g., adjusting parameters other than gas price)

4. The mempool rejects this with `MempoolStatusCode::InvalidUpdate`: [4](#0-3) 

5. This gets converted to `AptosErrorCode::InvalidTransactionUpdate` with code 401 in REST API: [5](#0-4) 

6. Rosetta incorrectly maps this to `ApiError::InvalidInput` (code 28) instead of code 29

7. Exchange receives code 28 and treats it as a generic invalid input error rather than a specific transaction update restriction

This breaks the security guarantee that error codes are unique and deterministic. Exchanges may implement different retry logic for generic invalid inputs (code 28) versus transaction update restrictions (code 29), potentially causing:
- Inappropriate retry attempts that waste resources
- Incorrect user notifications about why their transaction failed  
- Improper fund handling if retry logic differs between error types
- Transaction stuck states if the exchange expects code 29 but receives code 28

## Impact Explanation
This qualifies as **Medium Severity** per Aptos Bug Bounty criteria for the following reasons:

1. **Limited Funds Loss or Manipulation**: Exchanges may implement incorrect retry logic that could temporarily lock user funds or cause double-processing attempts, leading to limited financial impact on exchange users.

2. **State Inconsistencies Requiring Intervention**: The mismatch between documented error codes and actual error codes returned creates an operational inconsistency that requires manual intervention to resolve exchange integration issues.

3. **API Contract Violation**: The Rosetta specification explicitly requires error codes to be static and unique. This violation breaks the API contract that exchanges depend on, potentially affecting all exchanges integrating with Aptos via Rosetta.

4. **No Consensus Impact**: This issue is confined to the Rosetta API layer and does not affect consensus, validator operations, or core blockchain functionality.

The issue is not Critical or High severity because it does not directly cause consensus violations, validator compromise, or permanent fund loss. However, it is more severe than Low because it can lead to operational issues and potential limited financial impact for exchanges and their users.

## Likelihood Explanation
This vulnerability has **HIGH likelihood** of occurring:

1. **Common Operation**: Transaction updates are a common operation when exchanges need to adjust gas prices or other parameters before submission.

2. **Affects All Exchanges**: Any exchange using the Rosetta API to integrate with Aptos will encounter this issue when handling transaction update errors.

3. **Already Deployed**: This bug exists in the production codebase and affects all current Rosetta deployments.

4. **Automatic Trigger**: The bug triggers automatically whenever the mempool returns an `InvalidUpdate` status - no special conditions or attacker actions required beyond normal transaction update operations.

5. **No Mitigation**: There is no workaround for exchanges other than ignoring the documented error catalog and implementing custom error handling based on trial-and-error.

## Recommendation

Fix the error mapping in the `From<RestError> for ApiError` implementation to correctly map `AptosErrorCode::InvalidTransactionUpdate` to `ApiError::InvalidTransactionUpdate`: [2](#0-1) 

**Corrected code:**
```rust
AptosErrorCode::InvalidTransactionUpdate => {
    ApiError::InvalidTransactionUpdate(Some(err.error.message))
},
```

Additionally, add the missing `RejectedByFilter(None)` to the `all()` method to ensure all error codes are properly documented in the error catalog: [6](#0-5) 

**Add after line 104:**
```rust
MempoolIsFull(None),
RejectedByFilter(None),
```

## Proof of Concept

```rust
#[cfg(test)]
mod test_error_collision {
    use super::*;
    use aptos_rest_client::error::RestError;
    use aptos_rest_client::aptos_api_types::{AptosError, AptosErrorCode};

    #[test]
    fn test_invalid_transaction_update_collision() {
        // Create a REST API error for InvalidTransactionUpdate
        let rest_error = RestError::Api(aptos_rest_client::error::AptosErrorResponse {
            error: AptosError {
                message: "Can only update gas unit price".to_string(),
                error_code: AptosErrorCode::InvalidTransactionUpdate,
                vm_error_code: None,
            },
            state: Default::default(),
        });

        // Convert to ApiError
        let api_error: ApiError = rest_error.into();
        
        // BUG: This should be code 29 (InvalidTransactionUpdate)
        // but instead it's code 28 (InvalidInput)
        assert_eq!(api_error.code(), 29, 
            "Expected InvalidTransactionUpdate code 29, got code {}", 
            api_error.code()
        );

        // This assertion will FAIL, demonstrating the bug
        // The actual code returned is 28, not 29
    }

    #[test]
    fn test_error_catalog_completeness() {
        // Get all errors that should be in the catalog
        let all_errors = ApiError::all();
        let error_codes: Vec<u32> = all_errors.iter().map(|e| e.code()).collect();

        // RejectedByFilter (code 35) should be in the catalog but is missing
        assert!(error_codes.contains(&35), 
            "RejectedByFilter (code 35) is missing from error catalog");
            
        // This assertion will FAIL, demonstrating the missing error
    }
}
```

**Expected Output**: Both tests fail, demonstrating:
1. `InvalidTransactionUpdate` returns code 28 instead of 29
2. `RejectedByFilter` (code 35) is missing from the error catalog

This can be verified by submitting a transaction update through the Rosetta `/construction/submit` endpoint and observing the error code returned when the mempool rejects it with `InvalidUpdate` status.

### Citations

**File:** crates/aptos-rosetta/README.md (L85-88)
```markdown

All errors are 500s and have error codes that are static and must not change.  To add more errors,
add new codes and associated data.  The error details must not show in the network options call and
are all provided as Option<String> for that reason.
```

**File:** crates/aptos-rosetta/src/error.rs (L104-106)
```rust
            MempoolIsFull(None),
        ]
    }
```

**File:** crates/aptos-rosetta/src/error.rs (L139-140)
```rust
            InvalidInput(_) => 28,
            InvalidTransactionUpdate(_) => 29,
```

**File:** crates/aptos-rosetta/src/error.rs (L299-301)
```rust
                AptosErrorCode::InvalidTransactionUpdate => {
                    ApiError::InvalidInput(Some(err.error.message))
                },
```

**File:** api/src/transactions.rs (L1478-1481)
```rust
            MempoolStatusCode::InvalidUpdate => Err(AptosError::new_with_error_code(
                mempool_status.message,
                AptosErrorCode::InvalidTransactionUpdate,
            )),
```

**File:** api/types/src/error.rs (L92-93)
```rust
    /// The transaction was an invalid update to an already submitted transaction.
    InvalidTransactionUpdate = 401,
```
