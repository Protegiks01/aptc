# Audit Report

## Title
DelayedFieldID Validation Bypass Leading to Validator Panic via Malicious State Injection

## Summary
The `find_identifiers_in_value_impl()` function performs insufficient validation of DelayedFieldID values, only checking for duplicates. Combined with unsafe `.expect()` calls in the identifier exchange logic, this allows state corruption attacks when malicious DelayedFieldIDs are injected into storage, causing validator panics and potential consensus failures.

## Finding Description

The vulnerability exists in the delayed field identifier validation and exchange mechanism: [1](#0-0) 

The function only validates that DelayedFieldID values are not duplicated within a single value, but performs no verification that the IDs reference legitimate, existing delayed fields. 

When resources are deserialized from storage with delayed fields: [2](#0-1) 

The system uses `with_delayed_fields_serde()` which extracts DelayedFieldIDs without validation: [3](#0-2) 

During deserialization with `mapping = None`, the code calls `DelayedFieldID::try_from_move_value()` which converts any u64/u128/derived_string value matching the layout into a DelayedFieldID without verifying legitimacy.

When these resources later require identifier exchange (replacing IDs with actual values): [4](#0-3) 

The code uses `.expect()` on lines 101 and 104, which panics if the DelayedFieldID doesn't have a corresponding value in the delayed fields storage.

**Attack Vector**: During state synchronization, state values are written directly to storage: [5](#0-4) 

No deserialization or semantic validation occurs—only Merkle proof verification confirms the data was part of a committed state. If an attacker can provide malicious state snapshot data (via compromised state sync peer, byzantine validator, or state sync protocol vulnerability), resources containing arbitrary DelayedFieldID values can be injected into storage.

**Exploitation Path**:
1. Attacker crafts resource with Native field containing fake DelayedFieldID (arbitrary u64 value not in delayed fields storage)
2. Malicious state snapshot data containing this resource is provided during state sync
3. Data passes Merkle proof verification and is written to storage
4. Later transaction accesses and attempts to modify this resource
5. `replace_identifiers_with_values` is called: [6](#0-5) 

6. Deserialization succeeds, extracting fake DelayedFieldID
7. Serialization with `with_delayed_fields_replacement()` calls `identifier_to_value` for fake ID
8. `.expect()` panics: "Committed value for ID must always exist" or "Delayed field value for ID must always exist in sequential execution"
9. Validator crashes

## Impact Explanation

**Critical Severity** - This vulnerability breaks multiple critical invariants:

1. **Consensus Safety**: If different validators receive different malicious state during sync, they will have inconsistent storage. When transactions access the corrupted resources, some validators panic while others continue, causing a consensus split.

2. **Deterministic Execution**: The `.expect()` panic is non-deterministic based on whether a validator's storage was corrupted, violating the requirement that all validators produce identical results.

3. **Network Liveness**: If all validators sync malicious state, any transaction touching the corrupted resource causes network-wide validator crashes, resulting in total loss of liveness requiring manual intervention or hard fork.

4. **State Consistency**: The system's assumption that all DelayedFieldIDs in storage are valid is violated, corrupting the integrity of the state machine.

This qualifies as Critical severity per Aptos bug bounty criteria:
- "Consensus/Safety violations" 
- "Non-recoverable network partition (requires hardfork)"
- "Total loss of liveness/network availability"

## Likelihood Explanation

**Medium to High Likelihood**:

**Prerequisites**:
- Attacker must inject malicious state during state sync (requires compromised peer, byzantine validator, or state sync protocol exploit)
- A transaction must access and attempt to modify the corrupted resource

**Likelihood Factors**:
- State sync is a critical operation performed by new/recovering validators
- No validation prevents malicious data injection beyond Merkle proof verification
- The `.expect()` assumes perfect storage integrity without defensive programming
- Once injected, the malicious state persists and affects all future access attempts

**Mitigating Factors**:
- Requires state sync from malicious source
- Merkle proof verification provides some protection
- May require specific transaction patterns to trigger

However, the presence of unsafe `.expect()` calls combined with zero validation makes this highly concerning. A single successful injection can cause cascading failures across the network.

## Recommendation

Implement multi-layered validation:

**1. Validate DelayedFieldIDs during deserialization** - Modify `find_identifiers_in_value_impl()`:

```rust
Value::DelayedFieldID { id } => {
    // Check for duplicates
    if !identifiers.insert(id.as_u64()) {
        return Err(code_invariant_error(
            "Duplicated identifiers for Move value".to_string(),
        ));
    }
    // ADDED: Validate ID exists (requires passing delayed field storage context)
    // This validation should be added when context is available
}
```

**2. Replace `.expect()` with defensive error handling** in `identifier_to_value`:

```rust
let delayed_field = match &self.latest_view.latest_view {
    ViewState::Sync(state) => state
        .versioned_map
        .delayed_fields()
        .read_latest_predicted_value(
            &identifier,
            self.txn_idx,
            ReadPosition::AfterCurrentTxn,
        )
        .ok_or_else(|| {
            PartialVMError::new(StatusCode::DELAYED_FIELD_NOT_FOUND)
                .with_message(format!(
                    "DelayedFieldID {:?} not found in delayed field storage",
                    identifier
                ))
        })?,
    ViewState::Unsync(state) => state
        .read_delayed_field(identifier)
        .ok_or_else(|| {
            PartialVMError::new(StatusCode::DELAYED_FIELD_NOT_FOUND)
                .with_message(format!(
                    "DelayedFieldID {:?} not found in sequential execution",
                    identifier
                ))
        })?,
};
```

**3. Add validation during state sync** - Before writing state values, deserialize resources with delayed fields and verify all DelayedFieldIDs are valid or sanitize them.

**4. Add comprehensive validation** in `replace_identifiers_with_values` before exchange:

```rust
// After deserialization, validate all extracted IDs exist
for id in &mapping.delayed_field_ids.borrow() {
    // Verify ID exists in delayed field storage
    // Return error if invalid rather than panicking later
}
```

## Proof of Concept

```rust
// Rust test demonstrating the panic
#[test]
#[should_panic(expected = "Committed value for ID must always exist")]
fn test_fake_delayed_field_id_panic() {
    // 1. Create malicious StateValue containing resource with fake DelayedFieldID
    let fake_id = DelayedFieldID::from(999999u64); // Non-existent ID
    let malicious_value = create_resource_with_delayed_field(fake_id);
    let malicious_bytes = serialize_with_delayed_fields_serde(&malicious_value);
    
    // 2. Inject into storage via state sync (simulated)
    inject_state_value_via_sync(address, resource_type, malicious_bytes);
    
    // 3. Transaction attempts to access and modify the resource
    let view = create_latest_view();
    let layout = get_resource_layout();
    
    // 4. This will panic when trying to exchange the fake ID
    // because identifier_to_value calls .expect() on non-existent ID
    view.replace_identifiers_with_values(&malicious_bytes, &layout)
        .expect("Should panic due to fake DelayedFieldID");
}

// Attack simulation showing state sync injection:
// 1. Attacker controls state sync peer or compromises validator
// 2. Crafts StateValue bytes with Native field = fake DelayedFieldID encoded as u64
// 3. Provides malicious state snapshot with valid Merkle proof (from compromised source)
// 4. Victim validator writes data to storage without semantic validation
// 5. Next transaction touching the resource triggers panic, crashing validator
```

## Notes

The vulnerability exists at the intersection of three subsystems:
1. **Value traversal** - insufficient validation
2. **State synchronization** - no semantic validation of state values  
3. **Identifier exchange** - unsafe `.expect()` assumptions

The root cause is violation of the invariant: "All DelayedFieldIDs in storage must reference existing delayed fields." This invariant is assumed but not enforced, creating a security gap exploitable through state injection attacks. The defensive programming principle of "never trust external data" is violated—state sync data should be treated as untrusted and validated before use.

### Citations

**File:** third_party/move/move-vm/types/src/value_traversal.rs (L83-89)
```rust
        Value::DelayedFieldID { id } => {
            if !identifiers.insert(id.as_u64()) {
                return Err(code_invariant_error(
                    "Duplicated identifiers for Move value".to_string(),
                ));
            }
        },
```

**File:** third_party/move/move-vm/runtime/src/data_cache.rs (L302-314)
```rust
                let val = ValueSerDeContext::new(max_value_nest_depth)
                    .with_func_args_deserialization(&function_value_extension)
                    .with_delayed_fields_serde()
                    .deserialize(&blob, &layout)
                    .ok_or_else(|| {
                        let msg = format!(
                            "Failed to deserialize resource {} at {}!",
                            struct_tag.to_canonical_string(),
                            addr
                        );
                        PartialVMError::new(StatusCode::FAILED_TO_DESERIALIZE_RESOURCE)
                            .with_message(msg)
                    })?;
```

**File:** third_party/move/move-vm/types/src/values/values_impl.rs (L5193-5204)
```rust
                            None => {
                                let (id, _) =
                                    DelayedFieldID::try_from_move_value(layout, value, &())
                                        .map_err(|_| {
                                            D::Error::custom(format!(
                                        "Custom deserialization failed for {:?} with layout {}",
                                        kind, layout
                                    ))
                                        })?;
                                id
                            },
                        };
```

**File:** aptos-move/block-executor/src/value_exchange.rs (L86-107)
```rust
    fn identifier_to_value(
        &self,
        layout: &MoveTypeLayout,
        identifier: DelayedFieldID,
    ) -> PartialVMResult<Value> {
        self.delayed_field_ids.borrow_mut().insert(identifier);
        let delayed_field = match &self.latest_view.latest_view {
            ViewState::Sync(state) => state
                .versioned_map
                .delayed_fields()
                .read_latest_predicted_value(
                    &identifier,
                    self.txn_idx,
                    ReadPosition::AfterCurrentTxn,
                )
                .expect("Committed value for ID must always exist"),
            ViewState::Unsync(state) => state
                .read_delayed_field(identifier)
                .expect("Delayed field value for ID must always exist in sequential execution"),
        };
        delayed_field.try_into_move_value(layout, identifier.extract_width())
    }
```

**File:** storage/aptosdb/src/state_restore/mod.rs (L228-258)
```rust
    fn add_chunk(&mut self, chunk: Vec<(K, V)>, proof: SparseMerkleRangeProof) -> Result<()> {
        let kv_fn = || {
            let _timer = OTHER_TIMERS_SECONDS.timer_with(&["state_value_add_chunk"]);
            self.kv_restore
                .lock()
                .as_mut()
                .unwrap()
                .add_chunk(chunk.clone())
        };

        let tree_fn = || {
            let _timer = OTHER_TIMERS_SECONDS.timer_with(&["jmt_add_chunk"]);
            self.tree_restore
                .lock()
                .as_mut()
                .unwrap()
                .add_chunk_impl(chunk.iter().map(|(k, v)| (k, v.hash())).collect(), proof)
        };
        match self.restore_mode {
            StateSnapshotRestoreMode::KvOnly => kv_fn()?,
            StateSnapshotRestoreMode::TreeOnly => tree_fn()?,
            StateSnapshotRestoreMode::Default => {
                // We run kv_fn with TreeOnly to restore the usage of DB
                let (r1, r2) = IO_POOL.join(kv_fn, tree_fn);
                r1?;
                r2?;
            },
        }

        Ok(())
    }
```

**File:** aptos-move/block-executor/src/view.rs (L1316-1334)
```rust
        let value = ValueSerDeContext::new(function_value_extension.max_value_nest_depth())
            .with_func_args_deserialization(&function_value_extension)
            .with_delayed_fields_serde()
            .deserialize(bytes, layout)
            .ok_or_else(|| {
                anyhow::anyhow!(
                    "Failed to deserialize resource during id replacement: {:?}",
                    bytes
                )
            })?;

        let mapping = TemporaryValueToIdentifierMapping::new(self, self.txn_idx);
        let patched_bytes = ValueSerDeContext::new(function_value_extension.max_value_nest_depth())
            .with_delayed_fields_replacement(&mapping)
            .with_func_args_deserialization(&function_value_extension)
            .serialize(&value, layout)?
            .ok_or_else(|| anyhow::anyhow!("Failed to serialize resource during id replacement"))?
            .into();
        Ok((patched_bytes, mapping.into_inner()))
```
