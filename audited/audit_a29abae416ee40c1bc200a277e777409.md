# Audit Report

## Title
Missing Validation Invariants in Block Partitioner Configuration Leading to Division by Zero Panic

## Summary
The `ConnectedComponentPartitionerConfig` lacks validation for the `load_imbalance_tolerance` parameter, allowing invalid values (zero, negative, NaN, or infinity) that cause a division by zero panic during block partitioning. While this primarily affects the executor-benchmark tool, it violates defensive programming principles and could cause service disruption if deployed in performance-critical infrastructure.

## Finding Description
The `load_imbalance_tolerance` parameter in `ConnectedComponentPartitionerConfig` has no validation logic whatsoever. [1](#0-0) 

This parameter is directly used to calculate `group_size_limit` during the pre-partitioning phase: [2](#0-1) 

When `load_imbalance_tolerance` is set to 0 or a value that results in `group_size_limit` being 0, the subsequent `div_ceil` operation causes a panic: [3](#0-2) 

The parameter is configurable via command-line in the executor-benchmark tool without any bounds checking: [4](#0-3) 

**Attack Path:**
1. Operator runs `executor-benchmark --load-imbalance-tolerance 0.0`
2. `ConnectedComponentPartitionerConfig` is created with `load_imbalance_tolerance = 0.0` [5](#0-4) 
3. During block preparation, partitioner calculates `group_size_limit = (num_txns * 0.0 / num_shards).ceil() = 0`
4. Line 100 executes `txns.len().div_ceil(0)`, triggering panic

**Missing Protocol-Level Invariants:**
1. **Positivity invariant**: `load_imbalance_tolerance > 0` (to prevent division by zero)
2. **Upper bound invariant**: `load_imbalance_tolerance ≤ num_shards` (to prevent group size exceeding block size)
3. **Reasonable bounds**: `0.5 ≤ load_imbalance_tolerance ≤ 10.0` (based on practical use)
4. **Group size constraint**: The example in the question suggests groups should not exceed 50% of block size, which would require `load_imbalance_tolerance ≤ 0.5 * num_shards`

## Impact Explanation
**Severity: Medium (per bug bounty criteria)**

This issue qualifies as Medium severity for the following reasons:
- **State inconsistencies requiring intervention**: A misconfigured benchmark tool crashes, requiring manual restart and reconfiguration
- **Limited scope**: Affects executor-benchmark infrastructure, not production validator consensus
- **No direct consensus impact**: Does not affect block production, validation, or state commitment in production validators
- **Operational impact**: Could disrupt performance testing infrastructure or block preparation pipelines if this code were adapted for production use

This does NOT qualify as High or Critical because:
- No loss of funds or consensus violations in production
- No validator node slowdowns in production environment
- Limited to benchmarking/testing infrastructure

## Likelihood Explanation
**Likelihood: Low to Medium**

The vulnerability requires:
1. **Operator access**: An operator with permission to run executor-benchmark
2. **Misconfiguration**: Setting an invalid `--load-imbalance-tolerance` value
3. **No safeguards**: Zero validation prevents catching the error early

While operator error is common, the default value of 2.0 is safe, reducing the likelihood. However, exploratory testing or performance tuning could trigger this issue inadvertently.

## Recommendation
Add validation logic to `ConnectedComponentPartitionerConfig` to enforce invariants:

```rust
impl ConnectedComponentPartitionerConfig {
    pub fn new(load_imbalance_tolerance: f32) -> Result<Self, String> {
        if load_imbalance_tolerance <= 0.0 {
            return Err(format!(
                "load_imbalance_tolerance must be positive, got {}",
                load_imbalance_tolerance
            ));
        }
        if load_imbalance_tolerance.is_nan() || load_imbalance_tolerance.is_infinite() {
            return Err(format!(
                "load_imbalance_tolerance must be a finite number, got {}",
                load_imbalance_tolerance
            ));
        }
        if load_imbalance_tolerance > 10.0 {
            return Err(format!(
                "load_imbalance_tolerance should not exceed 10.0 (got {}), as this defeats partitioning",
                load_imbalance_tolerance
            ));
        }
        Ok(Self {
            load_imbalance_tolerance,
        })
    }
}
```

Additionally, add runtime validation in the pre_partition method: [2](#0-1) 

```rust
let group_size_limit = ((state.num_txns() as f32) * self.load_imbalance_tolerance
    / (state.num_executor_shards as f32))
    .ceil() as usize;
assert!(group_size_limit > 0, 
    "group_size_limit must be positive (got {}), check load_imbalance_tolerance", 
    group_size_limit);
```

## Proof of Concept
```bash
# Run executor-benchmark with invalid configuration
cargo run --bin aptos-executor-benchmark -- \
  --num-executor-shards 4 \
  --load-imbalance-tolerance 0.0 \
  --pre-partitioner connected-component \
  # ... other required parameters

# Expected result: Panic at connected_component/mod.rs:100
# thread 'main' panicked at 'attempt to divide by zero'
```

**Rust test case:**
```rust
#[test]
#[should_panic(expected = "attempt to divide by zero")]
fn test_zero_load_imbalance_tolerance_causes_panic() {
    let config = ConnectedComponentPartitionerConfig {
        load_imbalance_tolerance: 0.0,
    };
    let partitioner = config.build();
    
    // Create minimal test state with transactions
    let state = create_test_partition_state(10, 4); // 10 txns, 4 shards
    
    // This will panic due to division by zero
    partitioner.pre_partition(&state);
}
```

## Notes
While this vulnerability primarily affects the executor-benchmark tool rather than production validators, it represents a violation of defensive programming principles. The cited configuration file explicitly states protocol-level invariants should be enforced [6](#0-5) , yet no validation exists. This could become a production issue if the partitioner code is adapted for use in validator block preparation pipelines or performance-critical infrastructure.

### Citations

**File:** execution/block-partitioner/src/pre_partition/connected_component/config.rs (L9-23)
```rust
pub struct ConnectedComponentPartitionerConfig {
    /// If the size a connected component is larger than `load_imbalance_tolerance * block_size / num_shards`,
    /// this component will be broken up into smaller ones.
    ///
    /// See the comments of `aptos_block_partitioner::pre_partition::connected_component::ConnectedComponentPartitioner` for more details.
    pub load_imbalance_tolerance: f32,
}

impl Default for ConnectedComponentPartitionerConfig {
    fn default() -> Self {
        ConnectedComponentPartitionerConfig {
            load_imbalance_tolerance: 2.0,
        }
    }
}
```

**File:** execution/block-partitioner/src/pre_partition/connected_component/mod.rs (L88-91)
```rust
        // Calculate txn group size limit.
        let group_size_limit = ((state.num_txns() as f32) * self.load_imbalance_tolerance
            / (state.num_executor_shards as f32))
            .ceil() as usize;
```

**File:** execution/block-partitioner/src/pre_partition/connected_component/mod.rs (L96-106)
```rust
        let group_metadata: Vec<(usize, usize)> = txns_by_set
            .iter()
            .enumerate()
            .flat_map(|(set_idx, txns)| {
                let num_chunks = txns.len().div_ceil(group_size_limit);
                let mut ret = vec![(set_idx, group_size_limit); num_chunks];
                let last_chunk_size = txns.len() - group_size_limit * (num_chunks - 1);
                ret[num_chunks - 1] = (set_idx, last_chunk_size);
                ret
            })
            .collect();
```

**File:** execution/executor-benchmark/src/main.rs (L224-225)
```rust
    #[clap(long, default_value = "2.0")]
    load_imbalance_tolerance: f32,
```

**File:** execution/executor-benchmark/src/main.rs (L237-239)
```rust
            Some("connected-component") => Box::new(ConnectedComponentPartitionerConfig {
                load_imbalance_tolerance: self.load_imbalance_tolerance,
            }),
```
