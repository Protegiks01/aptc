# Audit Report

## Title
Indexer Backfiller Lacks Transaction Authenticity Verification Leading to Data Integrity Compromise

## Summary
The indexer-grpc-v2-file-store-backfiller accepts transactions from a fullnode via gRPC without cryptographic verification of their authenticity. A malicious or compromised fullnode can inject fabricated transactions with fake balances, NFT ownership, and governance state into the file store, which propagates to downstream indexers and applications.

## Finding Description

The backfiller's `backfill()` function fetches transactions from a fullnode via the `GetTransactionsFromNode` gRPC endpoint and writes them directly to the file store. [1](#0-0) 

The only validation performed is:
1. Chain ID matching [2](#0-1) 
2. Sequential version ordering [3](#0-2) 

**Critical Missing Validations:**
- No signature verification on transactions
- No accumulator proof verification against trusted checkpoints
- No state hash validation
- No cross-verification with multiple fullnodes

The `GetTransactionsFromNode` API returns raw `Transaction` protobuf objects without cryptographic proofs. [4](#0-3) 

Unlike state-sync APIs which provide `TransactionWithProof` containing accumulator proofs and LedgerInfo signatures for Byzantine fault tolerance, this endpoint provides no cryptographic guarantees. [5](#0-4) 

**Attack Scenario:**
1. Attacker compromises a fullnode or runs a malicious one
2. Modifies `get_transactions_from_node` implementation to serve fabricated transactions with:
   - Fake token transfers showing stolen funds
   - Fake NFT ownership changes
   - Fake governance votes
   - Modified transaction outcomes
3. Backfiller operator connects to compromised fullnode (via misconfiguration or social engineering)
4. Backfiller receives and validates only chain_id and version ordering (both easily forged)
5. Fake transactions written to file store [6](#0-5) 
6. Downstream indexers consume fake data from file store
7. Wallets, explorers, and DeFi protocols display incorrect balances, ownership, and state

## Impact Explanation

**Severity: Medium to High**

This violates the **State Consistency** invariant by allowing unverified state data into the indexer ecosystem. While it doesn't directly affect on-chain consensus or validator operations, the impact includes:

- **Data Integrity Compromise**: File store becomes untrustworthy, requiring complete re-backfilling
- **Application-Level Impact**: Wallets, explorers, analytics platforms, and DeFi protocols relying on indexed data will operate on false information
- **Financial Risk**: Users may make trading/transfer decisions based on fake balance information
- **Ecosystem Trust**: Undermines confidence in Aptos indexer infrastructure

This qualifies as **Medium Severity** under "State inconsistencies requiring intervention" or potentially **High Severity** as a "Significant protocol violation" affecting critical infrastructure.

## Likelihood Explanation

**Likelihood: Medium**

Attack requires:
- Compromising a fullnode (challenging but feasible via software vulnerabilities, insider threat, or supply chain attack)
- OR social engineering backfiller operator to use malicious endpoint
- OR man-in-the-middle attack on unencrypted gRPC connection

The backfiller is typically operated by Aptos Labs or ecosystem partners with access to trusted fullnodes, reducing likelihood. However, lack of defense-in-depth means a single point of failure (compromised fullnode) breaks the entire indexer data integrity.

## Recommendation

Implement cryptographic verification using Aptos's existing proof infrastructure:

```rust
// In processor.rs backfill() function, after receiving transactions:

// 1. Periodically fetch and verify LedgerInfo from multiple fullnodes
let trusted_ledger_info = fetch_and_verify_ledger_info_with_quorum(
    &fullnode_addresses, 
    &validator_set
).await?;

// 2. Request transactions WITH proofs
let request = GetTransactionsWithProofRequest {
    starting_version: Some(task_version),
    transactions_count: Some(num_transactions_per_folder),
};

// 3. Verify each transaction against trusted ledger info
for transaction_with_proof in transactions_with_proofs {
    transaction_with_proof.verify(
        trusted_ledger_info,
        task_version,
    )?;
    
    // Only after verification, buffer and dump
    file_store_operator
        .buffer_and_maybe_dump_transactions_to_file(
            transaction_with_proof.transaction,
            tx.clone(),
        )
        .await?;
}
```

**Alternative mitigation:**
- Cross-verify accumulator root hashes with multiple independent fullnodes
- Implement sampling verification: periodically verify random transactions against known checkpoints
- Add transaction signature verification as defense-in-depth even if not strictly necessary

## Proof of Concept

```rust
// Malicious fullnode implementation
// File: malicious_fullnode_service.rs

impl FullnodeData for MaliciousFullnodeService {
    async fn get_transactions_from_node(
        &self,
        req: Request<GetTransactionsFromNodeRequest>,
    ) -> Result<Response<Self::GetTransactionsFromNodeStream>, Status> {
        let r = req.into_inner();
        let starting_version = r.starting_version.unwrap();
        
        // Generate fake transactions with manipulated data
        let mut fake_transactions = vec![];
        for i in 0..r.transactions_count.unwrap() {
            let mut fake_txn = Transaction {
                version: starting_version + i,
                timestamp: Some(Timestamp::from_now()),
                info: Some(TransactionInfo {
                    // Fake state changes showing stolen funds
                    changes: vec![fake_balance_change()],
                    success: true,
                    ..Default::default()
                }),
                txn_data: Some(TxnData::User(UserTransaction {
                    // Fake user transaction with invalid signature
                    request: UserTransactionRequest {
                        signature: Some(random_fake_signature()),
                        ..Default::default()
                    },
                    ..Default::default()
                })),
                ..Default::default()
            };
            fake_transactions.push(fake_txn);
        }
        
        // Backfiller accepts these without verification!
        let response = TransactionsFromNodeResponse {
            response: Some(Response::Data(TransactionsOutput {
                transactions: fake_transactions,
            })),
            chain_id: 1, // Correct chain_id to pass validation
        };
        
        // Stream fake data to backfiller
        Ok(Response::new(Box::pin(stream_of(response))))
    }
}

// Result: Fake transactions written to file store and consumed by indexers
```

## Notes

This vulnerability highlights a trust boundary issue where the backfiller assumes fullnode data integrity without verification. While the component is designed for trusted environments, defense-in-depth principles suggest cryptographic verification should be mandatory, especially given that Aptos provides robust proof mechanisms (`LedgerInfoWithSignatures`, `TransactionWithProof`, accumulator proofs) that are already used in state-sync but not leveraged here.

The fix requires architectural changes to use proof-enabled APIs rather than raw transaction streaming, or implementing post-hoc verification against trusted checkpoints from validator quorums.

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-v2-file-store-backfiller/src/processor.rs (L173-188)
```rust
                        while let Some(response_item) = stream.next().await {
                            match response_item {
                                Ok(r) => {
                                    assert!(r.chain_id == chain_id);
                                    match r.response.unwrap() {
                                        Response::Data(data) => {
                                            let transactions = data.transactions;
                                            for transaction in transactions {
                                                file_store_operator
                                                    .buffer_and_maybe_dump_transactions_to_file(
                                                        transaction,
                                                        tx.clone(),
                                                    )
                                                    .await
                                                    .unwrap();
                                            }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-v2-file-store-backfiller/src/processor.rs (L226-259)
```rust
    async fn do_upload(
        &self,
        transactions: Vec<Transaction>,
        mut batch_metadata: BatchMetadata,
        end_batch: bool,
    ) -> Result<()> {
        let first_version = transactions.first().unwrap().version;

        let path = self
            .file_store_reader
            .get_path_for_version(first_version, Some(self.backfill_id));

        let data_file =
            FileEntry::from_transactions(transactions, StorageFormat::Lz4CompressedProto);

        self.file_store_writer
            .save_raw_file(path, data_file.into_inner())
            .await?;

        if end_batch {
            let path = self
                .file_store_reader
                .get_path_for_batch_metadata(first_version);
            batch_metadata.suffix = Some(self.backfill_id);
            self.file_store_writer
                .save_raw_file(
                    path,
                    serde_json::to_vec(&batch_metadata).map_err(anyhow::Error::msg)?,
                )
                .await?;
        }

        Ok(())
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/file_store_operator_v2/file_store_operator.rs (L50-55)
```rust
        ensure!(
            self.version == transaction.version,
            "Gap is found when buffering transaction, expected: {}, actual: {}",
            self.version,
            transaction.version,
        );
```

**File:** protos/proto/aptos/internal/fullnode/v1/fullnode_data.proto (L18-20)
```text
message TransactionsOutput {
  repeated aptos.transaction.v1.Transaction transactions = 1;
}
```

**File:** types/src/ledger_info.rs (L1-10)
```rust
// Copyright (c) Aptos Foundation
// Licensed pursuant to the Innovation-Enabling Source Code License, available at https://github.com/aptos-labs/aptos-core/blob/main/LICENSE

#[cfg(any(test, feature = "fuzzing"))]
use crate::validator_signer::ValidatorSigner;
use crate::{
    account_address::AccountAddress,
    block_info::{BlockInfo, Round},
    epoch_state::EpochState,
    on_chain_config::ValidatorSet,
```
