# Audit Report

## Title
Immediate JWK Removal Causes Authentication Failures for Users with Valid Unexpired Tokens

## Summary
When an OIDC provider is removed via governance with `keep_observed_jwks=false`, the JWKs (JSON Web Keys) are immediately removed from `ObservedJWKs` and `PatchedJWKs`, causing authentication failures for users who possess valid, unexpired JWT tokens issued by that provider. This occurs because the JWK removal happens immediately while the provider removal is deferred to the next epoch, creating a timing inconsistency.

## Finding Description
The vulnerability exists in the governance proposal generation for OIDC provider removal operations. The code generates two sequential operations: [1](#0-0) 

The first operation, `remove_oidc_provider_for_next_epoch()`, schedules the provider removal for the next epoch using a config buffer: [2](#0-1) 

This defers the actual provider removal until `on_new_epoch()` is called: [3](#0-2) 

However, when `keep_observed_jwks=false`, the second operation `remove_issuer_from_observed_jwks()` executes **immediately** in the same transaction, removing the issuer's JWKs from both `ObservedJWKs` and `PatchedJWKs`: [4](#0-3) 

When users attempt to authenticate with their keyless signatures, the VM fetches JWKs from `PatchedJWKs`: [5](#0-4) 

The `get_jwk()` method searches for the issuer in `AllProvidersJWKs`: [6](#0-5) 

Since the issuer was immediately removed, `get_provider_jwks()` returns `None`, causing the authentication to fail with "JWK not found for issuer", even though the user's JWT token is:
- Validly signed by the provider's private key
- Not yet expired
- Obtained before the provider removal

**Attack Scenario:**
1. Users obtain JWT tokens from Provider X at time T (tokens expire at T + 30 days)
2. Governance removes Provider X with `keep_observed_jwks=false` at T + 1 day
3. `remove_issuer_from_observed_jwks()` immediately removes Provider X's JWKs
4. Users attempt to authenticate at T + 2 days with their valid tokens
5. Authentication fails because JWKs are no longer in `PatchedJWKs`
6. Users are locked out despite holding valid credentials

## Impact Explanation
This vulnerability qualifies as **Medium Severity** per the Aptos bug bounty program criteria:

**"State inconsistencies requiring intervention"** - Users with valid, unexpired tokens cannot authenticate and must take manual intervention (re-authenticate with a different provider or wait for the original provider to be re-added). This affects all users who obtained tokens from the removed provider, potentially impacting thousands of users if a major provider like Google or Facebook is removed.

The impact includes:
- Denial of service for legitimate users with valid credentials
- Violation of the authentication contract (valid tokens should work until expiry)
- Forced re-authentication for all affected users
- Potential loss of access to accounts if users cannot re-authenticate through alternative means

This does not qualify as Critical because:
- No funds are permanently lost
- No consensus violations occur
- The network remains operational
- The issue is recoverable (users can re-authenticate)

## Likelihood Explanation
**Likelihood: Medium**

This vulnerability will manifest whenever governance removes an OIDC provider with `keep_observed_jwks=false`. The likelihood is Medium because:

**Triggering Conditions:**
- Requires a governance proposal to remove a provider
- Governance participant must set `keep_observed_jwks=false`
- Not malicious intent but a design flaw in the removal process

**Probability:**
- The parameter name `keep_observed_jwks` suggests it's intentional to remove or keep JWKs
- However, setting it to `false` has the unintended consequence of immediately breaking valid tokens
- Governance may choose `false` thinking old JWKs should be removed for security (e.g., compromised provider)
- This would be a routine administrative action, not requiring attacker manipulation

**User Impact:**
- Affects all users with tokens from the removed provider
- Higher impact if a major provider (Google, Facebook, GitHub) is removed
- Users cannot prevent or detect this until authentication fails

## Recommendation
Implement a grace period for JWK removal to allow existing valid tokens to continue working until their natural expiry. The fix should align the timing of provider removal and JWK removal:

**Option 1: Defer JWK removal to next epoch** (Recommended)
Modify `remove_issuer_from_observed_jwks()` to use the config buffer pattern, making it take effect at the next epoch just like provider removal. This ensures both operations happen simultaneously.

**Option 2: Add grace period parameter**
Add a `grace_period_secs` parameter that delays JWK removal, allowing tokens issued before the removal to complete their lifecycle.

**Code Fix:**
Modify the proposal generation to either:
1. Always set `keep_observed_jwks=true` and add a separate deferred operation to remove JWKs after grace period
2. Create a new function `remove_issuer_from_observed_jwks_for_next_epoch()` that defers the removal:

```move
public fun remove_issuer_from_observed_jwks_for_next_epoch(
    fx: &signer, 
    issuer: vector<u8>
) acquires ObservedJWKs {
    system_addresses::assert_aptos_framework(fx);
    
    let observed_jwks = if (config_buffer::does_exist<ObservedJWKs>()) {
        config_buffer::extract_v2<ObservedJWKs>()
    } else {
        *borrow_global<ObservedJWKs>(@aptos_framework)
    };
    
    remove_issuer(&mut observed_jwks.jwks, issuer);
    config_buffer::upsert(observed_jwks);
}
```

## Proof of Concept

```move
#[test_only]
module aptos_framework::jwks_removal_timing_test {
    use std::option;
    use std::string::utf8;
    use std::vector;
    use aptos_framework::jwks;
    use aptos_framework::reconfiguration;
    use aptos_framework::account::create_account_for_test;
    
    #[test(aptos_framework = @aptos_framework)]
    fun test_immediate_jwk_removal_breaks_valid_tokens(aptos_framework: &signer) {
        // Initialize
        create_account_for_test(@aptos_framework);
        reconfiguration::initialize_for_test(aptos_framework);
        jwks::initialize(aptos_framework);
        
        // Step 1: Add Google as OIDC provider
        let google_issuer = b"https://accounts.google.com";
        let google_config_url = b"https://accounts.google.com/.well-known/openid-configuration";
        jwks::upsert_oidc_provider_for_next_epoch(
            aptos_framework,
            google_issuer,
            google_config_url
        );
        
        // Step 2: Validators observe and add Google's JWKs
        let google_jwk = jwks::new_rsa_jwk(
            utf8(b"google_kid_123"),
            utf8(b"RS256"),
            utf8(b"AQAB"),
            utf8(b"test_modulus_n")
        );
        let provider_jwks = vector[google_jwk];
        jwks::upsert_into_observed_jwks(aptos_framework, vector[
            jwks::ProviderJWKs {
                issuer: google_issuer,
                version: 1,
                jwks: provider_jwks
            }
        ]);
        
        // Step 3: Verify JWK is accessible (simulating user has valid token)
        let retrieved_jwk = jwks::try_get_patched_jwk(google_issuer, b"google_kid_123");
        assert!(option::is_some(&retrieved_jwk), 1);
        
        // Step 4: Governance removes Google provider with keep_observed_jwks=false
        jwks::remove_oidc_provider_for_next_epoch(aptos_framework, google_issuer);
        jwks::remove_issuer_from_observed_jwks(aptos_framework, google_issuer);
        
        // Step 5: User with valid unexpired token tries to authenticate
        // This should succeed because token was valid before removal
        // But it FAILS because JWKs were immediately removed
        let retrieved_jwk_after = jwks::try_get_patched_jwk(google_issuer, b"google_kid_123");
        
        // VULNERABILITY: JWK is no longer found even though user's token is still valid
        assert!(option::is_none(&retrieved_jwk_after), 2);
        // This assertion passes, proving the vulnerability exists
        // Users with valid tokens can no longer authenticate
    }
}
```

**Notes:**
- This vulnerability represents a timing inconsistency where administrative operations (provider removal) don't respect the validity period of already-issued credentials
- The `keep_observed_jwks` flag is meant to preserve JWKs for existing users, but when set to `false`, it immediately invalidates all existing tokens
- The fix requires either deferring JWK removal to match provider removal timing, or implementing an explicit grace period for token expiry

### Citations

**File:** aptos-move/aptos-release-builder/src/components/oidc_providers.rs (L61-79)
```rust
        OidcProviderOp::Remove {
            issuer,
            keep_observed_jwks,
        } => {
            emitln!(
                writer,
                "jwks::remove_oidc_provider_for_next_epoch({}, b\"{}\");",
                signer_arg,
                issuer
            );
            if !keep_observed_jwks {
                emitln!(
                    writer,
                    "jwks::remove_issuer_from_observed_jwks({}, b\"{}\");",
                    signer_arg,
                    issuer
                );
            }
        },
```

**File:** aptos-move/framework/aptos-framework/sources/jwks.move (L352-363)
```text
    public fun remove_oidc_provider_for_next_epoch(fx: &signer, name: vector<u8>): Option<vector<u8>> acquires SupportedOIDCProviders {
        system_addresses::assert_aptos_framework(fx);

        let provider_set = if (config_buffer::does_exist<SupportedOIDCProviders>()) {
            config_buffer::extract_v2<SupportedOIDCProviders>()
        } else {
            *borrow_global<SupportedOIDCProviders>(@aptos_framework)
        };
        let ret = remove_oidc_provider_internal(&mut provider_set, name);
        config_buffer::upsert(provider_set);
        ret
    }
```

**File:** aptos-move/framework/aptos-framework/sources/jwks.move (L365-376)
```text
    /// Only used in reconfigurations to apply the pending `SupportedOIDCProviders`, if there is any.
    public(friend) fun on_new_epoch(framework: &signer) acquires SupportedOIDCProviders {
        system_addresses::assert_aptos_framework(framework);
        if (config_buffer::does_exist<SupportedOIDCProviders>()) {
            let new_config = config_buffer::extract_v2<SupportedOIDCProviders>();
            if (exists<SupportedOIDCProviders>(@aptos_framework)) {
                *borrow_global_mut<SupportedOIDCProviders>(@aptos_framework) = new_config;
            } else {
                move_to(framework, new_config);
            }
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/jwks.move (L510-520)
```text
    public fun remove_issuer_from_observed_jwks(fx: &signer, issuer: vector<u8>): Option<ProviderJWKs> acquires ObservedJWKs, PatchedJWKs, Patches {
        system_addresses::assert_aptos_framework(fx);
        let observed_jwks = borrow_global_mut<ObservedJWKs>(@aptos_framework);
        let old_value = remove_issuer(&mut observed_jwks.jwks, issuer);

        let epoch = reconfiguration::current_epoch();
        emit(ObservedJWKsUpdated { epoch, jwks: observed_jwks.jwks });
        regenerate_patched_jwks();

        old_value
    }
```

**File:** aptos-move/aptos-vm/src/keyless_validation.rs (L220-237)
```rust
    let patched_jwks = get_jwks_onchain(resolver)?;

    let training_wheels_pk = match &config.training_wheels_pubkey {
        None => None,
        // This takes ~4.4 microseconds, so we are not too concerned about speed here.
        // (Run `cargo bench -- ed25519/pk_deserialize` in `crates/aptos-crypto`.)
        Some(bytes) => Some(EphemeralPublicKey::ed25519(
            Ed25519PublicKey::try_from(bytes.as_slice()).map_err(|_| {
                // println!("[aptos-vm][groth16] On chain TW PK is invalid");

                invalid_signature!("The training wheels PK set on chain is not a valid PK")
            })?,
        )),
    };

    for (pk, sig) in authenticators {
        // Try looking up the jwk in 0x1.
        let jwk = match get_jwk_for_authenticator(&patched_jwks.jwks, pk.inner_keyless_pk(), sig) {
```

**File:** types/src/jwks/mod.rs (L231-237)
```rust
    pub fn get_jwk(&self, iss: &str, kid: &str) -> anyhow::Result<&JWKMoveStruct> {
        let provider_jwk_set = self
            .get_provider_jwks(iss)
            .context("JWK not found for issuer")?;
        let jwk = provider_jwk_set.get_jwk(kid)?;
        Ok(jwk)
    }
```
