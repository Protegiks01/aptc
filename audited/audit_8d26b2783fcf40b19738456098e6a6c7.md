# Audit Report

## Title
Script Type Parameter Count Mismatch Causes Verifier Panic (Denial of Service)

## Summary
The Move bytecode verifier can panic when verifying scripts with more declared type parameters than are referenced in signatures, if the `sig_checker_v2_fix_script_ty_param_count` configuration flag is disabled. This allows an unprivileged attacker to crash validator nodes via malicious script transactions.

## Finding Description
The vulnerability exists in the `verify_script` function's calculation of the bitset size needed to track type parameter constraints. The issue occurs in this flow: [1](#0-0) 

The `max_num_of_ty_params_or_args` function calculates the maximum type parameter count by examining type parameter indices actually used in signatures, function handles, and struct handles. However, it does **not** account for the script's own declared type parameters (`script.type_parameters.len()`). [2](#0-1) 

The fix exists but is controlled by a configuration flag. When disabled, the vulnerability is active.

At verification time: [3](#0-2) 

The verifier creates a `BitsetTypeParameterConstraints` from **all** declared type parameters: [4](#0-3) 

This iterates through every type parameter and calls `insert()`: [5](#0-4) 

The `assert!` at line 71-77 will **panic** if the type parameter index exceeds the bitset capacity (`N * NUM_PARAMS_PER_WORD`).

**Attack Scenario:**
1. Attacker creates a script with 17 type parameters: `script.type_parameters = [Empty; 17]`
2. Script only uses `TypeParameter(0)` in any signature
3. `max_num_of_ty_params_or_args()` returns 1 (max index 0 + 1)
4. Since 1 â‰¤ 16, `verify_script_impl::<1>` is called
5. `BitsetTypeParameterConstraints<1>` can handle up to 16 type parameters (indices 0-15)
6. When inserting type parameter at index 16, the assert fails: `16 < 16` is false
7. **Verifier panics** with: "Type parameter index out of bounds. The current Bitset implementation is only configured to handle 16 type parameters at max."

This breaks the **Move VM Safety** and **Resource Limits** invariants by causing uncontrolled panics during verification.

## Impact Explanation
**Severity: High** (up to $50,000 per Aptos Bug Bounty)

This qualifies as "Validator node slowdowns" and "Significant protocol violations":

1. **Denial of Service**: Any validator attempting to verify the malicious script will panic and potentially crash
2. **Network Availability**: Multiple nodes could be affected simultaneously if the transaction propagates through mempool
3. **Consensus Disruption**: Depending on panic handling, this could cause validators to become unavailable during consensus
4. **No Privilege Required**: Any user can submit a script transaction

The panic is unrecoverable within the verification flow, causing the entire verification to abort.

## Likelihood Explanation
**Current Likelihood: VERY LOW** (Mitigated in Production) [6](#0-5) 

The fix is **enabled by default** in `VerifierConfig`: [7](#0-6) 

The `SIGNATURE_CHECKER_V2_SCRIPT_FIX` feature flag is in the default features list, meaning it's enabled on Aptos mainnet.

However, the vulnerability remains exploitable if:
- Custom deployments disable the flag
- Test networks run with the fix disabled
- Old versions of the verifier are deployed
- The config flag is explicitly set to false

The fact that this is a **configuration option** rather than a mandatory fix is itself a concern.

## Recommendation
**Make the fix mandatory and remove the configuration flag:**

The fix at lines 1275-1277 should be applied unconditionally:

```rust
pub fn verify_script(config: &VerifierConfig, script: &CompiledScript) -> VMResult<()> {
    let mut max_num = max_num_of_ty_params_or_args(BinaryIndexedView::Script(script));
    // Always include script type parameters in the count
    max_num = max_num.max(script.type_parameters.len());
    
    // ... rest of verification
}
```

Remove the `sig_checker_v2_fix_script_ty_param_count` field from `VerifierConfig` entirely, as this should not be optional.

**Alternative:** Add early validation in the bounds checker to explicitly reject scripts where `script.type_parameters.len()` exceeds safe limits before reaching the signature verifier.

## Proof of Concept

```rust
// Proof of concept demonstrating the panic
// This would compile and demonstrate the issue when 
// sig_checker_v2_fix_script_ty_param_count = false

use move_binary_format::file_format::*;
use move_bytecode_verifier::VerifierConfig;
use move_bytecode_verifier::signature_v2;

fn create_malicious_script() -> CompiledScript {
    CompiledScript {
        version: 6,
        module_handles: vec![],
        struct_handles: vec![],
        function_handles: vec![],
        function_instantiations: vec![],
        signatures: SignaturePool(vec![
            Signature(vec![SignatureToken::TypeParameter(0)]) // Only uses T0
        ]),
        identifiers: IdentifierPool::new(),
        address_identifiers: AddressIdentifierPool::new(),
        constant_pool: ConstantPool::new(),
        metadata: vec![],
        code: CodeUnit {
            locals: SignatureIndex(0),
            code: vec![Bytecode::Ret],
        },
        // Declare 17 type parameters but only use TypeParameter(0)
        type_parameters: vec![AbilitySet::EMPTY; 17],
        parameters: SignatureIndex(0),
        access_specifiers: None,
    }
}

#[test]
#[should_panic(expected = "Type parameter index out of bounds")]
fn test_script_type_param_panic() {
    let script = create_malicious_script();
    let mut config = VerifierConfig::default();
    // Disable the fix to trigger the vulnerability
    config.sig_checker_v2_fix_script_ty_param_count = false;
    
    // This will panic when verifying
    let _ = signature_v2::verify_script(&config, &script);
}
```

## Notes

**IMPORTANT:** This vulnerability is **MITIGATED IN PRODUCTION** on Aptos mainnet because the `SIGNATURE_CHECKER_V2_SCRIPT_FIX` feature flag is enabled by default. However, the vulnerability remains in the codebase as an optional configuration, which represents a defense-in-depth concern. The fix should be made mandatory rather than optional to prevent accidental exposure in custom deployments or configuration changes.

### Citations

**File:** third_party/move/move-bytecode-verifier/src/signature_v2.rs (L49-57)
```rust
impl<'a, const N: usize> From<&'a [AbilitySet]> for BitsetTypeParameterConstraints<N> {
    fn from(abilities: &'a [AbilitySet]) -> Self {
        abilities
            .iter()
            .enumerate()
            .map(|(idx, abilities)| (idx as TypeParameterIndex, *abilities))
            .collect()
    }
}
```

**File:** third_party/move/move-bytecode-verifier/src/signature_v2.rs (L70-89)
```rust
    fn insert(&mut self, ty_param_idx: TypeParameterIndex, required_abilities: AbilitySet) {
        assert!(
            (ty_param_idx as usize) < N * NUM_PARAMS_PER_WORD,
            "Type parameter index out of bounds. \
             The current Bitset implementation is only configured to handle \
             {} type parameters at max.",
            N * NUM_PARAMS_PER_WORD
        );

        if required_abilities == AbilitySet::EMPTY {
            return;
        }

        let ty_param_idx = ty_param_idx as usize;

        let word_idx = ty_param_idx / NUM_PARAMS_PER_WORD;
        let offset_in_word = (ty_param_idx % NUM_PARAMS_PER_WORD) * NUM_ABILITIES;

        self.words[word_idx] |= (required_abilities.into_u8() as u64) << offset_in_word;
    }
```

**File:** third_party/move/move-bytecode-verifier/src/signature_v2.rs (L1190-1196)
```rust
    checker.verify_signature_in_context(
        &BitsetTypeParameterConstraints::from(script.type_parameters.as_slice()),
        script.parameters,
        // Script parameters can be signer references.
        true,
    )?;
    checker.verify_code(&script.type_parameters, &script.code)?;
```

**File:** third_party/move/move-bytecode-verifier/src/signature_v2.rs (L1201-1251)
```rust
fn max_num_of_ty_params_or_args(resolver: BinaryIndexedView) -> usize {
    let mut n = 0;

    for fh in resolver.function_handles() {
        n = n.max(fh.type_parameters.len())
    }

    for sh in resolver.struct_handles() {
        n = n.max(sh.type_parameters.len())
    }

    for sig in resolver.signatures() {
        for ty in &sig.0 {
            for ty in ty.preorder_traversal() {
                if let SignatureToken::TypeParameter(ty_param_idx) = ty {
                    n = n.max(*ty_param_idx as usize + 1)
                }
            }
        }
    }

    if let Some(struct_defs) = resolver.struct_defs() {
        for struct_def in struct_defs {
            match &struct_def.field_information {
                StructFieldInformation::Native => {},
                StructFieldInformation::Declared(fields) => {
                    for field in fields {
                        for ty in field.signature.0.preorder_traversal() {
                            if let SignatureToken::TypeParameter(ty_param_idx) = ty {
                                n = n.max(*ty_param_idx as usize + 1)
                            }
                        }
                    }
                },
                StructFieldInformation::DeclaredVariants(variants) => {
                    for variant in variants {
                        for field in &variant.fields {
                            for ty in field.signature.0.preorder_traversal() {
                                if let SignatureToken::TypeParameter(ty_param_idx) = ty {
                                    n = n.max(*ty_param_idx as usize + 1)
                                }
                            }
                        }
                    }
                },
            }
        }
    }

    n
}
```

**File:** third_party/move/move-bytecode-verifier/src/signature_v2.rs (L1273-1277)
```rust
pub fn verify_script(config: &VerifierConfig, script: &CompiledScript) -> VMResult<()> {
    let mut max_num = max_num_of_ty_params_or_args(BinaryIndexedView::Script(script));
    if config.sig_checker_v2_fix_script_ty_param_count {
        max_num = max_num.max(script.type_parameters.len());
    }
```

**File:** third_party/move/move-bytecode-verifier/src/verifier.rs (L262-262)
```rust
            sig_checker_v2_fix_script_ty_param_count: true,
```

**File:** types/src/on_chain_config/aptos_features.rs (L203-203)
```rust
            FeatureFlag::SIGNATURE_CHECKER_V2_SCRIPT_FIX,
```
