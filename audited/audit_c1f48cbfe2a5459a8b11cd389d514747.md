# Audit Report

## Title
Empty Validator Set Allows Network Halt via Governance-Controlled Minimum Stake Manipulation

## Summary
The `on_new_epoch()` function in `stake.move` fails to validate that the active validator set remains non-empty after filtering validators by minimum stake requirements. An attacker with governance control can set `minimum_stake` above all validators' current stakes, resulting in an empty validator set that creates genesis QCs with zero validators, bypassing quorum requirements and causing permanent network liveness failure requiring a hard fork to recover.

## Finding Description
The vulnerability exists in the epoch transition logic where validators are filtered based on minimum stake requirements. The attack flow is:

1. **Governance Manipulation**: An attacker with 51% voting power (or through governance proposal) calls `staking_config::update_required_stake()` to set `minimum_stake` to a value higher than all current validators' stakes. [1](#0-0) 

2. **Unchecked Empty Validator Set**: During the next epoch change, `stake::on_new_epoch()` filters validators by the new minimum stake requirement. All validators fail to meet the threshold and are excluded from `next_epoch_validators`. The code directly assigns this potentially empty vector to `validator_set.active_validators` without validation: [2](#0-1) 

3. **Empty ValidatorVerifier Creation**: The empty `ValidatorSet` is committed to state. When `ensure_next_epoch_state()` constructs the next epoch state, it creates a `ValidatorVerifier` from the empty validator set: [3](#0-2) 

4. **Zero Quorum Power**: The `ValidatorVerifier::new()` constructor sets `quorum_voting_power = 0` when the validator set is empty: [4](#0-3) 

5. **Genesis QC Bypasses Verification**: When consensus recovers, `certificate_for_genesis_from_ledger_info()` creates a genesis QC with an empty BitVec (size 0): [5](#0-4) 

6. **No Real Validation**: The genesis QC passes verification because round 0 blocks receive special handling that skips signature verification and only checks `get_num_voters() == 0`: [6](#0-5) 

**Critical Gap**: While `leave_validator_set()` has the `ELAST_VALIDATOR` check to prevent the last validator from voluntarily leaving, `on_new_epoch()` lacks any such protection when filtering by minimum stake: [7](#0-6) 

This violates the critical invariant that the active validator set must never be empty for network operation.

## Impact Explanation
**Critical Severity** - This meets multiple critical impact categories from the Aptos bug bounty:

1. **Total loss of liveness/network availability**: With zero validators, no blocks can be proposed, no votes can be cast, and the blockchain halts permanently.

2. **Non-recoverable network partition (requires hardfork)**: Recovery requires modifying on-chain state through a hard fork to restore a valid validator set, as there are no validators to process governance proposals or execute transactions.

3. **Consensus violations**: The network enters a state where consensus cannot proceed, violating the fundamental requirement that consensus must make progress under normal conditions.

The attack creates an irreversible deadlock where the blockchain cannot produce new blocks or process any transactions, including those that might attempt to fix the validator set configuration.

## Likelihood Explanation
**Medium to High Likelihood**:

- **Attack Requirements**: Requires 51% governance voting power or successful governance proposal approval
- **Detection**: Could go undetected if disguised as a legitimate stake requirement update
- **Feasibility**: Technically straightforward - requires only a single governance proposal with two parameters
- **Incentive**: Highly damaging but likely unintentional in most scenarios; could occur through governance misconfiguration or malicious governance attack

The vulnerability can also trigger accidentally if governance legitimately increases minimum stake requirements without ensuring all validators can meet them, making unintentional exploitation possible.

## Recommendation
Add validation in `stake::on_new_epoch()` to ensure the validator set cannot become empty after filtering:

```move
// After line 1399, before line 1401 in stake.move
assert!(
    vector::length(&next_epoch_validators) > 0,
    error::invalid_state(ELAST_VALIDATOR)
);
validator_set.active_validators = next_epoch_validators;
```

Additionally, add a check in `staking_config::update_required_stake()` to validate that the new minimum stake doesn't exceed all current validators' stakes:

```move
public fun update_required_stake(
    aptos_framework: &signer,
    minimum_stake: u64,
    maximum_stake: u64,
) acquires StakingConfig {
    system_addresses::assert_aptos_framework(aptos_framework);
    validate_required_stake(minimum_stake, maximum_stake);
    
    // Add validation that at least one validator can meet the new minimum
    let validator_set = stake::get_validator_set();
    let has_valid_validator = false;
    // Check that at least one validator meets new minimum
    // (implementation details)
    assert!(has_valid_validator, error::invalid_argument(ESTAKE_TOO_LOW));
    
    let staking_config = borrow_global_mut<StakingConfig>(@aptos_framework);
    staking_config.minimum_stake = minimum_stake;
    staking_config.maximum_stake = maximum_stake;
}
```

## Proof of Concept

```move
#[test(aptos_framework = @aptos_framework)]
#[expected_failure(abort_code = 0x60006, location = aptos_framework::stake)]
public entry fun test_empty_validator_set_prevention(
    aptos_framework: &signer,
) {
    use aptos_framework::stake;
    use aptos_framework::staking_config;
    
    // Setup: Initialize with validators having stake = 1000
    // ... (initialization code)
    
    // Attack: Set minimum_stake to exceed all validators' stakes
    staking_config::update_required_stake(
        aptos_framework,
        10000, // minimum_stake > all current stakes
        100000 // maximum_stake
    );
    
    // Trigger epoch change
    stake::on_new_epoch();
    
    // This should abort with ELAST_VALIDATOR error
    // Currently, it does NOT abort and creates empty validator set
}
```

## Notes
This vulnerability directly answers the security question: **Yes, genesis QCs can be created with empty validator sets (size 0), bypassing quorum requirements**. The genesis QC verification explicitly allows zero voters for round 0 blocks, and the staking logic fails to prevent the validator set from becoming empty during epoch transitions. While this doesn't create a safety violation (no invalid state transitions), it creates a critical liveness failure that renders the entire blockchain inoperable and requires a hard fork to recover.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/configs/staking_config.move (L274-285)
```text
    public fun update_required_stake(
        aptos_framework: &signer,
        minimum_stake: u64,
        maximum_stake: u64,
    ) acquires StakingConfig {
        system_addresses::assert_aptos_framework(aptos_framework);
        validate_required_stake(minimum_stake, maximum_stake);

        let staking_config = borrow_global_mut<StakingConfig>(@aptos_framework);
        staking_config.minimum_stake = minimum_stake;
        staking_config.maximum_stake = maximum_stake;
    }
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1250-1256)
```text
            // Validate that the validator is already part of the validator set.
            let maybe_active_index = find_validator(&validator_set.active_validators, pool_address);
            assert!(option::is_some(&maybe_active_index), error::invalid_state(ENOT_VALIDATOR));
            let validator_info = vector::swap_remove(
                &mut validator_set.active_validators, option::extract(&mut maybe_active_index));
            assert!(vector::length(&validator_set.active_validators) > 0, error::invalid_state(ELAST_VALIDATOR));
            vector::push_back(&mut validator_set.pending_inactive, validator_info);
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1372-1403)
```text
        let next_epoch_validators = vector::empty();
        let (minimum_stake, _) = staking_config::get_required_stake(&config);
        let vlen = vector::length(&validator_set.active_validators);
        let total_voting_power = 0;
        let i = 0;
        while ({
            spec {
                invariant spec_validators_are_initialized(next_epoch_validators);
                invariant i <= vlen;
            };
            i < vlen
        }) {
            let old_validator_info = vector::borrow_mut(&mut validator_set.active_validators, i);
            let pool_address = old_validator_info.addr;
            let validator_config = borrow_global<ValidatorConfig>(pool_address);
            let stake_pool = borrow_global<StakePool>(pool_address);
            let new_validator_info = generate_validator_info(pool_address, stake_pool, *validator_config);

            // A validator needs at least the min stake required to join the validator set.
            if (new_validator_info.voting_power >= minimum_stake) {
                spec {
                    assume total_voting_power + new_validator_info.voting_power <= MAX_U128;
                };
                total_voting_power = total_voting_power + (new_validator_info.voting_power as u128);
                vector::push_back(&mut next_epoch_validators, new_validator_info);
            };
            i = i + 1;
        };

        validator_set.active_validators = next_epoch_validators;
        validator_set.total_voting_power = total_voting_power;
        validator_set.total_joining_power = 0;
```

**File:** execution/executor/src/workflow/do_get_execution_output.rs (L520-540)
```rust
    fn ensure_next_epoch_state(to_commit: &TransactionsWithOutput) -> Result<EpochState> {
        let last_write_set = to_commit
            .transaction_outputs
            .last()
            .ok_or_else(|| anyhow!("to_commit is empty."))?
            .write_set();

        let write_set_view = WriteSetStateView {
            write_set: last_write_set,
        };

        let validator_set = ValidatorSet::fetch_config(&write_set_view)
            .ok_or_else(|| anyhow!("ValidatorSet not touched on epoch change"))?;
        let configuration = ConfigurationResource::fetch_config(&write_set_view)
            .ok_or_else(|| anyhow!("Configuration resource not touched on epoch change"))?;

        Ok(EpochState::new(
            configuration.epoch(),
            (&validator_set).into(),
        ))
    }
```

**File:** types/src/validator_verifier.rs (L206-214)
```rust
    pub fn new(validator_infos: Vec<ValidatorConsensusInfo>) -> Self {
        let total_voting_power = sum_voting_power(&validator_infos);
        let quorum_voting_power = if validator_infos.is_empty() {
            0
        } else {
            total_voting_power * 2 / 3 + 1
        };
        Self::build_index(validator_infos, quorum_voting_power, total_voting_power)
    }
```

**File:** consensus/consensus-types/src/quorum_cert.rs (L84-117)
```rust
    pub fn certificate_for_genesis_from_ledger_info(
        ledger_info: &LedgerInfo,
        genesis_id: HashValue,
    ) -> QuorumCert {
        let ancestor = BlockInfo::new(
            ledger_info
                .epoch()
                .checked_add(1)
                .expect("Integer overflow when creating cert for genesis from ledger info"),
            0,
            genesis_id,
            ledger_info.transaction_accumulator_hash(),
            ledger_info.version(),
            ledger_info.timestamp_usecs(),
            None,
        );

        let vote_data = VoteData::new(ancestor.clone(), ancestor.clone());
        let li = LedgerInfo::new(ancestor, vote_data.hash());

        let validator_set_size = ledger_info
            .next_epoch_state()
            .expect("Next epoch state not found in ledger info")
            .verifier
            .len();

        QuorumCert::new(
            vote_data,
            LedgerInfoWithSignatures::new(
                li,
                AggregateSignature::new(BitVec::with_num_bits(validator_set_size as u16), None),
            ),
        )
    }
```

**File:** consensus/consensus-types/src/quorum_cert.rs (L128-141)
```rust
        if self.certified_block().round() == 0 {
            ensure!(
                self.parent_block() == self.certified_block(),
                "Genesis QC has inconsistent parent block with certified block"
            );
            ensure!(
                self.certified_block() == self.ledger_info().ledger_info().commit_info(),
                "Genesis QC has inconsistent commit block with certified block"
            );
            ensure!(
                self.ledger_info().get_num_voters() == 0,
                "Genesis QC should not carry signatures"
            );
            return Ok(());
```
