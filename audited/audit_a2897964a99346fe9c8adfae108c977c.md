# Audit Report

## Title
Unauthorized Network Topology Disclosure via PeerMonitoringServiceRpc to Untrusted Public Peers

## Summary
The `PeerMonitoringServiceRpc` protocol exposes sensitive network topology information to any untrusted peer on the public network, including validator network addresses, peer IDs, connection metadata, and node synchronization state. This information disclosure enables attackers to map the validator network structure and prepare targeted attacks.

## Finding Description

The peer monitoring service is registered on ALL networks without access control restrictions: [1](#0-0) 

When any peer (including untrusted public peers) sends a `GetNetworkInformation` RPC request, the server handler processes it without checking the requesting peer's network or trust level: [2](#0-1) 

The critical vulnerability is in `get_network_information()` which returns ALL connected peers across ALL networks: [3](#0-2) 

The underlying `get_connected_peers_and_metadata()` function iterates over all network IDs without filtering: [4](#0-3) 

This means a Validator Full Node (VFN) that has connections to both validators (on the VFN network) and public peers (on the public network) will expose its validator connections to any attacker querying from the public network.

**Attack Path:**
1. Attacker connects to a VFN's public network endpoint
2. Attacker sends `PeerMonitoringServiceRequest::GetNetworkInformation` RPC
3. VFN responds with complete topology including:
   - All connected validator peer IDs and network addresses
   - All connected VFN peer information  
   - All connected public peer information
   - Peer roles (Validator, ValidatorFullNode, Unknown)
4. Attacker can also query `GetNodeInformation` to learn build versions, sync state, and uptime

The response includes `ConnectionMetadata` with sensitive information: [5](#0-4) 

## Impact Explanation

This vulnerability qualifies as **Medium Severity** based on the following:

**Information Disclosed:**
- Validator peer IDs and network addresses (IP:Port)
- Complete network topology (which VFNs connect to which validators)
- Node build information (for vulnerability targeting)
- Synchronization state and ledger information

**Security Implications:**
- **Network Topology Mapping:** Attackers can map the entire validator network structure
- **Validator Discovery:** Direct identification of validator nodes and their network locations
- **Eclipse Attack Preparation:** Knowledge of network topology facilitates eclipse attacks
- **Targeted Attack Planning:** Attackers can identify specific validators for coordinated attacks
- **Privacy Violation:** Validator network information should not be public knowledge

While this does not directly violate consensus safety or cause immediate fund loss, it breaks the network's privacy assumptions and enables more sophisticated attacks against the validator infrastructure. The Aptos network architecture assumes that validator network topology is not publicly accessible, but this vulnerability exposes it to any untrusted peer.

## Likelihood Explanation

**Likelihood: HIGH**

This vulnerability is trivially exploitable:
- No special privileges required - any peer can connect to the public network
- No authentication or authorization checks prevent the exploit
- Standard RPC protocol - attacker just needs to implement the message format
- Exploit succeeds 100% of the time once connected
- Multiple attack vectors: can query VFNs, PFNs, or any reachable node
- Information is returned immediately without rate limiting per peer

The only requirement is establishing a connection to a node's public network, which is intentionally open to the public by design.

## Recommendation

Implement network-aware access control in the peer monitoring service handler:

**Solution 1: Filter peers by requesting network**

Modify `Handler::call()` to filter returned peers based on the requesting peer's network:

```rust
fn get_network_information(&self, requesting_network_id: NetworkId) -> Result<PeerMonitoringServiceResponse, Error> {
    // Get the connected peers
    let connected_peers_and_metadata =
        self.peers_and_metadata.get_connected_peers_and_metadata()?;
    
    // Filter peers: only return peers from the same network as the requester
    let connected_peers = connected_peers_and_metadata
        .into_iter()
        .filter(|(peer_network_id, _)| {
            peer_network_id.network_id() == requesting_network_id
        })
        .map(|(peer, metadata)| {
            let connection_metadata = metadata.get_connection_metadata();
            (
                peer,
                ConnectionMetadata::new(
                    connection_metadata.addr,
                    connection_metadata.remote_peer_id,
                    connection_metadata.role,
                ),
            )
        })
        .collect();

    // Get the distance from the validators
    let distance_from_validators =
        get_distance_from_validators(&self.base_config, self.peers_and_metadata.clone());

    // Create and return the response
    let network_information_response = NetworkInformationResponse {
        connected_peers,
        distance_from_validators,
    };
    Ok(PeerMonitoringServiceResponse::NetworkInformation(
        network_information_response,
    ))
}
```

**Solution 2: Disable service on public networks**

Modify network registration to exclude PeerMonitoringServiceRpc from public networks:

```rust
// Only register peer monitoring on trusted networks
if !network_id.is_public_network() {
    let peer_monitoring_service_network_handle = register_client_and_service_with_network(
        &mut network_builder,
        network_id,
        &network_config,
        peer_monitoring_network_configuration(node_config),
        true,
    );
    peer_monitoring_service_network_handles.push(peer_monitoring_service_network_handle);
}
```

## Proof of Concept

```rust
// Test demonstrating information disclosure to public network peer
use aptos_config::network_id::{NetworkId, PeerNetworkId};
use aptos_peer_monitoring_service_types::{
    request::PeerMonitoringServiceRequest,
    response::PeerMonitoringServiceResponse,
};
use aptos_types::PeerId;

#[tokio::test]
async fn test_public_peer_can_access_validator_topology() {
    // Setup: Create a VFN node with connections to both validator and public networks
    let (vfn_server, vfn_peers_and_metadata) = setup_vfn_node_with_mixed_connections().await;
    
    // Add a validator peer connection on VFN network
    let validator_peer_id = PeerId::random();
    let validator_network_addr = "/ip4/10.0.0.1/tcp/6180".parse().unwrap();
    vfn_peers_and_metadata.insert_connection(
        PeerNetworkId::new(NetworkId::Vfn, validator_peer_id),
        validator_network_addr,
        PeerRole::Validator,
    );
    
    // Attacker: Create malicious peer on public network
    let attacker_peer_id = PeerId::random();
    let attacker_network_id = NetworkId::Public;
    
    // Attacker sends GetNetworkInformation request
    let request = PeerMonitoringServiceRequest::GetNetworkInformation;
    
    // VFN processes the request
    let response = vfn_server.call(attacker_network_id, request).unwrap();
    
    // Verify: Attacker receives validator topology information
    match response {
        PeerMonitoringServiceResponse::NetworkInformation(info) => {
            // The response contains validator peer information!
            assert!(info.connected_peers.contains_key(&PeerNetworkId::new(
                NetworkId::Vfn,
                validator_peer_id
            )));
            
            // Attacker can now see:
            println!("Validator Peer ID: {}", validator_peer_id);
            println!("Validator Network Address: {}", validator_network_addr);
            println!("Distance from validators: {}", info.distance_from_validators);
            println!("Total connected peers: {}", info.connected_peers.len());
        }
        _ => panic!("Expected NetworkInformation response"),
    }
}
```

## Notes

This vulnerability specifically affects VFNs that bridge between the validator network and public network. While validators themselves don't directly expose their network on public endpoints, the information about validator connections is leaked through VFNs that have no access controls on their peer monitoring service.

The lack of network-aware filtering in `get_connected_peers_and_metadata()` combined with unrestricted RPC access from public networks creates this information disclosure vector. The vulnerability is architectural rather than a simple implementation bug - the peer monitoring service was designed without consideration for multi-network privacy boundaries.

### Citations

**File:** aptos-node/src/network.rs (L370-378)
```rust
        // Register the peer monitoring service (both client and server) with the network
        let peer_monitoring_service_network_handle = register_client_and_service_with_network(
            &mut network_builder,
            network_id,
            &network_config,
            peer_monitoring_network_configuration(node_config),
            true,
        );
        peer_monitoring_service_network_handles.push(peer_monitoring_service_network_handle);
```

**File:** peer-monitoring-service/server/src/lib.rs (L155-182)
```rust
    pub fn call(
        &self,
        network_id: NetworkId,
        request: PeerMonitoringServiceRequest,
    ) -> Result<PeerMonitoringServiceResponse> {
        // Update the request count
        increment_counter(
            &metrics::PEER_MONITORING_REQUESTS_RECEIVED,
            network_id,
            request.get_label(),
        );

        // Time the request processing (the timer will stop when it's dropped)
        let _timer = start_timer(
            &metrics::PEER_MONITORING_REQUEST_PROCESSING_LATENCY,
            network_id,
            request.get_label(),
        );

        // Process the request
        let response = match &request {
            PeerMonitoringServiceRequest::GetNetworkInformation => self.get_network_information(),
            PeerMonitoringServiceRequest::GetServerProtocolVersion => {
                self.get_server_protocol_version()
            },
            PeerMonitoringServiceRequest::GetNodeInformation => self.get_node_information(),
            PeerMonitoringServiceRequest::LatencyPing(request) => self.handle_latency_ping(request),
        };
```

**File:** peer-monitoring-service/server/src/lib.rs (L217-248)
```rust
    fn get_network_information(&self) -> Result<PeerMonitoringServiceResponse, Error> {
        // Get the connected peers
        let connected_peers_and_metadata =
            self.peers_and_metadata.get_connected_peers_and_metadata()?;
        let connected_peers = connected_peers_and_metadata
            .into_iter()
            .map(|(peer, metadata)| {
                let connection_metadata = metadata.get_connection_metadata();
                (
                    peer,
                    ConnectionMetadata::new(
                        connection_metadata.addr,
                        connection_metadata.remote_peer_id,
                        connection_metadata.role,
                    ),
                )
            })
            .collect();

        // Get the distance from the validators
        let distance_from_validators =
            get_distance_from_validators(&self.base_config, self.peers_and_metadata.clone());

        // Create and return the response
        let network_information_response = NetworkInformationResponse {
            connected_peers,
            distance_from_validators,
        };
        Ok(PeerMonitoringServiceResponse::NetworkInformation(
            network_information_response,
        ))
    }
```

**File:** network/framework/src/application/storage.rs (L108-125)
```rust
    pub fn get_connected_peers_and_metadata(
        &self,
    ) -> Result<HashMap<PeerNetworkId, PeerMetadata>, Error> {
        // Get the cached peers and metadata
        let cached_peers_and_metadata = self.cached_peers_and_metadata.load();

        // Collect all connected peers
        let mut connected_peers_and_metadata = HashMap::new();
        for (network_id, peers_and_metadata) in cached_peers_and_metadata.iter() {
            for (peer_id, peer_metadata) in peers_and_metadata.iter() {
                if peer_metadata.is_connected() {
                    let peer_network_id = PeerNetworkId::new(*network_id, *peer_id);
                    connected_peers_and_metadata.insert(peer_network_id, peer_metadata.clone());
                }
            }
        }
        Ok(connected_peers_and_metadata)
    }
```

**File:** peer-monitoring-service/types/src/response.rs (L69-85)
```rust
/// Simple connection metadata associated with each peer
#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
pub struct ConnectionMetadata {
    pub network_address: NetworkAddress,
    pub peer_id: PeerId,
    pub peer_role: PeerRole,
}

impl ConnectionMetadata {
    pub fn new(network_address: NetworkAddress, peer_id: PeerId, peer_role: PeerRole) -> Self {
        Self {
            network_address,
            peer_id,
            peer_role,
        }
    }
}
```
