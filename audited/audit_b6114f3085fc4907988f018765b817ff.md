# Audit Report

## Title
SafetyRules Remote Service Can Bind to Public IP Addresses in Non-Mainnet Environments

## Summary
The `server_address()` function in the SafetyRules remote service configuration can return public IP addresses without validation, potentially exposing the critical validator signing service to internet-wide attacks in non-mainnet deployments (testnet, devnet, private networks).

## Finding Description

The SafetyRules service is responsible for critical validator signing operations in the Aptos consensus protocol. When configured in "Process" mode, it runs as a separate service that communicates over TCP/IP.

The vulnerability exists in multiple code paths:

1. **Configuration parsing without validation**: [1](#0-0) 

   The `RemoteService::server_address()` function converts a `NetworkAddress` to `SocketAddr` without any validation that the address is restricted to localhost or private networks.

2. **Direct address passthrough**: [2](#0-1) 

   The `ProcessService` implementation returns the configured address directly without validation.

3. **Unrestricted TCP binding**: [3](#0-2) 

   The `NetworkServer::new()` function binds to ANY provided `SocketAddr` without checking if it's a public IP.

4. **Service execution**: [4](#0-3) 

   The safety-rules service executes with whatever listen address is provided.

**Attack Scenario:**
A validator operator configures their node with a Process mode safety-rules service using a public IP address (e.g., `/ip4/203.0.113.42/tcp/6180` in the configuration YAML). [5](#0-4) 

The service binds to this public address, exposing the validator signing operations to the internet. An attacker can:
- Send malicious signing requests to compromise consensus
- Launch DoS attacks against the signing service
- Perform timing attacks to extract signing key information
- Disrupt validator operations causing downtime

**Mainnet Mitigation:**
The code DOES include a sanitizer that protects mainnet validators by completely disabling Process mode: [6](#0-5) 

However, this protection ONLY applies to mainnet. Non-mainnet environments (testnet, devnet, private deployments) are unprotected.

## Impact Explanation

**For Mainnet:** No impact - Process mode is completely disallowed by the configuration sanitizer.

**For Non-Mainnet Environments (Testnet/Devnet/Private Networks):** **High Severity**
- Validator node availability can be compromised through DoS attacks
- Signing service could be targeted for side-channel attacks
- Disruption of testnet/devnet consensus operations
- Potential for attackers to practice exploitation techniques for mainnet

This aligns with **High Severity** per Aptos bug bounty criteria:
- Validator node slowdowns
- API crashes  
- Significant protocol violations

The lack of defense-in-depth validation violates the **Cryptographic Correctness** invariant by allowing the signing service to be exposed without network-level protection.

## Likelihood Explanation

**Likelihood: Medium-Low**

Requires validator operator misconfiguration, but:
- Configuration files are complex and errors are common
- Example configs show localhost, but don't enforce it
- No warning or validation to prevent the mistake
- Non-mainnet validators may have less rigorous operational security
- Shared infrastructure between testnet and mainnet increases risk

The lack of code-level validation means this depends entirely on operator diligence and external firewall protection, violating defense-in-depth principles.

## Recommendation

Add IP address validation to prevent binding to public addresses in all environments:

```rust
impl RemoteService {
    pub fn server_address(&self) -> Result<SocketAddr, Error> {
        let addr = self.server_address
            .to_socket_addrs()
            .expect("server_address invalid")
            .next()
            .expect("server_address invalid");
        
        // Validate that the address is localhost or private
        if !addr.ip().is_loopback() && !is_private_ip(&addr.ip()) {
            return Err(Error::ConfigSanitizerFailed(
                "SafetyRulesConfig".to_string(),
                format!(
                    "SafetyRules Process service cannot bind to public IP address: {}. \
                     Only localhost (127.0.0.1/::1) or private network addresses are allowed.",
                    addr
                )
            ));
        }
        
        Ok(addr)
    }
}

fn is_private_ip(ip: &IpAddr) -> bool {
    match ip {
        IpAddr::V4(ipv4) => {
            ipv4.is_private() || ipv4.is_link_local()
        },
        IpAddr::V6(ipv6) => {
            ipv6.is_unique_local() || ipv6.is_link_local()
        }
    }
}
```

Additionally, extend the sanitizer to warn about Process mode usage even in non-mainnet environments.

## Proof of Concept

Create a malicious validator configuration:

```yaml
# malicious_validator.yaml
consensus:
    safety_rules:
        service:
            type: process
            server_address: "/ip4/203.0.113.42/tcp/6180"  # Public IP
        backend:
            type: on_disk_storage
        network_timeout_ms: 30000
```

The validator will start and bind the safety-rules service to the public IP without any error or warning. An attacker can then:

```bash
# From any internet host
nc 203.0.113.42 6180
# Service accepts connections from anywhere
```

To demonstrate:
1. Configure a testnet validator with Process mode and a public IP
2. Start the validator node
3. Verify the service binds to the public address: `netstat -an | grep 6180`
4. Attempt connection from external host - connection succeeds
5. Send malformed requests to cause service disruption

The service will accept connections from any source, exposing critical signing operations to internet-wide attacks.

## Notes

**Important Clarifications:**

1. **Mainnet is protected** - The configuration sanitizer completely disallows Process mode on mainnet, eliminating this risk for production validators.

2. **Non-mainnet exposure** - Testnet, devnet, and private network validators CAN use Process mode and are vulnerable to misconfiguration.

3. **Defense-in-depth gap** - Even with mainnet protection, the lack of address validation in the code itself violates security best practices. Multiple layers of validation should exist.

4. **Comparative analysis** - The ThreadService implementation correctly hardcodes localhost binding: [7](#0-6) 

5. **Trust model consideration** - While validator operators are in the trust model, defense-in-depth requires the code to prevent dangerous configurations regardless of operator trust level.

### Citations

**File:** config/src/config/safety_rules_config.rs (L98-104)
```rust
            // Verify that the safety rules service is set to local for optimal performance
            if chain_id.is_mainnet() && !safety_rules_config.service.is_local() {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    format!("The safety rules service should be set to local in mainnet for optimal performance! Given config: {:?}", &safety_rules_config.service)
                ));
            }
```

**File:** config/src/config/safety_rules_config.rs (L232-238)
```rust
    pub fn server_address(&self) -> SocketAddr {
        self.server_address
            .to_socket_addrs()
            .expect("server_address invalid")
            .next()
            .expect("server_address invalid")
    }
```

**File:** consensus/safety-rules/src/process.rs (L62-70)
```rust
impl RemoteService for ProcessService {
    fn server_address(&self) -> SocketAddr {
        self.server_addr
    }

    fn network_timeout_ms(&self) -> u64 {
        self.network_timeout_ms
    }
}
```

**File:** secure/net/src/lib.rs (L281-288)
```rust
    pub fn new(service: String, listen: SocketAddr, timeout_ms: u64) -> Self {
        let listener = TcpListener::bind(listen);
        Self {
            service,
            listener: Some(listener.unwrap()),
            stream: None,
            timeout_ms,
        }
```

**File:** consensus/safety-rules/src/remote_service.rs (L30-44)
```rust
pub fn execute(storage: PersistentSafetyStorage, listen_addr: SocketAddr, network_timeout_ms: u64) {
    let mut safety_rules = SafetyRules::new(storage, false);
    if let Err(e) = safety_rules.consensus_state() {
        warn!("Unable to print consensus state: {}", e);
    }

    let mut serializer_service = SerializerService::new(safety_rules);
    let mut network_server =
        NetworkServer::new("safety-rules".to_string(), listen_addr, network_timeout_ms);

    loop {
        if let Err(e) = process_one_message(&mut network_server, &mut serializer_service) {
            warn!("Failed to process message: {}", e);
        }
    }
```

**File:** config/src/config/test_data/validator.yaml (L14-16)
```yaml
        service:
            type: process
            server_address: "/ip4/127.0.0.1/tcp/5555"
```

**File:** consensus/safety-rules/src/thread.rs (L29-34)
```rust
    pub fn new(storage: PersistentSafetyStorage, timeout: u64) -> Self {
        let listen_port = utils::get_available_port();
        let listen_addr = SocketAddr::new(IpAddr::V4(Ipv4Addr::LOCALHOST), listen_port);
        let server_addr = listen_addr;

        let child = thread::spawn(move || remote_service::execute(storage, listen_addr, timeout));
```
