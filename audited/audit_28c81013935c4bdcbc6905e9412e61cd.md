# Audit Report

## Title
Database State Regression via Oneoff Transaction Restore Enables Double-Spending

## Summary
The transaction restore system allows replaying old backups over newer chain state through the `oneoff transaction` restore command, causing database regression and enabling double-spending of funds transferred after the backup point. This breaks state consistency guarantees and consensus safety.

## Finding Description

The Aptos backup/restore system provides two restore paths: the coordinated `bootstrap-db` command and the direct `oneoff transaction` command. While the bootstrap coordinator includes version validation checks, the oneoff transaction restore path has a critical flaw that allows restoring backups from older versions over a database with newer state.

**Vulnerable Code Path:**

When `TransactionRestoreController` is instantiated for oneoff restore, it passes `None` for the `first_version` parameter: [1](#0-0) 

This `None` value causes the restore process to accept any backup version without validating it against the current database state. The chunk filtering logic uses `first_version.unwrap_or(0)`, allowing chunks from any version to pass through: [2](#0-1) 

When processing transactions to save, the code retrieves `next_expected_version` from the database but only uses it to determine the replay boundary, not to reject old backups: [3](#0-2) 

The transactions are then saved directly to the database without version validation: [4](#0-3) 

The underlying `save_transactions` function directly overwrites database entries and updates the `OverallCommitProgress` metadata to the last restored version: [5](#0-4) 

**Attack Scenario:**

1. Validator operates normally, reaching database version 1000
2. Attacker obtains an old backup from version 500-600 (via compromised backup storage, validator access, or their own historical backup)
3. Attacker executes: `aptos-db-tool restore oneoff transaction --transaction-manifest old_backup_500_600.json --target-db-dir /validator/db`
4. The restore process:
   - Loads backup chunks for versions 500-600
   - Sets `global_first_version = 500` (from first chunk)
   - Sets `first_to_replay = Version::MAX` (no replay specified)
   - Saves transactions 500-600 directly to database, overwriting existing data
   - Updates `OverallCommitProgress` from 1000 to 600
5. The validator's database is now regressed to version 600:
   - Transactions 601-1000 become orphaned (still in DB but unreachable)
   - State root at version 600 differs from network consensus
   - Funds transferred in transactions 601-1000 can be double-spent

Unlike the bootstrap coordinator which validates backup versions, the oneoff path has no such protection: [6](#0-5) 

## Impact Explanation

**Critical Severity** - This vulnerability enables multiple critical impacts:

1. **Double-Spending**: Transactions that occurred after the backup point are reverted. If Alice sent 1000 APT to Bob at version 700, reverting to version 600 allows Alice to spend those funds again.

2. **Consensus Safety Violation**: The affected validator operates on a different state root than the network, breaking the fundamental consensus invariant that all honest validators agree on committed state.

3. **Network Fork Risk**: If multiple validators are compromised simultaneously, they could form a divergent chain, requiring emergency intervention or hard fork to resolve.

4. **Loss of Funds**: Users whose transactions were committed in versions 601-1000 effectively lose their fund transfers, as the validator no longer recognizes those state changes.

5. **Validator Slashing**: The regressed validator will produce incorrect signatures and votes, likely triggering slashing mechanisms and loss of staked funds.

This meets the **Critical Severity** criteria under "Consensus/Safety violations" and "Loss of Funds" categories, with potential payout up to $1,000,000.

## Likelihood Explanation

**High Likelihood** due to multiple realistic attack vectors:

1. **Compromised Validator Node**: If an attacker gains shell access to a validator (via software vulnerabilities, misconfigurations, or social engineering), they can directly execute the db-tool command.

2. **Insider Threat**: Malicious validator operators or infrastructure administrators have direct access to execute this command.

3. **Backup Storage Compromise**: Attackers who compromise backup storage can obtain old backup manifests and potentially inject them into restore operations.

4. **Operational Accidents**: Legitimate operators attempting to restore from backup might accidentally select old backup files, especially during disaster recovery scenarios.

The attack requires:
- Access to validator's filesystem (high barrier but achievable)
- Old backup manifest file (readily available from backup storage)
- Single CLI command execution (trivial complexity)

No cryptographic breaks, consensus manipulation, or complex exploit chains are needed. The vulnerability is a straightforward missing validation check.

## Recommendation

Add version validation in `TransactionRestoreController::new` or at the beginning of `TransactionRestoreBatchController::run_impl` to prevent restoring backups older than the current database state:

```rust
// In TransactionRestoreBatchController::run_impl, after line 312:
if let RestoreRunMode::Restore { restore_handler } = self.global_opt.run_mode.as_ref() {
    let current_db_version = restore_handler.get_next_expected_transaction_version()?;
    if current_db_version > 0 {
        ensure!(
            first_version >= current_db_version,
            "Cannot restore backup from version {} over newer database state at version {}. \
             This would cause database regression and potential double-spending. \
             Use bootstrap-db command instead for full database restore.",
            first_version,
            current_db_version - 1
        );
    }
}
```

Alternatively, deprecate the oneoff transaction restore command entirely and require all restores to go through the coordinated bootstrap path which has proper validation: [7](#0-6) 

## Proof of Concept

**Setup:**
1. Initialize a validator with database at version 1000
2. Create backup manifest for versions 500-600
3. Attempt oneoff transaction restore

**Exploitation Steps:**

```bash
# Step 1: Check current DB version
$ aptos-db-tool print-db-versions --db-path /validator/db
# Output shows: Overall commit progress: 1000

# Step 2: Attempt restore with old backup
$ aptos-db-tool restore oneoff transaction \
    --transaction-manifest backup_500_600.json \
    --local-fs-dir /backups \
    --target-db-dir /validator/db

# Step 3: Verify database regression
$ aptos-db-tool print-db-versions --db-path /validator/db
# Output shows: Overall commit progress: 600 (REGRESSED!)

# Step 4: Query transaction 700 (should exist but is now orphaned)
$ aptos-db-tool query-transaction --version 700 --db-path /validator/db
# Error: Transaction not found (or returns stale data)
```

**Rust Integration Test:**

```rust
#[tokio::test]
async fn test_backup_replay_regression() {
    let tmpdir = TempPath::new();
    let db = AptosDB::new_for_test(&tmpdir);
    
    // Commit transactions 0-1000
    for v in 0..=1000 {
        let chunk = generate_test_chunk(v, 1);
        db.save_transactions(...).unwrap();
    }
    assert_eq!(db.get_synced_version().unwrap(), Some(1000));
    
    // Create old backup for versions 500-600
    let backup_manifest = create_backup_manifest(500, 600);
    
    // Attempt restore via oneoff path
    let restore_controller = TransactionRestoreController::new(
        TransactionRestoreOpt {
            manifest_handle: backup_manifest,
            replay_from_version: None,
            kv_only_replay: None,
        },
        global_opts,
        storage,
        None,
        VerifyExecutionMode::NoVerify,
    );
    
    restore_controller.run().await.unwrap();
    
    // VULNERABILITY: DB regressed to version 600
    assert_eq!(db.get_synced_version().unwrap(), Some(600)); // This should fail but doesn't!
    
    // Transactions 601-1000 are now orphaned
    assert!(db.get_transaction(700).is_err()); // Unreachable transaction
}
```

## Notes

This vulnerability is distinct from normal commit validation which checks version ordering during regular operation: [8](#0-7) 

The normal commit path correctly rejects old versions, but the restore path bypasses these checks by writing directly to the database through the restore utilities. The fix requires adding equivalent validation to the restore code path.

### Citations

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L230-239)
```rust
        let inner = TransactionRestoreBatchController::new(
            global_opt,
            storage,
            vec![opt.manifest_handle],
            None,
            replay_from_version,
            epoch_history,
            verify_execution_mode,
            None,
        );
```

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L355-362)
```rust
        let target_version = self.global_opt.target_version;
        let first_version = self.first_version.unwrap_or(0);
        let chunk_manifest_stream = manifest_stream
            .map_ok(|m| stream::iter(m.chunks.into_iter().map(Result::<_>::Ok)))
            .try_flatten()
            .try_filter(move |c| {
                future::ready(c.first_version <= target_version && c.last_version >= first_version)
            })
```

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L442-457)
```rust
        // get the next expected transaction version of the current aptos db from txn_info CF
        let next_expected_version = self
            .global_opt
            .run_mode
            .get_next_expected_transaction_version()?;
        let start = Instant::now();

        let restore_handler_clone = restore_handler.clone();
        // DB doesn't allow replaying anything before what's in DB already.
        // self.replay_from_version is from cli argument. However, in fact, we either not replay or replay
        // after current DB's version.
        let first_to_replay = max(
            self.replay_from_version
                .map_or(Version::MAX, |(version, _)| version),
            next_expected_version,
        );
```

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L507-516)
```rust
                        tokio::task::spawn_blocking(move || {
                            restore_handler.save_transactions(
                                first_version,
                                &txns_to_save,
                                &persisted_aux_info_to_save,
                                &txn_infos_to_save,
                                &event_vecs_to_save,
                                write_sets_to_save,
                            )
                        })
```

**File:** storage/aptosdb/src/backup/restore_utils.rs (L279-291)
```rust
    let last_version = first_version + txns.len() as u64 - 1;
    ledger_db_batch
        .ledger_metadata_db_batches
        .put::<DbMetadataSchema>(
            &DbMetadataKey::LedgerCommitProgress,
            &DbMetadataValue::Version(last_version),
        )?;
    ledger_db_batch
        .ledger_metadata_db_batches
        .put::<DbMetadataSchema>(
            &DbMetadataKey::OverallCommitProgress,
            &DbMetadataValue::Version(last_version),
        )?;
```

**File:** storage/backup/backup-cli/src/coordinators/restore.rs (L152-155)
```rust
        let mut db_next_version = self
            .global_opt
            .run_mode
            .get_next_expected_transaction_version()?;
```

**File:** storage/backup/backup-cli/src/coordinators/restore.rs (L270-277)
```rust
            assert!(
                db_next_version == 0
                    || transaction_backups.first().map_or(0, |t| t.first_version)
                        <= db_next_version,
                "Inconsistent state: first txn version {} is larger than db_next_version {}",
                transaction_backups.first().map_or(0, |t| t.first_version),
                db_next_version
            );
```

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L522-538)
```rust
    fn get_and_check_commit_range(&self, version_to_commit: Version) -> Result<Option<Version>> {
        let old_committed_ver = self.ledger_db.metadata_db().get_synced_version()?;
        let pre_committed_ver = self.state_store.current_state_locked().version();
        ensure!(
            old_committed_ver.is_none() || version_to_commit >= old_committed_ver.unwrap(),
            "Version too old to commit. Committed: {:?}; Trying to commit with LI: {}",
            old_committed_ver,
            version_to_commit,
        );
        ensure!(
            pre_committed_ver.is_some() && version_to_commit <= pre_committed_ver.unwrap(),
            "Version too new to commit. Pre-committed: {:?}, Trying to commit with LI: {}",
            pre_committed_ver,
            version_to_commit,
        );
        Ok(old_committed_ver)
    }
```
