# Audit Report

## Title
Byzantine Validator Can Prevent Batch Retrieval via Stale LedgerInfo Injection in Quorum Store

## Summary
A Byzantine validator can prevent honest nodes from retrieving available batches by responding with `BatchResponse::NotFound` containing an old but valid `LedgerInfoWithSignatures`. The requester validates only the epoch, timestamp, and cryptographic signatures, but does not verify freshness or require consensus from multiple validators. This causes immediate request termination without waiting for responses from honest validators, resulting in a liveness attack.

## Finding Description
The vulnerability exists in the batch request handling logic. When a node requests a batch, it sends requests to multiple validators and processes responses as they arrive. [1](#0-0) 

The critical flaw occurs when processing `BatchResponse::NotFound` responses. [2](#0-1) 

The validation only checks:
1. Epoch matches current epoch
2. Timestamp exceeds batch expiration
3. Signatures are cryptographically valid

Critically, it does NOT verify:
- That this is the LATEST ledger info
- That multiple validators agree
- That the responding validator actually checked local storage

When these checks pass, the requester immediately returns an error and abandons the request, even if honest validators have the batch and would respond successfully.

**Attack Mechanism:**

The honest implementation retrieves the latest ledger info when a batch is not found locally: [3](#0-2) 

However, a Byzantine validator can:
1. Store old `LedgerInfoWithSignatures` from earlier in the same epoch
2. When requested for a batch it possesses, lie by sending `BatchResponse::NotFound(old_ledger_info)`
3. Use an old ledger info where `old_ledger_info.timestamp > batch.expiration`
4. The requester validates the old ledger info and immediately terminates
5. Honest validators' responses are never awaited

**Why This Works:**

Batches are created with expiration timestamps (typically current_time + 60 seconds). [4](#0-3) 

Batches remain in storage for an additional buffer period (60 seconds by default) after expiration to help slow nodes catch up. [5](#0-4) 

**Attack Timeline:**
1. T1: Batch B created with expiration = T1 + 60s
2. T2 (T1+65s): Ledger info L2 committed with timestamp T2  
3. T3 (T1+70s): Current latest ledger info L3 committed
4. T4 (T1+75s): Requester asks for batch B
5. Byzantine validator has batch B (not yet garbage collected) but sends `NotFound(L2)`
6. Requester validates L2 (epoch matches, T2 > T1+60s, signatures valid)
7. Requester immediately errors out without waiting for honest validators

## Impact Explanation
This is a **High Severity** liveness attack:

- **Validator Node Slowdowns**: Affected nodes cannot retrieve batches needed for consensus execution, causing them to fall behind
- **Significant Protocol Violation**: Breaks Byzantine fault tolerance guarantees - a single Byzantine validator (< 1/3 threshold) can cause denial of service
- **Consensus Impact**: Prevents block execution on affected nodes, potentially causing network-wide slowdowns if multiple nodes are targeted

While cryptographic forgery is impossible (cannot create fake signatures), the attack achieves the same goal using old but valid ledger infos. This breaks the critical invariant: "**Consensus Safety**: AptosBFT must prevent double-spending and chain splits under < 1/3 Byzantine" - specifically, a single Byzantine validator should not be able to cause liveness failures.

## Likelihood Explanation  
**High Likelihood:**
- Any validator in the active set can execute this attack
- No sophisticated exploit required - simply send old ledger info instead of batch
- Attacker only needs to store previous `LedgerInfoWithSignatures` from the same epoch
- Works whenever batch expiration < old_ledger_timestamp < current_ledger_timestamp
- No detection mechanism exists - appears as legitimate NotFound response
- Single Byzantine validator sufficient (no collusion needed)

## Recommendation
Implement multi-validator consensus for batch availability and add freshness verification:

```rust
// In batch_requester.rs, replace immediate return with response collection
Ok(BatchResponse::NotFound(ledger_info)) => {
    counters::RECEIVED_BATCH_NOT_FOUND_COUNT.inc();
    if ledger_info.commit_info().epoch() == epoch
        && ledger_info.commit_info().timestamp_usecs() > expiration
        && ledger_info.verify_signatures(&validator_verifier).is_ok()
    {
        // Don't immediately return - collect multiple responses
        not_found_responses.push(ledger_info);
        
        // Only accept if majority of responses indicate NotFound
        // with consistent latest ledger info
        if not_found_responses.len() >= (request_num_peers + 1) / 2 {
            // Verify all NotFound responses have similar timestamps
            // (within acceptable drift threshold)
            let timestamps: Vec<_> = not_found_responses
                .iter()
                .map(|li| li.commit_info().timestamp_usecs())
                .collect();
            
            if timestamps_are_consistent(&timestamps) {
                counters::RECEIVED_BATCH_EXPIRED_COUNT.inc();
                debug!("QS: batch request expired with consensus, digest:{}", digest);
                return Err(ExecutorError::CouldNotGetData);
            }
        }
    }
}
```

Additionally, add freshness bound checking:
```rust
// Verify ledger info is reasonably fresh (within epoch duration)
let max_acceptable_age = config.max_ledger_info_staleness_usecs;
if current_time - ledger_info.commit_info().timestamp_usecs() > max_acceptable_age {
    debug!("Rejecting stale ledger info in NotFound response");
    continue;
}
```

## Proof of Concept

```rust
#[tokio::test]
async fn test_byzantine_validator_stale_ledger_info_attack() {
    // Setup: Create batch store with batch B
    let batch_expiration = 1000;
    let batch_b = create_test_batch(batch_expiration);
    
    // T1: Create old but valid ledger info after batch expiration
    let old_ledger_time = batch_expiration + 5;
    let old_ledger_info = create_signed_ledger_info(
        epoch = 1,
        timestamp = old_ledger_time,
        // Signed by 2f+1 validators
    );
    
    // T2: Current time is later, with newer ledger info
    let current_time = batch_expiration + 20;
    let current_ledger_info = create_signed_ledger_info(
        epoch = 1, 
        timestamp = current_time,
    );
    
    // Setup Byzantine validator that has batch_b but responds with old ledger info
    let byzantine_validator = MockValidator::new()
        .with_batch(batch_b.digest())
        .with_response(BatchResponse::NotFound(old_ledger_info));
    
    // Setup honest validator that would return the batch
    let honest_validator = MockValidator::new()
        .with_batch(batch_b.digest())
        .with_response(BatchResponse::Batch(batch_b));
    
    // Create requester that queries both validators
    let requester = BatchRequester::new(...);
    
    // Byzantine validator responds quickly, honest validator responds slowly
    byzantine_validator.set_response_delay(Duration::from_millis(10));
    honest_validator.set_response_delay(Duration::from_millis(100));
    
    // Execute request
    let result = requester.request_batch(
        batch_b.digest(),
        batch_expiration,
        Arc::new(Mutex::new(BTreeSet::from([
            byzantine_validator.peer_id(),
            honest_validator.peer_id(),
        ]))),
        subscriber_rx,
    ).await;
    
    // VULNERABILITY: Request fails even though honest validator has the batch
    assert!(result.is_err());
    assert_eq!(result.unwrap_err(), ExecutorError::CouldNotGetData);
    
    // Verify honest validator was never queried or response ignored
    assert_eq!(honest_validator.response_count(), 0);
}
```

## Notes

**Key Distinction:** While an attacker cannot FORGE a `LedgerInfoWithSignatures` (cannot create fake BLS signatures without controlling 2f+1 stake), they CAN weaponize old but cryptographically valid ledger infos to achieve the same attack goal. The vulnerability is not in cryptographic forgery but in the lack of freshness validation and single-validator trust model.

The issue specifically violates the Byzantine fault tolerance guarantee that < 1/3 Byzantine validators should not cause liveness failures. The fix requires implementing quorum-based batch availability checks rather than trusting single validator responses.

### Citations

**File:** consensus/src/quorum_store/batch_requester.rs (L117-180)
```rust
        monitor!("batch_request", {
            let mut interval = time::interval(retry_interval);
            let mut futures = FuturesUnordered::new();
            let request = BatchRequest::new(my_peer_id, epoch, digest);
            loop {
                tokio::select! {
                    _ = interval.tick() => {
                        // send batch request to a set of peers of size request_num_peers
                        if let Some(request_peers) = request_state.next_request_peers(request_num_peers) {
                            for peer in request_peers {
                                futures.push(network_sender.request_batch(request.clone(), peer, rpc_timeout));
                            }
                        } else if futures.is_empty() {
                            // end the loop when the futures are drained
                            break;
                        }
                    },
                    Some(response) = futures.next() => {
                        match response {
                            Ok(BatchResponse::Batch(batch)) => {
                                counters::RECEIVED_BATCH_RESPONSE_COUNT.inc();
                                let payload = batch.into_transactions();
                                return Ok(payload);
                            }
                            // Short-circuit if the chain has moved beyond expiration
                            Ok(BatchResponse::NotFound(ledger_info)) => {
                                counters::RECEIVED_BATCH_NOT_FOUND_COUNT.inc();
                                if ledger_info.commit_info().epoch() == epoch
                                    && ledger_info.commit_info().timestamp_usecs() > expiration
                                    && ledger_info.verify_signatures(&validator_verifier).is_ok()
                                {
                                    counters::RECEIVED_BATCH_EXPIRED_COUNT.inc();
                                    debug!("QS: batch request expired, digest:{}", digest);
                                    return Err(ExecutorError::CouldNotGetData);
                                }
                            }
                            Ok(BatchResponse::BatchV2(_)) => {
                                error!("Batch V2 response is not supported");
                            }
                            Err(e) => {
                                counters::RECEIVED_BATCH_RESPONSE_ERROR_COUNT.inc();
                                debug!("QS: batch request error, digest:{}, error:{:?}", digest, e);
                            }
                        }
                    },
                    result = &mut subscriber_rx => {
                        match result {
                            Ok(persisted_value) => {
                                counters::RECEIVED_BATCH_FROM_SUBSCRIPTION_COUNT.inc();
                                let (_, maybe_payload) = persisted_value.unpack();
                                return Ok(maybe_payload.expect("persisted value must exist"));
                            }
                            Err(err) => {
                                debug!("channel closed: {}", err);
                            }
                        };
                    },
                }
            }
            counters::RECEIVED_BATCH_REQUEST_TIMEOUT_COUNT.inc();
            debug!("QS: batch request timed out, digest:{}", digest);
            Err(ExecutorError::CouldNotGetData)
        })
    }
```

**File:** consensus/src/quorum_store/quorum_store_builder.rs (L408-425)
```rust
                let response = if let Ok(value) =
                    batch_store.get_batch_from_local(&rpc_request.req.digest())
                {
                    let batch: Batch<BatchInfoExt> = value.try_into().unwrap();
                    let batch: Batch<BatchInfo> = batch
                        .try_into()
                        .expect("Batch retieval requests must be for V1 batch");
                    BatchResponse::Batch(batch)
                } else {
                    match aptos_db_clone.get_latest_ledger_info() {
                        Ok(ledger_info) => BatchResponse::NotFound(ledger_info),
                        Err(e) => {
                            let e = anyhow::Error::from(e);
                            error!(epoch = epoch, error = ?e, kind = error_kind(&e));
                            continue;
                        },
                    }
                };
```

**File:** config/src/config/quorum_store_config.rs (L62-65)
```rust
    /// from the mempool. This is NOT the maximum number of batches that the batch generator can create
    /// per second.
    pub sender_max_num_batches: usize,
    /// The maximum number of transactions that the batch generator pulls from the mempool at a time.
```

**File:** consensus/src/quorum_store/batch_store.rs (L443-448)
```rust
    pub(crate) fn clear_expired_payload(&self, certified_time: u64) -> Vec<HashValue> {
        // To help slow nodes catch up via execution without going to state sync we keep the blocks for 60 extra seconds
        // after the expiration time. This will help remote peers fetch batches that just expired but are within their
        // execution window.
        let expiration_time = certified_time.saturating_sub(self.expiration_buffer_usecs);
        let expired_digests = self.expirations.lock().expire(expiration_time);
```
