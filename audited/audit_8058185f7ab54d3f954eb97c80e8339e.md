# Audit Report

## Title
Insufficient Input Validation in Gas Schedule Governance Allows Blockchain DoS via Empty Entries Vector

## Summary
A malformed governance proposal can set `GasScheduleV2` with an empty `entries` vector, causing all transaction execution to fail with `VM_STARTUP_FAILURE` and creating a non-recoverable chain halt requiring a hard fork.

## Finding Description

The gas schedule update mechanism lacks validation to prevent empty gas parameter entries. When a governance proposal sets `GasScheduleV2.entries` to an empty vector:

1. The Move-side validation only checks that the BCS-serialized blob is non-empty, but doesn't validate the deserialized `entries` vector. [1](#0-0) 

2. The `into_btree_map()` function converts the empty vector to an empty `BTreeMap<String, u64>`: [2](#0-1) 

3. The `from_on_chain_gas_schedule` macro attempts to look up required parameters (like `"txn.min_transaction_gas_units"`) in the empty map: [3](#0-2) 

4. The lookup fails and returns an error. This error is stored in the `Environment`: [4](#0-3) 

5. While native gas parameters fallback to zeros, the main `gas_params` Result remains an error: [5](#0-4) 

6. All transaction execution attempts fail when retrieving gas parameters: [6](#0-5) 

**Attack Path:**
1. Craft a `GasScheduleV2` with `entries: vector[]` (empty) and valid `feature_version`
2. Submit as governance proposal via `set_for_next_epoch` or `set_for_next_epoch_check_hash`
3. Proposal passes on-chain validation (blob is non-empty due to BCS encoding)
4. After epoch transition, all transactions fail with `VM_STARTUP_FAILURE`
5. Even governance transactions to fix the schedule fail, creating permanent chain halt

## Impact Explanation

This constitutes **Critical Severity** under the Aptos bug bounty program:
- **Total loss of liveness/network availability**: No transactions can execute, including validator operations
- **Non-recoverable network partition (requires hardfork)**: Cannot fix via governance since governance transactions also fail
- Breaks the **Move VM Safety** invariant: The VM cannot enforce gas limits when gas parameters are unavailable
- Breaks the **Resource Limits** invariant: Operations cannot respect gas limits

## Likelihood Explanation

**Likelihood: Low to Medium**

While this requires governance access (a trusted role), the vulnerability could manifest through:
1. **Accidental misconfiguration**: A bug in proposal generation tools could create malformed schedules
2. **Compromised governance keys**: If governance credentials are compromised
3. **Supply chain attack**: Malicious code in proposal generation dependencies

The TODO comment at line 67 in `gas_schedule.move` indicates the developers are aware validation is incomplete, suggesting this is a known gap. [7](#0-6) 

## Recommendation

Add validation in the Move contract to reject empty `entries` vectors:

```move
public fun set_for_next_epoch(aptos_framework: &signer, gas_schedule_blob: vector<u8>) acquires GasScheduleV2 {
    system_addresses::assert_aptos_framework(aptos_framework);
    assert!(!vector::is_empty(&gas_schedule_blob), error::invalid_argument(EINVALID_GAS_SCHEDULE));
    let new_gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
    
    // ADD THIS VALIDATION:
    assert!(!vector::is_empty(&new_gas_schedule.entries), error::invalid_argument(EINVALID_GAS_SCHEDULE));
    
    if (exists<GasScheduleV2>(@aptos_framework)) {
        let cur_gas_schedule = borrow_global<GasScheduleV2>(@aptos_framework);
        assert!(
            new_gas_schedule.feature_version >= cur_gas_schedule.feature_version,
            error::invalid_argument(EINVALID_GAS_FEATURE_VERSION)
        );
    };
    config_buffer::upsert(new_gas_schedule);
}
```

Apply the same fix to `set_for_next_epoch_check_hash` and other gas schedule update functions.

## Proof of Concept

```move
#[test(fx = @aptos_framework)]
#[expected_failure(abort_code=0x010001, location = aptos_framework::gas_schedule)]
fun test_empty_gas_schedule_should_be_rejected(fx: signer) {
    use std::bcs;
    
    // Create a GasScheduleV2 with empty entries
    let malicious_schedule = GasScheduleV2 {
        feature_version: 1,
        entries: vector[], // Empty!
    };
    
    let schedule_bytes = bcs::to_bytes(&malicious_schedule);
    
    // This should abort with EINVALID_GAS_SCHEDULE after adding validation
    gas_schedule::set_for_next_epoch(&fx, schedule_bytes);
}
```

Without the validation fix, this test would pass (incorrectly accepting the empty schedule). With the fix, it properly rejects empty gas schedules.

**Note**: This vulnerability requires governance access to exploit, placing it outside the traditional "unprivileged attacker" scope. However, it represents a critical defense-in-depth failure that could enable chain halts through compromised governance or accidental misconfiguration.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L65-68)
```text
            assert!(new_gas_schedule.feature_version >= gas_schedule.feature_version,
                error::invalid_argument(EINVALID_GAS_FEATURE_VERSION));
            // TODO(Gas): check if gas schedule is consistent
            *gas_schedule = new_gas_schedule;
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L91-94)
```text
    public fun set_for_next_epoch(aptos_framework: &signer, gas_schedule_blob: vector<u8>) acquires GasScheduleV2 {
        system_addresses::assert_aptos_framework(aptos_framework);
        assert!(!vector::is_empty(&gas_schedule_blob), error::invalid_argument(EINVALID_GAS_SCHEDULE));
        let new_gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
```

**File:** types/src/on_chain_config/gas_schedule.rs (L56-60)
```rust
impl GasScheduleV2 {
    pub fn into_btree_map(self) -> BTreeMap<String, u64> {
        // TODO: what if the gas schedule contains duplicated entries?
        self.entries.into_iter().collect()
    }
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/macros.rs (L38-41)
```rust
                    if let Some(key) = $crate::gas_schedule::macros::define_gas_parameters_extract_key_at_version!($key_bindings, feature_version) {
                        let name = format!("{}.{}", $prefix, key);
                        params.$name = gas_schedule.get(&name).cloned().ok_or_else(|| format!("Gas parameter {} does not exist. Feature version: {}.", name, feature_version))?.into();
                    }
```

**File:** aptos-move/aptos-vm-environment/src/gas.rs (L31-35)
```rust
            let map = gas_schedule.into_btree_map();
            (
                AptosGasParameters::from_on_chain_gas_schedule(&map, feature_version),
                feature_version,
            )
```

**File:** aptos-move/aptos-vm-environment/src/environment.rs (L257-264)
```rust
            Err(_) => {
                let ty_builder = aptos_default_ty_builder();
                (
                    NativeGasParameters::zeros(),
                    MiscGasParameters::zeros(),
                    ty_builder,
                )
            },
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L273-281)
```rust
pub(crate) fn get_or_vm_startup_failure<'a, T>(
    gas_params: &'a Result<T, String>,
    log_context: &AdapterLogSchema,
) -> Result<&'a T, VMStatus> {
    gas_params.as_ref().map_err(|err| {
        let msg = format!("VM Startup Failed. {}", err);
        speculative_error!(log_context, msg.clone());
        VMStatus::error(StatusCode::VM_STARTUP_FAILURE, Some(msg))
    })
```
