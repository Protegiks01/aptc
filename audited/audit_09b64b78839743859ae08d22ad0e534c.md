# Audit Report

## Title
Unvalidated Block Gas Limit Override Enables Malicious Validators to Selectively Halt Block Execution

## Summary
A malicious validator who becomes a block proposer can set an arbitrarily low `block_gas_limit_override` value in their block's payload, causing block execution to halt after processing minimal transactions. This bypasses the intended on-chain gas limit mechanism without any validation, enabling strategic transaction censorship and network throughput manipulation.

## Finding Description

The vulnerability exists in the block execution gas limit enforcement mechanism. When a validator proposes a block, they can embed a `block_gas_limit_override` value in the payload through the `PayloadExecutionLimit` structure. This override completely replaces the on-chain configured gas limit during execution, with no validation of its reasonableness.

**Attack Flow:**

1. **Proposer sets malicious override**: In `proposal_generator.rs`, the block proposer calculates `block_gas_limit_override` through the `calculate_max_block_sizes()` method, which is supposed to use backpressure logic. However, a malicious proposer can modify this value to any arbitrary amount before embedding it in the payload. [1](#0-0) 

2. **Override embedded in payload**: The override is embedded into the block payload via `transform_to_quorum_store_v2()`, with no validation: [2](#0-1) 

3. **Validators extract override from payload**: When other validators receive the block, they extract the `block_gas_limit` from the payload and apply it without validation: [3](#0-2) 

4. **Override applied without bounds checking**: The override is set in the execution config with no validation: [4](#0-3) 

5. **Unconditional override in execution**: The `BlockGasLimitProcessor` uses the override unconditionally if present, with no minimum bound enforcement: [5](#0-4) 

6. **Early block termination**: The `should_end_block()` method terminates execution when accumulated gas exceeds the malicious limit: [6](#0-5) 

**Broken Invariant:**
- **Resource Limits (Invariant #9)**: "All operations must respect gas, storage, and computational limits" - The on-chain configured gas limit is bypassed through an unvalidated override mechanism.

**Strategic Benefits for Malicious Proposer:**
- **Transaction censorship**: Exclude specific transactions by setting limits that prevent their execution
- **MEV extraction**: Control transaction ordering and inclusion for profit
- **Network degradation**: Reduce throughput when beneficial to competing interests
- **Front-running protection**: Exclude competing transactions that would interfere with their own

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos bug bounty program:

1. **Validator node slowdowns**: Repeated blocks with artificially low gas limits would reduce network throughput and cause execution pipeline delays.

2. **Significant protocol violations**: The vulnerability bypasses the intended gas limit mechanism, which is a fundamental resource control in the protocol. The on-chain governance process configures `BlockGasLimitType` to ensure fair resource allocation, but this is circumvented.

3. **Deterministic Execution Maintained**: While all validators agree on the execution result (preserving consensus safety), the protocol's intended behavior is violated as the gas limit should derive from on-chain configuration and legitimate backpressure calculations, not arbitrary proposer choice.

The impact is limited to blocks proposed by the malicious validator, but a validator with significant stake or during a period of high proposal frequency could substantially degrade network performance.

## Likelihood Explanation

**Likelihood: Medium (when feature enabled)**

**Prerequisites:**
1. The `enable_per_block_gas_limit` flag must be set to `true` in the on-chain execution configuration (currently defaults to `false`): [7](#0-6) 

2. Attacker must be a validator in the active set
3. Attacker must become proposer for a round (happens naturally through rotation)

**Ease of Exploitation:**
- Once the feature is enabled, exploitation is trivial - the proposer simply modifies the `block_gas_limit_override` calculation before calling `transform_to_quorum_store_v2()`
- No cryptographic bypasses or complex exploits required
- The malicious value propagates automatically through the consensus and execution pipeline

**Detection:**
- Abnormally small blocks from specific validators would be observable
- However, legitimate backpressure can also cause small blocks, making attribution difficult
- No automated detection or slashing mechanism exists for this behavior

## Recommendation

Implement validation of `block_gas_limit_override` values to ensure they are reasonable and cannot be maliciously manipulated:

**1. Add minimum bound enforcement in `BlockGasLimitProcessor`:**

```rust
fn block_gas_limit(&self) -> Option<u64> {
    if let Some(override_limit) = self.block_gas_limit_override {
        // Enforce minimum bound
        let min_limit = self.block_gas_limit_type
            .block_gas_limit()
            .map(|limit| limit / 10) // At least 10% of on-chain limit
            .unwrap_or(MIN_CALIBRATED_BLOCK_GAS_LIMIT);
        
        return Some(override_limit.max(min_limit));
    }
    self.block_gas_limit_type.block_gas_limit()
}
```

**2. Add validation in execution config:**

```rust
pub fn with_block_gas_limit_override(self, block_gas_limit_override: Option<u64>) -> Self {
    let validated_override = block_gas_limit_override.and_then(|override_val| {
        if let Some(base_limit) = self.block_gas_limit_type.block_gas_limit() {
            // Reject overrides below 10% of base limit
            if override_val < base_limit / 10 {
                warn!("Rejecting suspiciously low block_gas_limit_override: {}", override_val);
                return None;
            }
        }
        Some(override_val)
    });
    
    Self {
        block_gas_limit_type: self.block_gas_limit_type,
        enable_per_block_gas_limit: self.enable_per_block_gas_limit,
        per_block_gas_limit: validated_override,
        gas_price_to_burn: self.gas_price_to_burn,
    }
}
```

**3. Add consensus-level verification:** Validators should verify that received `block_gas_limit_override` values are consistent with expected backpressure calculations before voting on blocks.

## Proof of Concept

**Rust Test Scenario:**

```rust
#[test]
fn test_malicious_gas_limit_override() {
    // Setup: Create block executor with normal on-chain gas limit
    let onchain_limit = BlockGasLimitType::Limit(1_000_000);
    let config = BlockExecutorConfigFromOnchain::new(
        onchain_limit,
        true, // enable_per_block_gas_limit = true
        None
    );
    
    // Malicious proposer sets extremely low override
    let malicious_override = Some(100); // Only 100 gas units
    let malicious_config = config.with_block_gas_limit_override(malicious_override);
    
    // Create limit processor
    let mut processor = BlockGasLimitProcessor::new(
        malicious_config.block_gas_limit_type.clone(),
        malicious_config.block_gas_limit_override(),
        1000
    );
    
    // Execute one transaction consuming 150 gas
    processor.accumulate_fee_statement(
        FeeStatement::new(150, 150, 0, 0, 0),
        None,
        None
    );
    
    // Verify block halts after first transaction (should NOT halt with normal 1M limit)
    assert!(processor.should_end_block_parallel());
    
    // Demonstrate normal behavior with proper limit
    let normal_config = BlockExecutorConfigFromOnchain::new(
        onchain_limit,
        false, // disabled override
        None
    );
    let mut normal_processor = BlockGasLimitProcessor::new(
        normal_config.block_gas_limit_type.clone(),
        normal_config.block_gas_limit_override(),
        1000
    );
    
    normal_processor.accumulate_fee_statement(
        FeeStatement::new(150, 150, 0, 0, 0),
        None,
        None
    );
    
    // Should NOT halt with normal limit
    assert!(!normal_processor.should_end_block_parallel());
}
```

This test demonstrates that when `block_gas_limit_override` is set to a maliciously low value (100), the block halts after a single transaction, whereas with the normal on-chain limit, execution continues normally.

### Citations

**File:** consensus/src/liveness/proposal_generator.rs (L787-804)
```rust
            let (txn_limit, gas_limit) = self
                .pipeline_backpressure_config
                .get_execution_block_txn_and_gas_limit_backoff(
                    &self
                        .block_store
                        .get_recent_block_execution_times(num_blocks_to_look_at),
                    self.max_block_txns_after_filtering,
                    self.max_block_gas_limit,
                );
            if let Some(txn_limit) = txn_limit {
                values_max_block_txns_after_filtering.push(txn_limit);
                execution_backpressure_applied = true;
            }
            block_gas_limit_override = gas_limit;
            if gas_limit.is_some() {
                execution_backpressure_applied = true;
            }
        }
```

**File:** consensus/consensus-types/src/common.rs (L258-268)
```rust
            Payload::QuorumStoreInlineHybridV2(inline_batches, proof_with_data, _) => {
                Payload::QuorumStoreInlineHybridV2(
                    inline_batches,
                    proof_with_data,
                    PayloadExecutionLimit::TxnAndGasLimits(TxnAndGasLimits {
                        transaction_limit: max_txns_to_execute,
                        gas_limit: block_gas_limit_override,
                    }),
                )
            },
        }
```

**File:** consensus/src/payload_manager/quorum_store_payload_manager.rs (L559-563)
```rust
        Ok((
            transaction_payload.transactions(),
            transaction_payload.transaction_limit(),
            transaction_payload.gas_limit(),
        ))
```

**File:** types/src/block_executor/config.rs (L146-152)
```rust
    pub fn with_block_gas_limit_override(self, block_gas_limit_override: Option<u64>) -> Self {
        Self {
            block_gas_limit_type: self.block_gas_limit_type,
            enable_per_block_gas_limit: self.enable_per_block_gas_limit,
            per_block_gas_limit: block_gas_limit_override,
            gas_price_to_burn: self.gas_price_to_burn,
        }
```

**File:** aptos-move/block-executor/src/limit_processor.rs (L119-125)
```rust
    fn block_gas_limit(&self) -> Option<u64> {
        if self.block_gas_limit_override.is_some() {
            self.block_gas_limit_override
        } else {
            self.block_gas_limit_type.block_gas_limit()
        }
    }
```

**File:** aptos-move/block-executor/src/limit_processor.rs (L127-140)
```rust
    fn should_end_block(&mut self, mode: &str) -> bool {
        if let Some(per_block_gas_limit) = self.block_gas_limit() {
            // When the accumulated block gas of the committed txns exceeds
            // PER_BLOCK_GAS_LIMIT, early halt BlockSTM.
            let accumulated_block_gas = self.get_effective_accumulated_block_gas();
            if accumulated_block_gas >= per_block_gas_limit {
                counters::EXCEED_PER_BLOCK_GAS_LIMIT_COUNT.inc_with(&[mode]);
                info!(
                    "[BlockSTM]: execution ({}) early halted due to \
                    accumulated_block_gas {} >= PER_BLOCK_GAS_LIMIT {}",
                    mode, accumulated_block_gas, per_block_gas_limit,
                );
                return true;
            }
```

**File:** types/src/on_chain_config/execution_config.rs (L122-133)
```rust
    /// The default values to use for new networks, e.g., devnet, forge.
    /// Features that are ready for deployment can be enabled here.
    pub fn default_for_genesis() -> Self {
        OnChainExecutionConfig::V7(ExecutionConfigV7 {
            transaction_shuffler_type: TransactionShufflerType::default_for_genesis(),
            block_gas_limit_type: BlockGasLimitType::default_for_genesis(),
            enable_per_block_gas_limit: false,
            transaction_deduper_type: TransactionDeduperType::TxnHashAndAuthenticatorV1,
            gas_price_to_burn: 90,
            persisted_auxiliary_info_version: 1,
        })
    }
```
