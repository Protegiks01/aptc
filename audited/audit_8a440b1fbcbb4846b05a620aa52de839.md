# Audit Report

## Title
Unbounded Memory Growth via Duplicate Proposals with Missing Payload in Consensus Layer

## Summary
The `FuturesUnordered` collection in `RoundManager::process_proposal()` lacks deduplication checks when creating futures for proposals with missing payloads. An attacker can send the same valid proposal multiple times to exhaust validator memory through unbounded future accumulation.

## Finding Description
The vulnerability exists in the consensus proposal processing logic where proposals awaiting payload data are handled. When a proposal is received but its payload is not locally available (e.g., missing quorum store batches), the system creates an async future to wait for the payload and pushes it to a `FuturesUnordered` collection. [1](#0-0) 

The critical flaw occurs in `process_proposal()` where no deduplication check exists before creating and pushing futures: [2](#0-1) 

The attack path works as follows:

1. **Duplicate Acceptance**: The `is_valid_proposal()` check explicitly allows the same block (same block ID) to be processed multiple times, only preventing equivocation (different blocks for same round): [3](#0-2) 

2. **Idempotent Block Insertion**: When the same proposal is received multiple times, `insert_block()` returns the existing block without error: [4](#0-3) 

3. **No Future Deduplication**: After the idempotent insert, `check_payload()` still fails for the missing payload, triggering creation of another future. There is no check to prevent creating duplicate futures for the same block ID.

4. **Unbounded Growth**: Each duplicate proposal creates a new future that remains in the `FuturesUnordered` until the round deadline timeout (typically 1-3 seconds). If proposals arrive faster than timeouts complete, memory grows unbounded.

**Attack Scenario:**
- A malicious validator (as designated proposer) creates a valid proposal referencing unavailable payload (quorum store batches they deliberately withhold)
- They broadcast this proposal multiple times through different network paths
- Each reception triggers future creation without deduplication
- Alternatively, a network attacker intercepts a valid proposal, blocks payload data, and replays the proposal message repeatedly
- The `FuturesUnordered` accumulates futures until memory exhaustion crashes the validator

This breaks the **Resource Limits** invariant (Invariant #9): "All operations must respect gas, storage, and computational limits."

## Impact Explanation
**Severity: High** (Validator node slowdowns / crashes)

This vulnerability enables a Denial of Service attack against validator nodes:

- **Memory Exhaustion**: Unbounded future accumulation can exhaust node memory, causing crashes
- **Validator Unavailability**: Crashed validators cannot participate in consensus, reducing network security
- **Network Liveness Impact**: If multiple validators are targeted simultaneously, consensus could stall
- **No Fund Loss**: Does not directly lead to fund theft or consensus safety violations

Per Aptos bug bounty criteria, this qualifies as **High Severity** due to enabling validator node slowdowns and potential crashes affecting network availability.

## Likelihood Explanation
**Likelihood: Medium-High**

The attack is relatively straightforward to execute:

**Attacker Requirements:**
- Ability to send consensus messages to validator nodes (malicious validator OR network-level attacker)
- For network attackers: ability to intercept/replay valid proposals and block payload data
- For malicious validators: ability to create proposals with missing payload (when they are designated proposer)

**Execution Complexity:**
- Low - simply requires sending duplicate proposal messages
- No special cryptographic capabilities needed beyond what a validator already has
- No need for Byzantine coalition (single malicious actor sufficient)

**Constraints:**
- Proposals must be for current round (checked by `ensure_round_and_sync_up`)
- Proposals must have valid signatures
- Channel has KLAST limit of 10 per author, but futures accumulate beyond channel limits
- Futures timeout after round deadline, but can accumulate faster than timeouts if attack rate is high

The attack is feasible and does not require extraordinary capabilities, making it a realistic threat.

## Recommendation
Implement deduplication before creating futures for payload waiting. Track block IDs that already have pending futures and skip creating duplicates:

```rust
// Add to RoundManager struct
pending_payload_futures: Mutex<HashSet<HashValue>>,

// In process_proposal(), replace lines 1262-1278 with:
let block_store = self.block_store.clone();
if block_store.check_payload(&proposal).is_err() {
    let block_id = proposal.id();
    
    // Check if we already have a future waiting for this block's payload
    if !self.pending_payload_futures.lock().insert(block_id) {
        debug!("Future already pending for block: {}", block_id);
        return Ok(());
    }
    
    debug!("Payload not available locally for block: {}", block_id);
    counters::CONSENSUS_PROPOSAL_PAYLOAD_AVAILABILITY
        .with_label_values(&["missing"])
        .inc();
    
    let start_time = Instant::now();
    let deadline = self.round_state.current_round_deadline();
    let pending_futures = self.pending_payload_futures.clone();
    
    let future = async move {
        let result = block_store.wait_for_payload(&proposal, deadline).await;
        // Remove from pending set when future completes
        pending_futures.lock().remove(&block_id);
        (result, proposal, start_time)
    }
    .boxed();
    
    self.futures.push(future);
    return Ok(());
}
```

This ensures at most one future waits for each unique block's payload, preventing unbounded growth from duplicate proposals.

## Proof of Concept
The vulnerability can be demonstrated through the following sequence:

```rust
// Conceptual PoC - would need full consensus test harness to execute
// 
// Setup:
// 1. Create a validator network with RoundManager
// 2. Have validator V1 as designated proposer for round R
// 
// Attack:
// 1. V1 creates proposal P with block_id = H, round = R
// 2. P references quorum store batches that V1 doesn't broadcast
// 3. V1 sends P to victim validator V2 multiple times (N times)
// 
// Observed behavior:
// - V2 receives P the first time
//   - insert_block(P) succeeds, adds block to store
//   - check_payload(P) fails (missing batches)
//   - Future F1 created and pushed to futures
// 
// - V2 receives P the second time
//   - insert_block(P) returns existing block (idempotent)
//   - check_payload(P) still fails
//   - Future F2 created and pushed to futures (DUPLICATE)
// 
// - Repeat N times: futures.len() grows to N
// 
// - After round timeout (~3 seconds), all N futures complete
// - But if N is large and sent rapidly, memory exhaustion occurs
// 
// To verify:
// 1. Add logging to count futures.len() before/after each push
// 2. Send same proposal 1000 times with missing payload
// 3. Observe futures.len() growing to 1000 (unbounded)
// 4. Monitor memory usage - should see significant growth
```

A full reproduction would require:
1. Consensus test framework with multiple validators
2. Ability to control quorum store batch delivery
3. Network layer that allows duplicate message delivery
4. Memory profiling to demonstrate unbounded growth

The key validation is checking that `futures.len()` grows linearly with duplicate proposals rather than remaining at 1 (as it should with deduplication).

## Notes
- This vulnerability affects all validators that receive proposals, not just specific configurations
- The bounded channel (`buffered_proposal_tx` with KLAST size 10) does NOT prevent this issue, as futures are created AFTER messages leave the channel
- Even with round timeouts, rapid duplicate sending can outpace timeout completion
- The attack can target multiple validators simultaneously for amplified network impact
- No fund loss occurs, but validator crashes reduce network security margins

### Citations

**File:** consensus/src/round_manager.rs (L326-328)
```rust
    futures: FuturesUnordered<
        Pin<Box<dyn Future<Output = (anyhow::Result<()>, Block, Instant)> + Send>>,
    >,
```

**File:** consensus/src/round_manager.rs (L1262-1278)
```rust
        if block_store.check_payload(&proposal).is_err() {
            debug!("Payload not available locally for block: {}", proposal.id());
            counters::CONSENSUS_PROPOSAL_PAYLOAD_AVAILABILITY
                .with_label_values(&["missing"])
                .inc();
            let start_time = Instant::now();
            let deadline = self.round_state.current_round_deadline();
            let future = async move {
                (
                    block_store.wait_for_payload(&proposal, deadline).await,
                    proposal,
                    start_time,
                )
            }
            .boxed();
            self.futures.push(future);
            return Ok(());
```

**File:** consensus/src/liveness/unequivocal_proposer_election.rs (L69-82)
```rust
                Ordering::Equal => {
                    if already_proposed.1 != block.id() {
                        error!(
                            SecurityEvent::InvalidConsensusProposal,
                            "Multiple proposals from {} for round {}: {} and {}",
                            author,
                            block.round(),
                            already_proposed.1,
                            block.id()
                        );
                        false
                    } else {
                        true
                    }
```

**File:** consensus/src/block_storage/block_store.rs (L413-415)
```rust
        if let Some(existing_block) = self.get_block(block.id()) {
            return Ok(existing_block);
        }
```
