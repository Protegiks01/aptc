# Audit Report

## Title
Indexer gRPC Service Panic via Invalid Address Length in Transaction Filter

## Summary
The `From<proto>` trait implementation in `UserTransactionFilter` calls `standardize_address()` without validating input length, causing the indexer-grpc service to panic when processing filters with address strings exceeding 64 hexadecimal characters. This enables unprivileged attackers to crash indexer API endpoints via malformed `GetTransactionsRequest` messages.

## Finding Description

The vulnerability exists in the transaction filter conversion logic for the indexer-grpc service. When a client sends a `GetTransactionsRequest` with a `UserTransactionFilter` containing an oversized address in the `sender` field, the conversion from protobuf to Rust types triggers a panic.

**Attack Flow:**

1. Attacker sends gRPC `GetTransactionsRequest` with `transaction_filter.user_transaction_filter.sender` set to an address string > 64 hex characters (e.g., 65+ character string after removing "0x" prefix)

2. The indexer service calls `parse_transaction_filter()` [1](#0-0) 

3. This invokes `BooleanTransactionFilter::new_from_proto()` which converts the protobuf filter [2](#0-1) 

4. The conversion calls `Into::<UserTransactionFilter>::into()` which uses the `From` trait implementation [3](#0-2) 

5. This `From` implementation pre-initializes `standardized_sender` by calling `standardize_address()` [4](#0-3) 

6. The `standardize_address()` function attempts to pad the address using `&ZEROS[..64 - trimmed.len()]` [5](#0-4) 

7. If `trimmed.len() > 64`, the subtraction `64 - trimmed.len()` causes integer underflow (panic in debug) or wraps to a large value (panic on slice bounds in release), crashing the request handler

**Additional Issue - Silent Corruption:**

If the address contains invalid hexadecimal characters (e.g., "0xZZZZZZ"), `standardize_address()` does not validate character validity and silently pads them, creating a filter with corrupted state [6](#0-5) 

The `validate_state()` function only checks that at least one field is set, but does not validate address format [7](#0-6) 

## Impact Explanation

This vulnerability meets **High Severity** criteria per the Aptos bug bounty program: "API crashes" (up to $50,000). 

The indexer-grpc service is a critical infrastructure component that provides transaction streaming to ecosystem applications, wallets, and analytics platforms. While it does not affect blockchain consensus or validator operations, its unavailability impacts:

- **Ecosystem availability**: Applications relying on real-time transaction data experience service disruption
- **User experience**: Wallets and dApps cannot display transaction history or monitor on-chain activity  
- **Operational impact**: Repeated attacks can exhaust resources and degrade service quality

The proper validation mechanism exists in the codebase (`AccountAddressWithChecks::from_str`), which explicitly checks for oversized addresses and returns errors gracefully [8](#0-7) 

## Likelihood Explanation

**Likelihood: High**

- **Attacker requirements**: None beyond network access to the indexer-grpc endpoint
- **Technical complexity**: Trivial - requires only crafting a protobuf message with an oversized string
- **Detection difficulty**: The panic would be logged, but determining the malicious vs accidental nature is difficult
- **Exploitation cost**: Free - no transaction fees or stake required
- **Service exposure**: Indexer-grpc endpoints are publicly accessible by design for ecosystem integration

## Recommendation

Add address validation before calling `standardize_address()` in the `From<proto>` implementation. The validation should verify:
1. Length constraints (â‰¤64 hex characters after removing "0x" prefix)
2. Valid hexadecimal character set
3. Return `Result` instead of panicking on invalid input

**Recommended fix for `user_transaction.rs`:**

Change the `From` implementation to `TryFrom` to properly handle validation errors, and add address validation:

```rust
impl TryFrom<aptos_protos::indexer::v1::UserTransactionFilter> for UserTransactionFilter {
    type Error = anyhow::Error;
    
    fn try_from(proto_filter: aptos_protos::indexer::v1::UserTransactionFilter) -> Result<Self> {
        let standardized_sender = if let Some(ref address) = proto_filter.sender {
            // Validate address before standardizing
            let trimmed = address.strip_prefix("0x").unwrap_or(address);
            if trimmed.len() > 64 {
                bail!("Address too long: {} hex characters (max 64)", trimmed.len());
            }
            if !trimmed.chars().all(|c| c.is_ascii_hexdigit()) {
                bail!("Address contains invalid non-hex characters");
            }
            Some(standardize_address(address))
        } else {
            None
        };
        
        Ok(Self {
            standardized_sender: OnceCell::with_value(standardized_sender),
            sender: proto_filter.sender,
            payload: proto_filter.payload_filter.map(|f| f.into()),
        })
    }
}
```

Similar fixes should be applied to `EntryFunctionFilter` which has the same pattern [9](#0-8) 

## Proof of Concept

```rust
#[cfg(test)]
mod exploit_test {
    use super::*;
    use aptos_protos::indexer::v1::UserTransactionFilter as ProtoFilter;

    #[test]
    #[should_panic(expected = "attempt to subtract with overflow")]
    fn test_panic_on_oversized_address() {
        // Create a proto filter with an address > 64 hex chars
        let oversized_address = format!("0x{}", "a".repeat(65));
        
        let proto_filter = ProtoFilter {
            sender: Some(oversized_address),
            payload_filter: None,
        };
        
        // This conversion will panic due to integer underflow in standardize_address
        let _filter: UserTransactionFilter = proto_filter.into();
    }
    
    #[test]
    fn test_silent_corruption_invalid_hex() {
        let proto_filter = ProtoFilter {
            sender: Some("0xZZZZZZ".to_string()),
            payload_filter: None,
        };
        
        // This succeeds but creates corrupted filter
        let filter: UserTransactionFilter = proto_filter.into();
        
        // The standardized sender will contain "ZZZZZZ" padded with zeros
        // which is not a valid address but doesn't cause a panic
        let standardized = filter.get_standardized_sender();
        assert!(standardized.is_some());
        println!("Corrupted address: {}", standardized.as_ref().unwrap());
    }
}
```

**Notes**

This vulnerability is specific to the indexer-grpc component and does not affect blockchain consensus, validator operations, or on-chain state. However, it represents a significant availability risk for the Aptos ecosystem infrastructure. The issue demonstrates a lack of input validation at API boundaries, where untrusted external input is processed without proper sanitization. While the indexer is not part of the critical consensus path, its widespread use across wallets, explorers, and analytics platforms means that service disruption has broad ecosystem impact.

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/filter_utils.rs (L9-14)
```rust
pub fn parse_transaction_filter(
    proto_filter: aptos_protos::indexer::v1::BooleanTransactionFilter,
    max_filter_size_bytes: usize,
) -> Result<BooleanTransactionFilter, Status> {
    BooleanTransactionFilter::new_from_proto(proto_filter, Some(max_filter_size_bytes))
        .map_err(|e| Status::invalid_argument(format!("Invalid transaction_filter: {e:?}.")))
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/boolean_transaction_filter.rs (L113-115)
```rust
                aptos_protos::indexer::v1::boolean_transaction_filter::Filter::ApiFilter(
                    api_filter,
                ) => TryInto::<APIFilter>::try_into(api_filter)?.into(),
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/boolean_transaction_filter.rs (L392-394)
```rust
                aptos_protos::indexer::v1::api_filter::Filter::UserTransactionFilter(
                    user_transaction_filter,
                ) => Into::<UserTransactionFilter>::into(user_transaction_filter).into(),
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/filters/user_transaction.rs (L51-56)
```rust
            standardized_sender: OnceCell::with_value(
                proto_filter
                    .sender
                    .as_ref()
                    .map(|address| standardize_address(address)),
            ),
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/filters/user_transaction.rs (L74-80)
```rust
    fn validate_state(&self) -> Result<(), FilterError> {
        if self.sender.is_none() && self.payload.is_none() {
            return Err(Error::msg("At least one of sender or payload must be set").into());
        };
        self.payload.is_valid()?;
        Ok(())
    }
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/filters/user_transaction.rs (L155-169)
```rust
impl From<aptos_protos::indexer::v1::EntryFunctionFilter> for EntryFunctionFilter {
    fn from(proto_filter: aptos_protos::indexer::v1::EntryFunctionFilter) -> Self {
        Self {
            standardized_address: OnceCell::with_value(
                proto_filter
                    .address
                    .as_ref()
                    .map(|address| standardize_address(address)),
            ),
            address: proto_filter.address,
            module: proto_filter.module_name,
            function: proto_filter.function,
        }
    }
}
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/utils.rs (L10-35)
```rust
pub fn standardize_address(address: &str) -> String {
    // Remove "0x" prefix if it exists
    let trimmed = address.strip_prefix("0x").unwrap_or(address);

    // Check if the address is a special address by seeing if the first 31 bytes are zero and the last byte is smaller than 0b10000
    if let Some(last_char) = trimmed.chars().last() {
        if trimmed[..trimmed.len().saturating_sub(1)]
            .chars()
            .all(|c| c == '0')
            && last_char.is_ascii_hexdigit()
            && last_char <= 'f'
        {
            // Return special addresses in short format
            let mut result = String::with_capacity(3);
            result.push_str("0x");
            result.push(last_char);
            return result;
        }
    }

    // Return non-special addresses in long format
    let mut result = String::with_capacity(66);
    result.push_str("0x");
    result.push_str(&ZEROS[..64 - trimmed.len()]);
    result.push_str(trimmed);
    result
```

**File:** types/src/account_address.rs (L54-60)
```rust
        if working.len() > NUM_CHARS {
            bail!(
                "AccountAddress {} is too long {} must be {} hex characters with or without a 0x in front",
                str,
                working.len(),
               NUM_CHARS
            )
```
