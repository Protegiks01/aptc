# Audit Report

## Title
Unauthenticated Remote Access to Tokio Console Debugging Interface Exposes Validator Runtime Information

## Summary
When the `tokio-console` feature is enabled and configured with a port, the debugging console binds to `0.0.0.0` (all network interfaces) without any authentication, allowing remote attackers to monitor real-time validator task execution, resource usage, and performance bottlenecks that can be leveraged for targeted denial-of-service attacks. [1](#0-0) 

## Finding Description

The `set_global_logger()` function in the logger initialization code creates a tokio-console `ConsoleLayer` that binds to all network interfaces (`0.0.0.0`) rather than localhost only (`127.0.0.1`). [2](#0-1) 

The tokio console port is configured through `LoggerConfig`, which includes a comment indicating it's "for local debugging" but the implementation doesn't enforce localhost-only binding: [3](#0-2) 

The tokio-console library (via `console-subscriber`) provides **no authentication mechanism**. Any client that can reach the port can connect and observe:

1. **All active Tokio tasks** - names, locations in code, execution state
2. **Task performance metrics** - poll counts, CPU time, idle/busy ratios
3. **Resource usage** - channels, locks, semaphores, and their contention
4. **Timing information** - task spawn times, wake patterns, scheduling delays
5. **Async operation details** - pending futures, blocking operations

This information enables an attacker to:
- **Identify performance bottlenecks** in consensus, execution, or network layers
- **Map validator internals** by observing task names and execution patterns  
- **Time attacks** based on observed task behavior and resource contention
- **Plan targeted DoS** by attacking the weakest/slowest components
- **Monitor validator state transitions** during epoch changes or high load

The attack path:
1. Attacker discovers a validator node compiled with `tokio-console` feature enabled
2. Validator operator enables `tokio_console_port` for debugging (e.g., port 6669)
3. Attacker connects to `validator-ip:6669` using tokio-console client
4. Attacker observes real-time validator runtime behavior without authentication
5. Attacker identifies consensus bottlenecks, slow database operations, or resource contention points
6. Attacker launches targeted attacks against identified weak points

## Impact Explanation

This vulnerability falls under **High Severity** per Aptos bug bounty criteria:
- **"Validator node slowdowns"** - The exposed information directly enables attackers to identify and exploit performance bottlenecks, leading to deliberate validator degradation
- **"Significant protocol violations"** - Exposing internal validator operations without access control violates security-by-obscurity principles protecting validator infrastructure

The impact is classified as HIGH rather than LOW ("minor information leaks") because:
1. The exposed information is **actionable intelligence** for attacks, not just metadata
2. It enables **targeted attacks** on critical validator operations (consensus, execution, state sync)
3. It operates **continuously in real-time**, allowing attackers to observe validator behavior under various conditions
4. It exposes **architectural details** that should remain confidential

While not directly causing consensus violations or fund theft, it creates a significant attack surface that can lead to validator availability issues and network instability.

## Likelihood Explanation

**Likelihood: Medium**

Exploitation requires:
- ✅ **Feature compilation**: The `tokio-console` feature must be enabled during build [4](#0-3) 
- ✅ **Configuration**: The `tokio_console_port` must be explicitly set (defaults to `None`) [5](#0-4) 
- ✅ **Network access**: Attacker must reach the validator's network

However:
- Operators may enable this for debugging and forget to disable it
- The comment "for local debugging" creates a false sense of security
- There's no warning that it binds to all interfaces
- No authentication creates zero barrier to exploitation once enabled
- Port scanning can discover exposed instances

## Recommendation

**Fix: Bind to localhost by default, require explicit configuration for network access**

Change the bind address from `0.0.0.0` to `127.0.0.1`:

```rust
let console_layer = console_subscriber::ConsoleLayer::builder()
    .server_addr(([127, 0, 0, 1], tokio_console_port))  // localhost only
    .spawn();
```

**Alternative: Make bind address configurable**

Extend `LoggerConfig` to include `tokio_console_addr` and bind address configuration, defaulting to localhost:

```rust
pub struct LoggerConfig {
    // ... existing fields ...
    pub tokio_console_port: Option<u16>,
    pub tokio_console_addr: Option<String>,  // Add this, default to "127.0.0.1"
}
```

**Additional hardening:**
1. Add runtime warning when tokio-console binds to non-localhost addresses
2. Document security implications in configuration examples
3. Consider network-level authentication via SSH tunneling in documentation

## Proof of Concept

**Step 1: Build validator with tokio-console enabled**
```bash
cargo build --release --features tokio-console
```

**Step 2: Configure validator with tokio console port**
```yaml
# validator.yaml
logger:
  tokio_console_port: 6669
```

**Step 3: Start validator**
```bash
./target/release/aptos-node -f validator.yaml
```

**Step 4: From remote attacker machine**
```bash
# Install tokio-console client
cargo install tokio-console

# Connect to exposed validator (no authentication required)
tokio-console http://validator-ip:6669
```

**Expected Result:**
Attacker sees real-time dashboard showing:
- All validator tasks (consensus, execution, network, storage)
- Task timing and performance metrics
- Resource contention and blocking operations
- Internal architecture details via task names

This information can then be used to identify performance bottlenecks and plan targeted attacks.

## Notes

- The vulnerability is in production code, not test files
- Default configuration is secure (port is `None`), but when enabled, it's insecure
- The feature is intended for debugging but lacks security controls for production use
- tokio-console has no built-in authentication mechanism
- The simple fix (binding to localhost) maintains debugging utility while preventing remote access

### Citations

**File:** crates/aptos-logger/src/logger.rs (L54-63)
```rust
    #[cfg(feature = "tokio-console")]
    {
        if let Some(tokio_console_port) = tokio_console_port {
            let console_layer = console_subscriber::ConsoleLayer::builder()
                .server_addr(([0, 0, 0, 0], tokio_console_port))
                .spawn();

            tracing_subscriber::registry().with(console_layer).init();
            return;
        }
```

**File:** config/src/config/logger_config.rs (L36-37)
```rust
    /// Tokio console port for local debugging
    pub tokio_console_port: Option<u16>,
```

**File:** config/src/config/logger_config.rs (L54-54)
```rust
            tokio_console_port: None,
```

**File:** aptos-node/Cargo.toml (L97-97)
```text
tokio-console = ["aptos-logger/tokio-console", "aptos-config/tokio-console"]
```
