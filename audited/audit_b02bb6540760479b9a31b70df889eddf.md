# Audit Report

## Title
Sync Duration Request Replacement Vulnerability Allows Denial of Service in State Sync Driver

## Summary
The state sync driver accepts new sync duration notifications without validating whether an active sync request is already in progress. Each new notification replaces the previous request and resets the start time, preventing the sync from ever completing. This allows consensus or consensus observer to cause a denial of service by repeatedly sending sync duration notifications.

## Finding Description
The vulnerability exists in the handling of consensus sync duration notifications in the state sync driver. When a sync duration notification is received, the driver calls `handle_consensus_sync_duration_notification()` [1](#0-0) , which then invokes `initialize_sync_duration_request()` [2](#0-1) .

The critical flaw is that `initialize_sync_duration_request()` unconditionally creates a new `ConsensusSyncRequest` and replaces the existing `consensus_sync_request` by creating a new Arc, without checking if an active sync request already exists. This replacement resets the `start_time` to the current time.

The sync request satisfaction check compares elapsed time against the requested duration [3](#0-2) . When the start_time is repeatedly reset, the elapsed time never reaches the required duration, preventing the sync from completing.

During an active sync request, consensus or consensus observer is blocked from normal operations [4](#0-3) . If the sync request never completes, the node cannot resume normal consensus operations.

**Attack Path:**
1. Consensus observer enters fallback mode and calls `sync_for_fallback()` [5](#0-4) 
2. This spawns a task that sends a sync duration notification to the state sync driver
3. If `sync_for_fallback()` is called again (either through a bug or malicious code), it spawns another task
4. Multiple tasks send sync duration notifications through the unbounded channel [6](#0-5) 
5. Each notification resets the active sync request's start_time
6. The sync request never completes, blocking consensus operations indefinitely

## Impact Explanation
This vulnerability constitutes a **Medium severity** denial of service issue per the Aptos bug bounty program. It can cause validator node slowdowns and availability problems by:

- Preventing state sync from ever completing its synchronization
- Blocking consensus or consensus observer from resuming normal operations indefinitely
- Causing the node to be stuck in a non-functional state requiring manual intervention

While this doesn't cause consensus safety violations or fund loss, it significantly impacts validator availability and network participation.

## Likelihood Explanation
The likelihood is **Medium** because:

1. The vulnerability requires either:
   - A bug in consensus observer logic that calls `sync_for_fallback()` multiple times without proper checks
   - A malicious or compromised consensus observer process

2. The consensus observer does track active fallback sync via `fallback_sync_handle` [7](#0-6) , but external callers must explicitly check `in_fallback_mode()` before calling `sync_for_fallback()` - this is not enforced by the API

3. The unbounded channel design allows queuing multiple notifications without backpressure

4. There are no rate limiting or validation mechanisms in the driver to detect and reject overlapping sync requests

## Recommendation
Add validation in `initialize_sync_duration_request()` to reject new sync requests when one is already active:

```rust
pub async fn initialize_sync_duration_request(
    &mut self,
    sync_duration_notification: ConsensusSyncDurationNotification,
) -> Result<(), Error> {
    // Check if there's already an active sync request
    if self.consensus_sync_request.lock().is_some() {
        let error = Err(Error::UnexpectedErrorEncountered(
            "Received sync duration notification while sync request is already active".into()
        ));
        self.respond_to_sync_duration_notification(
            sync_duration_notification,
            error.clone(),
            None,
        )?;
        return error;
    }

    // Get the current time
    let start_time = self.time_service.now();

    // Save the request so we can notify consensus once we've hit the duration
    let consensus_sync_request =
        ConsensusSyncRequest::new_with_duration(start_time, sync_duration_notification);
    self.consensus_sync_request = Arc::new(Mutex::new(Some(consensus_sync_request)));

    Ok(())
}
```

Additionally, add similar protection in `initialize_sync_target_request()` to prevent the same issue with sync target notifications.

## Proof of Concept
```rust
// Reproduction scenario in consensus observer context
// This demonstrates how multiple sync_for_fallback() calls can flood the driver

#[tokio::test]
async fn test_sync_duration_flooding() {
    // Create state sync driver with consensus notification handler
    let (consensus_notifier, consensus_listener) = 
        consensus_notifications::new_consensus_notifier_listener_pair(5000);
    
    // Simulate consensus observer sending multiple sync duration requests
    let notifier1 = consensus_notifier.clone();
    let handle1 = tokio::spawn(async move {
        notifier1.sync_for_duration(Duration::from_secs(10)).await
    });
    
    // Send another request immediately without waiting
    let notifier2 = consensus_notifier.clone();
    let handle2 = tokio::spawn(async move {
        notifier2.sync_for_duration(Duration::from_secs(10)).await
    });
    
    // The second request will reset the first request's start_time
    // Neither request will complete within their expected duration
    // Both tasks will block indefinitely waiting for state sync
    
    // Expected: Second request should be rejected with error
    // Actual: Second request replaces first, both hang
}
```

## Notes
The vulnerability affects both sync duration and sync target notifications, as both use the same replacement logic. The primary attack vector is through consensus observer's fallback sync mechanism, though similar issues could theoretically occur with consensus's sync operations if the write_mutex protection were bypassed or failed.

### Citations

**File:** state-sync/state-sync-driver/src/driver.rs (L384-405)
```rust
    async fn handle_consensus_sync_duration_notification(
        &mut self,
        sync_duration_notification: ConsensusSyncDurationNotification,
    ) -> Result<(), Error> {
        // Update the sync duration notification metrics
        let latest_synced_version = utils::fetch_pre_committed_version(self.storage.clone())?;
        info!(
            LogSchema::new(LogEntry::ConsensusNotification).message(&format!(
                "Received a consensus sync duration notification! Duration: {:?}. Latest synced version: {:?}",
                sync_duration_notification.get_duration(), latest_synced_version,
            ))
        );
        metrics::increment_counter(
            &metrics::DRIVER_COUNTERS,
            metrics::DRIVER_CONSENSUS_SYNC_DURATION_NOTIFICATION,
        );

        // Initialize a new sync request
        self.consensus_notification_handler
            .initialize_sync_duration_request(sync_duration_notification)
            .await
    }
```

**File:** state-sync/state-sync-driver/src/driver.rs (L626-630)
```rust
    fn check_if_consensus_or_observer_executing(&self) -> bool {
        self.is_consensus_or_observer_enabled()
            && self.bootstrapper.is_bootstrapped()
            && !self.active_sync_request()
    }
```

**File:** state-sync/state-sync-driver/src/notification_handlers.rs (L184-209)
```rust
    pub fn sync_request_satisfied(
        &self,
        latest_synced_ledger_info: &LedgerInfoWithSignatures,
        time_service: TimeService,
    ) -> bool {
        match self {
            ConsensusSyncRequest::SyncDuration(start_time, sync_duration_notification) => {
                // Get the duration and the current time
                let sync_duration = sync_duration_notification.get_duration();
                let current_time = time_service.now();

                // Check if the duration has been reached
                current_time.duration_since(*start_time) >= sync_duration
            },
            ConsensusSyncRequest::SyncTarget(sync_target_notification) => {
                // Get the sync target version and latest synced version
                let sync_target = sync_target_notification.get_target();
                let sync_target_version = sync_target.ledger_info().version();
                let latest_synced_version = latest_synced_ledger_info.ledger_info().version();

                // Check if we've satisfied the target
                latest_synced_version >= sync_target_version
            },
        }
    }
}
```

**File:** state-sync/state-sync-driver/src/notification_handlers.rs (L245-259)
```rust
    /// Initializes the sync duration request received from consensus
    pub async fn initialize_sync_duration_request(
        &mut self,
        sync_duration_notification: ConsensusSyncDurationNotification,
    ) -> Result<(), Error> {
        // Get the current time
        let start_time = self.time_service.now();

        // Save the request so we can notify consensus once we've hit the duration
        let consensus_sync_request =
            ConsensusSyncRequest::new_with_duration(start_time, sync_duration_notification);
        self.consensus_sync_request = Arc::new(Mutex::new(Some(consensus_sync_request)));

        Ok(())
    }
```

**File:** consensus/src/consensus_observer/observer/state_sync_manager.rs (L54-61)
```rust
    // we've fallen back to state sync, and we should wait for it to complete.
    fallback_sync_handle: Option<DropGuard>,

    // The active sync to commit handle. If this is set, it means that
    // we're waiting for state sync to synchronize to a known commit decision.
    // The flag indicates if the commit will transition us to a new epoch.
    sync_to_commit_handle: Option<(DropGuard, bool)>,
}
```

**File:** consensus/src/consensus_observer/observer/state_sync_manager.rs (L117-187)
```rust
    pub fn sync_for_fallback(&mut self) {
        // Log that we're starting to sync in fallback mode
        info!(
            LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                "Started syncing in fallback mode! Syncing duration: {:?} ms!",
                self.consensus_observer_config.observer_fallback_duration_ms
            ))
        );

        // Update the state sync fallback counter
        metrics::increment_counter_without_labels(&metrics::OBSERVER_STATE_SYNC_FALLBACK_COUNTER);

        // Clone the required components for the state sync task
        let consensus_observer_config = self.consensus_observer_config;
        let execution_client = self.execution_client.clone();
        let sync_notification_sender = self.state_sync_notification_sender.clone();

        // Spawn a task to sync for the fallback
        let (abort_handle, abort_registration) = AbortHandle::new_pair();
        tokio::spawn(Abortable::new(
            async move {
                // Update the state sync metrics now that we're syncing for the fallback
                metrics::set_gauge_with_label(
                    &metrics::OBSERVER_STATE_SYNC_EXECUTING,
                    metrics::STATE_SYNCING_FOR_FALLBACK,
                    1, // We're syncing for the fallback
                );

                // Get the fallback duration
                let fallback_duration =
                    Duration::from_millis(consensus_observer_config.observer_fallback_duration_ms);

                // Sync for the fallback duration
                let latest_synced_ledger_info = match execution_client
                    .clone()
                    .sync_for_duration(fallback_duration)
                    .await
                {
                    Ok(latest_synced_ledger_info) => latest_synced_ledger_info,
                    Err(error) => {
                        error!(LogSchema::new(LogEntry::ConsensusObserver)
                            .message(&format!("Failed to sync for fallback! Error: {:?}", error)));
                        return;
                    },
                };

                // Notify consensus observer that we've synced for the fallback
                let state_sync_notification =
                    StateSyncNotification::fallback_sync_completed(latest_synced_ledger_info);
                if let Err(error) = sync_notification_sender.send(state_sync_notification) {
                    error!(
                        LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                            "Failed to send state sync notification for fallback! Error: {:?}",
                            error
                        ))
                    );
                }

                // Clear the state sync metrics now that we're done syncing
                metrics::set_gauge_with_label(
                    &metrics::OBSERVER_STATE_SYNC_EXECUTING,
                    metrics::STATE_SYNCING_FOR_FALLBACK,
                    0, // We're no longer syncing for the fallback
                );
            },
            abort_registration,
        ));

        // Save the sync task handle
        self.fallback_sync_handle = Some(DropGuard::new(abort_handle));
    }
```

**File:** state-sync/inter-component/consensus-notifications/src/lib.rs (L59-68)
```rust
pub fn new_consensus_notifier_listener_pair(
    timeout_ms: u64,
) -> (ConsensusNotifier, ConsensusNotificationListener) {
    let (notification_sender, notification_receiver) = mpsc::unbounded();

    let consensus_notifier = ConsensusNotifier::new(notification_sender, timeout_ms);
    let consensus_listener = ConsensusNotificationListener::new(notification_receiver);

    (consensus_notifier, consensus_listener)
}
```
