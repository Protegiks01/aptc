# Audit Report

## Title
Resource Exhaustion via Unmetered Storage Reads in Federated Keyless Signature Validation

## Summary
An attacker can cause validator node slowdown or Denial of Service by submitting transactions with federated keyless authenticators that reference non-existent or unique `jwk_addr` values. Each transaction triggers up to 3 expensive uncached database reads during mempool validation, before any gas is charged, allowing an attacker to flood the storage layer with read requests.

## Finding Description

The vulnerability exists in the keyless signature validation flow where federated keyless authenticators trigger expensive storage reads during transaction validation in the mempool, prior to gas metering.

**Attack Flow:**

When transactions are submitted to mempool, they are validated in parallel using a pool of VM validators. [1](#0-0) 

During validation, the `validate_signed_transaction` function extracts keyless authenticators and calls `keyless_validation::validate_authenticators` without passing the gas meter parameter that exists in the function signature. [2](#0-1) 

For each federated keyless authenticator in the transaction, if the JWK is not found in the main registry at `0x1`, the validation attempts to fetch JWKs from the custom `jwk_addr` specified in the authenticator. [3](#0-2) 

The `get_federated_jwks_onchain` function calls `get_resource_on_chain_at_addr`, which performs an expensive `get_resource_bytes_with_metadata_and_layout` database read. [4](#0-3) [5](#0-4) 

**Attacker Control:**

The attacker fully controls the `jwk_addr` field in the `FederatedKeylessPublicKey` structure, which specifies where JWKs should be looked up. [6](#0-5) 

**Attack Parameters:**

The maximum number of keyless signatures per transaction is controlled by `max_signatures_per_txn`, which defaults to 3. [7](#0-6)  This limit is enforced during validation. [8](#0-7) 

**Cache Ineffectiveness:**

Each VMValidator in the pool maintains its own `CachedDbStateView`, meaning caches are not shared across validators. [9](#0-8)  The attacker can bypass caching by using unique addresses for each transaction.

**Critical Ordering:**

Validation occurs before transactions are added to mempool, meaning mempool capacity limits cannot prevent the expensive validation operations. [10](#0-9) 

## Impact Explanation

This vulnerability qualifies as **High Severity** per the Aptos bug bounty program criteria for "Validator Node Slowdowns":

- **Validator node slowdowns**: The primary impact is degraded validator performance as the storage layer is flooded with read requests for non-existent or unique resources
- **Consensus participation affected**: If sustained, validators may be unable to process legitimate transactions in a timely manner, affecting their ability to participate in consensus

The attack does not require privileged accessâ€”only the ability to submit transactions via public API. The impact is amplified because:
1. Storage reads from RocksDB are expensive I/O operations
2. Parallel validation means multiple expensive reads occur simultaneously
3. No gas is charged for failed validations, making the attack essentially free
4. Mempool capacity limits don't prevent the storage exhaustion since validation happens first
5. Per-validator caching makes unique addresses effective at bypassing cache

## Likelihood Explanation

**Likelihood: High**

The attack is highly likely to be exploited because:

1. **Low barrier to entry**: Attacker only needs to submit transactions via public API
2. **No resource cost**: Failed validations don't charge gas, making the attack economically free
3. **Simple to execute**: Creating transactions with custom `jwk_addr` values is straightforward
4. **Amplification factor**: Each transaction triggers up to 3 storage reads, and parallel validation multiplies the effect
5. **Difficult to distinguish**: Failed validations from invalid keyless authenticators appear similar to legitimate user errors

## Recommendation

1. **Add gas metering during validation**: Pass the gas meter to `keyless_validation::validate_authenticators` and charge gas for storage reads during validation, even if validation ultimately fails.

2. **Implement rate limiting**: Add rate limiting specifically for federated keyless validation failures to prevent rapid submission of malicious transactions.

3. **Shared caching**: Consider implementing a shared cache across VM validator instances for frequently accessed resources.

4. **Early validation**: Add a lightweight pre-validation check to verify that `jwk_addr` contains a valid `FederatedJWKs` resource before performing full validation.

## Proof of Concept

While a full PoC would require setting up transaction submission infrastructure, the vulnerability can be demonstrated by examining the code flow:

1. Create a `FederatedKeylessPublicKey` with an arbitrary `jwk_addr` (e.g., `0x1234`)
2. Create a transaction with 3 federated keyless authenticators, each with unique `jwk_addr` values
3. Submit the transaction to mempool via API
4. The transaction will fail validation, but not before triggering 3 database reads
5. Repeat with thousands of transactions using different addresses
6. Monitor validator storage layer performance degradation

The code evidence clearly shows this path is exploitable without any authentication or gas cost.

## Notes

This vulnerability represents a protocol-level resource exhaustion attack, not a network-level DoS attack. It exploits a design flaw where expensive operations (database reads) are performed without gas metering during the validation phase. The distinction is critical: this is an in-scope "Validator Node Slowdowns" issue, not an out-of-scope "Network DoS" attack.

The vulnerability is particularly severe because it bypasses all economic protections (gas fees) and capacity limits (mempool size), directly targeting the storage layer which is typically the bottleneck in blockchain nodes.

### Citations

**File:** mempool/src/shared_mempool/tasks.rs (L490-522)
```rust
    let validation_results = VALIDATION_POOL.install(|| {
        transactions
            .par_iter()
            .map(|t| {
                let result = smp.validator.read().validate_transaction(t.0.clone());
                // Pre-compute the hash and length if the transaction is valid, before locking mempool
                if result.is_ok() {
                    t.0.committed_hash();
                    t.0.txn_bytes_len();
                }
                result
            })
            .collect::<Vec<_>>()
    });
    vm_validation_timer.stop_and_record();
    {
        let mut mempool = smp.mempool.lock();
        for (idx, (transaction, account_sequence_number, ready_time_at_sender, priority)) in
            transactions.into_iter().enumerate()
        {
            if let Ok(validation_result) = &validation_results[idx] {
                match validation_result.status() {
                    None => {
                        let ranking_score = validation_result.score();
                        let mempool_status = mempool.add_txn(
                            transaction.clone(),
                            ranking_score,
                            account_sequence_number,
                            timeline_state,
                            client_submitted,
                            ready_time_at_sender,
                            priority.clone(),
                        );
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1802-1810)
```rust
        if !keyless_authenticators.is_empty() && !self.is_simulation {
            keyless_validation::validate_authenticators(
                self.environment().keyless_pvk(),
                self.environment().keyless_configuration(),
                &keyless_authenticators,
                self.features(),
                session.resolver,
                module_storage,
            )?;
```

**File:** aptos-move/aptos-vm/src/keyless_validation.rs (L60-61)
```rust
    let bytes = resolver
        .get_resource_bytes_with_metadata_and_layout(addr, &struct_tag, &module.metadata, None)
```

**File:** aptos-move/aptos-vm/src/keyless_validation.rs (L96-102)
```rust
fn get_federated_jwks_onchain(
    resolver: &impl AptosMoveResolver,
    jwk_addr: &AccountAddress,
    module_storage: &impl ModuleStorage,
) -> anyhow::Result<FederatedJWKs, VMStatus> {
    get_resource_on_chain_at_addr::<FederatedJWKs>(jwk_addr, resolver, module_storage)
}
```

**File:** aptos-move/aptos-vm/src/keyless_validation.rs (L202-205)
```rust
    if authenticators.len() > config.max_signatures_per_txn as usize {
        // println!("[aptos-vm][groth16] Too many keyless authenticators");
        return Err(invalid_signature!("Too many keyless authenticators"));
    }
```

**File:** aptos-move/aptos-vm/src/keyless_validation.rs (L244-252)
```rust
                    AnyKeylessPublicKey::Federated(fed_pk) => {
                        let federated_jwks =
                            get_federated_jwks_onchain(resolver, &fed_pk.jwk_addr, module_storage)
                                .map_err(|_| {
                                    invalid_signature!(format!(
                                        "Could not fetch federated PatchedJWKs at {}",
                                        fed_pk.jwk_addr
                                    ))
                                })?;
```

**File:** types/src/keyless/mod.rs (L376-378)
```rust
pub struct FederatedKeylessPublicKey {
    pub jwk_addr: AccountAddress,
    pub pk: KeylessPublicKey,
```

**File:** types/src/keyless/configuration.rs (L65-65)
```rust
            max_signatures_per_txn: 3,
```

**File:** vm-validator/src/vm_validator.rs (L42-45)
```rust
struct VMValidator {
    db_reader: Arc<dyn DbReader>,
    state: CachedModuleView<CachedDbStateView>,
}
```
