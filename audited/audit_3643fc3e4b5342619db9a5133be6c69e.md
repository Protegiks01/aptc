# Audit Report

## Title
Sharded Block Executor: Unvalidated Remote Execution Results Enable Consensus Safety Violation and State Poisoning

## Summary
The `RemoteExecutorClient` accepts execution results from remote executor shards over the network without validating their structure, authenticity, or consistency. A malicious or compromised remote executor can return crafted `ShardedExecutionOutput` with arbitrary transaction outputs, mismatched shard counts, or incorrect round numbers, leading to validator crashes (DoS), transaction dropping, state poisoning, and ultimately consensus safety violations where different validators commit different state roots for the same block.

## Finding Description

The sharded block executor architecture allows execution to be distributed across remote executor shards. When remote executors are configured, the `RemoteExecutorClient` receives execution results from network peers and aggregates them without validation.

**Vulnerability Chain:**

1. **Untrusted Network Input**: [1](#0-0) 
   The `get_output_from_shards()` method receives bytes from remote executors via network channels, deserializes them using BCS into `RemoteExecutionResult`, and directly returns the inner `Vec<Vec<Vec<TransactionOutput>>>` without any validation of structure, authenticity, or consistency.

2. **Missing Structure Validation**: [2](#0-1) 
   Unlike the `LocalExecutorClient` which validates `transactions.num_shards() == self.num_shards()`, the `RemoteExecutorClient` performs NO validation that the received results match the expected number of shards or that each shard returns the correct number of rounds.

3. **Unsafe Aggregation Logic**: [3](#0-2) 
   The aggregation logic assumes all shards return valid, consistent results:
   - Uses `sharded_output[0].len()` to determine round count (assumes shard 0 exists)
   - Allocates `ordered_results` with size `num_executor_shards * num_rounds`
   - Computes index as `round * num_executor_shards + shard_id` with NO bounds checking
   - If any shard returns different round count, this causes index out of bounds panic or silent transaction dropping

4. **State Commitment Without Validation**: [4](#0-3) 
   The unchecked `TransactionOutput` objects flow directly to state commitment where `write_set_hash`, `event_root_hash`, and `gas_used` are extracted and used to construct `TransactionInfo` hashes that become part of the transaction accumulator. No validation occurs between network deserialization and cryptographic commitment.

**Attack Scenarios:**

1. **Validator Crash (DoS)**: Malicious executor returns more rounds than shard 0, causing index out of bounds panic at aggregation
2. **Transaction Dropping**: Malicious executor returns fewer rounds, leaving empty slots that silently drop transactions
3. **State Poisoning**: Malicious executor returns arbitrary `WriteSet` modifications, injecting unauthorized state changes
4. **Consensus Split**: Different validators using different remote executors receive different results, producing different state roots and breaking consensus safety

**Invariant Violations:**

- **Deterministic Execution (Invariant #1)**: Different validators produce different state roots for identical blocks
- **Consensus Safety (Invariant #2)**: Can cause chain splits under < 1/3 Byzantine assumption
- **State Consistency (Invariant #4)**: State transitions become non-verifiable and non-atomic

## Impact Explanation

This is **Critical Severity** under the Aptos bug bounty program criteria:

- **Consensus/Safety Violations**: A malicious remote executor can cause different validators to commit different states for the same block, directly violating the fundamental consensus safety guarantee that honest validators agree on a unique chain. This can lead to permanent chain splits requiring a hard fork to resolve.

- **Non-recoverable Network Partition**: If different validator subsets use different compromised remote executors, the network can partition into incompatible forks with different state roots, requiring coordinated manual intervention or hard fork.

- **State Manipulation**: Arbitrary `WriteSet` injection allows attackers to modify any on-chain state including account balances, resource ownership, governance settings, and validator set membership.

The vulnerability breaks the core security model of blockchain consensus where all honest nodes must reach agreement on a single canonical state.

## Likelihood Explanation

**Likelihood: Medium to High** depending on deployment configuration.

**Attacker Requirements:**
- Control or compromise of a remote executor service endpoint
- Target validator configured to use remote executors (checked via `get_remote_addresses()`)
- Network access to communicate with target validator

**Feasibility:**
- Remote executors are designed as separate network services for performance scaling [5](#0-4) 
- No cryptographic authentication of results is implemented
- The attack requires only network-level access, not validator key compromise
- Multiple attack vectors exist (DoS, transaction dropping, state poisoning)

**Deployment Impact:**
- If remote executors are used in production validator deployments, this is immediately exploitable
- If remote executors are only used in testing/development, impact is limited to those environments

## Recommendation

Implement comprehensive validation and authentication of remote executor results:

**1. Structure Validation** - Add validation in `RemoteExecutorClient::execute_block()`:
```rust
fn execute_block(...) -> Result<ShardedExecutionOutput, VMStatus> {
    // ... existing code ...
    let execution_results = self.get_output_from_shards()?;
    
    // ADDED: Validate structure
    if execution_results.len() != self.num_shards() {
        return Err(VMStatus::Error(StatusCode::UNKNOWN_VALIDATION_STATUS));
    }
    
    let expected_rounds = execution_results[0].len();
    for (shard_id, shard_results) in execution_results.iter().enumerate() {
        if shard_results.len() != expected_rounds {
            return Err(VMStatus::Error(StatusCode::UNKNOWN_VALIDATION_STATUS));
        }
    }
    
    Ok(ShardedExecutionOutput::new(execution_results, vec![]))
}
```

**2. Cryptographic Authentication** - Sign results with executor identity:
```rust
struct AuthenticatedExecutionResult {
    shard_id: ShardId,
    results: Vec<Vec<TransactionOutput>>,
    signature: Signature,  // Sign over (shard_id, results_hash, nonce)
}
```

**3. Consistency Verification** - Add cross-validation logic in aggregation:
```rust
// In mod.rs execute_block()
assert_eq!(sharded_output.len(), num_executor_shards, 
    "Received {} shards but expected {}", sharded_output.len(), num_executor_shards);

let num_rounds = sharded_output[0].len();
for (shard_id, results) in sharded_output.iter().enumerate() {
    assert_eq!(results.len(), num_rounds,
        "Shard {} returned {} rounds but expected {}", shard_id, results.len(), num_rounds);
}
```

**4. Bounds Checking** - Add defensive bounds check before indexing:
```rust
for (shard_id, results_from_shard) in sharded_output.into_iter().enumerate() {
    for (round, result) in results_from_shard.into_iter().enumerate() {
        let index = round * num_executor_shards + shard_id;
        assert!(index < ordered_results.len(), 
            "Index out of bounds: round={}, shard={}, index={}, len={}", 
            round, shard_id, index, ordered_results.len());
        ordered_results[index] = result;
    }
}
```

## Proof of Concept

```rust
// Proof of Concept: Index Out of Bounds Attack
// File: execution/executor-service/src/tests.rs (add to test suite)

#[test]
#[should_panic(expected = "index out of bounds")]
fn test_malicious_remote_executor_extra_rounds() {
    use aptos_vm::sharded_block_executor::{
        executor_client::ShardedExecutionOutput, ShardedBlockExecutor,
    };
    use aptos_types::transaction::TransactionOutput;
    
    // Simulate malicious executor: shard 1 returns more rounds than shard 0
    let malicious_output = ShardedExecutionOutput::new(
        vec![
            // Shard 0: 1 round (normal)
            vec![vec![TransactionOutput::new_empty_success()]],
            // Shard 1: 2 rounds (ATTACK: extra round)
            vec![
                vec![TransactionOutput::new_empty_success()],
                vec![TransactionOutput::new_empty_success()], // Extra round
            ],
        ],
        vec![], // no global output
    );
    
    let (sharded_output, global_output) = malicious_output.into_inner();
    let num_executor_shards = 2;
    let num_rounds = sharded_output[0].len(); // = 1
    
    let mut ordered_results = vec![vec![]; num_executor_shards * num_rounds]; // size = 2
    
    // This will panic when processing shard 1, round 1:
    // index = 1 * 2 + 1 = 3, but ordered_results.len() = 2
    for (shard_id, results_from_shard) in sharded_output.into_iter().enumerate() {
        for (round, result) in results_from_shard.into_iter().enumerate() {
            ordered_results[round * num_executor_shards + shard_id] = result;
        }
    }
}

// Proof of Concept: State Poisoning Attack
#[test]
fn test_malicious_remote_executor_arbitrary_writesets() {
    use aptos_types::{
        transaction::{TransactionOutput, TransactionStatus, ExecutionStatus},
        write_set::{WriteSet, WriteSetMut},
    };
    
    // Malicious executor injects arbitrary state changes
    let malicious_write_set = WriteSetMut::default()
        // Could inject arbitrary account balance changes, etc.
        .freeze().unwrap();
    
    let malicious_output = TransactionOutput::new(
        malicious_write_set,
        vec![], // events
        0, // gas_used
        TransactionStatus::Keep(ExecutionStatus::Success),
        Default::default(),
    );
    
    // This output would flow through to state commitment without validation
    // Different validators could receive different malicious outputs
    // leading to consensus split
    assert_eq!(malicious_output.status(), 
        &TransactionStatus::Keep(ExecutionStatus::Success));
}
```

## Notes

This vulnerability only affects deployments using remote executor shards. The `LocalExecutorClient` implementation uses trusted local channels and includes proper validation [6](#0-5) . However, production deployments may use remote executors for performance scaling, making this a critical production vulnerability.

The root cause is the trust model mismatch: remote executors are treated as trusted components but communicate over untrusted network channels without authentication or validation. The aggregation logic assumes well-formed inputs from trusted sources, which is violated when using network-based executors.

### Citations

**File:** execution/executor-service/src/remote_executor_client.rs (L163-172)
```rust
    fn get_output_from_shards(&self) -> Result<Vec<Vec<Vec<TransactionOutput>>>, VMStatus> {
        trace!("RemoteExecutorClient Waiting for results");
        let mut results = vec![];
        for rx in self.result_rxs.iter() {
            let received_bytes = rx.recv().unwrap().to_bytes();
            let result: RemoteExecutionResult = bcs::from_bytes(&received_bytes).unwrap();
            results.push(result.inner?);
        }
        Ok(results)
    }
```

**File:** execution/executor-service/src/remote_executor_client.rs (L180-212)
```rust
    fn execute_block(
        &self,
        state_view: Arc<S>,
        transactions: PartitionedTransactions,
        concurrency_level_per_shard: usize,
        onchain_config: BlockExecutorConfigFromOnchain,
    ) -> Result<ShardedExecutionOutput, VMStatus> {
        trace!("RemoteExecutorClient Sending block to shards");
        self.state_view_service.set_state_view(state_view);
        let (sub_blocks, global_txns) = transactions.into();
        if !global_txns.is_empty() {
            panic!("Global transactions are not supported yet");
        }
        for (shard_id, sub_blocks) in sub_blocks.into_iter().enumerate() {
            let senders = self.command_txs.clone();
            let execution_request = RemoteExecutionRequest::ExecuteBlock(ExecuteBlockCommand {
                sub_blocks,
                concurrency_level: concurrency_level_per_shard,
                onchain_config: onchain_config.clone(),
            });

            senders[shard_id]
                .lock()
                .unwrap()
                .send(Message::new(bcs::to_bytes(&execution_request).unwrap()))
                .unwrap();
        }

        let execution_results = self.get_output_from_shards()?;

        self.state_view_service.drop_state_view();
        Ok(ShardedExecutionOutput::new(execution_results, vec![]))
    }
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/mod.rs (L98-105)
```rust
        let num_rounds = sharded_output[0].len();
        let mut aggregated_results = vec![];
        let mut ordered_results = vec![vec![]; num_executor_shards * num_rounds];
        // Append the output from individual shards in the round order
        for (shard_id, results_from_shard) in sharded_output.into_iter().enumerate() {
            for (round, result) in results_from_shard.into_iter().enumerate() {
                ordered_results[round * num_executor_shards + shard_id] = result;
            }
```

**File:** execution/executor/src/workflow/do_ledger_update.rs (L47-93)
```rust
    fn assemble_transaction_infos(
        to_commit: &TransactionsWithOutput,
        state_checkpoint_hashes: Vec<Option<HashValue>>,
    ) -> (Vec<TransactionInfo>, Vec<HashValue>) {
        let _timer = OTHER_TIMERS.timer_with(&["assemble_transaction_infos"]);

        (0..to_commit.len())
            .into_par_iter()
            .with_min_len(optimal_min_len(to_commit.len(), 64))
            .map(|i| {
                let txn = &to_commit.transactions[i];
                let txn_output = &to_commit.transaction_outputs[i];
                let persisted_auxiliary_info = &to_commit.persisted_auxiliary_infos[i];
                // Use the auxiliary info hash directly from the persisted info
                let auxiliary_info_hash = match persisted_auxiliary_info {
                    PersistedAuxiliaryInfo::None => None,
                    PersistedAuxiliaryInfo::V1 { .. } => {
                        Some(CryptoHash::hash(persisted_auxiliary_info))
                    },
                    PersistedAuxiliaryInfo::TimestampNotYetAssignedV1 { .. } => None,
                };
                let state_checkpoint_hash = state_checkpoint_hashes[i];
                let event_hashes = txn_output
                    .events()
                    .iter()
                    .map(CryptoHash::hash)
                    .collect::<Vec<_>>();
                let event_root_hash =
                    InMemoryEventAccumulator::from_leaves(&event_hashes).root_hash();
                let write_set_hash = CryptoHash::hash(txn_output.write_set());
                let txn_info = TransactionInfo::new(
                    txn.hash(),
                    write_set_hash,
                    event_root_hash,
                    state_checkpoint_hash,
                    txn_output.gas_used(),
                    txn_output
                        .status()
                        .as_kept_status()
                        .expect("Already sorted."),
                    auxiliary_info_hash,
                );
                let txn_info_hash = txn_info.hash();
                (txn_info, txn_info_hash)
            })
            .unzip()
    }
```

**File:** execution/executor/src/workflow/do_get_execution_output.rs (L261-267)
```rust
        if !get_remote_addresses().is_empty() {
            Ok(V::execute_block_sharded(
                &REMOTE_SHARDED_BLOCK_EXECUTOR.lock(),
                partitioned_txns,
                state_view,
                onchain_config,
            )?)
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/local_executor_shard.rs (L190-190)
```rust
        assert_eq!(transactions.num_shards(), self.num_shards());
```
