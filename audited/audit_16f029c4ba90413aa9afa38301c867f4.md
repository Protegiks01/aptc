# Audit Report

## Title
Consensus Indefinite Wait Due to Silent State Sync Callback Failures

## Summary
The state sync driver fails to send callbacks to consensus when storage errors occur during sync request handling. Consensus waits indefinitely without timeout mechanisms for `sync_to_target` and `sync_for_duration` operations, potentially causing validator liveness failures.

## Finding Description

The vulnerability exists in the interaction between consensus and state sync components, involving three critical design flaws:

**1. No Timeout on Consensus Side**

The `sync_to_target()` method waits indefinitely on the callback receiver without any timeout: [1](#0-0) 

Similarly, `sync_for_duration()` also awaits without timeout: [2](#0-1) 

In contrast, `notify_new_commit` does implement a timeout mechanism: [3](#0-2) 

**2. Silent Error Handling in State Sync**

When `check_sync_request_progress()` encounters errors, they are only logged without propagating callbacks to consensus: [4](#0-3) 

Similarly, errors in `handle_consensus_sync_target_notification()` are caught and logged but no callback is sent: [5](#0-4) 

**3. Storage Operations Can Fail**

The `check_sync_request_progress()` method calls multiple storage operations that can fail: [6](#0-5) 

These utility functions wrap storage calls that return `Result` types and can fail with `StorageError`: [7](#0-6) 

The underlying storage interface methods can return errors: [8](#0-7) [9](#0-8) 

**Attack Path:**

1. Consensus calls `sync_to_target()` and awaits callback without timeout
2. State sync receives notification and either:
   - Encounters storage error in `handle_consensus_sync_target_notification()` before storing the callback (lines 414-416)
   - Successfully stores the notification but encounters persistent storage errors in `check_sync_request_progress()` (lines 542, 573, 575, 596)
3. Errors are logged but no callback is sent to consensus
4. The oneshot sender remains in the lock or is never stored
5. Consensus waits indefinitely as the callback receiver never receives a response

## Impact Explanation

This vulnerability can cause **validator liveness failures**. When a validator's consensus component waits indefinitely for state sync callbacks, it cannot:
- Process new sync requests
- Progress with block execution  
- Participate in consensus rounds

While the report claims "Critical Severity" for "total loss of liveness/network availability," the actual impact depends on how many validators are affected simultaneously. Individual validator failures due to node-specific storage errors would constitute **High Severity** validator availability issues. Network-wide impact would require coordinated storage failures across multiple validators, which is less likely but theoretically possible through:
- Resource exhaustion attacks targeting storage subsystems
- Correlated storage failures during high load conditions
- Common infrastructure dependencies failing

This represents a protocol-level design flaw (missing timeout) that violates liveness guarantees under fault conditions.

## Likelihood Explanation

**Likelihood: Medium to High**

Storage errors can occur through:

**Natural Causes:**
- Database corruption from disk failures
- I/O errors from storage subsystem issues
- Out-of-memory conditions during high load
- File system inconsistencies

**Induced Scenarios:**
- Resource exhaustion targeting storage operations
- High transaction throughput causing storage contention
- Race conditions during epoch transitions

The vulnerability requires no privileged access and affects standard validator operations. Storage operations are called frequently in sync progress checks, making the probability of encountering persistent storage errors non-negligible under adverse conditions.

## Recommendation

**Add timeout mechanisms to consensus sync operations:**

1. Implement timeouts for `sync_to_target()` and `sync_for_duration()` similar to `notify_new_commit()`:

```rust
// In sync_to_target
let timeout_duration = Duration::from_millis(self.sync_timeout_ms);
if let Ok(response) = timeout(timeout_duration, callback_receiver).await {
    match response {
        Ok(consensus_notification_response) => consensus_notification_response.get_result(),
        Err(error) => Err(Error::UnexpectedErrorEncountered(/*...*/))
    }
} else {
    Err(Error::TimeoutWaitingForStateSync)
}
```

2. Ensure state sync sends error callbacks when storage operations fail:

```rust
// In drive_progress when check_sync_request_progress fails
if let Err(error) = self.check_sync_request_progress().await {
    // Send error callback to consensus before logging
    if let Some(request) = self.consensus_notification_handler.consensus_sync_request.lock().take() {
        self.consensus_notification_handler.respond_with_error(request, error.clone())?;
    }
    warn!(/*...*/);
}
```

3. Add retry logic with exponential backoff for transient storage errors.

## Proof of Concept

The vulnerability can be demonstrated by:

1. Setting up a validator node with consensus and state sync components
2. Injecting storage errors in `fetch_latest_synced_ledger_info()` or `fetch_pre_committed_version()`
3. Triggering a `sync_to_target()` call from consensus
4. Observing that consensus waits indefinitely without timeout or error response
5. Monitoring that the validator cannot progress with consensus rounds

The exact PoC would require modifying the storage layer to simulate failures, but the code paths clearly show that no timeout exists and errors are not propagated via callbacks.

## Notes

The technical vulnerability is valid and represents a genuine protocol design flaw. The missing timeout mechanism combined with silent error handling creates conditions where consensus can hang indefinitely. However, the severity classification depends on the scope of impact - whether this affects individual validators or can cause network-wide liveness failures. The bounty program administrators should assess the appropriate severity tier based on exploitability and impact analysis.

### Citations

**File:** state-sync/inter-component/consensus-notifications/src/lib.rs (L122-137)
```rust
        if let Ok(response) = timeout(
            Duration::from_millis(self.commit_timeout_ms),
            callback_receiver,
        )
        .await
        {
            match response {
                Ok(consensus_notification_response) => consensus_notification_response.get_result(),
                Err(error) => Err(Error::UnexpectedErrorEncountered(format!(
                    "Consensus commit notification failure: {:?}",
                    error
                ))),
            }
        } else {
            Err(Error::TimeoutWaitingForStateSync)
        }
```

**File:** state-sync/inter-component/consensus-notifications/src/lib.rs (L162-178)
```rust
        match callback_receiver.await {
            Ok(response) => match response.get_result() {
                Ok(_) => response.get_latest_synced_ledger_info().ok_or_else(|| {
                    Error::UnexpectedErrorEncountered(
                        "Sync for duration returned an empty latest synced ledger info!".into(),
                    )
                }),
                Err(error) => Err(Error::UnexpectedErrorEncountered(format!(
                    "Sync for duration returned an error: {:?}",
                    error
                ))),
            },
            Err(error) => Err(Error::UnexpectedErrorEncountered(format!(
                "Sync for duration failure: {:?}",
                error
            ))),
        }
```

**File:** state-sync/inter-component/consensus-notifications/src/lib.rs (L200-206)
```rust
        match callback_receiver.await {
            Ok(response) => response.get_result(),
            Err(error) => Err(Error::UnexpectedErrorEncountered(format!(
                "Sync to target failure: {:?}",
                error
            ))),
        }
```

**File:** state-sync/state-sync-driver/src/driver.rs (L308-312)
```rust
        if let Err(error) = result {
            warn!(LogSchema::new(LogEntry::ConsensusNotification)
                .error(&error)
                .message("Error encountered when handling the consensus notification!"));
        }
```

**File:** state-sync/state-sync-driver/src/driver.rs (L536-609)
```rust
    async fn check_sync_request_progress(&mut self) -> Result<(), Error> {
        // Check if the sync request has been satisfied
        let consensus_sync_request = self.consensus_notification_handler.get_sync_request();
        match consensus_sync_request.lock().as_ref() {
            Some(consensus_sync_request) => {
                let latest_synced_ledger_info =
                    utils::fetch_latest_synced_ledger_info(self.storage.clone())?;
                if !consensus_sync_request
                    .sync_request_satisfied(&latest_synced_ledger_info, self.time_service.clone())
                {
                    return Ok(()); // The sync request hasn't been satisfied yet
                }
            },
            None => {
                return Ok(()); // There's no active sync request
            },
        }

        // The sync request has been satisfied. Wait for the storage synchronizer
        // to drain. This prevents notifying consensus prematurely.
        while self.storage_synchronizer.pending_storage_data() {
            sample!(
                SampleRate::Duration(Duration::from_secs(PENDING_DATA_LOG_FREQ_SECS)),
                info!("Waiting for the storage synchronizer to handle pending data!")
            );

            // Yield to avoid starving the storage synchronizer threads.
            yield_now().await;
        }

        // If the request was to sync for a specified duration, we should only
        // stop syncing when the synced version and synced ledger info version match.
        // Otherwise, the DB will be left in an inconsistent state on handover.
        if let Some(sync_request) = consensus_sync_request.lock().as_ref() {
            if sync_request.is_sync_duration_request() {
                // Get the latest synced version and ledger info version
                let latest_synced_version =
                    utils::fetch_pre_committed_version(self.storage.clone())?;
                let latest_synced_ledger_info =
                    utils::fetch_latest_synced_ledger_info(self.storage.clone())?;
                let latest_ledger_info_version = latest_synced_ledger_info.ledger_info().version();

                // Check if the latest synced version matches the latest ledger info version
                if latest_synced_version != latest_ledger_info_version {
                    sample!(
                        SampleRate::Duration(Duration::from_secs(DRIVER_INFO_LOG_FREQ_SECS)),
                        info!(
                            "Waiting for state sync to sync to a ledger info! \
                            Latest synced version: {:?}, latest ledger info version: {:?}",
                            latest_synced_version, latest_ledger_info_version
                        )
                    );

                    return Ok(()); // State sync should continue to run
                }
            }
        }

        // Handle the satisfied sync request
        let latest_synced_ledger_info =
            utils::fetch_latest_synced_ledger_info(self.storage.clone())?;
        self.consensus_notification_handler
            .handle_satisfied_sync_request(latest_synced_ledger_info)
            .await?;

        // If the sync request was successfully handled, reset the continuous syncer
        // so that in the event another sync request occurs, we have fresh state.
        if !self.active_sync_request() {
            self.continuous_syncer.reset_active_stream(None).await?;
            self.storage_synchronizer.finish_chunk_executor(); // Consensus or consensus observer is now in control
        }

        Ok(())
    }
```

**File:** state-sync/state-sync-driver/src/driver.rs (L681-685)
```rust
        if let Err(error) = self.check_sync_request_progress().await {
            warn!(LogSchema::new(LogEntry::Driver)
                .error(&error)
                .message("Error found when checking the sync request progress!"));
        }
```

**File:** state-sync/state-sync-driver/src/utils.rs (L268-284)
```rust
pub fn fetch_latest_synced_ledger_info(
    storage: Arc<dyn DbReader>,
) -> Result<LedgerInfoWithSignatures, Error> {
    storage.get_latest_ledger_info().map_err(|error| {
        Error::StorageError(format!(
            "Failed to get the latest ledger info from storage: {:?}",
            error
        ))
    })
}

/// Fetches the latest synced version from the specified storage
pub fn fetch_pre_committed_version(storage: Arc<dyn DbReader>) -> Result<Version, Error> {
    storage.ensure_pre_committed_version().map_err(|e| {
        Error::StorageError(format!("Failed to get latest version from storage: {e:?}"))
    })
}
```

**File:** storage/storage-interface/src/lib.rs (L526-530)
```rust
    fn get_latest_ledger_info(&self) -> Result<LedgerInfoWithSignatures> {
        self.get_latest_ledger_info_option().and_then(|opt| {
            opt.ok_or_else(|| AptosDbError::Other("Latest LedgerInfo not found.".to_string()))
        })
    }
```

**File:** storage/storage-interface/src/lib.rs (L571-574)
```rust
    fn ensure_pre_committed_version(&self) -> Result<Version> {
        self.get_pre_committed_version()?
            .ok_or_else(|| AptosDbError::NotFound("Pre-committed version not found.".to_string()))
    }
```
