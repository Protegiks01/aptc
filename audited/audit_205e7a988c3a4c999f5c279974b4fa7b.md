# Audit Report

## Title
Race Condition in Database Debugger Tool Creates Inconsistent State View for Operators

## Summary
The `print_db_versions` debugger tool opens three separate databases (ledger_db, state_merkle_db, state_kv_db) sequentially in readonly mode without synchronization. When run against an actively committing node, the tool captures snapshots of each database at different points in time, creating a logically impossible state view that can mislead operators into diagnosing false database corruption issues.

## Finding Description

The vulnerability exists in the database commit architecture and how the debugger tool interacts with it. Aptos storage uses a multi-database architecture where state updates are NOT committed atomically across all databases. [1](#0-0) 

The system explicitly acknowledges this by using `OverallCommitProgress` as the source of truth and maintaining separate progress trackers for each database: [2](#0-1) 

The commit flow shows that ledger_db and state_kv_db are committed in parallel (not atomically), and state_merkle_db is committed asynchronously through the BufferedState mechanism, potentially lagging by up to 100,000 versions: [3](#0-2) 

During normal operation, the startup process calls `sync_commit_progress` to truncate any inconsistent data: [4](#0-3) 

However, the debugger tool bypasses this synchronization by directly opening databases in readonly mode: [5](#0-4) 

When databases are opened in readonly mode via RocksDB, each database gets a snapshot at its specific opening time: [6](#0-5) 

**Attack Scenario:**
1. Node is actively committing transactions (e.g., versions 1000-1010)
2. Operator runs `print_db_versions` tool at T1
3. Tool opens ledger_db at T1 → captures snapshot at version 1005
4. Between T1 and T2, node commits versions 1006-1010
5. Tool opens state_merkle_db at T2 → captures snapshot at version 1010
6. Tool opens state_kv_db at T3 → captures snapshot at version 1010
7. Tool reports:
   - Ledger Progress: 1005
   - StateMerkle Progress: 1010
   - StateKv Progress: 1010

This creates an impossible state where state databases appear ahead of the ledger, misleading operators into believing the database is corrupted.

## Impact Explanation

This qualifies as **Medium Severity** under the Aptos bug bounty criteria:

- **State inconsistencies requiring intervention**: Operators may make incorrect decisions based on false inconsistency reports
- **Operational disruption**: Teams waste time investigating phantom database corruption
- **Delayed incident response**: Real issues may be ignored if the tool is known to give false positives
- **Incorrect recovery actions**: Operators might unnecessarily restart nodes, restore from backups, or escalate non-issues

While this doesn't directly cause loss of funds, consensus violations, or availability issues, it undermines the reliability of critical operational tooling used to diagnose database health during incidents.

## Likelihood Explanation

**HIGH likelihood** of occurrence:

1. The tool is specifically designed to run on live nodes for diagnostics
2. No documentation warns against running on active nodes
3. The race window is large (sequential opening of 3 databases with no coordination)
4. Active validators commit transactions continuously
5. Operators naturally run diagnostic tools during incidents when nodes are most active

The vulnerability is inherent in the tool's design and will manifest whenever the tool runs concurrently with active commits.

## Recommendation

**Option 1 (Preferred)**: Call `sync_commit_progress` before reading to ensure consistency:

```rust
pub fn run(self) -> Result<()> {
    let (ledger_db, _hot_state_merkle_db, state_merkle_db, state_kv_db) = AptosDB::open_dbs(
        &StorageDirPaths::from_path(&self.db_dir),
        rocksdb_config,
        env,
        block_cache,
        /*readonly=*/ true,
        /*max_num_nodes_per_lru_cache_shard=*/ 0,
        /*reset_hot_state=*/ false,
    )?;
    
    // Synchronize databases to OverallCommitProgress
    StateStore::sync_commit_progress(
        Arc::new(ledger_db.clone()),
        Arc::new(state_kv_db.clone()),
        Arc::new(state_merkle_db.clone()),
        /*crash_if_difference_is_too_large=*/ false,
    );
    
    // Now read from synchronized databases
    println!("Overall Progress: {:?}", ledger_db.metadata_db().get_synced_version());
    // ...
}
```

**Option 2**: Use RocksDB secondary instances with `try_catch_up_with_primary()` for consistent snapshots

**Option 3**: Add prominent warning that tool must only be run on stopped nodes

**Option 4**: Read `OverallCommitProgress` first and warn if other databases differ significantly

## Proof of Concept

```rust
// Reproduction steps:
// 1. Start an Aptos validator node in one terminal
// 2. While the node is actively committing transactions, run:
//    cargo run -p aptos-db-tool -- print-db-versions --db-dir /path/to/db
// 3. Observe output showing inconsistent progress values

// Example inconsistent output:
// Overall Progress: Some(1000)
// Ledger Progress: Some(1005)  
// StateKv Progress: Some(1010)     // Ahead of ledger!
// StateMerkle Progress: Some(1010)  // Ahead of ledger!

// This state is impossible under normal operation since
// OverallCommitProgress (1000) should be >= all other progress values.
// The tool captured databases at different commit points.

// To verify the race:
use std::thread;
use std::time::Duration;

// Simulate the tool's sequential opening
let t1 = Instant::now();
let ledger_db = open_ledger_db_readonly(); // Snapshot at T1
println!("Opened ledger_db at {:?}", t1.elapsed());

thread::sleep(Duration::from_millis(100)); // Allow commits to happen

let t2 = Instant::now();
let state_merkle_db = open_state_merkle_db_readonly(); // Snapshot at T2
println!("Opened state_merkle_db at {:?}", t2.elapsed());

thread::sleep(Duration::from_millis(100));

let t3 = Instant::now();
let state_kv_db = open_state_kv_db_readonly(); // Snapshot at T3
println!("Opened state_kv_db at {:?}", t3.elapsed());

// Read progress values - they will be inconsistent
let ledger_progress = ledger_db.get_ledger_commit_progress();
let merkle_progress = state_merkle_db.get_commit_progress();
let kv_progress = state_kv_db.get_commit_progress();

assert_ne!(ledger_progress, merkle_progress); // Will fail - demonstrates race
```

## Notes

The vulnerability is a design flaw in how operational tooling interacts with the multi-database architecture. The databases themselves are working correctly - the issue is that the debugger tool creates a temporally inconsistent view by opening them sequentially without coordination. This is particularly problematic because the tool is specifically designed to detect database inconsistencies, so false positives undermine its core purpose.

### Citations

**File:** storage/aptosdb/src/state_store/mod.rs (L354-359)
```rust
            Self::sync_commit_progress(
                Arc::clone(&ledger_db),
                Arc::clone(&state_kv_db),
                Arc::clone(&state_merkle_db),
                /*crash_if_difference_is_too_large=*/ true,
            );
```

**File:** storage/aptosdb/src/state_store/mod.rs (L408-409)
```rust
    // We commit the overall commit progress at the last, and use it as the source of truth of the
    // commit progress.
```

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L369-381)
```rust
        rayon::scope(|s| {
            s.spawn(|_| {
                self.ledger_db
                    .metadata_db()
                    .write_schemas(ledger_metadata_batch)
                    .unwrap();
            });
            s.spawn(|_| {
                self.state_kv_db
                    .commit(chunk.expect_last_version(), None, sharded_state_kv_batches)
                    .unwrap();
            });
        });
```

**File:** storage/aptosdb/src/state_store/buffered_state.rs (L29-29)
```rust
pub(crate) const TARGET_SNAPSHOT_INTERVAL_IN_VERSION: u64 = 100_000;
```

**File:** storage/aptosdb/src/db_debugger/examine/print_db_versions.rs (L47-55)
```rust
        let (ledger_db, _hot_state_merkle_db, state_merkle_db, state_kv_db) = AptosDB::open_dbs(
            &StorageDirPaths::from_path(&self.db_dir),
            rocksdb_config,
            env,
            block_cache,
            /*readonly=*/ true,
            /*max_num_nodes_per_lru_cache_shard=*/ 0,
            /*reset_hot_state=*/ false,
        )?;
```

**File:** storage/schemadb/src/lib.rs (L174-180)
```rust
                ReadOnly => {
                    DB::open_cf_descriptors_read_only(
                        db_opts,
                        path.de_unc(),
                        all_cfds.filter(|cfd| !missing_cfs.contains(cfd.name())),
                        false, /* error_if_log_file_exist */
                    )
```
