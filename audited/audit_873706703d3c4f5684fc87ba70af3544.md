# Audit Report

## Title
Stale Incarnation Race Condition Causes Validator Node Crash in BlockSTMv2

## Summary
The `fetch_data_and_record_dependency()` function in BlockSTMv2 can record dependencies using stale incarnation values when a transaction is aborted and re-executed concurrently. This race condition triggers a panic in `assert_ok!()`, crashing validator nodes and threatening network liveness.

## Finding Description

In BlockSTMv2's parallel execution model, each transaction maintains an incarnation number that increments on each re-execution after an abort. The vulnerability arises from a race condition where:

1. A transaction T (txn_idx=N) starts executing with incarnation I, creating a `ParallelState` with a captured `self.incarnation = I` [1](#0-0) 

2. During execution, T reads a key K and calls `fetch_data_and_record_dependency(key, N, I)` using the captured incarnation value [2](#0-1) 

3. Before the dependency is recorded, another thread aborts T due to push validation, incrementing the incarnation to I+1 [3](#0-2) 

4. The scheduler immediately starts executing incarnation I+1, which reads the same key K and successfully records dependency (N, I+1) [4](#0-3) 

5. The old execution (incarnation I) finally reaches the dependency recording code and attempts to insert (N, I) [5](#0-4) 

6. The `insert()` method detects that the previous incarnation (I+1) is greater than the current (I) and returns an error [6](#0-5) 

7. The `assert_ok!()` wrapper panics, crashing the validator node

**Critical Design Flaw:** The code explicitly acknowledges that "reads from outdated incarnations are not assumed to be (eagerly) cleared" but uses `assert_ok!()` which crashes on insertion errors instead of gracefully handling stale incarnations: [7](#0-6) 

**No Synchronization:** The `finish_abort()` function sets the status to `Aborted` but does NOT wait for the old incarnation's execution thread to complete, allowing concurrent execution of different incarnations: [8](#0-7) 

## Impact Explanation

This vulnerability is classified as **High Severity** per the Aptos bug bounty program:
- **Validator node crashes**: The panic terminates the validator process
- **Network availability impact**: Multiple validators experiencing this race condition simultaneously could significantly degrade network liveness
- **Deterministic execution violation**: Different validators may crash at different times due to timing variations, creating inconsistent network state

While not directly causing consensus safety violations or fund loss, validator crashes threaten the network's liveness guaranteeâ€”a critical security property.

## Likelihood Explanation

The likelihood is **Medium-to-High** under load:

**Natural Occurrence:**
- High transaction throughput increases parallel execution and abort rates
- Transactions reading shared keys experience frequent re-executions
- The race window exists between starting a read and recording the dependency

**Attacker Amplification:**
An unprivileged attacker can increase probability by submitting transactions that:
- Read many highly-contended keys (forcing frequent aborts)
- Perform expensive computations (extending the race window)
- Are structured to maximize re-execution counts

**Incarnation 0 Special Case:**
Incarnation 0 is never interrupted early, creating a guaranteed race window: [9](#0-8) 

## Recommendation

Replace `assert_ok!()` with graceful handling of stale incarnations:

```rust
// In versioned_data.rs, read() function around line 282-284
if let Some(reader_incarnation) = maybe_reader_incarnation {
    // Silently skip recording if incarnation is stale
    let _ = dependencies.lock().insert(reader_txn_idx, reader_incarnation);
}
```

**Better Solution:** Add an incarnation validity check before recording:
```rust
if let Some(reader_incarnation) = maybe_reader_incarnation {
    // Only record if this incarnation is still current
    if !self.scheduler.already_started_abort(reader_txn_idx, reader_incarnation) {
        dependencies.lock().insert(reader_txn_idx, reader_incarnation)
            .unwrap_or_else(|_| {
                // Stale incarnation detected, skip recording
            });
    }
}
```

This requires passing scheduler context to the read function or checking incarnation validity before recording dependencies.

## Proof of Concept

```rust
#[test]
fn test_stale_incarnation_race_condition() {
    use std::sync::{Arc, Barrier};
    use std::thread;
    
    // Setup MVHashMap with initial state
    let versioned_map = MVHashMap::new();
    versioned_map.data().write(
        test_key.clone(), 
        3, // writer txn_idx
        0, // writer incarnation
        Arc::new(test_value), 
        None
    );
    
    let barrier = Arc::new(Barrier::new(3));
    
    // Thread 1: Execute transaction 5 incarnation 0
    let map1 = versioned_map.clone();
    let barrier1 = barrier.clone();
    let t1 = thread::spawn(move || {
        barrier1.wait(); // Sync point
        // This should trigger the panic when trying to insert (5, 0)
        // after thread 3 has already inserted (5, 1)
        map1.data().fetch_data_and_record_dependency(&test_key, 5, 0)
    });
    
    // Thread 2: Abort transaction 5 incarnation 0
    let barrier2 = barrier.clone();
    let t2 = thread::spawn(move || {
        barrier2.wait(); // Sync point
        scheduler.start_abort(5, 0);
        scheduler.finish_abort(5, 0, false);
    });
    
    // Thread 3: Execute transaction 5 incarnation 1
    let map3 = versioned_map.clone();
    let barrier3 = barrier.clone();
    let t3 = thread::spawn(move || {
        barrier3.wait(); // Sync point
        // This inserts (5, 1) before thread 1's (5, 0)
        map3.data().fetch_data_and_record_dependency(&test_key, 5, 1)
    });
    
    // Thread 1 should panic with "Recording dependency on txn 5 incarnation 0, found incarnation 1"
    let result = t1.join();
    assert!(result.is_err()); // Should panic
}
```

**Notes**
This is a fundamental design flaw in BlockSTMv2's incarnation tracking mechanism. The `assert_ok!()` assumes monotonic incarnation recording per transaction, but the concurrent execution model allows violations of this assumption. The codebase acknowledges stale dependencies exist but doesn't handle them safely, leading to validator crashes instead of graceful degradation.

### Citations

**File:** aptos-move/block-executor/src/view.rs (L522-539)
```rust
impl<'a, T: Transaction> ParallelState<'a, T> {
    pub(crate) fn new(
        shared_map: &'a MVHashMap<T::Key, T::Tag, T::Value, DelayedFieldID>,
        shared_scheduler: SchedulerWrapper<'a>,
        start_shared_counter: u32,
        shared_counter: &'a AtomicU32,
        incarnation: Incarnation,
    ) -> Self {
        let blockstm_v2 = shared_scheduler.is_v2();
        Self {
            versioned_map: shared_map,
            scheduler: shared_scheduler,
            start_counter: start_shared_counter,
            counter: shared_counter,
            incarnation,
            captured_reads: RefCell::new(CapturedReads::new(blockstm_v2.then_some(incarnation))),
        }
    }
```

**File:** aptos-move/block-executor/src/view.rs (L630-638)
```rust
            let data = if self.scheduler.is_v2() {
                self.versioned_map.data().fetch_data_and_record_dependency(
                    key,
                    txn_idx,
                    self.incarnation,
                )
            } else {
                self.versioned_map.data().fetch_data_no_record(key, txn_idx)
            };
```

**File:** aptos-move/block-executor/src/scheduler_status.rs (L647-693)
```rust
    pub(crate) fn finish_abort(
        &self,
        txn_idx: TxnIndex,
        aborted_incarnation: Incarnation,
        start_next_incarnation: bool,
    ) -> Result<(), PanicError> {
        let status = &self.statuses[txn_idx as usize];
        let new_incarnation = aborted_incarnation + 1;
        if status.next_incarnation_to_abort.load(Ordering::Relaxed) != new_incarnation {
            // The caller must have already successfully performed a start_abort, while
            // higher incarnation may not have started until the abort finished (here).
            return Err(code_invariant_error(format!(
                "Finish abort of incarnation {}, self.next_incarnation_to_abort = {}",
                aborted_incarnation,
                status.next_incarnation_to_abort.load(Ordering::Relaxed),
            )));
        }

        {
            let status_guard = &mut *status.status_with_incarnation.lock();
            if status_guard.already_aborted(aborted_incarnation)
                || status_guard.never_started_execution(aborted_incarnation)
            {
                return Err(code_invariant_error(format!(
                    "Finish abort of incarnation {}, but inner status {:?}",
                    aborted_incarnation, status_guard
                )));
            }

            match status_guard.status {
                SchedulingStatus::Executing(_) => {
                    if start_next_incarnation {
                        return Err(code_invariant_error(format!(
                            "Finish abort for txn_idx: {} incarnation: {} w. start_next_incarnation \
                            expected Executed Status, got Executing",
                            txn_idx, aborted_incarnation
                        )));
                    }

                    // Module validation requirements are irrelevant as the incarnation was aborted.
                    status_guard.status = SchedulingStatus::Aborted;
                    status.swap_dependency_status_any(
                        &[DependencyStatus::WaitForExecution],
                        DependencyStatus::ShouldDefer,
                        "finish_abort",
                    )?;
                },
```

**File:** aptos-move/mvhashmap/src/versioned_data.rs (L280-285)
```rust
                    if let Some(reader_incarnation) = maybe_reader_incarnation {
                        // TODO(BlockSTMv2): convert to PanicErrors after MVHashMap refactoring.
                        assert_ok!(dependencies
                            .lock()
                            .insert(reader_txn_idx, reader_incarnation));
                    }
```

**File:** aptos-move/mvhashmap/src/versioned_data.rs (L534-547)
```rust
    pub fn fetch_data_and_record_dependency<Q>(
        &self,
        key: &Q,
        txn_idx: TxnIndex,
        incarnation: Incarnation,
    ) -> Result<MVDataOutput<V>, MVDataError>
    where
        Q: Equivalent<K> + Hash,
    {
        self.values
            .get(key)
            .map(|v| v.read(txn_idx, Some(incarnation)))
            .unwrap_or(Err(MVDataError::Uninitialized))
    }
```

**File:** aptos-move/mvhashmap/src/registered_dependencies.rs (L52-73)
```rust
    pub(crate) fn insert(
        &mut self,
        txn_idx: TxnIndex,
        incarnation: Incarnation,
    ) -> Result<(), PanicError> {
        if let Some(prev_incarnation) = self.dependencies.insert(txn_idx, incarnation) {
            if prev_incarnation > incarnation {
                // A higher incarnation may not have been recorded before, as
                // incarnations for each txn index are monotonically incremented.
                //
                // TODO(BlockSTMv2): Consider also checking the cases when the
                // incarnations are equal, but local caching should have ensured that the
                // read with the same incarnation was not performed twice.
                return Err(code_invariant_error(format!(
                    "Recording dependency on txn {} incarnation {}, found incarnation {}",
                    txn_idx, incarnation, prev_incarnation
                )));
            }
        }

        Ok(())
    }
```

**File:** aptos-move/block-executor/src/scheduler_v2.rs (L204-210)
```rust
                // If *stored_incarnation >= invalidated_incarnation, it means either the same
                // or a newer incarnation (compared to the current invalidation) has already been
                // successfully aborted by this AbortManager instance. This can happen because
                // the reads from outdated incarnations are not assumed to be (eagerly) cleared.
                // In such cases, no new abort action is needed for this specific call. Note also
                // that an incarnation can register multiple reads that may later be invalidated.
                false
```

**File:** aptos-move/block-executor/src/scheduler_v2.rs (L969-973)
```rust
        if incarnation == 0 {
            // Never interrupt the 0-th incarnation due to an early abort to get the first output
            // estimation (even if it is based on invalidated reads).
            return false;
        }
```
