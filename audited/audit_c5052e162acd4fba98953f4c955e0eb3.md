# Audit Report

## Title
SafetyData Invariant Violation Through Deserialization Bypass - Consensus Rules Desynchronization

## Summary
The `SafetyData` struct in the consensus safety rules system lacks validation of the critical invariant that `one_chain_round >= preferred_round`. This invariant can be violated through backward-compatible deserialization, causing the 2-chain and 3-chain consensus safety rules to become desynchronized and preventing validators from proposing blocks.

## Finding Description

The `SafetyData` struct stores two critical consensus tracking fields without enforcing their relationship: [1](#0-0) 

The constructor accepts both values without validation: [2](#0-1) 

**Semantic Invariant:**
- `one_chain_round`: highest observed 1-chain round (certified block)
- `preferred_round`: highest observed 2-chain round (parent block forming 2-chain)

Since QuorumCert validation ensures `parent.round() < certified.round()`: [3](#0-2) 

The invariant **must** be: `one_chain_round >= preferred_round`

**Violation Path:**

1. The `one_chain_round` field uses `#[serde(default)]` for backward compatibility: [4](#0-3) 

2. Deserializing old SafetyData (without `one_chain_round`) creates: `preferred_round = 100, one_chain_round = 0`, violating the invariant.

3. The `observe_qc()` function updates these fields independently: [5](#0-4) 

If the network is at round 60 but deserialized state has `preferred_round = 100`, observing a QC at round 60 results in:
- `one_chain_round = 60` (updated)
- `preferred_round = 100` (unchanged, since parent round 59 < 100)
- **Persistent violation:** `60 < 100`

**Desynchronization Impact:**

The 3-chain proposal rule rejects valid QCs: [6](#0-5) 

With `preferred_round = 100`, any proposal with QC certified round < 100 is rejected with `IncorrectPreferredRound`, even though the network is legitimately at round 60.

The 2-chain timeout rule becomes overly permissive: [7](#0-6) 

With `one_chain_round` incorrectly low, timeouts with stale QCs may pass validation.

## Impact Explanation

**Severity: Medium**

This vulnerability causes **validator liveness degradation** rather than direct consensus safety violations:

1. **Affected validators cannot propose blocks** until the network round exceeds the stale `preferred_round` value
2. **Network liveness impact**: If multiple validators upgrade simultaneously, block production may slow significantly
3. **Validator operator intervention required**: Validators must either wait for network progression or manually reset SafetyData

This qualifies as **Medium severity** per Aptos bug bounty criteria: "State inconsistencies requiring intervention."

The vulnerability does NOT directly violate consensus safety because:
- Voting rules (`safe_to_vote`) don't use these fields
- A single validator's incorrect timeout doesn't compromise safety (requires 2f+1 signatures)
- The state self-corrects once the network progresses past the stale value

## Likelihood Explanation

**Likelihood: High during upgrades**

This vulnerability triggers automatically during legitimate validator software upgrades:

1. Any validator running older code (before `one_chain_round` was added) has persistent SafetyData with only `preferred_round`
2. Upgrading to current code deserializes this data with `one_chain_round = 0` by default
3. If `preferred_round` was at a high round (normal operation), the invariant is immediately violated
4. No operator action is required - this happens transparently during normal upgrades

The Aptos network likely experienced this during the upgrade that added `one_chain_round` support, affecting all validators simultaneously.

## Recommendation

**Add invariant validation in multiple locations:**

1. **Constructor validation:**
```rust
pub fn new(
    epoch: u64,
    last_voted_round: u64,
    preferred_round: u64,
    one_chain_round: u64,
    last_vote: Option<Vote>,
    highest_timeout_round: u64,
) -> Result<Self, String> {
    if one_chain_round < preferred_round {
        return Err(format!(
            "SafetyData invariant violated: one_chain_round ({}) must be >= preferred_round ({})",
            one_chain_round, preferred_round
        ));
    }
    Ok(Self {
        epoch,
        last_voted_round,
        preferred_round,
        one_chain_round,
        last_vote,
        highest_timeout_round,
    })
}
```

2. **Fix deserialization to maintain invariant:**
```rust
impl<'de> Deserialize<'de> for SafetyData {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(Deserialize)]
        struct SafetyDataHelper {
            epoch: u64,
            last_voted_round: u64,
            preferred_round: u64,
            #[serde(default)]
            one_chain_round: u64,
            last_vote: Option<Vote>,
            #[serde(default)]
            highest_timeout_round: u64,
        }
        
        let helper = SafetyDataHelper::deserialize(deserializer)?;
        
        // If one_chain_round defaulted to 0, set it to at least preferred_round
        let one_chain_round = if helper.one_chain_round == 0 && helper.preferred_round > 0 {
            helper.preferred_round
        } else {
            helper.one_chain_round
        };
        
        Ok(SafetyData {
            epoch: helper.epoch,
            last_voted_round: helper.last_voted_round,
            preferred_round: helper.preferred_round,
            one_chain_round,
            last_vote: helper.last_vote,
            highest_timeout_round: helper.highest_timeout_round,
        })
    }
}
```

3. **Add runtime assertion in observe_qc:**
```rust
pub(crate) fn observe_qc(&self, qc: &QuorumCert, safety_data: &mut SafetyData) -> bool {
    let mut updated = false;
    let one_chain = qc.certified_block().round();
    let two_chain = qc.parent_block().round();
    
    if one_chain > safety_data.one_chain_round {
        safety_data.one_chain_round = one_chain;
        updated = true;
    }
    if two_chain > safety_data.preferred_round {
        safety_data.preferred_round = two_chain;
        updated = true;
    }
    
    // Maintain invariant
    if safety_data.one_chain_round < safety_data.preferred_round {
        safety_data.one_chain_round = safety_data.preferred_round;
        updated = true;
    }
    
    updated
}
```

## Proof of Concept

```rust
#[test]
fn test_safety_data_invariant_violation() {
    use serde_json;
    
    // Simulate old SafetyData format
    #[derive(Debug, serde::Deserialize, serde::Serialize, Clone)]
    struct OldSafetyData {
        pub epoch: u64,
        pub last_voted_round: u64,
        pub preferred_round: u64,
        pub last_vote: Option<Vote>,
    }
    
    let old_data = OldSafetyData {
        epoch: 1,
        last_voted_round: 50,
        preferred_round: 100, // Network was at round 100
        last_vote: None,
    };
    
    // Serialize old format
    let json = serde_json::to_string(&old_data).unwrap();
    println!("Old SafetyData: {}", json);
    
    // Deserialize to new format
    let new_data: SafetyData = serde_json::from_str(&json).unwrap();
    
    // Invariant is violated!
    println!("preferred_round: {}", new_data.preferred_round); // 100
    println!("one_chain_round: {}", new_data.one_chain_round); // 0
    assert!(new_data.one_chain_round < new_data.preferred_round, 
            "Invariant violated: one_chain_round < preferred_round");
    
    // Validator now cannot propose on any QC with certified round < 100
    // even though the network is legitimately at round 60
}
```

## Notes

The question asks about enforcing `preferred_round >= one_chain_round`, but the correct invariant is actually the **opposite**: `one_chain_round >= preferred_round`. This is because:
- `one_chain_round` tracks the highest certified block round (1-chain head)
- `preferred_round` tracks the highest parent block round (2-chain head)
- Since certified blocks always have round > their parents, the invariant must be `one_chain_round >= preferred_round`

The vulnerability allows this correct invariant to be violated, causing consensus rule desynchronization and validator liveness issues.

### Citations

**File:** consensus/consensus-types/src/safety_data.rs (L10-21)
```rust
pub struct SafetyData {
    pub epoch: u64,
    pub last_voted_round: u64,
    // highest 2-chain round, used for 3-chain
    pub preferred_round: u64,
    // highest 1-chain round, used for 2-chain
    #[serde(default)]
    pub one_chain_round: u64,
    pub last_vote: Option<Vote>,
    #[serde(default)]
    pub highest_timeout_round: u64,
}
```

**File:** consensus/consensus-types/src/safety_data.rs (L24-40)
```rust
    pub fn new(
        epoch: u64,
        last_voted_round: u64,
        preferred_round: u64,
        one_chain_round: u64,
        last_vote: Option<Vote>,
        highest_timeout_round: u64,
    ) -> Self {
        Self {
            epoch,
            last_voted_round,
            preferred_round,
            one_chain_round,
            last_vote,
            highest_timeout_round,
        }
    }
```

**File:** consensus/consensus-types/src/safety_data.rs (L53-70)
```rust
#[test]
fn test_safety_data_upgrade() {
    #[derive(Debug, Deserialize, Eq, PartialEq, Serialize, Clone, Default)]
    struct OldSafetyData {
        pub epoch: u64,
        pub last_voted_round: u64,
        pub preferred_round: u64,
        pub last_vote: Option<Vote>,
    }
    let old_data = OldSafetyData {
        epoch: 1,
        last_voted_round: 10,
        preferred_round: 100,
        last_vote: None,
    };
    let value = serde_json::to_value(old_data).unwrap();
    let _: SafetyData = serde_json::from_value(value).unwrap();
}
```

**File:** consensus/consensus-types/src/vote_data.rs (L59-80)
```rust
    pub fn verify(&self) -> anyhow::Result<()> {
        anyhow::ensure!(
            self.parent.epoch() == self.proposed.epoch(),
            "Parent and proposed epochs do not match",
        );
        anyhow::ensure!(
            self.parent.round() < self.proposed.round(),
            "Proposed round is less than parent round",
        );
        anyhow::ensure!(
            self.parent.timestamp_usecs() <= self.proposed.timestamp_usecs(),
            "Proposed happened before parent",
        );
        anyhow::ensure!(
            // if decoupled execution is turned on, the versions are dummy values (0),
            // but the genesis block per epoch uses the ground truth version number,
            // so we bypass the version check here.
            self.proposed.version() == 0 || self.parent.version() <= self.proposed.version(),
            "Proposed version is less than parent version",
        );
        Ok(())
    }
```

**File:** consensus/safety-rules/src/safety_rules.rs (L135-156)
```rust
    pub(crate) fn observe_qc(&self, qc: &QuorumCert, safety_data: &mut SafetyData) -> bool {
        let mut updated = false;
        let one_chain = qc.certified_block().round();
        let two_chain = qc.parent_block().round();
        if one_chain > safety_data.one_chain_round {
            safety_data.one_chain_round = one_chain;
            trace!(
                SafetyLogSchema::new(LogEntry::OneChainRound, LogEvent::Update)
                    .preferred_round(safety_data.one_chain_round)
            );
            updated = true;
        }
        if two_chain > safety_data.preferred_round {
            safety_data.preferred_round = two_chain;
            trace!(
                SafetyLogSchema::new(LogEntry::PreferredRound, LogEvent::Update)
                    .preferred_round(safety_data.preferred_round)
            );
            updated = true;
        }
        updated
    }
```

**File:** consensus/safety-rules/src/safety_rules.rs (L173-188)
```rust
    fn verify_and_update_preferred_round(
        &mut self,
        quorum_cert: &QuorumCert,
        safety_data: &mut SafetyData,
    ) -> Result<bool, Error> {
        let preferred_round = safety_data.preferred_round;
        let one_chain_round = quorum_cert.certified_block().round();

        if one_chain_round < preferred_round {
            return Err(Error::IncorrectPreferredRound(
                one_chain_round,
                preferred_round,
            ));
        }
        Ok(self.observe_qc(quorum_cert, safety_data))
    }
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L124-145)
```rust
    fn safe_to_timeout(
        &self,
        timeout: &TwoChainTimeout,
        maybe_tc: Option<&TwoChainTimeoutCertificate>,
        safety_data: &SafetyData,
    ) -> Result<(), Error> {
        let round = timeout.round();
        let qc_round = timeout.hqc_round();
        let tc_round = maybe_tc.map_or(0, |tc| tc.round());
        if (round == next_round(qc_round)? || round == next_round(tc_round)?)
            && qc_round >= safety_data.one_chain_round
        {
            Ok(())
        } else {
            Err(Error::NotSafeToTimeout(
                round,
                qc_round,
                tc_round,
                safety_data.one_chain_round,
            ))
        }
    }
```
