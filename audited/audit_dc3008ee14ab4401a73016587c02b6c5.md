# Audit Report

## Title
DoS Amplification via Unauthenticated Expensive Cryptographic Verification in Secret Share Manager

## Summary
The `verification_task()` function in the consensus secret sharing manager performs expensive pairing-based cryptographic verification on incoming `SecretShareMessage::Share` messages without validating the sender identity or share author beforehand. Byzantine validators can exploit this to send malicious shares that pass lightweight checks but trigger computationally expensive verification operations, causing DoS amplification and validator node slowdowns.

## Finding Description

The vulnerability exists in the secret share verification pipeline. When a `SecretShareMessage::Share` arrives, the flow is: [1](#0-0) 

The function only performs two checks before expensive verification:
1. BCS deserialization (line 218)
2. `msg.verify()` call (line 220)

The `msg.verify()` implementation shows the problem: [2](#0-1) 

For Share messages, this calls `share.verify(config)`: [3](#0-2) 

Note the TODO comment at line 78 acknowledging missing bounds checking. The verification proceeds to call cryptographic verification: [4](#0-3) 

For weighted validators, this iterates over all virtual players (proportional to validator weight) and performs BLS verification for each, which involves expensive pairing operations: [5](#0-4) 

Each `verify_bls()` call performs **two pairing operations** (lines 126-127), which are among the most expensive cryptographic primitives (milliseconds each).

**Critical Issue**: The `IncomingSecretShareRequest` contains a `sender` field: [6](#0-5) 

However, this field is marked `#[allow(unused)]` and is **never checked** before the expensive verification. A Byzantine validator can:

1. Send malicious `SecretShareMessage::Share` with correct epoch but invalid cryptographic data
2. Message passes BCS deserialization and epoch check
3. Spawned on bounded executor, consuming a permit
4. Expensive pairing operations execute (failing after consuming CPU)
5. Attacker repeats, filling the bounded executor queue

The bounded executor provides concurrency limits but doesn't prevent the attack: [7](#0-6) 

While tasks wait for permits (line 50), malicious verification tasks consume CPU resources. Legitimate shares are delayed as the executor capacity is saturated with failing verification attempts.

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos bug bounty program criteria: "Validator node slowdowns."

**Specific impacts:**
- **CPU Exhaustion**: Each malicious share triggers multiple pairing operations (2 Ã— number of virtual players)
- **Verification Backlog**: Legitimate shares cannot be verified while executor is saturated
- **Consensus Delays**: Random beacon generation depends on threshold secret shares; delays impact consensus liveness
- **Amplification Factor**: Validators with higher weights have more virtual players, amplifying the attack (e.g., weight 10 = 20 pairing operations per message)

The attack is particularly effective because:
- No rate limiting per validator before verification
- No authentication of sender against share author
- BoundedExecutor only limits concurrency, not total malicious work
- Attacker can send messages much faster than verification completes

## Likelihood Explanation

**Likelihood: High**

**Attacker Requirements:**
- Must be a validator in the current epoch (Byzantine validator under 1/3 assumption)
- Needs network access to consensus layer
- Can observe current epoch from any node

**Attack Simplicity:**
- Craft messages with correct epoch (public information)
- Use any valid validator address as author
- Include random cryptographic points as share data
- Send at high rate through consensus network

**No Special Conditions Required:**
- No race conditions to exploit
- No timing dependencies
- Works against all validators simultaneously
- Effective throughout entire epoch

## Recommendation

Add lightweight authentication checks **before** expensive cryptographic verification:

```rust
async fn verification_task(
    epoch_state: Arc<EpochState>,
    mut incoming_rpc_request: aptos_channel::Receiver<Author, IncomingSecretShareRequest>,
    verified_msg_tx: UnboundedSender<SecretShareRpc>,
    config: SecretShareConfig,
    bounded_executor: BoundedExecutor,
) {
    while let Some(dec_msg) = incoming_rpc_request.next().await {
        let tx = verified_msg_tx.clone();
        let epoch_state_clone = epoch_state.clone();
        let config_clone = config.clone();
        let sender = dec_msg.sender; // USE THE SENDER FIELD
        
        bounded_executor
            .spawn(async move {
                match bcs::from_bytes::<SecretShareMessage>(dec_msg.req.data()) {
                    Ok(msg) => {
                        // LIGHTWEIGHT CHECKS FIRST
                        if msg.epoch() != epoch_state_clone.epoch {
                            return;
                        }
                        
                        // Validate sender is a known validator
                        if !epoch_state_clone.verifier.contains_address(&sender) {
                            warn!("Share from unknown validator: {:?}", sender);
                            return;
                        }
                        
                        // For Share messages, validate author matches sender
                        if let SecretShareMessage::Share(ref share) = msg {
                            if share.author() != &sender {
                                warn!("Share author mismatch: author={:?}, sender={:?}", 
                                      share.author(), sender);
                                return;
                            }
                        }
                        
                        // NOW perform expensive verification
                        if msg.verify(&epoch_state_clone, &config_clone).is_ok() {
                            let _ = tx.unbounded_send(SecretShareRpc {
                                msg,
                                protocol: dec_msg.protocol,
                                response_sender: dec_msg.response_sender,
                            });
                        }
                    },
                    Err(e) => {
                        warn!("Invalid dec message: {}", e);
                    },
                }
            })
            .await;
    }
}
```

Additional mitigations:
1. Implement per-validator rate limiting for incoming shares
2. Add bounds checking in `SecretShare::verify()` (address TODO at line 78)
3. Consider batching verification operations for efficiency
4. Add metrics for failed verifications per validator

## Proof of Concept

```rust
#[cfg(test)]
mod verification_dos_test {
    use super::*;
    use aptos_types::secret_sharing::{SecretShare, SecretShareMetadata};
    use aptos_crypto::HashValue;
    use std::time::Instant;
    
    #[tokio::test]
    async fn test_malicious_share_dos_amplification() {
        // Setup: Create epoch state with validators
        let (epoch_state, config, bounded_executor) = setup_test_environment();
        let byzantine_validator = epoch_state.verifier.get_ordered_account_addresses()[0];
        
        // Create malicious share with valid epoch but invalid cryptographic data
        let malicious_share = SecretShare::new(
            byzantine_validator,
            SecretShareMetadata::new(
                epoch_state.epoch,
                1, // round
                0, // timestamp
                HashValue::zero(), // block_id
                random_digest(), // random digest
            ),
            random_invalid_share_data(), // This will fail verification
        );
        
        // Measure time for expensive verification
        let start = Instant::now();
        let result = malicious_share.verify(&config);
        let duration = start.elapsed();
        
        // Verification should fail but consume significant CPU time
        assert!(result.is_err());
        println!("Single malicious share verification took: {:?}", duration);
        
        // Demonstrate amplification: send many malicious shares
        let num_malicious_shares = 100;
        let attack_start = Instant::now();
        
        for _ in 0..num_malicious_shares {
            // In real attack, these would be sent as network messages
            // Each would spawn a verification task
            let share = create_malicious_share(byzantine_validator, epoch_state.epoch);
            let _ = share.verify(&config); // Expensive operation per share
        }
        
        let attack_duration = attack_start.elapsed();
        println!("Verification of {} malicious shares took: {:?}", 
                 num_malicious_shares, attack_duration);
        println!("Average per share: {:?}", attack_duration / num_malicious_shares);
        
        // Demonstrate that legitimate shares are blocked
        // while bounded executor is full of malicious verification tasks
        assert!(attack_duration.as_millis() > 1000); // Significant delay
    }
}
```

**Notes**

This vulnerability demonstrates a classic DoS amplification attack where lightweight message validation is bypassed in favor of expensive cryptographic operations. The issue is compounded by the weighted validator system where higher-weight validators require proportionally more verification work. The fix requires reordering validation logic to perform cheap authentication checks before expensive cryptographic verification, following the principle of "fail fast on cheap checks."

### Citations

**File:** consensus/src/rand/secret_sharing/secret_share_manager.rs (L205-235)
```rust
    async fn verification_task(
        epoch_state: Arc<EpochState>,
        mut incoming_rpc_request: aptos_channel::Receiver<Author, IncomingSecretShareRequest>,
        verified_msg_tx: UnboundedSender<SecretShareRpc>,
        config: SecretShareConfig,
        bounded_executor: BoundedExecutor,
    ) {
        while let Some(dec_msg) = incoming_rpc_request.next().await {
            let tx = verified_msg_tx.clone();
            let epoch_state_clone = epoch_state.clone();
            let config_clone = config.clone();
            bounded_executor
                .spawn(async move {
                    match bcs::from_bytes::<SecretShareMessage>(dec_msg.req.data()) {
                        Ok(msg) => {
                            if msg.verify(&epoch_state_clone, &config_clone).is_ok() {
                                let _ = tx.unbounded_send(SecretShareRpc {
                                    msg,
                                    protocol: dec_msg.protocol,
                                    response_sender: dec_msg.response_sender,
                                });
                            }
                        },
                        Err(e) => {
                            warn!("Invalid dec message: {}", e);
                        },
                    }
                })
                .await;
        }
    }
```

**File:** consensus/src/rand/secret_sharing/network_messages.rs (L28-38)
```rust
    pub fn verify(
        &self,
        epoch_state: &EpochState,
        config: &SecretShareConfig,
    ) -> anyhow::Result<()> {
        ensure!(self.epoch() == epoch_state.epoch);
        match self {
            SecretShareMessage::RequestShare(_) => Ok(()),
            SecretShareMessage::Share(share) => share.verify(config),
        }
    }
```

**File:** types/src/secret_sharing.rs (L75-82)
```rust
    pub fn verify(&self, config: &SecretShareConfig) -> anyhow::Result<()> {
        let index = config.get_id(self.author());
        let decryption_key_share = self.share().clone();
        // TODO(ibalajiarun): Check index out of bounds
        config.verification_keys[index]
            .verify_decryption_key_share(&self.metadata.digest, &decryption_key_share)?;
        Ok(())
    }
```

**File:** crates/aptos-batch-encryption/src/schemes/fptx_weighted.rs (L149-169)
```rust
    pub fn verify_decryption_key_share(
        &self,
        digest: &Digest,
        dk_share: &WeightedBIBEDecryptionKeyShare,
    ) -> Result<()> {
        (self.vks_g2.len() == dk_share.1.len())
            .then_some(())
            .ok_or(BatchEncryptionError::DecryptionKeyVerifyError)?;

        self.vks_g2
            .iter()
            .map(|vk_g2| BIBEVerificationKey {
                mpk_g2: self.mpk_g2,
                vk_g2: *vk_g2,
                player: self.weighted_player, // arbitrary
            })
            .zip(&dk_share.1)
            .try_for_each(|(vk, dk_share)| {
                vk.verify_decryption_key_share(digest, &(self.weighted_player, dk_share.clone()))
            })
    }
```

**File:** crates/aptos-batch-encryption/src/shared/key_derivation.rs (L118-133)
```rust
fn verify_bls(
    verification_key_g2: G2Affine,
    digest: &Digest,
    offset: G2Affine,
    signature: G1Affine,
) -> Result<()> {
    let hashed_offset: G1Affine = symmetric::hash_g2_element(offset)?;

    if PairingSetting::pairing(digest.as_g1() + hashed_offset, verification_key_g2)
        == PairingSetting::pairing(signature, G2Affine::generator())
    {
        Ok(())
    } else {
        Err(anyhow::anyhow!("bls verification error"))
    }
}
```

**File:** consensus/src/network.rs (L155-161)
```rust
pub struct IncomingSecretShareRequest {
    pub req: SecretShareNetworkMessage,
    #[allow(unused)]
    pub sender: Author,
    pub protocol: ProtocolId,
    pub response_sender: oneshot::Sender<Result<Bytes, RpcError>>,
}
```

**File:** crates/bounded-executor/src/executor.rs (L33-51)
```rust
    async fn acquire_permit(&self) -> OwnedSemaphorePermit {
        self.semaphore.clone().acquire_owned().await.unwrap()
    }

    fn try_acquire_permit(&self) -> Option<OwnedSemaphorePermit> {
        self.semaphore.clone().try_acquire_owned().ok()
    }

    /// Spawn a [`Future`] on the `BoundedExecutor`. This function is async and
    /// will block if the executor is at capacity until one of the other spawned
    /// futures completes. This function returns a [`JoinHandle`] that the caller
    /// can `.await` on for the results of the [`Future`].
    pub async fn spawn<F>(&self, future: F) -> JoinHandle<F::Output>
    where
        F: Future + Send + 'static,
        F::Output: Send + 'static,
    {
        let permit = self.acquire_permit().await;
        self.executor.spawn(future_with_permit(future, permit))
```
