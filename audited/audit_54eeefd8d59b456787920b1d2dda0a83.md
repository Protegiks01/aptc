# Audit Report

## Title
Future Epoch Verification Bypass in Backup Restore Allows Database Corruption via Malicious Backup Sources

## Summary
The `EpochHistory::verify_ledger_info()` function in the backup restore subsystem accepts unverified LedgerInfo entries for future epochs (epochs beyond the current epoch history) without cryptographic verification, allowing malicious backup sources to inject arbitrary state into the node's database.

## Finding Description

The vulnerability exists in the epoch verification logic during backup restoration: [1](#0-0) 

When restoring from backup, if a `LedgerInfoWithSignatures` has an epoch number greater than the length of the current epoch history, the verification function logs a warning and returns `Ok()` without performing any cryptographic verification (no signature check, no waypoint verification, no validator set verification).

This unverified `LedgerInfo` then becomes a **trust anchor** for subsequent transaction verification: [2](#0-1) 

The malicious `LedgerInfo`'s `transaction_accumulator_hash` is used to verify transaction proofs: [3](#0-2) 

Specifically, the transaction proof verification delegates to: [4](#0-3) 

The unverified `ledger_info.transaction_accumulator_hash()` is used as the trusted root, allowing an attacker to craft matching proofs for arbitrary malicious transactions.

Finally, this corrupted state is persisted to the database: [5](#0-4) [6](#0-5) 

**Attack Scenario:**
1. Attacker provides malicious backup containing valid epochs 0-N plus fabricated epoch N+10
2. Epochs 0-N restore correctly and build epoch history
3. When processing epoch N+10 data:
   - `epoch (N+10) > self.epoch_endings.len() (N+1)` 
   - Verification returns `Ok()` without checking signatures
   - Malicious `LedgerInfo` with crafted `transaction_accumulator_hash` is accepted
   - Arbitrary transactions with matching proofs pass verification
   - Corrupted state written to database

This breaks the **Cryptographic Correctness** invariant: all LedgerInfo signatures must be verified before accepting state transitions.

## Impact Explanation

**Severity Assessment: Medium (up to $10,000)**

This vulnerability causes **state inconsistencies requiring intervention** but has limited scope:

1. **Limited Attack Surface**: Only exploitable during backup restoration operations, not during live consensus or normal node operation
2. **Requires Operator Compromise**: Attacker must either:
   - Compromise the backup storage to inject malicious data
   - Social engineer operators to use malicious backup sources
   - Act as a malicious backup provider
3. **Detection on Startup**: When the corrupted node attempts to sync with the network, state divergence will be detected and the node will fail to participate in consensus
4. **No Network-Wide Impact**: Only affects the single node being restored; does not compromise network consensus or other validators
5. **Recovery Possible**: Operator can recover by re-restoring from a trusted backup source

The impact is database corruption on a single node, not consensus violation or fund theft, aligning with Medium severity criteria.

## Likelihood Explanation

**Likelihood: Low to Medium**

The attack requires:
- Node operator performing backup restoration (uncommon operation, typically only during initial setup or recovery)
- Operator using an untrusted or compromised backup source (violates operational security best practices)
- Target versions lacking trusted waypoints (some protection exists when waypoints are configured)

However, the vulnerability is **guaranteed to trigger** when these conditions are met, as there is no defensive validation for future epochs.

## Recommendation

Add explicit validation to reject future epochs that cannot be verified:

```rust
pub fn verify_ledger_info(&self, li_with_sigs: &LedgerInfoWithSignatures) -> Result<()> {
    let epoch = li_with_sigs.ledger_info().epoch();
    ensure!(!self.epoch_endings.is_empty(), "Empty epoch history.");
    
    // FIXED: Explicitly reject epochs beyond verifiable history
    ensure!(
        epoch <= self.epoch_endings.len() as u64,
        "Cannot verify epoch {} as it exceeds epoch history length {}. \
         Ensure epoch ending backups are restored before transaction/state backups.",
        epoch,
        self.epoch_endings.len()
    );
    
    if epoch == 0 {
        ensure!(
            li_with_sigs.ledger_info() == &self.epoch_endings[0],
            "Genesis epoch LedgerInfo info doesn't match.",
        );
    } else if let Some(wp_trusted) = self
        .trusted_waypoints
        .get(&li_with_sigs.ledger_info().version())
    {
        let wp_li = Waypoint::new_any(li_with_sigs.ledger_info());
        ensure!(
            *wp_trusted == wp_li,
            "Waypoints don't match. In backup: {}, trusted: {}",
            wp_li,
            wp_trusted,
        );
    } else {
        self.epoch_endings[epoch as usize - 1]
            .next_epoch_state()
            .ok_or_else(|| anyhow!("Shouldn't contain non-epoch bumping LIs."))?
            .verify(li_with_sigs)?;
    }
    Ok(())
}
```

Additionally, improve backup restoration ordering to ensure epoch endings are always restored before state/transaction data that references them.

## Proof of Concept

```rust
// Conceptual PoC - demonstrates the vulnerability flow
#[test]
fn test_future_epoch_bypass() {
    // Setup: Restore valid epoch history 0-5
    let mut epoch_endings = vec![];
    for epoch in 0..=5 {
        epoch_endings.push(create_valid_epoch_ending(epoch));
    }
    let epoch_history = EpochHistory {
        epoch_endings,
        trusted_waypoints: Arc::new(HashMap::new()),
    };
    
    // Attack: Create malicious LedgerInfo for future epoch 10
    let malicious_li = create_malicious_ledger_info(
        epoch: 10,
        version: 1000000,
        fake_transaction_accumulator_hash: HashValue::random(),
        // No valid signatures!
    );
    
    // Vulnerability: This should fail but returns Ok()
    let result = epoch_history.verify_ledger_info(&malicious_li);
    assert!(result.is_ok()); // BUG: Accepts unverified future epoch!
    
    // Impact: Malicious LedgerInfo can now be used to "verify" fake transactions
    let fake_txns = create_fake_transactions_with_matching_proofs(
        &malicious_li.transaction_accumulator_hash()
    );
    
    // These fake transactions will pass verification and be written to database
    // because the malicious LedgerInfo is treated as a trust anchor
}
```

**Notes:**
- This vulnerability exists in the backup/restore tooling, not live consensus
- Requires operator to use compromised backup sources
- Detection occurs when node attempts network synchronization
- Impact limited to single node database corruption
- Does not enable network-wide consensus violations or fund theft

### Citations

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L276-312)
```rust
    pub fn verify_ledger_info(&self, li_with_sigs: &LedgerInfoWithSignatures) -> Result<()> {
        let epoch = li_with_sigs.ledger_info().epoch();
        ensure!(!self.epoch_endings.is_empty(), "Empty epoch history.",);
        if epoch > self.epoch_endings.len() as u64 {
            // TODO(aldenhu): fix this from upper level
            warn!(
                epoch = epoch,
                epoch_history_until = self.epoch_endings.len(),
                "Epoch is too new and can't be verified. Previous chunks are verified and node \
                won't be able to start if this data is malicious."
            );
            return Ok(());
        }
        if epoch == 0 {
            ensure!(
                li_with_sigs.ledger_info() == &self.epoch_endings[0],
                "Genesis epoch LedgerInfo info doesn't match.",
            );
        } else if let Some(wp_trusted) = self
            .trusted_waypoints
            .get(&li_with_sigs.ledger_info().version())
        {
            let wp_li = Waypoint::new_any(li_with_sigs.ledger_info());
            ensure!(
                *wp_trusted == wp_li,
                "Waypoints don't match. In backup: {}, trusted: {}",
                wp_li,
                wp_trusted,
            );
        } else {
            self.epoch_endings[epoch as usize - 1]
                .next_epoch_state()
                .ok_or_else(|| anyhow!("Shouldn't contain non- epoch bumping LIs."))?
                .verify(li_with_sigs)?;
        };
        Ok(())
    }
```

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L147-154)
```rust
        let (range_proof, ledger_info) = storage
            .load_bcs_file::<(TransactionAccumulatorRangeProof, LedgerInfoWithSignatures)>(
                &manifest.proof,
            )
            .await?;
        if let Some(epoch_history) = epoch_history {
            epoch_history.verify_ledger_info(&ledger_info)?;
        }
```

**File:** types/src/transaction/mod.rs (L2295-2354)
```rust
    pub fn verify(
        &self,
        ledger_info: &LedgerInfo,
        first_transaction_version: Option<Version>,
    ) -> Result<()> {
        // Verify the first transaction versions match
        ensure!(
            self.get_first_transaction_version() == first_transaction_version,
            "First transaction version ({:?}) doesn't match given version ({:?}).",
            self.get_first_transaction_version(),
            first_transaction_version,
        );

        // Verify the lengths of the transactions and transaction infos match
        ensure!(
            self.proof.transaction_infos.len() == self.get_num_transactions(),
            "The number of TransactionInfo objects ({}) does not match the number of \
             transactions ({}).",
            self.proof.transaction_infos.len(),
            self.get_num_transactions(),
        );

        // Verify the transaction hashes match those of the transaction infos
        self.transactions
            .par_iter()
            .zip_eq(self.proof.transaction_infos.par_iter())
            .map(|(txn, txn_info)| {
                let txn_hash = CryptoHash::hash(txn);
                ensure!(
                    txn_hash == txn_info.transaction_hash(),
                    "The hash of transaction does not match the transaction info in proof. \
                     Transaction hash: {:x}. Transaction hash in txn_info: {:x}.",
                    txn_hash,
                    txn_info.transaction_hash(),
                );
                Ok(())
            })
            .collect::<Result<Vec<_>>>()?;

        // Verify the transaction infos are proven by the ledger info.
        self.proof
            .verify(ledger_info, self.get_first_transaction_version())?;

        // Verify the events if they exist.
        if let Some(event_lists) = &self.events {
            ensure!(
                event_lists.len() == self.get_num_transactions(),
                "The length of event_lists ({}) does not match the number of transactions ({}).",
                event_lists.len(),
                self.get_num_transactions(),
            );
            event_lists
                .into_par_iter()
                .zip_eq(self.proof.transaction_infos.par_iter())
                .map(|(events, txn_info)| verify_events_against_root_hash(events, txn_info))
                .collect::<Result<Vec<_>>>()?;
        }

        Ok(())
    }
```

**File:** types/src/proof/definition.rs (L910-925)
```rust
    pub fn verify(
        &self,
        ledger_info: &LedgerInfo,
        first_transaction_info_version: Option<Version>,
    ) -> Result<()> {
        let txn_info_hashes: Vec<_> = self
            .transaction_infos
            .iter()
            .map(CryptoHash::hash)
            .collect();
        self.ledger_info_to_transaction_infos_proof.verify(
            ledger_info.transaction_accumulator_hash(),
            first_transaction_info_version,
            &txn_info_hashes,
        )
    }
```

**File:** storage/aptosdb/src/backup/restore_handler.rs (L61-63)
```rust
    pub fn save_ledger_infos(&self, ledger_infos: &[LedgerInfoWithSignatures]) -> Result<()> {
        restore_utils::save_ledger_infos(self.aptosdb.ledger_db.metadata_db(), ledger_infos, None)
    }
```

**File:** storage/aptosdb/src/backup/restore_utils.rs (L41-58)
```rust
pub(crate) fn save_ledger_infos(
    ledger_metadata_db: &LedgerMetadataDb,
    ledger_infos: &[LedgerInfoWithSignatures],
    existing_batch: Option<&mut SchemaBatch>,
) -> Result<()> {
    ensure!(!ledger_infos.is_empty(), "No LedgerInfos to save.");

    if let Some(existing_batch) = existing_batch {
        save_ledger_infos_impl(ledger_metadata_db, ledger_infos, existing_batch)?;
    } else {
        let mut batch = SchemaBatch::new();
        save_ledger_infos_impl(ledger_metadata_db, ledger_infos, &mut batch)?;
        ledger_metadata_db.write_schemas(batch)?;
        update_latest_ledger_info(ledger_metadata_db, ledger_infos)?;
    }

    Ok(())
}
```
