# Audit Report

## Title
Version Rollback in IndexerMetadataSchema Causes Event Sequence Number Corruption and Duplicate Indexing

## Summary
An attacker with database write access can downgrade version metadata in `IndexerMetadataSchema` without correspondingly rolling back `EventSequenceNumberSchema` entries, causing the indexer to assign incorrect sequence numbers to events during reprocessing. This results in duplicate event entries with different sequence numbers pointing to the same transaction version, corrupting the event index and breaking event queries.

## Finding Description

The vulnerability exists in how the indexer handles metadata rollback versus per-event-key state. When version metadata is downgraded but event sequence number state is not, the indexer reprocesses historical blocks with stale sequence number information, creating corrupted index entries.

**Root Cause:**

The `decode_value()` function in `IndexerMetadataSchema` performs no validation on version monotonicity: [1](#0-0) 

Version metadata (`LatestVersion`, `EventVersion`, etc.) is stored in this schema: [2](#0-1) 

However, `EventSequenceNumberSchema` stores the last sequence number assigned to each event key, and is NOT part of the metadata rollback logic: [3](#0-2) 

**Attack Flow:**

1. **Initial State:** Indexer processes versions 0-1000. For event key K1, sequence numbers 0-599 are assigned across these versions. Database contains:
   - `LatestVersion`: 1000
   - `EventSequenceNumberSchema[K1]`: 599  
   - `EventByKeySchema[(K1, 0)]`: (version_0, idx)
   - `EventByKeySchema[(K1, 599)]`: (version_999, idx)

2. **Attack:** Attacker with database write access downgrades:
   - `LatestVersion`: 400
   - `EventVersion`: 400
   - But leaves `EventSequenceNumberSchema[K1]`: 599 (not metadata!)

3. **Indexer Restart:** On startup, the indexer reads the rolled-back version: [4](#0-3) 

4. **Reprocessing with Stale State:** Starting from version 401, the indexer creates a new `EventV2TranslationEngine` with an empty cache: [5](#0-4) 

5. **Incorrect Sequence Number Assignment:** When translating V2 events, `get_next_sequence_number()` queries the database (cache miss): [6](#0-5) 

   It returns 600 (599 + 1) instead of the correct historical sequence number (e.g., 40).

6. **Data Corruption:** The indexer writes duplicate entries during batch processing: [7](#0-6) 

   For version 401:
   - OLD (correct): `EventByKeySchema[(K1, 40)]` → (401, 0)
   - NEW (incorrect): `EventByKeySchema[(K1, 600)]` → (401, 0)

**Result:** The same transaction version now appears under multiple sequence numbers. Event queries by sequence number return incorrect or duplicate results. The sequence number space has gaps and duplicates, breaking the event indexing invariant.

## Impact Explanation

**Severity: HIGH**

This vulnerability causes **significant protocol violations** and **state inconsistencies requiring intervention**, meeting High severity criteria per the Aptos bug bounty program:

1. **Index Corruption:** The event index becomes corrupted with duplicate and incorrect mappings between sequence numbers and transaction versions.

2. **Query Failures:** Applications querying events by key and sequence number receive incorrect results or miss events entirely, breaking API contracts.

3. **Data Integrity Loss:** The indexer's fundamental invariant (sequence numbers uniquely and sequentially map to events) is violated.

4. **Cascading Effects:** All event-dependent functionality is affected, including:
   - NFT/token event tracking
   - Coin deposit/withdraw history  
   - Account transaction history
   - Event-based indexers and analytics

5. **Difficult Recovery:** Requires manual database intervention to identify and remove corrupted entries, or complete re-indexing from genesis.

While this requires database write access (privileged position), it represents a realistic threat model for:
- Compromised node operators
- Database backup/restore attacks
- Insider threats
- Storage layer vulnerabilities

## Likelihood Explanation

**Likelihood: MEDIUM**

**Attack Prerequisites:**
- Database write access to the indexer database
- Knowledge of the indexer metadata schema structure
- Ability to selectively modify metadata tables

**Factors Increasing Likelihood:**
1. No validation in `decode_value()` prevents malformed version values
2. No consistency checks between `EventSequenceNumberSchema` and version metadata on startup
3. The panic checks only validate that different version metadata fields match each other, not that they're consistent with per-key state: [8](#0-7) 

**Factors Decreasing Likelihood:**
1. Requires privileged database access
2. Node operators would likely notice indexer reprocessing old blocks
3. The attack leaves detectable traces (duplicate entries)

## Recommendation

**Immediate Fix:**

Add validation to ensure version metadata is consistent with `EventSequenceNumberSchema` on startup. Before processing, verify that the minimum sequence number for each event key aligns with the version being processed.

**Code Fix:**

Add a consistency check in `get_start_version()`:

```rust
// In internal_indexer_db_service.rs, after line 164:

// Validate EventSequenceNumberSchema is consistent with rollback
if node_config.indexer_db_config.enable_event_v2_translation() {
    self.validate_event_sequence_consistency(start_version)?;
}

// New method:
fn validate_event_sequence_consistency(&self, start_version: Version) -> Result<()> {
    let mut iter = self.db_indexer.indexer_db.db
        .iter::<EventSequenceNumberSchema>()?;
    iter.seek_to_first();
    
    while let Some((event_key, seq_num)) = iter.next().transpose()? {
        // Verify this event key's data is consistent with start_version
        if let Some((actual_version, _)) = self.db_indexer.indexer_db.db
            .get::<EventByKeySchema>(&(event_key, seq_num))? {
            
            if actual_version < start_version {
                bail!(
                    "Inconsistent event sequence state: key {:?} seq {} points to version {}, \
                     but indexer is starting from {}. Possible metadata rollback detected.",
                    event_key, seq_num, actual_version, start_version
                );
            }
        }
    }
    Ok(())
}
```

**Alternative Approach:**

Treat `EventSequenceNumberSchema` as metadata that must be rolled back atomically with version metadata, or clear it entirely on version rollback.

## Proof of Concept

```rust
// Rust test demonstrating the vulnerability

#[test]
fn test_version_rollback_causes_sequence_corruption() {
    // Setup: Create indexer and process blocks 0-1000
    let (db, indexer_db, main_db_reader) = setup_test_indexer();
    let indexer = DBIndexer::new(indexer_db.clone(), main_db_reader);
    
    // Process initial blocks (0-1000) with event V2 translation enabled
    indexer.process(0, 1000).unwrap();
    
    // Verify initial state
    let latest_version = indexer_db.get_persisted_version().unwrap().unwrap();
    assert_eq!(latest_version, 999); // Last processed version
    
    // Get sequence number for test event key
    let test_event_key = create_test_event_key();
    let initial_seq = db.get::<EventSequenceNumberSchema>(&test_event_key)
        .unwrap().unwrap();
    assert_eq!(initial_seq, 599); // 600 events processed
    
    // Verify event at version 401 has sequence number 40
    let (version_401, _) = db.get::<EventByKeySchema>(&(test_event_key, 40))
        .unwrap().unwrap();
    assert_eq!(version_401, 401);
    
    // ATTACK: Rollback version metadata but NOT EventSequenceNumberSchema
    let mut batch = SchemaBatch::new();
    batch.put::<InternalIndexerMetadataSchema>(
        &MetadataKey::LatestVersion,
        &MetadataValue::Version(400)
    ).unwrap();
    batch.put::<InternalIndexerMetadataSchema>(
        &MetadataKey::EventVersion,
        &MetadataValue::Version(400)
    ).unwrap();
    batch.put::<InternalIndexerMetadataSchema>(
        &MetadataKey::EventV2TranslationVersion,
        &MetadataValue::Version(400)
    ).unwrap();
    db.write_schemas(batch).unwrap();
    
    // EventSequenceNumberSchema still has stale value 599
    let seq_after_rollback = db.get::<EventSequenceNumberSchema>(&test_event_key)
        .unwrap().unwrap();
    assert_eq!(seq_after_rollback, 599); // NOT rolled back!
    
    // Restart indexer (simulates node restart)
    drop(indexer);
    let new_indexer = DBIndexer::new(indexer_db.clone(), main_db_reader);
    
    // Reprocess from version 401
    new_indexer.process(401, 500).unwrap();
    
    // CORRUPTION DETECTED: Version 401 now has TWO sequence numbers!
    let (old_version, _) = db.get::<EventByKeySchema>(&(test_event_key, 40))
        .unwrap().unwrap();
    assert_eq!(old_version, 401); // Old correct entry
    
    let (new_version, _) = db.get::<EventByKeySchema>(&(test_event_key, 600))
        .unwrap().unwrap();
    assert_eq!(new_version, 401); // New incorrect entry - CORRUPTION!
    
    // Both entries point to the same version - index is corrupted!
}
```

## Notes

This vulnerability specifically affects the **event V2 translation** feature, which is critical for maintaining compatibility with V1 event APIs. The corruption occurs because `EventSequenceNumberSchema` is per-event-key state rather than global metadata, but is treated as persistent state across version rollbacks.

The lack of validation in `decode_value()` is compounded by the absence of cross-schema consistency checks during indexer initialization. While database write access is a high privilege, this threat model is explicitly stated in the security question and represents realistic attack scenarios including compromised operators, backup corruption, or storage vulnerabilities.

### Citations

**File:** storage/indexer_schemas/src/schema/indexer_metadata/mod.rs (L40-42)
```rust
    fn decode_value(data: &[u8]) -> Result<Self> {
        Ok(bcs::from_bytes(data)?)
    }
```

**File:** storage/indexer_schemas/src/metadata.rs (L31-42)
```rust
#[derive(Clone, Debug, Deserialize, PartialEq, Eq, Serialize, Hash, PartialOrd, Ord)]
#[cfg_attr(any(test, feature = "fuzzing"), derive(proptest_derive::Arbitrary))]
pub enum MetadataKey {
    LatestVersion,
    EventPrunerProgress,
    TransactionPrunerProgress,
    StateSnapshotRestoreProgress(Version),
    EventVersion,
    StateVersion,
    TransactionVersion,
    EventV2TranslationVersion,
}
```

**File:** storage/indexer_schemas/src/schema/event_sequence_number/mod.rs (L20-29)
```rust
define_pub_schema!(
    EventSequenceNumberSchema,
    Key,
    Value,
    EVENT_SEQUENCE_NUMBER_CF_NAME
);

type SeqNum = u64;
type Key = EventKey;
type Value = SeqNum;
```

**File:** ecosystem/indexer-grpc/indexer-grpc-table-info/src/internal_indexer_db_service.rs (L102-106)
```rust
        let start_version = self
            .db_indexer
            .indexer_db
            .get_persisted_version()?
            .map_or(0, |v| v + 1);
```

**File:** ecosystem/indexer-grpc/indexer-grpc-table-info/src/internal_indexer_db_service.rs (L114-138)
```rust
            if start_version != state_start_version {
                panic!("Cannot start state indexer because the progress doesn't match.");
            }
        }

        if node_config.indexer_db_config.enable_transaction() {
            let transaction_start_version = self
                .db_indexer
                .indexer_db
                .get_transaction_version()?
                .map_or(0, |v| v + 1);
            if start_version != transaction_start_version {
                panic!("Cannot start transaction indexer because the progress doesn't match.");
            }
        }

        if node_config.indexer_db_config.enable_event() {
            let event_start_version = self
                .db_indexer
                .indexer_db
                .get_event_version()?
                .map_or(0, |v| v + 1);
            if start_version != event_start_version {
                panic!("Cannot start event indexer because the progress doesn't match.");
            }
```

**File:** storage/indexer/src/event_v2_translator.rs (L155-160)
```rust
        Self {
            main_db_reader,
            internal_indexer_db,
            translators,
            event_sequence_number_cache: DashMap::new(),
        }
```

**File:** storage/indexer/src/event_v2_translator.rs (L190-200)
```rust
    pub fn get_next_sequence_number(&self, event_key: &EventKey, default: u64) -> Result<u64> {
        if let Some(seq) = self.get_cached_sequence_number(event_key) {
            Ok(seq + 1)
        } else {
            let seq = self
                .internal_indexer_db
                .get::<EventSequenceNumberSchema>(event_key)?
                .map_or(default, |seq| seq + 1);
            Ok(seq)
        }
    }
```

**File:** storage/indexer/src/db_indexer.rs (L464-475)
```rust
                                batch
                                    .put::<EventByKeySchema>(
                                        &(key, sequence_number),
                                        &(version, idx as u64),
                                    )
                                    .expect("Failed to put events by key to a batch");
                                batch
                                    .put::<EventByVersionSchema>(
                                        &(key, version, sequence_number),
                                        &(idx as u64),
                                    )
                                    .expect("Failed to put events by version to a batch");
```
