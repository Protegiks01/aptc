# Audit Report

## Title
Peer Address Multiplicity Attack via File Discovery: Connection Delay and Resource Exhaustion

## Summary
The `load_file()` function in the file discovery system lacks validation on the number of network addresses per peer, allowing an attacker to specify hundreds or thousands of conflicting addresses for a single PeerId. This causes the connectivity manager to cycle through all addresses with exponential backoff, resulting in severe connection delays (hours to days) and resource exhaustion.

## Finding Description

The vulnerability exists in the file-based peer discovery mechanism where a malicious YAML file can specify multiple conflicting network addresses for a single peer without any validation or limits.

**Attack Flow:**

1. **No Address Validation**: The `load_file()` function deserializes YAML into a `PeerSet` without validating the number of addresses per peer. [1](#0-0) 

2. **Unrestricted Address Storage**: Each `Peer` contains `addresses: Vec<NetworkAddress>` with no size limits. [2](#0-1) 

3. **All Addresses Stored**: When the ConnectivityManager processes discovered peers, it stores ALL addresses from the file without deduplication or validation. [3](#0-2) 

4. **Sequential Address Iteration**: The `Addresses` structure stores all addresses, and the dial logic cycles through them sequentially using round-robin with wrapping. [4](#0-3) 

5. **Exponential Backoff Delay**: Each failed dial attempt incurs exponential backoff up to `max_delay` (60 seconds by default). [5](#0-4) 

6. **Single Active Dial Per Peer**: Only one dial attempt per PeerId can be queued at a time, preventing the system from trying multiple addresses in parallel. [6](#0-5) 

**Attack Scenario:**
- Attacker creates a YAML file with a critical peer having 1,000 different IP addresses
- Only the last address (or none) is valid
- The node must sequentially try addresses 0-999 with exponential backoff
- With max backoff of 60 seconds, it could take 16+ hours to reach address #1000
- During this time, no connection can be established to that peer

## Impact Explanation

This vulnerability qualifies as **Medium Severity** per Aptos bug bounty criteria:

1. **Network Degradation**: Delays or prevents connections to critical peers (validators, VFNs), potentially causing network partition or liveness issues
2. **Resource Exhaustion**: Each address consumes memory and computational resources for dial states, futures, and connection attempts
3. **State Inconsistencies**: If validator connections are delayed, it can cause state sync issues requiring manual intervention
4. **DoS Vector**: File discovery becomes a denial-of-service attack vector against any node using this feature

The impact is limited to Medium (not Critical/High) because:
- No direct loss of funds or consensus safety violation
- Requires file system access or social engineering
- Does not cause permanent network damage
- Can be mitigated by restarting with a clean config

## Likelihood Explanation

**Likelihood: Medium**

This vulnerability is realistic and exploitable:

1. **File Discovery is Common**: Many node operators use file-based discovery for seed peers, especially in testnet/devnet environments
2. **Attack Vectors**:
   - Social engineering: Tricking operators to use a malicious peer list
   - Supply chain attacks: Compromising community-shared peer lists
   - Configuration management: Exploiting weak config deployment systems
3. **No Authentication Required**: The attacker only needs to provide a malicious YAML file
4. **Silent Degradation**: The attack is subtle and may go unnoticed initially as it appears as normal connection difficulties

## Recommendation

Implement validation and limits on peer addresses at multiple levels:

**1. Add Address Count Validation in `load_file()`:**
```rust
fn load_file(path: &Path) -> Result<PeerSet, DiscoveryError> {
    const MAX_ADDRESSES_PER_PEER: usize = 10;
    
    let contents = std::fs::read_to_string(path).map_err(DiscoveryError::IO)?;
    let peer_set: PeerSet = serde_yaml::from_str(&contents)
        .map_err(|err| DiscoveryError::Parsing(err.to_string()))?;
    
    // Validate address counts
    for (peer_id, peer) in &peer_set {
        if peer.addresses.len() > MAX_ADDRESSES_PER_PEER {
            return Err(DiscoveryError::Parsing(format!(
                "Peer {} has {} addresses, exceeding limit of {}",
                peer_id, peer.addresses.len(), MAX_ADDRESSES_PER_PEER
            )));
        }
    }
    
    Ok(peer_set)
}
```

**2. Add Address Deduplication in `Addresses::update()`:**
```rust
fn update(&mut self, src: DiscoverySource, mut addrs: Vec<NetworkAddress>) -> bool {
    const MAX_ADDRESSES_PER_SOURCE: usize = 10;
    
    // Deduplicate and limit addresses
    addrs.sort();
    addrs.dedup();
    addrs.truncate(MAX_ADDRESSES_PER_SOURCE);
    
    let src_idx = src.as_usize();
    if self.0[src_idx] != addrs {
        self.0[src_idx] = addrs;
        true
    } else {
        false
    }
}
```

**3. Add Early Address Validation:**
Extend `NetworkConfig::verify_seeds()` to validate file-discovered peers with similar checks.

## Proof of Concept

**Malicious YAML File (`malicious_peers.yaml`):**
```yaml
# Peer with 1000 conflicting addresses (only showing first few)
"ca3579457555c80fc7bb39964eb298c414fd60f81a2f8eedb0244ec07a26e575":
  addresses:
    - "/ip4/192.0.2.1/tcp/6180/noise-ik/080e287879c918794170e258bfaddd75acac5b3e350419044655e4983a487120/handshake/0"
    - "/ip4/192.0.2.2/tcp/6180/noise-ik/080e287879c918794170e258bfaddd75acac5b3e350419044655e4983a487120/handshake/0"
    - "/ip4/192.0.2.3/tcp/6180/noise-ik/080e287879c918794170e258bfaddd75acac5b3e350419044655e4983a487120/handshake/0"
    # ... repeat for 1000 addresses ...
    - "/ip4/192.0.6.232/tcp/6180/noise-ik/080e287879c918794170e258bfaddd75acac5b3e350419044655e4983a487120/handshake/0"
  keys:
    - "080e287879c918794170e258bfaddd75acac5b3e350419044655e4983a487120"
  role: "validator"
```

**Rust Test to Demonstrate Impact:**
```rust
#[tokio::test]
async fn test_address_multiplicity_attack() {
    use aptos_config::config::{Peer, PeerRole, PeerSet};
    use aptos_types::{network_address::NetworkAddress, PeerId};
    use std::str::FromStr;
    
    // Create a peer with 1000 different addresses
    let mut peer_set = PeerSet::new();
    let peer_id = PeerId::random();
    let mut addresses = Vec::new();
    
    for i in 0..1000 {
        let addr = NetworkAddress::from_str(&format!(
            "/ip4/192.0.{}.{}/tcp/6180/noise-ik/080e287879c918794170e258bfaddd75acac5b3e350419044655e4983a487120/handshake/0",
            i / 256, i % 256
        )).unwrap();
        addresses.push(addr);
    }
    
    peer_set.insert(
        peer_id,
        Peer::from_addrs(PeerRole::Validator, addresses)
    );
    
    // Write to file
    let yaml = serde_yaml::to_string(&peer_set).unwrap();
    std::fs::write("/tmp/malicious_peers.yaml", yaml).unwrap();
    
    // Load via load_file() - NO VALIDATION OCCURS
    let loaded = load_file(Path::new("/tmp/malicious_peers.yaml")).unwrap();
    
    // Verify all 1000 addresses were loaded
    assert_eq!(loaded.get(&peer_id).unwrap().addresses.len(), 1000);
    
    // The connectivity manager will now cycle through all 1000 addresses
    // with exponential backoff, causing extreme delays
}
```

**Notes:**
- The attack requires file system access or the ability to provide a malicious configuration file
- Impact is amplified when targeting critical validator peers
- The vulnerability affects both validator and fullnode deployments using file discovery
- Current implementation has no defense against this attack vector

### Citations

**File:** network/discovery/src/file.rs (L50-53)
```rust
fn load_file(path: &Path) -> Result<PeerSet, DiscoveryError> {
    let contents = std::fs::read_to_string(path).map_err(DiscoveryError::IO)?;
    serde_yaml::from_str(&contents).map_err(|err| DiscoveryError::Parsing(err.to_string()))
}
```

**File:** config/src/config/network_config.rs (L458-464)
```rust
#[derive(Clone, Debug, Default, Deserialize, PartialEq, Eq, Serialize)]
#[serde(default)]
pub struct Peer {
    pub addresses: Vec<NetworkAddress>,
    pub keys: HashSet<x25519::PublicKey>,
    pub role: PeerRole,
}
```

**File:** network/framework/src/connectivity_manager/mod.rs (L743-757)
```rust
        // Choose the next addr to dial for this peer. Currently, we just
        // round-robin the selection, i.e., try the sequence:
        // addr[0], .., addr[len-1], addr[0], ..
        let addr = match dial_state.next_addr(&peer.addrs) {
            Some(addr) => addr.clone(),
            None => {
                warn!(
                    NetworkSchema::new(&self.network_context).remote_peer(&peer_id),
                    "{} Peer {} does not have any network addresses!",
                    self.network_context,
                    peer_id.short_str()
                );
                return;
            },
        };
```

**File:** network/framework/src/connectivity_manager/mod.rs (L958-970)
```rust
            // Update the peer's addresses
            if peer.addrs.update(src, discovered_peer.addresses) {
                info!(
                    NetworkSchema::new(&self.network_context).remote_peer(&peer_id),
                    network_addresses = &peer.addrs,
                    "{} addresses updated for peer: {}, update src: {:?}, addrs: {}",
                    self.network_context,
                    peer_id.short_str(),
                    src,
                    &peer.addrs,
                );
                peer_updated = true;
            }
```

**File:** network/framework/src/connectivity_manager/mod.rs (L1365-1369)
```rust
    fn next_addr<'a>(&mut self, addrs: &'a Addresses) -> Option<&'a NetworkAddress> {
        let curr_addr = self.get_addr_at_index(self.addr_idx, addrs);
        self.addr_idx = self.addr_idx.wrapping_add(1);
        curr_addr
    }
```

**File:** network/framework/src/connectivity_manager/mod.rs (L1377-1381)
```rust
    fn next_backoff_delay(&mut self, max_delay: Duration) -> Duration {
        let jitter = jitter(MAX_CONNECTION_DELAY_JITTER);

        min(max_delay, self.backoff.next().unwrap_or(max_delay)) + jitter
    }
```
