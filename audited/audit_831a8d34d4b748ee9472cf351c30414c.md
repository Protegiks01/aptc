# Audit Report

## Title
Unhandled BCS Deserialization Failures in Remote Executor Service Cause Process Crashes via Malformed GRPC Messages

## Summary
The remote executor service's message handlers use `.unwrap()` on BCS deserialization without error handling, allowing attackers with network access to crash executor shards, the coordinator, or state view services by sending malformed protobuf messages through unauthenticated GRPC endpoints.

## Finding Description

The `process_one_outgoing_message()` function sends Message objects over GRPC without validating the payload content. [1](#0-0) 

Message objects contain raw byte vectors that are transmitted as-is through the protobuf NetworkMessage structure. [2](#0-1) 

The GRPC client wrapper directly copies the message data into the protobuf without validation: [3](#0-2) 

On the receiving side, multiple critical message handlers deserialize these bytes using `bcs::from_bytes().unwrap()` without error handling:

**Coordinator Client (Executor Shard):** [4](#0-3) 

**State View Service:** [5](#0-4) 

**Cross-Shard Client:** [6](#0-5) 

**Remote Executor Client (Coordinator):** [7](#0-6) 

The GRPC server accepts messages from any client without authentication: [8](#0-7) 

**Attack Path:**
1. Attacker gains network access to internal executor service endpoints (e.g., compromised network, insider threat, misconfigured firewall)
2. Attacker crafts a GRPC request with malformed BCS data in the `message` field
3. The receiving service attempts `bcs::from_bytes(&message.data).unwrap()`
4. Deserialization fails, `.unwrap()` panics
5. The panic crashes the thread or entire process (no panic handler installed in executor-service) [9](#0-8) 

This breaks the **availability invariant** - the system must remain operational under adversarial conditions.

## Impact Explanation

This qualifies as **High Severity** per Aptos bug bounty criteria:
- **"Validator node slowdowns"** - Crashing executor shards forces the system to restart or fail over, degrading performance
- **"API crashes"** - State view service crashes prevent state queries from being served
- **"Significant protocol violations"** - The sharded execution protocol cannot function if components keep crashing

The vulnerability affects:
- Executor shards (via execute_command messages)
- State view service (via remote_kv_request messages)  
- Cross-shard communication (via cross_shard_N messages)
- Coordinator (via execute_result messages)

A persistent attacker can repeatedly crash services, causing prolonged unavailability.

## Likelihood Explanation

**Likelihood: Medium**

**Prerequisites:**
- Network access to internal executor service GRPC endpoints (typically port 52200+ range)
- Knowledge of the protobuf message format

**Feasibility:**
- GRPC endpoints have no authentication or authorization
- Malformed BCS payloads are trivial to construct
- The remote executor service is designed for distributed deployment across multiple machines/processes

**Mitigating Factors:**
- These services are typically deployed on internal networks behind firewalls
- The remote executor may not be enabled on all deployments
- Access requires network-level compromise

However, defense-in-depth principles require resilience even when network boundaries are breached. The lack of input validation violates secure coding practices.

## Recommendation

**Immediate Fix:** Replace all `.unwrap()` calls on BCS deserialization with proper error handling:

```rust
// In remote_cordinator_client.rs
match bcs::from_bytes::<RemoteExecutionRequest>(&message.data) {
    Ok(request) => {
        // Process request
    },
    Err(e) => {
        error!("Failed to deserialize RemoteExecutionRequest: {:?}", e);
        return ExecutorShardCommand::Stop;
    }
}
```

**Additional Recommendations:**
1. Add authentication to GRPC endpoints (mTLS, API keys, or token-based auth)
2. Implement message size limits beyond the current MAX_MESSAGE_SIZE
3. Add rate limiting per client
4. Install panic handler in executor-service main.rs to prevent process crashes
5. Add structured logging of deserialization failures for security monitoring
6. Consider using a type-safe RPC framework that handles deserialization errors gracefully

## Proof of Concept

```rust
// PoC demonstrating the vulnerability
use aptos_secure_net::network_controller::{Message, NetworkController};
use std::net::{IpAddr, Ipv4Addr, SocketAddr};
use std::thread;
use std::time::Duration;

#[test]
fn test_malformed_bcs_crash() {
    // Start a remote state view service
    let server_addr = SocketAddr::new(IpAddr::V4(Ipv4Addr::LOCALHOST), 52300);
    let mut controller = NetworkController::new(
        "test_service".to_string(),
        server_addr,
        5000
    );
    
    let rx = controller.create_inbound_channel("remote_kv_request".to_string());
    controller.start();
    
    // Simulate receiving a message with malformed BCS data
    let attacker_controller = NetworkController::new(
        "attacker".to_string(),
        SocketAddr::new(IpAddr::V4(Ipv4Addr::LOCALHOST), 52301),
        5000
    );
    
    let tx = attacker_controller.create_outbound_channel(
        server_addr,
        "remote_kv_request".to_string()
    );
    
    // Send malformed BCS data (invalid bytes)
    let malformed_data = vec![0xFF, 0xFF, 0xFF, 0xFF]; // Invalid BCS
    tx.send(Message::new(malformed_data)).unwrap();
    
    thread::sleep(Duration::from_millis(100));
    
    // In real code, this would panic and crash the handler thread
    // when it tries: bcs::from_bytes(&message.data).unwrap()
    // Expected: Panic with "called `Result::unwrap()` on an `Err` value"
}
```

**Note:** This PoC demonstrates the attack vector. In production, the panic would crash the RemoteStateViewService handler thread, disrupting state queries for all shards.

### Citations

**File:** secure/net/src/network_controller/outbound_handler.rs (L155-159)
```rust
                grpc_clients
                    .get_mut(remote_addr)
                    .unwrap()
                    .send_message(*socket_addr, msg, message_type)
                    .await;
```

**File:** secure/net/src/network_controller/mod.rs (L56-60)
```rust
#[derive(Clone, Debug, Deserialize, Serialize)]
#[allow(dead_code)]
pub struct Message {
    pub data: Vec<u8>,
}
```

**File:** secure/net/src/grpc_network_service/mod.rs (L92-107)
```rust
impl NetworkMessageService for GRPCNetworkMessageServiceServerWrapper {
    async fn simple_msg_exchange(
        &self,
        request: Request<NetworkMessage>,
    ) -> Result<Response<Empty>, Status> {
        let _timer = NETWORK_HANDLER_TIMER
            .with_label_values(&[&self.self_addr.to_string(), "inbound_msgs"])
            .start_timer();
        let remote_addr = request.remote_addr();
        let network_message = request.into_inner();
        let msg = Message::new(network_message.message);
        let message_type = MessageType::new(network_message.message_type);

        if let Some(handler) = self.inbound_handlers.lock().unwrap().get(&message_type) {
            // Send the message to the registered handler
            handler.send(msg).unwrap();
```

**File:** secure/net/src/grpc_network_service/mod.rs (L146-149)
```rust
        let request = tonic::Request::new(NetworkMessage {
            message: message.data,
            message_type: mt.get_type(),
        });
```

**File:** execution/executor-service/src/remote_cordinator_client.rs (L89-89)
```rust
                let request: RemoteExecutionRequest = bcs::from_bytes(&message.data).unwrap();
```

**File:** execution/executor-service/src/remote_state_view_service.rs (L86-86)
```rust
        let req: RemoteKVRequest = bcs::from_bytes(&message.data).unwrap();
```

**File:** execution/executor-service/src/remote_cross_shard_client.rs (L64-64)
```rust
        let msg: CrossShardMsg = bcs::from_bytes(&message.to_bytes()).unwrap();
```

**File:** execution/executor-service/src/remote_executor_client.rs (L168-168)
```rust
            let result: RemoteExecutionResult = bcs::from_bytes(&received_bytes).unwrap();
```

**File:** execution/executor-service/src/main.rs (L27-48)
```rust
fn main() {
    let args = Args::parse();
    aptos_logger::Logger::new().init();

    let (tx, rx) = crossbeam_channel::unbounded();
    ctrlc::set_handler(move || {
        tx.send(()).unwrap();
    })
    .expect("Error setting Ctrl-C handler");

    let _exe_service = ProcessExecutorService::new(
        args.shard_id,
        args.num_shards,
        args.num_executor_threads,
        args.coordinator_address,
        args.remote_executor_addresses,
    );

    rx.recv()
        .expect("Could not receive Ctrl-C msg from channel.");
    info!("Process executor service shutdown successfully.");
}
```
