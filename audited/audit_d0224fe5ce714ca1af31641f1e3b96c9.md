# Audit Report

## Title
Byzantine Shard Can Cause Coordinator Crash or State Inconsistency via Unvalidated RemoteExecutionResult Structure

## Summary
The `RemoteExecutionResult` struct lacks validation of its inner `Vec<Vec<TransactionOutput>>` structure. A Byzantine executor shard can return a different number of rounds than expected, causing the coordinator to either panic with an out-of-bounds error or produce inconsistent state by including empty transaction output vectors in the final aggregated results.

## Finding Description

The sharded block execution system distributes transaction execution across multiple executor shards. Each shard receives a `SubBlocksForShard` containing a specific number of sub-blocks (rounds) to execute, and is expected to return results matching that structure.

**Vulnerability Location:**

The `RemoteExecutionResult` is created without validation: [1](#0-0) 

Results are received and deserialized without validation: [2](#0-1) 

The coordinator aggregates results by assuming all shards return the same number of rounds as shard 0: [3](#0-2) 

**Attack Scenario:**

1. Coordinator partitions block into 4 shards with 3 rounds each
2. Honest shards (0, 2, 3) execute their 3 rounds and return `Vec` of length 3
3. Byzantine shard 1 returns malicious result with different length

**Attack Variant A - Crash via Out-of-Bounds:**
- Shard 1 returns 5 rounds instead of 3
- Line 98: `num_rounds = sharded_output[0].len()` sets `num_rounds = 3`
- Line 100: `ordered_results` allocated with size `4 * 3 = 12`
- Lines 102-106: When processing shard 1's round 4, index = `4 * 4 + 1 = 17`
- **Result: Index 17 exceeds bounds of array size 12 → PANIC → Coordinator crash**

**Attack Variant B - State Inconsistency via Missing Outputs:**
- Shard 1 returns 1 round instead of 3
- `ordered_results` allocated with size 12, all initialized as empty `Vec::new()`
- Only position `0 * 4 + 1 = 1` gets filled for shard 1
- Positions `1 * 4 + 1 = 5` and `2 * 4 + 1 = 9` remain empty vectors
- Lines 108-110: These empty vectors are extended into `aggregated_results`
- **Result: Missing transaction outputs → Incomplete state transition → Inconsistent state root**

This breaks the **Deterministic Execution** invariant because different coordinator instances (or validators) could crash at different times or compute different state roots if they receive different malformed results.

## Impact Explanation

**Critical Severity** - This vulnerability enables multiple critical impacts:

1. **Consensus Safety Violation**: Different validators running coordinators could receive different malformed results from compromised shards, leading to different aggregated outputs and thus different state roots for the same block. This violates the core invariant that "all validators must produce identical state roots for identical blocks."

2. **Denial of Service**: A Byzantine shard returning more rounds than expected causes an immediate panic/crash of the coordinator node, leading to validator unavailability.

3. **State Inconsistency**: A Byzantine shard returning fewer rounds creates incomplete transaction output sets. When these are committed to storage, the state becomes inconsistent with what should have been executed, potentially requiring manual intervention or a hard fork to recover.

Per the Aptos Bug Bounty criteria, this qualifies as **Critical Severity** (up to $1,000,000) due to:
- Consensus/Safety violations
- Potential network partition if multiple validators crash
- State inconsistencies that may require intervention

## Likelihood Explanation

**Likelihood: Medium to High**

This vulnerability is exploitable whenever:
1. Sharded block execution is enabled
2. One or more executor shards are compromised or malicious

**Attacker Requirements:**
- Compromise a single executor shard process (via remote code execution, memory corruption, or insider access)
- Ability to modify the shard's return values before serialization

**Complexity:**
- Low technical complexity once a shard is compromised
- The malicious shard simply needs to return a `Vec<Vec<TransactionOutput>>` with incorrect outer Vec length
- No cryptographic bypasses or complex state manipulation required

**Factors Increasing Likelihood:**
- No validation exists at any layer (serialization, deserialization, or aggregation)
- The coordinator blindly trusts shard responses
- Multiple attack paths exist (crash vs. state corruption)

## Recommendation

Add comprehensive validation of `RemoteExecutionResult` structure before aggregation:

```rust
// In remote_executor_client.rs, modify get_output_from_shards():
fn get_output_from_shards(
    &self,
    expected_rounds_per_shard: Vec<usize>, // Pass expected structure
) -> Result<Vec<Vec<Vec<TransactionOutput>>>, VMStatus> {
    trace!("RemoteExecutorClient Waiting for results");
    let mut results = vec![];
    
    for (shard_id, (rx, expected_rounds)) in self.result_rxs.iter()
        .zip(expected_rounds_per_shard.iter())
        .enumerate() 
    {
        let received_bytes = rx.recv().unwrap().to_bytes();
        let result: RemoteExecutionResult = bcs::from_bytes(&received_bytes).unwrap();
        let shard_output = result.inner?;
        
        // VALIDATION: Check round count matches expected
        if shard_output.len() != *expected_rounds {
            return Err(VMStatus::error(
                StatusCode::UNEXPECTED_ERROR_FROM_KNOWN_MOVE_FUNCTION,
                Some(format!(
                    "Shard {} returned {} rounds but expected {}",
                    shard_id, shard_output.len(), expected_rounds
                ))
            ));
        }
        
        // VALIDATION: Check each round has expected transaction count
        // (requires passing expected tx counts as well)
        
        results.push(shard_output);
    }
    Ok(results)
}
```

Additionally, in `sharded_block_executor/mod.rs`, add defensive validation:

```rust
// Before line 98, add:
// Validate all shards returned the same number of rounds
let num_rounds = sharded_output[0].len();
for (shard_id, shard_results) in sharded_output.iter().enumerate() {
    if shard_results.len() != num_rounds {
        return Err(VMStatus::error(
            StatusCode::UNEXPECTED_ERROR_FROM_KNOWN_MOVE_FUNCTION,
            Some(format!(
                "Shard {} returned {} rounds but shard 0 returned {}",
                shard_id, shard_results.len(), num_rounds
            ))
        ));
    }
}
```

## Proof of Concept

```rust
#[cfg(test)]
mod byzantine_shard_test {
    use super::*;
    use aptos_types::transaction::TransactionOutput;
    
    #[test]
    #[should_panic(expected = "index out of bounds")]
    fn test_byzantine_shard_causes_coordinator_crash() {
        // Simulate 4 shards, 3 rounds each
        let num_shards = 4;
        let expected_rounds = 3;
        
        // Create honest shard outputs (3 rounds each)
        let mut sharded_output = vec![];
        for _ in 0..num_shards {
            let mut shard_output = vec![];
            for _ in 0..expected_rounds {
                shard_output.push(vec![TransactionOutput::default()]);
            }
            sharded_output.push(shard_output);
        }
        
        // Shard 1 is Byzantine: returns 5 rounds instead of 3
        sharded_output[1] = vec![
            vec![TransactionOutput::default()],
            vec![TransactionOutput::default()],
            vec![TransactionOutput::default()],
            vec![TransactionOutput::default()], // Extra round 3
            vec![TransactionOutput::default()], // Extra round 4
        ];
        
        // Reproduce the aggregation logic from sharded_block_executor/mod.rs
        let num_rounds = sharded_output[0].len(); // = 3
        let mut ordered_results = vec![vec![]; num_shards * num_rounds]; // size = 12
        
        // This will panic when shard 1 tries to write round 3 or 4
        for (shard_id, results_from_shard) in sharded_output.into_iter().enumerate() {
            for (round, result) in results_from_shard.into_iter().enumerate() {
                // When shard_id=1, round=3: index = 3*4+1 = 13 → OUT OF BOUNDS!
                // When shard_id=1, round=4: index = 4*4+1 = 17 → OUT OF BOUNDS!
                ordered_results[round * num_shards + shard_id] = result;
            }
        }
    }
    
    #[test]
    fn test_byzantine_shard_causes_missing_outputs() {
        let num_shards = 4;
        let expected_rounds = 3;
        
        let mut sharded_output = vec![];
        for _ in 0..num_shards {
            let mut shard_output = vec![];
            for _ in 0..expected_rounds {
                shard_output.push(vec![TransactionOutput::default()]);
            }
            sharded_output.push(shard_output);
        }
        
        // Shard 1 is Byzantine: returns only 1 round instead of 3
        sharded_output[1] = vec![vec![TransactionOutput::default()]];
        
        let num_rounds = sharded_output[0].len();
        let mut ordered_results = vec![vec![]; num_shards * num_rounds];
        let mut aggregated_results = vec![];
        
        for (shard_id, results_from_shard) in sharded_output.into_iter().enumerate() {
            for (round, result) in results_from_shard.into_iter().enumerate() {
                ordered_results[round * num_shards + shard_id] = result;
            }
        }
        
        for result in ordered_results.into_iter() {
            aggregated_results.extend(result);
        }
        
        // Expected: 4 shards * 3 rounds = 12 output vectors
        // Actual: Some positions remain empty due to shard 1's missing rounds
        assert_eq!(aggregated_results.len(), 10); // Missing 2 outputs
    }
}
```

**Notes:**
- This vulnerability exists because the remote execution system trusts shard responses without validation
- The attack requires compromise of an executor shard, which may be part of the validator's own infrastructure or a separate service depending on deployment
- The fix requires passing expected structure information through the execution pipeline and validating at multiple checkpoints
- Both crash and state inconsistency variants are exploitable, making this a critical multi-vector vulnerability

### Citations

**File:** execution/executor-service/src/lib.rs (L32-41)
```rust
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct RemoteExecutionResult {
    pub inner: Result<Vec<Vec<TransactionOutput>>, VMStatus>,
}

impl RemoteExecutionResult {
    pub fn new(inner: Result<Vec<Vec<TransactionOutput>>, VMStatus>) -> Self {
        Self { inner }
    }
}
```

**File:** execution/executor-service/src/remote_executor_client.rs (L163-172)
```rust
    fn get_output_from_shards(&self) -> Result<Vec<Vec<Vec<TransactionOutput>>>, VMStatus> {
        trace!("RemoteExecutorClient Waiting for results");
        let mut results = vec![];
        for rx in self.result_rxs.iter() {
            let received_bytes = rx.recv().unwrap().to_bytes();
            let result: RemoteExecutionResult = bcs::from_bytes(&received_bytes).unwrap();
            results.push(result.inner?);
        }
        Ok(results)
    }
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/mod.rs (L98-110)
```rust
        let num_rounds = sharded_output[0].len();
        let mut aggregated_results = vec![];
        let mut ordered_results = vec![vec![]; num_executor_shards * num_rounds];
        // Append the output from individual shards in the round order
        for (shard_id, results_from_shard) in sharded_output.into_iter().enumerate() {
            for (round, result) in results_from_shard.into_iter().enumerate() {
                ordered_results[round * num_executor_shards + shard_id] = result;
            }
        }

        for result in ordered_results.into_iter() {
            aggregated_results.extend(result);
        }
```
