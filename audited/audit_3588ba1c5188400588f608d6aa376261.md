# Audit Report

## Title
State Merkle Pruner Fails to Reset Progress After Database Truncation, Causing Permanent Storage Leak of Orphaned Stale Indices

## Summary
The state merkle pruner's progress tracking is not reset during database truncation operations, causing the pruner to permanently skip stale node indices at versions below its saved progress. This results in orphaned stale indices accumulating in the database, creating a storage leak that requires manual intervention.

## Finding Description

The vulnerability exists in the interaction between the pruner's progress tracking and database truncation recovery logic. When `maybe_prune_single_version()` encounters no stale indices (iterator exhausted), it stores `target_version` to maintain progress: [1](#0-0) 

The pruner persists its progress to the database: [2](#0-1) 

During database truncation (crash recovery), stale indices are deleted but **the pruner progress is NOT reset**: [3](#0-2) 

The `put_progress` call only updates commit progress, not pruner progress: [4](#0-3) 

When the pruner reinitializes after truncation, it loads the stale progress value: [5](#0-4) 

The pruner then seeks from this stale progress value: [6](#0-5) 

**Attack Scenario:**
1. Node operates normally with pruner progress at version 900
2. Crash occurs, database truncates to version 500
3. Stale indices at versions â‰¥501 are deleted by truncation
4. Pruner progress remains at 900 in database (not reset)
5. Node replays blocks 501-1000, creating new stale indices
6. Pruner loads progress=900 and seeks from version 900
7. **Stale indices at versions 501-899 are permanently missed**

The iterator in `get_stale_node_indices` cannot find these orphaned indices because it seeks forward from `start_version`: [7](#0-6) 

## Impact Explanation

This breaks the **State Consistency** invariant by creating orphaned database entries that cannot be cleaned up through normal operation. The orphaned stale indices and their associated Jellyfish Merkle tree nodes accumulate indefinitely, causing:

1. **Storage Bloat**: Each missed stale index retains its corresponding Merkle tree node
2. **Performance Degradation**: Database queries must traverse larger datasets
3. **Manual Intervention Required**: Only direct database maintenance can clean up orphaned entries

This qualifies as **Medium Severity** per Aptos bug bounty criteria: "State inconsistencies requiring intervention."

While not directly causing consensus failure or fund loss, accumulated storage bloat over multiple crash-recovery cycles can significantly impact node operation and requires administrative intervention to resolve.

## Likelihood Explanation

**Likelihood: Medium**

This occurs whenever:
1. A validator node crashes with inconsistent database state
2. The `sync_commit_progress` recovery mechanism triggers truncation
3. The pruner had advanced beyond the truncation point

The `sync_commit_progress` function is explicitly designed for crash recovery: [8](#0-7) 

Validator crashes are rare but inevitable in production environments. Each crash-with-truncation event permanently leaks storage for all stale indices between the truncation point and the pruner's saved progress.

## Recommendation

Add explicit pruner progress reset logic in the truncation path. The `delete_nodes_and_stale_indices_at_or_after_version` function should reset both commit progress AND pruner progress:

```rust
fn delete_nodes_and_stale_indices_at_or_after_version(
    db: &DB,
    version: Version,
    shard_id: Option<usize>,
    batch: &mut SchemaBatch,
) -> Result<()> {
    delete_stale_node_index_at_or_after_version::<StaleNodeIndexSchema>(db, version, batch)?;
    delete_stale_node_index_at_or_after_version::<StaleNodeIndexCrossEpochSchema>(
        db, version, batch,
    )?;

    let mut iter = db.iter::<JellyfishMerkleNodeSchema>()?;
    iter.seek(&NodeKey::new_empty_path(version))?;
    for item in iter {
        let (key, _) = item?;
        batch.delete::<JellyfishMerkleNodeSchema>(&key)?;
    }

    StateMerkleDb::put_progress(version.checked_sub(1), shard_id, batch)?;
    
    // ADD: Reset pruner progress to prevent seeking past truncation point
    if shard_id.is_some() {
        batch.put::<DbMetadataSchema>(
            &DbMetadataKey::StateMerkleShardPrunerProgress(shard_id.unwrap()),
            &DbMetadataValue::Version(version.saturating_sub(1)),
        )?;
    } else {
        batch.put::<DbMetadataSchema>(
            &DbMetadataKey::StateMerklePrunerProgress,
            &DbMetadataValue::Version(version.saturating_sub(1)),
        )?;
    }

    Ok(())
}
```

Additionally, reset the epoch snapshot pruner progress:

```rust
batch.put::<DbMetadataSchema>(
    &DbMetadataKey::EpochEndingStateMerklePrunerProgress,
    &DbMetadataValue::Version(version.saturating_sub(1)),
)?;
```

## Proof of Concept

```rust
// Rust test demonstrating the issue
#[test]
fn test_pruner_progress_not_reset_after_truncation() {
    use crate::utils::truncation_helper::*;
    use crate::pruner::state_merkle_pruner::*;
    
    // Setup: Create DB with stale indices at versions 0-1000
    let tmpdir = aptos_temppath::TempPath::new();
    let db = create_test_db(&tmpdir);
    let state_merkle_db = create_test_state_merkle_db(&db);
    
    // Write stale indices at versions 500-600
    for v in 500..=600 {
        write_stale_index(&state_merkle_db, v);
    }
    
    // Pruner processes up to version 900
    let pruner = StateMerklePruner::<StaleNodeIndexSchema>::new(
        Arc::clone(&state_merkle_db)
    ).unwrap();
    pruner.set_target_version(900);
    pruner.prune(100).unwrap();
    
    let progress_before = get_state_merkle_pruner_progress(&state_merkle_db).unwrap();
    assert_eq!(progress_before, Some(900));
    
    // Simulate crash and truncate to version 400
    truncate_state_merkle_db(&state_merkle_db, 400).unwrap();
    
    // Verify commit progress was reset
    let commit_progress = get_state_merkle_commit_progress(&state_merkle_db).unwrap();
    assert_eq!(commit_progress, Some(400));
    
    // BUG: Pruner progress was NOT reset
    let progress_after = get_state_merkle_pruner_progress(&state_merkle_db).unwrap();
    assert_eq!(progress_after, Some(900)); // Still at 900!
    
    // Write new stale indices at versions 401-600 after replay
    for v in 401..=600 {
        write_stale_index(&state_merkle_db, v);
    }
    
    // Create new pruner instance (simulating restart)
    let pruner2 = StateMerklePruner::<StaleNodeIndexSchema>::new(
        Arc::clone(&state_merkle_db)
    ).unwrap();
    
    // Pruner loads progress=900 and won't find indices at 401-600
    pruner2.set_target_version(1000);
    pruner2.prune(100).unwrap();
    
    // Verify: Stale indices at 401-899 still exist (leaked)
    for v in 401..=899 {
        assert!(stale_index_exists(&state_merkle_db, v), 
                "Stale index at version {} should exist but was missed", v);
    }
}
```

## Notes

The comment at line 74 states "reached the end of stale index" when `next_version` is `None`. This assumption is only valid during normal forward-only operation. After truncation, the database can contain stale indices at versions *before* the pruner's seek position, violating this assumption. The pruner's forward-only iteration model cannot recover from backward database state changes introduced by truncation.

### Citations

**File:** storage/aptosdb/src/pruner/state_merkle_pruner/state_merkle_metadata_pruner.rs (L53-58)
```rust
        let (indices, next_version) = StateMerklePruner::get_stale_node_indices(
            &self.metadata_db,
            current_progress,
            target_version_for_this_round,
            usize::MAX,
        )?;
```

**File:** storage/aptosdb/src/pruner/state_merkle_pruner/state_merkle_metadata_pruner.rs (L66-69)
```rust
        batch.put::<DbMetadataSchema>(
            &S::progress_metadata_key(None),
            &DbMetadataValue::Version(target_version_for_this_round),
        )?;
```

**File:** storage/aptosdb/src/pruner/state_merkle_pruner/state_merkle_metadata_pruner.rs (L73-76)
```rust
        self.next_version
            // If next_version is None, meaning we've already reached the end of stale index.
            // Updating it to the target_version to make sure it's still making progress.
            .store(next_version.unwrap_or(target_version), Ordering::SeqCst);
```

**File:** storage/aptosdb/src/utils/truncation_helper.rs (L603-622)
```rust
fn delete_nodes_and_stale_indices_at_or_after_version(
    db: &DB,
    version: Version,
    shard_id: Option<usize>,
    batch: &mut SchemaBatch,
) -> Result<()> {
    delete_stale_node_index_at_or_after_version::<StaleNodeIndexSchema>(db, version, batch)?;
    delete_stale_node_index_at_or_after_version::<StaleNodeIndexCrossEpochSchema>(
        db, version, batch,
    )?;

    let mut iter = db.iter::<JellyfishMerkleNodeSchema>()?;
    iter.seek(&NodeKey::new_empty_path(version))?;
    for item in iter {
        let (key, _) = item?;
        batch.delete::<JellyfishMerkleNodeSchema>(&key)?;
    }

    StateMerkleDb::put_progress(version.checked_sub(1), shard_id, batch)
}
```

**File:** storage/aptosdb/src/state_merkle_db.rs (L393-409)
```rust
    pub(crate) fn put_progress(
        version: Option<Version>,
        shard_id: Option<usize>,
        batch: &mut impl WriteBatch,
    ) -> Result<()> {
        let key = if let Some(shard_id) = shard_id {
            DbMetadataKey::StateMerkleShardCommitProgress(shard_id)
        } else {
            DbMetadataKey::StateMerkleCommitProgress
        };

        if let Some(version) = version {
            batch.put::<DbMetadataSchema>(&key, &DbMetadataValue::Version(version))
        } else {
            batch.delete::<DbMetadataSchema>(&key)
        }
    }
```

**File:** storage/aptosdb/src/pruner/state_merkle_pruner/mod.rs (L124-166)
```rust
    pub fn new(state_merkle_db: Arc<StateMerkleDb>) -> Result<Self> {
        info!(name = S::name(), "Initializing...");

        let metadata_pruner = StateMerkleMetadataPruner::new(state_merkle_db.metadata_db_arc());
        let metadata_progress = metadata_pruner.progress()?;

        info!(
            metadata_progress = metadata_progress,
            "Created {} metadata pruner, start catching up all shards.",
            S::name(),
        );

        let shard_pruners = if state_merkle_db.sharding_enabled() {
            let num_shards = state_merkle_db.num_shards();
            let mut shard_pruners = Vec::with_capacity(num_shards);
            for shard_id in 0..num_shards {
                shard_pruners.push(StateMerkleShardPruner::new(
                    shard_id,
                    state_merkle_db.db_shard_arc(shard_id),
                    metadata_progress,
                )?);
            }
            shard_pruners
        } else {
            Vec::new()
        };

        let pruner = StateMerklePruner {
            target_version: AtomicVersion::new(metadata_progress),
            progress: AtomicVersion::new(metadata_progress),
            metadata_pruner,
            shard_pruners,
            _phantom: std::marker::PhantomData,
        };

        info!(
            name = pruner.name(),
            progress = metadata_progress,
            "Initialized."
        );

        Ok(pruner)
    }
```

**File:** storage/aptosdb/src/pruner/state_merkle_pruner/mod.rs (L191-217)
```rust
    pub(in crate::pruner::state_merkle_pruner) fn get_stale_node_indices(
        state_merkle_db_shard: &DB,
        start_version: Version,
        target_version: Version,
        limit: usize,
    ) -> Result<(Vec<StaleNodeIndex>, Option<Version>)> {
        let mut indices = Vec::new();
        let mut iter = state_merkle_db_shard.iter::<S>()?;
        iter.seek(&StaleNodeIndex {
            stale_since_version: start_version,
            node_key: NodeKey::new_empty_path(0),
        })?;

        let mut next_version = None;
        while indices.len() < limit {
            if let Some((index, _)) = iter.next().transpose()? {
                next_version = Some(index.stale_since_version);
                if index.stale_since_version <= target_version {
                    indices.push(index);
                    continue;
                }
            }
            break;
        }

        Ok((indices, next_version))
    }
```

**File:** storage/aptosdb/src/state_store/mod.rs (L460-502)
```rust
            }
            truncate_state_kv_db(
                &state_kv_db,
                state_kv_commit_progress,
                overall_commit_progress,
                std::cmp::max(difference as usize, 1), /* batch_size */
            )
            .expect("Failed to truncate state K/V db.");

            let state_merkle_max_version = get_max_version_in_state_merkle_db(&state_merkle_db)
                .expect("Failed to get state merkle max version.")
                .expect("State merkle max version cannot be None.");
            if state_merkle_max_version > overall_commit_progress {
                let difference = state_merkle_max_version - overall_commit_progress;
                if crash_if_difference_is_too_large {
                    assert_le!(difference, MAX_COMMIT_PROGRESS_DIFFERENCE);
                }
            }
            let state_merkle_target_version = find_tree_root_at_or_before(
                ledger_metadata_db,
                &state_merkle_db,
                overall_commit_progress,
            )
            .expect("DB read failed.")
            .unwrap_or_else(|| {
                panic!(
                    "Could not find a valid root before or at version {}, maybe it was pruned?",
                    overall_commit_progress
                )
            });
            if state_merkle_target_version < state_merkle_max_version {
                info!(
                    state_merkle_max_version = state_merkle_max_version,
                    target_version = state_merkle_target_version,
                    "Start state merkle truncation..."
                );
                truncate_state_merkle_db(&state_merkle_db, state_merkle_target_version)
                    .expect("Failed to truncate state merkle db.");
            }
        } else {
            info!("No overall commit progress was found!");
        }
    }
```
