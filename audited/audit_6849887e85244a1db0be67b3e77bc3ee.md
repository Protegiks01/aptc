# Audit Report

## Title
Timestamp Source Mismatch in Batch Summary Garbage Collection Causes Non-Deterministic Transaction Deduplication

## Summary
The `gc_expired_batch_summaries_without_proofs()` function uses wall clock time while `insert_proof()` uses blockchain timestamp, creating a race condition where batch summaries can be prematurely garbage collected while their corresponding proofs remain valid. This breaks transaction deduplication and can lead to non-deterministic behavior across validators.

## Finding Description

The security question asks whether line 327 should use `>=` instead of `>` to match `insert_proof` logic. The answer is **no** - the comparison operator is correct. However, investigation reveals a more serious issue: **mismatched timestamp sources**. [1](#0-0) 

The `insert_proof()` function rejects proofs when `proof.expiration() <= self.latest_block_timestamp`, where `latest_block_timestamp` is the blockchain consensus time updated via committed blocks. [2](#0-1) 

However, `gc_expired_batch_summaries_without_proofs()` uses `aptos_infallible::duration_since_epoch()` (wall clock time) to determine expiration. This creates a race condition:

**Race Condition Scenario:**
1. A batch summary exists with expiration time T
2. Wall clock advances to T+100 (ahead of blockchain due to normal lag)
3. Blockchain timestamp is T-50 (lagging behind wall clock)
4. `gc_expired_batch_summaries_without_proofs()` is called (sampled every 500ms)
5. Check: `expiration (T) > wall_clock (T+100)` → FALSE → batch summary is **garbage collected**
6. A proof arrives with expiration T
7. `insert_proof()` checks: `expiration (T) <= blockchain_time (T-50)` → FALSE → proof is **accepted**
8. **Result**: Proof exists without its batch summary (`txn_summaries = None`) [3](#0-2) 

The garbage collection is triggered non-deterministically via sampling, meaning different validators may garbage collect at different times.

**Impact on Transaction Deduplication:** [4](#0-3) 

When `txn_summaries` is `None`, the system assumes all transactions in the batch are unique (`batch.num_txns()`) without checking for duplicates across batches. [5](#0-4) 

Without proper deduplication, the `filtered_txns` set is not updated correctly, causing:
- Incorrect unique transaction counts
- Potential violation of transaction limits
- Non-deterministic behavior across validators with different GC timing

## Impact Explanation

This qualifies as **Medium Severity** per Aptos bug bounty criteria:
- **State inconsistencies requiring intervention**: Different validators may have different batch queue states due to non-deterministic wall clock-based GC timing
- The broken determinism invariant means validators could make different decisions when constructing or validating blocks
- While not directly causing consensus failure, this creates observable non-determinism in transaction processing that could require manual intervention

The issue breaks the **Deterministic Execution** invariant: validators receiving identical network messages (proofs and batch summaries) can end up with different internal states due to wall clock variations, leading to different transaction selection behavior.

## Likelihood Explanation

**High likelihood**: This occurs naturally in production environments:
- Blockchain timestamps always lag behind wall clock time (by design)
- The sampling-based GC (every 500ms) combined with wall clock drift ensures different validators GC at different absolute times
- Network latency variations mean validators receive proofs at different relative times to their GC cycles
- No attacker action required - this is a systematic flaw triggered by normal operations

## Recommendation

Replace wall clock time with blockchain timestamp in `gc_expired_batch_summaries_without_proofs()`:

```rust
fn gc_expired_batch_summaries_without_proofs(&mut self) {
    // Use blockchain timestamp instead of wall clock
    let timestamp = self.latest_block_timestamp;
    self.items.retain(|_, item| {
        if item.is_committed() || item.proof.is_some() || item.info.expiration() > timestamp {
            true
        } else {
            self.author_to_batches
                .get_mut(&item.info.author())
                .map(|queue| queue.remove(&BatchSortKey::from_info(&item.info)));
            counters::GARBAGE_COLLECTED_IN_PROOF_QUEUE_COUNTER
                .with_label_values(&["expired_batch_without_proof"])
                .inc();
            false
        }
    });
}
```

This ensures GC decisions are based on the same time reference as proof acceptance decisions, maintaining consistency across validators.

**Note**: The comparison operator `>` is correct and should NOT be changed to `>=`. Both `insert_proof()` and the GC function correctly treat the boundary case (expiration equals timestamp) as "expired".

## Proof of Concept

```rust
#[tokio::test]
async fn test_timestamp_source_mismatch() {
    let my_peer_id = PeerId::random();
    let batch_store = batch_store_for_test(5 * 1024 * 1024);
    let mut proof_queue = BatchProofQueue::new(my_peer_id, batch_store, 100_000);
    
    // Get current wall clock time
    let wall_clock_usecs = aptos_infallible::duration_since_epoch().as_micros() as u64;
    
    // Set blockchain timestamp to lag behind wall clock by 100ms
    let blockchain_timestamp = wall_clock_usecs - 100_000;
    proof_queue.handle_updated_block_timestamp(blockchain_timestamp);
    
    // Create batch summary with expiration between blockchain time and wall clock
    let expiration = blockchain_timestamp + 50_000; // Expires in 50ms blockchain time
    let author = PeerId::random();
    let batch_info = BatchInfo::new(
        author,
        BatchId::new_for_test(0),
        0,
        expiration,
        HashValue::random(),
        10,
        10,
        100,
    ).into();
    
    let txn_summary = TxnSummaryWithExpiration::new(
        PeerId::ONE,
        ReplayProtector::SequenceNumber(0),
        (expiration / 1_000_000) + 1,
        HashValue::zero(),
    );
    
    // Insert batch summary
    proof_queue.insert_batches(vec![(batch_info.clone(), vec![txn_summary])]);
    assert_eq!(proof_queue.batch_summaries_len(), 1);
    
    // Trigger GC (uses wall clock) - should remove batch summary
    // because expiration < wall_clock_usecs
    proof_queue.gc_expired_batch_summaries_without_proofs();
    assert_eq!(proof_queue.batch_summaries_len(), 0); // Batch summary GC'd
    
    // But insert_proof with same expiration should succeed
    // because expiration > blockchain_timestamp
    let proof = ProofOfStore::new(batch_info, AggregateSignature::empty());
    proof_queue.insert_proof(proof);
    
    // Proof was accepted but has no txn_summaries
    let (remaining_txns, remaining_proofs) = proof_queue.remaining_txns_and_proofs();
    assert_eq!(remaining_proofs, 1); // Proof exists
    assert_eq!(proof_queue.batch_summaries_len(), 0); // But no batch summary
    
    // This breaks deduplication - transactions assumed unique without checking
}
```

## Notes

The specific question about `>=` vs `>` is answered definitively: **the current `>` operator is correct**. Both `insert_proof()` and `gc_expired_batch_summaries_without_proofs()` treat the boundary case identically (as "expired"), so they already match in logic.

The actual vulnerability is the timestamp source mismatch. This is a subtle but important distinction - the comparison operator is fine, but the operands are wrong.

### Citations

**File:** consensus/src/quorum_store/batch_proof_queue.rs (L175-179)
```rust
    pub(crate) fn insert_proof(&mut self, proof: ProofOfStore<BatchInfoExt>) {
        if proof.expiration() <= self.latest_block_timestamp {
            counters::inc_rejected_pos_count(counters::POS_EXPIRED_LABEL);
            return;
        }
```

**File:** consensus/src/quorum_store/batch_proof_queue.rs (L252-255)
```rust
        sample!(
            SampleRate::Duration(Duration::from_millis(500)),
            self.gc_expired_batch_summaries_without_proofs()
        );
```

**File:** consensus/src/quorum_store/batch_proof_queue.rs (L324-328)
```rust
    fn gc_expired_batch_summaries_without_proofs(&mut self) {
        let timestamp = aptos_infallible::duration_since_epoch().as_micros() as u64;
        self.items.retain(|_, item| {
            if item.is_committed() || item.proof.is_some() || item.info.expiration() > timestamp {
                true
```

**File:** consensus/src/quorum_store/batch_proof_queue.rs (L638-650)
```rust
                        let unique_txns = if let Some(ref txn_summaries) = item.txn_summaries {
                            cur_unique_txns
                                + txn_summaries
                                    .iter()
                                    .filter(|txn_summary| {
                                        !filtered_txns.contains(txn_summary)
                                            && block_timestamp.as_secs()
                                                < txn_summary.expiration_timestamp_secs
                                    })
                                    .count() as u64
                        } else {
                            cur_unique_txns + batch.num_txns()
                        };
```

**File:** consensus/src/quorum_store/batch_proof_queue.rs (L661-673)
```rust
                        cur_unique_txns +=
                            item.txn_summaries
                                .as_ref()
                                .map_or(batch.num_txns(), |summaries| {
                                    summaries
                                        .iter()
                                        .filter(|summary| {
                                            filtered_txns.insert(**summary)
                                                && block_timestamp.as_secs()
                                                    < summary.expiration_timestamp_secs
                                        })
                                        .count() as u64
                                });
```
