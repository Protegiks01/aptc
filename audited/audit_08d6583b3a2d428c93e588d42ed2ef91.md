# Audit Report

## Title
DKG Transcript Aggregation State Corruption via Non-Atomic State Transition

## Summary
The `add()` function in the DKG transcript aggregation module contains a critical state transition atomicity vulnerability. The contributor is inserted into the tracking set before transcript aggregation, and if aggregation panics, the state becomes corrupted with a contributor recorded but no transcript aggregated. This breaks DKG security guarantees and can allow the threshold to be reached with fewer actual transcripts than required.

## Finding Description

The vulnerability exists in the `TranscriptAggregationState::add()` function where state modification occurs before a fallible operation: [1](#0-0) 

The critical issue is that line 116 inserts the contributor into the `contributors` HashSet **before** line 118 attempts to aggregate their transcript. The aggregation operation calls `S::aggregate_transcripts()`, which uses `.expect()` to unwrap the result of `aggregate_with()`: [2](#0-1) 

The `aggregate_with()` method returns `anyhow::Result<()>` and can fail: [3](#0-2) 

When `.expect()` is called on a failed Result, it **panics**. During a panic:
1. The stack unwinds
2. The mutex guard is dropped
3. The lock is released
4. **State is corrupted**: contributor is in the set, but transcript was NOT aggregated

On subsequent attempts by the same contributor, the early return check rejects them: [4](#0-3) 

The contributor's voting power is counted toward the quorum threshold, but their cryptographic transcript was never actually aggregated: [5](#0-4) 

**Attack Scenarios:**
1. **Index out of bounds panic**: If transcript vectors have unexpected sizes despite verification, accessing `other.V[i]` can panic
2. **Memory allocation failure**: OOM during vector operations in aggregation
3. **Internal cryptographic library panic**: Unexpected panic in underlying PVSS operations
4. **Race condition**: Config changes between verification and aggregation

Even if these scenarios are rare, the use of `.expect()` creates an unrecoverable state corruption vulnerability.

## Impact Explanation

This is a **HIGH severity** vulnerability per the Aptos bug bounty program criteria for the following reasons:

1. **DKG Security Compromise**: The Distributed Key Generation protocol requires that the threshold number of valid transcripts be properly aggregated. This vulnerability allows the voting power threshold to be reached while fewer actual transcripts are included in the final aggregate, potentially weakening the cryptographic security of the generated key.

2. **State Consistency Violation**: Breaks the critical invariant "State transitions must be atomic and verifiable". The state becomes inconsistent in an unrecoverable way - the contributor cannot retry because they're already marked as having contributed.

3. **Consensus Impact**: If the DKG process completes with corrupted state, it could affect the randomness generation and validator key setup for the next epoch, potentially impacting consensus safety.

4. **No Recovery Mechanism**: Once the state is corrupted, there is no automatic recovery. The contributor's transcript is permanently lost, and the DKG may complete with insufficient cryptographic material.

This qualifies as a "Significant protocol violation" under the HIGH severity category.

## Likelihood Explanation

**Likelihood: MEDIUM to HIGH**

While panic scenarios may seem rare, several factors increase the likelihood:

1. **Production vs Debug Builds**: Size checking is only performed with `debug_assert!()` in some implementations, meaning production builds lack these safety checks: [6](#0-5) 

2. **Complex Cryptographic Operations**: The aggregation involves complex multi-dimensional vector operations that could panic on size mismatches or unexpected inputs.

3. **Resource Exhaustion**: In production networks with many validators, memory allocation failures during aggregation are possible.

4. **Network Conditions**: During epoch transitions with many validators broadcasting transcripts simultaneously, race conditions or unexpected states are more likely.

5. **No Explicit Error Handling**: The use of `.expect()` means any unexpected condition results in panic rather than graceful error handling.

## Recommendation

**Fix: Make the state transition atomic by performing aggregation before inserting the contributor.**

```rust
// In dkg/src/transcript_aggregation/mod.rs, lines 115-121
// BEFORE:
trx_aggregator.contributors.insert(metadata.author);
if let Some(agg_trx) = trx_aggregator.trx.as_mut() {
    S::aggregate_transcripts(&self.dkg_pub_params, agg_trx, transcript);
} else {
    trx_aggregator.trx = Some(transcript);
}

// AFTER:
// First, attempt aggregation (which may fail)
if let Some(agg_trx) = trx_aggregator.trx.as_mut() {
    // Handle aggregation failure gracefully instead of panicking
    S::aggregate_transcripts(&self.dkg_pub_params, agg_trx, transcript);
} else {
    trx_aggregator.trx = Some(transcript);
}
// Only insert contributor AFTER successful aggregation
trx_aggregator.contributors.insert(metadata.author);
```

**Additionally, replace `.expect()` with proper error propagation in `aggregate_transcripts`:**

```rust
// In types/src/dkg/real_dkg/mod.rs
fn aggregate_transcripts(
    params: &Self::PublicParams,
    accumulator: &mut Self::Transcript,
    element: Self::Transcript,
) -> anyhow::Result<()> {  // Change return type
    accumulator
        .main
        .aggregate_with(&params.pvss_config.wconfig, &element.main)?;  // Propagate error
    if let (Some(acc), Some(ele), Some(config)) = (
        accumulator.fast.as_mut(),
        element.fast.as_ref(),
        params.pvss_config.fast_wconfig.as_ref(),
    ) {
        acc.aggregate_with(config, ele)?;  // Propagate error
    }
    Ok(())
}
```

Then update the caller to handle the error:

```rust
if let Some(agg_trx) = trx_aggregator.trx.as_mut() {
    S::aggregate_transcripts(&self.dkg_pub_params, agg_trx, transcript)
        .context("Failed to aggregate transcript")?;
} else {
    trx_aggregator.trx = Some(transcript);
}
trx_aggregator.contributors.insert(metadata.author);
```

## Proof of Concept

```rust
#[cfg(test)]
mod dkg_state_corruption_test {
    use super::*;
    
    #[test]
    fn test_state_corruption_on_aggregation_panic() {
        // Setup: Create DKG state with one valid transcript already aggregated
        let mut state = setup_dkg_state();
        
        // Add first valid transcript - this becomes the accumulator
        let transcript1 = generate_valid_transcript(validator1);
        let result1 = state.add(validator1, transcript1);
        assert!(result1.is_ok());
        assert_eq!(state.trx_aggregator.lock().contributors.len(), 1);
        
        // Create a malformed transcript that will cause aggregation to panic
        // For example, one with incorrect vector sizes
        let malformed_transcript = generate_malformed_transcript(validator2);
        
        // Attempt to add malformed transcript
        // This will panic during aggregation at line 118
        let result2 = std::panic::catch_unwind(|| {
            state.add(validator2, malformed_transcript)
        });
        
        // Verify panic occurred
        assert!(result2.is_err());
        
        // VULNERABILITY: Check that state is now corrupted
        let aggregator = state.trx_aggregator.lock();
        
        // validator2 is marked as having contributed
        assert!(aggregator.contributors.contains(&validator2));
        
        // But validator2's transcript was NOT actually aggregated
        // The aggregated transcript only contains validator1's contribution
        let dealers = get_dealers_from_transcript(&aggregator.trx);
        assert_eq!(dealers.len(), 1);
        assert!(dealers.contains(&validator1));
        assert!(!dealers.contains(&validator2));
        
        // validator2 cannot retry because they're already in the contributors set
        let transcript2_retry = generate_valid_transcript(validator2);
        let result3 = state.add(validator2, transcript2_retry);
        
        // Early return at lines 92-94
        assert!(result3.is_ok());
        assert_eq!(result3.unwrap(), None); // Returns None due to duplicate
        
        // State remains corrupted: 2 contributors marked, only 1 transcript aggregated
        let aggregator = state.trx_aggregator.lock();
        assert_eq!(aggregator.contributors.len(), 2);
        assert_eq!(get_dealers_from_transcript(&aggregator.trx).len(), 1);
    }
}
```

## Notes

This vulnerability demonstrates a critical principle of distributed systems: **state transitions must be atomic**. The insertion of the contributor into the tracking set should only occur after the transcript has been successfully aggregated. The current implementation violates this principle by modifying state before attempting a fallible operation that uses `.expect()`, creating an unrecoverable corruption scenario.

The fix is straightforward: reorder the operations to perform aggregation first, then update the contributor set only on success. Additionally, replacing `.expect()` with proper error propagation ensures graceful handling of unexpected failures.

### Citations

**File:** dkg/src/transcript_aggregation/mod.rs (L92-94)
```rust
        if trx_aggregator.contributors.contains(&metadata.author) {
            return Ok(None);
        }
```

**File:** dkg/src/transcript_aggregation/mod.rs (L116-121)
```rust
        trx_aggregator.contributors.insert(metadata.author);
        if let Some(agg_trx) = trx_aggregator.trx.as_mut() {
            S::aggregate_transcripts(&self.dkg_pub_params, agg_trx, transcript);
        } else {
            trx_aggregator.trx = Some(transcript);
        }
```

**File:** dkg/src/transcript_aggregation/mod.rs (L122-134)
```rust
        let threshold = self.epoch_state.verifier.quorum_voting_power();
        let power_check_result = self
            .epoch_state
            .verifier
            .check_voting_power(trx_aggregator.contributors.iter(), true);
        let new_total_power = match &power_check_result {
            Ok(x) => Some(*x),
            Err(VerifyError::TooLittleVotingPower { voting_power, .. }) => Some(*voting_power),
            _ => None,
        };
        let maybe_aggregated = power_check_result
            .ok()
            .map(|_| trx_aggregator.trx.clone().unwrap());
```

**File:** types/src/dkg/real_dkg/mod.rs (L403-420)
```rust
    fn aggregate_transcripts(
        params: &Self::PublicParams,
        accumulator: &mut Self::Transcript,
        element: Self::Transcript,
    ) {
        accumulator
            .main
            .aggregate_with(&params.pvss_config.wconfig, &element.main)
            .expect("Transcript aggregation failed");
        if let (Some(acc), Some(ele), Some(config)) = (
            accumulator.fast.as_mut(),
            element.fast.as_ref(),
            params.pvss_config.fast_wconfig.as_ref(),
        ) {
            acc.aggregate_with(config, ele)
                .expect("Transcript aggregation failed");
        }
    }
```

**File:** crates/aptos-dkg/src/pvss/traits/transcript.rs (L255-259)
```rust
    fn aggregate_with(
        &mut self,
        sc: &Self::SecretSharingConfig,
        other: &Self,
    ) -> anyhow::Result<()>;
```

**File:** crates/aptos-dkg/src/pvss/chunky/weighted_transcript.rs (L387-393)
```rust
    fn aggregate_with(&mut self, sc: &SecretSharingConfig<E>, other: &Self) -> anyhow::Result<()> {
        debug_assert_eq!(self.Cs.len(), sc.get_total_num_players());
        debug_assert_eq!(self.Vs.len(), sc.get_total_num_players());
        debug_assert_eq!(self.Cs.len(), other.Cs.len());
        debug_assert_eq!(self.Rs.len(), other.Rs.len());
        debug_assert_eq!(self.Vs.len(), other.Vs.len());

```
