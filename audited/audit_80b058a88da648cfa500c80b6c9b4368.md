# Audit Report

## Title
Consensus Observer DoS via Unverified Epoch Extraction in CommitDecision Messages

## Summary
The consensus observer processes `CommitDecision` messages by extracting epoch and round values from the embedded `LedgerInfoWithSignatures` before verifying cryptographic signatures. When receiving messages with future epoch values, the node bypasses signature verification entirely, updates its root state to unverified data, and enters expensive state sync operations targeting non-existent epochs, resulting in resource exhaustion and denial of service.

## Finding Description

The vulnerability exists in the `process_commit_decision_message` function where epoch and round values are extracted and used to make critical state decisions before signature verification occurs. [1](#0-0) 

The `epoch()` method directly extracts the epoch value from the unverified `LedgerInfoWithSignatures` by calling through to the underlying `LedgerInfo`: [2](#0-1) 

The code then uses this unverified epoch value to determine whether to drop the message: [3](#0-2) 

Critically, the code only verifies signatures when the commit decision is for the **current** epoch: [4](#0-3) 

However, if the unverified epoch is **higher** than the current epoch, the code bypasses verification entirely and proceeds to update state and trigger synchronization. Note the TODO comment explicitly acknowledging this gap: [5](#0-4) 

The `update_blocks_for_state_sync_commit` function updates the node's root ledger info to the unverified commit proof: [6](#0-5) 

This calls `update_root` which directly replaces the root with unverified data: [7](#0-6) 

**Attack Scenario:**
1. A malicious or compromised validator (< 1/3 Byzantine, within threat model) crafts a `CommitDecision` with epoch = 999999 and invalid signatures
2. Sends the message to consensus observer nodes subscribed to it
3. Observer extracts epoch 999999 without verification
4. Observer compares 999999 > current_epoch â†’ bypasses signature verification
5. Observer updates its root ledger info to the unverified value
6. Observer triggers expensive state sync operations to epoch 999999
7. Observer wastes resources attempting to sync to a non-existent epoch
8. Observer cannot process legitimate consensus messages during this time

## Impact Explanation

This vulnerability qualifies as **Medium to High Severity** under Aptos bug bounty criteria:

**Severity Assessment:**
- **State corruption**: The node's root ledger info is updated with cryptographically unverified data, violating the fundamental security invariant that all ledger info must pass signature verification before acceptance
- **Resource exhaustion**: State sync operations consume CPU, memory, and network bandwidth while making no progress toward a non-existent epoch
- **Consensus observer denial of service**: While attempting to sync to an invalid target, the observer cannot process legitimate consensus messages, effectively removing it from the observer pool
- **Limited to observer nodes**: This affects Validator Fullnodes (VFNs) and Public Fullnodes (PFNs) running consensus observer, not validator consensus directly

The vulnerability does not reach Critical severity because:
- No funds are directly lost or stolen
- Validator consensus itself is not broken (only observer nodes affected)
- Recovery is possible by restarting the affected node
- No permanent state corruption requiring hardfork

**Impact Classification:** Medium severity (state inconsistencies requiring manual intervention, temporary liveness issues for observer infrastructure) with potential for High severity if VFNs are considered critical infrastructure for network usability.

## Likelihood Explanation

This vulnerability has **High likelihood** of exploitation:

**Attacker Requirements:**
- Control or compromise of a single validator that observer nodes subscribe to (< 1/3 Byzantine validators, which is within Aptos threat model)
- Ability to craft a `CommitDecision` message with arbitrary epoch and invalid signatures
- No majority stake or consensus compromise required

**Attack Complexity:**
- Low complexity - straightforward message construction
- Deterministic outcome - attack succeeds reliably when conditions are met
- No timing requirements or race conditions
- Can target multiple observer nodes simultaneously

**Detection:**
- Malicious messages may appear similar to legitimate future-epoch messages initially
- Logs will show failed state sync attempts to impossible epochs
- Requires manual intervention to identify and recover

## Recommendation

Implement signature verification for all commit decisions regardless of epoch:

```rust
fn process_commit_decision_message(
    &mut self,
    peer_network_id: PeerNetworkId,
    message_received_time: Instant,
    commit_decision: CommitDecision,
) {
    // Get the commit decision epoch and round
    let commit_epoch = commit_decision.epoch();
    let commit_round = commit_decision.round();

    // Drop messages behind our highest committed block
    let highest_committed = self.observer_block_data.lock().get_highest_committed_epoch_round();
    if (commit_epoch, commit_round) <= highest_committed {
        update_metrics_for_dropped_commit_decision_message(peer_network_id, &commit_decision);
        return;
    }

    // Update metrics
    update_metrics_for_commit_decision_message(peer_network_id, &commit_decision);

    // ALWAYS verify the commit proof before using it, regardless of epoch
    let epoch_state = self.get_epoch_state();
    
    // For future epochs, we need to obtain the correct epoch state first
    // or verify using the embedded epoch change proof if available
    if commit_epoch > epoch_state.epoch {
        // Verify using epoch change proof or reject if unavailable
        if let Err(error) = self.verify_future_epoch_commit(&commit_decision) {
            error!(LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                "Failed to verify future epoch commit decision! Ignoring: {:?}. Error: {:?}",
                commit_decision.proof_block_info(), error
            )));
            increment_invalid_message_counter(&peer_network_id, metrics::COMMIT_DECISION_LABEL);
            return;
        }
    } else {
        // Current epoch verification (existing code)
        if let Err(error) = commit_decision.verify_commit_proof(&epoch_state) {
            error!(LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                "Failed to verify commit decision! Ignoring: {:?}. Error: {:?}",
                commit_decision.proof_block_info(), error
            )));
            increment_invalid_message_counter(&peer_network_id, metrics::COMMIT_DECISION_LABEL);
            return;
        }
    }

    // Continue with processing only after verification succeeds
    // ...
}
```

Alternative approach: Require state sync to obtain and verify the new epoch state before accepting any commit decisions for future epochs.

## Proof of Concept

The vulnerability can be demonstrated by:

1. Creating a `LedgerInfoWithSignatures` with a far-future epoch and empty/invalid signatures:
```rust
let future_epoch = 999999;
let malicious_ledger_info = LedgerInfoWithSignatures::new(
    LedgerInfo::new(
        BlockInfo::random_with_epoch(future_epoch, 0),
        HashValue::random(),
    ),
    AggregateSignature::empty(), // Invalid signatures
);
```

2. Wrapping it in a `CommitDecision`:
```rust
let commit_decision = CommitDecision::new(malicious_ledger_info);
```

3. Sending it to a consensus observer from a subscribed validator peer

4. Observing that the observer:
   - Extracts the epoch value (999999) without verification
   - Bypasses signature verification due to future epoch check
   - Updates its root ledger info to the unverified value
   - Triggers state sync to an impossible target
   - Enters a resource-exhaustive state unable to recover without restart

## Notes

**Critical Security Invariant Violated:** The code violates the invariant that cryptographic verification must precede state updates. The TODO comment at lines 497-498 explicitly acknowledges this design gap but does not prevent exploitation.

**Affected Components:** Consensus observer nodes (Validator Fullnodes and Public Fullnodes) that subscribe to consensus publishers. Validator consensus itself is not directly affected.

**Threat Model:** The attack requires a single malicious or compromised validator (< 1/3 Byzantine), which is explicitly within Aptos threat model. This is NOT a network-level DoS attack but a protocol-level validation bypass.

**Recovery:** Affected nodes can recover by restarting, but repeated attacks can prevent sustained operation.

### Citations

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L449-450)
```rust
        let commit_epoch = commit_decision.epoch();
        let commit_round = commit_decision.round();
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L453-461)
```rust
        let get_highest_committed_epoch_round = self
            .observer_block_data
            .lock()
            .get_highest_committed_epoch_round();
        if (commit_epoch, commit_round) <= get_highest_committed_epoch_round {
            // Update the metrics for the dropped commit decision
            update_metrics_for_dropped_commit_decision_message(peer_network_id, &commit_decision);
            return;
        }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L467-495)
```rust
        let epoch_state = self.get_epoch_state();
        if commit_epoch == epoch_state.epoch {
            // Verify the commit decision
            if let Err(error) = commit_decision.verify_commit_proof(&epoch_state) {
                // Log the error and update the invalid message counter
                error!(
                    LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                        "Failed to verify commit decision! Ignoring: {:?}, from peer: {:?}. Error: {:?}",
                        commit_decision.proof_block_info(),
                        peer_network_id,
                        error
                    ))
                );
                increment_invalid_message_counter(&peer_network_id, metrics::COMMIT_DECISION_LABEL);
                return;
            }

            // Update the latency metrics for commit processing
            update_message_processing_latency_metrics(
                message_received_time,
                &peer_network_id,
                metrics::COMMIT_DECISION_LABEL,
            );

            // Update the pending blocks with the commit decision
            if self.process_commit_decision_for_pending_block(&commit_decision) {
                return; // The commit decision was successfully processed
            }
        }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L497-527)
```rust
        // TODO: identify the best way to handle an invalid commit decision
        // for a future epoch. In such cases, we currently rely on state sync.

        // Otherwise, we failed to process the commit decision. If the commit
        // is for a future epoch or round, we need to state sync.
        let last_block = self.observer_block_data.lock().get_last_ordered_block();
        let epoch_changed = commit_epoch > last_block.epoch();
        if epoch_changed || commit_round > last_block.round() {
            // If we're waiting for state sync to transition into a new epoch,
            // we should just wait and not issue a new state sync request.
            if self.state_sync_manager.is_syncing_through_epoch() {
                info!(
                    LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                        "Already waiting for state sync to reach new epoch: {:?}. Dropping commit decision: {:?}!",
                        self.observer_block_data.lock().root().commit_info(),
                        commit_decision.proof_block_info()
                    ))
                );
                return;
            }

            // Otherwise, we should start the state sync process for the commit.
            // Update the block data (to the commit decision).
            self.observer_block_data
                .lock()
                .update_blocks_for_state_sync_commit(&commit_decision);

            // Start state syncing to the commit decision
            self.state_sync_manager
                .sync_to_commit(commit_decision, epoch_changed);
        }
```

**File:** consensus/src/consensus_observer/network/observer_message.rs (L352-354)
```rust
    pub fn epoch(&self) -> u64 {
        self.commit_proof.ledger_info().epoch()
    }
```

**File:** consensus/src/consensus_observer/observer/block_data.rs (L275-291)
```rust
    pub fn update_blocks_for_state_sync_commit(&mut self, commit_decision: &CommitDecision) {
        // Get the commit proof, epoch and round
        let commit_proof = commit_decision.commit_proof();
        let commit_epoch = commit_decision.epoch();
        let commit_round = commit_decision.round();

        // Update the root
        self.update_root(commit_proof.clone());

        // Update the block payload store
        self.block_payload_store
            .remove_blocks_for_epoch_round(commit_epoch, commit_round);

        // Update the ordered block store
        self.ordered_block_store
            .remove_blocks_for_commit(commit_proof);
    }
```

**File:** consensus/src/consensus_observer/observer/block_data.rs (L299-302)
```rust
    /// Updates the root ledger info
    pub fn update_root(&mut self, new_root: LedgerInfoWithSignatures) {
        self.root = new_root;
    }
```
