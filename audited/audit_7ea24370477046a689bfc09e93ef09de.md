# Audit Report

## Title
Consensus Key Reuse Enables Voting Power Manipulation Through Missing Runtime Duplicate Key Validation

## Summary
The Aptos blockchain lacks runtime validation to prevent duplicate consensus public keys across validators. While genesis-time validation exists, validators can rotate their consensus keys to match another validator's key during runtime, enabling voting power manipulation and potential consensus safety violations.

## Finding Description

The vulnerability exists across multiple components:

**1. Missing Runtime Duplicate Key Validation**

At genesis, the system validates that consensus keys are unique: [1](#0-0) 

However, during runtime operations, there is NO equivalent validation when:
- Validators rotate their consensus keys via `rotate_consensus_key()`: [2](#0-1) 

- The validator set is updated during epoch transitions: [3](#0-2) 

**2. Vote Collection by Address, Not Public Key**

The consensus layer tracks votes by validator address rather than by public key or signature: [4](#0-3) 

This means if two validators share the same consensus key, their votes are treated as separate based on their addresses, not their cryptographic identity.

**3. BLS Signature Aggregation Vulnerability**

When votes are aggregated, the system collects signatures and public keys based on validator indices: [5](#0-4) 

Due to BLS signature aggregation properties, if two validators (A and B) share the same public key PK and private key SK:
- Validator A signs: `sig = Sign(message, SK)`
- This signature is valid for public key PK
- If both validators' signatures are aggregated: `aggregate([sig, sig])`
- And both public keys are aggregated: `aggregate([PK, PK])`
- The verification succeeds due to BLS bilinearity: `verify(aggregate([sig, sig]), message, aggregate([PK, PK]))` returns true

**Attack Scenario:**

1. Two validators (either through collusion, misconfiguration, or malicious rotation) end up with identical consensus keys after an epoch transition
2. Validator A creates a legitimate vote with signature S
3. The same signature S is submitted as a vote from Validator B (since B has the same key, the signature is cryptographically valid for B's public key)
4. Both votes are accepted by the pending votes tracker (different addresses)
5. During signature aggregation, both signatures and public keys are aggregated
6. The aggregated signature verification passes
7. **Result**: A single validator's vote is counted twice, effectively doubling their voting power

## Impact Explanation

This is a **Medium Severity** vulnerability because:

1. **Consensus Safety Violation**: The issue violates the "Consensus Safety" invariant - validators with <2f+1 voting power could achieve quorum by duplicating their votes through key reuse
2. **Voting Power Manipulation**: Enables artificial inflation of voting power without corresponding stake
3. **State Inconsistencies**: Could lead to conflicting validator set states requiring manual intervention
4. **Byzantine Fault Tolerance Reduction**: The actual BFT threshold decreases if keys are reused, as validators can effectively control multiple "identities"

Per Aptos bug bounty criteria, this qualifies as Medium severity: "State inconsistencies requiring intervention" and potential for "Limited... manipulation" of voting power.

## Likelihood Explanation

The likelihood is **Medium-to-Low** because:

**Required Preconditions:**
1. Validators must have identical consensus keys (requires either malicious rotation, collusion, or accidental misconfiguration)
2. Requires validator operator privileges to rotate keys

**Mitigating Factors:**
- Validators are trusted actors in the Aptos model
- Proof-of-possession validation prevents some forms of key manipulation
- Genesis validation prevents initial key duplication

**Risk Factors:**
- No runtime enforcement of key uniqueness
- No monitoring or alerting for duplicate keys
- Cryptographically valid if preconditions are met

## Recommendation

Implement runtime duplicate consensus key validation in multiple layers:

**1. Add validation in `rotate_consensus_key`:**
```move
// In stake.move, after line 932
// Check that new_consensus_pubkey is not already used by another validator
let validator_set = borrow_global<ValidatorSet>(@aptos_framework);
vector::for_each_ref(&validator_set.active_validators, |validator| {
    let v: &ValidatorInfo = validator;
    if (v.addr != pool_address) {
        let other_config = borrow_global<ValidatorConfig>(v.addr);
        assert!(
            other_config.consensus_pubkey != new_consensus_pubkey,
            error::invalid_argument(EDUPLICATE_CONSENSUS_KEY)
        );
    }
});
// Also check pending_active validators
vector::for_each_ref(&validator_set.pending_active, |validator| {
    // Similar check
});
```

**2. Add validation in `on_new_epoch`:**
```move
// In stake.move, after generating new_validator_info (line 1388)
// Verify no duplicate consensus keys in the new validator set
let seen_keys = vector::empty<vector<u8>>();
// Check each validator's key against previously seen keys
// Fail epoch transition if duplicates detected
```

**3. Add Rust-level validation in ValidatorVerifier construction:**
```rust
// In types/src/validator_verifier.rs, in build_index function
let mut seen_keys = HashSet::new();
for info in &validator_infos {
    if !seen_keys.insert(info.public_key.clone()) {
        return Err(anyhow!("Duplicate consensus public key detected"));
    }
}
```

## Proof of Concept

```move
// Move test demonstrating the vulnerability
#[test(framework = @0x1, validator1 = @0x123, validator2 = @0x456)]
fun test_duplicate_key_voting_power_manipulation(
    framework: &signer,
    validator1: &signer,
    validator2: &signer,
) {
    // Setup: Initialize two validators
    stake::initialize_validator(validator1, consensus_key, proof, network_addr, fullnode_addr);
    stake::initialize_validator(validator2, different_key, proof2, network_addr2, fullnode_addr2);
    
    // Both validators join and epoch changes
    stake::join_validator_set(validator1, addr1);
    stake::join_validator_set(validator2, addr2);
    reconfiguration::reconfigure();
    
    // EXPLOIT: Validator2 rotates their key to match Validator1's key
    stake::rotate_consensus_key(validator2_operator, addr2, consensus_key, proof);
    reconfiguration::reconfigure(); // Trigger epoch change
    
    // Now both validators have the same consensus key
    // In consensus, a single signature from validator1 can be counted twice:
    // - Once for validator1's address
    // - Once for validator2's address
    // This doubles validator1's effective voting power
    
    // Verify both validators have the same key
    let validator_set = stake::get_validator_set();
    assert!(validator_set[0].consensus_pubkey == validator_set[1].consensus_pubkey, 0);
}
```

## Notes

While validator operators are considered trusted actors in Aptos's threat model, defense-in-depth principles require the protocol to prevent misconfigurations that could compromise consensus safety. The absence of runtime duplicate key validation creates unnecessary risk, especially considering:

1. Key rotation is a supported operation
2. Multiple validator operators may use shared key management infrastructure
3. Accidental key collisions, while unlikely, have catastrophic consequences
4. The fix is straightforward and adds minimal overhead

The vulnerability demonstrates that key reuse across epochs is currently possible and does create exploitable security weaknesses in the consensus layer.

### Citations

**File:** crates/aptos/src/genesis/mod.rs (L750-758)
```rust
            if !unique_consensus_keys
                .insert(validator.consensus_public_key.as_ref().unwrap().clone())
            {
                errors.push(CliError::UnexpectedError(format!(
                    "Validator {} has a repeated a consensus public key {}",
                    name,
                    validator.consensus_public_key.as_ref().unwrap()
                )));
            }
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L909-952)
```text
    /// Rotate the consensus key of the validator, it'll take effect in next epoch.
    public entry fun rotate_consensus_key(
        operator: &signer,
        pool_address: address,
        new_consensus_pubkey: vector<u8>,
        proof_of_possession: vector<u8>,
    ) acquires StakePool, ValidatorConfig {
        check_stake_permission(operator);
        assert_reconfig_not_in_progress();
        assert_stake_pool_exists(pool_address);

        let stake_pool = borrow_global_mut<StakePool>(pool_address);
        assert!(signer::address_of(operator) == stake_pool.operator_address, error::unauthenticated(ENOT_OPERATOR));

        assert!(exists<ValidatorConfig>(pool_address), error::not_found(EVALIDATOR_CONFIG));
        let validator_info = borrow_global_mut<ValidatorConfig>(pool_address);
        let old_consensus_pubkey = validator_info.consensus_pubkey;
        // Checks the public key has a valid proof-of-possession to prevent rogue-key attacks.
        let pubkey_from_pop = &bls12381::public_key_from_bytes_with_pop(
            new_consensus_pubkey,
            &proof_of_possession_from_bytes(proof_of_possession)
        );
        assert!(option::is_some(pubkey_from_pop), error::invalid_argument(EINVALID_PUBLIC_KEY));
        validator_info.consensus_pubkey = new_consensus_pubkey;

        if (std::features::module_event_migration_enabled()) {
            event::emit(
                RotateConsensusKey {
                    pool_address,
                    old_consensus_pubkey,
                    new_consensus_pubkey,
                },
            );
        } else {
            event::emit_event(
                &mut stake_pool.rotate_consensus_key_events,
                RotateConsensusKeyEvent {
                    pool_address,
                    old_consensus_pubkey,
                    new_consensus_pubkey,
                },
            );
        };
    }
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1369-1398)
```text
        // Update active validator set so that network address/public key change takes effect.
        // Moreover, recalculate the total voting power, and deactivate the validator whose
        // voting power is less than the minimum required stake.
        let next_epoch_validators = vector::empty();
        let (minimum_stake, _) = staking_config::get_required_stake(&config);
        let vlen = vector::length(&validator_set.active_validators);
        let total_voting_power = 0;
        let i = 0;
        while ({
            spec {
                invariant spec_validators_are_initialized(next_epoch_validators);
                invariant i <= vlen;
            };
            i < vlen
        }) {
            let old_validator_info = vector::borrow_mut(&mut validator_set.active_validators, i);
            let pool_address = old_validator_info.addr;
            let validator_config = borrow_global<ValidatorConfig>(pool_address);
            let stake_pool = borrow_global<StakePool>(pool_address);
            let new_validator_info = generate_validator_info(pool_address, stake_pool, *validator_config);

            // A validator needs at least the min stake required to join the validator set.
            if (new_validator_info.voting_power >= minimum_stake) {
                spec {
                    assume total_voting_power + new_validator_info.voting_power <= MAX_U128;
                };
                total_voting_power = total_voting_power + (new_validator_info.voting_power as u128);
                vector::push_back(&mut next_epoch_validators, new_validator_info);
            };
            i = i + 1;
```

**File:** consensus/src/pending_votes.rs (L287-309)
```rust
        if let Some((previously_seen_vote, previous_li_digest)) =
            self.author_to_vote.get(&vote.author())
        {
            // is it the same vote?
            if &li_digest == previous_li_digest {
                // we've already seen an equivalent vote before
                let new_timeout_vote = vote.is_timeout() && !previously_seen_vote.is_timeout();
                if !new_timeout_vote {
                    // it's not a new timeout vote
                    return VoteReceptionResult::DuplicateVote;
                }
            } else {
                // we have seen a different vote for the same round
                error!(
                    SecurityEvent::ConsensusEquivocatingVote,
                    remote_peer = vote.author(),
                    vote = vote,
                    previous_vote = previously_seen_vote
                );

                return VoteReceptionResult::EquivocateVote;
            }
        }
```

**File:** types/src/validator_verifier.rs (L345-386)
```rust
    pub fn verify_multi_signatures<T: CryptoHash + Serialize>(
        &self,
        message: &T,
        multi_signature: &AggregateSignature,
    ) -> std::result::Result<(), VerifyError> {
        // Verify the number of signature is not greater than expected.
        Self::check_num_of_voters(self.len() as u16, multi_signature.get_signers_bitvec())?;
        let mut pub_keys = vec![];
        let mut authors = vec![];
        for index in multi_signature.get_signers_bitvec().iter_ones() {
            let validator = self
                .validator_infos
                .get(index)
                .ok_or(VerifyError::UnknownAuthor)?;
            authors.push(validator.address);
            pub_keys.push(validator.public_key());
        }
        // Verify the quorum voting power of the authors
        self.check_voting_power(authors.iter(), true)?;
        #[cfg(any(test, feature = "fuzzing"))]
        {
            if self.quorum_voting_power == 0 {
                // This should happen only in case of tests.
                // TODO(skedia): Clean up the test behaviors to not rely on empty signature
                // verification
                return Ok(());
            }
        }
        // Verify empty multi signature
        let multi_sig = multi_signature
            .sig()
            .as_ref()
            .ok_or(VerifyError::EmptySignature)?;
        // Verify the optimistically aggregated signature.
        let aggregated_key =
            PublicKey::aggregate(pub_keys).map_err(|_| VerifyError::FailedToAggregatePubKey)?;

        multi_sig
            .verify(message, &aggregated_key)
            .map_err(|_| VerifyError::InvalidMultiSignature)?;
        Ok(())
    }
```
