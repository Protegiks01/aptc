# Audit Report

## Title
Silent Consensus Message Drops Due to Protocol Mismatch Leading to Liveness Failure

## Summary
When all preferred consensus protocols fail to match with a connected peer's supported protocols, the system silently drops messages to that peer without error propagation, potentially causing consensus liveness failure if affecting a quorum of validators.

## Finding Description

The Aptos consensus network layer implements protocol negotiation during connection handshake, where peers exchange and agree upon common application protocols. [1](#0-0) 

However, a critical gap exists between handshake-level protocol negotiation and application-level protocol selection. The handshake succeeds if peers share **any** common protocol (e.g., `HealthCheckerRpc`, `MempoolDirectSend`), not necessarily consensus-specific protocols. [2](#0-1) 

When consensus attempts to send messages, it queries for a preferred protocol through `get_preferred_protocol_for_peer`, which iterates through consensus-specific protocols in priority order. [3](#0-2) 

If no consensus protocol matches, the function returns an error. However, in `send_to_peers` via `group_peers_by_protocol`, this error is **silently handled** - peers without matching protocols are merely logged with a sampled warning and excluded from message delivery. [4](#0-3) 

The consensus layer never receives notification that messages weren't delivered. In `broadcast_without_self`, send errors are only logged without propagation. [5](#0-4) 

**Attack Scenario:**
1. During a rolling upgrade or configuration change, validators become deployed with incompatible consensus protocol configurations
2. Validators successfully handshake (sharing non-consensus protocols)  
3. Consensus messages are silently dropped for affected peers
4. If f+1 validators are affected, quorum (2f+1) cannot be achieved
5. Consensus rounds timeout indefinitely - **liveness failure**

## Impact Explanation

This qualifies as **Medium Severity** per Aptos bug bounty criteria:
- **State inconsistencies requiring intervention**: Consensus cannot progress, requiring manual reconfiguration and restarts
- Does not qualify as Critical (no fund loss, safety maintained)
- More severe than Low (affects core consensus functionality)

The impact is limited because:
- Requires deployment/configuration issues (not remotely exploitable)
- Safety is preserved (no double-spending or chain forks)
- Only affects liveness, not safety
- Operators can diagnose via logs (though not immediately obvious)

## Likelihood Explanation

**Likelihood: Low-Medium** in production, but **realistic** in these scenarios:

1. **Rolling Upgrades**: Version N+1 deprecates old protocols while validators still run version N
2. **Configuration Drift**: Validator operators customize protocol configurations differently
3. **Incomplete Deployments**: Network-wide protocol changes deployed to only subset of validators

The vulnerability requires operational errors rather than malicious exploitation, but such errors are realistic in distributed validator networks with independent operators.

## Recommendation

Implement multi-layered safeguards:

1. **Pre-Handshake Protocol Validation**: After successful handshake, verify consensus-specific protocol compatibility before marking peer as "available":

```rust
// In network/framework/src/application/interface.rs
fn validate_application_protocols(&self, peer: &PeerNetworkId) -> Result<(), Error> {
    let consensus_protocols = &self.direct_send_protocols_and_preferences;
    let has_consensus_protocol = self
        .get_preferred_protocol_for_peer(peer, consensus_protocols)
        .is_ok();
    
    if !has_consensus_protocol {
        return Err(Error::NetworkError(format!(
            "Peer {:?} lacks required application protocols", peer
        )));
    }
    Ok(())
}
```

2. **Error Propagation**: Modify `send_to_peers` to return error when critical peers are excluded:

```rust
// Return error if any peer cannot be reached
if !peers_without_a_protocol.is_empty() {
    return Err(Error::NetworkError(format!(
        "Failed to reach peers: {:?}", peers_without_a_protocol
    )));
}
```

3. **Health Monitoring**: Add consensus-specific health checks that verify protocol compatibility periodically and disconnect incompatible peers.

4. **Operational Tooling**: Pre-deployment validation that verifies protocol compatibility across validator set before rolling upgrades.

## Proof of Concept

```rust
// Test demonstrating silent message drop
#[tokio::test]
async fn test_consensus_message_drop_on_protocol_mismatch() {
    use network::protocols::wire::handshake::v1::ProtocolId;
    use network::application::interface::NetworkClient;
    
    // Setup validator A with only compressed protocols
    let validator_a_protocols = vec![
        ProtocolId::ConsensusRpcCompressed,
        ProtocolId::ConsensusDirectSendCompressed,
        ProtocolId::HealthCheckerRpc,  // Common protocol for handshake
    ];
    
    // Setup validator B with only BCS protocols (no compressed)
    let validator_b_protocols = vec![
        ProtocolId::ConsensusRpcBcs,
        ProtocolId::ConsensusDirectSendBcs,
        ProtocolId::HealthCheckerRpc,  // Common protocol for handshake
    ];
    
    // Handshake succeeds (HealthCheckerRpc is common)
    let connection = establish_connection(validator_a_protocols, validator_b_protocols);
    assert!(connection.is_ok(), "Handshake should succeed");
    
    // Create consensus network client for validator A
    let client_a_preferences = vec![
        ProtocolId::ConsensusRpcCompressed,  // Only compressed in preferences
    ];
    let network_client = NetworkClient::new(
        client_a_preferences,
        vec![],
        network_senders,
        peers_and_metadata,
    );
    
    // Attempt to send consensus message
    let peers = vec![validator_b_peer_id];
    let result = network_client.send_to_peers(ConsensusMsg::ProposalMsg(proposal), peers);
    
    // Message send appears successful (no error returned)
    assert!(result.is_ok(), "send_to_peers returns Ok");
    
    // But message was actually dropped (validator B never receives it)
    // This would cause consensus to fail silently
}
```

**Notes:**
- This vulnerability is more of a **robustness/operational issue** than a direct security exploit
- Requires deployment errors or configuration drift rather than malicious attack
- The system works "as designed" but the design lacks adequate safeguards for operational scenarios
- Primary concern is **operational resilience** during upgrades and configuration changes

The root cause is the architectural gap between transport-level handshake (accepting any common protocol) and application-level requirements (needing consensus-specific protocols), combined with insufficient error handling and validation.

### Citations

**File:** network/framework/src/protocols/wire/handshake/v1/mod.rs (L431-465)
```rust
    pub fn perform_handshake(
        &self,
        other: &HandshakeMsg,
    ) -> Result<(MessagingProtocolVersion, ProtocolIdSet), HandshakeError> {
        // verify that both peers are on the same chain
        if self.chain_id != other.chain_id {
            return Err(HandshakeError::InvalidChainId(
                other.chain_id,
                self.chain_id,
            ));
        }

        // verify that both peers are on the same network
        if self.network_id != other.network_id {
            return Err(HandshakeError::InvalidNetworkId(
                other.network_id,
                self.network_id,
            ));
        }

        // find the greatest common MessagingProtocolVersion where we both support
        // at least one common ProtocolId.
        for (our_handshake_version, our_protocols) in self.supported_protocols.iter().rev() {
            if let Some(their_protocols) = other.supported_protocols.get(our_handshake_version) {
                let common_protocols = our_protocols.intersect(their_protocols);

                if !common_protocols.is_empty() {
                    return Ok((*our_handshake_version, common_protocols));
                }
            }
        }

        // no intersection found
        Err(HandshakeError::NoCommonProtocols)
    }
```

**File:** network/framework/src/application/interface.rs (L142-158)
```rust
    fn get_preferred_protocol_for_peer(
        &self,
        peer: &PeerNetworkId,
        preferred_protocols: &[ProtocolId],
    ) -> Result<ProtocolId, Error> {
        let protocols_supported_by_peer = self.get_supported_protocols(peer)?;
        for protocol in preferred_protocols {
            if protocols_supported_by_peer.contains(*protocol) {
                return Ok(*protocol);
            }
        }
        Err(Error::NetworkError(format!(
            "None of the preferred protocols are supported by this peer! \
            Peer: {:?}, supported protocols: {:?}",
            peer, protocols_supported_by_peer
        )))
    }
```

**File:** network/framework/src/application/interface.rs (L160-191)
```rust
    fn group_peers_by_protocol(
        &self,
        peers: Vec<PeerNetworkId>,
    ) -> HashMap<ProtocolId, Vec<PeerNetworkId>> {
        // Sort peers by protocol
        let mut peers_per_protocol = HashMap::new();
        let mut peers_without_a_protocol = vec![];
        for peer in peers {
            match self
                .get_preferred_protocol_for_peer(&peer, &self.direct_send_protocols_and_preferences)
            {
                Ok(protocol) => peers_per_protocol
                    .entry(protocol)
                    .or_insert_with(Vec::new)
                    .push(peer),
                Err(_) => peers_without_a_protocol.push(peer),
            }
        }

        // We only periodically log any unavailable peers (to prevent log spamming)
        if !peers_without_a_protocol.is_empty() {
            sample!(
                SampleRate::Duration(Duration::from_secs(10)),
                warn!(
                    "[sampled] Unavailable peers (without a common network protocol): {:?}",
                    peers_without_a_protocol
                )
            );
        }

        peers_per_protocol
    }
```

**File:** consensus/src/network.rs (L387-408)
```rust
    pub fn broadcast_without_self(&self, msg: ConsensusMsg) {
        fail_point!("consensus::send::any", |_| ());

        let self_author = self.author;
        let mut other_validators: Vec<_> = self
            .validators
            .get_ordered_account_addresses_iter()
            .filter(|author| author != &self_author)
            .collect();
        self.sort_peers_by_latency(&mut other_validators);

        counters::CONSENSUS_SENT_MSGS
            .with_label_values(&[msg.name()])
            .inc_by(other_validators.len() as u64);
        // Broadcast message over direct-send to all other validators.
        if let Err(err) = self
            .consensus_network_client
            .send_to_many(other_validators, msg)
        {
            warn!(error = ?err, "Error broadcasting message");
        }
    }
```
