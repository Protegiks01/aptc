# Audit Report

## Title
Consensus Security Logs Can Be Silently Suppressed Through RUST_LOG Misconfiguration

## Summary
When the `RUST_LOG` environment variable is set with module-specific directives that exclude consensus modules, critical Byzantine fault detection logs are completely suppressed, even at ERROR level. This occurs due to the `Filter::enabled()` function returning `false` when no directives match [1](#0-0) , and the absence of a default catch-all directive when custom module filters are configured [2](#0-1) .

## Finding Description

The logging filter system builds directives from the `RUST_LOG` environment variable [3](#0-2) . When `RUST_LOG` is set to module-specific values (e.g., `RUST_LOG=mempool=info,network=debug`), only those modules receive logging directives. The `build()` method only adds a default `LevelFilter::Error` catch-all directive when `directives.is_empty()` [2](#0-1) . 

During log evaluation, if no directive matches the module path, `Filter::enabled()` returns `false` at line 144, suppressing the log entirely [1](#0-0) .

**Critical Security Logs Affected:**

1. **Equivocating Vote Detection**: When a validator sends conflicting votes for the same round, consensus detects this and attempts to log `SecurityEvent::ConsensusEquivocatingVote` at ERROR level [4](#0-3) 

2. **Multiple Proposal Detection**: When a validator proposes multiple blocks in a single round, this Byzantine behavior triggers `SecurityEvent::InvalidConsensusProposal` logging [5](#0-4) 

3. **Invalid Message Detection**: Invalid consensus messages trigger `SecurityEvent::ConsensusInvalidMessage` [6](#0-5) 

**Exploitation Scenario:**

1. Operator sets `RUST_LOG=mempool=debug,aptos_vm=info` for debugging a transaction pool issue [7](#0-6) 
2. A malicious validator begins sending equivocating votes
3. The consensus module detects the equivocation and attempts to log at ERROR level
4. The filter checks: `"consensus::pending_votes".starts_with("mempool")` → false, `"consensus::pending_votes".starts_with("aptos_vm")` → false
5. No directives match, `Filter::enabled()` returns `false`
6. The critical security log is silently dropped
7. Operators monitoring stdout/file logs see no indication of Byzantine behavior

## Impact Explanation

**Severity: High** per Aptos bug bounty criteria ("Significant protocol violations" detection capability compromised).

While this doesn't directly break consensus safety (the protocol continues to function correctly), it severely degrades the ability to detect and respond to active Byzantine attacks. The security logs defined in `SecurityEvent` [8](#0-7)  are specifically designed to alert operators to malicious validator behavior.

**Partial Mitigation**: Telemetry logging may still capture these events if configured separately via `RUST_LOG_TELEMETRY` [9](#0-8) , but local monitoring is completely blind.

## Likelihood Explanation

**High Likelihood** in operational environments:

1. Operators commonly set module-specific `RUST_LOG` values when debugging issues
2. The default Helm chart configuration allows arbitrary `RUST_LOG` values [10](#0-9) 
3. The behavior is non-obvious: operators expect ERROR-level logs to always appear
4. No warnings are generated when consensus modules are excluded from logging
5. Documentation doesn't warn about this security implication

## Recommendation

Add a mandatory catch-all ERROR-level directive to ensure critical security logs are never suppressed:

```rust
pub fn build(&mut self) -> Filter {
    // Always ensure ERROR-level logs are captured for security events
    let has_catchall = self.directives.iter().any(|d| d.name.is_none());
    
    if self.directives.is_empty() {
        self.filter_level(LevelFilter::Error);
    } else if !has_catchall {
        // Insert catch-all ERROR directive at the beginning
        self.directives.insert(0, Directive::new(None::<String>, LevelFilter::Error));
    }
    
    self.directives.sort_by(|a, b| {
        let alen = a.name.as_ref().map(|a| a.len()).unwrap_or(0);
        let blen = b.name.as_ref().map(|b| b.len()).unwrap_or(0);
        alen.cmp(&blen)
    });

    Filter {
        directives: ::std::mem::take(&mut self.directives),
    }
}
```

**Additional Safeguard**: Emit a warning when consensus-related modules are not covered by any directive.

## Proof of Concept

```rust
// Add to crates/aptos-logger/tests/filter_security_test.rs
#[test]
fn test_consensus_security_logs_not_suppressed() {
    use aptos_logger::{Filter, Level, Metadata};
    
    // Simulate operator setting RUST_LOG for specific modules
    let mut builder = Filter::builder();
    builder.parse("mempool=info,network=debug");
    let filter = builder.build();
    
    // Create metadata for a consensus security event
    let metadata = Metadata::new(
        Level::Error,
        "consensus",
        "consensus::pending_votes",
        "consensus/src/pending_votes.rs:301"
    );
    
    // VULNERABILITY: This should return true for ERROR level, but returns false
    assert!(
        filter.enabled(&metadata),
        "ERROR-level consensus security logs must never be suppressed"
    );
}
```

**Expected**: Test fails, demonstrating that ERROR-level consensus logs are suppressed.

**After Fix**: Test passes, ensuring security logs always appear regardless of `RUST_LOG` configuration.

## Notes

- This issue represents a gap between the **expected security behavior** (critical logs always visible) and the **actual implementation** (module filtering can suppress everything)
- While telemetry may provide backup logging, real-time operator monitoring via stdout/files is essential for immediate incident response
- The root cause is an implicit assumption that operators understand Rust's logging filter semantics, which is unrealistic for production deployments
- Similar issues may exist in other blockchain implementations using `env_logger` or similar filtering mechanisms

### Citations

**File:** crates/aptos-logger/src/filter.rs (L105-122)
```rust
    pub fn build(&mut self) -> Filter {
        if self.directives.is_empty() {
            // Add the default filter if none exist
            self.filter_level(LevelFilter::Error);
        } else {
            // Sort the directives by length of their name, this allows a
            // little more efficient lookup at runtime.
            self.directives.sort_by(|a, b| {
                let alen = a.name.as_ref().map(|a| a.len()).unwrap_or(0);
                let blen = b.name.as_ref().map(|b| b.len()).unwrap_or(0);
                alen.cmp(&blen)
            });
        }

        Filter {
            directives: ::std::mem::take(&mut self.directives),
        }
    }
```

**File:** crates/aptos-logger/src/filter.rs (L136-145)
```rust
    pub fn enabled(&self, metadata: &Metadata) -> bool {
        // Search for the longest match, the vector is assumed to be pre-sorted.
        for directive in self.directives.iter().rev() {
            match &directive.name {
                Some(name) if !metadata.module_path().starts_with(name) => {},
                Some(..) | None => return LevelFilter::from(metadata.level()) <= directive.level,
            }
        }
        false
    }
```

**File:** crates/aptos-logger/src/aptos_logger.rs (L394-405)
```rust
    fn build_filter(&self) -> FilterTuple {
        let local_filter = {
            let mut filter_builder = Filter::builder();

            if env::var(RUST_LOG).is_ok() {
                filter_builder.with_env(RUST_LOG);
            } else {
                filter_builder.filter_level(self.level.into());
            }

            filter_builder.build()
        };
```

**File:** crates/aptos-logger/src/aptos_logger.rs (L406-420)
```rust
        let telemetry_filter = {
            let mut filter_builder = Filter::builder();

            if self.is_async && self.remote_log_tx.is_some() {
                if env::var(RUST_LOG_TELEMETRY).is_ok() {
                    filter_builder.with_env(RUST_LOG_TELEMETRY);
                } else {
                    filter_builder.filter_level(self.telemetry_level.into());
                }
            } else {
                filter_builder.filter_level(LevelFilter::Off);
            }

            filter_builder.build()
        };
```

**File:** consensus/src/pending_votes.rs (L300-305)
```rust
                error!(
                    SecurityEvent::ConsensusEquivocatingVote,
                    remote_peer = vote.author(),
                    vote = vote,
                    previous_vote = previously_seen_vote
                );
```

**File:** consensus/src/liveness/unequivocal_proposer_election.rs (L70-78)
```rust
                    if already_proposed.1 != block.id() {
                        error!(
                            SecurityEvent::InvalidConsensusProposal,
                            "Multiple proposals from {} for round {}: {} and {}",
                            author,
                            block.round(),
                            already_proposed.1,
                            block.id()
                        );
```

**File:** consensus/src/epoch_manager.rs (L1613-1618)
```rust
                            error!(
                                SecurityEvent::ConsensusInvalidMessage,
                                remote_peer = peer_id,
                                error = ?e,
                                unverified_event = unverified_event
                            );
```

**File:** terraform/helm/fullnode/templates/fullnode.yaml (L135-136)
```yaml
        - name: RUST_LOG
          value: {{ .Values.rust_log }}
```

**File:** crates/aptos-logger/src/security.rs (L23-82)
```rust
#[derive(Clone, Copy, Debug, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum SecurityEvent {
    //
    // Mempool
    //
    /// Mempool received a transaction from another peer with an invalid signature
    InvalidTransactionMempool,

    /// Mempool received an invalid network event
    InvalidNetworkEventMempool,

    // Consensus
    // ---------
    /// Consensus received an invalid message (not well-formed, invalid vote data or incorrect signature)
    ConsensusInvalidMessage,

    /// Consensus received an equivocating vote
    ConsensusEquivocatingVote,

    /// Consensus received an equivocating order vote
    ConsensusEquivocatingOrderVote,

    /// Consensus received an invalid proposal
    InvalidConsensusProposal,

    /// Consensus received an invalid new round message
    InvalidConsensusRound,

    /// Consensus received an invalid sync info message
    InvalidSyncInfoMsg,

    /// A received block is invalid
    InvalidRetrievedBlock,

    /// A block being committed or executed is invalid
    InvalidBlock,

    // State-Sync
    // ----------
    /// Invalid chunk of transactions received
    StateSyncInvalidChunk,

    // Health Checker
    // --------------
    /// HealthChecker received an invalid network event
    InvalidNetworkEventHC,

    /// HealthChecker received an invalid message
    InvalidHealthCheckerMsg,

    // Network
    // -------
    /// Network received an invalid message from a remote peer
    InvalidNetworkEvent,

    /// A failed noise handshake that's either a clear bug or indicates some
    /// security issue.
    NoiseHandshake,
}
```

**File:** terraform/helm/fullnode/values.yaml (L41-42)
```yaml
# -- Log level for the fullnode
rust_log: info
```
