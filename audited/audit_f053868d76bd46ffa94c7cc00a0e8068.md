# Audit Report

## Title
Consensus Divergence via Non-Backwards-Compatible PersistedAuxiliaryInfo Enum Evolution

## Summary
The `PersistedAuxiliaryInfo` enum lacks backwards compatibility for variant evolution. When future versions add new variants (e.g., V2) and upgraded validators write them to the database, old validators running unupgraded code will fail to deserialize these entries during state synchronization, causing complete state sync failure and consensus divergence between validator cohorts.

## Finding Description

The `PersistedAuxiliaryInfo` enum is serialized using BCS (Binary Canonical Serialization) and stored in the database keyed by transaction version [1](#0-0) 

The enum currently has three variants: `None`, `V1`, and `TimestampNotYetAssignedV1` [2](#0-1) 

The variant used during block execution is controlled by the on-chain `persisted_auxiliary_info_version` parameter [3](#0-2) 

When blocks are executed, the auxiliary info variant is created based on this version parameter [4](#0-3) 

**Attack Scenario:**

1. **Governance Upgrade**: Through normal governance process, `OnChainExecutionConfig` is upgraded to use `persisted_auxiliary_info_version = 2`

2. **Partial Code Deployment**: Some validators upgrade to code supporting hypothetical V2 variant, others remain on old code

3. **Execution Divergence**: 
   - Upgraded validators execute blocks with V2, write V2 entries to database
   - V2 auxiliary info is hashed and included in `TransactionInfo` [5](#0-4) 
   - These hashes affect the transaction accumulator root hash

4. **Deserialization Failure**: Old validators attempt state synchronization:
   - Call `get_persisted_auxiliary_info()` or `get_persisted_auxiliary_info_iter()` [6](#0-5) 
   - BCS deserialization encounters unknown variant index (V2 would be index 3)
   - Standard serde/BCS behavior: deserialization returns error for unknown enum variants
   - Error propagates through state sync multizip iterator [7](#0-6) 
   - State sync fails with `StorageErrorEncountered`

5. **Consensus Breakdown**:
   - Old validators cannot sync state from upgraded validators
   - Old validators attempting to execute would panic at `unimplemented!()` for unsupported version
   - Network partitions into upgraded vs non-upgraded validator sets
   - Different cohorts compute different state roots
   - **CRITICAL INVARIANT VIOLATION**: "All validators must produce identical state roots for identical blocks"

## Impact Explanation

**Critical Severity** - This vulnerability meets multiple Critical severity criteria:

1. **Consensus/Safety Violation**: Different validator cohorts compute different transaction accumulator roots because V2 variants hash differently than what old nodes can process. This directly breaks BFT consensus safety guarantees.

2. **Non-Recoverable Network Partition**: Old validators cannot deserialize V2 entries, cannot sync state, and cannot catch up. The network splits into incompatible validator sets. Recovery requires emergency hardfork intervention.

3. **Total Loss of Liveness**: If >1/3 of validators fail to upgrade before the governance proposal takes effect, the network loses its BFT quorum and halts completely.

This vulnerability affects the core deterministic execution invariant and can cause permanent network failure requiring manual intervention beyond normal protocol recovery mechanisms.

## Likelihood Explanation

**High Likelihood** during version upgrades:

- **Trigger Condition**: Requires governance proposal to increment `persisted_auxiliary_info_version` and code deployment of new variant
- **Realistic Scenario**: Standard upgrade procedure for new features involving auxiliary info
- **No Attack Required**: This is a protocol design flaw, not an active exploit - happens during normal operations if upgrade coordination fails
- **Historical Precedent**: Many blockchain protocols have experienced consensus issues during version upgrades with similar serialization format changes

The vulnerability becomes exploitable whenever:
1. Development adds new `PersistedAuxiliaryInfo` variant to codebase
2. Governance votes to enable it via config change
3. Validator upgrade coordination is imperfect (some validators lag behind)

## Recommendation

Implement backwards-compatible enum evolution using one of these approaches:

**Option 1: Explicit Unknown Variant Handling**
```rust
#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq)]
pub enum PersistedAuxiliaryInfo {
    None,
    V1 { transaction_index: u32 },
    TimestampNotYetAssignedV1 { transaction_index: u32 },
    // Add catch-all for unknown future variants
    #[serde(other)]
    Unknown,
}
```

Then modify deserialization to gracefully handle unknown variants by falling back to `None` behavior instead of failing.

**Option 2: Version-Aware Wrapper**
Replace direct BCS serialization with a versioned wrapper that can handle unknown versions:
```rust
pub struct VersionedAuxiliaryInfo {
    version: u8,
    data: Vec<u8>, // Raw BCS bytes
}
```
Old nodes can detect unsupported versions and either skip or use default values.

**Option 3: Strict Upgrade Coordination**
- Add on-chain check preventing `persisted_auxiliary_info_version` increment unless all active validators have signaled readiness
- Implement version compatibility matrix in consensus code
- Add migration period where both old and new variants are accepted

**Critical Fix**: Update state sync code to handle deserialization failures gracefully:
```rust
.unwrap_or_else(|e| {
    warn!("Failed to deserialize persisted_auxiliary_info, using None: {}", e);
    PersistedAuxiliaryInfo::None
})
```

However, this alone is insufficient because it causes consensus divergence (old nodes use None, new nodes use V2).

## Proof of Concept

```rust
// Rust test demonstrating the deserialization failure
#[test]
fn test_persisted_auxiliary_info_enum_evolution_breaks_consensus() {
    use aptos_types::transaction::PersistedAuxiliaryInfo;
    
    // Simulate old code with only 3 variants
    #[derive(Serialize, Deserialize)]
    enum OldPersistedAuxiliaryInfo {
        None,
        V1 { transaction_index: u32 },
        TimestampNotYetAssignedV1 { transaction_index: u32 },
    }
    
    // Simulate new code with 4 variants
    #[derive(Serialize, Deserialize)]
    enum NewPersistedAuxiliaryInfo {
        None,
        V1 { transaction_index: u32 },
        TimestampNotYetAssignedV1 { transaction_index: u32 },
        V2 { transaction_index: u32, extra_field: u64 }, // New variant
    }
    
    // New node creates V2 entry
    let new_variant = NewPersistedAuxiliaryInfo::V2 {
        transaction_index: 42,
        extra_field: 123,
    };
    let serialized = bcs::to_bytes(&new_variant).unwrap();
    
    // Old node tries to deserialize - THIS FAILS
    let result = bcs::from_bytes::<OldPersistedAuxiliaryInfo>(&serialized);
    assert!(result.is_err()); // Deserialization fails with unknown variant
    
    // This demonstrates that old validators cannot read V2 entries
    // State sync will fail, consensus will diverge
}
```

To demonstrate the full consensus impact, modify `consensus/src/pipeline/pipeline_builder.rs` to add V2 support, deploy to subset of validators, execute governance proposal to enable it, and observe that non-upgraded validators fail state sync when encountering V2 entries in the database.

### Citations

**File:** storage/aptosdb/src/schema/persisted_auxiliary_info/mod.rs (L43-51)
```rust
impl ValueCodec<PersistedAuxiliaryInfoSchema> for PersistedAuxiliaryInfo {
    fn encode_value(&self) -> Result<Vec<u8>> {
        bcs::to_bytes(self).map_err(Into::into)
    }

    fn decode_value(data: &[u8]) -> Result<Self> {
        bcs::from_bytes(data).map_err(Into::into)
    }
}
```

**File:** types/src/transaction/mod.rs (L3303-3318)
```rust
#[derive(
    Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq, CryptoHasher, BCSCryptoHash,
)]
#[cfg_attr(any(test, feature = "fuzzing"), derive(Arbitrary))]
pub enum PersistedAuxiliaryInfo {
    None,
    // The index of the transaction in a block (after shuffler, before execution).
    // Note that this would be slightly different from the index of transactions that get committed
    // onchain, as this considers transactions that may get discarded.
    V1 { transaction_index: u32 },
    // When we are doing a simulation or validation of transactions, the transaction is not executed
    // within the context of a block. The timestamp is not yet assigned, but we still track the
    // transaction index for multi-transaction simulations. For single transaction simulation or
    // validation, the transaction index is set to 0.
    TimestampNotYetAssignedV1 { transaction_index: u32 },
}
```

**File:** types/src/on_chain_config/execution_config.rs (L86-96)
```rust
    pub fn persisted_auxiliary_info_version(&self) -> u8 {
        match self {
            OnChainExecutionConfig::Missing
            | OnChainExecutionConfig::V1(_)
            | OnChainExecutionConfig::V2(_)
            | OnChainExecutionConfig::V3(_)
            | OnChainExecutionConfig::V4(_)
            | OnChainExecutionConfig::V5(_)
            | OnChainExecutionConfig::V6(_) => 0,
            OnChainExecutionConfig::V7(config) => config.persisted_auxiliary_info_version,
        }
```

**File:** consensus/src/pipeline/pipeline_builder.rs (L835-841)
```rust
                let persisted_auxiliary_info = match persisted_auxiliary_info_version {
                    0 => PersistedAuxiliaryInfo::None,
                    1 => PersistedAuxiliaryInfo::V1 {
                        transaction_index: txn_index as u32,
                    },
                    _ => unimplemented!("Unsupported persisted auxiliary info version"),
                };
```

**File:** execution/executor/src/workflow/do_ledger_update.rs (L61-67)
```rust
                let auxiliary_info_hash = match persisted_auxiliary_info {
                    PersistedAuxiliaryInfo::None => None,
                    PersistedAuxiliaryInfo::V1 { .. } => {
                        Some(CryptoHash::hash(persisted_auxiliary_info))
                    },
                    PersistedAuxiliaryInfo::TimestampNotYetAssignedV1 { .. } => None,
                };
```

**File:** storage/aptosdb/src/ledger_db/persisted_auxiliary_info_db.rs (L47-52)
```rust
    pub(crate) fn get_persisted_auxiliary_info(
        &self,
        version: Version,
    ) -> Result<Option<PersistedAuxiliaryInfo>> {
        self.db.get::<PersistedAuxiliaryInfoSchema>(&version)
    }
```

**File:** state-sync/storage-service/server/src/storage.rs (L678-683)
```rust
                Some((Err(error), _, _, _, _))
                | Some((_, Err(error), _, _, _))
                | Some((_, _, Err(error), _, _))
                | Some((_, _, _, Err(error), _))
                | Some((_, _, _, _, Err(error))) => {
                    return Err(Error::StorageErrorEncountered(error.to_string()));
```
