# Audit Report

## Title
Unchecked Network Configuration Constants Lead to Validator Node Crash via Division by Zero

## Summary
The network configuration constants `max_frame_size` and `max_message_size` lack validation checks before being used in critical division operations. When `max_frame_size` is set to 0 or below the required overhead (64 bytes), or when the relationship between these constants is invalid, the validator node will panic during peer connection establishment, causing immediate denial of service.

## Finding Description
The Aptos network layer defines critical constants in [1](#0-0) 

These constants are used throughout the network stack but can be overridden via YAML configuration files. [2](#0-1)  and [3](#0-2) 

When a validator node starts and attempts to establish peer connections, the `Peer::new()` function performs an unchecked division operation: [4](#0-3) 

This division operation has **no validation** to ensure `max_frame_size` is non-zero. If an operator sets `max_frame_size: 0` in the validator configuration YAML (as shown to be configurable in [5](#0-4) ), the node will panic with a division by zero error.

Additionally, validation checks exist in `OutboundStream::new()` but occur **after** `Peer::new()` has already executed: [6](#0-5)  and [7](#0-6) 

These validations are too late to prevent the panic in `Peer::new()`. The configuration flows through multiple layers without validation: [8](#0-7)  and [9](#0-8) 

**Attack Vector:**
1. Attacker gains access to node configuration files (through misconfiguration, compromised operator account, or malicious insider)
2. Sets `max_frame_size: 0` or `max_frame_size: 50` (below overhead) in validator YAML
3. Node operator restarts the validator
4. During startup, all peer connection attempts trigger the panic in `Peer::new()`
5. Validator crashes repeatedly, unable to participate in consensus

## Impact Explanation
This is a **High Severity** vulnerability per Aptos bug bounty criteria:
- **Validator node crashes**: The panic occurs during peer connection establishment, making the node unable to function
- **Network availability impact**: Multiple validators experiencing this issue would reduce network capacity and consensus participation
- **Consensus disruption**: Crashed validators cannot vote or propose blocks, affecting network liveness

While this doesn't directly cause fund loss or permanent network partition, it creates significant protocol violations and node unavailability, meeting the High severity threshold of "Validator node slowdowns" and "API crashes."

## Likelihood Explanation
**Likelihood: Medium to High**

This vulnerability can occur through:
1. **Operator misconfiguration**: Honest mistake when editing configuration files
2. **Malicious insider**: Operator with configuration access intentionally setting invalid values
3. **Configuration injection**: If configuration management systems are compromised
4. **Default configuration bugs**: If future updates accidentally set invalid defaults

The vulnerability is particularly dangerous because:
- No validation exists at multiple critical checkpoints
- The YAML configuration is directly deserializable without constraints
- The error manifests immediately on node startup, making debugging difficult
- All peer connections fail, not just a subset

## Recommendation

Add comprehensive validation in `NetworkConfig::network_with_id()` before the configuration is used:

**Location:** [10](#0-9) 

**Add validation after line 167 (before returning config):**

```rust
// Validate network constants
config.validate_network_constants()?;
```

**Add new method to NetworkConfig:**

```rust
pub fn validate_network_constants(&self) -> Result<(), Error> {
    const MIN_FRAME_SIZE: usize = 1024; // 1 KiB minimum
    const FRAME_OVERHEAD_BYTES: usize = 64;
    const MAX_FRAGMENTS: usize = 255; // u8::MAX
    
    // Validate max_frame_size
    if self.max_frame_size == 0 {
        return Err(Error::InvariantViolation(
            "max_frame_size cannot be zero".to_string()
        ));
    }
    
    if self.max_frame_size < FRAME_OVERHEAD_BYTES {
        return Err(Error::InvariantViolation(
            format!(
                "max_frame_size ({}) must be at least {} bytes to account for overhead",
                self.max_frame_size, FRAME_OVERHEAD_BYTES
            )
        ));
    }
    
    if self.max_frame_size < MIN_FRAME_SIZE {
        return Err(Error::InvariantViolation(
            format!(
                "max_frame_size ({}) is below minimum safe size of {} bytes",
                self.max_frame_size, MIN_FRAME_SIZE
            )
        ));
    }
    
    // Validate max_message_size
    if self.max_message_size == 0 {
        return Err(Error::InvariantViolation(
            "max_message_size cannot be zero".to_string()
        ));
    }
    
    if self.max_message_size < self.max_frame_size {
        return Err(Error::InvariantViolation(
            format!(
                "max_message_size ({}) must be >= max_frame_size ({})",
                self.max_message_size, self.max_frame_size
            )
        ));
    }
    
    // Validate relationship: max_message_size must be achievable with max_fragments
    let effective_frame_size = self.max_frame_size - FRAME_OVERHEAD_BYTES;
    let max_supported_message_size = effective_frame_size * MAX_FRAGMENTS;
    if self.max_message_size > max_supported_message_size {
        return Err(Error::InvariantViolation(
            format!(
                "max_message_size ({}) exceeds maximum supported size ({}) \
                 with max_frame_size ({}) and {} fragments",
                self.max_message_size, max_supported_message_size,
                self.max_frame_size, MAX_FRAGMENTS
            )
        ));
    }
    
    Ok(())
}
```

This ensures validation occurs before any networking code is executed, preventing panics from invalid configuration.

## Proof of Concept

**Rust test demonstrating the vulnerability:**

```rust
#[test]
#[should_panic(expected = "attempt to divide by zero")]
fn test_peer_new_panics_with_zero_frame_size() {
    use network::peer::Peer;
    use network::transport::Connection;
    use std::time::Duration;
    
    // Setup mock connection and channels
    let (connection_notifs_tx, _) = aptos_channels::new_test(10);
    let (_, peer_reqs_rx) = aptos_channel::new(QueueStyle::FIFO, 10, None);
    let upstream_handlers = Arc::new(HashMap::new());
    
    // Create mock connection
    let connection_metadata = ConnectionMetadata::mock(PeerId::random());
    let (socket, _) = tokio::io::duplex(1024);
    let connection = Connection::new(connection_metadata, socket);
    
    // THIS WILL PANIC: max_frame_size = 0
    let _peer = Peer::new(
        NetworkContext::mock(),
        Handle::current(),
        TimeService::mock(),
        connection,
        connection_notifs_tx,
        peer_reqs_rx,
        upstream_handlers,
        Duration::from_secs(10),
        100, // max_concurrent_inbound_rpcs
        100, // max_concurrent_outbound_rpcs
        0,   // max_frame_size = 0 (INVALID)
        64 * 1024 * 1024, // max_message_size
    );
    // Test fails here with division by zero
}

#[test]
fn test_network_config_validation_catches_zero_frame_size() {
    let mut config = NetworkConfig::default();
    config.max_frame_size = 0;
    
    // Should fail validation
    assert!(config.validate_network_constants().is_err());
}

#[test]
fn test_network_config_validation_catches_small_frame_size() {
    let mut config = NetworkConfig::default();
    config.max_frame_size = 32; // Below 64 byte overhead
    
    // Should fail validation
    assert!(config.validate_network_constants().is_err());
}

#[test]
fn test_network_config_validation_catches_invalid_relationship() {
    let mut config = NetworkConfig::default();
    config.max_frame_size = 1024;
    config.max_message_size = 1024 * 256; // Exceeds (1024-64) * 255
    
    // Should fail validation
    assert!(config.validate_network_constants().is_err());
}
```

**Notes:**
- The vulnerability exists because configuration validation is deferred until runtime rather than at configuration load time
- The issue affects all node types (validators, VFNs, fullnodes) that use the network layer
- The panic occurs deterministically on every peer connection attempt, not intermittently
- Current default values (4 MiB frame, 64 MiB message) are safe, but the lack of validation creates operational risk
- The recommended fix ensures invariants are enforced at configuration time rather than discovering issues during runtime

### Citations

**File:** network/framework/src/constants.rs (L20-21)
```rust
pub const MAX_FRAME_SIZE: usize = 4 * 1024 * 1024; /* 4 MiB */
pub const MAX_MESSAGE_SIZE: usize = 64 * 1024 * 1024; /* 64 MiB */
```

**File:** config/src/config/network_config.rs (L103-103)
```rust
    pub max_frame_size: usize,
```

**File:** config/src/config/network_config.rs (L121-121)
```rust
    pub max_message_size: usize,
```

**File:** config/src/config/network_config.rs (L135-176)
```rust
    pub fn network_with_id(network_id: NetworkId) -> NetworkConfig {
        let mutual_authentication = network_id.is_validator_network();
        let mut config = Self {
            discovery_method: DiscoveryMethod::None,
            discovery_methods: Vec::new(),
            identity: Identity::None,
            listen_address: "/ip4/0.0.0.0/tcp/6180".parse().unwrap(),
            mutual_authentication,
            network_id,
            runtime_threads: None,
            seed_addrs: HashMap::new(),
            seeds: PeerSet::default(),
            max_frame_size: MAX_FRAME_SIZE,
            enable_proxy_protocol: false,
            max_connection_delay_ms: MAX_CONNECTION_DELAY_MS,
            connectivity_check_interval_ms: CONNECTIVITY_CHECK_INTERVAL_MS,
            network_channel_size: NETWORK_CHANNEL_SIZE,
            connection_backoff_base: CONNECTION_BACKOFF_BASE,
            ping_interval_ms: PING_INTERVAL_MS,
            ping_timeout_ms: PING_TIMEOUT_MS,
            ping_failures_tolerated: PING_FAILURES_TOLERATED,
            max_outbound_connections: MAX_FULLNODE_OUTBOUND_CONNECTIONS,
            max_inbound_connections: MAX_INBOUND_CONNECTIONS,
            inbound_rate_limit_config: None,
            outbound_rate_limit_config: None,
            max_message_size: MAX_MESSAGE_SIZE,
            inbound_rx_buffer_size_bytes: None,
            inbound_tx_buffer_size_bytes: None,
            outbound_rx_buffer_size_bytes: None,
            outbound_tx_buffer_size_bytes: None,
            max_parallel_deserialization_tasks: None,
            enable_latency_aware_dialing: true,
        };

        // Configure the number of parallel deserialization tasks
        config.configure_num_deserialization_tasks();

        // Prepare the identity based on the identity format
        config.prepare_identity();

        config
    }
```

**File:** network/framework/src/peer/mod.rs (L168-168)
```rust
        let max_fragments = max_message_size / max_frame_size;
```

**File:** config/src/config/test_data/validator.yaml (L79-79)
```yaml
    max_frame_size: 4194304 # 4 MiB
```

**File:** network/framework/src/protocols/stream/mod.rs (L232-234)
```rust
        let max_frame_size = max_frame_size
            .checked_sub(FRAME_OVERHEAD_BYTES)
            .expect("Frame size too small, overhead exceeds frame size!");
```

**File:** network/framework/src/protocols/stream/mod.rs (L237-243)
```rust
        assert!(
            (max_frame_size * (u8::MAX as usize)) >= max_message_size,
            "Stream only supports {} chunks! Frame size {}, message size {}.",
            u8::MAX,
            max_frame_size,
            max_message_size
        );
```

**File:** network/builder/src/builder.rs (L186-187)
```rust
            config.max_frame_size,
            config.max_message_size,
```

**File:** network/framework/src/peer_manager/builder.rs (L170-171)
```rust
        max_frame_size: usize,
        max_message_size: usize,
```
