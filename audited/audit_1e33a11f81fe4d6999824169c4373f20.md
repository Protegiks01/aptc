# Audit Report

## Title
Missing Depth Validation During BCS Deserialization Causes Asymmetric Checks and Potential Consensus Issues

## Summary
The Move VM's value deserialization path fails to enforce depth limits even when `enable_depth_checks` is configured, creating an asymmetry with serialization which does enforce these limits. This allows deeply nested structures to bypass validation during deserialization, potentially causing stack overflow, resource exhaustion, and consensus divergence between nodes with different configurations.

## Finding Description

The vulnerability exists in the implementation of BCS value deserialization for Move VM values. While serialization properly enforces depth limits via `check_depth()` calls, the deserialization path completely omits this validation.

**Serialization (CORRECT Implementation):** [1](#0-0) 

The serialization path includes explicit depth tracking with a `depth` field in `SerializationReadyValue` and calls `check_depth()` at the beginning of serialization. When recursing into nested structures, depth is incremented: [2](#0-1) 

**Deserialization (VULNERABLE Implementation):** [3](#0-2) 

The `DeserializationSeed` struct has no `depth` field and the `deserialize` implementation never calls `check_depth()`. The deserialization proceeds recursively without any depth validation: [4](#0-3) 

**Attack Scenario:**

1. **Configuration-Based Attack**: Node A operates with `enable_depth_checks = false` or a very high depth limit (e.g., during early network operation or testing). Values with depth > 128 are created and stored in tables/state.

2. **Configuration Change**: Network upgrades to enable strict depth checks with the default limit: [5](#0-4) 

3. **Exploitation**: When Node B (with strict checks) retrieves these deeply nested values from storage via table operations, deserialization succeeds without depth validation: [6](#0-5) 

4. **Consensus Divergence**: If the same deeply nested value is later re-serialized (e.g., during state updates), serialization will fail (return `None`), causing Node B to behave differently than Node A. Different nodes may reach different conclusions about transaction validity.

5. **Resource Exhaustion**: Recursive operations on the deeply nested deserialized values can cause stack overflow before reaching the intended depth limit, as the comment acknowledges: [7](#0-6) 

## Impact Explanation

**Medium Severity** - This qualifies as "State inconsistencies requiring intervention" under the Aptos bug bounty criteria for the following reasons:

1. **Consensus Divergence**: Nodes with different configurations or that upgraded at different times could reach different states when processing the same blocks containing deeply nested values. This violates the "Deterministic Execution" invariant.

2. **State Inconsistency**: Values that can be deserialized but not serialized create an asymmetric state where operations succeed in one direction but fail in the other, violating "State Consistency" invariant.

3. **Resource Exhaustion Potential**: While the depth limit is intended to prevent stack overflow at 128 levels, deserialization bypasses this protection, allowing structures that could cause stack overflow during subsequent recursive operations on the deserialized values.

4. **Operational Risk**: This requires network intervention if deeply nested values enter the state during configuration transitions or through malicious/buggy contracts during periods with relaxed checks.

## Likelihood Explanation

**Medium Likelihood**:

1. **Configuration Transitions**: The vulnerability is most likely to manifest during:
   - Network upgrades that change depth check configurations
   - Testing/staging environments with relaxed checks that promote data to production
   - Nodes joining the network with different configuration versions

2. **Temporal Exposure**: The VMConfig's `enable_depth_checks` field can be toggled: [8](#0-7) 

3. **State Persistence**: Once deeply nested values enter storage during a period with relaxed checks, they persist and can be deserialized later under strict checks without validation.

4. **Natural Occurrence**: This isn't just a theoretical attack - it can naturally occur during legitimate network operations and configuration management.

## Recommendation

Add depth tracking and validation to the deserialization path to match the serialization implementation:

1. **Add depth field to DeserializationSeed**:
```rust
pub(crate) struct DeserializationSeed<'c, L> {
    pub(crate) ctx: &'c ValueSerDeContext<'c>,
    pub(crate) layout: L,
    pub(crate) depth: u64,  // ADD THIS
}
```

2. **Check depth at the start of deserialize implementation**:
```rust
impl<'d> serde::de::DeserializeSeed<'d> for DeserializationSeed<'_, &MoveTypeLayout> {
    type Value = Value;

    fn deserialize<D: serde::de::Deserializer<'d>>(
        self,
        deserializer: D,
    ) -> Result<Self::Value, D::Error> {
        use MoveTypeLayout as L;
        
        // ADD THIS CHECK
        self.ctx.check_depth(self.depth).map_err(D::Error::custom)?;
        
        match self.layout {
            // ... rest of implementation
        }
    }
}
```

3. **Increment depth when creating nested DeserializationSeeds** - similar to serialization pattern.

4. **Initialize with depth = 1** in the public deserialize methods: [4](#0-3) 

## Proof of Concept

```rust
#[test]
fn test_asymmetric_depth_check() {
    use move_vm_types::values::{Value, Struct};
    use move_core_types::value::{MoveTypeLayout, MoveStructLayout};
    use move_vm_types::value_serde::ValueSerDeContext;
    
    // Create a deeply nested structure (depth > default limit of 128)
    let mut nested_value = Value::u8(0);
    let mut nested_layout = MoveTypeLayout::U8;
    
    // Nest 150 levels deep
    for _ in 0..150 {
        nested_value = Value::struct_(Struct::pack(vec![nested_value]));
        nested_layout = MoveTypeLayout::Struct(
            MoveStructLayout::Runtime(vec![nested_layout])
        );
    }
    
    // With no depth limit, serialization succeeds
    let ctx_no_limit = ValueSerDeContext::new(None);
    let serialized = ctx_no_limit.serialize(&nested_value, &nested_layout)
        .expect("Serialization should succeed with no limit")
        .expect("Should produce bytes");
    
    // With depth limit of 128, serialization correctly fails (returns None)
    let ctx_with_limit = ValueSerDeContext::new(Some(128));
    let serialization_result = ctx_with_limit.serialize(&nested_value, &nested_layout)
        .expect("Should not error");
    assert!(serialization_result.is_none(), 
        "Serialization should return None when depth exceeds limit");
    
    // VULNERABILITY: Deserialization with depth limit DOES NOT CHECK DEPTH
    // This should fail but succeeds, demonstrating the asymmetry
    let ctx_deser = ValueSerDeContext::new(Some(128));
    let deserialized = ctx_deser.deserialize(&serialized, &nested_layout);
    
    // This assertion should fail, exposing the vulnerability
    assert!(deserialized.is_none(), 
        "Deserialization should fail when depth exceeds limit, but it doesn't!");
}
```

This test demonstrates that:
1. Serialization with depth limit correctly rejects deep structures (returns `None`)
2. Deserialization with the same depth limit incorrectly accepts deep structures (succeeds)
3. This asymmetry violates the expected behavior and can cause consensus issues

### Citations

**File:** third_party/move/move-vm/types/src/values/values_impl.rs (L50-57)
```rust
/// Values can be recursive, and so it is important that we do not use recursive algorithms over
/// deeply nested values as it can cause stack overflow. Since it is not always possible to avoid
/// recursion, we opt for a reasonable limit on VM value depth. It is defined in Move VM config,
/// but since it is difficult to propagate config context everywhere, we use this constant.
///
/// IMPORTANT: When changing this constant, make sure it is in-sync with one in VM config (it is
/// used there now).
pub const DEFAULT_MAX_VM_VALUE_NESTED_DEPTH: u64 = 128;
```

**File:** third_party/move/move-vm/types/src/values/values_impl.rs (L4834-4838)
```rust
impl serde::Serialize for SerializationReadyValue<'_, '_, '_, MoveTypeLayout, Value> {
    fn serialize<S: serde::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        use MoveTypeLayout as L;

        self.ctx.check_depth(self.depth).map_err(S::Error::custom)?;
```

**File:** third_party/move/move-vm/types/src/values/values_impl.rs (L4898-4910)
```rust
                    (_, Container::Vec(r)) => {
                        let v = r.borrow();
                        let mut t = serializer.serialize_seq(Some(v.len()))?;
                        for value in v.iter() {
                            t.serialize_element(&SerializationReadyValue {
                                ctx: self.ctx,
                                layout,
                                value,
                                depth: self.depth + 1,
                            })?;
                        }
                        t.end()
                    },
```

**File:** third_party/move/move-vm/types/src/values/values_impl.rs (L5085-5092)
```rust
pub(crate) struct DeserializationSeed<'c, L> {
    // Holds extensions external to the deserializer.
    pub(crate) ctx: &'c ValueSerDeContext<'c>,
    // Layout to guide deserialization.
    pub(crate) layout: L,
}

impl<'d> serde::de::DeserializeSeed<'d> for DeserializationSeed<'_, &MoveTypeLayout> {
```

**File:** third_party/move/move-vm/types/src/value_serde.rs (L237-241)
```rust
    /// Deserializes the bytes using the provided layout into a Move [Value].
    pub fn deserialize(self, bytes: &[u8], layout: &MoveTypeLayout) -> Option<Value> {
        let seed = DeserializationSeed { ctx: &self, layout };
        bcs::from_bytes_seed(seed, bytes).ok()
    }
```

**File:** aptos-move/framework/table-natives/src/lib.rs (L704-721)
```rust
fn deserialize_value(
    function_value_extension: &dyn FunctionValueExtension,
    bytes: &[u8],
    layout_info: &LayoutInfo,
) -> PartialVMResult<Value> {
    let layout = layout_info.layout.as_ref();
    let deserialization_result = if layout_info.contains_delayed_fields {
        ValueSerDeContext::new(function_value_extension.max_value_nest_depth())
            .with_func_args_deserialization(function_value_extension)
            .with_delayed_fields_serde()
            .deserialize(bytes, layout)
    } else {
        ValueSerDeContext::new(function_value_extension.max_value_nest_depth())
            .with_func_args_deserialization(function_value_extension)
            .deserialize(bytes, layout)
    };
    deserialization_result.ok_or_else(|| partial_extension_error("cannot deserialize table value"))
}
```

**File:** third_party/move/move-vm/runtime/src/config.rs (L39-39)
```rust
    pub enable_depth_checks: bool,
```
