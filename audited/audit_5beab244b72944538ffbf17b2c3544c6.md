# Audit Report

## Title
Critical Panic-Induced Network DoS via Malformed DKG Sigma Protocol Proof

## Summary
A malicious validator can craft a DKG transcript containing a sigma protocol proof with `FirstProofItem::Challenge` variant instead of the expected `FirstProofItem::Commitment`, causing all other validators to panic and crash during transcript verification, resulting in total network liveness loss.

## Finding Description
The `FirstProofItem` enum in the DKG sigma protocol implementation can be serialized as either `Commitment` or `Challenge` variant. [1](#0-0) 

The deserialization logic correctly handles both variants using a tag-based approach: [2](#0-1) 

However, the verification logic in `msm_terms_for_verify` explicitly panics when encountering the `Challenge` variant: [3](#0-2) 

The same panic exists in the `PairingTupleHomomorphism` implementation: [4](#0-3) 

**Attack Path:**

1. A malicious validator creates a DKG transcript where the `sharing_proof.SoK` field contains a proof with `first_proof_item: FirstProofItem::Challenge(...)` instead of `FirstProofItem::Commitment(...)`. The `SharingProof` structure is defined as: [5](#0-4) 

2. This malformed transcript passes consensus-level validation, which only checks basic structure, dealer indices, and voting power via `verify_transcript_extra`: [6](#0-5) 

3. The transcript is included in a block and reaches execution phase where `process_dkg_result` is invoked: [7](#0-6) 

4. During deep cryptographic verification, the transcript's sigma protocol proof is verified: [8](#0-7) 

5. The verification calls `msm_terms_for_verify`, which encounters `FirstProofItem::Challenge` and panics, crashing the validator node.

The panic is NOT caught by any error handling in the execution pipeline: [9](#0-8) 

## Impact Explanation
**Critical Severity - Total Loss of Network Liveness**

This vulnerability allows a single malicious validator to cause all other validators to crash simultaneously when they attempt to process a block containing the malformed DKG transcript. According to Aptos bug bounty criteria, this qualifies as:

- **"Total loss of liveness/network availability"** - All validators crash, halting the network
- **"Non-recoverable network partition (requires hardfork)"** - The malicious transcript is in a committed block, requiring manual intervention to remove

The panic propagates through the entire validator network because:
1. All validators must execute the same blocks deterministically
2. No panic catching exists in the DKG verification path
3. The malformed transcript passes initial validation checks

This violates the **Consensus Safety** invariant: "AptosBFT must prevent double-spending and chain splits under < 1/3 Byzantine" - while this doesn't cause a chain split, it causes complete network halt with just a single Byzantine validator.

## Likelihood Explanation
**High Likelihood**

Prerequisites for exploitation:
- Attacker must be a validator (can submit DKG transcripts)
- No special cryptographic knowledge required - simply swap enum variants
- No coordination with other validators needed

The attack is trivial to execute:
1. Legitimate proof generation uses `store_prover_commitment: true`: [10](#0-9) 

2. Attacker calls `prove_homomorphism` with `store_prover_commitment: false` or manually constructs the proof with `FirstProofItem::Challenge` variant: [11](#0-10) 

3. The crafted transcript serializes correctly and passes all validation until execution

## Recommendation
Replace all panic statements in sigma protocol verification with proper error returns:

**In `crates/aptos-dkg/src/sigma_protocol/traits.rs` (lines 113-118):**
```rust
let prover_first_message = match &proof.first_proof_item {
    FirstProofItem::Commitment(A) => A,
    FirstProofItem::Challenge(_) => {
        anyhow::bail!("Invalid proof: expected Commitment variant, got Challenge variant")
    },
};
```

**In `crates/aptos-dkg/src/sigma_protocol/homomorphism/tuple.rs` (lines 337-342):**
```rust
let prover_first_message = match &proof.first_proof_item {
    FirstProofItem::Commitment(A) => A,
    FirstProofItem::Challenge(_) => {
        anyhow::bail!("Invalid proof: expected Commitment variant, got Challenge variant")
    },
};
```

**Additional defensive measure:** Add validation in the `CanonicalDeserialize` implementation to enforce that only `Commitment` variant is allowed in specific contexts where it's expected.

## Proof of Concept
```rust
// This PoC demonstrates how to craft a malicious DKG transcript

use aptos_dkg::sigma_protocol::{
    traits::{FirstProofItem, Proof},
    homomorphism::Trait as HomomorphismTrait,
};
use aptos_types::dkg::{DKGTranscript, DKGTranscriptMetadata};
use move_core_types::account_address::AccountAddress;

// Step 1: Create a valid sigma protocol proof but with Challenge variant
fn create_malicious_proof<F, H>() -> Proof<F, H>
where
    F: ark_ff::PrimeField,
    H: HomomorphismTrait,
{
    let challenge_scalar = F::from(12345u64); // Arbitrary challenge value
    let response = /* compute valid response */;
    
    Proof {
        first_proof_item: FirstProofItem::Challenge(challenge_scalar), // Wrong variant!
        z: response,
    }
}

// Step 2: Embed in DKG transcript and submit
fn craft_malicious_transcript() -> DKGTranscript {
    let malicious_proof = create_malicious_proof();
    let transcript_bytes = bcs::to_bytes(&malicious_proof).unwrap();
    
    DKGTranscript::new(
        999, // current epoch
        AccountAddress::random(), // attacker's address
        transcript_bytes,
    )
}

// Step 3: When other validators verify this transcript:
// - Deserialization succeeds (valid BCS encoding)
// - Initial validation passes (correct structure)
// - Deep verification calls msm_terms_for_verify()
// - Panic occurs at line 115 in traits.rs
// - Validator node crashes
// Result: Network halt
```

## Notes
This vulnerability exists because the code was designed to support both `Commitment` and `Challenge` variants for different proof types (compact vs batchable), but the verification implementation only handles the `Commitment` case. The panic message "Missing implementation" suggests this was a known incomplete feature rather than an intentional design choice. However, the incomplete implementation creates a critical DoS vector that must be addressed immediately.

### Citations

**File:** crates/aptos-dkg/src/sigma_protocol/traits.rs (L113-118)
```rust
        let prover_first_message = match &proof.first_proof_item {
            FirstProofItem::Commitment(A) => A,
            FirstProofItem::Challenge(_) => {
                panic!("Missing implementation - expected commitment, not challenge")
            },
        };
```

**File:** crates/aptos-dkg/src/sigma_protocol/traits.rs (L235-246)
```rust
/// The “first item” recorded in a Σ-proof, which is one of:
/// - The first message of the protocol, which is the commitment from the prover. This leads to a more compact proof.
/// - The second message of the protocol, which is the challenge from the verifier. This leads to a proof which is amenable to batch verification.
/// TODO: Better name? In https://github.com/sigma-rs/sigma-proofs these would be called "compact" and "batchable" proofs
#[derive(Clone, Debug, Eq)]
pub enum FirstProofItem<F: PrimeField, H: homomorphism::Trait>
where
    H::Codomain: Statement,
{
    Commitment(H::Codomain),
    Challenge(F), // In more generality, this should be H::Domain::Scalar
}
```

**File:** crates/aptos-dkg/src/sigma_protocol/traits.rs (L313-340)
```rust
    fn deserialize_with_mode<R: Read>(
        mut reader: R,
        compress: Compress,
        validate: Validate,
    ) -> Result<Self, SerializationError> {
        // Read the discriminant tag
        let tag = u8::deserialize_with_mode(&mut reader, compress, validate)?;

        let item = match tag {
            0 => {
                let c = H::Codomain::deserialize_with_mode(reader, compress, validate)?;
                FirstProofItem::Commitment(c)
            },
            1 => {
                let f = F::deserialize_with_mode(reader, compress, validate)?;
                FirstProofItem::Challenge(f)
            },
            _ => return Err(SerializationError::InvalidData),
        };

        // Run validity check if requested
        if validate == Validate::Yes {
            item.check()?;
        }

        Ok(item)
    }
}
```

**File:** crates/aptos-dkg/src/sigma_protocol/traits.rs (L499-509)
```rust
    // Step 5: Pick first **recorded** item
    let first_proof_item = if store_prover_commitment {
        FirstProofItem::Commitment(A)
    } else {
        FirstProofItem::Challenge(c)
    };

    Proof {
        first_proof_item,
        z,
    }
```

**File:** crates/aptos-dkg/src/sigma_protocol/homomorphism/tuple.rs (L289-297)
```rust
    pub fn prove<Ct: Serialize, R: rand_core::RngCore + rand_core::CryptoRng>(
        &self,
        witness: &<Self as homomorphism::Trait>::Domain,
        statement: &<Self as homomorphism::Trait>::Codomain,
        cntxt: &Ct, // for SoK purposes
        rng: &mut R,
    ) -> Proof<H1::Scalar, Self> {
        prove_homomorphism(self, witness, statement, cntxt, true, rng, &self.dst())
    }
```

**File:** crates/aptos-dkg/src/sigma_protocol/homomorphism/tuple.rs (L337-342)
```rust
        let prover_first_message = match &proof.first_proof_item {
            FirstProofItem::Commitment(A) => A,
            FirstProofItem::Challenge(_) => {
                panic!("Missing implementation - expected commitment, not challenge")
            },
        };
```

**File:** crates/aptos-dkg/src/pvss/chunky/weighted_transcript.rs (L178-190)
```rust
            if let Err(err) = hom.verify(
                &TupleCodomainShape(
                    self.sharing_proof.range_proof_commitment.clone(),
                    chunked_elgamal::WeightedCodomainShape {
                        chunks: self.subtrs.Cs.clone(),
                        randomness: self.subtrs.Rs.clone(),
                    },
                ),
                &self.sharing_proof.SoK,
                &sok_cntxt,
            ) {
                bail!("PoK verification failed: {:?}", err);
            }
```

**File:** crates/aptos-dkg/src/pvss/chunky/weighted_transcript.rs (L419-432)
```rust
#[allow(non_snake_case)]
#[derive(CanonicalSerialize, CanonicalDeserialize, Clone, Debug, PartialEq, Eq)]
pub struct SharingProof<E: Pairing> {
    /// SoK: the SK is knowledge of `witnesses` s_{i,j} yielding the commitment and the C and the R, their image is the PK, and the signed message is a certain context `cntxt`
    pub SoK: sigma_protocol::Proof<
        E::ScalarField,
        hkzg_chunked_elgamal::WeightedHomomorphism<'static, E>,
    >, // static because we don't want the lifetime of the Proof to depend on the Homomorphism TODO: try removing it?
    /// A batched range proof showing that all committed values s_{i,j} lie in some range
    pub range_proof: dekart_univariate_v2::Proof<E>,
    /// A KZG-style commitment to the values s_{i,j} going into the range proof
    pub range_proof_commitment:
        <dekart_univariate_v2::Proof<E> as BatchedRangeProof<E>>::Commitment,
}
```

**File:** types/src/dkg/real_dkg/mod.rs (L295-329)
```rust
    fn verify_transcript_extra(
        trx: &Self::Transcript,
        verifier: &ValidatorVerifier,
        checks_voting_power: bool,
        ensures_single_dealer: Option<AccountAddress>,
    ) -> anyhow::Result<()> {
        let all_validator_addrs = verifier.get_ordered_account_addresses();
        let main_trx_dealers = trx.main.get_dealers();
        let mut dealer_set = HashSet::with_capacity(main_trx_dealers.len());
        for dealer in main_trx_dealers.iter() {
            if let Some(dealer_addr) = all_validator_addrs.get(dealer.id) {
                dealer_set.insert(*dealer_addr);
            } else {
                bail!("invalid dealer idx");
            }
        }
        ensure!(main_trx_dealers.len() == dealer_set.len());
        if ensures_single_dealer.is_some() {
            let expected_dealer_set: HashSet<AccountAddress> =
                ensures_single_dealer.into_iter().collect();
            ensure!(expected_dealer_set == dealer_set);
        }

        if checks_voting_power {
            verifier
                .check_voting_power(dealer_set.iter(), true)
                .context("not enough power")?;
        }

        if let Some(fast_trx) = &trx.fast {
            ensure!(fast_trx.get_dealers() == main_trx_dealers);
            ensure!(trx.main.get_dealt_public_key() == fast_trx.get_dealt_public_key());
        }
        Ok(())
    }
```

**File:** aptos-move/aptos-vm/src/validator_txns/dkg.rs (L104-112)
```rust
        // Deserialize transcript and verify it.
        let pub_params = DefaultDKG::new_public_params(&in_progress_session_state.metadata);
        let transcript = bcs::from_bytes::<<DefaultDKG as DKGTrait>::Transcript>(
            dkg_node.transcript_bytes.as_slice(),
        )
        .map_err(|_| Expected(TranscriptDeserializationFailed))?;

        DefaultDKG::verify_transcript(&pub_params, &transcript)
            .map_err(|_| Expected(TranscriptVerificationFailed))?;
```

**File:** aptos-move/aptos-vm/src/validator_txns/mod.rs (L16-36)
```rust
    pub(crate) fn process_validator_transaction(
        &self,
        resolver: &impl AptosMoveResolver,
        module_storage: &impl AptosModuleStorage,
        txn: ValidatorTransaction,
        log_context: &AdapterLogSchema,
    ) -> Result<(VMStatus, VMOutput), VMStatus> {
        let session_id = SessionId::validator_txn(&txn);
        match txn {
            ValidatorTransaction::DKGResult(dkg_node) => {
                self.process_dkg_result(resolver, module_storage, log_context, session_id, dkg_node)
            },
            ValidatorTransaction::ObservedJWKUpdate(jwk_update) => self.process_jwk_update(
                resolver,
                module_storage,
                log_context,
                session_id,
                jwk_update,
            ),
        }
    }
```
