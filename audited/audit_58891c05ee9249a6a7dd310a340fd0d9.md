# Audit Report

## Title
Cross-Shard Commit Sender Spoofing Vulnerability Enables Consensus Safety Violations in Sharded Block Executor

## Summary
The sharded block executor lacks authentication mechanisms for cross-shard commit messages, allowing a malicious shard to impersonate any other shard and send fraudulent state updates. This breaks deterministic execution guarantees and can cause consensus safety violations.

## Finding Description

The sharded block execution system implements parallel transaction processing across multiple shards with cross-shard dependency resolution through message passing. When a transaction in one shard writes to state that another shard depends on, a `CrossShardCommitSender` sends a `RemoteTxnWriteMsg` containing the write operation.

**Vulnerability Chain:**

1. **No Sender Identification in Message Structure**: The `CrossShardMsg` enum contains no sender shard identification. [1](#0-0) 

2. **No Authentication in Message Sending**: When sending cross-shard messages, the `RemoteCrossShardClient` simply serializes and sends to the target shard without any sender authentication. [2](#0-1) 

3. **No Verification in Message Reception**: The receiving shard's `receive_cross_shard_msg()` deserializes the message without verifying which shard sent it. [3](#0-2) 

4. **GRPC Service Lacks Authentication**: The network layer receives messages and routes them based solely on message type, without authenticating the sender's identity or mapping socket addresses to shard IDs. [4](#0-3) 

5. **Unchecked State Updates**: The `CrossShardCommitReceiver` processes incoming messages and directly updates the `CrossShardStateView` without any validation. [5](#0-4) 

6. **Direct Value Setting**: The `CrossShardStateView.set_value()` accepts any value without verification. [6](#0-5) 

**Attack Scenario:**

A malicious Shard A can send fraudulent commit messages to Shard C, claiming to be Shard B:
- Shard C has a dependency on `state_key_X` from Shard B
- Malicious Shard A sends `RemoteTxnWriteMsg(state_key_X, fraudulent_value)` to Shard C
- Shard C receives and processes this message, updating its `CrossShardStateView` with the fraudulent value
- When Shard C executes transactions depending on `state_key_X`, it uses the fraudulent value
- Different validators receive different fraudulent messages, producing different state roots
- **Consensus safety is violated** - the network cannot agree on a single canonical state

## Impact Explanation

**Critical Severity** - This vulnerability falls under the "Consensus/Safety violations" category, which qualifies for up to $1,000,000 in the Aptos bug bounty program.

**Broken Invariants:**
1. **Deterministic Execution**: Validators no longer produce identical state roots for identical blocks when receiving different fraudulent messages
2. **Consensus Safety**: AptosBFT's safety guarantees are broken as different validators commit different states

**Potential Consequences:**
- Network fork requiring emergency intervention or hard fork
- Loss of liveness if validators cannot agree on state
- Corruption of on-chain state affecting all subsequent transactions
- Potential for coordinated attacks to maximize damage across multiple shards

This represents a fundamental consensus layer vulnerability that undermines the blockchain's core security guarantees.

## Likelihood Explanation

**Moderate to High Likelihood:**

**Prerequisites:**
- Requires a malicious or compromised shard operator
- Does NOT require > 1/3 Byzantine validators (single malicious shard can attack)
- No cryptographic barriers to overcome
- Attack is straightforward to execute once shard access is obtained

**Factors Increasing Likelihood:**
- Sharded execution is a performance-critical feature likely to be enabled in production
- No authentication makes attack trivial to execute
- Remote execution mode is designed for distributed deployments where network boundaries exist
- Single point of compromise can affect multiple shards

**Factors Decreasing Likelihood:**
- Requires insider access (shard operator role)
- May be limited to specific deployment configurations using remote sharded execution

The vulnerability is easier to exploit than traditional Byzantine fault tolerance assumptions (< 1/3 malicious) since a single malicious shard can corrupt others.

## Recommendation

Implement multi-layered sender authentication:

**1. Add Sender Identification to Messages:**
```rust
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct RemoteTxnWrite {
    sender_shard_id: ShardId,  // Add this field
    state_key: StateKey,
    write_op: Option<WriteOp>,
}
```

**2. Verify Sender in CrossShardCommitReceiver:**
```rust
pub fn start<S: StateView + Sync + Send>(
    expected_shard_id: ShardId,  // Pass expected sender
    cross_shard_state_view: Arc<CrossShardStateView<S>>,
    cross_shard_client: Arc<dyn CrossShardClient>,
    round: RoundId,
) {
    loop {
        let msg = cross_shard_client.receive_cross_shard_msg(round);
        match msg {
            RemoteTxnWriteMsg(txn_commit_msg) => {
                // Verify sender matches expected shard
                if txn_commit_msg.sender_shard_id != expected_shard_id {
                    error!("Received message from unexpected shard");
                    continue;
                }
                let (state_key, write_op) = txn_commit_msg.take();
                cross_shard_state_view.set_value(&state_key, write_op.and_then(|w| w.as_state_value()));
            },
            // ...
        }
    }
}
```

**3. Add Authentication Mapping in NetworkController:**
- Map socket addresses to authenticated shard IDs during setup
- Validate incoming messages against this mapping
- Reject messages from unexpected sources

**4. Add Cryptographic Signatures (Defense in Depth):**
- Sign cross-shard messages with shard-specific keys
- Verify signatures before processing messages
- Provides protection even if network layer is compromised

## Proof of Concept

```rust
// PoC demonstrating the vulnerability
// This would be integrated into the existing test suite

#[test]
fn test_cross_shard_spoofing_attack() {
    use std::sync::Arc;
    use aptos_types::state_store::state_key::StateKey;
    use aptos_types::write_set::WriteOp;
    
    // Setup: 3 shards with remote cross-shard clients
    let num_shards = 3;
    let (executor_client, mut executor_services) = 
        create_thread_remote_executor_shards(num_shards, Some(2));
    
    // Shard 0 (attacker) obtains reference to cross_shard_client
    let malicious_shard_client = // ... get from shard 0
    
    // Target: Shard 2 expects value from Shard 1
    let target_shard_id = 2;
    let legitimate_sender_shard_id = 1;
    let target_state_key = StateKey::raw(b"important_key");
    
    // Attacker (Shard 0) sends fraudulent message to Shard 2
    // pretending to be Shard 1
    let fraudulent_value = WriteOp::Modification(b"fraudulent_data".to_vec());
    malicious_shard_client.send_cross_shard_msg(
        target_shard_id,
        0,  // round
        CrossShardMsg::RemoteTxnWriteMsg(RemoteTxnWrite::new(
            target_state_key.clone(),
            Some(fraudulent_value)
        ))
    );
    
    // Shard 2 will accept and use the fraudulent value
    // without knowing it didn't come from Shard 1
    
    // Execute block and observe different state roots across validators
    // if they receive different fraudulent messages
    
    // Cleanup
    executor_services.iter_mut().for_each(|s| s.shutdown());
}
```

**Notes:**

This vulnerability is particularly dangerous because:
- It undermines the fundamental trust model of sharded execution
- A single compromised shard can corrupt multiple other shards
- The attack is undetectable without external monitoring
- Recovery requires identifying and correcting all corrupted state

The lack of authentication represents a critical oversight in the cross-shard communication protocol design that must be addressed before production deployment of the sharded block executor in distributed configurations.

### Citations

**File:** aptos-move/aptos-vm/src/sharded_block_executor/messages.rs (L7-11)
```rust
#[derive(Clone, Debug, Deserialize, Serialize)]
pub enum CrossShardMsg {
    RemoteTxnWriteMsg(RemoteTxnWrite),
    StopMsg,
}
```

**File:** execution/executor-service/src/remote_cross_shard_client.rs (L55-59)
```rust
    fn send_cross_shard_msg(&self, shard_id: ShardId, round: RoundId, msg: CrossShardMsg) {
        let input_message = bcs::to_bytes(&msg).unwrap();
        let tx = self.message_txs[shard_id][round].lock().unwrap();
        tx.send(Message::new(input_message)).unwrap();
    }
```

**File:** execution/executor-service/src/remote_cross_shard_client.rs (L61-66)
```rust
    fn receive_cross_shard_msg(&self, current_round: RoundId) -> CrossShardMsg {
        let rx = self.message_rxs[current_round].lock().unwrap();
        let message = rx.recv().unwrap();
        let msg: CrossShardMsg = bcs::from_bytes(&message.to_bytes()).unwrap();
        msg
    }
```

**File:** secure/net/src/grpc_network_service/mod.rs (L93-115)
```rust
    async fn simple_msg_exchange(
        &self,
        request: Request<NetworkMessage>,
    ) -> Result<Response<Empty>, Status> {
        let _timer = NETWORK_HANDLER_TIMER
            .with_label_values(&[&self.self_addr.to_string(), "inbound_msgs"])
            .start_timer();
        let remote_addr = request.remote_addr();
        let network_message = request.into_inner();
        let msg = Message::new(network_message.message);
        let message_type = MessageType::new(network_message.message_type);

        if let Some(handler) = self.inbound_handlers.lock().unwrap().get(&message_type) {
            // Send the message to the registered handler
            handler.send(msg).unwrap();
        } else {
            error!(
                "No handler registered for sender: {:?} and msg type {:?}",
                remote_addr, message_type
            );
        }
        Ok(Response::new(Empty {}))
    }
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/cross_shard_client.rs (L31-44)
```rust
        loop {
            let msg = cross_shard_client.receive_cross_shard_msg(round);
            match msg {
                RemoteTxnWriteMsg(txn_commit_msg) => {
                    let (state_key, write_op) = txn_commit_msg.take();
                    cross_shard_state_view
                        .set_value(&state_key, write_op.and_then(|w| w.as_state_value()));
                },
                CrossShardMsg::StopMsg => {
                    trace!("Cross shard commit receiver stopped for round {}", round);
                    break;
                },
            }
        }
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/cross_shard_state_view.rs (L49-56)
```rust
    pub fn set_value(&self, state_key: &StateKey, state_value: Option<StateValue>) {
        self.cross_shard_data
            .get(state_key)
            .unwrap()
            .set_value(state_value);
        // uncomment the following line to debug waiting count
        // trace!("waiting count for shard id {} is {}", self.shard_id, self.waiting_count());
    }
```
