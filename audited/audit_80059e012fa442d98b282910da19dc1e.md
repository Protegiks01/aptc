# Audit Report

## Title
Platform-Dependent BCS Deserialization of OnChainConsensusConfig Breaks Consensus Determinism Due to usize Fields

## Summary
The `validator_txn_enabled()` native function in `consensus_config.rs` deserializes `OnChainConsensusConfig` from on-chain bytes using BCS. However, `OnChainConsensusConfig` contains several `usize` fields which serialize differently on 32-bit versus 64-bit platforms. When deserialization fails due to platform incompatibility, the `.unwrap_or_default()` silently returns a default configuration with validator transactions disabled, causing different validators on different platforms to have divergent consensus state.

## Finding Description
The vulnerability exists in the interaction between three components:

1. **Native function with silent failure**: [1](#0-0) 

The function uses `.unwrap_or_default()` which masks deserialization failures and returns a default config.

2. **Default config disables validator transactions**: [2](#0-1) 

The default uses `ValidatorTxnConfig::default_if_missing()` which returns `V0` (disabled): [3](#0-2) 

3. **Platform-dependent usize fields in serialized structs**: The `OnChainConsensusConfig` hierarchy contains multiple `usize` fields:
   - [4](#0-3) 
   - [5](#0-4) 
   - [6](#0-5) 

**The BCS specification does NOT support `usize`/`isize`** as they are platform-dependent. When serde serializes `usize`:
- On 64-bit platforms: serializes as 8-byte little-endian (u64)
- On 32-bit platforms: serializes as 4-byte little-endian (u32)

**Attack Scenario:**
1. Malicious governance proposal sets `max_failed_authors_to_store` to 5,000,000,000 (exceeds u32::MAX)
2. Config serialized on 64-bit validator and stored on-chain (8 bytes for usize field)
3. All current 64-bit validators deserialize successfully, validator transactions remain **enabled**
4. Future 32-bit validator (embedded device, WASM, or cross-platform testing) attempts deserialization:
   - Expects 4 bytes for usize field but encounters 8 bytes
   - Byte stream becomes misaligned
   - Deserialization fails with BCS error
5. The `.unwrap_or_default()` silently catches the error and returns default config
6. 32-bit validator sees validator transactions as **disabled** while 64-bit validators see **enabled**
7. Consensus safety violation: validators execute different transaction sets

The vulnerability is called from Move code: [7](#0-6) 

## Impact Explanation
This is a **Critical Severity** vulnerability (up to $1,000,000) because it constitutes a **Consensus Safety Violation**:

- **Breaks Deterministic Execution Invariant**: Different validators produce different state roots for identical blocks when running on different platforms
- **Enables Consensus Splits**: Validators with different architecture interpretations would fork the chain
- **Non-recoverable without hardfork**: Once divergent state is committed, reconciliation requires hardfork to fix the consensus config structure

Even though current Aptos validators likely run on 64-bit systems, this violates the fundamental guarantee that BCS deserialization must be deterministic across all platforms, which is a core requirement for any blockchain consensus system.

## Likelihood Explanation
**Current Likelihood: Low** - All production validators currently run on 64-bit Linux/x86_64 systems.

**Future Likelihood: Medium-to-High** when:
- Aptos expands to embedded validator hardware
- WebAssembly-based light clients or validators are deployed  
- Cross-platform testing reveals the issue
- Any architecture diversity is introduced to the validator set

**Exploitability**: Requires governance proposal approval to set malicious config values exceeding u32::MAX, making it governance-gated but still feasible through compromised or malicious proposals.

The silent failure via `.unwrap_or_default()` makes this particularly dangerous as there's no error logging or detection when deserialization fails on incompatible platforms.

## Recommendation
Replace all `usize` fields in `OnChainConsensusConfig` and related structs with explicit fixed-width types (`u32` or `u64`):

**In `ConsensusConfigV1`:**
```rust
pub struct ConsensusConfigV1 {
    pub decoupled_execution: bool,
    pub back_pressure_limit: u64,
    pub exclude_round: u64,
    pub proposer_election_type: ProposerElectionType,
    pub max_failed_authors_to_store: u64, // Changed from usize
}
```

**In `ProposerAndVoterConfig`:**
```rust
pub struct ProposerAndVoterConfig {
    pub active_weight: u64,
    pub inactive_weight: u64,
    pub failed_weight: u64,
    pub failure_threshold_percent: u32,
    pub proposer_window_num_validators_multiplier: u64, // Changed from usize
    pub voter_window_num_validators_multiplier: u64,     // Changed from usize
    pub weight_by_voting_power: bool,
    pub use_history_from_previous_epoch_max_count: u32,
}
```

**In `DagConsensusConfigV1`:**
```rust
pub struct DagConsensusConfigV1 {
    pub dag_ordering_causal_history_window: u64, // Changed from usize
    pub anchor_election_mode: AnchorElectionMode,
}
```

Additionally, remove the silent failure handling:
```rust
pub fn validator_txn_enabled(
    _context: &mut SafeNativeContext,
    _ty_args: &[Type],
    mut args: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    let config_bytes = safely_pop_arg!(args, Vec<u8>);
    let config = bcs::from_bytes::<OnChainConsensusConfig>(&config_bytes)
        .map_err(|e| SafeNativeError::InvariantViolation(
            PartialVMError::new(StatusCode::INTERNAL_TYPE_ERROR)
                .with_message(format!("Failed to deserialize consensus config: {}", e))
        ))?; // Fail explicitly instead of using default
    Ok(smallvec![Value::bool(config.is_vtxn_enabled())])
}
```

## Proof of Concept
```rust
// Proof of Concept demonstrating platform-dependent serialization
#[test]
fn test_usize_platform_dependency() {
    use aptos_types::on_chain_config::{ConsensusConfigV1, OnChainConsensusConfig};
    
    // Create config with large usize value (> u32::MAX on 32-bit)
    let config = OnChainConsensusConfig::V1(ConsensusConfigV1 {
        max_failed_authors_to_store: 5_000_000_000, // Exceeds u32::MAX
        ..ConsensusConfigV1::default()
    });
    
    // Serialize on 64-bit platform
    let serialized = bcs::to_bytes(&config).unwrap();
    println!("Serialized length: {} bytes", serialized.len());
    
    // On 64-bit: deserialization succeeds
    let deserialized = bcs::from_bytes::<OnChainConsensusConfig>(&serialized);
    assert!(deserialized.is_ok());
    
    // Simulate 32-bit incompatibility:
    // If this were a 32-bit platform, the usize field would be read as 4 bytes
    // instead of 8 bytes, causing misalignment and deserialization failure.
    // The .unwrap_or_default() would then return V4 config with vtxn disabled.
    
    let config_with_default = bcs::from_bytes::<OnChainConsensusConfig>(&serialized)
        .unwrap_or_default();
    
    // On 64-bit: vtxn stays enabled (original config preserved)
    // On 32-bit: would deserialize to default with vtxn DISABLED
    // This divergence breaks consensus!
}
```

**Notes**

The BCS linter at [8](#0-7)  checks for unsupported types like F32, F64, and Char but does NOT check for `usize`/`isize`, allowing this platform-dependent type to pass validation. This is a gap in the BCS format validation that enabled this vulnerability to exist.

### Citations

**File:** aptos-move/framework/src/natives/consensus_config.rs (L18-19)
```rust
    let config_bytes = safely_pop_arg!(args, Vec<u8>);
    let config = bcs::from_bytes::<OnChainConsensusConfig>(&config_bytes).unwrap_or_default();
```

**File:** types/src/on_chain_config/consensus_config.rs (L147-149)
```rust
    pub fn default_if_missing() -> Self {
        Self::V0
    }
```

**File:** types/src/on_chain_config/consensus_config.rs (L443-450)
```rust
impl Default for OnChainConsensusConfig {
    fn default() -> Self {
        OnChainConsensusConfig::V4 {
            alg: ConsensusAlgorithmConfig::default_if_missing(),
            vtxn: ValidatorTxnConfig::default_if_missing(),
            window_size: DEFAULT_WINDOW_SIZE,
        }
    }
```

**File:** types/src/on_chain_config/consensus_config.rs (L478-478)
```rust
    pub max_failed_authors_to_store: usize,
```

**File:** types/src/on_chain_config/consensus_config.rs (L565-568)
```rust
    pub proposer_window_num_validators_multiplier: usize,
    // Window into history considered for votre statistics, multiplier
    // on top of number of validators
    pub voter_window_num_validators_multiplier: usize,
```

**File:** types/src/on_chain_config/consensus_config.rs (L586-586)
```rust
    pub dag_ordering_causal_history_window: usize,
```

**File:** aptos-move/framework/aptos-framework/sources/configs/consensus_config.move (L71-73)
```text
    public fun validator_txn_enabled(): bool acquires ConsensusConfig {
        let config_bytes = borrow_global<ConsensusConfig>(@aptos_framework).config;
        validator_txn_enabled_internal(config_bytes)
```

**File:** testsuite/generate-format/src/linter.rs (L14-14)
```rust
            F32 | F64 | Char => Err(Error::Custom(format!("BCS does not support type {:?}", f))),
```
