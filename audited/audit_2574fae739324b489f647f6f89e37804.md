# Audit Report

## Title
Cache Key Collision Vulnerability in ProofOfStore Verification Allows Signature Verification Bypass

## Summary
The `ProofOfStore::verify()` function uses a shared cache keyed by `BatchInfoExt`, but performs signature verification over different types (`BatchInfo` or `BatchInfoExt`) that use distinct cryptographic hash seeds. This creates a cache collision vulnerability where a signature verified for `BatchInfo` can be accepted for `BatchInfoExt` without proper cryptographic verification, leading to consensus divergence.

## Finding Description

The vulnerability exists in the interaction between caching logic and the CryptoHasher domain separation system.

**Core Issue:**

The `ProofOfStore::verify()` method converts `self.info` to `BatchInfoExt` for cache lookup but verifies the signature over the original `self.info` type: [1](#0-0) 

When `self.info` is `BatchInfo`, it gets converted to `BatchInfoExt::V1` for caching via the From implementation: [2](#0-1) 

**Cryptographic Domain Separation Issue:**

The `signing_message()` function prepends type-specific CryptoHasher seeds before BCS serialization: [3](#0-2) 

This means:
- `BatchInfo` signatures use `BatchInfoHasher::seed()` + bcs(BatchInfo)
- `BatchInfoExt` signatures use `BatchInfoExtHasher::seed()` + bcs(BatchInfoExt)

These seeds are generated from serde type names and are cryptographically different: [4](#0-3) 

**Both Message Types Share the Same Cache:**

The `ProofCache` type is defined as: [5](#0-4) 

Both `ProofOfStoreMsg<BatchInfo>` (v1) and `ProofOfStoreMsgV2<BatchInfoExt>` (v2) use the same cache instance during verification: [6](#0-5) 

The cache is created once per epoch by the EpochManager: [7](#0-6) 

**Attack Scenario:**

1. **V1 Message Processed First:** Validator receives `ProofOfStoreMsg<BatchInfo>` with (info=A, signature=S)
   - Line 636: Converts `BatchInfo A` → `BatchInfoExt::V1(A)` for cache key
   - Line 643: Verifies S over `BatchInfo A` using `BatchInfoHasher::seed()` ✓ Valid
   - Line 649: Caches `BatchInfoExt::V1(A) → S`

2. **V2 Message Arrives:** Attacker broadcasts `ProofOfStoreMsgV2<BatchInfoExt>` with (info=`BatchInfoExt::V1(A)`, signature=S)
   - Line 636: `BatchInfoExt::V1(A)` → `BatchInfoExt::V1(A)` (identity)
   - Line 637: Cache lookup finds `BatchInfoExt::V1(A) → S`
   - Line 639: Returns Ok() **without verifying S with BatchInfoExtHasher::seed()**

The signature S was never verified against the correct cryptographic domain for `BatchInfoExt`. 

**Consensus Divergence:**

Validators that processed the v1 message will accept the v2 message via cache hit. Validators that only see the v2 message will reject it (signature invalid under `BatchInfoExtHasher::seed()`). This creates **non-deterministic verification** where different validators reach different conclusions about the same proof.

## Impact Explanation

This is a **Critical Severity** vulnerability under Aptos bug bounty criteria category "Consensus/Safety Violations."

**Critical Impact: Consensus Safety Violation**

The vulnerability enables consensus divergence where different validators accept different sets of proofs:

1. **Non-Deterministic Proof Acceptance:** Validators processing messages in different orders will reach different states about which proofs are valid
2. **Byzantine Fault Tolerance Compromise:** The system's BFT guarantees assume all honest validators agree on message validity, but this cache collision breaks that assumption
3. **Potential Chain Splits:** If different validator sets accept different proofs, they may propose and vote on different blocks

The vulnerability requires **< 1/3 Byzantine validators** (actually requires 0 Byzantine validators - just network message ordering differences), making it a clear consensus safety violation under Aptos security model.

**Violates Cryptographic Domain Separation:**

The CryptoHasher seed system exists specifically to prevent signatures from one cryptographic context being valid in another. This vulnerability completely undermines that protection by allowing cache-based bypass of proper signature verification under the correct hash domain.

## Likelihood Explanation

**High Likelihood** - The attack is practical with:

1. **No Privileged Access Required:** Any network peer can broadcast consensus messages. Both message types are accepted by the consensus network interface: [8](#0-7) 

2. **Low Attack Complexity:** Attacker only needs to:
   - Observe legitimate `ProofOfStoreMsg<BatchInfo>` messages on the network
   - Rebroadcast the same proof data as `ProofOfStoreMsgV2<BatchInfoExt>` with type conversion
   - No cryptographic operations or computational resources required

3. **Active Exploitation Window:** The vulnerability is exploitable whenever both v1 and v2 messages coexist:
   - During protocol upgrades
   - Backward compatibility periods
   - Normal operation (both message types are currently supported)

4. **Deterministic Success:** The cache behavior is deterministic - if a validator processes the v1 message before the v2 message, the attack succeeds with 100% reliability.

## Recommendation

**Fix: Verify signature under correct hash domain before cache insertion**

The cache key should include the actual type being verified, not just the converted `BatchInfoExt`:

```rust
pub fn verify(&self, validator: &ValidatorVerifier, cache: &ProofCache) -> anyhow::Result<()> {
    // Verify FIRST with the correct type's hash domain
    let result = validator
        .verify_multi_signatures(&self.info, &self.multi_signature)
        .context(format!(
            "Failed to verify ProofOfStore for batch: {:?}",
            self.info
        ));
    
    // Only cache AFTER successful verification
    if result.is_ok() {
        let batch_info_ext: BatchInfoExt = self.info.clone().into();
        cache.insert(batch_info_ext, self.multi_signature.clone());
    }
    result
}
```

Or alternatively, separate caches for v1 and v2:

```rust
pub type ProofCacheV1 = Cache<BatchInfo, AggregateSignature>;
pub type ProofCacheV2 = Cache<BatchInfoExt, AggregateSignature>;
```

## Proof of Concept

A complete PoC would demonstrate:
1. Create a valid `ProofOfStoreMsg<BatchInfo>` with signature from validators
2. Process it on Validator Node A (caches the proof)
3. Broadcast `ProofOfStoreMsgV2<BatchInfoExt::V1>` with same signature
4. Validator Node A accepts via cache hit
5. Validator Node B (without cache) rejects due to invalid signature
6. Observe consensus divergence: Node A and B have different proof acceptance states

The vulnerability is demonstrated by the code paths shown above where cache lookup precedes signature verification, allowing cryptographic domain separation bypass through cache collision.

## Notes

This vulnerability is particularly critical because:
- It violates fundamental cryptographic design principles (domain separation via CryptoHasher seeds)
- It can cause consensus divergence with 0 Byzantine validators
- It's triggered by normal network conditions (message ordering differences)
- It affects a core consensus mechanism (proof-of-store verification)
- The attack requires no special privileges or resources

### Citations

**File:** consensus/consensus-types/src/proof_of_store.rs (L120-124)
```rust
impl From<BatchInfo> for BatchInfoExt {
    fn from(info: BatchInfo) -> Self {
        Self::V1 { info }
    }
}
```

**File:** consensus/consensus-types/src/proof_of_store.rs (L616-616)
```rust
pub type ProofCache = Cache<BatchInfoExt, AggregateSignature>;
```

**File:** consensus/consensus-types/src/proof_of_store.rs (L635-652)
```rust
    pub fn verify(&self, validator: &ValidatorVerifier, cache: &ProofCache) -> anyhow::Result<()> {
        let batch_info_ext: BatchInfoExt = self.info.clone().into();
        if let Some(signature) = cache.get(&batch_info_ext) {
            if signature == self.multi_signature {
                return Ok(());
            }
        }
        let result = validator
            .verify_multi_signatures(&self.info, &self.multi_signature)
            .context(format!(
                "Failed to verify ProofOfStore for batch: {:?}",
                self.info
            ));
        if result.is_ok() {
            cache.insert(batch_info_ext, self.multi_signature.clone());
        }
        result
    }
```

**File:** crates/aptos-crypto/src/traits/mod.rs (L168-177)
```rust
/// Returns the signing message for the given message.
/// It is used by `SigningKey#sign` function.
pub fn signing_message<T: CryptoHash + Serialize>(
    message: &T,
) -> Result<Vec<u8>, CryptoMaterialError> {
    let mut bytes = <T::Hasher as CryptoHasher>::seed().to_vec();
    bcs::serialize_into(&mut bytes, &message)
        .map_err(|_| CryptoMaterialError::SerializationError)?;
    Ok(bytes)
}
```

**File:** crates/aptos-crypto-derive/src/lib.rs (L406-413)
```rust
        impl aptos_crypto::hash::CryptoHasher for #hasher_name {
            fn seed() -> &'static [u8; 32] {
                #static_seed_name.get_or_init(|| {
                    let name = aptos_crypto::_serde_name::trace_name::<#type_name #param>()
                        .expect("The `CryptoHasher` macro only applies to structs and enums.").as_bytes();
                    aptos_crypto::hash::DefaultHasher::prefixed_hash(&name)
                })
            }
```

**File:** consensus/src/round_manager.rs (L212-229)
```rust
            UnverifiedEvent::ProofOfStoreMsg(p) => {
                if !self_message {
                    p.verify(max_num_batches, validator, proof_cache)?;
                    counters::VERIFY_MSG
                        .with_label_values(&["proof_of_store"])
                        .observe(start_time.elapsed().as_secs_f64());
                }
                VerifiedEvent::ProofOfStoreMsg(Box::new((*p).into()))
            },
            UnverifiedEvent::ProofOfStoreMsgV2(p) => {
                if !self_message {
                    p.verify(max_num_batches, validator, proof_cache)?;
                    counters::VERIFY_MSG
                        .with_label_values(&["proof_of_store_v2"])
                        .observe(start_time.elapsed().as_secs_f64());
                }
                VerifiedEvent::ProofOfStoreMsg(p)
            },
```

**File:** consensus/src/epoch_manager.rs (L250-254)
```rust
            proof_cache: Cache::builder()
                .max_capacity(node_config.consensus.proof_cache_capacity)
                .initial_capacity(1_000)
                .time_to_live(Duration::from_secs(20))
                .build(),
```

**File:** consensus/src/network_interface.rs (L78-102)
```rust
    ProofOfStoreMsg(Box<ProofOfStoreMsg<BatchInfo>>),
    /// DAG protocol message
    DAGMessage(DAGNetworkMessage),
    /// Commit message
    CommitMessage(Box<CommitMessage>),
    /// Randomness generation message
    RandGenMessage(RandGenMessage),
    /// Quorum Store: Response to the batch request.
    BatchResponseV2(Box<BatchResponse>),
    /// OrderVoteMsg is the struct that is broadcasted by a validator on receiving quorum certificate
    /// on a block.
    OrderVoteMsg(Box<OrderVoteMsg>),
    /// RoundTimeoutMsg is broadcasted by a validator once it decides to timeout the current round.
    RoundTimeoutMsg(Box<RoundTimeoutMsg>),
    /// RPC to get a chain of block of the given length starting from the given block id, using epoch and round.
    BlockRetrievalRequest(Box<BlockRetrievalRequest>),
    /// OptProposalMsg contains the optimistic proposal and sync info.
    OptProposalMsg(Box<OptProposalMsg>),
    /// Quorum Store: Send a Batch of transactions.
    BatchMsgV2(Box<BatchMsg<BatchInfoExt>>),
    /// Quorum Store: Send a signed batch digest with BatchInfoExt. This is a vote for the batch and a promise that
    /// the batch of transactions was received and will be persisted until batch expiration.
    SignedBatchInfoMsgV2(Box<SignedBatchInfoMsg<BatchInfoExt>>),
    /// Quorum Store: Broadcast a certified proof of store (a digest that received 2f+1 votes) with BatchInfoExt.
    ProofOfStoreMsgV2(Box<ProofOfStoreMsg<BatchInfoExt>>),
```
