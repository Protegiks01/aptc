# Audit Report

## Title
Insecure File Permissions Expose Validator Consensus and Account Private Keys to Local Attackers

## Summary
Multiple functions that write sensitive identity files containing validator consensus keys, account private keys, and network private keys fail to set secure file permissions on Unix systems. Files are created with default umask permissions (typically 0644), making them world-readable and exposing critical cryptographic material to any local user on the validator node.

## Finding Description

The Aptos Core codebase contains several functions that write `IdentityBlob` objects to disk without setting proper file permissions. The `IdentityBlob` struct contains highly sensitive cryptographic keys essential for validator operation:
- `account_private_key` (Ed25519): Used for validator account operations and fund management
- `consensus_private_key` (BLS12-381): Used for signing consensus messages and participating in AptosBFT
- `network_private_key` (x25519): Used for secure P2P communication

**Vulnerable Function #1: `write_yaml()` in Genesis Builder** [1](#0-0) 

This function uses `File::create()` without setting file permissions and is used to write validator identity files during genesis setup: [2](#0-1) 

**Vulnerable Function #2: `Identity::save_private_key()`** [3](#0-2) 

This function is called in production to save fullnode network identity keys: [4](#0-3) 

**Vulnerable Function #3: `IdentityBlob::to_file()`** [5](#0-4) 

This function has an additional bug (using `File::open()` instead of `File::create()`), but even if corrected, would not set secure permissions.

**The Security Breach:**
On Unix systems, `File::create()` creates files using the process's umask. The typical default umask is 0022, resulting in files with 0644 permissions (rw-r--r--), which are world-readable. This violates the fundamental security requirement that private keys must never be readable by unauthorized users.

**Secure Implementation Exists But Not Used:**
The codebase already has a secure helper function that properly sets 0600 permissions on Unix: [6](#0-5) 

This function is used correctly for writing keys in the CLI tools: [7](#0-6) 

However, the vulnerable functions in the genesis builder and config optimizer do not use this secure helper.

**Attack Scenario:**
1. Validator operator sets up a validator node on a shared or multi-user system
2. Genesis process creates identity files using `write_yaml()` with world-readable permissions (0644)
3. Local attacker (malicious system administrator, compromised service account, or other local user) reads the identity files
4. Attacker extracts the consensus private key (BLS), account private key (Ed25519), and network private key (x25519)
5. Attacker can now:
   - Sign arbitrary consensus messages as the validator (consensus safety violation)
   - Submit transactions from the validator's account (fund theft)
   - Impersonate the validator in P2P network communications
   - Cause double-signing or equivocation, potentially slashing the validator

## Impact Explanation

This vulnerability qualifies as **Critical Severity** under the Aptos Bug Bounty program for multiple reasons:

1. **Consensus Safety Violation**: An attacker with the consensus private key can sign malicious blocks, violate consensus safety rules, and potentially cause chain splits or safety breaks in AptosBFT.

2. **Loss of Funds**: The account private key controls the validator's stake and rewards. An attacker can drain all funds from the validator account.

3. **Validator Compromise**: Complete compromise of validator identity allows the attacker to impersonate the validator, sign arbitrary consensus messages, and participate in malicious consensus behavior.

4. **Network-Wide Impact**: If multiple validators are compromised through this vulnerability, it could enable coordinated attacks on the consensus layer, potentially exceeding the 1/3 Byzantine fault tolerance threshold.

The vulnerability breaks the **Cryptographic Correctness** invariant: "BLS signatures, VRF, and hash operations must be secure." When private keys are exposed to unauthorized parties, all cryptographic security guarantees are void.

## Likelihood Explanation

**Likelihood: Very High**

The vulnerability is **trivially exploitable** with the following characteristics:

1. **No Special Privileges Required**: Any local user on the system can read world-readable files using standard Unix tools (`cat`, `cp`, etc.)

2. **Common Deployment Scenarios**: Many validator deployments use shared infrastructure, cloud VMs with multiple services, or containerized environments where file isolation may be imperfect

3. **Automatic Exploitation**: The vulnerability triggers automatically during normal genesis setup - no specific attack trigger is needed

4. **Wide Attack Surface**: Multiple functions are vulnerable, and they execute in critical code paths (genesis setup, config optimization)

5. **Long Exposure Window**: Identity files persist on disk indefinitely, providing attackers with an unlimited time window to discover and exploit the vulnerability

6. **Detection Difficulty**: World-readable file permissions are a silent failure - operators may not notice the exposure until after compromise

Real-world scenarios where exploitation is likely:
- Shared hosting environments
- Cloud VMs with monitoring agents or backup services running as different users
- Containerized deployments with inadequate volume permission management
- Systems with compromised non-root accounts
- Development/staging environments with lax security controls

## Recommendation

**Immediate Fix: Use OpenOptions with Proper Permissions**

Replace all vulnerable file creation calls with the secure pattern already used in `write_to_user_only_file()`:

**For `write_yaml()` function:**
```rust
use std::fs::OpenOptions;
#[cfg(unix)]
use std::os::unix::fs::OpenOptionsExt;

fn write_yaml<T: Serialize>(path: &Path, object: &T) -> anyhow::Result<()> {
    let mut opts = OpenOptions::new();
    opts.write(true).create(true).truncate(true);
    
    #[cfg(unix)]
    opts.mode(0o600);
    
    let mut file = opts.open(path)?;
    file.write_all(serde_yaml::to_string(object)?.as_bytes())?;
    Ok(())
}
```

**For `Identity::save_private_key()`:**
```rust
pub fn save_private_key(path: &PathBuf, key: &x25519::PrivateKey) -> anyhow::Result<()> {
    let parent_path = path.parent().unwrap();
    fs::create_dir_all(parent_path)?;
    
    let mut opts = OpenOptions::new();
    opts.write(true).create(true).truncate(true);
    
    #[cfg(unix)]
    opts.mode(0o600);
    
    opts.open(path)?
        .write_all(&key.to_bytes())
        .map_err(|error| error.into())
}
```

**For `IdentityBlob::to_file()`:**
```rust
pub fn to_file(&self, path: &Path) -> anyhow::Result<()> {
    let mut opts = OpenOptions::new();
    opts.write(true).create(true).truncate(true);
    
    #[cfg(unix)]
    opts.mode(0o600);
    
    let mut file = opts.open(path)?;
    file.write_all(serde_yaml::to_string(self)?.as_bytes())?;
    Ok(())
}
```

**Alternative: Reuse Existing Secure Helper**

Better yet, refactor to use the existing secure helper function or create a common secure file writing utility in the config crate.

**Additional Security Measures:**
1. Add CI/CD checks to enforce that all file creation operations involving sensitive data use secure permissions
2. Document the security requirement for file permissions in developer guidelines
3. Conduct security audit of all file I/O operations to identify similar issues
4. Add runtime checks to verify file permissions after creation and log warnings for insecure permissions

## Proof of Concept

**Rust Reproduction Steps:**

```rust
use std::fs::{File, OpenOptions};
use std::io::Write;
use std::os::unix::fs::PermissionsExt;
use tempfile::TempDir;

#[test]
fn test_insecure_file_permissions_vulnerability() {
    let temp_dir = TempDir::new().unwrap();
    let insecure_file = temp_dir.path().join("insecure_key.yaml");
    let secure_file = temp_dir.path().join("secure_key.yaml");
    
    // Vulnerable pattern (current implementation)
    let mut file = File::create(&insecure_file).unwrap();
    file.write_all(b"private_key: supersecret123").unwrap();
    
    // Check permissions - will show world-readable (0644 or 0664)
    let metadata = std::fs::metadata(&insecure_file).unwrap();
    let permissions = metadata.permissions();
    let mode = permissions.mode() & 0o777;
    println!("Insecure file permissions: {:o}", mode);
    
    // On most systems, this will be 0644 (world-readable)
    assert!(mode & 0o004 != 0, "File is world-readable!");
    
    // Secure pattern (recommended fix)
    let mut opts = OpenOptions::new();
    opts.write(true).create(true).truncate(true);
    #[cfg(unix)]
    opts.mode(0o600);
    
    let mut file = opts.open(&secure_file).unwrap();
    file.write_all(b"private_key: supersecret123").unwrap();
    
    // Check permissions - should be 0600 (user-only)
    let metadata = std::fs::metadata(&secure_file).unwrap();
    let permissions = metadata.permissions();
    let mode = permissions.mode() & 0o777;
    println!("Secure file permissions: {:o}", mode);
    
    // Verify secure permissions
    assert_eq!(mode, 0o600, "File should have 0600 permissions");
}
```

**Exploitation PoC (Local User):**

```bash
#!/bin/bash
# Attacker with local access to validator node

# Assume validator has created identity files in /opt/aptos/genesis/
IDENTITY_FILE="/opt/aptos/genesis/validator-identity.yaml"

# Check if file exists and is readable
if [ -r "$IDENTITY_FILE" ]; then
    echo "[+] Found world-readable validator identity file"
    
    # Extract the private keys
    echo "[+] Extracting private keys..."
    cat "$IDENTITY_FILE"
    
    # Parse YAML to extract specific keys
    consensus_key=$(grep "consensus_private_key" "$IDENTITY_FILE" | cut -d: -f2 | tr -d ' ')
    account_key=$(grep "account_private_key" "$IDENTITY_FILE" | cut -d: -f2 | tr -d ' ')
    network_key=$(grep "network_private_key" "$IDENTITY_FILE" | cut -d: -f2 | tr -d ' ')
    
    echo "[+] Consensus Key: $consensus_key"
    echo "[+] Account Key: $account_key"
    echo "[+] Network Key: $network_key"
    echo "[+] Validator compromised - attacker can now sign consensus messages and drain funds"
else
    echo "[-] File not found or not readable"
fi
```

**Notes**

This vulnerability affects all Aptos validators that use the standard genesis setup process or auto-generated fullnode identities. The impact extends beyond individual validators to the entire network's consensus security, as compromised consensus keys can be used to violate AptosBFT safety guarantees. The fix is straightforward and follows a pattern already established in the codebase, making it immediately implementable without architectural changes.

### Citations

**File:** crates/aptos-genesis/src/builder.rs (L145-148)
```rust
            write_yaml(val_identity_file.as_path(), &validator_identity)?;
            write_yaml(vfn_identity_file.as_path(), &vfn_identity)?;
            write_yaml(private_identity_file.as_path(), &private_identity)?;
            write_yaml(public_identity_file.as_path(), &public_identity)?;
```

**File:** crates/aptos-genesis/src/builder.rs (L418-421)
```rust
fn write_yaml<T: Serialize>(path: &Path, object: &T) -> anyhow::Result<()> {
    File::create(path)?.write_all(serde_yaml::to_string(object)?.as_bytes())?;
    Ok(())
}
```

**File:** config/src/config/identity_config.rs (L44-47)
```rust
    pub fn to_file(&self, path: &Path) -> anyhow::Result<()> {
        let mut file = File::open(path)?;
        Ok(file.write_all(serde_yaml::to_string(self)?.as_bytes())?)
    }
```

**File:** config/src/config/identity_config.rs (L117-126)
```rust
    pub fn save_private_key(path: &PathBuf, key: &x25519::PrivateKey) -> anyhow::Result<()> {
        // Create the parent directory
        let parent_path = path.parent().unwrap();
        fs::create_dir_all(parent_path)?;

        // Save the private key to the specified path
        File::create(path)?
            .write_all(&key.to_bytes())
            .map_err(|error| error.into())
    }
```

**File:** config/src/config/config_optimizer.rs (L230-230)
```rust
                    Identity::save_private_key(&path, &config_key.private_key())?;
```

**File:** crates/aptos/src/common/utils.rs (L224-228)
```rust
pub fn write_to_user_only_file(path: &Path, name: &str, bytes: &[u8]) -> CliTypedResult<()> {
    let mut opts = OpenOptions::new();
    #[cfg(unix)]
    opts.mode(0o600);
    write_to_file_with_opts(path, name, bytes, &mut opts)
```

**File:** crates/aptos/src/genesis/keys.rs (L82-97)
```rust
        write_to_user_only_file(
            private_keys_file.as_path(),
            PRIVATE_KEYS_FILE,
            to_yaml(&private_identity)?.as_bytes(),
        )?;
        write_to_user_only_file(
            public_keys_file.as_path(),
            PUBLIC_KEYS_FILE,
            to_yaml(&public_identity)?.as_bytes(),
        )?;
        write_to_user_only_file(
            validator_file.as_path(),
            VALIDATOR_FILE,
            to_yaml(&validator_blob)?.as_bytes(),
        )?;
        write_to_user_only_file(vfn_file.as_path(), VFN_FILE, to_yaml(&vfn_blob)?.as_bytes())?;
```
