# Audit Report

## Title
Missing Signature Verification in Order Vote Aggregation Error Path

## Summary
The `aggregate_and_verify` function in the signature aggregation logic contains a code path that returns an unverified aggregated signature when initial verification fails. This occurs in the error recovery path where invalid signatures are filtered and re-aggregated, but the second aggregation is returned without cryptographic verification.

## Finding Description

The vulnerability exists in the signature aggregation flow used by the consensus order vote system: [1](#0-0) 

When order votes are collected, the `aggregate_and_verify` function is called to aggregate signatures and verify them: [2](#0-1) 

The critical issue occurs in the error recovery path:
1. Initial aggregation and verification is attempted (line 521-523 in ledger_info.rs)
2. If verification fails, invalid signatures are filtered (line 530)
3. Signatures are re-aggregated (line 532)
4. **The function returns Ok() WITHOUT re-verifying the new aggregate** (line 533)

This causes the `OrderVoteStatus::EnoughVotes` status to be set with an unverified `LedgerInfoWithSignatures`: [3](#0-2) 

Subsequently, `has_enough_order_votes()` returns true based solely on the cached status without signature validation: [4](#0-3) 

The unverified `LedgerInfoWithSignatures` is then used directly in consensus decisions and inserted into the block store without re-verification: [5](#0-4) 

## Impact Explanation

This violates **Critical Invariant #10: Cryptographic Correctness** - the system should never trust cryptographic material without verification.

**Theoretical Impact**: If the re-aggregation produces an invalid signature (due to BLS implementation bugs, incorrect bitvec handling, or validator set mapping errors), the system would:
- Accept invalid order votes as valid
- Form incorrect quorum certificates
- Potentially cause consensus safety violations or chain splits

**Practical Limitation**: BLS signature mathematical properties guarantee that aggregating individually-valid signatures produces a valid aggregate signature. The `filter_invalid_signatures` function verifies each signature individually: [6](#0-5) 

Therefore, exploitation requires either:
1. A bug in the BLS cryptographic implementation itself
2. A bug in the filtering logic that allows invalid signatures to pass
3. Memory corruption or other Rust safety violations

**Severity Assessment**: While the code violates defense-in-depth principles, demonstrating concrete exploitability requires breaking the mathematical properties of BLS signatures or finding bugs in the underlying crypto implementation, which is out of scope per the audit guidelines ("Cryptographic primitives are assumed secure").

## Likelihood Explanation

**Likelihood: Very Low** 

The vulnerability requires:
- A scenario where initial aggregate verification fails (malicious or corrupted signatures)
- The filtering step to incorrectly identify valid/invalid signatures
- OR the BLS aggregation to produce an invalid result from valid individual signatures

The test suite demonstrates correct handling of invalid signatures: [7](#0-6) 

## Recommendation

Add cryptographic verification after the re-aggregation step to enforce defense-in-depth:

```rust
Err(_) => {
    self.filter_invalid_signatures(verifier);
    
    let aggregated_sig = self.try_aggregate(verifier)?;
    // FIX: Verify the re-aggregated signature
    verifier.verify_multi_signatures(&self.data, &aggregated_sig)
        .map_err(|e| {
            error!("Re-aggregated signature verification failed: {:?}", e);
            e
        })?;
    Ok((self.data.clone(), aggregated_sig))
},
```

This ensures all signatures are cryptographically verified before setting `EnoughVotes` status.

## Proof of Concept

Due to the mathematical properties of BLS signatures, creating a PoC that produces valid individual signatures but an invalid aggregate is not feasible without breaking the BLS cryptographic scheme itself. The vulnerability is a **defense-in-depth violation** rather than a directly exploitable attack vector under normal cryptographic assumptions.

---

## Notes

While I identified the missing verification in the error path, I must note that **this is primarily a code quality issue rather than a critical exploitable vulnerability** under the stated trust model where "Cryptographic primitives (Rust crypto crates, BLS implementations) are assumed secure." 

The mathematical properties of BLS signatures ensure that if individual signatures are valid (as guaranteed by the filtering step), their aggregate will also be valid. True exploitation would require:
1. Breaking BLS cryptographic assumptions
2. Finding bugs in the filtering implementation
3. Exploiting Rust memory safety violations

All of which fall outside the scope of this consensus logic audit. The recommendation to add verification is still valid for defense-in-depth, but the practical security impact is minimal given the trust model.

### Citations

**File:** types/src/ledger_info.rs (L517-535)
```rust
    pub fn aggregate_and_verify(
        &mut self,
        verifier: &ValidatorVerifier,
    ) -> Result<(T, AggregateSignature), VerifyError> {
        let aggregated_sig = self.try_aggregate(verifier)?;

        match verifier.verify_multi_signatures(&self.data, &aggregated_sig) {
            Ok(_) => {
                // We are not marking all the signatures as "verified" here, as two malicious
                // voters can collude and create a valid aggregated signature.
                Ok((self.data.clone(), aggregated_sig))
            },
            Err(_) => {
                self.filter_invalid_signatures(verifier);

                let aggregated_sig = self.try_aggregate(verifier)?;
                Ok((self.data.clone(), aggregated_sig))
            },
        }
```

**File:** consensus/src/pending_order_votes.rs (L111-143)
```rust
                sig_aggregator
                    .add_signature(order_vote.author(), order_vote.signature_with_status());
                match sig_aggregator.check_voting_power(validator_verifier, true) {
                    Ok(aggregated_voting_power) => {
                        assert!(
                            aggregated_voting_power >= validator_verifier.quorum_voting_power(),
                            "QC aggregation should not be triggered if we don't have enough votes to form a QC"
                        );
                        let verification_result = {
                            let _timer = counters::VERIFY_MSG
                                .with_label_values(&["order_vote_aggregate_and_verify"])
                                .start_timer();
                            sig_aggregator.aggregate_and_verify(validator_verifier).map(
                                |(ledger_info, aggregated_sig)| {
                                    LedgerInfoWithSignatures::new(ledger_info, aggregated_sig)
                                },
                            )
                        };
                        match verification_result {
                            Ok(ledger_info_with_sig) => {
                                *status =
                                    OrderVoteStatus::EnoughVotes(ledger_info_with_sig.clone());
                                OrderVoteReceptionResult::NewLedgerInfoWithSignatures((
                                    Arc::new(quorum_cert.clone()),
                                    ledger_info_with_sig,
                                ))
                            },
                            Err(VerifyError::TooLittleVotingPower { voting_power, .. }) => {
                                OrderVoteReceptionResult::VoteAdded(voting_power)
                            },
                            Err(e) => OrderVoteReceptionResult::ErrorAggregatingSignature(e),
                        }
                    },
```

**File:** consensus/src/pending_order_votes.rs (L172-179)
```rust
    pub fn has_enough_order_votes(&self, ledger_info: &LedgerInfo) -> bool {
        let li_digest = ledger_info.hash();
        if let Some((_, OrderVoteStatus::EnoughVotes(_))) = self.li_digest_to_votes.get(&li_digest)
        {
            return true;
        }
        false
    }
```

**File:** consensus/src/pending_order_votes.rs (L273-377)
```rust
    #[test]
    fn order_vote_aggregation_with_unverified_votes() {
        ::aptos_logger::Logger::init_for_testing();

        let (signers, verifier) = random_validator_verifier(5, Some(3), false);
        let mut pending_order_votes = PendingOrderVotes::new();
        let mut partial_signatures = PartialSignatures::empty();
        let qc = QuorumCert::dummy();

        // create random vote from validator[0]
        let li = random_ledger_info();
        let li_hash = li.hash();
        let vote_0 = OrderVote::new_with_signature(
            signers[0].author(),
            li.clone(),
            signers[0].sign(&li).expect("Unable to sign ledger info"),
        );
        partial_signatures.add_signature(signers[0].author(), vote_0.signature().clone());

        let vote_1 = OrderVote::new_with_signature(
            signers[1].author(),
            li.clone(),
            signers[1].sign(&li).expect("Unable to sign ledger info"),
        );
        partial_signatures.add_signature(signers[1].author(), vote_1.signature().clone());

        let vote_2 = OrderVote::new_with_signature(
            signers[2].author(),
            li.clone(),
            bls12381::Signature::dummy_signature(),
        );

        let vote_3 = OrderVote::new_with_signature(
            signers[3].author(),
            li.clone(),
            signers[3].sign(&li).expect("Unable to sign ledger info"),
        );
        partial_signatures.add_signature(signers[3].author(), vote_3.signature().clone());

        let vote_4 = OrderVote::new_with_signature(
            signers[4].author(),
            li.clone(),
            signers[4].sign(&li).expect("Unable to sign ledger info"),
        );

        assert_eq!(
            pending_order_votes.insert_order_vote(&vote_0, &verifier, Some(qc.clone())),
            OrderVoteReceptionResult::VoteAdded(1)
        );

        assert_eq!(
            pending_order_votes.insert_order_vote(&vote_0, &verifier, None),
            OrderVoteReceptionResult::VoteAdded(1)
        );

        assert_eq!(
            pending_order_votes.insert_order_vote(&vote_1, &verifier, None),
            OrderVoteReceptionResult::VoteAdded(2)
        );

        assert_eq!(verifier.pessimistic_verify_set().len(), 0);
        assert_eq!(
            pending_order_votes.insert_order_vote(&vote_2, &verifier, None),
            OrderVoteReceptionResult::VoteAdded(2)
        );
        assert_eq!(verifier.pessimistic_verify_set().len(), 1);
        let (_, order_vote_status) = pending_order_votes
            .li_digest_to_votes
            .get(&li_hash)
            .unwrap();
        match order_vote_status {
            OrderVoteStatus::NotEnoughVotes(sig_aggregator) => {
                assert_eq!(sig_aggregator.verified_voters().count(), 2);
                assert_eq!(sig_aggregator.unverified_voters().count(), 0);
            },
            _ => {
                panic!("QC should not be formed yet.");
            },
        }

        let aggregate_sig = verifier
            .aggregate_signatures(partial_signatures.signatures_iter())
            .unwrap();
        match pending_order_votes.insert_order_vote(&vote_3, &verifier, None) {
            OrderVoteReceptionResult::NewLedgerInfoWithSignatures((_qc, li_with_sig)) => {
                assert!(li_with_sig.check_voting_power(&verifier).is_ok());

                assert_eq!(li_with_sig.signatures().clone(), aggregate_sig.clone());
            },
            _ => {
                panic!("No QC formed.");
            },
        };

        match pending_order_votes.insert_order_vote(&vote_4, &verifier, None) {
            OrderVoteReceptionResult::NewLedgerInfoWithSignatures((_qc, li_with_sig)) => {
                assert!(li_with_sig.check_voting_power(&verifier).is_ok());

                assert_eq!(li_with_sig.signatures().clone(), aggregate_sig.clone());
            },
            _ => {
                panic!("No QC formed.");
            },
        };
    }
```

**File:** consensus/src/block_storage/block_tree.rs (L388-392)
```rust
    pub fn insert_ordered_cert(&mut self, ordered_cert: WrappedLedgerInfo) {
        if ordered_cert.commit_info().round() > self.highest_ordered_cert.commit_info().round() {
            self.highest_ordered_cert = Arc::new(ordered_cert);
        }
    }
```

**File:** types/src/validator_verifier.rs (L287-311)
```rust
    pub fn filter_invalid_signatures<T: Send + Sync + Serialize + CryptoHash>(
        &self,
        message: &T,
        signatures: BTreeMap<AccountAddress, SignatureWithStatus>,
    ) -> BTreeMap<AccountAddress, SignatureWithStatus> {
        signatures
            .into_iter()
            .collect_vec()
            .into_par_iter()
            .with_min_len(4) // At least 4 signatures are verified in each task
            .filter_map(|(account_address, signature)| {
                if signature.is_verified()
                    || self
                        .verify(account_address, message, signature.signature())
                        .is_ok()
                {
                    signature.set_verified();
                    Some((account_address, signature))
                } else {
                    self.add_pessimistic_verify_set(account_address);
                    None
                }
            })
            .collect()
    }
```
