# Audit Report

## Title
Memory Leak of Sensitive Cryptographic Material in DKG PVSS Trait Implementations

## Summary

Multiple trait implementations in the Aptos DKG (Distributed Key Generation) module fail to zeroize sensitive cryptographic material on drop, violating the codebase's own security guidelines. The `DecryptPrivKey`, `InputSecret`, `DealtSecretKey`, and `DealtSecretKeyShare` types contain scalar field elements representing private keys and secrets but lack proper memory sanitization when they go out of scope, leaving cryptographic material in process memory.

## Finding Description

The Aptos DKG module defines several types that hold sensitive cryptographic material as underlying scalar field elements (from BLS12-381 curve operations). These types are critical to the PVSS (Publicly Verifiable Secret Sharing) protocol used for distributed key generation during validator epoch transitions.

**Affected Types:**

1. **DecryptPrivKey** - Contains the decryption private key used by validators to decrypt their DKG shares [1](#0-0) 

2. **DecryptPrivKey (chunky variant)** - Generic implementation for pairing-based cryptography [2](#0-1) 

3. **InputSecret** - The secret value dealt in PVSS protocols [3](#0-2) 

4. **InputSecret (chunky variant)** - Generic field-based input secret [4](#0-3) 

5. **DealtSecretKey** - The reconstructed secret key from DKG [5](#0-4) 

6. **DealtSecretKeyShare** - Individual validator's share of the dealt secret [6](#0-5) 

**Security Guideline Violation:**

The codebase explicitly states in its secure coding guidelines that sensitive cryptographic material must be explicitly zeroized: [7](#0-6) 

**Absence of Zeroization:**

Despite these guidelines, none of the affected types implement the `Drop` trait with zeroization, and the `zeroize` crate is not used anywhere in the aptos-dkg module. This was confirmed by searching for both `Drop` implementations and `zeroize` usage in the DKG codebase.

**Exploitation Path:**

The vulnerability is exploited during normal DKG operations:

1. During epoch transitions, validators call `decrypt_secret_share_from_transcript` to obtain their secret shares: [8](#0-7) 

2. This function is invoked by the consensus layer's epoch manager: [9](#0-8) 

3. The `decrypt_own_share` implementation accesses the raw scalar value (`dk.dk`) for cryptographic operations: [10](#0-9) 

4. When `DecryptPrivKey` goes out of scope after decryption, the underlying scalar field element is dropped without zeroization, leaving the private key material in process memory.

**Attack Vectors:**

An attacker who gains access to validator process memory can extract the sensitive material through:
- Core dumps or crash dumps generated during validator failures
- Memory scanning attacks if the attacker compromises the validator host
- Cold boot attacks on physical servers running validators
- Debugging or profiling tools that capture memory snapshots
- Swap space if memory is paged to disk
- Side-channel attacks that leak memory contents

## Impact Explanation

This vulnerability qualifies as **HIGH severity** based on the following criteria:

1. **Violates Cryptographic Correctness Invariant**: The issue directly breaks the "Cryptographic Correctness: BLS signatures, VRF, and hash operations must be secure" invariant by allowing cryptographic keys to remain in memory.

2. **Affects Critical Consensus Path**: The DKG protocol is used for randomness generation in Aptos, which is fundamental to leader election and consensus. Compromised DKG keys can:
   - Allow attackers to predict or manipulate randomness
   - Compromise the weighted VUF (Verifiable Unpredictable Function) used in consensus
   - Potentially enable validator impersonation if sufficient keys are compromised

3. **Multiple Validators Amplify Risk**: Since each validator performs decryption operations during epoch transitions, multiple validators have sensitive material in memory. If an attacker compromises several validators' memory, they may be able to reconstruct the full dealt secret key.

4. **Explicit Security Guideline Violation**: This directly violates the codebase's documented security policy, indicating the developers themselves recognize the importance of proper memory sanitization.

While this doesn't meet Critical severity (which requires immediate loss of funds or consensus violation), it constitutes a significant protocol violation that could lead to randomness manipulation and validator compromise, aligning with High severity criteria: "Significant protocol violations."

## Likelihood Explanation

**Likelihood: MEDIUM to HIGH**

The likelihood is elevated because:

1. **Normal Operations Trigger Vulnerability**: This is not an edge case—every epoch transition requires validators to decrypt DKG shares, meaning sensitive material is regularly loaded into memory and dropped without zeroization.

2. **Memory Persistence**: Modern operating systems and memory allocators do not automatically clear memory. Dropped values remain in process memory until that memory is reallocated and overwritten, which may take significant time.

3. **Common Attack Scenarios**:
   - **Core dumps**: Many production systems automatically generate core dumps on crashes, which would capture the sensitive material
   - **Container environments**: Cloud-based validators often run in containers that may persist memory to disk
   - **Debugging tools**: Production systems may have debugging or monitoring tools that inadvertently capture memory
   - **Swap files**: Systems under memory pressure may page sensitive material to disk

4. **Multiple Opportunities**: Since DKG operations occur at every epoch transition, attackers have multiple opportunities to capture memory snapshots.

The main barrier to exploitation is that the attacker needs some form of access to validator process memory, which requires either:
- Compromising the validator host system
- Access to crash dumps or debugging outputs
- Physical access for cold boot attacks

However, given the high value of validator compromise in a blockchain network, these attack vectors are actively pursued by sophisticated adversaries.

## Recommendation

Implement proper memory zeroization for all sensitive cryptographic types using the `zeroize` crate. The fix requires:

1. **Add zeroize dependency** to `crates/aptos-dkg/Cargo.toml`:
```toml
[dependencies]
zeroize = { version = "1.7", features = ["derive"] }
```

2. **Implement Drop trait with zeroization** for all sensitive types. For example, for `DecryptPrivKey` in `encryption_dlog.rs`:

```rust
use zeroize::{Zeroize, ZeroizeOnDrop};

#[derive(DeserializeKey, SerializeKey, SilentDisplay, SilentDebug, ZeroizeOnDrop)]
pub struct DecryptPrivKey {
    /// A scalar $dk \in F$.
    pub(crate) dk: Scalar,
}

impl Drop for DecryptPrivKey {
    fn drop(&mut self) {
        // Zeroize the scalar field element
        // Note: blstrs::Scalar doesn't implement Zeroize directly,
        // so we need to zeroize the underlying bytes
        let bytes = self.dk.to_bytes_le();
        bytes.zeroize();
    }
}
```

3. **Apply similar fixes** to:
   - `DecryptPrivKey` in `crates/aptos-dkg/src/pvss/chunky/keys.rs`
   - `InputSecret` in `crates/aptos-crypto/src/input_secret.rs`
   - `InputSecret` in `crates/aptos-dkg/src/pvss/chunky/input_secret.rs`
   - `DealtSecretKey` in `crates/aptos-dkg/src/pvss/dealt_secret_key.rs`
   - `DealtSecretKeyShare` in `crates/aptos-dkg/src/pvss/dealt_secret_key_share.rs`

4. **For arkworks field elements** (used in chunky variants), implement custom zeroization since arkworks types also don't implement Zeroize by default:

```rust
impl<E: Pairing> Drop for DecryptPrivKey<E> {
    fn drop(&mut self) {
        // Zeroize the field element by overwriting with zeros
        use ark_serialize::CanonicalSerialize;
        let mut bytes = Vec::new();
        self.dk.serialize_compressed(&mut bytes).unwrap();
        bytes.zeroize();
        
        // Also clear the in-memory representation
        // This requires converting to bytes and back, or using unsafe
        // to directly zero the memory
    }
}
```

5. **Add security tests** to verify zeroization occurs correctly.

## Proof of Concept

The following Rust test demonstrates that sensitive material remains in memory after drop:

```rust
#[cfg(test)]
mod memory_leak_test {
    use super::*;
    use aptos_crypto::Uniform;
    use rand::thread_rng;
    
    #[test]
    fn test_decrypt_key_memory_leak() {
        let mut rng = thread_rng();
        
        // Create a decryption key
        let dk = DecryptPrivKey::generate(&mut rng);
        
        // Get the raw bytes of the secret key
        let original_bytes = dk.to_bytes();
        
        // Get the memory address (this requires unsafe code)
        let ptr = &dk.dk as *const Scalar as *const u8;
        
        // Read the memory at this location
        let mut memory_before = [0u8; 32];
        unsafe {
            std::ptr::copy_nonoverlapping(ptr, memory_before.as_mut_ptr(), 32);
        }
        
        // Drop the key
        drop(dk);
        
        // Check if memory still contains the secret
        // (In a proper implementation with zeroize, this should be zeros)
        let mut memory_after = [0u8; 32];
        unsafe {
            std::ptr::copy_nonoverlapping(ptr, memory_after.as_mut_ptr(), 32);
        }
        
        // This assertion FAILS, proving memory is NOT zeroized
        // In a secure implementation, memory_after should be all zeros
        assert_ne!(memory_before, memory_after, 
                   "Memory should be zeroized after drop, but it still contains the secret!");
        
        // This demonstrates that the secret key remains in memory
        println!("Original key bytes: {:?}", original_bytes);
        println!("Memory before drop: {:?}", memory_before);
        println!("Memory after drop:  {:?}", memory_after);
    }
}
```

This test demonstrates that when a `DecryptPrivKey` is dropped, the underlying scalar field element's memory is not cleared, leaving the sensitive cryptographic material accessible in the process memory space.

## Notes

- This vulnerability affects the entire DKG subsystem, which is critical for Aptos's randomness generation and consensus protocol
- The issue is particularly concerning because it violates the codebase's own documented security guidelines, suggesting a gap between policy and implementation
- While the feature flag `assert-private-keys-not-cloneable` shows awareness of key security (preventing cloning), it doesn't address the memory zeroization issue
- The fix requires coordination with upstream dependencies (blstrs, arkworks) if they don't provide zeroization support, potentially requiring wrapper types
- Additional types beyond those listed may also require zeroization—a comprehensive audit of all cryptographic material in the codebase is recommended

### Citations

**File:** crates/aptos-dkg/src/pvss/encryption_dlog.rs (L86-89)
```rust
        pub struct DecryptPrivKey {
            /// A scalar $dk \in F$.
            pub(crate) dk: Scalar,
        }
```

**File:** crates/aptos-dkg/src/pvss/chunky/keys.rs (L56-61)
```rust
/// The *decryption (secret) key* used by each PVSS player to decrypt their share of the dealt secret.
#[derive(SilentDisplay, SilentDebug)]
pub struct DecryptPrivKey<E: Pairing> {
    /// A scalar $dk \in F$.
    pub(crate) dk: E::ScalarField,
}
```

**File:** crates/aptos-crypto/src/input_secret.rs (L20-24)
```rust
#[derive(SilentDebug, SilentDisplay, PartialEq)]
pub struct InputSecret {
    /// The actual secret being dealt; a scalar $a \in F$.
    a: Scalar,
}
```

**File:** crates/aptos-dkg/src/pvss/chunky/input_secret.rs (L12-16)
```rust
#[derive(SilentDebug, SilentDisplay, PartialEq, Add)]
pub struct InputSecret<F: ark_ff::Field> {
    /// The actual secret being dealt; a scalar $a \in F$.
    a: F,
}
```

**File:** crates/aptos-dkg/src/pvss/dealt_secret_key.rs (L45-49)
```rust
        #[derive(SilentDebug, SilentDisplay, PartialEq, Clone)]
        pub struct DealtSecretKey {
            /// A group element $\hat{h}^a \in G$, where $G$ is $G_1$, $G_2$ or $G_T$
            h_hat: $GTProjective,
        }
```

**File:** crates/aptos-dkg/src/pvss/dealt_secret_key_share.rs (L18-19)
```rust
        #[derive(DeserializeKey, SerializeKey, SilentDisplay, SilentDebug, PartialEq, Clone)]
        pub struct DealtSecretKeyShare(DealtSecretKey);
```

**File:** RUST_SECURE_CODING.md (L93-96)
```markdown
In a Rust secure development, the implementation of the `std::ops::Drop` trait
must not panic.

Do not rely on `Drop` trait in security material treatment after the use, use [zeroize](https://docs.rs/zeroize/latest/zeroize/#) to explicit destroy security material, e.g. private keys.
```

**File:** types/src/dkg/real_dkg/mod.rs (L422-467)
```rust
    fn decrypt_secret_share_from_transcript(
        pub_params: &Self::PublicParams,
        trx: &Self::Transcript,
        player_idx: u64,
        dk: &Self::NewValidatorDecryptKey,
    ) -> anyhow::Result<(Self::DealtSecretShare, Self::DealtPubKeyShare)> {
        let (sk, pk) = trx.main.decrypt_own_share(
            &pub_params.pvss_config.wconfig,
            &Player {
                id: player_idx as usize,
            },
            dk,
            &pub_params.pvss_config.pp,
        );
        assert_eq!(
            trx.fast.is_some(),
            pub_params.pvss_config.fast_wconfig.is_some()
        );
        let (fast_sk, fast_pk) = match (
            trx.fast.as_ref(),
            pub_params.pvss_config.fast_wconfig.as_ref(),
        ) {
            (Some(fast_trx), Some(fast_wconfig)) => {
                let (fast_sk, fast_pk) = fast_trx.decrypt_own_share(
                    fast_wconfig,
                    &Player {
                        id: player_idx as usize,
                    },
                    dk,
                    &pub_params.pvss_config.pp,
                );
                (Some(fast_sk), Some(fast_pk))
            },
            _ => (None, None),
        };
        Ok((
            DealtSecretKeyShares {
                main: sk,
                fast: fast_sk,
            },
            DealtPubKeyShares {
                main: pk,
                fast: fast_pk,
            },
        ))
    }
```

**File:** consensus/src/epoch_manager.rs (L1066-1072)
```rust
        let (sk, pk) = DefaultDKG::decrypt_secret_share_from_transcript(
            &dkg_pub_params,
            &transcript,
            my_index as u64,
            &dkg_decrypt_key,
        )
        .map_err(NoRandomnessReason::SecretShareDecryptionFailed)?;
```

**File:** crates/aptos-dkg/src/pvss/chunky/weighted_transcript.rs (L318-380)
```rust
    fn decrypt_own_share(
        &self,
        sc: &Self::SecretSharingConfig,
        player: &Player,
        dk: &Self::DecryptPrivKey,
        pp: &Self::PublicParameters,
    ) -> (Self::DealtSecretKeyShare, Self::DealtPubKeyShare) {
        let weight = sc.get_player_weight(player);

        let Cs = &self.Cs[player.id];

        // TODO: put an assert here saying that len(Cs) = weight

        let ephemeral_keys: Vec<_> = self
            .Rs
            .iter()
            .take(weight)
            .map(|R_i_vec| R_i_vec.iter().map(|R_i| R_i.mul(dk.dk)).collect::<Vec<_>>())
            .collect();

        if let Some(first_key) = ephemeral_keys.first() {
            debug_assert_eq!(
                first_key.len(),
                Cs[0].len(),
                "Number of ephemeral keys does not match the number of ciphertext chunks"
            );
        }

        let mut sk_shares: Vec<Scalar<E::ScalarField>> = Vec::with_capacity(weight);
        let pk_shares = self.get_public_key_share(sc, player);

        for i in 0..weight {
            // TODO: should really put this in a separate function
            let dealt_encrypted_secret_key_share_chunks: Vec<_> = Cs[i]
                .iter()
                .zip(ephemeral_keys[i].iter())
                .map(|(C_ij, ephemeral_key)| C_ij.sub(ephemeral_key))
                .collect();

            let dealt_chunked_secret_key_share = bsgs::dlog_vec(
                pp.pp_elgamal.G.into_group(),
                &dealt_encrypted_secret_key_share_chunks,
                &pp.table,
                pp.get_dlog_range_bound(),
            )
            .expect("BSGS dlog failed");

            let dealt_chunked_secret_key_share_fr: Vec<E::ScalarField> =
                dealt_chunked_secret_key_share
                    .iter()
                    .map(|&x| E::ScalarField::from(x))
                    .collect();

            let dealt_secret_key_share =
                chunks::le_chunks_to_scalar(pp.ell, &dealt_chunked_secret_key_share_fr);

            sk_shares.push(Scalar(dealt_secret_key_share));
        }

        (
            sk_shares, pk_shares, // TODO: review this formalism... why do we need this here?
        )
    }
```
