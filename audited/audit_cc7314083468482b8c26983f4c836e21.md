# Audit Report

## Title
Consensus Split Vulnerability Due to Version-Dependent Bytecode Verification at RELEASE_V1_34 Boundary

## Summary
A critical consensus-breaking vulnerability exists at the RELEASE_V1_34 boundary where the `sig_checker_v2_fix_function_signatures` configuration change causes different validators to reach different conclusions about transaction validity. Modules published before v1.34 with malformed Function signature types can pass verification, but after the upgrade, validators with cold verification caches will fail to load these modules while validators with warm caches will succeed, causing a deterministic consensus split.

## Finding Description

The vulnerability stems from the interaction between three components:

1. **Version-dependent verification behavior:** [1](#0-0) 

When `gas_feature_version >= RELEASE_V1_34`, the flag `sig_checker_v2_fix_function_signatures` is enabled, which fundamentally changes how Function signature types are validated: [2](#0-1) 

When this flag is **false** (before v1.34), the entire recursive check for Function types is **skipped**. When **true** (at/after v1.34), it recursively validates all parameter and return types within Function signatures, requiring `AbilitySet::EMPTY` for nested types.

2. **Module re-verification on load:** [3](#0-2) 

Modules stored on-chain are re-verified when loaded if not in the verification cache: [4](#0-3) 

3. **Non-deterministic cache state:** [5](#0-4) 

The `VERIFIED_MODULES_CACHE` is a process-local LRU cache that varies across validators based on restarts, memory pressure, and module loading patterns.

**Attack Path:**

1. Before RELEASE_V1_34, an attacker publishes a module containing a `SignatureToken::Function` with types that violate the stricter v2 checking rules but pass the lenient pre-v1.34 validation [6](#0-5) 

2. The module's hash is computed and cached in validators that process the publish transaction

3. After the gas schedule upgrade to v1.34 (which happens at epoch boundaries via governance): [7](#0-6) 

4. Some validators restart or have their caches flushed, while others maintain warm caches

5. A transaction attempts to load and execute code from the malformed module

6. **Validators with warm cache:** Module hash found in `VERIFIED_MODULES_CACHE`, verification skipped, transaction succeeds

7. **Validators with cold cache:** Module hash not in cache, re-verification runs with new stricter config, verification fails with: [8](#0-7) 

8. **Result:** Different validators reach different conclusions about the same transaction's validity, breaking the **Deterministic Execution** invariant and causing a consensus split.

## Impact Explanation

**Critical Severity** - This vulnerability meets the highest severity criteria:

- **Consensus/Safety violation**: Validators disagree on transaction validity for identical blocks, violating AptosBFT safety guarantees
- **Non-recoverable network partition**: Once validators diverge on state, they cannot reconcile without manual intervention or hardfork
- **Total loss of liveness**: The network cannot make progress while validators are split on different state roots

This directly breaks Invariant #1 (Deterministic Execution): "All validators must produce identical state roots for identical blocks."

The impact affects the entire network, not just individual transactions, as consensus failure cascades to all subsequent blocks.

## Likelihood Explanation

**High Likelihood:**

1. **Pre-conditions are met**: Any module with Function types published before RELEASE_V1_34 that contains nested references or ability violations becomes a trigger
2. **Cache divergence is common**: Validators naturally have different cache states due to:
   - Routine restarts for maintenance or upgrades
   - Memory pressure causing LRU evictions
   - New validators joining the network with empty caches
   - The cache size limit of 100,000 modules being reached
3. **Attack is deterministic**: Once a malformed module exists on-chain, any transaction loading it reliably triggers the vulnerability
4. **No special privileges required**: Any transaction sender can trigger the vulnerability by interacting with the malformed module

The attack complexity is low - an attacker only needs to have published a specific type of module before v1.34, which may have occurred naturally without malicious intent.

## Recommendation

**Immediate mitigation** (for existing deployments):

1. Perform a one-time full chain scan before RELEASE_V1_34 deployment to identify all modules with Function types
2. Re-verify all such modules with both old and new verification configs
3. Reject the upgrade if any modules would change verification status

**Long-term fix** - Decouple verification configuration from runtime environment:

```rust
// In prod_configs.rs, add a verification epoch marker
pub fn aptos_prod_verifier_config(
    gas_feature_version: u64, 
    features: &Features,
    module_publish_epoch: Option<u64>  // NEW: epoch when module was published
) -> VerifierConfig {
    let sig_checker_v2_fix_function_signatures = match module_publish_epoch {
        Some(epoch) => epoch >= EPOCH_V1_34_DEPLOYED,  // Use epoch of original publish
        None => gas_feature_version >= RELEASE_V1_34,   // For new publishes, use current
    };
    // ... rest of config
}
```

Store the verification epoch with each module on-chain, and always re-verify using the original epoch's rules to ensure deterministic results regardless of cache state.

**Alternative fix** - Disable re-verification for on-chain modules:

Modify the cache check to always trust on-chain bytecode:

```rust
// In environment.rs
pub fn build_locally_verified_module(
    &self,
    compiled_module: Arc<CompiledModule>,
    module_size: usize,
    module_hash: &[u8; 32],
    is_from_storage: bool,  // NEW parameter
) -> VMResult<LocallyVerifiedModule> {
    if is_from_storage || VERIFIED_MODULES_CACHE.contains(module_hash) {
        // Trust on-chain modules - they were verified at publish time
        return Ok(LocallyVerifiedModule(compiled_module, module_size));
    }
    // Only verify newly published modules
    move_bytecode_verifier::verify_module_with_config(/*...*/)?;
    VERIFIED_MODULES_CACHE.put(*module_hash);
    Ok(LocallyVerifiedModule(compiled_module, module_size))
}
```

## Proof of Concept

```rust
// Create a malformed module that passes pre-v1.34 verification
// but fails post-v1.34 verification

use move_binary_format::{
    file_format::*,
    CompiledModule,
};
use move_bytecode_verifier::{verify_module_with_config, VerifierConfig};
use aptos_gas_schedule::gas_feature_versions::{RELEASE_V1_33, RELEASE_V1_34};

fn create_malformed_function_sig_module() -> CompiledModule {
    // Create a module with a Function type containing a nested reference
    // which violates the sig_checker_v2_fix_function_signatures rules
    let mut module = CompiledModule::default();
    
    // Add a Function signature: fn(fn(&u64) -> u64) -> u64
    // The nested &u64 in the parameter should fail recursive checking
    let inner_ref = SignatureToken::Reference(Box::new(SignatureToken::U64));
    let inner_fn = SignatureToken::Function(
        vec![inner_ref],  // Parameter contains reference
        vec![SignatureToken::U64],
        AbilitySet::EMPTY
    );
    
    module.signatures.push(Signature(vec![inner_fn]));
    module
}

#[test]
fn test_consensus_split_vulnerability() {
    let module = create_malformed_function_sig_module();
    
    // Pre-v1.34 config (sig_checker_v2_fix_function_signatures = false)
    let mut config_v33 = VerifierConfig::production();
    config_v33.sig_checker_v2_fix_function_signatures = false;
    
    // Post-v1.34 config (sig_checker_v2_fix_function_signatures = true)
    let mut config_v34 = VerifierConfig::production();
    config_v34.sig_checker_v2_fix_function_signatures = true;
    
    // Module passes verification with v33 config
    let result_v33 = verify_module_with_config(&config_v33, &module);
    assert!(result_v33.is_ok(), "Module should pass pre-v1.34 verification");
    
    // Same module fails verification with v34 config
    let result_v34 = verify_module_with_config(&config_v34, &module);
    assert!(result_v34.is_err(), "Module should fail post-v1.34 verification");
    
    // This demonstrates that validators with different cache states
    // will disagree on transaction validity after the v1.34 upgrade
    println!("CONSENSUS SPLIT: Pre-v1.34 config allows module, post-v1.34 rejects it");
}
```

**Notes:**
- The vulnerability window includes ALL modules with Function types published before RELEASE_V1_34
- The verification cache flush can occur naturally through validator restarts, making this exploitable without attacker intervention
- The fix requires either preventing the configuration change from affecting already-published modules, or performing a network-wide migration before deployment

### Citations

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L148-148)
```rust
    let sig_checker_v2_fix_function_signatures = gas_feature_version >= RELEASE_V1_34;
```

**File:** third_party/move/move-bytecode-verifier/src/signature_v2.rs (L172-187)
```rust
            Function(params, results, abilities) => {
                assert_abilities(*abilities, required_abilities)?;
                if self.sig_checker_v2_fix_function_signatures {
                    for ty in params.iter().chain(results) {
                        self.check_ty(
                            ty,
                            // Immediate params and returns can be references.
                            true,
                            // Note we do not need to check abilities of argument or result types,
                            // they do not matter for the `required_abilities`.
                            AbilitySet::EMPTY,
                            param_constraints,
                        )?
                    }
                }
            },
```

**File:** third_party/move/move-vm/runtime/src/storage/module_storage.rs (L295-329)
```rust
    fn unmetered_get_lazily_verified_module(
        &self,
        module_id: &ModuleId,
    ) -> VMResult<Option<Arc<Module>>> {
        let (module, version) = match self.get_module_or_build_with(module_id, self)? {
            Some(module_and_version) => module_and_version,
            None => return Ok(None),
        };

        if module.code().is_verified() {
            return Ok(Some(module.code().verified().clone()));
        }

        let _timer = VM_TIMER.timer_with_label("unmetered_get_lazily_verified_module [cache miss]");
        let runtime_environment = self.runtime_environment();
        runtime_environment.paranoid_check_module_address_and_name(
            module.code().deserialized(),
            module_id.address(),
            module_id.name(),
        )?;
        let locally_verified_code = runtime_environment.build_locally_verified_module(
            module.code().deserialized().clone(),
            module.extension().size_in_bytes(),
            module.extension().hash(),
        )?;
        let verified_code =
            runtime_environment.build_verified_module_skip_linking_checks(locally_verified_code)?;
        let verified_module = self.insert_verified_module(
            module_id.clone(),
            verified_code,
            module.extension().clone(),
            version,
        )?;
        Ok(Some(verified_module.code().verified().clone()))
    }
```

**File:** third_party/move/move-vm/runtime/src/storage/environment.rs (L184-198)
```rust
        if !VERIFIED_MODULES_CACHE.contains(module_hash) {
            let _timer =
                VM_TIMER.timer_with_label("move_bytecode_verifier::verify_module_with_config");

            // For regular execution, we cache already verified modules. Note that this even caches
            // verification for the published modules. This should be ok because as long as the
            // hash is the same, the deployed bytecode and any dependencies are the same, and so
            // the cached verification result can be used.
            move_bytecode_verifier::verify_module_with_config(
                &self.vm_config().verifier_config,
                compiled_module.as_ref(),
            )?;
            check_natives(compiled_module.as_ref())?;
            VERIFIED_MODULES_CACHE.put(*module_hash);
        }
```

**File:** third_party/move/move-vm/runtime/src/storage/verified_module_cache.rs (L51-54)
```rust
lazy_static! {
    pub(crate) static ref VERIFIED_MODULES_CACHE: VerifiedModuleCache =
        VerifiedModuleCache::empty();
}
```

**File:** third_party/move/move-binary-format/src/file_format.rs (L932-971)
```rust
pub enum SignatureToken {
    /// Boolean, `true` or `false`.
    Bool,
    /// Unsigned integers, 8 bits length.
    U8,
    /// Unsigned integers, 64 bits length.
    U64,
    /// Unsigned integers, 128 bits length.
    U128,
    /// Address, a 16 bytes immutable type.
    Address,
    /// Signer, a 16 bytes immutable type representing the capability to publish at an address
    Signer,
    /// Vector
    Vector(Box<SignatureToken>),
    /// Function, with n argument types and m result types, and an associated ability set.
    Function(Vec<SignatureToken>, Vec<SignatureToken>, AbilitySet),
    /// User defined type
    Struct(StructHandleIndex),
    StructInstantiation(StructHandleIndex, Vec<SignatureToken>),
    /// Reference to a type.
    Reference(Box<SignatureToken>),
    /// Mutable reference to a type.
    MutableReference(Box<SignatureToken>),
    /// Type parameter.
    TypeParameter(TypeParameterIndex),
    /// Unsigned integers, 16 bits length.
    U16,
    /// Unsigned integers, 32 bits length.
    U32,
    /// Unsigned integers, 256 bits length.
    U256,
    /// Signed integers
    I8,
    I16,
    I32,
    I64,
    I128,
    I256,
}
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L135-145)
```text
    public(friend) fun on_new_epoch(framework: &signer) acquires GasScheduleV2 {
        system_addresses::assert_aptos_framework(framework);
        if (config_buffer::does_exist<GasScheduleV2>()) {
            let new_gas_schedule = config_buffer::extract_v2<GasScheduleV2>();
            if (exists<GasScheduleV2>(@aptos_framework)) {
                *borrow_global_mut<GasScheduleV2>(@aptos_framework) = new_gas_schedule;
            } else {
                move_to(framework, new_gas_schedule);
            }
        }
    }
```

**File:** third_party/move/move-vm/runtime/src/logging.rs (L11-42)
```rust
pub fn expect_no_verification_errors(err: VMError) -> VMError {
    match err.status_type() {
        status_type @ StatusType::Deserialization | status_type @ StatusType::Verification => {
            let message = format!(
                "Unexpected verifier/deserialization error! This likely means there is code \
                stored on chain that is unverifiable!\nError: {:?}",
                &err
            );
            let (
                _old_status,
                _old_sub_status,
                _old_message,
                _stacktrace,
                location,
                indices,
                offsets,
            ) = err.all_data();
            let major_status = match status_type {
                StatusType::Deserialization => StatusCode::UNEXPECTED_DESERIALIZATION_ERROR,
                StatusType::Verification => StatusCode::UNEXPECTED_VERIFIER_ERROR,
                _ => unreachable!(),
            };

            PartialVMError::new(major_status)
                .with_message(message)
                .at_indices(indices)
                .at_code_offsets(offsets)
                .finish(location)
        },
        _ => err,
    }
}
```
