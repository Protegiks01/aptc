# Audit Report

## Title
Multisig Transactions with None Payload Bypass Module Address and Entry Function Filtering

## Summary
Multisig transactions with no transaction payload (`transaction_payload = None`) bypass module address and entry function filtering in the mempool's transaction filter system by returning `false` in the matcher functions, allowing execution of transactions that should be blocked by node operators' deny rules.

## Finding Description
The transaction filtering system allows node operators to configure rules to allow or deny transactions based on various criteria, including module addresses and entry functions. When a Multisig transaction is submitted with `transaction_payload = None`, the filtering logic incorrectly returns `false` for both `matches_entry_function_module_address()` and `matches_entry_function()`, causing these transactions to bypass deny rules. [1](#0-0) 

In the `matches_entry_function_module_address()` function, when handling Multisig payloads, the code uses `.unwrap_or(false)` which returns `false` when `transaction_payload` is `None`. This means the matcher returns `false`, indicating "this transaction does NOT match the module address filter." [2](#0-1) 

The same issue exists in `matches_entry_function()`, also returning `false` via `.unwrap_or(false)` for Multisig transactions with None payload.

The Multisig system is designed to support transactions where the payload is stored on-chain: [3](#0-2) 

During execution, the actual payload is retrieved from on-chain storage via `get_next_transaction_payload()`: [4](#0-3) 

**Attack Path:**
1. Attacker creates a multisig account and stores a transaction calling `0x1::malicious_module::attack()` on-chain
2. Node operator configures a Deny filter: `Deny([ModuleAddress(0x1)])` to block all transactions calling modules at address `0x1`
3. Attacker gets approvals and submits a Multisig transaction with `transaction_payload = None`
4. Mempool filter checks the transaction using `matches_entry_function_module_address(txn, 0x1)` which returns `false`
5. Since the matcher returns `false`, the Deny rule doesn't match, and the transaction is allowed into mempool
6. During execution, the VM retrieves the actual payload from on-chain storage and executes `0x1::malicious_module::attack()` [5](#0-4) 

## Impact Explanation
This is a **Medium severity** vulnerability per Aptos bug bounty criteria. It allows bypassing transaction filtering configured by node operators, but does not directly lead to consensus violations or fund loss. However, it represents a significant control bypass:

- Node operators may configure filters to block high-risk modules, deprecated contracts, or malicious entry functions
- Attackers can bypass these filters entirely using Multisig transactions with None payload
- The actual execution still occurs with the on-chain stored payload
- This breaks the security guarantee that transaction filters provide

While the impact is limited compared to consensus or fund loss issues, it represents a clear security control bypass that could be exploited to execute transactions that should be blocked.

## Likelihood Explanation
The likelihood is **Medium to High**:

**Requirements:**
- Attacker must create a multisig account (low barrier)
- Must store the payload on-chain via `create_transaction()` (requires gas but straightforward)
- Must obtain required approvals from multisig owners (depends on governance, but feasible)
- Node must have filtering configured (not all nodes use this feature)

**Feasibility:**
- The attack is straightforward once prerequisites are met
- No special privileges required beyond normal multisig operations
- The bypass is automatic due to the `.unwrap_or(false)` logic
- Any node operator using module address or entry function filters is vulnerable

## Recommendation
The filtering functions should retrieve the actual payload that will be executed, not just check the transaction payload field. When `transaction_payload` is `None`, the filter should:

1. **Option A (Recommended):** Default to `true` (match) instead of `false` for Deny rules when payload is unknown, applying a fail-secure approach:

```rust
TransactionPayload::Multisig(multisig) => multisig
    .transaction_payload
    .as_ref()
    .map(|payload| match payload {
        MultisigTransactionPayload::EntryFunction(entry_function) => {
            compare_entry_function_module_address(entry_function, module_address)
        },
    })
    .unwrap_or(true),  // Changed from false to true - default to matching when payload is unknown
```

2. **Option B (More Conservative):** Add a separate matcher type for Multisig transactions that matches based on the multisig address, allowing operators to explicitly allow/deny multisig transactions with None payloads.

3. **Option C (Most Secure):** Query the on-chain payload during filtering if the transaction has `None` payload, though this adds significant overhead.

**Recommended Fix:** Option A is the most practical - changing `.unwrap_or(false)` to `.unwrap_or(true)` for module address and entry function matching in Multisig transactions. This applies a fail-secure principle where unknown payloads are treated as potentially matching deny rules.

## Proof of Concept

```rust
#[test]
fn test_multisig_none_payload_bypasses_module_filter() {
    use aptos_types::transaction::{Multisig, TransactionPayload, SignedTransaction};
    use move_core_types::account_address::AccountAddress;
    
    // Create a Multisig transaction with None payload
    let multisig_address = AccountAddress::from_hex_literal("0x1").unwrap();
    let target_module_address = AccountAddress::from_hex_literal("0x999").unwrap();
    
    let multisig_payload = Multisig {
        multisig_address,
        transaction_payload: None,  // No payload in transaction
    };
    
    let raw_transaction = RawTransaction::new(
        AccountAddress::random(),
        0,
        TransactionPayload::Multisig(multisig_payload),
        0,
        0,
        0,
        ChainId::new(10),
    );
    
    let private_key = Ed25519PrivateKey::generate_for_testing();
    let signed_transaction = SignedTransaction::new(
        raw_transaction,
        private_key.public_key(),
        private_key.sign(&raw_transaction).unwrap(),
    );
    
    // Create a filter that denies transactions to target_module_address
    let filter = TransactionFilter::empty()
        .add_module_address_filter(false, target_module_address)
        .add_all_filter(true);  // Allow all others
    
    // The Multisig transaction with None payload should be blocked but isn't
    assert!(filter.allows_transaction(&signed_transaction)); // PASSES - Bug confirmed!
    // Expected: false (should be blocked), Actual: true (bypasses filter)
}
```

This PoC demonstrates that a Multisig transaction with `None` payload bypasses module address filtering, even when that module address should be explicitly denied by the filter configuration.

### Citations

**File:** crates/aptos-transaction-filters/src/transaction_filter.rs (L333-375)
```rust
fn matches_entry_function(
    signed_transaction: &SignedTransaction,
    address: &AccountAddress,
    module_name: &String,
    function: &String,
) -> bool {
    // Match all variants explicitly to ensure future enum changes are caught during compilation
    match signed_transaction.payload() {
        TransactionPayload::Script(_) | TransactionPayload::ModuleBundle(_) => false,
        TransactionPayload::Multisig(multisig) => multisig
            .transaction_payload
            .as_ref()
            .map(|payload| match payload {
                MultisigTransactionPayload::EntryFunction(entry_function) => {
                    compare_entry_function(entry_function, address, module_name, function)
                },
            })
            .unwrap_or(false),
        TransactionPayload::EntryFunction(entry_function) => {
            compare_entry_function(entry_function, address, module_name, function)
        },
        TransactionPayload::Payload(TransactionPayloadInner::V1 { executable, .. }) => {
            match executable.as_ref() {
                TransactionExecutableRef::Script(_) | TransactionExecutableRef::Empty => false,
                TransactionExecutableRef::EntryFunction(entry_function) => {
                    compare_entry_function(entry_function, address, module_name, function)
                },
            }
        },
        TransactionPayload::EncryptedPayload(payload) => {
            if let Ok(executable) = payload.executable_ref() {
                match executable {
                    TransactionExecutableRef::Script(_) | TransactionExecutableRef::Empty => false,
                    TransactionExecutableRef::EntryFunction(entry_function) => {
                        compare_entry_function(entry_function, address, module_name, function)
                    },
                }
            } else {
                false
            }
        },
    }
}
```

**File:** crates/aptos-transaction-filters/src/transaction_filter.rs (L377-418)
```rust
/// Returns true iff the transaction's module address matches the given account address
fn matches_entry_function_module_address(
    signed_transaction: &SignedTransaction,
    module_address: &AccountAddress,
) -> bool {
    // Match all variants explicitly to ensure future enum changes are caught during compilation
    match signed_transaction.payload() {
        TransactionPayload::Script(_) | TransactionPayload::ModuleBundle(_) => false,
        TransactionPayload::Multisig(multisig) => multisig
            .transaction_payload
            .as_ref()
            .map(|payload| match payload {
                MultisigTransactionPayload::EntryFunction(entry_function) => {
                    compare_entry_function_module_address(entry_function, module_address)
                },
            })
            .unwrap_or(false),
        TransactionPayload::EntryFunction(entry_function) => {
            compare_entry_function_module_address(entry_function, module_address)
        },
        TransactionPayload::Payload(TransactionPayloadInner::V1 { executable, .. }) => {
            match executable.as_ref() {
                TransactionExecutableRef::Script(_) | TransactionExecutableRef::Empty => false,
                TransactionExecutableRef::EntryFunction(entry_function) => {
                    compare_entry_function_module_address(entry_function, module_address)
                },
            }
        },
        TransactionPayload::EncryptedPayload(payload) => {
            if let Ok(executable) = payload.executable_ref() {
                match executable {
                    TransactionExecutableRef::Script(_) | TransactionExecutableRef::Empty => false,
                    TransactionExecutableRef::EntryFunction(entry_function) => {
                        compare_entry_function_module_address(entry_function, module_address)
                    },
                }
            } else {
                false
            }
        },
    }
}
```

**File:** types/src/transaction/multisig.rs (L9-17)
```rust
/// A multisig transaction that allows an owner of a multisig account to execute a pre-approved
/// transaction as the multisig account.
#[derive(Clone, Debug, Hash, Eq, PartialEq, Serialize, Deserialize)]
pub struct Multisig {
    pub multisig_address: AccountAddress,

    // Transaction payload is optional if already stored on chain.
    pub transaction_payload: Option<MultisigTransactionPayload>,
}
```

**File:** aptos-move/framework/aptos-framework/sources/multisig_account.move (L391-404)
```text
    #[view]
    /// Return the payload for the next transaction in the queue.
    public fun get_next_transaction_payload(
        multisig_account: address, provided_payload: vector<u8>): vector<u8> acquires MultisigAccount {
        let multisig_account_resource = borrow_global<MultisigAccount>(multisig_account);
        let sequence_number = multisig_account_resource.last_executed_sequence_number + 1;
        let transaction = table::borrow(&multisig_account_resource.transactions, sequence_number);

        if (option::is_some(&transaction.payload)) {
            *option::borrow(&transaction.payload)
        } else {
            provided_payload
        }
    }
```

**File:** mempool/src/shared_mempool/tasks.rs (L406-460)
```rust
/// Filters transactions based on the transaction filter configuration. Any
/// transactions that are filtered out will have their statuses marked accordingly.
fn filter_transactions(
    transaction_filter_config: &TransactionFilterConfig,
    transactions: Vec<(
        SignedTransaction,
        Option<u64>,
        Option<BroadcastPeerPriority>,
    )>,
    statuses: &mut Vec<(SignedTransaction, (MempoolStatus, Option<StatusCode>))>,
) -> Vec<(
    SignedTransaction,
    Option<u64>,
    Option<BroadcastPeerPriority>,
)> {
    // If the filter is not enabled, return early
    if !transaction_filter_config.is_enabled() {
        return transactions;
    }

    // Start the filter processing timer
    let transaction_filter_timer = counters::PROCESS_TXN_BREAKDOWN_LATENCY
        .with_label_values(&[counters::FILTER_TRANSACTIONS_LABEL])
        .start_timer();

    // Filter the transactions and update the statuses accordingly
    let transactions = transactions
        .into_iter()
        .filter_map(|(transaction, account_sequence_number, priority)| {
            if transaction_filter_config
                .transaction_filter()
                .allows_transaction(&transaction)
            {
                Some((transaction, account_sequence_number, priority))
            } else {
                info!(LogSchema::event_log(
                    LogEntry::TransactionFilter,
                    LogEvent::TransactionRejected
                )
                .message(&format!(
                    "Transaction {} rejected by filter",
                    transaction.committed_hash()
                )));

                statuses.push((
                    transaction.clone(),
                    (
                        MempoolStatus::new(MempoolStatusCode::RejectedByFilter),
                        None,
                    ),
                ));
                None
            }
        })
        .collect();
```
