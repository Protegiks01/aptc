# Audit Report

## Title
Out-of-Bounds Index Panic in Randomness Key Decryption During Epoch Transition

## Summary
The `try_get_rand_config_for_new_epoch()` function in `consensus/src/epoch_manager.rs` fails to validate that `my_index` is within bounds for the DKG transcript's target validator set before using it for secret share decryption. If a validator's index in the new epoch exceeds the size of the DKG session's target validator set, the node will panic with an out-of-bounds array access, preventing that validator from participating in randomness generation and potentially causing consensus liveness issues.

## Finding Description

The vulnerability occurs in the randomness key initialization path during epoch transitions: [1](#0-0) 

The code obtains `my_index` from the new epoch's validator set without validating it against the DKG transcript's target validator set size. This index is then used directly for decryption: [2](#0-1) 

The decryption flow calls into the PVSS layer, where `decrypt_own_share` accesses the secret sharing configuration: [3](#0-2) 

This calls `get_player_weight()`, which performs an **unchecked array access**: [4](#0-3) 

Similarly, `get_share_index()` also performs unchecked array access: [5](#0-4) 

**Attack Scenario:**
1. DKG session completes for epoch X â†’ X+1 with target validator set of size N
2. Validator set changes (validators added/reordered) before epoch X+1 starts
3. New epoch has M validators where M > N or validators in different positions
4. Validator at index `i` (where `i >= N`) attempts to decrypt their randomness key
5. `weights[i]` access panics because `i >= weights.len()`
6. Validator node crashes during critical epoch transition

The code only validates epoch numbers match but **not** that validator sets are compatible: [6](#0-5) 

## Impact Explanation

**High Severity** - This vulnerability causes validator node crashes, meeting the "API crashes" and "Validator node slowdowns" criteria from the Aptos bug bounty program.

**Specific Impacts:**
- **Validator Node Crash**: Affected validators panic during epoch transition, a critical operational phase
- **Loss of Randomness Participation**: Crashed validators cannot contribute to on-chain randomness generation
- **Partial Network Disruption**: Multiple validators may be affected simultaneously if validator set changes
- **Recovery Required**: Node operators must manually restart crashed validators
- **Consensus Degradation**: Fewer active validators reduce network resilience

While not a total network failure, this represents significant protocol violation during epoch transitions when validator participation is most critical.

## Likelihood Explanation

**Medium Likelihood** in practice:

**Favorable Conditions:**
- Normal case: Target validator set in DKG should match actual new epoch validator set
- Validator set is typically stable between epochs
- Proper DKG implementation should use correct target set

**Risk Factors:**
- **Validator Set Changes**: If governance adds validators or reorders validator set after DKG completes
- **Implementation Bugs**: Bugs in how target validator set is determined could cause mismatches
- **Edge Cases**: Race conditions during epoch transition or emergency validator set updates
- **No Defensive Validation**: Complete absence of bounds checking means any mismatch causes crash

Even if rare, the **lack of defensive validation** makes this a serious reliability issue. Production systems should validate critical assumptions rather than panic on unexpected inputs.

## Recommendation

Add explicit bounds validation before using `my_index` for decryption:

```rust
fn try_get_rand_config_for_new_epoch(
    &self,
    consensus_key: Arc<PrivateKey>,
    new_epoch_state: &EpochState,
    onchain_randomness_config: &OnChainRandomnessConfig,
    maybe_dkg_state: anyhow::Result<DKGState>,
    consensus_config: &OnChainConsensusConfig,
) -> Result<(RandConfig, Option<RandConfig>), NoRandomnessReason> {
    // ... existing validation ...
    
    let dkg_pub_params = DefaultDKG::new_public_params(&dkg_session.metadata);
    let my_index = new_epoch_state
        .verifier
        .address_to_validator_index()
        .get(&self.author)
        .copied()
        .ok_or_else(|| NoRandomnessReason::NotInValidatorSet)?;

    // ADD THIS VALIDATION:
    let target_validator_count = dkg_session.metadata.target_validator_set.len();
    if my_index >= target_validator_count {
        return Err(NoRandomnessReason::ValidatorIndexOutOfBounds {
            my_index,
            target_set_size: target_validator_count,
        });
    }

    // ... rest of function ...
}
```

Additionally, validate that the new epoch validator set is compatible with the DKG target set:

```rust
// Verify validator set compatibility
let new_epoch_validators = new_epoch_state.verifier.len();
if new_epoch_validators != target_validator_count {
    return Err(NoRandomnessReason::ValidatorSetMismatch {
        expected: target_validator_count,
        actual: new_epoch_validators,
    });
}
```

## Proof of Concept

```rust
#[cfg(test)]
mod test_index_bounds {
    use super::*;
    
    #[test]
    #[should_panic(expected = "index out of bounds")]
    fn test_out_of_bounds_my_index_causes_panic() {
        // Setup: Create DKG session with target validator set of size 5
        let target_validators = create_validator_set(5);
        let dkg_session = create_dkg_session_for_validators(&target_validators);
        
        // Create new epoch state with 7 validators (added 2 new ones)
        let new_epoch_validators = create_validator_set(7);
        let new_epoch_state = EpochState::new(
            epoch + 1,
            ValidatorVerifier::new(new_epoch_validators),
        );
        
        // Validator at index 6 tries to decrypt (6 >= 5)
        let validator_at_index_6 = new_epoch_validators[6].account_address();
        let consensus_key = new_epoch_validators[6].consensus_private_key();
        
        let epoch_manager = create_test_epoch_manager(validator_at_index_6);
        
        // This will panic with "index out of bounds: the len is 5 but the index is 6"
        let result = epoch_manager.try_get_rand_config_for_new_epoch(
            Arc::new(consensus_key),
            &new_epoch_state,
            &onchain_randomness_config,
            Ok(DKGState {
                last_completed: Some(dkg_session),
                in_progress: None,
            }),
            &consensus_config,
        );
        
        // Should return error instead of panicking
        assert!(result.is_err());
    }
}
```

## Notes

The vulnerability is in the defensive programming layer rather than normal operation. The DKG protocol is designed so that the target validator set should match the new epoch's validator set. However, the complete absence of validation means any implementation bug, race condition, or edge case in validator set management will cause validator crashes rather than graceful error handling. This violates the principle of defensive programming for critical consensus infrastructure.

### Citations

**File:** consensus/src/epoch_manager.rs (L1043-1045)
```rust
        if dkg_session.metadata.dealer_epoch + 1 != new_epoch_state.epoch {
            return Err(NoRandomnessReason::CompletedSessionTooOld);
        }
```

**File:** consensus/src/epoch_manager.rs (L1047-1052)
```rust
        let my_index = new_epoch_state
            .verifier
            .address_to_validator_index()
            .get(&self.author)
            .copied()
            .ok_or_else(|| NoRandomnessReason::NotInValidatorSet)?;
```

**File:** consensus/src/epoch_manager.rs (L1066-1072)
```rust
        let (sk, pk) = DefaultDKG::decrypt_secret_share_from_transcript(
            &dkg_pub_params,
            &transcript,
            my_index as u64,
            &dkg_decrypt_key,
        )
        .map_err(NoRandomnessReason::SecretShareDecryptionFailed)?;
```

**File:** crates/aptos-dkg/src/pvss/das/weighted_protocol.rs (L220-243)
```rust
    fn decrypt_own_share(
        &self,
        sc: &Self::SecretSharingConfig,
        player: &Player,
        dk: &Self::DecryptPrivKey,
        _pp: &Self::PublicParameters,
    ) -> (Self::DealtSecretKeyShare, Self::DealtPubKeyShare) {
        let weight = sc.get_player_weight(player);
        let mut sk_shares = Vec::with_capacity(weight);
        let pk_shares = self.get_public_key_share(sc, player);

        for j in 0..weight {
            let k = sc.get_share_index(player.id, j).unwrap();

            let ctxt = self.C[k]; // h_1^{f(s_i + j - 1)} \ek_i^{r_{s_i + j}}
            let ephemeral_key = self.R[k].mul(dk.dk); // (g_1^{r_{s_i + j}})
            let dealt_secret_key_share = ctxt.sub(ephemeral_key);

            sk_shares.push(pvss::dealt_secret_key_share::g1::DealtSecretKeyShare::new(
                Self::DealtSecretKey::new(dealt_secret_key_share),
            ));
        }

        (sk_shares, pk_shares)
```

**File:** crates/aptos-crypto/src/weighted_config.rs (L163-165)
```rust
    pub fn get_player_weight(&self, player: &Player) -> usize {
        self.weights[player.id]
    }
```

**File:** crates/aptos-crypto/src/weighted_config.rs (L199-204)
```rust
    pub fn get_share_index(&self, i: usize, j: usize) -> Option<usize> {
        if j < self.weights[i] {
            Some(self.starting_index[i] + j)
        } else {
            None
        }
```
