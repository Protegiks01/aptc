# Audit Report

## Title
Consensus Split Risk from Version-Dependent Delayed Field Removal Logic During Rolling Upgrades

## Summary
The `remove()` function in `versioned_delayed_fields.rs` contains version-dependent assertion logic that differs between BlockSTM V1 and V2. During rolling upgrades where validators run different binary versions with different `blockstm_v2` configurations, this can cause validators to diverge when processing the same block, potentially leading to consensus splits.

## Finding Description

The delayed field removal logic has fundamentally different behavior based on the BlockSTM version: [1](#0-0) 

**V1 Behavior (blockstm_v2 = false):**
- Performs strict assertion that removed entries must be `Estimate` type
- Assertion failure triggers panic/code_invariant_error

**V2 Behavior (blockstm_v2 = true):**
- Returns early, skipping all validation checks
- No assertions performed

The BlockSTM version is determined by local configuration, not on-chain consensus: [2](#0-1) 

This creates different execution paths: [3](#0-2) [4](#0-3) 

The code explicitly acknowledges this inconsistency: [5](#0-4) 

**Critical Issue:** During rolling upgrades, validators with `blockstm_v2 = false` will enforce invariants that validators with `blockstm_v2 = true` completely skip, creating potential for divergent execution outcomes.

## Impact Explanation

**Severity: Critical** - Consensus/Safety Violation

This breaks the fundamental invariant of **Deterministic Execution**: "All validators must produce identical state roots for identical blocks."

During a rolling upgrade:
1. Validator set is split between V1 and V2 configurations
2. Both process the same block containing delayed field operations
3. If V1's assertion fails (entry is not an `Estimate`), V1 validator hits `PanicError` and cannot commit
4. V2 validator skips the check and commits successfully
5. Network splits: some validators commit, others reject the same block

This can cause:
- **Chain halt** if >1/3 validators fail the assertion
- **Chain fork** if validators commit different states
- **Consensus failure** requiring manual intervention or hardfork to resolve

The vulnerability directly violates the consensus safety guarantee that Aptos relies on for correctness.

## Likelihood Explanation

**Likelihood: Medium-High during rolling upgrades**

Required conditions:
1. Network is performing a rolling upgrade between BlockSTM V1 and V2
2. Validators have heterogeneous `config.local.blockstm_v2` settings
3. Block contains transactions with delayed field operations that trigger re-execution
4. Entry state doesn't match V1's assertion expectation

While the exact trigger condition (non-`Estimate` entry at removal time) may be rare, the developers' own TODO comments indicate this is a known incomplete implementation: [6](#0-5) 

The comment "V2 currently does not mark estimate" suggests the implementations are deliberately divergent, increasing the likelihood of assertion failures during version skew.

## Recommendation

1. **Immediate**: Synchronize removal logic across V1 and V2:
   - Either enforce the assertion in both versions (with `PanicError` in V2)
   - Or remove the assertion from V1 and rely on other invariants
   - Ensure consistent estimate marking across versions

2. **Short-term**: Add version compatibility checks:
   - Prevent rolling upgrades when delayed fields are in use
   - Require epoch boundary for BlockSTM version changes
   - Add on-chain config for BlockSTM version to ensure consensus

3. **Long-term**: Convert `blockstm_v2` from local config to on-chain config:
   - Make BlockSTM version part of consensus-critical configuration
   - Ensure all validators in an epoch use the same execution path
   - Synchronize version changes with reconfiguration events

**Code Fix:**
```rust
fn remove(&mut self, txn_idx: TxnIndex, is_blockstm_v2: bool) {
    let deleted_entry = self.versioned_map.remove(&txn_idx);
    
    // Enforce invariant in both V1 and V2 for consensus safety
    if let Some(entry) = deleted_entry {
        match entry.as_ref().deref() {
            VersionEntry::Estimate(_) => {},
            _ => {
                // Return PanicError instead of assertion for proper error handling
                return Err(code_invariant_error(format!(
                    "Removed entry at txn {} must be an Estimate, got {:?}",
                    txn_idx, entry
                )));
            }
        }
    }
    
    self.read_estimate_deltas = false;
    Ok(())
}
```

## Proof of Concept

```rust
// Simulated rolling upgrade scenario
// This demonstrates the divergence, not a full executable PoC

// Validator A (V1): config.local.blockstm_v2 = false
let v1_result = process_delayed_field_output(
    output, txn_idx, read_set, last_input_output, 
    versioned_cache, false  // is_v2 = false
);
// If entry is not Estimate: assertion fails → PanicError

// Validator B (V2): config.local.blockstm_v2 = true  
let v2_result = process_delayed_field_output(
    output, txn_idx, read_set, last_input_output,
    versioned_cache, true  // is_v2 = true
);
// Same entry: early return, no check → Success

// Result: v1_result is Err, v2_result is Ok
// Same block, different outcomes → consensus split
```

**Reproduction Steps:**
1. Configure test environment with 4 validators: 2 with `blockstm_v2=false`, 2 with `blockstm_v2=true`
2. Submit transactions creating delayed fields (aggregators)
3. Trigger transaction re-execution via read dependency invalidation
4. Submit transaction that no longer modifies previously modified delayed field
5. Observe divergence: V1 validators fail with assertion, V2 validators succeed

**Notes**

This vulnerability is specifically triggered during rolling upgrades when validator versions are mixed. While it requires operational circumstances rather than attacker action, it represents a critical consensus safety violation. The developers' TODO comments indicate awareness of the incomplete V2 implementation, suggesting this is a known technical debt that creates consensus risk during deployment transitions.

The fix requires either completing the V2 implementation to match V1 invariants, or making the BlockSTM version part of on-chain consensus to ensure all validators use identical execution logic within each epoch.

### Citations

**File:** aptos-move/mvhashmap/src/versioned_delayed_fields.rs (L124-145)
```rust
    fn remove(&mut self, txn_idx: TxnIndex, is_blockstm_v2: bool) {
        let deleted_entry = self.versioned_map.remove(&txn_idx);

        // TODO(BlockSTMv2): deal w. V2 & estimates and potentially bring back the check
        // that removed entry must be an estimate (but with PanicError).
        if is_blockstm_v2 {
            return;
        }

        // Entries should only be deleted if the transaction that produced them is
        // aborted and re-executed, but abort must have marked the entry as an Estimate.
        assert_matches!(
            deleted_entry
                .expect("Entry must exist to be removed")
                .as_ref()
                .deref(),
            VersionEntry::Estimate(_),
            "Removed entry must be an Estimate",
        );
        // Incarnation changed output behavior, disable reading through estimates optimization.
        self.read_estimate_deltas = false;
    }
```

**File:** aptos-move/mvhashmap/src/versioned_delayed_fields.rs (L182-189)
```rust
                    (_cur, _new) => {
                        // TODO(BlockSTMv2): V2 currently does not mark estimate.
                        // For V1, used to return Err(code_invariant_error(format!(
                        //    "Replaced entry must be an Estimate, {:?} to {:?}",
                        //    cur, new,
                        //)))
                        true
                    },
```

**File:** aptos-move/block-executor/src/executor.rs (L444-451)
```rust
        Self::process_delayed_field_output(
            maybe_output,
            idx_to_execute,
            &mut read_set,
            last_input_output,
            versioned_cache,
            true,
        )?;
```

**File:** aptos-move/block-executor/src/executor.rs (L593-600)
```rust
        Self::process_delayed_field_output(
            processed_output,
            idx_to_execute,
            &mut read_set,
            last_input_output,
            versioned_cache,
            false,
        )?;
```

**File:** aptos-move/block-executor/src/executor.rs (L2555-2575)
```rust
        let _timer = BLOCK_EXECUTOR_INNER_EXECUTE_BLOCK.start_timer();

        if self.config.local.concurrency_level > 1 {
            let parallel_result = if self.config.local.blockstm_v2 {
                BLOCKSTM_VERSION_NUMBER.set(2);
                self.execute_transactions_parallel_v2(
                    signature_verified_block,
                    base_view,
                    transaction_slice_metadata,
                    module_cache_manager_guard,
                )
            } else {
                BLOCKSTM_VERSION_NUMBER.set(1);
                self.execute_transactions_parallel(
                    signature_verified_block,
                    base_view,
                    transaction_slice_metadata,
                    module_cache_manager_guard,
                )
            };

```
