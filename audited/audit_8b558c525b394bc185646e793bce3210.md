# Audit Report

## Title
Write Set Hash Validation Missing in Backup Restore Process Allows State Corruption

## Summary
The backup restore system fails to validate that write_sets match their cryptographic commitment (state_change_hash) in TransactionInfo during the backup load phase. When verification is disabled or backups are restored without replay, corrupted write_sets can be written directly to the database, violating the fundamental invariant that `state_change_hash == hash(write_set)`.

## Finding Description

The Aptos backup system stores transactions along with their execution outputs (events and write_sets) and cryptographic commitments (TransactionInfo). The TransactionInfo contains `state_change_hash`, which must equal the hash of the corresponding write_set to maintain state consistency.

**Vulnerable Code Path:**

When loading backup data, the `LoadedChunk::load()` function verifies the backup's cryptographic integrity: [1](#0-0) 

This verification creates a `TransactionListWithProof` and calls `verify()`, which validates: [2](#0-1) 

Critically, this verification checks transaction hashes (lines 2318-2332) and event root hashes (lines 2338-2351), but **does not validate write_sets** against the `state_change_hash` in TransactionInfo. The write_sets are deserialized but never verified: [3](#0-2) 

**Two Attack Vectors:**

**Vector 1: Direct Save Without Replay**

When transactions are saved before the replay version, unverified write_sets are written directly to the database: [4](#0-3) 

The `save_transactions()` implementation writes write_sets without validation: [5](#0-4) 

**Vector 2: Replay Without Verification**

When verification is disabled (`VerifyExecutionMode::NoVerify`), the system uses `remove_and_apply()` which creates TransactionOutputs from unverified write_sets: [6](#0-5) [7](#0-6) 

The VerifyCoordinator explicitly uses NoVerify mode: [8](#0-7) 

**Broken Invariant:**

The only place write_sets are validated is in `verify_execution()` via `ensure_match_transaction_info()`: [9](#0-8) 

But this validation is **skipped** when verification is disabled, breaking the invariant that `state_change_hash == hash(write_set)`.

## Impact Explanation

This vulnerability meets **Medium Severity** criteria per the Aptos bug bounty program:
- **State inconsistencies requiring intervention**: Corrupted write_sets in the database violate cryptographic commitments
- **Consensus divergence risk**: If different nodes restore from different backups (corrupted vs uncorrupted), they would have different state despite identical TransactionInfo hashes
- **Breaks State Consistency Invariant**: "State transitions must be atomic and verifiable via Merkle proofs" - corrupted write_sets cannot be verified against their committed hashes

While not immediately causing consensus failure (TransactionInfo hashes still match), any state reads or subsequent executions depending on the corrupted write_sets would produce incorrect results.

## Likelihood Explanation

**Likelihood: Medium**

**Attack Requirements:**
1. Attacker obtains or intercepts backup files
2. Modifies write_sets while preserving TransactionInfo hashes
3. Node operator restores from the corrupted backup with verification disabled or without replay

**Feasibility:**
- The verify coordinator **explicitly uses `NoVerify` mode**, making this a realistic scenario
- Backup files are often stored in cloud storage (S3, GCS) which could be compromised
- Large node operators may skip verification for faster restore times
- The verification logic exists but is optional, suggesting it's intended to be skipped in some cases

## Recommendation

Add write_set validation in `LoadedChunk::load()` immediately after verifying the TransactionListWithProof:

```rust
// After line 167 in restore.rs, add:
for (ws, txn_info) in write_sets.iter().zip(txn_infos.iter()) {
    let write_set_hash = CryptoHash::hash(ws);
    ensure!(
        write_set_hash == txn_info.state_change_hash(),
        "Write set hash mismatch at version {}. Expected: {:?}, Got: {:?}",
        version,
        txn_info.state_change_hash(),
        write_set_hash
    );
}
```

This ensures that corrupted write_sets are rejected during the load phase, regardless of whether verification is enabled during replay.

## Proof of Concept

```rust
// Rust test demonstrating the vulnerability
#[test]
fn test_corrupted_writeset_bypass() {
    // 1. Create a legitimate backup with transaction, txn_info, events, and write_set
    let txn = create_test_transaction();
    let write_set = create_legitimate_write_set();
    let events = vec![];
    let txn_info = TransactionInfo::new(
        CryptoHash::hash(&txn),
        CryptoHash::hash(&write_set), // state_change_hash
        EventRootHash::default(),
        /* other fields */
    );
    
    // 2. Corrupt the write_set (attacker modifies backup file)
    let corrupted_write_set = create_different_write_set();
    assert_ne!(
        CryptoHash::hash(&corrupted_write_set),
        txn_info.state_change_hash()
    );
    
    // 3. Serialize corrupted backup data
    let corrupted_record = bcs::to_bytes(&(
        txn,
        PersistedAuxiliaryInfo::None,
        txn_info,
        events,
        corrupted_write_set.clone()
    )).unwrap();
    
    // 4. Load the corrupted backup (this should fail but currently passes)
    let loaded_chunk = LoadedChunk::load(/* ... */).await.unwrap();
    
    // 5. With NoVerify mode, corrupted write_set gets written to DB
    let mut restore_controller = TransactionRestoreBatchController::new(
        /* ... */,
        VerifyExecutionMode::NoVerify,
        /* ... */
    );
    
    restore_controller.run().await.unwrap(); // Should fail but succeeds!
    
    // 6. Verify corruption: DB contains write_set that doesn't match state_change_hash
    let stored_write_set = db.get_write_set(version).unwrap();
    let stored_txn_info = db.get_transaction_info(version).unwrap();
    assert_ne!(
        CryptoHash::hash(&stored_write_set),
        stored_txn_info.state_change_hash()
    ); // INVARIANT VIOLATED!
}
```

### Citations

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L156-167)
```rust
        // make a `TransactionListWithProof` to reuse its verification code.
        let txn_list_with_proof =
            TransactionListWithProofV2::new(TransactionListWithAuxiliaryInfos::new(
                TransactionListWithProof::new(
                    txns,
                    Some(event_vecs),
                    Some(manifest.first_version),
                    TransactionInfoListWithProof::new(range_proof, txn_infos),
                ),
                persisted_aux_info,
            ));
        txn_list_with_proof.verify(ledger_info.ledger_info(), Some(manifest.first_version))?;
```

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L177-186)
```rust
        Ok(Self {
            manifest,
            txns,
            persisted_aux_info,
            txn_infos,
            event_vecs,
            range_proof,
            write_sets,
        })
    }
```

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L507-515)
```rust
                        tokio::task::spawn_blocking(move || {
                            restore_handler.save_transactions(
                                first_version,
                                &txns_to_save,
                                &persisted_aux_info_to_save,
                                &txn_infos_to_save,
                                &event_vecs_to_save,
                                write_sets_to_save,
                            )
```

**File:** types/src/transaction/mod.rs (L1898-1908)
```rust
        let write_set_hash = CryptoHash::hash(self.write_set());
        ensure!(
            write_set_hash == txn_info.state_change_hash(),
            "{}: version:{}, write_set_hash:{:?}, expected:{:?}, write_set: {:?}, expected(if known): {:?}",
            ERR_MSG,
            version,
            write_set_hash,
            txn_info.state_change_hash(),
            self.write_set,
            expected_write_set,
        );
```

**File:** types/src/transaction/mod.rs (L2295-2354)
```rust
    pub fn verify(
        &self,
        ledger_info: &LedgerInfo,
        first_transaction_version: Option<Version>,
    ) -> Result<()> {
        // Verify the first transaction versions match
        ensure!(
            self.get_first_transaction_version() == first_transaction_version,
            "First transaction version ({:?}) doesn't match given version ({:?}).",
            self.get_first_transaction_version(),
            first_transaction_version,
        );

        // Verify the lengths of the transactions and transaction infos match
        ensure!(
            self.proof.transaction_infos.len() == self.get_num_transactions(),
            "The number of TransactionInfo objects ({}) does not match the number of \
             transactions ({}).",
            self.proof.transaction_infos.len(),
            self.get_num_transactions(),
        );

        // Verify the transaction hashes match those of the transaction infos
        self.transactions
            .par_iter()
            .zip_eq(self.proof.transaction_infos.par_iter())
            .map(|(txn, txn_info)| {
                let txn_hash = CryptoHash::hash(txn);
                ensure!(
                    txn_hash == txn_info.transaction_hash(),
                    "The hash of transaction does not match the transaction info in proof. \
                     Transaction hash: {:x}. Transaction hash in txn_info: {:x}.",
                    txn_hash,
                    txn_info.transaction_hash(),
                );
                Ok(())
            })
            .collect::<Result<Vec<_>>>()?;

        // Verify the transaction infos are proven by the ledger info.
        self.proof
            .verify(ledger_info, self.get_first_transaction_version())?;

        // Verify the events if they exist.
        if let Some(event_lists) = &self.events {
            ensure!(
                event_lists.len() == self.get_num_transactions(),
                "The length of event_lists ({}) does not match the number of transactions ({}).",
                event_lists.len(),
                self.get_num_transactions(),
            );
            event_lists
                .into_par_iter()
                .zip_eq(self.proof.transaction_infos.par_iter())
                .map(|(events, txn_info)| verify_events_against_root_hash(events, txn_info))
                .collect::<Result<Vec<_>>>()?;
        }

        Ok(())
    }
```

**File:** storage/aptosdb/src/backup/restore_utils.rs (L261-267)
```rust
    for (idx, ws) in write_sets.iter().enumerate() {
        WriteSetDb::put_write_set(
            first_version + idx as Version,
            ws,
            &mut ledger_db_batch.write_set_db_batches,
        )?;
    }
```

**File:** execution/executor/src/chunk_executor/mod.rs (L562-584)
```rust
            let next_begin = if verify_execution_mode.should_verify() {
                self.verify_execution(
                    transactions,
                    persisted_aux_info,
                    transaction_infos,
                    write_sets,
                    event_vecs,
                    batch_begin,
                    batch_end,
                    verify_execution_mode,
                )?
            } else {
                batch_end
            };
            self.remove_and_apply(
                transactions,
                persisted_aux_info,
                transaction_infos,
                write_sets,
                event_vecs,
                batch_begin,
                next_begin,
            )?;
```

**File:** execution/executor/src/chunk_executor/mod.rs (L668-688)
```rust
        let (transactions, persisted_aux_info, transaction_outputs) = multizip((
            transactions.drain(..num_txns),
            persisted_aux_info.drain(..num_txns),
            txn_infos.iter(),
            write_sets.drain(..num_txns),
            event_vecs.drain(..num_txns),
        ))
        .map(|(txn, persisted_aux_info, txn_info, write_set, events)| {
            (
                txn,
                persisted_aux_info,
                TransactionOutput::new(
                    write_set,
                    events,
                    txn_info.gas_used(),
                    TransactionStatus::Keep(txn_info.status().clone()),
                    TransactionAuxiliaryData::default(), // No auxiliary data if transaction is not executed through VM
                ),
            )
        })
        .multiunzip();
```

**File:** storage/backup/backup-cli/src/coordinators/verify.rs (L145-154)
```rust
        TransactionRestoreBatchController::new(
            global_opt,
            self.storage,
            txn_manifests,
            None,
            None, /* replay_from_version */
            epoch_history,
            VerifyExecutionMode::NoVerify,
            self.output_transaction_analysis,
        )
```
