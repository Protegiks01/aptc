# Audit Report

## Title
Byzantine Validator Timeout Equivocation Enables Network Inconsistency via Missing Duplicate Detection

## Summary
A Byzantine validator can construct and distribute multiple valid but conflicting `RoundTimeout` messages for the same round with different highest quorum certificate (HQC) values to different honest validators. Unlike `VoteMsg` which has explicit equivocation detection, `RoundTimeout` messages lack any duplicate/conflict detection mechanism, allowing Byzantine validators to cause different honest validators to form incompatible timeout certificates for the same round.

## Finding Description

The AptosBFT consensus protocol includes explicit equivocation detection for vote messages to prevent Byzantine validators from sending conflicting votes. However, the same protection is **completely absent** for `RoundTimeout` messages. [1](#0-0) 

When processing vote messages, `PendingVotes::insert_vote()` maintains an `author_to_vote` map and explicitly checks if a validator has already voted with different content, logging a `SecurityEvent::ConsensusEquivocatingVote` and rejecting the conflicting vote.

In contrast, `RoundTimeout` processing has no such protection: [2](#0-1) 

The `insert_round_timeout()` function has no check for duplicate or conflicting timeouts from the same author. It directly adds the timeout to the aggregation structure without verifying if the validator already sent a different timeout for this round. [3](#0-2) 

The underlying `TwoChainTimeoutWithPartialSignatures::add()` uses `or_insert` which only prevents storing multiple signatures, but doesn't detect when a validator sends conflicting timeouts with different HQC rounds.

**Attack Scenario:**

1. Byzantine validator V_B creates two valid timeouts for round R:
   - `timeout_low`: `TwoChainTimeout(epoch=E, round=R, qc=QC_8)` signed over `(E, R, 8)`
   - `timeout_high`: `TwoChainTimeout(epoch=E, round=R, qc=QC_9)` signed over `(E, R, 9)`

2. V_B sends `timeout_low` to validators in set A
3. V_B sends `timeout_high` to validators in set B

4. Validators in set A aggregate `timeout_low` and form `TC_A` with `highest_hqc = 8`
5. Validators in set B aggregate `timeout_high` and form `TC_B` with `highest_hqc = 9`

6. Both timeout certificates verify correctly per their respective signatures: [4](#0-3) 

7. Different validators now have incompatible views of the network's highest certified round, affecting safety rule evaluation: [5](#0-4) 

When evaluating proposals in the next round, validators with `TC_A` accept proposals with `qc.round >= 8`, while validators with `TC_B` only accept proposals with `qc.round >= 9`. This creates network inconsistency and potential for validator disagreement on proposal validity.

## Impact Explanation

**Severity: High** - Significant Protocol Violation

This vulnerability violates critical AptosBFT protocol invariants:

1. **Equivocation Without Detection**: The explicit equivocation check for votes demonstrates that the protocol SHOULD detect and prevent conflicting messages from the same validator. The absence of this check for timeouts is a protocol design inconsistency.

2. **Network State Inconsistency**: Different honest validators form incompatible timeout certificates, breaking consensus on the network's highest certified round. This violates the assumption that all honest nodes have a consistent view of consensus state.

3. **Safety Rule Divergence**: Validators apply different safety rules based on their incompatible TCs, potentially accepting different proposals as valid. This creates conditions for consensus splits.

While this doesn't directly cause honest validators to double-sign (they still follow their individual safety rules), it creates network conditions that could enable more sophisticated attacks and breaks the protocol's equivocation detection invariant.

## Likelihood Explanation

**Likelihood: High**

- Any Byzantine validator can perform this attack with no special setup
- Requires only the ability to send different messages to different peers (standard network behavior)  
- No coordination with other Byzantine validators needed
- Attack is completely undetectable by the current codebase (no logging, no rejection, no penalties)
- Byzantine validators have clear incentive to disrupt consensus

The attack is trivial to execute and has no detection mechanism.

## Recommendation

Add equivocation detection for `RoundTimeout` messages, mirroring the protection already in place for votes:

**In `PendingVotes` struct:**
```rust
pub struct PendingVotes {
    // ... existing fields ...
    /// Map of Author to (timeout, timeout_hash) for duplicate detection
    author_to_timeout: HashMap<Author, (RoundTimeout, HashValue)>,
}
```

**In `insert_round_timeout()` function:**
```rust
pub fn insert_round_timeout(
    &mut self,
    round_timeout: &RoundTimeout,
    validator_verifier: &ValidatorVerifier,
) -> VoteReceptionResult {
    // Compute a hash of the timeout's content (epoch, round, hqc_round)
    let timeout_hash = hash_timeout_content(round_timeout);
    
    // Check for equivocation
    if let Some((previous_timeout, previous_hash)) = 
        self.author_to_timeout.get(&round_timeout.author()) 
    {
        if timeout_hash != *previous_hash {
            error!(
                SecurityEvent::ConsensusEquivocatingTimeout,
                remote_peer = round_timeout.author(),
                timeout = round_timeout,
                previous_timeout = previous_timeout
            );
            return VoteReceptionResult::EquivocateVote; // Reuse existing error type
        }
        // Duplicate timeout - already processed
        return VoteReceptionResult::DuplicateVote;
    }
    
    // Store timeout for duplicate detection
    self.author_to_timeout.insert(
        round_timeout.author(), 
        (round_timeout.clone(), timeout_hash)
    );
    
    // ... rest of existing logic ...
}
```

This change ensures timeout messages receive the same equivocation protection as vote messages.

## Proof of Concept

```rust
// Test demonstrating timeout equivocation is not detected
#[test]
fn test_timeout_equivocation_undetected() {
    use aptos_consensus_types::{
        timeout_2chain::TwoChainTimeout,
        round_timeout::{RoundTimeout, RoundTimeoutReason},
        quorum_cert::QuorumCert,
    };
    use aptos_types::validator_verifier::random_validator_verifier;
    
    let (signers, validator_verifier) = random_validator_verifier(4, None, false);
    let mut pending_votes = PendingVotes::new();
    
    // Byzantine validator creates two different timeouts for round 10
    let qc_8 = generate_qc_for_round(8, &signers, &validator_verifier);
    let qc_9 = generate_qc_for_round(9, &signers, &validator_verifier);
    
    let timeout_low = TwoChainTimeout::new(1, 10, qc_8);
    let sig_low = timeout_low.sign(&signers[0]).unwrap();
    let round_timeout_low = RoundTimeout::new(
        timeout_low,
        signers[0].author(),
        RoundTimeoutReason::NoQC,
        sig_low,
    );
    
    let timeout_high = TwoChainTimeout::new(1, 10, qc_9);
    let sig_high = timeout_high.sign(&signers[0]).unwrap();
    let round_timeout_high = RoundTimeout::new(
        timeout_high,
        signers[0].author(),
        RoundTimeoutReason::NoQC,
        sig_high,
    );
    
    // Insert first timeout - succeeds
    let result1 = pending_votes.insert_round_timeout(
        &round_timeout_low,
        &validator_verifier
    );
    assert!(matches!(result1, VoteReceptionResult::VoteAdded(_)));
    
    // Insert conflicting timeout from SAME author - should detect equivocation
    // but currently does NOT!
    let result2 = pending_votes.insert_round_timeout(
        &round_timeout_high,
        &validator_verifier
    );
    
    // CURRENT BEHAVIOR: Accepts the equivocating timeout without detection
    // EXPECTED BEHAVIOR: Should return VoteReceptionResult::EquivocateVote
    assert!(matches!(result2, VoteReceptionResult::VoteAdded(_)));
    // ^ This assertion PASSES, demonstrating the vulnerability
}
```

## Notes

This vulnerability represents a critical gap in the protocol's Byzantine fault detection. While votes have robust equivocation detection, timeouts can be equivocated freely. This asymmetry suggests an oversight in the implementation rather than an intentional design choice, especially given that timeout certificates directly influence consensus safety rules through the `highest_hqc` value.

### Citations

**File:** consensus/src/pending_votes.rs (L190-232)
```rust
    pub fn insert_round_timeout(
        &mut self,
        round_timeout: &RoundTimeout,
        validator_verifier: &ValidatorVerifier,
    ) -> VoteReceptionResult {
        //
        // Let's check if we can create a TC
        //

        let timeout = round_timeout.two_chain_timeout();
        let signature = round_timeout.signature();

        let validator_voting_power = validator_verifier
            .get_voting_power(&round_timeout.author())
            .unwrap_or(0);
        if validator_voting_power == 0 {
            warn!(
                "Received vote with no voting power, from {}",
                round_timeout.author()
            );
        }
        let cur_epoch = round_timeout.epoch();
        let cur_round = round_timeout.round();

        counters::CONSENSUS_CURRENT_ROUND_TIMEOUT_VOTED_POWER
            .with_label_values(&[&round_timeout.author().to_string()])
            .set(validator_voting_power as f64);
        counters::CONSENSUS_LAST_TIMEOUT_VOTE_EPOCH
            .with_label_values(&[&round_timeout.author().to_string()])
            .set(cur_epoch as i64);
        counters::CONSENSUS_LAST_TIMEOUT_VOTE_ROUND
            .with_label_values(&[&round_timeout.author().to_string()])
            .set(cur_round as i64);

        let two_chain_votes = self
            .maybe_2chain_timeout_votes
            .get_or_insert_with(|| TwoChainTimeoutVotes::new(timeout.clone()));
        two_chain_votes.add(
            round_timeout.author(),
            timeout.clone(),
            signature.clone(),
            round_timeout.reason().clone(),
        );
```

**File:** consensus/src/pending_votes.rs (L287-308)
```rust
        if let Some((previously_seen_vote, previous_li_digest)) =
            self.author_to_vote.get(&vote.author())
        {
            // is it the same vote?
            if &li_digest == previous_li_digest {
                // we've already seen an equivalent vote before
                let new_timeout_vote = vote.is_timeout() && !previously_seen_vote.is_timeout();
                if !new_timeout_vote {
                    // it's not a new timeout vote
                    return VoteReceptionResult::DuplicateVote;
                }
            } else {
                // we have seen a different vote for the same round
                error!(
                    SecurityEvent::ConsensusEquivocatingVote,
                    remote_peer = vote.author(),
                    vote = vote,
                    previous_vote = previously_seen_vote
                );

                return VoteReceptionResult::EquivocateVote;
            }
```

**File:** consensus/consensus-types/src/timeout_2chain.rs (L141-183)
```rust
    pub fn verify(&self, validators: &ValidatorVerifier) -> anyhow::Result<()> {
        let hqc_round = self.timeout.hqc_round();
        // Verify the highest timeout validity.
        let (timeout_result, sig_result) = rayon::join(
            || self.timeout.verify(validators),
            || {
                let timeout_messages: Vec<_> = self
                    .signatures_with_rounds
                    .get_voters_and_rounds(
                        &validators
                            .get_ordered_account_addresses_iter()
                            .collect_vec(),
                    )
                    .into_iter()
                    .map(|(_, round)| TimeoutSigningRepr {
                        epoch: self.timeout.epoch(),
                        round: self.timeout.round(),
                        hqc_round: round,
                    })
                    .collect();
                let timeout_messages_ref: Vec<_> = timeout_messages.iter().collect();
                validators.verify_aggregate_signatures(
                    &timeout_messages_ref,
                    self.signatures_with_rounds.sig(),
                )
            },
        );
        timeout_result?;
        sig_result?;
        let signed_hqc = self
            .signatures_with_rounds
            .rounds()
            .iter()
            .max()
            .ok_or_else(|| anyhow::anyhow!("Empty rounds"))?;
        ensure!(
            hqc_round == *signed_hqc,
            "Inconsistent hqc round, qc has round {}, highest signed round {}",
            hqc_round,
            *signed_hqc
        );
        Ok(())
    }
```

**File:** consensus/consensus-types/src/timeout_2chain.rs (L242-263)
```rust
    pub fn add(
        &mut self,
        author: Author,
        timeout: TwoChainTimeout,
        signature: bls12381::Signature,
    ) {
        debug_assert_eq!(
            self.timeout.epoch(),
            timeout.epoch(),
            "Timeout should have the same epoch as TimeoutCert"
        );
        debug_assert_eq!(
            self.timeout.round(),
            timeout.round(),
            "Timeout should have the same round as TimeoutCert"
        );
        let hqc_round = timeout.hqc_round();
        if timeout.hqc_round() > self.timeout.hqc_round() {
            self.timeout = timeout;
        }
        self.signatures.add_signature(author, hqc_round, signature);
    }
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L147-166)
```rust
    /// Core safety voting rule for 2-chain protocol. Return success if 1 or 2 is true
    /// 1. block.round == block.qc.round + 1
    /// 2. block.round == tc.round + 1 && block.qc.round >= tc.highest_hqc.round
    fn safe_to_vote(
        &self,
        block: &Block,
        maybe_tc: Option<&TwoChainTimeoutCertificate>,
    ) -> Result<(), Error> {
        let round = block.round();
        let qc_round = block.quorum_cert().certified_block().round();
        let tc_round = maybe_tc.map_or(0, |tc| tc.round());
        let hqc_round = maybe_tc.map_or(0, |tc| tc.highest_hqc_round());
        if round == next_round(qc_round)?
            || (round == next_round(tc_round)? && qc_round >= hqc_round)
        {
            Ok(())
        } else {
            Err(Error::NotSafeToVote(round, qc_round, tc_round, hqc_round))
        }
    }
```
