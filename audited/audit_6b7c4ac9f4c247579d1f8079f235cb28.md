> Searching codebase... [1](#0-0) [2](#0-1)

### Citations

**File:** network/framework/src/protocols/stream/mod.rs (L225-251)
```rust
impl OutboundStream {
    pub fn new(
        max_frame_size: usize,
        max_message_size: usize,
        stream_tx: Sender<MultiplexMessage>,
    ) -> Self {
        // Calculate the effective max frame size (subtracting overhead)
        let max_frame_size = max_frame_size
            .checked_sub(FRAME_OVERHEAD_BYTES)
            .expect("Frame size too small, overhead exceeds frame size!");

        // Ensure that the max message size can be supported with the given frame size
        assert!(
            (max_frame_size * (u8::MAX as usize)) >= max_message_size,
            "Stream only supports {} chunks! Frame size {}, message size {}.",
            u8::MAX,
            max_frame_size,
            max_message_size
        );

        Self {
            request_id_gen: U32IdGenerator::new(),
            max_frame_size,
            max_message_size,
            stream_tx,
        }
    }
```

**File:** network/framework/src/protocols/stream/mod.rs (L259-341)
```rust
    pub async fn stream_message(&mut self, mut message: NetworkMessage) -> anyhow::Result<()> {
        // Verify that the message is not an error message
        ensure!(
            !matches!(message, NetworkMessage::Error(_)),
            "Error messages should not be streamed!"
        );

        // Verify that the message size is within limits
        let message_data_len = message.data_len();
        ensure!(
            message_data_len <= self.max_message_size,
            "Message length {} exceeds max message size {}!",
            message_data_len,
            self.max_message_size,
        );

        // Verify that the message size exceeds the frame size
        ensure!(
            message_data_len >= self.max_frame_size,
            "Message length {} is smaller than frame size {}! It should not be streamed.",
            message_data_len,
            self.max_frame_size,
        );

        // Generate a new request ID for the stream
        let request_id = self.request_id_gen.next();

        // Split the message data into chunks
        let rest = match &mut message {
            NetworkMessage::Error(_) => {
                unreachable!("NetworkMessage::Error(_) should always fit into a single frame!")
            },
            NetworkMessage::RpcRequest(request) => {
                request.raw_request.split_off(self.max_frame_size)
            },
            NetworkMessage::RpcResponse(response) => {
                response.raw_response.split_off(self.max_frame_size)
            },
            NetworkMessage::DirectSendMsg(message) => {
                message.raw_msg.split_off(self.max_frame_size)
            },
        };
        let chunks = rest.chunks(self.max_frame_size);

        // Ensure that the number of chunks does not exceed u8::MAX
        let num_chunks = chunks.len();
        ensure!(
            num_chunks <= (u8::MAX as usize),
            "Number of fragments overflowed the u8 limit: {} (max: {})!",
            num_chunks,
            u8::MAX
        );

        // Send the stream header
        let header = StreamMessage::Header(StreamHeader {
            request_id,
            num_fragments: num_chunks as u8,
            message,
        });
        self.stream_tx
            .send(MultiplexMessage::Stream(header))
            .await?;

        // Send each fragment
        for (index, chunk) in chunks.enumerate() {
            // Calculate the fragment ID (note: fragment IDs start at 1)
            let fragment_id = index.checked_add(1).ok_or_else(|| {
                anyhow::anyhow!("Fragment ID overflowed when adding 1: {}", index)
            })?;

            // Send the fragment message
            let message = StreamMessage::Fragment(StreamFragment {
                request_id,
                fragment_id: fragment_id as u8,
                raw_data: Vec::from(chunk),
            });
            self.stream_tx
                .send(MultiplexMessage::Stream(message))
                .await?;
        }

        Ok(())
    }
```
