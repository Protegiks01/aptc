# Audit Report

## Title
Indexer gRPC Service Denial of Service via Integer Underflow in Address Standardization

## Summary
The `standardize_address` function in the transaction filter module contains an integer underflow vulnerability that causes a panic when processing address strings longer than 64 hexadecimal characters. This vulnerability can be exploited by sending malformed protobuf messages to indexer gRPC endpoints, causing immediate service crashes.

## Finding Description

The vulnerability exists in the `From<aptos_protos::indexer::v1::EntryFunctionFilter>` trait implementation, which performs infallible type conversion from protobuf to Rust types. During this conversion, the `standardize_address` function is called to normalize address strings. [1](#0-0) 

The `standardize_address` function attempts to pad addresses to 64 hex characters by calculating the required padding: [2](#0-1) 

At line 33, the expression `64 - trimmed.len()` will underflow if `trimmed.len() > 64`. In Rust:
- **Debug mode**: Immediate panic due to integer underflow check
- **Release mode**: Wraps to a very large number (e.g., `usize::MAX - difference`), causing panic when slicing `ZEROS[..huge_number]`

The attack path is straightforward:

1. Attacker crafts a protobuf `GetTransactionsRequest` with a malicious filter
2. The `EntryFunctionFilter.address` field contains a string with >64 hex characters (e.g., "0x" + 65 'a's)
3. Request is sent to indexer gRPC endpoint (historical or live data service)
4. Service calls `parse_transaction_filter`: [3](#0-2) 

5. The conversion chain executes: `new_from_proto` → `TryInto<APIFilter>` → `From::from` for `UserTransactionFilter` → `From::from` for `EntryFunctionFilter`
6. `standardize_address` panics, crashing the entire service

The critical issue is that the `From` trait is **infallible** - it cannot return errors. The error handling in `parse_transaction_filter` at line 14 only catches errors from operations that return `Result`, but panics propagate upward and crash the service. [4](#0-3) 

The same vulnerability affects `UserTransactionFilter` when the sender field contains oversized addresses: [5](#0-4) 

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos bug bounty program criteria:
- **API crashes**: The indexer gRPC service terminates immediately upon receiving a malformed filter
- **Service availability impact**: The indexer is critical infrastructure for Aptos ecosystem applications, wallets, explorers, and analytics platforms

The indexer gRPC service processes real-time blockchain data for external consumers. A crash requires manual restart and may cause:
- Data processing delays and gaps
- Downstream application failures
- Loss of monitoring/alerting capabilities
- Degraded user experience across the ecosystem

The vulnerability does NOT meet Critical severity because:
- No consensus impact (indexer is off-chain infrastructure)
- No fund loss or state corruption
- Service can be restarted (not non-recoverable)

## Likelihood Explanation

**Likelihood: High**

This vulnerability is trivially exploitable:
- **No authentication required**: Indexer gRPC endpoints are public
- **No complex state manipulation**: Single malformed request sufficient
- **Reliable exploitation**: Deterministic panic on every request
- **Low attacker resources**: Can be scripted and automated
- **Wide attack surface**: Multiple endpoints affected (historical_data_service, live_data_service, fullnode localnet service)

The vulnerability exists in production code paths used by: [6](#0-5) 

An attacker can cause persistent denial of service by repeatedly sending malformed requests, especially if automated restart mechanisms exist.

## Recommendation

**Immediate Fix**: Replace the `From` trait with `TryFrom` to enable proper error handling.

**For `standardize_address` function**:
```rust
pub fn standardize_address(address: &str) -> Result<String, anyhow::Error> {
    let trimmed = address.strip_prefix("0x").unwrap_or(address);
    
    // Validate length BEFORE performing arithmetic
    anyhow::ensure!(
        trimmed.len() <= 64,
        "Address too long: {} characters (max 64 hex digits)", 
        trimmed.len()
    );
    
    if let Some(last_char) = trimmed.chars().last() {
        if trimmed[..trimmed.len().saturating_sub(1)]
            .chars()
            .all(|c| c == '0')
            && last_char.is_ascii_hexdigit()
            && last_char <= 'f'
        {
            let mut result = String::with_capacity(3);
            result.push_str("0x");
            result.push(last_char);
            return Ok(result);
        }
    }

    let mut result = String::with_capacity(66);
    result.push_str("0x");
    result.push_str(&ZEROS[..64 - trimmed.len()]);
    result.push_str(trimmed);
    Ok(result)
}
```

**For `EntryFunctionFilter` conversion**:
```rust
impl TryFrom<aptos_protos::indexer::v1::EntryFunctionFilter> for EntryFunctionFilter {
    type Error = anyhow::Error;

    fn try_from(proto_filter: aptos_protos::indexer::v1::EntryFunctionFilter) -> Result<Self> {
        let standardized_address = if let Some(ref address) = proto_filter.address {
            Some(standardize_address(address)?)
        } else {
            None
        };

        Ok(Self {
            standardized_address: OnceCell::with_value(standardized_address),
            address: proto_filter.address,
            module: proto_filter.module_name,
            function: proto_filter.function,
        })
    }
}
```

Apply similar changes to `UserTransactionFilter` and update all call sites to use `try_into()` instead of `into()`.

## Proof of Concept

```rust
#[cfg(test)]
mod vulnerability_test {
    use super::*;
    use aptos_protos::indexer::v1::EntryFunctionFilter as ProtoFilter;

    #[test]
    #[should_panic(expected = "range end index")]
    fn test_oversized_address_causes_panic() {
        // Create a protobuf filter with oversized address (65 hex chars)
        let malicious_address = "0x".to_string() + &"a".repeat(65);
        
        let proto_filter = ProtoFilter {
            address: Some(malicious_address),
            module_name: None,
            function: None,
        };

        // This conversion will panic due to integer underflow in standardize_address
        let _rust_filter: EntryFunctionFilter = proto_filter.into();
        
        // Service crashes here - never reaches this line
        panic!("Should have panicked before this point");
    }

    #[test]
    fn test_normal_address_works() {
        // Verify normal addresses still work
        let proto_filter = ProtoFilter {
            address: Some("0x1".to_string()),
            module_name: Some("coin".to_string()),
            function: Some("transfer".to_string()),
        };

        let rust_filter: EntryFunctionFilter = proto_filter.into();
        assert_eq!(rust_filter.address, Some("0x1".to_string()));
    }
}
```

**Notes:**
- The vulnerability also affects `MoveStructTagFilter` in event filters through the same code path
- Empty addresses ("") do not trigger the bug as `64 - 0 = 64` is valid
- Addresses with exactly 64 hex characters work correctly
- The bug is triggered at 65+ hex characters in the trimmed string

### Citations

**File:** ecosystem/indexer-grpc/transaction-filter/src/filters/user_transaction.rs (L48-61)
```rust
impl From<aptos_protos::indexer::v1::UserTransactionFilter> for UserTransactionFilter {
    fn from(proto_filter: aptos_protos::indexer::v1::UserTransactionFilter) -> Self {
        Self {
            standardized_sender: OnceCell::with_value(
                proto_filter
                    .sender
                    .as_ref()
                    .map(|address| standardize_address(address)),
            ),
            sender: proto_filter.sender,
            payload: proto_filter.payload_filter.map(|f| f.into()),
        }
    }
}
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/filters/user_transaction.rs (L155-169)
```rust
impl From<aptos_protos::indexer::v1::EntryFunctionFilter> for EntryFunctionFilter {
    fn from(proto_filter: aptos_protos::indexer::v1::EntryFunctionFilter) -> Self {
        Self {
            standardized_address: OnceCell::with_value(
                proto_filter
                    .address
                    .as_ref()
                    .map(|address| standardize_address(address)),
            ),
            address: proto_filter.address,
            module: proto_filter.module_name,
            function: proto_filter.function,
        }
    }
}
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/utils.rs (L30-36)
```rust
    // Return non-special addresses in long format
    let mut result = String::with_capacity(66);
    result.push_str("0x");
    result.push_str(&ZEROS[..64 - trimmed.len()]);
    result.push_str(trimmed);
    result
}
```

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/filter_utils.rs (L9-15)
```rust
pub fn parse_transaction_filter(
    proto_filter: aptos_protos::indexer::v1::BooleanTransactionFilter,
    max_filter_size_bytes: usize,
) -> Result<BooleanTransactionFilter, Status> {
    BooleanTransactionFilter::new_from_proto(proto_filter, Some(max_filter_size_bytes))
        .map_err(|e| Status::invalid_argument(format!("Invalid transaction_filter: {e:?}.")))
}
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/boolean_transaction_filter.rs (L380-400)
```rust
impl TryFrom<aptos_protos::indexer::v1::ApiFilter> for APIFilter {
    type Error = anyhow::Error;

    fn try_from(proto_filter: aptos_protos::indexer::v1::ApiFilter) -> Result<Self> {
        Ok(
            match proto_filter
                .filter
                .ok_or(anyhow!("Oneof is not set in ApiFilter."))?
            {
                aptos_protos::indexer::v1::api_filter::Filter::TransactionRootFilter(
                    transaction_root_filter,
                ) => Into::<TransactionRootFilter>::into(transaction_root_filter).into(),
                aptos_protos::indexer::v1::api_filter::Filter::UserTransactionFilter(
                    user_transaction_filter,
                ) => Into::<UserTransactionFilter>::into(user_transaction_filter).into(),
                aptos_protos::indexer::v1::api_filter::Filter::EventFilter(event_filter) => {
                    Into::<EventFilter>::into(event_filter).into()
                },
            },
        )
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/historical_data_service.rs (L83-97)
```rust
                let filter = if let Some(proto_filter) = request.transaction_filter {
                    match filter_utils::parse_transaction_filter(
                        proto_filter,
                        self.max_transaction_filter_size_bytes,
                    ) {
                        Ok(filter) => Some(filter),
                        Err(err) => {
                            info!("Client error: {err:?}.");
                            let _ = response_sender.blocking_send(Err(err));
                            COUNTER
                                .with_label_values(&["historical_data_service_invalid_filter"])
                                .inc();
                            continue;
                        },
                    }
```
