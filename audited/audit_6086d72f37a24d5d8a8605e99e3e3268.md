# Audit Report

## Title
Cross-Shard Messages Lack Transaction Hash Binding Enabling State Manipulation in Compromised Remote Execution

## Summary
Cross-shard messages in Aptos' sharded block execution system do not include transaction hashes or cryptographic bindings to specific transactions. Messages contain only `(state_key, write_op)` pairs without any proof that they originated from the correct transaction execution, enabling a compromised remote executor shard to send arbitrary state values to dependent shards. [1](#0-0) 

## Finding Description

The sharded block execution system uses `CrossShardMsg::RemoteTxnWriteMsg` to communicate state updates between shards. When a transaction commits in one shard and has dependent transactions in other shards, it sends messages containing only the state key and write operation: [2](#0-1) 

The sending function creates messages without any transaction identifier: [3](#0-2) 

The receiving side accepts these messages without validation of their origin transaction: [4](#0-3) 

**Attack Vector**: In remote sharded execution mode, a compromised executor shard can send incorrect state values: [5](#0-4) 

The message is simply serialized and sent over the network with no cryptographic proof that it came from executing a specific transaction.

**Exploitation Path**:
1. Validator V1 uses remote sharded execution across machines E0, E1, E2, E3
2. Attacker compromises executor shard E0 (via software vulnerability, supply chain attack, or infrastructure breach)
3. During block execution, transaction T5 in E0 should write `StateKey("Alice_balance") = StateValue(900)`
4. Compromised E0 instead sends `CrossShardMsg(RemoteTxnWrite("Alice_balance", StateValue(9000)))`
5. Dependent shard E1 receives this malicious message and uses the incorrect value
6. E1 executes dependent transactions with corrupted state (10x actual balance)
7. Validator V1 produces incorrect state root, breaking **Deterministic Execution** invariant

## Impact Explanation

**Critical Severity** under the following scenarios:

1. **Single Validator Impact**: Compromised executor shard causes validator to compute incorrect state root. Validator's vote is rejected by consensus (< 1/3 Byzantine tolerance). This represents a **validator node compromise** requiring intervention.

2. **Consensus Safety Violation**: If multiple validators use compromised remote executor services (e.g., shared cloud providers, compromised software supply chain), >1/3 validators could produce divergent state roots, breaking **AptosBFT consensus safety**.

3. **State Manipulation**: Incorrect cross-shard messages enable:
   - **Balance inflation** (sending higher amounts than actually transferred)
   - **Unauthorized access** (sending state indicating account has permissions it lacks)  
   - **Double-spending** (inconsistent state across shards within same validator)

4. **No Recovery Mechanism**: The system has no transaction hash validation to detect or reject malicious messages. Once a compromised shard sends incorrect values, dependent shards blindly accept them.

This violates the **Deterministic Execution** invariant: "All validators must produce identical state roots for identical blocks."

## Likelihood Explanation

**Likelihood: Medium to High** depending on deployment model:

**High Likelihood if**:
- Remote executor shards run on untrusted infrastructure (cloud providers, third-party services)
- Multiple validators share executor infrastructure
- Remote executor software has exploitable vulnerabilities
- Supply chain attacks compromise executor binaries

**Medium Likelihood if**:
- Remote executors are within validator's trusted perimeter
- Strong infrastructure security controls exist
- Limited deployment of remote sharded execution

**Attacker Requirements**:
- Compromise one remote executor shard process (realistic via CVE, supply chain, or infrastructure breach)
- Network access to send malicious messages (already has as compromised shard)
- No additional validator privileges needed

**Complexity**: Low - once shard is compromised, attack is straightforward:
1. Intercept outgoing cross-shard messages
2. Modify `write_op` field to arbitrary value
3. Send modified message to dependent shards
4. No cryptographic checks prevent this

## Recommendation

**Add transaction hash binding and cryptographic verification to cross-shard messages:**

```rust
// Modified message structure
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct RemoteTxnWrite {
    state_key: StateKey,
    write_op: Option<WriteOp>,
    // NEW: Bind to specific transaction
    txn_hash: HashValue,
    source_txn_index: TxnIndex,
    // NEW: Cryptographic proof
    signature: Signature, // Sign (txn_hash, state_key, write_op)
}
```

**Validation on receive:**
```rust
RemoteTxnWriteMsg(txn_commit_msg) => {
    // NEW: Verify signature
    if !verify_cross_shard_message(&txn_commit_msg) {
        panic!("Invalid cross-shard message signature");
    }
    
    // NEW: Verify expected transaction
    if !dependency_matches(txn_commit_msg.source_txn_index, state_key) {
        panic!("Unexpected source transaction for dependency");
    }
    
    let (state_key, write_op) = txn_commit_msg.take();
    cross_shard_state_view.set_value(&state_key, write_op);
}
```

**Alternative**: If signatures are too expensive, use commitment scheme:
- Include `block_hash` and `txn_hash` in messages
- Receiving shard verifies against expected block/transaction structure
- Provides binding without per-message signatures

## Proof of Concept

```rust
// PoC: Malicious Remote Executor Shard
use aptos_vm::sharded_block_executor::{
    cross_shard_client::CrossShardClient,
    messages::{CrossShardMsg, RemoteTxnWrite},
};
use aptos_types::{
    block_executor::partitioner::{RoundId, ShardId},
    state_store::state_key::StateKey,
    write_set::WriteOp,
};

pub struct MaliciousRemoteCrossShardClient {
    inner: RemoteCrossShardClient,
}

impl CrossShardClient for MaliciousRemoteCrossShardClient {
    fn send_cross_shard_msg(&self, shard_id: ShardId, round: RoundId, msg: CrossShardMsg) {
        // Intercept and modify message
        match msg {
            CrossShardMsg::RemoteTxnWriteMsg(txn_write) => {
                let (state_key, write_op) = txn_write.take();
                
                // ATTACK: Modify state value
                let malicious_write_op = if let Some(WriteOp::Modification(state_value)) = write_op {
                    // Inflate balance by 10x
                    let mut bytes = state_value.bytes().to_vec();
                    if bytes.len() >= 8 {
                        let balance = u64::from_le_bytes(bytes[0..8].try_into().unwrap());
                        let malicious_balance = balance.saturating_mul(10);
                        bytes[0..8].copy_from_slice(&malicious_balance.to_le_bytes());
                    }
                    Some(WriteOp::Modification(StateValue::from(bytes)))
                } else {
                    write_op
                };
                
                // Send malicious message - no validation prevents this!
                let malicious_msg = CrossShardMsg::RemoteTxnWriteMsg(
                    RemoteTxnWrite::new(state_key, malicious_write_op)
                );
                self.inner.send_cross_shard_msg(shard_id, round, malicious_msg);
            },
            _ => self.inner.send_cross_shard_msg(shard_id, round, msg),
        }
    }
    
    // Other trait methods delegated to inner...
}
```

**Test Scenario**:
1. Create block with sharded transactions
2. T1 in Shard 0: Transfer 100 tokens from Alice (balance becomes 900)
3. T2 in Shard 1: Depends on Alice's balance from T1
4. Use `MaliciousRemoteCrossShardClient` for Shard 0
5. Malicious shard sends balance=9000 instead of 900
6. T2 executes with incorrect state
7. Validator produces incorrect state root
8. Consensus rejects validator (or breaks if >1/3 affected)

**Notes**:
- The vulnerability exists because messages have no cryptographic binding to source transactions
- No validation mechanism prevents compromised shards from sending arbitrary values
- The trust model implicitly assumes all executor shards are equally trusted as the main validator
- Defense-in-depth principle violated: network authentication (Noise protocol) exists but content authenticity missing

### Citations

**File:** aptos-move/aptos-vm/src/sharded_block_executor/messages.rs (L13-18)
```rust
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct RemoteTxnWrite {
    state_key: StateKey,
    // The write op is None if the transaction is aborted.
    write_op: Option<WriteOp>,
}
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/cross_shard_client.rs (L26-45)
```rust
    pub fn start<S: StateView + Sync + Send>(
        cross_shard_state_view: Arc<CrossShardStateView<S>>,
        cross_shard_client: Arc<dyn CrossShardClient>,
        round: RoundId,
    ) {
        loop {
            let msg = cross_shard_client.receive_cross_shard_msg(round);
            match msg {
                RemoteTxnWriteMsg(txn_commit_msg) => {
                    let (state_key, write_op) = txn_commit_msg.take();
                    cross_shard_state_view
                        .set_value(&state_key, write_op.and_then(|w| w.as_state_value()));
                },
                CrossShardMsg::StopMsg => {
                    trace!("Cross shard commit receiver stopped for round {}", round);
                    break;
                },
            }
        }
    }
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/cross_shard_client.rs (L103-134)
```rust
    fn send_remote_update_for_success(
        &self,
        txn_idx: TxnIndex,
        txn_output: &OnceCell<TransactionOutput>,
    ) {
        let edges = self.dependent_edges.get(&txn_idx).unwrap();
        let write_set = txn_output
            .get()
            .expect("Committed output must be set")
            .write_set();

        for (state_key, write_op) in write_set.expect_write_op_iter() {
            if let Some(dependent_shard_ids) = edges.get(state_key) {
                for (dependent_shard_id, round_id) in dependent_shard_ids.iter() {
                    trace!("Sending remote update for success for shard id {:?} and txn_idx: {:?}, state_key: {:?}, dependent shard id: {:?}", self.shard_id, txn_idx, state_key, dependent_shard_id);
                    let message = RemoteTxnWriteMsg(RemoteTxnWrite::new(
                        state_key.clone(),
                        Some(write_op.clone()),
                    ));
                    if *round_id == GLOBAL_ROUND_ID {
                        self.cross_shard_client.send_global_msg(message);
                    } else {
                        self.cross_shard_client.send_cross_shard_msg(
                            *dependent_shard_id,
                            *round_id,
                            message,
                        );
                    }
                }
            }
        }
    }
```

**File:** execution/executor-service/src/remote_cross_shard_client.rs (L55-59)
```rust
    fn send_cross_shard_msg(&self, shard_id: ShardId, round: RoundId, msg: CrossShardMsg) {
        let input_message = bcs::to_bytes(&msg).unwrap();
        let tx = self.message_txs[shard_id][round].lock().unwrap();
        tx.send(Message::new(input_message)).unwrap();
    }
```
