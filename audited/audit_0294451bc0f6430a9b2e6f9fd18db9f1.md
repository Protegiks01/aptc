# Audit Report

## Title
Insufficient DKG Transcript Validation in Consensus Allows Epoch Transition DoS

## Summary
A malicious block proposer can inject cryptographically invalid DKG transcripts that pass consensus verification but fail during VM execution, causing epoch transitions to be blocked until governance intervention. The vulnerability exists because consensus performs only metadata validation without cryptographic verification of PVSS proofs.

## Finding Description

The DKG (Distributed Key Generation) result processing has a critical validation gap between consensus and execution layers that breaks the **Consensus Liveness** and **Deterministic Execution** invariants.

**Consensus Verification (Insufficient):** [1](#0-0) 

When validators receive a block proposal containing a `ValidatorTransaction::DKGResult`, they verify it using: [2](#0-1) 

This calls `verify_transcript_extra` which only performs metadata checks: [3](#0-2) 

**Critical Gap:** This verification checks dealer indices and voting power but does NOT cryptographically verify the PVSS (Publicly Verifiable Secret Sharing) proofs, encryption correctness, or dealt public key validity.

**VM Verification (Complete but Too Late):** [4](#0-3) 

The VM performs full cryptographic verification: [5](#0-4) 

If this verification fails, the transaction is discarded with ABORTED status: [6](#0-5) 

**Attack Scenario:**
1. Malicious validator becomes block proposer
2. Creates `ValidatorTransaction::DKGResult` with:
   - Valid dealer indices (claiming other validators as dealers)
   - Sufficient voting power (>= 2/3 threshold)
   - Cryptographically invalid PVSS data (random bytes, corrupted proofs)
3. Puts this in their local validator transaction pool
4. Includes it in their block proposal
5. Other validators verify with `vtxn.verify()` â†’ passes (only metadata checked)
6. Validators vote and commit the block
7. VM executes and cryptographic verification fails
8. Transaction is discarded, but DKG session remains in "in_progress" state [7](#0-6) 

9. Epoch transition is blocked because `finish_with_dkg_result` is never called [8](#0-7) 

10. System waits indefinitely or until governance calls `finish()` to clear the incomplete session: [9](#0-8) 

## Impact Explanation

**Critical Severity** - This qualifies as "Total loss of liveness/network availability" per Aptos bug bounty criteria:

- **Network-wide liveness failure**: Epoch transitions are completely blocked
- **Requires governance intervention**: Recovery requires passing and executing a governance proposal to call `finish()` and clear the incomplete DKG session
- **Governance delay**: Governance proposals have voting periods and execution delays, during which the network cannot progress epochs
- **Repeatable attack**: A malicious proposer can repeat this attack in subsequent blocks until their proposer slot ends
- **No automatic recovery**: There is no timeout mechanism; the system waits indefinitely for a valid DKG result

The attack breaks the fundamental liveness guarantee that the network will continue to make progress.

## Likelihood Explanation

**High Likelihood:**

- **Low barrier to entry**: Any single validator can execute this attack when selected as block proposer
- **No collusion required**: Does not require multiple validators to collude
- **No special privileges needed**: Only requires being in the validator set and being selected as proposer (happens regularly in round-robin)
- **Simple to execute**: The malicious validator only needs to bypass local aggregation and insert a crafted transcript
- **Difficult to attribute**: The attack appears as a "failed DKG verification" which could be attributed to various causes
- **Detection after commitment**: The issue is only detected after the block is committed, not before

## Recommendation

Add cryptographic verification to consensus-layer validation. Modify the `DKGTranscript::verify` method to perform full cryptographic verification before blocks are committed:

**Fix in `types/src/dkg/mod.rs`:**
```rust
pub(crate) fn verify(&self, verifier: &ValidatorVerifier) -> Result<()> {
    let transcripts: Transcripts = bcs::from_bytes(&self.transcript_bytes)
        .context("Transcripts deserialization failed")?;
    
    // Perform metadata checks
    RealDKG::verify_transcript_extra(&transcripts, verifier, true, None)?;
    
    // CRITICAL FIX: Add cryptographic verification in consensus
    // This requires access to DKG public parameters
    // Option 1: Fetch from on-chain config during verification
    // Option 2: Pass as parameter to verify()
    
    // For now, this requires architectural change to make pub_params available
    // at consensus verification time, not just VM execution time
    
    Ok(())
}
```

**Alternative approach:** Add a signature requirement where the DKG transcript must be signed by validators representing >= 2/3 voting power, verified during consensus.

**Immediate mitigation:** Implement a monitoring system to detect repeated DKG verification failures and automatically trigger governance proposals to clear incomplete sessions.

## Proof of Concept

```rust
// Theoretical PoC (cannot be fully executed without node modifications)
// This demonstrates the attack vector

use aptos_types::{
    dkg::{DKGTranscript, DKGTranscriptMetadata},
    validator_txn::ValidatorTransaction,
};
use move_core_types::account_address::AccountAddress;

// Malicious validator creates invalid transcript
fn create_malicious_dkg_transcript(
    epoch: u64,
    author: AccountAddress,
    validator_indices: Vec<usize>, // Valid indices with >= 2/3 power
) -> ValidatorTransaction {
    // Create transcript structure with valid dealer indices
    // but invalid cryptographic data (random bytes)
    let invalid_pvss_data = vec![0xFF; 1000]; // Random garbage
    
    ValidatorTransaction::DKGResult(DKGTranscript {
        metadata: DKGTranscriptMetadata {
            epoch,
            author,
        },
        transcript_bytes: invalid_pvss_data,
    })
}

// This transcript will:
// 1. Pass verify_transcript_extra() in consensus (checks only indices)
// 2. Fail verify_transcript() in VM (checks cryptographic validity)
// 3. Block epoch transition until governance intervenes
```

**Notes:**
- The vulnerability exists due to the architectural separation between consensus verification (metadata-only) and VM verification (full cryptographic)
- The root cause is that `verify_transcript_extra` does not validate that dealers actually contributed to the transcript or that the PVSS proofs are valid
- A single Byzantine validator can exploit this when selected as proposer, without requiring collusion or privileged access beyond normal validator operations
- Recovery requires governance action, introducing significant delay during which the network cannot transition epochs

### Citations

**File:** consensus/src/round_manager.rs (L1126-1136)
```rust
        if let Some(vtxns) = proposal.validator_txns() {
            for vtxn in vtxns {
                let vtxn_type_name = vtxn.type_name();
                ensure!(
                    is_vtxn_expected(&self.randomness_config, &self.jwk_consensus_config, vtxn),
                    "unexpected validator txn: {:?}",
                    vtxn_type_name
                );
                vtxn.verify(self.epoch_state.verifier.as_ref())
                    .context(format!("{} verify failed", vtxn_type_name))?;
            }
```

**File:** types/src/dkg/mod.rs (L83-87)
```rust
    pub(crate) fn verify(&self, verifier: &ValidatorVerifier) -> Result<()> {
        let transcripts: Transcripts = bcs::from_bytes(&self.transcript_bytes)
            .context("Transcripts deserialization failed")?;
        RealDKG::verify_transcript_extra(&transcripts, verifier, true, None)
    }
```

**File:** types/src/dkg/real_dkg/mod.rs (L295-329)
```rust
    fn verify_transcript_extra(
        trx: &Self::Transcript,
        verifier: &ValidatorVerifier,
        checks_voting_power: bool,
        ensures_single_dealer: Option<AccountAddress>,
    ) -> anyhow::Result<()> {
        let all_validator_addrs = verifier.get_ordered_account_addresses();
        let main_trx_dealers = trx.main.get_dealers();
        let mut dealer_set = HashSet::with_capacity(main_trx_dealers.len());
        for dealer in main_trx_dealers.iter() {
            if let Some(dealer_addr) = all_validator_addrs.get(dealer.id) {
                dealer_set.insert(*dealer_addr);
            } else {
                bail!("invalid dealer idx");
            }
        }
        ensure!(main_trx_dealers.len() == dealer_set.len());
        if ensures_single_dealer.is_some() {
            let expected_dealer_set: HashSet<AccountAddress> =
                ensures_single_dealer.into_iter().collect();
            ensure!(expected_dealer_set == dealer_set);
        }

        if checks_voting_power {
            verifier
                .check_voting_power(dealer_set.iter(), true)
                .context("not enough power")?;
        }

        if let Some(fast_trx) = &trx.fast {
            ensure!(fast_trx.get_dealers() == main_trx_dealers);
            ensure!(trx.main.get_dealt_public_key() == fast_trx.get_dealt_public_key());
        }
        Ok(())
    }
```

**File:** types/src/dkg/real_dkg/mod.rs (L332-374)
```rust
    fn verify_transcript(
        params: &Self::PublicParams,
        trx: &Self::Transcript,
    ) -> anyhow::Result<()> {
        // Verify dealer indices are valid.
        let dealers = trx
            .main
            .get_dealers()
            .iter()
            .map(|player| player.id)
            .collect::<Vec<usize>>();
        let num_validators = params.session_metadata.dealer_validator_set.len();
        ensure!(
            dealers.iter().all(|id| *id < num_validators),
            "real_dkg::verify_transcript failed with invalid dealer index."
        );

        let all_eks = params.pvss_config.eks.clone();

        let addresses = params.verifier.get_ordered_account_addresses();
        let dealers_addresses = dealers
            .iter()
            .filter_map(|&pos| addresses.get(pos))
            .cloned()
            .collect::<Vec<_>>();

        let spks = dealers_addresses
            .iter()
            .filter_map(|author| params.verifier.get_public_key(author))
            .collect::<Vec<_>>();

        let aux = dealers_addresses
            .iter()
            .map(|address| (params.pvss_config.epoch, address))
            .collect::<Vec<_>>();

        trx.main.verify(
            &params.pvss_config.wconfig,
            &params.pvss_config.pp,
            &spks,
            &all_eks,
            &aux,
        )?;
```

**File:** aptos-move/aptos-vm/src/validator_txns/dkg.rs (L68-77)
```rust
            Err(Expected(failure)) => {
                // Pretend we are inside Move, and expected failures are like Move aborts.
                Ok((
                    VMStatus::MoveAbort {
                        location: AbortLocation::Script,
                        code: failure as u64,
                        message: None,
                    },
                    VMOutput::empty_with_status(TransactionStatus::Discard(StatusCode::ABORTED)),
                ))
```

**File:** aptos-move/aptos-vm/src/validator_txns/dkg.rs (L111-112)
```rust
        DefaultDKG::verify_transcript(&pub_params, &transcript)
            .map_err(|_| Expected(TranscriptVerificationFailed))?;
```

**File:** aptos-move/framework/aptos-framework/sources/dkg.move (L90-97)
```text
    public(friend) fun finish(transcript: vector<u8>) acquires DKGState {
        let dkg_state = borrow_global_mut<DKGState>(@aptos_framework);
        assert!(option::is_some(&dkg_state.in_progress), error::invalid_state(EDKG_NOT_IN_PROGRESS));
        let session = option::extract(&mut dkg_state.in_progress);
        session.transcript = transcript;
        dkg_state.last_completed = option::some(session);
        dkg_state.in_progress = option::none();
    }
```

**File:** aptos-move/framework/aptos-framework/sources/reconfiguration_with_dkg.move (L46-61)
```text
    public(friend) fun finish(framework: &signer) {
        system_addresses::assert_aptos_framework(framework);
        dkg::try_clear_incomplete_session(framework);
        consensus_config::on_new_epoch(framework);
        execution_config::on_new_epoch(framework);
        gas_schedule::on_new_epoch(framework);
        std::version::on_new_epoch(framework);
        features::on_new_epoch(framework);
        jwk_consensus_config::on_new_epoch(framework);
        jwks::on_new_epoch(framework);
        keyless_account::on_new_epoch(framework);
        randomness_config_seqnum::on_new_epoch(framework);
        randomness_config::on_new_epoch(framework);
        randomness_api_v0_config::on_new_epoch(framework);
        reconfiguration::reconfigure();
    }
```

**File:** aptos-move/framework/aptos-framework/sources/reconfiguration_with_dkg.move (L65-68)
```text
    fun finish_with_dkg_result(account: &signer, dkg_result: vector<u8>) {
        dkg::finish(dkg_result);
        finish(account);
    }
```
