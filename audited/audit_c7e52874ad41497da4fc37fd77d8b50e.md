# Audit Report

## Title
Faucet Returns Transactions with Discontinuous Sequence Numbers Causing Validation Failures

## Summary
The Aptos faucet service can return signed transactions with sequence numbers that are ahead of the faucet account's on-chain sequence number when processing concurrent requests. These transactions will fail validation with `PROLOGUE_ESEQUENCE_NUMBER_TOO_NEW` (error code 1003) when submitted to the blockchain, breaking the transaction validation invariant.

## Finding Description
The vulnerability exists in the faucet's transaction creation flow. When multiple concurrent requests arrive at the faucet (e.g., via the `/mint` endpoint with `return_txns=true`), the sequence number management allows up to 15 transactions to be created simultaneously with sequential sequence numbers, even though the blockchain has not yet processed earlier transactions.

**Root Cause:**

The faucet's `update_sequence_numbers` function allows multiple concurrent requests to proceed as long as the check `our_funder_seq < funder_seq + MAX_NUM_OUTSTANDING_TRANSACTIONS` passes, where `MAX_NUM_OUTSTANDING_TRANSACTIONS = 15`. [1](#0-0) 

Each concurrent request then signs a transaction using `LocalAccount::sign_with_transaction_builder`, which atomically increments the local sequence number using `fetch_add(1, Ordering::SeqCst)`. [2](#0-1) 

The critical issue is that the queue mechanism only enforces ordering for requests with identical `(receiver_address, amount)` pairs. Different receiver addresses or amounts bypass the queue and can proceed concurrently. [3](#0-2) 

**Attack Scenario:**

1. Faucet account on-chain sequence number: 10
2. User A requests `create_account(address_A)` - gets local seq 10, signs transaction with seq 10
3. User B immediately requests `create_account(address_B)` - gets local seq 11, signs transaction with seq 11
4. User B receives the signed transaction via `txns[0]` at line 76 of `faucet.rs` [4](#0-3) 
5. User B's client calls `wait_for_signed_transaction` which waits for the transaction to be confirmed
6. When User B's transaction reaches a validator for validation, the blockchain sequence number is still 10 (User A's transaction hasn't been processed yet)
7. The transaction prologue validates sequence numbers and fails the assertion `txn_sequence_number == account_sequence_number` [5](#0-4) 
8. The transaction is rejected with error code `PROLOGUE_ESEQUENCE_NUMBER_TOO_NEW` (1003) [6](#0-5) 

## Impact Explanation
This vulnerability meets **Medium Severity** criteria per the Aptos bug bounty program:
- Causes transaction validation failures requiring user intervention
- Creates state inconsistencies where transactions are signed but cannot be executed
- Results in poor user experience with failed transactions
- Can be exploited as a denial-of-service vector against faucet users

While no funds are directly lost, users receive transactions that will never succeed, potentially causing their applications to hang indefinitely waiting for confirmation. This breaks the Transaction Validation invariant that requires transactions to be properly validated before execution.

## Likelihood Explanation
**High Likelihood:**
- Trivially exploitable with just 2+ concurrent requests to different addresses
- No special privileges required - any user can trigger this
- Occurs naturally under normal concurrent load without malicious intent
- The faucet explicitly allows up to 15 concurrent transactions by design
- Common in production environments where multiple users request funds simultaneously

## Recommendation
Implement proper serialization of all transaction creation, regardless of receiver address:

1. **Option 1: Strict Sequential Processing**
   - Modify the queue mechanism to enforce global FIFO ordering for all requests, not just those with matching `(receiver_address, amount)`
   - Remove the per-request-key queue and use a single global queue per asset

2. **Option 2: Wait for Transaction Confirmation**
   - Set `wait_for_transactions = true` in the transaction submission config
   - Only return transactions to clients after they've been confirmed on-chain
   - This ensures the on-chain sequence number advances before the next transaction is created

3. **Option 3: Sequence Number Synchronization**
   - Before signing each transaction, re-fetch the on-chain sequence number
   - Only proceed if `local_seq == onchain_seq`
   - This prevents creating transactions with future sequence numbers

**Recommended Fix (Option 1):**
Modify `update_sequence_numbers` to use a global queue: [7](#0-6) 

Change the queue to not be keyed by `(receiver_address, amount)` but instead maintain insertion order for all requests regardless of parameters.

## Proof of Concept

```rust
// Rust test demonstrating the vulnerability
#[tokio::test]
async fn test_concurrent_faucet_sequence_number_gap() {
    // Setup faucet with initial sequence number 10
    let faucet_account = LocalAccount::new(/* ... */, 10);
    
    // Simulate two concurrent requests
    let handle1 = tokio::spawn(async {
        // Request A: create_account(address_A)
        let txn_a = faucet.process(/* address_A */).await.unwrap();
        assert_eq!(txn_a.sequence_number(), 10);
    });
    
    let handle2 = tokio::spawn(async {
        // Request B: create_account(address_B) - different address
        let txn_b = faucet.process(/* address_B */).await.unwrap();
        assert_eq!(txn_b.sequence_number(), 11);
    });
    
    handle1.await.unwrap();
    handle2.await.unwrap();
    
    // Transaction B will be returned to client but will fail validation
    // when submitted to blockchain with on-chain seq still at 10
    let result = client.submit(&txn_b).await;
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("PROLOGUE_ESEQUENCE_NUMBER_TOO_NEW"));
}
```

**Notes**

This vulnerability is particularly insidious because:
1. The faucet's queue mechanism appears to provide ordering guarantees, but only for identical requests
2. The atomic sequence number operations in `LocalAccount` seem safe, but they operate on local state that can diverge from blockchain state
3. The `MAX_NUM_OUTSTANDING_TRANSACTIONS` limit of 15 means up to 14 transactions can be created with invalid sequence numbers in a single burst
4. The issue manifests as client-side failures rather than server-side errors, making it harder to detect and debug

The vulnerability is confirmed by examining the transaction validation logic in the Move framework, which strictly requires exact sequence number matching with no tolerance for gaps.

### Citations

**File:** crates/aptos-faucet/core/src/funder/common.rs (L39-39)
```rust
const MAX_NUM_OUTSTANDING_TRANSACTIONS: u64 = 15;
```

**File:** crates/aptos-faucet/core/src/funder/common.rs (L228-229)
```rust
    let mut set_outstanding = false;
    let request_key = (receiver_address, amount);
```

**File:** crates/aptos-faucet/core/src/funder/common.rs (L236-243)
```rust
            if !set_outstanding {
                let mut requests_map = outstanding_requests.write().await;
                let queue = requests_map
                    .entry(asset_name.to_string())
                    .or_insert_with(Vec::new);
                queue.push(request_key);
                set_outstanding = true;
            }
```

**File:** sdk/src/types.rs (L546-548)
```rust
    pub fn increment_sequence_number(&self) -> u64 {
        self.sequence_number.fetch_add(1, Ordering::SeqCst)
    }
```

**File:** crates/aptos-rest-client/src/faucet.rs (L75-77)
```rust
        self.rest_client
            .wait_for_signed_transaction(&txns[0])
            .await
```

**File:** aptos-move/framework/aptos-framework/sources/transaction_validation.move (L64-64)
```text
    const PROLOGUE_ESEQUENCE_NUMBER_TOO_NEW: u64 = 1003;
```

**File:** aptos-move/framework/aptos-framework/sources/transaction_validation.move (L238-241)
```text
            assert!(
                txn_sequence_number == account_sequence_number,
                error::invalid_argument(PROLOGUE_ESEQUENCE_NUMBER_TOO_NEW)
            );
```
