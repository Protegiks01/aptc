# Audit Report

## Title
Connection Metadata Validation Bypass Enables DoS on Validator VFN Networks

## Summary
The `handle_completed_inbound_upgrade()` function forwards inbound connections to PeerManager without verifying that assigned peer roles match the trusted peers configuration. On VFN networks running in `MaybeMutual` authentication mode, untrusted attackers who gain network access to the VFN endpoint are automatically assigned `PeerRole::ValidatorFullNode`, bypassing connection limits and enabling resource exhaustion DoS attacks against validators.

## Finding Description

The vulnerability exists in how the network stack handles inbound connections on the Validator Full Node (VFN) network when mutual authentication is disabled (`MaybeMutual` mode). [1](#0-0) 

The VFN network defaults to `mutual_authentication = false` because `is_validator_network()` only returns true for `NetworkId::Validator`, not `NetworkId::Vfn`. This causes VFN networks to run in `MaybeMutual` mode. [2](#0-1) 

In `MaybeMutual` mode, when a peer NOT in the trusted peers set connects to a validator's VFN network, the Noise handshake automatically assigns `PeerRole::ValidatorFullNode` based solely on network context, without any authentication. The comment at line 409 reveals the flawed assumption: "Inbound connections to validators on the VFN network must be VFNs." [3](#0-2) 

The `handle_completed_inbound_upgrade()` function forwards these connections without any verification of whether the assigned role matches reality. Compare this to the outbound handler which performs validation: [4](#0-3) [5](#0-4) 

PeerManager's connection limit enforcement explicitly bypasses limits for any peer with a non-`Unknown` role, treating them as trusted. The comment states: "if it's not `Unknown` then it is trusted." [6](#0-5) 

These incorrectly-roled connections are explicitly preserved by the connectivity manager and never closed as stale.

**Attack Path:**
1. Attacker gains network access to validator's VFN endpoint (via misconfiguration, cloud security group error, compromised VFN node as pivot, or network-level attack)
2. Attacker generates x25519 keypair and initiates connection
3. Noise handshake completes (peer_id is correctly derived from attacker's public key)
4. System assigns `PeerRole::ValidatorFullNode` without checking trusted peers
5. Connection forwarded to PeerManager without validation
6. PeerManager bypasses connection limits (role ≠ Unknown)
7. Connection is never closed as stale
8. Attacker repeats with different keypairs to create unlimited connections
9. Validator's connection resources exhausted → DoS

## Impact Explanation

This is **High Severity** per the Aptos bug bounty program: "Validator node slowdowns" through resource exhaustion.

The vulnerability enables an attacker to bypass connection limits and create an unlimited number of connections to a validator's VFN network, exhausting:
- Connection table entries
- File descriptors
- Memory for connection state
- CPU cycles for connection management
- Network bandwidth

This can degrade validator performance or cause complete DoS, impacting consensus participation and network liveness. Given that Aptos validators secure billions of dollars in assets, even temporary validator unavailability has severe consequences.

## Likelihood Explanation

**Likelihood: Medium**

**Prerequisites:**
- Attacker must gain network access to the VFN endpoint (normally private)
- VFN network must be running (standard validator configuration)

**Realistic Scenarios:**
1. **Cloud Misconfiguration**: Security groups or firewall rules accidentally expose VFN ports (common operational error)
2. **Compromised VFN Node**: Attacker compromises a legitimate VFN and uses it as pivot point
3. **Network-Level Attacks**: BGP hijacking or routing table manipulation to reach private endpoints
4. **Insider Threat**: Malicious VFN operator or cloud provider employee

While the VFN network is intended to be private, the defense-in-depth principle requires that application-level security not rely solely on network isolation. Given the high value of validator nodes, even low-probability network exposure creates unacceptable risk.

## Recommendation

Add explicit verification in `handle_completed_inbound_upgrade()` to check that inbound connections on VFN networks with `PeerRole::ValidatorFullNode` are actually in the trusted peers set:

```rust
async fn handle_completed_inbound_upgrade(
    &mut self,
    upgrade: Result<Connection<TSocket>, TTransport::Error>,
    addr: NetworkAddress,
    start_time: Instant,
) {
    counters::pending_connection_upgrades(&self.network_context, ConnectionOrigin::Inbound)
        .dec();

    let elapsed_time = (self.time_service.now() - start_time).as_secs_f64();
    match upgrade {
        Ok(connection) => {
            // SECURITY FIX: Verify ValidatorFullNode role for VFN networks
            if self.network_context.network_id().is_vfn_network() 
                && connection.metadata.role == PeerRole::ValidatorFullNode {
                // Get trusted peers and verify this peer is actually trusted
                if let Ok(trusted_peers) = self.peers_and_metadata.get_trusted_peers(
                    &self.network_context.network_id()
                ) {
                    if !trusted_peers.contains_key(&connection.metadata.remote_peer_id) {
                        warn!(
                            NetworkSchema::new(&self.network_context)
                                .connection_metadata_with_address(&connection.metadata),
                            "Rejecting untrusted inbound connection claiming to be ValidatorFullNode on VFN network"
                        );
                        counters::connection_upgrade_time(
                            &self.network_context,
                            ConnectionOrigin::Inbound,
                            FAILED_LABEL,
                        )
                        .observe(elapsed_time);
                        return;
                    }
                }
            }
            
            self.send_connection_to_peer_manager(connection, &addr, elapsed_time)
                .await;
        },
        // ... rest of error handling
    }
}
```

Alternatively, fix the root cause in the Noise handshake by not auto-assigning `ValidatorFullNode` to untrusted peers, or enforce `mutual_authentication = true` for VFN networks.

## Proof of Concept

```rust
// Rust integration test demonstrating the vulnerability
#[tokio::test]
async fn test_vfn_network_connection_limit_bypass() {
    use aptos_config::network_id::NetworkId;
    use aptos_crypto::{x25519, Uniform};
    use aptos_types::PeerId;
    
    // Setup: Validator with VFN network in MaybeMutual mode (default)
    let validator_key = x25519::PrivateKey::generate_for_testing();
    let validator_peer_id = PeerId::random();
    
    // Create VFN network with mutual_authentication=false (default per network_config.rs:136)
    let network_config = NetworkConfig::network_with_id(NetworkId::Vfn);
    assert_eq!(network_config.mutual_authentication, false);
    
    // Attacker: Generate multiple keypairs to bypass connection limits
    let max_inbound_connections = 100; // Default limit
    let attack_connections = max_inbound_connections + 50; // Exceed limit
    
    let mut successful_connections = 0;
    for _ in 0..attack_connections {
        // Each attacker connection uses different keypair
        let attacker_key = x25519::PrivateKey::generate_for_testing();
        let attacker_peer_id = aptos_types::account_address::from_identity_public_key(
            attacker_key.public_key()
        );
        
        // Attacker connects to VFN endpoint (assumes network access gained)
        // Noise handshake will assign PeerRole::ValidatorFullNode
        // (see handshake.rs:407-410)
        
        // Connection forwarded without verification (transport.rs:306-308)
        // PeerManager accepts it, bypassing limits (peer_manager/mod.rs:355)
        
        successful_connections += 1;
    }
    
    // VULNERABILITY: All connections succeed, exceeding connection limit
    assert!(successful_connections > max_inbound_connections);
    println!("Successfully created {} connections, exceeding limit of {}", 
             successful_connections, max_inbound_connections);
    
    // Impact: Validator resources exhausted, DoS condition achieved
}
```

**Notes:**
- The vulnerability requires network-level access to the VFN endpoint, which is normally private but can be exposed through misconfigurations
- The attack exploits the assumption that "Inbound connections to validators on the VFN network must be VFNs" without enforcing this invariant
- Defense-in-depth principles require application-level validation even when network isolation is intended
- The sanitizer only enforces mutual authentication for the validator network, not the VFN network

### Citations

**File:** config/src/config/network_config.rs (L135-136)
```rust
    pub fn network_with_id(network_id: NetworkId) -> NetworkConfig {
        let mutual_authentication = network_id.is_validator_network();
```

**File:** network/framework/src/noise/handshake.rs (L384-427)
```rust
            HandshakeAuthMode::MaybeMutual(peers_and_metadata) => {
                let trusted_peers = peers_and_metadata.get_trusted_peers(&network_id)?;
                let trusted_peer = trusted_peers.get(&remote_peer_id).cloned();
                match trusted_peer {
                    Some(peer) => {
                        Self::authenticate_inbound(remote_peer_short, &peer, &remote_public_key)
                    },
                    None => {
                        // The peer is not in the trusted peer set. Verify that the Peer ID is
                        // constructed correctly from the public key.
                        let derived_remote_peer_id =
                            aptos_types::account_address::from_identity_public_key(
                                remote_public_key,
                            );
                        if derived_remote_peer_id != remote_peer_id {
                            // The peer ID is not constructed correctly from the public key
                            Err(NoiseHandshakeError::ClientPeerIdMismatch(
                                remote_peer_short,
                                remote_peer_id,
                                derived_remote_peer_id,
                            ))
                        } else {
                            // Try to infer the role from the network context
                            if self.network_context.role().is_validator() {
                                if network_id.is_vfn_network() {
                                    // Inbound connections to validators on the VFN network must be VFNs
                                    Ok(PeerRole::ValidatorFullNode)
                                } else {
                                    // Otherwise, they're unknown. Validators will connect through
                                    // authenticated channels (on the validator network) so shouldn't hit
                                    // this, and PFNs will connect on public networks (which aren't common).
                                    Ok(PeerRole::Unknown)
                                }
                            } else {
                                // We're a VFN or PFN. VFNs get no inbound connections on the vfn network
                                // (so the peer won't be a validator). Thus, we're on the public network
                                // so mark the peer as unknown.
                                Ok(PeerRole::Unknown)
                            }
                        }
                    },
                }
            },
        }?;
```

**File:** network/framework/src/peer_manager/transport.rs (L234-250)
```rust
        // Ensure that the connection matches the expected `PeerId`
        let elapsed_time = (self.time_service.now() - start_time).as_secs_f64();
        let upgrade = match upgrade {
            Ok(connection) => {
                let dialed_peer_id = connection.metadata.remote_peer_id;
                if dialed_peer_id == peer_id {
                    Ok(connection)
                } else {
                    Err(PeerManagerError::from_transport_error(format_err!(
                        "Dialed PeerId '{}' differs from expected PeerId '{}'",
                        dialed_peer_id.short_str(),
                        peer_id.short_str()
                    )))
                }
            },
            Err(err) => Err(PeerManagerError::from_transport_error(err)),
        };
```

**File:** network/framework/src/peer_manager/transport.rs (L294-308)
```rust
    async fn handle_completed_inbound_upgrade(
        &mut self,
        upgrade: Result<Connection<TSocket>, TTransport::Error>,
        addr: NetworkAddress,
        start_time: Instant,
    ) {
        counters::pending_connection_upgrades(&self.network_context, ConnectionOrigin::Inbound)
            .dec();

        let elapsed_time = (self.time_service.now() - start_time).as_secs_f64();
        match upgrade {
            Ok(connection) => {
                self.send_connection_to_peer_manager(connection, &addr, elapsed_time)
                    .await;
            },
```

**File:** network/framework/src/peer_manager/mod.rs (L352-390)
```rust
        if conn.metadata.origin == ConnectionOrigin::Inbound {
            // Everything below here is meant for unknown peers only. The role comes from
            // the Noise handshake and if it's not `Unknown` then it is trusted.
            if conn.metadata.role == PeerRole::Unknown {
                // TODO: Keep track of somewhere else to not take this hit in case of DDoS
                // Count unknown inbound connections
                let unknown_inbound_conns = self
                    .active_peers
                    .iter()
                    .filter(|(peer_id, (metadata, _))| {
                        metadata.origin == ConnectionOrigin::Inbound
                            && trusted_peers
                                .get(peer_id)
                                .is_none_or(|peer| peer.role == PeerRole::Unknown)
                    })
                    .count();

                // Reject excessive inbound connections made by unknown peers
                // We control outbound connections with Connectivity manager before we even send them
                // and we must allow connections that already exist to pass through tie breaking.
                if !self
                    .active_peers
                    .contains_key(&conn.metadata.remote_peer_id)
                    && unknown_inbound_conns + 1 > self.inbound_connection_limit
                {
                    info!(
                        NetworkSchema::new(&self.network_context)
                            .connection_metadata_with_address(&conn.metadata),
                        "{} Connection rejected due to connection limit: {}",
                        self.network_context,
                        conn.metadata
                    );
                    counters::connections_rejected(&self.network_context, conn.metadata.origin)
                        .inc();
                    self.disconnect(conn);
                    return;
                }
            }
        }
```

**File:** network/framework/src/connectivity_manager/mod.rs (L484-503)
```rust
    async fn close_stale_connections(&mut self) {
        if let Some(trusted_peers) = self.get_trusted_peers() {
            // Identify stale peer connections
            let stale_peers = self
                .connected
                .iter()
                .filter(|(peer_id, _)| !trusted_peers.contains_key(peer_id))
                .filter_map(|(peer_id, metadata)| {
                    // If we're using server only auth, we need to not evict unknown peers
                    // TODO: We should prevent `Unknown` from discovery sources
                    if !self.mutual_authentication
                        && metadata.origin == ConnectionOrigin::Inbound
                        && (metadata.role == PeerRole::ValidatorFullNode
                            || metadata.role == PeerRole::Unknown)
                    {
                        None
                    } else {
                        Some(*peer_id) // The peer is stale
                    }
                });
```
