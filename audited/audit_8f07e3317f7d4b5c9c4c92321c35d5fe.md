# Audit Report

## Title
Consensus Observer Liveness Failure When Execution Pool is Enabled - Missing OrderedBlockWithWindow Implementation

## Summary
The consensus observer system contains a critical incomplete implementation that causes all consensus observers to fail when the execution pool feature is enabled via on-chain governance. Publishers send `OrderedBlock` messages without execution pool window data, but observers configured with execution pool enabled reject these messages, causing complete loss of observer liveness.

## Finding Description

The vulnerability exists in the interaction between three components:

1. **Message Publishing**: The buffer manager publishes ordered blocks to observers using `new_ordered_block_message()` which creates `OrderedBlock` messages without execution pool window information. [1](#0-0) 

2. **Observer Configuration**: Consensus observers read the execution pool window size from the on-chain consensus configuration, which is globally applied across all validators and observers. [2](#0-1) 

3. **Message Rejection**: When execution pool is enabled (`window_size.is_some()`), observers explicitly **reject** `OrderedBlock` messages and expect `OrderedBlockWithWindow` messages instead. [3](#0-2) 

4. **Missing Implementation**: The processing logic for `OrderedBlockWithWindow` messages is incomplete and simply drops the messages with a TODO comment. [4](#0-3) 

Additionally, even if blocks contain `OrderedBlockWindow` internally, the `PipelinedBlock` serialization explicitly excludes the `block_window` field, so dependency information is lost during network transmission. [5](#0-4) 

**Attack Scenario:**
1. Network governance passes a proposal to enable execution pool (sets `window_size = Some(1)` in on-chain consensus config)
2. All validators and observers receive the updated configuration and enable execution pool
3. Validator nodes continue publishing `OrderedBlock` messages via `new_ordered_block_message()`
4. **All consensus observers reject these messages** as invalid because they expect `OrderedBlockWithWindow` when execution pool is enabled
5. Observers cannot sync, repeatedly fall back to state sync, and become unable to serve as read-only consensus participants

## Impact Explanation

**Severity: High** (up to $50,000 per bug bounty criteria)

This vulnerability causes **total loss of consensus observer liveness** when execution pool is enabled:

- **Scope**: Affects ALL consensus observer nodes network-wide
- **Type**: Availability/Liveness failure - observers cannot sync or provide consensus services
- **Duration**: Permanent until execution pool is disabled or proper implementation is deployed
- **Invariant Broken**: Network availability for observer nodes (critical for read scalability)

While this doesn't affect validator consensus directly, it represents a "Significant protocol violation" and could cause "API crashes" if observer-dependent services rely on the affected nodes, meeting the High severity criteria.

The issue doesn't reach Critical severity because:
- Validator consensus continues to function
- No funds are at risk
- No permanent state corruption occurs
- Can be recovered by disabling execution pool via governance

## Likelihood Explanation

**Likelihood: Medium-High**

The vulnerability is **currently latent** because:
- The default execution pool configuration is `None` (disabled) [6](#0-5) 

However, it becomes **immediately exploitable** if:
1. Governance enables execution pool before implementing `OrderedBlockWithWindow` support
2. No additional validator privileges or sophisticated attacks are required
3. The feature can be enabled through standard governance proposals
4. The incomplete implementation is already merged into the codebase

The likelihood increases if:
- There are plans to enable execution pool for performance improvements
- Governance proposals don't adequately validate feature completeness
- The TODO comment at line 895 is not addressed before enabling the feature

## Recommendation

**Immediate Actions:**
1. Complete the `OrderedBlockWithWindow` implementation before enabling execution pool in production
2. Add on-chain feature flag validation to prevent enabling execution pool until the implementation is complete
3. Implement proper window serialization in `PipelinedBlock` or create a separate transmission mechanism

**Code Fix:**

The buffer manager should send `OrderedBlockWithWindow` when execution pool is enabled:

```rust
// In buffer_manager.rs, replace lines 400-406:
if let Some(consensus_publisher) = &self.consensus_publisher {
    let message = if window_size.is_some() {
        // Create ExecutionPoolWindow from ordered_blocks
        let block_ids: Vec<HashValue> = ordered_blocks
            .iter()
            .map(|b| b.id())
            .collect();
        let execution_pool_window = ExecutionPoolWindow::new(block_ids);
        let ordered_block = OrderedBlock::new(ordered_blocks.clone(), ordered_proof.clone());
        let ordered_block_with_window = OrderedBlockWithWindow::new(ordered_block, execution_pool_window);
        ConsensusObserverDirectSend::OrderedBlockWithWindow(ordered_block_with_window)
    } else {
        ConsensusObserverMessage::new_ordered_block_message(
            ordered_blocks.clone(),
            ordered_proof.clone(),
        )
    };
    consensus_publisher.publish_message(message);
}
```

And complete the processing logic in `process_ordered_block_with_window_message()`: [7](#0-6) 

## Proof of Concept

While a full PoC requires a multi-node testnet setup, the vulnerability can be demonstrated with the following steps:

**Setup:**
1. Deploy testnet with consensus observers
2. Enable execution pool via governance proposal:
```move
// Governance proposal to update consensus config
aptos_governance::update_consensus_config(
    &framework_signer,
    new_config_with_window_size_enabled()
);
```

**Exploit Steps:**
1. Wait for epoch change to apply new config
2. Observer nodes update `execution_pool_window_size` from on-chain config
3. Validator publishes ordered blocks via `new_ordered_block_message()`
4. Observer receives message and executes check at consensus_observer.rs:646
5. Observer rejects message with: "Received ordered block message but execution pool is enabled!"
6. Observer cannot sync and enters fallback mode
7. Repeat for all ordered block messages - observer remains unable to sync

**Expected Result:** All consensus observers become unavailable and cannot provide read services.

**Verification:** Check observer logs for repeated warnings about rejected `OrderedBlock` messages when execution pool is enabled.

---

**Notes:**
This vulnerability represents incomplete feature implementation that becomes exploitable when the feature is enabled via governance. The system should either complete the implementation or add safeguards to prevent enabling execution pool until `OrderedBlockWithWindow` support is fully functional.

### Citations

**File:** consensus/src/pipeline/buffer_manager.rs (L400-406)
```rust
        if let Some(consensus_publisher) = &self.consensus_publisher {
            let message = ConsensusObserverMessage::new_ordered_block_message(
                ordered_blocks.clone(),
                ordered_proof.clone(),
            );
            consensus_publisher.publish_message(message);
        }
```

**File:** consensus/src/consensus_observer/observer/epoch_state.rs (L100-107)
```rust
        self.epoch_state = Some(epoch_state.clone());
        self.execution_pool_window_size = consensus_config.window_size();
        self.quorum_store_enabled = consensus_config.quorum_store_enabled();
        info!(
            LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                "New epoch started: {:?}. Execution pool window: {:?}. Quorum store enabled: {:?}",
                epoch_state.epoch, self.execution_pool_window_size, self.quorum_store_enabled,
            ))
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L646-656)
```rust
        if self.get_execution_pool_window_size().is_some() {
            // Log the failure and update the invalid message counter
            warn!(
                LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                    "Received ordered block message from peer: {:?}, but execution pool is enabled! Ignoring: {:?}",
                    peer_network_id, ordered_block.proof_block_info()
                ))
            );
            increment_invalid_message_counter(&peer_network_id, metrics::ORDERED_BLOCK_LABEL);
            return;
        }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L804-896)
```rust
    async fn process_ordered_block_with_window_message(
        &mut self,
        peer_network_id: PeerNetworkId,
        _message_received_time: Instant,
        ordered_block_with_window: OrderedBlockWithWindow,
    ) {
        // If execution pool is disabled, ignore the message
        let execution_pool_window_size = match self.get_execution_pool_window_size() {
            Some(window_size) => window_size,
            None => {
                // Log the failure and update the invalid message counter
                warn!(
                    LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                        "Received ordered block with window message from peer: {:?}, but execution pool is disabled! Ignoring: {:?}",
                        peer_network_id,
                        ordered_block_with_window.ordered_block().proof_block_info()
                    ))
                );
                increment_invalid_message_counter(
                    &peer_network_id,
                    metrics::ORDERED_BLOCK_WITH_WINDOW_LABEL,
                );
                return;
            },
        };

        // Verify the ordered blocks before processing
        let ordered_block = ordered_block_with_window.ordered_block();
        if let Err(error) = ordered_block.verify_ordered_blocks() {
            // Log the error and update the invalid message counter
            error!(
                LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                    "Failed to verify ordered block with window! Ignoring: {:?}, from peer: {:?}. Error: {:?}",
                    ordered_block.proof_block_info(),
                    peer_network_id,
                    error
                ))
            );
            increment_invalid_message_counter(
                &peer_network_id,
                metrics::ORDERED_BLOCK_WITH_WINDOW_LABEL,
            );
            return;
        };

        // Verify the execution pool window contents
        let execution_pool_window = ordered_block_with_window.execution_pool_window();
        if let Err(error) = execution_pool_window.verify_window_contents(execution_pool_window_size)
        {
            // Log the error and update the invalid message counter
            error!(
                LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                    "Failed to verify execution pool window contents! Ignoring: {:?}, from peer: {:?}. Error: {:?}",
                    ordered_block.proof_block_info(),
                    peer_network_id,
                    error
                ))
            );
            increment_invalid_message_counter(
                &peer_network_id,
                metrics::ORDERED_BLOCK_WITH_WINDOW_LABEL,
            );
            return;
        };

        // Get the epoch and round of the first block
        let first_block = ordered_block.first_block();
        let first_block_epoch_round = (first_block.epoch(), first_block.round());

        // Determine if the block is behind the last ordered block, or if it is already pending
        let last_ordered_block = self.observer_block_data.lock().get_last_ordered_block();
        let block_out_of_date =
            first_block_epoch_round <= (last_ordered_block.epoch(), last_ordered_block.round());
        let block_pending = self
            .observer_block_data
            .lock()
            .existing_pending_block(ordered_block);

        // If the block is out of date or already pending, ignore it
        if block_out_of_date || block_pending {
            // Update the metrics for the dropped ordered block with window
            update_metrics_for_dropped_ordered_block_with_window_message(
                peer_network_id,
                ordered_block,
            );
            return;
        }

        // Update the metrics for the received ordered block with window
        update_metrics_for_ordered_block_with_window_message(peer_network_id, ordered_block);

        // TODO: process the ordered block with window message (instead of just dropping it!)
    }
```

**File:** consensus/consensus-types/src/pipelined_block.rs (L228-247)
```rust
impl Serialize for PipelinedBlock {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        #[derive(Serialize)]
        #[serde(rename = "PipelineBlock")]
        struct SerializedBlock<'a> {
            block: &'a Block,
            input_transactions: &'a Vec<SignedTransaction>,
            randomness: Option<&'a Randomness>,
        }

        let serialized = SerializedBlock {
            block: &self.block,
            input_transactions: &self.input_transactions,
            randomness: self.randomness.get(),
        };
        serialized.serialize(serializer)
    }
```

**File:** types/src/on_chain_config/consensus_config.rs (L10-13)
```rust
/// Default Window Size for Execution Pool.
/// This describes the number of blocks in the Execution Pool Window
pub const DEFAULT_WINDOW_SIZE: Option<u64> = None;
pub const DEFAULT_ENABLED_WINDOW_SIZE: Option<u64> = Some(1);
```
