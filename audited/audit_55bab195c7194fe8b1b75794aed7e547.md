# Audit Report

## Title
Authentication Bypass via JWT Header Without JWT Validation in Aptos Faucet

## Summary
The `AuthTokenChecker` in the Aptos faucet unconditionally skips authentication when the `X_IS_JWT_HEADER` is present, assuming JWT validation will occur elsewhere. However, JWT validation only happens in `RedisRatelimitChecker` when explicitly configured with JWT-based rate limiting. This creates an authentication bypass vulnerability in faucet deployments that don't use JWT-based rate limiting.

## Finding Description

The Aptos faucet implements a checker system where each checker returns a `Vec<RejectionReason>` - an empty vector signals validation passed, while a non-empty vector signals rejection. [1](#0-0) 

The `AuthTokenChecker.check()` function has a critical logic flaw: [2](#0-1) 

This code assumes that when `X_IS_JWT_HEADER` is present, JWT validation will happen in another checker. However, JWT validation only occurs in `RedisRatelimitChecker` when configured with the JWT provider: [3](#0-2) 

The `MemoryRatelimitChecker` explicitly does NOT support JWT validation: [4](#0-3) 

The example configuration in `testing_checkers.yaml` demonstrates this vulnerable setup: [5](#0-4) 

This configuration uses `AuthToken` checker for authentication but only has `MemoryRatelimit` (IP-based) for rate limiting. When a request includes `X_IS_JWT_HEADER: true`:

1. `AuthTokenChecker` sees the header and returns `Ok(vec![])`, bypassing auth token validation
2. `MemoryRatelimit` only checks IP-based rate limits, never validates the JWT
3. The request is processed without ANY authentication

The faucet's checker orchestration accumulates rejection reasons from all checkers: [6](#0-5) 

Since both checkers return empty vectors, the request proceeds as if fully authenticated.

## Impact Explanation

This vulnerability allows **complete authentication bypass** on faucet deployments using the common configuration pattern shown in the example config. An attacker can drain faucet funds by repeatedly sending requests with `X_IS_JWT_HEADER: true` without providing any valid credentials.

According to Aptos bug bounty criteria, this constitutes **Medium Severity** impact:
- "Limited funds loss or manipulation" - faucet funds can be drained
- While the faucet is auxiliary infrastructure (testnet/devnet), it represents real operational costs
- The vulnerability doesn't affect mainnet consensus or validator operations

The impact is limited to faucet services but is severe within that scope, as it completely negates authentication controls.

## Likelihood Explanation

**Likelihood: High**

The vulnerability is highly likely to be exploitable because:

1. **Common configuration pattern**: The example configuration file uses this vulnerable setup, suggesting it's a documented/recommended pattern
2. **Zero authentication required**: Attacker only needs to add a single HTTP header
3. **No special privileges needed**: Any network client can exploit this
4. **Simple attack vector**: `curl -H "x-is-jwt: true" -H "Authorization: Bearer fake" <faucet_url>/fund`
5. **No rate limit bypass needed**: IP-based rate limiting still applies, but authentication is completely bypassed

The only deployments NOT vulnerable are those that:
- Use `RedisRatelimitChecker` with `RatelimitKeyProviderConfig::Jwt` configured, OR
- Don't use `AuthToken` checker at all

## Recommendation

Add a dedicated JWT validation checker that ALWAYS validates JWT when `X_IS_JWT_HEADER` is present, regardless of rate limiting configuration. This ensures the implicit contract of `AuthTokenChecker` is fulfilled.

**Recommended fix:**

1. Create a new `JwtAuthChecker` in `crates/aptos-faucet/core/src/checkers/jwt_auth.rs`:

```rust
pub struct JwtAuthChecker {
    pub jwt_verifier: FirebaseJwtVerifier,
}

#[async_trait]
impl CheckerTrait for JwtAuthChecker {
    async fn check(&self, data: CheckerData, _dry_run: bool) -> Result<Vec<RejectionReason>, AptosTapError> {
        // Only check if X_IS_JWT_HEADER is present
        if !data.headers.contains_key(X_IS_JWT_HEADER) {
            return Ok(vec![]);
        }
        
        // Validate JWT and return rejection if invalid
        match self.jwt_verifier.validate_jwt(data.headers.clone()).await {
            Ok(_) => Ok(vec![]),
            Err(e) => Ok(vec![RejectionReason::new(
                e.message,
                e.error_code.into(),
            )]),
        }
    }
    
    fn cost(&self) -> u8 { 5 }
}
```

2. Alternatively, modify `AuthTokenChecker` to validate JWT when the header is present instead of blindly skipping validation.

3. Update all example configurations to include JWT validation when using JWT authentication.

## Proof of Concept

**Attack Script:**
```bash
#!/bin/bash
# Exploit authentication bypass in Aptos faucet

FAUCET_URL="http://localhost:8081"
TARGET_ADDRESS="0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef"

# Bypass authentication by setting X_IS_JWT_HEADER without valid JWT
curl -X POST "${FAUCET_URL}/fund" \
  -H "Content-Type: application/json" \
  -H "x-is-jwt: true" \
  -H "Authorization: Bearer invalid_or_fake_jwt_token" \
  -d "{\"address\": \"${TARGET_ADDRESS}\", \"amount\": 100000000}"

# This request will succeed if the faucet is configured with:
# - AuthToken checker
# - MemoryRatelimit or IP-based RedisRatelimit (not JWT-based)
```

**Test Setup:**
1. Start faucet with `testing_checkers.yaml` configuration
2. Create auth tokens file at `/tmp/auth_tokens.txt` with valid tokens
3. Run the attack script above with `x-is-jwt: true` header
4. Observe that the request succeeds without valid JWT or auth token

**Expected Result:** Request should be rejected due to invalid/missing JWT
**Actual Result:** Request succeeds, funds are transferred

This demonstrates complete authentication bypass affecting any faucet deployment using the documented configuration pattern.

## Notes

- This vulnerability specifically affects the Aptos faucet service, not core blockchain consensus
- The issue stems from implicit assumptions about checker orchestration without enforcement
- Similar bypasser logic also skips JWT validation: [7](#0-6) 
- The vulnerability exists because there's no dedicated JWT authentication checker - JWT validation is conflated with rate limiting in `RedisRatelimitChecker`

### Citations

**File:** crates/aptos-faucet/core/src/checkers/mod.rs (L38-52)
```rust
/// Implementers of this trait are responsible for checking something about the
/// request, and if it doesn't look valid, returning a list of rejection reasons
/// explaining why. It may also do something extra after the funding happened
/// if there is something to clean up afterwards.
#[async_trait]
#[enum_dispatch]
pub trait CheckerTrait: Sync + Send + 'static {
    /// Returns a list of rejection reasons for the request, if any. If dry_run
    /// is set, if this Checker would store anything based on the request, it
    /// instead will not. This is useful for the is_eligible endpoint.
    async fn check(
        &self,
        data: CheckerData,
        dry_run: bool,
    ) -> Result<Vec<RejectionReason>, AptosTapError>;
```

**File:** crates/aptos-faucet/core/src/checkers/auth_token.rs (L37-40)
```rust
        // Don't check if the request has X_IS_JWT_HEADER set.
        if data.headers.contains_key(X_IS_JWT_HEADER) {
            return Ok(vec![]);
        }
```

**File:** crates/aptos-faucet/core/src/checkers/redis_ratelimit.rs (L44-51)
```rust
    pub async fn ratelimit_key_value(&self, data: &CheckerData) -> Result<String, AptosTapError> {
        match self {
            RatelimitKeyProvider::Ip => Ok(data.source_ip.to_string()),
            RatelimitKeyProvider::Jwt(jwt_verifier) => {
                jwt_verifier.validate_jwt(data.headers.clone()).await
            },
        }
    }
```

**File:** crates/aptos-faucet/core/src/checkers/memory_ratelimit.rs (L29-30)
```rust
/// Simple in memory storage that rejects if we've ever seen a request from an
/// IP that has succeeded. This does not support JWT-based ratelimiting.
```

**File:** crates/aptos-faucet/configs/testing_checkers.yaml (L7-18)
```yaml
checker_configs:
  - type: "AuthToken"
    file: "/tmp/auth_tokens.txt"
  - type: "IpBlocklist"
    file: "/tmp/ip_blocklist.txt"
  - type: "RefererBlocklist"
    file: "/tmp/referer_blocklist.txt"
  - type: "MagicHeader"
    magic_header_key: "what_wallet_my_guy"
    magic_header_value: "the_wallet_that_rocks"
  - type: "MemoryRatelimit"
    max_requests_per_day: 1000000000
```

**File:** crates/aptos-faucet/core/src/endpoints/fund.rs (L261-278)
```rust
        // Ensure request passes checkers.
        let mut rejection_reasons = Vec::new();
        for checker in &self.checkers {
            rejection_reasons.extend(checker.check(checker_data.clone(), dry_run).await.map_err(
                |e| AptosTapError::new_with_error_code(e, AptosTapErrorCode::CheckerError),
            )?);
            if !rejection_reasons.is_empty() && self.return_rejections_early {
                break;
            }
        }

        if !rejection_reasons.is_empty() {
            return Err(AptosTapError::new(
                format!("Request rejected by {} checkers", rejection_reasons.len()),
                AptosTapErrorCode::Rejected,
            )
            .rejection_reasons(rejection_reasons));
        }
```

**File:** crates/aptos-faucet/core/src/bypasser/auth_token.rs (L33-36)
```rust
        // Don't check if the request has X_IS_JWT_HEADER set.
        if data.headers.contains_key(X_IS_JWT_HEADER) {
            return Ok(false);
        }
```
