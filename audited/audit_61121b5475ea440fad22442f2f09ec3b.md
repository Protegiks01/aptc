# Audit Report

## Title
Faucet Can Create Inaccessible Fund State When default_account_resource Feature Is Disabled

## Summary
The faucet's `fund_account` operation can deposit funds to an address without creating the required `Account` resource when the `default_account_resource` feature flag is disabled. This creates an inconsistent state where funds exist in a primary fungible store but cannot be accessed because the account cannot sign transactions.

## Finding Description
The vulnerability lies in the interaction between the faucet implementation and the Aptos account model when the `default_account_resource` feature flag is disabled. [1](#0-0) 

The CLI delegates to the faucet which calls `aptos_coin::mint()`: [2](#0-1) 

This function mints coins and deposits them using `coin::deposit()`, which converts to a fungible asset and calls `primary_fungible_store::deposit()`: [3](#0-2) [4](#0-3) 

The `ensure_primary_store_exists()` function creates the primary store without requiring an Account resource: [5](#0-4) [6](#0-5) 

When the `default_account_resource` feature flag is disabled, `account::exists_at()` only returns true if an Account resource actually exists: [7](#0-6) 

With the feature disabled, `get_sequence_number()` aborts for addresses without Account resources: [8](#0-7) 

This means when a user tries to send their first transaction from an address that received faucet funds without an Account resource, the transaction prologue will abort when attempting to get the sequence number, making the funds permanently inaccessible.

## Impact Explanation
This is a **Medium severity** vulnerability per Aptos bug bounty criteria:
- **Limited funds loss**: Funds deposited via faucet become inaccessible
- **State inconsistencies requiring intervention**: Primary store exists with funds but no Account resource to access them
- Requires hard fork or special recovery mechanism to retrieve locked funds

The impact is limited because:
- Only affects faucet operations (not general protocol)
- Requires feature flag to be disabled
- Typically affects testnet/devnet more than mainnet
- Each incident involves limited faucet amounts

## Likelihood Explanation
**Likelihood: Medium to Low**

The vulnerability occurs when:
1. The `default_account_resource` feature flag is disabled (feature #91)
2. A user requests faucet funds to an address without an existing Account resource
3. The faucet successfully deposits to the primary store
4. The user cannot access the funds

Factors increasing likelihood:
- New users on testnet/devnet may not create accounts properly before requesting funds
- Feature flag could be disabled during rollback scenarios
- Automated scripts might request funds before account creation

Factors decreasing likelihood:
- The feature flag appears designed to prevent this exact issue when enabled
- Modern wallets typically create accounts before requesting funds
- Faucet documentation likely guides proper account creation

## Recommendation

The faucet implementation should use `aptos_account::deposit_coins()` instead of directly calling `aptos_coin::mint()` with `coin::deposit()`. This ensures the Account resource is created before depositing funds: [9](#0-8) 

Alternatively, modify `aptos_coin::mint()` to explicitly check and create the Account resource:

```move
public entry fun mint(
    account: &signer,
    dst_addr: address,
    amount: u64,
) acquires MintCapStore {
    // Ensure account exists
    if (!account::exists_at(dst_addr)) {
        aptos_account::create_account(dst_addr);
    };
    
    let account_addr = signer::address_of(account);
    assert!(
        exists<MintCapStore>(account_addr),
        error::not_found(ENO_CAPABILITIES),
    );

    let mint_cap = &borrow_global<MintCapStore>(account_addr).mint_cap;
    let coins_minted = coin::mint<AptosCoin>(amount, mint_cap);
    coin::deposit<AptosCoin>(dst_addr, coins_minted);
}
```

## Proof of Concept

```move
#[test_only]
module test_addr::faucet_vulnerability_test {
    use std::signer;
    use aptos_framework::account;
    use aptos_framework::aptos_coin::{Self, AptosCoin};
    use aptos_framework::coin;
    use aptos_framework::features;
    
    #[test(aptos_framework = @aptos_framework, faucet = @0xFAUCET, user = @0xUSER)]
    #[expected_failure(abort_code = 0x60001, location = aptos_framework::account)]
    fun test_faucet_locked_funds(
        aptos_framework: &signer,
        faucet: &signer,
        user: &signer,
    ) {
        // Setup: Initialize framework and disable feature flag
        features::change_feature_flags_for_testing(
            aptos_framework,
            vector[],
            vector[features::get_default_account_resource_feature()],
        );
        
        // Setup: Create faucet account with mint capability
        let (burn_cap, mint_cap) = aptos_coin::initialize_for_test(aptos_framework);
        aptos_coin::configure_accounts_for_test(aptos_framework, faucet, mint_cap);
        coin::destroy_burn_cap(burn_cap);
        
        let user_addr = signer::address_of(user);
        
        // Faucet mints to non-existent account (no Account resource)
        aptos_coin::mint(faucet, user_addr, 100_000_000);
        
        // Verify primary store exists and has funds
        let balance = coin::balance<AptosCoin>(user_addr);
        assert!(balance == 100_000_000, 1);
        
        // Verify Account resource does NOT exist
        assert!(!account::exists_at(user_addr), 2);
        
        // Attempt to get sequence number - THIS WILL ABORT
        // In real scenario, this would happen in transaction prologue
        account::get_sequence_number(user_addr); // ABORTS with EACCOUNT_DOES_NOT_EXIST
    }
}
```

**Notes:**
- This vulnerability only manifests when `default_account_resource` feature flag is disabled
- When enabled (feature #91), accounts without Account resources return default values and are auto-created on first transaction
- The inconsistent state (funded primary store without Account resource) breaks the State Consistency invariant
- Recovery requires either enabling the feature flag or hard fork intervention to create the missing Account resource

### Citations

**File:** crates/aptos/src/account/fund.rs (L52-54)
```rust
        self.faucet_options
            .fund_account(client, &self.profile_options, self.amount, address)
            .await?;
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_coin.move (L93-108)
```text
    public entry fun mint(
        account: &signer,
        dst_addr: address,
        amount: u64,
    ) acquires MintCapStore {
        let account_addr = signer::address_of(account);

        assert!(
            exists<MintCapStore>(account_addr),
            error::not_found(ENO_CAPABILITIES),
        );

        let mint_cap = &borrow_global<MintCapStore>(account_addr).mint_cap;
        let coins_minted = coin::mint<AptosCoin>(amount, mint_cap);
        coin::deposit<AptosCoin>(dst_addr, coins_minted);
    }
```

**File:** aptos-move/framework/aptos-framework/sources/coin.move (L914-918)
```text
    public fun deposit<CoinType>(
        account_addr: address, coin: Coin<CoinType>
    ) acquires CoinConversionMap, CoinInfo {
        primary_fungible_store::deposit(account_addr, coin_to_fungible_asset(coin));
    }
```

**File:** aptos-move/framework/aptos-framework/sources/primary_fungible_store.move (L62-72)
```text
    public fun ensure_primary_store_exists<T: key>(
        owner: address,
        metadata: Object<T>,
    ): Object<FungibleStore> acquires DeriveRefPod {
        let store_addr = primary_store_address(owner, metadata);
        if (fungible_asset::store_exists(store_addr)) {
            object::address_to_object(store_addr)
        } else {
            create_primary_store(owner, metadata)
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/primary_fungible_store.move (L75-88)
```text
    public fun create_primary_store<T: key>(
        owner_addr: address,
        metadata: Object<T>,
    ): Object<FungibleStore> acquires DeriveRefPod {
        let metadata_addr = metadata.object_address();
        object::address_to_object<Metadata>(metadata_addr);
        let derive_ref = &borrow_global<DeriveRefPod>(metadata_addr).metadata_derive_ref;
        let constructor_ref = &object::create_user_derived_object(owner_addr, derive_ref);
        // Disable ungated transfer as deterministic stores shouldn't be transferrable.
        let transfer_ref = &constructor_ref.generate_transfer_ref();
        transfer_ref.disable_ungated_transfer();

        fungible_asset::create_store(constructor_ref, metadata)
    }
```

**File:** aptos-move/framework/aptos-framework/sources/primary_fungible_store.move (L195-199)
```text
    public fun deposit(owner: address, fa: FungibleAsset) acquires DeriveRefPod {
        let metadata = fa.asset_metadata();
        let store = ensure_primary_store_exists(owner, metadata);
        dispatchable_fungible_asset::deposit(store, fa);
    }
```

**File:** aptos-move/framework/aptos-framework/sources/account/account.move (L348-350)
```text
    public fun exists_at(addr: address): bool {
        features::is_default_account_resource_enabled() || exists<Account>(addr)
    }
```

**File:** aptos-move/framework/aptos-framework/sources/account/account.move (L384-392)
```text
    public fun get_sequence_number(addr: address): u64 acquires Account {
        if (resource_exists_at(addr)) {
            Account[addr].sequence_number
        } else if (features::is_default_account_resource_enabled()) {
            0
        } else {
            abort error::not_found(EACCOUNT_DOES_NOT_EXIST)
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_account.move (L128-148)
```text
    public fun deposit_coins<CoinType>(
        to: address, coins: Coin<CoinType>
    ) acquires DirectTransferConfig {
        if (!account::exists_at(to)) {
            create_account(to);
            spec {
                // TODO(fa_migration)
                // assert coin::spec_is_account_registered<AptosCoin>(to);
                // assume aptos_std::type_info::type_of<CoinType>() == aptos_std::type_info::type_of<AptosCoin>() ==>
                //     coin::spec_is_account_registered<CoinType>(to);
            };
        };
        if (!coin::is_account_registered<CoinType>(to)) {
            assert!(
                can_receive_direct_coin_transfers(to),
                error::permission_denied(EACCOUNT_DOES_NOT_ACCEPT_DIRECT_COIN_TRANSFERS)
            );
            coin::register<CoinType>(&create_signer(to));
        };
        coin::deposit<CoinType>(to, coins)
    }
```
