# Audit Report

## Title
IPv4-Mapped IPv6 Address Bypass in Faucet IP Range Manager Allows Blocklist Evasion

## Summary
The `contains_ip()` function in the Aptos faucet's IP range manager fails to handle IPv4-mapped IPv6 addresses, allowing attackers to bypass IP blocklists by connecting via IPv6. When a blocklist contains IPv4 ranges (e.g., `192.0.2.0/24`), an attacker using the IPv4-mapped IPv6 address `::ffff:192.0.2.1` can evade detection and abuse the faucet service. [1](#0-0) 

## Finding Description

The `contains_ip()` function strictly segregates IPv4 and IPv6 address checking by matching on the `IpAddr` enum and only checking against the corresponding list. This creates a critical gap: IPv4-mapped IPv6 addresses (format: `::ffff:x.x.x.x`) are legitimate IPv6 addresses that represent IPv4 addresses, but they will only be checked against the IPv6 list.

**Attack Flow:**

1. Faucet administrator blocks abusive IPv4 address by adding `192.0.2.0/24` to the blocklist configuration file
2. The configuration file only contains IPv4 CIDR ranges, which are loaded into `ipv4_list` during initialization [2](#0-1) 

3. Attacker connects to the faucet endpoint from the same machine but via IPv6, resulting in source IP `::ffff:192.0.2.1`
4. The request processing extracts the source IP and creates `CheckerData` [3](#0-2) 

5. The `IpBlocklistChecker` uses the IP range manager to check if the IP is blocked [4](#0-3) 

6. Since `::ffff:192.0.2.1` is an `IpAddr::V6`, it gets checked only against `ipv6_list.contains()`, which is empty
7. Check returns false, allowing the blocked IP to bypass restrictions

Similarly, the `IpAllowlistBypasser` has the inverse problem where legitimate IPv6 connections from allowlisted IPv4 addresses fail to bypass rate limits [5](#0-4) 

## Impact Explanation

**Severity: High to Medium** (depending on deployment context)

For testnet faucets, this allows:
- **Resource Exhaustion**: Blocked attackers can repeatedly request tokens, depleting faucet funds
- **Rate Limit Bypass**: Abusive users can circumvent IP-based rate limiting
- **Access Control Violation**: Undermines the entire IP-based security model

The impact aligns with **High Severity** per Aptos bug bounty criteria ("Significant protocol violations" and potential "API crashes" from resource exhaustion). While not directly causing consensus issues or mainnet fund loss, it represents a significant security control bypass that could enable sustained attacks on faucet infrastructure.

If similar IP filtering logic were used in mainnet-adjacent services (e.g., API gateways, validator admission control), the impact would escalate to **Critical Severity** due to potential fund loss or network disruption.

## Likelihood Explanation

**Likelihood: High**

IPv4-mapped IPv6 addresses occur naturally in:
- **Dual-stack environments**: Modern cloud providers (AWS, GCP, Azure) support both IPv4 and IPv6
- **Reverse proxies**: Load balancers may present IPv4 connections as IPv6-mapped addresses to backend services
- **Container networking**: Docker and Kubernetes commonly use IPv6 internally
- **Operating system defaults**: Many systems prefer IPv6 when available

An attacker can trivially exploit this by:
- Using IPv6-enabled clients or proxies
- Configuring systems to prefer IPv6
- Using standard tools (curl, wget) with IPv6 connectivity

No special technical knowledge or resources required beyond basic IPv6 connectivity.

## Recommendation

Normalize IPv4-mapped IPv6 addresses to their IPv4 equivalents before checking:

```rust
pub fn contains_ip(&self, ip: &IpAddr) -> bool {
    match ip {
        IpAddr::V4(ipv4) => self.ipv4_list.contains(ipv4),
        IpAddr::V6(ipv6) => {
            // Check if this is an IPv4-mapped IPv6 address
            if let Some(ipv4) = ipv6.to_ipv4_mapped() {
                // Check against IPv4 list if it's IPv4-mapped
                self.ipv4_list.contains(&ipv4)
            } else {
                // Otherwise check against IPv6 list
                self.ipv6_list.contains(ipv6)
            }
        },
    }
}
```

**Additional Hardening:**
- Document this behavior in configuration file comments
- Log warnings when IPv4-mapped addresses are detected
- Consider validating configuration files for both IPv4 and IPv6 versions of critical ranges
- Add integration tests covering IPv4-mapped IPv6 scenarios

## Proof of Concept

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use std::io::Write;
    use tempfile::NamedTempFile;

    #[test]
    fn test_ipv4_mapped_ipv6_bypass() {
        // Create a temporary config file with IPv4 blocklist
        let mut config_file = NamedTempFile::new().unwrap();
        writeln!(config_file, "192.0.2.0/24").unwrap();
        writeln!(config_file, "198.51.100.0/24").unwrap();
        config_file.flush().unwrap();

        let config = IpRangeManagerConfig {
            file: config_file.path().to_path_buf(),
        };
        let manager = IpRangeManager::new(config).unwrap();

        // Test normal IPv4 address - should be blocked
        let ipv4_blocked = "192.0.2.1".parse::<IpAddr>().unwrap();
        assert!(manager.contains_ip(&ipv4_blocked), 
                "IPv4 address should be in blocklist");

        // Test IPv4-mapped IPv6 address for the SAME IP - bypasses blocklist!
        let ipv6_mapped = "::ffff:192.0.2.1".parse::<IpAddr>().unwrap();
        assert!(!manager.contains_ip(&ipv6_mapped), 
                "VULNERABILITY: IPv4-mapped IPv6 address bypasses blocklist!");

        // Another example
        let ipv6_mapped2 = "::ffff:198.51.100.50".parse::<IpAddr>().unwrap();
        assert!(!manager.contains_ip(&ipv6_mapped2), 
                "VULNERABILITY: Another IPv4-mapped IPv6 bypasses blocklist!");
    }

    #[test]
    fn test_ipv4_mapped_ipv6_allowlist_failure() {
        // Create a temporary config file with IPv4 allowlist
        let mut config_file = NamedTempFile::new().unwrap();
        writeln!(config_file, "10.0.0.0/8").unwrap();
        config_file.flush().unwrap();

        let config = IpRangeManagerConfig {
            file: config_file.path().to_path_buf(),
        };
        let manager = IpRangeManager::new(config).unwrap();

        // Test normal IPv4 address - should be allowed
        let ipv4_allowed = "10.0.1.100".parse::<IpAddr>().unwrap();
        assert!(manager.contains_ip(&ipv4_allowed), 
                "IPv4 address should be in allowlist");

        // Test IPv4-mapped IPv6 address - fails to match allowlist
        let ipv6_mapped = "::ffff:10.0.1.100".parse::<IpAddr>().unwrap();
        assert!(!manager.contains_ip(&ipv6_mapped), 
                "VULNERABILITY: IPv4-mapped IPv6 fails to match allowlist!");
    }
}
```

**To run the PoC:**
1. Add the test code to `crates/aptos-faucet/core/src/common/ip_range_manager.rs`
2. Add `tempfile = "3.0"` to `[dev-dependencies]` in `Cargo.toml`
3. Run: `cargo test --package aptos-faucet-core test_ipv4_mapped_ipv6`
4. Both tests will pass, demonstrating the vulnerability

## Notes

While this vulnerability affects the faucet service (primarily testnet infrastructure) rather than core consensus or Move VM components, it represents a fundamental access control bypass. The same IP filtering pattern could be used in other Aptos services where the impact would be more severe. Organizations deploying Aptos infrastructure should audit all IP-based access controls for this issue.

The Rust standard library provides `Ipv6Addr::to_ipv4_mapped()` specifically to handle this case, indicating it's a well-known security consideration in network programming.

### Citations

**File:** crates/aptos-faucet/core/src/common/ip_range_manager.rs (L24-53)
```rust
    pub fn new(config: IpRangeManagerConfig) -> Result<Self> {
        let file = File::open(&config.file)
            .with_context(|| format!("Failed to open {}", config.file.to_string_lossy()))?;

        let mut ipv4_list = IpRange::<Ipv4Net>::new();
        let mut ipv6_list = IpRange::<Ipv6Net>::new();
        for line in std::io::BufReader::new(file).lines() {
            let line = line?;
            if line.starts_with('#') || line.starts_with("//") || line.is_empty() {
                continue;
            }
            match line.parse::<Ipv4Net>() {
                Ok(ipv4_net) => {
                    ipv4_list.add(ipv4_net);
                },
                Err(_) => match line.parse::<Ipv6Net>() {
                    Ok(ipv6_net) => {
                        ipv6_list.add(ipv6_net);
                    },
                    Err(_) => {
                        bail!("Failed to parse line as IPv4 or IPv6 range: {}", line);
                    },
                },
            }
        }
        Ok(Self {
            ipv4_list,
            ipv6_list,
        })
    }
```

**File:** crates/aptos-faucet/core/src/common/ip_range_manager.rs (L55-60)
```rust
    pub fn contains_ip(&self, ip: &IpAddr) -> bool {
        match ip {
            IpAddr::V4(ipv4) => self.ipv4_list.contains(ipv4),
            IpAddr::V6(ipv6) => self.ipv6_list.contains(ipv6),
        }
    }
```

**File:** crates/aptos-faucet/core/src/endpoints/fund.rs (L217-242)
```rust
        let source_ip = match source_ip.0 {
            Some(ip) => ip,
            None => {
                return Err(AptosTapError::new(
                    "No source IP found in the request".to_string(),
                    AptosTapErrorCode::SourceIpMissing,
                ))
            },
        };

        let receiver = match fund_request.receiver() {
            Some(receiver) => receiver,
            None => {
                return Err(AptosTapError::new(
                    "Account address, auth key, or pub key must be provided and valid".to_string(),
                    AptosTapErrorCode::InvalidRequest,
                ))
            },
        };

        let checker_data = CheckerData {
            receiver,
            source_ip,
            headers: Arc::new(header_map.clone()),
            time_request_received_secs: get_current_time_secs(),
        };
```

**File:** crates/aptos-faucet/core/src/checkers/ip_blocklist.rs (L32-49)
```rust
        match &data.source_ip {
            IpAddr::V4(source_ip) => {
                if self.manager.ipv4_list.contains(source_ip) {
                    return Ok(vec![RejectionReason::new(
                        format!("IP {} is in blocklist", source_ip),
                        RejectionReasonCode::IpInBlocklist,
                    )]);
                }
            },
            IpAddr::V6(source_ip) => {
                if self.manager.ipv6_list.contains(source_ip) {
                    return Ok(vec![RejectionReason::new(
                        format!("IP {} is in blocklist", source_ip),
                        RejectionReasonCode::IpInBlocklist,
                    )]);
                }
            },
        }
```

**File:** crates/aptos-faucet/core/src/bypasser/ip_allowlist.rs (L26-28)
```rust
    async fn request_can_bypass(&self, data: CheckerData) -> Result<bool> {
        Ok(self.manager.contains_ip(&data.source_ip))
    }
```
