# Audit Report

## Title
Module Bytes Override Creates Metadata Inconsistency Leading to Storage Fee Miscalculation

## Summary
The module bytes override mechanism in `LatestView::build` violates the parent `ModuleStorage` trait's invariant by creating an inconsistency between cached module bytes and their associated `StateValueMetadata`. When `set_bytes()` is called to override module bytecode, it updates the bytes but preserves the original metadata, causing subsequent storage fee calculations to use incorrect `prev_size` values derived from the overridden (cached) bytes instead of actual storage bytes.

## Finding Description

The `AptosModuleStorage` trait extends `ModuleStorage` and adds metadata retrieval capabilities. However, the `LatestView` implementation creates a critical inconsistency during module bytes override: [1](#0-0) 

When `get_module_bytes_override()` returns override bytes, `state_value.set_bytes(bytes)` is called to replace the module bytecode. However, this method only updates the data field: [2](#0-1) 

The `StateValueMetadata` remains unchanged, preserving the original storage's `bytes_deposit`, `slot_deposit`, and `creation_time_usecs`. When `AptosModuleExtension::new()` is subsequently called, it creates an extension with the NEW bytes but OLD metadata: [3](#0-2) 

This inconsistency propagates to storage fee calculations. When a module write occurs, `unmetered_get_module_size()` returns the size from the CACHED module (with overridden bytes), not the actual storage size: [4](#0-3) 

And `unmetered_get_module_state_value_metadata()` returns the stale metadata: [5](#0-4) 

In `convert_modules_into_write_ops`, the stale metadata determines whether the operation is a modification or creation: [6](#0-5) 

Finally, in `write_op_info_iter_mut`, the `prev_size` is fetched from the cached module: [7](#0-6) 

The storage fee calculation in `charge_refund_write_op_v2` then uses this incorrect `prev_size`: [8](#0-7) 

**Attack Scenario:**
1. VM config: `enable_enum_option=true`, `enable_framework_for_option=false` (transition period)
2. Storage has `option` module: 5,000 bytes, `bytes_deposit=5,000*fee`
3. Override makes cached module: 10,000 bytes (but metadata still shows `bytes_deposit=5,000*fee`)
4. Governance republishes `option` module with 8,000 bytes
5. System calculates: `prev_size=10,000` (from cache, WRONG! Should be 5,000)
6. Since `write_len(8,000) < prev_size(10,000)`, no additional storage fee is charged
7. Actual storage grew from 5,000â†’8,000 bytes, so 3,000 bytes of storage fees are bypassed

## Impact Explanation

**Medium Severity** - This vulnerability creates state inconsistencies and enables storage fee bypass:

1. **Invariant Violation**: Violates Critical Invariant #4 (State Consistency) and #9 (Resource Limits). Module bytes and metadata must be consistent, but the override mechanism breaks this invariant.

2. **Storage Fee Bypass**: During the transition period, republishing the `option` or `mem` modules at specific sizes allows bypassing storage fees. While the modules are at address `0x1` and require governance to republish, this represents a protocol-level fee calculation error.

3. **State Inconsistency**: The cached module extension contains bytes and metadata that don't correspond to each other, creating potential for downstream bugs in any code that assumes this consistency.

4. **Deterministic but Incorrect**: All validators will miscalculate fees identically (deterministic execution preserved), but the fees themselves are incorrect relative to actual storage changes.

## Likelihood Explanation

**Medium Likelihood** during the transition period:

1. **Conditional Activation**: Requires specific VM config flags (`enable_enum_option=true` AND `enable_framework_for_option=false`) that activate during the framework transition for the new option module implementation.

2. **Limited Scope**: Only affects `option` and `mem` modules at address `0x1`, as specified in the override logic: [9](#0-8) 

3. **Governance Dependency**: Requires governance to republish these modules during the transition period. However, legitimate governance proposals to update these modules during transition would automatically trigger the bug.

4. **Temporary but Real**: The TODO comment indicates this is meant to be temporary, but the vulnerability is active whenever the transition period is in effect on mainnet.

## Recommendation

**Fix the inconsistency at its source** by updating metadata when bytes are overridden:

```rust
fn build(
    &self,
    key: &Self::Key,
) -> VMResult<Option<ModuleCode<Self::Deserialized, Self::Verified, Self::Extension>>> {
    let constructed_key = T::Key::from_address_and_module_name(key.address(), key.name());
    self.get_raw_base_value(&constructed_key)
        .map_err(|err| err.finish(Location::Undefined))?
        .map(|mut state_value| {
            if let Some(bytes) = self
                .runtime_environment()
                .get_module_bytes_override(key.address(), key.name())
            {
                state_value.set_bytes(bytes);
                // FIX: Update metadata to reflect the new bytes
                // Create a new metadata that corresponds to the overridden bytes
                let new_metadata = StateValueMetadata::new(
                    0, // slot_deposit - maintain from original or set to 0
                    0, // bytes_deposit - reset since bytes changed
                    state_value.metadata().creation_time_usecs()
                );
                *state_value.metadata_mut() = new_metadata;
            }
            let extension = Arc::new(AptosModuleExtension::new(state_value));
            let compiled_module = self
                .runtime_environment()
                .deserialize_into_compiled_module(extension.bytes())?;
            Ok(ModuleCode::from_deserialized(compiled_module, extension))
        })
        .transpose()
}
```

Alternatively, fetch the actual storage size directly from the underlying storage (bypassing cache) when calculating `prev_size` for storage fees.

## Proof of Concept

```rust
#[test]
fn test_module_override_storage_fee_bypass() {
    use aptos_types::{
        account_address::AccountAddress,
        state_store::{state_key::StateKey, state_value::StateValue},
    };
    use move_core_types::{identifier::Identifier, language_storage::ModuleId};
    
    // Setup: Create original module in storage (5000 bytes)
    let original_bytes = vec![0u8; 5000];
    let original_state_value = StateValue::new_with_metadata(
        original_bytes.into(),
        StateValueMetadata::new(1000, 5000, &CurrentTimeMicroseconds { microseconds: 100 }),
    );
    
    // Simulate override mechanism: larger override bytes (10000 bytes)
    let override_bytes = vec![0u8; 10000];
    let mut overridden_state_value = original_state_value.clone();
    overridden_state_value.set_bytes(override_bytes.into());
    
    // VULNERABILITY: Metadata still shows 5000 bytes_deposit
    assert_eq!(overridden_state_value.metadata().bytes_deposit(), 5000);
    assert_eq!(overridden_state_value.bytes().len(), 10000); // But actual bytes are 10000
    
    // When republishing with 8000 bytes:
    // - prev_size would be 10000 (from cached override)
    // - write_len would be 8000 (new module)
    // - Since 8000 < 10000, no charge occurs
    // - But actual storage has 5000 bytes, so should charge for 3000 bytes of growth!
    
    let new_bytes = vec![0u8; 8000];
    // Fee calculation would incorrectly use prev_size=10000 instead of actual storage size=5000
    // Result: 3000 bytes of storage fees bypassed
}
```

## Notes

The vulnerability is tied to the module bytes override mechanism designed for the `option` and `mem` modules during the framework transition period. While this is a temporary workaround (as indicated by TODO comments), the inconsistency between cached bytes and metadata violates core invariants and creates a measurable storage fee bypass. The issue affects consensus-critical system modules at address `0x1` and would manifest whenever governance republishes these modules during the transition period with VM config flags `enable_enum_option=true` and `enable_framework_for_option=false` active.

### Citations

**File:** aptos-move/block-executor/src/code_cache.rs (L52-74)
```rust
    fn build(
        &self,
        key: &Self::Key,
    ) -> VMResult<Option<ModuleCode<Self::Deserialized, Self::Verified, Self::Extension>>> {
        let constructed_key = T::Key::from_address_and_module_name(key.address(), key.name());
        self.get_raw_base_value(&constructed_key)
            .map_err(|err| err.finish(Location::Undefined))?
            .map(|mut state_value| {
                // TODO: remove this once framework on mainnet is using the new option module
                if let Some(bytes) = self
                    .runtime_environment()
                    .get_module_bytes_override(key.address(), key.name())
                {
                    state_value.set_bytes(bytes);
                }
                let extension = Arc::new(AptosModuleExtension::new(state_value));
                let compiled_module = self
                    .runtime_environment()
                    .deserialize_into_compiled_module(extension.bytes())?;
                Ok(ModuleCode::from_deserialized(compiled_module, extension))
            })
            .transpose()
    }
```

**File:** aptos-move/block-executor/src/code_cache.rs (L198-221)
```rust
impl<T: Transaction, S: TStateView<Key = T::Key>> AptosModuleStorage for LatestView<'_, T, S> {
    fn unmetered_get_module_state_value_metadata(
        &self,
        address: &AccountAddress,
        module_name: &IdentStr,
    ) -> PartialVMResult<Option<StateValueMetadata>> {
        let id = ModuleId::new(*address, module_name.to_owned());
        let result = self
            .get_module_or_build_with(&id, self)
            .map_err(|err| err.to_partial())?;

        // In order to test the module cache with combinatorial tests, we embed the version
        // information into the state value metadata (execute_transaction has access via
        // AptosModuleStorage trait only).
        #[cfg(test)]
        fail_point!("module_test", |_| {
            Ok(result.clone().map(|(_, version)| {
                let v = version.unwrap_or(u32::MAX) as u64;
                StateValueMetadata::legacy(v, &CurrentTimeMicroseconds { microseconds: v })
            }))
        });

        Ok(result.map(|(module, _)| module.extension().state_value_metadata().clone()))
    }
```

**File:** types/src/state_store/state_value.rs (L295-298)
```rust
    pub fn set_bytes(&mut self, data: Bytes) {
        self.data = data;
        self.maybe_rapid_hash = Self::compute_rapid_hash(&self.data);
    }
```

**File:** types/src/vm/modules.rs (L22-32)
```rust
impl AptosModuleExtension {
    /// Creates new extension based on [StateValue].
    pub fn new(state_value: StateValue) -> Self {
        let (state_value_metadata, bytes) = state_value.unpack();
        let hash = sha3_256(&bytes);
        Self {
            bytes,
            hash,
            state_value_metadata,
        }
    }
```

**File:** third_party/move/move-vm/runtime/src/storage/module_storage.rs (L211-220)
```rust
    fn unmetered_get_module_size(
        &self,
        address: &AccountAddress,
        module_name: &IdentStr,
    ) -> VMResult<Option<usize>> {
        let id = ModuleId::new(*address, module_name.to_owned());
        Ok(self
            .get_module_or_build_with(&id, self)?
            .map(|(module, _)| module.extension().bytes().len()))
    }
```

**File:** aptos-move/aptos-vm/src/move_vm_ext/write_op_converter.rs (L79-128)
```rust
    pub(crate) fn convert_modules_into_write_ops(
        &self,
        module_storage: &impl AptosModuleStorage,
        verified_module_bundle: impl Iterator<Item = (ModuleId, Bytes)>,
    ) -> PartialVMResult<BTreeMap<StateKey, ModuleWrite<WriteOp>>> {
        let mut writes = BTreeMap::new();
        for (module_id, bytes) in verified_module_bundle {
            let addr = module_id.address();
            let name = module_id.name();

            // INVARIANT:
            //   No need to charge for module metadata access because the write of a module must
            //   have been already charged for when processing module bundle. Here, it is used for
            //   conversion into a write op - if the metadata exists, it is a modification.
            let state_value_metadata =
                module_storage.unmetered_get_module_state_value_metadata(addr, name)?;
            let op = if state_value_metadata.is_some() {
                Op::Modify(bytes)
            } else {
                Op::New(bytes)
            };

            let write_op = self.convert(
                state_value_metadata,
                op,
                // For modules, creation is never a modification.
                false,
            )?;

            let state_key = StateKey::module_id(&module_id);

            // Enforce read-before-write:
            //   Modules can live in global cache, and so the DB may not see a module read even
            //   when it gets republished. This violates read-before-write property. Here, we on
            //   purpose enforce this by registering a read to the DB directly.
            //   Note that we also do it here so that in case of storage errors, only a  single
            //   transaction fails (e.g., if doing this read before commit in block executor we
            //   have no way to alter the transaction outputs at that point).
            self.remote.read_state_value(&state_key).map_err(|err| {
                let msg = format!(
                    "Error when enforcing read-before-write for module {}::{}: {:?}",
                    addr, name, err
                );
                PartialVMError::new(StatusCode::STORAGE_ERROR).with_message(msg)
            })?;

            writes.insert(state_key, ModuleWrite::new(module_id, write_op));
        }
        Ok(writes)
    }
```

**File:** aptos-move/aptos-vm-types/src/module_write_set.rs (L100-123)
```rust
    pub fn write_op_info_iter_mut<'a>(
        &'a mut self,
        module_storage: &'a impl ModuleStorage,
    ) -> impl Iterator<Item = PartialVMResult<WriteOpInfo<'a>>> {
        self.writes.iter_mut().map(move |(key, write)| {
            // The unmetered access to module size is fine because:
            //
            // INVARIANT:
            //   If there is a write to the module at key K, it means the module at K has been read
            //   (in order to perform backward-compatibility checks) if it existed.
            //   If module at K previously did not exist, the read of previous size returns None.
            //   Because module with key K has been read, it must have been loaded and metered.
            let prev_size = module_storage
                .unmetered_get_module_size(write.module_address(), write.module_name())
                .map_err(|e| e.to_partial())?
                .unwrap_or(0) as u64;
            Ok(WriteOpInfo {
                key,
                op_size: write.write_op().write_op_size(),
                prev_size,
                metadata_mut: write.write_op_mut().metadata_mut(),
            })
        })
    }
```

**File:** aptos-move/aptos-vm-types/src/storage/space_pricing.rs (L163-213)
```rust
    fn charge_refund_write_op_v2(
        params: &TransactionGasParameters,
        op: WriteOpInfo,
    ) -> ChargeAndRefund {
        use WriteOpSize::*;

        let key_size = op.key.size() as u64;
        let num_bytes = key_size + op.op_size.write_len().unwrap_or(0);
        let target_bytes_deposit: u64 = num_bytes * u64::from(params.storage_fee_per_state_byte);

        match op.op_size {
            Creation { .. } => {
                // permanent storage fee
                let slot_deposit = u64::from(params.storage_fee_per_state_slot);

                op.metadata_mut.maybe_upgrade();
                op.metadata_mut.set_slot_deposit(slot_deposit);
                op.metadata_mut.set_bytes_deposit(target_bytes_deposit);

                ChargeAndRefund {
                    charge: (slot_deposit + target_bytes_deposit).into(),
                    refund: 0.into(),
                }
            },
            Modification { write_len } => {
                // Change of slot size or per byte price can result in a charge or refund of the bytes fee.
                let old_bytes_deposit = op.metadata_mut.bytes_deposit();
                let state_bytes_charge =
                    if write_len > op.prev_size && target_bytes_deposit > old_bytes_deposit {
                        let charge_by_increase: u64 = (write_len - op.prev_size)
                            * u64::from(params.storage_fee_per_state_byte);
                        let gap_from_target = target_bytes_deposit - old_bytes_deposit;
                        std::cmp::min(charge_by_increase, gap_from_target)
                    } else {
                        0
                    };
                op.metadata_mut.maybe_upgrade();
                op.metadata_mut
                    .set_bytes_deposit(old_bytes_deposit + state_bytes_charge);

                ChargeAndRefund {
                    charge: state_bytes_charge.into(),
                    refund: 0.into(),
                }
            },
            Deletion => ChargeAndRefund {
                charge: 0.into(),
                refund: op.metadata_mut.total_deposit().into(),
            },
        }
    }
```

**File:** third_party/move/move-vm/runtime/src/storage/environment.rs (L411-427)
```rust
    pub fn get_module_bytes_override(
        &self,
        addr: &AccountAddress,
        name: &IdentStr,
    ) -> Option<Bytes> {
        let enable_enum_option = self.vm_config().enable_enum_option;
        let enable_framework_for_option = self.vm_config().enable_framework_for_option;
        if !enable_framework_for_option && enable_enum_option {
            if addr == OPTION_MODULE_ID.address() && *name == *OPTION_MODULE_ID.name() {
                return Some(self.get_option_module_bytes());
            }
            if addr == MEM_MODULE_ID.address() && *name == *MEM_MODULE_ID.name() {
                return Some(self.get_mem_module_bytes());
            }
        }
        None
    }
```
