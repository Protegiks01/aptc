# Audit Report

## Title
Indexer-GRPC Service DoS via Unchecked Address Length in `standardize_address()`

## Summary
The `standardize_address()` function in the transaction filter module lacks input validation for address length, causing a panic when processing addresses exceeding 64 hexadecimal characters. This allows any client to crash the indexer-gRPC service by submitting a transaction filter with an overly long address, resulting in a denial of service.

## Finding Description

The `standardize_address()` function is designed to normalize Aptos addresses according to AIP-40 display format (short format for special addresses 0x0-0xf, long format for others). However, it fails to validate input length before performing arithmetic operations. [1](#0-0) 

The vulnerability occurs at the regular address formatting path. When the input address (after stripping "0x" prefix) exceeds 64 characters, the expression `64 - trimmed.len()` causes integer underflow in debug mode or wraps to a large value in release mode. The subsequent slice operation `&ZEROS[..64 - trimmed.len()]` then panics with an out-of-bounds access.

**Attack Path:**

1. Attacker constructs a gRPC `GetTransactionsRequest` with a `UserTransactionFilter` or `EntryFunctionFilter` containing a sender/address field with > 64 hex characters (e.g., 70 characters)
2. The protobuf message is deserialized and converted to Rust types
3. During conversion, the `From<proto>` trait implementation calls `standardize_address()` to normalize filter addresses for comparison [2](#0-1) 

4. The function panics at the slice operation, crashing the indexer-gRPC service thread/process
5. Downstream indexers lose connectivity and cannot receive transaction data

**Secondary Issue - Silent Invalid Output:**

The function also lacks validation for hexadecimal characters. Addresses containing invalid characters (e.g., "0xGHIJKL") pass through and get zero-padded without error. While this doesn't cause crashes, it results in malformed filter criteria that fail to match valid blockchain addresses, potentially causing downstream indexers to miss transactions (data incompleteness).

## Impact Explanation

**Primary Impact - High Severity (API Crashes):**

This vulnerability enables remote denial of service against the indexer-gRPC data service, which is critical infrastructure for transaction indexing. Per the Aptos bug bounty program, "API crashes" are classified as High Severity (up to $50,000). The impact includes:

- Immediate service unavailability when malicious filter is processed
- Disruption of downstream indexers that depend on the gRPC service
- Potential cascading failures if indexing infrastructure cannot recover automatically
- No authentication or special privileges required to exploit

**Secondary Impact - Medium Severity (Data Gaps):**

The silent acceptance of invalid hex characters could lead to state inconsistencies requiring intervention. Malformed filters may cause downstream indexers to miss transactions they should process, resulting in incomplete indexed data. This qualifies as Medium Severity per the "State inconsistencies requiring intervention" category.

## Likelihood Explanation

**Likelihood: High**

This vulnerability is highly likely to be exploited because:

1. **Trivial Exploitation**: Attack requires only sending a gRPC request with a long string - no complex timing, race conditions, or cryptographic operations needed
2. **No Authentication Required**: Any client with network access to the indexer-gRPC service can send filters
3. **Immediate Effect**: Single malicious request causes immediate panic
4. **Common Attack Vector**: Input validation failures are well-known and actively searched for by attackers
5. **Public Endpoint**: Indexer-gRPC services are typically exposed for external indexer integration

The secondary issue (invalid hex acceptance) is less likely to be intentionally exploited but could occur through client bugs or malformed data.

## Recommendation

**Immediate Fix - Add Input Validation:**

Add length and character validation before processing addresses. The function should return a `Result<String, Error>` instead of bare `String` to properly handle invalid inputs:

```rust
pub fn standardize_address(address: &str) -> Result<String, anyhow::Error> {
    let trimmed = address.strip_prefix("0x").unwrap_or(address);
    
    // Validate length
    ensure!(
        trimmed.len() <= 64,
        "Address exceeds maximum length of 64 hex characters: {} characters provided",
        trimmed.len()
    );
    
    // Validate all characters are valid hex
    ensure!(
        trimmed.chars().all(|c| c.is_ascii_hexdigit()),
        "Address contains invalid non-hexadecimal characters"
    );
    
    // Existing logic for special vs regular addresses
    if let Some(last_char) = trimmed.chars().last() {
        if trimmed[..trimmed.len().saturating_sub(1)].chars().all(|c| c == '0')
            && last_char.is_ascii_hexdigit()
            && last_char <= 'f'
        {
            let mut result = String::with_capacity(3);
            result.push_str("0x");
            result.push(last_char);
            return Ok(result);
        }
    }
    
    let mut result = String::with_capacity(66);
    result.push_str("0x");
    result.push_str(&ZEROS[..64 - trimmed.len()]);
    result.push_str(trimmed);
    Ok(result)
}
```

Update all call sites to handle the `Result` type and propagate errors appropriately through the filter validation chain.

## Proof of Concept

```rust
#[cfg(test)]
mod exploit_tests {
    use super::*;

    #[test]
    #[should_panic(expected = "index out of bounds")]
    fn test_dos_via_long_address() {
        // Construct address with 70 hex characters (exceeds max of 64)
        let malicious_address = format!("0x{}", "1".repeat(70));
        
        // This will panic when trying to slice ZEROS
        let _ = standardize_address(&malicious_address);
    }

    #[test]
    fn test_silent_invalid_hex() {
        // Address with invalid hex characters
        let invalid_address = "0xGHIJKLMN12345678";
        
        // Function returns without error, producing malformed output
        let result = standardize_address(invalid_address);
        
        // Result contains invalid hex characters 'G', 'H', etc.
        assert!(result.contains('G'));
        // This malformed address won't match any valid blockchain addresses
    }
}
```

**Reproduction Steps:**

1. Build the indexer-grpc-data-service with debug assertions enabled
2. Start the service and expose the gRPC endpoint
3. Send a `GetTransactionsRequest` with filter:
   ```json
   {
     "filter": {
       "api_filter": {
         "user_transaction_filter": {
           "sender": "0x1111111111111111111111111111111111111111111111111111111111111111111111"
         }
       }
     }
   }
   ```
4. Observe service panic with "attempt to subtract with overflow" or "index out of bounds" error
5. Service becomes unavailable for transaction filtering requests

**Notes:**

The vulnerability exists specifically in the transaction-filter utility, not in the main indexer's `standardize_address()` function (which has different implementation). The transaction-filter version is used when converting protobuf filter messages to Rust filter types, making it directly exploitable via gRPC requests. The issue affects availability rather than causing direct data corruption, as the function is used for filtering logic rather than data storage. However, service crashes prevent legitimate indexing operations, and malformed filters could cause downstream indexers to miss transactions, leading to data incompleteness.

### Citations

**File:** ecosystem/indexer-grpc/transaction-filter/src/utils.rs (L10-36)
```rust
pub fn standardize_address(address: &str) -> String {
    // Remove "0x" prefix if it exists
    let trimmed = address.strip_prefix("0x").unwrap_or(address);

    // Check if the address is a special address by seeing if the first 31 bytes are zero and the last byte is smaller than 0b10000
    if let Some(last_char) = trimmed.chars().last() {
        if trimmed[..trimmed.len().saturating_sub(1)]
            .chars()
            .all(|c| c == '0')
            && last_char.is_ascii_hexdigit()
            && last_char <= 'f'
        {
            // Return special addresses in short format
            let mut result = String::with_capacity(3);
            result.push_str("0x");
            result.push(last_char);
            return result;
        }
    }

    // Return non-special addresses in long format
    let mut result = String::with_capacity(66);
    result.push_str("0x");
    result.push_str(&ZEROS[..64 - trimmed.len()]);
    result.push_str(trimmed);
    result
}
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/filters/user_transaction.rs (L48-60)
```rust
impl From<aptos_protos::indexer::v1::UserTransactionFilter> for UserTransactionFilter {
    fn from(proto_filter: aptos_protos::indexer::v1::UserTransactionFilter) -> Self {
        Self {
            standardized_sender: OnceCell::with_value(
                proto_filter
                    .sender
                    .as_ref()
                    .map(|address| standardize_address(address)),
            ),
            sender: proto_filter.sender,
            payload: proto_filter.payload_filter.map(|f| f.into()),
        }
    }
```
