# Audit Report

## Title
Cross-Chain and Cross-Fork Replay Attack on JWK Updates Due to Missing Chain ID in Multi-Signature

## Summary
JWK update multi-signatures lack chain ID binding, enabling malicious validators to replay legitimate JWK updates across different blockchain instances (mainnet/testnet/forks) that share overlapping validator sets, violating consensus safety and keyless account security guarantees.

## Finding Description

The `QuorumCertifiedUpdate` structure used for JWK updates signs only the `ProviderJWKs` data without including chain ID, epoch, or any chain-specific context. This breaks the fundamental replay protection invariant that should prevent cross-chain transaction replay.

**Vulnerable Data Structure:** [1](#0-0) 

The signed payload contains only `issuer`, `version`, and `jwks` - no chain identifier.

**Signature Generation:** [2](#0-1) 

Validators sign `ProviderJWKs` directly without any chain-specific binding.

**Signature Verification:** [3](#0-2) 

Verification checks the multi-signature against `ProviderJWKs` but performs no chain ID validation.

**Missing Chain Context in EpochState:**

The `EpochState` structure used throughout JWK consensus contains no chain ID, only epoch number and validator verifier, providing no chain-specific binding for signatures.

**Attack Path:**

1. Legitimate JWK update occurs on Chain A (e.g., mainnet) with version increment Nâ†’N+1
2. Validators sign `QuorumCertifiedUpdate` for `ProviderJWKs{issuer, version: N+1, jwks}`
3. Malicious validator on Chain B (testnet/fork) with overlapping validator set observes this transaction
4. Malicious validator includes the identical `ValidatorTransaction::ObservedJWKUpdate` in a block on Chain B
5. Chain B execution accepts it because:
   - Signatures verify (same validator public keys, no chain binding)
   - Voting power check passes (quorum overlap)
   - Version check passes (if Chain B is also at version N)
   - **No chain ID validation exists** [4](#0-3) 

**Broken Invariants:**
- **Cryptographic Correctness**: Signatures must prevent cross-protocol replay
- **Consensus Safety**: Different chains must maintain independent state
- **Transaction Validation**: Chain ID must be verified to prevent cross-chain replay

## Impact Explanation

**Severity: CRITICAL** (up to $1,000,000)

This vulnerability enables:

1. **Consensus/Safety Violations**: Malicious validators can force identical JWK state across independent blockchain instances, violating chain independence
2. **Keyless Account Security Compromise**: JWKs control authentication for keyless accounts - replaying compromised or outdated keys across chains could enable account takeover
3. **Cross-Chain State Manipulation**: Attackers can prevent legitimate JWK rotations by replaying stale updates
4. **Fork Attack Scenarios**: During chain forks, JWK state can be manipulated to be identical even when different keys should be active

The vulnerability breaks the fundamental security boundary between independent blockchain instances.

## Likelihood Explanation

**Likelihood: MEDIUM**

**Prerequisites:**
- Malicious validator access on target chain (insider threat scenario)
- Overlapping validator sets between chains with quorum threshold
- Aligned JWK version states

**Mitigating Factors:**
- Mainnet and testnet typically have distinct validator sets
- Requires validator collusion/compromise

**Aggravating Factors:**
- Common during testing/development with shared validator keys
- Highly feasible during fork scenarios (identical validator sets at fork point)
- Test environments often reuse validator configurations

While requiring validator access, the attack is straightforward to execute when conditions are met, and the impact is severe enough to warrant critical classification.

## Recommendation

**Fix: Include chain ID in the signed message**

Modify `ProviderJWKs` or create a wrapper structure that includes chain ID:

```rust
#[derive(Clone, Eq, PartialEq, Serialize, Deserialize, CryptoHasher, BCSCryptoHash)]
pub struct ChainBoundProviderJWKs {
    pub chain_id: ChainId,
    pub epoch: u64,  // Optional: add epoch for additional binding
    pub provider_jwks: ProviderJWKs,
}
```

Update signature generation and verification to use this chain-bound structure: [2](#0-1) 

Add chain ID validation during processing: [5](#0-4) 

Fetch on-chain chain ID and verify it matches before accepting the update.

## Proof of Concept

**Conceptual PoC (Rust test scenario):**

```rust
// Setup two chains with overlapping validator sets
let chain_a_id = ChainId::mainnet();
let chain_b_id = ChainId::testnet();
let shared_validators = create_validator_set(/* shared keys */);

// On Chain A: Legitimate JWK update
let provider_jwks = ProviderJWKs {
    issuer: b"https://accounts.google.com".to_vec(),
    version: 1,
    jwks: vec![/* new keys */],
};

// Validators sign on Chain A
let signatures = validators.sign(&provider_jwks);
let multi_sig = aggregate_signatures(signatures);
let update_chain_a = QuorumCertifiedUpdate {
    update: provider_jwks.clone(),
    multi_sig: multi_sig.clone(),
};

// Chain A accepts and executes
assert!(chain_a.execute_jwk_update(update_chain_a).is_ok());

// ATTACK: Replay on Chain B
let update_chain_b = QuorumCertifiedUpdate {
    update: provider_jwks.clone(),  // Same data!
    multi_sig: multi_sig.clone(),   // Same signature!
};

// Chain B INCORRECTLY accepts because no chain ID check
assert!(chain_b.execute_jwk_update(update_chain_b).is_ok());

// Both chains now have identical JWK state despite being independent
assert_eq!(chain_a.get_jwks(), chain_b.get_jwks());
```

**Notes:**
- Actual PoC requires validator transaction pool access (validator-only)
- Demonstrates protocol-level design flaw enabling cross-chain replay
- Fix requires protocol upgrade to include chain ID in signed payload

### Citations

**File:** types/src/jwks/mod.rs (L122-128)
```rust
#[derive(Clone, Default, Eq, PartialEq, Serialize, Deserialize, CryptoHasher, BCSCryptoHash)]
pub struct ProviderJWKs {
    #[serde(with = "serde_bytes")]
    pub issuer: Issuer,
    pub version: u64,
    pub jwks: Vec<JWKMoveStruct>,
}
```

**File:** crates/aptos-jwk-consensus/src/observation_aggregation/mod.rs (L86-89)
```rust
        // Verify peer signature.
        self.epoch_state
            .verifier
            .verify(sender, &peer_view, &signature)?;
```

**File:** aptos-move/aptos-vm/src/validator_txns/jwk.rs (L100-112)
```rust
    fn process_jwk_update_inner(
        &self,
        resolver: &impl AptosMoveResolver,
        module_storage: &impl AptosModuleStorage,
        log_context: &AdapterLogSchema,
        session_id: SessionId,
        update: jwks::QuorumCertifiedUpdate,
    ) -> Result<(VMStatus, VMOutput), ExecutionFailure> {
        // Load resources.
        let validator_set =
            ValidatorSet::fetch_config(resolver).ok_or(Expected(MissingResourceValidatorSet))?;
        let observed_jwks =
            ObservedJWKs::fetch_config(resolver).ok_or(Expected(MissingResourceObservedJWKs))?;
```

**File:** aptos-move/aptos-vm/src/validator_txns/jwk.rs (L127-142)
```rust
        // Check version.
        if on_chain.version + 1 != observed.version {
            return Err(Expected(IncorrectVersion));
        }

        let authors = multi_sig.get_signers_addresses(&verifier.get_ordered_account_addresses());

        // Check voting power.
        verifier
            .check_voting_power(authors.iter(), true)
            .map_err(|_| Expected(NotEnoughVotingPower))?;

        // Verify multi-sig.
        verifier
            .verify_multi_signatures(&observed, &multi_sig)
            .map_err(|_| Expected(MultiSigVerificationFailed))?;
```
