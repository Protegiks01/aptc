# Audit Report

## Title
Unbounded Module Cache Growth in VMValidator Leads to Memory Exhaustion and Node Crashes

## Summary
The `CachedModuleView` used by `VMValidator` contains an unbounded `UnsyncModuleCache` that persists across transaction validations without size limits or eviction policies. Attackers can force validator nodes to cache unlimited modules by submitting transactions referencing different on-chain modules, causing memory exhaustion and node crashes that affect network liveness.

## Finding Description

**Clarification on Line 35:**
The security question references line 35 of `module_view.rs`, which contains the `module_cache` in the simple `ModuleView` struct. However, this specific instance is **not vulnerable** because it is created per API request and short-lived: [1](#0-0) [2](#0-1) 

Each API request creates a new `MoveConverter`, which creates a new `AptosValueAnnotator`, which creates a new `ModuleView` with a fresh HashMap. When the request completes, the cache is dropped.

**The Real Vulnerability:**
The actual exploitable vulnerability exists at line 101 in the same file - the `CachedModuleView` struct which uses an `UnsyncModuleCache`: [3](#0-2) 

This is used in `VMValidator`, which maintains a long-lived cache across all transaction validations: [4](#0-3) [5](#0-4) 

**Critical Issue:** The cache persists across transactions and is only updated (not cleared) during normal operation: [6](#0-5) 

Lines 92-93 show that `reset_state_view()` does NOT clear the module cache - only `reset_all()` at line 97 clears it, which only happens on incompatible state view changes (not during normal block progression).

**No Size Limit:** The underlying `UnsyncModuleCache` is just a HashMap with no size limits: [7](#0-6) [8](#0-7) 

Unlike the `GlobalModuleCache` used in block execution which has size checking and flushing mechanisms: [9](#0-8) 

The `VMValidator`'s cache has NO such protections.

**Attack Vector:**
1. Attacker submits transactions that call entry functions or scripts referencing different on-chain modules
2. During `validate_transaction`, these modules are loaded via `module_storage`: [10](#0-9) [11](#0-10) 

3. Each unique module is cached permanently in the `VMValidator`'s `CachedModuleView`
4. Cache grows without bounds as attacker references more modules
5. Eventually node runs out of memory and crashes

**Exploitation Requirements:**
- Modules must exist on-chain (attacker cannot cache arbitrary non-existent modules): [12](#0-11) 

- Attacker needs gas to submit transactions
- Attack is rate-limited by transaction throughput
- However, as the network matures, thousands of modules naturally exist on-chain, making the attack increasingly feasible

## Impact Explanation

**High Severity** per Aptos Bug Bounty criteria:
- **Validator node slowdowns**: As cache grows, memory pressure degrades performance
- **Node crashes**: Memory exhaustion causes validator crashes  
- **Network liveness impact**: Multiple validators crashing simultaneously affects consensus participation and block production
- **Non-recoverable without restart**: Cache only clears on incompatible state view, requiring manual intervention

This breaks the **Resource Limits** invariant (#9): "All operations must respect gas, storage, and computational limits." The unbounded cache violates memory resource limits.

## Likelihood Explanation

**High Likelihood:**
1. **Natural growth**: As Aptos network matures, more protocols deploy modules (DeFi, NFTs, gaming)
2. **Easy exploitation**: Attacker simply calls different entry functions across various protocols
3. **Persistent**: Attack accumulates over days/weeks as cache never clears during normal operation
4. **Amplification**: Type parameters in function calls (e.g., `coin::transfer<CoinType>()`) load multiple modules per transaction
5. **Low cost**: Attacker only pays normal transaction gas fees
6. **Validator pool**: The `PooledVMValidator` maintains multiple instances but each has unbounded cache: [13](#0-12) 

## Recommendation

**Solution 1: Add Size Limit and Eviction Policy**
Implement size tracking and LRU eviction similar to `GlobalModuleCache`:

```rust
impl<S: StateView> CachedModuleView<S> {
    const MAX_CACHE_SIZE_BYTES: usize = 1024 * 1024 * 512; // 512 MB limit
    
    fn check_and_flush_if_needed(&mut self) {
        let cache_size = self.module_cache.size_in_bytes();
        if cache_size > Self::MAX_CACHE_SIZE_BYTES {
            self.module_cache = UnsyncModuleCache::empty();
        }
    }
}
```

Call this after each validation in `VMValidator::validate_transaction`.

**Solution 2: Periodic Cache Clearing**
Clear cache after N transactions or time period in `notify_commit()`:

```rust
fn notify_commit(&mut self) {
    self.validation_count += 1;
    if self.validation_count >= CACHE_CLEAR_INTERVAL {
        self.state.reset_all(self.db_state_view());
        self.validation_count = 0;
    } else {
        // existing logic
    }
}
```

**Solution 3: Use Bounded LRU Cache**
Replace `UnsyncModuleCache` with a bounded LRU cache that automatically evicts least-recently-used entries.

## Proof of Concept

```rust
// Rust test demonstrating unbounded growth
#[test]
fn test_vmvalidator_unbounded_cache_growth() {
    let db = Arc::new(MockDbReader::new());
    let mut validator = PooledVMValidator::new(db.clone(), 1);
    
    // Deploy 1000 different modules to the mock blockchain
    let modules: Vec<ModuleId> = (0..1000)
        .map(|i| ModuleId::new(
            AccountAddress::random(), 
            Identifier::new(format!("Module{}", i)).unwrap()
        ))
        .collect();
    
    // Simulate 1000 transactions, each referencing a different module
    for module_id in &modules {
        let txn = create_transaction_calling_module(module_id);
        let _ = validator.validate_transaction(txn);
    }
    
    // Cache now contains all 1000 modules with no eviction
    // In production with 10,000+ modules, this causes memory exhaustion
    // No mechanism exists to clear this cache during normal operation
}

fn create_transaction_calling_module(module_id: &ModuleId) -> SignedTransaction {
    // Create transaction with entry function call to module_id
    // Transaction payload references the module, forcing it to be loaded
    // during validation
    TransactionBuilder::new()
        .entry_function(EntryFunction::new(
            module_id.clone(),
            ident_str!("some_function").to_owned(),
            vec![],
            vec![]
        ))
        .build()
}
```

**Notes:**
- While the security question references line 35 (`ModuleView`), that specific instance is not vulnerable due to per-request scoping
- The actual vulnerability exists at line 101 (`CachedModuleView`) in the same file, which exhibits the exact same unbounded growth pattern but in a long-lived, exploitable context
- The vulnerability also affects the consensus pipeline's shared `CachedModuleView`: [14](#0-13) 

- This is a time-bomb vulnerability that worsens as the network grows and more modules are deployed
- Validators should monitor memory usage and implement cache size limits immediately

### Citations

**File:** aptos-move/aptos-resource-viewer/src/lib.rs (L29-32)
```rust
    pub fn new(state_view: &'a S) -> Self {
        let view = ModuleView::new(state_view);
        Self(MoveValueAnnotator::new(view))
    }
```

**File:** api/types/src/convert.rs (L73-83)
```rust
    pub fn new(
        inner: &'a S,
        db: Arc<dyn DbReader>,
        indexer_reader: Option<Arc<dyn IndexerReader>>,
    ) -> Self {
        Self {
            inner: AptosValueAnnotator::new(inner),
            db,
            indexer_reader,
        }
    }
```

**File:** aptos-move/aptos-resource-viewer/src/module_view.rs (L93-103)
```rust
pub struct CachedModuleView<S> {
    /// The raw snapshot of the state used for validation.
    pub state_view: S,
    /// Stores configs needed for execution.
    pub environment: AptosEnvironment,
    /// Versioned cache for deserialized and verified Move modules. The versioning allows to detect
    /// when the version of the code is no longer up-to-date (a newer version has been committed to
    /// the state view) and update the cache accordingly.
    pub module_cache:
        UnsyncModuleCache<ModuleId, CompiledModule, Module, AptosModuleExtension, usize>,
}
```

**File:** aptos-move/aptos-resource-viewer/src/module_view.rs (L287-293)
```rust
        let state_value = match self
            .state_view
            .get_state_value(&StateKey::module_id(key))
            .map_err(|err| module_storage_error!(key.address(), key.name(), err))?
        {
            Some(state_value) => state_value,
            None => return Ok(None),
```

**File:** vm-validator/src/vm_validator.rs (L42-45)
```rust
struct VMValidator {
    db_reader: Arc<dyn DbReader>,
    state: CachedModuleView<CachedDbStateView>,
}
```

**File:** vm-validator/src/vm_validator.rs (L54-62)
```rust
    fn new(db_reader: Arc<dyn DbReader>) -> Self {
        let db_state_view = db_reader
            .latest_state_checkpoint_view()
            .expect("Get db view cannot fail");
        VMValidator {
            db_reader,
            state: CachedModuleView::new(db_state_view.into()),
        }
    }
```

**File:** vm-validator/src/vm_validator.rs (L76-99)
```rust
    fn notify_commit(&mut self) {
        let db_state_view = self.db_state_view();

        // On commit, we need to update the state view so that we can see the latest resources.
        let base_view_id = self.state.state_view_id();
        let new_view_id = db_state_view.id();
        match (base_view_id, new_view_id) {
            (
                StateViewId::TransactionValidation {
                    base_version: old_version,
                },
                StateViewId::TransactionValidation {
                    base_version: new_version,
                },
            ) => {
                // if the state view forms a linear history, just update the state view
                if old_version <= new_version {
                    self.state.reset_state_view(db_state_view.into());
                }
            },
            // if the version is incompatible, we flush the cache
            _ => self.state.reset_all(db_state_view.into()),
        }
    }
```

**File:** vm-validator/src/vm_validator.rs (L123-134)
```rust
pub struct PooledVMValidator {
    vm_validators: Vec<Arc<Mutex<VMValidator>>>,
}

impl PooledVMValidator {
    pub fn new(db_reader: Arc<dyn DbReader>, pool_size: usize) -> Self {
        let mut vm_validators = Vec::new();
        for _ in 0..pool_size {
            vm_validators.push(Arc::new(Mutex::new(VMValidator::new(db_reader.clone()))));
        }
        PooledVMValidator { vm_validators }
    }
```

**File:** third_party/move/move-vm/types/src/code/cache/module_cache.rs (L210-226)
```rust
/// Non-[Sync] version of module cache suitable for sequential execution.
pub struct UnsyncModuleCache<K, DC, VC, E, V> {
    module_cache: RefCell<HashMap<K, VersionedModuleCode<DC, VC, E, V>>>,
}

impl<K, DC, VC, E, V> UnsyncModuleCache<K, DC, VC, E, V>
where
    K: Eq + Hash + Clone,
    VC: Deref<Target = Arc<DC>>,
    V: Clone + Default + Ord,
{
    /// Returns an empty module cache.
    pub fn empty() -> Self {
        Self {
            module_cache: RefCell::new(HashMap::new()),
        }
    }
```

**File:** third_party/move/move-vm/types/src/code/cache/module_cache.rs (L360-362)
```rust
    fn num_modules(&self) -> usize {
        self.module_cache.borrow().len()
    }
```

**File:** aptos-move/block-executor/src/code_cache_global_manager.rs (L168-175)
```rust
        let module_cache_size_in_bytes = self.module_cache.size_in_bytes();
        GLOBAL_MODULE_CACHE_SIZE_IN_BYTES.set(module_cache_size_in_bytes as i64);
        GLOBAL_MODULE_CACHE_NUM_MODULES.set(self.module_cache.num_modules() as i64);

        // If module cache stores too many modules, flush it as well.
        if module_cache_size_in_bytes > config.max_module_cache_size_in_bytes {
            self.module_cache.flush();
        }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L3163-3168)
```rust
    fn validate_transaction(
        &self,
        transaction: SignedTransaction,
        state_view: &impl StateView,
        module_storage: &impl ModuleStorage,
    ) -> VMValidatorResult {
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L3282-3290)
```rust
        let (counter_label, result) = match self.validate_signed_transaction(
            &mut session,
            module_storage,
            &txn,
            &txn_data,
            &log_context,
            is_approved_gov_script,
            &mut TraversalContext::new(&storage),
            &mut gas_meter,
```

**File:** consensus/src/pipeline/pipeline_builder.rs (L720-730)
```rust
                    cache_mut.reset_state_view(parent_state_view);
                } else {
                    counters::RAND_BLOCK
                        .with_label_values(&["reset_cache"])
                        .inc();
                    cache_mut.reset_all(parent_state_view);
                }
            } else {
                *cache_guard = Some(CachedModuleView::new(parent_state_view));
            }
            let cache_ref = cache_guard.as_mut().expect("just set");
```
