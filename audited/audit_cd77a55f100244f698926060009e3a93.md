# Audit Report

## Title
Protocol Downgrade Attack: Missing Protocol Negotiation Enforcement in Network Layer

## Summary
The Aptos network layer fails to validate that incoming messages use protocols negotiated during the handshake. An attacker can initiate a connection negotiating newer protocols (e.g., `ConsensusRpcCompressed`), then send messages claiming to use older protocol versions (e.g., `ConsensusRpcJson`), bypassing protocol-specific security features and validation checks.

## Finding Description

During connection establishment, peers exchange `HandshakeMsg` and negotiate a common set of supported protocols through `perform_handshake()`, storing the result in `ConnectionMetadata.application_protocols`. [1](#0-0) [2](#0-1) 

However, when processing incoming messages, the `Peer` actor in `peer/mod.rs` only checks if an upstream handler exists for the claimed `protocol_id` in the message, without verifying it was part of the negotiated protocol set: [3](#0-2) 

The consensus subsystem registers multiple protocol versions simultaneously: [4](#0-3) 

For consensus observer specifically, the `protocol_id` is explicitly discarded and never validated: [5](#0-4) 

**Attack Flow:**
1. Attacker connects to a validator node
2. During handshake, negotiates to use newer protocols (e.g., `ConsensusRpcCompressed`, `ConsensusObserverRpc`)
3. After handshake completes, sends messages with `protocol_id` set to older versions (e.g., `ConsensusRpcJson`)
4. The `Peer` actor routes the message to the JSON handler without checking if JSON was negotiated
5. Message is deserialized using JSON instead of the negotiated compressed BCS format

This violates the fundamental security principle that protocol negotiation must be binding and enforced throughout the connection lifetime.

## Impact Explanation

**Severity: High** 

This vulnerability enables several attack vectors:

1. **Protocol-Specific Security Bypass**: Different protocol versions have different security properties. For example:
   - BCS protocols use `RECURSION_LIMIT = 64` with strict validation
   - JSON protocols use `serde_json` deserialization with different limits
   - Compressed protocols enforce compression bomb protection [6](#0-5) 

2. **Consensus Message Manipulation**: An attacker could force consensus messages to be processed through less-secure deserialization paths, potentially causing:
   - Different validation behavior across validators
   - Consensus splits if validators handle malformed messages differently
   - Resource exhaustion through JSON parsing of deeply nested structures

3. **Validator Node Slowdowns**: By forcing expensive JSON deserialization instead of efficient BCS, attackers can degrade validator performance, qualifying as **High Severity** per Aptos bug bounty criteria ("Validator node slowdowns").

## Likelihood Explanation

**Likelihood: High**

- **No special access required**: Any network peer can connect to validators
- **Simple exploitation**: Attacker only needs to send messages with modified `protocol_id` field
- **No detection**: No logging or monitoring alerts on protocol mismatches
- **Affects all subsystems**: Consensus, mempool, state sync, and consensus observer all vulnerable
- **Multiple validators at risk**: Attack can target the entire validator set simultaneously

The lack of validation is a fundamental design flaw affecting the core network protocol handling, making exploitation highly probable.

## Recommendation

Add protocol negotiation enforcement by validating incoming message `protocol_id` against the negotiated `application_protocols` set:

```rust
// In network/framework/src/peer/mod.rs, handle_inbound_network_message()

fn handle_inbound_network_message(
    &mut self,
    message: NetworkMessage,
) -> Result<(), PeerManagerError> {
    match &message {
        NetworkMessage::DirectSendMsg(direct) => {
            // ADD VALIDATION HERE
            if !self.connection_metadata.application_protocols.contains(direct.protocol_id) {
                warn!(
                    NetworkSchema::new(&self.network_context)
                        .connection_metadata(&self.connection_metadata),
                    protocol_id = ?direct.protocol_id,
                    "Received message with non-negotiated protocol_id, dropping"
                );
                counters::direct_send_messages(&self.network_context, "protocol_violation").inc();
                return Err(PeerManagerError::ProtocolNotNegotiated(direct.protocol_id));
            }
            
            let data_len = direct.raw_msg.len();
            // ... rest of existing code
        },
        NetworkMessage::RpcRequest(request) => {
            // ADD VALIDATION HERE
            if !self.connection_metadata.application_protocols.contains(request.protocol_id) {
                warn!(
                    NetworkSchema::new(&self.network_context)
                        .connection_metadata(&self.connection_metadata),
                    protocol_id = ?request.protocol_id,
                    "Received RPC with non-negotiated protocol_id, dropping"
                );
                counters::rpc_messages(&self.network_context, "protocol_violation", INBOUND_LABEL, DECLINED_LABEL).inc();
                return Err(PeerManagerError::ProtocolNotNegotiated(request.protocol_id));
            }
            // ... rest of existing code
        },
        // ... other cases
    }
}
```

Additionally, for consensus observer, restore protocol_id validation instead of discarding it:

```rust
// In consensus/src/consensus_observer/network/network_handler.rs

let NetworkMessage {
    peer_network_id,
    protocol_id,  // DON'T DISCARD
    consensus_observer_message,
    response_sender,
} = network_message;

// Validate expected protocols
match consensus_observer_message {
    ConsensusObserverMessage::DirectSend(_) => {
        if protocol_id != Some(ProtocolId::ConsensusObserver) {
            warn!("Unexpected protocol_id for DirectSend: {:?}", protocol_id);
            return;
        }
    },
    ConsensusObserverMessage::Request(_) => {
        if protocol_id != Some(ProtocolId::ConsensusObserverRpc) {
            warn!("Unexpected protocol_id for RPC: {:?}", protocol_id);
            return;
        }
    },
    // ...
}
```

## Proof of Concept

```rust
// Test demonstrating protocol downgrade attack
#[tokio::test]
async fn test_protocol_downgrade_attack() {
    use aptos_network::protocols::wire::handshake::v1::{HandshakeMsg, ProtocolId, ProtocolIdSet};
    use aptos_network::protocols::wire::messaging::v1::{NetworkMessage, RpcRequest};
    
    // Setup: Create two peers that will communicate
    let (peer_a, peer_b) = setup_test_peers().await;
    
    // Step 1: Attacker negotiates compressed protocol during handshake
    let mut attacker_protocols = ProtocolIdSet::empty();
    attacker_protocols.insert(ProtocolId::ConsensusRpcCompressed);
    let attacker_handshake = HandshakeMsg {
        supported_protocols: [(MessagingProtocolVersion::V1, attacker_protocols)].into(),
        chain_id: ChainId::test(),
        network_id: NetworkId::Validator,
    };
    
    // Handshake succeeds - both peers agree on ConsensusRpcCompressed
    let (negotiated_version, negotiated_protocols) = 
        peer_a.handshake.perform_handshake(&attacker_handshake).unwrap();
    
    assert!(negotiated_protocols.contains(ProtocolId::ConsensusRpcCompressed));
    assert!(!negotiated_protocols.contains(ProtocolId::ConsensusRpcJson));
    
    // Step 2: Attacker sends message claiming to use JSON protocol (not negotiated!)
    let malicious_message = NetworkMessage::RpcRequest(RpcRequest {
        protocol_id: ProtocolId::ConsensusRpcJson,  // DOWNGRADE ATTACK
        request_id: 1,
        priority: 0,
        raw_request: create_malicious_json_payload(),
    });
    
    // Step 3: Message is accepted and processed despite protocol violation
    // VULNERABILITY: No validation that protocol_id matches negotiated set
    let result = peer_a.handle_inbound_message(malicious_message).await;
    
    // This should FAIL but currently SUCCEEDS
    assert!(result.is_ok(), "Protocol downgrade attack succeeded!");
    
    // The message was deserialized as JSON instead of compressed BCS
    // This bypasses compression bomb protection and uses different security limits
}
```

**Notes:**
- The attack requires no special privileges or validator access
- Affects all protocol subsystems (consensus, mempool, state sync, consensus observer)
- Can cause validator performance degradation and potential consensus inconsistencies
- Simple fix: validate protocol_id against `ConnectionMetadata.application_protocols`

### Citations

**File:** network/framework/src/protocols/wire/handshake/v1/mod.rs (L156-172)
```rust
    fn encoding(self) -> Encoding {
        match self {
            ProtocolId::ConsensusDirectSendJson | ProtocolId::ConsensusRpcJson => Encoding::Json,
            ProtocolId::ConsensusDirectSendCompressed | ProtocolId::ConsensusRpcCompressed => {
                Encoding::CompressedBcs(RECURSION_LIMIT)
            },
            ProtocolId::ConsensusObserver => Encoding::CompressedBcs(RECURSION_LIMIT),
            ProtocolId::DKGDirectSendCompressed | ProtocolId::DKGRpcCompressed => {
                Encoding::CompressedBcs(RECURSION_LIMIT)
            },
            ProtocolId::JWKConsensusDirectSendCompressed
            | ProtocolId::JWKConsensusRpcCompressed => Encoding::CompressedBcs(RECURSION_LIMIT),
            ProtocolId::MempoolDirectSend => Encoding::CompressedBcs(USER_INPUT_RECURSION_LIMIT),
            ProtocolId::MempoolRpc => Encoding::Bcs(USER_INPUT_RECURSION_LIMIT),
            _ => Encoding::Bcs(RECURSION_LIMIT),
        }
    }
```

**File:** network/framework/src/protocols/wire/handshake/v1/mod.rs (L431-465)
```rust
    pub fn perform_handshake(
        &self,
        other: &HandshakeMsg,
    ) -> Result<(MessagingProtocolVersion, ProtocolIdSet), HandshakeError> {
        // verify that both peers are on the same chain
        if self.chain_id != other.chain_id {
            return Err(HandshakeError::InvalidChainId(
                other.chain_id,
                self.chain_id,
            ));
        }

        // verify that both peers are on the same network
        if self.network_id != other.network_id {
            return Err(HandshakeError::InvalidNetworkId(
                other.network_id,
                self.network_id,
            ));
        }

        // find the greatest common MessagingProtocolVersion where we both support
        // at least one common ProtocolId.
        for (our_handshake_version, our_protocols) in self.supported_protocols.iter().rev() {
            if let Some(their_protocols) = other.supported_protocols.get(our_handshake_version) {
                let common_protocols = our_protocols.intersect(their_protocols);

                if !common_protocols.is_empty() {
                    return Ok((*our_handshake_version, common_protocols));
                }
            }
        }

        // no intersection found
        Err(HandshakeError::NoCommonProtocols)
    }
```

**File:** network/framework/src/transport/mod.rs (L99-108)
```rust
#[derive(Clone, Deserialize, Eq, PartialEq, Serialize)]
pub struct ConnectionMetadata {
    pub remote_peer_id: PeerId,
    pub connection_id: ConnectionId,
    pub addr: NetworkAddress,
    pub origin: ConnectionOrigin,
    pub messaging_protocol: MessagingProtocolVersion,
    pub application_protocols: ProtocolIdSet,
    pub role: PeerRole,
}
```

**File:** network/framework/src/peer/mod.rs (L505-530)
```rust
            NetworkMessage::RpcRequest(request) => {
                match self.upstream_handlers.get(&request.protocol_id) {
                    None => {
                        counters::direct_send_messages(&self.network_context, UNKNOWN_LABEL).inc();
                        counters::direct_send_bytes(&self.network_context, UNKNOWN_LABEL)
                            .inc_by(request.raw_request.len() as u64);
                    },
                    Some(handler) => {
                        let sender = self.connection_metadata.remote_peer_id;
                        let network_id = self.network_context.network_id();
                        let sender = PeerNetworkId::new(network_id, sender);
                        if let Err(err) = self
                            .inbound_rpcs
                            .handle_inbound_request(handler, ReceivedMessage::new(message, sender))
                        {
                            warn!(
                                NetworkSchema::new(&self.network_context)
                                    .connection_metadata(&self.connection_metadata),
                                error = %err,
                                "{} Error handling inbound rpc request: {}",
                                self.network_context,
                                err
                            );
                        }
                    },
                }
```

**File:** consensus/src/network_interface.rs (L156-168)
```rust
/// Supported protocols in preferred order (from highest priority to lowest).
pub const RPC: &[ProtocolId] = &[
    ProtocolId::ConsensusRpcCompressed,
    ProtocolId::ConsensusRpcBcs,
    ProtocolId::ConsensusRpcJson,
];

/// Supported protocols in preferred order (from highest priority to lowest).
pub const DIRECT_SEND: &[ProtocolId] = &[
    ProtocolId::ConsensusDirectSendCompressed,
    ProtocolId::ConsensusDirectSendBcs,
    ProtocolId::ConsensusDirectSendJson,
];
```

**File:** consensus/src/consensus_observer/network/network_handler.rs (L130-156)
```rust
                Some(network_message) = self.network_service_events.next() => {
                    // Unpack the network message
                    let NetworkMessage {
                        peer_network_id,
                        protocol_id: _,
                        consensus_observer_message,
                        response_sender,
                    } = network_message;

                    // Process the consensus observer message
                    match consensus_observer_message {
                        ConsensusObserverMessage::DirectSend(message) => {
                            self.handle_observer_message(peer_network_id, message);
                        },
                        ConsensusObserverMessage::Request(request) => {
                            self.handle_publisher_message(peer_network_id, request, response_sender);
                        },
                        ConsensusObserverMessage::Response(_) => {
                            warn!(
                                LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                                    "Received unexpected response from peer: {}",
                                    peer_network_id
                                ))
                            );
                        },
                    }
                }
```
