# Audit Report

## Title
Excessive Information Exposure on Non-Mainnet Validators Due to Testnet Assumption in Config Optimizer

## Summary
The `optimize()` function in `InspectionServiceConfig` automatically enables all inspection service endpoints for non-mainnet chains (testnet, premainnet, devnet, etc.), exposing sensitive validator information including IP addresses, peer topology, and internal state. This is based on a flawed assumption that non-mainnet networks have no security requirements or value at stake.

## Finding Description

The config optimizer makes a dangerous assumption that testnet validators have no value at stake and can safely expose all debugging information. [1](#0-0) 

The code comment explicitly states "Enable all endpoints for non-mainnet nodes (to aid debugging)", and uses only `!chain_id.is_mainnet()` as the condition. This means that TESTNET (chain ID 2), PREMAINNET (chain ID 5), DEVNET (chain ID 3), and any custom chain IDs automatically expose all endpoints unless explicitly configured otherwise. [2](#0-1) 

The sanitizer only prevents mainnet validators from exposing configuration, but does not check testnet, premainnet, or other validators: [3](#0-2) 

The exposed information includes:

1. **Configuration endpoint** - Full node configuration [4](#0-3) 

2. **Identity information** - Peer IDs for validator and fullnode networks [5](#0-4) 

3. **Peer information** - Connection metadata including network addresses, trusted peers (validator set), state sync metadata, and internal client states [6](#0-5) 

The `ConnectionMetadata` structure contains network addresses that include IP addresses: [7](#0-6) 

And `NetworkAddress` contains IP address protocols: [8](#0-7) 

The inspection service binds to `0.0.0.0:9101` by default and is accessible without authentication: [9](#0-8) [10](#0-9) 

## Impact Explanation

This constitutes a **Low to Medium severity** information disclosure vulnerability based on the network's value:

**Information Disclosed:**
- Validator IP addresses and ports (enabling targeted DDoS attacks)
- Network topology and peer relationships (validator set mapping)
- Connection states and internal client metadata
- State sync status revealing synchronization vulnerabilities
- System build information

**Security Impact:**
- Enables reconnaissance for targeted attacks against validators
- Violates defense-in-depth principles by exposing internal infrastructure
- Assumes non-mainnet networks have no security requirements
- Particularly problematic for incentivized testnets or premainnet deployments with real economic value

Per Aptos bug bounty criteria, this is a **minor information leak** (Low Severity) that could potentially enable attacks leading to validator slowdowns or disruption, but does not directly cause funds loss or consensus violations.

## Likelihood Explanation

**High Likelihood:**
- The vulnerability is present in default configurations for all non-mainnet networks
- Operators must explicitly disable endpoints to prevent exposure
- Many operators may be unaware of this automatic exposure
- The inspection service is enabled by default on all nodes

**Attack Requirements:**
- Attacker needs network access to validator nodes on port 9101
- No authentication or authorization required
- Simple HTTP GET requests to exposed endpoints

## Recommendation

**Immediate Fix:** Apply the same security restrictions to testnet and premainnet validators as mainnet validators:

```rust
impl ConfigOptimizer for InspectionServiceConfig {
    fn optimize(
        node_config: &mut NodeConfig,
        local_config_yaml: &Value,
        node_type: NodeType,  // Use this parameter
        chain_id: Option<ChainId>,
    ) -> Result<bool, Error> {
        let inspection_service_config = &mut node_config.inspection_service;
        let local_inspection_config_yaml = &local_config_yaml["inspection_service"];

        // Only enable endpoints for development networks, not production-like networks
        let mut modified_config = false;
        if let Some(chain_id) = chain_id {
            // Only auto-enable for truly development networks (TESTING, local chains)
            // Do NOT auto-enable for TESTNET, PREMAINNET, or validators on any network
            let is_development_network = !chain_id.is_mainnet() 
                && !chain_id.is_testnet() 
                && !matches!(NamedChain::from_chain_id(&chain_id), Ok(NamedChain::PREMAINNET));
            
            let is_validator = node_type.is_validator();
            
            if is_development_network && !is_validator {
                // Only enable for non-validator development nodes
                if local_inspection_config_yaml["expose_configuration"].is_null() {
                    inspection_service_config.expose_configuration = true;
                    modified_config = true;
                }
                // ... similar for other endpoints
            }
        }

        Ok(modified_config)
    }
}

impl ConfigSanitizer for InspectionServiceConfig {
    fn sanitize(
        node_config: &NodeConfig,
        node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();
        let inspection_service_config = &node_config.inspection_service;

        // Prevent validators from exposing sensitive information on any production-like network
        if let Some(chain_id) = chain_id {
            if node_type.is_validator() {
                let is_production_like = chain_id.is_mainnet() 
                    || chain_id.is_testnet() 
                    || matches!(NamedChain::from_chain_id(&chain_id), Ok(NamedChain::PREMAINNET));
                
                if is_production_like && inspection_service_config.expose_configuration {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name,
                        "Validators on production-like networks should not expose node configuration!".to_string(),
                    ));
                }
                
                if is_production_like && inspection_service_config.expose_peer_information {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name,
                        "Validators on production-like networks should not expose peer information!".to_string(),
                    ));
                }
            }
        }

        Ok(())
    }
}
```

**Additional Recommendations:**
1. Add authentication/authorization to inspection service endpoints
2. Document security implications clearly in operator guides
3. Consider binding to localhost by default for validator nodes
4. Add rate limiting to prevent information gathering attacks

## Proof of Concept

**Setup:**
1. Deploy a testnet validator with default configuration
2. The optimizer automatically enables all inspection endpoints

**Exploitation:**
```bash
# Query the peer information endpoint to extract IP addresses and validator set
curl http://testnet-validator-ip:9101/peer_information

# This returns:
# - All connected peer IPs and ports
# - Validator set topology (trusted peers)
# - Connection states and metadata
# - State sync information

# Query identity information to map peer IDs
curl http://testnet-validator-ip:9101/identity_information

# Query configuration (if not explicitly disabled)
curl http://testnet-validator-ip:9101/configuration
```

**Impact:** Attacker obtains complete network topology, validator IP addresses, and connection metadata that can be used for targeted reconnaissance and attack planning.

## Notes

While this is primarily an information disclosure issue (Low severity per bug bounty criteria), it represents a **fundamental security design flaw** in the assumption that non-mainnet networks have no security requirements. For incentivized testnets or premainnet environments with real economic value, this could enable attacks that impact validator availability and network stability. The automatic opt-in behavior violates security best practices of defense-in-depth and least privilege.

### Citations

**File:** config/src/config/inspection_service_config.rs (L26-36)
```rust
impl Default for InspectionServiceConfig {
    fn default() -> InspectionServiceConfig {
        InspectionServiceConfig {
            address: "0.0.0.0".to_string(),
            port: 9101,
            expose_configuration: false,
            expose_identity_information: true,
            expose_peer_information: true,
            expose_system_information: true,
        }
    }
```

**File:** config/src/config/inspection_service_config.rs (L54-64)
```rust
        // Verify that mainnet validators do not expose the configuration
        if let Some(chain_id) = chain_id {
            if node_type.is_validator()
                && chain_id.is_mainnet()
                && inspection_service_config.expose_configuration
            {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "Mainnet validators should not expose the node configuration!".to_string(),
                ));
            }
```

**File:** config/src/config/inspection_service_config.rs (L81-104)
```rust
        // Enable all endpoints for non-mainnet nodes (to aid debugging)
        let mut modified_config = false;
        if let Some(chain_id) = chain_id {
            if !chain_id.is_mainnet() {
                if local_inspection_config_yaml["expose_configuration"].is_null() {
                    inspection_service_config.expose_configuration = true;
                    modified_config = true;
                }

                if local_inspection_config_yaml["expose_identity_information"].is_null() {
                    inspection_service_config.expose_identity_information = true;
                    modified_config = true;
                }

                if local_inspection_config_yaml["expose_peer_information"].is_null() {
                    inspection_service_config.expose_peer_information = true;
                    modified_config = true;
                }

                if local_inspection_config_yaml["expose_system_information"].is_null() {
                    inspection_service_config.expose_system_information = true;
                    modified_config = true;
                }
            }
```

**File:** types/src/chain_id.rs (L80-86)
```rust
    pub fn is_testnet(&self) -> bool {
        self.matches_named_chain(NamedChain::TESTNET)
    }

    /// Returns true iff the chain ID matches mainnet
    pub fn is_mainnet(&self) -> bool {
        self.matches_named_chain(NamedChain::MAINNET)
```

**File:** crates/aptos-inspection-service/src/server/configuration.rs (L13-26)
```rust
pub fn handle_configuration_request(node_config: &NodeConfig) -> (StatusCode, Body, String) {
    // Only return configuration if the endpoint is enabled
    let (status_code, body) = if node_config.inspection_service.expose_configuration {
        // We format the configuration using debug formatting. This is important to
        // prevent secret/private keys from being serialized and leaked (i.e.,
        // all secret keys are marked with SilentDisplay and SilentDebug).
        let encoded_configuration = format!("{:?}", node_config);
        (StatusCode::OK, Body::from(encoded_configuration))
    } else {
        (
            StatusCode::FORBIDDEN,
            Body::from(CONFIGURATION_DISABLED_MESSAGE),
        )
    };
```

**File:** crates/aptos-inspection-service/src/server/identity_information.rs (L28-51)
```rust
/// Returns a simple text formatted string with identity information
fn get_identity_information(node_config: &NodeConfig) -> String {
    let mut identity_information = Vec::<String>::new();
    identity_information.push("Identity Information:".into());

    // If the validator network is configured, fetch the identity information
    if let Some(validator_network) = &node_config.validator_network {
        identity_information.push(format!(
            "\t- Validator network ({}), peer ID: {}",
            validator_network.network_id,
            validator_network.peer_id()
        ));
    }

    // For each fullnode network, fetch the identity information
    for fullnode_network in &node_config.full_node_networks {
        identity_information.push(format!(
            "\t- Fullnode network ({}), peer ID: {}",
            fullnode_network.network_id,
            fullnode_network.peer_id()
        ));
    }

    identity_information.join("\n") // Separate each entry with a newline to construct the output
```

**File:** crates/aptos-inspection-service/src/server/peer_information.rs (L40-105)
```rust
/// Returns a simple text formatted string with peer and network information
fn get_peer_information(
    aptos_data_client: AptosDataClient,
    peers_and_metadata: Arc<PeersAndMetadata>,
) -> String {
    // Get all registered networks
    let registered_networks: Vec<NetworkId> =
        peers_and_metadata.get_registered_networks().collect();

    // Get all peers (sorted by peer ID)
    let mut all_peers = peers_and_metadata.get_all_peers();
    all_peers.sort();

    // Display a summary of all peers and networks
    let mut peer_information_output = Vec::<String>::new();
    display_peer_information_summary(
        &mut peer_information_output,
        &all_peers,
        &registered_networks,
    );
    peer_information_output.push("\n".into());

    // Display connection metadata for each peer
    display_peer_connection_metadata(
        &mut peer_information_output,
        &all_peers,
        peers_and_metadata.deref(),
    );
    peer_information_output.push("\n".into());

    // Display the entire set of trusted peers
    display_trusted_peers(
        &mut peer_information_output,
        registered_networks,
        peers_and_metadata.deref(),
    );
    peer_information_output.push("\n".into());

    // Display basic peer metadata for each peer
    display_peer_monitoring_metadata(
        &mut peer_information_output,
        &all_peers,
        peers_and_metadata.deref(),
    );
    peer_information_output.push("\n".into());

    // Display state sync metadata for each peer
    display_state_sync_metadata(&mut peer_information_output, &all_peers, aptos_data_client);
    peer_information_output.push("\n".into());

    // Display detailed peer metadata for each peer
    display_detailed_monitoring_metadata(
        &mut peer_information_output,
        &all_peers,
        peers_and_metadata.deref(),
    );
    peer_information_output.push("\n".into());

    // Display the internal client state for each peer
    display_internal_client_state(
        &mut peer_information_output,
        &all_peers,
        peers_and_metadata.deref(),
    );

    peer_information_output.join("\n") // Separate each entry with a newline to construct the output
```

**File:** network/framework/src/transport/mod.rs (L98-108)
```rust
/// Metadata associated with an established and fully upgraded connection.
#[derive(Clone, Deserialize, Eq, PartialEq, Serialize)]
pub struct ConnectionMetadata {
    pub remote_peer_id: PeerId,
    pub connection_id: ConnectionId,
    pub addr: NetworkAddress,
    pub origin: ConnectionOrigin,
    pub messaging_protocol: MessagingProtocolVersion,
    pub application_protocols: ProtocolIdSet,
    pub role: PeerRole,
}
```

**File:** types/src/network_address/mod.rs (L110-127)
```rust
/// A single protocol in the [`NetworkAddress`] protocol stack.
#[derive(Clone, Debug, Eq, Hash, PartialEq, Deserialize, Serialize)]
#[cfg_attr(any(test, feature = "fuzzing"), derive(Arbitrary))]
pub enum Protocol {
    Ip4(Ipv4Addr),
    Ip6(Ipv6Addr),
    Dns(DnsName),
    Dns4(DnsName),
    Dns6(DnsName),
    Tcp(u16),
    Memory(u16),
    // human-readable x25519::PublicKey is lower-case hex encoded
    NoiseIK(x25519::PublicKey),
    // TODO(philiphayes): use actual handshake::MessagingProtocolVersion. we
    // probably need to move network wire into its own crate to avoid circular
    // dependency b/w network and types.
    Handshake(u8),
}
```

**File:** crates/aptos-inspection-service/src/server/mod.rs (L54-69)
```rust
) {
    // Fetch the service port and address
    let service_port = node_config.inspection_service.port;
    let service_address = node_config.inspection_service.address.clone();

    // Create the inspection service socket address
    let address: SocketAddr = (service_address.as_str(), service_port)
        .to_socket_addrs()
        .unwrap_or_else(|_| {
            panic!(
                "Failed to parse {}:{} as address",
                service_address, service_port
            )
        })
        .next()
        .unwrap();
```
