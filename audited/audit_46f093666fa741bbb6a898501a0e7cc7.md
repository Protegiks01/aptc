# Audit Report

## Title
Transaction Filter Bypass via Multisig Stored Payload Execution

## Summary
The transaction filtering system in Aptos mempool and consensus can be bypassed by attackers using multisig transactions with stored payloads. The `matches_entry_function_module_address()` function only inspects the inline transaction payload, not the payload that will actually be executed from on-chain storage, allowing prohibited module addresses to be invoked despite active filter rules.

## Finding Description

The Aptos transaction filtering system is designed to allow node operators to deny transactions based on various criteria, including the module address being called. This is critical for regulatory compliance, sanctions enforcement, and blocking known vulnerable contracts.

The vulnerability exists in how the filter handles multisig transactions with stored payloads: [1](#0-0) 

For `TransactionPayload::Multisig`, the function checks if `transaction_payload` exists inline. However, multisig transactions can have `transaction_payload: None`, indicating the payload is stored on-chain: [2](#0-1) 

When a multisig transaction with `None` payload reaches the filter, the logic returns `false` (no match), allowing the transaction through: [3](#0-2) 

During execution, the actual payload is retrieved from on-chain storage via `get_next_transaction_payload()`: [4](#0-3) [5](#0-4) 

**Attack Scenario:**

1. Node operator configures filter: `Deny(ModuleAddress(0xSANCTIONED))`
2. Attacker creates multisig account and stores malicious transaction calling `0xSANCTIONED::exploit::steal()`
3. Attacker submits `TransactionPayload::Multisig` with `transaction_payload: None`
4. Filter inspects inline payload, finds `None`, returns `false` (no match)
5. Transaction passes through mempool and consensus filters
6. During execution, stored payload is retrieved and malicious code executes

The same vulnerability exists for:
- `TransactionPayload::Payload(V1)` with `Empty` executable and multisig_address set
- `TransactionPayload::EncryptedPayload` that fails decryption or contains `Empty` executable

## Impact Explanation

**High Severity** - This constitutes a significant protocol violation per Aptos bug bounty criteria:

1. **Security Control Bypass**: Completely undermines transaction filtering, a critical security feature for node operators
2. **Regulatory Compliance Failure**: Nodes intending to comply with sanctions or regulatory requirements can be forced to execute prohibited transactions
3. **Attack Surface Expansion**: Allows attackers to invoke known vulnerable or malicious contracts that operators explicitly blocked
4. **Network-Wide Impact**: Affects all nodes running transaction filters in both mempool and consensus layers

While this doesn't directly cause loss of funds or consensus safety violations, it represents a fundamental failure of an access control mechanism that node operators rely on for security and compliance. [6](#0-5) [7](#0-6) 

## Likelihood Explanation

**High Likelihood** - This vulnerability is easily exploitable:

1. **No Special Privileges Required**: Any user can create multisig accounts and store transactions
2. **Standard Feature Usage**: Multisig with stored payloads is a documented, intended feature
3. **No Detection**: Operators cannot distinguish malicious from legitimate stored payload executions
4. **Deterministic Bypass**: Works 100% of the time once set up
5. **Multiple Attack Vectors**: Works via Multisig, Payload(V1), and EncryptedPayload variants

The attack requires minimal setup: create multisig account, store malicious transaction, get approvals, submit with `None` payload.

## Recommendation

The filter must inspect the **actual** payload that will be executed, not just the inline payload. This requires retrieving stored payloads during filtering.

**Recommended Fix:**

Modify `matches_entry_function_module_address()` to handle stored payloads:

```rust
TransactionPayload::Multisig(multisig) => {
    // Check inline payload if present
    let inline_match = multisig
        .transaction_payload
        .as_ref()
        .map(|payload| match payload {
            MultisigTransactionPayload::EntryFunction(entry_function) => {
                compare_entry_function_module_address(entry_function, module_address)
            },
        })
        .unwrap_or(false);
    
    // If no inline payload, must check stored payload
    // This requires resolver access to query on-chain state
    if !inline_match && multisig.transaction_payload.is_none() {
        // Query multisig_account storage to get actual payload
        // and check its module address
        // Implementation requires resolver parameter addition
    }
    
    inline_match
}
```

**Alternative Approaches:**
1. **Reject stored-payload transactions entirely** in filters (conservative, breaks legitimate use)
2. **Add metadata to multisig transactions** indicating the stored payload's module address
3. **Filter at execution time** instead of submission time (less efficient but more accurate)

The proper solution requires architectural changes to make stored payload inspection possible during filtering, potentially requiring state access in the filter layer.

## Proof of Concept

```rust
#[test]
fn test_multisig_stored_payload_filter_bypass() {
    use aptos_types::transaction::{
        Multisig, MultisigTransactionPayload, TransactionPayload, EntryFunction,
        SignedTransaction, RawTransaction,
    };
    use aptos_crypto::{ed25519::Ed25519PrivateKey, PrivateKey, Uniform};
    use move_core_types::{account_address::AccountAddress, identifier::Identifier};
    use aptos_transaction_filters::transaction_filter::TransactionFilter;
    
    // Setup: Create filter denying module address 0xBAD
    let bad_module = AccountAddress::from_hex_literal("0xBAD").unwrap();
    let filter = TransactionFilter::empty()
        .add_module_address_filter(false, bad_module); // Deny
    
    // Step 1: Create legitimate inline multisig transaction
    // This SHOULD be denied by filter
    let entry_function = EntryFunction::new(
        ModuleId::new(bad_module, Identifier::new("exploit").unwrap()),
        Identifier::new("steal").unwrap(),
        vec![],
        vec![],
    );
    let inline_multisig = Multisig {
        multisig_address: AccountAddress::random(),
        transaction_payload: Some(MultisigTransactionPayload::EntryFunction(entry_function.clone())),
    };
    let inline_txn = create_signed_transaction(TransactionPayload::Multisig(inline_multisig));
    
    // Verify inline transaction is correctly denied
    assert!(!filter.allows_transaction(&inline_txn), "Inline payload should be denied");
    
    // Step 2: Create stored-payload multisig transaction
    // This BYPASSES the filter despite calling same module
    let stored_multisig = Multisig {
        multisig_address: AccountAddress::random(),
        transaction_payload: None, // Payload stored on-chain
    };
    let stored_txn = create_signed_transaction(TransactionPayload::Multisig(stored_multisig));
    
    // VULNERABILITY: Transaction is allowed despite calling denied module
    assert!(filter.allows_transaction(&stored_txn), "Stored payload bypasses filter");
    
    // In actual execution, get_next_transaction_payload() would retrieve
    // the stored entry_function calling 0xBAD::exploit::steal
    // and execute it despite the filter
}

fn create_signed_transaction(payload: TransactionPayload) -> SignedTransaction {
    let private_key = Ed25519PrivateKey::generate_for_testing();
    let raw_txn = RawTransaction::new(
        AccountAddress::random(),
        0,
        payload,
        1000000,
        1,
        u64::MAX,
        aptos_types::chain_id::ChainId::test(),
    );
    SignedTransaction::new(raw_txn, private_key.public_key(), private_key.sign(&raw_txn).unwrap())
}
```

**Expected Behavior**: Both transactions should be denied
**Actual Behavior**: Only inline transaction is denied; stored-payload transaction bypasses filter

This PoC demonstrates that the filter cannot inspect stored payloads, creating a complete bypass of module address filtering for multisig transactions.

### Citations

**File:** crates/aptos-transaction-filters/src/transaction_filter.rs (L377-418)
```rust
/// Returns true iff the transaction's module address matches the given account address
fn matches_entry_function_module_address(
    signed_transaction: &SignedTransaction,
    module_address: &AccountAddress,
) -> bool {
    // Match all variants explicitly to ensure future enum changes are caught during compilation
    match signed_transaction.payload() {
        TransactionPayload::Script(_) | TransactionPayload::ModuleBundle(_) => false,
        TransactionPayload::Multisig(multisig) => multisig
            .transaction_payload
            .as_ref()
            .map(|payload| match payload {
                MultisigTransactionPayload::EntryFunction(entry_function) => {
                    compare_entry_function_module_address(entry_function, module_address)
                },
            })
            .unwrap_or(false),
        TransactionPayload::EntryFunction(entry_function) => {
            compare_entry_function_module_address(entry_function, module_address)
        },
        TransactionPayload::Payload(TransactionPayloadInner::V1 { executable, .. }) => {
            match executable.as_ref() {
                TransactionExecutableRef::Script(_) | TransactionExecutableRef::Empty => false,
                TransactionExecutableRef::EntryFunction(entry_function) => {
                    compare_entry_function_module_address(entry_function, module_address)
                },
            }
        },
        TransactionPayload::EncryptedPayload(payload) => {
            if let Ok(executable) = payload.executable_ref() {
                match executable {
                    TransactionExecutableRef::Script(_) | TransactionExecutableRef::Empty => false,
                    TransactionExecutableRef::EntryFunction(entry_function) => {
                        compare_entry_function_module_address(entry_function, module_address)
                    },
                }
            } else {
                false
            }
        },
    }
}
```

**File:** types/src/transaction/multisig.rs (L12-17)
```rust
pub struct Multisig {
    pub multisig_address: AccountAddress,

    // Transaction payload is optional if already stored on chain.
    pub transaction_payload: Option<MultisigTransactionPayload>,
}
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1221-1250)
```rust
            TransactionExecutableRef::Empty => {
                // Default to empty bytes if payload is not provided.
                if self
                    .features()
                    .is_abort_if_multisig_payload_mismatch_enabled()
                {
                    vec![]
                } else {
                    bcs::to_bytes::<Vec<u8>>(&vec![]).map_err(|_| invariant_violation_error())?
                }
            },
            TransactionExecutableRef::Script(_) => {
                let s = VMStatus::error(
                    StatusCode::FEATURE_UNDER_GATING,
                    Some("Multisig transaction does not support script payload".to_string()),
                );
                return Ok((s, discarded_output(StatusCode::FEATURE_UNDER_GATING)));
            },
        };
        // Failures here will be propagated back.
        let payload_bytes: Vec<Vec<u8>> = session
            .execute(|session| {
                session.execute_function_bypass_visibility(
                    &MULTISIG_ACCOUNT_MODULE,
                    GET_NEXT_TRANSACTION_PAYLOAD,
                    vec![],
                    serialize_values(&vec![
                        MoveValue::Address(multisig_address),
                        MoveValue::vector_u8(provided_payload),
                    ]),
```

**File:** aptos-move/framework/aptos-framework/sources/multisig_account.move (L393-404)
```text
    public fun get_next_transaction_payload(
        multisig_account: address, provided_payload: vector<u8>): vector<u8> acquires MultisigAccount {
        let multisig_account_resource = borrow_global<MultisigAccount>(multisig_account);
        let sequence_number = multisig_account_resource.last_executed_sequence_number + 1;
        let transaction = table::borrow(&multisig_account_resource.transactions, sequence_number);

        if (option::is_some(&transaction.payload)) {
            *option::borrow(&transaction.payload)
        } else {
            provided_payload
        }
    }
```

**File:** mempool/src/shared_mempool/tasks.rs (L1-1)
```rust
// Copyright (c) Aptos Foundation
```

**File:** consensus/src/payload_manager/direct_mempool_payload_manager.rs (L1-1)
```rust
// Copyright (c) Aptos Foundation
```
