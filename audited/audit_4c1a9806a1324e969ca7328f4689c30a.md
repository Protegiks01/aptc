# Audit Report

## Title
Transaction Size Validation Bypass via Oversized Authenticators Enabling Memory Exhaustion

## Summary
The `VMValidator::validate_transaction()` implementation only validates the raw transaction size (excluding authenticator) against the 64 KB limit, while the full signed transaction (including authenticator) is loaded into memory. Attackers can craft transactions with small raw transactions but large authenticators (up to 128+ KB) to bypass size validation and exhaust node memory.

## Finding Description

The transaction size validation in the VM validator has a critical gap that allows oversized transactions to bypass size limits:

**The Core Issue:**

When transactions are validated, the `TransactionMetadata` struct captures only the raw transaction size: [1](#0-0) 

This `transaction_size` field excludes the authenticator (signatures, public keys, etc.) and only includes the unsigned transaction bytes. Later, this incomplete size is used for validation: [2](#0-1) 

The validation checks `transaction_size` against `max_transaction_size_in_bytes` (64 KB), but this only validates the raw transaction portion.

**The Attack Vector:**

Transaction authenticators can be extremely large:
- `MAX_NUM_OF_SIGS` allows up to 32 signatures [3](#0-2) 

- Each `KeylessSignature` can be up to 4000 bytes [4](#0-3) 

- A FeePayer transaction with multiple secondary signers can have authenticators totaling 128+ KB

**Memory Consumption Path:**

The full signed transaction (raw + authenticator) is loaded into memory at multiple stages:

1. During validation, the full transaction is processed [5](#0-4) 

2. In mempool, the size accounting also uses only raw transaction size [6](#0-5) 

This means mempool capacity tracking is also incorrect, counting transactions at ~1 KB when they actually consume 128+ KB.

**Exploitation Scenario:**

1. Attacker creates transactions with:
   - Raw transaction: 1 KB (well under 64 KB limit)
   - Authenticator: 127 KB (FeePayer with 32 keyless signatures)
   - Total: 128 KB

2. Transaction passes size validation (only checks 1 KB)

3. Full 128 KB transaction is loaded into memory during:
   - Network transmission
   - Mempool storage (counted as only 1 KB toward capacity)
   - VM validation and execution

4. Attacker floods mempool with such transactions, causing 128x memory amplification

5. Node experiences memory exhaustion, degraded performance, or crashes

## Impact Explanation

This is a **Medium Severity** vulnerability per the Aptos bug bounty criteria:

- **State inconsistencies requiring intervention**: Nodes may crash or require restart due to memory exhaustion, causing temporary state inconsistencies
- **Validator node slowdowns**: Affected nodes experience significant performance degradation
- **Limited DoS impact**: While this can affect node availability, it doesn't cause permanent consensus violations or fund loss

The vulnerability doesn't qualify as High/Critical because:
- It doesn't directly lead to fund theft or consensus safety violations
- Requires sustained attack to maintain impact
- Node operators can recover by restarting nodes
- Network-level rate limiting provides some mitigation

However, it's more severe than Low because:
- Can affect multiple validator nodes simultaneously
- Mempool capacity miscalculation can prevent legitimate transactions
- Memory exhaustion can cascade to other node components

## Likelihood Explanation

**Likelihood: High**

This vulnerability is highly likely to be exploited because:

1. **Low Attack Complexity**: Crafting oversized authenticators requires only:
   - Creating a FeePayer transaction with multiple secondary signers
   - Using keyless signatures (which are legitimate and supported)
   - No special permissions or validator access needed

2. **Wide Attack Surface**: Any transaction submitter can exploit this via:
   - Direct node API submission
   - Mempool gossip network
   - Public fullnode endpoints

3. **Economically Rational**: Attack cost is minimal:
   - Only needs to pay gas for small raw transaction
   - Can flood mempool with 128x memory amplification
   - Single attacker can affect multiple nodes

4. **Detection Difficulty**: Hard to distinguish from legitimate traffic:
   - Keyless signatures are valid features
   - Multi-signer transactions are normal
   - Size appears valid (passes validation)

## Recommendation

Implement comprehensive transaction size validation that includes the authenticator:

1. **Modify TransactionMetadata to track full transaction size:**

```rust
// In aptos-move/aptos-vm/src/transaction_metadata.rs
pub struct TransactionMetadata {
    // ... existing fields ...
    pub transaction_size: NumBytes,  // Raw transaction only
    pub total_transaction_size: NumBytes,  // Raw + authenticator
    // ... rest of fields ...
}

impl TransactionMetadata {
    pub fn new(txn: &SignedTransaction, auxiliary_info: &AuxiliaryInfo) -> Self {
        Self {
            // ... existing fields ...
            transaction_size: (txn.raw_txn_bytes_len() as u64).into(),
            total_transaction_size: (txn.txn_bytes_len() as u64).into(),
            // ... rest of initialization ...
        }
    }
}
```

2. **Add total size validation in check_gas():**

```rust
// In aptos-move/aptos-vm/src/gas.rs
pub(crate) fn check_gas(
    // ... existing parameters ...
) -> Result<(), VMStatus> {
    let raw_bytes_len = txn_metadata.transaction_size;
    let total_bytes_len = txn_metadata.total_transaction_size;
    
    // Validate raw transaction size (existing check)
    if raw_bytes_len > txn_gas_params.max_transaction_size_in_bytes {
        // ... existing error ...
    }
    
    // NEW: Validate total transaction size
    let max_total_size = if is_approved_gov_script {
        txn_gas_params.max_transaction_size_in_bytes_gov
    } else {
        txn_gas_params.max_transaction_size_in_bytes
    };
    
    if total_bytes_len > max_total_size {
        return Err(VMStatus::error(
            StatusCode::EXCEEDED_MAX_TRANSACTION_SIZE,
            Some(format!(
                "Total transaction size {} exceeds maximum {}",
                total_bytes_len, max_total_size
            )),
        ));
    }
    
    // ... rest of existing checks ...
}
```

3. **Update mempool size tracking:**

```rust
// In mempool/src/core_mempool/transaction.rs
pub(crate) fn get_estimated_bytes(&self) -> usize {
    // Use full transaction size instead of just raw transaction
    self.txn.txn_bytes_len() + TXN_FIXED_ESTIMATED_BYTES + TXN_INDEX_ESTIMATED_BYTES
}
```

## Proof of Concept

```rust
// Test demonstrating the vulnerability
// File: aptos-move/aptos-vm/src/transaction_size_bypass_test.rs

#[cfg(test)]
mod transaction_size_bypass_tests {
    use super::*;
    use aptos_types::transaction::{
        TransactionAuthenticator, AccountAuthenticator, SignedTransaction,
        RawTransaction, TransactionPayload, Script,
    };
    use aptos_crypto::ed25519::Ed25519PrivateKey;
    
    #[test]
    fn test_oversized_authenticator_bypasses_validation() {
        // Create a small raw transaction (1 KB)
        let small_script = Script::new(vec![0u8; 1024], vec![], vec![]);
        let raw_txn = RawTransaction::new_script(
            AccountAddress::random(),
            0,
            small_script,
            1000000,
            1,
            u64::MAX,
            ChainId::test(),
        );
        
        // Create authenticator with 32 keyless signatures
        // Each KeylessSignature can be up to 4000 bytes
        // Total authenticator: ~128 KB
        let mut secondary_signers = vec![];
        for _ in 0..31 {
            // Create large keyless signature (4000 bytes each)
            let keyless_sig = create_large_keyless_signature();
            secondary_signers.push(AccountAuthenticator::SingleKey {
                authenticator: SingleKeyAuthenticator::new(
                    AnyPublicKey::keyless(/* ... */),
                    AnySignature::Keyless { signature: keyless_sig },
                ),
            });
        }
        
        let authenticator = TransactionAuthenticator::FeePayer {
            sender: create_large_keyless_authenticator(),
            secondary_signer_addresses: vec![AccountAddress::random(); 31],
            secondary_signers,
            fee_payer_address: AccountAddress::random(),
            fee_payer_signer: create_large_keyless_authenticator(),
        };
        
        let signed_txn = SignedTransaction::new(raw_txn, authenticator);
        
        // Verify the bypass:
        // 1. Raw transaction is only ~1 KB
        assert!(signed_txn.raw_txn_bytes_len() < 2000);
        
        // 2. But full transaction is ~128 KB
        assert!(signed_txn.txn_bytes_len() > 120_000);
        
        // 3. Passes size validation (only checks raw_txn_bytes_len)
        let txn_metadata = TransactionMetadata::new(&signed_txn, &auxiliary_info);
        assert!(txn_metadata.transaction_size < NumBytes::new(64 * 1024));
        
        // 4. But actually consumes 128 KB in memory
        // This demonstrates the 128x memory amplification attack
        println!("Raw transaction size: {} bytes", signed_txn.raw_txn_bytes_len());
        println!("Full transaction size: {} bytes", signed_txn.txn_bytes_len());
        println!("Validation checks: {} bytes", txn_metadata.transaction_size);
        println!("Actual memory usage: {} bytes", signed_txn.txn_bytes_len());
    }
}
```

## Notes

- The vulnerability affects both transaction validation and mempool capacity tracking
- The 128x amplification factor allows effective DoS with minimal transaction costs
- Fix requires changes to both VM validation and mempool accounting
- Backward compatibility: New size limit enforcement may reject some existing valid transactions with large authenticators, but this is necessary for security
- Consider also adding authenticator-specific size limits in addition to total transaction size limits

### Citations

**File:** aptos-move/aptos-vm/src/transaction_metadata.rs (L63-63)
```rust
            transaction_size: (txn.raw_txn_bytes_len() as u64).into(),
```

**File:** aptos-move/aptos-vm/src/gas.rs (L81-121)
```rust
    let raw_bytes_len = txn_metadata.transaction_size;

    if is_approved_gov_script {
        let max_txn_size_gov = if gas_feature_version >= RELEASE_V1_13 {
            gas_params.vm.txn.max_transaction_size_in_bytes_gov
        } else {
            MAXIMUM_APPROVED_TRANSACTION_SIZE_LEGACY.into()
        };

        if txn_metadata.transaction_size > max_txn_size_gov
            // Ensure that it is only the approved payload that exceeds the
            // maximum. The (unknown) user input should be restricted to the original
            // maximum transaction size.
            || txn_metadata.transaction_size
                > txn_metadata.script_size + txn_gas_params.max_transaction_size_in_bytes
        {
            speculative_warn!(
                log_context,
                format!(
                    "[VM] Governance transaction size too big {} payload size {}",
                    txn_metadata.transaction_size, txn_metadata.script_size,
                ),
            );
            return Err(VMStatus::error(
                StatusCode::EXCEEDED_MAX_TRANSACTION_SIZE,
                None,
            ));
        }
    } else if txn_metadata.transaction_size > txn_gas_params.max_transaction_size_in_bytes {
        speculative_warn!(
            log_context,
            format!(
                "[VM] Transaction size too big {} (max {})",
                txn_metadata.transaction_size, txn_gas_params.max_transaction_size_in_bytes
            ),
        );
        return Err(VMStatus::error(
            StatusCode::EXCEEDED_MAX_TRANSACTION_SIZE,
            None,
        ));
    }
```

**File:** types/src/transaction/authenticator.rs (L34-34)
```rust
pub const MAX_NUM_OF_SIGS: usize = 32;
```

**File:** types/src/keyless/mod.rs (L195-195)
```rust
    pub const MAX_LEN: usize = 4000;
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L3163-3168)
```rust
    fn validate_transaction(
        &self,
        transaction: SignedTransaction,
        state_view: &impl StateView,
        module_storage: &impl ModuleStorage,
    ) -> VMValidatorResult {
```

**File:** mempool/src/core_mempool/transaction.rs (L70-72)
```rust
    pub(crate) fn get_estimated_bytes(&self) -> usize {
        self.txn.raw_txn_bytes_len() + TXN_FIXED_ESTIMATED_BYTES + TXN_INDEX_ESTIMATED_BYTES
    }
```
