# Audit Report

## Title
BCS vs JSON Type Mismatch in Events API Causes Client Deserialization Failures

## Summary
The `list()` function in `api/src/events.rs` returns different data types for BCS and JSON accept types, violating the API contract and causing deserialization failures for third-party BCS clients. JSON responses return `Vec<VersionedEvent>` (with decoded event data), while BCS responses return `Vec<EventWithVersion>` (with raw event bytes), despite the API signature promising `Vec<VersionedEvent>` for both.

## Finding Description
The vulnerability exists in the events API endpoint implementation where the response type diverges based on the accept type: [1](#0-0) 

In the JSON code path, the raw storage events (`Vec<EventWithVersion>`) are converted to API-formatted events (`Vec<VersionedEvent>`) via `try_into_versioned_events()`, which decodes the raw event bytes into JSON. [2](#0-1) 

However, the BCS code path returns the raw storage events directly without conversion, despite the function signature declaring a return type of `BasicResultWith404<Vec<VersionedEvent>>`. [3](#0-2) 

The two types have fundamentally different structures:

**EventWithVersion** (storage format): [4](#0-3) 

**VersionedEvent** (API format): [5](#0-4) 

The key difference is that `EventWithVersion` contains raw BCS-encoded event data as bytes, while `VersionedEvent` contains decoded event data as `serde_json::Value`. The official SDK works around this issue by explicitly expecting `Vec<EventWithVersion>` for BCS responses. [6](#0-5) 

This creates a critical inconsistency where:
1. Third-party clients following the API signature expect `Vec<VersionedEvent>` for both accept types
2. BCS clients receive `Vec<EventWithVersion>` instead, causing BCS deserialization to fail
3. The event data format differs (raw bytes vs decoded JSON)
4. Different clients using different accept types observe fundamentally different data structures

## Impact Explanation
This qualifies as **Medium Severity** under the Aptos bug bounty program criteria for the following reasons:

1. **State Inconsistencies**: Applications using both JSON and BCS endpoints would observe different data structures and event data formats, potentially causing application-level state divergence

2. **Client Failures**: Third-party BCS clients trusting the API contract would experience deserialization failures when attempting to parse responses as `Vec<VersionedEvent>`, as the actual payload contains `Vec<EventWithVersion>` with incompatible field structures

3. **Data Integrity Violation**: The raw event bytes in `EventWithVersion` versus decoded JSON in `VersionedEvent` means the same event data is represented in fundamentally different formats, violating the expectation that BCS and JSON are equivalent serializations

4. **API Contract Breach**: The function signature explicitly promises `Vec<VersionedEvent>` but delivers different types based on accept headers, breaking type safety guarantees

While this does not directly compromise blockchain consensus or enable fund theft, it creates reliability and interoperability issues that can cause application failures requiring manual intervention.

## Likelihood Explanation
**Likelihood: High**

This issue will be encountered by:
- Any third-party client implementing BCS support based on the API documentation
- Any application that switches between JSON and BCS accept types expecting equivalent data
- Integration tools that validate BCS responses against the declared schema

The official Aptos SDK works around this bug by explicitly expecting the wrong type, but this creates vendor lock-in and prevents proper API ecosystem development. The issue is trivially triggered by simply requesting events with the `Accept: application/x-bcs` header.

## Recommendation
The BCS response path must apply the same conversion as the JSON path to ensure type consistency. Modify the `list()` function to convert events for BCS responses:

```rust
fn list(
    &self,
    latest_ledger_info: LedgerInfo,
    accept_type: AcceptType,
    page: Page,
    event_key: EventKey,
) -> BasicResultWith404<Vec<VersionedEvent>> {
    let ledger_version = latest_ledger_info.version();
    let events = self.context.get_events(...)?;

    // Convert events for both JSON and BCS to ensure consistency
    let converted_events = self
        .context
        .latest_state_view_poem(&latest_ledger_info)?
        .as_converter(self.context.db.clone(), self.context.indexer_reader.clone())
        .try_into_versioned_events(&events)
        .context("Failed to convert events from storage into response")
        .map_err(|err| {
            BasicErrorWith404::internal_with_code(
                err,
                AptosErrorCode::InternalError,
                &latest_ledger_info,
            )
        })?;

    match accept_type {
        AcceptType::Json => {
            BasicResponse::try_from_json((converted_events, &latest_ledger_info, BasicResponseStatus::Ok))
        },
        AcceptType::Bcs => {
            BasicResponse::try_from_bcs((converted_events, &latest_ledger_info, BasicResponseStatus::Ok))
        },
    }
}
```

This ensures both accept types return the same `Vec<VersionedEvent>` structure with decoded event data, matching the API signature and maintaining type safety.

## Proof of Concept

```rust
#[tokio::test]
async fn test_events_bcs_json_divergence() {
    use aptos_api_types::VersionedEvent;
    use aptos_types::contract_event::EventWithVersion;
    
    let context = new_test_context("test_events_divergence");
    
    // Request events with JSON accept type
    let json_response = context
        .get("/accounts/0x1/events/0x1::reconfiguration::Configuration/events")
        .await;
    
    // Request events with BCS accept type
    let bcs_response_bytes = context
        .get_bcs("/accounts/0x1/events/0x1::reconfiguration::Configuration/events")
        .await;
    
    // Try to deserialize BCS response as the declared type (Vec<VersionedEvent>)
    let versioned_events_result: Result<Vec<VersionedEvent>, _> = 
        bcs::from_bytes(&bcs_response_bytes);
    
    // This will FAIL because BCS actually contains Vec<EventWithVersion>
    assert!(versioned_events_result.is_err(), 
        "BCS deserialization as Vec<VersionedEvent> should fail due to type mismatch");
    
    // But deserializing as the actual type works (proving the divergence)
    let event_with_version: Vec<EventWithVersion> = 
        bcs::from_bytes(&bcs_response_bytes).unwrap();
    
    // The types are fundamentally different
    assert_ne!(
        std::any::TypeId::of::<VersionedEvent>(),
        std::any::TypeId::of::<EventWithVersion>(),
        "Types differ between JSON and BCS responses"
    );
}
```

This test demonstrates that BCS clients following the API contract will fail to deserialize responses, while clients that know to expect the wrong type can work around the issue. The divergence creates an interoperability barrier for the API ecosystem.

### Citations

**File:** api/src/events.rs (L161-161)
```rust
    ) -> BasicResultWith404<Vec<VersionedEvent>> {
```

**File:** api/src/events.rs (L180-201)
```rust
        match accept_type {
            AcceptType::Json => {
                let events = self
                    .context
                    .latest_state_view_poem(&latest_ledger_info)?
                    .as_converter(self.context.db.clone(), self.context.indexer_reader.clone())
                    .try_into_versioned_events(&events)
                    .context("Failed to convert events from storage into response")
                    .map_err(|err| {
                        BasicErrorWith404::internal_with_code(
                            err,
                            AptosErrorCode::InternalError,
                            &latest_ledger_info,
                        )
                    })?;

                BasicResponse::try_from_json((events, &latest_ledger_info, BasicResponseStatus::Ok))
            },
            AcceptType::Bcs => {
                BasicResponse::try_from_bcs((events, &latest_ledger_info, BasicResponseStatus::Ok))
            },
        }
```

**File:** api/types/src/convert.rs (L612-624)
```rust
    pub fn try_into_versioned_events(
        &self,
        events: &[EventWithVersion],
    ) -> Result<Vec<VersionedEvent>> {
        let mut ret = vec![];
        for event in events {
            let data = self
                .inner
                .view_value(event.event.type_tag(), event.event.event_data())?;
            ret.push((event, MoveValue::try_from(data)?.json()?).into());
        }
        Ok(ret)
    }
```

**File:** types/src/contract_event.rs (L420-425)
```rust
#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize)]
#[cfg_attr(any(test, feature = "fuzzing"), derive(Arbitrary))]
pub struct EventWithVersion {
    pub transaction_version: Version,
    pub event: ContractEvent,
}
```

**File:** api/types/src/transaction.rs (L897-909)
```rust
#[derive(Clone, Debug, Deserialize, Eq, Object, PartialEq, Serialize)]
pub struct VersionedEvent {
    pub version: U64,
    // The globally unique identifier of this event stream.
    pub guid: EventGuid,
    // The sequence number of the event
    pub sequence_number: U64,
    #[serde(rename = "type")]
    #[oai(rename = "type")]
    pub typ: MoveType,
    /// The JSON representation of the event
    pub data: serde_json::Value,
}
```

**File:** crates/aptos-rest-client/src/lib.rs (L1407-1424)
```rust
    pub async fn get_account_events_bcs(
        &self,
        address: AccountAddress,
        struct_tag: &str,
        field_name: &str,
        start: Option<u64>,
        limit: Option<u16>,
    ) -> AptosResult<Response<Vec<EventWithVersion>>> {
        let url = self.build_path(&format!(
            "accounts/{}/events/{}/{}",
            address.to_hex_literal(),
            struct_tag,
            field_name
        ))?;

        let response = self.get_bcs_with_page(url, start, limit).await?;
        Ok(response.and_then(|inner| bcs::from_bytes(&inner))?)
    }
```
