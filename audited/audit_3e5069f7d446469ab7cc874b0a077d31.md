# Audit Report

## Title
Epoch Ending Backup Accepts Unverified Epoch Data Without Cryptographic Validation

## Summary
The `EpochEndingBackupController.run()` method does not validate epoch ending ledger infos during backup creation, and the restore process accepts the first epoch in a backup sequence without cryptographic signature verification if no trusted waypoint is provided. This allows a compromised backup service to inject fraudulent epoch data that would be accepted by nodes restoring from backup.

## Finding Description

The vulnerability exists across the backup creation and restoration flow for epoch ending data:

**1. Backup Creation (No Validation):**

The `EpochEndingBackupController.run()` method directly fetches epoch ending ledger infos from the backup service without any validation: [1](#0-0) 

The backup service simply reads from its local database without validation: [2](#0-1) 

The only check during backup creation is a basic epoch number sanity check, not cryptographic verification: [3](#0-2) 

**2. Restore/Verification (Missing Validation for First Epoch):**

During restore, the `EpochEndingRestoreController.preheat_impl()` performs validation, but has a critical gap: [4](#0-3) 

The validation logic at lines 129-147 shows:
- If a trusted waypoint exists: waypoint verification occurs
- If previous ledger info exists: cryptographic signature verification occurs using `next_epoch_state().verify()`
- **If neither exists: NO validation occurs**

For the first ledger info in the backup (`previous_li` starts as `None`), if there's no trusted waypoint, it bypasses all validation and is added to the list unverified.

The cryptographic verification that SHOULD occur uses BLS signature verification: [5](#0-4) [6](#0-5) 

**3. No Enforcement of Trusted Waypoints:**

The system does not enforce that trusted waypoints must be provided. The `TrustedWaypointOpt` is optional: [7](#0-6) 

The `VerifyCoordinator` accepts empty trusted waypoints and proceeds: [8](#0-7) 

**Attack Scenario:**

1. Attacker compromises backup service or modifies backup storage
2. Attacker injects fraudulent epoch ending ledger info with malicious validator set
3. Victim performs restore/verification without providing trusted waypoint for first epoch
4. Fraudulent epoch data is accepted without cryptographic verification
5. Subsequent epochs are verified against the fraudulent first epoch, propagating the attack

This breaks the **Consensus Safety** invariant because epoch endings contain the `next_epoch_state` which defines the validator set and voting power for consensus. Accepting fraudulent epoch data allows an attacker to manipulate which validators can participate in consensus.

## Impact Explanation

This is a **Critical Severity** vulnerability under the Aptos Bug Bounty program for the following reasons:

1. **Consensus/Safety Violation**: Epoch endings contain validator sets that determine consensus participation. Fraudulent epoch data allows manipulation of consensus validators, breaking the fundamental safety property that only legitimate validators can participate in block production and finalization.

2. **Loss of Funds**: If a node restores with fraudulent epoch data, it may accept blocks signed by invalid validators, potentially accepting double-spends or unauthorized state transitions that could result in fund theft.

3. **Network Partition Risk**: Nodes restored with fraudulent epoch data will have different views of the validator set, causing them to reject legitimate blocks and potentially creating non-recoverable network partitions.

The vulnerability directly violates multiple critical invariants:
- **Consensus Safety**: Different nodes could have different validator sets
- **Deterministic Execution**: Nodes with different epoch histories produce different state
- **Cryptographic Correctness**: Signature verification is bypassed entirely

## Likelihood Explanation

The likelihood is **MEDIUM to HIGH** in certain deployment scenarios:

**Factors Increasing Likelihood:**
- Backup services are often run on separate infrastructure from validators and may have weaker security
- Cloud storage for backups (S3, GCS) could be compromised through credential theft
- Organizations performing disaster recovery without properly configured trusted waypoints
- Automated backup/restore procedures that don't enforce waypoint verification

**Factors Decreasing Likelihood:**
- Best practices recommend always using trusted waypoints (genesis waypoint at minimum)
- Most production deployments would configure trusted waypoints
- Requires attacker to compromise backup infrastructure

However, the code does not **enforce** trusted waypoints, making this exploitable in real-world scenarios where operators fail to configure them properly.

## Recommendation

**Immediate Fix:** Enforce that at least one trusted waypoint (typically genesis) must be provided for epoch ending restore/verification operations.

**Code Fix:**

In `storage/backup/backup-cli/src/utils/mod.rs`, modify `GlobalRestoreOptions::new()` to require a genesis waypoint:

```rust
pub fn new(opt: GlobalRestoreOpt) -> Result<Self> {
    // ... existing code ...
    
    let trusted_waypoints = opt.trusted_waypoints.verify()?;
    
    // SECURITY FIX: Require at least genesis waypoint (epoch 0)
    anyhow::ensure!(
        !trusted_waypoints.is_empty() || opt.target_db_dir.is_none(),
        "At least one trusted waypoint (typically genesis) must be provided for restore operations. \
         This is required to cryptographically verify epoch ending data and prevent accepting \
         fraudulent validator sets from compromised backup sources."
    );
    
    Ok(Self {
        target_version,
        trusted_waypoints: Arc::new(trusted_waypoints),
        // ... rest of fields ...
    })
}
```

**Additional Hardening:**

1. In `EpochEndingRestoreController.preheat_impl()`, add explicit validation that refuses to accept epoch data without verification:

```rust
// After line 147, before adding to ledger_infos:
if previous_li.is_none() && self.trusted_waypoints.get(&wp_li.version()).is_none() {
    anyhow::bail!(
        "First epoch {} in backup has no trusted waypoint and no previous epoch to verify against. \
         This is insecure as it would accept unverified epoch data. \
         Please provide a trusted waypoint for epoch {} or ensure the backup starts from a verified epoch.",
        li.ledger_info().epoch(),
        li.ledger_info().epoch()
    );
}
```

2. Update documentation to emphasize that trusted waypoints are mandatory for security, not optional

## Proof of Concept

```rust
// This PoC demonstrates the vulnerability by showing that restore accepts 
// unverified epoch data when no trusted waypoint is provided

#[tokio::test]
async fn test_epoch_ending_restore_without_waypoint_accepts_fraudulent_data() {
    use aptos_backup_cli::{
        backup_types::epoch_ending::restore::{EpochEndingRestoreController, EpochEndingRestoreOpt},
        storage::local_fs::LocalFs,
        utils::{GlobalRestoreOptions, RestoreRunMode},
    };
    use aptos_crypto::HashValue;
    use aptos_types::{
        ledger_info::{LedgerInfo, LedgerInfoWithSignatures},
        validator_verifier::ValidatorVerifier,
    };
    use std::{collections::HashMap, sync::Arc};

    // Create fraudulent epoch ending with invalid validator set
    let fraudulent_validator_set = ValidatorVerifier::new(vec![]); // Empty = invalid
    let fraudulent_li = LedgerInfo::new(
        /* epoch */ 0,
        /* version */ 0,
        HashValue::random(),
        HashValue::random(),
        Some(fraudulent_validator_set.into()),
        HashValue::random(),
        0,
    );
    let fraudulent_li_with_sigs = LedgerInfoWithSignatures::new(fraudulent_li, HashMap::new());
    
    // Write fraudulent backup to storage
    // ... (backup creation code) ...
    
    // Attempt restore WITHOUT trusted waypoint
    let global_opt = GlobalRestoreOptions {
        target_version: u64::MAX,
        trusted_waypoints: Arc::new(HashMap::new()), // NO TRUSTED WAYPOINTS!
        run_mode: Arc::new(RestoreRunMode::Verify),
        concurrent_downloads: 1,
        replay_concurrency_level: 1,
    };
    
    let controller = EpochEndingRestoreController::new(
        EpochEndingRestoreOpt { /* ... */ },
        global_opt,
        Arc::new(/* storage */),
    );
    
    // This SHOULD fail but currently succeeds, accepting fraudulent epoch data
    let result = controller.run(None).await;
    
    // VULNERABILITY: result is Ok, fraudulent epoch accepted without verification!
    assert!(result.is_ok(), "Fraudulent epoch data was accepted without validation");
}
```

## Notes

This vulnerability is particularly dangerous because:

1. **Silent Failure**: The system provides no warning that epoch data is being accepted without verification
2. **Trust Chain Broken**: Once the first fraudulent epoch is accepted, all subsequent epochs are verified against it, propagating the attack
3. **Production Impact**: Disaster recovery scenarios often involve restoring from backups without full waypoint configuration
4. **No Audit Trail**: There's no logging that indicates when epoch data is accepted without cryptographic verification

The fix is straightforward but critical: enforce trusted waypoints and refuse to accept unverified epoch data.

### Citations

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/backup.rs (L83-86)
```rust
        let mut ledger_infos_file = self
            .client
            .get_epoch_ending_ledger_infos(self.start_epoch, self.end_epoch)
            .await?;
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/backup.rs (L140-149)
```rust
    fn get_waypoint(record: &[u8], epoch: u64) -> Result<Waypoint> {
        let li: LedgerInfoWithSignatures = bcs::from_bytes(record)?;
        ensure!(
            li.ledger_info().epoch() == epoch,
            "Epoch not expected. expected: {}, actual: {}.",
            li.ledger_info().epoch(),
            epoch,
        );
        Waypoint::new_epoch_boundary(li.ledger_info())
    }
```

**File:** storage/aptosdb/src/backup/backup_handler.rs (L207-221)
```rust
    pub fn get_epoch_ending_ledger_info_iter(
        &self,
        start_epoch: u64,
        end_epoch: u64,
    ) -> Result<impl Iterator<Item = Result<LedgerInfoWithSignatures>> + '_> {
        Ok(self
            .ledger_db
            .metadata_db()
            .get_epoch_ending_ledger_info_iter(start_epoch, end_epoch)?
            .enumerate()
            .map(move |(idx, li)| {
                BACKUP_EPOCH_ENDING_EPOCH.set((start_epoch + idx as u64) as i64);
                li
            }))
    }
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L88-151)
```rust
        let mut previous_li: Option<&LedgerInfoWithSignatures> = None;
        let mut ledger_infos = Vec::new();

        let mut past_target = false;
        for chunk in &manifest.chunks {
            if past_target {
                break;
            }

            let lis = self.read_chunk(&chunk.ledger_infos).await?;
            ensure!(
                chunk.first_epoch + lis.len() as u64 == chunk.last_epoch + 1,
                "Number of items in chunks doesn't match that in manifest. \
                first_epoch: {}, last_epoch: {}, items in chunk: {}",
                chunk.first_epoch,
                chunk.last_epoch,
                lis.len(),
            );

            for li in lis {
                if li.ledger_info().version() > self.target_version {
                    past_target = true;
                    break;
                }

                ensure!(
                    li.ledger_info().epoch() == next_epoch,
                    "LedgerInfo epoch not expected. Expected: {}, actual: {}.",
                    li.ledger_info().epoch(),
                    next_epoch,
                );
                let wp_manifest = waypoint_iter.next().ok_or_else(|| {
                    anyhow!("More LedgerInfo's found than waypoints in manifest.")
                })?;
                let wp_li = Waypoint::new_epoch_boundary(li.ledger_info())?;
                ensure!(
                    *wp_manifest == wp_li,
                    "Waypoints don't match. In manifest: {}, In chunk: {}",
                    wp_manifest,
                    wp_li,
                );
                if let Some(wp_trusted) = self.trusted_waypoints.get(&wp_li.version()) {
                    ensure!(
                        *wp_trusted == wp_li,
                        "Waypoints don't match. In backup: {}, trusted: {}",
                        wp_li,
                        wp_trusted,
                    );
                } else if let Some(pre_li) = previous_li {
                    pre_li
                        .ledger_info()
                        .next_epoch_state()
                        .ok_or_else(|| {
                            anyhow!(
                                "Next epoch state not found from LI at epoch {}.",
                                pre_li.ledger_info().epoch()
                            )
                        })?
                        .verify(&li)?;
                }
                ledger_infos.push(li);
                previous_li = ledger_infos.last();
                next_epoch += 1;
            }
```

**File:** types/src/epoch_state.rs (L40-50)
```rust
impl Verifier for EpochState {
    fn verify(&self, ledger_info: &LedgerInfoWithSignatures) -> anyhow::Result<()> {
        ensure!(
            self.epoch == ledger_info.ledger_info().epoch(),
            "LedgerInfo has unexpected epoch {}, expected {}",
            ledger_info.ledger_info().epoch(),
            self.epoch
        );
        ledger_info.verify_signatures(&self.verifier)?;
        Ok(())
    }
```

**File:** types/src/ledger_info.rs (L303-308)
```rust
    pub fn verify_signatures(
        &self,
        validator: &ValidatorVerifier,
    ) -> ::std::result::Result<(), VerifyError> {
        validator.verify_multi_signatures(self.ledger_info(), &self.signatures)
    }
```

**File:** storage/backup/backup-cli/src/utils/mod.rs (L331-363)
```rust
#[derive(Clone, Default, Parser)]
pub struct TrustedWaypointOpt {
    #[clap(
        long,
        help = "(multiple) When provided, an epoch ending LedgerInfo at the waypoint version will be \
        checked against the hash in the waypoint, but signatures on it are NOT checked. \
        Use this for two purposes: \
        1. set the genesis or the latest waypoint to confirm the backup is compatible. \
        2. set waypoints at versions where writeset transactions were used to overwrite the \
        validator set, so that the signature check is skipped. \
        N.B. LedgerInfos are verified only when restoring / verifying the epoch ending backups, \
        i.e. they are NOT checked at all when doing one-shot restoring of the transaction \
        and state backups."
    )]
    pub trust_waypoint: Vec<Waypoint>,
}

impl TrustedWaypointOpt {
    pub fn verify(self) -> Result<HashMap<Version, Waypoint>> {
        let mut trusted_waypoints = HashMap::new();
        for w in self.trust_waypoint {
            trusted_waypoints
                .insert(w.version(), w)
                .map_or(Ok(()), |w| {
                    Err(AptosDbError::Other(format!(
                        "Duplicated waypoints at version {}",
                        w.version()
                    )))
                })?;
        }
        Ok(trusted_waypoints)
    }
}
```

**File:** storage/backup/backup-cli/src/coordinators/verify.rs (L98-104)
```rust
        let global_opt = GlobalRestoreOptions {
            target_version: ver_max,
            trusted_waypoints: Arc::new(self.trusted_waypoints_opt.verify()?),
            run_mode: Arc::new(RestoreRunMode::Verify),
            concurrent_downloads: self.concurrent_downloads,
            replay_concurrency_level: 0, // won't replay, doesn't matter
        };
```
