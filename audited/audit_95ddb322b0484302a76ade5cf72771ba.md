# Audit Report

## Title
Unbounded State Growth in ApprovedExecutionHashes Through Unexecuted Governance Proposals

## Summary
The `ApprovedExecutionHashes` resource in the Aptos governance system can be permanently bloated by creating proposals that succeed but are never executed. There is no cleanup mechanism for removing execution hashes of succeeded proposals that remain unresolved, leading to unbounded on-chain state growth.

## Finding Description

The Aptos governance system tracks approved execution hashes to bypass mempool transaction size limits for large governance proposals. When a proposal reaches `PROPOSAL_STATE_SUCCEEDED`, its execution hash is automatically added to the `ApprovedExecutionHashes` map. [1](#0-0) 

The hash can only be removed when the proposal is resolved (executed), which requires submitting the exact execution script with matching hash: [2](#0-1) 

The resolution process in the voting module enforces that only scripts with matching execution hashes can resolve proposals: [3](#0-2) 

**The Attack Vector:**

1. A malicious actor creates a governance proposal with the required proposer stake
2. Through legitimate or coordinated voting, the proposal reaches `PROPOSAL_STATE_SUCCEEDED`
3. The execution hash is automatically added to `ApprovedExecutionHashes`
4. The proposer never submits the execution script
5. The hash remains in the `SimpleMap` permanently—there is no expiration-based cleanup, no admin override function, and no size limits [4](#0-3) 

Additionally, anyone can manually add hashes for succeeded proposals through the public entry function: [5](#0-4) 

This breaks the **Resource Limits** invariant: "All operations must respect gas, storage, and computational limits." The `ApprovedExecutionHashes` map can grow without bound, as there is no mechanism to clean up succeeded but unexecuted proposals.

## Impact Explanation

This qualifies as **Medium Severity** under the Aptos bug bounty criteria: "State inconsistencies requiring intervention."

**Specific impacts:**
- **Unbounded state growth**: Each unexecuted succeeded proposal permanently consumes on-chain storage
- **Increased gas costs**: Operations on larger `SimpleMap` structures cost more gas, affecting all governance operations
- **Denial of service**: Repeated exploitation could degrade governance system performance
- **Manual intervention required**: No automated cleanup mechanism exists; requires governance action or hard fork to resolve

The vulnerability does not directly steal funds or break consensus, but it enables a griefing attack that degrades system state and requires manual intervention to clean up.

## Likelihood Explanation

**Likelihood: Medium-High**

**Attack Requirements:**
- Attacker needs `required_proposer_stake` (configurable, typically 100 APT based on test code)
- Proposal must receive enough votes to succeed
- Cost scales linearly with number of griefing attempts

**Why this is likely to occur:**
1. The attack is economically feasible—stake is not burned, only locked temporarily
2. Coordinated voting or legitimate proposals that happen to succeed can be left unexecuted
3. No rate limiting on proposal creation beyond stake requirements
4. The vulnerability can be triggered accidentally if proposers abandon succeeded proposals
5. Anyone can call `add_approved_script_hash_script()` to ensure hashes are added

**Constraints:**
- Limited by attacker's available stake for concurrent proposals
- Each proposal requires voting period to succeed (~1000 seconds based on default configs)

## Recommendation

Implement a cleanup mechanism for stale approved execution hashes. **Recommended fixes:**

1. **Add expiration-based cleanup**: Remove hashes for proposals that have been succeeded but unresolved for a configurable period (e.g., 30 days)

```move
public fun cleanup_expired_approved_hashes(proposal_ids: vector<u64>) acquires ApprovedExecutionHashes {
    let approved_hashes = &mut borrow_global_mut<ApprovedExecutionHashes>(@aptos_framework).hashes;
    vector::for_each(proposal_ids, |proposal_id| {
        if (simple_map::contains_key(approved_hashes, &proposal_id)) {
            let proposal_expiration = voting::get_proposal_expiration_secs<GovernanceProposal>(@aptos_framework, proposal_id);
            let is_resolved = voting::is_resolved<GovernanceProposal>(@aptos_framework, proposal_id);
            
            // Remove if expired and unresolved
            if (!is_resolved && timestamp::now_seconds() > proposal_expiration + CLEANUP_GRACE_PERIOD_SECS) {
                simple_map::remove(approved_hashes, &proposal_id);
            }
        }
    });
}
```

2. **Add size limits**: Enforce maximum size on `ApprovedExecutionHashes` map

3. **Add admin override**: Allow governance to force-remove specific entries through a governance proposal

## Proof of Concept

```move
#[test(aptos_framework = @aptos_framework, proposer = @0x123, yes_voter = @0x234, no_voter = @345)]
public entry fun test_unexecuted_proposal_bloats_approved_hashes(
    aptos_framework: signer,
    proposer: signer,
    yes_voter: signer,
    no_voter: signer,
) acquires ApprovedExecutionHashes, GovernanceConfig, GovernanceResponsbility, VotingRecords, VotingRecordsV2, GovernanceEvents {
    setup_partial_voting(&aptos_framework, &proposer, &yes_voter, &no_voter);
    
    // Create first proposal
    create_proposal_for_test(&proposer, false);
    vote(&yes_voter, signer::address_of(&yes_voter), 0, true);
    vote(&no_voter, signer::address_of(&no_voter), 0, false);
    
    // Wait for proposal to succeed
    timestamp::update_global_time_for_test(100001000000);
    let proposal_state = voting::get_proposal_state<GovernanceProposal>(@aptos_framework, 0);
    assert!(proposal_state == PROPOSAL_STATE_SUCCEEDED, 0);
    
    // Add approved hash (happens automatically in vote_internal or can be called manually)
    add_approved_script_hash(0);
    let approved_hashes = borrow_global<ApprovedExecutionHashes>(@aptos_framework).hashes;
    assert!(simple_map::length(&approved_hashes) == 1, 1);
    
    // Create second proposal - never execute first one
    create_proposal_for_test(&proposer, false);
    vote(&yes_voter, signer::address_of(&yes_voter), 1, true);
    timestamp::update_global_time_for_test(200001000000);
    add_approved_script_hash(1);
    
    // Both hashes remain in map forever - no cleanup mechanism
    let approved_hashes = borrow_global<ApprovedExecutionHashes>(@aptos_framework).hashes;
    assert!(simple_map::length(&approved_hashes) == 2, 2);
    assert!(simple_map::contains_key(&approved_hashes, &0), 3);
    assert!(simple_map::contains_key(&approved_hashes, &1), 4);
    
    // Even after proposal expiration, hashes cannot be removed without resolution
    // This demonstrates unbounded growth potential
}
```

**Notes:**
- This vulnerability enables a state bloat griefing attack requiring manual intervention to clean up
- The attack is economically bounded by stake requirements but can still cause significant state growth
- The lack of any cleanup mechanism for succeeded but unexecuted proposals is a fundamental design flaw in the governance system

### Citations

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L110-112)
```text
    struct ApprovedExecutionHashes has key {
        hashes: SimpleMap<u64, vector<u8>>,
    }
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L600-603)
```text
        let proposal_state = voting::get_proposal_state<GovernanceProposal>(@aptos_framework, proposal_id);
        if (proposal_state == PROPOSAL_STATE_SUCCEEDED) {
            add_approved_script_hash(proposal_id);
        }
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L606-608)
```text
    public entry fun add_approved_script_hash_script(proposal_id: u64) acquires ApprovedExecutionHashes {
        add_approved_script_hash(proposal_id)
    }
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L664-674)
```text
    public fun remove_approved_hash(proposal_id: u64) acquires ApprovedExecutionHashes {
        assert!(
            voting::is_resolved<GovernanceProposal>(@aptos_framework, proposal_id),
            error::invalid_argument(EPROPOSAL_NOT_RESOLVED_YET),
        );

        let approved_hashes = &mut borrow_global_mut<ApprovedExecutionHashes>(@aptos_framework).hashes;
        if (simple_map::contains_key(approved_hashes, &proposal_id)) {
            simple_map::remove(approved_hashes, &proposal_id);
        };
    }
```

**File:** aptos-move/framework/aptos-framework/sources/voting.move (L447-450)
```text
        assert!(
            transaction_context::get_script_hash() == proposal.execution_hash,
            error::invalid_argument(EPROPOSAL_EXECUTION_HASH_NOT_MATCHING),
        );
```
