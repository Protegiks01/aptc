# Audit Report

## Title
Mutex Poisoning in gRPC Network Service Causes Permanent Node DoS

## Summary
The `simple_msg_exchange()` function in the gRPC network service contains a critical Mutex poisoning vulnerability. When a channel receiver is dropped but its sender remains registered in `inbound_handlers`, any incoming message triggers a panic while holding the shared Mutex lock. This permanently poisons the Mutex, causing all subsequent message processing for all message types to fail, resulting in a complete and permanent denial of service that requires node restart.

## Finding Description

The vulnerability exists in the message routing logic: [1](#0-0) 

Due to Rust's temporary lifetime extension rules, the `MutexGuard` returned by `lock().unwrap()` is kept alive for the entire `if let` block because the reference `handler` borrows from it. This means the Mutex lock is held during the `handler.send(msg).unwrap()` call on line 107.

When a crossbeam channel receiver is dropped, subsequent `send()` operations return `SendError`. [2](#0-1) 

The `.unwrap()` call panics on this error while the thread holds the `inbound_handlers` Mutex lock. According to Rust's panic semantics, this poisons the Mutex. All future `lock().unwrap()` calls on this poisoned Mutex will panic, cascading the failure to all message types since they share the same Mutex.

**Attack Path:**

1. The `NetworkController` creates inbound channels for message routing: [3](#0-2) 

2. Components like `RemoteCoordinatorClient` and `RemoteCrossShardClient` receive these channel receivers: [4](#0-3)  and [5](#0-4) 

3. If any component drops its receiver (due to panic, error handling, or early shutdown) while the NetworkController's gRPC server is still running, the channel closes but the sender remains in `inbound_handlers`

4. When a new message arrives for that message type, `simple_msg_exchange()` attempts to send, panics, and poisons the Mutex

5. All subsequent messages (of any type) fail permanently because the Mutex is poisoned

The same vulnerability exists in a second location: [6](#0-5) 

## Impact Explanation

This is **HIGH severity** per Aptos bug bounty criteria:

- **Validator node slowdowns**: The affected node cannot process any network messages, effectively removing it from the network
- **API crashes**: All gRPC message handling crashes after the first panic
- **Significant protocol violations**: Breaks the availability invariant for network communication

The vulnerability affects the `ExecutorService` used for sharded block execution: [7](#0-6) 

Once triggered, the node requires a full restart to recover, as there is no runtime mechanism to clear Mutex poisoning.

## Likelihood Explanation

**MEDIUM-HIGH likelihood:**

- **Trigger conditions are realistic**: Component panics, error handling paths, or race conditions during shutdown can all cause receivers to be dropped
- **No special privileges required**: Any condition that drops a receiver while the network service is running will trigger it
- **Cascading failure**: A single panic in any message handler permanently disables the entire node's network layer
- **Production scenarios**: Thread panics, out-of-memory conditions, or bugs in executor service logic can trigger this

The vulnerability is particularly dangerous because it converts a local component failure into a complete node failure.

## Recommendation

Replace all `.unwrap()` calls on channel send operations with proper error handling. The Mutex must be dropped before handling the send error:

```rust
async fn simple_msg_exchange(
    &self,
    request: Request<NetworkMessage>,
) -> Result<Response<Empty>, Status> {
    let _timer = NETWORK_HANDLER_TIMER
        .with_label_values(&[&self.self_addr.to_string(), "inbound_msgs"])
        .start_timer();
    let remote_addr = request.remote_addr();
    let network_message = request.into_inner();
    let msg = Message::new(network_message.message);
    let message_type = MessageType::new(network_message.message_type);

    // Clone the sender outside the lock to avoid holding it during send
    let handler_opt = self.inbound_handlers.lock().unwrap().get(&message_type).cloned();
    
    if let Some(handler) = handler_opt {
        // Send without holding the Mutex lock
        if let Err(e) = handler.send(msg) {
            error!(
                "Failed to send message from {:?} for type {:?}: {}",
                remote_addr, message_type, e
            );
            return Err(Status::internal("Handler channel closed"));
        }
    } else {
        error!(
            "No handler registered for sender: {:?} and msg type {:?}",
            remote_addr, message_type
        );
    }
    Ok(Response::new(Empty {}))
}
```

Apply the same fix to: [8](#0-7) 

Alternatively, implement automatic handler cleanup when channels close, removing stale senders from `inbound_handlers`.

## Proof of Concept

```rust
#[test]
fn test_mutex_poisoning_dos() {
    use aptos_config::utils;
    use std::{
        net::{IpAddr, Ipv4Addr, SocketAddr},
        thread,
        time::Duration,
    };

    let server_addr = SocketAddr::new(IpAddr::V4(Ipv4Addr::LOCALHOST), utils::get_available_port());
    let message_type = "test_poison".to_string();
    let server_handlers: Arc<Mutex<HashMap<MessageType, Sender<Message>>>> =
        Arc::new(Mutex::new(HashMap::new()));

    // Create channel and register handler
    let (msg_tx, msg_rx) = crossbeam_channel::unbounded();
    server_handlers
        .lock()
        .unwrap()
        .insert(MessageType::new(message_type.clone()), msg_tx);
    
    let server = GRPCNetworkMessageServiceServerWrapper::new(server_handlers.clone(), server_addr);

    let rt = Runtime::new().unwrap();
    let (server_shutdown_tx, server_shutdown_rx) = oneshot::channel();
    server.start(&rt, "poison_test".to_string(), server_addr, 1000, server_shutdown_rx);

    thread::sleep(Duration::from_millis(50));

    // DROP THE RECEIVER - this closes the channel
    drop(msg_rx);

    let mut grpc_client = GRPCNetworkMessageServiceClientWrapper::new(&rt, server_addr);
    let client_addr = SocketAddr::new(IpAddr::V4(Ipv4Addr::LOCALHOST), utils::get_available_port());

    // First message: causes panic and poisons the Mutex
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        rt.block_on(async {
            grpc_client
                .send_message(
                    client_addr,
                    Message::new(b"trigger_poison".to_vec()),
                    &MessageType::new(message_type.clone()),
                )
                .await;
        });
    }));
    assert!(result.is_err(), "First send should panic");

    // Register a NEW message type with valid channel
    let (msg_tx2, _msg_rx2) = crossbeam_channel::unbounded();
    server_handlers
        .lock()
        .unwrap()
        .insert(MessageType::new("new_type".to_string()), msg_tx2);

    // Try to send to the NEW message type - should fail due to poisoned Mutex
    let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        rt.block_on(async {
            grpc_client
                .send_message(
                    client_addr,
                    Message::new(b"test_new_type".to_vec()),
                    &MessageType::new("new_type".to_string()),
                )
                .await;
        });
    }));
    assert!(result.is_err(), "Subsequent sends to ANY message type should fail due to poisoned Mutex");

    server_shutdown_tx.send(()).ok();
}
```

This PoC demonstrates:
1. Dropping a receiver while the server is running
2. First message to that type panics and poisons the Mutex
3. All subsequent messages (even to different message types) fail due to the poisoned Mutex
4. Complete and permanent DoS of the node's network message processing

### Citations

**File:** secure/net/src/grpc_network_service/mod.rs (L105-107)
```rust
        if let Some(handler) = self.inbound_handlers.lock().unwrap().get(&message_type) {
            // Send the message to the registered handler
            handler.send(msg).unwrap();
```

**File:** secure/net/src/network_controller/error.rs (L18-21)
```rust
impl From<SendError<network_controller::Message>> for Error {
    fn from(error: SendError<network_controller::Message>) -> Self {
        Self::InternalError(error.to_string())
    }
```

**File:** secure/net/src/network_controller/mod.rs (L128-137)
```rust
    pub fn create_inbound_channel(&mut self, message_type: String) -> Receiver<Message> {
        let (inbound_sender, inbound_receiver) = unbounded();

        self.inbound_handler
            .lock()
            .unwrap()
            .register_handler(message_type, inbound_sender);

        inbound_receiver
    }
```

**File:** execution/executor-service/src/remote_cordinator_client.rs (L34-34)
```rust
        let command_rx = controller.create_inbound_channel(execute_command_type);
```

**File:** execution/executor-service/src/remote_cross_shard_client.rs (L39-39)
```rust
            let rx = controller.create_inbound_channel(message_type);
```

**File:** secure/net/src/network_controller/inbound_handler.rs (L66-74)
```rust
    pub fn send_incoming_message_to_handler(&self, message_type: &MessageType, message: Message) {
        // Check if there is a registered handler for the sender
        if let Some(handler) = self.inbound_handlers.lock().unwrap().get(message_type) {
            // Send the message to the registered handler
            handler.send(message).unwrap();
        } else {
            warn!("No handler registered for message type: {:?}", message_type);
        }
    }
```

**File:** execution/executor-service/src/remote_executor_service.rs (L31-31)
```rust
        let mut controller = NetworkController::new(service_name, self_address, 5000);
```
