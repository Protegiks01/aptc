# Audit Report

## Title
Indexer GRPC Service Resource Exhaustion via Indefinite Wait in ensure_highest_known_version()

## Summary
The `ensure_highest_known_version()` function in the indexer-grpc-fullnode service lacks a maximum wait time limit, causing it to loop indefinitely when clients request future transaction versions during blockchain halts. This leads to tokio task exhaustion and denial of service for the indexer GRPC API.

## Finding Description
The vulnerability exists in the `ensure_highest_known_version()` function which waits for the blockchain to reach a requested version before processing transactions. [1](#0-0) 

The function loops while `current_version > highest_known_version`, with only two exit conditions:
1. An abort_handle is set to true (only available in FullnodeDataService, not LocalnetDataService)
2. The blockchain produces enough blocks to reach the requested version

**Critical Issue in LocalnetDataService:** [2](#0-1) 

The LocalnetDataService passes `None` as the abort_handle, eliminating the only manual escape mechanism.

**Attack Scenario:**
1. Attacker opens multiple GRPC stream connections to the indexer service
2. Each connection requests transactions starting from a far-future version (e.g., current blockchain head + 1,000,000)
3. When `process_next_batch()` is called, it invokes `get_batches()` which calls `ensure_highest_known_version()`
4. The function enters an infinite loop waiting for the blockchain to reach the requested version
5. Each stuck stream consumes a tokio task that sleeps for 100ms per iteration but never terminates
6. Multiple concurrent requests exhaust the tokio runtime thread pool
7. Legitimate indexer queries cannot be processed, causing service unavailability

**Amplification During Blockchain Issues:**
During blockchain halts, network partitions, or slow block production (which are critical times when indexers are most needed), even legitimate clients requesting the latest version can trigger this issue, as `current_version` may legitimately exceed `highest_known_version` temporarily.

The sleep duration is defined as: [3](#0-2) 

The configuration provides no timeout parameters: [4](#0-3) 

## Impact Explanation
This vulnerability qualifies as **Medium Severity** per Aptos bug bounty criteria:
- **API Crashes/Unavailability**: The indexer GRPC service becomes unresponsive as tokio tasks accumulate
- **Service Degradation**: Legitimate clients cannot retrieve blockchain data
- **Resource Exhaustion**: Memory and thread pool resources are consumed by stuck tasks

While this doesn't directly affect consensus or validator operations (as indexer services typically run separately), it impacts the availability of critical blockchain data infrastructure that applications and users depend on. The impact is amplified during blockchain issues when the indexer service is most critical.

## Likelihood Explanation
**High Likelihood:**
- **No Authentication Required**: GRPC endpoints are publicly accessible
- **Trivial to Exploit**: Any client can request future versions with a simple API call
- **Natural Occurrence**: Legitimate clients may inadvertently trigger this during blockchain slowdowns
- **No Existing Protections**: No timeout configuration, rate limiting on version ranges, or maximum iteration limits exist

The vulnerability is particularly likely to manifest during:
- Blockchain halt scenarios (maintenance, network issues, consensus problems)
- Network partitions where the indexer falls behind
- Malicious attacks specifically targeting the indexer service

## Recommendation

Implement a maximum wait time limit with configurable timeout:

```rust
// In IndexerGrpcConfig (config/src/config/indexer_grpc_config.rs)
pub struct IndexerGrpcConfig {
    // ... existing fields ...
    
    /// Maximum time in seconds to wait for blockchain to reach requested version
    /// If timeout is reached, the request will return an error
    pub highest_version_wait_timeout_secs: u64,
}

impl Default for IndexerGrpcConfig {
    fn default() -> Self {
        Self {
            // ... existing defaults ...
            highest_version_wait_timeout_secs: 300, // 5 minutes default
        }
    }
}

// In stream_coordinator.rs
async fn ensure_highest_known_version(&mut self) -> Result<bool, Status> {
    let mut empty_loops = 0;
    let start_time = std::time::Instant::now();
    let timeout_duration = Duration::from_secs(
        self.config.highest_version_wait_timeout_secs
    );
    
    while self.highest_known_version == 0 || self.current_version > self.highest_known_version {
        // Check timeout
        if start_time.elapsed() > timeout_duration {
            return Err(Status::deadline_exceeded(format!(
                "Timeout waiting for blockchain to reach version {}. Current highest version: {}",
                self.current_version, self.highest_known_version
            )));
        }
        
        if let Some(abort_handle) = self.abort_handle.as_ref() {
            if abort_handle.load(Ordering::SeqCst) {
                return Ok(false);
            }
        }
        
        if empty_loops > 0 {
            tokio::time::sleep(Duration::from_millis(RETRY_TIME_MILLIS)).await;
        }
        empty_loops += 1;
        
        if let Err(err) = self.set_highest_known_version() {
            error!(
                error = format!("{:?}", err),
                "[Indexer Fullnode] Failed to set highest known version"
            );
            continue;
        }
        // ... rest of logging ...
    }
    Ok(true)
}
```

Additionally, implement validation to reject requests for versions too far in the future:

```rust
// In get_batches()
async fn get_batches(&mut self) -> Vec<TransactionBatchInfo> {
    if !self.ensure_highest_known_version().await? {
        return vec![];
    }
    
    // Validate requested version is reasonable
    const MAX_VERSION_AHEAD: u64 = 10_000;
    if self.current_version > self.highest_known_version + MAX_VERSION_AHEAD {
        return Err(Status::invalid_argument(format!(
            "Requested version {} is too far ahead of current highest version {}",
            self.current_version, self.highest_known_version
        )));
    }
    
    // ... rest of function ...
}
```

## Proof of Concept

```rust
// Integration test demonstrating the vulnerability
#[tokio::test]
async fn test_indefinite_wait_on_future_version() {
    use tokio::time::{timeout, Duration};
    
    // Setup: Create indexer coordinator with future version request
    let context = create_test_context();
    let current_blockchain_version = context.get_latest_ledger_info().unwrap().ledger_version.0;
    let far_future_version = current_blockchain_version + 1_000_000;
    
    let (tx, _rx) = mpsc::channel(10);
    
    let mut coordinator = IndexerStreamCoordinator::new(
        context,
        far_future_version, // Request far-future version
        u64::MAX,
        1,
        100,
        100,
        tx,
        None,
        None, // No abort_handle (like LocalnetDataService)
    );
    
    // Attempt to process batch - this should timeout but instead hangs indefinitely
    let result = timeout(
        Duration::from_secs(5),
        coordinator.process_next_batch()
    ).await;
    
    // This assertion will FAIL because the function hangs indefinitely
    assert!(result.is_err(), "Expected timeout but function is still running");
    
    // To demonstrate DoS, spawn multiple tasks
    let mut handles = vec![];
    for _ in 0..10 {
        let mut coord_clone = coordinator.clone();
        let handle = tokio::spawn(async move {
            coord_clone.process_next_batch().await
        });
        handles.push(handle);
    }
    
    // All tasks will hang indefinitely, exhausting tokio runtime
    tokio::time::sleep(Duration::from_secs(10)).await;
    
    // Tasks are still running and consuming resources
    for handle in handles {
        assert!(!handle.is_finished(), "Task should still be waiting");
    }
}
```

## Notes

The HTTP2 keepalive timeout configured in the GRPC server is insufficient to protect against this issue: [5](#0-4) 

These keepalive settings only detect broken network connections, not application-level infinite waiting scenarios where the connection remains alive but the request is blocked waiting for blockchain state changes.

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/stream_coordinator.rs (L550-579)
```rust
    async fn ensure_highest_known_version(&mut self) -> bool {
        let mut empty_loops = 0;
        while self.highest_known_version == 0 || self.current_version > self.highest_known_version {
            if let Some(abort_handle) = self.abort_handle.as_ref() {
                if abort_handle.load(Ordering::SeqCst) {
                    return false;
                }
            }
            if empty_loops > 0 {
                tokio::time::sleep(Duration::from_millis(RETRY_TIME_MILLIS)).await;
            }
            empty_loops += 1;
            if let Err(err) = self.set_highest_known_version() {
                error!(
                    error = format!("{:?}", err),
                    "[Indexer Fullnode] Failed to set highest known version"
                );
                continue;
            } else {
                sample!(
                    SampleRate::Frequency(10),
                    info!(
                        highest_known_version = self.highest_known_version,
                        "[Indexer Fullnode] Found new highest known version",
                    )
                );
            }
        }
        true
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/localnet_data_service.rs (L79-88)
```rust
            let mut coordinator = IndexerStreamCoordinator::new(
                context,
                starting_version,
                ending_version,
                processor_task_count,
                processor_batch_size,
                output_batch_size,
                tx.clone(),
                filter,
                None,
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/runtime.rs (L31-32)
```rust
pub const DEFAULT_NUM_RETRIES: usize = 3;
pub const RETRY_TIME_MILLIS: u64 = 100;
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/runtime.rs (L101-104)
```rust
        let tonic_server = Server::builder()
            .http2_keepalive_interval(Some(std::time::Duration::from_secs(60)))
            .http2_keepalive_timeout(Some(std::time::Duration::from_secs(5)))
            .add_service(reflection_service_clone);
```

**File:** config/src/config/indexer_grpc_config.rs (L31-59)
```rust
#[derive(Clone, Deserialize, PartialEq, Eq, Serialize)]
#[serde(default, deny_unknown_fields)]
pub struct IndexerGrpcConfig {
    pub enabled: bool,

    /// If true, the GRPC stream interface exposed by the data service will be used
    /// instead of the standard fullnode GRPC stream interface. In other words, with
    /// this enabled, you can use an indexer fullnode like it is an instance of the
    /// indexer-grpc data service (aka the Transaction Stream Service API).
    pub use_data_service_interface: bool,

    /// The address that the grpc server will listen on.
    pub address: SocketAddr,

    /// Number of processor tasks to fan out
    pub processor_task_count: Option<u16>,

    /// Number of transactions each processor will process
    pub processor_batch_size: u16,

    /// Number of transactions returned in a single stream response
    pub output_batch_size: u16,

    /// Size of the transaction channel buffer for streaming.
    pub transaction_channel_size: usize,

    /// Maximum size in bytes for transaction filters.
    pub max_transaction_filter_size_bytes: usize,
}
```
