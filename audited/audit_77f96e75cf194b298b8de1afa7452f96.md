# Audit Report

## Title
Batch Transaction Deserialization Allows Resource Exhaustion DoS via Late Signature Validation

## Summary
The JSON batch transaction submission endpoint processes expensive payload operations (including module loading from storage) before validating Ed25519 signatures via TryFrom. An attacker can submit batches with intentionally malformed signatures placed at the end, causing the API server to waste resources on payload processing before the batch atomically fails.

## Finding Description

The `/transactions/batch` endpoint accepts batches of up to 10 transactions. When processing JSON-encoded batches, the implementation executes expensive operations before signature validation occurs, creating a resource exhaustion vulnerability. [1](#0-0) 

For each transaction in the batch, the code calls `try_into_signed_transaction_poem`, which creates a new state view and converter for EACH transaction: [2](#0-1) 

Within this function, the raw transaction payload is processed BEFORE the signature is validated. The payload processing includes: [3](#0-2) 

This `view_existing_module` call performs storage I/O to load the module: [4](#0-3) 

The signature validation via TryFrom only occurs AFTER all this expensive processing: [5](#0-4) 

The TryFrom implementation includes malleability checking: [6](#0-5) 

**Attack scenario:**
1. Attacker crafts a batch of 10 transactions via JSON
2. Transactions 0-8 reference complex entry functions requiring module loads
3. Transaction 9 has an intentionally malformed Ed25519 signature (e.g., non-canonical S component)
4. Server processes transactions 0-8: creates 9 state views, loads modules 9 times from storage, validates payloads
5. On transaction 9, TryFrom fails during signature malleability check
6. Entire batch atomically fails, but server has already consumed significant resources
7. Attacker repeats with concurrent batch requests to exhaust API server resources

Note that each transaction gets its own state view, preventing module cache sharing within a batch, amplifying the cost.

## Impact Explanation

This qualifies as **High Severity** per Aptos bug bounty criteria:
- **"Validator node slowdowns"** - If API nodes are co-located with or servicing validators, this DoS can impact validator operations
- **"API crashes"** - Sustained attacks could exhaust API server memory/CPU, causing crashes or severe degradation

The attack allows an unprivileged attacker to consume disproportionate server resources (storage I/O, CPU for deserialization) while submitting zero valid transactions to mempool. This breaks the **Resource Limits** invariant - operations should reject invalid inputs early before expensive processing.

## Likelihood Explanation

**Likelihood: High**

The attack is trivial to execute:
1. No authentication required for batch submission endpoint
2. Attacker can generate malformed signatures programmatically (e.g., set S â‰¥ L in Ed25519 signature)
3. Default batch size of 10 provides sufficient amplification
4. Can be repeated with concurrent requests
5. No apparent rate limiting on malformed batch submissions

The vulnerability is deterministic - every malformed batch will cause expensive processing before failure.

## Recommendation

Validate signatures BEFORE processing transaction payloads. Move signature deserialization and validation to occur before module loading and payload conversion.

**Proposed fix in `api/types/src/convert.rs`:**

```rust
pub fn try_into_signed_transaction_poem(
    &self,
    submit_transaction_request: SubmitTransactionRequest,
    chain_id: ChainId,
) -> Result<SignedTransaction> {
    let SubmitTransactionRequest {
        user_transaction_request,
        signature,
    } = submit_transaction_request;

    // VALIDATE SIGNATURE FIRST - before expensive payload processing
    let authenticator: TransactionAuthenticator = (&signature)
        .try_into()
        .context("Failed to parse transaction signature")?;

    // Now process payload (expensive)
    let raw_txn = self.try_into_raw_transaction_poem(
        user_transaction_request,
        chain_id,
    )?;

    Ok(SignedTransaction::new_signed_transaction(raw_txn, authenticator))
}
```

Additionally, consider:
1. Sharing state view across transactions in the same batch to enable module cache reuse
2. Implementing rate limiting on failed batch submissions per IP
3. Adding metrics to track batch failure reasons

## Proof of Concept

```rust
// PoC: Craft a batch with invalid signature at the end
// This would be submitted via REST API as JSON

use aptos_types::transaction::SignedTransaction;
use aptos_crypto::ed25519::Ed25519Signature;

// Create 9 valid transactions with complex entry functions
let mut batch = Vec::new();
for i in 0..9 {
    let txn = create_complex_entry_function_txn(i); // Valid signature
    batch.push(txn);
}

// Create 10th transaction with malformed signature
let mut malformed_sig_bytes = [0u8; 64];
// Set S component to L (order of curve), making it non-canonical
malformed_sig_bytes[32..].copy_from_slice(&[
    0xed, 0xd3, 0xf5, 0x5c, 0x1a, 0x63, 0x12, 0x58,
    0xd6, 0x9c, 0xf7, 0xa2, 0xde, 0xf9, 0xde, 0x14,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10
]); // S >= L fails malleability check

let malformed_txn = create_txn_with_signature(&malformed_sig_bytes);
batch.push(malformed_txn);

// Submit batch via POST to /transactions/batch as JSON
// Server will:
// 1. Load modules for transactions 0-8 (9 storage I/O operations)
// 2. Validate 9 payloads
// 3. Fail on transaction 9's signature check
// 4. Reject entire batch
// 5. Repeat attack to exhaust resources
```

**Notes**

The vulnerability is specific to JSON batch submission. BCS batch submission deserializes the entire batch atomically via `bcs::from_bytes_with_limit`, which would fail earlier without per-transaction payload processing. [7](#0-6) 

The atomic failure behavior is correct for consistency, but the timing of signature validation creates the DoS vector. Early signature validation would preserve atomic failure semantics while preventing resource exhaustion.

### Citations

**File:** api/src/transactions.rs (L1400-1409)
```rust
                let signed_transactions: Vec<SignedTransaction> =
                    bcs::from_bytes_with_limit(&data.0, Self::MAX_SIGNED_TRANSACTION_DEPTH)
                        .context("Failed to deserialize input into SignedTransaction")
                        .map_err(|err| {
                            SubmitTransactionError::bad_request_with_code(
                                err,
                                AptosErrorCode::InvalidInput,
                                ledger_info,
                            )
                        })?;
```

**File:** api/src/transactions.rs (L1416-1433)
```rust
            SubmitTransactionsBatchPost::Json(data) => data
                .0
                .into_iter()
                .enumerate()
                .map(|(index, txn)| {
                    self.context.latest_state_view_poem(ledger_info)?
                        .as_converter(self.context.db.clone(), self.context.indexer_reader.clone())
                        .try_into_signed_transaction_poem(txn, self.context.chain_id())
                        .context(format!("Failed to create SignedTransaction from SubmitTransactionRequest at position {}", index))
                        .map_err(|err| {
                            SubmitTransactionError::bad_request_with_code(
                                err,
                                AptosErrorCode::InvalidInput,
                                ledger_info,
                            )
                        })
                })
                .collect(),
```

**File:** api/types/src/convert.rs (L626-643)
```rust
    pub fn try_into_signed_transaction_poem(
        &self,
        submit_transaction_request: SubmitTransactionRequest,
        chain_id: ChainId,
    ) -> Result<SignedTransaction> {
        let SubmitTransactionRequest {
            user_transaction_request,
            signature,
        } = submit_transaction_request;

        Ok(SignedTransaction::new_signed_transaction(
            self.try_into_raw_transaction_poem(
                user_transaction_request,
                chain_id,
            )?,
            (&signature).try_into().context("Failed to parse transaction when building SignedTransaction from SubmitTransactionRequest")?,
        ))
    }
```

**File:** api/types/src/convert.rs (L699-703)
```rust
                let module_id: ModuleId = function.module.clone().into();
                let code = self.inner.view_existing_module(&module_id)? as Arc<dyn Bytecode>;
                let func = code
                    .find_entry_function(function.name.0.as_ident_str())
                    .ok_or_else(|| format_err!("could not find entry function by {}", function))?;
```

**File:** aptos-move/aptos-resource-viewer/src/module_view.rs (L62-67)
```rust
        let state_key = StateKey::module_id(module_id);
        Ok(
            match self
                .state_view
                .get_state_value_bytes(&state_key)
                .map_err(|e| anyhow!("Error retrieving module {:?}: {:?}", module_id, e))?
```

**File:** crates/aptos-crypto/src/ed25519/ed25519_sigs.rs (L168-178)
```rust
impl TryFrom<&[u8]> for Ed25519Signature {
    type Error = CryptoMaterialError;

    fn try_from(bytes: &[u8]) -> std::result::Result<Ed25519Signature, CryptoMaterialError> {
        // We leave this check here to detect mauled signatures earlier, since it does not hurt
        // performance much. (This check is performed again in Ed25519Signature::verify_arbitrary_msg
        // and in ed25519-dalek's verify_strict API.)
        Ed25519Signature::check_s_malleability(bytes)?;
        Ed25519Signature::from_bytes_unchecked(bytes)
    }
}
```
