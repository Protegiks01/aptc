# Audit Report

## Title
Cross-Chain Signature Replay Attack via Missing Chain ID in SignerCapabilityOfferProofChallengeV2

## Summary
The `SignerCapabilityOfferProofChallengeV2` structure used for delegating signer capabilities lacks a `chain_id` field, enabling signature replay attacks across different Aptos networks (mainnet, testnet, devnet). An attacker can observe a signer capability offer signature on one chain and replay it on another chain where the victim uses the same private key, granting unauthorized signer capability without the victim's consent.

## Finding Description

The vulnerability exists in the account capability delegation system. When analyzing signature verification for cross-chain contexts, I discovered an inconsistency in chain ID protection:

**RotationCapabilityOfferProofChallengeV2** (used for key rotation) correctly includes `chain_id`: [1](#0-0) 

However, **SignerCapabilityOfferProofChallengeV2** (used for signer capability delegation) is missing the `chain_id` field: [2](#0-1) 

The proof challenge is constructed in `offer_signer_capability()` without chain binding: [3](#0-2) 

The signature verification uses `signature_verify_strict_t`, which only provides domain separation via the Move type's `TypeInfo`, not chain ID: [4](#0-3) 

The `SignedMessage` structure wraps the challenge but does not include chain context: [5](#0-4) 

**Attack Scenario:**
1. Alice creates a transaction on **MAINNET** (chain_id=1) to offer signer capability to Bob with signature S
2. The signature is computed over: `SignedMessage<SignerCapabilityOfferProofChallengeV2>` containing {sequence_number, source_address, recipient_address}
3. An attacker observes transaction containing signature S on-chain
4. If Alice uses the same private key on **TESTNET** (chain_id=2) with matching sequence number, the attacker replays signature S
5. TESTNET accepts the signature because the proof challenge structure is identical (no chain_id differentiation)
6. Bob now has unauthorized signer capability over Alice's TESTNET account

The Aptos team recognized this issue when adding chain_id to `RotationCapabilityOfferProofChallengeV2`: [6](#0-5) 

But failed to apply the same fix to `SignerCapabilityOfferProofChallengeV2`.

## Impact Explanation

**Critical Severity - Loss of Funds**

Signer capability is the most powerful capability in Aptos, granting complete control over an account. An attacker who gains unauthorized signer capability can:
- Transfer all tokens and assets from the victim's account
- Execute arbitrary transactions on behalf of the victim
- Modify account resources and state
- Rotate authentication keys to permanently lock out the legitimate owner

This meets the **Critical** severity criteria for "Loss of Funds (theft)" per the Aptos bug bounty program. The attack enables complete account takeover across chains.

The vulnerability is particularly severe because:
- Many users test on testnet/devnet before mainnet deployment with the same keys
- Blockchain forks inherit the same state and key material
- All signer capability offer transactions are publicly visible on-chain
- The attack requires no special privileges beyond transaction observation

## Likelihood Explanation

**High Likelihood**

The attack is highly likely to occur because:

1. **Common user behavior**: Developers routinely use the same private keys across testnet and mainnet during development and testing
2. **Public signatures**: All `offer_signer_capability` transactions include signatures as parameters, making them trivially observable
3. **Network diversity**: Aptos has multiple production networks (MAINNET, TESTNET, DEVNET, PREMAINNET) as shown in ChainId definitions: [7](#0-6) 

4. **Sequence number alignment**: Users often have similar transaction patterns across chains, making sequence number matches probable
5. **No additional barriers**: The vulnerability requires only passive observation and transaction replayâ€”no cryptographic breaks or complex exploitation

## Recommendation

Add `chain_id` field to `SignerCapabilityOfferProofChallengeV2` to match the protection provided by `RotationCapabilityOfferProofChallengeV2`:

```move
struct SignerCapabilityOfferProofChallengeV2 has copy, drop {
    chain_id: u8,  // ADD THIS FIELD
    sequence_number: u64,
    source_address: address,
    recipient_address: address,
}
```

Update `offer_signer_capability()` to include chain_id:

```move
let proof_challenge = SignerCapabilityOfferProofChallengeV2 {
    chain_id: chain_id::get(),  // ADD THIS LINE
    sequence_number: get_sequence_number(source_address),
    source_address,
    recipient_address,
};
```

This mirrors the existing protection in `offer_rotation_capability()`: [8](#0-7) 

## Proof of Concept

```move
#[test_only]
module test_addr::cross_chain_replay_poc {
    use std::signer;
    use aptos_framework::account;
    use aptos_std::ed25519;
    
    #[test(alice = @0xa11ce, bob = @0xb0b)]
    fun test_cross_chain_signer_capability_replay(alice: &signer, bob: &signer) {
        // Setup: Alice creates accounts on both "chains" (simulated via separate test contexts)
        let alice_addr = signer::address_of(alice);
        let bob_addr = signer::address_of(bob);
        
        // Alice generates keys (same key pair used on both chains)
        let (sk, pk) = ed25519::generate_keys();
        
        // CHAIN 1 (e.g., MAINNET): Alice offers signer capability to Bob
        // Create SignerCapabilityOfferProofChallengeV2 WITHOUT chain_id
        let proof_challenge_chain1 = /* construct challenge with seq=1, alice_addr, bob_addr */;
        let signature = ed25519::sign_struct(&sk, proof_challenge_chain1);
        
        // Alice submits transaction on Chain 1
        // account::offer_signer_capability(alice, sig_bytes, scheme, pk_bytes, bob_addr);
        
        // CHAIN 2 (e.g., TESTNET): Attacker observes the signature from Chain 1
        // If Alice has same sequence number on Chain 2, attacker can replay:
        let proof_challenge_chain2 = /* IDENTICAL challenge: seq=1, alice_addr, bob_addr */;
        // Same signature validates because challenges are identical (no chain_id)
        
        // Attacker calls offer_signer_capability on Chain 2 with the same signature
        // Bob now has signer capability on Chain 2 WITHOUT Alice's explicit consent for Chain 2
        
        // Demonstrate: Bob can create signer for Alice's account on Chain 2
        // let alice_signer_on_chain2 = account::create_signer_with_capability(&chain2_capability);
        // Bob can now steal funds, modify state, etc. on Chain 2
    }
}
```

**Notes**

The vulnerability stems from incomplete application of the chain ID replay protection mechanism. While the Aptos team correctly identified and fixed the issue for rotation capabilities (as evidenced by the V2 structure and explicit comment about preventing replays), they overlooked applying the same fix to signer capability offers.

This is particularly concerning given that signer capability is arguably more dangerous than rotation capability, as it provides immediate transaction execution authority rather than just key management control.

The fix is straightforward and follows the established pattern already present in the codebase for `RotationCapabilityOfferProofChallengeV2`.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/account/account.move (L135-143)
```text
    /// This struct stores the challenge message that should be signed by the source account, when the source account
    /// is delegating its rotation capability to the `recipient_address`.
    /// This V2 struct adds the `chain_id` and `source_address` to the challenge message, which prevents replaying the challenge message.
    struct RotationCapabilityOfferProofChallengeV2 has drop {
        chain_id: u8,
        sequence_number: u64,
        source_address: address,
        recipient_address: address,
    }
```

**File:** aptos-move/framework/aptos-framework/sources/account/account.move (L145-149)
```text
    struct SignerCapabilityOfferProofChallengeV2 has copy, drop {
        sequence_number: u64,
        source_address: address,
        recipient_address: address,
    }
```

**File:** aptos-move/framework/aptos-framework/sources/account/account.move (L777-782)
```text
        let proof_challenge = RotationCapabilityOfferProofChallengeV2 {
            chain_id: chain_id::get(),
            sequence_number: account_resource.sequence_number,
            source_address: addr,
            recipient_address,
        };
```

**File:** aptos-move/framework/aptos-framework/sources/account/account.move (L922-926)
```text
        let proof_challenge = SignerCapabilityOfferProofChallengeV2 {
            sequence_number: get_sequence_number(source_address),
            source_address,
            recipient_address,
        };
```

**File:** aptos-move/framework/aptos-stdlib/sources/cryptography/ed25519.move (L44-48)
```text
    /// A BCS-serializable message, which one can verify signatures on via `signature_verify_strict_t`
    struct SignedMessage<MessageType> has drop {
        type_info: TypeInfo,
        inner: MessageType,
    }
```

**File:** aptos-move/framework/aptos-stdlib/sources/cryptography/ed25519.move (L142-149)
```text
    public fun signature_verify_strict_t<T: drop>(signature: &Signature, public_key: &UnvalidatedPublicKey, data: T): bool {
        let encoded = SignedMessage {
            type_info: type_info::type_of<T>(),
            inner: data,
        };

        signature_verify_strict_internal(signature.bytes, public_key.bytes, bcs::to_bytes(&encoded))
    }
```

**File:** types/src/chain_id.rs (L11-24)
```rust
#[repr(u8)]
#[derive(Copy, Clone, Debug, Eq, PartialEq)]
pub enum NamedChain {
    /// Users might accidentally initialize the ChainId field to 0, hence reserving ChainId 0 for accidental
    /// initialization.
    /// MAINNET is the Aptos mainnet production chain and is reserved for 1
    MAINNET = 1,
    // Even though these CHAIN IDs do not correspond to MAINNET, changing them should be avoided since they
    // can break test environments for various organisations.
    TESTNET = 2,
    DEVNET = 3,
    TESTING = 4,
    PREMAINNET = 5,
}
```
