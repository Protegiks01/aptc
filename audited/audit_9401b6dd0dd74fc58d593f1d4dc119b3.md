# Audit Report

## Title
Private Function Visibility Bypass via View Function Attribute

## Summary
The `is_valid_view_function()` validation function and the extended checks during module publishing fail to verify function visibility when processing `#[view]` attributes. This allows private functions to be marked as view functions and subsequently invoked externally via the view API, bypassing Move's intended access control model.

## Finding Description

Move's visibility system enforces three access levels: **Private** (callable only within the same module), **Public** (callable from anywhere), and **Friend** (callable from friend modules). This is a fundamental security boundary in Move. [1](#0-0) 

The vulnerability exists in the view function validation logic. When a module is published, the `is_valid_view_function()` checks if functions marked with `#[view]` meet basic requirements: [2](#0-1) 

At line 384, the function retrieves both `func_handle` and `func_def` from the functions map. The `func_def` contains the `visibility` field: [3](#0-2) 

However, `is_valid_view_function()` only validates that the function has a non-empty return signature (line 386-387) and **never checks the visibility field**. The `_func_def` parameter is ignored.

Similarly, the extended checker's `check_and_record_view_functions()` validates signer parameters and return values but does not check visibility: [4](#0-3) 

This is confirmed by the test suite, where a private function with `#[view]` successfully publishes: [5](#0-4) 

When view functions are invoked via the API, they are executed as entry points without a caller context: [6](#0-5) 

The function is loaded and executed directly (line 2751-2783) without any visibility checks, because visibility checks only apply to cross-module calls during normal execution: [7](#0-6) 

**Attack Scenario:**

A module developer creates a private helper function that exposes sensitive data or logic, assuming it can only be called internally with proper authorization checks:

```move
module attacker::vault {
    struct SecretData has key {
        secret: vector<u8>,
        owner: address,
    }
    
    // Public function requires signer (authorization)
    public fun get_my_secret(account: &signer): vector<u8> acquires SecretData {
        let addr = signer::address_of(account);
        read_secret_internal(addr)
    }
    
    // Private helper - incorrectly marked as view
    #[view]
    fun read_secret_internal(addr: address): vector<u8> acquires SecretData {
        borrow_global<SecretData>(addr).secret
    }
}
```

An attacker can now call `read_secret_internal()` directly via the view API without providing a signer, bypassing the authorization check in `get_my_secret()`.

## Impact Explanation

**Severity: High**

This vulnerability breaks the **Access Control** invariant (Invariant #8) from the Aptos security model. It allows:

1. **Information Disclosure**: Private functions designed to return sensitive data only through authorized public functions can be called by anyone
2. **Logic Bypass**: Private helper functions that assume certain preconditions (established by their callers) can be invoked with arbitrary parameters
3. **Unintended State Exposure**: Read-only access to module internals that should be encapsulated

While view functions cannot permanently modify state (they execute in a read-only session), they can leak sensitive information and break encapsulation guarantees that module developers rely on.

This qualifies as **High Severity** per the Aptos bug bounty program: "Significant protocol violations" - specifically, violation of Move's fundamental visibility and access control model.

## Likelihood Explanation

**Likelihood: Medium-High**

- **Ease of Exploitation**: Trivial - attacker only needs to identify private view functions and call them via the public API
- **Attack Requirements**: No special privileges required, just API access
- **Developer Error Factor**: Module developers may accidentally mark private functions as view, especially when refactoring or if they don't understand the security implications
- **Code Pattern**: Private helper functions are common in Move modules for code organization

The test suite already demonstrates this works (test_view_attribute), indicating it's a known code pattern that developers might use without understanding the security implications.

## Recommendation

Add visibility checks to both validation functions:

**Fix for `is_valid_view_function()` in types/src/vm/module_metadata.rs:**

```rust
pub fn is_valid_view_function(
    module: &CompiledModule,
    functions: &BTreeMap<&IdentStr, (&FunctionHandle, &FunctionDefinition)>,
    fun: &str,
) -> Result<(), AttributeValidationError> {
    if let Ok(ident_fun) = Identifier::new(fun) {
        if let Some((func_handle, func_def)) = functions.get(ident_fun.as_ident_str()) {
            // Check visibility - view functions must be public
            if !func_def.visibility.is_public() {
                return Err(AttributeValidationError {
                    key: fun.to_string(),
                    attribute: KnownAttributeKind::ViewFunction as u8,
                });
            }
            
            let sig = module.signature_at(func_handle.return_);
            if !sig.0.is_empty() {
                return Ok(());
            }
        }
    }
    
    Err(AttributeValidationError {
        key: fun.to_string(),
        attribute: KnownAttributeKind::ViewFunction as u8,
    })
}
```

**Fix for `check_and_record_view_functions()` in aptos-move/framework/src/extended_checks.rs:**

```rust
fn check_and_record_view_functions(&mut self, module: &ModuleEnv) {
    for ref fun in module.get_functions() {
        if !self.has_attribute(fun, VIEW_FUN_ATTRIBUTE) {
            continue;
        }
        
        // Check visibility - view functions must be public
        if fun.visibility() != Visibility::Public {
            self.env.error(
                &fun.get_id_loc(),
                "`#[view]` functions must be public"
            );
            continue;
        }
        
        self.check_transaction_args(&fun.get_parameters());
        // ... rest of existing checks
    }
}
```

## Proof of Concept

**Move Test Module:**

```move
#[test_only]
module 0xcafe::poc_visibility_bypass {
    struct Vault has key {
        secret_balance: u64,
        owner: address,
    }
    
    // Public function with proper authorization
    public fun get_balance(account: &signer): u64 acquires Vault {
        let addr = signer::address_of(account);
        assert!(exists<Vault>(addr), 1);
        get_balance_internal(addr)
    }
    
    // VULNERABILITY: Private function marked as view
    // Should only be callable from get_balance() with signer proof
    #[view]
    fun get_balance_internal(addr: address): u64 acquires Vault {
        borrow_global<Vault>(addr).secret_balance
    }
    
    #[test(admin = @0xcafe, victim = @0xbeef)]
    public fun test_visibility_bypass(admin: &signer, victim: &signer) acquires Vault {
        // Setup: victim has a vault
        move_to(victim, Vault { 
            secret_balance: 1000000, 
            owner: signer::address_of(victim) 
        });
        
        // Attack: Anyone can call private function via view API
        // In real scenario, this would be: POST /view with function "0xcafe::poc::get_balance_internal"
        let leaked_balance = get_balance_internal(signer::address_of(victim));
        assert!(leaked_balance == 1000000, 2);
        
        // This should fail without signer, but view API allows it!
    }
}
```

**Notes**

This vulnerability represents a fundamental flaw in the view function validation logic. The fix is straightforward but critical: view functions should be restricted to public visibility only. Private and friend functions should be rejected during module publishing if marked with `#[view]`. This preserves Move's visibility model and prevents unintended exposure of module internals through the view API.

### Citations

**File:** third_party/move/move-binary-format/src/file_format.rs (L648-659)
```rust
pub enum Visibility {
    /// Accessible within its defining module only.
    #[default]
    Private = 0x0,
    /// Accessible by any module or script outside of its declaring module.
    Public = 0x1,
    // DEPRECATED for separate entry modifier
    // Accessible by any script or other `Script` functions from any module
    // Script = 0x2,
    /// Accessible by this module as well as modules declared in the friend list.
    Friend = 0x3,
}
```

**File:** third_party/move/move-binary-format/src/file_format.rs (L701-725)
```rust
pub struct FunctionDefinition {
    /// The prototype of the function (module, name, signature).
    pub function: FunctionHandleIndex,
    /// The visibility of this function.
    pub visibility: Visibility,
    /// Marker if the function is intended as an entry function. That is
    pub is_entry: bool,
    /// List of locally defined types (declared in this module) with the `Key` ability
    /// that the procedure might access, either through: BorrowGlobal, MoveFrom, or transitively
    /// through another procedure
    /// This list of acquires grants the borrow checker the ability to statically verify the safety
    /// of references into global storage
    ///
    /// Not in the signature as it is not needed outside of the declaring module
    ///
    /// Note, there is no SignatureIndex with each struct definition index, so all instantiations of
    /// that type are considered as being acquired
    pub acquires_global_resources: Vec<StructDefinitionIndex>,
    /// Code for this function.
    #[cfg_attr(
        any(test, feature = "fuzzing"),
        proptest(strategy = "any_with::<CodeUnit>(params).prop_map(Some)")
    )]
    pub code: Option<CodeUnit>,
}
```

**File:** types/src/vm/module_metadata.rs (L378-396)
```rust
pub fn is_valid_view_function(
    module: &CompiledModule,
    functions: &BTreeMap<&IdentStr, (&FunctionHandle, &FunctionDefinition)>,
    fun: &str,
) -> Result<(), AttributeValidationError> {
    if let Ok(ident_fun) = Identifier::new(fun) {
        if let Some((func_handle, _func_def)) = functions.get(ident_fun.as_ident_str()) {
            let sig = module.signature_at(func_handle.return_);
            if !sig.0.is_empty() {
                return Ok(());
            }
        }
    }

    Err(AttributeValidationError {
        key: fun.to_string(),
        attribute: KnownAttributeKind::ViewFunction as u8,
    })
}
```

**File:** aptos-move/framework/src/extended_checks.rs (L689-741)
```rust
    fn check_and_record_view_functions(&mut self, module: &ModuleEnv) {
        for ref fun in module.get_functions() {
            if !self.has_attribute(fun, VIEW_FUN_ATTRIBUTE) {
                continue;
            }
            self.check_transaction_args(&fun.get_parameters());
            if fun.get_return_count() == 0 {
                self.env
                    .error(&fun.get_id_loc(), "`#[view]` function must return values")
            }

            fun.get_parameters()
                .iter()
                .for_each(
                    |Parameter(_sym, parameter_type, param_loc)| match parameter_type {
                        Type::Primitive(inner) => {
                            if inner == &PrimitiveType::Signer {
                                self.env.error(
                                    param_loc,
                                    "`#[view]` function cannot use a `signer` parameter",
                                )
                            }
                        },
                        Type::Reference(mutability, inner) => {
                            if let Type::Primitive(inner) = inner.as_ref() {
                                if inner == &PrimitiveType::Signer
                                // Avoid a redundant error message for `&mut signer`, which is
                                // always disallowed for transaction entries, not just for
                                // `#[view]`.
                                    && mutability == &ReferenceKind::Immutable
                                {
                                    self.env.error(
                                        param_loc,
                                        "`#[view]` function cannot use the `&signer` parameter",
                                    )
                                }
                            }
                        },
                        _ => (),
                    },
                );

            // Remember the runtime info that this is a view function
            let module_id = self.get_runtime_module_id(module);
            self.output
                .entry(module_id)
                .or_default()
                .fun_attributes
                .entry(fun.get_simple_name_string().to_string())
                .or_default()
                .push(KnownAttribute::view_function());
        }
    }
```

**File:** aptos-move/e2e-move-tests/src/tests/attributes.rs (L18-35)
```rust
#[test]
fn test_view_attribute() {
    let mut h = MoveHarness::new();
    let account = h.new_account_at(AccountAddress::from_hex_literal("0xf00d").unwrap());

    let mut builder = PackageBuilder::new("Package");
    builder.add_source(
        "m.move",
        r#"
        module 0xf00d::M {
            #[view]
            fun view(value: u64): u64 { value }
        }
        "#,
    );
    let path = builder.write_to_temp().unwrap();
    assert_success!(h.publish_package(&account, path.path()));
}
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L2739-2790)
```rust
    fn execute_view_function_in_vm(
        session: &mut SessionExt<impl AptosMoveResolver>,
        vm: &AptosVM,
        module_id: ModuleId,
        func_name: Identifier,
        ty_args: Vec<TypeTag>,
        arguments: Vec<Vec<u8>>,
        gas_meter: &mut impl AptosGasMeter,
        traversal_context: &mut TraversalContext,
        module_storage: &impl AptosModuleStorage,
    ) -> Result<Vec<Vec<u8>>, VMError> {
        dispatch_loader!(module_storage, loader, {
            let func = loader.load_instantiated_function(
                &LegacyLoaderConfig::unmetered(),
                gas_meter,
                traversal_context,
                &module_id,
                &func_name,
                &ty_args,
            )?;

            let metadata = get_metadata(&func.owner_as_module()?.metadata);

            let arguments = view_function::validate_view_function(
                session,
                &loader,
                gas_meter,
                traversal_context,
                arguments,
                func_name.as_ident_str(),
                &func,
                metadata.as_ref().map(Arc::as_ref),
                vm.features().is_enabled(FeatureFlag::STRUCT_CONSTRUCTORS),
            )
            .map_err(|e| e.finish(Location::Module(module_id)))?;

            let result = session.execute_loaded_function(
                func,
                arguments,
                gas_meter,
                traversal_context,
                &loader,
                // No need to record any traces for view functions.
                &mut NoOpTraceRecorder,
            )?;

            Ok(result
                .return_values
                .into_iter()
                .map(|(bytes, _ty)| bytes)
                .collect::<Vec<_>>())
        })
```

**File:** third_party/move/move-vm/runtime/src/runtime_type_checks.rs (L42-81)
```rust
    fn check_call_visibility(
        caller: &LoadedFunction,
        callee: &LoadedFunction,
        call_type: CallType,
    ) -> PartialVMResult<()> {
        match call_type {
            CallType::Regular => {
                // We only need to check cross-contract calls.
                if caller.module_id() == callee.module_id() {
                    return Ok(());
                }
                Self::check_cross_module_regular_call_visibility(caller, callee)
            },
            CallType::ClosureDynamicDispatch => {
                // In difference to regular calls, we skip visibility check. It is possible to call
                // a private function of another module via a closure.
                Ok(())
            },
            CallType::NativeDynamicDispatch => {
                // Dynamic dispatch may fail at runtime and this is ok. Hence, these errors are not
                // invariant violations as they cannot be checked at compile- or load-time.
                //
                // Note: native dispatch cannot call into the same module, otherwise the reentrancy
                // check is broken. For more details, see AIP-73:
                //   https://github.com/aptos-foundation/AIPs/blob/main/aips/aip-73.md
                if callee.is_friend_or_private() || callee.module_id() == caller.module_id() {
                    return Err(PartialVMError::new(StatusCode::RUNTIME_DISPATCH_ERROR)
                        .with_message(
                            "Invoking private or friend function during dispatch".to_string(),
                        ));
                }

                if callee.is_native() {
                    return Err(PartialVMError::new(StatusCode::RUNTIME_DISPATCH_ERROR)
                        .with_message("Invoking native function during dispatch".to_string()));
                }
                Ok(())
            },
        }
    }
```
