# Audit Report

## Title
Reentrant Memory Allocation in jemalloc Callback Causes Potential Deadlock and Node Crash

## Summary
The `write_cb()` function in `malloc.rs` incorrectly uses `out.capacity()` instead of `out.capacity() - out.len()` when limiting writes during jemalloc statistics collection. This causes Vec reallocation on subsequent callback invocations, triggering reentrant calls to the jemalloc allocator from within its own callback, leading to potential deadlock or undefined behavior that can crash validator nodes. [1](#0-0) 

## Finding Description

**Important Clarification**: This is NOT a traditional "buffer overflow" in the sense of writing past allocated memory boundaries. Rust's memory safety guarantees prevent that. However, there IS a critical bug that breaks the intended safety invariant of the callback.

The `write_cb()` callback is invoked multiple times by `jemalloc_sys::malloc_stats_print()` to output statistics in chunks. The code attempts to prevent memory allocation during the callback by pre-allocating a buffer and limiting writes to capacity. However, the implementation is incorrect: [2](#0-1) 

The bug: Line 19 uses `out.capacity()` (total allocated space) instead of `out.capacity() - out.len()` (remaining space). On subsequent callback invocations:

**First callback invocation:**
- `out.len() = 0`, `out.capacity() = 2MB` (default: [3](#0-2) )
- `len = min(2MB, stats_cstr.len())`
- After extend: `out.len() = len`

**Second callback invocation:**
- `out.len() = len` (non-zero), `out.capacity() = 2MB`
- `len = min(2MB, stats_cstr.len())` 
- `extend_from_slice` needs `out.len() + len` total space
- If `out.len() + len > 2MB`, **Vec reallocates**

Since jemalloc is the global allocator ( [4](#0-3) ), Vec reallocation calls back into jemalloc's malloc/realloc while still inside `malloc_stats_print`. This violates the explicit invariant stated in the code comment [5](#0-4) .

**Attack Vector**: The `/malloc/stats` endpoint is exposed via the admin service [6](#0-5) . When jemalloc has accumulated sufficient statistics (from normal node operation with many allocations), its output can easily exceed 2MB across multiple callback invocations, triggering the reallocation bug.

## Impact Explanation

**Severity: High** (per Aptos Bug Bounty categories)

This qualifies as "Validator node slowdowns" and "API crashes" because:

1. **Deadlock Risk**: Reentrant jemalloc calls can deadlock if internal locks are held during stats printing, causing the validator node to hang completely
2. **Undefined Behavior**: Violating jemalloc's callback contract can cause memory corruption or crashes
3. **Node Availability**: Affects the node's ability to process blocks and participate in consensus
4. **Denial of Service**: Can be triggered remotely via HTTP endpoint

While the admin service requires authentication on mainnet ( [7](#0-6) ), it may be unauthenticated on testnet, and even authenticated operators can accidentally trigger this during routine debugging.

## Likelihood Explanation

**Likelihood: Medium-High**

- Jemalloc statistics output size is unpredictable and depends on allocation patterns
- Validator nodes under load (processing many transactions) accumulate large statistics
- The default 2MB buffer can be exceeded in production scenarios
- Multiple callback invocations are normal behavior for `malloc_stats_print`
- No special attacker capabilities required beyond endpoint access
- Can occur during routine operational monitoring

## Recommendation

Replace line 19 to correctly calculate remaining buffer space:

```rust
let len = std::cmp::min(out.capacity() - out.len(), stats_cstr.len());
```

This ensures writes stay within pre-allocated capacity, preventing any reallocation. If statistics exceed the buffer, they will be truncated gracefully without allocation.

Alternative: Add explicit check to stop accepting data once capacity is reached:

```rust
let remaining = out.capacity() - out.len();
if remaining == 0 {
    return; // Buffer full, stop accepting more data
}
let len = std::cmp::min(remaining, stats_cstr.len());
out.extend_from_slice(&stats_cstr[0..len]);
```

## Proof of Concept

```rust
// Add to crates/aptos-admin-service/src/server/malloc.rs tests
#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_write_cb_reallocation_bug() {
        // Simulate multiple callback invocations with capacity exceeded
        let max_len = 100; // Small capacity to trigger issue
        let mut stats = Vec::with_capacity(max_len);
        
        // First callback - fills 80 bytes
        let chunk1 = vec![b'A'; 80];
        let chunk1_cstr = std::ffi::CString::new(chunk1).unwrap();
        unsafe {
            write_cb(
                &mut stats as *mut _ as *mut std::ffi::c_void,
                chunk1_cstr.as_ptr(),
            );
        }
        assert_eq!(stats.len(), 80);
        assert_eq!(stats.capacity(), 100); // No reallocation yet
        
        // Second callback - tries to add 80 more bytes
        // With buggy code: len = min(100, 80) = 80
        // Needs: 80 + 80 = 160 > 100 capacity -> REALLOCATION!
        let chunk2 = vec![b'B'; 80];
        let chunk2_cstr = std::ffi::CString::new(chunk2).unwrap();
        
        let old_capacity = stats.capacity();
        unsafe {
            write_cb(
                &mut stats as *mut _ as *mut std::ffi::c_void,
                chunk2_cstr.as_ptr(),
            );
        }
        
        // BUG: Reallocation occurred during callback
        assert!(stats.capacity() > old_capacity, 
                "Reallocation occurred! capacity changed from {} to {}", 
                old_capacity, stats.capacity());
        
        // This proves the bug: allocation happened in callback,
        // which would deadlock if called from within jemalloc
    }
}
```

**Notes**

While the security question mentions "buffer overflow" and "write beyond buffer boundaries," these terms are imprecise in the Rust context. Rust's Vec type is memory-safe and cannot write past allocated memory. The actual vulnerability is **reentrant allocation** - calling the allocator from within its own callback - which violates jemalloc's safety contract and can cause deadlock, crashes, or undefined behavior. This is still a serious security issue affecting node availability, qualifying as High severity under the Aptos bug bounty program.

### Citations

**File:** crates/aptos-admin-service/src/server/malloc.rs (L14-20)
```rust
unsafe extern "C" fn write_cb(buf: *mut c_void, s: *const c_char) {
    let out = unsafe { &mut *(buf as *mut Vec<u8>) };
    let stats_cstr = unsafe { CStr::from_ptr(s).to_bytes() };
    // We do not want any memory allocation in the callback.
    let len = std::cmp::min(out.capacity(), stats_cstr.len());
    out.extend_from_slice(&stats_cstr[0..len]);
}
```

**File:** config/src/config/admin_service_config.rs (L48-48)
```rust
            malloc_stats_max_len: 2 * 1024 * 1024,
```

**File:** config/src/config/admin_service_config.rs (L69-75)
```rust
                if chain_id.is_mainnet()
                    && node_config.admin_service.authentication_configs.is_empty()
                {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name,
                        "Must enable authentication for AdminService on mainnet.".into(),
                    ));
```

**File:** aptos-node/src/main.rs (L11-12)
```rust
#[global_allocator]
static ALLOC: jemallocator::Jemalloc = jemallocator::Jemalloc;
```

**File:** crates/aptos-admin-service/src/server/mod.rs (L189-191)
```rust
            (hyper::Method::GET, "/malloc/stats") => {
                malloc::handle_malloc_stats_request(context.config.malloc_stats_max_len)
            },
```
