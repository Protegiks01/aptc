# Audit Report

## Title
Ed25519PrivateKey Memory Exposure Risk Due to Missing Zeroization in Genesis Builder

## Summary
The `Builder::build()` function returns the genesis `root_key` as `Ed25519PrivateKey` by value without implementing memory zeroization. This violates Aptos's documented secure coding guidelines and creates a risk of sensitive key material remaining in memory, potentially exposing it to memory-based attacks. However, this issue is limited to test/development environments and requires local system access to exploit.

## Finding Description

The `Ed25519PrivateKey` type does not implement the `Zeroize` trait, which is explicitly required by Aptos's secure coding guidelines: [1](#0-0) [2](#0-1) 

The `Ed25519PrivateKey` struct definition lacks zeroization: [3](#0-2) 

The `Builder::build()` function returns this sensitive key material directly: [4](#0-3) [5](#0-4) 

When returned, the key is subsequently serialized and written to files: [6](#0-5) 

In test environments, this root_key controls the `@core_resources` account with mint capabilities: [7](#0-6) [8](#0-7) 

The `@core_resources` account receives unlimited minting capability: [9](#0-8) [10](#0-9) 

## Impact Explanation

**Why Medium Severity:**

This issue represents a violation of documented security standards that creates unnecessary risk. However, its practical impact is significantly limited:

1. **Limited Scope**: Only affects test/development environments where `is_test=true`
2. **Already Exposed**: The key is intentionally written to files (`mint.key`, `root_key`, `root_key.bin`) in all observed usage patterns
3. **Requires Local Access**: Exploitation requires memory access via core dumps, memory inspection tools, or similar techniques
4. **No Production Impact**: Production genesis does not use this mechanism or grant mint capabilities

If exploited in a test environment with local access, an attacker could:
- Extract the root_key from process memory
- Sign transactions as `@core_resources`
- Call `aptos_coin::mint()` to create unlimited APT tokens
- Manipulate test economics or governance through stake

This fits the **Medium Severity** category: "Limited funds loss or manipulation" in the context of test environments, combined with "State inconsistencies requiring intervention."

## Likelihood Explanation

**Likelihood: Low**

Multiple factors reduce the likelihood of exploitation:

1. **Local Access Required**: Attacker must have access to read process memory (via debugger, core dump analysis, cold boot attack, or memory scanning)
2. **Test Environment Only**: Vulnerability only exists where `is_test=true`, which is not production
3. **Key Already Persisted**: In all observed usage patterns, the key is written to files, providing an easier attack vector than memory extraction
4. **Time Window**: The key must be extracted from memory before it's naturally overwritten by other operations
5. **Limited Value**: The compromised key only provides privileges in test/development networks, not production

An attacker with local system access would typically have easier methods to compromise the system (e.g., reading the persisted key files directly).

## Recommendation

**1. Implement Zeroize for Ed25519PrivateKey:**

Add the `zeroize` dependency and implement the trait:

```rust
use zeroize::{Zeroize, ZeroizeOnDrop};

#[derive(DeserializeKey, SerializeKey, SilentDebug, SilentDisplay, Zeroize, ZeroizeOnDrop)]
pub struct Ed25519PrivateKey(pub(crate) ed25519_dalek::SecretKey);
```

**2. Consider Wrapper Types for Sensitive Operations:**

For genesis operations, consider wrapping the key in a secure container that enforces zeroization:

```rust
use zeroize::Zeroizing;

pub fn build<R>(
    mut self,
    mut rng: R,
) -> anyhow::Result<(
    Zeroizing<Ed25519PrivateKey>,  // Wrapped in Zeroizing
    Transaction,
    Waypoint,
    Vec<ValidatorNodeConfig>,
)>
```

**3. Document Memory Security Requirements:**

Add documentation to `Builder::build()` explicitly stating that callers must handle the returned key securely and should zeroize it after use.

## Proof of Concept

```rust
#[cfg(test)]
mod memory_exposure_test {
    use super::*;
    use rand::rngs::StdRng;
    use rand::SeedableRng;
    
    #[test]
    fn test_root_key_remains_in_memory() {
        // Setup
        let temp_dir = tempfile::tempdir().unwrap();
        let framework = aptos_cached_packages::head_release_bundle().clone();
        let rng = StdRng::from_entropy();
        
        // Build genesis and get root_key
        let builder = Builder::new(temp_dir.path(), framework).unwrap();
        let (root_key, _genesis, _waypoint, _validators) = builder.build(rng).unwrap();
        
        // Serialize the key to demonstrate memory copies
        let serialized = bcs::to_bytes(&root_key).unwrap();
        
        // At this point, multiple copies of the key exist in memory:
        // 1. The original root_key
        // 2. The serialized form
        // 3. Any intermediate copies during return
        
        // Drop the root_key
        drop(root_key);
        drop(serialized);
        
        // VULNERABILITY: The key material has NOT been zeroized from memory
        // In a real attack, memory scanning here could recover the key
        
        // This test demonstrates that without Zeroize implementation,
        // sensitive key material persists in memory after being dropped
    }
}
```

## Notes

While this finding represents a legitimate security concern and violation of Aptos's documented secure coding standards, its practical exploitability is severely constrained:

- **Defense-in-depth issue**: Rather than a direct vulnerability, this is a failure to implement defense-in-depth measures
- **Test environment scope**: The actual security impact is limited to test/development scenarios
- **Intentional persistence**: The key is deliberately written to files in all observed usage patterns, making memory extraction unnecessary
- **Local access requirement**: Any attacker with sufficient access to read process memory would have easier attack vectors available

This issue should be addressed to maintain consistency with secure coding practices and provide proper defense-in-depth, but it does not represent a critical or high-severity vulnerability in production environments.

### Citations

**File:** RUST_SECURE_CODING.md (L96-96)
```markdown
Do not rely on `Drop` trait in security material treatment after the use, use [zeroize](https://docs.rs/zeroize/latest/zeroize/#) to explicit destroy security material, e.g. private keys.
```

**File:** RUST_SECURE_CODING.md (L145-145)
```markdown
Use [zeroize](https://docs.rs/zeroize/latest/zeroize/#) for zeroing memory containing sensitive data.
```

**File:** crates/aptos-crypto/src/ed25519/ed25519_keys.rs (L23-24)
```rust
#[derive(DeserializeKey, SerializeKey, SilentDebug, SilentDisplay)]
pub struct Ed25519PrivateKey(pub(crate) ed25519_dalek::SecretKey);
```

**File:** crates/aptos-genesis/src/builder.rs (L514-522)
```rust
    pub fn build<R>(
        mut self,
        mut rng: R,
    ) -> anyhow::Result<(
        Ed25519PrivateKey,
        Transaction,
        Waypoint,
        Vec<ValidatorNodeConfig>,
    )>
```

**File:** crates/aptos-genesis/src/builder.rs (L552-552)
```rust
        Ok((root_key, genesis, waypoint, validators))
```

**File:** aptos-node/src/lib.rs (L616-621)
```rust
    let (root_key, _genesis, genesis_waypoint, mut validators) = builder.build(rng)?;

    // Write the mint key to disk
    let serialized_keys = bcs::to_bytes(&root_key)?;
    let mut key_file = fs::File::create(aptos_root_key_path)?;
    key_file.write_all(&serialized_keys)?;
```

**File:** aptos-move/vm-genesis/src/lib.rs (L312-318)
```rust
    if genesis_config.is_test {
        initialize_core_resources_and_aptos_coin(
            &mut session,
            &module_storage,
            &mut traversal_context,
            core_resources_key,
        );
```

**File:** aptos-move/framework/aptos-framework/sources/genesis.move (L153-173)
```text
    fun initialize_core_resources_and_aptos_coin(
        aptos_framework: &signer,
        core_resources_auth_key: vector<u8>,
    ) {
        let (burn_cap, mint_cap) = aptos_coin::initialize(aptos_framework);

        coin::create_coin_conversion_map(aptos_framework);
        coin::create_pairing<AptosCoin>(aptos_framework);

        // Give stake module MintCapability<AptosCoin> so it can mint rewards.
        stake::store_aptos_coin_mint_cap(aptos_framework, mint_cap);
        // Give transaction_fee module BurnCapability<AptosCoin> so it can burn gas.
        transaction_fee::store_aptos_coin_burn_cap(aptos_framework, burn_cap);
        // Give transaction_fee module MintCapability<AptosCoin> so it can mint refunds.
        transaction_fee::store_aptos_coin_mint_cap(aptos_framework, mint_cap);

        let core_resources = account::create_account(@core_resources);
        account::rotate_authentication_key_internal(&core_resources, core_resources_auth_key);
        aptos_account::register_apt(&core_resources); // registers APT store
        aptos_coin::configure_accounts_for_test(aptos_framework, &core_resources, mint_cap);
    }
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_coin.move (L73-89)
```text
    public(friend) fun configure_accounts_for_test(
        aptos_framework: &signer,
        core_resources: &signer,
        mint_cap: MintCapability<AptosCoin>,
    ) {
        system_addresses::assert_aptos_framework(aptos_framework);

        // Mint the core resource account AptosCoin for gas so it can execute system transactions.
        let coins = coin::mint<AptosCoin>(
            18446744073709551615,
            &mint_cap,
        );
        coin::deposit<AptosCoin>(signer::address_of(core_resources), coins);

        move_to(core_resources, MintCapStore { mint_cap });
        move_to(core_resources, Delegations { inner: vector::empty() });
    }
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_coin.move (L93-108)
```text
    public entry fun mint(
        account: &signer,
        dst_addr: address,
        amount: u64,
    ) acquires MintCapStore {
        let account_addr = signer::address_of(account);

        assert!(
            exists<MintCapStore>(account_addr),
            error::not_found(ENO_CAPABILITIES),
        );

        let mint_cap = &borrow_global<MintCapStore>(account_addr).mint_cap;
        let coins_minted = coin::mint<AptosCoin>(amount, mint_cap);
        coin::deposit<AptosCoin>(dst_addr, coins_minted);
    }
```
