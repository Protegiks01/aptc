# Audit Report

## Title
Incomplete Key Binding Verification in EncryptionKey::verify_decryption_key() Allows Cross-Context Key Confusion

## Summary
The `EncryptionKey::verify_decryption_key()` function only verifies the `sig_mpk_g2` component of the encryption key but ignores the `tau_g2` component, allowing decryption keys to verify against encryption keys they weren't intended for, creating a verification bypass vulnerability.

## Finding Description

The BIBE (Batch Identity-Based Encryption) scheme used in Aptos batch encryption requires two cryptographic components to work correctly together:
1. `sig_mpk_g2` - The master public key for BLS signature verification
2. `tau_g2` - The trapdoor parameter used in encryption and digest proof verification

The security model requires that a decryption key derived for a specific `(sig_mpk_g2, tau_g2)` pair should ONLY verify against an `EncryptionKey` with that exact same pair. However, the verification function only checks half of this requirement. [1](#0-0) 

This delegates to `BIBEMasterPublicKey::verify_decryption_key()` which only uses `sig_mpk_g2`: [2](#0-1) 

The verification performs a BLS pairing check that only involves `sig_mpk_g2`, completely ignoring whether the `tau_g2` values match.

Meanwhile, during encryption, `tau_g2` is a critical cryptographic parameter: [3](#0-2) 

In legitimate setups, `EncryptionKey.tau_g2` must match `DigestKey.tau_g2`: [4](#0-3) [5](#0-4) 

**Attack Scenario:**
1. Honest setup creates `EncryptionKey_A = (sig_mpk, tau_A)` and `DigestKey_A` with matching `tau_A`
2. Attacker constructs malicious `EncryptionKey_B = (sig_mpk, tau_B)` where `tau_B â‰  tau_A`
3. User derives decryption key from `DigestKey_A` for some digest
4. Attacker calls `EncryptionKey_B.verify_decryption_key(digest, key)` 
5. **Verification PASSES** even though the key was derived for `tau_A`, not `tau_B`
6. Any subsequent decryption attempt using this "verified" key will **FAIL** cryptographically

This breaks the security invariant that verification should enforce complete key binding, enabling authorization bypass if code uses this function to gate decryption access.

## Impact Explanation

**Severity: HIGH** 

This qualifies as "Significant protocol violations" per the High severity category because:

1. **Cryptographic Correctness Violation**: Breaks invariant #10 - the verification function provides false security guarantees about key-context binding

2. **Authorization Bypass Potential**: If future code uses `verify_decryption_key()` for access control (to check if a party should be allowed to decrypt), attackers can present keys from wrong contexts and bypass these checks

3. **Cross-Epoch/Batch Key Confusion**: In a multi-epoch or multi-batch system, keys from one context could incorrectly verify against encryption keys from another context, leading to authorization failures

4. **Denial of Service Vector**: Systems that verify keys before attempting decryption will proceed with cryptographically incompatible keys, causing guaranteed decryption failures and error conditions

While currently only used in tests, this is a **public API function** that is part of the `BatchThresholdEncryption` trait interface. The consensus randomness beacon system imports these types, making this a landmine for future security-critical code. [6](#0-5) 

## Likelihood Explanation

**Current Likelihood: LOW** - The function is currently only called in test code, not production paths. [7](#0-6) 

**Future Likelihood: MEDIUM-HIGH** - The function is:
- Part of the public API surface
- Exported through type aliases used in consensus
- Could easily be misused in future code that assumes verification provides complete key binding guarantees
- No documentation warns about the incomplete verification

The vulnerability becomes exploitable the moment any production code path uses this function for security decisions.

## Recommendation

The verification function must check BOTH `sig_mpk_g2` AND `tau_g2` to ensure complete key binding. The fix should:

1. **Add tau_g2 to BIBEMasterPublicKey** to carry both parameters:
```rust
pub struct BIBEMasterPublicKey {
    pub(crate) sig_mpk_g2: G2Affine,
    pub(crate) tau_g2: G2Affine,
}
```

2. **Update EncryptionKey::verify_decryption_key()** to pass both:
```rust
pub fn verify_decryption_key(
    &self,
    digest: &Digest,
    decryption_key: &BIBEDecryptionKey,
) -> Result<()> {
    BIBEMasterPublicKey {
        sig_mpk_g2: self.sig_mpk_g2,
        tau_g2: self.tau_g2,
    }.verify_decryption_key(digest, decryption_key)
}
```

3. **Verify tau_g2 matches** in the underlying verification by checking that the decryption key's derivation context includes the correct `tau_g2`. This requires either:
   - Embedding `tau_g2` in the digest or decryption key structure, OR
   - Verifying eval proofs were created with matching `tau_g2` from `DigestKey`

The safest approach is to verify that the decryption key was derived from a digest created with a `DigestKey` that has matching `tau_g2`, which requires passing additional context to the verification function.

## Proof of Concept

```rust
#[test]
fn test_cross_key_verification_bypass() {
    use crate::group::{Fr, G2Affine};
    use crate::shared::{
        digest::DigestKey,
        encryption_key::EncryptionKey,
        key_derivation::{gen_msk_shares, BIBEDecryptionKey},
    };
    use aptos_crypto::arkworks::shamir::ShamirThresholdConfig;
    use ark_ec::AffineRepr;
    use ark_ff::UniformRand;
    use ark_std::rand::thread_rng;

    let mut rng = thread_rng();
    let tc = ShamirThresholdConfig::new(2, 3);
    
    // Setup with tau_g2_A
    let digest_key_a = DigestKey::new(&mut rng, 8, 1).unwrap();
    let msk = Fr::rand(&mut rng);
    let (mpk, _vks, msk_shares) = gen_msk_shares(msk, &mut rng, &tc);
    
    let encryption_key_a = EncryptionKey::new(mpk.0, digest_key_a.tau_g2);
    
    // Create malicious EncryptionKey with different tau_g2_B but same sig_mpk
    let tau_g2_b = (G2Affine::generator() * Fr::rand(&mut rng)).into();
    let encryption_key_b = EncryptionKey::new(mpk.0, tau_g2_b);
    
    // Derive decryption key for digest from digest_key_a
    let mut ids = crate::shared::ids::IdSet::with_capacity(1).unwrap();
    ids.add(&crate::shared::ids::Id::new(Fr::from(0)));
    ids.compute_poly_coeffs();
    let (digest, _) = digest_key_a.digest(&mut ids, 0).unwrap();
    
    let dk_shares: Vec<_> = msk_shares
        .iter()
        .map(|share| share.derive_decryption_key_share(&digest).unwrap())
        .collect();
    
    let dk = BIBEDecryptionKey::reconstruct(&tc, &dk_shares[..2]).unwrap();
    
    // Verification against encryption_key_a (correct) - should pass
    assert!(encryption_key_a.verify_decryption_key(&digest, &dk).is_ok());
    
    // VULNERABILITY: Verification against encryption_key_b (wrong tau_g2) - should FAIL but PASSES!
    assert!(encryption_key_b.verify_decryption_key(&digest, &dk).is_ok(),
        "Verification incorrectly passes for encryption key with different tau_g2!");
    
    // Note: While verification passes, actual decryption would fail due to tau_g2 mismatch
}
```

**Notes**

The vulnerability exists in the cryptographic verification logic where incomplete parameter binding allows keys from one encryption context to verify against a different context. While currently unexploited due to limited production usage, this represents a dangerous API design flaw that violates the principle of complete cryptographic binding. The function's public API status and use in consensus-related types creates significant risk for future misuse. Any code that relies on this verification for authorization decisions would be vulnerable to bypass attacks.

### Citations

**File:** crates/aptos-batch-encryption/src/shared/encryption_key.rs (L27-33)
```rust
    pub fn verify_decryption_key(
        &self,
        digest: &Digest,
        decryption_key: &BIBEDecryptionKey,
    ) -> Result<()> {
        BIBEMasterPublicKey(self.sig_mpk_g2).verify_decryption_key(digest, decryption_key)
    }
```

**File:** crates/aptos-batch-encryption/src/shared/key_derivation.rs (L154-163)
```rust
    pub fn verify_decryption_key(
        &self,
        digest: &Digest,
        decryption_key: &BIBEDecryptionKey,
    ) -> Result<()> {
        verify_bls(self.0, digest, self.0, decryption_key.signature_g1)
            .map_err(|_| BatchEncryptionError::DecryptionKeyVerifyError)?;

        Ok(())
    }
```

**File:** crates/aptos-batch-encryption/src/shared/ciphertext/bibe.rs (L128-132)
```rust
        let ct_g2 = [
            (G2Affine::generator() * r[0] + self.sig_mpk_g2 * r[1]).into(),
            ((G2Affine::generator() * id.x() - self.tau_g2) * r[0]).into(),
            (-(G2Affine::generator() * r[1])).into(),
        ];
```

**File:** crates/aptos-batch-encryption/src/schemes/fptx_weighted.rs (L241-243)
```rust
        let mpk_g2: G2Affine = subtranscript.get_dealt_public_key().as_g2();

        let ek = EncryptionKey::new(mpk_g2, digest_key.tau_g2);
```

**File:** crates/aptos-batch-encryption/src/schemes/fptx_weighted.rs (L301-306)
```rust
        let digest_key = DigestKey::new(&mut rng, max_batch_size, number_of_rounds)
            .ok_or(anyhow!("Failed to create digest key"))?;
        let msk = Fr::rand(&mut rng);
        let (mpk, vks, msk_shares) = gen_weighted_msk_shares(msk, &mut rng, threshold_config);

        let ek = EncryptionKey::new(mpk.0, digest_key.tau_g2);
```

**File:** consensus/src/rand/secret_sharing/types.rs (L8-12)
```rust
    secret_sharing::{
        DigestKey, EncryptionKey, MasterSecretKeyShare, SecretShareMetadata, VerificationKey,
    },
    validator_verifier::ValidatorVerifier,
};
```

**File:** crates/aptos-batch-encryption/src/tests/fptx_weighted_smoke.rs (L51-51)
```rust
    ek.verify_decryption_key(&d, &dk).unwrap();
```
