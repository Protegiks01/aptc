# Audit Report

## Title
JWK Consensus Configuration with Empty OIDC Providers Causes Permanent Keyless Account Transaction Failures

## Summary
The `ConfigV1` struct in JWK consensus configuration allows an empty `oidc_providers` vector, which enables JWK consensus but spawns no JWK observers. This results in an empty `PatchedJWKs` resource on-chain, causing all keyless account transactions to fail validation permanently until governance manually intervenes.

## Finding Description

The vulnerability exists in the JWK consensus configuration system where `ConfigV1` can be created with an empty `oidc_providers` vector. The `jwk_consensus_enabled()` function returns `true` for any V1 variant regardless of whether the provider list is empty. [1](#0-0) [2](#0-1) 

The Move framework also permits creating `ConfigV1` with empty providers without validation: [3](#0-2) 

When this configuration is active, the JWK consensus manager receives an empty provider list and spawns zero observers: [4](#0-3) 

During mainnet genesis, no initial JWK patches are added: [5](#0-4) 

This results in `PatchedJWKs` remaining empty. When keyless account transactions are validated, they fail because no JWKs exist: [6](#0-5) [7](#0-6) 

The error message at line 121-126 indicates failure when JWK is not found.

## Impact Explanation

This is a **Medium Severity** vulnerability per Aptos bug bounty criteria:
- **State inconsistencies requiring intervention**: The chain enters a state where JWK consensus is "enabled" but non-functional, requiring emergency governance action
- **Denial of Service**: All keyless account users are permanently unable to submit transactions
- **Scope**: Affects an entire authentication method (keyless accounts) across the network
- **Recovery**: Requires governance proposal and epoch reconfiguration to manually add JWK patches

The impact is medium rather than high because:
- No funds are lost or stolen
- Only keyless accounts are affected, not all users
- The issue is recoverable through governance intervention
- Does not affect consensus safety or validator operations

## Likelihood Explanation

The likelihood is **Medium to High**:

**Factors increasing likelihood:**
1. The `default_for_genesis()` function explicitly uses empty providers "to avoid DDoSing the CI infra", indicating this configuration is intentionally used in test environments
2. No validation prevents this configuration in production
3. The example usage in Move documentation shows `new_v1(vector[])` as valid
4. Genesis configuration could inadvertently use this on mainnet if `initial_jwks` is empty and no providers are specified

**Factors decreasing likelihood:**
1. Production deployments would typically configure real OIDC providers
2. The issue would be caught during testing if keyless accounts are tested
3. Governance could preemptively add patches before the issue manifests

However, a misconfiguration during genesis or a governance proposal that "enables" JWK consensus without adding providers would trigger this vulnerability.

## Recommendation

**Immediate Fix:**
Add validation in the Move `new_v1` function to reject empty provider lists:

```move
public fun new_v1(oidc_providers: vector<OIDCProvider>): JWKConsensusConfig {
    // Add validation for empty vector
    assert!(!vector::is_empty(&oidc_providers), error::invalid_argument(EEMPTY_PROVIDERS));
    
    let name_set = simple_map::new<String, u64>();
    vector::for_each_ref(&oidc_providers, |provider| {
        let provider: &OIDCProvider = provider;
        let (_, old_value) = simple_map::upsert(&mut name_set, provider.name, 0);
        if (option::is_some(&old_value)) {
            abort(error::invalid_argument(EDUPLICATE_PROVIDERS))
        }
    });
    JWKConsensusConfig {
        variant: copyable_any::pack( ConfigV1 { oidc_providers } )
    }
}
```

Add corresponding error constant:
```move
const EEMPTY_PROVIDERS: u64 = 2;
```

**Additional Safeguards:**
1. Update `jwk_consensus_enabled()` to also check if providers exist:
   ```rust
   pub fn jwk_consensus_enabled(&self) -> bool {
       match self {
           OnChainJWKConsensusConfig::Off => false,
           OnChainJWKConsensusConfig::V1(v1) => !v1.oidc_providers.is_empty(),
       }
   }
   ```

2. Add runtime warning in epoch manager when JWK consensus starts with zero providers

3. For genesis, either require non-empty providers OR use `ConfigOff` variant instead of empty V1

## Proof of Concept

**Scenario:** Mainnet genesis with empty OIDC providers

```rust
// In genesis configuration
let jwk_config = OnChainJWKConsensusConfig::default_for_genesis();
// Creates: V1(ConfigV1 { oidc_providers: vec![] })

// During genesis for mainnet (chain_id.is_mainnet() == true)
// No patches are added (line 944 check in lib.rs)
// Result: PatchedJWKs has empty entries

// User submits keyless transaction
let keyless_sig = KeylessSignature {
    cert: EphemeralCertificate::ZeroKnowledgeSig { /* ... */ },
    jwt_header_json: "...",
    exp_date_secs: current_time + 100,
    ephemeral_pubkey: EphemeralPublicKey::Ed25519 { /* ... */ },
    ephemeral_signature: EphemeralSignature::Ed25519 { /* ... */ },
};

// In validate_authenticators():
let patched_jwks = get_jwks_onchain(resolver)?; // Returns empty AllProvidersJWKs

// In get_jwk_for_authenticator():
let jwk_move_struct = jwks.get_jwk(&pk.iss_val, &jwt_header.kid)
    .map_err(|_| {
        invalid_signature!(format!(
            "JWK for {} with KID {} was not found",  // ERROR: Always fails
            pk.iss_val, jwt_header.kid
        ))
    })?;

// Result: Transaction rejected with INVALID_SIGNATURE
// All keyless account transactions fail until governance adds patches
```

**Move Test Reproduction:**
```move
#[test(framework = @aptos_framework)]
fun test_empty_providers_breaks_keyless(framework: signer) {
    // Initialize with empty providers
    let config = jwk_consensus_config::new_v1(vector[]);
    jwk_consensus_config::initialize(&framework, config);
    
    // Initialize keyless resources with no patches
    jwks::initialize(&framework);
    
    // Verify PatchedJWKs is empty
    let patched = borrow_global<PatchedJWKs>(@aptos_framework);
    assert!(vector::is_empty(&patched.jwks.entries), 1);
    
    // Any keyless transaction would fail validation here
    // because get_patched_jwk() will abort with EJWK_ID_NOT_FOUND
}
```

## Notes

This vulnerability demonstrates a critical design flaw where a feature can be "enabled" but completely non-functional. The explicit comment in `default_for_genesis()` about avoiding DDoS attacks suggests this empty configuration is intentionally used in some contexts, which increases the risk of accidental production deployment with the same settings.

The remediation requires both immediate validation fixes and architectural improvements to ensure that "enabled" features are actually operational.

### Citations

**File:** types/src/on_chain_config/jwk_consensus_config.rs (L61-67)
```rust
    pub fn default_for_genesis() -> Self {
        // Here it is supposed to use `default_enabled()`.
        // Using an empty list instead to avoid DDoSing the CI infra or the actual providers.
        Self::V1(ConfigV1 {
            oidc_providers: vec![],
        })
    }
```

**File:** types/src/on_chain_config/jwk_consensus_config.rs (L69-74)
```rust
    pub fn jwk_consensus_enabled(&self) -> bool {
        match self {
            OnChainJWKConsensusConfig::Off => false,
            OnChainJWKConsensusConfig::V1 { .. } => true,
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/jwk_consensus_config.move (L90-102)
```text
    public fun new_v1(oidc_providers: vector<OIDCProvider>): JWKConsensusConfig {
        let name_set = simple_map::new<String, u64>();
        vector::for_each_ref(&oidc_providers, |provider| {
            let provider: &OIDCProvider = provider;
            let (_, old_value) = simple_map::upsert(&mut name_set, provider.name, 0);
            if (option::is_some(&old_value)) {
                abort(error::invalid_argument(EDUPLICATE_PROVIDERS))
            }
        });
        JWKConsensusConfig {
            variant: copyable_any::pack( ConfigV1 { oidc_providers } )
        }
    }
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager/mod.rs (L108-134)
```rust
        this.jwk_observers = oidc_providers
            .unwrap_or_default()
            .into_provider_vec()
            .into_iter()
            .filter_map(|provider| {
                let OIDCProvider { name, config_url } = provider;
                let maybe_issuer = String::from_utf8(name);
                let maybe_config_url = String::from_utf8(config_url);
                match (maybe_issuer, maybe_config_url) {
                    (Ok(issuer), Ok(config_url)) => Some(JWKObserver::spawn(
                        this.epoch_state.epoch,
                        this.my_addr,
                        issuer,
                        config_url,
                        Duration::from_secs(10),
                        local_observation_tx.clone(),
                    )),
                    (maybe_issuer, maybe_config_url) => {
                        warn!(
                            "unable to spawn observer, issuer={:?}, config_url={:?}",
                            maybe_issuer, maybe_config_url
                        );
                        None
                    },
                }
            })
            .collect();
```

**File:** aptos-move/vm-genesis/src/lib.rs (L944-975)
```rust
    if !chain_id.is_mainnet() {
        let additional_jwk_patch = IssuerJWK {
            issuer: get_sample_iss(),
            jwk: JWK::RSA(secure_test_rsa_jwk()),
        };
        initial_jwks.insert(0, additional_jwk_patch);

        let jwk_patches: Vec<PatchJWKMoveStruct> = initial_jwks
            .into_iter()
            .map(|issuer_jwk| {
                let IssuerJWK { issuer, jwk } = issuer_jwk;
                let upsert_patch = PatchUpsertJWK {
                    issuer,
                    jwk: JWKMoveStruct::from(jwk),
                };
                PatchJWKMoveStruct::from(upsert_patch)
            })
            .collect();

        exec_function(
            session,
            module_storage,
            traversal_context,
            JWKS_MODULE_NAME,
            "set_patches",
            vec![],
            serialize_values(&vec![
                MoveValue::Signer(CORE_CODE_ADDRESS),
                jwk_patches.as_move_value(),
            ]),
        );
    }
```

**File:** aptos-move/aptos-vm/src/keyless_validation.rs (L220-221)
```rust
    let patched_jwks = get_jwks_onchain(resolver)?;

```

**File:** aptos-move/aptos-vm/src/keyless_validation.rs (L236-260)
```rust
        // Try looking up the jwk in 0x1.
        let jwk = match get_jwk_for_authenticator(&patched_jwks.jwks, pk.inner_keyless_pk(), sig) {
            // 1: If found in 0x1, then we consider that the ground truth & we are done.
            Ok(jwk) => jwk,
            // 2: If not found in 0x1, we check the Keyless PK type.
            Err(e) => {
                match pk {
                    // 2.a: If this is a federated keyless account; look in `jwk_addr` for JWKs
                    AnyKeylessPublicKey::Federated(fed_pk) => {
                        let federated_jwks =
                            get_federated_jwks_onchain(resolver, &fed_pk.jwk_addr, module_storage)
                                .map_err(|_| {
                                    invalid_signature!(format!(
                                        "Could not fetch federated PatchedJWKs at {}",
                                        fed_pk.jwk_addr
                                    ))
                                })?;
                        // 2.a.i If not found in jwk_addr either, then we fail the validation.
                        get_jwk_for_authenticator(&federated_jwks.jwks, pk.inner_keyless_pk(), sig)?
                    },
                    // 2.b: If this is not a federated keyless account, then we fail the validation.
                    AnyKeylessPublicKey::Normal(_) => return Err(e),
                }
            },
        };
```
