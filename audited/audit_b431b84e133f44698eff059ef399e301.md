# Audit Report

## Title
Protocol Confusion in get_available_peers() Causes Incorrect Peer Availability Assessment

## Summary
The `get_available_peers()` function in `NetworkClient` incorrectly returns peers that support ANY protocol (direct_send OR rpc) rather than peers that support the appropriate protocol for each operation type. This causes send operations to fail when attempting to use peers that don't support the required protocol type, potentially impacting validator performance and message propagation reliability.

## Finding Description

The vulnerability exists in the `get_available_peers()` method [1](#0-0) , which combines both `direct_send_protocols_and_preferences` and `rpc_protocols_and_preferences` into a single list and returns all peers that support ANY of these protocols.

The underlying `get_connected_supported_peers()` implementation [2](#0-1)  uses `supports_any_protocol()` [3](#0-2)  which checks if a peer supports at least one protocol from the combined list.

This creates a semantic mismatch because:

1. **Direct send operations** (`send_to_peer()`, `send_to_peers()`) only check against `direct_send_protocols_and_preferences` [4](#0-3)  and [5](#0-4) 

2. **RPC operations** (`send_to_peer_rpc()`) only check against `rpc_protocols_and_preferences` [6](#0-5) 

3. A peer returned by `get_available_peers()` might only support RPC protocols but not direct_send (or vice versa), causing send operations to fail

Real-world configurations demonstrate this issue. For example, consensus uses both protocol types [7](#0-6) , while mempool uses only direct_send [8](#0-7)  and storage service uses only RPC [9](#0-8) .

The existence of this issue is confirmed by a test case [10](#0-9)  which explicitly demonstrates that `get_available_peers()` returns both RPC-only and direct-send-only peers, and subsequent send operations fail with protocol mismatches.

## Impact Explanation

This qualifies as **High severity** under the "Validator node slowdowns" and "Significant protocol violations" categories because:

1. **Consensus Message Propagation Delays**: When consensus components broadcast critical messages (proposals, votes, commit decisions) using `send_to_peers()`, they may attempt to send to peers that don't support direct_send protocols. These failures waste resources and delay message propagation, potentially impacting block production times.

2. **Wasted Network Resources**: Each failed send attempt consumes CPU cycles for protocol negotiation and error handling, multiplied across all validators in the network.

3. **Operational Confusion**: Components that call `get_available_peers()` receive misleading information about which peers are truly available for their specific operation types, violating the principle of least surprise and potentially causing cascading failures in error handling logic.

4. **Attack Surface**: A malicious actor could deliberately connect to validators advertising only RPC protocols (or only direct_send), causing the validator to include these peers in availability checks but fail when attempting to broadcast critical consensus messages, effectively creating a partial denial-of-service condition.

## Likelihood Explanation

This issue has **high likelihood** of occurring in production because:

1. **Natural Network Heterogeneity**: Different node types and versions may support different protocol subsets, especially during network upgrades or when nodes run different client implementations.

2. **Consensus is Primary User**: Consensus components use both direct_send (for broadcasting) and RPC (for retrieval) [11](#0-10) , making them directly affected by this issue.

3. **State-sync Components Affected**: State synchronization clients call `get_available_peers()` [12](#0-11)  and may encounter similar protocol mismatches.

4. **No Explicit Warning**: The function signature and documentation don't warn callers that returned peers may not support all operation types.

## Recommendation

Provide separate methods for querying peers by protocol type, or modify `get_available_peers()` to accept a protocol type parameter:

```rust
// Option 1: Separate methods
fn get_available_peers_for_direct_send(&self) -> Result<Vec<PeerNetworkId>, Error> {
    self.peers_and_metadata
        .get_connected_supported_peers(&self.direct_send_protocols_and_preferences)
}

fn get_available_peers_for_rpc(&self) -> Result<Vec<PeerNetworkId>, Error> {
    self.peers_and_metadata
        .get_connected_supported_peers(&self.rpc_protocols_and_preferences)
}

// Option 2: Return intersection (peers supporting BOTH)
fn get_available_peers(&self) -> Result<Vec<PeerNetworkId>, Error> {
    let direct_send_peers: HashSet<_> = self.peers_and_metadata
        .get_connected_supported_peers(&self.direct_send_protocols_and_preferences)?
        .into_iter()
        .collect();
    let rpc_peers: HashSet<_> = self.peers_and_metadata
        .get_connected_supported_peers(&self.rpc_protocols_and_preferences)?
        .into_iter()
        .collect();
    Ok(direct_send_peers.intersection(&rpc_peers).cloned().collect())
}
```

Update all callers to use the appropriate method based on their intended operation type.

## Proof of Concept

The existing test demonstrates this vulnerability: [10](#0-9) 

This test creates a NetworkClient with both direct_send (`ConsensusDirectSendBcs`) and RPC (`StorageServiceRpc`) protocols, then creates two peers: one supporting only RPC, another supporting only direct_send. The test verifies that:

1. Both peers are returned by `get_available_peers()` (line 731)
2. Sending direct_send to the RPC-only peer fails (line 734-736)  
3. Sending RPC to the direct-send-only peer fails (line 737-744)

To observe the impact in a realistic scenario, monitor consensus message send failures when validators have heterogeneous peer protocol support.

## Notes

While error handling mechanisms exist to catch these failures, the semantic confusion at the API level creates unnecessary performance overhead and potential for operational issues. The vulnerability is particularly concerning for consensus-critical components where message propagation delays can impact network liveness and block production times.

### Citations

**File:** network/framework/src/application/interface.rs (L214-223)
```rust
    fn get_available_peers(&self) -> Result<Vec<PeerNetworkId>, Error> {
        let supported_protocol_ids: Vec<ProtocolId> = self
            .direct_send_protocols_and_preferences
            .iter()
            .chain(self.rpc_protocols_and_preferences.iter())
            .cloned()
            .collect();
        self.peers_and_metadata
            .get_connected_supported_peers(&supported_protocol_ids)
    }
```

**File:** network/framework/src/application/interface.rs (L229-234)
```rust
    fn send_to_peer(&self, message: Message, peer: PeerNetworkId) -> Result<(), Error> {
        let network_sender = self.get_sender_for_network_id(&peer.network_id())?;
        let direct_send_protocol_id = self
            .get_preferred_protocol_for_peer(&peer, &self.direct_send_protocols_and_preferences)?;
        Ok(network_sender.send_to(peer.peer_id(), direct_send_protocol_id, message)?)
    }
```

**File:** network/framework/src/application/interface.rs (L243-258)
```rust
    fn send_to_peers(&self, message: Message, peers: Vec<PeerNetworkId>) -> Result<(), Error> {
        let peers_per_protocol = self.group_peers_by_protocol(peers);

        // Send to all peers in each protocol group and network
        for (protocol_id, peers) in peers_per_protocol {
            for (network_id, peers) in &peers
                .iter()
                .chunk_by(|peer_network_id| peer_network_id.network_id())
            {
                let network_sender = self.get_sender_for_network_id(&network_id)?;
                let peer_ids = peers.map(|peer_network_id| peer_network_id.peer_id());
                network_sender.send_to_many(peer_ids, protocol_id, message.clone())?;
            }
        }
        Ok(())
    }
```

**File:** network/framework/src/application/interface.rs (L260-272)
```rust
    async fn send_to_peer_rpc(
        &self,
        message: Message,
        rpc_timeout: Duration,
        peer: PeerNetworkId,
    ) -> Result<Message, Error> {
        let network_sender = self.get_sender_for_network_id(&peer.network_id())?;
        let rpc_protocol_id =
            self.get_preferred_protocol_for_peer(&peer, &self.rpc_protocols_and_preferences)?;
        Ok(network_sender
            .send_rpc(peer.peer_id(), rpc_protocol_id, message, rpc_timeout)
            .await?)
    }
```

**File:** network/framework/src/application/storage.rs (L129-148)
```rust
    pub fn get_connected_supported_peers(
        &self,
        protocol_ids: &[ProtocolId],
    ) -> Result<Vec<PeerNetworkId>, Error> {
        // Get the cached peers and metadata
        let cached_peers_and_metadata = self.cached_peers_and_metadata.load();

        // Collect all connected peers that support at least one of the given protocols
        let mut connected_supported_peers = Vec::new();
        for (network_id, peers_and_metadata) in cached_peers_and_metadata.iter() {
            for (peer_id, peer_metadata) in peers_and_metadata.iter() {
                if peer_metadata.is_connected() && peer_metadata.supports_any_protocol(protocol_ids)
                {
                    let peer_network_id = PeerNetworkId::new(*network_id, *peer_id);
                    connected_supported_peers.push(peer_network_id);
                }
            }
        }
        Ok(connected_supported_peers)
    }
```

**File:** network/framework/src/application/metadata.rs (L64-71)
```rust
    pub fn supports_any_protocol(&self, protocol_ids: &[ProtocolId]) -> bool {
        let protocol_id_set = ProtocolIdSet::from_iter(protocol_ids);
        !self
            .connection_metadata
            .application_protocols
            .intersect(&protocol_id_set)
            .is_empty()
    }
```

**File:** aptos-node/src/network.rs (L57-72)
```rust
pub fn consensus_network_configuration(node_config: &NodeConfig) -> NetworkApplicationConfig {
    let direct_send_protocols: Vec<ProtocolId> =
        aptos_consensus::network_interface::DIRECT_SEND.into();
    let rpc_protocols: Vec<ProtocolId> = aptos_consensus::network_interface::RPC.into();

    let network_client_config =
        NetworkClientConfig::new(direct_send_protocols.clone(), rpc_protocols.clone());
    let network_service_config = NetworkServiceConfig::new(
        direct_send_protocols,
        rpc_protocols,
        aptos_channel::Config::new(node_config.consensus.max_network_channel_size)
            .queue_style(QueueStyle::FIFO)
            .counters(&aptos_consensus::counters::PENDING_CONSENSUS_NETWORK_EVENTS),
    );
    NetworkApplicationConfig::new(network_client_config, network_service_config)
}
```

**File:** aptos-node/src/network.rs (L108-123)
```rust
/// Returns the network application config for the mempool client and service
pub fn mempool_network_configuration(node_config: &NodeConfig) -> NetworkApplicationConfig {
    let direct_send_protocols = vec![ProtocolId::MempoolDirectSend];
    let rpc_protocols = vec![]; // Mempool does not use RPC

    let network_client_config =
        NetworkClientConfig::new(direct_send_protocols.clone(), rpc_protocols.clone());
    let network_service_config = NetworkServiceConfig::new(
        direct_send_protocols,
        rpc_protocols,
        aptos_channel::Config::new(node_config.mempool.max_network_channel_size)
            .queue_style(QueueStyle::KLAST) // TODO: why is this not FIFO?
            .counters(&aptos_mempool::counters::PENDING_MEMPOOL_NETWORK_EVENTS),
    );
    NetworkApplicationConfig::new(network_client_config, network_service_config)
}
```

**File:** aptos-node/src/network.rs (L146-150)
```rust
/// Returns the network application config for the storage service client and server
pub fn storage_service_network_configuration(node_config: &NodeConfig) -> NetworkApplicationConfig {
    let direct_send_protocols = vec![]; // The storage service does not use direct send
    let rpc_protocols = vec![ProtocolId::StorageServiceRpc];
    let max_network_channel_size = node_config
```

**File:** network/framework/src/application/tests.rs (L698-745)
```rust
#[tokio::test]
async fn test_network_client_senders_no_matching_protocols() {
    // Create the peers and metadata container
    let network_ids = vec![NetworkId::Validator, NetworkId::Vfn, NetworkId::Public];
    let peers_and_metadata = PeersAndMetadata::new(&network_ids);

    // Create a network client with network senders
    let (network_senders, _network_events, _outbound_request_receivers, _inbound_request_senders) =
        create_network_sender_and_events(&network_ids);
    let network_client: NetworkClient<DummyMessage> = NetworkClient::new(
        vec![ProtocolId::ConsensusDirectSendBcs],
        vec![ProtocolId::StorageServiceRpc],
        network_senders,
        peers_and_metadata.clone(),
    );

    // Verify the registered networks and that there are no available peers
    check_registered_networks(&peers_and_metadata, network_ids);
    check_available_peers(&network_client, vec![]);

    // Create two peers and initialize the connection metadata
    let (peer_network_id_1, _) = create_peer_and_connection(
        NetworkId::Validator,
        vec![ProtocolId::StorageServiceRpc],
        peers_and_metadata.clone(),
    );
    let (peer_network_id_2, _) = create_peer_and_connection(
        NetworkId::Vfn,
        vec![ProtocolId::ConsensusDirectSendBcs],
        peers_and_metadata.clone(),
    );

    // Verify that there are available peers
    check_available_peers(&network_client, vec![peer_network_id_1, peer_network_id_2]);

    // Verify that sending a message to a peer without a matching protocol fails
    network_client
        .send_to_peer(DummyMessage::new_empty(), peer_network_id_1)
        .unwrap_err();
    network_client
        .send_to_peer_rpc(
            DummyMessage::new_empty(),
            Duration::from_secs(MAX_MESSAGE_TIMEOUT_SECS),
            peer_network_id_2,
        )
        .await
        .unwrap_err();
}
```

**File:** consensus/src/network_interface.rs (L157-168)
```rust
pub const RPC: &[ProtocolId] = &[
    ProtocolId::ConsensusRpcCompressed,
    ProtocolId::ConsensusRpcBcs,
    ProtocolId::ConsensusRpcJson,
];

/// Supported protocols in preferred order (from highest priority to lowest).
pub const DIRECT_SEND: &[ProtocolId] = &[
    ProtocolId::ConsensusDirectSendCompressed,
    ProtocolId::ConsensusDirectSendBcs,
    ProtocolId::ConsensusDirectSendJson,
];
```

**File:** state-sync/aptos-data-client/src/client.rs (L563-572)
```rust
    fn get_all_connected_peers(&self) -> crate::error::Result<HashSet<PeerNetworkId>, Error> {
        let connected_peers = self.storage_service_client.get_available_peers()?;
        if connected_peers.is_empty() {
            return Err(Error::NoConnectedPeers(
                "No available peers found!".to_owned(),
            ));
        }

        Ok(connected_peers)
    }
```
