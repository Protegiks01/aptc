# Audit Report

## Title
Unvalidated Cursor in Prefixed State Iterator Causes Incorrect Query Results

## Summary
The `get_prefixed_state_value_iterator()` function in both the indexer and main storage implementations accepts an unvalidated cursor parameter that, when pointing outside the requested key prefix range, causes the iterator to return empty results instead of the actual data. This allows any API user to force incorrect (incomplete) responses from state query endpoints.

## Finding Description

The vulnerability exists in two implementations of `PrefixedStateValueIterator`:

1. **Indexer implementation** [1](#0-0) 

2. **Main storage implementation** [2](#0-1) 

Both implementations fail to validate that the cursor falls within the `key_prefix` range before starting iteration. When a cursor is provided that is lexicographically before the prefix range, the iterator seeks to that cursor position. Upon encountering the first state key (which may be between the cursor and the prefix range), the iterator checks if it matches the prefix:

**Indexer iterator logic:** [3](#0-2) 

**Main storage iterator logic:** [4](#0-3) 

In both cases, when the first encountered key doesn't match the prefix, the iterator immediately sets `is_finished = true` and returns `None`, **without advancing to find keys that do match the prefix**. This breaks the expected invariant that a prefixed iterator should return all keys matching the specified prefix.

**Attack Vector:** The vulnerability is exposed through the REST API where users can provide arbitrary cursor values: [5](#0-4) 

The API accepts `StateKeyWrapper` cursors from users [6](#0-5)  which can be arbitrary hex-encoded `StateKey` values. These cursors are passed directly to `get_prefixed_state_value_iterator()` without validation [7](#0-6) 

**StateKey Ordering:** StateKeys are ordered by variant (AccessPath < TableItem < Raw), then by their internal fields [8](#0-7) . For AccessPath variants, ordering is by address then path. The prefix matching checks byte-level prefix equality [9](#0-8) 

**Exploitation Scenario:**
1. Attacker wants to query resources for address `0x0000...0005`
2. Attacker crafts a cursor pointing to a resource for address `0x0000...0002`  
3. Attacker calls `/accounts/0x0000...0005/resources?start=<crafted_cursor>`
4. Iterator seeks to the cursor (address `0x02`)
5. Iterator encounters state keys for addresses between `0x02` and `0x05` (e.g., `0x03`, `0x04`)
6. First key doesn't match prefix for `0x05`, iterator returns `None`
7. API returns empty result `[]` even though address `0x05` has resources

This violates the data consistency guarantee that queries should return all matching data.

## Impact Explanation

**Severity: Medium**

This qualifies as **"State inconsistencies requiring intervention"** under the Medium severity category. The vulnerability:

- Causes API endpoints to return incorrect (empty or incomplete) results
- Affects data availability and correctness at the query layer
- Could cause applications relying on the API to make incorrect decisions based on incomplete data
- Does not directly affect consensus, blockchain state integrity, or cause funds loss
- Limited to the query/API layer, not the core protocol

The impact is significant because:
1. Any user can exploit this without special privileges
2. It affects critical API endpoints like `get_account_resources` and `get_account_modules`
3. Applications depending on these APIs could malfunction due to receiving incorrect data
4. The behavior is silent - no error is returned, just incorrect empty results

However, it does not reach High/Critical severity because:
- It doesn't affect the actual blockchain state or consensus
- It doesn't cause funds loss or validator node crashes
- It's limited to the API query layer

## Likelihood Explanation

**Likelihood: Medium to High**

This vulnerability is likely to occur because:

1. **Easy to trigger:** Any API user can provide arbitrary cursor values via the `start` parameter
2. **No validation:** There is no validation that cursors fall within the requested prefix range
3. **Realistic scenario:** In a production blockchain with thousands of accounts, state keys for many addresses exist. When paginating through resources, if a user (accidentally or maliciously) provides a cursor from a different account query, the bug triggers
4. **Documented but not enforced:** While the API documentation states cursors "cannot be derived manually client-side" [10](#0-9) , there is no enforcement preventing users from providing arbitrary cursors

The vulnerability could be triggered:
- **Accidentally:** User reuses a cursor from a previous query to a different address
- **Maliciously:** Attacker intentionally crafts cursors to cause API endpoints to return empty results for legitimate queries

## Recommendation

Add cursor validation before creating the iterator to ensure the cursor, if provided, falls within the expected key prefix range. If the cursor is outside the range, either:

**Option 1 (Strict):** Return an error indicating invalid cursor
**Option 2 (Lenient):** Ignore the invalid cursor and start from the prefix beginning

Recommended implementation (Option 2 - more user-friendly):

```rust
pub fn get_prefixed_state_value_iterator(
    &self,
    key_prefix: &StateKeyPrefix,
    cursor: Option<&StateKey>,
    ledger_version: Version,
) -> Result<impl Iterator<Item = anyhow::Result<(StateKey, StateValue)>> + '_ + use<'_>> {
    self.indexer_db
        .ensure_cover_ledger_version(ledger_version)?;
    
    // Validate cursor falls within prefix range
    let validated_cursor = if let Some(cursor) = cursor {
        if !key_prefix.is_prefix(cursor)? {
            // Cursor is outside prefix range, ignore it and start from prefix
            None
        } else {
            Some(cursor.clone())
        }
    } else {
        None
    };
    
    PrefixedStateValueIterator::new(
        self.main_db_reader.clone(),
        self.indexer_db.get_inner_db_ref(),
        key_prefix.clone(),
        validated_cursor,
        ledger_version,
    )
}
```

Apply the same fix to both implementations:
- [1](#0-0) 
- [11](#0-10) 

## Proof of Concept

The following demonstrates the vulnerability using the REST API:

```bash
# Step 1: Create two test accounts with resources
# Account A: 0x0000000000000000000000000000000000000000000000000000000000000005
# Account B: 0x0000000000000000000000000000000000000000000000000000000000000002

# Step 2: Query Account A's resources normally (should return data)
curl "http://localhost:8080/v1/accounts/0x5/resources"
# Expected: Returns list of resources for account 0x5

# Step 3: Craft a cursor for Account B's resource
# Get a valid StateKey for account 0x2's AptosCoin resource
# Encode as hex: <hex_encoded_state_key_for_account_0x2>

# Step 4: Query Account A with cursor pointing to Account B
curl "http://localhost:8080/v1/accounts/0x5/resources?start=<cursor_for_account_0x2>"
# Expected (buggy): Returns empty array []
# Should return: All resources for account 0x5

# The bug triggers because:
# 1. Iterator seeks to account 0x2's state key
# 2. Encounters state keys for accounts 0x3, 0x4 (if they exist)
# 3. These don't match prefix for account 0x5
# 4. Iterator returns None immediately
# 5. API returns empty result
```

**Notes**

This vulnerability affects both sharded (using indexer) and non-sharded (using state store) database configurations. The root cause is the same in both implementations: lack of cursor validation combined with premature termination when the first non-matching key is encountered. The fix should be applied consistently to both code paths to ensure uniform behavior across different deployment configurations.

### Citations

**File:** storage/indexer/src/db_indexer.rs (L614-629)
```rust
    pub fn get_prefixed_state_value_iterator(
        &self,
        key_prefix: &StateKeyPrefix,
        cursor: Option<&StateKey>,
        ledger_version: Version,
    ) -> Result<impl Iterator<Item = anyhow::Result<(StateKey, StateValue)>> + '_ + use<'_>> {
        self.indexer_db
            .ensure_cover_ledger_version(ledger_version)?;
        PrefixedStateValueIterator::new(
            self.main_db_reader.clone(),
            self.indexer_db.get_inner_db_ref(),
            key_prefix.clone(),
            cursor.cloned(),
            ledger_version,
        )
    }
```

**File:** storage/aptosdb/src/utils/iterators.rs (L113-146)
```rust
impl<'a> PrefixedStateValueIterator<'a> {
    pub fn new(
        db: &'a StateKvDb,
        key_prefix: StateKeyPrefix,
        first_key: Option<StateKey>,
        desired_version: Version,
    ) -> Result<Self> {
        let mut read_opts = ReadOptions::default();
        // Without this, iterators are not guaranteed a total order of all keys, but only keys for the same prefix.
        // For example,
        // aptos/abc|2
        // aptos/abc|1
        // aptos/abc|0
        // aptos/abd|1
        // if we seek('aptos/'), and call next, we may not reach `aptos/abd/1` because the prefix extractor we adopted
        // here will stick with prefix `aptos/abc` and return `None` or any arbitrary result after visited all the
        // keys starting with `aptos/abc`.
        read_opts.set_total_order_seek(true);
        let mut kv_iter = db
            .metadata_db()
            .iter_with_opts::<StateValueSchema>(read_opts)?;
        if let Some(first_key) = &first_key {
            kv_iter.seek(&(first_key.clone(), u64::MAX))?;
        } else {
            kv_iter.seek(&&key_prefix)?;
        };
        Ok(Self {
            kv_iter: Some(kv_iter),
            key_prefix,
            prev_key: None,
            desired_version,
            is_finished: false,
        })
    }
```

**File:** storage/aptosdb/src/utils/iterators.rs (L158-162)
```rust
                if !self.key_prefix.is_prefix(&state_key)? {
                    // No more keys matching the key_prefix, we can return the result.
                    self.is_finished = true;
                    break;
                }
```

**File:** storage/indexer/src/utils.rs (L54-58)
```rust
        while let Some((state_key, _)) = iter.next().transpose()? {
            if !self.key_prefix.is_prefix(&state_key)? {
                self.is_finished = true;
                return Ok(None);
            }
```

**File:** api/src/accounts.rs (L91-128)
```rust
    async fn get_account_resources(
        &self,
        accept_type: AcceptType,
        /// Address of account with or without a `0x` prefix
        address: Path<Address>,
        /// Ledger version to get state of account
        ///
        /// If not provided, it will be the latest version
        ledger_version: Query<Option<U64>>,
        /// Cursor specifying where to start for pagination
        ///
        /// This cursor cannot be derived manually client-side. Instead, you must
        /// call this endpoint once without this query parameter specified, and
        /// then use the cursor returned in the X-Aptos-Cursor header in the
        /// response.
        start: Query<Option<StateKeyWrapper>>,
        /// Max number of account resources to retrieve
        ///
        /// If not provided, defaults to default page size.
        limit: Query<Option<u16>>,
    ) -> BasicResultWith404<Vec<MoveResource>> {
        fail_point_poem("endpoint_get_account_resources")?;
        self.context
            .check_api_output_enabled("Get account resources", &accept_type)?;

        let context = self.context.clone();
        api_spawn_blocking(move || {
            let account = Account::new(
                context,
                address.0,
                ledger_version.0,
                start.0.map(StateKey::from),
                limit.0,
            )?;
            account.resources(&accept_type)
        })
        .await
    }
```

**File:** api/types/src/wrappers.rs (L133-141)
```rust
impl FromStr for StateKeyWrapper {
    type Err = anyhow::Error;

    fn from_str(s: &str) -> anyhow::Result<Self, anyhow::Error> {
        let state_key_prefix: StateKey =
            StateKey::decode(&hex::decode(s).context("Failed to decode StateKey as hex string")?)
                .context("Failed to decode StateKey from hex string")?;
        Ok(StateKeyWrapper(state_key_prefix))
    }
```

**File:** api/src/context.rs (L477-496)
```rust
        let account_iter = if !db_sharding_enabled(&self.node_config) {
            Box::new(
                self.db
                    .get_prefixed_state_value_iterator(
                        &StateKeyPrefix::from(address),
                        prev_state_key,
                        version,
                    )?
                    .map(|item| item.map_err(|err| anyhow!(err.to_string()))),
            )
        } else {
            self.indexer_reader
                .as_ref()
                .ok_or_else(|| format_err!("Indexer reader doesn't exist"))?
                .get_prefixed_state_value_iterator(
                    &StateKeyPrefix::from(address),
                    prev_state_key,
                    version,
                )?
        };
```

**File:** types/src/state_store/state_key/inner.rs (L46-59)
```rust
#[derive(Clone, CryptoHasher, Eq, PartialEq, Serialize, Deserialize, Ord, PartialOrd, Hash)]
#[cfg_attr(any(test, feature = "fuzzing"), derive(proptest_derive::Arbitrary))]
#[serde(rename = "StateKey")]
pub enum StateKeyInner {
    AccessPath(AccessPath),
    TableItem {
        handle: TableHandle,
        #[serde(with = "serde_bytes")]
        key: Vec<u8>,
    },
    // Only used for testing
    #[serde(with = "serde_bytes")]
    Raw(Vec<u8>),
}
```

**File:** types/src/state_store/state_key/prefix.rs (L28-36)
```rust
    pub fn is_prefix(&self, state_key: &StateKey) -> anyhow::Result<bool> {
        let encoded_key = state_key.encoded();
        let encoded_prefix = self.encode()?;
        // Check if bytes is a sub-vector of encoded key.
        if encoded_prefix.len() > encoded_key.len() {
            return Ok(false);
        }
        Ok(encoded_prefix == encoded_key[..encoded_prefix.len()])
    }
```

**File:** storage/aptosdb/src/state_store/mod.rs (L732-746)
```rust
    pub fn get_prefixed_state_value_iterator(
        &self,
        key_prefix: &StateKeyPrefix,
        first_key_opt: Option<&StateKey>,
        desired_version: Version,
    ) -> Result<PrefixedStateValueIterator<'_>> {
        // this can only handle non-sharded db scenario.
        // For sharded db, should look at API side using internal indexer to handle this request
        PrefixedStateValueIterator::new(
            &self.state_kv_db,
            key_prefix.clone(),
            first_key_opt.cloned(),
            desired_version,
        )
    }
```
