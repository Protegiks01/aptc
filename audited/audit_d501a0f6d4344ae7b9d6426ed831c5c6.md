# Audit Report

## Title
Remote Batch Validation Missing Individual Transaction Size Check Enables Block Space Waste Attack

## Summary
The quorum store's remote batch validation (`Batch::verify()`) does not validate individual transaction sizes against `max_transaction_size_in_bytes`, only checking aggregate batch sizes. This allows malicious validators to broadcast batches containing oversized transactions that pass consensus validation but are discarded during execution, wasting block space and reducing network throughput.

## Finding Description

The Aptos consensus system validates transaction sizes at multiple layers, but there is a critical gap in the remote batch validation path:

**Normal Flow (Secure)**:
1. Transactions enter mempool and are validated via `validate_transaction` [1](#0-0) 
2. The `check_gas` function validates transaction size against `max_transaction_size_in_bytes` [2](#0-1) 
3. Only valid transactions are batched and included in proposals

**Vulnerable Path**:
1. A malicious validator creates a `Batch` with oversized transactions (each exceeding `max_transaction_size_in_bytes`)
2. The batch is broadcast to other validators via `BatchMsg`
3. Receiving validators validate via `Batch::verify()` which only checks: [3](#0-2) 
   - Payload author matches batch info
   - Payload hash matches digest
   - Transaction count matches
   - **Byte count matches (total only, not per-transaction)**
   - Gas prices are valid
4. The batch is accepted and stored in `batch_store`
5. When pulled for block proposals, consensus validates only total block size: [4](#0-3) 
6. During execution, each oversized transaction is validated and returns `EXCEEDED_MAX_TRANSACTION_SIZE` [5](#0-4) 
7. All oversized transactions are discarded (TransactionStatus::Discard)
8. Block is committed containing only discarded transactions

The transaction metadata uses `raw_txn_bytes_len()` for size calculation: [6](#0-5) 

## Impact Explanation

**Severity: High** - Significant protocol violations and validator node slowdowns

This vulnerability enables a **block space waste attack**:
- Malicious validators can consistently propose blocks filled with transactions that will be discarded
- All honest validators waste computational resources validating and discarding these transactions
- Network throughput is reduced as valid transactions are excluded from blocks
- The attack is deterministic (all validators discard the same transactions), maintaining consensus safety
- However, it degrades liveness and wastes resources across the entire validator set

This qualifies as a **High severity issue** per Aptos bug bounty criteria:
- Causes validator node slowdowns (all validators must deserialize, validate, and discard oversized transactions)
- Represents a significant protocol violation (bypasses intended transaction size validation)
- Enables persistent DoS via resource exhaustion

## Likelihood Explanation

**Likelihood: Medium**

The attack requires:
- A malicious validator (untrusted actor per trust model)
- Ability to create and sign transactions (trivial)
- Access to consensus network for broadcasting batches (validators have this)

The attack is straightforward:
1. Craft `SignedTransaction` objects with large payloads (e.g., 1MB each)
2. Create a `Batch` with these transactions
3. Broadcast via `BatchMsg` to other validators
4. When becoming block proposer, include the batch as inline batch

No sophisticated techniques required. The only barrier is having validator status, but the trust model explicitly considers malicious validators as potential attackers.

## Recommendation

Add individual transaction size validation to `Batch::verify()`:

```rust
pub fn verify(&self) -> anyhow::Result<()> {
    // ... existing validations ...
    
    // Add individual transaction size validation
    for txn in self.payload.txns() {
        let txn_size = txn.raw_txn_bytes_len() as u64;
        ensure!(
            txn_size <= MAX_TRANSACTION_SIZE_IN_BYTES,  // Use appropriate constant/config
            "Transaction size {} exceeds maximum allowed size",
            txn_size
        );
    }
    
    Ok(())
}
```

Alternatively, add validation in `BatchCoordinator::handle_batches_msg()` before storing batches: [7](#0-6) 

The validation should use the same `max_transaction_size_in_bytes` parameter from `TransactionGasParameters` that `check_gas` uses, ensuring consistency across all validation layers.

## Proof of Concept

```rust
// Pseudocode for attack demonstration
use aptos_types::transaction::{RawTransaction, SignedTransaction};
use consensus::quorum_store::types::Batch;

// Step 1: Create oversized transaction (> 65KB for non-governance)
let large_payload = vec![0u8; 1_000_000]; // 1MB payload
let raw_txn = RawTransaction::new(
    sender,
    sequence_number,
    TransactionPayload::Script(Script::new(large_payload, vec![], vec![])),
    max_gas_amount,
    gas_unit_price,
    expiration_timestamp_secs,
    chain_id,
);
let signed_txn = SignedTransaction::new(raw_txn, authenticator);

// Step 2: Create batch with oversized transactions
let oversized_txns = vec![signed_txn; 5]; // 5x 1MB = 5MB total (under 6MB limit)
let batch = Batch::new(
    batch_id,
    oversized_txns,
    epoch,
    expiration,
    malicious_validator_id,
    gas_bucket_start,
);

// Step 3: Broadcast to other validators
network_sender.send_batch_msg(batch, peer_validators).await;

// Result: Batch passes verification at all validators
// When included in block: consensus accepts (5MB < 6MB limit)
// During execution: all 5 transactions discarded (each > 65KB)
// Block contains only discarded transactions
```

**Notes**

The vulnerability exists because batch validation assumes transactions were already validated by mempool when batched. However, the remote batch path allows validators to inject arbitrary batches that bypass this assumption. The consensus layer's aggregate size checks are insufficient to prevent this attack since multiple small-but-oversized transactions can fit within block limits while still exceeding per-transaction limits.

### Citations

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1998-2012)
```rust
        // Revalidate the transaction.
        let mut prologue_session = PrologueSession::new(self, &txn_data, resolver);
        let initial_gas = gas_meter.balance();
        let serialized_signers = unwrap_or_discard!(prologue_session.execute(|session| {
            self.validate_signed_transaction(
                session,
                code_storage,
                txn,
                &txn_data,
                log_context,
                is_approved_gov_script,
                &mut traversal_context,
                gas_meter,
            )
        }));
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L3163-3305)
```rust
    fn validate_transaction(
        &self,
        transaction: SignedTransaction,
        state_view: &impl StateView,
        module_storage: &impl ModuleStorage,
    ) -> VMValidatorResult {
        let _timer = TXN_VALIDATION_SECONDS.start_timer();
        let log_context = AdapterLogSchema::new(state_view.id(), 0);

        if !self
            .features()
            .is_enabled(FeatureFlag::SINGLE_SENDER_AUTHENTICATOR)
        {
            if let aptos_types::transaction::authenticator::TransactionAuthenticator::SingleSender{ .. } = transaction.authenticator_ref() {
                return VMValidatorResult::error(StatusCode::FEATURE_UNDER_GATING);
            }
        }

        if !self.features().is_enabled(FeatureFlag::WEBAUTHN_SIGNATURE) {
            if let Ok(sk_authenticators) = transaction
                .authenticator_ref()
                .to_single_key_authenticators()
            {
                for authenticator in sk_authenticators {
                    if let AnySignature::WebAuthn { .. } = authenticator.signature() {
                        return VMValidatorResult::error(StatusCode::FEATURE_UNDER_GATING);
                    }
                }
            } else {
                return VMValidatorResult::error(StatusCode::INVALID_SIGNATURE);
            }
        }

        if !self
            .features()
            .is_enabled(FeatureFlag::SLH_DSA_SHA2_128S_SIGNATURE)
        {
            if let Ok(sk_authenticators) = transaction
                .authenticator_ref()
                .to_single_key_authenticators()
            {
                for authenticator in sk_authenticators {
                    if let AnySignature::SlhDsa_Sha2_128s { .. } = authenticator.signature() {
                        return VMValidatorResult::error(StatusCode::FEATURE_UNDER_GATING);
                    }
                }
            } else {
                return VMValidatorResult::error(StatusCode::INVALID_SIGNATURE);
            }
        }

        if !self
            .features()
            .is_enabled(FeatureFlag::ALLOW_SERIALIZED_SCRIPT_ARGS)
        {
            if let Ok(TransactionExecutableRef::Script(script)) =
                transaction.payload().executable_ref()
            {
                for arg in script.args() {
                    if let TransactionArgument::Serialized(_) = arg {
                        return VMValidatorResult::error(StatusCode::FEATURE_UNDER_GATING);
                    }
                }
            }
        }

        if transaction.payload().is_encrypted_variant() {
            return VMValidatorResult::error(StatusCode::FEATURE_UNDER_GATING);
        }
        let txn = match transaction.check_signature() {
            Ok(t) => t,
            _ => {
                return VMValidatorResult::error(StatusCode::INVALID_SIGNATURE);
            },
        };
        let auxiliary_info = AuxiliaryInfo::new_timestamp_not_yet_assigned(0);
        let txn_data = TransactionMetadata::new(&txn, &auxiliary_info);

        let resolver = self.as_move_resolver(&state_view);
        let is_approved_gov_script = is_approved_gov_script(&resolver, &txn, &txn_data);

        let mut session = self.new_session(
            &resolver,
            SessionId::prologue_meta(&txn_data),
            Some(txn_data.as_user_transaction_context()),
        );

        let vm_params = match self.gas_params(&log_context) {
            Ok(vm_params) => vm_params.vm.clone(),
            Err(err) => {
                return VMValidatorResult::new(Some(err.status_code()), 0);
            },
        };
        let storage_gas_params = match self.storage_gas_params(&log_context) {
            Ok(storage_params) => storage_params.clone(),
            Err(err) => {
                return VMValidatorResult::new(Some(err.status_code()), 0);
            },
        };

        let initial_balance = if self.features().is_account_abstraction_enabled()
            || self.features().is_derivable_account_abstraction_enabled()
        {
            vm_params.txn.max_aa_gas.min(txn_data.max_gas_amount())
        } else {
            txn_data.max_gas_amount()
        };

        let mut gas_meter = make_prod_gas_meter(
            self.gas_feature_version(),
            vm_params,
            storage_gas_params,
            is_approved_gov_script,
            initial_balance,
            &NoopBlockSynchronizationKillSwitch {},
        );
        let storage = TraversalStorage::new();

        // Increment the counter for transactions verified.
        let (counter_label, result) = match self.validate_signed_transaction(
            &mut session,
            module_storage,
            &txn,
            &txn_data,
            &log_context,
            is_approved_gov_script,
            &mut TraversalContext::new(&storage),
            &mut gas_meter,
        ) {
            Err(err) if err.status_code() != StatusCode::SEQUENCE_NUMBER_TOO_NEW => (
                "failure",
                VMValidatorResult::new(Some(err.status_code()), 0),
            ),
            _ => (
                "success",
                VMValidatorResult::new(None, txn.gas_unit_price()),
            ),
        };

        TRANSACTIONS_VALIDATED.inc_with(&[counter_label]);

        result
    }
```

**File:** aptos-move/aptos-vm/src/gas.rs (L70-121)
```rust
pub(crate) fn check_gas(
    gas_params: &AptosGasParameters,
    gas_feature_version: u64,
    resolver: &impl AptosMoveResolver,
    module_storage: &impl ModuleStorage,
    txn_metadata: &TransactionMetadata,
    features: &Features,
    is_approved_gov_script: bool,
    log_context: &AdapterLogSchema,
) -> Result<(), VMStatus> {
    let txn_gas_params = &gas_params.vm.txn;
    let raw_bytes_len = txn_metadata.transaction_size;

    if is_approved_gov_script {
        let max_txn_size_gov = if gas_feature_version >= RELEASE_V1_13 {
            gas_params.vm.txn.max_transaction_size_in_bytes_gov
        } else {
            MAXIMUM_APPROVED_TRANSACTION_SIZE_LEGACY.into()
        };

        if txn_metadata.transaction_size > max_txn_size_gov
            // Ensure that it is only the approved payload that exceeds the
            // maximum. The (unknown) user input should be restricted to the original
            // maximum transaction size.
            || txn_metadata.transaction_size
                > txn_metadata.script_size + txn_gas_params.max_transaction_size_in_bytes
        {
            speculative_warn!(
                log_context,
                format!(
                    "[VM] Governance transaction size too big {} payload size {}",
                    txn_metadata.transaction_size, txn_metadata.script_size,
                ),
            );
            return Err(VMStatus::error(
                StatusCode::EXCEEDED_MAX_TRANSACTION_SIZE,
                None,
            ));
        }
    } else if txn_metadata.transaction_size > txn_gas_params.max_transaction_size_in_bytes {
        speculative_warn!(
            log_context,
            format!(
                "[VM] Transaction size too big {} (max {})",
                txn_metadata.transaction_size, txn_gas_params.max_transaction_size_in_bytes
            ),
        );
        return Err(VMStatus::error(
            StatusCode::EXCEEDED_MAX_TRANSACTION_SIZE,
            None,
        ));
    }
```

**File:** consensus/src/quorum_store/types.rs (L262-290)
```rust
    pub fn verify(&self) -> anyhow::Result<()> {
        ensure!(
            self.payload.author() == self.author(),
            "Payload author doesn't match the info"
        );
        ensure!(
            self.payload.hash() == *self.digest(),
            "Payload hash doesn't match the digest"
        );
        ensure!(
            self.payload.num_txns() as u64 == self.num_txns(),
            "Payload num txns doesn't match batch info"
        );
        ensure!(
            self.payload.num_bytes() as u64 == self.num_bytes(),
            "Payload num bytes doesn't match batch info"
        );
        for txn in self.payload.txns() {
            ensure!(
                txn.gas_unit_price() >= self.gas_bucket_start(),
                "Payload gas unit price doesn't match batch info"
            );
            ensure!(
                !txn.payload().is_encrypted_variant(),
                "Encrypted transaction is not supported yet"
            );
        }
        Ok(())
    }
```

**File:** consensus/src/round_manager.rs (L1178-1193)
```rust
        let payload_len = proposal.payload().map_or(0, |payload| payload.len());
        let payload_size = proposal.payload().map_or(0, |payload| payload.size());
        ensure!(
            num_validator_txns + payload_len as u64 <= self.local_config.max_receiving_block_txns,
            "Payload len {} exceeds the limit {}",
            payload_len,
            self.local_config.max_receiving_block_txns,
        );

        ensure!(
            validator_txns_total_bytes + payload_size as u64
                <= self.local_config.max_receiving_block_bytes,
            "Payload size {} exceeds the limit {}",
            payload_size,
            self.local_config.max_receiving_block_bytes,
        );
```

**File:** aptos-move/aptos-vm/src/transaction_metadata.rs (L63-63)
```rust
            transaction_size: (txn.raw_txn_bytes_len() as u64).into(),
```

**File:** consensus/src/quorum_store/batch_coordinator.rs (L173-213)
```rust
    pub(crate) async fn handle_batches_msg(
        &mut self,
        author: PeerId,
        batches: Vec<Batch<BatchInfoExt>>,
    ) {
        if let Err(e) = self.ensure_max_limits(&batches) {
            error!("Batch from {}: {}", author, e);
            counters::RECEIVED_BATCH_MAX_LIMIT_FAILED.inc();
            return;
        }

        let Some(batch) = batches.first() else {
            error!("Empty batch received from {}", author.short_str().as_str());
            return;
        };

        // Filter the transactions in the batches. If any transaction is rejected,
        // the message will be dropped, and all batches will be rejected.
        if self.transaction_filter_config.is_enabled() {
            let transaction_filter = &self.transaction_filter_config.batch_transaction_filter();
            for batch in batches.iter() {
                for transaction in batch.txns() {
                    if !transaction_filter.allows_transaction(
                        batch.batch_info().batch_id(),
                        batch.author(),
                        batch.digest(),
                        transaction,
                    ) {
                        error!(
                            "Transaction {}, in batch {}, from {}, was rejected by the filter. Dropping {} batches!",
                            transaction.committed_hash(),
                            batch.batch_info().batch_id(),
                            author.short_str().as_str(),
                            batches.len()
                        );
                        counters::RECEIVED_BATCH_REJECTED_BY_FILTER.inc();
                        return;
                    }
                }
            }
        }
```
