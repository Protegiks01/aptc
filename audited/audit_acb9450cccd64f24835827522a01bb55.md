# Audit Report

## Title
Information Disclosure via Unredacted Referer Header Logging in Aptos Faucet Middleware

## Summary
The Aptos Faucet logging middleware captures and logs the complete HTTP Referer header without sanitization or redaction. This can expose sensitive authentication tokens, session identifiers, and other confidential parameters from referring URLs to anyone with access to the faucet's log files or log aggregation systems.

## Finding Description

The `middleware_log()` function in the faucet's logging middleware extracts and logs the complete Referer header without any filtering or sanitization: [1](#0-0) 

This referer value is stored in the `HttpRequestLog` struct and subsequently logged through structured logging at multiple severity levels: [2](#0-1) 

The security issue arises when users navigate to the faucet from pages that contain sensitive information in their URLs. According to the HTTP specification, browsers automatically include the complete URL of the referring page in the Referer header, including all query parameters and URL fragments.

**Attack Scenario:**

1. A user visits a page containing sensitive parameters: `https://admin-panel.example.com/dashboard?session_token=abc123xyz&api_key=sk_live_789def`
2. From that page, the user clicks a link to the Aptos Faucet
3. The browser automatically sends: `Referer: https://admin-panel.example.com/dashboard?session_token=abc123xyz&api_key=sk_live_789def`
4. The faucet logs this complete URL with all sensitive parameters
5. Anyone with log access (operators, DevOps, third-party log aggregation services) can now view these credentials

While the faucet itself uses Authorization headers for authentication (as seen in the JWT verification and API key bypasser implementations), external sites often use URL-based authentication which then leaks through the Referer header. [3](#0-2) [4](#0-3) 

## Impact Explanation

This vulnerability qualifies as **Medium Severity** under the Aptos Bug Bounty criteria, which includes "Minor information leaks" at Low Severity and "Limited funds loss or manipulation" at Medium Severity.

The impact is elevated to Medium because:

1. **Broad Exposure Surface**: Logs are typically accessible to system administrators, DevOps personnel, security monitoring tools, and often third-party log aggregation services (CloudWatch, Splunk, ELK stack), significantly wider than credential access should be.

2. **Long-term Retention**: Logs are frequently retained for extended periods (months to years) for compliance and debugging purposes, creating a persistent attack surface even after tokens expire.

3. **Credential Harvesting**: An attacker with log access could harvest authentication tokens, API keys, and session identifiers from various external services, potentially enabling lateral movement or escalation of privileges in connected systems.

4. **Chain Attack Enabler**: While not directly compromising the faucet or blockchain, this leak could facilitate attacks on users' accounts in other systems, which could then be leveraged for social engineering or targeted attacks against Aptos users.

## Likelihood Explanation

The likelihood of this vulnerability being exploited is **MODERATE to HIGH**:

1. **Automatic Trigger**: This occurs through normal browser behavior - no special attacker action is required beyond having log access.

2. **Common Bad Practice**: Many web applications still include sensitive data in URLs despite security best practices discouraging this. OAuth flows, password reset tokens, and API keys in URLs are still common.

3. **Log Access**: While logs should have restricted access, in practice, they are often more accessible than authentication systems due to operational requirements, monitoring needs, and incident response workflows.

4. **No Detection**: This information disclosure occurs silently through normal logging operations with no anomaly detection or alerting.

## Recommendation

Implement Referer header sanitization before logging to redact sensitive query parameters:

```rust
use url::Url;

fn sanitize_referer(referer: &str) -> String {
    match Url::parse(referer) {
        Ok(mut url) => {
            // Remove all query parameters to prevent token leakage
            url.set_query(None);
            url.set_fragment(None);
            url.to_string()
        },
        Err(_) => {
            // If parsing fails, log only the domain/host portion
            referer.split('?').next().unwrap_or(referer).to_string()
        }
    }
}

// In middleware_log():
referer: request
    .headers()
    .get(header::REFERER)
    .and_then(|v| v.to_str().ok().map(|v| sanitize_referer(v))),
```

Alternatively, implement a redaction pattern for common sensitive parameter names:

```rust
fn redact_sensitive_params(url: &str) -> String {
    let sensitive_params = [
        "token", "api_key", "apikey", "key", "secret", 
        "password", "pwd", "session", "auth", "access_token",
        "refresh_token", "jwt", "bearer"
    ];
    
    let mut result = url.to_string();
    for param in &sensitive_params {
        // Redact both snake_case and camelCase variants
        let patterns = [
            format!("{}=", param),
            format!("{}=", param.to_uppercase()),
        ];
        for pattern in &patterns {
            if let Some(pos) = result.find(pattern) {
                if let Some(end) = result[pos..].find('&').map(|i| pos + i) {
                    result.replace_range(pos + pattern.len()..end, "[REDACTED]");
                } else {
                    // Last parameter in URL
                    let end = result[pos..].find('#').map(|i| pos + i).unwrap_or(result.len());
                    result.replace_range(pos + pattern.len()..end, "[REDACTED]");
                }
            }
        }
    }
    result
}
```

## Proof of Concept

```bash
# Step 1: Start the Aptos Faucet service
# Assume faucet is running at http://localhost:8081

# Step 2: Send a request with a referer containing sensitive tokens
curl -X POST http://localhost:8081/v1/fund \
  -H "Content-Type: application/json" \
  -H "Referer: https://admin.example.com/panel?session_token=SENSITIVE_SESSION_123&api_key=sk_live_PRIVATE_KEY_789" \
  -d '{
    "address": "0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef",
    "amount": 100000000
  }'

# Step 3: Check the faucet logs
# The logs will contain:
# {
#   "source_ip": "127.0.0.1",
#   "method": "POST",
#   "path": "/v1/fund",
#   "referer": "https://admin.example.com/panel?session_token=SENSITIVE_SESSION_123&api_key=sk_live_PRIVATE_KEY_789",
#   "user_agent": "curl/7.68.0",
#   ...
# }

# The sensitive tokens are now exposed in the logs
```

**Notes:**

This vulnerability is confirmed in the codebase and represents a legitimate information disclosure risk. However, it should be noted that:

1. The faucet itself does not use URL-based authentication, so its own credentials are not leaked through this mechanism
2. The leaked information comes from external referring sites that use poor security practices
3. The primary security control should be proper log access management and retention policies
4. This is similar to standard web server logging behavior, though security-conscious applications typically sanitize such data

The vulnerability exists because modern security best practices recommend redacting sensitive parameters from logged URLs, and the faucet currently lacks this protection.

### Citations

**File:** crates/aptos-faucet/core/src/middleware/log.rs (L34-37)
```rust
        referer: request
            .headers()
            .get(header::REFERER)
            .and_then(|v| v.to_str().ok().map(|v| v.to_string())),
```

**File:** crates/aptos-faucet/core/src/middleware/log.rs (L145-151)
```rust
                        info!(self.request_log, *response_log, process_info)
                    );
                } else if response_log.response_status >= 500 {
                    error!(self.request_log, *response_log, process_info);
                } else {
                    info!(self.request_log, *response_log, process_info);
                }
```

**File:** crates/aptos-faucet/core/src/firebase_jwt.rs (L91-101)
```rust
    match headers
        .get(AUTHORIZATION)
        .and_then(|v| v.to_str().ok())
        .and_then(|v| v.split_whitespace().nth(1))
    {
        Some(auth_token) => Ok(auth_token.to_string()),
        None => Err(AptosTapError::new(
            "Either the Authorization header is missing or it is not in the form of 'Bearer <token>'".to_string(),
            AptosTapErrorCode::AuthTokenInvalid,
        )),
    }
```

**File:** crates/aptos-faucet/core/src/bypasser/auth_token.rs (L38-46)
```rust
        let auth_token = match data
            .headers
            .get(AUTHORIZATION)
            .and_then(|v| v.to_str().ok())
            .and_then(|v| v.split_whitespace().nth(1))
        {
            Some(auth_token) => auth_token,
            None => return Ok(false),
        };
```
