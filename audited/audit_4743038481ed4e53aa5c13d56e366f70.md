# Audit Report

## Title
Missing Validation in Groth16 Verification Key Update Allows Governance-Induced DoS of All Keyless Accounts

## Summary
The `Groth16VerificationKey` structure stores `alpha_g1` and other elliptic curve points as raw bytes without validation when set via governance proposals. A `validate_groth16_vk()` function exists in the Move code but is never called, allowing invalid or malicious verification keys to be deployed on-chain, permanently disabling all ZK keyless accounts. [1](#0-0) 

## Finding Description

The keyless authentication system relies on a Groth16 verification key stored on-chain to validate zero-knowledge proofs. This verification key contains critical cryptographic parameters including `alpha_g1`, `beta_g2`, `gamma_g2`, `delta_g2`, and `gamma_abc_g1`.

**Critical Flaw: Validation Function Exists But Is Never Called**

The Move framework contains a validation function that checks all curve points: [2](#0-1) 

However, this validation function is **dead code** - it is never invoked by any VK-setting function:

1. `new_groth16_verification_key()` - constructs VK without validation [3](#0-2) 

2. `set_groth16_verification_key_for_next_epoch()` - accepts VK via governance without validation [4](#0-3) 

3. `on_new_epoch()` - applies queued VK changes without validation [5](#0-4) 

**Attack Vector via Governance**

A governance proposal can set an invalid verification key using a script that calls `set_groth16_verification_key_for_next_epoch()`: [6](#0-5) 

**Two Attack Scenarios**

**Scenario A: Invalid Curve Points (e.g., invalid alpha_g1)**
When the Rust code attempts to convert the on-chain VK to a `PreparedVerifyingKey`: [7](#0-6) 

If `alpha_g1` contains invalid bytes, deserialization fails, returning `Err(CryptoMaterialError::DeserializationError)`. The environment initialization handles this failure: [8](#0-7) 

Note the misleading comment claiming validation happens in Move - this is **false**. When deserialization fails, `keyless_pvk` becomes `None`. Subsequently, all ZK keyless transactions are rejected: [9](#0-8) 

**Scenario B: Valid But Cryptographically Incorrect Points**
If an attacker provides valid BN254 curve points that don't correspond to the actual circuit's verification key, deserialization succeeds but the pairing `e(alpha_g1, beta_g2)` will be incorrect. When proof verification executes: [10](#0-9) 

The pairing equation check will fail for all legitimate proofs, resulting in verification failures: [11](#0-10) 

## Impact Explanation

This vulnerability qualifies as **Critical Severity** under Aptos bug bounty criteria for the following reasons:

1. **Total Loss of Liveness/Network Availability**: All users with keyless accounts (ZK-based) lose access to their funds and cannot submit transactions. This represents a permanent freezing of funds until governance can pass another proposal to fix the VK.

2. **Non-Recoverable Without Governance**: Recovery requires a new governance proposal. If a significant portion of governance participants use keyless accounts, the system could become permanently broken, potentially requiring a hard fork.

3. **Violates Critical Invariants**:
   - **Cryptographic Correctness**: The invalid `alpha_g1` breaks the pairing equation `e(A, B) = e(alpha_g1, beta_g2) * e(sum, gamma_g2) * e(C, delta_g2)`
   - **Transaction Validation**: Authentication checks can no longer be performed correctly
   - **Governance Integrity**: Governance should not be able to permanently break core system functionality

The impact affects all keyless account users simultaneously, making this a network-wide availability incident rather than an isolated account compromise.

## Likelihood Explanation

**Likelihood: Medium to High**

This vulnerability can occur through three realistic paths:

1. **Accidental Misconfiguration**: During a legitimate VK rotation (e.g., circuit upgrade), a governance proposer could accidentally provide malformed bytes due to:
   - Encoding errors (wrong hex format)
   - Copy-paste mistakes
   - Incorrect parameter ordering
   - Circuit compilation errors

2. **Malicious Governance Proposal**: An attacker who gains influence over governance (through stake accumulation or social engineering) could deliberately submit a malicious VK to DoS the network.

3. **Compromised VK Generation**: If the off-chain VK generation process is compromised, an attacker could inject an invalid VK that passes initial testing but fails in production.

The test suite demonstrates that VK rotation is an expected operation, making accidental misconfiguration a realistic concern. The lack of on-chain validation means there is **no safety net** to prevent these scenarios.

## Recommendation

**Immediate Fix: Call Validation Function**

Modify `set_groth16_verification_key_for_next_epoch()` to validate the VK before accepting it:

```move
public fun set_groth16_verification_key_for_next_epoch(fx: &signer, vk: Groth16VerificationKey) {
    system_addresses::assert_aptos_framework(fx);
    validate_groth16_vk(&vk);  // ADD THIS LINE
    config_buffer::upsert<Groth16VerificationKey>(vk);
}
```

Similarly, modify `update_groth16_verification_key()` for genesis:

```move
public fun update_groth16_verification_key(fx: &signer, vk: Groth16VerificationKey) {
    system_addresses::assert_aptos_framework(fx);
    chain_status::assert_genesis();
    validate_groth16_vk(&vk);  // ADD THIS LINE
    move_to(fx, vk);
}
```

**Additional Safeguards**

1. **Test VK Before Deployment**: Add a governance proposal template that includes test proof verification before committing the VK change.

2. **Rollback Mechanism**: Implement a time-locked VK change system where the new VK can be rolled back within a grace period if issues are detected.

3. **Cryptographic Verification**: Beyond point validation, consider adding a test proof/statement pair that must verify successfully before the VK can be set.

4. **Update Documentation**: Fix the misleading comment in `environment.rs` that claims validation occurs in Move. [12](#0-11) 

## Proof of Concept

The following Move script demonstrates how a governance proposal can set an invalid VK:

```move
script {
    use aptos_framework::keyless_account;
    use aptos_framework::aptos_governance;
    
    fun main(core_resources: &signer) {
        let framework_signer = aptos_governance::get_signer_testnet_only(core_resources, @0x1);
        
        // Create VK with invalid alpha_g1 (all zeros - not a valid curve point)
        let invalid_vk = keyless_account::new_groth16_verification_key(
            x"0000000000000000000000000000000000000000000000000000000000000000",  // Invalid alpha_g1
            x"abb73dc17fbc13021e2471e0c08bd67d8401f52b73d6d07483794cad4778180e0c06f33bbc4c79a9cadef253a68084d382f17788f885c9afd176f7cb2f036789",  // Valid beta_g2
            x"edf692d95cbdde46ddda5ef7d422436779445c5e66006a42761e1f12efde0018c212f3aeb785e49712e7a9353349aaf1255dfb31b7bf60723a480d9293938e19",  // Valid gamma_g2
            x"b106619932d0ef372c46909a2492e246d5de739aa140e27f2c71c0470662f125219049cfe15e4d140d7e4bb911284aad1cad19880efb86f2d9dd4b1bb344ef8f",  // Valid delta_g2
            vector[
                x"6123b6fea40de2a7e3595f9c35210da8a45a7e8c2f7da9eb4548e9210cfea81a",
                x"32a9b8347c512483812ee922dc75952842f8f3083edb6fe8d5c3c07e1340b683"
            ]  // Valid gamma_abc_g1
        );
        
        // This call succeeds without validation!
        keyless_account::set_groth16_verification_key_for_next_epoch(&framework_signer, invalid_vk);
        aptos_governance::force_end_epoch(&framework_signer);
    }
}
```

**Expected Result**: The proposal passes and sets the invalid VK on-chain. Subsequently:
- All ZK keyless transactions are rejected with "Groth16 VK has not been set on-chain" (Scenario A)
- OR all ZK keyless transactions fail proof verification (Scenario B if using wrong but valid points)

**Validation**: Run this script in a test environment and observe that it successfully sets an invalid VK, then attempt a keyless transaction to confirm the DoS.

## Notes

The vulnerability exists because of a disconnect between the Rust and Move codebases:
- **Rust expectation**: Comments indicate Move should validate the VK
- **Move reality**: Validation function exists but is never called
- **Result**: No layer provides adequate validation

This represents a critical gap in defense-in-depth. While the Rust deserialization provides some protection against invalid encodings, it cannot protect against valid encodings of incorrect keys, and the failure mode (complete DoS) is catastrophic. The fix is straightforward: simply invoke the existing validation function.

### Citations

**File:** types/src/keyless/groth16_vk.rs (L26-26)
```rust
    pub alpha_g1: Vec<u8>,
```

**File:** types/src/keyless/groth16_vk.rs (L75-76)
```rust
            alpha_g1: G1Affine::deserialize_compressed(vk.alpha_g1.as_slice())
                .map_err(|_| CryptoMaterialError::DeserializationError)?,
```

**File:** aptos-move/framework/aptos-framework/sources/keyless_account.move (L145-158)
```text
    public fun new_groth16_verification_key(alpha_g1: vector<u8>,
                                            beta_g2: vector<u8>,
                                            gamma_g2: vector<u8>,
                                            delta_g2: vector<u8>,
                                            gamma_abc_g1: vector<vector<u8>>
    ): Groth16VerificationKey {
        Groth16VerificationKey {
            alpha_g1,
            beta_g2,
            gamma_g2,
            delta_g2,
            gamma_abc_g1,
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/keyless_account.move (L183-192)
```text
    fun validate_groth16_vk(vk: &Groth16VerificationKey) {
        // Could be leveraged to speed up the VM deserialization of the VK by 2x, since it can assume the points are valid.
        assert!(option::is_some(&crypto_algebra::deserialize<bn254_algebra::G1, bn254_algebra::FormatG1Compr>(&vk.alpha_g1)), E_INVALID_BN254_G1_SERIALIZATION);
        assert!(option::is_some(&crypto_algebra::deserialize<bn254_algebra::G2, bn254_algebra::FormatG2Compr>(&vk.beta_g2)), E_INVALID_BN254_G2_SERIALIZATION);
        assert!(option::is_some(&crypto_algebra::deserialize<bn254_algebra::G2, bn254_algebra::FormatG2Compr>(&vk.gamma_g2)), E_INVALID_BN254_G2_SERIALIZATION);
        assert!(option::is_some(&crypto_algebra::deserialize<bn254_algebra::G2, bn254_algebra::FormatG2Compr>(&vk.delta_g2)), E_INVALID_BN254_G2_SERIALIZATION);
        for (i in 0..vector::length(&vk.gamma_abc_g1)) {
            assert!(option::is_some(&crypto_algebra::deserialize<bn254_algebra::G1, bn254_algebra::FormatG1Compr>(vector::borrow(&vk.gamma_abc_g1, i))), E_INVALID_BN254_G1_SERIALIZATION);
        };
    }
```

**File:** aptos-move/framework/aptos-framework/sources/keyless_account.move (L263-266)
```text
    public fun set_groth16_verification_key_for_next_epoch(fx: &signer, vk: Groth16VerificationKey) {
        system_addresses::assert_aptos_framework(fx);
        config_buffer::upsert<Groth16VerificationKey>(vk);
    }
```

**File:** aptos-move/framework/aptos-framework/sources/keyless_account.move (L358-378)
```text
    public(friend) fun on_new_epoch(fx: &signer) acquires Groth16VerificationKey, Configuration {
        system_addresses::assert_aptos_framework(fx);

        if (config_buffer::does_exist<Groth16VerificationKey>()) {
            let vk = config_buffer::extract_v2();
            if (exists<Groth16VerificationKey>(@aptos_framework)) {
                *borrow_global_mut<Groth16VerificationKey>(@aptos_framework) = vk;
            } else {
                move_to(fx, vk);
            }
        };

        if (config_buffer::does_exist<Configuration>()) {
            let config = config_buffer::extract_v2();
            if (exists<Configuration>(@aptos_framework)) {
                *borrow_global_mut<Configuration>(@aptos_framework) = config;
            } else {
                move_to(fx, config);
            }
        };
    }
```

**File:** testsuite/smoke-test/src/keyless.rs (L1018-1045)
```rust
fn get_rotate_vk_governance_script(vk: &Groth16VerificationKey) -> String {
    let script = format!(
        r#"
script {{
    use aptos_framework::{};
    use aptos_framework::aptos_governance;
    fun main(core_resources: &signer) {{
        let framework_signer = aptos_governance::get_signer_testnet_only(core_resources, @0x1);
        let vk = {}::new_groth16_verification_key(x"{}", x"{}", x"{}", x"{}", vector[x"{}", x"{}"]);
        {}::set_groth16_verification_key_for_next_epoch(&framework_signer, vk);
        aptos_governance::force_end_epoch(&framework_signer);
    }}
}}
"#,
        KEYLESS_ACCOUNT_MODULE_NAME,
        KEYLESS_ACCOUNT_MODULE_NAME,
        hex::encode(&vk.alpha_g1),
        hex::encode(&vk.beta_g2),
        hex::encode(&vk.gamma_g2),
        hex::encode(&vk.delta_g2),
        hex::encode(&vk.gamma_abc_g1[0]),
        hex::encode(&vk.gamma_abc_g1[1]),
        KEYLESS_ACCOUNT_MODULE_NAME
    );
    debug!("Move script for changing VK follows below:\n{:?}", script);

    script
}
```

**File:** aptos-move/aptos-vm-environment/src/environment.rs (L287-293)
```rust
        // We use an `Option` to handle the VK not being set on-chain, or an incorrect VK being set
        // via governance (although, currently, we do check for that in `keyless_account.move`).
        let keyless_pvk =
            Groth16VerificationKey::fetch_keyless_config(state_view).and_then(|(vk, vk_bytes)| {
                sha3_256.update(&vk_bytes);
                vk.try_into().ok()
            });
```

**File:** aptos-move/aptos-vm/src/keyless_validation.rs (L188-191)
```rust
    // If there are ZK authenticators, the Groth16 VK must have been set on-chain.
    if with_zk && pvk.is_none() {
        return Err(invalid_signature!("Groth16 VK has not been set on-chain"));
    }
```

**File:** aptos-move/aptos-vm/src/keyless_validation.rs (L347-362)
```rust
                        let result = zksig.verify_groth16_proof(public_inputs_hash, pvk.unwrap());

                        result.map_err(|_| {
                            // println!("[aptos-vm][groth16] ZKP verification failed");
                            // println!("[aptos-vm][groth16] PIH: {}", public_inputs_hash);
                            // match zksig.proof {
                            //     ZKP::Groth16(proof) => {
                            //         println!("[aptos-vm][groth16] ZKP: {}", proof.hash());
                            //     },
                            // }
                            // println!(
                            //     "[aptos-vm][groth16] PVK: {}",
                            //     Groth16VerificationKey::from(pvk).hash()
                            // );
                            invalid_signature!("Proof verification failed")
                        })?;
```

**File:** types/src/keyless/groth16_sig.rs (L229-229)
```rust
        let verified = Groth16::<Bn254>::verify_proof(pvk, &proof, &[public_inputs_hash])?;
```
