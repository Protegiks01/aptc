# Audit Report

## Title
Unvalidated Chunk Count Causes Index Out-of-Bounds Panic in DKG Transcript Verification

## Summary
The PVSS transcript verification code does not validate that chunked ElGamal ciphertexts contain the expected number of chunks before accessing a fixed-size array, allowing malicious validators to crash all honest validator nodes during Distributed Key Generation (DKG) transcript verification.

## Finding Description

The DKG protocol uses chunked ElGamal encryption where field elements are split into `num_chunks_per_scalar(ell)` chunks. The verification code computes a Multi-Scalar Multiplication (MSM) that indexes into a precomputed array `pp.powers_of_radix` without validating chunk counts. [1](#0-0) 

The `powers_of_radix` array has exactly `num_chunks_per_scalar(ell)` elements, computed during public parameter initialization: [2](#0-1) 

The only validation performed checks the outer dimension of `Cs` (number of players), not the inner dimensions (chunk counts per ciphertext): [3](#0-2) [4](#0-3) 

**Attack Propagation Path:**

1. Malicious validator constructs a `Subtranscript` with `Cs[i][j]` containing more than `num_chunks_per_scalar(ell)` chunks
2. The transcript is serialized via BCS (which does not validate inner vector dimensions): [5](#0-4) 

3. Transcript is wrapped in a `ValidatorTransaction::DKGResult` and submitted to consensus
4. Validators process the transaction through the VM: [6](#0-5) 

5. VM calls DKG verification: [7](#0-6) 

6. Which flows to the weighted transcript verification: [8](#0-7) 

7. The loop iterates `j in 0..Cs_flat[i].len()` and accesses `pp.powers_of_radix[j]` without bounds checking
8. When `j >= pp.powers_of_radix.len()`, Rust panics with "index out of bounds," terminating the validator process

The sigma protocol and range proof verifications do not catch this structural issue because they verify cryptographic properties of the provided data structure, not its dimensional constraints.

## Impact Explanation

This vulnerability achieves **Critical Severity** under the Aptos Bug Bounty program criteria for **Total Loss of Liveness/Network Availability**.

A single malicious validator can crash all honest validator nodes by submitting a DKG transcript with oversized chunk vectors. Since DKG transcripts are processed as validator transactions during consensus, all validators attempting to verify the malformed transcript will panic simultaneously, halting the network.

The attack causes:
- Immediate validator process termination via panic
- Network-wide consensus halt
- Manual intervention required to restore service
- Potential persistent crash loop if the malicious transaction is included in blocks

This does NOT require:
- Validator majority control (< 1/3 Byzantine assumption holds)
- Cryptographic breaks
- Network-level attacks

It exploits a simple bounds-checking failure in critical consensus infrastructure, meeting the criteria for "Total loss of liveness/network availability" where "All validators unable to progress."

## Likelihood Explanation

**Likelihood: High**

**Attacker Requirements:**
- Participation as a validator (standard Byzantine threat model allows < 1/3 malicious validators)
- Knowledge of `num_chunks_per_scalar(ell)` (publicly available from protocol parameters)
- Ability to construct and serialize a malformed `Subtranscript` structure

**Attack Complexity: Low**
- No cryptographic operations required
- No timing dependencies
- Single malicious transcript submission sufficient
- Deterministic crash behavior (100% reliable)

**Detection Difficulty:**
- Crash manifests as generic Rust panic
- No clear attribution without forensic analysis
- May be misdiagnosed as implementation bug rather than attack

**Operational Context:**
- DKG verification is part of validator transaction processing during epoch transitions
- Cannot be bypassed without protocol changes
- Affects all validators simultaneously when processing the same malformed transcript

## Recommendation

Add explicit validation of chunk counts before accessing the `powers_of_radix` array:

```rust
for i in 0..Cs_flat.len() {
    // Validate chunk count matches expected value
    let expected_chunks = num_chunks_per_scalar::<E::ScalarField>(pp.ell) as usize;
    if Cs_flat[i].len() != expected_chunks {
        bail!(
            "Invalid chunk count: expected {}, got {}",
            expected_chunks,
            Cs_flat[i].len()
        );
    }
    
    for j in 0..Cs_flat[i].len() {
        let base = Cs_flat[i][j];
        let exp = pp.powers_of_radix[j] * powers_of_beta[i];
        base_vec.push(base);
        exp_vec.push(exp);
    }
}
```

This validation should be added at line 255 in `weighted_transcript.rs` before the MSM computation loop.

## Proof of Concept

```rust
// Test demonstrating the vulnerability
#[test]
#[should_panic(expected = "index out of bounds")]
fn test_oversized_chunks_cause_panic() {
    use rand::thread_rng;
    let mut rng = thread_rng();
    
    // Setup normal parameters
    let sc = create_test_config(4, 3);
    let pp = PublicParameters::<Bls12_381>::default();
    
    // Create a malicious transcript with oversized Cs vectors
    let mut trx = Transcript::generate(&sc, &pp, &mut rng);
    
    // Inject extra chunks into one ciphertext vector
    let extra_chunks = num_chunks_per_scalar::<Fr>(pp.ell) as usize + 5;
    trx.subtrs.Cs[0][0] = unsafe_random_points_group(extra_chunks, &mut rng);
    
    // Verification triggers panic at line 258
    let result = trx.subtrs.verify(&sc, &pp, &[], &[], &());
    // Validator process crashes here
}
```

## Notes

This vulnerability is particularly severe because:
1. It affects the critical consensus path during epoch transitions
2. The attack is deterministic and requires minimal sophistication
3. Recovery requires coordinated manual intervention across all validators
4. The malformed data could potentially be persisted in consensus state, creating a persistent crash condition

The vulnerability satisfies all criteria for Critical severity under the Aptos Bug Bounty program.

### Citations

**File:** crates/aptos-dkg/src/pvss/chunky/weighted_transcript.rs (L102-109)
```rust
impl<E: Pairing> TryFrom<&[u8]> for Subtranscript<E> {
    type Error = CryptoMaterialError;

    fn try_from(bytes: &[u8]) -> Result<Self, Self::Error> {
        bcs::from_bytes::<Subtranscript<E>>(bytes)
            .map_err(|_| CryptoMaterialError::DeserializationError)
    }
}
```

**File:** crates/aptos-dkg/src/pvss/chunky/weighted_transcript.rs (L140-153)
```rust
        if self.subtrs.Cs.len() != sc.get_total_num_players() {
            bail!(
                "Expected {} arrays of chunked ciphertexts, but got {}",
                sc.get_total_num_players(),
                self.subtrs.Cs.len()
            );
        }
        if self.subtrs.Vs.len() != sc.get_total_num_players() {
            bail!(
                "Expected {} arrays of commitment elements, but got {}",
                sc.get_total_num_players(),
                self.subtrs.Vs.len()
            );
        }
```

**File:** crates/aptos-dkg/src/pvss/chunky/weighted_transcript.rs (L247-252)
```rust
        let Cs_flat: Vec<_> = self.subtrs.Cs.iter().flatten().cloned().collect();
        assert_eq!(
            Cs_flat.len(),
            sc.get_total_weight(),
            "Number of ciphertexts does not equal number of weights"
        ); // TODO what if zero weight?
```

**File:** crates/aptos-dkg/src/pvss/chunky/weighted_transcript.rs (L255-262)
```rust
        for i in 0..Cs_flat.len() {
            for j in 0..Cs_flat[i].len() {
                let base = Cs_flat[i][j];
                let exp = pp.powers_of_radix[j] * powers_of_beta[i];
                base_vec.push(base);
                exp_vec.push(exp);
            }
        }
```

**File:** crates/aptos-dkg/src/pvss/chunky/public_parameters.rs (L35-40)
```rust
fn compute_powers_of_radix<E: Pairing>(ell: u8) -> Vec<E::ScalarField> {
    utils::powers(
        E::ScalarField::from(1u64 << ell),
        num_chunks_per_scalar::<E::ScalarField>(ell) as usize,
    )
}
```

**File:** aptos-move/aptos-vm/src/validator_txns/mod.rs (L24-27)
```rust
        match txn {
            ValidatorTransaction::DKGResult(dkg_node) => {
                self.process_dkg_result(resolver, module_storage, log_context, session_id, dkg_node)
            },
```

**File:** aptos-move/aptos-vm/src/validator_txns/dkg.rs (L111-112)
```rust
        DefaultDKG::verify_transcript(&pub_params, &transcript)
            .map_err(|_| Expected(TranscriptVerificationFailed))?;
```

**File:** types/src/dkg/real_dkg/mod.rs (L368-374)
```rust
        trx.main.verify(
            &params.pvss_config.wconfig,
            &params.pvss_config.pp,
            &spks,
            &all_eks,
            &aux,
        )?;
```
