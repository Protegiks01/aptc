# Audit Report

## Title
ViewFunction API Error Code Enumeration Enables Systematic Module and Function Discovery

## Summary
The ViewFunction API exposes granular VM error codes that allow attackers to systematically enumerate deployed modules, functions, and their properties on any blockchain address without authentication or rate limiting.

## Finding Description

The Aptos ViewFunction API returns specific VM status codes in error responses that reveal different failure reasons: [1](#0-0) 

When a ViewFunction call fails, the system propagates distinct VM error codes through the execution stack: [2](#0-1) 

These error codes are then preserved and returned to the API caller: [3](#0-2) 

The Move VM uses specific status codes for different failure scenarios: [4](#0-3) 

An attacker can systematically probe any address and observe distinct error codes:
- **LINKER_ERROR (1081)**: Module doesn't exist at the address
- **FUNCTION_RESOLUTION_FAILURE (1091)**: Module exists but function doesn't exist
- **INVALID_MAIN_FUNCTION_SIGNATURE**: Function exists but isn't marked as a view function
- **NUMBER_OF_ARGUMENTS_MISMATCH (1098)**: Reveals parameter count
- **FAILED_TO_DESERIALIZE_ARGUMENT (1100)**: Reveals parameter type information

This creates an oracle that enables:
1. Enumeration of all deployed modules on any address
2. Discovery of all functions within those modules
3. Identification of which functions are view functions
4. Mapping of function signatures (parameter counts/types)
5. Inference of account state structure

## Impact Explanation

This issue qualifies as **Low Severity** per the Aptos bug bounty criteria:
- **Category**: Minor information leak
- **Bounty Range**: Up to $1,000
- **No direct impact** on funds, consensus, or network availability
- **Does not break** critical invariants (deterministic execution, consensus safety, etc.)

However, the impact is non-trivial because:
- Smart contract internals are exposed through automated enumeration
- Account state structures can be systematically mapped
- Private/internal module organization is revealed
- Aids vulnerability research and attack planning
- Requires zero authentication or privileges

## Likelihood Explanation

**Likelihood: Very High**
- Zero authentication required - public API endpoint
- No rate limiting on ViewFunction calls
- Trivial to automate with simple scripts
- Can be performed from any network location
- Requires no special knowledge or resources
- Observable through normal API usage

## Recommendation

Implement error normalization to prevent enumeration attacks:

1. **Return generic error messages** that don't distinguish between:
   - Module not found vs. Function not found
   - Function exists vs. Not a view function

2. **Sanitize vm_error_code field** in API responses for ViewFunction errors:
   ```rust
   // In convert_view_function_error:
   pub fn convert_view_function_error(
       error: &ViewFunctionError,
       state_view: &impl StateView,
       context: &Context,
   ) -> (String, Option<StatusCode>) {
       match error {
           ViewFunctionError::MoveAbort(status, vm_error_code) => {
               // Preserve abort info for legitimate debugging
               let vm_status = state_view
                   .as_converter(context.db.clone(), context.indexer_reader.clone())
                   .explain_vm_status(status, None);
               (vm_status, *vm_error_code)
           },
           ViewFunctionError::ErrorMessage(_, _) => {
               // Return generic error for all non-abort failures
               ("Invalid view function call".to_string(), None)
           },
       }
   }
   ```

3. **Implement rate limiting** on ViewFunction API endpoint to slow enumeration attempts

## Proof of Concept

```python
# Enumeration script demonstrating the vulnerability
import requests
import json

def enumerate_modules(address, candidate_modules):
    """Enumerate which modules exist at an address"""
    found_modules = []
    
    for module in candidate_modules:
        response = requests.post(
            "https://fullnode.mainnet.aptoslabs.com/v1/view",
            json={
                "function": f"{address}::{module}::dummy_function",
                "type_arguments": [],
                "arguments": []
            }
        )
        
        if response.status_code == 400:
            error_data = response.json()
            vm_code = error_data.get("vm_error_code")
            
            # LINKER_ERROR (1081) = module doesn't exist
            # FUNCTION_RESOLUTION_FAILURE (1091) = module exists
            if vm_code != 1081:
                found_modules.append(module)
                print(f"[+] Found module: {module}")
    
    return found_modules

def enumerate_functions(address, module, candidate_functions):
    """Enumerate which functions exist in a module"""
    found_functions = []
    
    for func in candidate_functions:
        response = requests.post(
            "https://fullnode.mainnet.aptoslabs.com/v1/view",
            json={
                "function": f"{address}::{module}::{func}",
                "type_arguments": [],
                "arguments": []
            }
        )
        
        if response.status_code == 400:
            error_data = response.json()
            vm_code = error_data.get("vm_error_code")
            
            # FUNCTION_RESOLUTION_FAILURE (1091) = function doesn't exist
            if vm_code != 1091:
                found_functions.append(func)
                print(f"[+] Found function: {func}")
    
    return found_functions

# Example: Enumerate modules on 0x1 (framework address)
target_address = "0x1"
common_modules = ["coin", "account", "aptos_account", "token"]
found = enumerate_modules(target_address, common_modules)
```

**Notes**

While this is a valid information disclosure vulnerability, it has several important caveats:

1. **Public Blockchain Context**: Smart contracts on Aptos are inherently public - the bytecode is visible on-chain, so module and function names are not truly secret. However, the distinct error codes make enumeration **trivial and automated** rather than requiring manual bytecode analysis.

2. **Severity Classification**: This issue is correctly classified as **Low Severity** in the security question itself. It does not threaten funds, consensus, state integrity, or any of the critical blockchain invariants.

3. **Standard Practice**: Many blockchain APIs return detailed error information for debugging purposes. However, security best practice suggests returning generic errors for probing attempts to avoid creating enumeration oracles.

4. **Mitigation Trade-offs**: Removing detailed error codes may impact developer experience and debugging capabilities, so any fix should balance security with usability.

### Citations

**File:** api/types/src/error.rs (L12-18)
```rust
pub struct AptosError {
    /// A message describing the error
    pub message: String,
    pub error_code: AptosErrorCode,
    /// A code providing VM error details when submitting transactions to the VM
    pub vm_error_code: Option<u64>,
}
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L2750-2773)
```rust
        dispatch_loader!(module_storage, loader, {
            let func = loader.load_instantiated_function(
                &LegacyLoaderConfig::unmetered(),
                gas_meter,
                traversal_context,
                &module_id,
                &func_name,
                &ty_args,
            )?;

            let metadata = get_metadata(&func.owner_as_module()?.metadata);

            let arguments = view_function::validate_view_function(
                session,
                &loader,
                gas_meter,
                traversal_context,
                arguments,
                func_name.as_ident_str(),
                &func,
                metadata.as_ref().map(Arc::as_ref),
                vm.features().is_enabled(FeatureFlag::STRUCT_CONSTRUCTORS),
            )
            .map_err(|e| e.finish(Location::Module(module_id)))?;
```

**File:** api/src/view_function.rs (L163-172)
```rust
    let values = output.values.map_err(|status| {
        let (err_string, vm_error_code) =
            convert_view_function_error(&status, &state_view, &context);
        BasicErrorWith404::bad_request_with_optional_vm_status_and_ledger_info(
            anyhow::anyhow!(err_string),
            AptosErrorCode::InvalidInput,
            vm_error_code,
            Some(&ledger_info),
        )
    })?;
```

**File:** third_party/move/move-core/types/src/vm_status.rs (L749-769)
```rust
    LINKER_ERROR = 1081,
    INVALID_CONSTANT_TYPE = 1082,
    MALFORMED_CONSTANT_DATA = 1083,
    EMPTY_CODE_UNIT = 1084,
    INVALID_LOOP_SPLIT = 1085,
    INVALID_LOOP_BREAK = 1086,
    INVALID_LOOP_CONTINUE = 1087,
    UNSAFE_RET_UNUSED_VALUES_WITHOUT_DROP = 1088,
    TOO_MANY_LOCALS = 1089,
    GENERIC_MEMBER_OPCODE_MISMATCH = 1090,
    FUNCTION_RESOLUTION_FAILURE = 1091,
    INVALID_OPERATION_IN_SCRIPT = 1094,
    // The sender is trying to publish two modules with the same name in one transaction
    DUPLICATE_MODULE_NAME = 1095,
    // The sender is trying to publish a module that breaks the compatibility checks
    BACKWARD_INCOMPATIBLE_MODULE_UPDATE = 1096,
    // The updated module introduces a cyclic dependency (i.e., A uses B and B also uses A)
    CYCLIC_MODULE_DEPENDENCY = 1097,
    NUMBER_OF_ARGUMENTS_MISMATCH = 1098,
    INVALID_PARAM_TYPE_FOR_DESERIALIZATION = 1099,
    FAILED_TO_DESERIALIZE_ARGUMENT = 1100,
```
