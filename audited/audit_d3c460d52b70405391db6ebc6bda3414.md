# Audit Report

## Title
Block Gas Limit Bypass via Zero Multipliers in ComplexLimitV1 Configuration

## Summary
The `BlockGasLimitType::ComplexLimitV1` configuration allows `execution_gas_effective_multiplier` and `io_gas_effective_multiplier` to be set to 0 without validation, which completely disables block gas limiting and breaks the "Resource Limits" invariant (Invariant #9). This can be exploited through a governance proposal to allow unbounded transaction throughput per block.

## Finding Description

The block gas limit calculation in `BlockGasLimitProcessor::accumulate_fee_statement()` uses the formula: [1](#0-0) 

When both multipliers are set to 0, `raw_gas_used` always equals 0, causing `accumulated_effective_block_gas` to remain 0 regardless of actual gas consumption. The block termination check then becomes: [2](#0-1) 

Since `0 >= per_block_gas_limit` is always false, blocks never terminate due to gas limits.

**Attack Path:**

1. A malicious or compromised governance proposal creates a `BlockGasLimitType::ComplexLimitV1` config with both multipliers set to 0: [3](#0-2) 

2. The proposal passes through `execution_config::set_for_next_epoch()`, which only validates that the config bytes are non-empty: [4](#0-3) 

3. At the next epoch, all validators apply the malicious config via `on_new_epoch()`: [5](#0-4) 

4. Block execution no longer enforces gas limits, allowing blocks to include far more transactions than intended (limited only by consensus transaction count limits of ~10,000 and optional 4MB output size limit).

**Invariant Violated:** Resource Limits (Invariant #9) - "All operations must respect gas, storage, and computational limits."

## Impact Explanation

**Severity: Critical** (up to $1,000,000)

This meets Critical severity criteria under "Consensus/Safety violations" and "Total loss of liveness/network availability":

1. **Validator Resource Exhaustion**: Blocks with 10,000 max-gas transactions would consume ~20-50x normal gas, overwhelming validators with limited resources and causing node crashes or severe slowdowns.

2. **Consensus Liveness Failure**: Under-resourced validators unable to execute massive blocks within timeout windows would fail to vote, potentially dropping validator participation below the 2/3 threshold required for consensus, causing total network halt.

3. **Chain State Bloat**: Sustained high-throughput blocks would cause rapid state growth (potentially 10-50x normal rate), making it prohibitively expensive for new validators to sync, leading to validator set centralization and network fragility.

4. **Deterministic Execution Break**: During the epoch transition, validators might process blocks differently based on their computational resources, potentially causing state divergence if some validators time out while others complete execution.

While consensus transaction limits (~10,000 per block) provide some bound, the default gas limit of 20,000 units would normally allow only ~200-400 transactions per block. A 25-50x increase in transactions per block constitutes a severe protocol violation.

## Likelihood Explanation

**Likelihood: Low-Medium**

This requires a governance proposal with 2/3 stake approval. However:

1. **Accidental Misconfiguration**: A typo or bug in proposal generation code could accidentally set multipliers to 0. The release builder generates proposals programmatically: [6](#0-5) 

2. **Compromised Governance**: If governance keys are compromised or colluding validators control 2/3 stake, this could be exploited maliciously.

3. **No Defense in Depth**: Complete lack of validation means a single error propagates directly to production without any safety net.

The default configuration shows sane values: [7](#0-6) 

But there's no enforcement of minimum multiplier values anywhere in the codebase.

## Recommendation

Add validation in multiple layers:

**Layer 1: Move Framework Validation**
```move
public fun set_for_next_epoch(account: &signer, config: vector<u8>) {
    system_addresses::assert_aptos_framework(account);
    assert!(vector::length(&config) > 0, error::invalid_argument(EINVALID_CONFIG));
    
    // Validate config contents
    let execution_config: ExecutionConfig = bcs::from_bytes(&config);
    validate_execution_config(&execution_config);
    
    config_buffer::upsert(ExecutionConfig { config });
}

fun validate_execution_config(config: &ExecutionConfig) {
    // Ensure gas multipliers are non-zero if ComplexLimitV1 is used
    // This requires exposing validation functions or doing basic checks on raw bytes
}
```

**Layer 2: Rust Deserialization Validation**

Add validation in `OnChainConfig::deserialize_into_config`:

```rust
fn deserialize_into_config(bytes: &[u8]) -> Result<Self> {
    let raw_bytes: Vec<u8> = bcs::from_bytes(bytes)?;
    let config: OnChainExecutionConfig = bcs::from_bytes(&raw_bytes)
        .map_err(|e| format_err!("[on-chain config] Failed to deserialize: {}", e))?;
    
    // Validate gas multipliers
    if let OnChainExecutionConfig::V4(v4) | OnChainExecutionConfig::V5(v5) 
        | OnChainExecutionConfig::V6(v6) | OnChainExecutionConfig::V7(v7) = &config {
        if let BlockGasLimitType::ComplexLimitV1 { 
            execution_gas_effective_multiplier,
            io_gas_effective_multiplier,
            ..
        } = &config.block_gas_limit_type() {
            ensure!(*execution_gas_effective_multiplier > 0, 
                "execution_gas_effective_multiplier must be positive");
            ensure!(*io_gas_effective_multiplier > 0,
                "io_gas_effective_multiplier must be positive");
        }
    }
    
    Ok(config)
}
```

**Layer 3: Runtime Assertion**

Add defensive check in `BlockGasLimitProcessor::new()`:

```rust
pub fn new(
    block_gas_limit_type: BlockGasLimitType,
    block_gas_limit_override: Option<u64>,
    init_size: usize,
) -> Self {
    // Validate multipliers are non-zero
    assert!(block_gas_limit_type.execution_gas_effective_multiplier() > 0,
        "execution_gas_effective_multiplier must be positive");
    assert!(block_gas_limit_type.io_gas_effective_multiplier() > 0,
        "io_gas_effective_multiplier must be positive");
    
    // ... rest of initialization
}
```

## Proof of Concept

```rust
#[cfg(test)]
mod test {
    use super::*;
    use crate::types::FeeStatement;
    
    #[test]
    #[should_panic(expected = "Gas limit should be reached")]
    fn test_zero_multipliers_bypass_gas_limit() {
        // Create config with zero multipliers
        let malicious_config = BlockGasLimitType::ComplexLimitV1 {
            effective_block_gas_limit: 100,  // Very low limit
            execution_gas_effective_multiplier: 0,  // ZERO - bypasses limit
            io_gas_effective_multiplier: 0,          // ZERO - bypasses limit
            conflict_penalty_window: 1,
            use_module_publishing_block_conflict: false,
            block_output_limit: None,
            include_user_txn_size_in_block_output: false,
            add_block_limit_outcome_onchain: false,
            use_granular_resource_group_conflicts: false,
        };
        
        let mut processor = BlockGasLimitProcessor::<MockTransaction>::new(
            malicious_config, 
            None, 
            10
        );
        
        // Consume 1000 units of gas (10x the limit)
        for _ in 0..10 {
            let fee_stmt = FeeStatement::new(100, 100, 0, 0, 0);
            processor.accumulate_fee_statement(fee_stmt, None, None);
        }
        
        // With zero multipliers, accumulated gas is 0, so limit never reached
        assert!(!processor.should_end_block_parallel(), 
            "Gas limit should be reached");
        
        // Verify accumulated gas is actually 0 due to zero multipliers
        assert_eq!(processor.accumulated_effective_block_gas, 0,
            "Accumulated gas should be 0 with zero multipliers");
    }
    
    #[test]
    fn test_normal_multipliers_respect_limit() {
        let normal_config = BlockGasLimitType::ComplexLimitV1 {
            effective_block_gas_limit: 100,
            execution_gas_effective_multiplier: 1,  // Normal value
            io_gas_effective_multiplier: 1,          // Normal value
            conflict_penalty_window: 1,
            use_module_publishing_block_conflict: false,
            block_output_limit: None,
            include_user_txn_size_in_block_output: false,
            add_block_limit_outcome_onchain: false,
            use_granular_resource_group_conflicts: false,
        };
        
        let mut processor = BlockGasLimitProcessor::<MockTransaction>::new(
            normal_config,
            None,
            10
        );
        
        // Consume 50 gas units
        processor.accumulate_fee_statement(
            FeeStatement::new(50, 50, 0, 0, 0),
            None,
            None
        );
        assert!(!processor.should_end_block_parallel());
        
        // Consume another 50 gas units (total 100)
        processor.accumulate_fee_statement(
            FeeStatement::new(50, 50, 0, 0, 0),
            None,
            None
        );
        
        // Should hit limit with normal multipliers
        assert!(processor.should_end_block_parallel(),
            "Block should end when gas limit reached");
    }
}
```

## Notes

This vulnerability exploits the **absence of input validation** at the governance configuration layer. While governance is a trusted component, defense-in-depth principles require sanity checks on critical parameters like gas multipliers to prevent both accidental misconfiguration and potential governance compromise. The lack of validation violates the "Resource Limits" invariant and could enable severe consensus disruption if exploited.

### Citations

**File:** aptos-move/block-executor/src/limit_processor.rs (L103-109)
```rust
        let raw_gas_used = fee_statement.execution_gas_used()
            * self
                .block_gas_limit_type
                .execution_gas_effective_multiplier()
            + fee_statement.io_gas_used() * self.block_gas_limit_type.io_gas_effective_multiplier();
        self.accumulated_raw_block_gas += raw_gas_used;
        self.accumulated_effective_block_gas += conflict_multiplier * raw_gas_used;
```

**File:** aptos-move/block-executor/src/limit_processor.rs (L131-140)
```rust
            let accumulated_block_gas = self.get_effective_accumulated_block_gas();
            if accumulated_block_gas >= per_block_gas_limit {
                counters::EXCEED_PER_BLOCK_GAS_LIMIT_COUNT.inc_with(&[mode]);
                info!(
                    "[BlockSTM]: execution ({}) early halted due to \
                    accumulated_block_gas {} >= PER_BLOCK_GAS_LIMIT {}",
                    mode, accumulated_block_gas, per_block_gas_limit,
                );
                return true;
            }
```

**File:** types/src/on_chain_config/execution_config.rs (L143-156)
```rust
    pub fn default_for_genesis() -> Self {
        BlockGasLimitType::ComplexLimitV1 {
            effective_block_gas_limit: 20000,
            execution_gas_effective_multiplier: 1,
            io_gas_effective_multiplier: 1,
            conflict_penalty_window: 9,
            use_granular_resource_group_conflicts: false,
            use_module_publishing_block_conflict: true,
            block_output_limit: Some(4 * 1024 * 1024),
            include_user_txn_size_in_block_output: true,
            add_block_limit_outcome_onchain: true,
        }
    }
}
```

**File:** types/src/on_chain_config/execution_config.rs (L280-312)
```rust
    ComplexLimitV1 {
        /// Formula for effective block gas limit:
        /// effective_block_gas_limit <
        /// (execution_gas_effective_multiplier * execution_gas_used +
        ///  io_gas_effective_multiplier * io_gas_used
        /// ) * (1 + num conflicts in conflict_penalty_window)
        effective_block_gas_limit: u64,
        execution_gas_effective_multiplier: u64,
        io_gas_effective_multiplier: u64,
        conflict_penalty_window: u32,

        /// If true we look at granular resource group conflicts (i.e. if same Tag
        /// within a resource group has a conflict)
        /// If false, we treat any conclicts inside of resource groups (even across
        /// non-overlapping tags) as conflicts).
        use_granular_resource_group_conflicts: bool,
        /// Module publishing today fallbacks to sequential execution,
        /// even though there is no read-write conflict.
        /// When enabled, this flag allows us to account for that conflict.
        /// NOTE: Currently not supported.
        use_module_publishing_block_conflict: bool,

        /// Block limit on the total (approximate) txn output size in bytes.
        block_output_limit: Option<u64>,
        /// When set, we include the user txn size in the approximate computation
        /// of block output size, which is compared against the block_output_limit above.
        include_user_txn_size_in_block_output: bool,

        /// When set, we create BlockEpilogue (instead of StateCheckpint) transaction,
        /// which contains BlockEndInfo
        /// NOTE: Currently not supported.
        add_block_limit_outcome_onchain: bool,
    },
```

**File:** aptos-move/framework/aptos-framework/sources/configs/execution_config.move (L48-52)
```text
    public fun set_for_next_epoch(account: &signer, config: vector<u8>) {
        system_addresses::assert_aptos_framework(account);
        assert!(vector::length(&config) > 0, error::invalid_argument(EINVALID_CONFIG));
        config_buffer::upsert(ExecutionConfig { config });
    }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/execution_config.move (L55-65)
```text
    public(friend) fun on_new_epoch(framework: &signer) acquires ExecutionConfig {
        system_addresses::assert_aptos_framework(framework);
        if (config_buffer::does_exist<ExecutionConfig>()) {
            let config = config_buffer::extract_v2<ExecutionConfig>();
            if (exists<ExecutionConfig>(@aptos_framework)) {
                *borrow_global_mut<ExecutionConfig>(@aptos_framework) = config;
            } else {
                move_to(framework, config);
            };
        }
    }
```

**File:** aptos-move/aptos-release-builder/src/components/execution_config.rs (L11-51)
```rust
pub fn generate_execution_config_upgrade_proposal(
    execution_config: &OnChainExecutionConfig,
    is_testnet: bool,
    next_execution_hash: Option<HashValue>,
    is_multi_step: bool,
) -> Result<Vec<(String, String)>> {
    let signer_arg = get_signer_arg(is_testnet, &next_execution_hash);
    let mut result = vec![];

    let writer = CodeWriter::new(Loc::default());

    emitln!(writer, "// Execution config upgrade proposal\n");
    let config_comment = format!("// config: {:#?}", execution_config).replace('\n', "\n// ");
    emitln!(writer, "{}\n", config_comment);

    let proposal = generate_governance_proposal(
        &writer,
        is_testnet,
        next_execution_hash,
        is_multi_step,
        &["aptos_framework::execution_config"],
        |writer| {
            let execution_config_blob = bcs::to_bytes(execution_config).unwrap();
            assert!(execution_config_blob.len() < 65536);

            emit!(writer, "let execution_blob: vector<u8> = ");
            generate_blob_as_hex_string(writer, &execution_config_blob);
            emitln!(writer, ";\n");

            emitln!(
                writer,
                "execution_config::set_for_next_epoch({}, execution_blob);",
                signer_arg
            );
            emitln!(writer, "aptos_governance::reconfigure({});", signer_arg);
        },
    );

    result.push(("execution-config".to_string(), proposal));
    Ok(result)
}
```
