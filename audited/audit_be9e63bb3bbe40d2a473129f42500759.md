# Audit Report

## Title
Database Resource Leak in `generate_waypoint()` - Temporary Directory Not Cleaned Up on Failure

## Summary
The `generate_waypoint()` function in `crates/aptos-genesis/src/lib.rs` creates a temporary directory for database operations but fails to ensure cleanup when the function fails or succeeds. The `TempPath` instance is prematurely dropped, leaving database files on disk indefinitely.

## Finding Description

The vulnerability lies in how `generate_waypoint()` handles the temporary database directory lifecycle. [1](#0-0) 

The function creates a `TempPath` at line 170 to store a temporary database, but then passes it **by value** to `StorageDirPaths::from_path(path)` at line 172. The `from_path` method takes ownership of the `TempPath`: [2](#0-1) 

This method only extracts the path string (line 586: `path.as_ref().to_path_buf()`) and then the `TempPath` is immediately dropped when `from_path` returns. The `TempPath::Drop` implementation attempts cleanup: [3](#0-2) 

However, since the directory doesn't exist yet when the `TempPath` is dropped (it's created later by `AptosDB::open`), the cleanup silently fails. The database files created by `AptosDB::open` are never cleaned up.

**Contrast with correct usage:** [4](#0-3) 

Here, the `TempPath` is kept alive alongside the database by returning both from the function.

**Same vulnerability exists in mainnet.rs:** [5](#0-4) 

## Impact Explanation

This issue falls under **Low Severity** per Aptos bug bounty criteria: "Non-critical implementation bugs". 

The impact is limited because:
1. **No consensus or safety impact**: This doesn't affect blockchain consensus, state consistency, or transaction processing
2. **No funds at risk**: No financial loss or manipulation possible
3. **Limited scope**: Only affects nodes during genesis/initialization phase
4. **Bounded damage**: Each call leaks several MB of RocksDB files, but genesis generation is infrequent

The disk space leak accumulates over repeated genesis generations but doesn't affect running validator operations or network security.

## Likelihood Explanation

**Likelihood: Medium** - The bug triggers every time `generate_waypoint()` is called:
- During testnet/devnet setup
- During validator node initialization with custom genesis
- During debugging and development

However, this is not exploitable by external attackers as genesis generation is a privileged operation performed by node operators.

## Recommendation

Fix: Keep the `TempPath` alive for the function's duration by storing it and passing a reference to `StorageDirPaths::from_path`:

```rust
pub fn generate_waypoint(&mut self) -> anyhow::Result<Waypoint> {
    let genesis = self.get_genesis();
    let path = TempPath::new();
    let aptosdb = AptosDB::open(
        StorageDirPaths::from_path(&path),  // Pass by reference
        /* readonly = */ false,
        NO_OP_STORAGE_PRUNER_CONFIG,
        RocksdbConfigs::default(),
        /* enable_indexer = */ false,
        BUFFERED_STATE_TARGET_ITEMS,
        DEFAULT_MAX_NUM_NODES_PER_LRU_CACHE_SHARD,
        /* internal_indexer_db = */ None,
        HotStateConfig::default(),
    )?;
    let db_rw = DbReaderWriter::new(aptosdb);
    let result = aptos_executor::db_bootstrapper::generate_waypoint::<AptosVMBlockExecutor>(&db_rw, genesis)?;
    // path is dropped here, cleaning up the directory
    Ok(result)
}
```

Apply the same fix to `crates/aptos-genesis/src/mainnet.rs` line 152-168.

## Proof of Concept

```rust
#[test]
fn test_waypoint_resource_leak() {
    use aptos_temppath::TempPath;
    use std::fs;
    
    // Simulate the buggy behavior
    let path = TempPath::new();
    let path_str = path.path().to_path_buf();
    
    // Pass by value - TempPath is dropped here
    let storage_paths = StorageDirPaths::from_path(path);
    
    // Create a file to simulate database
    fs::create_dir_all(&path_str).unwrap();
    fs::write(path_str.join("test.db"), b"data").unwrap();
    
    // End of function - file still exists!
    assert!(path_str.exists(), "Leaked directory still exists");
    
    // Manual cleanup needed
    fs::remove_dir_all(path_str).unwrap();
}
```

## Notes

While this is a genuine resource leak bug that should be fixed, it does not meet the severity threshold for Critical, High, or Medium impact per the Aptos bug bounty program. The leak only occurs during genesis generation (an infrequent privileged operation) and does not affect blockchain security, consensus, funds, or availability. The fix is straightforward but the security impact is minimal.

### Citations

**File:** crates/aptos-genesis/src/lib.rs (L168-184)
```rust
    pub fn generate_waypoint(&mut self) -> anyhow::Result<Waypoint> {
        let genesis = self.get_genesis();
        let path = TempPath::new();
        let aptosdb = AptosDB::open(
            StorageDirPaths::from_path(path),
            /* readonly = */ false,
            NO_OP_STORAGE_PRUNER_CONFIG,
            RocksdbConfigs::default(),
            /* enable_indexer = */ false,
            BUFFERED_STATE_TARGET_ITEMS,
            DEFAULT_MAX_NUM_NODES_PER_LRU_CACHE_SHARD,
            /* internal_indexer_db = */ None,
            HotStateConfig::default(),
        )?;
        let db_rw = DbReaderWriter::new(aptosdb);
        aptos_executor::db_bootstrapper::generate_waypoint::<AptosVMBlockExecutor>(&db_rw, genesis)
    }
```

**File:** config/src/config/storage_config.rs (L584-593)
```rust
    pub fn from_path<P: AsRef<Path>>(path: P) -> Self {
        Self {
            default_path: path.as_ref().to_path_buf(),
            ledger_db_path: None,
            state_kv_db_paths: Default::default(),
            state_merkle_db_paths: Default::default(),
            hot_state_kv_db_paths: Default::default(),
            hot_state_merkle_db_paths: Default::default(),
        }
    }
```

**File:** crates/aptos-temppath/src/lib.rs (L20-28)
```rust
impl Drop for TempPath {
    fn drop(&mut self) {
        if !self.persist {
            fs::remove_dir_all(&self.path_buf)
                .or_else(|_| fs::remove_file(&self.path_buf))
                .unwrap_or(());
        }
    }
}
```

**File:** storage/backup/backup-cli/src/utils/test_utils.rs (L19-24)
```rust
pub fn tmp_db_empty() -> (TempPath, Arc<AptosDB>) {
    let tmpdir = TempPath::new();
    let db = Arc::new(AptosDB::new_for_test(&tmpdir));

    (tmpdir, db)
}
```

**File:** crates/aptos-genesis/src/mainnet.rs (L152-168)
```rust
    pub fn generate_waypoint(&mut self) -> anyhow::Result<Waypoint> {
        let genesis = self.get_genesis();
        let path = TempPath::new();
        let aptosdb = AptosDB::open(
            StorageDirPaths::from_path(path),
            /* readonly = */ false,
            NO_OP_STORAGE_PRUNER_CONFIG,
            RocksdbConfigs::default(),
            /* enable_indexer = */ false,
            BUFFERED_STATE_TARGET_ITEMS,
            DEFAULT_MAX_NUM_NODES_PER_LRU_CACHE_SHARD,
            /* internal_indexer_db = */ None,
            HotStateConfig::default(),
        )?;
        let db_rw = DbReaderWriter::new(aptosdb);
        aptos_executor::db_bootstrapper::generate_waypoint::<AptosVMBlockExecutor>(&db_rw, genesis)
    }
```
