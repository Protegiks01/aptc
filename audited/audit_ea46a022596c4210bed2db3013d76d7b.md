# Audit Report

## Title
Critical Security Errors Silently Dropped During Parallel Execution Fallback

## Summary
When parallel transaction execution fails and falls back to sequential execution, all buffered speculative logs—including critical security errors from transaction prologue validation—are cleared without being dispatched. This allows critical invariant violations to go undetected and unalerted, bypassing the monitoring system designed to detect consensus bugs, state corruption, and other security vulnerabilities.

## Finding Description

The Aptos VM uses a speculative logging system to buffer log entries during parallel transaction execution. Critical errors (such as unexpected prologue aborts) are logged via `speculative_error!()` macro, which stores them in a buffer. These errors are only dispatched (and `CRITICAL_ERRORS` counter incremented) when the logs are flushed after successful execution. [1](#0-0) 

When a critical error occurs during speculative execution, it's buffered: [2](#0-1) 

The error should eventually be dispatched, triggering the critical alert: [3](#0-2) 

However, when parallel execution fails (e.g., due to a `CodeInvariantError` from any transaction in the block), the system falls back to sequential execution and **intentionally clears all speculative logs** without dispatching them: [4](#0-3) 

**Attack Scenario:**

1. Transaction A executes in parallel and triggers an unexpected prologue abort (e.g., invalid multisig validation) via: [5](#0-4) 

2. This critical error is buffered in speculative logs, waiting to be dispatched
3. Transaction B (anywhere in the same block) causes a `CodeInvariantError`, triggering parallel execution failure
4. All speculative logs are cleared (line 2587), losing Transaction A's critical error
5. Sequential execution re-processes the block—Transaction A may succeed or fail differently
6. **The original invariant violation is never logged and never increments `CRITICAL_ERRORS`**
7. Operators receive no alert about this security-critical event

The prologue validation is documented as critical: [6](#0-5) 

## Impact Explanation

This vulnerability meets **High Severity** criteria per the Aptos bug bounty program as it constitutes a "Significant protocol violation":

- **Hidden Invariant Violations**: Critical transaction validation errors (prologue/epilogue failures) represent invariant violations that should trigger immediate alerts. Silently dropping these logs allows security issues to go undetected.

- **Masked Security Vulnerabilities**: Unexpected prologue errors can indicate consensus bugs, state corruption, or attack attempts. Without logging, these issues remain invisible to operators and security monitoring systems.

- **Monitoring System Bypass**: The entire purpose of `CRITICAL_ERRORS` counter and `alert!()` macro is to provide real-time security monitoring. This bug completely bypasses that protection for any critical error occurring during failed parallel execution.

- **Consensus Impact**: Unexpected transaction validation errors can indicate deterministic execution failures that could lead to state divergence between validators if not properly investigated and resolved.

## Likelihood Explanation

**Likelihood: Medium to High**

- **Common Trigger**: Parallel execution fallback occurs during normal operation when resource conflicts or other issues prevent parallel completion. The `allow_fallback` configuration is typically enabled.

- **Attacker Control**: An attacker can craft transactions that:
  - Trigger unexpected prologue errors (e.g., edge cases in multisig validation, gas payer logic)
  - Potentially influence parallel execution failures through resource contention
  
- **No Special Privileges Required**: Any transaction sender can submit transactions that exercise edge cases in validation logic

- **Production Relevance**: The block executor runs in production with parallel execution enabled, making this a real operational concern

## Recommendation

**Immediate Fix**: Ensure critical errors logged during parallel execution are preserved and dispatched even when fallback occurs.

**Option 1 - Dispatch Before Clearing:**
Before re-initializing speculative logs during fallback, flush only the critical errors (Level::Error entries) synchronously:

```rust
// In executor.rs, before line 2587:
// Flush critical errors from parallel execution before clearing
if let Some(log_events) = BUFFERED_LOG_EVENTS.load().as_ref() {
    // Synchronously dispatch only Error-level entries
    for txn_idx in 0..signature_verified_block.num_txns() {
        if let Ok(events) = log_events.get_txn_events(txn_idx) {
            for event in events.iter().filter(|e| e.level == Level::Error) {
                event.clone().dispatch(); // Increments CRITICAL_ERRORS
            }
        }
    }
}
// Then clear as before
init_speculative_logs(signature_verified_block.num_txns() + 1);
```

**Option 2 - Use SpeculativeCounter (Recommended):**
Implement the TODO suggestion and use `SpeculativeCounter` to increment `CRITICAL_ERRORS` on the critical path instead of async dispatching: [7](#0-6) 

This ensures errors are counted immediately when they occur, regardless of whether speculative logs are later cleared.

## Proof of Concept

```rust
// Integration test demonstrating the vulnerability
#[test]
fn test_critical_errors_lost_on_parallel_fallback() {
    // Setup: Create a block with two transactions
    // Transaction 0: Triggers unexpected prologue abort (e.g., invalid multisig)
    // Transaction 1: Causes CodeInvariantError to trigger fallback
    
    let initial_critical_errors = CRITICAL_ERRORS.get();
    
    // Execute block with parallel execution enabled
    let result = executor.execute_block(
        &block,
        &state_view,
        &slice_metadata,
        &mut cache_guard,
    );
    
    // Verify parallel execution failed and fell back to sequential
    assert!(parallel_fallback_occurred);
    
    // BUG: Critical error from Transaction 0 was never logged
    let final_critical_errors = CRITICAL_ERRORS.get();
    
    // Expected: critical_errors increased by 1 (from unexpected prologue abort)
    // Actual: critical_errors unchanged (error was silently dropped)
    assert_eq!(
        final_critical_errors,
        initial_critical_errors,  // BUG: No increase!
        "Critical error from Transaction 0 was lost during fallback"
    );
}
```

## Notes

This vulnerability specifically affects the interaction between speculative logging and parallel execution fallback. The `SPECULATIVE_LOGGING_ERRORS` counter itself functions as documented (tracking infrastructure errors), but the broader system design allows critical security errors to be lost entirely when parallel execution requires fallback to sequential mode.

The issue is exacerbated because the comment explicitly states "All logs from the parallel execution should be cleared and not reported," suggesting this behavior is intentional but potentially not fully understood in terms of its security implications for critical error monitoring.

### Citations

**File:** aptos-move/aptos-vm-logging/src/lib.rs (L45-58)
```rust
impl SpeculativeEvent for VMLogEntry {
    fn dispatch(self) {
        match self.level {
            Level::Error => {
                // TODO: Consider using SpeculativeCounter to increase CRITICAL_ERRORS
                // on the critical path instead of async dispatching.
                alert!(self.context, "{}", self.message);
            },
            Level::Warn => warn!(self.context, "{}", self.message),
            Level::Info => info!(self.context, "{}", self.message),
            Level::Debug => debug!(self.context, "{}", self.message),
            Level::Trace => trace!(self.context, "{}", self.message),
        }
    }
```

**File:** aptos-move/aptos-vm-logging/src/lib.rs (L93-118)
```rust
pub fn speculative_log(level: Level, context: &AdapterLogSchema, message: String) {
    let txn_idx = context.get_txn_idx();

    if !context.speculation_supported() || speculation_disabled() {
        // Speculation isn't supported in the current mode, or disabled globally.
        // log the entry directly.
        let log_event = VMLogEntry::new(level, context.clone(), message);
        log_event.dispatch();
    } else {
        // Store in speculative log events.
        match &*BUFFERED_LOG_EVENTS.load() {
            Some(log_events) => {
                let log_event = VMLogEntry::new(level, context.clone(), message);
                if let Err(e) = log_events.record(txn_idx, log_event) {
                    speculative_alert!("{:?}", e);
                };
            },
            None => {
                speculative_alert!(
                    "Speculative state not initialized to log message = {}",
                    message
                );
            },
        };
    }
}
```

**File:** aptos-move/aptos-vm-logging/src/lib.rs (L180-186)
```rust
macro_rules! speculative_error {
    ($($args:tt)+) => {
        if enabled!(Level::Error) {
            speculative_log(Level::Error, $($args)+);
        }
    };
}
```

**File:** aptos-move/block-executor/src/executor.rs (L2585-2587)
```rust
            // All logs from the parallel execution should be cleared and not reported.
            // Clear by re-initializing the speculative logs.
            init_speculative_logs(signature_verified_block.num_txns() + 1);
```

**File:** aptos-move/aptos-vm/src/errors.rs (L12-16)
```rust
/// Error codes that can be emitted by the prologue. These have special significance to the VM when
/// they are raised during the prologue.
/// These errors are only expected from the module that is registered as the account module for the system.
/// The prologue should not emit any other error codes or fail for any reason, doing so will result
/// in the VM throwing an invariant violation
```

**File:** aptos-move/aptos-vm/src/errors.rs (L102-114)
```rust
                    let mut err_msg = format!(
                        "[aptos_vm] Unexpected prologue Move abort: {:?}::{:?} (Category: {:?} Reason: {:?})",
                        location, code, category, reason
                    );
                    if let Some(abort_msg) = message {
                        err_msg.push_str(" Message: ");
                        err_msg.push_str(&abort_msg);
                    }
                    speculative_error!(log_context, err_msg.clone());
                    return Err(VMStatus::error(
                        StatusCode::UNEXPECTED_ERROR_FROM_KNOWN_MOVE_FUNCTION,
                        Some(err_msg),
                    ));
```
