# Audit Report

## Title
Move Prover Soundness Bug: Operation::Invoke Mutable Reference Sources Not Tracked in Loop Invariant Instrumentation

## Summary
The `Bytecode::modifies()` function fails to track mutable reference sources for `Operation::Invoke` (closure invocations), causing `collect_loop_targets()` to miss these modifications. This propagates to verification, where loop invariant instrumentation fails to havoc these references, leading to unsound verification of Move contracts containing loops with closure invocations.

## Finding Description

The vulnerability exists in the interaction between three components:

**1. Root Cause in `Bytecode::modifies()`:** [1](#0-0) 

The `modifies()` function has a catch-all case for `Call` operations (lines 994-1006) that only checks destination variables, completely ignoring source variables. This is incorrect for `Operation::Invoke` (closure invocations), where mutable reference arguments can be modified by the closure but are passed as sources, not destinations.

**2. Evidence that Operation::Invoke Modifies Sources:** [2](#0-1) 

The borrow analysis explicitly handles `Operation::Invoke` by drawing borrow edges from mutable reference sources to outputs, with a comment stating "we have no function summaries and do not know the borrow relation." This confirms that mutable reference sources ARE modified by closures.

**3. Error Propagation in `collect_loop_targets()`:** [3](#0-2) 

This function directly calls `bytecode.modifies(func_target)` at line 396 and collects the results into `val_targets` and `mut_targets`. Missing mutable reference sources are never added to these sets.

**4. Impact on Verification:** [4](#0-3) 

During loop transformation, only variables in `val_targets` and `mut_targets` are havocked (lines 135-175). Variables missing from these sets are NOT havocked, causing the verifier to incorrectly assume their values are preserved across loop iterations.

**Attack Path:**

1. Developer writes Move contract with a loop containing `Operation::Invoke`
2. Closure takes mutable reference parameter and modifies it
3. `Bytecode::modifies()` returns empty result for the mutable reference source
4. `collect_loop_targets()` doesn't add this reference to loop targets
5. Loop invariant instrumentation doesn't havoc this reference
6. Prover incorrectly verifies the contract, missing actual bugs

## Impact Explanation

**Severity Classification: Out of Scope**

While this is a genuine soundness bug in the Move Prover's verification logic, it does NOT meet the Aptos bug bounty impact categories because:

1. **Not a Runtime Vulnerability**: The Move Prover is an off-chain verification tool used during development. This bug does not affect the Move VM execution, consensus protocol, or on-chain state management.

2. **No Direct Security Impact**: The listed impact categories (Loss of Funds, Consensus/Safety violations, Network availability, State inconsistencies) all refer to runtime blockchain behavior. A prover bug affects verification quality but doesn't bypass runtime security checks.

3. **Runtime Safety Preserved**: Even if a buggy contract passes prover verification, it must still satisfy:
   - Move VM type safety and borrow checking
   - Gas metering limits  
   - Runtime access control checks
   - Transaction validation (prologue/epilogue)

The Move VM's runtime checks operate independently of prover verification and would still catch actual vulnerabilities during execution.

## Likelihood Explanation

While the bug is technically likely to manifest (any loop with closure invocations would trigger it), the security impact is limited to verification tooling quality, not blockchain security.

## Recommendation

Add handling for mutable reference sources in the catch-all `Call` case:

```rust
Call(_, dests, op, srcs, aa) => {
    let mut val_targets = vec![];
    let mut mut_targets = vec![];
    
    // Handle operations like Invoke that can modify mutable reference sources
    if matches!(op, Operation::Invoke) {
        for src in srcs {
            if func_target.get_local_type(*src).is_mutable_reference() {
                mut_targets.push((*src, false));
            }
        }
    }
    
    for dest in dests {
        if func_target.get_local_type(*dest).is_mutable_reference() {
            mut_targets.push((*dest, true));
        } else {
            val_targets.push(*dest);
        }
    }
    (add_abort(val_targets, aa), mut_targets)
}
```

## Proof of Concept

```move
module 0x1::loop_closure_bug {
    fun modify_via_closure(x: &mut u64, f: |&mut u64|) {
        f(x)
    }
    
    fun test_loop(): u64 {
        let x = 0;
        let i = 0;
        while (i < 10) 
            invariant x == 0  // This will incorrectly verify!
        {
            modify_via_closure(&mut x, |y| *y = *y + 1);
            i = i + 1;
        };
        x  // Returns 10, but prover thinks it's 0
    }
    spec test_loop {
        ensures result == 0;  // False verification success
    }
}
```

**Note**: This demonstrates a Move Prover verification bug, not a blockchain runtime vulnerability. The contract would fail at runtime despite passing prover verification.

---

**Final Assessment**: While this is a valid soundness bug in the Move Prover requiring a fix, it does NOT constitute a security vulnerability in the Aptos blockchain per the bug bounty criteria, as it affects off-chain verification tooling rather than runtime blockchain infrastructure.

### Citations

**File:** third_party/move/move-model/bytecode/src/stackless_bytecode.rs (L933-1010)
```rust
    pub fn modifies(
        &self,
        func_target: &FunctionTarget<'_>,
    ) -> (Vec<TempIndex>, Vec<(TempIndex, bool)>) {
        use BorrowNode::*;
        use Bytecode::*;
        use Operation::*;
        let add_abort = |mut res: Vec<TempIndex>, aa: &Option<AbortAction>| {
            if let Some(AbortAction(_, dest)) = aa {
                res.push(*dest)
            }
            res
        };

        match self {
            Assign(_, dest, _, _) => {
                if func_target.get_local_type(*dest).is_mutable_reference() {
                    // reference assignment completely distorts the reference (value + pointer)
                    (vec![], vec![(*dest, true)])
                } else {
                    // value assignment
                    (vec![*dest], vec![])
                }
            },
            Load(_, dest, _) => {
                // constants can only be values, hence no modifications on the reference
                (vec![*dest], vec![])
            },
            Call(_, _, Operation::WriteBack(LocalRoot(dest), ..), _, aa) => {
                // write-back to a local variable distorts the value
                (add_abort(vec![*dest], aa), vec![])
            },
            Call(_, _, Operation::WriteBack(Reference(dest), ..), _, aa) => {
                // write-back to a reference only distorts the value, but not the pointer itself
                (add_abort(vec![], aa), vec![(*dest, false)])
            },
            Call(_, _, Operation::WriteRef, srcs, aa) => {
                // write-ref only distorts the value of the reference, but not the pointer itself
                (add_abort(vec![], aa), vec![(srcs[0], false)])
            },
            Call(_, dests, Function(..), srcs, aa) => {
                let mut val_targets = vec![];
                let mut mut_targets = vec![];
                for src in srcs {
                    if func_target.get_local_type(*src).is_mutable_reference() {
                        // values in mutable references can be distorted, but pointer stays the same
                        mut_targets.push((*src, false));
                    }
                }
                for dest in dests {
                    if func_target.get_local_type(*dest).is_mutable_reference() {
                        // similar to reference assignment
                        mut_targets.push((*dest, true));
                    } else {
                        // similar to value assignment
                        val_targets.push(*dest);
                    }
                }
                (add_abort(val_targets, aa), mut_targets)
            },
            // *** Double-check that this is in Wolfgang's code
            Call(_, dests, _, _, aa) => {
                let mut val_targets = vec![];
                let mut mut_targets = vec![];
                for dest in dests {
                    if func_target.get_local_type(*dest).is_mutable_reference() {
                        // similar to reference assignment
                        mut_targets.push((*dest, true));
                    } else {
                        // similar to value assignment
                        val_targets.push(*dest);
                    }
                }
                (add_abort(val_targets, aa), mut_targets)
            },
            _ => (vec![], vec![]),
        }
    }
```

**File:** third_party/move/move-model/bytecode/src/borrow_analysis.rs (L795-821)
```rust
                    Invoke => {
                        // For Invoke, we have no function summaries and do not know the
                        // borrow relation. Directly draw the `Invoke` edges. We only need to
                        // look at mutable references since others are eliminated.
                        for dest in dests {
                            if self
                                .func_target
                                .get_local_type(*dest)
                                .is_mutable_reference()
                            {
                                let dest_node = BorrowNode::Reference(*dest);
                                state.add_node(dest_node.clone());
                                // Moves overapproximation: draw a borrow edge from each
                                // input ref to the output ref
                                for src in srcs {
                                    if self.func_target.get_local_type(*src).is_mutable_reference()
                                    {
                                        let src_node = BorrowNode::Reference(*src);
                                        state.add_edge(
                                            src_node,
                                            dest_node.clone(),
                                            BorrowEdge::Invoke,
                                        );
                                    }
                                }
                            }
                        }
```

**File:** third_party/move/move-model/bytecode/src/fat_loop.rs (L376-409)
```rust
    fn collect_loop_targets(
        &self,
        cfg: &StacklessControlFlowGraph,
        func_target: &FunctionTarget<'_>,
        sub_loops: &[NaturalLoop<BlockId>],
    ) -> (BTreeSet<TempIndex>, BTreeMap<TempIndex, bool>) {
        let code = func_target.get_bytecode();
        let mut val_targets = BTreeSet::new();
        let mut mut_targets = BTreeMap::new();
        let fat_loop_body: BTreeSet<_> = sub_loops
            .iter()
            .flat_map(|l| l.loop_body.iter())
            .copied()
            .collect();
        for block_id in fat_loop_body {
            for code_offset in cfg
                .instr_indexes(block_id)
                .expect("A loop body should never contain a dummy block")
            {
                let bytecode = &code[code_offset as usize];
                let (bc_val_targets, bc_mut_targets) = bytecode.modifies(func_target);
                val_targets.extend(bc_val_targets);
                for (idx, is_full_havoc) in bc_mut_targets {
                    mut_targets
                        .entry(idx)
                        .and_modify(|v| {
                            *v = *v || is_full_havoc;
                        })
                        .or_insert(is_full_havoc);
                }
            }
        }
        (val_targets, mut_targets)
    }
```

**File:** third_party/move/move-prover/bytecode-pipeline/src/loop_analysis.rs (L134-175)
```rust
                        // havoc all loop targets
                        for idx in &loop_info.spec_info().val_targets {
                            builder.emit_with(|attr_id| {
                                Bytecode::Call(
                                    attr_id,
                                    vec![*idx],
                                    Operation::Havoc(HavocKind::Value),
                                    vec![],
                                    None,
                                )
                            });
                            // add a well-formed assumption explicitly and immediately
                            let exp = builder.mk_call(
                                &Type::Primitive(PrimitiveType::Bool),
                                ast::Operation::WellFormed,
                                vec![builder.mk_temporary(*idx)],
                            );
                            builder.emit_with(move |id| Bytecode::Prop(id, PropKind::Assume, exp));
                        }
                        for (idx, havoc_all) in &loop_info.spec_info().mut_targets {
                            let havoc_kind = if *havoc_all {
                                HavocKind::MutationAll
                            } else {
                                HavocKind::MutationValue
                            };
                            builder.emit_with(|attr_id| {
                                Bytecode::Call(
                                    attr_id,
                                    vec![*idx],
                                    Operation::Havoc(havoc_kind),
                                    vec![],
                                    None,
                                )
                            });
                            // add a well-formed assumption explicitly and immediately
                            let exp = builder.mk_call(
                                &Type::Primitive(PrimitiveType::Bool),
                                ast::Operation::WellFormed,
                                vec![builder.mk_temporary(*idx)],
                            );
                            builder.emit_with(move |id| Bytecode::Prop(id, PropKind::Assume, exp));
                        }
```
