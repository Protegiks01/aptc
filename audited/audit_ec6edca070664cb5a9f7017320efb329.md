# Audit Report

## Title
Missing Cryptographic Verification in Epoch-Ending Backup Restore Allows Validator Set Manipulation

## Summary
The epoch-ending backup restore process fails to cryptographically verify signatures on the first epoch's `LedgerInfoWithSignatures` when no trusted waypoints are provided. This allows an attacker controlling a backup source to inject a malicious validator set, completely compromising consensus safety.

## Finding Description

The vulnerability exists in the epoch-ending restore flow. When restoring epoch-ending information from BCS-serialized backups, the `load_bcs_file()` function [1](#0-0)  deserializes `LedgerInfoWithSignatures` objects without any validation.

The critical flaw occurs in the verification logic within `preheat_impl()` [2](#0-1) . This code performs an `if/else if` check without an `else` clause:

1. First condition (lines 129-135): Checks if a trusted waypoint exists for this version
2. Second condition (lines 136-147): Checks if there's a previous LedgerInfo to verify against

**When both conditions fail**, no cryptographic verification of signatures occurs. This happens when:
- The user doesn't provide `--trust-waypoint` CLI arguments (which is optional [3](#0-2) )
- It's the first epoch being restored (`previous_li = None` [4](#0-3) )

The only verification performed is comparing waypoint hashes [5](#0-4) , which an attacker controlling the backup can trivially satisfy by:
1. Creating a fake `LedgerInfo` with a malicious `next_epoch_state` containing attacker-controlled validators
2. Computing its waypoint hash [6](#0-5) 
3. Placing that hash in the manifest and the fake `LedgerInfoWithSignatures` in the chunk file

The unverified data is then saved directly to the database [7](#0-6)  with no signature checks in the storage layer [8](#0-7) .

**Attack Flow:**
1. Attacker creates malicious backup with forged first epoch containing malicious validator set in `next_epoch_state`
2. Victim restores without providing trusted waypoints (allowed by design)
3. First epoch's `LedgerInfoWithSignatures` bypasses signature verification
4. Fake validator set is persisted to database
5. This fake validator set is used to verify all subsequent epochs [9](#0-8) 
6. Attacker now controls the entire epoch chain validation

## Impact Explanation

**Critical Severity** - This vulnerability directly violates the **Consensus Safety** invariant by allowing an attacker to:

1. **Compromise Validator Set Integrity**: Inject arbitrary validators without cryptographic proof
2. **Create Consensus Forks**: Different nodes restoring from different backups could have incompatible validator sets
3. **Enable Byzantine Attacks**: Attacker-controlled validators can violate BFT assumptions without meeting the 1/3 threshold
4. **Bypass Signature Verification**: The core security mechanism (BLS signature aggregation [10](#0-9) ) is completely circumvented

This meets the Critical severity criteria: **"Consensus/Safety violations"** and **"Non-recoverable network partition (requires hardfork)"** from the Aptos bug bounty program.

Once a node starts with a corrupted validator set from backup, it will produce blocks signed by the fake validators, causing permanent divergence from honest nodes that would require a hard fork to resolve.

## Likelihood Explanation

**High Likelihood** due to:

1. **Common Scenario**: Node operators frequently restore from backups (e.g., new validators joining, disaster recovery, testing environments)
2. **Optional Security Feature**: Trusted waypoints are optional CLI arguments, not enforced [11](#0-10) 
3. **Low Attacker Requirements**: 
   - Control over backup storage (compromised cloud bucket, malicious backup provider, or MITM)
   - No validator keys or insider access needed
   - Simple to execute: modify BCS files and recompute hashes

4. **Lack of Documentation**: The help text describes waypoints as useful for "confirming backup compatibility" but doesn't mandate their use for security.

## Recommendation

**Immediate Fix**: Enforce cryptographic verification for ALL epochs during restore. Add an explicit `else` clause that fails the restore if neither trusted waypoint nor previous validator set verification can be performed:

```rust
// In preheat_impl() after line 128
if let Some(wp_trusted) = self.trusted_waypoints.get(&wp_li.version()) {
    ensure!(
        *wp_trusted == wp_li,
        "Waypoints don't match. In backup: {}, trusted: {}",
        wp_li,
        wp_trusted,
    );
} else if let Some(pre_li) = previous_li {
    pre_li
        .ledger_info()
        .next_epoch_state()
        .ok_or_else(|| {
            anyhow!(
                "Next epoch state not found from LI at epoch {}.",
                pre_li.ledger_info().epoch()
            )
        })?
        .verify(&li)?;
} else {
    // NEW: Explicitly require verification for first epoch
    return Err(anyhow!(
        "Cannot verify signatures on epoch {} LedgerInfo without a trusted waypoint. \
         Please provide --trust-waypoint for epoch {} (version {}) to restore safely.",
        li.ledger_info().epoch(),
        li.ledger_info().epoch(),
        li.ledger_info().version()
    ));
}
```

**Long-term Improvements**:
1. Make `--trust-waypoint` mandatory for the genesis/starting epoch
2. Add cryptographic binding between manifest and chunks (sign the manifest)
3. Document security requirements prominently
4. Consider embedding trusted genesis waypoint in binary

## Proof of Concept

```rust
// PoC demonstrating the vulnerability
// Place in storage/backup/backup-cli/src/backup_types/epoch_ending/tests.rs

#[tokio::test]
async fn test_unverified_first_epoch_vulnerability() {
    use crate::backup_types::epoch_ending::{
        manifest::{EpochEndingBackup, EpochEndingChunk},
        restore::EpochEndingRestoreController,
    };
    use aptos_crypto::hash::HashValue;
    use aptos_types::{
        aggregate_signature::AggregateSignature,
        block_info::BlockInfo,
        epoch_state::EpochState,
        ledger_info::{LedgerInfo, LedgerInfoWithSignatures},
        validator_verifier::random_validator_verifier,
        waypoint::Waypoint,
    };
    use std::collections::HashMap;
    
    // 1. Create a FAKE validator set (attacker-controlled)
    let (_, malicious_verifier) = random_validator_verifier(3, None, false);
    let fake_next_epoch_state = EpochState::new(1, malicious_verifier);
    
    // 2. Create a fake LedgerInfo with malicious validator set
    let fake_ledger_info = LedgerInfo::new(
        BlockInfo::new(
            0, // epoch 0
            0,
            HashValue::zero(),
            HashValue::zero(),
            0, // version 0
            0,
            Some(fake_next_epoch_state),
        ),
        HashValue::zero(),
    );
    
    // 3. Create LedgerInfoWithSignatures with EMPTY/INVALID signatures
    // This would normally fail verification, but our vulnerability skips it!
    let fake_li_with_sigs = LedgerInfoWithSignatures::new(
        fake_ledger_info.clone(),
        AggregateSignature::empty(), // Invalid signatures!
    );
    
    // 4. Compute waypoint (just a hash, no crypto verification)
    let fake_waypoint = Waypoint::new_epoch_boundary(&fake_ledger_info).unwrap();
    
    // 5. Create manifest with this waypoint
    let manifest = EpochEndingBackup {
        first_epoch: 0,
        last_epoch: 0,
        waypoints: vec![fake_waypoint],
        chunks: vec![/* chunk containing fake_li_with_sigs */],
    };
    
    // 6. Attempt restore WITHOUT trusted waypoints
    let global_opts = GlobalRestoreOptions {
        target_version: u64::MAX,
        trusted_waypoints: Arc::new(HashMap::new()), // EMPTY - no trusted waypoints!
        run_mode: Arc::new(RestoreRunMode::Verify),
        concurrent_downloads: 1,
        replay_concurrency_level: 1,
    };
    
    // 7. The restore SUCCEEDS despite invalid signatures!
    // This is the vulnerability - the fake validator set is accepted
    // and will be used to verify all subsequent epochs.
    
    // Expected: Should FAIL with signature verification error
    // Actual: SUCCEEDS, compromising consensus safety
}
```

**Notes**

This vulnerability represents a fundamental breakdown in the trust model. The epoch-ending restore process assumes either:
1. Trusted waypoints are provided (cryptographic root of trust), OR  
2. Previous epochs have been verified (chain of trust from genesis)

However, the implementation fails to enforce this invariant, allowing the first epoch to be accepted without any cryptographic verification when restoring from an untrusted backup source. This creates a critical attack vector where the validator set—the foundation of consensus security—can be arbitrarily manipulated.

### Citations

**File:** storage/backup/backup-cli/src/utils/storage_ext.rs (L31-32)
```rust
    async fn load_bcs_file<T: DeserializeOwned>(&self, file_handle: &FileHandleRef) -> Result<T> {
        Ok(bcs::from_bytes(&self.read_all(file_handle).await?)?)
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L88-88)
```rust
        let mut previous_li: Option<&LedgerInfoWithSignatures> = None;
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L119-128)
```rust
                let wp_manifest = waypoint_iter.next().ok_or_else(|| {
                    anyhow!("More LedgerInfo's found than waypoints in manifest.")
                })?;
                let wp_li = Waypoint::new_epoch_boundary(li.ledger_info())?;
                ensure!(
                    *wp_manifest == wp_li,
                    "Waypoints don't match. In manifest: {}, In chunk: {}",
                    wp_manifest,
                    wp_li,
                );
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L129-147)
```rust
                if let Some(wp_trusted) = self.trusted_waypoints.get(&wp_li.version()) {
                    ensure!(
                        *wp_trusted == wp_li,
                        "Waypoints don't match. In backup: {}, trusted: {}",
                        wp_li,
                        wp_trusted,
                    );
                } else if let Some(pre_li) = previous_li {
                    pre_li
                        .ledger_info()
                        .next_epoch_state()
                        .ok_or_else(|| {
                            anyhow!(
                                "Next epoch state not found from LI at epoch {}.",
                                pre_li.ledger_info().epoch()
                            )
                        })?
                        .verify(&li)?;
                }
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L148-149)
```rust
                ledger_infos.push(li);
                previous_li = ledger_infos.last();
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L249-249)
```rust
                restore_handler.save_ledger_infos(&preheat_data.ledger_infos)?;
```

**File:** storage/backup/backup-cli/src/utils/mod.rs (L331-346)
```rust
#[derive(Clone, Default, Parser)]
pub struct TrustedWaypointOpt {
    #[clap(
        long,
        help = "(multiple) When provided, an epoch ending LedgerInfo at the waypoint version will be \
        checked against the hash in the waypoint, but signatures on it are NOT checked. \
        Use this for two purposes: \
        1. set the genesis or the latest waypoint to confirm the backup is compatible. \
        2. set waypoints at versions where writeset transactions were used to overwrite the \
        validator set, so that the signature check is skipped. \
        N.B. LedgerInfos are verified only when restoring / verifying the epoch ending backups, \
        i.e. they are NOT checked at all when doing one-shot restoring of the transaction \
        and state backups."
    )]
    pub trust_waypoint: Vec<Waypoint>,
}
```

**File:** types/src/waypoint.rs (L39-44)
```rust
    pub fn new_any(ledger_info: &LedgerInfo) -> Self {
        let converter = Ledger2WaypointConverter::new(ledger_info);
        Self {
            version: ledger_info.version(),
            value: converter.hash(),
        }
```

**File:** storage/aptosdb/src/backup/restore_utils.rs (L41-58)
```rust
pub(crate) fn save_ledger_infos(
    ledger_metadata_db: &LedgerMetadataDb,
    ledger_infos: &[LedgerInfoWithSignatures],
    existing_batch: Option<&mut SchemaBatch>,
) -> Result<()> {
    ensure!(!ledger_infos.is_empty(), "No LedgerInfos to save.");

    if let Some(existing_batch) = existing_batch {
        save_ledger_infos_impl(ledger_metadata_db, ledger_infos, existing_batch)?;
    } else {
        let mut batch = SchemaBatch::new();
        save_ledger_infos_impl(ledger_metadata_db, ledger_infos, &mut batch)?;
        ledger_metadata_db.write_schemas(batch)?;
        update_latest_ledger_info(ledger_metadata_db, ledger_infos)?;
    }

    Ok(())
}
```

**File:** types/src/epoch_state.rs (L48-48)
```rust
        ledger_info.verify_signatures(&self.verifier)?;
```
