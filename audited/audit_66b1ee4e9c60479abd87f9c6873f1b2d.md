# Audit Report

## Title
Script Type Parameter Count Mismatch Causes Verifier Panic via Undersized Bitset Allocation

## Summary
When `sig_checker_v2_fix_script_ty_param_count` is disabled, an attacker can craft a malicious script with more declared type parameters than are referenced in signatures, causing the Move bytecode verifier to panic due to an assertion failure in `BitsetTypeParameterConstraints::insert()`.

## Finding Description

The vulnerability exists in the interaction between bitset size calculation and type parameter constraint validation in the signature checker v2 implementation. [1](#0-0) 

The `verify_script` function calculates `max_num` by scanning all type parameter indices referenced in signatures. Without the `sig_checker_v2_fix_script_ty_param_count` flag enabled, it does NOT account for `script.type_parameters.len()`: [2](#0-1) 

The `max_num_of_ty_params_or_args` function finds the maximum type parameter INDEX used (e.g., if `TypeParameter(5)` is the highest, `max_num = 6`): [3](#0-2) 

Based on this potentially undersized `max_num`, the wrong const generic parameter `N` is chosen for `BitsetTypeParameterConstraints<N>` (e.g., `N=1` supports only 16 type parameters): [4](#0-3) 

Later, when verifying the script, the code attempts to create a bitset from ALL declared script type parameters: [5](#0-4) 

The `BitsetTypeParameterConstraints::from` implementation iterates through all type parameters and calls `insert()`: [6](#0-5) 

The `insert()` method contains an assertion that panics if the type parameter index exceeds the bitset capacity: [7](#0-6) 

**Attack Scenario:**
1. Attacker crafts a script declaring 17 type parameters: `script.type_parameters = [Copy, Drop, Store, ...] // length 17`
2. Script signatures reference only `TypeParameter(0)` or no type parameters at all
3. `max_num` is calculated as 1 (to handle index 0) or 0 (no references)
4. `N=1` is chosen since `max_num <= 16`, giving capacity for only 16 type parameters (`1 * 16 = 16`)
5. `BitsetTypeParameterConstraints::from(script.type_parameters)` attempts to insert indices 0-16
6. When inserting index 16, the assertion `assert!(16 < 16)` fails
7. Verifier panics with message: "Type parameter index out of bounds. The current Bitset implementation is only configured to handle 16 type parameters at max."

The `BoundsChecker` does not prevent this attack because it only validates that type parameter indices USED in signatures are within bounds, not that the total declared count is reasonable: [8](#0-7) 

## Impact Explanation

This is a **High Severity** vulnerability per the Aptos bug bounty program:

- **Validator Node Crashes**: The panic crashes the verifier process when processing the malicious script transaction
- **Network Liveness Issues**: If multiple validator nodes attempt to verify the malicious script, widespread crashes could occur
- **Consensus Disruption**: Different handling of panics across validator implementations could lead to consensus splits where some nodes successfully reject the transaction while others crash
- **Denial of Service**: An attacker can submit such transactions repeatedly to keep validators in a crash loop

While the default configuration has `sig_checker_v2_fix_script_ty_param_count = true` (protecting against this), the vulnerability exists in any deployment using:
- Legacy configurations
- Test environments with the flag disabled
- Custom verifier configurations [9](#0-8) 

## Likelihood Explanation

**Likelihood: Medium**

The attack is straightforward to execute:
- No special privileges required (any transaction sender can submit scripts)
- Malicious script is trivial to construct
- No timing or race condition dependencies
- Attack succeeds deterministically if the flag is disabled

However, mitigation factors include:
- Default production config has the fix enabled
- The fix flag exists specifically to address this issue
- Would require intentional misconfiguration or use of legacy settings

## Recommendation

**Mandatory Fix:** Always enable `sig_checker_v2_fix_script_ty_param_count` in all verifier configurations. The flag should be deprecated and the fix should be made unconditional.

**Code Fix:**

In `verify_script` function (signature_v2.rs), make the script type parameter count check unconditional:

```rust
pub fn verify_script(config: &VerifierConfig, script: &CompiledScript) -> VMResult<()> {
    let mut max_num = max_num_of_ty_params_or_args(BinaryIndexedView::Script(script));
    // ALWAYS include script type parameter count, do not gate behind flag
    max_num = max_num.max(script.type_parameters.len());
    
    // ... rest of function
}
```

**Additional Hardening:** Add an explicit limit check in `BoundsChecker::verify_script` to reject scripts with unreasonably large `type_parameters.len()` values (e.g., > 256).

## Proof of Concept

```rust
#[test]
#[should_panic(expected = "Type parameter index out of bounds")]
fn test_script_type_param_count_vulnerability() {
    use move_binary_format::file_format::*;
    use move_bytecode_verifier::{verify_script_with_config, VerifierConfig};
    use move_core_types::ability::AbilitySet;
    
    // Create a malicious script with 17 type parameters declared
    let mut script = move_binary_format::file_format::empty_script();
    
    // Declare 17 type parameters (exceeds N=1 capacity of 16)
    script.type_parameters = vec![AbilitySet::EMPTY; 17];
    
    // Signature uses no type parameters (or only low indices)
    script.parameters = SignatureIndex(0);
    script.signatures = vec![Signature(vec![])];
    
    // Configure verifier with the fix flag DISABLED
    let mut config = VerifierConfig::default();
    config.sig_checker_v2_fix_script_ty_param_count = false;
    
    // This will panic when trying to insert index 16 into BitsetTypeParameterConstraints<1>
    // which only supports indices 0-15
    verify_script_with_config(&config, &script).unwrap();
}
```

**Expected Behavior:** The test panics with assertion failure when `BitsetTypeParameterConstraints::insert()` tries to insert type parameter index 16 into a bitset sized for only 16 parameters (indices 0-15).

**Notes**

The existence of the `sig_checker_v2_fix_script_ty_param_count` flag in the codebase indicates this was a known issue that was patched. The flag serves as a feature gate to enable the fix while maintaining backward compatibility. However, any configuration with this flag disabled remains vulnerable to this attack vector.

The vulnerability demonstrates a classic bounds checking failure where the size of a data structure (BitsetTypeParameterConstraints) is calculated based on usage (max type parameter index found) rather than capacity requirements (total type parameters declared), leading to an exploitable assertion failure.

### Citations

**File:** third_party/move/move-bytecode-verifier/src/signature_v2.rs (L49-57)
```rust
impl<'a, const N: usize> From<&'a [AbilitySet]> for BitsetTypeParameterConstraints<N> {
    fn from(abilities: &'a [AbilitySet]) -> Self {
        abilities
            .iter()
            .enumerate()
            .map(|(idx, abilities)| (idx as TypeParameterIndex, *abilities))
            .collect()
    }
}
```

**File:** third_party/move/move-bytecode-verifier/src/signature_v2.rs (L70-77)
```rust
    fn insert(&mut self, ty_param_idx: TypeParameterIndex, required_abilities: AbilitySet) {
        assert!(
            (ty_param_idx as usize) < N * NUM_PARAMS_PER_WORD,
            "Type parameter index out of bounds. \
             The current Bitset implementation is only configured to handle \
             {} type parameters at max.",
            N * NUM_PARAMS_PER_WORD
        );
```

**File:** third_party/move/move-bytecode-verifier/src/signature_v2.rs (L1190-1195)
```rust
    checker.verify_signature_in_context(
        &BitsetTypeParameterConstraints::from(script.type_parameters.as_slice()),
        script.parameters,
        // Script parameters can be signer references.
        true,
    )?;
```

**File:** third_party/move/move-bytecode-verifier/src/signature_v2.rs (L1201-1251)
```rust
fn max_num_of_ty_params_or_args(resolver: BinaryIndexedView) -> usize {
    let mut n = 0;

    for fh in resolver.function_handles() {
        n = n.max(fh.type_parameters.len())
    }

    for sh in resolver.struct_handles() {
        n = n.max(sh.type_parameters.len())
    }

    for sig in resolver.signatures() {
        for ty in &sig.0 {
            for ty in ty.preorder_traversal() {
                if let SignatureToken::TypeParameter(ty_param_idx) = ty {
                    n = n.max(*ty_param_idx as usize + 1)
                }
            }
        }
    }

    if let Some(struct_defs) = resolver.struct_defs() {
        for struct_def in struct_defs {
            match &struct_def.field_information {
                StructFieldInformation::Native => {},
                StructFieldInformation::Declared(fields) => {
                    for field in fields {
                        for ty in field.signature.0.preorder_traversal() {
                            if let SignatureToken::TypeParameter(ty_param_idx) = ty {
                                n = n.max(*ty_param_idx as usize + 1)
                            }
                        }
                    }
                },
                StructFieldInformation::DeclaredVariants(variants) => {
                    for variant in variants {
                        for field in &variant.fields {
                            for ty in field.signature.0.preorder_traversal() {
                                if let SignatureToken::TypeParameter(ty_param_idx) = ty {
                                    n = n.max(*ty_param_idx as usize + 1)
                                }
                            }
                        }
                    }
                },
            }
        }
    }

    n
}
```

**File:** third_party/move/move-bytecode-verifier/src/signature_v2.rs (L1273-1291)
```rust
pub fn verify_script(config: &VerifierConfig, script: &CompiledScript) -> VMResult<()> {
    let mut max_num = max_num_of_ty_params_or_args(BinaryIndexedView::Script(script));
    if config.sig_checker_v2_fix_script_ty_param_count {
        max_num = max_num.max(script.type_parameters.len());
    }

    let res = if max_num <= NUM_PARAMS_PER_WORD {
        verify_script_impl::<1>(config, script)
    } else if max_num <= NUM_PARAMS_PER_WORD * 2 {
        verify_script_impl::<2>(config, script)
    } else if max_num <= NUM_PARAMS_PER_WORD * 16 {
        verify_script_impl::<16>(config, script)
    } else {
        return Err(
            PartialVMError::new(StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR)
                .with_message("too many type parameters/arguments in the program".to_string())
                .finish(Location::Undefined),
        );
    };
```

**File:** third_party/move/move-binary-format/src/check_bounds.rs (L43-69)
```rust
    pub fn verify_script(script: &'a CompiledScript) -> PartialVMResult<()> {
        let mut bounds_check = Self {
            view: BinaryIndexedView::Script(script),
            context: BoundsCheckingContext::Script,

            max_ty_param_ids: RefCell::new(BTreeMap::new()),
        };
        bounds_check.verify_impl()?;

        let type_param_count = script.type_parameters.len();

        check_bounds_impl(bounds_check.view.signatures(), script.parameters)?;
        bounds_check.check_type_parameters_in_signature(script.parameters, type_param_count)?;

        // The bounds checker has already checked each function definition's code, but a
        // script's code exists outside of any function definition. It gets checked here.
        bounds_check.check_code(
            &script.code,
            &script.type_parameters,
            bounds_check
                .view
                .signatures()
                .get(script.parameters.into_index())
                .unwrap(),
            CompiledScript::MAIN_INDEX.into_index(),
        )
    }
```

**File:** third_party/move/move-bytecode-verifier/src/verifier.rs (L260-263)
```rust
            _use_signature_checker_v2: true,

            sig_checker_v2_fix_script_ty_param_count: true,
            sig_checker_v2_fix_function_signatures: true,
```
