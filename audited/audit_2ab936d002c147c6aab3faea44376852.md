# Audit Report

## Title
Rate Limit Bypass via TAP_EPOCH_SECS Constant Change in Redis Faucet Rate Limiter

## Summary
The Aptos faucet's Redis-based rate limiter uses a hardcoded constant `TAP_EPOCH_SECS` to calculate daily rate limit keys. Changing this constant invalidates all existing Redis rate limit keys, allowing users who have exhausted their limits to immediately bypass restrictions and drain the faucet. This represents a complete failure of the rate limiting security control.

## Finding Description

The Aptos faucet implements rate limiting using Redis counters to track daily request limits per IP address or Firebase JWT. The rate limit enforcement relies on Redis keys that incorporate a "days since epoch" calculation.

The vulnerable constant is defined as: [1](#0-0) 

This constant is used to calculate the number of days since the epoch: [2](#0-1) 

The Redis rate limiter generates keys by concatenating the rate limit type (IP or JWT), the identifier value, and the day count: [3](#0-2) 

**The Attack Scenario:**

1. **Initial State** (TAP_EPOCH_SECS = 1664089260):
   - Current time: 1700000000
   - Days since epoch: (1700000000 - 1664089260) / 86400 = 415
   - User 192.168.1.1 exhausts their limit (e.g., 100 requests)
   - Redis key: "ip:192.168.1.1:415" with counter = 100

2. **Constant Changed** (TAP_EPOCH_SECS = 1650000000):
   - Same current time: 1700000000
   - New days since epoch: (1700000000 - 1650000000) / 86400 = 578
   - New Redis key: "ip:192.168.1.1:578"
   - This key doesn't exist, counter starts at 0

3. **Exploitation**:
   - All previously rate-limited users can now make unlimited requests
   - The old Redis keys remain in the database but are never checked
   - Attackers can drain the faucet by making requests up to the daily limit again

The rate limit check occurs here: [4](#0-3) 

The system retrieves and checks the counter, but with a different day calculation, it checks a completely different Redis key that has no history: [5](#0-4) 

## Impact Explanation

This vulnerability qualifies as **High Severity** per the Aptos bug bounty criteria:

1. **Complete Rate Limit Bypass**: All rate limiting controls are instantly circumvented when the constant changes
2. **Faucet Drainage**: Attackers can request unlimited funds (up to the daily limit multiplied by the number of IPs/identities they control), potentially draining the faucet
3. **Service Availability**: Faucet could become unavailable for legitimate users due to fund exhaustion
4. **Silent Failure**: No error messages or warnings indicate that rate limits have been bypassed
5. **Persistent Impact**: The issue persists until the old Redis keys expire (24 hours), during which the database stores duplicate information

This directly impacts the **Resource Limits** invariant (Invariant #9) and breaks the fundamental security guarantee of rate limiting, which is designed to prevent resource exhaustion attacks.

## Likelihood Explanation

**Likelihood: Medium to High**

The vulnerability will occur whenever:

1. **Testnet Resets**: During testnet resets or major configuration changes, operators might update `TAP_EPOCH_SECS` to align with the new network timeline
2. **Accidental Changes**: Developers might modify the constant without understanding the security implications
3. **Intentional Reconfigurations**: If operators need to reset rate limits across the board, they might change this constant as a perceived "quick fix"
4. **Code Refactoring**: During code cleanup or modernization, the constant might be updated to use a more recent reference date

The constant is hardcoded with no documentation warning about the security implications of changing it. [6](#0-5) 

The MemoryRatelimitChecker also relies on this constant: [7](#0-6) 

## Recommendation

**Immediate Fix**: Make the epoch configurable and implement a Redis key migration strategy.

**Recommended Solution**:

1. **Move the constant to configuration**:
   - Add `tap_epoch_secs` to `RedisRatelimitCheckerConfig` and `MemoryRatelimitCheckerConfig`
   - Default to the current value for backward compatibility
   - Document that changing this value requires Redis cleanup

2. **Implement key versioning**:
   - Include a version prefix in Redis keys (e.g., "v2:ip:192.168.1.1:415")
   - When the epoch changes, increment the version
   - Add a migration script to clean up old versioned keys

3. **Add validation and warnings**:
   - On startup, store the current epoch value in Redis
   - On subsequent startups, compare and warn if it changed
   - Provide a CLI command to safely migrate rate limits

**Example configuration approach**:

```rust
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct RedisRatelimitCheckerConfig {
    // ... existing fields ...
    
    /// Reference epoch timestamp for calculating days since epoch.
    /// WARNING: Changing this value will reset all rate limits.
    /// Default: 1664089260 (2021-09-25 12:01am PDT)
    #[serde(default = "RedisRatelimitCheckerConfig::default_tap_epoch_secs")]
    pub tap_epoch_secs: u64,
}

impl RedisRatelimitCheckerConfig {
    fn default_tap_epoch_secs() -> u64 {
        1664089260
    }
}
```

**Alternative solution**: Use absolute date-based keys (e.g., "ip:192.168.1.1:2024-01-15") instead of days-since-epoch, making the keys independent of any reference timestamp.

## Proof of Concept

```rust
#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_tap_epoch_change_invalidates_keys() {
        // Simulate two different TAP_EPOCH_SECS values
        let old_epoch: u64 = 1664089260;
        let new_epoch: u64 = 1650000000;
        let current_time: u64 = 1700000000;
        
        // Calculate days with old epoch
        let days_old = (current_time - old_epoch) / 86400;
        println!("Days with old epoch: {}", days_old);
        
        // Calculate days with new epoch
        let days_new = (current_time - new_epoch) / 86400;
        println!("Days with new epoch: {}", days_new);
        
        // Generate keys
        let key_old = format!("ip:192.168.1.1:{}", days_old);
        let key_new = format!("ip:192.168.1.1:{}", days_new);
        
        println!("Old key: {}", key_old);
        println!("New key: {}", key_new);
        
        // Keys are different, proving rate limits are bypassed
        assert_ne!(key_old, key_new, 
            "Changing TAP_EPOCH_SECS produces different Redis keys, bypassing rate limits");
    }
    
    #[tokio::test]
    async fn test_rate_limit_bypass_scenario() {
        // This test demonstrates the bypass by simulating:
        // 1. User exhausts rate limit with old epoch
        // 2. Epoch changes
        // 3. User can make requests again with new epoch
        
        use redis::{AsyncCommands, Client};
        
        // Connect to local Redis (requires Redis running)
        let client = Client::open("redis://127.0.0.1/").unwrap();
        let mut con = client.get_async_connection().await.unwrap();
        
        let test_ip = "192.168.1.100";
        let max_requests = 3u32;
        let current_time = 1700000000u64;
        
        // Old epoch scenario
        let old_epoch = 1664089260u64;
        let days_old = (current_time - old_epoch) / 86400;
        let key_old = format!("test:ip:{}:{}", test_ip, days_old);
        
        // Simulate exhausting the limit
        let _: () = con.set(&key_old, max_requests).await.unwrap();
        let limit_old: u32 = con.get(&key_old).await.unwrap();
        assert_eq!(limit_old, max_requests, "Rate limit reached with old epoch");
        
        // New epoch scenario - same current time
        let new_epoch = 1650000000u64;
        let days_new = (current_time - new_epoch) / 86400;
        let key_new = format!("test:ip:{}:{}", test_ip, days_new);
        
        // Check if key exists (it shouldn't)
        let limit_new: Option<u32> = con.get(&key_new).await.unwrap();
        assert_eq!(limit_new, None, 
            "New key doesn't exist, allowing bypass of rate limit!");
        
        // Cleanup
        let _: () = con.del(key_old).await.unwrap();
    }
}
```

**Notes**:
- This vulnerability is specific to the faucet service and does not affect consensus, the Move VM, or other blockchain components
- The impact is limited to faucet operations but represents a complete failure of a critical security control
- The fix requires careful coordination with Redis state management to avoid disrupting legitimate users

### Citations

**File:** crates/aptos-faucet/core/src/helpers.rs (L26-29)
```rust
/// This unixtime is 12:01am PDT on 2021-09-25. See the docstring for
/// RedisRatelimitChecker for more information on how we use this value.
/// We also use this in MemoryRatelimitChecker in a similar way.
pub const TAP_EPOCH_SECS: u64 = 1664089260;
```

**File:** crates/aptos-faucet/core/src/helpers.rs (L33-35)
```rust
pub fn days_since_tap_epoch(current_time_secs: u64) -> u64 {
    (current_time_secs - TAP_EPOCH_SECS) / 86400
}
```

**File:** crates/aptos-faucet/core/src/checkers/redis_ratelimit.rs (L186-200)
```rust
    fn get_key_and_secs_until_next_day(
        &self,
        ratelimit_key_prefix: &str,
        ratelimit_key_value: &str,
    ) -> (String, u64) {
        let now_secs = get_current_time_secs();
        let seconds_until_next_day = seconds_until_next_day(now_secs);
        let key = format!(
            "{}:{}:{}",
            ratelimit_key_prefix,
            ratelimit_key_value,
            days_since_tap_epoch(now_secs)
        );
        (key, seconds_until_next_day)
    }
```

**File:** crates/aptos-faucet/core/src/checkers/redis_ratelimit.rs (L236-243)
```rust
        // Generate a key corresponding to this identifier and the current day.
        let key_prefix = self.ratelimit_key_provider.ratelimit_key_prefix();
        let key_value = self
            .ratelimit_key_provider
            .ratelimit_key_value(&data)
            .await?;
        let (key, seconds_until_next_day) =
            self.get_key_and_secs_until_next_day(key_prefix, &key_value);
```

**File:** crates/aptos-faucet/core/src/checkers/redis_ratelimit.rs (L247-259)
```rust
        let limit_value: Option<i64> = conn.get(&key).await.map_err(|e| {
            AptosTapError::new_with_error_code(
                format!("Failed to get value for redis key {}: {}", key, e),
                AptosTapErrorCode::StorageError,
            )
        })?;

        // If the limit value is greater than what we allow per day, signal that we
        // should reject this request.
        if let Some(rejection_reason) = self.check_limit_value(limit_value, seconds_until_next_day)
        {
            return Ok(vec![rejection_reason]);
        }
```

**File:** crates/aptos-faucet/core/src/checkers/memory_ratelimit.rs (L49-49)
```rust
            current_day: AtomicU64::new(days_since_tap_epoch(get_current_time_secs())),
```
