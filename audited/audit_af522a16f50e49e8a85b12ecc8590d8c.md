# Audit Report

## Title
Unsigned Timeout Reasons Enable Byzantine Validators to Corrupt Liveness Decisions and Exclude Honest Validators

## Summary
The `RoundTimeoutReason` field in consensus timeout votes is not covered by cryptographic signatures, allowing Byzantine validators with ≥ f+1 voting power to inject false timeout reasons. When `unpack_aggregate()` aggregates these unverified reasons, the corrupted data flows into the `ExponentialWindowFailureTracker`, which falsely excludes honest validators from payload requests and manipulates OptQS behavior, degrading network liveness.

## Finding Description

The vulnerability exists in the timeout aggregation logic where signature verification coverage does not include the timeout reason field.

**Root Cause - Missing Signature Coverage:**

The `TimeoutSigningRepr` structure that validators sign only includes `(epoch, round, hqc_round)` but omits the `reason` field: [1](#0-0) 

When validators create timeout signatures, they sign this limited structure: [2](#0-1) 

However, the `RoundTimeout` struct contains a separate `reason` field that is transmitted but never verified: [3](#0-2) 

**Verification Gap:**

When timeout messages are verified, only the signature over `(epoch, round, hqc_round)` is checked: [4](#0-3) 

**Unverified Aggregation:**

When `process_certificates()` drains timeout votes and calls `unpack_aggregate()`, it computes the aggregated timeout reason based solely on voting power of signers, without any cryptographic verification of the reason values: [5](#0-4) [6](#0-5) 

The `aggregated_timeout_reason()` function aggregates reasons by voting power and selects the majority reason if it reaches f+1 threshold: [7](#0-6) 

**Impact on Consensus Decisions:**

The corrupted aggregated reason is included in `NewRoundEvent` and pushed to the proposal status tracker: [8](#0-7) 

The `ExponentialWindowFailureTracker` uses this unverified reason to make critical decisions: [9](#0-8) 

When the reason is falsely claimed as `PayloadUnavailable`, honest validators are excluded from payload requests: [10](#0-9) 

**Attack Scenario:**

1. Byzantine validators with ≥ f+1 voting power coordinate to send timeout votes with:
   - Valid signatures over `(epoch, round, hqc_round)` 
   - False `RoundTimeoutReason::PayloadUnavailable { missing_authors: <crafted_bitvec> }` claiming honest validators are unavailable

2. The timeout votes pass signature verification because the `reason` field is not signed

3. When the round advances, `unpack_aggregate()` computes the aggregated reason, and the false `PayloadUnavailable` reason achieves f+1 voting power

4. The corrupted reason is used by `ExponentialWindowFailureTracker` to:
   - Falsely exclude honest validators from payload requests
   - Double the failure window, affecting OptQS enablement
   - Record false metrics blaming honest validators

5. Payload fetching avoids the falsely accused validators, potentially causing actual payload unavailability and further timeouts

6. The attack can be repeated every round, causing sustained liveness degradation

## Impact Explanation

**Severity: High**

This vulnerability meets the High severity criteria per Aptos bug bounty program:
- **"Validator node slowdowns"**: Falsely excluding honest validators from payload requests degrades network performance and causes unnecessary timeouts
- **"Significant protocol violations"**: The timeout reason aggregation mechanism is corrupted, violating the protocol's assumption that timeout reasons are authentic

The vulnerability does not reach Critical severity because:
- Consensus safety is not violated (blocks still get committed correctly)
- Network does not completely halt (can make progress with reduced performance)
- No funds are lost or frozen

However, the impact is significant:
- **Liveness Degradation**: Sustained false exclusion of validators degrades network throughput
- **Protocol Manipulation**: Byzantine validators can manipulate failure tracking and OptQS behavior
- **False Attribution**: Honest validators are falsely blamed for unavailability in metrics/logs
- **Amplification**: The exponential window doubling can amplify the impact over multiple rounds

## Likelihood Explanation

**Likelihood: Medium-High**

The attack is realistic and feasible:

**Attack Requirements:**
- ≥ f+1 Byzantine validators (within BFT threat model of < 1/3 Byzantine)
- Coordination to send consistent false timeout reasons
- No special cryptographic breaks or implementation bugs required

**Ease of Exploitation:**
- Simple to execute: just claim false `PayloadUnavailable` reasons in timeout votes
- No complex timing requirements
- Can be automated and sustained indefinitely
- Difficult to distinguish from legitimate payload unavailability

**Detection Difficulty:**
- False reasons appear valid (proper structure, f+1 voting power)
- Metrics and logs would show the false data as if authentic
- Hard to prove validators are lying about payload unavailability

**Incentives:**
- Byzantine validators can degrade competitor validators' reputation
- Can manipulate network performance for strategic advantage
- Can test network resilience without obvious attribution

## Recommendation

**Fix: Include `reason` in the Signature Commitment**

Modify `TimeoutSigningRepr` to include the timeout reason in the signed data:

```rust
// consensus/consensus-types/src/timeout_2chain.rs
#[derive(Serialize, Deserialize, Debug, CryptoHasher, BCSCryptoHash)]
pub struct TimeoutSigningRepr {
    pub epoch: u64,
    pub round: Round,
    pub hqc_round: Round,
    pub reason_hash: HashValue,  // Add hash of serialized reason
}

impl TwoChainTimeout {
    pub fn signing_format(&self, reason: &RoundTimeoutReason) -> TimeoutSigningRepr {
        TimeoutSigningRepr {
            epoch: self.epoch(),
            round: self.round(),
            hqc_round: self.hqc_round(),
            reason_hash: CryptoHash::hash(reason),  // Include reason in signature
        }
    }
}
```

Update `RoundTimeout::verify()` to verify the reason is covered by signature:

```rust
// consensus/consensus-types/src/round_timeout.rs
pub fn verify(&self, validator: &ValidatorVerifier) -> anyhow::Result<()> {
    self.timeout.verify(validator)?;
    validator
        .verify(
            self.author(),
            &self.timeout.signing_format(&self.reason),  // Pass reason for signing
            &self.signature,
        )
        .context("Failed to verify 2-chain timeout signature")?;
    Ok(())
}
```

This ensures that:
1. Validators must sign over their claimed timeout reason
2. False reasons will fail signature verification
3. Aggregated reasons are guaranteed to be authentic
4. Byzantine validators cannot manipulate timeout reasoning without detection

## Proof of Concept

**Reproduction Steps:**

1. Set up a test network with 4 validators (f=1, 2f+1=3 quorum)

2. Validator 1 (Byzantine) generates a timeout vote with:
   - Valid signature over `(epoch=1, round=5, hqc_round=4)`
   - False reason: `PayloadUnavailable { missing_authors: bitvec[Validator_3, Validator_4] }`

3. Validator 2 (Byzantine) generates a timeout vote with:
   - Valid signature over `(epoch=1, round=5, hqc_round=4)` 
   - Same false reason: `PayloadUnavailable { missing_authors: bitvec[Validator_3, Validator_4] }`

4. These timeout votes pass verification (signatures are valid)

5. When `process_certificates()` is called with round 6:
   - `drain_votes()` returns the partial timeout votes
   - `unpack_aggregate()` computes aggregated reason
   - With 2 votes (≥ f+1), the false `PayloadUnavailable` reason is selected

6. `NewRoundEvent` contains the false reason

7. `process_new_round_event()` pushes the false reason to `proposal_status_tracker`

8. `ExponentialWindowFailureTracker` falsely excludes Validator 3 and 4 from payload requests

9. Next proposal fetching avoids the falsely accused validators

10. Network metrics incorrectly blame Validators 3 and 4 for unavailability

**Expected vs Actual:**
- **Expected**: Timeout reasons should be authenticated and trusted
- **Actual**: Byzantine validators can inject arbitrary false reasons that corrupt liveness decisions

**Test Implementation:**

```rust
#[tokio::test]
async fn test_unsigned_timeout_reason_manipulation() {
    // Setup 4-validator network
    let (mut signers, validator_verifier) = random_validator_verifier(4, None, false);
    
    // Create false timeout reason claiming validators 2,3 unavailable
    let mut missing_authors = BitVec::with_num_bits(4);
    missing_authors.set(2);
    missing_authors.set(3);
    let false_reason = RoundTimeoutReason::PayloadUnavailable { missing_authors };
    
    // Byzantine validators 0,1 create timeout votes with false reason
    let timeout = TwoChainTimeout::new(1, 5, create_qc(4));
    let signature_0 = timeout.sign(&signers[0]).unwrap();
    let signature_1 = timeout.sign(&signers[1]).unwrap();
    
    let timeout_vote_0 = RoundTimeout::new(
        timeout.clone(),
        signers[0].author(),
        false_reason.clone(),  // FALSE reason, but signature is valid!
        signature_0,
    );
    
    let timeout_vote_1 = RoundTimeout::new(
        timeout.clone(),
        signers[1].author(),
        false_reason.clone(),  // FALSE reason, but signature is valid!
        signature_1,
    );
    
    // Verify timeout votes pass verification (they do!)
    assert!(timeout_vote_0.verify(&validator_verifier).is_ok());
    assert!(timeout_vote_1.verify(&validator_verifier).is_ok());
    
    // Add to pending votes and drain
    let mut pending_votes = PendingVotes::new();
    pending_votes.insert_round_timeout(&timeout_vote_0, &validator_verifier);
    pending_votes.insert_round_timeout(&timeout_vote_1, &validator_verifier);
    
    let (_, timeout_votes) = pending_votes.drain_votes();
    
    // Unpack aggregate - false reason becomes aggregated!
    let (_, aggregated_reason) = timeout_votes
        .unwrap()
        .unpack_aggregate(&validator_verifier);
    
    // Assert: FALSE reason was accepted as aggregated reason
    assert_eq!(aggregated_reason, false_reason);
    
    // This false reason would now be used by ExponentialWindowFailureTracker
    // to falsely exclude validators 2 and 3 from payload requests!
}
```

**Notes:**

- The vulnerability is systemic: any timeout reason field can be manipulated
- Applies to all timeout reason variants (`ProposalNotReceived`, `NoQC`, `Unknown`, `PayloadUnavailable`)
- The `PayloadUnavailable` variant is most impactful as it triggers validator exclusion
- Fix requires protocol upgrade to include reason in signature commitment
- Backward compatibility considerations needed for the signature format change

### Citations

**File:** consensus/consensus-types/src/timeout_2chain.rs (L66-72)
```rust
    pub fn signing_format(&self) -> TimeoutSigningRepr {
        TimeoutSigningRepr {
            epoch: self.epoch(),
            round: self.round(),
            hqc_round: self.hqc_round(),
        }
    }
```

**File:** consensus/consensus-types/src/timeout_2chain.rs (L98-103)
```rust
#[derive(Serialize, Deserialize, Debug, CryptoHasher, BCSCryptoHash)]
pub struct TimeoutSigningRepr {
    pub epoch: u64,
    pub round: Round,
    pub hqc_round: Round,
}
```

**File:** consensus/consensus-types/src/round_timeout.rs (L37-45)
```rust
#[derive(Deserialize, Serialize, Clone, PartialEq, Eq)]
pub struct RoundTimeout {
    // The timeout
    timeout: TwoChainTimeout,
    author: Author,
    reason: RoundTimeoutReason,
    /// Signature on the Timeout
    signature: bls12381::Signature,
}
```

**File:** consensus/consensus-types/src/round_timeout.rs (L97-107)
```rust
    pub fn verify(&self, validator: &ValidatorVerifier) -> anyhow::Result<()> {
        self.timeout.verify(validator)?;
        validator
            .verify(
                self.author(),
                &self.timeout.signing_format(),
                &self.signature,
            )
            .context("Failed to verify 2-chain timeout signature")?;
        Ok(())
    }
```

**File:** consensus/src/liveness/round_state.rs (L264-266)
```rust
            let (prev_round_timeout_votes, prev_round_timeout_reason) = prev_round_timeout_votes
                .map(|votes| votes.unpack_aggregate(verifier))
                .unzip();
```

**File:** consensus/src/pending_votes.rs (L93-129)
```rust
    fn aggregated_timeout_reason(&self, verifier: &ValidatorVerifier) -> RoundTimeoutReason {
        let mut reason_voting_power: HashMap<RoundTimeoutReason, u128> = HashMap::new();
        let mut missing_batch_authors: HashMap<usize, u128> = HashMap::new();
        // let ordered_authors = verifier.get_ordered_account_addresses();
        for (author, reason) in &self.timeout_reason {
            // To aggregate the reason, we only care about the variant type itself and
            // exclude any data within the variants.
            let reason_key = match reason {
                reason @ RoundTimeoutReason::Unknown
                | reason @ RoundTimeoutReason::ProposalNotReceived
                | reason @ RoundTimeoutReason::NoQC => reason.clone(),
                RoundTimeoutReason::PayloadUnavailable { missing_authors } => {
                    for missing_idx in missing_authors.iter_ones() {
                        *missing_batch_authors.entry(missing_idx).or_default() +=
                            verifier.get_voting_power(author).unwrap_or_default() as u128;
                    }
                    RoundTimeoutReason::PayloadUnavailable {
                        // Since we care only about the variant type, we replace the bitvec
                        // with a placeholder.
                        missing_authors: BitVec::with_num_bits(verifier.len() as u16),
                    }
                },
            };
            *reason_voting_power.entry(reason_key).or_default() +=
                verifier.get_voting_power(author).unwrap_or_default() as u128;
        }
        // The aggregated timeout reason is the reason with the most voting power received from
        // at least f+1 peers by voting power. If such voting power does not exist, then the
        // reason is unknown.

        reason_voting_power
            .into_iter()
            .max_by_key(|(_, voting_power)| *voting_power)
            .filter(|(_, voting_power)| {
                verifier
                    .check_aggregated_voting_power(*voting_power, false)
                    .is_ok()
```

**File:** consensus/src/pending_votes.rs (L155-161)
```rust
    pub(crate) fn unpack_aggregate(
        self,
        verifier: &ValidatorVerifier,
    ) -> (TwoChainTimeoutWithPartialSignatures, RoundTimeoutReason) {
        let aggregated_reason = self.aggregated_timeout_reason(verifier);
        (self.partial_2chain_tc, aggregated_reason)
    }
```

**File:** consensus/src/round_manager.rs (L469-470)
```rust
        self.proposal_status_tracker
            .push(new_round_event.reason.clone());
```

**File:** consensus/src/liveness/proposal_status_tracker.rs (L65-78)
```rust
    fn compute_failure_window(&mut self) {
        self.last_consecutive_success_count = self.last_consecutive_statuses_matching(|reason| {
            !matches!(
                reason,
                NewRoundReason::Timeout(RoundTimeoutReason::PayloadUnavailable { .. })
            )
        });
        if self.last_consecutive_success_count == 0 {
            self.window *= 2;
            self.window = self.window.min(self.max_window);
        } else if self.last_consecutive_success_count == self.past_round_statuses.len() {
            self.window = 2;
        }
    }
```

**File:** consensus/src/liveness/proposal_status_tracker.rs (L80-98)
```rust
    fn get_exclude_authors(&self) -> HashSet<Author> {
        let mut exclude_authors = HashSet::new();

        let limit = self.window;
        for round_reason in self.past_round_statuses.iter().rev().take(limit) {
            if let NewRoundReason::Timeout(RoundTimeoutReason::PayloadUnavailable {
                missing_authors,
            }) = round_reason
            {
                for author_idx in missing_authors.iter_ones() {
                    if let Some(author) = self.ordered_authors.get(author_idx) {
                        exclude_authors.insert(*author);
                    }
                }
            }
        }

        exclude_authors
    }
```
