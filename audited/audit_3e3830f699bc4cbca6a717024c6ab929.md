# Audit Report

## Title
Indexer Data Corruption via Unprotected Event Table Updates During Reprocessing

## Summary
The `starting_version` configuration field's comment claims reprocessing "will not delete any database contents, just transactions as it reprocesses them." However, the `events` and `move_resources` tables use unprotected `do_update()` clauses without transaction version guards, allowing reprocessing to silently corrupt indexed data when blockchain state differs from the existing database.

## Finding Description

The configuration comment at [1](#0-0)  claims that setting `starting_version` will not delete database contents, only reprocess transactions. This guarantee is **false** for the `events` table.

The `events` table schema uses a composite primary key of `(account_address, creation_number, sequence_number)` [2](#0-1)  that does NOT include `transaction_version`, despite storing it as a column [3](#0-2) .

The `insert_events` function [4](#0-3)  uses `on_conflict().do_update()` to update `inserted_at` and `event_index` fields **without any WHERE clause** checking transaction versions. This contrasts with `current_table_items` [5](#0-4)  and `current_objects` [6](#0-5)  which include WHERE clauses preventing older transactions from corrupting newer state.

Similarly, `insert_move_resources` [7](#0-6)  uses unprotected `do_update()` that unconditionally overwrites `state_key_hash` and `inserted_at`.

**Corruption Scenario:**
1. Indexer has processed blockchain versions 0-1000 from Node A
2. Event E with identifier (account=A, creation=C, sequence=S) exists at transaction version 200 with `event_index=5`
3. Operator connects to Node B (different fork, or after indexer bug fix) and sets `starting_version=100`
4. Node B has the same Event E at transaction version 150 with `event_index=3`
5. When reprocessing transaction 150, the conflict handler executes:
   - Tries to insert `(A, C, S, transaction_version=150, event_index=3)`
   - Conflicts on primary key `(A, C, S)`
   - Updates only `event_index=3` and `inserted_at=NOW()`
   - **Leaves `transaction_version=200` unchanged**
6. Result: Event now has `transaction_version=200` but `event_index=3` from transaction 150 - **INCONSISTENT DATA**

## Impact Explanation

**Severity: Medium** - State inconsistencies requiring intervention.

This vulnerability causes silent data corruption in the indexer database, violating the **State Consistency** invariant. While the blockchain itself remains secure, applications querying the indexer receive corrupted event data with mismatched transaction versions and event indices.

The impact is limited to the off-chain indexer component and does not affect:
- Blockchain consensus or safety
- On-chain state or funds
- Validator operations

However, it creates unreliable indexed data that could cause downstream application failures if they rely on event ordering, transaction associations, or data consistency guarantees.

## Likelihood Explanation

**Likelihood: Medium**

This requires:
1. Operator/administrator access to set `starting_version` configuration
2. Blockchain state change (different node, indexer bug fix, or testing scenario)
3. Reprocessing overlapping transaction ranges

While Aptos BFT consensus prevents forks after finality, realistic scenarios include:
- Indexer bug fixes requiring reprocessing with corrected logic
- Switching between different archive nodes with inconsistent data
- Development/testing environments resetting blockchain state
- Disaster recovery scenarios

The lack of error detection means corruption occurs silently, making it difficult to detect and remediate.

## Recommendation

Add WHERE clauses to all historical table updates matching the pattern used in `current_*` tables. Specifically, modify `insert_events` to check that existing `transaction_version` matches or is older:

```rust
fn insert_events(
    conn: &mut PgConnection,
    items_to_insert: &[EventModel],
) -> Result<(), diesel::result::Error> {
    use schema::events::dsl::*;
    let chunks = get_chunks(items_to_insert.len(), EventModel::field_count());
    for (start_ind, end_ind) in chunks {
        execute_with_better_error(
            conn,
            diesel::insert_into(schema::events::table)
                .values(&items_to_insert[start_ind..end_ind])
                .on_conflict((account_address, creation_number, sequence_number))
                .do_update()
                .set((
                    transaction_version.eq(excluded(transaction_version)),
                    inserted_at.eq(excluded(inserted_at)),
                    event_index.eq(excluded(event_index)),
                )),
            Some(" WHERE events.transaction_version >= excluded.transaction_version "),
        )?;
    }
    Ok(())
}
```

Also update `insert_move_resources` similarly, and revise the configuration comment to accurately describe the reprocessing behavior and potential data modification.

## Proof of Concept

```rust
// Test demonstrating event table corruption
#[tokio::test]
async fn test_event_corruption_on_reprocessing() {
    let (conn_pool, tailer) = setup_indexer().await.unwrap();
    let mut conn = conn_pool.get().unwrap();
    
    // First indexing: Insert event at transaction 200
    let event_v200 = create_test_event(
        "0xA", 1, 5, 200, 100, 3, // account, creation, seq, tx_ver, block, event_idx
    );
    insert_events(&mut conn, &[event_v200]).unwrap();
    
    // Verify initial state
    let result = query_event(&mut conn, "0xA", 1, 5);
    assert_eq!(result.transaction_version, 200);
    assert_eq!(result.event_index, 3);
    
    // Reprocessing: Same event identifier but different transaction version
    let event_v150 = create_test_event(
        "0xA", 1, 5, 150, 80, 7, // Same (account, creation, seq), different tx_ver and event_idx
    );
    insert_events(&mut conn, &[event_v150]).unwrap();
    
    // Corruption: transaction_version is still 200, but event_index is now 7
    let corrupted = query_event(&mut conn, "0xA", 1, 5);
    assert_eq!(corrupted.transaction_version, 200); // Old value retained
    assert_eq!(corrupted.event_index, 7); // New value from tx 150 - CORRUPTION!
}
```

## Notes

The vulnerability specifically affects the indexer subsystem's data integrity rather than blockchain consensus. While the indexer is not part of the core consensus layer, it provides critical infrastructure for applications. The unprotected update pattern in `events` and `move_resources` tables contrasts sharply with the defensive WHERE clauses used in `current_table_items` and `current_objects`, suggesting this inconsistency was an oversight rather than intentional design.

### Citations

**File:** config/src/config/indexer_config.rs (L43-44)
```rust
    /// If set, will ignore database contents and start processing from the specified version.
    /// This will not delete any database contents, just transactions as it reprocesses them.
```

**File:** crates/indexer/migrations/2022-08-08-043603_core_tables/up.sql (L212-212)
```sql
  transaction_version BIGINT NOT NULL,
```

**File:** crates/indexer/migrations/2022-08-08-043603_core_tables/up.sql (L218-222)
```sql
  PRIMARY KEY (
    account_address,
    creation_number,
    sequence_number
  ),
```

**File:** crates/indexer/src/processors/default_processor.rs (L276-297)
```rust
fn insert_events(
    conn: &mut PgConnection,
    items_to_insert: &[EventModel],
) -> Result<(), diesel::result::Error> {
    use schema::events::dsl::*;
    let chunks = get_chunks(items_to_insert.len(), EventModel::field_count());
    for (start_ind, end_ind) in chunks {
        execute_with_better_error(
            conn,
            diesel::insert_into(schema::events::table)
                .values(&items_to_insert[start_ind..end_ind])
                .on_conflict((account_address, creation_number, sequence_number))
                .do_update()
                .set((
                    inserted_at.eq(excluded(inserted_at)),
                    event_index.eq(excluded(event_index)),
                )),
            None,
        )?;
    }
    Ok(())
}
```

**File:** crates/indexer/src/processors/default_processor.rs (L337-358)
```rust
fn insert_move_resources(
    conn: &mut PgConnection,
    items_to_insert: &[MoveResource],
) -> Result<(), diesel::result::Error> {
    use schema::move_resources::dsl::*;
    let chunks = get_chunks(items_to_insert.len(), MoveResource::field_count());
    for (start_ind, end_ind) in chunks {
        execute_with_better_error(
            conn,
            diesel::insert_into(schema::move_resources::table)
                .values(&items_to_insert[start_ind..end_ind])
                .on_conflict((transaction_version, write_set_change_index))
                .do_update()
                .set((
                    inserted_at.eq(excluded(inserted_at)),
                    state_key_hash.eq(excluded(state_key_hash)),
                )),
            None,
        )?;
    }
    Ok(())
}
```

**File:** crates/indexer/src/processors/default_processor.rs (L400-400)
```rust
                Some(" WHERE current_table_items.last_transaction_version <= excluded.last_transaction_version "),
```

**File:** crates/indexer/src/processors/default_processor.rs (L466-466)
```rust
                Some(" WHERE current_objects.last_transaction_version <= excluded.last_transaction_version "),
```
