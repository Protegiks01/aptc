# Audit Report

## Title
Missing Address Validation in aptos_coin::mint() Allows Permanent Token Lock to VM Reserved Address (0x0)

## Summary
The `aptos_coin::mint()` function lacks validation to prevent minting tokens to the VM reserved address `0x0`. This allows tokens to be permanently locked in an inaccessible FungibleStore, effectively removing them from circulation without proper accounting as burned tokens.

## Finding Description

The vulnerability exists in the token minting flow where address validation is absent. The attack path is:

1. **SDK Layer** - No validation in TransactionFactory::mint() [1](#0-0) 

2. **Move Framework - aptos_coin::mint()** - Accepts any destination address without validation [2](#0-1) 

3. **coin::deposit()** - Passes address through without checks [3](#0-2) 

4. **primary_fungible_store::deposit()** - Creates store for any owner address [4](#0-3) 

5. **Object Creation** - Creates ObjectCore with owner=0x0 without validation [5](#0-4) 

The critical issue is that while **Account creation** is properly protected against `0x0`: [6](#0-5) 

**Object creation** (used for FungibleStores) has no such protection. The system_addresses module confirms `0x0` is VM reserved: [7](#0-6) 

When tokens are minted to `0x0`:
- A FungibleStore object is created with owner = `0x0`
- Tokens are deposited into this store
- The store is permanently inaccessible because:
  - `0x0` cannot have an Account resource (VM reserved)
  - Withdrawing requires a signer for `0x0`, which is impossible to obtain
  - No Account means no authentication key, no signature capability

This breaks the invariant: **"Access Control: System addresses (@aptos_framework, @core_resources) must be protected"** - `0x0` is the VM reserved system address and should not be usable for token storage.

## Impact Explanation

**Medium Severity** per Aptos bug bounty criteria:
- **Limited funds loss or manipulation**: Tokens minted to `0x0` are permanently locked, reducing circulating supply
- **State inconsistencies requiring intervention**: Locked tokens appear in total supply but cannot be recovered without hardfork
- Does not meet Critical severity because:
  - Requires mint capability (only available to core resources account in tests/testnets)
  - Not directly stealing from existing holders
  - Does not break consensus or network availability

However, the impact includes:
- Permanent token burn without proper accounting
- Supply manipulation (tokens appear minted but are inaccessible)
- Potential economic attacks if exploited systematically
- No recovery mechanism without protocol upgrade

## Likelihood Explanation

**Medium-High Likelihood**:
- **Prerequisites**: Requires MintCapStore capability (available in test/testnet environments)
- **Complexity**: Trivial to exploit - single function call with `dst_addr = 0x0`
- **Detection**: Difficult to detect without explicit balance checks on `0x0`
- **Scenarios**:
  - Accidental minting to `0x0` due to address parsing errors
  - Intentional supply manipulation in test environments
  - Integration bugs in systems constructing mint transactions

The vulnerability is especially concerning because:
- No warning or error occurs - transaction succeeds silently
- Standard transfer functions like `aptos_account::transfer()` properly validate and create accounts, creating a false sense of security
- Developers may not realize minting bypasses account validation

## Recommendation

Add explicit address validation in `aptos_coin::mint()` before calling `coin::deposit()`:

```move
public entry fun mint(
    account: &signer,
    dst_addr: address,
    amount: u64,
) acquires MintCapStore {
    let account_addr = signer::address_of(account);

    assert!(
        exists<MintCapStore>(account_addr),
        error::not_found(ENO_CAPABILITIES),
    );

    // ADD THIS VALIDATION
    assert!(
        dst_addr != @vm_reserved && 
        dst_addr != @aptos_framework && 
        dst_addr != @aptos_token,
        error::invalid_argument(ECANNOT_MINT_TO_RESERVED_ADDRESS)
    );

    let mint_cap = &borrow_global<MintCapStore>(account_addr).mint_cap;
    let coins_minted = coin::mint<AptosCoin>(amount, mint_cap);
    coin::deposit<AptosCoin>(dst_addr, coins_minted);
}
```

Add error constant:
```move
const ECANNOT_MINT_TO_RESERVED_ADDRESS: u64 = 4;
```

Alternative: Add validation at the `primary_fungible_store::deposit()` level to protect all fungible assets, not just AptosCoin.

## Proof of Concept

```move
#[test_only]
module aptos_framework::mint_to_zero_address_test {
    use aptos_framework::aptos_coin::{Self, AptosCoin};
    use aptos_framework::coin;
    use aptos_framework::primary_fungible_store;
    use aptos_framework::object;
    use aptos_framework::fungible_asset::Metadata;
    use std::signer;

    #[test(aptos_framework = @aptos_framework, core_resources = @core_resources)]
    fun test_mint_to_zero_address_locks_tokens(
        aptos_framework: &signer,
        core_resources: &signer
    ) {
        // Initialize AptosCoin
        let (burn_cap, mint_cap) = aptos_coin::initialize_for_test(aptos_framework);
        
        // Configure accounts for test (gives core_resources mint capability)
        aptos_coin::configure_accounts_for_test(
            aptos_framework,
            core_resources,
            mint_cap
        );

        // Mint 1000 tokens to 0x0 - THIS SHOULD FAIL BUT DOESN'T
        aptos_coin::mint(core_resources, @0x0, 1000);

        // Verify tokens were deposited to 0x0's primary store
        let metadata = object::address_to_object<Metadata>(@aptos_fungible_asset);
        let balance = primary_fungible_store::balance(@0x0, metadata);
        assert!(balance == 1000, 0); // Tokens are locked at 0x0!

        // Demonstrate tokens are permanently inaccessible:
        // - Cannot withdraw (no signer for 0x0)
        // - Cannot transfer (no Account resource at 0x0)
        // - Tokens effectively burned but still counted in supply

        coin::destroy_burn_cap(burn_cap);
    }
}
```

**Expected behavior**: Transaction should abort with `ECANNOT_MINT_TO_RESERVED_ADDRESS`

**Actual behavior**: Transaction succeeds, tokens are permanently locked at address `0x0`

## Notes

This vulnerability demonstrates a gap in the defensive architecture: while Account creation properly validates reserved addresses, Object creation (used for fungible asset stores) does not. This creates an inconsistency where tokens can be sent to addresses that cannot be used for normal operations. The issue affects all code paths that create FungibleStores for arbitrary addresses, not just minting.

### Citations

**File:** sdk/src/transaction_builder.rs (L342-344)
```rust
    pub fn mint(&self, to: AccountAddress, amount: u64) -> TransactionBuilder {
        self.payload(aptos_stdlib::aptos_coin_mint(to, amount))
    }
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_coin.move (L93-108)
```text
    public entry fun mint(
        account: &signer,
        dst_addr: address,
        amount: u64,
    ) acquires MintCapStore {
        let account_addr = signer::address_of(account);

        assert!(
            exists<MintCapStore>(account_addr),
            error::not_found(ENO_CAPABILITIES),
        );

        let mint_cap = &borrow_global<MintCapStore>(account_addr).mint_cap;
        let coins_minted = coin::mint<AptosCoin>(amount, mint_cap);
        coin::deposit<AptosCoin>(dst_addr, coins_minted);
    }
```

**File:** aptos-move/framework/aptos-framework/sources/coin.move (L914-918)
```text
    public fun deposit<CoinType>(
        account_addr: address, coin: Coin<CoinType>
    ) acquires CoinConversionMap, CoinInfo {
        primary_fungible_store::deposit(account_addr, coin_to_fungible_asset(coin));
    }
```

**File:** aptos-move/framework/aptos-framework/sources/primary_fungible_store.move (L195-199)
```text
    public fun deposit(owner: address, fa: FungibleAsset) acquires DeriveRefPod {
        let metadata = fa.asset_metadata();
        let store = ensure_primary_store_exists(owner, metadata);
        dispatchable_fungible_asset::deposit(store, fa);
    }
```

**File:** aptos-move/framework/aptos-framework/sources/object.move (L318-339)
```text
    fun create_object_internal(
        creator_address: address,
        object: address,
        can_delete: bool,
    ): ConstructorRef {
        assert!(!exists<ObjectCore>(object), error::already_exists(EOBJECT_EXISTS));

        let object_signer = create_signer(object);
        let guid_creation_num = INIT_GUID_CREATION_NUM;
        let transfer_events_guid = guid::create(object, &mut guid_creation_num);

        move_to(
            &object_signer,
            ObjectCore {
                guid_creation_num,
                owner: creator_address,
                allow_ungated_transfer: true,
                transfer_events: event::new_event_handle(transfer_events_guid),
            },
        );
        ConstructorRef { self: object, can_delete }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/account/account.move (L276-284)
```text
    public fun create_account_if_does_not_exist(account_address: address) {
        if (!resource_exists_at(account_address)) {
            assert!(
                account_address != @vm_reserved && account_address != @aptos_framework && account_address != @aptos_token,
                error::invalid_argument(ECANNOT_RESERVED_ADDRESS)
            );
            create_account_unchecked(account_address);
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/system_addresses.move (L68-76)
```text
    /// Return true if `addr` is a reserved address for the VM to call system modules.
    public fun is_vm(account: &signer): bool {
        is_vm_address(signer::address_of(account))
    }

    /// Return true if `addr` is a reserved address for the VM to call system modules.
    public fun is_vm_address(addr: address): bool {
        addr == @vm_reserved
    }
```
