# Audit Report

## Title
Configuration Inconsistency Between Sanitizer and Runtime Indexer Dependencies Causes Node API Failures

## Summary
The config sanitizer in `indexer_grpc_config.rs` validates that either `storage.enable_indexer` or `table_info_service_mode` is enabled when indexer gRPC is enabled, but fails to check for the internal indexer DB configuration. On nodes with DB sharding enabled (required for mainnet/testnet), the runtime code depends on a different configuration setting (`indexer_db_config`), causing the sanitizer to pass while runtime API calls fail with "Indexer reader doesn't exist" errors.

## Finding Description

The vulnerability stems from a mismatch between what the configuration sanitizer validates and what the runtime code actually requires.

**Sanitizer Validation** [1](#0-0) 

The sanitizer checks that `storage.enable_indexer` (the old, deprecated AptosDB indexer) OR `table_info_service_mode.is_enabled()` is true.

**Runtime Dependencies** - When DB sharding is enabled, API methods require an `indexer_reader`: [2](#0-1) [3](#0-2) [4](#0-3) 

**DB Sharding Check** [5](#0-4) 

**Indexer Reader Creation** - The `indexer_reader` is created from `IndexerReaders::new()`: [6](#0-5) 

This returns `None` if both `table_info_reader` and `db_indexer_reader` are `None`.

**Internal Indexer DB Bootstrap** - The `db_indexer_reader` depends on: [7](#0-6) 

**Internal Indexer DB Enabled Check** [8](#0-7) 

**The Inconsistency:**
- `storage.enable_indexer` controls the old AptosDB indexer (being deprecated)
- But runtime with DB sharding needs `indexer_db_config.is_internal_indexer_db_enabled()` to be true
- These are **different configuration settings**

**Attack Scenario:**
A node operator (or attacker) can configure:
- `storage.enable_indexer = true` ✓ (sanitizer passes)
- `indexer_grpc.enabled = true` ✓
- `storage.rocksdb_configs.enable_storage_sharding = true` ✓ (required for mainnet)
- `indexer_db_config.enable_transaction = false` ✓
- `indexer_db_config.enable_event = false` ✓  
- `indexer_db_config.enable_statekeys = false` ✓
- `indexer_table_info.table_info_service_mode = Disabled` ✓

Result:
1. Config sanitizer passes
2. Node starts successfully  
3. Indexer gRPC service starts
4. API calls requiring `indexer_reader` fail with errors, causing API crashes and node unavailability

## Impact Explanation

This qualifies as **High Severity** per Aptos bug bounty criteria:
- **API crashes**: API endpoints fail with "Indexer reader doesn't exist" errors
- **Validator node slowdowns**: The node cannot serve certain API requests, degrading service
- **Significant protocol violation**: The config validation system fails to catch a runtime dependency mismatch

On mainnet/testnet where `enable_storage_sharding = true` is mandatory [9](#0-8) , this makes indexer gRPC services non-functional despite passing configuration validation, breaking the node availability invariant.

## Likelihood Explanation

**Likelihood: Medium-High**

This can occur through:
1. **Misconfiguration**: Operators following outdated documentation or misunderstanding the relationship between `storage.enable_indexer` and `indexer_db_config`
2. **Configuration drift**: Migrating from old indexer to new internal indexer without updating all related settings
3. **Malicious configuration**: An attacker with node configuration access can intentionally create this inconsistent state

The vulnerability is easy to trigger (just config settings), difficult to debug (passes validation but fails at runtime), and affects critical node functionality.

## Recommendation

Add a validation check in the `IndexerGrpcConfig::sanitize()` function to ensure that when DB sharding is enabled and indexer gRPC is enabled, the internal indexer DB must also be properly configured:

```rust
// In config/src/config/indexer_grpc_config.rs, update sanitize() function:

impl ConfigSanitizer for IndexerGrpcConfig {
    fn sanitize(
        node_config: &NodeConfig,
        _node_type: NodeType,
        _chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();

        if !node_config.indexer_grpc.enabled {
            return Ok(());
        }

        if !node_config.storage.enable_indexer
            && !node_config
                .indexer_table_info
                .table_info_service_mode
                .is_enabled()
        {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "storage.enable_indexer must be true or indexer_table_info.table_info_service_mode must be IndexingOnly if indexer_grpc.enabled is true".to_string(),
            ));
        }
        
        // NEW CHECK: When DB sharding is enabled, ensure internal indexer DB is configured
        if node_config.storage.rocksdb_configs.enable_storage_sharding {
            if !node_config.indexer_db_config.is_internal_indexer_db_enabled()
                && !node_config.indexer_table_info.table_info_service_mode.is_enabled()
            {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "When DB sharding is enabled and indexer_grpc is enabled, either indexer_db_config must have at least one feature enabled (enable_transaction, enable_event, or enable_statekeys) or table_info_service_mode must be enabled".to_string(),
                ));
            }
        }
        
        Ok(())
    }
}
```

## Proof of Concept

Create a node configuration file `malicious_config.yaml`:

```yaml
base:
  role: "full_node"
  waypoint:
    from_config: "0:0000000000000000000000000000000000000000000000000000000000000000"

storage:
  dir: "./data"
  enable_indexer: true  # Old indexer enabled (sanitizer passes)
  rocksdb_configs:
    enable_storage_sharding: true  # Required for mainnet

indexer_grpc:
  enabled: true  # Indexer gRPC enabled
  address: "0.0.0.0:50051"

indexer_db_config:
  enable_transaction: false  # Internal indexer features disabled
  enable_event: false
  enable_statekeys: false

indexer_table_info:
  table_info_service_mode: "Disabled"  # Table info disabled
```

**Steps to reproduce:**
1. Start node with this configuration: `aptos-node -f malicious_config.yaml`
2. Node starts successfully (sanitizer passes)
3. Make API call requiring indexer reader (e.g., `/v1/accounts/{address}/resources`)
4. Observe error: "Indexer reader doesn't exist" and API failure

The node passes configuration validation but fails at runtime, demonstrating the sanitizer/runtime inconsistency vulnerability.

### Citations

**File:** config/src/config/indexer_grpc_config.rs (L115-125)
```rust
        if !node_config.storage.enable_indexer
            && !node_config
                .indexer_table_info
                .table_info_service_mode
                .is_enabled()
        {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "storage.enable_indexer must be true or indexer_table_info.table_info_service_mode must be IndexingOnly if indexer_grpc.enabled is true".to_string(),
            ));
        }
```

**File:** api/src/context.rs (L443-458)
```rust
        let mut iter = if !db_sharding_enabled(&self.node_config) {
            Box::new(
                self.db
                    .get_prefixed_state_value_iterator(
                        &StateKeyPrefix::from(address),
                        None,
                        version,
                    )?
                    .map(|item| item.map_err(|err| anyhow!(err.to_string()))),
            )
        } else {
            self.indexer_reader
                .as_ref()
                .ok_or_else(|| format_err!("Indexer reader doesn't exist"))?
                .get_prefixed_state_value_iterator(&StateKeyPrefix::from(address), None, version)?
        };
```

**File:** api/src/context.rs (L477-496)
```rust
        let account_iter = if !db_sharding_enabled(&self.node_config) {
            Box::new(
                self.db
                    .get_prefixed_state_value_iterator(
                        &StateKeyPrefix::from(address),
                        prev_state_key,
                        version,
                    )?
                    .map(|item| item.map_err(|err| anyhow!(err.to_string()))),
            )
        } else {
            self.indexer_reader
                .as_ref()
                .ok_or_else(|| format_err!("Indexer reader doesn't exist"))?
                .get_prefixed_state_value_iterator(
                    &StateKeyPrefix::from(address),
                    prev_state_key,
                    version,
                )?
        };
```

**File:** api/src/context.rs (L900-923)
```rust
        let txns_res = if !db_sharding_enabled(&self.node_config) {
            self.db.get_account_ordered_transactions(
                address,
                start_seq_number,
                limit as u64,
                true,
                ledger_version,
            )
        } else {
            self.indexer_reader
                .as_ref()
                .ok_or_else(|| anyhow!("Indexer reader is None"))
                .map_err(|err| {
                    E::internal_with_code(err, AptosErrorCode::InternalError, ledger_info)
                })?
                .get_account_ordered_transactions(
                    address,
                    start_seq_number,
                    limit as u64,
                    true,
                    ledger_version,
                )
                .map_err(|e| AptosDbError::Other(e.to_string()))
        };
```

**File:** api/src/context.rs (L1771-1773)
```rust
fn db_sharding_enabled(node_config: &NodeConfig) -> bool {
    node_config.storage.rocksdb_configs.enable_storage_sharding
}
```

**File:** storage/indexer/src/indexer_reader.rs (L27-39)
```rust
    pub fn new(
        table_info_reader: Option<Arc<IndexerAsyncV2>>,
        db_indexer_reader: Option<Arc<DBIndexer>>,
    ) -> Option<Self> {
        if table_info_reader.is_none() && db_indexer_reader.is_none() {
            None
        } else {
            Some(Self {
                table_info_reader,
                db_indexer_reader,
            })
        }
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-table-info/src/runtime.rs (L23-31)
```rust
pub fn bootstrap_internal_indexer_db(
    config: &NodeConfig,
    db_rw: DbReaderWriter,
    internal_indexer_db: Option<InternalIndexerDB>,
    update_receiver: Option<WatchReceiver<(Instant, Version)>>,
) -> Option<(Runtime, Arc<DBIndexer>)> {
    if !config.indexer_db_config.is_internal_indexer_db_enabled() || internal_indexer_db.is_none() {
        return None;
    }
```

**File:** config/src/config/internal_indexer_db_config.rs (L60-62)
```rust
    pub fn is_internal_indexer_db_enabled(&self) -> bool {
        self.enable_transaction || self.enable_event || self.enable_statekeys
    }
```

**File:** config/src/config/storage_config.rs (L664-668)
```rust
            if (chain_id.is_testnet() || chain_id.is_mainnet())
                && config_yaml["rocksdb_configs"]["enable_storage_sharding"].as_bool() != Some(true)
            {
                panic!("Storage sharding (AIP-97) is not enabled in node config. Please follow the guide to migration your node, and set storage.rocksdb_configs.enable_storage_sharding to true explicitly in your node config. https://aptoslabs.notion.site/DB-Sharding-Migration-Public-Full-Nodes-1978b846eb7280b29f17ceee7d480730");
            }
```
