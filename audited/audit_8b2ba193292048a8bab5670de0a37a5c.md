# Audit Report

## Title
Validator Node Panic Due to Partial State in ledger_update() Retry Scenario

## Summary
The `ledger_update()` function in BlockExecutor sets `state_checkpoint_output` and `ledger_update_output` sequentially. If `DoLedgerUpdate::run()` fails after `DoStateCheckpoint::run()` succeeds, the block remains in memory with partial state. A subsequent retry attempt triggers a panic when trying to set the already-set `state_checkpoint_output`, causing validator node crash.

## Finding Description

The vulnerability exists in the executor's block processing pipeline. The `PartialStateComputeResult` struct contains two `OnceCell` fields that must both be populated for a complete result: [1](#0-0) 

Both `OnceCell` fields use `.expect()` calls that panic if the cell is already set: [2](#0-1) [3](#0-2) 

The `get_complete_result()` function returns `None` when only `state_checkpoint_output` is set, as it checks specifically for `ledger_update_output`: [4](#0-3) 

The critical vulnerability occurs in the `ledger_update()` method where these outputs are set sequentially within a closure: [5](#0-4) 

The execution flow creates a window for partial state:
1. Line 315-320: `set_state_checkpoint_output()` succeeds
2. Line 321-328: `DoLedgerUpdate::run()` is called but may fail
3. Line 330: Error is propagated via `?` operator

If an error occurs after line 320 but before completing line 328, the block remains in the BlockTree with:
- `state_checkpoint_output`: SET  
- `ledger_update_output`: NOT SET

The BlockTree's `fetch_or_add_block` method returns the same block instance when called with an existing block ID: [6](#0-5) 

On a retry attempt, the check at line 291 uses `get_complete_result()` which returns `None` in this partial state, so execution continues: [7](#0-6) 

When execution reaches line 315-320 again, `set_state_checkpoint_output()` is called on an already-set `OnceCell`, triggering the panic at line 79.

**Failure Scenarios:**

The `DoLedgerUpdate::run()` implementation contains a panic point: [8](#0-7) 

Additionally, a failpoint is explicitly configured for testing such failure scenarios: [9](#0-8) 

## Impact Explanation

**Medium Severity**: This vulnerability causes validator node panics, resulting in temporary liveness loss for affected validators. The impact aligns with Medium severity per bug bounty criteria for several reasons:

1. **State Inconsistencies**: The partial state in memory requires manual intervention or node restart to resolve
2. **Node Availability**: Affected validators crash and become temporarily unavailable
3. **No Consensus Safety Violation**: Since 2/3+ honest validators can continue, consensus safety is maintained, preventing this from being Critical severity
4. **Network Resilience**: Reduces overall network resilience during the failure window

The impact is limited to individual validator crashes rather than network-wide consensus failure, which correctly places it at Medium rather than Critical severity.

## Likelihood Explanation

**Low-Medium Likelihood**: The vulnerability requires specific conditions to trigger:

1. `DoStateCheckpoint::run()` must succeed (routine operation)
2. An error must occur after state checkpoint but before ledger update completion
3. A retry operation must occur on the same block ID

**Failure Points:**
- The `.expect("Already sorted.")` panic in transaction status processing
- Failpoint injection for testing (explicitly configured in code)
- Resource exhaustion (thread pool, memory pressure)
- Future code modifications introducing additional error paths

**Evidence of Retry Consideration:**

The code includes a TODO comment acknowledging the retry scenario: [10](#0-9) 

The presence of both the retry check and the TODO comment indicates developers anticipated retry scenarios, even if not currently implemented in the consensus pipeline. The architectural pattern of persisting blocks in memory across function calls enables this vulnerability if any retry mechanism exists or is introduced.

## Recommendation

Implement one of the following fixes:

**Option 1: Idempotent Setting**
Modify the retry check to verify each OnceCell individually before attempting to set:

```rust
// Check if state_checkpoint_output needs to be set
if output.state_checkpoint_output.get().is_none() {
    output.set_state_checkpoint_output(DoStateCheckpoint::run(...)?);
}

// Check if ledger_update_output needs to be set  
if output.ledger_update_output.get().is_none() {
    output.set_ledger_update_output(DoLedgerUpdate::run(...)?);
}
```

**Option 2: Atomic Transaction**
Compute both outputs before setting either, ensuring atomic all-or-nothing behavior:

```rust
let state_checkpoint = DoStateCheckpoint::run(...)?;
let ledger_update = DoLedgerUpdate::run(...)?;

output.set_state_checkpoint_output(state_checkpoint);
output.set_ledger_update_output(ledger_update);
```

**Option 3: Remove Block on Failure**
Remove the block from the BlockTree on any ledger_update failure to ensure clean state on retry.

## Proof of Concept

```rust
#[cfg(test)]
mod test {
    use super::*;
    use fail::FailScenario;
    
    #[test]
    #[should_panic(expected = "StateCheckpointOutput already set")]
    fn test_ledger_update_partial_state_panic() {
        let scenario = FailScenario::setup();
        // Configure failpoint to inject error after state checkpoint
        fail::cfg("executor::block_state_checkpoint", "off").unwrap();
        
        let executor = create_test_executor();
        let (block_id, parent_id) = setup_test_blocks();
        
        // First attempt - will fail after setting state_checkpoint_output
        fail::cfg("executor::block_ledger_update", "return").unwrap();
        let result = executor.ledger_update(block_id, parent_id);
        assert!(result.is_err());
        
        // Second attempt - will panic on already-set state_checkpoint_output
        fail::cfg("executor::block_ledger_update", "off").unwrap();
        let _ = executor.ledger_update(block_id, parent_id);
        // Panic occurs here
    }
}
```

## Notes

The vulnerability is confirmed through code analysis showing the sequential setting of `OnceCell` fields with potential for errors between the two operations. The TODO comment at line 290 and the presence of the retry check at line 291 demonstrate that developers recognized retry scenarios as a concern. While current consensus pipeline code doesn't show explicit retry logic, the architectural pattern of persisting blocks in memory and the existence of retry-checking code indicate this vulnerability could be triggered if retry mechanisms exist in other code paths or are introduced in future modifications. The failpoint infrastructure further confirms that failure injection between the two operations is an anticipated test scenario.

### Citations

**File:** execution/executor/src/types/partial_state_compute_result.rs (L17-22)
```rust
#[derive(Clone, Debug)]
pub struct PartialStateComputeResult {
    pub execution_output: ExecutionOutput,
    pub state_checkpoint_output: OnceCell<StateCheckpointOutput>,
    pub ledger_update_output: OnceCell<LedgerUpdateOutput>,
}
```

**File:** execution/executor/src/types/partial_state_compute_result.rs (L76-80)
```rust
    pub fn set_state_checkpoint_output(&self, state_checkpoint_output: StateCheckpointOutput) {
        self.state_checkpoint_output
            .set(state_checkpoint_output)
            .expect("StateCheckpointOutput already set");
    }
```

**File:** execution/executor/src/types/partial_state_compute_result.rs (L88-92)
```rust
    pub fn set_ledger_update_output(&self, ledger_update_output: LedgerUpdateOutput) {
        self.ledger_update_output
            .set(ledger_update_output)
            .expect("LedgerUpdateOutput already set");
    }
```

**File:** execution/executor/src/types/partial_state_compute_result.rs (L94-105)
```rust
    pub fn get_complete_result(&self) -> Option<StateComputeResult> {
        self.ledger_update_output.get().map(|ledger_update_output| {
            StateComputeResult::new(
                self.execution_output.clone(),
                // ledger_update_output is set in a later stage, so it's safe to `expect` here.
                self.ensure_state_checkpoint_output()
                    .expect("StateCheckpointOutput missing.")
                    .clone(),
                ledger_update_output.clone(),
            )
        })
    }
```

**File:** execution/executor/src/block_executor/mod.rs (L290-294)
```rust
        // TODO(aldenhu): remove, assuming no retries.
        if let Some(complete_result) = block.output.get_complete_result() {
            info!(block_id = block_id, "ledger_update already done.");
            return Ok(complete_result);
        }
```

**File:** execution/executor/src/block_executor/mod.rs (L310-330)
```rust
            THREAD_MANAGER.get_non_exe_cpu_pool().install(|| {
                // TODO(aldenhu): remove? no known strategy to recover from this failure
                fail_point!("executor::block_state_checkpoint", |_| {
                    Err(anyhow::anyhow!("Injected error in block state checkpoint."))
                });
                output.set_state_checkpoint_output(DoStateCheckpoint::run(
                    &output.execution_output,
                    parent_block.output.ensure_result_state_summary()?,
                    &ProvableStateSummary::new_persisted(self.db.reader.as_ref())?,
                    None,
                )?);
                output.set_ledger_update_output(DoLedgerUpdate::run(
                    &output.execution_output,
                    output.ensure_state_checkpoint_output()?,
                    parent_out
                        .ensure_ledger_update_output()?
                        .transaction_accumulator
                        .clone(),
                )?);
                Result::<_>::Ok(())
            })?;
```

**File:** execution/executor/src/block_executor/block_tree/mod.rs (L109-116)
```rust
        match self.0.entry(id) {
            Entry::Occupied(entry) => {
                let existing = entry
                    .get()
                    .upgrade()
                    .ok_or_else(|| anyhow!("block dropped unexpected."))?;
                Ok((existing, true, parent_block))
            },
```

**File:** execution/executor/src/workflow/do_ledger_update.rs (L84-87)
```rust
                        .status()
                        .as_kept_status()
                        .expect("Already sorted."),
                    auxiliary_info_hash,
```
