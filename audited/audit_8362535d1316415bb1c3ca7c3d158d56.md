# Audit Report

## Title
State Sync Stream Engine Resource Leak via Invalid Index Range

## Summary
The `create_data_client_request_batch()` function silently returns an empty vector when `start_index > end_index`, which can cause data streams to become permanently stuck without making progress or raising errors, leading to resource leaks in validator nodes.

## Finding Description

The vulnerability exists in the state synchronization subsystem where data streams are used to fetch blockchain data. When `create_data_client_request_batch()` encounters `start_index > end_index`, it returns an empty vector instead of raising an error. [1](#0-0) 

This occurs in two stream engine types:

**1. StateStreamEngine - Insufficient Validation:**
The `number_of_states` validation uses `<` instead of `<=`, allowing edge cases where `number_of_states == next_request_index`: [2](#0-1) 

When this occurs, the subsequent request creation calculates:
- `end_state_index = number_of_states - 1`
- `start_index = next_request_index = number_of_states`
- Result: `start_index > end_index` â†’ empty vector returned [3](#0-2) 

**2. TransactionStreamEngine - No Range Validation:**
No validation exists during initialization to ensure `start_version <= end_version`: [4](#0-3) 

**Resource Leak Mechanism:**

When an empty vector is returned, the stream enters an infinite stuck state:
1. No requests are sent (empty vector)
2. `update_request_tracking()` does nothing with empty input
3. Stream indices remain unchanged
4. Stream is never marked complete (requires processing a response) [5](#0-4) 

The progress checker continuously retries but makes no progress: [6](#0-5) 

Streams remain in the `data_streams` HashMap indefinitely with no automatic cleanup mechanism (as noted in existing TODO): [7](#0-6) 

## Impact Explanation

**Medium Severity** - This constitutes a state inconsistency requiring intervention. While not directly exploitable by external attackers, it can cause:

1. **Resource Exhaustion**: Stuck streams accumulate in memory, consuming:
   - HashMap entries in `data_streams`
   - Notification channels and generators
   - Pending request queues

2. **Node Availability Impact**: Affected validator nodes experience:
   - Memory leaks over time
   - Potential slowdown from resource contention
   - Requires manual intervention (node restart) to clear

3. **State Sync Failures**: Nodes cannot complete state synchronization in edge cases, affecting:
   - New nodes bootstrapping to the network
   - Existing nodes recovering from downtime
   - Fast sync operations

This violates the **Resource Limits** invariant (all operations must respect resource limits) and affects **node availability**.

## Likelihood Explanation

**Low-to-Medium Likelihood:**

The vulnerability triggers under specific edge case conditions:

1. **StateStreamEngine**: Occurs when a node requests states starting from index N, and the queried version has exactly N states (indexed 0 to N-1). This is rare but can happen during:
   - Version boundary transitions
   - State pruning operations
   - Recovery from specific sync states

2. **TransactionStreamEngine**: Would require a bug in the state sync driver that creates malformed requests with `start_version > end_version`

While not directly attacker-controlled (stream parameters derive from internal node state), the edge cases can occur naturally during normal node operations, making this a reliability and availability concern rather than a direct security exploit.

## Recommendation

**Fix 1: Add Error Handling for Invalid Range**

In `create_data_client_request_batch()`, return an error instead of empty vector:

```rust
fn create_data_client_request_batch(
    start_index: u64,
    end_index: u64,
    max_number_of_requests: u64,
    optimal_chunk_size: u64,
    stream_engine: StreamEngine,
) -> Result<Vec<DataClientRequest>, Error> {
    if start_index > end_index {
        return Err(Error::NoDataToFetch(format!(
            "Invalid index range: start_index ({}) > end_index ({})",
            start_index, end_index
        )));
    }
    // ... rest of function
}
```

**Fix 2: Strengthen StateStreamEngine Validation**

Change the validation to use `<=`:

```rust
// Line 373
if number_of_states <= self.next_request_index {
    return Err(Error::NoDataToFetch(format!(
        "The next state index to fetch is >= the total number of states. Next index: {:?}, total states: {:?}",
        self.next_request_index, number_of_states
    )));
}
```

**Fix 3: Add Range Validation in TransactionStreamEngine**

Add validation during initialization to ensure valid range.

**Fix 4: Implement Stream Timeout and Cleanup**

Add automatic stream cleanup for streams that make no progress within a timeout period, addressing the TODO at line 200-201.

## Proof of Concept

```rust
// This PoC demonstrates the stuck stream scenario
#[tokio::test]
async fn test_stuck_stream_resource_leak() {
    // Setup: Create a state stream engine with edge case parameters
    let version = 100;
    let start_index = 100; // Request starts at index 100
    
    let request = GetAllStatesRequest {
        version,
        start_index,
    };
    
    let mut engine = StateStreamEngine::new(&request).unwrap();
    
    // Simulate receiving number_of_states = 100 (states indexed 0-99)
    engine.number_of_states = Some(100);
    engine.next_request_index = 100;
    
    // Attempt to create requests
    let global_data_summary = create_test_global_data_summary();
    let requests = engine.create_data_client_requests(
        10, // max_number_of_requests
        6,  // max_in_flight_requests
        0,  // num_in_flight_requests
        &global_data_summary,
        Arc::new(U64IdGenerator::new()),
    ).unwrap();
    
    // Verify: Empty vector returned, stream makes no progress
    assert_eq!(requests.len(), 0);
    assert_eq!(engine.next_request_index, 100); // Unchanged
    assert!(!engine.is_stream_complete()); // Not complete
    
    // Subsequent calls continue returning empty vectors
    let requests2 = engine.create_data_client_requests(
        10, 6, 0, &global_data_summary, Arc::new(U64IdGenerator::new())
    ).unwrap();
    assert_eq!(requests2.len(), 0); // Still stuck
}
```

**Notes**

This vulnerability represents an **edge case reliability bug** rather than a directly exploitable security vulnerability. The streaming service is an internal component used by the state sync driver, and stream parameters are derived from the node's own state rather than external inputs. However, the bug can cause resource leaks and node availability issues when edge case conditions are met during normal operations, warranting Medium severity classification for state inconsistencies requiring intervention.

### Citations

**File:** state-sync/data-streaming-service/src/stream_engine.rs (L201-216)
```rust
    fn update_request_tracking(
        &mut self,
        client_requests: &[DataClientRequest],
    ) -> Result<(), Error> {
        for client_request in client_requests {
            match client_request {
                StateValuesWithProof(request) => {
                    self.next_request_index =
                        request.end_index.checked_add(1).ok_or_else(|| {
                            Error::IntegerOverflow("Next request index has overflown!".into())
                        })?;
                },
                request => invalid_client_request!(request, self),
            }
        }
        Ok(())
```

**File:** state-sync/data-streaming-service/src/stream_engine.rs (L250-261)
```rust
            let end_state_index = number_of_states
                .checked_sub(1)
                .ok_or_else(|| Error::IntegerOverflow("End state index has overflown!".into()))?;

            // Create the client requests
            let client_requests = create_data_client_request_batch(
                self.next_request_index,
                end_state_index,
                num_requests_to_send,
                global_data_summary.optimal_chunk_sizes.state_chunk_size,
                self.clone().into(),
            )?;
```

**File:** state-sync/data-streaming-service/src/stream_engine.rs (L373-378)
```rust
                    if number_of_states < self.next_request_index {
                        return Err(Error::NoDataToFetch(format!(
                            "The next state index to fetch is higher than the \
                            total number of states. Next index: {:?}, total states: {:?}",
                            self.next_request_index, number_of_states
                        )));
```

**File:** state-sync/data-streaming-service/src/stream_engine.rs (L1668-1689)
```rust
    fn new(stream_request: &StreamRequest) -> Result<Self, Error> {
        match stream_request {
            StreamRequest::GetAllTransactions(request) => Ok(TransactionStreamEngine {
                request: stream_request.clone(),
                next_stream_version: request.start_version,
                next_request_version: request.start_version,
                stream_is_complete: false,
            }),
            StreamRequest::GetAllTransactionOutputs(request) => Ok(TransactionStreamEngine {
                request: stream_request.clone(),
                next_stream_version: request.start_version,
                next_request_version: request.start_version,
                stream_is_complete: false,
            }),
            StreamRequest::GetAllTransactionsOrOutputs(request) => Ok(TransactionStreamEngine {
                request: stream_request.clone(),
                next_stream_version: request.start_version,
                next_request_version: request.start_version,
                stream_is_complete: false,
            }),
            request => invalid_stream_request!(request),
        }
```

**File:** state-sync/data-streaming-service/src/stream_engine.rs (L2056-2058)
```rust
    if start_index > end_index {
        return Ok(vec![]);
    }
```

**File:** state-sync/data-streaming-service/src/streaming_service.rs (L200-201)
```rust
    /// TODO(joshlind): once this is exposed to the wild, we'll need automatic
    /// garbage collection for misbehaving clients.
```

**File:** state-sync/data-streaming-service/src/streaming_service.rs (L309-337)
```rust
    async fn check_progress_of_all_data_streams(&mut self) {
        // Drive the progress of each stream
        let data_stream_ids = self.get_all_data_stream_ids();
        for data_stream_id in &data_stream_ids {
            if let Err(error) = self.update_progress_of_data_stream(data_stream_id).await {
                if matches!(error, Error::NoDataToFetch(_)) {
                    sample!(
                        SampleRate::Duration(Duration::from_secs(NO_DATA_TO_FETCH_LOG_FREQ_SECS)),
                        info!(LogSchema::new(LogEntry::CheckStreamProgress)
                            .stream_id(*data_stream_id)
                            .event(LogEvent::Pending)
                            .error(&error))
                    );
                } else {
                    metrics::increment_counter(
                        &metrics::CHECK_STREAM_PROGRESS_ERROR,
                        error.get_label(),
                    );
                    warn!(LogSchema::new(LogEntry::CheckStreamProgress)
                        .stream_id(*data_stream_id)
                        .event(LogEvent::Error)
                        .error(&error));
                }
            }
        }

        // Update the metrics
        metrics::set_active_data_streams(data_stream_ids.len());
    }
```
