# Audit Report

## Title
Unbounded Memory Growth in Mempool Due to Account Sequence Number Map Leak

## Summary
The `account_sequence_numbers` HashMap in the mempool's `TransactionStore` grows unbounded over time, as entries are inserted for every committed transaction but only removed when the last transaction for an account is removed from the mempool. This leads to a memory leak where accounts that never have transactions in a particular node's mempool still accumulate entries, eventually causing memory exhaustion.

## Finding Description

The vulnerability exists in the cleanup logic for the `account_sequence_numbers` HashMap in `TransactionStore`. This HashMap tracks the current sequence number for accounts that have transactions in the mempool.

**The problematic flow:**

1. When a transaction is committed on the blockchain, `commit_transaction()` is called on ALL mempool nodes, regardless of whether the transaction was in their mempool. [1](#0-0) 

2. In `commit_transaction()`, for sequence-number-based transactions, the function unconditionally inserts the account's new sequence number into `account_sequence_numbers`: [2](#0-1) 

3. The ONLY place where entries are removed from `account_sequence_numbers` is in `index_remove()`, which is called when a transaction is removed from the mempool: [3](#0-2) 

**The critical issue:** If `commit_transaction()` is called for an account that has NO transactions in this node's mempool, an entry is inserted into `account_sequence_numbers` but will NEVER be cleaned up because `index_remove()` is only called when removing transactions from the mempool.

**Attack scenario:**
- Normal blockchain operation: As the network processes transactions from millions of unique accounts (submitted to various nodes), each validator receives commit notifications for ALL transactions
- For accounts that never submitted to a particular node's mempool, `commit_transaction()` still inserts entries
- These entries accumulate over weeks/months as the blockchain processes transactions from more unique accounts
- An attacker can accelerate this by intentionally creating many accounts and submitting transactions through other nodes

The `clean_committed_transactions_below_account_seq_num()` function cannot help because it only operates on accounts that exist in the `transactions` map: [4](#0-3) 

## Impact Explanation

This is **HIGH severity** per Aptos bug bounty criteria: "Validator node slowdowns."

**Memory impact:**
- Each entry: ~40 bytes (32-byte `AccountAddress` + 8-byte `u64` + HashMap overhead)
- Over time, millions of unique accounts could accumulate
- Result: Hundreds of MB to GB of leaked memory
- Eventually leads to: Node performance degradation, increased memory pressure, potential crashes

**Network impact:**
- All validator nodes affected equally (deterministic across network)
- Gradual degradation over time (weeks to months)
- Can impact consensus performance as nodes experience memory pressure
- May require node restarts to clear accumulated state

This violates **Resource Limits** invariant: "All operations must respect gas, storage, and computational limits." The unbounded memory growth has no natural limit or cleanup mechanism.

## Likelihood Explanation

**Likelihood: HIGH** - This occurs naturally during normal blockchain operation.

**Factors:**
1. **Guaranteed to occur:** Every unique account that commits a transaction across the network adds an entry to ALL nodes
2. **No attacker needed:** Organic user growth naturally triggers this over time
3. **Accelerated by design:** Aptos's high throughput means more unique accounts processed
4. **No mitigation:** No configuration, gas limits, or operational procedures prevent this

**Timeline estimate:**
- Mainnet with millions of active accounts could accumulate significant entries within months
- High-activity periods (airdrops, NFT mints) with many new accounts accelerate growth
- No cleanup means growth is monotonic - never decreases

## Recommendation

Add periodic cleanup of stale `account_sequence_numbers` entries. The cleanest solution is to remove entries during garbage collection if the account has no transactions in the mempool:

```rust
// In TransactionStore::gc() or as a separate periodic task
fn cleanup_stale_account_sequence_numbers(&mut self) {
    self.account_sequence_numbers.retain(|address, _| {
        self.transactions.contains_key(address)
    });
}
```

Call this periodically (e.g., during system TTL garbage collection): [5](#0-4) 

**Alternative approaches:**
1. **LRU cache:** Replace HashMap with bounded LRU cache (e.g., 100K entries max)
2. **TTL-based expiration:** Add timestamps and expire old entries
3. **Lazy cleanup:** Remove entries when accessed if account has no transactions

The simplest and most correct fix is to remove entries for accounts with no transactions during GC, as `account_sequence_numbers` should only track accounts actively using the mempool.

## Proof of Concept

```rust
#[cfg(test)]
mod unbounded_growth_test {
    use super::*;
    use aptos_config::config::NodeConfig;
    use aptos_types::{
        account_address::AccountAddress,
        transaction::ReplayProtector,
    };

    #[test]
    fn test_account_sequence_numbers_unbounded_growth() {
        let config = NodeConfig::default();
        let mut store = TransactionStore::new(&config.mempool);
        
        // Simulate commits for accounts NOT in mempool
        let num_accounts = 10_000;
        for i in 0..num_accounts {
            let account = AccountAddress::from_hex_literal(&format!("0x{:x}", i)).unwrap();
            
            // Call commit_transaction without any transactions in mempool
            store.commit_transaction(&account, ReplayProtector::SequenceNumber(0));
            
            // Verify entry was added
            assert!(store.account_sequence_numbers.contains_key(&account));
        }
        
        // Verify all entries persist
        assert_eq!(store.account_sequence_numbers.len(), num_accounts);
        
        // Run garbage collection
        store.gc_by_system_ttl(aptos_infallible::duration_since_epoch());
        
        // BUG: Entries are NOT cleaned up
        assert_eq!(store.account_sequence_numbers.len(), num_accounts);
        // Expected: 0 (should be cleaned since no transactions in mempool)
        
        println!("Memory leaked: {} entries never cleaned", num_accounts);
    }
}
```

This test demonstrates that `commit_transaction()` creates entries that persist indefinitely when accounts have no transactions in the mempool, violating resource limit guarantees and enabling unbounded memory growth.

### Citations

**File:** mempool/src/shared_mempool/tasks.rs (L728-738)
```rust
    for transaction in transactions {
        pool.log_commit_transaction(
            &transaction.sender,
            transaction.replay_protector,
            tracking_usecases
                .get(&transaction.use_case)
                .map(|name| (transaction.use_case.clone(), name)),
            block_timestamp,
        );
        pool.commit_transaction(&transaction.sender, transaction.replay_protector);
    }
```

**File:** mempool/src/core_mempool/transaction_store.rs (L635-644)
```rust
    fn clean_committed_transactions_below_account_seq_num(
        &mut self,
        address: &AccountAddress,
        account_sequence_number: u64,
    ) {
        // Remove all previous seq number transactions for this account.
        // This can happen if transactions are sent to multiple nodes and one of the
        // nodes has sent the transaction to consensus but this node still has the
        // transaction sitting in mempool.
        if let Some(txns) = self.transactions.get_mut(address) {
```

**File:** mempool/src/core_mempool/transaction_store.rs (L676-689)
```rust
        match replay_protector {
            ReplayProtector::SequenceNumber(txn_sequence_number) => {
                let current_account_seq_number =
                    self.get_account_sequence_number(account).map_or(0, |v| *v);
                let new_account_seq_number =
                    max(current_account_seq_number, txn_sequence_number + 1);
                self.account_sequence_numbers
                    .insert(*account, new_account_seq_number);
                self.clean_committed_transactions_below_account_seq_num(
                    account,
                    new_account_seq_number,
                );
                self.process_ready_seq_num_based_transactions(account, new_account_seq_number);
            },
```

**File:** mempool/src/core_mempool/transaction_store.rs (L758-765)
```rust
        // Remove account datastructures if there are no more transactions for the account.
        let address = &txn.get_sender();
        if let Some(txns) = self.transactions.get(address) {
            if txns.len() == 0 {
                self.transactions.remove(address);
                self.account_sequence_numbers.remove(address);
            }
        }
```

**File:** mempool/src/core_mempool/transaction_store.rs (L904-906)
```rust
    pub(crate) fn gc_by_system_ttl(&mut self, gc_time: Duration) {
        self.gc(gc_time, true);
    }
```
