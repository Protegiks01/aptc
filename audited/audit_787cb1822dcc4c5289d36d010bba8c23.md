# Audit Report

## Title
Config Sanitizer Bypass Allows InMemoryStorage Backend for Mainnet Validators, Exposing Consensus Keys to Memory Attacks

## Summary
The configuration sanitizer designed to prevent InMemoryStorage from being used in mainnet production validators can be bypassed through two mechanisms: (1) explicitly setting `skip_config_sanitizer: true`, or (2) having a missing or corrupted genesis file that causes chain ID extraction to fail. When bypassed, consensus private keys are stored in unencrypted DRAM, vulnerable to memory dumps, swap files, and memory scanning attacks.

## Finding Description

The Aptos consensus safety rules storage backend is configured via `SafetyRulesConfig` and sanitized during node startup to prevent insecure storage backends in production. However, critical security checks can be bypassed:

**Bypass Method 1: skip_config_sanitizer Flag** [1](#0-0) 

The sanitizer can be completely disabled by setting `skip_config_sanitizer: true` in the node configuration, bypassing all security validations including the InMemoryStorage check.

**Bypass Method 2: Chain ID Extraction Failure** [2](#0-1) 

When genesis transaction loading fails, the chain ID is set to `None` with only a printed warning, allowing the node to continue. [3](#0-2) 

The mainnet InMemoryStorage check only executes when `chain_id.is_some()`. If chain ID is `None`, the check is silently skipped.

**Security Impact**

When InMemoryStorage is used, consensus private keys are stored insecurely: [4](#0-3) [5](#0-4) 

Keys are stored in a plain `HashMap<String, Vec<u8>>` in DRAM without encryption, explicitly violating secure key material handling. The documentation states "This should not be used in production." [6](#0-5) 

Consensus private keys are written directly to this storage without any runtime validation of the backend type. [7](#0-6) 

## Impact Explanation

**Critical Severity** - This vulnerability enables multiple attack vectors that violate the **Consensus Safety** and **Cryptographic Correctness** invariants:

1. **Memory Dump Exposure**: Core dumps, crash dumps, or debugging tools can extract private keys from process memory
2. **Swap File Leakage**: OS memory paging can write unencrypted keys to disk swap space
3. **Memory Scanning Attacks**: Process memory scanners can locate and extract key material
4. **No Secure Zeroization**: Keys persist in memory even after deallocation

An attacker who obtains a validator's consensus private key can:
- Sign malicious blocks and votes, enabling equivocation attacks
- Participate in double-signing scenarios
- Impersonate the validator in consensus protocol
- Potentially cause consensus safety violations and chain splits (violating < 1/3 Byzantine fault tolerance)

This directly maps to **Critical Severity** per the bug bounty criteria: "Consensus/Safety violations."

## Likelihood Explanation

**Medium-to-Low Likelihood** with **High Impact**: 

While the sanitizer bypass mechanisms exist, exploitation requires one of:
1. **Operator Misconfiguration**: Validator operator inadvertently sets `skip_config_sanitizer: true` or deploys without proper genesis configuration
2. **Insider Threat**: Malicious operator deliberately weakens security to enable later key extraction
3. **Compromised Deployment Pipeline**: Attacker modifies deployment configs or genesis files

The issue is unlikely to occur through external attack vectors alone but becomes critical when combined with operator error or partial system compromise. The defense-in-depth principle is violated since the sanitizer—the primary security control—can be circumvented.

## Recommendation

**Fix 1: Remove skip_config_sanitizer bypass for critical checks**

Modify `SafetyRulesConfig::sanitize()` to enforce mainnet InMemoryStorage validation regardless of the `skip_config_sanitizer` flag:

```rust
impl ConfigSanitizer for SafetyRulesConfig {
    fn sanitize(
        node_config: &NodeConfig,
        node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();
        let safety_rules_config = &node_config.consensus.safety_rules;

        if !node_type.is_validator() {
            return Ok(());
        }

        // CRITICAL CHECK - Cannot be skipped even if skip_config_sanitizer is true
        if let Some(chain_id) = chain_id {
            if chain_id.is_mainnet() && safety_rules_config.backend.is_in_memory() {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "The secure backend must not be InMemoryStorage in mainnet!".to_string(),
                ));
            }
        } else if safety_rules_config.backend.is_in_memory() {
            // Also fail if chain ID is unknown and InMemoryStorage is configured
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "The secure backend must not be InMemoryStorage when chain ID cannot be determined!".to_string(),
            ));
        }

        // Only skip remaining checks if flag is set
        if node_config.node_startup.skip_config_sanitizer {
            return Ok(());
        }

        // ... remaining checks
    }
}
```

**Fix 2: Fail-hard on chain ID extraction failures for validators**

Modify `extract_node_type_and_chain_id()` to return an error instead of `None` when chain ID extraction fails for validator nodes:

```rust
fn extract_node_type_and_chain_id(node_config: &NodeConfig) -> Result<(NodeType, ChainId), Error> {
    let node_type = NodeType::extract_from_config(node_config);
    
    let chain_id = get_chain_id(node_config)?; // Fail hard instead of returning None
    
    Ok((node_type, chain_id))
}
```

**Fix 3: Add runtime validation in PersistentSafetyStorage**

Add an explicit check in `PersistentSafetyStorage::initialize()` to prevent InMemoryStorage in production:

```rust
pub fn initialize(
    internal_store: Storage,
    author: Author,
    consensus_private_key: bls12381::PrivateKey,
    waypoint: Waypoint,
    enable_cached_safety_data: bool,
) -> Self {
    // Runtime check - reject InMemoryStorage in production builds
    #[cfg(not(test))]
    {
        // Check if storage is InMemoryStorage by attempting a type downcast
        // This requires adding a method to Storage enum
        if internal_store.is_in_memory() {
            panic!("SECURITY: InMemoryStorage is not permitted for consensus private keys in production!");
        }
    }
    
    // ... rest of initialization
}
```

## Proof of Concept

**Step 1: Create a malicious validator configuration file (`validator.yaml`):**

```yaml
base:
  role: validator
  data_dir: "/opt/aptos/data"

consensus:
  safety_rules:
    backend:
      type: in_memory_storage
    service:
      type: local

# Bypass the sanitizer
node_startup:
  skip_config_sanitizer: true

# Minimal validator network config
validator_network:
  discovery_method: onchain
  identity:
    type: from_config
    key: "0x..." # validator private key
  network_id: validator
```

**Step 2: Demonstrate sanitizer bypass:**

```rust
// Test demonstrating the vulnerability
#[test]
fn test_inmemory_storage_bypass_via_skip_sanitizer() {
    use aptos_config::config::{NodeConfig, NodeStartupConfig, SafetyRulesConfig, SecureBackend};
    use aptos_types::chain_id::ChainId;
    
    // Create config with InMemoryStorage and sanitizer disabled
    let mut node_config = NodeConfig::default();
    node_config.node_startup.skip_config_sanitizer = true;
    node_config.consensus.safety_rules.backend = SecureBackend::InMemoryStorage;
    
    // This should fail but doesn't due to bypass
    let result = NodeConfig::sanitize(
        &node_config, 
        NodeType::Validator,
        Some(ChainId::mainnet())
    );
    
    assert!(result.is_ok()); // Vulnerability: sanitizer bypassed!
}

#[test]
fn test_inmemory_storage_bypass_via_missing_chain_id() {
    use aptos_config::config::{NodeConfig, SafetyRulesConfig, SecureBackend};
    
    let mut node_config = NodeConfig::default();
    node_config.consensus.safety_rules.backend = SecureBackend::InMemoryStorage;
    
    // Sanitizer check skipped when chain_id is None
    let result = NodeConfig::sanitize(
        &node_config,
        NodeType::Validator, 
        None  // Missing chain ID bypasses mainnet check
    );
    
    assert!(result.is_ok()); // Vulnerability: check skipped!
}
```

**Step 3: Extract keys from memory (conceptual):**

```bash
# After validator starts with InMemoryStorage
# Keys are in process memory, vulnerable to:

# 1. Core dump extraction
gcore <validator_pid>
strings core.<pid> | grep -A 50 "consensus_key"

# 2. Memory scanning
sudo gdb -p <validator_pid>
(gdb) dump memory mem.dump 0x... 0x...
strings mem.dump | grep -E '[0-9a-f]{64}'

# 3. Swap file analysis (if memory paged to disk)
sudo strings /swapfile | grep -E '[0-9a-f]{64}'
```

## Notes

This vulnerability represents a **defense-in-depth failure** where the primary security control (config sanitizer) can be circumvented. While exploitation requires some level of privileged access (config file modification or deployment pipeline compromise), the issue violates secure design principles by:

1. Allowing explicit bypass of critical security checks via configuration flag
2. Failing silently when unable to determine chain ID instead of failing safely
3. Lacking runtime validation to prevent insecure storage backends

The default `SafetyRulesConfig` uses `InMemoryStorage` [8](#0-7) , making misconfiguration more likely if sanitizer checks are bypassed.

### Citations

**File:** config/src/config/config_sanitizer.rs (L45-48)
```rust
        // If config sanitization is disabled, don't do anything!
        if node_config.node_startup.skip_config_sanitizer {
            return Ok(());
        }
```

**File:** config/src/config/node_config_loader.rs (L117-123)
```rust
    match get_chain_id(node_config) {
        Ok(chain_id) => (node_type, Some(chain_id)),
        Err(error) => {
            println!("Failed to extract the chain ID from the genesis transaction: {:?}! Continuing with None.", error);
            (node_type, None)
        },
    }
```

**File:** config/src/config/safety_rules_config.rs (L39-39)
```rust
            backend: SecureBackend::InMemoryStorage,
```

**File:** config/src/config/safety_rules_config.rs (L85-96)
```rust
        if let Some(chain_id) = chain_id {
            // Verify that the secure backend is appropriate for mainnet validators
            if chain_id.is_mainnet()
                && node_type.is_validator()
                && safety_rules_config.backend.is_in_memory()
            {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "The secure backend should not be set to in memory storage in mainnet!"
                        .to_string(),
                ));
            }
```

**File:** secure/storage/src/in_memory.rs (L9-14)
```rust
/// InMemoryStorage represents a key value store that is purely in memory and intended for single
/// threads (or must be wrapped by a Arc<RwLock<>>). This provides no permission checks and simply
/// is a proof of concept to unblock building of applications without more complex data stores.
/// Internally, it retains all data, which means that it must make copies of all key material which
/// violates the code base. It violates it because the anticipation is that data stores would
/// securely handle key material. This should not be used in production.
```

**File:** secure/storage/src/in_memory.rs (L16-18)
```rust
pub struct InMemoryStorage {
    data: HashMap<String, Vec<u8>>,
    time_service: TimeService,
```

**File:** consensus/safety-rules/src/persistent_safety_storage.rs (L68-68)
```rust
        let result = internal_store.set(CONSENSUS_KEY, consensus_private_key);
```

**File:** secure/storage/README.md (L34-36)
```markdown
- `InMemory`: The InMemory secure storage implementation provides a simple in-memory storage
engine. This engine should only be used for testing, as it does not offer any persistence, or
security (i.e., data is simply held in DRAM and may be lost on a crash, or restart).
```
