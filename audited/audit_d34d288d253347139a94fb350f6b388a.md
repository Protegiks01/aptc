# Audit Report

## Title
Epoch Consistency Validation Occurs After Expensive Cryptographic Operations in OptProposalMsg Processing

## Summary
The `OptBlockData::new()` function accepts mismatched epoch parameters without validation, and `OptProposalMsg::verify()` performs expensive cryptographic operations (BLS signature verification and payload verification) before checking epoch consistency in `verify_well_formed()`. This ordering allows malicious validators to force all other validators to waste computational resources processing invalid proposals, enabling a resource exhaustion attack.

## Finding Description

The vulnerability exists in the validation order of optimistic proposals in the Aptos consensus protocol. [1](#0-0) 

The `new()` function constructs an `OptBlockData` without validating that the `epoch`, `parent.epoch()`, and `grandparent_qc.certified_block().epoch()` are consistent. [2](#0-1) 

Epoch consistency is only validated later in `verify_well_formed()`, which checks that all three epochs match.

The critical issue is in the validation sequence: [3](#0-2) 

The `verify()` method performs expensive parallel cryptographic operations (payload verification and QC signature verification) at lines 110-119, and only then calls `verify_well_formed()` at line 122 to check epoch consistency. [4](#0-3) 

The QC verification involves expensive BLS aggregate signature verification over the validator set.

**Attack Flow:**

1. A malicious validator crafts an `OptProposalMsg` where:
   - `block_data.epoch = current_epoch` (passes epoch filter)
   - `parent.epoch = wrong_epoch` (creates inconsistency)  
   - `grandparent_qc` = legitimate QC observed on the network

2. The message passes the epoch filter: [5](#0-4) 

The check only validates the outer epoch (`block_data.epoch`), not internal consistency.

3. The message enters verification: [6](#0-5) 

4. Each validator performs expensive cryptographic operations before detecting the epoch mismatch, wasting CPU resources on every receiving node.

## Impact Explanation

This is a **Medium severity** vulnerability per Aptos bug bounty criteria. It enables resource exhaustion attacks that can cause validator node slowdowns. A malicious validator can repeatedly send crafted proposals with mismatched epochs, forcing all other validators to perform expensive BLS signature verifications before detecting the invalid epoch configuration. This computational waste can accumulate, potentially degrading consensus performance and increasing block proposal latency.

The attack does not directly violate consensus safety (cannot create invalid state transitions) but impacts availability by consuming computational resources unnecessarily. Under sustained attack, validators may experience degraded performance, though the network remains operational.

## Likelihood Explanation

**Likelihood: Medium**

This vulnerability requires:
- Attacker must be an active validator in the current epoch
- Attack is simple to execute once validator access is obtained
- No additional cryptographic capabilities or stake manipulation required

In Aptos' BFT threat model, up to 1/3 of validators are assumed potentially Byzantine. A single malicious validator can exploit this vulnerability without coordination. The attack is repeatable and can be automated to maximize resource consumption across the validator set.

## Recommendation

Move the `verify_well_formed()` check to occur **before** expensive cryptographic operations. The cheap structural validation (epoch consistency, round ordering, timestamp checks) should gate the expensive signature verifications.

**Recommended Fix:**

Modify `OptProposalMsg::verify()` to check well-formedness first:

```rust
pub fn verify(
    &self,
    sender: Author,
    validator: &ValidatorVerifier,
    proof_cache: &ProofCache,
    quorum_store_enabled: bool,
) -> Result<()> {
    ensure!(
        self.proposer() == sender,
        "OptProposal author {:?} doesn't match sender {:?}",
        self.proposer(),
        sender
    );

    // Check well-formedness BEFORE expensive crypto operations
    self.verify_well_formed()?;

    let (payload_verify_result, qc_verify_result) = rayon::join(
        || {
            self.block_data()
                .payload()
                .verify(validator, proof_cache, quorum_store_enabled)
        },
        || self.block_data().grandparent_qc().verify(validator),
    );
    payload_verify_result?;
    qc_verify_result?;

    Ok(())
}
```

This ensures epoch consistency, round ordering, and timestamp validity are checked before performing expensive BLS signature verification and payload validation.

## Proof of Concept

```rust
// In consensus/src/round_manager_tests/opt_proposal_test.rs

#[tokio::test]
async fn test_epoch_mismatch_dos_attack() {
    use crate::test_utils::*;
    use consensus_types::{
        block::block_test_utils::certificate_for_genesis,
        common::Payload,
        opt_block_data::OptBlockData,
        opt_proposal_msg::OptProposalMsg,
    };
    use aptos_types::{
        block_info::BlockInfo,
        validator_signer::ValidatorSigner,
    };
    use aptos_crypto::HashValue;
    use std::time::Instant;

    let (signers, validators) = random_validator_verifier(1, None, false);
    let signer = signers.first().unwrap();
    
    // Create legitimate grandparent QC from epoch 1
    let grandparent_qc = certificate_for_genesis();
    
    // Create parent BlockInfo with WRONG epoch (epoch 2 instead of 1)
    let parent = BlockInfo::new(
        2, // Wrong epoch
        1,
        HashValue::random(),
        HashValue::zero(),
        0,
        1000,
        None,
    );
    
    // Create OptBlockData with current epoch 1 but wrong parent epoch
    let opt_block_data = OptBlockData::new(
        vec![],
        Payload::empty(false, true),
        signer.author(),
        1, // Current epoch
        3,
        3000,
        parent, // Wrong epoch
        grandparent_qc.clone(),
    );
    
    let sync_info = SyncInfo::new(
        grandparent_qc.clone(),
        grandparent_qc.into_wrapped_ledger_info(),
        None,
    );
    
    let proposal = OptProposalMsg::new(opt_block_data, sync_info);
    let proof_cache = ProofCache::new(1024);
    
    // Time the verification to demonstrate expensive operations occur
    let start = Instant::now();
    let result = proposal.verify(signer.author(), &validators, &proof_cache, false);
    let elapsed = start.elapsed();
    
    // Verification should fail due to epoch mismatch
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("epoch"));
    
    // But it took time to perform crypto operations first
    println!("Verification with epoch mismatch took: {:?}", elapsed);
    // In production, this represents wasted BLS signature verification
}
```

## Notes

This vulnerability violates the security principle that cheap validation checks should precede expensive operations to prevent resource exhaustion attacks. The fix is straightforward and maintains backward compatibility while significantly reducing the attack surface for DoS attempts by Byzantine validators. The epoch consistency check in `verify_well_formed()` is a simple comparison operation that should gate all cryptographic verifications.

### Citations

**File:** consensus/consensus-types/src/opt_block_data.rs (L31-53)
```rust
    pub fn new(
        validator_txns: Vec<ValidatorTransaction>,
        payload: Payload,
        author: Author,
        epoch: u64,
        round: Round,
        timestamp_usecs: u64,
        parent: BlockInfo,
        grandparent_qc: QuorumCert,
    ) -> Self {
        Self {
            epoch,
            round,
            timestamp_usecs,
            parent,
            block_body: OptBlockBody::V0 {
                validator_txns,
                payload,
                author,
                grandparent_qc,
            },
        }
    }
```

**File:** consensus/consensus-types/src/opt_block_data.rs (L90-93)
```rust
        ensure!(
            grandparent_qc.epoch() == self.epoch() && parent.epoch() == self.epoch(),
            "Block's parent and grantparent should be in the same epoch"
        );
```

**File:** consensus/consensus-types/src/opt_proposal_msg.rs (L110-122)
```rust
        let (payload_verify_result, qc_verify_result) = rayon::join(
            || {
                self.block_data()
                    .payload()
                    .verify(validator, proof_cache, quorum_store_enabled)
            },
            || self.block_data().grandparent_qc().verify(validator),
        );
        payload_verify_result?;
        qc_verify_result?;

        // Note that we postpone the verification of SyncInfo until it's being used.
        self.verify_well_formed()
```

**File:** consensus/consensus-types/src/quorum_cert.rs (L143-145)
```rust
        self.ledger_info()
            .verify_signatures(validator)
            .context("Fail to verify QuorumCert")?;
```

**File:** consensus/src/epoch_manager.rs (L1645-1647)
```rust
                let event: UnverifiedEvent = msg.into();
                if event.epoch()? == self.epoch() {
                    return Ok(Some(event));
```

**File:** consensus/src/round_manager.rs (L129-136)
```rust
            UnverifiedEvent::OptProposalMsg(p) => {
                if !self_message {
                    p.verify(peer_id, validator, proof_cache, quorum_store_enabled)?;
                    counters::VERIFY_MSG
                        .with_label_values(&["opt_proposal"])
                        .observe(start_time.elapsed().as_secs_f64());
                }
                VerifiedEvent::OptProposalMsg(p)
```
