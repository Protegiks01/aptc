# Audit Report

## Title
Validator Consensus Key Exposure via World-Readable Config Files in Test Environments

## Summary
The `save_config()` method in `PersistableConfig` trait creates configuration files with default permissions (typically 0o644 on Unix), making them world-readable. When `NodeConfig` contains consensus private keys through `SafetyRulesTestConfig`, these keys can be read by any local user on the validator system, potentially allowing consensus message forgery.

## Finding Description

The `NodeConfig` struct can contain BLS consensus private keys through the following path: [1](#0-0) [2](#0-1) [3](#0-2) [4](#0-3) 

The `ConfigKey` wrapper serializes private keys: [5](#0-4) 

When `save_config()` is called, it uses `File::create()` without setting restrictive permissions: [6](#0-5) 

This creates files with default Unix permissions (typically 0o644 = rw-r--r--), making them readable by all local users. In contrast, the codebase has a secure pattern for sensitive files: [7](#0-6) 

**Attack Path:**
1. Validator operator creates a `NodeConfig` with `SafetyRulesTestConfig` containing a consensus private key (as seen in test utilities): [8](#0-7) 

2. The config is saved via `save_config()`: [9](#0-8) 

3. Local attacker with unprivileged access reads the world-readable YAML config file
4. Attacker extracts the serialized BLS consensus private key
5. Attacker can forge consensus messages and disrupt the AptosBFT protocol

## Impact Explanation

**Mitigating Factor:** Mainnet validators have a sanitizer that explicitly prohibits `SafetyRulesTestConfig`: [10](#0-9) 

However, this vulnerability still presents risk:
- **Testnet validators** may use test configs with real economic value
- **Development environments** could leak keys used in staging networks  
- **Misconfiguration scenarios** where sanitizer is bypassed or not invoked
- **Defense-in-depth failure** - the codebase itself recognizes this pattern as insecure by providing `write_to_user_only_file()`

If successfully exploited, consensus key exposure would allow an attacker to:
- Sign malicious consensus votes and blocks
- Violate Consensus Safety invariant (prevent BFT safety guarantees)
- Potentially cause chain forks or liveness failures

This qualifies as **Medium Severity**: "State inconsistencies requiring intervention" and represents a significant protocol violation in non-mainnet environments.

## Likelihood Explanation

**Likelihood: Low to Medium**

Required conditions:
1. Validator operator must use `SafetyRulesTestConfig` (prohibited on mainnet)
2. Attacker must have local unprivileged access to validator system
3. Config must be saved after test config is set

The mainnet sanitizer significantly reduces production risk, but testnet and development environments remain vulnerable. The existence of the secure `write_to_user_only_file()` pattern demonstrates the codebase recognizes this threat model.

## Recommendation

Modify `PersistableConfig::write_file()` to use restrictive file permissions on Unix systems:

```rust
fn write_file<P: AsRef<Path>>(serialized_config: Vec<u8>, output_file: P) -> Result<(), Error> {
    use std::fs::OpenOptions;
    
    let mut file = {
        let mut opts = OpenOptions::new();
        opts.write(true).create(true).truncate(true);
        
        #[cfg(unix)]
        {
            use std::os::unix::fs::OpenOptionsExt;
            opts.mode(0o600);  // User read/write only
        }
        
        opts.open(output_file.as_ref())
            .map_err(|e| Error::IO(output_file.as_ref().to_str().unwrap().to_string(), e))?
    };
    
    file.write_all(&serialized_config)
        .map_err(|e| Error::IO(output_file.as_ref().to_str().unwrap().to_string(), e))?;

    Ok(())
}
```

This applies the same security pattern already used in `write_to_user_only_file()` to all config file writes.

## Proof of Concept

```rust
use aptos_config::config::{NodeConfig, SafetyRulesTestConfig};
use aptos_config::config::PersistableConfig;
use aptos_types::account_address::AccountAddress as PeerId;
use aptos_crypto::{bls12381, Uniform};
use rand::{SeedableRng, rngs::StdRng};
use std::fs;

fn main() {
    // Create a NodeConfig with embedded consensus key
    let mut config = NodeConfig::default();
    let mut rng = StdRng::from_seed([42u8; 32]);
    
    let peer_id = PeerId::random();
    let mut test_config = SafetyRulesTestConfig::new(peer_id);
    test_config.random_consensus_key(&mut rng);
    config.consensus.safety_rules.test = Some(test_config);
    
    // Save config - creates world-readable file
    let path = "/tmp/test_validator_config.yaml";
    config.save_config(path).unwrap();
    
    // Check permissions
    let metadata = fs::metadata(path).unwrap();
    let permissions = metadata.permissions();
    println!("File permissions: {:?}", permissions);
    
    #[cfg(unix)]
    {
        use std::os::unix::fs::PermissionsExt;
        let mode = permissions.mode();
        println!("Unix mode: {:o}", mode & 0o777);
        // Will show 0o644 (rw-r--r--) - world readable!
    }
    
    // Demonstrate key extraction
    let yaml_content = fs::read_to_string(path).unwrap();
    if yaml_content.contains("consensus_key") {
        println!("WARNING: Consensus private key found in world-readable config!");
    }
}
```

**Notes**

While this vulnerability exists in the code, its exploitation in production mainnet environments is prevented by the config sanitizer. However, it represents a defense-in-depth failure and poses real risk to testnet validators and development environments. The codebase's own security patterns (`write_to_user_only_file()`) demonstrate that restrictive file permissions are the intended security posture for sensitive configuration data.

### Citations

**File:** config/src/config/node_config.rs (L45-45)
```rust
    pub consensus: ConsensusConfig,
```

**File:** config/src/config/node_config.rs (L178-178)
```rust
        self.save_config(&output_path)?;
```

**File:** config/src/config/node_config.rs (L224-226)
```rust
            let mut safety_rules_test_config = SafetyRulesTestConfig::new(peer_id);
            safety_rules_test_config.random_consensus_key(rng);
            node_config.consensus.safety_rules.test = Some(safety_rules_test_config);
```

**File:** config/src/config/consensus_config.rs (L51-51)
```rust
    pub safety_rules: SafetyRulesConfig,
```

**File:** config/src/config/safety_rules_config.rs (L29-29)
```rust
    pub test: Option<SafetyRulesTestConfig>,
```

**File:** config/src/config/safety_rules_config.rs (L106-112)
```rust
            // Verify that the safety rules test config is not enabled in mainnet
            if chain_id.is_mainnet() && safety_rules_config.test.is_some() {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "The safety rules test config should not be used in mainnet!".to_string(),
                ));
            }
```

**File:** config/src/config/safety_rules_config.rs (L244-244)
```rust
    pub consensus_key: Option<ConfigKey<bls12381::PrivateKey>>,
```

**File:** config/src/keys.rs (L25-29)
```rust
#[derive(Debug, Deserialize, Serialize)]
pub struct ConfigKey<T: PrivateKey + Serialize> {
    #[serde(bound(deserialize = "T: Deserialize<'de>"))]
    key: T,
}
```

**File:** config/src/config/persistable_config.rs (L43-47)
```rust
    fn write_file<P: AsRef<Path>>(serialized_config: Vec<u8>, output_file: P) -> Result<(), Error> {
        let mut file = File::create(output_file.as_ref())
            .map_err(|e| Error::IO(output_file.as_ref().to_str().unwrap().to_string(), e))?;
        file.write_all(&serialized_config)
            .map_err(|e| Error::IO(output_file.as_ref().to_str().unwrap().to_string(), e))?;
```

**File:** crates/aptos/src/common/utils.rs (L224-228)
```rust
pub fn write_to_user_only_file(path: &Path, name: &str, bytes: &[u8]) -> CliTypedResult<()> {
    let mut opts = OpenOptions::new();
    #[cfg(unix)]
    opts.mode(0o600);
    write_to_file_with_opts(path, name, bytes, &mut opts)
```
