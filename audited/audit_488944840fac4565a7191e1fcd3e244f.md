# Audit Report

## Title
Consensus Private Keys Exposed via World-Readable Files in OnDiskStorage Due to Missing File Permission Controls

## Summary
The `OnDiskStorage::new()` function creates the storage file using `File::create()` without explicitly setting restrictive file permissions. This results in consensus private keys being stored in files with permissions determined by the process umask, which on most systems defaults to creating world-readable files (mode 0644). Any local user can then read validator consensus keys, enabling validator impersonation and consensus safety violations. [1](#0-0) 

## Finding Description

### Vulnerability Details

The `OnDiskStorage` implementation is used to persist validator consensus private keys and safety data. When a validator node initializes, the storage backend is configured through the `SecureBackend` configuration, which converts to a `Storage` instance: [2](#0-1) 

The consensus keys are stored using this storage: [3](#0-2) 

Official validator configuration files use `on_disk_storage` as the backend: [4](#0-3) [5](#0-4) 

### The Security Flaw

When `File::create()` is called in Rust without explicit permission settings, it uses the system's default file creation mode (typically 0666) AND'd with the complement of the process umask. On most Unix systems, the default umask is 0022, resulting in files created with permissions 0644 (rw-r--r--), making them world-readable.

The codebase demonstrates awareness of this issue, as it provides secure file creation utilities: [6](#0-5) 

However, `OnDiskStorage` does not use these secure functions and instead relies on the default, insecure behavior.

### Attack Scenarios

**Scenario 1: Default System Umask (Most Common)**
1. Validator node starts with default umask 0022
2. `OnDiskStorage::new()` creates `/opt/aptos/data/secure-data.json` with permissions 0644
3. Consensus private keys are written to the file via JSON serialization
4. Any local user on the system can execute: `cat /opt/aptos/data/secure-data.json`
5. Attacker extracts the BLS consensus private key from the JSON
6. Attacker can now sign blocks, votes, and timeouts, impersonating the validator

**Scenario 2: Manipulated Umask (Advanced)**
1. Attacker compromises a startup script, systemd unit file, or Docker entrypoint
2. Attacker sets `umask 0000` before validator process launches
3. File is created with permissions 0666 (world-readable AND world-writable)
4. Any local user can read AND modify consensus keys
5. Attacker can replace keys or inject malicious data

### Broken Invariants

This vulnerability violates the **Cryptographic Correctness** invariant: "BLS signatures, VRF, and hash operations must be secure." Exposing the consensus private key completely breaks the security foundation of the consensus protocol, as the key's secrecy is fundamental to the security of BLS signatures.

## Impact Explanation

**Critical Severity** per Aptos Bug Bounty criteria:

This vulnerability enables **Consensus/Safety violations**, which is explicitly listed as Critical severity (up to $1,000,000). With access to a validator's consensus private key, an attacker can:

1. **Sign malicious blocks**: Create and sign blocks containing invalid transactions or state transitions
2. **Equivocation**: Sign multiple conflicting blocks for the same round, violating AptosBFT safety
3. **Vote manipulation**: Cast votes for malicious proposals in consensus
4. **Quorum certificate forgery**: Participate in creating invalid QCs
5. **Validator impersonation**: Fully impersonate the validator in the consensus protocol

These attacks can lead to:
- Chain splits requiring manual intervention or hardfork
- Loss of consensus safety (double-spending becomes possible)
- Corruption of committed state
- Loss of network trust and validator reputation

The impact is amplified because:
- The vulnerability exists by default (no attacker manipulation needed with standard umask)
- Multiple validators may be affected if they follow example configurations
- Recovery requires key rotation and potentially manual intervention

## Likelihood Explanation

**High Likelihood** - This vulnerability will occur in practice because:

1. **Default Behavior**: With standard system umask (0022), the vulnerability manifests without any attacker action
2. **Official Examples Use OnDiskStorage**: Despite warnings in comments, the official validator configuration files use `on_disk_storage`
3. **Common Deployment Patterns**: Many validators deploy using Docker, Kubernetes, or systemd, where umask manipulation is straightforward
4. **Multi-User Systems**: Validators often run on shared infrastructure where multiple users/services have local access
5. **No Warning at Runtime**: The code does not alert operators that consensus keys are being stored insecurely

While the code comments state OnDiskStorage "should not be used in production," the presence of this backend in official configuration templates suggests it may be used in practice, especially for testing, development, or small validator deployments. [7](#0-6) 

## Recommendation

**Fix 1: Set Explicit File Permissions (Immediate)**

Modify `OnDiskStorage::new()` to explicitly set secure file permissions:

```rust
fn new_with_time_service(file_path: PathBuf, time_service: TimeService) -> Self {
    if !file_path.exists() {
        #[cfg(unix)]
        {
            use std::os::unix::fs::OpenOptionsExt;
            std::fs::OpenOptions::new()
                .write(true)
                .create(true)
                .mode(0o600)  // User read/write only
                .open(&file_path)
                .unwrap_or_else(|_| panic!("Unable to create storage at path: {:?}", file_path));
        }
        #[cfg(not(unix))]
        {
            File::create(&file_path)
                .unwrap_or_else(|_| panic!("Unable to create storage at path: {:?}", file_path));
        }
    }
    // ... rest of the function
}
```

**Fix 2: Add Permission Verification**

Add a startup check to verify file permissions and warn if insecure:

```rust
// After file creation, verify permissions
#[cfg(unix)]
{
    use std::os::unix::fs::PermissionsExt;
    let metadata = std::fs::metadata(&file_path)?;
    let mode = metadata.permissions().mode();
    if mode & 0o077 != 0 {
        panic!("Storage file {:?} has insecure permissions: {:o}. Expected 0600.", 
               file_path, mode);
    }
}
```

**Fix 3: Deprecate OnDiskStorage for Production**

Update configuration validation to prevent OnDiskStorage in production:

```rust
impl SafetyRulesConfig {
    pub fn validate(&self) -> Result<(), Error> {
        if !cfg!(test) && matches!(self.backend, SecureBackend::OnDiskStorage(_)) {
            return Err(Error::ConfigError(
                "OnDiskStorage must not be used in production. Use Vault instead.".into()
            ));
        }
        Ok(())
    }
}
```

## Proof of Concept

```rust
// Test demonstrating the vulnerability
// File: secure/storage/src/on_disk_test_permissions.rs

#[cfg(test)]
#[cfg(unix)]
mod permission_tests {
    use super::*;
    use std::os::unix::fs::PermissionsExt;
    use aptos_temppath::TempPath;

    #[test]
    fn test_file_permissions_are_insecure() {
        // Create a temporary directory
        let temp_dir = TempPath::new();
        temp_dir.create_as_dir().unwrap();
        let storage_path = temp_dir.path().join("test-storage.json");

        // Create OnDiskStorage - this will create the file
        let _storage = OnDiskStorage::new(storage_path.clone());

        // Check the file permissions
        let metadata = std::fs::metadata(&storage_path).unwrap();
        let mode = metadata.permissions().mode();
        
        // On most systems with default umask 0022, this will be 0644
        // which means world-readable
        println!("File created with permissions: {:o}", mode & 0o777);
        
        // This assertion will likely pass, demonstrating the vulnerability
        assert_ne!(mode & 0o077, 0, 
            "File should have group/other permissions (INSECURE), but doesn't. \
             This test verifies the vulnerability exists.");
        
        // The file should have been created with 0600, but wasn't
        assert_ne!(mode & 0o777, 0o600,
            "File should be 0600 (user-only), but has insecure permissions: {:o}",
            mode & 0o777);
    }

    #[test]
    fn test_consensus_key_readable_by_others() {
        use aptos_crypto::{bls12381, PrivateKey, Uniform};
        use aptos_secure_storage::{KVStorage, Storage};
        use aptos_global_constants::CONSENSUS_KEY;

        // Create storage file
        let temp_dir = TempPath::new();
        temp_dir.create_as_dir().unwrap();
        let storage_path = temp_dir.path().join("consensus-keys.json");

        let mut storage = OnDiskStorage::new(storage_path.clone());
        
        // Store a consensus key (simulating what PersistentSafetyStorage does)
        let consensus_key = bls12381::PrivateKey::generate_for_testing();
        storage.set(CONSENSUS_KEY, consensus_key.clone()).unwrap();

        // Verify file is world-readable
        let metadata = std::fs::metadata(&storage_path).unwrap();
        let mode = metadata.permissions().mode();
        
        // Check if others can read (0o004 permission bit)
        let others_can_read = (mode & 0o004) != 0;
        
        if others_can_read {
            println!("VULNERABILITY CONFIRMED: Consensus keys stored in world-readable file!");
            println!("File permissions: {:o}", mode & 0o777);
            
            // Any user can read the file
            let file_contents = std::fs::read_to_string(&storage_path).unwrap();
            println!("File contents (readable by any user):\n{}", file_contents);
        }
        
        assert!(others_can_read, 
            "This test expects the vulnerability to exist (world-readable file). \
             If this fails, the vulnerability may have been fixed.");
    }
}
```

This PoC can be run with:
```bash
cd secure/storage
cargo test --lib permission_tests -- --nocapture
```

The test will demonstrate that consensus keys are stored in world-readable files, confirming the vulnerability.

---

**Notes:**

While the code documentation warns against production use of OnDiskStorage, this does not absolve the security issue because:
1. Official configuration examples use it
2. Developers may use it despite warnings
3. The code should be secure by default, not rely on external documentation
4. Other parts of the codebase demonstrate secure file creation, proving the developers are aware of the issue but didn't apply it consistently

### Citations

**File:** secure/storage/src/on_disk.rs (L35-38)
```rust
        if !file_path.exists() {
            File::create(&file_path)
                .unwrap_or_else(|_| panic!("Unable to create storage at path: {:?}", file_path));
        }
```

**File:** config/src/config/secure_backend_config.rs (L166-172)
```rust
            SecureBackend::OnDiskStorage(config) => {
                let storage = Storage::from(OnDiskStorage::new(config.path()));
                if let Some(namespace) = &config.namespace {
                    Storage::from(Namespaced::new(namespace, Box::new(storage)))
                } else {
                    storage
                }
```

**File:** consensus/safety-rules/src/persistent_safety_storage.rs (L68-68)
```rust
        let result = internal_store.set(CONSENSUS_KEY, consensus_private_key);
```

**File:** docker/compose/aptos-node/validator.yaml (L11-14)
```yaml
    backend:
      type: "on_disk_storage"
      path: secure-data.json
      namespace: ~
```

**File:** terraform/helm/aptos-node/files/configs/validator-base.yaml (L14-17)
```yaml
    backend:
      type: "on_disk_storage"
      path: secure-data.json
      namespace: ~
```

**File:** crates/aptos/src/common/utils.rs (L224-229)
```rust
pub fn write_to_user_only_file(path: &Path, name: &str, bytes: &[u8]) -> CliTypedResult<()> {
    let mut opts = OpenOptions::new();
    #[cfg(unix)]
    opts.mode(0o600);
    write_to_file_with_opts(path, name, bytes, &mut opts)
}
```

**File:** secure/storage/README.md (L37-42)
```markdown
- `OnDisk`: Similar to InMemory, the OnDisk secure storage implementation provides another
useful testing implementation: an on-disk storage engine, where the storage backend is
implemented using a single file written to local disk. In a similar fashion to the in-memory
storage, on-disk should not be used in production environments as it provides no security
guarantees (e.g., encryption before writing to disk). Moreover, OnDisk storage does not
currently support concurrent data accesses.
```
