# Audit Report

## Title
Supply Chain Attack via Unverified Embedded Move Bytecode Modules

## Summary
The Move VM runtime embeds core framework modules (`option.mv` and `mem.mv`) directly into validator binaries without any compile-time or runtime integrity verification beyond bytecode safety checks. An attacker who compromises the build pipeline can inject semantically malicious but verifier-valid bytecode that would be executed by all validators, leading to consensus on incorrect state transitions.

## Finding Description

The vulnerability exists in the embedded module loading mechanism. [1](#0-0) 

These embedded modules override on-chain modules when specific feature flags are enabled. [2](#0-1) 

The embedded bytecode is used to replace storage bytes during module loading. [3](#0-2) 

**Critical Security Gap:** The only verification performed is the Move bytecode verifier, which checks memory safety, type safety, and resource safety, but **NOT semantic correctness**. [4](#0-3) 

The bytecode verifier prevents crashes and memory corruption, but cannot detect:
- Incorrect business logic (e.g., `Option::some()` returning `None`)
- Backdoors or privilege escalation
- State manipulation
- Fund theft mechanisms

Furthermore, during module publishing with the transition feature flags, compatibility checks are explicitly skipped for the option module. [5](#0-4) 

**Attack Path:**
1. Attacker compromises build/release pipeline (CI/CD, developer infrastructure)
2. Attacker replaces `option.mv`/`mem.mv` with malicious bytecode that passes verifier
3. Malicious bytecode implements incorrect logic while maintaining type/memory safety
4. Compromised binary distributed to all validators
5. Feature flags activate embedded modules
6. All validators execute identical malicious code
7. Network reaches consensus on incorrect state (violates **Deterministic Execution** invariant)

## Impact Explanation

**Critical Severity** - This vulnerability enables:

1. **Loss of Funds**: Malicious option/mem module logic could manipulate state to steal funds or mint tokens
2. **Consensus Violation**: All validators execute the same malicious logic, producing deterministically incorrect but mutually agreed-upon state
3. **State Corruption**: Core framework modules (`0x1::option`, `0x1::mem`) are used throughout the Aptos framework, amplifying impact

The attack violates the **Deterministic Execution** invariant: while validators produce identical state roots, they are roots of **incorrect** state transitions that differ from the intended protocol behavior.

## Likelihood Explanation

**Likelihood: Medium-High** given successful build compromise:

**Prerequisites:**
- Compromise of build/release infrastructure (CI/CD, signing keys, or developer machines)
- Ability to create verifier-valid but semantically malicious bytecode
- Feature flag activation window (during enum option rollout)

**Mitigating Factors:**
- Requires infrastructure compromise (high barrier)
- Limited to specific feature flag configuration
- Temporary mechanism (TODO comments indicate eventual removal)

**Amplifying Factors:**
- No integrity checks to detect compromise
- No reproducible build verification
- No cryptographic signatures on embedded modules
- All validators affected simultaneously
- Silent failure (no runtime detection possible)

## Recommendation

Implement defense-in-depth supply chain protections:

1. **Compile-Time Hash Verification**: Add build script to verify embedded module hashes against known-good values:
```rust
// build.rs
const EXPECTED_OPTION_HASH: &str = "sha256:abc123...";
const EXPECTED_MEM_HASH: &str = "sha256:def456...";

fn verify_embedded_modules() {
    let option_bytes = include_bytes!("src/storage/option.mv");
    let mem_bytes = include_bytes!("src/storage/mem.mv");
    
    assert_eq!(sha3_256(option_bytes), EXPECTED_OPTION_HASH);
    assert_eq!(sha3_256(mem_bytes), EXPECTED_MEM_HASH);
}
```

2. **Cryptographic Signatures**: Sign embedded modules with developer keys and verify signatures at runtime

3. **Reproducible Builds**: Enable reproducible builds with hash verification in validator startup

4. **On-Chain Governance Hash Verification**: Store expected module hashes in governance and verify at runtime

5. **Remove Temporary Mechanism**: Prioritize completing the enum option migration to eliminate embedded module override mechanism entirely

## Proof of Concept

**Scenario: Malicious Option Module**

1. Create malicious but verifier-valid option module:
```move
// Malicious option.move that passes verifier but implements incorrect logic
module 0x1::option {
    public fun some<T>(value: T): Option<T> {
        // Malicious: always returns None instead of Some
        none()
    }
    
    public fun none<T>(): Option<T> {
        // Correct implementation
        Option { vec: vector::empty() }
    }
}
```

2. Compile to bytecode: `move build` produces verifier-valid bytecode

3. Replace `option.mv` in source tree with malicious bytecode

4. Build validator binary: `cargo build --release`

5. Deploy to all validators

6. Activate feature flags: `enable_enum_option=true`, `enable_framework_for_option=false`

7. **Impact**: All code using `Option::some()` now gets `None`, causing:
   - Failed unwraps leading to transaction aborts
   - State corruption where None is stored instead of Some
   - Consensus on incorrect state across all validators

**Note**: This PoC demonstrates the attack vector. The actual malicious logic could be far more subtle (e.g., conditional backdoors, specific account targeting, time-based triggers) making detection extremely difficult.

## Notes

- This vulnerability requires **build process compromise** as a prerequisite, which is a high barrier but not impossible (supply chain attacks are increasingly common)
- The issue is a **lack of defense-in-depth**: even with secure infrastructure, cryptographic verification should exist
- The embedded module mechanism is marked as temporary (TODO comments), but remains a critical attack vector while active
- No runtime detection is possible since all validators execute identical malicious code and reach consensus
- The Move bytecode verifier is working as designedâ€”it checks safety, not correctness

### Citations

**File:** third_party/move/move-vm/runtime/src/storage/environment.rs (L40-41)
```rust
const OPTION_MODULE_BYTES: &[u8] = include_bytes!("option.mv");
const MEM_MODULE_BYTES: &[u8] = include_bytes!("mem.mv");
```

**File:** third_party/move/move-vm/runtime/src/storage/environment.rs (L178-201)
```rust
    pub fn build_locally_verified_module(
        &self,
        compiled_module: Arc<CompiledModule>,
        module_size: usize,
        module_hash: &[u8; 32],
    ) -> VMResult<LocallyVerifiedModule> {
        if !VERIFIED_MODULES_CACHE.contains(module_hash) {
            let _timer =
                VM_TIMER.timer_with_label("move_bytecode_verifier::verify_module_with_config");

            // For regular execution, we cache already verified modules. Note that this even caches
            // verification for the published modules. This should be ok because as long as the
            // hash is the same, the deployed bytecode and any dependencies are the same, and so
            // the cached verification result can be used.
            move_bytecode_verifier::verify_module_with_config(
                &self.vm_config().verifier_config,
                compiled_module.as_ref(),
            )?;
            check_natives(compiled_module.as_ref())?;
            VERIFIED_MODULES_CACHE.put(*module_hash);
        }

        Ok(LocallyVerifiedModule(compiled_module, module_size))
    }
```

**File:** third_party/move/move-vm/runtime/src/storage/environment.rs (L411-427)
```rust
    pub fn get_module_bytes_override(
        &self,
        addr: &AccountAddress,
        name: &IdentStr,
    ) -> Option<Bytes> {
        let enable_enum_option = self.vm_config().enable_enum_option;
        let enable_framework_for_option = self.vm_config().enable_framework_for_option;
        if !enable_framework_for_option && enable_enum_option {
            if addr == OPTION_MODULE_ID.address() && *name == *OPTION_MODULE_ID.name() {
                return Some(self.get_option_module_bytes());
            }
            if addr == MEM_MODULE_ID.address() && *name == *MEM_MODULE_ID.name() {
                return Some(self.get_mem_module_bytes());
            }
        }
        None
    }
```

**File:** aptos-move/block-executor/src/code_cache.rs (L61-66)
```rust
                if let Some(bytes) = self
                    .runtime_environment()
                    .get_module_bytes_override(key.address(), key.name())
                {
                    state_value.set_bytes(bytes);
                }
```

**File:** third_party/move/move-vm/runtime/src/storage/publishing.rs (L181-193)
```rust
                    if !is_framework_for_option_enabled
                        && is_enum_option_enabled
                        && old_module_ref.self_id().is_option()
                        && old_module_ref.self_id() == compiled_module.self_id()
                    {
                        // skip check for option module during publishing
                    } else {
                        let old_module = old_module_ref.as_ref();
                        compatibility
                            .check(old_module, &compiled_module)
                            .map_err(|e| e.finish(Location::Undefined))?;
                    }
                }
```
