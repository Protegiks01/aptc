# Audit Report

## Title
Sequence Number Race Condition in CreateObjectAndPublishPackage Causes Transaction Failure and Gas Loss

## Summary
The `CreateObjectAndPublishPackage::execute()` function predicts the future sequence number to derive an object address for code compilation, but this prediction becomes stale if concurrent transactions occur before submission. This causes the Move VM to reject the deployment with `MODULE_ADDRESS_DOES_NOT_MATCH_SENDER`, resulting in failed transactions and gas loss for users.

## Finding Description

The vulnerability exists in the object code deployment workflow where the CLI tool must predict an object address before compiling the package. The object address derivation depends on the publisher's sequence number, which is fetched at two different points in time, creating a race condition window.

**Step 1: Sequence Number Prediction** [1](#0-0) 

The CLI fetches the current sequence number and predicts what it will be when the deployment transaction executes (current + 1 for normal mode, or current + staging_tx_count + 1 for chunked mode).

**Step 2: Object Address Derivation** [2](#0-1) 

The predicted sequence number is used to derive the object address: [3](#0-2) 

**Step 3: Package Compilation** [4](#0-3) 

The package is compiled with the predicted object address baked into the bytecode as a named address.

**Step 4: Transaction Submission (Race Window)** [5](#0-4) 

The transaction submission refetches the sequence number from the blockchain. If another transaction from the same account was committed during the compilation window, the sequence number will be different from the prediction.

**Step 5: On-Chain Address Calculation** [6](#0-5) 

During execution, the object seed is calculated using the ACTUAL sequence number at execution time (current sequence + 1).

**Step 6: Address Mismatch Detection** [7](#0-6) 

The Move VM validates that the module's compiled address matches the deployment address. If they don't match due to the race condition, the transaction fails with `MODULE_ADDRESS_DOES_NOT_MATCH_SENDER`.

**Race Condition Scenario:**
1. User's current sequence number: 10
2. CLI predicts: sequence 11 → derives object_address_A
3. Package compiled with object_address_A
4. **[RACE WINDOW]** Another transaction from user's account commits → sequence becomes 11
5. CLI submits deployment with sequence 11
6. On-chain calculates: sequence 11 + 1 = 12 → derives object_address_B
7. Module contains object_address_A but deploys to object_address_B
8. **Transaction fails with MODULE_ADDRESS_DOES_NOT_MATCH_SENDER**
9. User loses gas but deployment fails

## Impact Explanation

This bug causes **limited funds loss** through wasted gas fees and temporary denial of service. Per the Aptos bug bounty program, this qualifies as **Medium Severity** based on:

1. **Limited Funds Loss**: Users lose gas on failed transactions (typically hundreds to thousands of Octas per attempt)
2. **Denial of Service**: Users cannot deploy their code when concurrent transactions exist
3. **User Confusion**: The error message doesn't explain the root cause, leading to repeated failures
4. **Amplified Risk in Chunked Mode**: The race window is significantly larger when chunked publishing is used

However, the security impact is contained because:
- No code is deployed to unintended addresses (the VM's security check prevents this)
- External attackers cannot exploit this against other users (requires victim's private key)
- The protocol's address verification works correctly

## Likelihood Explanation

**Medium to High Likelihood** in practical scenarios:

1. **Natural Occurrence**: Users with multiple wallet clients, background transactions (staking, governance), or automated operations will encounter this
2. **Chunked Publishing**: The vulnerability window extends across multiple transaction submissions, increasing collision probability
3. **No Malicious Intent Required**: This happens accidentally during normal usage
4. **Cannot Be Externally Exploited**: Attackers cannot force this to happen to other users (would need victim's private key)

## Recommendation

Implement atomic sequence number reservation or post-submission address verification:

**Option 1: Use Transaction Sequence Number**
Modify the CLI to use the sequence number that will actually be assigned to the transaction, rather than predicting it beforehand. This requires refactoring to delay compilation until after transaction sequence number assignment.

**Option 2: Post-Submission Verification**
After transaction submission but before compilation, fetch the exact sequence number assigned to the transaction and use that for address derivation. This eliminates the race window.

**Option 3: Retry with Updated Prediction**
Detect `MODULE_ADDRESS_DOES_NOT_MATCH_SENDER` errors and automatically retry with an updated sequence number prediction. While not ideal, this provides better user experience than silent failure.

**Option 4: Warning and Confirmation**
Add warnings to users about the race condition risk and prompt them to ensure no other transactions are pending before proceeding.

## Proof of Concept

```rust
// Reproduction steps:
// 1. Set up account with initial sequence number N
// 2. Initiate CreateObjectAndPublishPackage CLI command
// 3. During compilation (after sequence prediction, before submission),
//    submit another simple transaction from the same account
// 4. Observe the deployment transaction fails with MODULE_ADDRESS_DOES_NOT_MATCH_SENDER
// 5. User has paid gas but code was not deployed

// The PoC would require:
// - Setting up a test harness with account sequence number N
// - Calling CreateObjectAndPublishPackage::execute()
// - Injecting a concurrent transaction between lines 1202 and 1238 of mod.rs
// - Verifying the deployment fails with the expected error code
// - Confirming gas was deducted but no code was deployed
```

**Notes:**
While this is a real implementation bug that causes user impact, it does **not** allow code deployment to unintended addresses as the security question asks. The Move VM's `MODULE_ADDRESS_DOES_NOT_MATCH_SENDER` check correctly prevents such deployment. The bug is limited to transaction failure and gas loss, with no consensus or protocol-level security impact.

### Citations

**File:** crates/aptos/src/move_tool/mod.rs (L1181-1200)
```rust
        let sequence_number = if self.chunked_publish_option.chunked_publish {
            // Perform a preliminary build to determine the number of transactions needed for chunked publish mode.
            // This involves building the package with mock account address `0xcafe` to calculate the transaction count.
            let mock_object_address = AccountAddress::from_hex_literal("0xcafe").unwrap();
            self.move_options
                .add_named_address(self.address_name.clone(), mock_object_address.to_string());
            let package = build_package_options(&self.move_options, &self.included_artifacts_args)?;
            let mock_payloads = create_chunked_publish_payloads(
                package,
                PublishType::AccountDeploy,
                None,
                chunked_publish_large_packages_module_address.unwrap(),
                self.chunked_publish_option.chunk_size,
            )?
            .payloads;
            let staging_tx_count = (mock_payloads.len() - 1) as u64;
            self.txn_options.sequence_number(sender_address).await? + staging_tx_count + 1
        } else {
            self.txn_options.sequence_number(sender_address).await? + 1
        };
```

**File:** crates/aptos/src/move_tool/mod.rs (L1202-1202)
```rust
        let object_address = create_object_code_deployment_address(sender_address, sequence_number);
```

**File:** crates/aptos/src/move_tool/mod.rs (L1204-1207)
```rust
        self.move_options
            .add_named_address(self.address_name, object_address.to_string());

        let package = build_package_options(&self.move_options, &self.included_artifacts_args)?;
```

**File:** types/src/object_address.rs (L9-17)
```rust
pub fn create_object_code_deployment_address(
    creator: AccountAddress,
    creator_sequence_number: u64,
) -> AccountAddress {
    let mut seed = vec![];
    seed.extend(bcs::to_bytes(OBJECT_CODE_DEPLOYMENT_DOMAIN_SEPARATOR).unwrap());
    seed.extend(bcs::to_bytes(&creator_sequence_number).unwrap());
    create_object_address(creator, &seed)
}
```

**File:** crates/aptos/src/common/types.rs (L1958-1960)
```rust
        // Get sequence number for account
        let (account, state) = get_account_with_state(&client, sender_address).await?;
        let sequence_number = account.sequence_number;
```

**File:** aptos-move/framework/aptos-framework/sources/object_code_deployment.move (L108-114)
```text
    inline fun object_seed(publisher: address): vector<u8> {
        let sequence_number = account::get_sequence_number(publisher) + 1;
        let seeds = vector[];
        vector::append(&mut seeds, bcs::to_bytes(&OBJECT_CODE_DEPLOYMENT_DOMAIN_SEPARATOR));
        vector::append(&mut seeds, bcs::to_bytes(&sequence_number));
        seeds
    }
```

**File:** third_party/move/move-vm/runtime/src/storage/publishing.rs (L156-171)
```rust
            // Make sure all modules' addresses match the sender. The self address is
            // where the module will actually be published. If we did not check this,
            // the sender could publish a module under anyone's account.
            if addr != sender {
                let msg = format!(
                    "Compiled modules address {} does not match the sender {}",
                    addr, sender
                );
                return Err(verification_error(
                    StatusCode::MODULE_ADDRESS_DOES_NOT_MATCH_SENDER,
                    IndexKind::AddressIdentifier,
                    compiled_module.self_handle_idx().0,
                )
                .with_message(msg)
                .finish(Location::Undefined));
            }
```
