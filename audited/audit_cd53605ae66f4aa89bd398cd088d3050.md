# Audit Report

## Title
Gas Metering Bypass in Type Substitution Operations Allows Computation Without Payment

## Summary
The Move VM performs expensive type substitution operations for generic structs before verifying sufficient gas is available to pay for them. This ordering flaw allows attackers to force validator nodes to execute costly computations that fail gas checks only after the work completes, enabling resource exhaustion attacks through unpaid computation.

## Finding Description
The vulnerability exists in the PackGeneric bytecode instruction execution path where type instantiation work precedes gas metering.

When PackGeneric is executed, the interpreter calls `frame_cache.get_struct_fields_types()` which performs complete type substitution before any gas is charged: [1](#0-0) 

The `get_struct_fields_types()` method uses a caching macro that evaluates the full type substitution expression when the cache misses: [2](#0-1) 

This triggers `instantiate_generic_struct_fields()` which performs the actual computational work: [3](#0-2) 

The substitution uses `create_ty_with_subst()` which recursively traverses type structures via `apply_subst()`: [4](#0-3) 

Critically, the `check()` function called during substitution only validates type size and depth limits, **not gas availability**: [5](#0-4) 

Gas is only charged AFTER the complete type structure is built and node counts are calculated. The gas cost is 400 internal gas units per type node: [6](#0-5) 

With the 128-node type size limit, an attacker can force up to 51,200 gas units worth of computation (128 Ã— 400) before gas charging occurs.

**Attack Execution:**
1. Attacker deploys Move module with complex generic structs near the 128-node limit
2. Submits transaction that consumes most gas allocation through preliminary instructions
3. Triggers PackGeneric with minimal remaining gas (e.g., 1,000 units)
4. VM performs type substitution requiring 51,200 gas units of CPU work
5. Gas charge fails due to insufficient remaining gas
6. Transaction aborts, but validator has already performed the computation

This violates the fundamental gas metering invariant that computational work must be paid for before execution.

## Impact Explanation
This qualifies as **High Severity** under the "Validator Node Slowdowns" category of the Aptos bug bounty program.

An attacker can repeatedly submit specially-crafted transactions that force validators to perform disproportionate unpaid work. Each transaction causes validators to execute type substitution operations worth up to 51,200 gas units while only charging for the minimal gas remaining at execution time.

By creating modules with multiple distinct generic instantiations and submitting transactions in rapid succession, an attacker can amplify this effect to cause measurable performance degradation. The cache provides limited protection since each unique `StructDefInstantiationIndex` requires separate computation.

This resource exhaustion attack affects all validators processing these transactions, potentially impacting block production rates and network responsiveness.

## Likelihood Explanation
**High Likelihood** - The vulnerability is readily exploitable:

- **No special privileges**: Any user can submit transactions and deploy Move modules
- **Simple to construct**: Generic structs with deep nesting are straightforward to create
- **Bypass protections**: Type size/depth limits (128 nodes) are enforced but don't prevent the attack; caching only helps for repeated identical instantiations
- **Always active**: The vulnerability has existed since feature version 14 when type substitution gas metering was introduced: [7](#0-6) 

The minimum transaction gas requirement does not prevent exploitation since attackers can consume that gas before reaching the PackGeneric instruction, leaving insufficient gas for the type substitution charge while forcing the work to be performed.

## Recommendation
Implement gas pre-checking before performing type substitution work:

1. **Calculate gas cost before computation**: Estimate the number of type nodes that will result from substitution without performing the actual work
2. **Check gas availability upfront**: Verify sufficient gas exists before calling `instantiate_generic_struct_fields()`
3. **Fail fast on insufficient gas**: Abort before doing any type substitution work if gas check fails

Alternatively, perform type substitution incrementally with gas checks at each recursive step, similar to how other operations charge gas progressively.

## Proof of Concept
```move
module attacker::gas_exhaustion {
    use std::vector;
    
    // Create deeply nested generic struct near 128-node limit
    struct Deep<T1, T2, T3, T4> has drop {
        a: vector<T1>,
        b: vector<T2>,
        c: vector<T3>,
        d: vector<T4>,
    }
    
    public entry fun exploit() {
        // Consume most transaction gas through loops
        let i = 0;
        while (i < 10000) {
            i = i + 1;
        };
        
        // Trigger PackGeneric with complex type instantiation
        // This forces expensive substitution with minimal remaining gas
        let _x = Deep<vector<u64>, vector<u128>, vector<u256>, vector<address>> {
            a: vector::empty(),
            b: vector::empty(),
            c: vector::empty(),
            d: vector::empty(),
        };
    }
}
```

This PoC demonstrates the attack pattern: preliminary instructions consume gas, then PackGeneric triggers expensive type substitution that will fail gas charging after computation completes.

## Notes
This is a VM-level gas metering bug causing validator resource exhaustion, distinct from network-level DoS attacks which are out of scope. The vulnerability specifically affects the computational gas accounting mechanism, making it a valid High Severity issue under the Aptos bug bounty program's "Validator Node Slowdowns" category.

### Citations

**File:** third_party/move/move-vm/runtime/src/interpreter.rs (L2338-2347)
```rust
                    Instruction::PackGeneric(si_idx) => {
                        // TODO: Even though the types are not needed for execution, we still
                        //       instantiate them for gas metering.
                        //
                        //       This is a bit wasteful since the newly created types are
                        //       dropped immediately.
                        let field_tys = frame_cache.get_struct_fields_types(*si_idx, self)?;
                        for (_, ty_count) in field_tys {
                            gas_meter.charge_create_ty(*ty_count)?;
                        }
```

**File:** third_party/move/move-vm/runtime/src/frame_type_cache.rs (L163-182)
```rust
    pub(crate) fn get_struct_fields_types(
        &mut self,
        idx: StructDefInstantiationIndex,
        frame: &Frame,
    ) -> PartialVMResult<&[(Type, NumTypeNodes)]> {
        Ok(get_or_insert!(
            &mut self.struct_field_type_instantiation,
            idx,
            {
                frame
                    .instantiate_generic_struct_fields(idx)?
                    .into_iter()
                    .map(|ty| {
                        let num_nodes = NumTypeNodes::new(ty.num_nodes() as u64);
                        (ty, num_nodes)
                    })
                    .collect::<Vec<_>>()
            }
        ))
    }
```

**File:** third_party/move/move-vm/runtime/src/frame.rs (L406-458)
```rust
    pub(crate) fn instantiate_generic_struct_fields(
        &self,
        idx: StructDefInstantiationIndex,
    ) -> PartialVMResult<Vec<Type>> {
        use LoadedFunctionOwner::*;
        let struct_inst = match self.function.owner() {
            Module(module) => module.struct_instantiation_at(idx.0),
            Script(_) => unreachable!("Scripts cannot have type instructions"),
        };
        let struct_ty = &struct_inst.definition_struct_type;
        self.instantiate_generic_fields(struct_ty, None, &struct_inst.instantiation)
    }

    pub(crate) fn instantiate_generic_struct_variant_fields(
        &self,
        idx: StructVariantInstantiationIndex,
    ) -> PartialVMResult<Vec<Type>> {
        use LoadedFunctionOwner::*;
        let struct_inst = match self.function.owner() {
            Module(module) => module.struct_variant_instantiation_at(idx),
            Script(_) => unreachable!("Scripts cannot have type instructions"),
        };
        let struct_ty = &struct_inst.definition_struct_type;
        self.instantiate_generic_fields(
            struct_ty,
            Some(struct_inst.variant),
            &struct_inst.instantiation,
        )
    }

    pub(crate) fn instantiate_generic_fields(
        &self,
        struct_ty: &Arc<StructType>,
        variant: Option<VariantIndex>,
        instantiation: &[Type],
    ) -> PartialVMResult<Vec<Type>> {
        let instantiation_tys = instantiation
            .iter()
            .map(|inst_ty| {
                self.ty_builder
                    .create_ty_with_subst(inst_ty, self.function.ty_args())
            })
            .collect::<PartialVMResult<Vec<_>>>()?;

        struct_ty
            .fields(variant)?
            .iter()
            .map(|(_, inst_ty)| {
                self.ty_builder
                    .create_ty_with_subst(inst_ty, &instantiation_tys)
            })
            .collect::<PartialVMResult<Vec<_>>>()
    }
```

**File:** third_party/move/move-vm/types/src/loaded_data/runtime_types.rs (L1195-1203)
```rust
    fn check(&self, count: &mut u64, depth: u64) -> PartialVMResult<()> {
        if *count >= self.max_ty_size {
            return self.too_many_nodes_error();
        }
        if depth > self.max_ty_depth {
            return self.too_large_depth_error();
        }
        Ok(())
    }
```

**File:** third_party/move/move-vm/types/src/loaded_data/runtime_types.rs (L1339-1431)
```rust
    fn apply_subst<F, G>(
        ty: &Type,
        subst: F,
        count: &mut u64,
        depth: u64,
        check: G,
    ) -> PartialVMResult<Type>
    where
        F: Fn(u16, &mut u64, u64) -> PartialVMResult<Type> + Copy,
        G: Fn(&mut u64, u64) -> PartialVMResult<()> + Copy,
    {
        use Type::*;

        check(count, depth)?;
        *count += 1;
        Ok(match ty {
            TyParam(idx) => {
                // To avoid double-counting, revert counting the type parameter.
                *count -= 1;
                subst(*idx, count, depth)?
            },

            Bool => Bool,
            U8 => U8,
            U16 => U16,
            U32 => U32,
            U64 => U64,
            U128 => U128,
            U256 => U256,
            I8 => I8,
            I16 => I16,
            I32 => I32,
            I64 => I64,
            I128 => I128,
            I256 => I256,
            Address => Address,
            Signer => Signer,
            Vector(elem_ty) => {
                let elem_ty = Self::apply_subst(elem_ty, subst, count, depth + 1, check)?;
                Vector(TriompheArc::new(elem_ty))
            },
            Reference(inner_ty) => {
                let inner_ty = Self::apply_subst(inner_ty, subst, count, depth + 1, check)?;
                Reference(Box::new(inner_ty))
            },
            MutableReference(inner_ty) => {
                let inner_ty = Self::apply_subst(inner_ty, subst, count, depth + 1, check)?;
                MutableReference(Box::new(inner_ty))
            },
            Struct { idx, ability } => Struct {
                idx: *idx,
                ability: ability.clone(),
            },
            StructInstantiation {
                idx,
                ty_args: non_instantiated_tys,
                ability,
            } => {
                let mut instantiated_tys = vec![];
                for ty in non_instantiated_tys.iter() {
                    let ty = Self::apply_subst(ty, subst, count, depth + 1, check)?;
                    instantiated_tys.push(ty);
                }
                StructInstantiation {
                    idx: *idx,
                    ty_args: TriompheArc::new(instantiated_tys),
                    ability: ability.clone(),
                }
            },
            Function {
                args,
                results,
                abilities,
            } => {
                let subs_elem = |count: &mut u64, ty: &Type| -> PartialVMResult<Type> {
                    Self::apply_subst(ty, subst, count, depth + 1, check)
                };
                let args = args
                    .iter()
                    .map(|ty| subs_elem(count, ty))
                    .collect::<PartialVMResult<Vec<_>>>()?;
                let results = results
                    .iter()
                    .map(|ty| subs_elem(count, ty))
                    .collect::<PartialVMResult<Vec<_>>>()?;
                Function {
                    args,
                    results,
                    abilities: *abilities,
                }
            },
        })
    }
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/instr.rs (L166-166)
```rust
        [subst_ty_per_node: InternalGasPerTypeNode, { 14.. => "subst_ty_per_node" }, 400],
```

**File:** aptos-move/aptos-gas-meter/src/meter.rs (L541-549)
```rust
    fn charge_create_ty(&mut self, num_nodes: NumTypeNodes) -> PartialVMResult<()> {
        if self.feature_version() < 14 {
            return Ok(());
        }

        let cost = SUBST_TY_PER_NODE * num_nodes;

        self.algebra.charge_execution(cost)
    }
```
