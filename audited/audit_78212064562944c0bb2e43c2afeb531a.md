# Audit Report

## Title
Gas Estimation Cache Corruption via Incomplete Garbage Collection on Error Paths

## Summary
The gas estimation cache in `api/src/context.rs` can be corrupted when error conditions occur after cache entries are inserted but before cache metadata is updated. This leads to unbounded cache growth, incorrect garbage collection, and inconsistent gas price estimates that persist across API calls.

## Finding Description

The `estimate_gas_price` function in `api/src/context.rs` contains a critical flaw in its cache management logic. The function inserts entries into the cache but has multiple early return paths that bypass the cache metadata update, leaving the cache in an inconsistent state. [1](#0-0) 

The cache entries are inserted in the loop above, keyed by `(epoch, last)` version pairs. However, the function has two error paths that return early without updating the cache epoch: [2](#0-1) [3](#0-2) 

Both early returns occur AFTER cache insertions but BEFORE the cache metadata update: [4](#0-3) 

The cache cleanup logic only clears the cache when the epoch changes: [5](#0-4) 

**Attack Scenario:**
1. Attacker triggers gas estimation during edge conditions (e.g., empty blocks, epoch boundaries)
2. Cache entries get inserted at line 1378
3. Error condition causes early return at line 1418 or 1434
4. `last_updated_epoch` is NOT updated (still points to previous epoch or None)
5. On next call with same epoch, cache is NOT cleared (line 1320 condition fails)
6. More orphaned entries accumulate with each failed call
7. Cache size exceeds `max_block_history` without proper cleanup
8. Garbage collection at line 1450 removes wrong entries (mixes valid and invalid data)
9. Subsequent gas estimations use corrupted cache, returning incorrect prices

The cache structure stores entries with keys `(epoch, lookup_version)`: [6](#0-5) 

This breaks the **State Consistency** invariant (all state must be atomic and correct) and the **Resource Limits** invariant (cache can grow unbounded).

## Impact Explanation

This is a **Medium Severity** vulnerability per Aptos bug bounty criteria:

1. **State Inconsistencies**: The cache contains mixed valid/invalid entries, causing incorrect gas price estimates that persist across multiple API calls
2. **Resource Exhaustion**: Cache can grow beyond configured `max_block_history` limit, consuming excessive memory
3. **API Instability**: Corrupted cache causes unpredictable gas estimation results, affecting user transactions and potentially causing systematic underpricing or overpricing
4. **No Direct Funds Loss**: Does not directly steal funds or break consensus, but incorrect gas estimates can cause transaction failures or economic losses

This qualifies as "State inconsistencies requiring intervention" under Medium severity.

## Likelihood Explanation

**Likelihood: High**

This vulnerability is highly likely to occur because:

1. **Common Trigger Conditions**: Empty blocks, epoch transitions, or database read errors can trigger the error paths
2. **No Special Privileges Required**: Any API user can trigger gas estimation requests
3. **Persistent State**: Once corrupted, the cache remains inconsistent until epoch changes or node restart
4. **Production Conditions**: High load or network issues increase probability of hitting error paths
5. **Accumulative Effect**: Each failed call adds more corruption, making the issue progressively worse

The test suite validates normal operation but doesn't cover error path cache consistency: [7](#0-6) 

## Recommendation

Fix the issue by ensuring cache metadata is updated (or entries are rolled back) on ALL code paths, including error paths:

```rust
// Option 1: Update cache metadata before error paths
// Move update_cached_gas_estimation earlier and use a flag to track success

// Option 2: Rollback cache entries on error
// Save initial cache state and restore on early return

// Option 3: Use a transaction-like pattern
let initial_cache_size = cache.min_inclusion_prices.len();
let mut new_entries = Vec::new();

// Store entries to add instead of adding directly
for (first, last) in blocks {
    let min_inclusion_price = self
        .block_min_inclusion_price(ledger_info, first, last, config, &execution_config)
        .unwrap_or(min_gas_unit_price);
    min_inclusion_prices.push(min_inclusion_price);
    new_entries.push(((epoch, last), min_inclusion_price));
}

// ... validation logic ...

let market_price = match latest_prices.get(latest_prices.len() / 2) {
    None => {
        error!("prices empty...");
        // DO NOT add entries to cache on error
        return Ok(self.default_gas_estimation(min_gas_unit_price));
    },
    Some(price) => low_price.max(*price),
};

let p90_price = match min_inclusion_prices.get(min_inclusion_prices.len() * 9 / 10) {
    None => {
        error!("prices empty...");
        // DO NOT add entries to cache on error
        return Ok(self.default_gas_estimation(min_gas_unit_price));
    },
    Some(price) => market_price.max(*price),
};

// Only commit entries to cache after all validation passes
for (key, value) in new_entries {
    cache.min_inclusion_prices.insert(key, value);
}

// Now safe to update metadata and run GC
if cache.min_inclusion_prices.len() > max_block_history {
    for _i in max_block_history..cache.min_inclusion_prices.len() {
        cache.min_inclusion_prices.pop_first();
    }
}
self.update_cached_gas_estimation(&mut cache, epoch, estimation);
```

## Proof of Concept

```rust
#[tokio::test]
async fn test_gas_estimation_cache_corruption() {
    let mut node_config = NodeConfig::default();
    node_config.api.gas_estimation.enabled = true;
    node_config.api.gas_estimation.aggressive_block_history = 10;
    
    let context = new_test_context_with_config("test", node_config, false, false);
    
    // Create scenario that triggers error path:
    // 1. Create blocks with transactions
    // 2. Force empty price calculation (blocks without user transactions)
    // 3. Trigger gas estimation multiple times
    // 4. Verify cache size exceeds max_block_history
    
    for _ in 0..5 {
        context.commit_block(&[]).await; // Empty blocks
    }
    
    // This should hit error path at line 1418 or 1434
    let _ = context.get("/estimate_gas_price").await;
    
    // Check cache size - should be limited but will be larger due to orphaned entries
    let cache_size_1 = context.last_updated_gas_estimation_cache_size();
    
    // Repeat to accumulate corruption
    for _ in 0..8 {
        context.commit_block(&[]).await;
    }
    let _ = context.get("/estimate_gas_price").await;
    
    let cache_size_2 = context.last_updated_gas_estimation_cache_size();
    
    // Cache should be limited to 10 but will grow beyond due to orphaned entries
    assert!(cache_size_2 > 10, "Cache exceeded max_block_history due to incomplete GC");
}
```

**Notes:**

The vulnerability is located in the API layer's gas estimation caching mechanism, not in consensus-critical code. However, it still represents a real security issue because:

1. It can cause unbounded memory growth (DoS vector)
2. It produces incorrect gas estimates that affect user transactions
3. It violates the stated resource limits configuration
4. The corrupted state persists and accumulates over time

The fix requires ensuring atomicity of cache operations by either committing all changes together after validation, or rolling back partial changes on error paths.

### Citations

**File:** api/src/context.rs (L1318-1323)
```rust
        // Clear the cache if the epoch has changed
        if let Some(cached_epoch) = cache.last_updated_epoch {
            if cached_epoch != epoch {
                cache.min_inclusion_prices.clear();
            }
        }
```

**File:** api/src/context.rs (L1371-1378)
```rust
        for (first, last) in blocks {
            let min_inclusion_price = self
                .block_min_inclusion_price(ledger_info, first, last, config, &execution_config)
                .unwrap_or(min_gas_unit_price);
            min_inclusion_prices.push(min_inclusion_price);
            cache
                .min_inclusion_prices
                .insert((epoch, last), min_inclusion_price);
```

**File:** api/src/context.rs (L1409-1418)
```rust
        let market_price = match latest_prices.get(latest_prices.len() / 2) {
            None => {
                error!(
                    "prices empty, blocks.len={}, cached_blocks_hit={}, epoch={}, version={}",
                    blocks_len,
                    cached_blocks_hit,
                    ledger_info.epoch.0,
                    ledger_info.ledger_version.0
                );
                return Ok(self.default_gas_estimation(min_gas_unit_price));
```

**File:** api/src/context.rs (L1425-1435)
```rust
        let p90_price = match min_inclusion_prices.get(min_inclusion_prices.len() * 9 / 10) {
            None => {
                error!(
                    "prices empty, blocks.len={}, cached_blocks_hit={}, epoch={}, version={}",
                    blocks_len,
                    cached_blocks_hit,
                    ledger_info.epoch.0,
                    ledger_info.ledger_version.0
                );
                return Ok(self.default_gas_estimation(min_gas_unit_price));
            },
```

**File:** api/src/context.rs (L1453-1453)
```rust
        self.update_cached_gas_estimation(&mut cache, epoch, estimation);
```

**File:** api/src/context.rs (L1630-1636)
```rust
pub struct GasEstimationCache {
    last_updated_epoch: Option<u64>,
    last_updated_time: Option<Instant>,
    estimation: Option<GasEstimation>,
    /// (epoch, lookup_version) -> min_inclusion_price
    min_inclusion_prices: BTreeMap<(u64, u64), u64>,
}
```

**File:** api/src/tests/transactions_test.rs (L2322-2385)
```rust
async fn test_gas_estimation_cache(
    use_txn_payload_v2_format: bool,
    use_orderless_transactions: bool,
) {
    let mut node_config = NodeConfig::default();
    node_config.api.gas_estimation.enabled = true;
    // Sets max cache size to 10
    let max_block_history = 10;
    node_config.api.gas_estimation.low_block_history = max_block_history;
    node_config.api.gas_estimation.market_block_history = max_block_history;
    node_config.api.gas_estimation.aggressive_block_history = max_block_history;
    let sleep_duration =
        Duration::from_millis(node_config.api.gas_estimation.cache_expiration_ms * 2);
    let mut context = new_test_context_with_config(
        current_function_name!(),
        node_config,
        use_txn_payload_v2_format,
        use_orderless_transactions,
    );

    let ctx = &mut context;
    // First block is ignored in gas estimate, so expect 4 entries
    for _i in 0..5 {
        ctx.commit_block(&[]).await;
    }
    ctx.get("/estimate_gas_price").await;
    assert_eq!(ctx.last_updated_gas_estimation_cache_size(), 4);
    // Wait for cache to expire
    sleep(sleep_duration).await;

    // Expect max of 10 entries
    for _i in 0..8 {
        ctx.commit_block(&[]).await;
    }
    ctx.get("/estimate_gas_price").await;
    assert_eq!(
        ctx.last_updated_gas_estimation_cache_size(),
        max_block_history
    );
    // Wait for cache to expire
    sleep(sleep_duration).await;
    ctx.get("/estimate_gas_price").await;
    assert_eq!(
        ctx.last_updated_gas_estimation_cache_size(),
        max_block_history
    );

    // Expect max of 10 entries
    for _i in 0..8 {
        ctx.commit_block(&[]).await;
    }
    ctx.get("/estimate_gas_price").await;
    assert_eq!(
        ctx.last_updated_gas_estimation_cache_size(),
        max_block_history
    );
    // Wait for cache to expire
    sleep(sleep_duration).await;
    ctx.get("/estimate_gas_price").await;
    assert_eq!(
        ctx.last_updated_gas_estimation_cache_size(),
        max_block_history
    );
}
```
