# Audit Report

## Title
Gas Schedule Semantic Validation Bypass Enables Network-Wide Denial of Service

## Summary
The `FromOnChainGasSchedule` trait implementation lacks semantic validation of gas parameter relationships, allowing governance proposals to deploy gas schedules with internally inconsistent parameters (e.g., `min_price_per_gas_unit > max_price_per_gas_unit`) that cause complete network unavailability by making all transactions invalid.

## Finding Description

The gas schedule update mechanism has three layers of validation, but critically lacks semantic consistency checks:

**Layer 1 - On-Chain Move Validation** has explicit TODOs acknowledging missing consistency checks: [1](#0-0) [2](#0-1) 

The validation only checks: (1) non-empty blob, (2) feature version is non-decreasing. No semantic validation of parameter relationships exists.

**Layer 2 - Rust Parsing** uses a macro-generated implementation that only validates key existence: [3](#0-2) 

At line 40, the code performs direct `.into()` conversion from `u64` to gas types without any range or semantic validation. Missing parameters cause errors, but semantically invalid values pass through.

**Layer 3 - Runtime Validation** assumes parameters are semantically valid: [4](#0-3) 

The `check_gas` function validates transaction gas prices against `min_price_per_gas_unit` and `max_price_per_gas_unit` bounds, but never validates that min â‰¤ max.

**Attack Scenario:**

1. Attacker submits governance proposal with gas schedule where `min_price_per_gas_unit = 1000` and `max_price_per_gas_unit = 100`
2. Proposal passes on-chain validation (only checks non-empty blob + version)
3. Rust parsing succeeds (keys exist, values are valid u64s)
4. Proposal gets approved and applied via `on_new_epoch`: [5](#0-4) 

5. All subsequent transactions fail validation because no gas price can satisfy both `price >= 1000` AND `price <= 100`
6. Network experiences complete liveness failure

**Comparison with Predecessor:** The Diem framework (Aptos's predecessor) had explicit validation: [6](#0-5) 

This validation was not ported to Aptos, leaving the gap exploitable.

## Impact Explanation

**Severity: Critical** - Total loss of liveness/network availability

This vulnerability enables complete network DoS through a single malicious governance proposal. Once invalid gas parameters are deployed:
- All transaction submissions fail at validation layer
- No transactions can execute (transfers, staking, governance votes)
- Network becomes completely non-functional
- Recovery requires emergency governance proposal, which cannot be submitted due to the DoS

The impact qualifies as Critical under Aptos Bug Bounty criteria: "Total loss of liveness/network availability" and potentially "Non-recoverable network partition (requires hardfork)" if governance cannot be used to fix the issue.

Additional attack vectors include:
- `maximum_number_of_gas_units = 0`: All transactions exceed limit
- `gas_unit_scaling_factor = 0`: Division operations fail (has workaround at line 295 of transaction.rs, but inconsistent)
- `max_execution_gas = 0` or `max_io_gas = 0`: Immediate limit violations

## Likelihood Explanation

**Likelihood: Medium-High**

While this requires a governance proposal to exploit, the likelihood is elevated because:

1. **No validation exists**: The TODOs in the code explicitly acknowledge this gap
2. **Legitimate mistakes possible**: Even non-malicious governance proposals with typos/errors could trigger this
3. **Governance is permissionless**: Any stakeholder can submit proposals
4. **Historical precedent**: Diem had these validations, indicating they were deemed necessary
5. **No runtime detection**: Invalid parameters are only detected when transactions start failing

The main barrier is proposal approval, but a sophisticated attacker could craft a proposal that appears legitimate but contains subtle inconsistencies.

## Recommendation

Implement comprehensive semantic validation in `gas_schedule.move` before allowing parameter updates:

```move
public fun set_for_next_epoch(aptos_framework: &signer, gas_schedule_blob: vector<u8>) acquires GasScheduleV2 {
    system_addresses::assert_aptos_framework(aptos_framework);
    assert!(!vector::is_empty(&gas_schedule_blob), error::invalid_argument(EINVALID_GAS_SCHEDULE));
    
    let new_gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
    
    // ADDED: Validate semantic consistency
    validate_gas_schedule_consistency(&new_gas_schedule);
    
    if (exists<GasScheduleV2>(@aptos_framework)) {
        let cur_gas_schedule = borrow_global<GasScheduleV2>(@aptos_framework);
        assert!(
            new_gas_schedule.feature_version >= cur_gas_schedule.feature_version,
            error::invalid_argument(EINVALID_GAS_FEATURE_VERSION)
        );
    };
    config_buffer::upsert(new_gas_schedule);
}

fun validate_gas_schedule_consistency(schedule: &GasScheduleV2) {
    let map = entries_to_map(&schedule.entries);
    
    // Validate min <= max for price bounds
    let min_price = *table::borrow(&map, string::utf8(b"txn.min_price_per_gas_unit"));
    let max_price = *table::borrow(&map, string::utf8(b"txn.max_price_per_gas_unit"));
    assert!(min_price <= max_price, error::invalid_argument(EGAS_CONSTANT_INCONSISTENCY));
    
    // Validate min <= max for gas units
    let min_gas = *table::borrow(&map, string::utf8(b"txn.min_transaction_gas_units"));
    let max_gas = *table::borrow(&map, string::utf8(b"txn.maximum_number_of_gas_units"));
    assert!(min_gas <= max_gas, error::invalid_argument(EGAS_CONSTANT_INCONSISTENCY));
    
    // Validate critical non-zero parameters
    let scaling_factor = *table::borrow(&map, string::utf8(b"txn.gas_unit_scaling_factor"));
    assert!(scaling_factor > 0, error::invalid_argument(EINVALID_GAS_SCHEDULE));
    
    let max_gas_units = *table::borrow(&map, string::utf8(b"txn.maximum_number_of_gas_units"));
    assert!(max_gas_units > 0, error::invalid_argument(EINVALID_GAS_SCHEDULE));
}
```

Additional validations should be added for execution/IO gas limits, storage parameters, and any other interdependent parameters.

## Proof of Concept

```move
#[test(framework = @0x1)]
#[expected_failure(abort_code = 0x010001, location = aptos_framework::gas_schedule)]
fun test_invalid_gas_price_bounds_should_abort(framework: signer) {
    use aptos_framework::gas_schedule;
    use std::bcs;
    
    // Create gas schedule with inverted price bounds
    let mut entries = vector::empty();
    vector::push_back(&mut entries, gas_schedule::GasEntry {
        key: string::utf8(b"txn.min_price_per_gas_unit"),
        val: 1000  // min > max
    });
    vector::push_back(&mut entries, gas_schedule::GasEntry {
        key: string::utf8(b"txn.max_price_per_gas_unit"),
        val: 100
    });
    
    let invalid_schedule = gas_schedule::GasScheduleV2 {
        feature_version: 1,
        entries
    };
    
    // This should abort with EINVALID_GAS_SCHEDULE after adding validation
    gas_schedule::set_for_next_epoch(&framework, bcs::to_bytes(&invalid_schedule));
}

#[test(framework = @0x1, user = @0x42)]
fun test_dos_attack_with_invalid_gas_schedule(framework: signer, user: signer) {
    // Setup: Deploy invalid gas schedule (currently passes)
    let mut entries = vector::empty();
    // ... populate with inverted bounds ...
    gas_schedule::set_for_next_epoch(&framework, bcs::to_bytes(&invalid_schedule));
    aptos_governance::reconfigure(&framework);
    
    // Attack: Try to submit any transaction
    let account = account::create_account_for_test(@0x42);
    
    // This will fail validation because no gas price satisfies min > max
    aptos_coin::transfer(&user, @0x1, 100);  // Should abort with gas price validation error
}
```

**Notes:**
- The vulnerability exists due to incomplete validation migration from Diem to Aptos
- The TODOs in gas_schedule.move acknowledge this gap but it remains unfixed
- This affects consensus determinism (invariant #1) if nodes somehow load different gas parameters
- Recovery from such an attack may require coordinated hardfork if governance is non-functional

### Citations

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L47-48)
```text
        // TODO(Gas): check if gas schedule is consistent
        let gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L91-103)
```text
    public fun set_for_next_epoch(aptos_framework: &signer, gas_schedule_blob: vector<u8>) acquires GasScheduleV2 {
        system_addresses::assert_aptos_framework(aptos_framework);
        assert!(!vector::is_empty(&gas_schedule_blob), error::invalid_argument(EINVALID_GAS_SCHEDULE));
        let new_gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
        if (exists<GasScheduleV2>(@aptos_framework)) {
            let cur_gas_schedule = borrow_global<GasScheduleV2>(@aptos_framework);
            assert!(
                new_gas_schedule.feature_version >= cur_gas_schedule.feature_version,
                error::invalid_argument(EINVALID_GAS_FEATURE_VERSION)
            );
        };
        config_buffer::upsert(new_gas_schedule);
    }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L135-145)
```text
    public(friend) fun on_new_epoch(framework: &signer) acquires GasScheduleV2 {
        system_addresses::assert_aptos_framework(framework);
        if (config_buffer::does_exist<GasScheduleV2>()) {
            let new_gas_schedule = config_buffer::extract_v2<GasScheduleV2>();
            if (exists<GasScheduleV2>(@aptos_framework)) {
                *borrow_global_mut<GasScheduleV2>(@aptos_framework) = new_gas_schedule;
            } else {
                move_to(framework, new_gas_schedule);
            }
        }
    }
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/macros.rs (L32-46)
```rust
        impl $crate::traits::FromOnChainGasSchedule for $params_name {
            #[allow(unused)]
            fn from_on_chain_gas_schedule(gas_schedule: &std::collections::BTreeMap<String, u64>, feature_version: u64) -> Result<Self, String> {
                let mut params = $params_name::zeros();

                $(
                    if let Some(key) = $crate::gas_schedule::macros::define_gas_parameters_extract_key_at_version!($key_bindings, feature_version) {
                        let name = format!("{}.{}", $prefix, key);
                        params.$name = gas_schedule.get(&name).cloned().ok_or_else(|| format!("Gas parameter {} does not exist. Feature version: {}.", name, feature_version))?.into();
                    }
                )*

                Ok(params)
            }
        }
```

**File:** aptos-move/aptos-vm/src/gas.rs (L174-208)
```rust
    // The submitted gas price is less than the minimum gas unit price set by the VM.
    // NB: MIN_PRICE_PER_GAS_UNIT may equal zero, but need not in the future. Hence why
    // we turn off the clippy warning.
    #[allow(clippy::absurd_extreme_comparisons)]
    let below_min_bound = txn_metadata.gas_unit_price() < txn_gas_params.min_price_per_gas_unit;
    if below_min_bound {
        speculative_warn!(
            log_context,
            format!(
                "[VM] Gas unit error; min {}, submitted {}",
                txn_gas_params.min_price_per_gas_unit,
                txn_metadata.gas_unit_price()
            ),
        );
        return Err(VMStatus::error(
            StatusCode::GAS_UNIT_PRICE_BELOW_MIN_BOUND,
            None,
        ));
    }

    // The submitted gas price is greater than the maximum gas unit price set by the VM.
    if txn_metadata.gas_unit_price() > txn_gas_params.max_price_per_gas_unit {
        speculative_warn!(
            log_context,
            format!(
                "[VM] Gas unit error; max {}, submitted {}",
                txn_gas_params.max_price_per_gas_unit,
                txn_metadata.gas_unit_price()
            ),
        );
        return Err(VMStatus::error(
            StatusCode::GAS_UNIT_PRICE_ABOVE_MAX_BOUND,
            None,
        ));
    }
```

**File:** third_party/move/move-examples/diem-framework/move-packages/DPN/sources/DiemVMConfig.move (L154-161)
```text
        assert!(
            min_price_per_gas_unit <= max_price_per_gas_unit,
            errors::invalid_argument(EGAS_CONSTANT_INCONSISTENCY)
        );
        assert!(
            min_transaction_gas_units <= maximum_number_of_gas_units,
            errors::invalid_argument(EGAS_CONSTANT_INCONSISTENCY)
        );
```
