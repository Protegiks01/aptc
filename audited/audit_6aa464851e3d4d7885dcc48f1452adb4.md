# Audit Report

## Title
Inconsistent Default Behavior for JWK Consensus Configuration When On-Chain Resources Are Missing

## Summary
When the `Features` on-chain resource is missing, there is an inconsistency between the main consensus epoch manager and the JWK consensus epoch manager in determining whether JWK consensus should be enabled. This discrepancy causes the JWK consensus manager to run when main consensus expects it to be disabled, leading to resource waste and potential proposal rejection.

## Finding Description

The vulnerability stems from different default handling of missing `Features` resources between two critical components:

**Main Consensus Epoch Manager** uses `equivalent_jwk_consensus_config_from_deprecated_resources()`: [1](#0-0) 

This function retrieves `Features` as `Option` and passes it to the conversion: [2](#0-1) 

When `Features` is `None`, it returns `OnChainJWKConsensusConfig::Off` (line 128-129), meaning JWK consensus is **disabled**.

**JWK Consensus Epoch Manager** uses a different fallback: [3](#0-2) 

Line 172 uses `.unwrap_or_default()` which creates a default `Features` instance. The default Features has JWK_CONSENSUS **enabled**: [4](#0-3) 

This causes `should_run = true` (line 190-191) when main consensus expects JWK consensus to be off.

**Impact Chain:**

1. When `Features` resource is missing, main consensus creates `OnChainJWKConsensusConfig::Off`
2. Main consensus uses this to validate proposals via `is_vtxn_expected()`: [5](#0-4) 

3. Proposals with `ObservedJWKUpdate` validator transactions are **rejected** (line 22 returns false)
4. However, JWK consensus manager starts running and may produce such transactions
5. These transactions get rejected, causing wasted resources and potential liveness degradation

## Impact Explanation

This issue qualifies as **Medium Severity** under the "State inconsistencies requiring intervention" category because:

1. **Internal State Inconsistency**: Two subsystems have contradictory views of whether JWK consensus is enabled
2. **Resource Waste**: JWK consensus manager spawns observers and runs consensus rounds unnecessarily
3. **Proposal Rejection Risk**: If `SupportedOIDCProviders` exists while `Features` is missing, the JWK manager runs with real providers, produces `ObservedJWKUpdate` transactions, but main consensus rejects all proposals containing them
4. **Requires Manual Intervention**: This state can only be resolved by properly initializing the `Features` resource through governance

While all validators make the same incorrect decision (preventing consensus splits), the inconsistency violates the principle that system components should have coherent views of configuration state.

## Likelihood Explanation

**Likelihood: Low to Medium**

This can occur in scenarios such as:
- Genesis initialization race conditions where resources are published in specific orders
- Governance proposal errors that remove or fail to initialize `Features` 
- Network upgrades with improper resource migration
- Testing/development environments with incomplete state

While validators cannot be directly attacked to trigger this, operational errors or edge cases during critical system transitions make this realistic enough to warrant attention.

## Recommendation

Both epoch managers should use identical logic for determining JWK consensus configuration. The recommended fix is for the JWK consensus epoch manager to call the same conversion function:

```rust
// In crates/aptos-jwk-consensus/src/epoch_manager.rs, line 188-195
Err(_) => {
    // Use the same logic as main consensus
    let equivalent_config = OnChainJWKConsensusConfig::from((
        payload.get::<Features>().ok(),
        payload.get::<SupportedOIDCProviders>().ok()
    ));
    let should_run = equivalent_config.jwk_consensus_enabled() 
        && onchain_consensus_config.is_vtxn_enabled();
    let providers = if should_run {
        Some(SupportedOIDCProviders { 
            providers: equivalent_config.oidc_providers_cloned()
                .into_iter()
                .map(jwks::OIDCProvider::from)
                .collect()
        })
    } else {
        None
    };
    (should_run, providers)
}
```

This ensures both managers use consistent defaults when resources are missing.

## Proof of Concept

The inconsistency can be demonstrated by tracing through the code when `Features` is missing:

1. Main consensus: `features = payload.get::<Features>().ok()` → `None`
2. Main consensus: `OnChainJWKConsensusConfig::from((None, oidc_providers))` → goes to else branch → returns `Off`
3. JWK consensus: `features = payload.get::<Features>().unwrap_or_default()` → returns Features with JWK_CONSENSUS enabled
4. JWK consensus: `should_run = features.is_enabled(FeatureFlag::JWK_CONSENSUS)` → `true`

The test in `consensus/src/round_manager_tests/vtxn_on_proposal_test.rs` demonstrates that proposals are rejected when config is disabled: [6](#0-5) 

Lines 100-106 show that with `default_disabled()`, the proposal is rejected (`expected_result: false`).

## Notes

This vulnerability represents an internal consistency violation rather than a direct attack vector. All validators experience the same inconsistency (preventing consensus forks), but the mismatch between subsystems creates operational risks during resource initialization or migration scenarios. The fix should ensure both consensus and JWK consensus managers use identical default logic when on-chain resources are missing.

### Citations

**File:** consensus/src/epoch_manager.rs (L1963-1969)
```rust
    fn equivalent_jwk_consensus_config_from_deprecated_resources(
        payload: &OnChainConfigPayload<P>,
    ) -> OnChainJWKConsensusConfig {
        let features = payload.get::<Features>().ok();
        let oidc_providers = payload.get::<SupportedOIDCProviders>().ok();
        OnChainJWKConsensusConfig::from((features, oidc_providers))
    }
```

**File:** types/src/on_chain_config/jwk_consensus_config.rs (L112-131)
```rust
impl From<(Option<Features>, Option<SupportedOIDCProviders>)> for OnChainJWKConsensusConfig {
    fn from(
        (features, supported_oidc_providers): (Option<Features>, Option<SupportedOIDCProviders>),
    ) -> Self {
        if let Some(features) = features {
            if features.is_enabled(FeatureFlag::JWK_CONSENSUS) {
                let oidc_providers = supported_oidc_providers
                    .unwrap_or_default()
                    .providers
                    .into_iter()
                    .filter_map(|deprecated| OIDCProvider::try_from(deprecated).ok())
                    .collect();
                OnChainJWKConsensusConfig::V1(ConfigV1 { oidc_providers })
            } else {
                OnChainJWKConsensusConfig::Off
            }
        } else {
            OnChainJWKConsensusConfig::Off
        }
    }
```

**File:** crates/aptos-jwk-consensus/src/epoch_manager.rs (L172-195)
```rust
        let features = payload.get::<Features>().unwrap_or_default();
        let jwk_consensus_config = payload.get::<OnChainJWKConsensusConfig>();
        let onchain_observed_jwks = payload.get::<ObservedJWKs>().ok();
        let onchain_consensus_config = payload.get::<OnChainConsensusConfig>().unwrap_or_default();

        let (jwk_manager_should_run, oidc_providers) = match jwk_consensus_config {
            Ok(config) => {
                let should_run =
                    config.jwk_consensus_enabled() && onchain_consensus_config.is_vtxn_enabled();
                let providers = config
                    .oidc_providers_cloned()
                    .into_iter()
                    .map(jwks::OIDCProvider::from)
                    .collect();
                (should_run, Some(SupportedOIDCProviders { providers }))
            },
            Err(_) => {
                //TODO: remove this case once the framework change of this commit is published.
                let should_run = features.is_enabled(FeatureFlag::JWK_CONSENSUS)
                    && onchain_consensus_config.is_vtxn_enabled();
                let providers = payload.get::<SupportedOIDCProviders>().ok();
                (should_run, providers)
            },
        };
```

**File:** types/src/on_chain_config/aptos_features.rs (L171-221)
```rust
    pub fn default_features() -> Vec<Self> {
        vec![
            FeatureFlag::CODE_DEPENDENCY_CHECK,
            FeatureFlag::TREAT_FRIEND_AS_PRIVATE,
            FeatureFlag::SHA_512_AND_RIPEMD_160_NATIVES,
            FeatureFlag::APTOS_STD_CHAIN_ID_NATIVES,
            // Feature flag V6 is used to enable metadata v1 format and needs to stay on, even
            // if we enable a higher version.
            FeatureFlag::VM_BINARY_FORMAT_V6,
            FeatureFlag::VM_BINARY_FORMAT_V7,
            FeatureFlag::MULTI_ED25519_PK_VALIDATE_V2_NATIVES,
            FeatureFlag::BLAKE2B_256_NATIVE,
            FeatureFlag::RESOURCE_GROUPS,
            FeatureFlag::MULTISIG_ACCOUNTS,
            FeatureFlag::DELEGATION_POOLS,
            FeatureFlag::CRYPTOGRAPHY_ALGEBRA_NATIVES,
            FeatureFlag::BLS12_381_STRUCTURES,
            FeatureFlag::ED25519_PUBKEY_VALIDATE_RETURN_FALSE_WRONG_LENGTH,
            FeatureFlag::STRUCT_CONSTRUCTORS,
            FeatureFlag::PERIODICAL_REWARD_RATE_DECREASE,
            FeatureFlag::PARTIAL_GOVERNANCE_VOTING,
            FeatureFlag::_SIGNATURE_CHECKER_V2,
            FeatureFlag::STORAGE_SLOT_METADATA,
            FeatureFlag::CHARGE_INVARIANT_VIOLATION,
            FeatureFlag::DELEGATION_POOL_PARTIAL_GOVERNANCE_VOTING,
            FeatureFlag::APTOS_UNIQUE_IDENTIFIERS,
            FeatureFlag::GAS_PAYER_ENABLED,
            FeatureFlag::BULLETPROOFS_NATIVES,
            FeatureFlag::SIGNER_NATIVE_FORMAT_FIX,
            FeatureFlag::MODULE_EVENT,
            FeatureFlag::EMIT_FEE_STATEMENT,
            FeatureFlag::STORAGE_DELETION_REFUND,
            FeatureFlag::SIGNATURE_CHECKER_V2_SCRIPT_FIX,
            FeatureFlag::AGGREGATOR_V2_API,
            FeatureFlag::SAFER_RESOURCE_GROUPS,
            FeatureFlag::SAFER_METADATA,
            FeatureFlag::SINGLE_SENDER_AUTHENTICATOR,
            FeatureFlag::SPONSORED_AUTOMATIC_ACCOUNT_V1_CREATION,
            FeatureFlag::FEE_PAYER_ACCOUNT_OPTIONAL,
            FeatureFlag::AGGREGATOR_V2_DELAYED_FIELDS,
            FeatureFlag::CONCURRENT_TOKEN_V2,
            FeatureFlag::LIMIT_MAX_IDENTIFIER_LENGTH,
            FeatureFlag::OPERATOR_BENEFICIARY_CHANGE,
            FeatureFlag::BN254_STRUCTURES,
            FeatureFlag::RESOURCE_GROUPS_SPLIT_IN_VM_CHANGE_SET,
            FeatureFlag::COMMISSION_CHANGE_DELEGATION_POOL,
            FeatureFlag::WEBAUTHN_SIGNATURE,
            FeatureFlag::KEYLESS_ACCOUNTS,
            FeatureFlag::FEDERATED_KEYLESS,
            FeatureFlag::KEYLESS_BUT_ZKLESS_ACCOUNTS,
            FeatureFlag::JWK_CONSENSUS,
```

**File:** consensus/src/util/mod.rs (L15-24)
```rust
pub fn is_vtxn_expected(
    randomness_config: &OnChainRandomnessConfig,
    jwk_consensus_config: &OnChainJWKConsensusConfig,
    vtxn: &ValidatorTransaction,
) -> bool {
    match vtxn {
        ValidatorTransaction::DKGResult(_) => randomness_config.randomness_enabled(),
        ValidatorTransaction::ObservedJWKUpdate(_) => jwk_consensus_config.jwk_consensus_enabled(),
    }
}
```

**File:** consensus/src/round_manager_tests/vtxn_on_proposal_test.rs (L94-115)
```rust
#[test]
fn no_vote_on_proposal_with_unexpected_vtxns() {
    let vtxns = vec![ValidatorTransaction::ObservedJWKUpdate(
        QuorumCertifiedUpdate::dummy(),
    )];

    assert_process_proposal_result(
        None,
        None,
        Some(OnChainJWKConsensusConfig::default_disabled()),
        vtxns.clone(),
        false,
    );

    assert_process_proposal_result(
        None,
        None,
        Some(OnChainJWKConsensusConfig::default_enabled()),
        vtxns,
        true,
    );
}
```
