# Audit Report

## Title
Extended Security Checks Bypass via Hidden Experiment Flag Allows Deployment of Vulnerable Packages

## Summary
The `SKIP_BAILOUT_ON_EXTENDED_CHECKS` experiment flag, accessible via the hidden `--experiments` CLI parameter, can be exploited to bypass critical security validations during Move package compilation, allowing deployment of packages with known security vulnerabilities including unsafe randomness usage, invalid entry functions, and malformed module initialization code.

## Finding Description

The vulnerability exists in the package building pipeline where extended security checks can be completely bypassed through a user-controllable experiment flag.

**Attack Path:**

1. A developer compiles a Move package with security issues using the Aptos CLI
2. The developer adds `--experiments skip-bailout-on-extended-checks` to bypass security validations
3. The package builds successfully despite containing security vulnerabilities
4. The package is deployed on-chain with exploitable code

**Code Flow:**

The experiments flag is exposed through the CLI at: [1](#0-0) 

These experiments are passed into the build system: [2](#0-1) 

During package building, the critical security bypass occurs: [3](#0-2) 

When `SKIP_BAILOUT_ON_EXTENDED_CHECKS` is enabled, the condition at line 312-316 evaluates to false, causing the entire error-checking block to be skipped. This means:
- Security diagnostics are not reported to the user
- The `bail!("extended checks failed")` at line 321 is never reached
- Compilation proceeds despite critical security errors

**Extended Checks That Can Be Bypassed:**

The experiment is defined as "for testing only": [4](#0-3) 

The extended checks perform critical security validations: [5](#0-4) 

Most critically, the randomness safety check prevents a severe vulnerability: [6](#0-5) 

This check prevents public functions from exposing randomness features, which would allow attackers to bias randomness by controlling transaction timing. When bypassed, such vulnerable code can be deployed and exploited for randomness manipulation attacks.

**Broken Invariants:**

1. **Move VM Safety**: The extended checks are part of the Move safety guarantees. Bypassing them violates the principle that all deployed code must pass security validation.

2. **Access Control**: The system should enforce that only secure, validated code can be deployed. This bypass allows deployment of code that fails security checks.

3. **Deterministic Execution**: Packages with bypassed init_module checks or invalid entry functions could cause non-deterministic behavior or execution failures across validators.

## Impact Explanation

This vulnerability qualifies as **High Severity** per the Aptos bug bounty program for the following reasons:

**Significant Protocol Violation**: The extended checks system is a critical security layer designed to prevent deployment of vulnerable contracts. Bypassing these checks undermines the entire security validation framework.

**Concrete Attack Scenarios:**

1. **Randomness Manipulation**: An attacker deploys a contract with public functions exposing randomness features (bypassing the check at line 634-644 of extended_checks.rs). The attacker can then manipulate randomness outcomes by controlling when they submit transactions, potentially winning lotteries, gaming prediction markets, or manipulating on-chain random outcomes.

2. **Invalid Entry Functions**: Deployment of entry functions with invalid parameter types could cause transaction failures that affect other users or create denial-of-service conditions.

3. **Malformed Module Initialization**: Bypassing init_module validation could result in modules that fail to initialize properly, leading to state inconsistencies.

While this doesn't directly cause loss of funds or consensus violations, it enables deployment of code that can be exploited for such purposes, particularly in randomness-based applications.

## Likelihood Explanation

**Likelihood: Medium-High**

The vulnerability is easily exploitable but requires active misuse:

1. **Easy to Exploit**: The flag is a simple CLI parameter. A malicious developer only needs to add `--experiments skip-bailout-on-extended-checks` to their build command.

2. **Hidden but Accessible**: While the flag is marked as hidden in the CLI, it's still functional and accessible to anyone with access to the build process.

3. **Intentional Misuse Required**: The attack requires deliberate action by the developer/deployer. However, scenarios include:
   - Malicious developers intentionally deploying vulnerable code
   - Developers under pressure to deploy despite warnings
   - Compromised build processes where an attacker adds the flag
   - Developers who don't understand the security implications

4. **No Additional Safeguards**: There are no warnings when using this flag, no additional confirmations required, and no on-chain re-validation of the bypassed checks.

## Recommendation

**Primary Fix**: Remove the ability to set `SKIP_BAILOUT_ON_EXTENDED_CHECKS` through user input for production builds:

```rust
// In crates/aptos/src/common/types.rs, modify compute_experiments():
pub fn compute_experiments(&self) -> Vec<String> {
    let mut experiments = self.experiments.clone();
    
    // Prevent use of testing-only experiments in production
    let forbidden_experiments = ["skip-bailout-on-extended-checks"];
    experiments.retain(|exp| {
        let exp_name = exp.split('=').next().unwrap_or(exp);
        if forbidden_experiments.contains(&exp_name) {
            eprintln!("Warning: Experiment '{}' is for testing only and has been removed", exp_name);
            false
        } else {
            true
        }
    });
    
    // ... rest of the function
}
```

**Alternative Fix**: Add explicit production-mode detection and warning:

```rust
// In aptos-move/framework/src/built_package.rs, before the skip check:
if let Some(model_options) = model.get_extension::<Options>() {
    if model_options.experiment_on(Experiment::SKIP_BAILOUT_ON_EXTENDED_CHECKS) {
        eprintln!("\n⚠️  WARNING: SKIP_BAILOUT_ON_EXTENDED_CHECKS is enabled!");
        eprintln!("⚠️  This bypasses critical security checks and should NEVER be used for production deployment!");
        eprintln!("⚠️  Press Ctrl+C to abort or wait 10 seconds to continue...\n");
        std::thread::sleep(std::time::Duration::from_secs(10));
    }
}
```

**Defense in Depth**: Add runtime validation in the Move VM to re-check critical properties like randomness safety when modules are published on-chain, providing a second layer of defense.

## Proof of Concept

**Step 1**: Create a vulnerable Move package with a public function exposing randomness:

```move
// File: sources/vulnerable.move
module deployer::vulnerable {
    use aptos_framework::randomness;
    
    // This violates randomness safety - public function exposing randomness
    public fun get_random_number(): u64 {
        randomness::u64_integer()
    }
}
```

**Step 2**: Attempt normal compilation (should fail):

```bash
aptos move compile --package-dir ./vulnerable_package
```

Expected output: Error from extended checks about public function exposing randomness features.

**Step 3**: Bypass security checks using the hidden experiment flag:

```bash
aptos move compile --package-dir ./vulnerable_package --experiments skip-bailout-on-extended-checks
```

Expected output: Compilation succeeds despite the security violation.

**Step 4**: Deploy the vulnerable package:

```bash
aptos move publish --package-dir ./vulnerable_package \
  --experiments skip-bailout-on-extended-checks \
  --profile default
```

Result: The vulnerable package is deployed on-chain and can be exploited for randomness manipulation attacks.

**Validation**: This PoC demonstrates that critical security checks can be bypassed through a user-accessible CLI flag, allowing deployment of code that violates security invariants.

## Notes

This vulnerability is particularly concerning because:

1. **Silent Bypass**: There are no warnings or confirmations when using this experiment flag
2. **Production Impact**: The flag is documented as "for testing only" but is fully functional in production builds
3. **Multiple Vulnerabilities**: It bypasses ALL extended checks, not just warnings, including critical security validations for randomness, entry functions, view functions, resource groups, init modules, and event emissions
4. **Diagnostic System Behavior**: The `diag_count(Severity::Warning)` check at line 1237 of model.rs counts all diagnostics with severity >= Warning, meaning it includes both warnings and errors. When the experiment is enabled, both warning reporting and error bailout are skipped.

### Citations

**File:** crates/aptos/src/common/types.rs (L1250-1252)
```rust
    /// Experiments
    #[clap(long, hide(true), num_args = 1.., value_delimiter = ',')]
    pub experiments: Vec<String>,
```

**File:** crates/aptos/src/move_tool/mod.rs (L941-956)
```rust
        let mut experiments = move_options.compute_experiments();
        experiments.append(&mut more_experiments);

        let base_options = BuildOptions {
            dev,
            // Always enable error map bytecode injection
            with_error_map: true,
            named_addresses,
            override_std,
            skip_fetch_latest_git_deps,
            bytecode_version,
            compiler_version,
            language_version,
            skip_attribute_checks,
            check_test_code,
            experiments,
```

**File:** aptos-move/framework/src/built_package.rs (L311-323)
```rust
            if model.diag_count(Severity::Warning) > 0
                && !model
                    .get_extension::<Options>()
                    .is_some_and(|model_options| {
                        model_options.experiment_on(Experiment::SKIP_BAILOUT_ON_EXTENDED_CHECKS)
                    })
            {
                let mut error_writer = StandardStream::stderr(ColorChoice::Auto);
                model.report_diag(&mut error_writer, Severity::Warning);
                if model.has_errors() {
                    bail!("extended checks failed")
                }
            }
```

**File:** third_party/move/move-compiler-v2/src/experiments.rs (L283-287)
```rust
            name: Experiment::SKIP_BAILOUT_ON_EXTENDED_CHECKS.to_string(),
            description: "Skip errors originating from extended checks, for testing only"
                .to_string(),
            default: Given(false),
        },
```

**File:** aptos-move/framework/src/extended_checks.rs (L117-131)
```rust
    fn run(&mut self) {
        for ref module in self.env.get_modules() {
            if module.is_primary_target() {
                self.check_and_record_resource_groups(module);
                self.check_and_record_resource_group_members(module);
                self.check_and_record_view_functions(module);
                self.check_entry_functions(module);
                self.check_and_record_unbiasabale_entry_functions(module);
                self.check_unsafe_randomness_usage(module);
                self.check_and_record_events(module);
                self.check_init_module(module);
                self.build_error_map(module)
            }
        }
    }
```

**File:** aptos-move/framework/src/extended_checks.rs (L606-647)
```rust
    /// Checks unsafe usage of the randomness feature for the given module.
    ///
    /// 1. Checks that no public function in the module calls randomness features. An
    ///    attribute can be used to override this check.
    /// 2. Check that every private entry function which uses randomness
    ///    features has the #[randomness] attribute
    fn check_unsafe_randomness_usage(&mut self, module: &ModuleEnv) {
        for ref fun in module.get_functions() {
            let fun_id = fun.module_env.get_id().qualified(fun.get_id());
            // Check condition (2)
            if !fun.visibility().is_public() && fun.is_entry() {
                if !self.has_attribute(fun, RANDOMNESS_ATTRIBUTE) && self.calls_randomness(fun_id) {
                    self.env.error(
                        &fun.get_id_loc(),
                        "entry function calling randomness features must \
                    use the `#[randomness]` attribute.",
                    )
                }
                continue;
            }
            // Check condition (1) only if function is public and if the check is not disabled.
            // Also, only check functions which are not declared in the framework.
            if self.is_framework_function(fun_id)
                || !fun.visibility().is_public()
                || self.has_attribute(fun, ALLOW_UNSAFE_RANDOMNESS_ATTRIBUTE)
            {
                continue;
            }
            if self.calls_randomness(fun_id) {
                self.env.error(
                    &fun.get_id_loc(),
                    &format!(
                        "public function exposes functionality of the `randomness` module \
                    which can be unsafe. Consult the randomness documentation for an explanation \
                    of this error. To skip this check, add \
                    attribute `#[{}]`.",
                        ALLOW_UNSAFE_RANDOMNESS_ATTRIBUTE
                    ),
                )
            }
        }
    }
```
