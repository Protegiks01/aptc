# Audit Report

## Title
Unlimited Brute-Force Attack Against Admin Service Authentication Due to Missing Rate Limiting

## Summary
The Aptos admin service authentication mechanism lacks rate limiting and account lockout for failed passcode attempts, allowing attackers to perform unlimited brute-force attacks against the SHA256 passcode hash to gain unauthorized access to sensitive validator debugging endpoints.

## Finding Description
The admin service implements authentication via SHA256-hashed passcodes passed as query parameters. [1](#0-0) 

The authentication logic iterates through configured authentication methods and grants access if any passcode matches. However, there are **critical security gaps**:

1. **No Rate Limiting**: The authentication check has no restrictions on the number of attempts an attacker can make
2. **No Account Lockout**: Failed authentication attempts never trigger blocking or throttling
3. **No Logging**: Failed attempts are not logged, preventing detection and incident response
4. **Fast Hash Function**: SHA256 is designed for speed, not password security, enabling rapid guessing

An attacker can exploit this by:
1. Making continuous HTTP requests to any admin endpoint (e.g., `/profilez?passcode=guess1`, `/profilez?passcode=guess2`, etc.)
2. Testing common passwords from dictionaries (e.g., "admin123", "password", "aptos2024")
3. Running the attack slowly to avoid network-level detection
4. Eventually gaining access once the correct passcode is guessed

Once authenticated, the attacker gains access to highly sensitive endpoints that expose:
- Consensus database dumps (voting history, blocks, quorum certificates) [2](#0-1) 
- Quorum store transaction batches [3](#0-2) 
- Block transaction data [4](#0-3) 
- Mempool parking lot addresses [5](#0-4) 
- CPU profiling, thread dumps, and memory statistics [6](#0-5) 

This breaks the **Access Control** invariant requiring that system administrative interfaces only be accessible to authorized operators.

## Impact Explanation
This vulnerability meets **Medium Severity** criteria per the Aptos bug bounty program:

- **Information Disclosure**: Unauthorized access to sensitive internal validator state including consensus voting patterns, pending transactions, and node performance characteristics
- **Attack Facilitation**: Exposed consensus data could help sophisticated attackers understand validator behavior patterns and timing for more advanced attacks
- **Privacy Violation**: Transaction data in mempool/consensus DBs may be exposed before public commitment
- **Operational Security**: Profiling data reveals node performance characteristics useful for DoS planning

While this does not directly cause loss of funds or consensus violations, it significantly weakens the security posture of validator nodes by exposing internal state meant only for authorized operators. The configuration sanitizer enforces authentication on mainnet [7](#0-6) , indicating the intended security requirement that this vulnerability bypasses.

## Likelihood Explanation
**Likelihood: High**

- **Low Attack Complexity**: Standard brute-force tools can be trivially adapted for this attack
- **No Special Access Required**: Only network access to the admin service port (default 9102) is needed
- **Weak Passcode Likely**: Human-memorable passcodes are often weak and in common dictionaries
- **No Detection Mechanism**: Lack of logging means attacks go unnoticed until successful
- **Fast Hash Function**: SHA256 allows testing thousands of passwords per second on modest hardware
- **Persistent Attack**: Attackers can run low-rate attacks indefinitely without triggering alarms

The Aptos codebase contains a rate limiting library (`aptos-rate-limiter`) but it is **not integrated** with the admin service, confirming this protection is absent by design oversight rather than intentional.

## Recommendation

Implement comprehensive authentication security controls:

**1. Add Rate Limiting per Source IP:**
```rust
// In Context struct, add:
use aptos_rate_limiter::{AsyncRateLimiter, Bucket};
use std::net::IpAddr;

auth_rate_limiter: AsyncRateLimiter<IpAddr>,

// In serve_requests(), before authentication:
let remote_addr = /* extract from connection */;
if !context.auth_rate_limiter.try_consume(remote_addr, 1).await {
    return Ok(reply_with_status(
        StatusCode::TOO_MANY_REQUESTS,
        "Rate limit exceeded. Try again later.",
    ));
}
```

**2. Implement Account Lockout:**
- Track failed attempts per IP address
- Lock out IPs after N failed attempts (e.g., 5) for a cooldown period (e.g., 15 minutes)

**3. Add Comprehensive Logging:**
```rust
if !authenticated {
    aptos_logger::warn!(
        remote_addr = ?remote_addr,
        path = req.uri().path(),
        "Failed authentication attempt on admin service"
    );
}
```

**4. Use Stronger Password Hashing:**
Replace SHA256 with password-specific hashing:
- Consider bcrypt, scrypt, or argon2 instead of SHA256
- Add salt to prevent rainbow table attacks

**5. Alternative Authentication:**
- Consider mutual TLS instead of or in addition to passcodes
- Implement token-based authentication with expiration

## Proof of Concept

```rust
// PoC: Brute-force attack simulation
use hyper::{Body, Client, Request};
use std::time::Duration;

#[tokio::test]
async fn test_unlimited_brute_force() {
    // Assume admin service running on localhost:9102
    let client = Client::new();
    let base_url = "http://localhost:9102/profilez";
    
    // Common password dictionary
    let passwords = vec![
        "password", "admin", "aptos123", "validator", 
        "secret", "12345678", "qwerty", "letmein"
    ];
    
    for password in passwords {
        let url = format!("{}?passcode={}", base_url, password);
        let req = Request::builder()
            .uri(url)
            .body(Body::empty())
            .unwrap();
            
        let resp = client.request(req).await.unwrap();
        
        // No rate limiting - all requests succeed
        assert!(resp.status().as_u16() != 429); // No "Too Many Requests"
        
        if resp.status().is_success() {
            println!("SUCCESS! Password found: {}", password);
            break;
        }
        
        // Small delay to avoid network-level detection
        tokio::time::sleep(Duration::from_millis(100)).await;
    }
    
    // Attack continues indefinitely with no restrictions
}
```

**Real-world Attack Scenario:**
1. Attacker identifies validator node with admin service exposed
2. Runs automated script testing 10,000 common passwords at 1 request/second
3. Within hours to days, finds weak passcode like "aptos2024" or "validator123"
4. Downloads entire consensus database revealing validator voting patterns
5. Uses this intelligence for more sophisticated attacks or to deanonymize validators

## Notes
The admin service is designed for operational debugging by authorized validators only, as evidenced by the mainnet authentication requirement. The lack of brute-force protection represents a critical gap between the intended security model and the actual implementation. While infrastructure-level protections (HAProxy, firewalls) may provide some defense, relying solely on external controls violates defense-in-depth principles for protecting sensitive administrative interfaces.

### Citations

**File:** crates/aptos-admin-service/src/server/mod.rs (L154-174)
```rust
        let mut authenticated = false;
        if context.config.authentication_configs.is_empty() {
            authenticated = true;
        } else {
            for authentication_config in &context.config.authentication_configs {
                match authentication_config {
                    AuthenticationConfig::PasscodeSha256(passcode_sha256) => {
                        let query = req.uri().query().unwrap_or("");
                        let query_pairs: HashMap<_, _> =
                            url::form_urlencoded::parse(query.as_bytes()).collect();
                        let passcode: Option<String> =
                            query_pairs.get("passcode").map(|p| p.to_string());
                        if let Some(passcode) = passcode {
                            if sha256::digest(passcode) == *passcode_sha256 {
                                authenticated = true;
                            }
                        }
                    },
                }
            }
        };
```

**File:** crates/aptos-admin-service/src/server/mod.rs (L183-193)
```rust
        match (req.method().clone(), req.uri().path()) {
            #[cfg(target_os = "linux")]
            (hyper::Method::GET, "/profilez") => handle_cpu_profiling_request(req).await,
            #[cfg(target_os = "linux")]
            (hyper::Method::GET, "/threadz") => handle_thread_dump_request(req).await,
            #[cfg(unix)]
            (hyper::Method::GET, "/malloc/stats") => {
                malloc::handle_malloc_stats_request(context.config.malloc_stats_max_len)
            },
            #[cfg(unix)]
            (hyper::Method::GET, "/malloc/dump_profile") => malloc::handle_dump_profile_request(),
```

**File:** crates/aptos-admin-service/src/server/consensus/mod.rs (L130-156)
```rust
fn dump_consensus_db(consensus_db: &dyn PersistentLivenessStorage) -> anyhow::Result<String> {
    let mut body = String::new();

    let (last_vote, highest_tc, consensus_blocks, consensus_qcs) =
        consensus_db.consensus_db().get_data()?;

    body.push_str(&format!("Last vote: \n{last_vote:?}\n\n"));
    body.push_str(&format!("Highest tc: \n{highest_tc:?}\n\n"));
    body.push_str("Blocks: \n");
    for block in consensus_blocks {
        body.push_str(&format!(
            "[id: {:?}, author: {:?}, epoch: {}, round: {:02}, parent_id: {:?}, timestamp: {}, payload: {:?}]\n\n",
            block.id(),
            block.author(),
            block.epoch(),
            block.round(),
            block.parent_id(),
            block.timestamp_usecs(),
            block.payload(),
        ));
    }
    body.push_str("QCs: \n");
    for qc in consensus_qcs {
        body.push_str(&format!("{qc:?}\n\n"));
    }
    Ok(body)
}
```

**File:** crates/aptos-admin-service/src/server/consensus/mod.rs (L158-177)
```rust
fn dump_quorum_store_db(
    quorum_store_db: &dyn QuorumStoreStorage,
    digest: Option<HashValue>,
) -> anyhow::Result<String> {
    let mut body = String::new();

    if let Some(digest) = digest {
        body.push_str(&format!("{digest:?}:\n"));
        body.push_str(&format!(
            "{:?}",
            quorum_store_db.get_batch(&digest).map_err(Error::msg)?
        ));
    } else {
        for (digest, _batch) in quorum_store_db.get_all_batches()? {
            body.push_str(&format!("{digest:?}:\n"));
        }
    }

    Ok(body)
}
```

**File:** crates/aptos-admin-service/src/server/consensus/mod.rs (L179-215)
```rust
fn dump_blocks(
    consensus_db: &dyn PersistentLivenessStorage,
    quorum_store_db: &dyn QuorumStoreStorage,
    block_id: Option<HashValue>,
) -> anyhow::Result<String> {
    let mut body = String::new();

    let all_batches = quorum_store_db.get_all_batches()?;

    let (_, _, blocks, _) = consensus_db.consensus_db().get_data()?;

    for block in blocks {
        let id = block.id();
        if block_id.is_none() || id == block_id.unwrap() {
            body.push_str(&format!("Block ({id:?}): \n\n"));
            match extract_txns_from_block(&block, &all_batches) {
                Ok(txns) => {
                    body.push_str(&format!("{txns:?}"));
                },
                Err(e) => {
                    body.push_str(&format!("Not available: {e:?}"));
                },
            };
            body.push_str("\n\n");
        }
    }

    if body.is_empty() {
        if let Some(block_id) = block_id {
            body.push_str(&format!("Done, block ({block_id:?}) is not found."));
        } else {
            body.push_str("Done, no block is found.");
        }
    }

    Ok(body)
}
```

**File:** crates/aptos-admin-service/src/server/mempool/mod.rs (L12-38)
```rust
pub async fn mempool_handle_parking_lot_address_request(
    _req: Request<Body>,
    mempool_client_sender: MempoolClientSender,
) -> hyper::Result<Response<Body>> {
    match get_parking_lot_addresses(mempool_client_sender).await {
        Ok(addresses) => {
            info!("Finished getting parking lot addresses from mempool.");
            match bcs::to_bytes(&addresses) {
                Ok(addresses) => Ok(reply_with(vec![], addresses)),
                Err(e) => {
                    info!("Failed to bcs serialize parking lot addresses from mempool: {e:?}");
                    Ok(reply_with_status(
                        StatusCode::INTERNAL_SERVER_ERROR,
                        e.to_string(),
                    ))
                },
            }
        },
        Err(e) => {
            info!("Failed to get parking lot addresses from mempool: {e:?}");
            Ok(reply_with_status(
                StatusCode::INTERNAL_SERVER_ERROR,
                e.to_string(),
            ))
        },
    }
}
```

**File:** config/src/config/admin_service_config.rs (L67-77)
```rust
        if node_config.admin_service.enabled == Some(true) {
            if let Some(chain_id) = chain_id {
                if chain_id.is_mainnet()
                    && node_config.admin_service.authentication_configs.is_empty()
                {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name,
                        "Must enable authentication for AdminService on mainnet.".into(),
                    ));
                }
            }
```
