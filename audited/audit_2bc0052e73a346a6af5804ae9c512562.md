# Audit Report

## Title
Consensus Observer Accepts Unvalidated CommitDecisions for Future Epochs Leading to State Divergence

## Summary
Consensus observers fail to validate cryptographic signatures on `CommitDecision` messages for future epochs, allowing attackers to trick observers into syncing to malicious blockchain state. This breaks consensus safety and can cause permanent network divergence requiring a hardfork to recover.

## Finding Description

The consensus observer accepts `CommitDecision` messages from network peers and uses them to determine when to enter state sync mode. However, when a commit decision is received for a **future epoch** (an epoch the observer hasn't reached yet), the signature verification is completely skipped because the observer doesn't have the validator set for that future epoch. [1](#0-0) 

The critical code path shows that validation only occurs when `commit_epoch == epoch_state.epoch`. For future epochs, the code jumps directly to the state sync path without any cryptographic validation: [2](#0-1) 

The TODO comment at line 497-498 explicitly acknowledges this security gap but provides no solution. When the unvalidated commit decision is processed, it's passed directly to state sync: [3](#0-2) 

State sync then treats this unvalidated `LedgerInfoWithSignatures` as the trusted sync target. The state sync driver only performs version ordering checks, **not signature validation**: [4](#0-3) 

During chunk application, the malicious target is used as the "verified_target_li" to validate incoming chunks: [5](#0-4) [6](#0-5) 

This means an attacker can:
1. Send a fake `CommitDecision` for epoch N+1 with invalid/forged signatures
2. Observer skips validation (no epoch state for N+1)
3. Observer accepts this as sync target
4. Attacker provides chunks matching the fake target's state root
5. Observer commits malicious state to database
6. Observer diverges from honest network

The vulnerability breaks the **Consensus Safety** invariant: "AptosBFT must prevent double-spending and chain splits under < 1/3 Byzantine". An unprivileged network attacker (not even a validator) can cause observers to fork onto a fake chain.

## Impact Explanation

**CRITICAL SEVERITY** - This meets the highest severity criteria per Aptos bug bounty:

1. **Consensus/Safety violations**: Observers commit to fake blockchain state, violating BFT consensus safety guarantees
2. **Non-recoverable network partition**: Once observers sync to malicious state, they cannot rejoin the honest network without manual intervention
3. **Potential hardfork required**: If compromised observers become validators, the network may require a hardfork to recover

The attack affects all consensus observer nodes (full nodes following the chain via consensus messages rather than state sync). In Aptos architecture, observers are the primary mechanism for non-validator nodes to track the blockchain in real-time. Compromising observers compromises the entire network's ability to provide trusted blockchain state to users.

## Likelihood Explanation

**HIGH LIKELIHOOD**:

**Attacker Requirements:**
- Network access to send messages to consensus observer nodes (standard P2P connectivity)
- No validator keys or special privileges required
- No need for stake or validator collusion

**Attack Complexity:**
- Low - Simply craft a `CommitDecision` message with future epoch number
- No cryptographic breaks needed (signatures aren't checked!)
- Can be executed passively by any network peer

**Attack Window:**
- Continuous - Any time an observer receives messages from untrusted peers
- Especially effective during epoch transitions when observers expect future epoch commits

The code explicitly has a TODO acknowledging this issue exists, indicating developers are aware of the security gap but haven't implemented a fix.

## Recommendation

**Immediate Fix**: Observers must NOT accept commit decisions for future epochs without proper validation. Since they lack the future epoch's validator set, they cannot validate future epoch commits. The observer should:

1. **Reject future epoch commits entirely** until the observer naturally progresses to that epoch through normal state sync
2. **OR** require a chain of valid epoch change proofs to establish the validator set for the future epoch before accepting the commit

**Recommended Code Fix** for `process_commit_decision_message`:

```rust
// If the commit decision is for the current epoch, verify and process it
let epoch_state = self.get_epoch_state();
if commit_epoch == epoch_state.epoch {
    // Verify the commit decision
    if let Err(error) = commit_decision.verify_commit_proof(&epoch_state) {
        error!(/* ... */);
        increment_invalid_message_counter(&peer_network_id, metrics::COMMIT_DECISION_LABEL);
        return;
    }
    // ... process commit ...
} else if commit_epoch > epoch_state.epoch {
    // SECURITY FIX: Reject future epoch commits - we cannot validate them
    warn!(
        LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
            "Rejecting commit decision for future epoch: {:?}. Current epoch: {:?}. \
             Cannot validate without future epoch's validator set.",
            commit_epoch, epoch_state.epoch
        ))
    );
    increment_invalid_message_counter(&peer_network_id, metrics::COMMIT_DECISION_LABEL);
    return;
}
```

**Alternative Safer Approach**: If future epoch commits are needed, require the sender to provide:
1. A chain of valid `LedgerInfoWithSignatures` proving the epoch changes from current epoch to target epoch
2. Validate each epoch transition's signatures with the previous epoch's validator set
3. Only then accept the future epoch commit decision

## Proof of Concept

```rust
// PoC demonstrating the vulnerability
// File: consensus/src/consensus_observer/observer/tests/attack_poc.rs

#[tokio::test]
async fn test_malicious_future_epoch_commit_accepted() {
    // Setup: Create a consensus observer in epoch 1
    let (mut observer, epoch_state_1) = create_test_observer(1).await;
    
    // Attack: Craft a malicious CommitDecision for epoch 2 (future epoch)
    // with INVALID signatures (e.g., empty aggregated signature)
    let malicious_ledger_info = LedgerInfoWithSignatures::new(
        LedgerInfo::new(
            BlockInfo::new(
                2, // epoch 2 (future)
                100, // round
                HashValue::random(),
                HashValue::random(),
                0,
                0,
                None,
            ),
            HashValue::zero(),
        ),
        AggregateSignature::empty(), // INVALID - no signatures!
    );
    
    let malicious_commit = CommitDecision::new(malicious_ledger_info);
    
    // Send the malicious commit decision to observer
    observer.process_commit_decision_message(
        PeerNetworkId::random(),
        Instant::now(),
        malicious_commit.clone(),
    );
    
    // Verify: Observer accepts it and enters state sync mode
    // WITHOUT validating signatures!
    assert!(observer.state_sync_manager.is_syncing_to_commit());
    
    // The observer is now syncing to a completely fabricated target
    // with no valid quorum signatures - CONSENSUS SAFETY VIOLATION!
    
    // In production, attacker would provide matching malicious chunks
    // and observer would commit fake state to database
}
```

The PoC demonstrates that an observer will accept and begin syncing to a commit decision with completely invalid signatures (empty signature) as long as it's for a future epoch. This violates the fundamental assumption that all committed state must have valid 2f+1 validator signatures.

---

**Notes:**

This vulnerability is particularly severe because:
1. It affects the primary mechanism for non-validator nodes to track the blockchain
2. It requires no special privileges or validator access to exploit
3. The code explicitly has a TODO acknowledging the problem but no fix was implemented
4. Once exploited, observers cannot recover without manual intervention
5. If compromised observers later become validators, they could propagate the malicious state further

The fix must ensure observers NEVER accept future epoch commits without proper cryptographic validation of the entire epoch transition chain.

### Citations

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L466-495)
```rust
        // If the commit decision is for the current epoch, verify and process it
        let epoch_state = self.get_epoch_state();
        if commit_epoch == epoch_state.epoch {
            // Verify the commit decision
            if let Err(error) = commit_decision.verify_commit_proof(&epoch_state) {
                // Log the error and update the invalid message counter
                error!(
                    LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                        "Failed to verify commit decision! Ignoring: {:?}, from peer: {:?}. Error: {:?}",
                        commit_decision.proof_block_info(),
                        peer_network_id,
                        error
                    ))
                );
                increment_invalid_message_counter(&peer_network_id, metrics::COMMIT_DECISION_LABEL);
                return;
            }

            // Update the latency metrics for commit processing
            update_message_processing_latency_metrics(
                message_received_time,
                &peer_network_id,
                metrics::COMMIT_DECISION_LABEL,
            );

            // Update the pending blocks with the commit decision
            if self.process_commit_decision_for_pending_block(&commit_decision) {
                return; // The commit decision was successfully processed
            }
        }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L497-527)
```rust
        // TODO: identify the best way to handle an invalid commit decision
        // for a future epoch. In such cases, we currently rely on state sync.

        // Otherwise, we failed to process the commit decision. If the commit
        // is for a future epoch or round, we need to state sync.
        let last_block = self.observer_block_data.lock().get_last_ordered_block();
        let epoch_changed = commit_epoch > last_block.epoch();
        if epoch_changed || commit_round > last_block.round() {
            // If we're waiting for state sync to transition into a new epoch,
            // we should just wait and not issue a new state sync request.
            if self.state_sync_manager.is_syncing_through_epoch() {
                info!(
                    LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                        "Already waiting for state sync to reach new epoch: {:?}. Dropping commit decision: {:?}!",
                        self.observer_block_data.lock().root().commit_info(),
                        commit_decision.proof_block_info()
                    ))
                );
                return;
            }

            // Otherwise, we should start the state sync process for the commit.
            // Update the block data (to the commit decision).
            self.observer_block_data
                .lock()
                .update_blocks_for_state_sync_commit(&commit_decision);

            // Start state syncing to the commit decision
            self.state_sync_manager
                .sync_to_commit(commit_decision, epoch_changed);
        }
```

**File:** consensus/src/consensus_observer/observer/state_sync_manager.rs (L189-221)
```rust
    /// Invokes state sync to synchronize to a new commit decision
    pub fn sync_to_commit(&mut self, commit_decision: CommitDecision, epoch_changed: bool) {
        // Log that we're starting to sync to the commit decision
        info!(
            LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                "Started syncing to commit: {}!",
                commit_decision.proof_block_info()
            ))
        );

        // Get the commit decision epoch and round
        let commit_epoch = commit_decision.epoch();
        let commit_round = commit_decision.round();

        // Clone the required components for the state sync task
        let execution_client = self.execution_client.clone();
        let sync_notification_sender = self.state_sync_notification_sender.clone();

        // Spawn a task to sync to the commit decision
        let (abort_handle, abort_registration) = AbortHandle::new_pair();
        tokio::spawn(Abortable::new(
            async move {
                // Update the state sync metrics now that we're syncing to a commit
                metrics::set_gauge_with_label(
                    &metrics::OBSERVER_STATE_SYNC_EXECUTING,
                    metrics::STATE_SYNCING_TO_COMMIT,
                    1, // We're syncing to a commit decision
                );

                // Sync to the commit decision
                if let Err(error) = execution_client
                    .clone()
                    .sync_to_target(commit_decision.commit_proof().clone())
```

**File:** state-sync/state-sync-driver/src/notification_handlers.rs (L261-317)
```rust
    /// Initializes the sync target request received from consensus
    pub async fn initialize_sync_target_request(
        &mut self,
        sync_target_notification: ConsensusSyncTargetNotification,
        latest_pre_committed_version: Version,
        latest_synced_ledger_info: LedgerInfoWithSignatures,
    ) -> Result<(), Error> {
        // Get the target sync version and latest committed version
        let sync_target_version = sync_target_notification
            .get_target()
            .ledger_info()
            .version();
        let latest_committed_version = latest_synced_ledger_info.ledger_info().version();

        // If the target version is old, return an error to consensus (something is wrong!)
        if sync_target_version < latest_committed_version
            || sync_target_version < latest_pre_committed_version
        {
            let error = Err(Error::OldSyncRequest(
                sync_target_version,
                latest_pre_committed_version,
                latest_committed_version,
            ));
            self.respond_to_sync_target_notification(sync_target_notification, error.clone())?;
            return error;
        }

        // If the committed version is at the target, return successfully
        if sync_target_version == latest_committed_version {
            info!(
                LogSchema::new(LogEntry::NotificationHandler).message(&format!(
                    "We're already at the requested sync target version: {} \
                (pre-committed version: {}, committed version: {})!",
                    sync_target_version, latest_pre_committed_version, latest_committed_version
                ))
            );
            let result = Ok(());
            self.respond_to_sync_target_notification(sync_target_notification, result.clone())?;
            return result;
        }

        // If the pre-committed version is already at the target, something has else gone wrong
        if sync_target_version == latest_pre_committed_version {
            let error = Err(Error::InvalidSyncRequest(
                sync_target_version,
                latest_pre_committed_version,
            ));
            self.respond_to_sync_target_notification(sync_target_notification, error.clone())?;
            return error;
        }

        // Save the request so we can notify consensus once we've hit the target
        let consensus_sync_request =
            ConsensusSyncRequest::new_with_target(sync_target_notification);
        self.consensus_sync_request = Arc::new(Mutex::new(Some(consensus_sync_request)));

        Ok(())
```

**File:** state-sync/state-sync-driver/src/storage_synchronizer.rs (L986-1000)
```rust
async fn apply_output_chunk<ChunkExecutor: ChunkExecutorTrait + 'static>(
    chunk_executor: Arc<ChunkExecutor>,
    outputs_with_proof: TransactionOutputListWithProofV2,
    target_ledger_info: LedgerInfoWithSignatures,
    end_of_epoch_ledger_info: Option<LedgerInfoWithSignatures>,
) -> anyhow::Result<()> {
    // Apply the output chunk
    let num_outputs = outputs_with_proof.get_num_outputs();
    let result = tokio::task::spawn_blocking(move || {
        chunk_executor.enqueue_chunk_by_transaction_outputs(
            outputs_with_proof,
            &target_ledger_info,
            end_of_epoch_ledger_info.as_ref(),
        )
    })
```

**File:** execution/executor/src/chunk_executor/mod.rs (L158-174)
```rust
    fn enqueue_chunk_by_transaction_outputs(
        &self,
        txn_output_list_with_proof: TransactionOutputListWithProofV2,
        verified_target_li: &LedgerInfoWithSignatures,
        epoch_change_li: Option<&LedgerInfoWithSignatures>,
    ) -> Result<()> {
        let _guard = CONCURRENCY_GAUGE.concurrency_with(&["chunk", "enqueue_by_outputs"]);
        let _timer = APPLY_CHUNK.start_timer();

        // Verify input data.
        THREAD_MANAGER.get_exe_cpu_pool().install(|| {
            let _timer = CHUNK_OTHER_TIMERS.timer_with(&["apply_chunk__verify"]);
            txn_output_list_with_proof.verify(
                verified_target_li.ledger_info(),
                txn_output_list_with_proof.get_first_output_version(),
            )
        })?;
```
