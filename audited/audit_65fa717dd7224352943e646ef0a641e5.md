# Audit Report

## Title
Cache Key Missing Causes Indexer File Store Processor Panic and Complete Service Crash

## Summary
The indexer-grpc-file-store processor's main loop uses `.unwrap()` on an `Option<u64>` returned from Redis cache queries without handling the `None` case. If the Redis cache key `CACHE_KEY_LATEST_VERSION` is deleted or becomes unavailable during runtime, the processor panics and exits completely, halting all file store indexing operations until manual restart. [1](#0-0) 

## Finding Description
The vulnerability exists in the main processing loop of the file store processor. The code retrieves the latest version from Redis cache and immediately unwraps the Option without checking for None: [2](#0-1) 

The `get_latest_version()` method returns `Result<Option<u64>>` and can return `Ok(None)` when the Redis key is empty or missing: [3](#0-2) [4](#0-3) 

**Attack Scenarios:**

1. **Redis Flush Attack**: Attacker with Redis access executes `FLUSHDB` or `FLUSHALL`, clearing all keys including `CACHE_KEY_LATEST_VERSION`
2. **Manual Key Deletion**: `DEL latest_version` command removes the specific key
3. **Redis Failover**: During Redis failover to a replica without the key, processor reconnects to empty instance
4. **Operational Error**: Redis restart without persistence, administrator clearing cache during maintenance

When any of these scenarios occur during the processor's main loop execution, the `.unwrap()` call panics. The panic handler immediately exits the process: [5](#0-4) 

The service has no automatic restart mechanism and requires manual intervention: [6](#0-5) 

## Impact Explanation
**Severity: HIGH** (API Crashes - per Aptos Bug Bounty criteria)

This vulnerability causes complete unavailability of the indexer-grpc-file-store service, which is critical infrastructure for the Aptos ecosystem:

1. **Service Disruption**: The processor crashes immediately with no recovery, requiring manual restart
2. **Data Indexing Gap**: All file store indexing stops, creating data gaps that may require backfilling
3. **Downstream Impact**: Applications and services depending on indexed data lose access to real-time blockchain information
4. **No Automatic Recovery**: Unlike transient errors, this requires human intervention to diagnose and restart

While this doesn't directly affect blockchain consensus or validator operations, it meets the "API crashes" criteria for High severity in the bug bounty program, as the indexer API is a critical component for blockchain data accessibility.

## Likelihood Explanation
**Likelihood: MEDIUM-HIGH**

The vulnerability can be triggered through multiple realistic scenarios:

**Intentional Exploitation** (requires Redis access):
- Misconfigured Redis exposed to network (common deployment error)
- Compromised service sharing the same Redis instance
- Insider threat with infrastructure access

**Unintentional Triggering** (operational scenarios):
- Redis failover during high availability setup
- Cache clearing during maintenance windows
- Redis restart without proper state preservation
- Network partition causing connection to different Redis instance

The initialization in `new()` sets the key initially, but provides no guarantee it persists throughout the processor's lifetime: [7](#0-6) 

## Recommendation
Replace the `.unwrap()` with proper error handling that either retries or gracefully handles the missing key scenario:

```rust
// Recommended fix for line 128
let cache_worker_latest = match self.cache_operator.get_latest_version().await? {
    Some(version) => version,
    None => {
        tracing::error!(
            "Cache latest_version key is missing. Attempting to reinitialize cache."
        );
        // Reinitialize cache
        self.cache_operator.cache_setup_if_needed().await?;
        // Retry getting the version
        self.cache_operator.get_latest_version().await?
            .ok_or_else(|| anyhow::anyhow!("Failed to reinitialize cache latest_version"))?
    }
};
```

Alternative approach - fail fast with proper error propagation:

```rust
let cache_worker_latest = self.cache_operator.get_latest_version().await?
    .ok_or_else(|| anyhow::anyhow!(
        "Cache latest_version key is missing. Redis cache may have been cleared."
    ))?;
```

This allows the error to propagate up to the service layer where proper alerting and restart logic can be applied.

## Proof of Concept

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use redis_test::{MockCmd, MockRedisConnection};
    
    #[tokio::test]
    #[should_panic(expected = "called `Option::unwrap()` on a `None` value")]
    async fn test_processor_panics_on_missing_cache_key() {
        // Simulate Redis returning empty result for latest_version key
        let cmds = vec![
            MockCmd::new(
                redis::cmd("GET").arg("latest_version"),
                Ok::<Vec<u8>, redis::RedisError>(vec![]), // Empty result = None
            ),
        ];
        
        let mock_connection = MockRedisConnection::new(cmds);
        let mut cache_operator = CacheOperator::new(
            mock_connection, 
            StorageFormat::Base64UncompressedProto
        );
        
        // This should panic when unwrap is called on None
        let _result = cache_operator.get_latest_version().await.unwrap().unwrap();
    }
    
    #[tokio::test]
    async fn test_processor_handles_missing_cache_key_with_fix() {
        // Simulate Redis returning empty result, then successful reinitialization
        let cmds = vec![
            MockCmd::new(
                redis::cmd("GET").arg("latest_version"),
                Ok::<Vec<u8>, redis::RedisError>(vec![]),
            ),
            MockCmd::new(
                redis::cmd("SET")
                    .arg("latest_version")
                    .arg("0")
                    .arg("NX"),
                Ok("1"),
            ),
            MockCmd::new(
                redis::cmd("GET").arg("latest_version"),
                Ok("0"),
            ),
        ];
        
        let mock_connection = MockRedisConnection::new(cmds);
        let mut cache_operator = CacheOperator::new(
            mock_connection,
            StorageFormat::Base64UncompressedProto
        );
        
        // Recommended fix: handle None case
        let result = match cache_operator.get_latest_version().await.unwrap() {
            Some(v) => v,
            None => {
                cache_operator.cache_setup_if_needed().await.unwrap();
                cache_operator.get_latest_version().await.unwrap().unwrap()
            }
        };
        
        assert_eq!(result, 0);
    }
}
```

## Notes

**Additional Context:**

1. **Similar Vulnerabilities**: The same pattern appears in other locations in the codebase where `.unwrap()` is called on `get_latest_version()` results, suggesting this may be a broader code quality issue requiring systematic review.

2. **Defense in Depth**: While fixing this specific unwrap is critical, additional monitoring should be implemented to alert on Redis key deletions or cache corruption scenarios before they cause service failures.

3. **Redis Persistence**: Proper Redis configuration with AOF (Append-Only File) or RDB persistence should be enforced to prevent data loss during restarts, but this doesn't eliminate the need for defensive coding.

4. **Scope Consideration**: This vulnerability affects the indexing infrastructure rather than core consensus/execution, but remains High severity due to its critical role in data availability and the "API crashes" impact category in the bug bounty program.

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-file-store/src/processor.rs (L86-98)
```rust
        // Cache config in the cache
        cache_operator.cache_setup_if_needed().await?;
        match cache_operator.get_chain_id().await? {
            Some(id) => {
                ensure!(id == chain_id, "Chain ID mismatch.");
            },
            None => {
                cache_operator.set_chain_id(chain_id).await?;
            },
        }
        cache_operator
            .update_file_store_latest_version(batch_start_version)
            .await?;
```

**File:** ecosystem/indexer-grpc/indexer-grpc-file-store/src/processor.rs (L126-129)
```rust
        loop {
            let latest_loop_time = std::time::Instant::now();
            let cache_worker_latest = self.cache_operator.get_latest_version().await?.unwrap();

```

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/cache_operator.rs (L145-147)
```rust
    pub async fn get_latest_version(&mut self) -> anyhow::Result<Option<u64>> {
        self.get_config_by_key(CACHE_KEY_LATEST_VERSION).await
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/cache_operator.rs (L169-179)
```rust
    async fn get_config_by_key(&mut self, key: &str) -> anyhow::Result<Option<u64>> {
        let result = self.conn.get::<&str, Vec<u8>>(key).await?;
        if result.is_empty() {
            Ok(None)
        } else {
            let result_string = String::from_utf8(result).unwrap();
            Ok(Some(result_string.parse::<u64>().with_context(|| {
                format!("Redis key {} is not a number.", key)
            })?))
        }
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-server-framework/src/lib.rs (L149-168)
```rust
pub fn setup_panic_handler() {
    std::panic::set_hook(Box::new(move |pi: &PanicHookInfo<'_>| {
        handle_panic(pi);
    }));
}

// Formats and logs panic information
fn handle_panic(panic_info: &PanicHookInfo<'_>) {
    // The Display formatter for a PanicHookInfo contains the message, payload and location.
    let details = format!("{}", panic_info);
    let backtrace = format!("{:#?}", Backtrace::new());
    let info = CrashInfo { details, backtrace };
    let crash_info = toml::to_string_pretty(&info).unwrap();
    error!("{}", crash_info);
    // TODO / HACK ALARM: Write crash info synchronously via eprintln! to ensure it is written before the process exits which error! doesn't guarantee.
    // This is a workaround until https://github.com/aptos-labs/aptos-core/issues/2038 is resolved.
    eprintln!("{}", crash_info);
    // Kill the process
    process::exit(12);
}
```

**File:** ecosystem/indexer-grpc/indexer-grpc-file-store/src/lib.rs (L48-62)
```rust
    async fn run(&self) -> Result<()> {
        let mut processor = Processor::new(
            self.redis_main_instance_address.clone(),
            self.file_store_config.clone(),
            self.chain_id,
            self.enable_cache_compression,
        )
        .await
        .expect("Failed to create file store processor");
        processor
            .run()
            .await
            .expect("File store processor exited unexpectedly");
        Ok(())
    }
```
