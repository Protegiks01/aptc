# Audit Report

## Title
Unhandled BCS Deserialization Failures Cause Executor Shard Crashes via Panic Instead of Error Masking

## Summary
The executor-service defines error handling infrastructure to convert `bcs::Error` to `SerializationError`, but this infrastructure is never used. Instead, all BCS deserialization operations use `.unwrap()`, causing immediate panics when processing malformed payloads. This creates a denial-of-service vulnerability where attackers can crash remote executor shards by sending invalid BCS-encoded messages over unauthenticated gRPC channels.

## Finding Description

The security question asks whether error masking via the `from()` implementation could hide attack signatures. Investigation reveals the actual issue is more severe: **the error conversion is never invoked because all deserialization panics immediately**. [1](#0-0) 

This `from()` implementation is defined to enable proper error handling, but examining all BCS deserialization points reveals systematic `.unwrap()` usage:

**Critical Panic Points:**

1. **RemoteExecutionRequest deserialization** - crashes executor shard: [2](#0-1) 

2. **RemoteExecutionResult deserialization** - crashes coordinator: [3](#0-2) 

3. **CrossShardMsg deserialization** - crashes executor shard: [4](#0-3) 

4. **RemoteKVResponse deserialization** - crashes executor shard: [5](#0-4) 

The network layer uses unauthenticated HTTP gRPC without TLS or peer validation: [6](#0-5) 

Remote executor shards are integrated into the production execution path: [7](#0-6) 

**Attack Path:**
1. Attacker identifies network address of remote executor shard (configured via CLI)
2. Attacker sends gRPC message with malformed BCS encoding for any message type
3. BCS deserialization fails and `.unwrap()` causes panic
4. Executor shard process crashes
5. Block execution fails on coordinator, affecting validator operation
6. Attacker can repeat indefinitely as shards restart

This violates the **Deterministic Execution** and **Resource Limits** invariants by allowing external actors to disrupt block execution.

## Impact Explanation

**High Severity** per Aptos Bug Bounty criteria:
- **API crashes**: Direct crash of executor service API via malformed input
- **Validator node slowdowns**: Failed block execution when remote shards are configured

The vulnerability breaks availability guarantees in the execution layer. While the system is designed to restart after panics, an attacker can repeatedly crash services, causing:
- Execution delays affecting validator participation
- Potential loss of validator rewards due to missed block proposals
- Reduced network throughput if multiple validators are affected

This is NOT a network-level DoS (which is out of scope), but an **application-level vulnerability** exploiting improper error handling in the API layer.

## Likelihood Explanation

**Moderate to High likelihood** depending on deployment configuration:

**Factors increasing likelihood:**
- Zero authentication on NetworkController
- Systematic use of `.unwrap()` across all deserialization paths
- Simple attack requiring only network access and malformed BCS data
- Production integration exists via `do_get_execution_output.rs`

**Factors decreasing likelihood:**
- Remote executor addresses must be configured (not default)
- May be intended for internal/trusted networks only
- Proper network segmentation could prevent external access
- Unclear if production validators actually deploy with remote execution enabled

The vulnerability is **definitely exploitable** if executor shards are network-accessible to attackers. Deployment practices determine actual exploitability.

## Recommendation

**Immediate Fix:** Replace all `.unwrap()` calls with proper error handling using the existing `Error` type:

```rust
// In remote_cordinator_client.rs:89
let request: RemoteExecutionRequest = match bcs::from_bytes(&message.data) {
    Ok(req) => req,
    Err(e) => {
        error!("Failed to deserialize RemoteExecutionRequest: {}", e);
        return ExecutorShardCommand::Stop;
    }
};

// In remote_executor_client.rs:168
let result: RemoteExecutionResult = match bcs::from_bytes(&received_bytes) {
    Ok(res) => res,
    Err(e) => {
        error!("Failed to deserialize RemoteExecutionResult: {}", e);
        return Err(VMStatus::Error {
            status_code: StatusCode::UNEXPECTED_DESERIALIZATION_ERROR,
            sub_status: None,
            message: Some(format!("BCS deserialization failed: {}", e)),
        });
    }
};
```

**Additional Hardening:**
1. Add authentication to NetworkController using Noise protocol similar to main Aptos network
2. Implement rate limiting and connection throttling
3. Add monitoring/alerting for repeated deserialization failures
4. Consider TLS for remote executor communication
5. Document intended deployment model and network security requirements

**Long-term:** Audit all `.unwrap()` usage in security-critical code paths and replace with proper error handling.

## Proof of Concept

```rust
// PoC: Crash remote executor shard with malformed BCS
use aptos_secure_net::network_controller::Message;
use std::net::SocketAddr;

#[test]
fn test_malformed_bcs_crash() {
    // Setup: Start executor shard on localhost:50000
    let shard_addr: SocketAddr = "127.0.0.1:50000".parse().unwrap();
    
    // Craft malformed BCS payload
    // Valid BCS encoding would start with enum variant tag
    // We send invalid tag 0xFF followed by garbage
    let malformed_payload = vec![0xFF, 0xDE, 0xAD, 0xBE, 0xEF];
    
    // Connect via gRPC and send to execute_command_0 channel
    let client = NetworkMessageServiceClient::connect(
        format!("http://{}", shard_addr)
    ).await.unwrap();
    
    let request = NetworkMessage {
        message: malformed_payload,
        message_type: "execute_command_0".to_string(),
    };
    
    // This will cause the remote shard to panic at line 89 of remote_cordinator_client.rs
    // Expected: Shard process crashes with "called `Result::unwrap()` on an `Err` value"
    client.simple_msg_exchange(request).await.unwrap();
    
    // Shard will be unresponsive after panic
    // Subsequent execution attempts will fail
}
```

## Notes

**Clarification on Security Question:**
The original question asks about "error masking" via `SerializationError` conversion. This investigation found that:
- Error masking does NOT occur because `from()` is never called
- The actual vulnerability is **worse**: panics instead of errors
- This creates a DoS vector rather than an information hiding issue

**Deployment Context:**
The remote executor service appears designed for distributed execution benchmarking or specialized deployments. Its production usage in validators is unclear from the codebase alone. However, the integration exists in the main executor path, making this a valid security concern.

**Scope Alignment:**
This is NOT a "network-level DoS" (excluded from scope), but an **API-level crash vulnerability** (High Severity per bug bounty). The distinction is that the attack exploits application logic errors rather than overwhelming network resources.

### Citations

**File:** execution/executor-service/src/error.rs (L16-20)
```rust
impl From<bcs::Error> for Error {
    fn from(error: bcs::Error) -> Self {
        Self::SerializationError(format!("{}", error))
    }
}
```

**File:** execution/executor-service/src/remote_cordinator_client.rs (L89-89)
```rust
                let request: RemoteExecutionRequest = bcs::from_bytes(&message.data).unwrap();
```

**File:** execution/executor-service/src/remote_executor_client.rs (L168-168)
```rust
            let result: RemoteExecutionResult = bcs::from_bytes(&received_bytes).unwrap();
```

**File:** execution/executor-service/src/remote_cross_shard_client.rs (L64-64)
```rust
        let msg: CrossShardMsg = bcs::from_bytes(&message.to_bytes()).unwrap();
```

**File:** execution/executor-service/src/remote_state_view.rs (L254-254)
```rust
        let response: RemoteKVResponse = bcs::from_bytes(&message.data).unwrap();
```

**File:** secure/net/src/grpc_network_service/mod.rs (L93-115)
```rust
    async fn simple_msg_exchange(
        &self,
        request: Request<NetworkMessage>,
    ) -> Result<Response<Empty>, Status> {
        let _timer = NETWORK_HANDLER_TIMER
            .with_label_values(&[&self.self_addr.to_string(), "inbound_msgs"])
            .start_timer();
        let remote_addr = request.remote_addr();
        let network_message = request.into_inner();
        let msg = Message::new(network_message.message);
        let message_type = MessageType::new(network_message.message_type);

        if let Some(handler) = self.inbound_handlers.lock().unwrap().get(&message_type) {
            // Send the message to the registered handler
            handler.send(msg).unwrap();
        } else {
            error!(
                "No handler registered for sender: {:?} and msg type {:?}",
                remote_addr, message_type
            );
        }
        Ok(Response::new(Empty {}))
    }
```

**File:** execution/executor/src/workflow/do_get_execution_output.rs (L256-276)
```rust
    fn execute_block_sharded<V: VMBlockExecutor>(
        partitioned_txns: PartitionedTransactions,
        state_view: Arc<CachedStateView>,
        onchain_config: BlockExecutorConfigFromOnchain,
    ) -> Result<Vec<TransactionOutput>> {
        if !get_remote_addresses().is_empty() {
            Ok(V::execute_block_sharded(
                &REMOTE_SHARDED_BLOCK_EXECUTOR.lock(),
                partitioned_txns,
                state_view,
                onchain_config,
            )?)
        } else {
            Ok(V::execute_block_sharded(
                &SHARDED_BLOCK_EXECUTOR.lock(),
                partitioned_txns,
                state_view,
                onchain_config,
            )?)
        }
    }
```
