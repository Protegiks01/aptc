# Audit Report

## Title
Gas Metering Bypass in Frame Cleanup - Missing Charge for Dropping Function Locals

## Summary
The Move VM's `charge_drop_frame()` function returns `Ok()` without charging any gas when dropping function call frames, allowing attackers to cause validators to perform computational work (iterating through up to 255 locals, performing memory operations, and managing reference counting) without proper gas accounting. This violates the critical invariant that all computational operations must be properly metered.

## Finding Description

The production gas meter implementation fails to charge gas when dropping function frames: [1](#0-0) 

When a Move function returns, the interpreter performs frame cleanup by calling `drop_all_values()` on the function's local variables: [2](#0-1) 

The `drop_all_values()` method performs significant computational work, iterating through all locals (up to 255), pattern matching on each value, and performing memory operations: [3](#0-2) 

Additionally, when the Locals struct is dropped, another iteration occurs to invalidate remaining values and break reference cycles: [4](#0-3) 

**Attack Path:**

1. Attacker creates a Move function with 255 local variables (the maximum allowed)
2. The function is called repeatedly in a loop within a transaction
3. Each function call charges gas: `CALL_PER_LOCAL * 255 = 367 * 255 = 93,585` internal gas units [5](#0-4) 

4. Each function return drops 255 locals with **zero gas charged**, despite performing substantial work
5. By comparison, popping a single value from the operand stack costs 147 internal gas units: [6](#0-5) 

The attacker effectively receives ~40% of frame cleanup work for free (approximately 37,485 internal gas units per call if we baseline on the `POP` cost of 147 per local).

## Impact Explanation

This is a **Medium Severity** vulnerability per the Aptos bug bounty program criteria:

- **Gas Metering Inaccuracy**: Breaks the fundamental invariant that "all operations must respect gas, storage, and computational limits"
- **Resource Exhaustion**: Validators perform computational work (memory operations, reference counting, iteration) without proper charging
- **Amplification Factor**: With functions having 255 locals called repeatedly, the missing charges accumulate significantly
- **Validator Performance Impact**: Forces validators to spend CPU cycles on work they're not compensated for through gas fees

While not a consensus-breaking issue, this represents a clear violation of the gas metering system's integrity and enables a resource exhaustion vector against validator nodes.

## Likelihood Explanation

**Likelihood: High**

- **Easy to Exploit**: Creating functions with many locals is straightforward Move code
- **No Special Privileges Required**: Any transaction sender can exploit this
- **Immediate Impact**: Each function call/return cycle results in uncharged work
- **Repeatable**: Can be exploited in loops within a single transaction up to the transaction gas limit
- **Low Detection Difficulty**: The exploitation pattern (functions with many locals) is not inherently suspicious

The only limiting factor is the overall transaction gas limit, which prevents infinite exploitation but does not prevent significant resource theft.

## Recommendation

Implement gas charging in `charge_drop_frame()` proportional to the number and complexity of locals being dropped. The charge should account for:

1. Iteration cost over all locals
2. Pattern matching and conditional logic per local
3. Memory operations (`std::mem::replace`)
4. Reference counting overhead for `Rc` types

**Suggested Fix:**

```rust
fn charge_drop_frame(
    &mut self,
    locals: impl Iterator<Item = impl ValueView>,
) -> PartialVMResult<()> {
    // Count the locals and charge appropriately
    let num_locals = locals.count();
    let cost = DROP_FRAME_BASE + DROP_FRAME_PER_LOCAL * NumArgs::new(num_locals as u64);
    self.algebra.charge_execution(cost)
}
```

Add new gas parameters to the gas schedule:
- `DROP_FRAME_BASE`: Base cost for frame cleanup overhead
- `DROP_FRAME_PER_LOCAL`: Per-local cleanup cost (suggested: similar to `POP` at 147 internal gas units)

This ensures validators are compensated for all computational work performed during frame cleanup.

## Proof of Concept

```move
module 0x1::gas_bypass_poc {
    // Function with maximum locals (255 total including parameters)
    public fun exploit_drop_frame(
        _a0: u64, _a1: u64, _a2: u64, _a3: u64, _a4: u64,
        _a5: u64, _a6: u64, _a7: u64, _a8: u64, _a9: u64
    ) {
        // Declare 245 additional local variables (255 - 10 params = 245)
        let l0 = 0u64; let l1 = 0u64; let l2 = 0u64; let l3 = 0u64; let l4 = 0u64;
        let l5 = 0u64; let l6 = 0u64; let l7 = 0u64; let l8 = 0u64; let l9 = 0u64;
        // ... (continue declaring locals up to l244)
        
        // Use the locals to prevent optimization
        l0 = l0 + l1 + l2 + l3 + l4;
        l5 = l5 + l6 + l7 + l8 + l9;
        // ...
        
        // When this function returns, all 255 locals are dropped without gas charge
    }
    
    public entry fun attack() {
        // Call the function repeatedly to maximize uncharged work
        let i = 0;
        while (i < 100) {
            exploit_drop_frame(0, 1, 2, 3, 4, 5, 6, 7, 8, 9);
            i = i + 1;
        };
        // Total uncharged work: ~100 calls * 37,485 gas = ~3.7M internal gas units
    }
}
```

**Testing Instructions:**
1. Deploy the module above to a test network
2. Execute the `attack()` entry function
3. Monitor validator CPU usage and compare gas charged vs. computational work performed
4. Observe that frame cleanup work for 255 locals * 100 calls is performed without corresponding gas charges

## Notes

This vulnerability affects both the test utilities gas meter [7](#0-6)  and the production StandardGasMeter implementation, indicating this was a design decision rather than an oversight. However, it violates the principle that all computational work must be properly metered to prevent resource exhaustion attacks against validators.

### Citations

**File:** aptos-move/aptos-gas-meter/src/meter.rs (L245-247)
```rust
    fn charge_pop(&mut self, _popped_val: impl ValueView) -> PartialVMResult<()> {
        self.algebra.charge_execution(POP)
    }
```

**File:** aptos-move/aptos-gas-meter/src/meter.rs (L250-265)
```rust
    fn charge_call(
        &mut self,
        _module_id: &ModuleId,
        _func_name: &str,
        args: impl ExactSizeIterator<Item = impl ValueView>,
        num_locals: NumArgs,
    ) -> PartialVMResult<()> {
        let cost = CALL_BASE + CALL_PER_ARG * NumArgs::new(args.len() as u64);

        match self.feature_version() {
            0..=2 => self.algebra.charge_execution(cost),
            3.. => self
                .algebra
                .charge_execution(cost + CALL_PER_LOCAL * num_locals),
        }
    }
```

**File:** aptos-move/aptos-gas-meter/src/meter.rs (L533-538)
```rust
    fn charge_drop_frame(
        &mut self,
        _locals: impl Iterator<Item = impl ValueView>,
    ) -> PartialVMResult<()> {
        Ok(())
    }
```

**File:** third_party/move/move-vm/runtime/src/interpreter.rs (L399-404)
```rust
                ExitCode::Return => {
                    let non_ref_vals = current_frame.locals.drop_all_values();

                    gas_meter
                        .charge_drop_frame(non_ref_vals.iter())
                        .map_err(|e| set_err_info!(current_frame, e))?;
```

**File:** third_party/move/move-vm/types/src/values/values_impl.rs (L2395-2408)
```rust
        let mut locals = self.0.borrow_mut();
        let mut res = Vec::with_capacity(locals.len());

        for local in locals.iter_mut() {
            match &local {
                Value::Invalid => (),
                Value::ContainerRef(_) | Value::IndexedRef(_) => {
                    *local = Value::Invalid;
                },
                _ => res.push(std::mem::replace(local, Value::Invalid)),
            }
        }

        res
```

**File:** third_party/move/move-vm/types/src/values/values_impl.rs (L5459-5471)
```rust
impl Drop for Locals {
    #[cfg_attr(feature = "inline-locals", inline(always))]
    fn drop(&mut self) {
        let mut locals = self.0.borrow_mut();
        for local in locals.iter_mut() {
            match &local {
                Value::Invalid => (),
                _ => {
                    *local = Value::Invalid;
                },
            }
        }
    }
```

**File:** third_party/move/move-vm/test-utils/src/gas_schedule.rs (L531-536)
```rust
    fn charge_drop_frame(
        &mut self,
        _locals: impl Iterator<Item = impl ValueView>,
    ) -> PartialVMResult<()> {
        Ok(())
    }
```
