# Audit Report

## Title
Incorrect Deletion Method Used for V2 Batches Leading to Database Storage Bloat

## Summary
The `delete_batches_v2()` function properly cleans up extended metadata (BatchKind, ExtraBatchInfo) when called, but critical cleanup code paths incorrectly invoke `delete_batches()` (V1 method) instead of `delete_batches_v2()` (V2 method), causing V2 batch metadata to remain orphaned in the database.

## Finding Description

The `BatchInfoExt` enum has two variants: V1 (basic BatchInfo) and V2 (BatchInfo + ExtraBatchInfo containing BatchKind). [1](#0-0)  These variants are stored in separate column families in the database: `BATCH_CF_NAME` for V1 and `BATCH_V2_CF_NAME` for V2. [2](#0-1) 

The `delete_batches_v2()` function correctly deletes from the V2 column family. [3](#0-2) 

However, two critical cleanup code paths use the wrong deletion method:

**Bug #1**: In `gc_previous_epoch_batches_from_db_v2()`, the function reads V2 batches but calls `delete_batches()` instead of `delete_batches_v2()`. [4](#0-3)  This occurs during epoch transitions.

**Bug #2**: In `update_certified_timestamp()`, expired batches (which can include V2 batches when `enable_batch_v2=true`) are removed from the in-memory cache but deleted from the database using only `delete_batches()`. [5](#0-4)  This occurs during regular operation as batches expire.

The in-memory cache stores `PersistedValue<BatchInfoExt>` which can contain both V1 and V2 batches. [6](#0-5)  When persisting, the code correctly routes V1 and V2 batches to their respective storage methods. [7](#0-6) 

## Impact Explanation

This qualifies as **Medium severity** under the "State inconsistencies requiring intervention" category. The bug causes:

1. **Database Bloat**: V2 batch metadata accumulates indefinitely in the `BATCH_V2_CF_NAME` column family since expired batches are never deleted from the correct storage location
2. **Disk Space Waste**: Each orphaned batch contains substantial metadata (author, batch_id, epoch, expiration, digest, num_txns, num_bytes, gas_bucket_start, and BatchKind/ExtraBatchInfo)
3. **Performance Degradation**: Over time, the growing database size can impact read/write performance and node synchronization
4. **Operational Intervention Required**: Manual database cleanup or node restarts become necessary to reclaim space

While this does not directly compromise consensus safety or cause fund loss, it creates a persistent storage inconsistency that degrades system health and requires operational intervention to resolve.

## Likelihood Explanation

**Likelihood: HIGH**

This bug triggers automatically during normal validator operation when `enable_batch_v2=true` in the configuration. [8](#0-7) 

The bug manifests in two scenarios:
1. **Every epoch transition**: When `is_new_epoch=true`, Bug #1 executes and fails to delete old V2 batches
2. **Every certified timestamp update**: Bug #2 executes regularly during normal operation, failing to delete expired V2 batches

No attacker action is required. The issue affects all validators using V2 batches and worsens during migration periods when both V1 and V2 batches coexist.

## Recommendation

Fix both cleanup code paths to check batch version and call the appropriate deletion method:

**Fix for Bug #1** (line 241 in batch_store.rs):
```rust
db.delete_batches_v2(expired_keys)
    .expect("Deletion of expired keys should not fail");
```

**Fix for Bug #2** (lines 535-538 in batch_store.rs):
```rust
let expired_keys = self.clear_expired_payload(certified_time);
// Separate V1 and V2 batches for proper cleanup
let mut v1_keys = Vec::new();
let mut v2_keys = Vec::new();
for digest in expired_keys {
    // Check if this was a V2 batch by attempting to read from V2 storage
    if self.db.get_batch_v2(&digest).ok().flatten().is_some() {
        v2_keys.push(digest);
    } else {
        v1_keys.push(digest);
    }
}
if let Err(e) = self.db.delete_batches(v1_keys) {
    debug!("Error deleting V1 batches: {:?}", e)
}
if let Err(e) = self.db.delete_batches_v2(v2_keys) {
    debug!("Error deleting V2 batches: {:?}", e)
}
```

Alternatively, maintain version information in the cache to avoid additional database lookups during cleanup.

## Proof of Concept

The bug can be demonstrated through the following test scenario:

1. Configure a validator with `enable_batch_v2 = true`
2. Generate and persist multiple V2 batches during normal operation
3. Advance the blockchain past batch expiration times
4. Observe `update_certified_timestamp()` execution removing batches from in-memory cache
5. Query the `BATCH_V2_CF_NAME` column family directly - expired V2 batches remain in database
6. Observe database size growth over time as more batches accumulate without deletion

The root cause can be verified by adding logging to track which deletion methods are invoked and comparing against the actual database state after cleanup operations execute.

### Citations

**File:** consensus/consensus-types/src/proof_of_store.rs (L195-203)
```rust
pub enum BatchInfoExt {
    V1 {
        info: BatchInfo,
    },
    V2 {
        info: BatchInfo,
        extra: ExtraBatchInfo,
    },
}
```

**File:** consensus/src/quorum_store/schema.rs (L14-16)
```rust
pub(crate) const BATCH_CF_NAME: ColumnFamilyName = "batch";
pub(crate) const BATCH_ID_CF_NAME: ColumnFamilyName = "batch_ID";
pub(crate) const BATCH_V2_CF_NAME: ColumnFamilyName = "batch_v2";
```

**File:** consensus/src/quorum_store/quorum_store_db.rs (L123-131)
```rust
    fn delete_batches_v2(&self, digests: Vec<HashValue>) -> Result<(), DbError> {
        let mut batch = SchemaBatch::new();
        for digest in digests.iter() {
            trace!("QS: db delete digest {}", digest);
            batch.delete::<BatchV2Schema>(digest)?;
        }
        self.db.write_schemas_relaxed(batch)?;
        Ok(())
    }
```

**File:** consensus/src/quorum_store/batch_store.rs (L116-116)
```rust
    db_cache: DashMap<HashValue, PersistedValue<BatchInfoExt>>,
```

**File:** consensus/src/quorum_store/batch_store.rs (L212-243)
```rust
    fn gc_previous_epoch_batches_from_db_v2(db: Arc<dyn QuorumStoreStorage>, current_epoch: u64) {
        let db_content = db
            .get_all_batches_v2()
            .expect("failed to read data from db");
        info!(
            epoch = current_epoch,
            "QS: Read batches from storage. Len: {}",
            db_content.len(),
        );

        let mut expired_keys = Vec::new();
        for (digest, value) in db_content {
            let epoch = value.epoch();

            trace!(
                "QS: Batchreader recovery content epoch {:?}, digest {}",
                epoch,
                digest
            );

            if epoch < current_epoch {
                expired_keys.push(digest);
            }
        }

        info!(
            "QS: Batch store bootstrap expired keys len {}",
            expired_keys.len()
        );
        db.delete_batches(expired_keys)
            .expect("Deletion of expired keys should not fail");
    }
```

**File:** consensus/src/quorum_store/batch_store.rs (L500-513)
```rust
                if needs_db {
                    if !batch_info.is_v2() {
                        let persist_request =
                            persist_request.try_into().expect("Must be a V1 batch");
                        #[allow(clippy::unwrap_in_result)]
                        self.db
                            .save_batch(persist_request)
                            .expect("Could not write to DB");
                    } else {
                        #[allow(clippy::unwrap_in_result)]
                        self.db
                            .save_batch_v2(persist_request)
                            .expect("Could not write to DB")
                    }
```

**File:** consensus/src/quorum_store/batch_store.rs (L530-539)
```rust
    pub fn update_certified_timestamp(&self, certified_time: u64) {
        trace!("QS: batch reader updating time {:?}", certified_time);
        self.last_certified_time
            .fetch_max(certified_time, Ordering::SeqCst);

        let expired_keys = self.clear_expired_payload(certified_time);
        if let Err(e) = self.db.delete_batches(expired_keys) {
            debug!("Error deleting batches: {:?}", e)
        }
    }
```

**File:** config/src/config/quorum_store_config.rs (L102-102)
```rust
    pub enable_batch_v2: bool,
```
