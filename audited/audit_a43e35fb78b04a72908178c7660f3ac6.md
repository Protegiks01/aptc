# Audit Report

## Title
MultiKey Authenticator Deserialization Bypass Enables Resource Exhaustion in Metrics Collection

## Summary
A transaction with thousands of signatures in a MultiKey authenticator can bypass validation limits through BCS deserialization, causing excessive metric operations that slow down chunk processing when detailed counters are enabled.

## Finding Description

The Aptos transaction authenticator system enforces a limit of 32 signatures (`MAX_NUM_OF_SIGS`) during signature verification. [1](#0-0) 

However, both `MultiKey` and `MultiKeyAuthenticator` structures use automatic BCS deserialization without enforcing these limits at deserialization time. [2](#0-1) [3](#0-2) 

The validation only occurs in the constructor methods `new()`, which are bypassed during deserialization. [4](#0-3) 

**Attack Flow:**

1. Attacker crafts a transaction containing a `MultiKeyAuthenticator` with thousands of signatures (e.g., 10,000) by directly serializing the struct fields
2. Transaction is deserialized successfully, bypassing constructor validation
3. During signature verification, `number_of_signatures()` returns thousands, exceeding `MAX_NUM_OF_SIGS` [5](#0-4) 
4. Verification fails and transaction is marked Invalid [6](#0-5) 
5. Invalid transaction is executed, immediately rejected, and placed in `to_discard` [7](#0-6) 
6. The `SignatureVerifiedTransaction` is converted back to `Transaction` via `into_inner()` [8](#0-7) 
7. Metrics collection processes discarded transactions [9](#0-8) 
8. When detailed counters are enabled, the code iterates over all signatures in the MultiKey authenticator [10](#0-9) 
9. Each signature triggers a Prometheus counter operation involving lock acquisition and label formatting

The `signatures()` method returns all signatures by zipping the bitmap with the signatures vector, allowing thousands of iterations. [11](#0-10) 

## Impact Explanation

This qualifies as **Medium Severity** per Aptos bug bounty criteria:

- **Validator node slowdowns**: Excessive Prometheus metric operations in the background thread pool can degrade node performance
- **Resource exhaustion**: Each metric operation requires lock acquisition, string formatting, and hash table operations
- **Amplification attack**: Multiple malicious transactions can compound the effect
- **DoS on monitoring**: Metrics collection backlog impairs node observability

The impact is limited because metrics collection happens asynchronously and only when `detailed_counters` is enabled. [12](#0-11) [13](#0-12) 

This breaks the **Resource Limits** invariant: "All operations must respect gas, storage, and computational limits."

## Likelihood Explanation

**High likelihood** because:
- Any attacker can submit transactions to the network
- BCS serialization tools make crafting malicious payloads straightforward
- Transaction size limits (6MB) allow fitting 10,000+ signatures within a single transaction
- Detailed counters are typically enabled in production for monitoring
- No authentication or privileged access required

## Recommendation

Add deserialization validation to enforce limits during BCS deserialization:

**Option 1: Custom Deserialize Implementation**
Implement custom `Deserialize` for `MultiKey` and `MultiKeyAuthenticator` that enforces `MAX_NUM_OF_SIGS` during deserialization.

**Option 2: Post-Deserialization Validation**
Add validation immediately after deserialization in transaction handling code, before signature verification:
- Validate `public_keys.len() <= MAX_NUM_OF_SIGS`
- Validate `signatures.len() <= MAX_NUM_OF_SIGS`
- Reject transactions that exceed limits before processing

**Option 3: Limit Metrics Iteration**
Add a safety check in the metrics collection code:
```rust
AccountAuthenticator::MultiKey { authenticator } => {
    let sigs = authenticator.signatures();
    if sigs.len() > MAX_NUM_OF_SIGS {
        // Log warning and skip detailed metrics
        continue;
    }
    for (_, signature) in sigs {
        // ... existing metric code
    }
}
```

## Proof of Concept

```rust
use aptos_types::transaction::authenticator::{MultiKey, MultiKeyAuthenticator, AnyPublicKey, AnySignature};
use aptos_crypto::ed25519::{Ed25519PrivateKey, Ed25519PublicKey};
use bcs;

// Create malicious authenticator with 10,000 signatures
let mut public_keys = Vec::new();
let mut signatures = Vec::new();
let mut bitmap = aptos_bitvec::BitVec::with_num_bits(10000);

for i in 0..10000 {
    let private_key = Ed25519PrivateKey::generate_for_testing();
    let public_key = Ed25519PublicKey::from(&private_key);
    public_keys.push(AnyPublicKey::ed25519(public_key));
    
    // Create dummy signature
    let signature = AnySignature::ed25519(/* dummy signature */);
    signatures.push(signature);
    bitmap.set(i);
}

// Construct without validation by direct field access
let malicious_multikey = MultiKey {
    public_keys,
    signatures_required: 1,
};

let malicious_authenticator = MultiKeyAuthenticator {
    public_keys: malicious_multikey,
    signatures,
    signatures_bitmap: bitmap,
};

// Serialize to BCS
let serialized = bcs::to_bytes(&malicious_authenticator).unwrap();

// When deserialized and processed, this will cause 10,000 metric operations
// during chunk processing if detailed_counters is enabled
```

**Notes**

This vulnerability exists because Rust's `derive(Deserialize)` macro generates deserialization code that directly populates struct fields without invoking validation logic in constructor methods. The `MAX_NUM_OF_SIGS` limit is only enforced during signature verification, after the malicious data structure has already been deserialized and can cause resource exhaustion during metrics collection.

The attack vector requires detailed counters to be enabled, but this is common in production deployments for monitoring purposes. The async nature of metrics collection prevents immediate consensus disruption but enables a sustained resource exhaustion attack against validator node performance.

### Citations

**File:** types/src/transaction/authenticator.rs (L32-34)
```rust
/// Maximum number of signatures supported in `TransactionAuthenticator`,
/// across all `AccountAuthenticator`s included.
pub const MAX_NUM_OF_SIGS: usize = 32;
```

**File:** types/src/transaction/authenticator.rs (L160-169)
```rust
    pub fn verify(&self, raw_txn: &RawTransaction) -> Result<()> {
        let num_sigs: usize = self.sender().number_of_signatures()
            + self
                .secondary_signers()
                .iter()
                .map(|auth| auth.number_of_signatures())
                .sum::<usize>();
        if num_sigs > MAX_NUM_OF_SIGS {
            return Err(Error::new(AuthenticationError::MaxSignaturesExceeded));
        }
```

**File:** types/src/transaction/authenticator.rs (L838-847)
```rust
    pub fn number_of_signatures(&self) -> usize {
        match self {
            Self::Ed25519 { .. } => 1,
            Self::MultiEd25519 { signature, .. } => signature.signatures().len(),
            Self::SingleKey { .. } => 1,
            Self::MultiKey { authenticator } => authenticator.signatures.len(),
            Self::NoAccountAuthenticator => 0,
            Self::Abstract { .. } => 0,
        }
    }
```

**File:** types/src/transaction/authenticator.rs (L1025-1030)
```rust
#[derive(Clone, Debug, Eq, Hash, PartialEq, Serialize, Deserialize)]
pub struct MultiKeyAuthenticator {
    public_keys: MultiKey,
    signatures: Vec<AnySignature>,
    signatures_bitmap: aptos_bitvec::BitVec,
}
```

**File:** types/src/transaction/authenticator.rs (L1070-1078)
```rust
    pub fn signatures(&self) -> Vec<(u8, &AnySignature)> {
        let mut values = vec![];
        for (idx, signature) in
            std::iter::zip(self.signatures_bitmap.iter_ones(), self.signatures.iter())
        {
            values.push((idx as u8, signature));
        }
        values
    }
```

**File:** types/src/transaction/authenticator.rs (L1132-1136)
```rust
#[derive(Clone, Debug, Eq, PartialEq, Hash, Serialize, Deserialize)]
pub struct MultiKey {
    public_keys: Vec<AnyPublicKey>,
    signatures_required: u8,
}
```

**File:** types/src/transaction/authenticator.rs (L1154-1164)
```rust
    pub fn new(public_keys: Vec<AnyPublicKey>, signatures_required: u8) -> Result<Self> {
        ensure!(
            signatures_required > 0,
            "The number of required signatures is 0."
        );

        ensure!(
            public_keys.len() <= MAX_NUM_OF_SIGS, // This max number of signatures is also the max number of public keys.
            "The number of public keys is greater than {}.",
            MAX_NUM_OF_SIGS
        );
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L2881-2884)
```rust
        if let SignatureVerifiedTransaction::Invalid(_) = txn {
            let vm_status = VMStatus::error(StatusCode::INVALID_SIGNATURE, None);
            let discarded_output = discarded_output(vm_status.status_code());
            return Ok((vm_status, discarded_output));
```

**File:** execution/executor/src/workflow/do_get_execution_output.rs (L92-100)
```rust
        THREAD_MANAGER.get_background_pool().spawn(move || {
            let _timer = OTHER_TIMERS.timer_with(&["async_update_counters__by_execution"]);
            for x in [&out.to_commit, &out.to_retry, &out.to_discard] {
                metrics::update_counters_for_processed_chunk(
                    &x.transactions,
                    &x.transaction_outputs,
                    "execution",
                )
            }
```

**File:** execution/executor/src/workflow/do_get_execution_output.rs (L125-128)
```rust
        let mut transactions = transactions
            .into_iter()
            .map(|t| t.into_inner())
            .collect_vec();
```

**File:** execution/executor/src/metrics.rs (L377-377)
```rust
            if detailed_counters {
```

**File:** execution/executor/src/metrics.rs (L404-414)
```rust
                        AccountAuthenticator::MultiKey { authenticator } => {
                            for (_, signature) in authenticator.signatures() {
                                signature_count += 1;
                                PROCESSED_TXNS_AUTHENTICATOR
                                    .with_label_values(&[
                                        process_type,
                                        &format!("{}_in_MultiKey", signature.name()),
                                    ])
                                    .inc();
                            }
                        },
```

**File:** aptos-node/src/utils.rs (L69-74)
```rust
    if node_config
        .execution
        .processed_transactions_detailed_counters
    {
        AptosVM::set_processed_transactions_detailed_counters();
    }
```
