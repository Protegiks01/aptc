# Audit Report

## Title
Validator Node Crash on Startup Due to Missing Parent Directory Creation in OnDiskStorage

## Summary
The `OnDiskStorage::new()` function in `secure/storage/src/on_disk.rs` does not create parent directories before attempting to create the storage file. If the parent directory does not exist, the node will panic during initialization, causing a validator node crash and potential network liveness degradation.

## Finding Description

The `OnDiskStorage` component is used by the consensus layer's `SafetyRules` to persist critical safety data [1](#0-0) . During initialization, `OnDiskStorage::new()` attempts to create the storage file using `File::create()` without first ensuring the parent directory exists [2](#0-1) .

The `File::create()` function in Rust will fail with an IO error if the parent directory does not exist. This error is caught by `unwrap_or_else()` which triggers a panic, immediately crashing the validator node [3](#0-2) .

The vulnerability manifests when:
1. `OnDiskStorageConfig` is configured with an absolute path to a non-existent directory [4](#0-3) 
2. The configuration specifies a path where the parent directory has been deleted or is not mounted
3. Deployment scripts fail to pre-create the required directory structure

During node startup, `SafetyRulesManager::new()` is called during consensus initialization [5](#0-4) , which converts the `SecureBackend::OnDiskStorage` configuration to a `Storage` instance [6](#0-5) . This conversion immediately calls `OnDiskStorage::new()` with the configured path, triggering the panic if the parent directory is missing.

## Impact Explanation

**Severity: Medium (Operational Reliability/Availability)**

This issue causes validator nodes to crash during startup if the storage directory structure is not properly initialized. While RocksDB creates the database directory automatically [7](#0-6) , the consensus safety storage can be configured with a different path that may not exist.

Impact on the network:
- **Single Validator**: Node cannot start until directory is manually created, reducing validator set size
- **Multiple Validators**: If multiple validators encounter this issue (e.g., due to shared deployment scripts or infrastructure problems), network liveness could be significantly degraded
- **Network Partition**: In extreme cases with coordinated infrastructure failures, this could contribute to network partition scenarios

This qualifies as Medium severity under Aptos bug bounty criteria as it can cause "State inconsistencies requiring intervention" - validators cannot participate in consensus until manual intervention creates the required directories.

## Likelihood Explanation

**Likelihood: Low-Medium**

In normal production deployments using standard configurations, this issue is unlikely because:
- Default configurations use relative paths that resolve to the data directory [8](#0-7) 
- RocksDB database initialization typically creates the base data directory before consensus starts [9](#0-8) 

However, likelihood increases in scenarios involving:
- Custom deployment configurations with absolute paths
- Infrastructure automation failures
- Container/VM provisioning issues where volumes are not properly mounted
- Manual validator setup without proper documentation
- Recovery scenarios after filesystem corruption or data loss

## Recommendation

Add defensive directory creation in `OnDiskStorage::new_with_time_service()` before attempting to create the file:

```rust
fn new_with_time_service(file_path: PathBuf, time_service: TimeService) -> Self {
    if !file_path.exists() {
        // Create parent directories if they don't exist
        if let Some(parent) = file_path.parent() {
            std::fs::create_dir_all(parent)
                .unwrap_or_else(|_| panic!("Unable to create parent directory: {:?}", parent));
        }
        
        File::create(&file_path)
            .unwrap_or_else(|_| panic!("Unable to create storage at path: {:?}", file_path));
    }

    let file_dir = file_path
        .parent()
        .map_or_else(PathBuf::new, |p| p.to_path_buf());

    Self {
        file_path,
        temp_path: TempPath::new_with_temp_dir(file_dir),
        time_service,
    }
}
```

This ensures that all parent directories are created before attempting file creation, following Rust best practices for filesystem operations.

## Proof of Concept

```rust
// Test demonstrating the panic with missing parent directory
#[test]
#[should_panic(expected = "Unable to create storage at path")]
fn test_on_disk_storage_missing_parent_directory() {
    use aptos_temppath::TempPath;
    use std::path::PathBuf;
    
    // Create a temporary directory that we'll use as base
    let temp_dir = TempPath::new();
    temp_dir.create_as_dir().unwrap();
    
    // Create a path with a non-existent parent directory
    let non_existent_parent = temp_dir.path().join("missing_dir").join("secure-data.json");
    
    // Ensure the parent doesn't exist
    assert!(!non_existent_parent.parent().unwrap().exists());
    
    // This should panic because the parent directory doesn't exist
    let _storage = OnDiskStorage::new(non_existent_parent);
}

// Test demonstrating successful creation when parent exists
#[test]
fn test_on_disk_storage_with_existing_parent() {
    use aptos_temppath::TempPath;
    
    let temp_dir = TempPath::new();
    temp_dir.create_as_dir().unwrap();
    
    // Create the parent directory
    let parent = temp_dir.path().join("existing_dir");
    std::fs::create_dir_all(&parent).unwrap();
    
    let storage_path = parent.join("secure-data.json");
    
    // This should succeed because parent exists
    let _storage = OnDiskStorage::new(storage_path);
}
```

## Notes

While this issue is rated as Medium severity, its real-world exploitability is limited because:

1. **Not directly exploitable by external attackers**: Requires filesystem access or configuration control
2. **Mitigated by standard deployments**: Production configurations use relative paths and proper initialization
3. **Fail-safe behavior**: Node crashes immediately on startup rather than operating in an inconsistent state

This is primarily an **operational reliability** issue rather than a security vulnerability in the strict sense. However, it should be fixed to improve deployment robustness and follow defensive programming practices. The fix is straightforward and adds minimal overhead while significantly improving reliability in edge cases and non-standard deployment scenarios.

### Citations

**File:** consensus/safety-rules/src/safety_rules_manager.rs (L21-26)
```rust
pub fn storage(config: &SafetyRulesConfig) -> PersistentSafetyStorage {
    let backend = &config.backend;
    let internal_storage: Storage = backend.into();
    if let Err(error) = internal_storage.available() {
        panic!("Storage is not available: {:?}", error);
    }
```

**File:** secure/storage/src/on_disk.rs (L34-38)
```rust
    fn new_with_time_service(file_path: PathBuf, time_service: TimeService) -> Self {
        if !file_path.exists() {
            File::create(&file_path)
                .unwrap_or_else(|_| panic!("Unable to create storage at path: {:?}", file_path));
        }
```

**File:** config/src/config/secure_backend_config.rs (L140-146)
```rust
    pub fn path(&self) -> PathBuf {
        if self.path.is_relative() {
            self.data_dir.join(&self.path)
        } else {
            self.path.clone()
        }
    }
```

**File:** config/src/config/secure_backend_config.rs (L166-172)
```rust
            SecureBackend::OnDiskStorage(config) => {
                let storage = Storage::from(OnDiskStorage::new(config.path()));
                if let Some(namespace) = &config.namespace {
                    Storage::from(Namespaced::new(namespace, Box::new(storage)))
                } else {
                    storage
                }
```

**File:** consensus/src/epoch_manager.rs (L209-210)
```rust
        let safety_rules_manager = SafetyRulesManager::new(sr_config);
        let key_storage = safety_rules_manager::storage(sr_config);
```

**File:** storage/rocksdb-options/src/lib.rs (L38-41)
```rust
    if !readonly {
        db_opts.create_if_missing(true);
        db_opts.create_missing_column_families(true);
    }
```

**File:** docker/compose/aptos-node/validator.yaml (L12-14)
```yaml
      type: "on_disk_storage"
      path: secure-data.json
      namespace: ~
```

**File:** aptos-node/src/lib.rs (L704-705)
```rust
    let (db_rw, backup_service, genesis_waypoint, indexer_db_opt, update_receiver) =
        storage::initialize_database_and_checkpoints(&mut node_config)?;
```
