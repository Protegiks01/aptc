# Audit Report

## Title
Non-Deterministic Storage Errors Can Cause Consensus Failures During Module Publishing

## Summary
The `finish_with_module_publishing_and_initialization()` function contains multiple code paths that can produce `STORAGE_ERROR` (StatusCode 2008) when underlying storage operations fail. Since `STORAGE_ERROR` is classified as an InvariantViolation error, it causes transactions to be discarded rather than included in blocks. If validators experience different storage failures due to hardware issues, database corruption, or I/O errors, they will disagree on which transactions to include, violating the deterministic execution invariant and potentially causing consensus failures.

## Finding Description

The vulnerability exists across three storage access points in the module publishing flow:

**Error Path 1:** Module existence check at [1](#0-0) 

This calls `unmetered_check_module_exists()` which internally uses `get_module_or_build_with()` at [2](#0-1) . Storage failures during module loading propagate as errors.

**Error Path 2:** Module metadata retrieval at [3](#0-2) , which calls `convert_modules_into_write_ops()` that fetches module metadata at [4](#0-3) 

The implementation at [5](#0-4)  calls `get_state_value()` which can fail with storage errors, converted to `STORAGE_ERROR` via the `module_storage_error!` macro.

**Error Path 3:** Read-before-write enforcement at [6](#0-5) 

This explicitly converts `StateViewError` to `STORAGE_ERROR`. The `read_state_value` implementation at [7](#0-6)  calls `get_state_value()` which can return `StateViewError::Other(String)` for various storage failures at [8](#0-7) 

**The Critical Issue:** `STORAGE_ERROR` (code 2008) is defined as an InvariantViolation error at [9](#0-8)  (in the 2000-2999 range at [10](#0-9) ).

When transactions are processed, InvariantViolation errors cause them to be **discarded** rather than kept, as shown in the `keep_or_discard()` function at [11](#0-10) 

**Consensus Impact:** If Validator A experiences a storage error (disk corruption, I/O failure) while Validator B does not:
- Validator A: Storage fails → `STORAGE_ERROR` → InvariantViolation → Transaction discarded
- Validator B: Storage succeeds → Transaction included in block
- Result: Validators disagree on block contents → Consensus failure

This violates the fundamental invariant that all validators must produce identical state roots for identical blocks.

## Impact Explanation

**Severity: Critical** - Consensus/Safety Violation

This meets the Critical severity criteria from the Aptos bug bounty program: "Consensus/Safety violations" and potentially "Non-recoverable network partition (requires hardfork)."

The vulnerability breaks **Invariant #1: Deterministic Execution** - "All validators must produce identical state roots for identical blocks." When validators experience different storage errors, they no longer execute deterministically, even with identical inputs and blockchain state.

The impact affects:
- **Consensus safety**: Validators may fail to reach agreement on blocks containing module publishing transactions
- **Network availability**: Persistent storage failures on a subset of validators could prevent the network from making progress
- **State consistency**: Different validators may have different views of which modules are published

## Likelihood Explanation

**Likelihood: Medium to High** in production environments.

Storage failures are not theoretical - they occur regularly in distributed systems:
- **Hardware failures**: Disk failures, bad sectors, controller errors
- **I/O errors**: Transient read/write failures, timeouts
- **Database corruption**: SQLite corruption, RocksDB inconsistencies  
- **Resource exhaustion**: Disk full, inode exhaustion affecting reads
- **Software bugs**: Storage implementation bugs causing intermittent failures

In a network with hundreds of validators running diverse hardware configurations, the probability that at least one validator experiences a storage error during module publishing operations is substantial. The issue becomes more likely as:
- Network size increases (more validators = higher probability of individual failures)
- Module publishing frequency increases
- Validators run on heterogeneous infrastructure with varying reliability

Unlike cryptographic vulnerabilities that require sophisticated attacks, this vulnerability is triggered by mundane operational issues that occur naturally in production systems.

## Recommendation

**Immediate Fix:** Storage errors should **halt the validator** rather than discard transactions. Validators experiencing storage errors have corrupted local state and cannot safely participate in consensus.

**Implementation:**

1. Modify error handling to distinguish between deterministic errors (transaction invalid) and non-deterministic errors (validator infrastructure failure)

2. When `STORAGE_ERROR` occurs during transaction execution, the validator should:
   - Log a critical alert indicating storage subsystem failure
   - Halt transaction processing
   - Enter a safe mode that prevents voting on proposals
   - Trigger operator alerting for immediate investigation

3. Update the error classification in `vm_status.rs` or add special handling in the consensus layer to recognize storage errors as validator failures rather than transaction failures

**Code Fix Pattern:**
```rust
// In execution layer, before returning STORAGE_ERROR to consensus:
match execution_result {
    Err(status) if status.status_code() == StatusCode::STORAGE_ERROR => {
        // Log critical alert
        error!("CRITICAL: Storage subsystem failure detected. Validator cannot safely continue.");
        // Signal to consensus layer that this validator should halt
        return Err(ValidatorHaltRequired(status));
    }
    other => other
}
```

This ensures that storage failures cause the affected validator to safely exit consensus rather than causing network-wide disagreement.

## Proof of Concept

Due to the nature of this vulnerability (requiring actual storage failures), a complete PoC requires simulating storage errors. Here's a conceptual Rust test demonstrating the issue:

```rust
#[test]
fn test_storage_error_causes_consensus_divergence() {
    // Setup: Two validators with identical state
    let mut validator_a = setup_validator_with_storage(FailingStorage::new());
    let mut validator_b = setup_validator_with_storage(HealthyStorage::new());
    
    // Create a module publishing transaction
    let txn = create_module_publishing_transaction();
    
    // Execute on both validators
    let result_a = validator_a.execute_transaction(&txn);
    let result_b = validator_b.execute_transaction(&txn);
    
    // Validator A should get STORAGE_ERROR and discard transaction
    assert!(matches!(result_a, 
        Err(VMStatus::Error { 
            status_code: StatusCode::STORAGE_ERROR, 
            .. 
        })
    ));
    
    // Validator B should succeed and keep transaction
    assert!(matches!(result_b, Ok(KeptVMStatus::Executed)));
    
    // CONSENSUS FAILURE: Validators disagree on whether to include transaction
    assert_ne!(
        result_a.is_ok(), 
        result_b.is_ok(),
        "Validators disagree on transaction inclusion due to storage error"
    );
}
```

**Notes**

- This vulnerability is triggered by operational failures rather than malicious attacks
- The core issue is treating non-deterministic infrastructure failures (storage errors) the same as deterministic transaction validation failures
- The fix requires validators to recognize when they have infrastructure failures and safely halt rather than silently disagreeing with the network
- Proper monitoring and alerting around storage errors is critical for validator operators

### Citations

**File:** aptos-move/aptos-vm/src/move_vm_ext/session/user_transaction_sessions/user.rs (L115-117)
```rust
            if module_storage
                .unmetered_check_module_exists(module.self_addr(), module.self_name())?
            {
```

**File:** aptos-move/aptos-vm/src/move_vm_ext/session/user_transaction_sessions/user.rs (L194-200)
```rust
        let write_ops = convert_modules_into_write_ops(
            resolver,
            features,
            module_storage,
            staging_module_storage.release_verified_module_bundle(),
        )
        .map_err(|e| e.finish(Location::Undefined))?;
```

**File:** third_party/move/move-vm/runtime/src/storage/module_storage.rs (L191-198)
```rust
    fn unmetered_check_module_exists(
        &self,
        address: &AccountAddress,
        module_name: &IdentStr,
    ) -> VMResult<bool> {
        let id = ModuleId::new(*address, module_name.to_owned());
        Ok(self.get_module_or_build_with(&id, self)?.is_some())
    }
```

**File:** aptos-move/aptos-vm/src/move_vm_ext/write_op_converter.rs (L93-94)
```rust
            let state_value_metadata =
                module_storage.unmetered_get_module_state_value_metadata(addr, name)?;
```

**File:** aptos-move/aptos-vm/src/move_vm_ext/write_op_converter.rs (L117-123)
```rust
            self.remote.read_state_value(&state_key).map_err(|err| {
                let msg = format!(
                    "Error when enforcing read-before-write for module {}::{}: {:?}",
                    addr, name, err
                );
                PartialVMError::new(StatusCode::STORAGE_ERROR).with_message(msg)
            })?;
```

**File:** aptos-move/aptos-vm-types/src/module_and_script_storage/state_view_adapter.rs (L164-178)
```rust
    fn unmetered_get_module_state_value_metadata(
        &self,
        address: &AccountAddress,
        module_name: &IdentStr,
    ) -> PartialVMResult<Option<StateValueMetadata>> {
        let state_key = StateKey::module(address, module_name);
        Ok(self
            .storage
            .module_storage()
            .byte_storage()
            .state_view
            .get_state_value(&state_key)
            .map_err(|err| module_storage_error!(address, module_name, err).to_partial())?
            .map(|state_value| state_value.into_metadata()))
    }
```

**File:** aptos-move/aptos-vm-types/src/resolver.rs (L262-265)
```rust
    fn read_state_value(&self, state_key: &Self::Key) -> Result<(), StateViewError> {
        self.get_state_value(state_key)?;
        Ok(())
    }
```

**File:** types/src/state_store/errors.rs (L7-15)
```rust
pub enum StateViewError {
    #[error("{0} not found.")]
    NotFound(String),
    /// Other non-classified error.
    #[error("{0}")]
    Other(String),
    #[error(transparent)]
    BcsError(#[from] bcs::Error),
}
```

**File:** third_party/move/move-core/types/src/vm_status.rs (L29-33)
```rust
/// The minimum status code for invariant violation statuses
pub static INVARIANT_VIOLATION_STATUS_MIN_CODE: u64 = 2000;

/// The maximum status code for invariant violation statuses
pub static INVARIANT_VIOLATION_STATUS_MAX_CODE: u64 = 2999;
```

**File:** third_party/move/move-core/types/src/vm_status.rs (L299-300)
```rust
                    StatusType::InvariantViolation => Err(code),
                    // A transaction that publishes code that cannot be verified will be charged.
```

**File:** third_party/move/move-core/types/src/vm_status.rs (L841-841)
```rust
    STORAGE_ERROR = 2008,
```
