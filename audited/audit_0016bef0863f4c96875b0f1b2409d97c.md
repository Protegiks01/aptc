# Audit Report

## Title
Missing Event Count Limit Enables Transaction Processing DoS via Event Flooding

## Summary
The Aptos VM lacks an explicit limit on the number of events that can be emitted per transaction. While total event size is capped at 10 MB, an attacker can emit tens of thousands of minimal-sized events within gas limits, causing memory exhaustion, computation overhead, and validator slowdowns during post-execution processing (event hashing and accumulation).

## Finding Description

The event emission system in Aptos has a critical design flaw: it validates only the **total byte size** of events per transaction, not the **count** of events. This allows a malicious contract to emit an excessive number of tiny events that pass size validation but impose significant computational and memory burdens on all validators.

**Vulnerable Code Path:**

1. **Event Collection (No Count Check):** Events are collected in an unbounded `Vec` during transaction execution without any count validation. [1](#0-0) 

2. **Event Emission (Unbounded Push):** Each event emission simply pushes to the vector with only gas charging. [2](#0-1) 

3. **Size-Only Validation:** Post-execution validation only checks total bytes, not event count. [3](#0-2) 

4. **Gas Schedule Limits:** The size limits are defined but no count limit exists. [4](#0-3) 

5. **Post-Execution Processing Burden:** After execution, ALL events must be hashed and accumulated. [5](#0-4) 

**Attack Scenario:**

An attacker creates a Move contract that emits minimal events in a loop:

```move
struct TinyEvent has drop, store { v: u8 }

public entry fun flood_events() {
    let i = 0;
    while (i < 40000) {  // Within gas limits
        event::emit(TinyEvent { v: 1 });
        i = i + 1;
    }
}
```

Each tiny event consumes minimal gas (estimated ~20,000-50,000 gas) but the transaction can emit ~20,000-40,000 events within the `max_execution_gas` limit of 920,000,000 gas. These events:

1. **Memory Consumption:** 40,000 `ContractEvent` structs (~2-4 MB RAM per transaction)
2. **Hash Computation:** 40,000 individual cryptographic hash operations creating a 1.25 MB vector of hashes
3. **Accumulator Construction:** 40,000 Merkle tree append operations
4. **Database Write Load:** 40,000 event records to persist

All validators must perform this processing **for every such transaction**, creating a DoS vector.

**Invariant Violation:**

This breaks the **Resource Limits** invariant (#9): "All operations must respect gas, storage, and computational limits." While gas is charged for event *data*, the computational overhead of processing tens of thousands of events is not adequately bounded.

## Impact Explanation

**Severity: High** (per Aptos bug bounty: "Validator node slowdowns")

- **Validator Performance Degradation:** Each malicious transaction forces all validators to hash and process tens of thousands of events post-execution, consuming CPU cycles and memory outside the gas-metered execution phase
- **Network Throughput Reduction:** Processing time for each block increases as the event accumulator construction and hashing is serial per transaction
- **Memory Pressure:** While individual transactions may use only 2-4 MB, concurrent processing of multiple such transactions in a block could cause memory spikes
- **Database Bloat:** Persistent storage of tens of thousands of small events per transaction leads to rapid database growth

This does not reach "Critical" severity as it requires sustained transaction submission (not a single-transaction kill) and doesn't break consensus safety or cause fund loss, but significantly degrades validator performance.

## Likelihood Explanation

**Likelihood: High**

- **Low Attack Cost:** Emitting 40,000 events costs only normal gas fees (no special privileges needed)
- **Easy to Execute:** Simple Move loop can generate the attack payload
- **Broad Impact:** All validators must process these events, not just the transaction sender
- **Repeatable:** Attacker can submit multiple such transactions per block
- **No Detection:** The size-only check makes these transactions appear valid

The attack requires no validator access, no complex exploitation, and produces deterministic slowdowns on all nodes.

## Recommendation

Add an explicit maximum event count limit per transaction alongside the existing size limits:

**Configuration Addition:** [4](#0-3) 

Add a new parameter after line 172:
```rust
[
    max_events_per_transaction: NumSlots,
    { 5.. => "max_events_per_transaction" },
    1024, // Reasonable limit: 1024 events per transaction
]
```

**Validation Logic Addition:** [6](#0-5) 

Add `max_events_per_transaction: u64` field to `ChangeSetConfigs`. [3](#0-2) 

Add count validation before the size check loop:
```rust
// Check event count
let event_count = change_set.events_iter().count();
if event_count > self.max_events_per_transaction as usize {
    return storage_write_limit_reached(Some("Too many events."));
}
```

## Proof of Concept

**Move Module (`sources/event_flood.move`):**
```move
module attacker::event_flood {
    use std::event;

    #[event]
    struct TinyEvent has drop, store {
        value: u8,
    }

    public entry fun flood_with_events(iterations: u64) {
        let i = 0;
        while (i < iterations) {
            event::emit(TinyEvent { value: 1 });
            i = i + 1;
        }
    }
}
```

**Rust Test Harness:**
```rust
#[test]
fn test_event_count_dos() {
    let mut harness = MoveHarness::new();
    let account = harness.new_account_at(AccountAddress::from_hex_literal("0xcafe").unwrap());
    
    // Publish malicious module
    harness.publish_package(
        &account,
        &PathBuf::from("path/to/event_flood"),
    );
    
    // Execute with 40,000 events (within gas limits)
    let result = harness.run_entry_function(
        &account,
        str::parse("0xcafe::event_flood::flood_with_events").unwrap(),
        vec![],
        vec![bcs::to_bytes(&40000u64).unwrap()],
    );
    
    // Transaction succeeds but causes validator slowdown
    assert!(matches!(result, TransactionStatus::Keep(_)));
    
    // Verify event count exceeds reasonable limits
    let events = harness.get_events();
    assert!(events.len() > 30000); // Demonstrates excessive event emission
}
```

**Expected Behavior:** Transaction executes successfully, emitting tens of thousands of events, demonstrating the missing count limit.

**Notes**

The vulnerability stems from an incomplete resource limiting strategy that measures only data size (bytes) but not operation count (number of events). This is particularly problematic because:

1. Post-execution processing (hashing, accumulation) has `O(n)` complexity in event count
2. Memory quota tracking may not properly account for event structures [7](#0-6) 

3. The size limit of 10 MB allows ~10 million 1-byte events in theory, though gas limits reduce this to ~40,000 in practice

The fix should implement defense-in-depth by adding both count and size limits, ensuring predictable worst-case performance regardless of future gas schedule changes.

### Citations

**File:** aptos-move/framework/src/natives/event.rs (L33-36)
```rust
#[derive(Default, Tid)]
pub struct NativeEventContext {
    events: Vec<(ContractEvent, Option<MoveTypeLayout>)>,
}
```

**File:** aptos-move/framework/src/natives/event.rs (L140-149)
```rust
    let ctx = context.extensions_mut().get_mut::<NativeEventContext>();
    let event =
        ContractEvent::new_v1(key, seq_num, ty_tag, blob).map_err(|_| SafeNativeError::Abort {
            abort_code: ECANNOT_CREATE_EVENT,
        })?;
    // TODO(layouts): avoid cloning layouts for events with delayed fields.
    ctx.events.push((
        event,
        contains_delayed_fields.then(|| layout.as_ref().clone()),
    ));
```

**File:** aptos-move/aptos-vm-types/src/storage/change_set_configs.rs (L10-17)
```rust
pub struct ChangeSetConfigs {
    gas_feature_version: u64,
    max_bytes_per_write_op: u64,
    max_bytes_all_write_ops_per_transaction: u64,
    max_bytes_per_event: u64,
    max_bytes_all_events_per_transaction: u64,
    max_write_ops_per_transaction: u64,
}
```

**File:** aptos-move/aptos-vm-types/src/storage/change_set_configs.rs (L115-125)
```rust
        let mut total_event_size = 0;
        for event in change_set.events_iter() {
            let size = event.event_data().len() as u64;
            if size > self.max_bytes_per_event {
                return storage_write_limit_reached(None);
            }
            total_event_size += size;
            if total_event_size > self.max_bytes_all_events_per_transaction {
                return storage_write_limit_reached(None);
            }
        }
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L164-172)
```rust
            max_bytes_per_event: NumBytes,
            { 5.. => "max_bytes_per_event" },
            1 << 20, // a single event is 1MB max
        ],
        [
            max_bytes_all_events_per_transaction: NumBytes,
            { 5.. => "max_bytes_all_events_per_transaction"},
            10 << 20, // all events from a single transaction are 10MB max
        ],
```

**File:** execution/executor/src/workflow/do_ledger_update.rs (L69-75)
```rust
                let event_hashes = txn_output
                    .events()
                    .iter()
                    .map(CryptoHash::hash)
                    .collect::<Vec<_>>();
                let event_root_hash =
                    InMemoryEventAccumulator::from_leaves(&event_hashes).root_hash();
```

**File:** aptos-move/aptos-memory-usage-tracker/src/lib.rs (L311-315)
```rust
        self.should_leak_memory_for_native = (*module_id.address() == CORE_CODE_ADDRESS
            && module_id.name().as_str() == "table")
            || (self.feature_version() >= 4
                && *module_id.address() == CORE_CODE_ADDRESS
                && module_id.name().as_str() == "event");
```
