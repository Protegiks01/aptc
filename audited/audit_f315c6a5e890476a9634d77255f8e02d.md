# Audit Report

## Title
Unbounded Module Cache in Consensus Pipeline Enables Memory Exhaustion DoS Attack

## Summary
The `CachedModuleView` used in the consensus pipeline's randomness check has no size limits on its internal module cache. Attackers can deploy thousands of unique modules and submit transactions calling them, causing validators to cache unbounded amounts of compiled module data in memory, leading to OOM crashes and network unavailability.

## Finding Description

The vulnerability exists in the consensus pipeline's randomness checking mechanism. When processing blocks, the `rand_check_future()` function loads every entry function's module into an unbounded cache.

**The Vulnerable Components:**

1. **Unbounded Cache Structure**: `CachedModuleView` uses `UnsyncModuleCache` which is simply a `RefCell<HashMap>` with no size limits or eviction policy. [1](#0-0) 

2. **Module Loading in Consensus**: The consensus pipeline iterates through all user transactions and loads their modules into this cache without any size checks. [2](#0-1) 

3. **Persistent Cache**: The cache persists across blocks and only gets reset when state views are incompatible, not based on size. [3](#0-2) 

4. **No Size Tracking**: The `CachedModuleView` structure contains the unbounded cache with no memory tracking. [4](#0-3) 

**Attack Flow:**

1. Attacker deploys thousands of unique modules (e.g., 10,000 modules Ã— 1KB each = 10MB on-chain, costing ~400 APT in storage fees)
2. Attacker submits transactions calling entry functions from these unique modules
3. During block processing, `rand_check_future()` calls `unmetered_get_deserialized_module()` for each transaction
4. Each unique module gets deserialized and cached in the `UnsyncModuleCache` HashMap
5. The cache grows indefinitely as more unique modules are referenced
6. Eventually exhausts validator memory, causing OOM crashes

**Broken Invariants:**
- **Move VM Safety**: "Bytecode execution must respect gas limits and memory constraints" - module caching bypasses memory constraints
- **Resource Limits**: "All operations must respect gas, storage, and computational limits" - no limit on cached module count
- **Consensus Safety**: OOM crashes cause validator failures, potentially breaking consensus

## Impact Explanation

This is a **HIGH to CRITICAL severity** vulnerability:

**High Severity** ($50,000): Directly causes "Validator node slowdowns" as memory fills up, degrading performance before OOM.

**Critical Severity** ($1,000,000): Can escalate to "Total loss of liveness/network availability" if enough validators experience OOM crashes simultaneously, preventing block production and finalization.

The attack is economically feasible - deploying 10,000 small modules costs approximately 400 APT (~$3,000-4,000 at current prices), making it affordable for a determined attacker to cause network-wide disruption.

## Likelihood Explanation

**Likelihood: HIGH**

1. **Easy to Execute**: Attacker only needs to deploy modules and submit transactions - no special privileges required
2. **Low Cost**: Storage fees for modules are predictable and relatively low compared to impact
3. **Undetectable**: Module deployment and transaction submission are legitimate operations
4. **Wide Impact**: Affects all validators processing blocks containing these transactions
5. **No Automatic Mitigation**: Cache never gets cleared based on size, only on state view mismatches

The attack is highly practical and can be executed by any user with sufficient APT for gas and storage fees.

## Recommendation

Implement bounded cache with LRU eviction policy for `CachedModuleView`:

```rust
// In module_view.rs
pub struct CachedModuleView<S> {
    pub state_view: S,
    pub environment: AptosEnvironment,
    pub module_cache: BoundedModuleCache<ModuleId, CompiledModule, Module, AptosModuleExtension, usize>,
    max_cache_size_bytes: usize,
}

impl<S: StateView> CachedModuleView<S> {
    pub fn new_with_limit(state_view: S, max_cache_size_bytes: usize) -> Self {
        let environment = AptosEnvironment::new(&state_view);
        Self {
            state_view,
            environment,
            module_cache: BoundedModuleCache::new(max_cache_size_bytes),
            max_cache_size_bytes,
        }
    }
}
```

**Specific Fixes:**

1. Add `max_module_cache_size_in_bytes` configuration (similar to `BlockExecutorModuleCacheLocalConfig`) [5](#0-4) 

2. Implement size tracking in `UnsyncModuleCache` using module extension's `size_in_bytes()` method
3. Add eviction logic when cache exceeds size limit (LRU or random eviction)
4. Set default limit to reasonable value (e.g., 100MB per validator)

## Proof of Concept

```move
// File: malicious_modules.move
// Deploy thousands of these with unique addresses/names

module attacker_addr::module_0 {
    public entry fun trigger() { }
}

module attacker_addr::module_1 {
    public entry fun trigger() { }
}

// ... repeat for module_2 through module_9999
```

```rust
// Rust exploitation script
use aptos_sdk::transaction_builder::TransactionBuilder;

async fn exploit_cache_exhaustion() {
    // Step 1: Deploy 10,000 unique modules
    for i in 0..10000 {
        let module_code = generate_unique_module(i);
        let txn = TransactionBuilder::new()
            .publish_package(module_code)
            .build();
        submit_transaction(txn).await;
    }
    
    // Step 2: Submit transactions calling each module
    for i in 0..10000 {
        let txn = TransactionBuilder::new()
            .entry_function(
                format!("attacker_addr::module_{}::trigger", i),
                vec![],
                vec![]
            )
            .build();
        submit_transaction(txn).await;
    }
    
    // Validators will cache all 10,000 modules in memory
    // With ~1KB per module = ~10MB uncompressed
    // Repeat with more modules to exhaust memory
}
```

**Expected Result**: Validator memory usage grows continuously as unique modules accumulate in cache, eventually causing OOM crashes when memory is exhausted.

## Notes

The vulnerability also affects `ModuleView` which has a similar unbounded cache structure, though it's less critical as it's typically used in shorter-lived contexts. The primary concern is `CachedModuleView` in the consensus pipeline where the cache persists across many blocks. [6](#0-5)

### Citations

**File:** third_party/move/move-vm/types/src/code/cache/module_cache.rs (L210-226)
```rust
/// Non-[Sync] version of module cache suitable for sequential execution.
pub struct UnsyncModuleCache<K, DC, VC, E, V> {
    module_cache: RefCell<HashMap<K, VersionedModuleCode<DC, VC, E, V>>>,
}

impl<K, DC, VC, E, V> UnsyncModuleCache<K, DC, VC, E, V>
where
    K: Eq + Hash + Clone,
    VC: Deref<Target = Arc<DC>>,
    V: Clone + Default + Ord,
{
    /// Returns an empty module cache.
    pub fn empty() -> Self {
        Self {
            module_cache: RefCell::new(HashMap::new()),
        }
    }
```

**File:** consensus/src/pipeline/pipeline_builder.rs (L711-729)
```rust
            let mut cache_guard = module_cache.lock();
            if let Some(cache_mut) = cache_guard.as_mut() {
                // flush the cache if the execution state view is not linear
                // in case of speculative executing a forked block
                let previous_state_view = cache_mut.state_view_id();
                let expected_state_view = StateViewId::BlockExecution {
                    block_id: grand_parent_id,
                };
                if previous_state_view == expected_state_view {
                    cache_mut.reset_state_view(parent_state_view);
                } else {
                    counters::RAND_BLOCK
                        .with_label_values(&["reset_cache"])
                        .inc();
                    cache_mut.reset_all(parent_state_view);
                }
            } else {
                *cache_guard = Some(CachedModuleView::new(parent_state_view));
            }
```

**File:** consensus/src/pipeline/pipeline_builder.rs (L732-742)
```rust
            for txn in user_txns.iter() {
                if let Some(txn) = txn.borrow_into_inner().try_as_signed_user_txn() {
                    if let Ok(TransactionExecutableRef::EntryFunction(entry_fn)) =
                        txn.executable_ref()
                    {
                        // use the deserialized API to avoid cloning the metadata
                        // should migrate once we move metadata into the extension and avoid cloning
                        if let Ok(Some(module)) = cache_ref.unmetered_get_deserialized_module(
                            entry_fn.module().address(),
                            entry_fn.module().name(),
                        ) {
```

**File:** aptos-move/aptos-resource-viewer/src/module_view.rs (L34-50)
```rust
pub struct ModuleView<'a, S> {
    module_cache: RefCell<HashMap<ModuleId, Arc<CompiledModule>>>,
    deserializer_config: DeserializerConfig,
    state_view: &'a S,
}

impl<'a, S: StateView> ModuleView<'a, S> {
    pub fn new(state_view: &'a S) -> Self {
        let features = Features::fetch_config(state_view).unwrap_or_default();
        let deserializer_config = aptos_prod_deserializer_config(&features);

        Self {
            module_cache: RefCell::new(HashMap::new()),
            deserializer_config,
            state_view,
        }
    }
```

**File:** aptos-move/aptos-resource-viewer/src/module_view.rs (L93-103)
```rust
pub struct CachedModuleView<S> {
    /// The raw snapshot of the state used for validation.
    pub state_view: S,
    /// Stores configs needed for execution.
    pub environment: AptosEnvironment,
    /// Versioned cache for deserialized and verified Move modules. The versioning allows to detect
    /// when the version of the code is no longer up-to-date (a newer version has been committed to
    /// the state view) and update the cache accordingly.
    pub module_cache:
        UnsyncModuleCache<ModuleId, CompiledModule, Module, AptosModuleExtension, usize>,
}
```

**File:** types/src/block_executor/config.rs (L58-59)
```rust
    // Otherwise, if there is an error in either of the execution, we will panic.
    pub allow_fallback: bool,
```
