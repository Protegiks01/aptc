# Audit Report

## Title
Royalty Bait-and-Switch: TOCTOU Vulnerability in NFT Marketplace Royalty Enforcement

## Summary
The Aptos TokenV1 marketplace implementation suffers from a time-of-check to time-of-use (TOCTOU) vulnerability where token creators can front-run purchase transactions by mutating royalty values immediately before execution, causing buyers to pay significantly higher royalties than expected. Event visibility does not prevent this economic attack.

## Finding Description

The vulnerability exists in the interaction between three components:

1. **Royalty Mutation**: The `mutate_tokendata_royalty()` function allows creators to change royalty settings instantly without any time locks or restrictions [1](#0-0) 

2. **Dynamic Royalty Reading**: The marketplace's `compute_royalty()` function reads royalty values at purchase execution time, not at listing time [2](#0-1) 

3. **Royalty Enforcement**: The `complete_purchase()` function calculates and extracts royalty charges during the purchase transaction [3](#0-2) 

**Attack Flow:**

1. Creator creates TokenV1 with `mutability_config.royalty = true` and initial royalty of 1% (1/100)
2. Primary buyer purchases token, observing the 1% royalty
3. Primary buyer lists token on secondary marketplace at fixed price of 1000 APT
4. Secondary buyer sees listing with 1% royalty (10 APT expected royalty)
5. Secondary buyer submits purchase transaction to mempool
6. **Malicious creator monitors mempool, detects purchase transaction**
7. **Creator front-runs by calling `mutate_tokendata_royalty()` with 100% royalty (100/100)**
8. Creator's transaction executes first, updating `token_data.royalty` [4](#0-3) 

9. Buyer's purchase transaction executes, calling `get_tokendata_royalty()` which reads the CURRENT value [5](#0-4) 

10. Buyer pays 1000 APT royalty instead of expected 10 APT (990 APT loss)

**Why Event Visibility Doesn't Prevent This:**

The `RoyaltyMutateEvent` is emitted by the mutation function, but events are informational logs onlyâ€”they provide no on-chain security controls: [6](#0-5) 

By the time the event is visible off-chain, the buyer's transaction is already committed on-chain with the inflated royalty charge.

## Impact Explanation

**Severity: Medium** (per Aptos Bug Bounty criteria: "Limited funds loss or manipulation")

**Economic Impact:**
- Secondary buyers can lose up to 100% of their purchase price to unexpected royalty charges
- For a 10,000 APT NFT purchase, a creator can extract up to 10,000 APT vs. expected 100 APT (1% royalty)
- Affects all TokenV1 NFTs with mutable royalty settings
- Undermines trust in Aptos NFT marketplaces

**Scope:**
- Impacts TokenV1 standard (legacy but still widely used)
- Affects all marketplace implementations using the standard royalty enforcement pattern
- Does not affect consensus or validator operations
- Limited to economic harm, not protocol-level compromise

This qualifies as Medium severity because it enables "limited funds loss" through manipulation of marketplace economics, not catastrophic protocol failure.

## Likelihood Explanation

**Likelihood: High**

**Attacker Requirements:**
- Creator must set `mutability_config.royalty = true` when creating token (common for "flexibility")
- Creator must monitor mempool or marketplace listings (standard MEV infrastructure)
- Creator must have sufficient gas to front-run (minimal cost)

**Incentives:**
- High profit potential: extract up to 99% additional value from sales
- Low risk: creator has legitimate control over royalty mutation
- Automatable: MEV bots can execute this attack pattern

**Real-World Feasibility:**
- Mempool monitoring is standard practice for MEV extraction on all blockchains
- Front-running infrastructure already exists in Aptos ecosystem
- No technical barriers to execution
- Economic incentive aligns with rational malicious behavior

## Recommendation

**Solution 1: Royalty Snapshot at Listing Time (Preferred)**

Modify the marketplace to store a royalty snapshot when the listing is created, rather than reading royalty dynamically at purchase time:

```move
// In listing.move, add to Listing struct:
struct Listing has key {
    // ... existing fields ...
    royalty_snapshot: Option<RoyaltySnapshot>,
}

struct RoyaltySnapshot has store {
    payee_address: address,
    numerator: u64,
    denominator: u64,
}

// Capture royalty at listing initialization:
public(friend) fun init(...) {
    let royalty_snapshot = capture_current_royalty(object);
    // Store in Listing struct
}

// Use snapshot in compute_royalty instead of reading current value:
public fun compute_royalty(object: Object<Listing>, amount: u64): (address, u64) {
    let listing = borrow_listing(object);
    if (option::is_some(&listing.royalty_snapshot)) {
        let snapshot = option::borrow(&listing.royalty_snapshot);
        // Use snapshot values
    }
}
```

**Solution 2: Rate Limiting on Royalty Changes**

Add a cooldown period between royalty mutations:

```move
// In token.move TokenData struct:
struct TokenData has store {
    // ... existing fields ...
    last_royalty_mutation_time: u64,
}

// In mutate_tokendata_royalty:
public fun mutate_tokendata_royalty(...) {
    let now = timestamp::now_seconds();
    assert!(
        now >= token_data.last_royalty_mutation_time + ROYALTY_COOLDOWN_SECONDS,
        error::invalid_state(EROYALTY_COOLDOWN_ACTIVE)
    );
    token_data.last_royalty_mutation_time = now;
    // ... rest of mutation logic
}
```

**Solution 3: Maximum Royalty Change Limit**

Restrict the magnitude of royalty changes per mutation:

```move
const MAX_ROYALTY_CHANGE_PERCENTAGE: u64 = 10; // 10% max change

public fun mutate_tokendata_royalty(...) {
    let old_percentage = (token_data.royalty.numerator * 100) / token_data.royalty.denominator;
    let new_percentage = (royalty.numerator * 100) / royalty.denominator;
    
    assert!(
        abs_diff(old_percentage, new_percentage) <= MAX_ROYALTY_CHANGE_PERCENTAGE,
        error::invalid_argument(EROYALTY_CHANGE_TOO_LARGE)
    );
}
```

**Recommendation: Implement Solution 1** (royalty snapshot) as it provides the strongest protection while maintaining creator flexibility for future listings.

## Proof of Concept

```move
#[test(aptos_framework = @0x1, marketplace = @0x111, creator = @0x222, buyer = @0x333)]
fun test_royalty_bait_and_switch(
    aptos_framework: &signer,
    marketplace: &signer,
    creator: &signer,
    buyer: &signer,
) {
    // Setup accounts with sufficient balance
    test_utils::setup(aptos_framework, marketplace, creator, buyer);
    
    // Step 1: Creator creates token with LOW royalty (1%) and mutability=true
    let collection_name = string::utf8(b"Test Collection");
    let token_name = string::utf8(b"Test Token");
    
    tokenv1::create_collection_script(
        creator,
        collection_name,
        string::utf8(b"Description"),
        string::utf8(b"https://example.com"),
        0,
        vector[false, false, false], // collection mutability
    );
    
    let mutate_setting = vector[false, false, true, false, false]; // royalty mutable
    
    tokenv1::create_token_script(
        creator,
        collection_name,
        token_name,
        string::utf8(b"Token Description"),
        1, // balance
        1, // maximum
        string::utf8(b"https://example.com/token"),
        signer::address_of(creator), // royalty payee
        100, // denominator
        1,   // numerator (1% royalty)
        mutate_setting,
        vector::empty(),
        vector::empty(),
        vector::empty(),
    );
    
    // Step 2: Create marketplace listing at 1000 APT
    let token_id = tokenv1::create_token_id_raw(
        signer::address_of(creator),
        collection_name,
        token_name,
        0
    );
    
    let fee_schedule = test_utils::fee_schedule(marketplace);
    let token_container = listing::create_tokenv1_container(
        creator,
        signer::address_of(creator),
        collection_name,
        token_name,
        0
    );
    
    let listing = coin_listing::init_fixed_price_internal<AptosCoin>(
        creator,
        object::convert(token_container),
        fee_schedule,
        timestamp::now_seconds(),
        1000, // price: 1000 APT
    );
    
    // Step 3: Verify initial royalty is 1% (buyer sees this)
    let (royalty_addr, royalty_amount) = listing::compute_royalty(listing, 1000);
    assert!(royalty_amount == 10, 0); // Expected: 1% of 1000 = 10 APT
    
    let creator_balance_before = coin::balance<AptosCoin>(signer::address_of(creator));
    
    // Step 4: ATTACK - Creator front-runs buyer by mutating royalty to 100%
    let token_data_id = tokenv1::create_token_data_id(
        signer::address_of(creator),
        collection_name,
        token_name,
    );
    
    let high_royalty = tokenv1::create_royalty(
        100, // numerator
        100, // denominator (100% royalty!)
        signer::address_of(creator),
    );
    
    tokenv1::mutate_tokendata_royalty(creator, token_data_id, high_royalty);
    
    // Step 5: Buyer's purchase executes with NEW royalty value
    coin_listing::purchase<AptosCoin>(buyer, listing);
    
    // Step 6: Verify creator received 100% royalty (1000 APT) instead of 1% (10 APT)
    let creator_balance_after = coin::balance<AptosCoin>(signer::address_of(creator));
    let royalty_received = creator_balance_after - creator_balance_before;
    
    assert!(royalty_received == 1000, 1); // Creator received FULL payment as royalty
    // Buyer lost 990 APT more than expected!
}
```

## Notes

This vulnerability specifically affects the **TokenV1** standard implementation. The newer **Token Objects (TokenV2)** standard may have different characteristics and should be audited separately. The vulnerability is rooted in the fundamental design decision to read royalty values dynamically rather than capturing them at commitment time (listing creation), combined with unrestricted creator mutation capabilities.

### Citations

**File:** aptos-move/framework/aptos-token/sources/token.move (L831-850)
```text
    public fun mutate_tokendata_royalty(creator: &signer, token_data_id: TokenDataId, royalty: Royalty) acquires Collections {
        assert_tokendata_exists(creator, token_data_id);

        let all_token_data = &mut Collections[token_data_id.creator].token_data;
        let token_data = all_token_data.borrow_mut(token_data_id);
        assert!(token_data.mutability_config.royalty, error::permission_denied(EFIELD_NOT_MUTABLE));

        token_event_store::emit_token_royalty_mutate_event(
            creator,
            token_data_id.collection,
            token_data_id.name,
            token_data.royalty.royalty_points_numerator,
            token_data.royalty.royalty_points_denominator,
            token_data.royalty.payee_address,
            royalty.royalty_points_numerator,
            royalty.royalty_points_denominator,
            royalty.payee_address
        );
        token_data.royalty = royalty;
    }
```

**File:** aptos-move/framework/aptos-token/sources/token.move (L1662-1670)
```text
    public fun get_tokendata_royalty(token_data_id: TokenDataId): Royalty acquires Collections {
        let creator_address = token_data_id.creator;
        assert!(exists<Collections>(creator_address), error::not_found(ECOLLECTIONS_NOT_PUBLISHED));
        let all_token_data = &Collections[creator_address].token_data;
        assert!(all_token_data.contains(token_data_id), error::not_found(ETOKEN_DATA_NOT_PUBLISHED));

        let token_data = all_token_data.borrow(token_data_id);
        token_data.royalty
    }
```

**File:** aptos-move/move-examples/marketplace/sources/listing.move (L244-274)
```text
    public fun compute_royalty(
        object: Object<Listing>,
        amount: u64,
    ): (address, u64) acquires Listing, TokenV1Container {
        let listing = borrow_listing(object);
        let obj_addr = object::object_address(&listing.object);
        if (exists<TokenV1Container>(obj_addr)) {
            let token_container = borrow_global<TokenV1Container>(obj_addr);
            let token_id = tokenv1::get_token_id(&token_container.token);
            let royalty = tokenv1::get_royalty(token_id);

            let payee_address = tokenv1::get_royalty_payee(&royalty);
            let numerator = tokenv1::get_royalty_numerator(&royalty);
            let denominator = tokenv1::get_royalty_denominator(&royalty);
            let royalty_amount = bounded_percentage(amount, numerator, denominator);
            (payee_address, royalty_amount)
        } else {
            let royalty = tokenv2::royalty(listing.object);
            if (option::is_some(&royalty)) {
                let royalty = option::destroy_some(royalty);
                let payee_address = royalty::payee_address(&royalty);
                let numerator = royalty::numerator(&royalty);
                let denominator = royalty::denominator(&royalty);

                let royalty_amount = bounded_percentage(amount, numerator, denominator);
                (payee_address, royalty_amount)
            } else {
                (@0x0, 0)
            }
        }
    }
```

**File:** aptos-move/move-examples/marketplace/sources/coin_listing.move (L485-511)
```text
    inline fun complete_purchase<CoinType>(
        completer: &signer,
        purchaser_addr: address,
        object: Object<Listing>,
        coins: Coin<CoinType>,
        type: String,
    ) {
        let token_metadata = listing::token_metadata(object);

        let price = coin::value(&coins);
        let (royalty_addr, royalty_charge) = listing::compute_royalty(object, price);
        let (seller, fee_schedule) = listing::close(completer, object, purchaser_addr);

        // Take royalty first
        if (royalty_charge != 0) {
            let royalty = coin::extract(&mut coins, royalty_charge);
            aptos_account::deposit_coins(royalty_addr, royalty);
        };

        // Take commission of what's left, creators get paid first
        let commission_charge = fee_schedule::commission(fee_schedule, price);
        let actual_commission_charge = math64::min(coin::value(&coins), commission_charge);
        let commission = coin::extract(&mut coins, actual_commission_charge);
        aptos_account::deposit_coins(fee_schedule::fee_address(fee_schedule), commission);

        // Seller gets what is left
        aptos_account::deposit_coins(seller, coins);
```

**File:** aptos-move/framework/aptos-token/sources/token_event_store.move (L153-177)
```text
    struct RoyaltyMutateEvent has drop, store {
        creator: address,
        collection: String,
        token: String,
        old_royalty_numerator: u64,
        old_royalty_denominator: u64,
        old_royalty_payee_addr: address,
        new_royalty_numerator: u64,
        new_royalty_denominator: u64,
        new_royalty_payee_addr: address,
    }

    #[event]
    /// Event emitted when the token royalty is mutated
    struct RoyaltyMutate has drop, store {
        creator: address,
        collection: String,
        token: String,
        old_royalty_numerator: u64,
        old_royalty_denominator: u64,
        old_royalty_payee_addr: address,
        new_royalty_numerator: u64,
        new_royalty_denominator: u64,
        new_royalty_payee_addr: address,
    }
```
