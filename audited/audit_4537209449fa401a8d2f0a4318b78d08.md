# Audit Report

## Title
Function Type Compatibility Bypass Allowing ABI-Breaking Module Upgrades via gas_feature_version < 34

## Summary
When `gas_feature_version < RELEASE_V1_34` (value 38), the module compatibility checker uses a flawed comparison method for function types that performs simple representation equality instead of proper structural compatibility checks. This allows attackers to publish ABI-breaking module upgrades that violate Move's type safety guarantees, potentially causing type confusion and runtime errors in dependent contracts.

## Finding Description
The vulnerability exists in the module compatibility checking system used during module publishing. When a module is upgraded with the "compat" upgrade policy, the system must verify that the new version is backward compatible with the old version. [1](#0-0) 

The code intentionally sets `function_compat_bug = true` when `gas_feature_version < RELEASE_V1_34` (38), which triggers buggy behavior in the compatibility checker: [2](#0-1) 

When comparing function signature tokens (specifically first-class function types), the buggy code path uses simple equality `old_tok == new_tok` instead of the proper structural comparison that recursively checks argument types, result types, and abilities.

**Attack Path:**
1. Attacker publishes module M with function `public fun foo(f: |StructA|)` using "compat" upgrade policy
2. Dependent contracts are deployed that call `foo` with closures accepting `StructA`
3. Attacker crafts an upgrade where:
   - Function signature changes to `public fun foo(f: |StructB|)` 
   - Struct definitions are reordered to change StructHandleIndex values
   - The raw representation of `|StructA|` and `|StructB|` are different due to different struct indices
4. The buggy compatibility check compares the raw tokens and sees they're different, but incorrectly accepts the upgrade because it uses representation equality
5. Dependent contracts now call `foo` with `|StructA|` closures, but the upgraded function expects `|StructB|`, causing type confusion [3](#0-2) 

The compatibility check is invoked during module publishing: [4](#0-3) 

## Impact Explanation
This vulnerability meets **High Severity** criteria per Aptos bug bounty program as it constitutes a "Significant protocol violation":

1. **Breaks Move VM Safety Invariant**: Move's type system guarantees are violated, allowing type confusion at runtime
2. **Breaks Deterministic Execution**: Dependent contracts may behave unpredictably when type mismatches occur
3. **State Consistency Risk**: Type confusion during closure execution could lead to undefined behavior or VM crashes
4. **Protocol-wide Impact**: Affects all modules using first-class function types on networks with `gas_feature_version < 38`

The vulnerability breaks the fundamental guarantee that compatible module upgrades preserve type safety for dependent contracts.

## Likelihood Explanation
**Likelihood: Medium to Low** (but HIGH impact when exploited)

**Required conditions:**
1. Network must have `gas_feature_version < 38` configured on-chain (historical versions or private deployments)
2. Attacker must control a module with "compat" upgrade policy (not "immutable" or "arbitrary")
3. Module must use first-class function types (requires `enable_function_values` feature flag and bytecode VERSION_8+)
4. Dependent contracts must exist that call the vulnerable function

**Attacker capabilities:**
- No validator access required
- Standard module publishing permissions sufficient
- Knowledge of bytecode structure and struct handle indices needed

**Mitigation in current codebase:**
The current `LATEST_GAS_FEATURE_VERSION` is 45, well above the threshold. However, networks that haven't upgraded or test environments may still be vulnerable. [5](#0-4) 

## Recommendation
**For networks with gas_feature_version < 38:**
Immediately upgrade the on-chain `GasScheduleV2` configuration to set `feature_version >= 38` to enable the fix.

**For the codebase:**
The buggy behavior is intentionally preserved for backwards compatibility. Once all production networks have upgraded to gas_feature_version >= 38, remove the backwards compatibility code:

Remove the conditional check and always use proper structural comparison:
```rust
// In compatibility.rs, lines 478-491
(
    SignatureToken::Function(old_args, old_results, old_abilities),
    SignatureToken::Function(new_args, new_results, new_abilities),
) => {
    // Remove the bug compatibility branch entirely
    vec_ok(old_args, new_args)
        && vec_ok(old_results, new_results)
        && old_abilities == new_abilities
},
```

Remove the `function_type_compat_bug` field from the `Compatibility` struct and all related code paths. [6](#0-5) 

## Proof of Concept
The vulnerability is already demonstrated in the existing test case: [3](#0-2) 

**Test execution:**
1. First module published with `can_upgrade_wrong_type(f: |A|)`
2. Test module calls it with closure accepting type A
3. Module upgraded with structs reordered and signature changed to `can_upgrade_wrong_type(f: |B|)`
4. With bug enabled: upgrade succeeds (incorrectly)
5. Subsequent call causes type confusion between A and B

To reproduce on a network with `gas_feature_version < 38`, deploy the modules in sequence as shown in the test file.

## Notes
This is a **known issue** (bug #17171) that has been fixed in gas feature version 34 and above. The buggy behavior is intentionally preserved in the codebase for backwards compatibility with older network configurations. Networks running with current gas feature versions (â‰¥ 38) are not affected. However, test networks, private deployments, or historical data using older versions remain vulnerable to this ABI-breaking upgrade attack.

### Citations

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1574-1582)
```rust
        // TODO(#17171): remove this once 1.34 is in production.
        let function_compat_bug = self.gas_feature_version() < gas_feature_versions::RELEASE_V1_34;
        let compatibility_checks = Compatibility::new(
            check_struct_layout,
            check_friend_linking,
            self.timed_features()
                .is_enabled(TimedFeatureFlag::EntryCompatibility),
            function_compat_bug,
        );
```

**File:** third_party/move/move-binary-format/src/compatibility.rs (L38-41)
```rust
    /// A temporary flag to preserve compatibility.
    /// TODO(#17171): remove this once 1.34 rolled out
    function_type_compat_bug: bool,
}
```

**File:** third_party/move/move-binary-format/src/compatibility.rs (L478-491)
```rust
                SignatureToken::Function(old_args, old_results, old_abilities),
                SignatureToken::Function(new_args, new_results, new_abilities),
            ) => {
                // Before bug #17171 was fixed, function types where compared with representation
                // equality. Simulate this behavior if requested.
                // TODO(#17171): remove this once fix rolled out
                if self.function_type_compat_bug {
                    old_tok == new_tok
                } else {
                    vec_ok(old_args, new_args)
                        && vec_ok(old_results, new_results)
                        && old_abilities == new_abilities
                }
            },
```

**File:** third_party/move/move-vm/transactional-tests/tests/function_values_safety/compatibility_bug_17171.masm (L1-52)
```text
//# publish --verbose
module 0x66::m
struct A has drop     // StructHandleIndex = 0
    x: u64
struct B has drop     // StructHandleIndex = 1
    x: u64

// First publish with function |A|
public fun can_upgrade_wrong_type(f: |A|)
    ld_u64 32
    pack A
    move_loc f
    call_closure <|A|>
    ret

//# publish
module 0x66::test
use 0x66::m

public fun call_it()
    // Call the function using a closure of type |A|
    pack_closure action, 0
    call m::can_upgrade_wrong_type
    ret

fun action(x: m::A)
    ret

// Run it the function
//# run 0x66::test::call_it

//# publish --verbose
module 0x66::m
// We are swapping the order of A and B, such they get different struct handle
// indices assigned.
struct B has drop    // StructHandleIndex = 0
    x: u64
struct A has drop    // StructHandleIndex = 1
    x: u64

// Second publish with wrong type. This worked before #17171 was fixed,
// allowing to pass a `B` to `0x66::test::action`. This was only
// recognized during actual execution by paranoid mode.
public fun can_upgrade_wrong_type(f: |B|)
    ld_u64 32
    pack B
    move_loc f
    call_closure <|B|>
    ret

// Run it again, this time passing `B`. Should never reach this point.
//# run --verbose 0x66::test::call_it
```

**File:** third_party/move/move-vm/runtime/src/storage/publishing.rs (L175-193)
```rust
            if compatibility.need_check_compat() {
                // INVARIANT:
                //   Old module must be metered at the caller side.
                if let Some(old_module_ref) =
                    existing_module_storage.unmetered_get_deserialized_module(addr, name)?
                {
                    if !is_framework_for_option_enabled
                        && is_enum_option_enabled
                        && old_module_ref.self_id().is_option()
                        && old_module_ref.self_id() == compiled_module.self_id()
                    {
                        // skip check for option module during publishing
                    } else {
                        let old_module = old_module_ref.as_ref();
                        compatibility
                            .check(old_module, &compiled_module)
                            .map_err(|e| e.finish(Location::Undefined))?;
                    }
                }
```

**File:** aptos-move/aptos-gas-schedule/src/ver.rs (L76-76)
```rust
pub const LATEST_GAS_FEATURE_VERSION: u64 = gas_feature_versions::RELEASE_V1_41;
```
