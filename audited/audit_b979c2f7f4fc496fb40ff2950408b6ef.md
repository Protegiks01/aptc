# Audit Report

## Title
Missing Validation in Groth16 Verification Key Updates Enables Governance-Approved Storage DoS on Keyless Accounts

## Summary
The `set_groth16_verification_key_for_next_epoch` function in the keyless account module does not validate the size of vector fields before storing the verification key on-chain. While a `validate_groth16_vk` function exists, it is never called in production code paths. This allows a governance-approved proposal to set a verification key with arbitrarily large vectors (up to the 1MB transaction limit), causing state bloat and rendering all keyless accounts unusable until corrected via another governance proposal.

## Finding Description
The `Groth16VerificationKey` struct stores BN254 elliptic curve points as variable-length byte vectors: [1](#0-0) 

The Move framework defines corresponding fields without size constraints: [2](#0-1) 

A validation function exists that verifies these vectors can be deserialized as valid BN254 curve points: [3](#0-2) 

However, when updating the verification key via governance, this validation is never invoked: [4](#0-3) 

The config buffer's `upsert` function imposes no size validation: [5](#0-4) 

When validators fetch and attempt to use the verification key, the Rust deserialization strictly enforces expected sizes: [6](#0-5) [7](#0-6) 

If oversized vectors are stored (e.g., 100KB instead of 32 bytes for `alpha_g1`), the conversion to `PreparedVerifyingKey` fails during environment initialization: [8](#0-7) 

The failure is handled silently by returning `None`, causing all keyless transactions with ZK proofs to be rejected: [9](#0-8) 

**Attack Scenario:**
1. Malicious governance proposal calls `set_groth16_verification_key_for_next_epoch` with VK containing 100KB vectors per field
2. Transaction succeeds (within 1MB governance limit per [10](#0-9) )
3. VK stored in config buffer without validation
4. Next epoch applies the change via [11](#0-10) 
5. All validators fail to deserialize VK (`keyless_pvk` becomes `None`)
6. All keyless account transactions fail indefinitely
7. ~500KB of bloated state persists on all validators

## Impact Explanation
**Severity: High** (up to $50,000 per bug bounty criteria)

This constitutes a "Significant protocol violation" because:
- **Availability Impact**: All keyless accounts become completely unusable network-wide until a corrective governance proposal is executed and a new epoch begins
- **State Bloat**: Hundreds of kilobytes of invalid data persist in validator storage
- **Service Degradation**: Affects the keyless authentication feature introduced in AIP-61

This does NOT reach Critical severity because:
- No funds are lost or stolen
- Consensus safety is not violated
- Network liveness for non-keyless accounts remains intact
- Recovery is possible via governance (no hardfork required)

## Likelihood Explanation
**Likelihood: Low**

This vulnerability requires:
1. A malicious or erroneous governance proposal to be submitted
2. The proposal to receive sufficient votes to pass
3. Governance participants to fail to detect the invalid VK during review

**However, this represents a missing security control.** The validation function exists but is bypassed in the governance update path. Defense-in-depth principles require validation at the point of storage, not just at the point of use.

## Recommendation
Call `validate_groth16_vk` before storing the verification key in both genesis and governance update paths:

```move
public fun set_groth16_verification_key_for_next_epoch(fx: &signer, vk: Groth16VerificationKey) {
    system_addresses::assert_aptos_framework(fx);
    validate_groth16_vk(&vk);  // ADD THIS LINE
    config_buffer::upsert<Groth16VerificationKey>(vk);
}

public fun update_groth16_verification_key(fx: &signer, vk: Groth16VerificationKey) {
    system_addresses::assert_aptos_framework(fx);
    chain_status::assert_genesis();
    validate_groth16_vk(&vk);  // ADD THIS LINE
    move_to(fx, vk);
}
```

Additionally, add explicit size checks in `validate_groth16_vk` before attempting deserialization to fail fast:

```move
fun validate_groth16_vk(vk: &Groth16VerificationKey) {
    assert!(vector::length(&vk.alpha_g1) == 32, E_INVALID_BN254_G1_SERIALIZATION);
    assert!(vector::length(&vk.beta_g2) == 64, E_INVALID_BN254_G2_SERIALIZATION);
    assert!(vector::length(&vk.gamma_g2) == 64, E_INVALID_BN254_G2_SERIALIZATION);
    assert!(vector::length(&vk.delta_g2) == 64, E_INVALID_BN254_G2_SERIALIZATION);
    assert!(vector::length(&vk.gamma_abc_g1) == 2, E_INVALID_BN254_G1_SERIALIZATION);
    
    // Then proceed with existing deserialization checks...
    assert!(option::is_some(&crypto_algebra::deserialize<bn254_algebra::G1, bn254_algebra::FormatG1Compr>(&vk.alpha_g1)), E_INVALID_BN254_G1_SERIALIZATION);
    // ... rest of validation
}
```

## Proof of Concept

```move
#[test(aptos_framework = @0x1)]
#[expected_failure(abort_code = 0x10002, location = aptos_framework::keyless_account)]
fun test_oversized_vk_should_fail(aptos_framework: &signer) {
    use std::vector;
    use aptos_framework::keyless_account;
    
    // Create VK with oversized alpha_g1 (100KB instead of 32 bytes)
    let oversized_vector = vector::empty<u8>();
    let i = 0;
    while (i < 100000) {
        vector::push_back(&mut oversized_vector, 0xFF);
        i = i + 1;
    };
    
    // This should fail if validation is added
    let malicious_vk = keyless_account::new_groth16_verification_key(
        oversized_vector,                    // 100KB alpha_g1
        vector[0u8; 64],                     // Valid beta_g2
        vector[0u8; 64],                     // Valid gamma_g2  
        vector[0u8; 64],                     // Valid delta_g2
        vector[vector[0u8; 32], vector[0u8; 32]]  // Valid gamma_abc_g1
    );
    
    // Without validation, this would succeed and cause DoS
    keyless_account::set_groth16_verification_key_for_next_epoch(aptos_framework, malicious_vk);
}
```

**Note:** This vulnerability requires governance proposal approval to exploit, making it a **governance security issue** rather than a vulnerability exploitable by unprivileged attackers. The missing validation represents a defense-in-depth failure that could enable a malicious or compromised governance action to cause network-wide service degradation for keyless accounts.

### Citations

**File:** types/src/keyless/groth16_vk.rs (L24-31)
```rust
#[derive(Clone, Serialize, Deserialize, Eq, PartialEq, Debug, BCSCryptoHash, CryptoHasher)]
pub struct Groth16VerificationKey {
    pub alpha_g1: Vec<u8>,
    pub beta_g2: Vec<u8>,
    pub gamma_g2: Vec<u8>,
    pub delta_g2: Vec<u8>,
    pub gamma_abc_g1: Vec<Vec<u8>>,
}
```

**File:** aptos-move/framework/aptos-framework/sources/keyless_account.move (L32-45)
```text
    /// The 288-byte Groth16 verification key (VK) for the ZK relation that implements keyless accounts
    struct Groth16VerificationKey has key, store, drop {
        /// 32-byte serialization of `alpha * G`, where `G` is the generator of `G1`.
        alpha_g1: vector<u8>,
        /// 64-byte serialization of `alpha * H`, where `H` is the generator of `G2`.
        beta_g2: vector<u8>,
        /// 64-byte serialization of `gamma * H`, where `H` is the generator of `G2`.
        gamma_g2: vector<u8>,
        /// 64-byte serialization of `delta * H`, where `H` is the generator of `G2`.
        delta_g2: vector<u8>,
        /// `\forall i \in {0, ..., \ell}, 64-byte serialization of gamma^{-1} * (beta * a_i + alpha * b_i + c_i) * H`, where
        /// `H` is the generator of `G1` and `\ell` is 1 for the ZK relation.
        gamma_abc_g1: vector<vector<u8>>,
    }
```

**File:** aptos-move/framework/aptos-framework/sources/keyless_account.move (L183-192)
```text
    fun validate_groth16_vk(vk: &Groth16VerificationKey) {
        // Could be leveraged to speed up the VM deserialization of the VK by 2x, since it can assume the points are valid.
        assert!(option::is_some(&crypto_algebra::deserialize<bn254_algebra::G1, bn254_algebra::FormatG1Compr>(&vk.alpha_g1)), E_INVALID_BN254_G1_SERIALIZATION);
        assert!(option::is_some(&crypto_algebra::deserialize<bn254_algebra::G2, bn254_algebra::FormatG2Compr>(&vk.beta_g2)), E_INVALID_BN254_G2_SERIALIZATION);
        assert!(option::is_some(&crypto_algebra::deserialize<bn254_algebra::G2, bn254_algebra::FormatG2Compr>(&vk.gamma_g2)), E_INVALID_BN254_G2_SERIALIZATION);
        assert!(option::is_some(&crypto_algebra::deserialize<bn254_algebra::G2, bn254_algebra::FormatG2Compr>(&vk.delta_g2)), E_INVALID_BN254_G2_SERIALIZATION);
        for (i in 0..vector::length(&vk.gamma_abc_g1)) {
            assert!(option::is_some(&crypto_algebra::deserialize<bn254_algebra::G1, bn254_algebra::FormatG1Compr>(vector::borrow(&vk.gamma_abc_g1, i))), E_INVALID_BN254_G1_SERIALIZATION);
        };
    }
```

**File:** aptos-move/framework/aptos-framework/sources/keyless_account.move (L263-266)
```text
    public fun set_groth16_verification_key_for_next_epoch(fx: &signer, vk: Groth16VerificationKey) {
        system_addresses::assert_aptos_framework(fx);
        config_buffer::upsert<Groth16VerificationKey>(vk);
    }
```

**File:** aptos-move/framework/aptos-framework/sources/keyless_account.move (L358-368)
```text
    public(friend) fun on_new_epoch(fx: &signer) acquires Groth16VerificationKey, Configuration {
        system_addresses::assert_aptos_framework(fx);

        if (config_buffer::does_exist<Groth16VerificationKey>()) {
            let vk = config_buffer::extract_v2();
            if (exists<Groth16VerificationKey>(@aptos_framework)) {
                *borrow_global_mut<Groth16VerificationKey>(@aptos_framework) = vk;
            } else {
                move_to(fx, vk);
            }
        };
```

**File:** aptos-move/framework/aptos-framework/sources/configs/config_buffer.move (L65-70)
```text
    public(friend) fun upsert<T: drop + store>(config: T) acquires PendingConfigs {
        let configs = borrow_global_mut<PendingConfigs>(@aptos_framework);
        let key = type_info::type_name<T>();
        let value = any::pack(config);
        simple_map::upsert(&mut configs.configs, key, value);
    }
```

**File:** aptos-move/framework/src/natives/cryptography/algebra/serialization.rs (L546-558)
```rust
        (Some(Structure::BN254G1), Some(SerializationFormat::BN254G1Compressed)) => {
            // Valid BN254G1AffineCompressed serialization should be 32-byte.
            if bytes.len() != 32 {
                return Ok(smallvec![Value::bool(false), Value::u64(0)]);
            }
            ark_ec_point_deserialize_internal!(
                context,
                bytes,
                ark_bn254::G1Affine,
                deserialize_compressed,
                ALGEBRA_ARK_BN254_G1_AFFINE_DESER_COMP
            )
        },
```

**File:** aptos-move/framework/src/natives/cryptography/algebra/serialization.rs (L572-583)
```rust
        (Some(Structure::BN254G2), Some(SerializationFormat::BN254G2Compressed)) => {
            // Valid BN254G2AffineCompressed serialization should be 64-byte.
            if bytes.len() != 64 {
                return Ok(smallvec![Value::bool(false), Value::u64(0)]);
            }
            ark_ec_point_deserialize_internal!(
                context,
                bytes,
                ark_bn254::G2Affine,
                deserialize_compressed,
                ALGEBRA_ARK_BN254_G2_AFFINE_DESER_COMP
            )
```

**File:** aptos-move/aptos-vm-environment/src/environment.rs (L289-293)
```rust
        let keyless_pvk =
            Groth16VerificationKey::fetch_keyless_config(state_view).and_then(|(vk, vk_bytes)| {
                sha3_256.update(&vk_bytes);
                vk.try_into().ok()
            });
```

**File:** aptos-move/aptos-vm/src/keyless_validation.rs (L188-191)
```rust
    // If there are ZK authenticators, the Groth16 VK must have been set on-chain.
    if with_zk && pvk.is_none() {
        return Err(invalid_signature!("Groth16 VK has not been set on-chain"));
    }
```

**File:** aptos-move/aptos-vm/src/gas.rs (L26-26)
```rust
const MAXIMUM_APPROVED_TRANSACTION_SIZE_LEGACY: u64 = 1024 * 1024;
```
