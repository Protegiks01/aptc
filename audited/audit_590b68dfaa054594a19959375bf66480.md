# Audit Report

## Title
Redis Credential Exposure Through Debug Trait in Indexer GRPC Services

## Summary
The `RedisUrl` struct in the indexer-grpc services derives the `Debug` trait and implements `Display`, both of which expose the full Redis connection URL including embedded credentials. These credentials are leaked through stdout logging, error messages, and panic handlers in multiple locations across the indexer infrastructure, potentially allowing attackers with log access to compromise the Redis cache.

## Finding Description

The vulnerability exists in the `RedisUrl` struct definition where both `Debug` and `Display` traits expose the complete URL: [1](#0-0) [2](#0-1) 

The `Display` implementation directly outputs the inner `Url` which typically contains credentials in the format `redis://:[password]@host:port` or `redis://username:password@host:port`.

**Critical Exposure Point 1 - Direct stdout logging:** [3](#0-2) 

The Redis URL is printed directly to stdout using the Debug formatter during normal service startup, exposing credentials in application logs.

**Critical Exposure Point 2 - Error context messages:** [4](#0-3) [5](#0-4) [6](#0-5) 

When Redis connection fails, error messages containing the full URL (including credentials) are created via `.with_context()` and propagated through the error chain.

**Critical Exposure Point 3 - Panic handler:** [7](#0-6) 

The panic handler logs full error chains (including credentials) via both `error!` macro and `eprintln!`, ensuring the sensitive data reaches both structured logs and stderr.

**Attack Scenario:**
1. Indexer service starts or encounters Redis connection error
2. Credentials are logged to stdout/stderr or error logs
3. Attacker with log access (via compromised monitoring dashboard, log aggregation system, or misconfigured container logs) extracts Redis credentials
4. Attacker uses credentials to access Redis cache and either:
   - Extract sensitive indexer data
   - Poison cache with malicious blockchain data affecting downstream consumers
   - Execute `FLUSHALL` causing denial of service

## Impact Explanation

This qualifies as **Medium Severity** per the original classification because:

1. **Information Disclosure**: Direct exposure of authentication credentials violates the principle of least privilege and defense in depth
2. **State Inconsistencies**: Compromised Redis credentials enable cache poisoning attacks that could cause state inconsistencies in the indexer data, affecting wallets, explorers, and dApps that rely on this infrastructure
3. **Service Availability**: Attackers with Redis access can flush the cache, causing degraded service for all indexer consumers

While this doesn't directly compromise blockchain consensus, the indexer infrastructure is critical for the Aptos ecosystem's usability and security posture.

## Likelihood Explanation

**Likelihood: Medium-High**

The vulnerability triggers during normal operations:
- Credentials are logged on every service startup (config.rs:162-165)
- Credentials appear in error logs whenever Redis connection fails
- Container orchestration systems commonly capture and centralize stdout/stderr
- Log aggregation systems (Datadog, Splunk, CloudWatch) may have weak access controls
- Insider threats or compromised adjacent systems can access logs

Many production deployments expose logs through monitoring dashboards without proper access controls, making credential extraction feasible for attackers with initial foothold.

## Recommendation

Implement a custom `Debug` and `Display` trait that redacts credentials:

```rust
impl Display for RedisUrl {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        // Redact password from URL
        let mut url_clone = self.0.clone();
        if url_clone.password().is_some() {
            let _ = url_clone.set_password(Some("***REDACTED***"));
        }
        if url_clone.username() != "" {
            let _ = url_clone.set_username("***REDACTED***");
        }
        write!(f, "{}", url_clone)
    }
}

impl std::fmt::Debug for RedisUrl {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        // Use Display implementation for Debug as well
        write!(f, "RedisUrl({})", self)
    }
}
```

Remove the derived `Debug` trait and implement it manually:

```rust
#[derive(Clone, Eq, PartialEq, Serialize)]
pub struct RedisUrl(pub Url);
```

Remove the direct credential logging:

```rust
// Remove or redact this line in config.rs
// println!(">>>> Starting Redis connection: {:?}", &self.redis_read_replica_address.0);
println!(">>>> Starting Redis connection to {}", self.redis_read_replica_address.host_str().unwrap_or("unknown"));
```

## Proof of Concept

**Reproduction Steps:**

1. Deploy indexer-grpc-data-service with a Redis URL containing credentials:
   ```yaml
   redis_read_replica_address: "redis://:supersecretpassword@redis.internal:6379"
   ```

2. Start the service and observe stdout:
   ```bash
   cargo run --bin aptos-indexer-grpc-data-service -- --config-path config.yaml
   ```

3. **Expected vulnerable output:**
   ```
   >>>> Starting Redis connection: Url { scheme: "redis", host: Some(Domain("redis.internal")), port: Some(6379), path: "", query: None, fragment: None }
   ```
   Note: The Debug representation may expose the password through the internal Url structure.

4. Trigger a Redis connection failure (stop Redis or use wrong host):
   ```yaml
   redis_read_replica_address: "redis://:supersecretpassword@invalid-host:6379"
   ```

5. **Expected vulnerable error output:**
   ```
   Error: Failed to create redis client for redis://:supersecretpassword@invalid-host:6379
   ```

The credentials are visible in both normal operation logs and error messages, confirming the vulnerability.

## Notes

While this vulnerability affects the indexer infrastructure rather than core blockchain consensus, it represents a significant security weakness in the Aptos ecosystem. The indexer services are critical for:
- Wallets retrieving account balances and transaction history
- Block explorers displaying blockchain data
- DApps querying blockchain state
- Analytics platforms processing on-chain metrics

Compromising the Redis cache through credential theft could enable sophisticated attacks including:
- Cache poisoning to display false balances or transactions
- Targeted censorship of specific addresses' transaction history
- Denial of service through cache invalidation

The fix is straightforward and should be implemented across all services handling sensitive connection strings.

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/types.rs (L13-14)
```rust
#[derive(Clone, Debug, Eq, PartialEq, Serialize)]
pub struct RedisUrl(pub Url);
```

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/types.rs (L58-62)
```rust
impl Display for RedisUrl {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.0)
    }
}
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service/src/config.rs (L162-165)
```rust
        println!(
            ">>>> Starting Redis connection: {:?}",
            &self.redis_read_replica_address.0
        );
```

**File:** ecosystem/indexer-grpc/indexer-grpc-cache-worker/src/worker.rs (L84-90)
```rust
        let redis_client = redis::Client::open(redis_main_instance_address.0.clone())
            .with_context(|| {
                format!(
                    "[Indexer Cache] Failed to create redis client for {}",
                    redis_main_instance_address
                )
            })?;
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service/src/service.rs (L110-114)
```rust
            redis_client: Arc::new(
                redis::Client::open(redis_address.0.clone()).with_context(|| {
                    format!("Failed to create redis client for {}", redis_address)
                })?,
            ),
```

**File:** ecosystem/indexer-grpc/indexer-grpc-file-store/src/processor.rs (L44-58)
```rust
        let conn = redis::Client::open(redis_main_instance_address.0.clone())
            .with_context(|| {
                format!(
                    "Create redis client for {} failed",
                    redis_main_instance_address.0
                )
            })?
            .get_tokio_connection_manager()
            .await
            .with_context(|| {
                format!(
                    "Create redis connection to {} failed.",
                    redis_main_instance_address.0
                )
            })?;
```

**File:** ecosystem/indexer-grpc/indexer-grpc-server-framework/src/lib.rs (L156-168)
```rust
fn handle_panic(panic_info: &PanicHookInfo<'_>) {
    // The Display formatter for a PanicHookInfo contains the message, payload and location.
    let details = format!("{}", panic_info);
    let backtrace = format!("{:#?}", Backtrace::new());
    let info = CrashInfo { details, backtrace };
    let crash_info = toml::to_string_pretty(&info).unwrap();
    error!("{}", crash_info);
    // TODO / HACK ALARM: Write crash info synchronously via eprintln! to ensure it is written before the process exits which error! doesn't guarantee.
    // This is a workaround until https://github.com/aptos-labs/aptos-core/issues/2038 is resolved.
    eprintln!("{}", crash_info);
    // Kill the process
    process::exit(12);
}
```
