# Audit Report

## Title
Unbounded Proof Count in DKG Schnorr Batch Verification Enables DoS via Resource Exhaustion

## Summary

The `pok_batch_verify()` function in the DKG PVSS implementation lacks any upper bound on the number of proofs (`n`) it processes. An attacker can craft a malicious DKG transcript containing millions of Schnorr proofs-of-knowledge (SoKs), causing validator nodes to exhaust memory and CPU resources during verification, leading to denial of service.

## Finding Description

The vulnerability exists in the DKG transcript verification flow where Schnorr proof-of-knowledge batch verification is performed without checking the number of proofs being verified.

**Attack Flow:**

1. An attacker crafts a malicious `DKGTranscript` by serializing a `Transcript` object with an arbitrarily large `soks` vector (e.g., 1,000,000 elements)
2. The attacker submits this as a DKG result transaction to the network
3. When a validator processes this transaction via the VM, the transcript is deserialized without size limits [1](#0-0) 
4. The verification calls `verify_transcript()` which invokes transcript verification [2](#0-1) 
5. This calls `trx.main.verify()` BEFORE any dealer count validation [3](#0-2) 
6. The `verify()` method calls `batch_verify_soks()` with the entire soks array [4](#0-3) 
7. This in turn calls `pok_batch_verify()` with all proofs [5](#0-4) 
8. The batch verification function has NO limit on `n` and performs resource-intensive operations [6](#0-5) 

**Resource Exhaustion Details:**

In `pok_batch_verify()`, when processing `n` proofs:
- Allocates vectors with capacity `2 * n + 1` for bases and exponents [7](#0-6) 
- Computes `gamma^i` for all i in [0, n-1] via iterative multiplication [8](#0-7) 
- Loops through all n proofs performing hash computations and scalar multiplications [9](#0-8) 
- Performs multi-exponentiation on `2*n + 1` group elements [10](#0-9) 

With n = 1,000,000:
- Memory: Allocates ~2 million group elements and scalars
- CPU: 1 million exponentiations plus expensive multi-exponentiation

**Why Existing Checks Don't Prevent This:**

The `Transcript` struct stores soks as an unbounded vector [11](#0-10)  and can be deserialized from arbitrary bytes [12](#0-11) . The `check_sizes()` validation only verifies V, R, and C array sizes, but NOT the soks count [13](#0-12) . Dealer validation in `verify_transcript_extra()` happens separately and after the resource-intensive batch verification.

This breaks the **Resource Limits** invariant: "All operations must respect gas, storage, and computational limits."

## Impact Explanation

**Severity: High** (up to $50,000 per Aptos Bug Bounty criteria)

This vulnerability enables validator node denial of service:
- **Validator node slowdowns**: A single malicious transaction forces validators to perform millions of cryptographic operations
- **API crashes**: Nodes may crash due to memory exhaustion or timeout
- **Network availability**: Multiple such transactions could impact network liveness by stalling validator nodes

While this doesn't directly cause consensus safety violations or fund loss, it impacts network availability and validator operations, qualifying as High severity under "Validator node slowdowns" and "API crashes" categories.

## Likelihood Explanation

**Likelihood: High**

The attack is:
- **Easy to execute**: Any transaction sender can submit DKG transcripts without special privileges
- **Low cost**: Single transaction submission with minimal gas costs
- **No prior knowledge required**: Attacker only needs to craft a serialized transcript with large soks vector
- **Difficult to detect**: Transaction appears valid until verification begins
- **Repeatable**: Attacker can submit multiple such transactions

The only limitation is that malicious transcripts would eventually fail validation, but resource exhaustion occurs before failure is detected.

## Recommendation

Add a maximum limit on the number of proofs in `pok_batch_verify()` and validate soks count before verification:

```rust
// In crates/aptos-dkg/src/pvss/schnorr.rs
const MAX_BATCH_PROOF_COUNT: usize = 1000; // Based on expected max validators

pub fn pok_batch_verify<'a, Gr>(
    poks: &Vec<(Gr, PoK<Gr>)>,
    g: &Gr,
    gamma: &Scalar,
) -> anyhow::Result<()>
where
    Gr: Serialize + Group + Mul<&'a Scalar> + HasMultiExp,
{
    let n = poks.len();
    if n > MAX_BATCH_PROOF_COUNT {
        bail!("Too many proofs: {} exceeds maximum {}", n, MAX_BATCH_PROOF_COUNT);
    }
    // ... rest of function
}
```

Additionally, add soks count validation in `check_sizes()`:

```rust
// In crates/aptos-dkg/src/pvss/das/weighted_protocol.rs
fn check_sizes(&self, sc: &WeightedConfigBlstrs) -> anyhow::Result<()> {
    let W = sc.get_total_weight();
    
    // Add soks validation
    let num_players = sc.get_total_num_players();
    if self.soks.len() > num_players {
        bail!("Too many soks: {} exceeds number of players {}", 
              self.soks.len(), num_players);
    }
    
    // ... existing checks
}
```

## Proof of Concept

```rust
use aptos_dkg::pvss::das::weighted_protocol::Transcript;
use aptos_crypto::bls12381;
use blstrs::{G1Projective, Scalar};

// Craft malicious transcript with excessive soks
fn create_malicious_transcript() -> Vec<u8> {
    let mut transcript = Transcript::dummy();
    
    // Add 100,000 fake SoKs (in practice could be millions)
    let fake_sok = (
        Player { id: 0 },
        G1Projective::identity(),
        bls12381::Signature::dummy_signature(),
        (G1Projective::identity(), Scalar::ZERO)
    );
    
    for _ in 0..100_000 {
        transcript.soks.push(fake_sok.clone());
    }
    
    // Serialize to bytes
    bcs::to_bytes(&transcript).unwrap()
}

// Submitting this as a DKG transaction will cause validators to:
// 1. Deserialize successfully (no limit)
// 2. Attempt batch verification of 100,000 proofs
// 3. Allocate 200,001 element vectors
// 4. Compute 100,000 exponentiations
// 5. Exhaust memory/CPU before validation fails
```

**Notes:**
- The actual limit should be set based on the maximum expected validator set size (currently `MAX_VALIDATOR_SET_SIZE = 65536` [14](#0-13) )
- Transcript aggregation can combine multiple dealers' soks [15](#0-14) , so the limit should account for this
- The vulnerability is exploitable because deserialization and verification occur before comprehensive validation of dealer counts and indices

### Citations

**File:** aptos-move/aptos-vm/src/validator_txns/dkg.rs (L106-109)
```rust
        let transcript = bcs::from_bytes::<<DefaultDKG as DKGTrait>::Transcript>(
            dkg_node.transcript_bytes.as_slice(),
        )
        .map_err(|_| Expected(TranscriptDeserializationFailed))?;
```

**File:** aptos-move/aptos-vm/src/validator_txns/dkg.rs (L111-112)
```rust
        DefaultDKG::verify_transcript(&pub_params, &transcript)
            .map_err(|_| Expected(TranscriptVerificationFailed))?;
```

**File:** types/src/dkg/real_dkg/mod.rs (L368-374)
```rust
        trx.main.verify(
            &params.pvss_config.wconfig,
            &params.pvss_config.pp,
            &spks,
            &all_eks,
            &aux,
        )?;
```

**File:** crates/aptos-dkg/src/pvss/das/weighted_protocol.rs (L58-58)
```rust
    soks: Vec<SoK<G1Projective>>,
```

**File:** crates/aptos-dkg/src/pvss/das/weighted_protocol.rs (L82-90)
```rust
impl TryFrom<&[u8]> for Transcript {
    type Error = CryptoMaterialError;

    fn try_from(bytes: &[u8]) -> Result<Self, Self::Error> {
        // NOTE: The `serde` implementation in `blstrs` already performs the necessary point validation
        // by ultimately calling `GroupEncoding::from_bytes`.
        bcs::from_bytes::<Transcript>(bytes).map_err(|_| CryptoMaterialError::DeserializationError)
    }
}
```

**File:** crates/aptos-dkg/src/pvss/das/weighted_protocol.rs (L302-309)
```rust
        batch_verify_soks::<G1Projective, A>(
            self.soks.as_slice(),
            g_1,
            &self.V[W],
            spks,
            auxs,
            sok_vrfy_challenge,
        )?;
```

**File:** crates/aptos-dkg/src/pvss/das/weighted_protocol.rs (L405-407)
```rust
        for sok in &other.soks {
            self.soks.push(sok.clone());
        }
```

**File:** crates/aptos-dkg/src/pvss/das/weighted_protocol.rs (L415-455)
```rust
    fn check_sizes(&self, sc: &WeightedConfigBlstrs) -> anyhow::Result<()> {
        let W = sc.get_total_weight();

        if self.V.len() != W + 1 {
            bail!(
                "Expected {} G_2 (polynomial) commitment elements, but got {}",
                W + 1,
                self.V.len()
            );
        }

        if self.V_hat.len() != W + 1 {
            bail!(
                "Expected {} G_2 (polynomial) commitment elements, but got {}",
                W + 1,
                self.V_hat.len()
            );
        }

        if self.R.len() != W {
            bail!(
                "Expected {} G_1 commitment(s) to ElGamal randomness, but got {}",
                W,
                self.R.len()
            );
        }

        if self.R_hat.len() != W {
            bail!(
                "Expected {} G_2 commitment(s) to ElGamal randomness, but got {}",
                W,
                self.R_hat.len()
            );
        }

        if self.C.len() != W {
            bail!("Expected C of length {}, but got {}", W, self.C.len());
        }

        Ok(())
    }
```

**File:** crates/aptos-dkg/src/pvss/contribution.rs (L76-76)
```rust
    schnorr::pok_batch_verify::<Gr>(&poks, pk_base, &tau)?;
```

**File:** crates/aptos-dkg/src/pvss/schnorr.rs (L77-86)
```rust
    let n = poks.len();
    let mut exps = Vec::with_capacity(2 * n + 1);
    let mut bases = Vec::with_capacity(2 * n + 1);

    // Compute \gamma_i = \gamma^i, for all i \in [0, n]
    let mut gammas = Vec::with_capacity(n);
    gammas.push(Scalar::ONE);
    for _ in 0..(n - 1) {
        gammas.push(gammas.last().unwrap().mul(gamma));
    }
```

**File:** crates/aptos-dkg/src/pvss/schnorr.rs (L89-99)
```rust
    for i in 0..n {
        let (pk, (R, s)) = poks[i];

        bases.push(R);
        exps.push(gammas[i]);

        bases.push(pk);
        exps.push(schnorr_hash(Challenge::<Gr> { R, pk, g: *g }) * gammas[i]);

        last_exp += s * gammas[i];
    }
```

**File:** crates/aptos-dkg/src/pvss/schnorr.rs (L104-104)
```rust
    if Gr::multi_exp_iter(bases.iter(), exps.iter()) != Gr::identity() {
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L100-100)
```text
    const MAX_VALIDATOR_SET_SIZE: u64 = 65536;
```
