# Audit Report

## Title
Missing Epoch Ending Ledger Info Verification Causes Bootstrap Synchronization Failure

## Summary
The `get_end_of_epoch_ledger_info()` function in the bootstrapper queries `verified_epoch_states` for epoch ending ledger info at `payload_end_version`, but returns `None` when this version was never verified. If the payload actually contains an epoch-ending transaction at this unverified version, the chunk executor will detect the epoch change during execution and reject the chunk, causing synchronization failure and preventing nodes from completing the bootstrap process. [1](#0-0) 

## Finding Description
The vulnerability occurs in the state synchronization bootstrapping process through the following sequence:

1. The bootstrapper fetches epoch ending ledger infos from the network and stores them in `verified_epoch_states` via `process_epoch_ending_payload()`. [2](#0-1) 

2. When processing transaction/output payloads, `get_end_of_epoch_ledger_info()` calculates the `payload_end_version` based on the number of transactions/outputs received: [3](#0-2) 

3. It then queries `verified_epoch_states` for an epoch ending ledger info at that version, returning `None` if not found: [1](#0-0) 

4. This result is passed to the chunk executor as `end_of_epoch_ledger_info`: [4](#0-3) 

5. The chunk executor creates a `StateSyncChunkVerifier` with `epoch_change_li` set to this value: [5](#0-4) 

6. During chunk verification, if an epoch change is detected during execution (`next_epoch_state` is `Some`) but no `epoch_change_li` was provided, the verifier returns an error: [6](#0-5) 

**Attack Scenario:**
A malicious peer or buggy data streaming service could send a transaction payload that:
- Extends beyond the requested `end_version` range
- Contains transactions that trigger an epoch change at a version not present in `verified_epoch_states`
- Carries valid cryptographic proofs (passing initial verification)

The bootstrapper would accept the payload, attempt to execute it, detect the epoch change, but fail verification due to the missing epoch ending ledger info, causing synchronization to abort and retry indefinitely.

The root cause is that there's no explicit verification that the received payload respects the requested version range. The code only verifies the `payload_start_version` matches expectations: [7](#0-6) 

But it does not verify that `payload_end_version` matches the requested `end_version` or that it doesn't exceed known epoch boundaries.

## Impact Explanation
This vulnerability constitutes a **High Severity** issue under the Aptos bug bounty criteria:

**High Severity (Validator node slowdowns / API crashes / Significant protocol violations):**
- **Validator node slowdowns**: Affected nodes cannot complete bootstrapping and remain stuck in a retry loop, preventing them from joining the network or recovering from state synchronization.
- **Significant protocol violations**: The synchronization protocol assumes nodes can reliably fetch and verify epoch boundaries, but this vulnerability allows peers to provide data that violates these assumptions.

The impact includes:
- **Availability degradation**: New validator nodes or nodes recovering from outages cannot complete bootstrapping
- **Network health**: Reduced number of operational nodes affects network resilience
- **Validator rewards**: Affected validators cannot participate in consensus and earn rewards
- **User experience**: Fullnodes serving user queries cannot sync to current state

While this does not constitute a Critical severity issue (no consensus violation, no direct fund loss), it significantly impacts network operations and node availability.

## Likelihood Explanation
**Likelihood: Medium to High**

This vulnerability is exploitable under the following conditions:

1. **Attacker capabilities required**:
   - Ability to act as a data streaming peer (malicious validator, fullnode, or man-in-the-middle)
   - No special cryptographic privileges required
   - No validator key compromise needed

2. **Triggering conditions**:
   - Node in bootstrapping mode (initial sync or recovery from state loss)
   - Connection to malicious/buggy peer
   - Peer sends payload extending beyond requested range with epoch change

3. **Exploitation complexity**: LOW
   - Simply requires sending more transactions than requested
   - If those transactions include an epoch change, the vulnerability triggers automatically
   - No sophisticated timing or race conditions required

4. **Detection difficulty**: MEDIUM
   - Appears as normal synchronization errors in logs
   - May be attributed to network issues rather than malicious activity
   - Repeated failures would raise suspicion but root cause may not be immediately obvious

The vulnerability is particularly concerning during network stress or when many nodes are bootstrapping simultaneously (e.g., after network upgrades or incidents).

## Recommendation

Implement strict validation of received payload bounds before processing:

1. **Add payload end version validation** in `process_transaction_or_output_payload()`:
   - Verify that `payload_end_version` does not exceed the requested `end_version`
   - Verify that `payload_end_version` aligns with known epoch boundaries from `verified_epoch_states`
   - Reject payloads that violate these constraints and reset the stream

2. **Enhanced verification** in `get_end_of_epoch_ledger_info()`:
   - Add assertion that if an epoch ending is expected at `payload_end_version`, it must exist in `verified_epoch_states`
   - Log warning if `payload_end_version` doesn't match any known epoch boundary
   - Return explicit error instead of `None` when expected epoch ending is missing

3. **Defensive checks** in chunk executor:
   - Add validation that received chunk boundaries align with requested ranges
   - Verify consistency between `verified_target_li`, `epoch_change_li`, and actual execution results
   - Fail early with descriptive errors to aid debugging

**Implementation guidance**: Add validation after line 1159 in bootstrapper.rs to check that the calculated `payload_end_version` (once known) does not exceed the requested `end_version` and matches expected epoch boundaries. Reject the payload and reset the stream if validation fails, similar to how `verify_payload_start_version` handles mismatches.

## Proof of Concept

```rust
// Conceptual PoC - demonstrates the vulnerability flow
// This would need to be integrated into Aptos test framework

#[test]
fn test_missing_epoch_ending_causes_sync_failure() {
    // Setup: Bootstrapper with verified epoch states at versions [100, 200, 300]
    let mut bootstrapper = create_test_bootstrapper();
    bootstrapper.verified_epoch_states = create_verified_epoch_states(vec![100, 200, 300]);
    
    // Simulate syncing from version 50 to 100 (next epoch boundary)
    let highest_synced_version = 50;
    let requested_end_version = 100;
    
    // Attack: Malicious peer sends transactions from 51 to 150 instead of 51 to 100
    // The payload includes an epoch change at version 120 (not in verified_epoch_states)
    let malicious_payload = create_transaction_payload(
        start_version: 51,
        end_version: 150,  // Exceeds requested range
        epoch_change_at: Some(120),  // Epoch ending not in verified_epoch_states
    );
    
    // Process the payload
    let result = bootstrapper.process_transaction_or_output_payload(
        notification_metadata,
        Some(malicious_payload),
        None,
        Some(51),  // payload_start_version
    ).await;
    
    // Expected outcome: Chunk execution fails
    // Because get_end_of_epoch_ledger_info(150) returns None
    // But execution detects epoch change, triggering error at chunk_result_verifier.rs:119
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains(
        "End of epoch chunk based on local computation but no EoE LedgerInfo provided"
    ));
    
    // Node is stuck - cannot complete bootstrapping
    assert!(!bootstrapper.is_bootstrapped());
}
```

**Note**: This PoC demonstrates the logical flow. A complete implementation would require:
- Access to Aptos test harness for creating mock bootstrapper and peer connections
- Construction of valid transaction payloads with cryptographic proofs
- Simulation of epoch changes in transaction execution
- Integration with the data streaming service mock framework

The vulnerability can be triggered by any peer that can inject payloads exceeding requested bounds during the bootstrap synchronization phase.

### Citations

**File:** state-sync/state-sync-driver/src/bootstrapper.rs (L1062-1112)
```rust
    /// Process a single epoch ending payload
    async fn process_epoch_ending_payload(
        &mut self,
        notification_id: NotificationId,
        epoch_ending_ledger_infos: Vec<LedgerInfoWithSignatures>,
    ) -> Result<(), Error> {
        // Verify that we're expecting epoch ending ledger info payloads
        if !self.should_fetch_epoch_ending_ledger_infos() {
            self.reset_active_stream(Some(NotificationAndFeedback::new(
                notification_id,
                NotificationFeedback::InvalidPayloadData,
            )))
            .await?;
            return Err(Error::InvalidPayload(
                "Received an unexpected epoch ending payload!".into(),
            ));
        }

        // Verify the payload isn't empty
        if epoch_ending_ledger_infos.is_empty() {
            self.reset_active_stream(Some(NotificationAndFeedback::new(
                notification_id,
                NotificationFeedback::EmptyPayloadData,
            )))
            .await?;
            return Err(Error::VerificationError(
                "The epoch ending payload was empty!".into(),
            ));
        }

        // Verify the epoch change proofs, update our latest epoch state and
        // verify our waypoint.
        for epoch_ending_ledger_info in epoch_ending_ledger_infos {
            if let Err(error) = self.verified_epoch_states.update_verified_epoch_states(
                &epoch_ending_ledger_info,
                &self.driver_configuration.waypoint,
            ) {
                self.reset_active_stream(Some(NotificationAndFeedback::new(
                    notification_id,
                    NotificationFeedback::PayloadProofFailed,
                )))
                .await?;
                return Err(error);
            }
        }

        // TODO(joshlind): do we want to preemptively notify certain components
        // of the new reconfigurations?

        Ok(())
    }
```

**File:** state-sync/state-sync-driver/src/bootstrapper.rs (L1149-1159)
```rust
        // Verify the payload starting version
        let expected_start_version = self
            .get_speculative_stream_state()?
            .expected_next_version()?;
        let payload_start_version = self
            .verify_payload_start_version(
                notification_metadata.notification_id,
                payload_start_version,
                expected_start_version,
            )
            .await?;
```

**File:** state-sync/state-sync-driver/src/bootstrapper.rs (L1167-1174)
```rust
        let end_of_epoch_ledger_info = self
            .get_end_of_epoch_ledger_info(
                notification_metadata.notification_id,
                payload_start_version,
                transaction_list_with_proof.as_ref(),
                transaction_outputs_with_proof.as_ref(),
            )
            .await?;
```

**File:** state-sync/state-sync-driver/src/bootstrapper.rs (L1431-1436)
```rust
        let payload_end_version = payload_start_version
            .checked_add(num_versions as u64)
            .and_then(|v| v.checked_sub(1))
            .ok_or_else(|| {
                Error::IntegerOverflow("The payload end version has overflown!".into())
            })?; // payload_end_version = payload_start_version + num_versions - 1
```

**File:** state-sync/state-sync-driver/src/bootstrapper.rs (L1439-1441)
```rust
        Ok(self
            .verified_epoch_states
            .get_epoch_ending_ledger_info(payload_end_version))
```

**File:** execution/executor/src/chunk_executor/mod.rs (L148-152)
```rust
        let chunk_verifier = Arc::new(StateSyncChunkVerifier {
            txn_infos_with_proof,
            verified_target_li: verified_target_li.clone(),
            epoch_change_li: epoch_change_li.cloned(),
        });
```

**File:** execution/executor/src/chunk_executor/chunk_result_verifier.rs (L119-123)
```rust
            ensure!(
                next_epoch_state.is_none(),
                "End of epoch chunk based on local computation but no EoE LedgerInfo provided. version: {:?}",
                txn_accumulator.num_leaves().checked_sub(1),
            );
```
