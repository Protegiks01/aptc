# Audit Report

## Title
Gas Miscalculation Vulnerability in DerefVisitor Due to Missing visit_vec_u16/u32/u256 Overrides

## Summary
The `DerefVisitor` in the gas schedule implementation is missing method overrides for `visit_vec_u16`, `visit_vec_u32`, and `visit_vec_u256`, causing it to fall back to default implementations that incorrectly iterate through all vector elements. This results in significant gas overcharging (up to 20x) when performing equality operations on references to vectors of these types, making certain operations economically infeasible and potentially causing transactions to fail due to insufficient gas.

## Finding Description

The TODO comment at lines 879-880 references an "upstream bug" in the ValueVisitor trait implementation. The bug is that default implementations of `visit_vec_*` methods don't respect the boolean return value from `visit_vec()` that signals whether to continue visiting child elements. [1](#0-0) 

In the ValueVisitor trait, default implementations unconditionally iterate through all vector elements after calling `visit_vec()`, even when the visitor returns `false` to indicate "don't visit children": [2](#0-1) 

Most gas calculation visitors work around this by overriding these methods to only call `visit_vec()` and return immediately: [3](#0-2) 

However, the `DerefVisitor`, which wraps other visitors for dereferencing calculations, has a critical omission. It explicitly documents missing support for three vector types: [4](#0-3) 

The delegate list includes `visit_vec_u8`, `visit_vec_u64`, `visit_vec_u128`, but is missing `visit_vec_u16`, `visit_vec_u32`, and `visit_vec_u256`. This causes these three methods to use default implementations that iterate through all elements.

When `abstract_value_size_dereferenced` is called (used in equality checks), it wraps an `AbstractValueSizeVisitor` with a `DerefVisitor`: [5](#0-4) 

This is invoked during equality operations on dereferenced values: [6](#0-5) 

**Gas Miscalculation:**
For a `Vec<u16>` with N elements:
- **Correct charging** (with proper override): 40 (vector base) + 2*N (packed per-element cost)
- **Actual charging** (with default implementation): 40 (vector base) + 40*N (unpacked per-element cost) [7](#0-6) 

For a vector with 1000 u16 elements:
- Correct: 40 + 2,000 = 2,040 gas units
- Actual: 40 + 40,000 = 40,040 gas units (19.6x overcharge)

The vector types `vector<u16>`, `vector<u32>`, and `vector<u256>` are fully supported in Move and used in production code: [8](#0-7) 

The Container implementation confirms these specialized vector types exist and call the respective visitor methods: [9](#0-8) 

## Impact Explanation

**Severity: HIGH** (per Aptos bug bounty criteria)

This vulnerability breaks the **Move VM Safety** invariant that "bytecode execution must respect gas limits and memory constraints" by incorrectly calculating gas costs, and the **Resource Limits** invariant that "all operations must respect gas, storage, and computational limits."

The impact includes:

1. **Significant Gas Overcharging**: Users are charged up to 20x more gas than intended for equality operations on references to `Vec<u16>`, `Vec<u32>`, or `Vec<u256>`

2. **Transaction Failures**: Transactions may fail with "out of gas" errors when they should succeed, as users calculate expected gas costs based on correct pricing but are charged incorrect amounts

3. **Economic Denial of Service**: Legitimate operations become economically infeasible, effectively denying service to users who need to perform equality checks on these vector types

4. **Consensus Impact**: While this doesn't directly break consensus (all nodes miscalculate identically), it makes the system behave incorrectly according to its specification, potentially causing state transitions that shouldn't occur (transactions failing when they should succeed)

This qualifies as **High Severity** under the "Significant protocol violations" category, as it violates the gas metering protocol specification and causes material harm to users through overcharging and failed transactions.

## Likelihood Explanation

**Likelihood: HIGH**

- Vector types `u16`, `u32`, and `u256` are fully supported in Move and present in production code
- Equality operations on references are common in Move programs
- The vulnerable code path is in production and actively used
- No special privileges or complex attack setup required
- Any user writing Move code that performs equality checks on references to these vector types will trigger the vulnerability

The only factor reducing likelihood is that developers might not frequently use `vector<u16>` and `vector<u32>` compared to more common types like `vector<u8>` or `vector<u64>`. However, `vector<u256>` is used for large integer arithmetic and is present in example code.

## Recommendation

Add the missing method overrides to `DerefVisitor` to properly delegate `visit_vec_u16`, `visit_vec_u32`, and `visit_vec_u256`:

```rust
impl<V> ValueVisitor for DerefVisitor<V>
where
    V: ValueVisitor,
{
    deref_visitor_delegate_simple!(
        [visit_delayed, DelayedFieldID],
        [visit_u8, u8],
        [visit_u16, u16],
        [visit_u32, u32],
        [visit_u64, u64],
        [visit_u128, u128],
        [visit_u256, &U256],
        [visit_i8, i8],
        [visit_i16, i16],
        [visit_i32, i32],
        [visit_i64, i64],
        [visit_i128, i128],
        [visit_i256, &I256],
        [visit_bool, bool],
        [visit_address, &AccountAddress],
        [visit_vec_u8, &[u8]],
        [visit_vec_u16, &[u16]],    // ADD THIS
        [visit_vec_u32, &[u32]],    // ADD THIS
        [visit_vec_u64, &[u64]],
        [visit_vec_u128, &[u128]],
        [visit_vec_u256, &[U256]],  // ADD THIS
        [visit_vec_bool, &[bool]],
        [visit_vec_address, &[AccountAddress]],
        [visit_vec_i8, &[i8]],
        [visit_vec_i16, &[i16]],
        [visit_vec_i32, &[i32]],
        [visit_vec_i64, &[i64]],
        [visit_vec_i128, &[i128]],
        [visit_vec_i256, &[I256]],
    );
    // ... rest of implementation
}
```

Remove the TODO comment once these are added.

## Proof of Concept

```move
module 0x1::gas_overcharge_poc {
    use std::vector;

    struct Container has key {
        data_u16: vector<u16>,
        data_u32: vector<u32>,
        data_u256: vector<u256>,
    }

    public entry fun test_equality_gas_cost(account: &signer) acquires Container {
        // Create large vectors
        let vec_u16 = vector::empty<u16>();
        let vec_u32 = vector::empty<u32>();
        let vec_u256 = vector::empty<u256>();
        
        let i = 0;
        while (i < 1000) {
            vector::push_back(&mut vec_u16, (i as u16));
            vector::push_back(&mut vec_u32, (i as u32));
            vector::push_back(&mut vec_u256, (i as u256));
            i = i + 1;
        };

        // Store in global storage
        move_to(account, Container {
            data_u16: vec_u16,
            data_u32: vec_u32,
            data_u256: vec_u256,
        });

        // Borrow references
        let container_ref = borrow_global<Container>(@0x1);
        let ref1 = &container_ref.data_u16;
        let ref2 = &container_ref.data_u16;

        // This equality check will trigger the vulnerable code path
        // Expected gas: ~2040 units
        // Actual gas: ~40040 units (19.6x overcharge)
        let _ = (ref1 == ref2);
    }
}
```

**Expected behavior:** The equality check should cost approximately 2,040 gas units (40 base + 2*1000 packed).

**Actual behavior:** The equality check costs approximately 40,040 gas units (40 base + 40*1000 unpacked), resulting in a 19.6x overcharge that could cause the transaction to fail if the user didn't allocate sufficient gas.

## Notes

- This vulnerability specifically affects `vector<u16>`, `vector<u32>`, and `vector<u256>` types only when accessed through references during equality/inequality operations
- `vector<u8>`, `vector<u64>`, and `vector<u128>` are not affected as they have proper delegate implementations
- The issue exists in the TODO comment at line 129 with reference number ##17840, indicating it's a known technical debt item that hasn't been addressed
- While this causes overcharging (not undercharging), it still represents a significant security issue as it makes the system behave incorrectly and can cause economic denial of service
- The fix is straightforward: add three lines to the delegate macro invocation

### Citations

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/misc.rs (L33-56)
```rust
        [u8: AbstractValueSize, "u8", 40],
        [u16: AbstractValueSize, { 5.. => "u16" }, 40],
        [u32: AbstractValueSize, { 5.. => "u32" }, 40],
        [u64: AbstractValueSize, "u64", 40],
        [u128: AbstractValueSize, "u128", 40],
        [u256: AbstractValueSize, { 5.. => "u256" }, 40],
        [i8: AbstractValueSize, { RELEASE_V1_38.. => "i8" }, 40],
        [i16: AbstractValueSize, { RELEASE_V1_38.. => "i16" }, 40],
        [i32: AbstractValueSize, { RELEASE_V1_38.. => "i32" }, 40],
        [i64: AbstractValueSize, { RELEASE_V1_38.. => "i64" }, 40],
        [i128: AbstractValueSize, { RELEASE_V1_38.. => "i128" }, 40],
        [i256: AbstractValueSize, { RELEASE_V1_38.. => "i256" }, 40],
        [bool: AbstractValueSize, "bool", 40],
        [address: AbstractValueSize, "address", 40],
        [struct_: AbstractValueSize, "struct", 40],
        [closure: AbstractValueSize, { RELEASE_V1_33.. => "closure" }, 40],
        [vector: AbstractValueSize, "vector", 40],
        [reference: AbstractValueSize, "reference", 40],
        [per_u8_packed: AbstractValueSizePerArg, "per_u8_packed", 1],
        [per_u16_packed: AbstractValueSizePerArg, { 5.. => "per_u16_packed" }, 2],
        [per_u32_packed: AbstractValueSizePerArg, { 5.. => "per_u32_packed" }, 4],
        [per_u64_packed: AbstractValueSizePerArg, "per_u64_packed", 8],
        [per_u128_packed: AbstractValueSizePerArg, "per_u128_packed", 16],
        [per_u256_packed: AbstractValueSizePerArg, { 5.. => "per_u256_packed" }, 32],
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/misc.rs (L129-141)
```rust
        // TODO(##17840): add supports for `visit_vec_u16`, `visit_vec_u32`, `visit_vec_u256`
        [visit_vec_u8, &[u8]],
        [visit_vec_u64, &[u64]],
        [visit_vec_u128, &[u128]],
        [visit_vec_bool, &[bool]],
        [visit_vec_address, &[AccountAddress]],
        [visit_vec_i8, &[i8]],
        [visit_vec_i16, &[i16]],
        [visit_vec_i32, &[i32]],
        [visit_vec_i64, &[i64]],
        [visit_vec_i128, &[i128]],
        [visit_vec_i256, &[I256]],
    );
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/misc.rs (L483-491)
```rust
    pub fn abstract_value_size_dereferenced(
        &self,
        val: impl ValueView,
        feature_version: u64,
    ) -> PartialVMResult<AbstractValueSize> {
        let mut visitor = DerefVisitor::new(AbstractValueSizeVisitor::new(self, feature_version));
        val.visit(&mut visitor)?;
        Ok(visitor.into_inner().finish())
    }
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/misc.rs (L879-880)
```rust
            // TODO(Gas): The following function impls are necessary due to a bug upstream.
            //            Remove them once the bug is fixed.
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/misc.rs (L881-930)
```rust
            #[inline]
            fn visit_vec_u8(&mut self, depth: u64, vals: &[u8]) -> PartialVMResult<()> {
                self.visit_vec(depth, vals.len())?;
                Ok(())
            }

            #[inline]
            fn visit_vec_u16(&mut self, depth: u64, vals: &[u16]) -> PartialVMResult<()> {
                self.visit_vec(depth, vals.len())?;
                Ok(())
            }

            #[inline]
            fn visit_vec_u32(&mut self, depth: u64, vals: &[u32]) -> PartialVMResult<()> {
                self.visit_vec(depth, vals.len())?;
                Ok(())
            }

            #[inline]
            fn visit_vec_u64(&mut self, depth: u64, vals: &[u64]) -> PartialVMResult<()> {
                self.visit_vec(depth, vals.len())?;
                Ok(())
            }

            #[inline]
            fn visit_vec_u128(&mut self, depth: u64, vals: &[u128]) -> PartialVMResult<()> {
                self.visit_vec(depth, vals.len())?;
                Ok(())
            }

            fn visit_vec_u256(&mut self, depth: u64, vals: &[U256]) -> PartialVMResult<()> {
                self.visit_vec(depth, vals.len())?;
                Ok(())
            }

            #[inline]
            fn visit_vec_bool(&mut self, depth: u64, vals: &[bool]) -> PartialVMResult<()> {
                self.visit_vec(depth, vals.len())?;
                Ok(())
            }

            #[inline]
            fn visit_vec_address(
                &mut self,
                depth: u64,
                vals: &[AccountAddress],
            ) -> PartialVMResult<()> {
                self.visit_vec(depth, vals.len())?;
                Ok(())
            }
```

**File:** third_party/move/move-vm/types/src/views.rs (L242-256)
```rust
    fn visit_vec_u8(&mut self, depth: u64, vals: &[u8]) -> PartialVMResult<()> {
        self.visit_vec(depth, vals.len())?;
        for val in vals {
            self.visit_u8(depth + 1, *val)?;
        }
        Ok(())
    }

    fn visit_vec_u16(&mut self, depth: u64, vals: &[u16]) -> PartialVMResult<()> {
        self.visit_vec(depth, vals.len())?;
        for val in vals {
            self.visit_u16(depth + 1, *val)?;
        }
        Ok(())
    }
```

**File:** aptos-move/aptos-gas-meter/src/meter.rs (L398-408)
```rust
    fn charge_eq(&mut self, lhs: impl ValueView, rhs: impl ValueView) -> PartialVMResult<()> {
        let abs_val_params = &self.vm_gas_params().misc.abs_val;

        let cost = EQ_BASE
            + EQ_PER_ABS_VAL_UNIT
                * (abs_val_params.abstract_value_size_dereferenced(lhs, self.feature_version())?
                    + abs_val_params
                        .abstract_value_size_dereferenced(rhs, self.feature_version())?);

        self.algebra.charge_execution(cost)
    }
```

**File:** aptos-move/move-examples/argument_example/sources/arguments.move (L6-14)
```text
    struct NumberHolder has key {
        u8: u8,
        u16: u16,
        u32: u32,
        u64: u64,
        u128: u128,
        u256: u256,
        vec_u256: vector<u256>,
    }
```

**File:** third_party/move/move-vm/types/src/values/values_impl.rs (L5503-5516)
```rust
            VecU8(r) => visitor.visit_vec_u8(depth, &r.borrow()),
            VecU16(r) => visitor.visit_vec_u16(depth, &r.borrow()),
            VecU32(r) => visitor.visit_vec_u32(depth, &r.borrow()),
            VecU64(r) => visitor.visit_vec_u64(depth, &r.borrow()),
            VecU128(r) => visitor.visit_vec_u128(depth, &r.borrow()),
            VecU256(r) => visitor.visit_vec_u256(depth, &r.borrow()),
            VecI8(r) => visitor.visit_vec_i8(depth, &r.borrow()),
            VecI16(r) => visitor.visit_vec_i16(depth, &r.borrow()),
            VecI32(r) => visitor.visit_vec_i32(depth, &r.borrow()),
            VecI64(r) => visitor.visit_vec_i64(depth, &r.borrow()),
            VecI128(r) => visitor.visit_vec_i128(depth, &r.borrow()),
            VecI256(r) => visitor.visit_vec_i256(depth, &r.borrow()),
            VecBool(r) => visitor.visit_vec_bool(depth, &r.borrow()),
            VecAddress(r) => visitor.visit_vec_address(depth, &r.borrow()),
```
