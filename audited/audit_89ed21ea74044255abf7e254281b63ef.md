# Audit Report

## Title
Integer Underflow in StreamStatus Processing Allows Cache Worker Denial of Service via Malicious Version Range

## Summary
The indexer-grpc cache worker does not validate that `end_version >= start_version` when processing `StreamStatus` messages with `BatchEnd` type. A malicious fullnode can send a `StreamStatus` where `end_version < start_version`, causing unsigned integer underflow in the transaction count calculation, leading to cache worker disconnection and denial of service.

## Finding Description
The vulnerability exists in the `process_transactions_from_node_response` function where `StreamStatus` messages are processed. [1](#0-0) 

When a `BatchEnd` status is received, the code calculates `num_of_transactions` as:
```
num_of_transactions = end_version - start_version + 1
```

Since both `start_version` and `end_version` are `u64` (unsigned 64-bit integers), if `end_version < start_version`, the subtraction wraps around, producing an extremely large value (approximately `u64::MAX - (start_version - end_version)`).

**Attack Flow:**
1. Malicious fullnode sends legitimate transaction data
2. Fullnode then sends a `BatchEnd` StreamStatus with:
   - `start_version`: 1000
   - `end_version`: 500 (invalid - less than start)
3. Cache worker calculates: `num_of_transactions = 500 - 1000 + 1 = u64::MAX - 498`
4. Version validation check fails at line 433: `current_version != start_version + num_of_transactions` [2](#0-1) 

5. Cache worker logs error and breaks from the processing loop, disconnecting from the malicious fullnode
6. If the cache worker has limited fallback options, this can disrupt indexer service availability

Unlike the state-sync data streaming service which includes proper validation: [3](#0-2) 

The indexer-grpc cache worker lacks this defensive check.

## Impact Explanation
This is a **High Severity** vulnerability per Aptos bug bounty criteria:

1. **Validator node slowdowns / API crashes**: The cache worker is critical infrastructure for the indexer gRPC system. Disconnection causes:
   - Cache staleness and unavailability
   - Degraded indexer API performance
   - Potential cascading failures if multiple cache workers are affected

2. **Significant protocol violation**: Breaks the version consistency guarantee - the system should reject malformed version ranges but instead processes them, leading to incorrect state tracking.

3. While not directly affecting consensus or validator nodes, this impacts the broader Aptos infrastructure that applications depend on for querying blockchain state.

## Likelihood Explanation
**Likelihood: Medium-High**

**Attacker Requirements:**
- Control of a fullnode that cache workers connect to
- Ability to modify gRPC responses (simple code modification)

**Complexity: Low**
- Attack is straightforward to execute
- No cryptographic breaks or complex timing required
- Single malformed message triggers the vulnerability

**Mitigating Factors:**
- Cache workers may connect to multiple fullnodes and can failover
- Requires attacker to operate a fullnode that cache workers trust/connect to

However, in deployment scenarios where cache workers connect to a limited set of fullnodes, a compromised fullnode operator can effectively DoS the indexer infrastructure.

## Recommendation
Add validation to ensure `end_version >= start_version` before calculating `num_of_transactions`:

```rust
StatusType::BatchEnd => {
    let start_version = status.start_version;
    let end_version = status
        .end_version
        .expect("TransactionsFromNodeResponse status end_version is None");
    
    // Validation: end_version must be >= start_version
    if end_version < start_version {
        return Err(anyhow::anyhow!(
            "[Indexer Cache] Invalid StreamStatus: end_version ({}) < start_version ({})",
            end_version,
            start_version
        ));
    }
    
    let num_of_transactions = end_version - start_version + 1;
    Ok(GrpcDataStatus::BatchEnd {
        start_version,
        num_of_transactions,
    })
}
```

This validation should also be added at the point where `StreamStatus` is created in the fullnode service: [4](#0-3) 

Add a debug assertion or validation in the `get_status` function to catch bugs during development.

## Proof of Concept
```rust
#[cfg(test)]
mod tests {
    use super::*;
    use aptos_protos::internal::fullnode::v1::{StreamStatus, stream_status::StatusType};

    #[test]
    fn test_malicious_stream_status_underflow() {
        // Simulate malicious StreamStatus with end_version < start_version
        let malicious_status = StreamStatus {
            r#type: StatusType::BatchEnd as i32,
            start_version: 1000,
            end_version: Some(500), // Invalid: less than start_version
        };

        // This calculation will underflow
        let start_version = malicious_status.start_version;
        let end_version = malicious_status.end_version.unwrap();
        
        // Without validation, this produces a huge number
        let num_of_transactions = end_version.wrapping_sub(start_version).wrapping_add(1);
        
        // num_of_transactions will be approximately u64::MAX - 498
        assert!(num_of_transactions > u64::MAX / 2);
        
        println!("Underflow result: {}", num_of_transactions);
        // This would cause version tracking to become completely desynchronized
    }
}
```

The test demonstrates that without validation, `end_version < start_version` produces a massive `num_of_transactions` value that desynchronizes version tracking and causes the cache worker to disconnect.

## Notes
- This vulnerability affects the indexer infrastructure, not the core consensus layer
- Similar validation exists in the state-sync data streaming service but was omitted in the indexer-grpc cache worker
- The fix is straightforward and should be applied to both the sender (fullnode service) and receiver (cache worker) sides for defense in depth
- Consider adding fuzz testing for gRPC message handlers to catch similar validation issues

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-cache-worker/src/worker.rs (L194-200)
```rust
                StatusType::BatchEnd => {
                    let start_version = status.start_version;
                    let num_of_transactions = status
                        .end_version
                        .expect("TransactionsFromNodeResponse status end_version is None")
                        - start_version
                        + 1;
```

**File:** ecosystem/indexer-grpc/indexer-grpc-cache-worker/src/worker.rs (L433-442)
```rust
                    if current_version != start_version + num_of_transactions {
                        error!(
                            current_version = current_version,
                            actual_current_version = start_version + num_of_transactions,
                            "[Indexer Cache] End signal received with wrong version."
                        );
                        ERROR_COUNT
                            .with_label_values(&["data_end_wrong_version"])
                            .inc();
                        break;
```

**File:** state-sync/data-streaming-service/src/stream_engine.rs (L2009-2030)
```rust
/// Verifies that the `expected_next_index` matches the `start_index` and that
/// the `end_index` is greater than or equal to `expected_next_index`.
fn verify_client_request_indices(
    expected_next_index: u64,
    start_index: u64,
    end_index: u64,
) -> Result<(), Error> {
    if start_index != expected_next_index {
        return Err(Error::UnexpectedErrorEncountered(format!(
            "The start index did not match the expected next index! Given: {:?}, expected: {:?}",
            start_index, expected_next_index
        )));
    }

    if end_index < expected_next_index {
        return Err(Error::UnexpectedErrorEncountered(format!(
            "The end index was less than the expected next index! Given: {:?}, expected: {:?}",
            end_index, expected_next_index
        )));
    }

    Ok(())
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/fullnode_data_service.rs (L245-261)
```rust
pub fn get_status(
    status_type: StatusType,
    start_version: u64,
    end_version: Option<u64>,
    ledger_chain_id: u8,
) -> TransactionsFromNodeResponse {
    TransactionsFromNodeResponse {
        response: Some(transactions_from_node_response::Response::Status(
            StreamStatus {
                r#type: status_type as i32,
                start_version,
                end_version,
            },
        )),
        chain_id: ledger_chain_id as u32,
    }
}
```
