# Audit Report

## Title
Subscription Requests Bypass Rate Limiting, Enabling Information Disclosure and Resource Exhaustion

## Summary
Subscription requests in the storage service bypass the request moderator's rate limiting mechanism, allowing public network peers to send unlimited subscription requests without being blocked. This enables both information disclosure through metadata error messages and potential resource exhaustion attacks.

## Finding Description

The storage service implements a `RequestModerator` that validates inbound requests and rate limits peers that send too many invalid requests. However, subscription requests completely bypass this security control.

In the request handling flow, when a storage service request is received, the code checks if it's a subscription request and routes it differently: [1](#0-0) 

Subscription requests go directly to `handle_subscription_request()` without calling the request moderator. In contrast, regular requests go through `process_request()` which calls the moderator: [2](#0-1) 

The request moderator provides rate limiting by tracking invalid requests and temporarily blocking public network peers that exceed thresholds: [3](#0-2) 

When a peer attempts to add a subscription request to an existing stream with mismatched metadata, detailed error messages are returned revealing the expected metadata: [4](#0-3) 

The `SubscriptionStreamMetadata` structure contains sensitive information: [5](#0-4) 

**Attack Path:**

1. Attacker connects as a public network peer
2. Attacker sends subscription requests with varying stream IDs to create and replace streams repeatedly
3. Each request bypasses rate limiting and consumes server resources (metrics, logs, entry operations)
4. Attacker can send requests with incorrect metadata to probe existing stream metadata through error messages
5. No rate limiting or temporary blocking occurs, unlike regular requests

## Impact Explanation

This vulnerability has two dimensions of impact:

**1. Resource Exhaustion:** An attacker from the public network can send unlimited subscription requests without being rate limited. Each request creates metrics, logs, and performs map operations on the subscriptions DashMap. By repeatedly creating new subscription streams with different stream IDs, an attacker can consume server resources indefinitely. While individual requests are relatively lightweight, the unlimited nature of the attack makes this a **Medium severity** resource exhaustion issue.

**2. Information Disclosure:** Error messages reveal the exact subscription metadata (stream ID, known version, known epoch) expected by the server. While this primarily affects the attacker's own subscription streams, it still represents an information leak about the server's state tracking. This falls under **Low to Medium severity** for information disclosure.

Combined, this represents a **Medium Severity** vulnerability according to Aptos bug bounty criteria, as it enables resource exhaustion on storage service nodes without rate limiting protection.

## Likelihood Explanation

**Likelihood: High**

The vulnerability is easily exploitable:
- Any peer can connect to the public network
- No special privileges required
- No complex timing or race conditions needed
- Simple network request sending is sufficient
- The bypass is consistent and reproducible

The only barrier is that the moderator already exempts validator and VFN peers from rate limiting, but for public network peers, this represents a complete bypass of an intended security control.

## Recommendation

Subscription requests should be validated through the request moderator like all other requests. Modify `process_request_and_respond()` to call the moderator before handling subscription requests:

**Fix approach:** [6](#0-5) 

Insert moderator validation before handling subscription requests:

```rust
// Handle any subscription requests
if request.data_request.is_subscription_request() {
    // Validate the subscription request with the moderator
    if let Err(error) = self.request_moderator.validate_request(&peer_network_id, &request) {
        // Log and return error for invalid subscription request
        warn!(LogSchema::new(LogEntry::StorageServiceError)
            .error(&error)
            .peer_network_id(&peer_network_id)
            .request(&request));
        
        response_sender.send(Err(match error {
            Error::InvalidRequest(msg) => StorageServiceError::InvalidRequest(msg),
            Error::TooManyInvalidRequests(msg) => StorageServiceError::TooManyInvalidRequests(msg),
            _ => StorageServiceError::InternalError(error.to_string()),
        }));
        return;
    }
    
    self.handle_subscription_request(
        storage_service_config,
        peer_network_id,
        request,
        response_sender,
    );
    return;
}
```

Additionally, consider making error messages less revealing by removing the detailed metadata disclosure: [7](#0-6) 

Replace with a generic error message:
```rust
if subscription_stream_metadata != self.subscription_stream_metadata {
    return Err((
        Error::InvalidRequest(
            "The subscription request stream metadata does not match the existing stream".to_string()
        ),
        subscription_request,
    ));
}
```

## Proof of Concept

```rust
// Proof of Concept - Rust code demonstrating the vulnerability
// This would be run as a test in the storage service test suite

use aptos_config::network_id::{NetworkId, PeerNetworkId};
use aptos_storage_service_types::requests::{
    DataRequest, StorageServiceRequest, SubscriptionStreamMetadata,
    SubscribeTransactionOutputsWithProofRequest,
};
use aptos_types::PeerId;

#[tokio::test]
async fn test_subscription_bypass_rate_limiting() {
    // Setup: Create a storage service handler and moderator
    // (initialization code omitted for brevity)
    
    // Create a public network peer (these should be rate limited)
    let peer_network_id = PeerNetworkId::new(NetworkId::Public, PeerId::random());
    
    // Create multiple subscription requests with different stream IDs
    // Normal requests would trigger rate limiting after max_invalid_requests
    // But subscription requests bypass the moderator entirely
    
    for stream_id in 0..1000 {
        let subscription_metadata = SubscriptionStreamMetadata {
            known_version_at_stream_start: 100,
            known_epoch_at_stream_start: 1,
            subscription_stream_id: stream_id,
        };
        
        let request = StorageServiceRequest::new(
            DataRequest::SubscribeTransactionOutputsWithProof(
                SubscribeTransactionOutputsWithProofRequest {
                    subscription_stream_metadata: subscription_metadata,
                    subscription_stream_index: 0,
                }
            ),
            false, // use_compression
        );
        
        // Send the subscription request
        // This bypasses the request moderator and is never rate limited
        // handler.process_request_and_respond(config, peer_network_id, protocol_id, request, response_sender);
        
        // The peer is NEVER marked as unhealthy or ignored
        // Even after 1000+ requests, no rate limiting occurs
    }
    
    // Verify: Check that the peer was never blocked or rate limited
    // (In contrast, 1000 invalid regular requests would block the peer)
    
    // Assert: The moderator never tracked these as invalid requests
    // let peer_state = moderator.get_unhealthy_peer_states().get(&peer_network_id);
    // assert!(peer_state.is_none() || !peer_state.unwrap().is_ignored());
}

#[tokio::test]
async fn test_metadata_information_disclosure() {
    // Create a subscription stream with known metadata
    let peer_network_id = PeerNetworkId::new(NetworkId::Public, PeerId::random());
    
    let initial_metadata = SubscriptionStreamMetadata {
        known_version_at_stream_start: 12345,
        known_epoch_at_stream_start: 42,
        subscription_stream_id: 99,
    };
    
    // First request creates the stream
    // ... (send initial subscription request)
    
    // Second request with different metadata to probe
    let probe_metadata = SubscriptionStreamMetadata {
        known_version_at_stream_start: 99999,
        known_epoch_at_stream_start: 88,
        subscription_stream_id: 99, // Same stream ID
    };
    
    // Send probe request and observe error message
    // Error will reveal: "Expected: {:?}, found: {:?}" 
    // This discloses the actual metadata values being tracked
}
```

## Notes

This vulnerability violates the **Resource Limits** invariant: "All operations must respect gas, storage, and computational limits." Subscription requests should be subject to the same rate limiting controls as other requests to prevent resource exhaustion attacks.

The issue affects only public network peers, as validator and VFN peers are exempt from rate limiting by design. However, this represents a significant security control bypass for the public network, which is the most exposed attack surface for the Aptos network.

### Citations

**File:** state-sync/storage-service/server/src/handler.rs (L125-134)
```rust
        // Handle any subscription requests
        if request.data_request.is_subscription_request() {
            self.handle_subscription_request(
                storage_service_config,
                peer_network_id,
                request,
                response_sender,
            );
            return;
        }
```

**File:** state-sync/storage-service/server/src/handler.rs (L206-213)
```rust
    fn validate_and_handle_request(
        &self,
        peer_network_id: &PeerNetworkId,
        request: &StorageServiceRequest,
    ) -> Result<StorageServiceResponse, Error> {
        // Validate the request with the moderator
        self.request_moderator
            .validate_request(peer_network_id, request)?;
```

**File:** state-sync/storage-service/server/src/moderator.rs (L50-69)
```rust
    pub fn increment_invalid_request_count(&mut self, peer_network_id: &PeerNetworkId) {
        // Increment the invalid request count
        self.invalid_request_count += 1;

        // If the peer is a PFN and has sent too many invalid requests, start ignoring it
        if self.ignore_start_time.is_none()
            && peer_network_id.network_id().is_public_network()
            && self.invalid_request_count >= self.max_invalid_requests
        {
            // TODO: at some point we'll want to terminate the connection entirely

            // Start ignoring the peer
            self.ignore_start_time = Some(self.time_service.now());

            // Log the fact that we're now ignoring the peer
            warn!(LogSchema::new(LogEntry::RequestModeratorIgnoredPeer)
                .peer_network_id(peer_network_id)
                .message("Ignoring peer due to too many invalid requests!"));
        }
    }
```

**File:** state-sync/storage-service/server/src/subscription.rs (L346-356)
```rust
        // Verify that the subscription metadata is valid
        let subscription_stream_metadata = subscription_request.subscription_stream_metadata();
        if subscription_stream_metadata != self.subscription_stream_metadata {
            return Err((
                Error::InvalidRequest(format!(
                    "The subscription request stream metadata is invalid! Expected: {:?}, found: {:?}",
                    self.subscription_stream_metadata, subscription_stream_metadata
                )),
                subscription_request,
            ));
        }
```

**File:** state-sync/storage-service/types/src/requests.rs (L418-422)
```rust
pub struct SubscriptionStreamMetadata {
    pub known_version_at_stream_start: u64, // The highest known transaction version at stream start
    pub known_epoch_at_stream_start: u64,   // The highest known epoch at stream start
    pub subscription_stream_id: u64,        // The unique id of the subscription stream
}
```
