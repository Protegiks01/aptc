# Audit Report

## Title
Lazy Loading Dependency Metering Bypass Enabling Transaction DoS

## Summary
When lazy loading is enabled, module publishing only validates and meters immediate dependencies, not the full transitive dependency closure. This allows attackers to publish modules with arbitrarily deep dependency chains that later cause legitimate user transactions to fail with `DEPENDENCY_LIMIT_REACHED`, creating a denial-of-service vector.

## Finding Description

The vulnerability exists in the interaction between module publishing validation and lazy loading execution semantics. During module publishing with lazy loading enabled, only immediate dependencies are metered and validated against gas limits, while transitive dependencies remain unchecked until execution time.

**Publishing Phase (Bypasses Full Validation):**

In `create_with_compat_config()`, only immediate dependencies are loaded without recursive traversal: [1](#0-0) 

The comment states dependencies "must be metered at the caller side," but this only applies to immediate dependencies. The lazy loading implementation explicitly skips linking checks: [2](#0-1) 

At line 321, `build_verified_module_skip_linking_checks` is called, which does not load or validate transitive dependencies.

**Publishing Gas Charging (Only Immediate Dependencies):**

In `resolve_pending_code_publish_and_finish_user_session`, when lazy loading is enabled, only immediate dependencies are charged: [3](#0-2) 

Contrast this with non-lazy loading, which traverses the full transitive closure: [4](#0-3) 

**Dependency Limits Enforced Only at Execution:**

Dependency limits are enforced during execution via `count_dependency`: [5](#0-4) 

The limits are: [6](#0-5) 

**Attack Scenario:**
1. Attacker publishes Module A → B → C → D → ... → Z (deep chain where → represents "depends on")
2. During publishing with lazy loading, only Module B is validated/charged
3. Modules C through Z are not validated against dependency limits during publishing
4. Victim calls a function in Module A that uses the full dependency chain
5. During execution, all modules B through Z are loaded
6. If total exceeds 768 modules or 1.8 MB, transaction fails with `DEPENDENCY_LIMIT_REACHED`
7. Victim loses gas and their transaction fails

This behavior is explicitly tested and expected: [7](#0-6) [8](#0-7) 

## Impact Explanation

This constitutes a **High severity** vulnerability because it enables:

1. **Denial of Service**: Attackers can publish modules that cause legitimate user transactions to systematically fail, degrading protocol availability
2. **Gas Griefing**: Publishers externalize costs to callers by creating deep dependency chains that only manifest at execution time
3. **Unpredictable Transaction Behavior**: Users cannot reliably estimate gas or determine if module calls will succeed without analyzing the complete dependency graph

This meets the High severity criteria: "Validator node slowdowns" and "Significant protocol violations" as it disrupts normal protocol operation and creates unexpected transaction failures.

## Likelihood Explanation

Likelihood is **High** because:

1. **No Special Privileges Required**: Any user can publish modules
2. **Simple Exploit**: Creating deep dependency chains is straightforward
3. **Lazy Loading is Default**: The vulnerable code path is active when lazy loading is enabled
4. **Detection Difficulty**: Victims cannot easily identify problematic modules before calling them
5. **Demonstrated in Tests**: The behavior is reproducible and tested, confirming exploitability

The test suite explicitly validates this behavior, proving the attack is practical and reliably executable.

## Recommendation

Enforce transitive dependency validation during module publishing, even with lazy loading enabled. Modify `charge_package_dependencies` to traverse the full dependency closure:

```rust
// In aptos_vm.rs, replace the lazy loading branch
if !self.features().is_lazy_loading_enabled() {
    // Current full traversal code
} else {
    // RECOMMENDED FIX: Also traverse full closure with lazy loading
    check_dependencies_and_charge_gas(
        module_storage,
        gas_meter,
        traversal_context,
        modules
            .iter()
            .flat_map(|module| {
                module.immediate_dependencies_iter()
                    .chain(module.immediate_friends_iter())
            })
            .filter(|addr_and_name| !module_ids_in_bundle.contains(addr_and_name)),
    )?;
}
```

This ensures publishers pay upfront for all dependencies their modules may access, preventing cost externalization and DoS vectors.

## Proof of Concept

The existing test suite demonstrates the vulnerability. To exploit:

1. Publish a chain of modules where each depends on the previous
2. Set dependency limits artificially low (simulating a realistic but deep dependency graph)
3. Publish the final module - it succeeds with lazy loading despite transitive dependencies exceeding limits
4. Call a function that uses the full chain - transaction fails with `DEPENDENCY_LIMIT_REACHED`

The proof is in the test file demonstrating that publishing succeeds (line 58) but execution fails (line 148) when limits are exceeded by transitive dependencies with lazy loading enabled.

**Notes:**

The vulnerability stems from the asymmetry between publish-time validation (immediate dependencies only) and execution-time validation (full transitive closure). While dependency limits prevent unbounded resource consumption, they do not prevent publishers from creating modules that systematically cause caller transactions to fail, violating the expectation that successfully published modules should be safely callable within normal gas parameters.

### Citations

**File:** third_party/move/move-vm/runtime/src/storage/publishing.rs (L262-270)
```rust
                for (dep_addr, dep_name) in locally_verified_code.immediate_dependencies_iter() {
                    // INVARIANT:
                    //   Immediate dependency of the module in a bundle must be metered at the
                    //   caller side.
                    let dependency =
                        staged_module_storage.unmetered_get_existing_lazily_verified_module(
                            &ModuleId::new(*dep_addr, dep_name.to_owned()),
                        )?;
                    verified_dependencies.push(dependency);
```

**File:** third_party/move/move-vm/runtime/src/storage/module_storage.rs (L295-329)
```rust
    fn unmetered_get_lazily_verified_module(
        &self,
        module_id: &ModuleId,
    ) -> VMResult<Option<Arc<Module>>> {
        let (module, version) = match self.get_module_or_build_with(module_id, self)? {
            Some(module_and_version) => module_and_version,
            None => return Ok(None),
        };

        if module.code().is_verified() {
            return Ok(Some(module.code().verified().clone()));
        }

        let _timer = VM_TIMER.timer_with_label("unmetered_get_lazily_verified_module [cache miss]");
        let runtime_environment = self.runtime_environment();
        runtime_environment.paranoid_check_module_address_and_name(
            module.code().deserialized(),
            module_id.address(),
            module_id.name(),
        )?;
        let locally_verified_code = runtime_environment.build_locally_verified_module(
            module.code().deserialized().clone(),
            module.extension().size_in_bytes(),
            module.extension().hash(),
        )?;
        let verified_code =
            runtime_environment.build_verified_module_skip_linking_checks(locally_verified_code)?;
        let verified_module = self.insert_verified_module(
            module_id.clone(),
            verified_code,
            module.extension().clone(),
            version,
        )?;
        Ok(Some(verified_module.code().verified().clone()))
    }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1616-1631)
```rust
        if !self.features().is_lazy_loading_enabled() {
            check_dependencies_and_charge_gas(
                module_storage,
                gas_meter,
                traversal_context,
                modules
                    .iter()
                    .flat_map(|module| {
                        module
                            .immediate_dependencies_iter()
                            .chain(module.immediate_friends_iter())
                    })
                    .filter(|addr_and_name| !module_ids_in_bundle.contains(addr_and_name)),
            )?;
            return Ok(());
        }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1637-1655)
```rust
        for (dep_addr, dep_name) in modules
            .iter()
            .flat_map(|module| module.immediate_dependencies_iter())
            .filter(|addr_and_name| !module_ids_in_bundle.contains(addr_and_name))
        {
            if traversal_context.visit_if_not_special_address(dep_addr, dep_name) {
                let size = module_storage
                    .unmetered_get_existing_module_size(dep_addr, dep_name)
                    .map(|v| v as u64)?;
                gas_meter
                    .charge_dependency(
                        DependencyKind::Existing,
                        dep_addr,
                        dep_name,
                        NumBytes::new(size),
                    )
                    .map_err(|err| err.finish(Location::Undefined))?;
            }
        }
```

**File:** aptos-move/aptos-gas-meter/src/algebra.rs (L300-313)
```rust
    fn count_dependency(&mut self, size: NumBytes) -> PartialVMResult<()> {
        if self.feature_version >= 15 {
            self.num_dependencies += 1.into();
            self.total_dependency_size += size;

            if self.num_dependencies > self.vm_gas_params.txn.max_num_dependencies {
                return Err(PartialVMError::new(StatusCode::DEPENDENCY_LIMIT_REACHED));
            }
            if self.total_dependency_size > self.vm_gas_params.txn.max_total_dependency_size {
                return Err(PartialVMError::new(StatusCode::DEPENDENCY_LIMIT_REACHED));
            }
        }
        Ok(())
    }
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L251-259)
```rust
            max_num_dependencies: NumModules,
            { RELEASE_V1_10.. => "max_num_dependencies" },
            768,
        ],
        [
            max_total_dependency_size: NumBytes,
            { RELEASE_V1_10.. => "max_total_dependency_size" },
            1024 * 1024 * 18 / 10, // 1.8 MB
        ],
```

**File:** aptos-move/e2e-move-tests/src/tests/dependencies.rs (L53-60)
```rust
    // Since lazy loading only checks immediate dependencies, and p3 depends on p2 only, publishing
    // should succeed.
    let res =
        h.publish_package_cache_building(&acc, &common::test_dir_path("dependencies.data/p3"));
    if enable_lazy_loading {
        assert_success!(res);
    } else {
        assert_dependency_limit_reached(res);
```

**File:** aptos-move/e2e-move-tests/src/tests/dependencies.rs (L141-148)
```rust
    // For both lazy and eager loading, we load 3 modules here and so it must fail.
    let res = h.run_entry_function(
        &acc,
        str::parse("0xcafe::m3::load_m2_m1").unwrap(),
        vec![],
        vec![],
    );
    assert_dependency_limit_reached(res);
```
