# Audit Report

## Title
Consensus Observer Subscription DoS via Repeated Slow Response Attacks

## Summary
Malicious peers can repeatedly delay consensus observer subscription creation by responding to subscription requests slowly (just under the timeout threshold). The lack of persistent peer blacklisting allows attackers to continuously exploit this vulnerability, forcing observer nodes into degraded fallback mode.

## Finding Description

The consensus observer subscription mechanism in `subscription_utils.rs` is vulnerable to a timing-based denial of service attack. When attempting to create subscriptions to peers, the system:

1. Sorts peers by "optimality" (low distance from validators, low ping latency) [1](#0-0) 

2. Sequentially attempts subscription to each peer with a 5-second timeout [2](#0-1) 

3. Adds failed peers to a local list during the current subscription task [3](#0-2) 

4. Removes failed peers from the sorted list only within the current task [4](#0-3) 

**Critical vulnerability:** Failed peers are NOT persistently blacklisted across subscription attempts. When the next subscription creation task runs, the malicious peers are re-sorted as "optimal" and the attack repeats.

An attacker can exploit this by:
- Running malicious peers that report fake low distance from validators (self-reported in `NetworkInformationResponse`) [5](#0-4) 
- Responding to ping requests quickly (to maintain low latency metrics)
- Responding to subscription requests slowly (~4.9 seconds) to maximize delay [6](#0-5) 
- Since subscription attempts are sequential, N malicious peers cause N Ã— 5 seconds delay per task
- The attack blocks concurrent subscription creation attempts [7](#0-6) 

## Impact Explanation

This vulnerability causes **Medium severity** impact per the Aptos bug bounty program criteria:

1. **Node slowdowns**: Consensus observer nodes (VFNs and PFNs) experience significant delays in establishing subscriptions, degrading their ability to receive timely consensus updates.

2. **Forced fallback mode**: When subscription creation continuously fails, observers enter fallback mode and rely on state sync instead of direct consensus messages [8](#0-7) , resulting in slower block processing.

3. **Availability degradation**: While not a total denial of service, the attack significantly degrades the performance and availability of the consensus observer feature, affecting network health for fullnodes.

This does not affect consensus safety or validator operations directly, but impacts the broader network infrastructure.

## Likelihood Explanation

**High likelihood** of exploitation:

1. **Low barrier to entry**: Any actor can run a peer and manipulate their peer metadata (distance and latency values are self-reported or computed from self-reported data).

2. **Easy execution**: The attack requires only:
   - Running a peer that supports consensus observer protocols
   - Responding to pings quickly but to subscription requests slowly
   - No special privileges or validator access needed

3. **No detection mechanism**: There is no persistent tracking or blacklisting of slow-responding peers across subscription attempts.

4. **Repeatable attack**: The vulnerability can be exploited continuously every time subscription creation is attempted (every 5 seconds during progress checks [9](#0-8) ).

## Recommendation

Implement persistent peer reputation tracking with exponential backoff for subscription attempts:

```rust
// Add to SubscriptionManager struct
struct PeerReputationTracker {
    failed_attempts: HashMap<PeerNetworkId, (u32, Instant)>, // (count, last_failure)
    blacklist_duration_ms: u64,
}

// In sort_peers_for_subscriptions, filter out recently failed peers:
fn sort_peers_for_subscriptions(
    mut connected_peers_and_metadata: HashMap<PeerNetworkId, PeerMetadata>,
    active_subscription_peers: Vec<PeerNetworkId>,
    unhealthy_subscription_peers: Vec<PeerNetworkId>,
    reputation_tracker: &PeerReputationTracker, // Add this parameter
    consensus_publisher: Option<Arc<ConsensusPublisher>>,
) -> Option<Vec<PeerNetworkId>> {
    // Remove recently failed peers based on reputation
    let now = Instant::now();
    connected_peers_and_metadata.retain(|peer, _| {
        if let Some((failures, last_failure)) = reputation_tracker.failed_attempts.get(peer) {
            let backoff = Duration::from_millis(
                reputation_tracker.blacklist_duration_ms * 2u64.pow(*failures - 1)
            );
            now.duration_since(*last_failure) > backoff
        } else {
            true
        }
    });
    // ... rest of existing logic
}
```

Additional mitigations:
1. **Parallel peer probing**: Try multiple peers concurrently instead of sequentially
2. **Early timeout detection**: Track response times and reduce timeout for consistently slow peers
3. **Reputation metrics**: Expose peer reliability metrics to monitor for attack patterns

## Proof of Concept

```rust
#[tokio::test]
async fn test_slow_response_dos_attack() {
    // Setup consensus observer client and config
    let consensus_observer_config = ConsensusObserverConfig {
        network_request_timeout_ms: 5000,
        ..Default::default()
    };
    
    // Create malicious peer that responds slowly
    let malicious_peer = create_malicious_peer_with_delay(
        NetworkId::Public,
        0, // fake distance = 0 (appears optimal)
        0.01, // fake latency = 10ms (appears fast)
        4900, // response delay = 4.9 seconds
    );
    
    // Measure time for first subscription attempt
    let start = Instant::now();
    let subscription = create_single_subscription(
        consensus_observer_config,
        consensus_observer_client,
        db_reader,
        vec![malicious_peer],
        time_service,
    ).await;
    let first_attempt_duration = start.elapsed();
    
    // Verify it took ~5 seconds and failed
    assert!(first_attempt_duration >= Duration::from_millis(4900));
    assert!(subscription.0.is_none());
    
    // Attempt second subscription - malicious peer should be tried AGAIN
    let start = Instant::now();
    let subscription = create_single_subscription(
        consensus_observer_config,
        consensus_observer_client,
        db_reader,
        vec![malicious_peer], // Same peer, no blacklisting
        time_service,
    ).await;
    let second_attempt_duration = start.elapsed();
    
    // Verify attack can repeat
    assert!(second_attempt_duration >= Duration::from_millis(4900));
    assert!(subscription.0.is_none());
    
    // Total time wasted: ~10 seconds for 2 attempts with 1 malicious peer
    // With N malicious peers sorted first: N * 5 seconds per subscription task
}
```

## Notes

This vulnerability specifically affects consensus observer nodes (VFNs and PFNs) that subscribe to peers for consensus updates. It does not impact validators running the core consensus protocol. The attack exploits the lack of persistent peer reputation tracking combined with sequential peer probing and attacker-controllable peer metadata. The fallback mechanism prevents total failure but results in significantly degraded performance.

### Citations

**File:** consensus/src/consensus_observer/observer/subscription_utils.rs (L95-96)
```rust
        // Remove the failed peers from the sorted list
        sorted_potential_peers.retain(|peer| !failed_subscription_peers.contains(peer));
```

**File:** consensus/src/consensus_observer/observer/subscription_utils.rs (L138-140)
```rust
        let response = consensus_observer_client
            .send_rpc_request_to_peer(&potential_peer, subscription_request, request_timeout_ms)
            .await;
```

**File:** consensus/src/consensus_observer/observer/subscription_utils.rs (L176-186)
```rust
            Err(error) => {
                // We encountered an error while sending the request
                warn!(
                    LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                        "Failed to send subscription request to peer: {}! Error: {:?}",
                        potential_peer, error
                    ))
                );

                // Add the peer to the list of failed attempts
                peers_with_failed_attempts.push(potential_peer);
```

**File:** consensus/src/consensus_observer/observer/subscription_utils.rs (L268-269)
```rust
    // Sort the peers by subscription optimality
    let sorted_peers = sort_peers_by_subscription_optimality(&connected_peers_and_metadata);
```

**File:** peer-monitoring-service/server/src/lib.rs (L324-332)
```rust
        if let Some(ref latest_network_info_response) = peer_metadata
            .get_peer_monitoring_metadata()
            .latest_network_info_response
        {
            min_peer_distance_from_validators = min(
                min_peer_distance_from_validators,
                latest_network_info_response.distance_from_validators,
            );
        }
```

**File:** config/src/config/consensus_observer_config.rs (L70-70)
```rust
            network_request_timeout_ms: 5_000,                 // 5 seconds
```

**File:** config/src/config/consensus_observer_config.rs (L73-73)
```rust
            progress_check_interval_ms: 5_000, // 5 seconds
```

**File:** consensus/src/consensus_observer/observer/subscription_manager.rs (L193-196)
```rust
        if let Some(subscription_creation_task) = &*self.active_subscription_creation_task.lock() {
            if !subscription_creation_task.is_finished() {
                return; // The task is still running
            }
```

**File:** consensus/src/consensus_observer/observer/fallback_manager.rs (L104-108)
```rust
            if duration_since_highest_seen > fallback_threshold {
                Err(Error::ObserverProgressStopped(format!(
                    "Consensus observer is not making progress! Highest synced version: {}, elapsed: {:?}",
                    highest_synced_version, duration_since_highest_seen
                )))
```
