# Audit Report

## Title
Resource Group Initialization Race Condition Causes Cache Poisoning in Parallel Execution

## Summary
A race condition exists in the resource group initialization logic where concurrent transactions can poison the multi-version cache with incorrect deletion entries instead of actual storage values. This occurs because group entries become visible in the DashMap before individual tag values are written, allowing concurrent reads to observe a partially initialized state and write incorrect sentinel values that override the correct storage data.

## Finding Description

The vulnerability exists in the interaction between `VersionedGroupData::set_raw_base_values` and `fetch_tagged_data_*` methods during parallel execution. The issue breaks the **Deterministic Execution** invariant, which requires all validators to produce identical state roots for identical blocks. [1](#0-0) 

In `set_raw_base_values`, the group entry is inserted into the DashMap via `or_default()` at line 155, making it immediately visible to other threads. However, the individual tag values are only written later in the loop (lines 176-182). This creates a window where other transactions can observe the group as initialized but find specific tags uninitialized. [2](#0-1) 

The fetch methods check if a group is initialized by calling `contains_key()` on line 452, which returns `true` if the entry exists. The comment on line 448 states "we always write size after data", but this is contradicted by the actual implementation which writes size **before** data. [3](#0-2) 

When `fetch_tagged_data` observes `initialized = true` but gets `Uninitialized` from the values map, `convert_tagged_data` returns `TagNotFound` (line 684). This triggers special handling in the view layer: [4](#0-3) 

The `TagNotFound` handler writes a deletion to the base value and retries. However, when the initialization thread subsequently tries to write the actual storage value, it is ignored: [5](#0-4) 

The `set_base_value` logic prioritizes `Exchanged` values over `RawFromStorage`, causing the correct storage value to be discarded in favor of the poisoned deletion.

**Attack Scenario:**
1. Transaction T1 reads resource group G at address A, triggering initialization
2. T1's `set_raw_base_values` inserts group entry (line 155), making it visible
3. T1 begins writing individual tag values in loop (line 176)
4. Transaction T2 concurrently reads tag T from group G
5. T2 sees `group_sizes.contains_key(G) = true` (group initialized)
6. T2 fetches tag T data â†’ returns `Uninitialized` (T1 hasn't written it yet)
7. T2 converts to `TagNotFound`, writes deletion for tag T
8. T1 continues and tries to write actual value for tag T from storage
9. T1's write is ignored because deletion (Exchanged) > storage value (RawFromStorage)
10. Cache now contains deletion instead of actual storage value

During validation, if both transactions read the poisoned deletion, validation passes even though the value is incorrect: [6](#0-5) 

## Impact Explanation

This vulnerability qualifies as **Medium Severity** per the Aptos bug bounty program:
- **State inconsistencies requiring intervention**: Different transactions may observe different values depending on execution timing, violating deterministic execution
- **Non-deterministic behavior**: The same block executed by different validators could produce different state roots if the race condition manifests differently
- **Validation failures**: Transactions that read correct values may fail validation against poisoned cache, causing unnecessary aborts and execution delays

While this doesn't directly cause fund loss, it can lead to consensus issues if validators observe different execution outcomes, potentially requiring manual intervention to resolve state divergence.

## Likelihood Explanation

**Likelihood: High** during normal parallel execution workloads.

The race condition occurs naturally during concurrent transaction processing:
- No malicious intent required - normal transaction parallelism triggers it
- Resource groups are commonly used in Aptos (e.g., coin stores, token collections)
- The timing window is significant: between DashMap entry insertion and completing the tag value write loop
- Parallel execution with BlockSTM actively encourages concurrent access to the same resources
- The comment indicating "TODO(BlockSTMv2): complete overhaul of initialization logic" suggests developers are aware of initialization issues

The vulnerability is more likely to manifest under high transaction throughput when multiple transactions access the same resource group simultaneously.

## Recommendation

**Fix 1: Atomic Initialization with All Tags**
Write all tag values to the underlying `VersionedData` **before** making the group visible in `group_sizes`. This ensures no concurrent reader can observe a partially initialized group:

```rust
pub fn set_raw_base_values(
    &self,
    group_key: K,
    base_values: Vec<(T, V)>,
) -> anyhow::Result<()> {
    // Check if already initialized without inserting
    if let Some(g) = self.group_sizes.get(&group_key) {
        if g.size_entries.contains_key(&ShiftedTxnIndex::zero_idx()) {
            return Ok(()); // Already initialized
        }
    }
    
    // Compute size first
    let group_size = group_size_as_sum::<T>(
        base_values
            .iter()
            .flat_map(|(tag, value)| value.bytes().map(|b| (tag.clone(), b.len()))),
    )?;
    
    // Write ALL tag values BEFORE making group visible
    let mut tags_to_insert = HashSet::new();
    for (tag, value) in base_values.iter() {
        tags_to_insert.insert(tag.clone());
        self.values.set_base_value(
            (group_key.clone(), tag.clone()),
            ValueWithLayout::RawFromStorage(Arc::new(value.clone())),
        );
    }
    
    // NOW make group visible atomically
    let mut group_sizes = self.group_sizes.entry(group_key.clone()).or_default();
    if let Vacant(entry) = group_sizes.size_entries.entry(ShiftedTxnIndex::zero_idx()) {
        entry.insert(SizeEntry::new(SizeAndDependencies::from_size(group_size)));
        
        let mut superset_tags = self.group_tags.entry(group_key.clone()).or_default();
        for tag in tags_to_insert {
            superset_tags.insert(tag);
        }
    }
    
    Ok(())
}
```

**Fix 2: Use Initialization Lock Pattern**
Add an explicit initialization state separate from the group_sizes existence check, preventing concurrent readers from accessing partially initialized groups.

## Proof of Concept

The following Rust proptest demonstrates the race condition:

```rust
#[test]
fn test_resource_group_initialization_race() {
    use std::sync::Arc;
    use std::thread;
    use proptest::prelude::*;
    
    let group_data = Arc::new(VersionedGroupData::<KeyType, usize, TestValue>::empty());
    let group_key = KeyType(b"/test/group".to_vec());
    
    // Prepare base values with multiple tags
    let base_values = vec![
        (1, TestValue::creation_with_len(100)),
        (2, TestValue::creation_with_len(200)),
        (3, TestValue::creation_with_len(300)),
    ];
    
    let group_data_clone1 = Arc::clone(&group_data);
    let group_data_clone2 = Arc::clone(&group_data);
    let group_key_clone = group_key.clone();
    
    // Thread 1: Initialize group
    let init_thread = thread::spawn(move || {
        group_data_clone1.set_raw_base_values(group_key.clone(), base_values).unwrap();
    });
    
    // Thread 2: Concurrent read of tag 2 (may execute before initialization completes)
    let read_thread = thread::spawn(move || {
        // Small delay to increase likelihood of hitting race window
        thread::sleep(std::time::Duration::from_micros(10));
        
        // This fetch may observe initialized=true but tag not written yet
        let result = group_data_clone2.fetch_tagged_data_no_record(&group_key_clone, &2, 0);
        result
    });
    
    init_thread.join().unwrap();
    let read_result = read_thread.join().unwrap();
    
    // After both threads complete, verify the final state
    let final_result = group_data.fetch_tagged_data_no_record(&group_key, &2, 0);
    
    // Bug: If race occurred, final_result may be TagNotFound (deletion)
    // even though tag 2 exists in storage with value 200
    match final_result {
        Ok((_, value)) => {
            assert_eq!(value.bytes().map(|b| b.len()), Some(200));
        },
        Err(MVGroupError::TagNotFound) => {
            panic!("Cache poisoning detected: tag 2 shows as deleted but exists in storage!");
        },
        _ => {}
    }
}
```

The test demonstrates that under concurrent execution, a tag that exists in storage can appear as deleted in the cache due to the initialization race condition.

## Notes

The codebase contains a TODO comment acknowledging initialization issues that need to be addressed. This vulnerability confirms those concerns are valid and require immediate attention to maintain the deterministic execution guarantee critical for blockchain consensus.

### Citations

**File:** aptos-move/mvhashmap/src/versioned_group_data.rs (L150-186)
```rust
    pub fn set_raw_base_values(
        &self,
        group_key: K,
        base_values: Vec<(T, V)>,
    ) -> anyhow::Result<()> {
        let mut group_sizes = self.group_sizes.entry(group_key.clone()).or_default();

        // Currently the size & value are written while holding the sizes lock.
        if let Vacant(entry) = group_sizes.size_entries.entry(ShiftedTxnIndex::zero_idx()) {
            // Perform group size computation if base not already provided.
            let group_size = group_size_as_sum::<T>(
                base_values
                    .iter()
                    .flat_map(|(tag, value)| value.bytes().map(|b| (tag.clone(), b.len()))),
            )
            .map_err(|e| {
                anyhow!(
                    "Tag serialization error in resource group at {:?}: {:?}",
                    group_key.clone(),
                    e
                )
            })?;

            entry.insert(SizeEntry::new(SizeAndDependencies::from_size(group_size)));

            let mut superset_tags = self.group_tags.entry(group_key.clone()).or_default();
            for (tag, value) in base_values.into_iter() {
                superset_tags.insert(tag.clone());
                self.values.set_base_value(
                    (group_key.clone(), tag),
                    ValueWithLayout::RawFromStorage(Arc::new(value)),
                );
            }
        }

        Ok(())
    }
```

**File:** aptos-move/mvhashmap/src/versioned_group_data.rs (L436-458)
```rust
    pub fn fetch_tagged_data_and_record_dependency(
        &self,
        group_key: &K,
        tag: &T,
        txn_idx: TxnIndex,
        incarnation: Incarnation,
    ) -> Result<(Version, ValueWithLayout<V>), MVGroupError> {
        let key_ref = GroupKeyRef { group_key, tag };

        // We are accessing group_sizes and values non-atomically, hence the order matters.
        // It is important that initialization check happens before fetch data below. O.w.
        // we could incorrectly get a TagNotFound error (do not find data, but then find
        // size initialized in between the calls). In fact, we always write size after data,
        // and sometimes (e.g. during initialization) even hold the sizes lock during writes.
        // It is fine to observe initialized = false, but find data, in convert_tagged_data.
        // TODO(BlockSTMv2): complete overhaul of initialization logic.
        let initialized = self.group_sizes.contains_key(group_key);

        let data_value =
            self.values
                .fetch_data_and_record_dependency(&key_ref, txn_idx, incarnation);
        self.convert_tagged_data(data_value, initialized)
    }
```

**File:** aptos-move/mvhashmap/src/versioned_group_data.rs (L676-695)
```rust
    fn convert_tagged_data(
        &self,
        data_value: anyhow::Result<MVDataOutput<V>, MVDataError>,
        initialized: bool,
    ) -> Result<(Version, ValueWithLayout<V>), MVGroupError> {
        match data_value {
            Ok(MVDataOutput::Versioned(version, value)) => Ok((version, value)),
            Err(MVDataError::Uninitialized) => Err(if initialized {
                MVGroupError::TagNotFound
            } else {
                MVGroupError::Uninitialized
            }),
            Err(MVDataError::Dependency(dep_idx)) => Err(MVGroupError::Dependency(dep_idx)),
            Ok(MVDataOutput::Resolved(_))
            | Err(MVDataError::Unresolved(_))
            | Err(MVDataError::DeltaApplicationFailure) => {
                unreachable!("Not using aggregatorV1")
            },
        }
    }
```

**File:** aptos-move/block-executor/src/view.rs (L815-828)
```rust
                Err(TagNotFound) => {
                    // TagNotFound means group was initialized (o.w. Uninitialized branch
                    // would be visited), but the tag didn't exist. So record an empty resource
                    // as a base value, and do continue to retry the read.
                    self.versioned_map
                        .group_data()
                        .update_tagged_base_value_with_layout(
                            group_key.clone(),
                            resource_tag.clone(),
                            TransactionWrite::from_state_value(None),
                            None,
                        );
                    continue;
                },
```

**File:** aptos-move/mvhashmap/src/versioned_data.rs (L586-588)
```rust
                        (Exchanged(_, _), RawFromStorage(_)) => {
                            // Stored value contains more info, nothing to do.
                        },
```

**File:** aptos-move/block-executor/src/captured_reads.rs (L1119-1130)
```rust
                    Err(TagNotFound) => {
                        let sentinel_deletion =
                            TriompheArc::<T::Value>::new(TransactionWrite::from_state_value(None));
                        assert!(sentinel_deletion.is_deletion());
                        matches!(
                            self.data_read_comparator.compare_data_reads(
                                &DataRead::Versioned(Err(StorageVersion), sentinel_deletion, None),
                                r,
                            ),
                            DataReadComparison::Contains
                        )
                    },
```
