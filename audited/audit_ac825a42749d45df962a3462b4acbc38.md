# Audit Report

## Title
Zero InputSecret in DKG Allows Malicious Validators to Reduce Randomness Entropy

## Summary
The PVSS dealing protocol does not validate that `InputSecret` values are non-zero before using them as the constant term of Shamir secret sharing polynomials. Malicious validators can exploit this by contributing zero secrets during DKG, reducing the entropy of the aggregated dealt secret key used for on-chain randomness generation.

## Finding Description

The Aptos blockchain uses Distributed Key Generation (DKG) with Publicly Verifiable Secret Sharing (PVSS) to establish a shared secret key for on-chain randomness. Each validator contributes an `InputSecret` that becomes the constant term of a Shamir polynomial. [1](#0-0) 

The `InputSecret` type implements the `Zero` trait, allowing creation and detection of zero-valued secrets, but no validation prevents their use.

During transcript generation, the secret is directly used as the polynomial's constant term without validation: [2](#0-1) [3](#0-2) 

When transcripts are aggregated from multiple validators, the polynomial commitments are added homomorphically: [4](#0-3) [5](#0-4) 

**Attack Scenario:**

1. A Byzantine validator generates `InputSecret::zero()` instead of random secret
2. They create a valid PVSS transcript with this zero secret
3. The transcript passes all verification checks (no zero validation exists)
4. During aggregation, their contribution adds nothing: `aggregated_secret = honest_secrets + 0`
5. If k malicious validators do this, entropy is reduced from n validators to (n-k) validators
6. In extreme case where (n - threshold) validators use zero secrets, the remaining validators' secrets can be learned through collusion

The dealt secret key is used for on-chain randomness generation: [6](#0-5) 

**Which Invariant is Broken:**

This violates **Cryptographic Correctness** (Invariant #10): "BLS signatures, VRF, and hash operations must be secure." The DKG protocol assumes all validators contribute random entropy, but zero secrets violate this assumption, making the randomness predictable if enough validators collude.

## Impact Explanation

**Severity: High** 

This qualifies as a **Significant Protocol Violation** under the High severity category. While it doesn't directly cause consensus safety violations or fund theft, it compromises the security foundation of on-chain randomness:

- **Randomness Predictability**: If Byzantine validators (up to 33% under BFT assumptions) all use zero secrets, they reduce the effective entropy from all n validators to only the honest validators
- **Collusion Amplification**: With knowledge that confederates used zero secrets, malicious actors can predict randomness if they comprise enough of the remaining set
- **Application Security Impact**: Smart contracts relying on `aptos_framework::randomness` for fair lotteries, NFT mints, or validator selection could be exploited

The vulnerability affects all validators network-wide when malicious participants abuse it. While it doesn't require a hardfork to fix, it undermines trust in the randomness beacon.

## Likelihood Explanation

**Likelihood: Medium-High**

- **Attacker Requirements**: Requires being a validator with voting power, which is a privileged position. However, under standard Byzantine assumptions, up to 1/3 of validators may be malicious.
- **Complexity**: Trivially easy to execute - simply call `InputSecret::zero()` instead of `InputSecret::generate(&mut rng)`
- **Detection Difficulty**: No current validation would detect this attack; zero secrets produce valid transcripts
- **Incentive**: High incentive for validators who want predictable randomness for frontrunning DeFi operations or manipulating randomness-dependent protocols

The attack becomes more powerful with collusion. Even 2-3 colluding validators significantly reduce entropy, and the attack is undetectable without the proposed fix.

## Recommendation

Add validation to reject zero secrets in the `deal()` function before creating the polynomial:

```rust
fn deal<A: Serialize + Clone, R: rand_core::RngCore + rand_core::CryptoRng>(
    sc: &Self::SecretSharingConfig,
    pp: &Self::PublicParameters,
    _ssk: &Self::SigningSecretKey,
    spk: &Self::SigningPubKey,
    eks: &[Self::EncryptPubKey],
    s: &Self::InputSecret,
    session_id: &A,
    dealer: &Player,
    rng: &mut R,
) -> Self {
    // Validate secret is non-zero
    if s.is_zero() {
        panic!("InputSecret must be non-zero for cryptographic security");
    }
    
    // ... existing implementation
}
```

Additionally, add a verification check in `verify_transcript()` to reject transcripts with zero commitment to the constant term (though this is computationally infeasible to check directly, the dealing-side validation is sufficient).

Apply this fix to all PVSS implementations:
- `crates/aptos-dkg/src/pvss/chunky/weighted_transcript.rs`
- `crates/aptos-dkg/src/pvss/chunky/weighted_transcriptv2.rs`
- `crates/aptos-dkg/src/pvss/das/weighted_protocol.rs`
- `crates/aptos-dkg/src/pvss/das/unweighted_protocol.rs`

## Proof of Concept

```rust
#[cfg(test)]
mod zero_secret_attack {
    use super::*;
    use aptos_crypto::Uniform;
    use aptos_dkg::pvss::traits::Transcript;
    use rand::thread_rng;
    
    #[test]
    #[should_panic(expected = "InputSecret must be non-zero")]
    fn test_zero_secret_rejected() {
        let mut rng = thread_rng();
        let sc = /* setup secret sharing config */;
        let pp = /* setup public parameters */;
        let eks = /* setup encryption keys */;
        
        // Malicious validator creates zero secret
        let zero_secret = InputSecret::zero();
        
        // This should panic with the fix applied
        let transcript = WTrx::deal(
            &sc,
            &pp,
            &ssk,
            &spk,
            &eks,
            &zero_secret,  // ATTACK: Using zero secret
            &session_id,
            &Player { id: 0 },
            &mut rng,
        );
    }
    
    #[test]
    fn test_entropy_reduction_attack() {
        // Demonstrate that multiple zero secrets reduce entropy
        let mut rng = thread_rng();
        
        // Validator 1: honest, random secret
        let secret1 = InputSecret::generate(&mut rng);
        let trx1 = /* generate transcript with secret1 */;
        
        // Validator 2: malicious, zero secret  
        let secret2 = InputSecret::zero();
        let trx2 = /* generate transcript with secret2 */;
        
        // Aggregate
        let mut aggregated = trx1.clone();
        aggregated.aggregate_with(&sc, &trx2);
        
        // The aggregated secret equals secret1 + 0 = secret1
        // Validator 2 contributed no entropy
        assert!(/* verify entropy reduced */);
    }
}
```

**Notes:**

This vulnerability is a protocol-level flaw that affects the security foundation of Aptos on-chain randomness. The fix is straightforward and should be applied immediately to prevent entropy reduction attacks by Byzantine validators.

### Citations

**File:** crates/aptos-crypto/src/input_secret.rs (L53-61)
```rust
impl Zero for InputSecret {
    fn zero() -> Self {
        InputSecret { a: Scalar::ZERO }
    }

    fn is_zero(&self) -> bool {
        self.a.is_zero_vartime()
    }
}
```

**File:** crates/aptos-dkg/src/pvss/chunky/weighted_transcript.rs (L394-395)
```rust
        // Aggregate the V0s
        self.V0 += other.V0;
```

**File:** crates/aptos-dkg/src/pvss/chunky/weighted_transcript.rs (L508-514)
```rust
        // Generate the Shamir secret sharing polynomial
        let mut f = vec![*s.get_secret_a()]; // constant term of polynomial
        f.extend(sample_field_elements::<E::ScalarField, _>(
            sc.get_threshold_weight() - 1,
            rng,
        )); // these are the remaining coefficients; total degree is `t - 1`, so the reconstruction threshold is `t`

```

**File:** crates/aptos-crypto/src/blstrs/polynomials.rs (L657-661)
```rust
) -> (Vec<Scalar>, Vec<Scalar>) {
    // A random, degree t-1 polynomial $f(X) = [a_0, \dots, a_{t-1}]$, with $a_0$ set to `s.a`
    let mut f = random_scalars(sc.t, rng);
    f[0] = *s.get_secret_a();

```

**File:** types/src/dkg/real_dkg/mod.rs (L234-238)
```rust
    fn dealt_secret_from_input(
        pub_params: &Self::PublicParams,
        input: &Self::InputSecret,
    ) -> Self::DealtSecret {
        input.to(&pub_params.pvss_config.pp)
```

**File:** types/src/dkg/real_dkg/mod.rs (L408-411)
```rust
        accumulator
            .main
            .aggregate_with(&params.pvss_config.wconfig, &element.main)
            .expect("Transcript aggregation failed");
```
