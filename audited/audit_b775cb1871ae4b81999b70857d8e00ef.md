# Audit Report

## Title
Race Condition in GasUnitPriceManager Leading to Transaction Failures and API Overload

## Summary
The `GasUnitPriceManager::get_gas_unit_price()` function in the Aptos faucet contains a Time-of-Check-Time-of-Use (TOCTOU) race condition that allows multiple threads to simultaneously fetch gas prices from the API when the cache expires, causing redundant API calls and inconsistent gas price values across concurrent requests, potentially leading to transaction failures.

## Finding Description
The vulnerability exists in the `GasUnitPriceManager::get_gas_unit_price()` method [1](#0-0) . The function implements a flawed double-checked locking pattern:

1. **First check (with read lock)**: Multiple threads check if the cache has expired
2. **Race window**: After releasing the read lock but before acquiring the write lock, multiple threads can all determine the cache is expired
3. **Missing re-check**: After acquiring the write lock, there is no verification to check if another thread has already updated the cache
4. **Redundant updates**: Each thread independently fetches from the API and updates the shared state

**Attack Flow:**

When the 30-second cache TTL expires and multiple concurrent faucet requests arrive:

- Thread A reads `last_updated` (expired), releases read lock, waits for write lock
- Thread B reads `last_updated` (still expired), releases read lock, waits for write lock  
- Thread A acquires write lock → fetches gas price (gets 100) → stores 100 → releases lock → returns 100
- Thread B acquires write lock → fetches gas price (gets 105, price changed) → stores 105 → releases lock → returns 105

Thread A uses gas price 100 for its transaction [2](#0-1) , while Thread B uses 105. If the actual minimum gas unit price is now 105, Thread A's transaction will be rejected with `GAS_UNIT_PRICE_BELOW_MIN_BOUND` [3](#0-2) .

The gas price can legitimately vary between API calls because it's calculated dynamically based on recent block history [4](#0-3) , meaning new blocks added between calls will change the estimated price.

## Impact Explanation
This qualifies as **High Severity** under the Aptos bug bounty program because:

1. **API Overload**: When cache expires, all concurrent requests independently call the gas estimation API, causing redundant load. With many concurrent users, this creates API request spikes that can degrade service performance or cause API slowdowns.

2. **Transaction Failures**: Faucet transactions built with stale gas prices below the minimum bound will be rejected [3](#0-2) , preventing users from receiving funds. The minimum gas price is enforced at 100 in production [5](#0-4) .

3. **Service Reliability**: Unpredictable transaction failures due to race conditions undermine faucet service reliability, affecting developer experience and testnet functionality.

## Likelihood Explanation
**High Likelihood** - This will occur regularly in production because:

1. The cache expires every 30 seconds by default [6](#0-5) 
2. Faucet services typically receive concurrent requests from multiple users/CI systems
3. No special timing or coordination is required - normal concurrent usage triggers the race
4. The race window is large (entire duration of the API fetch network call)

## Recommendation

Implement proper double-checked locking by re-checking the cache after acquiring the write lock:

```rust
pub async fn get_gas_unit_price(&self) -> Result<u64> {
    let now = Instant::now();

    // First check with read lock
    if let Some(last_updated) = *self.last_updated.read().await {
        if now.duration_since(last_updated) < self.cache_ttl {
            return Ok(self.gas_unit_price.load(Ordering::Acquire));
        }
    }

    // Acquire write lock
    let mut last_updated = self.last_updated.write().await;
    
    // RE-CHECK after acquiring write lock - another thread may have updated
    if let Some(updated) = *last_updated {
        let now = Instant::now(); // Re-sample time
        if now.duration_since(updated) < self.cache_ttl {
            return Ok(self.gas_unit_price.load(Ordering::Acquire));
        }
    }

    // Only update if still expired
    let new_price = self.fetch_gas_unit_price().await?;
    self.gas_unit_price.store(new_price, Ordering::Release);
    *last_updated = Some(now);

    info!(gas_unit_price = new_price, event = "gas_unit_price_updated");
    Ok(new_price)
}
```

This mirrors the correct pattern already implemented in the API's own gas estimation cache [7](#0-6) .

## Proof of Concept

```rust
use std::sync::Arc;
use std::time::Duration;
use tokio::sync::RwLock;
use tokio::time::Instant;

#[tokio::test]
async fn test_gas_price_race_condition() {
    let manager = Arc::new(GasUnitPriceManager::new(
        Url::parse("http://localhost:8080").unwrap(),
        Duration::from_secs(1), // Short TTL for testing
    ));
    
    // Wait for initial cache to expire
    tokio::time::sleep(Duration::from_secs(2)).await;
    
    // Spawn 10 concurrent requests when cache is expired
    let mut handles = vec![];
    for i in 0..10 {
        let manager_clone = manager.clone();
        handles.push(tokio::spawn(async move {
            let price = manager_clone.get_gas_unit_price().await.unwrap();
            println!("Thread {} got price: {}", i, price);
            price
        }));
    }
    
    let results: Vec<u64> = futures::future::join_all(handles)
        .await
        .into_iter()
        .map(|r| r.unwrap())
        .collect();
    
    // Assert: Multiple different prices indicate race condition
    // Expected: Only 1 API call should have been made (all should get same price)
    // Actual: Multiple API calls made, potentially different prices
    let unique_prices: std::collections::HashSet<_> = results.iter().collect();
    assert_eq!(unique_prices.len(), 1, "Race condition: got {} different gas prices", unique_prices.len());
}
```

**Expected behavior**: All 10 threads should receive the same gas price (only 1 API call).  
**Actual behavior**: Multiple threads call the API independently, potentially receiving different prices if the blockchain state changes between calls.

## Notes

The vulnerability is specific to the faucet service's gas price caching mechanism. The Aptos API itself has proper protection with double-checked locking [8](#0-7) , but the faucet's wrapper around it reintroduces the race condition. This affects both the `MintFunder` [9](#0-8)  and `TransferFunder` [10](#0-9)  implementations.

### Citations

**File:** crates/aptos-faucet/core/src/funder/common.rs (L153-155)
```rust
    fn default_gas_unit_price_ttl_secs() -> u16 {
        30
    }
```

**File:** crates/aptos-faucet/core/src/funder/common.rs (L420-438)
```rust
    pub async fn get_gas_unit_price(&self) -> Result<u64> {
        let now = Instant::now();

        // If we're still within the TTL, just return the current value.
        if let Some(last_updated) = *self.last_updated.read().await {
            if now.duration_since(last_updated) < self.cache_ttl {
                return Ok(self.gas_unit_price.load(Ordering::Acquire));
            }
        }

        // We're beyond the TTL, update the value and last_updated.
        let mut last_updated = self.last_updated.write().await;
        let new_price = self.fetch_gas_unit_price().await?;
        self.gas_unit_price.store(new_price, Ordering::Release);
        *last_updated = Some(now);

        info!(gas_unit_price = new_price, event = "gas_unit_price_updated");
        Ok(new_price)
    }
```

**File:** crates/aptos-faucet/core/src/funder/mint.rs (L212-212)
```rust
    gas_unit_price_manager: GasUnitPriceManager,
```

**File:** crates/aptos-faucet/core/src/funder/mint.rs (L269-274)
```rust
    async fn get_transaction_factory(&self) -> Result<TransactionFactory, AptosTapError> {
        Ok(self
            .transaction_factory
            .clone()
            .with_gas_unit_price(self.get_gas_unit_price().await?))
    }
```

**File:** aptos-move/aptos-vm/src/gas.rs (L178-191)
```rust
    let below_min_bound = txn_metadata.gas_unit_price() < txn_gas_params.min_price_per_gas_unit;
    if below_min_bound {
        speculative_warn!(
            log_context,
            format!(
                "[VM] Gas unit error; min {}, submitted {}",
                txn_gas_params.min_price_per_gas_unit,
                txn_metadata.gas_unit_price()
            ),
        );
        return Err(VMStatus::error(
            StatusCode::GAS_UNIT_PRICE_BELOW_MIN_BOUND,
            None,
        ));
```

**File:** api/src/context.rs (L1305-1317)
```rust
        // 0. (0) Return cached result if it exists
        let cache = self.gas_estimation_cache.read().unwrap();
        if let Some(cached_gas_estimation) = self.cached_gas_estimation(&cache, epoch) {
            return Ok(cached_gas_estimation);
        }
        drop(cache);

        // 0. (1) Write lock and prepare cache
        let mut cache = self.gas_estimation_cache.write().unwrap();
        // Retry cached result after acquiring write lock
        if let Some(cached_gas_estimation) = self.cached_gas_estimation(&cache, epoch) {
            return Ok(cached_gas_estimation);
        }
```

**File:** api/src/context.rs (L1325-1389)
```rust
        let max_block_history = config.aggressive_block_history;
        // 1. Get the block metadata txns
        let mut lookup_version = ledger_info.ledger_version.0;
        let mut blocks = vec![];
        // Skip the first block, which may be partial
        if let Ok((first, _, block)) = self.db.get_block_info_by_version(lookup_version) {
            if block.epoch() == epoch {
                lookup_version = first.saturating_sub(1);
            }
        }
        let mut cached_blocks_hit = false;
        for _i in 0..max_block_history {
            if cache
                .min_inclusion_prices
                .contains_key(&(epoch, lookup_version))
            {
                cached_blocks_hit = true;
                break;
            }
            match self.db.get_block_info_by_version(lookup_version) {
                Ok((first, last, block)) => {
                    if block.epoch() != epoch {
                        break;
                    }
                    lookup_version = first.saturating_sub(1);
                    blocks.push((first, last));
                    if lookup_version == 0 {
                        break;
                    }
                },
                Err(_) => {
                    break;
                },
            }
        }
        if blocks.is_empty() && !cached_blocks_hit {
            let estimation = self.default_gas_estimation(min_gas_unit_price);
            self.update_cached_gas_estimation(&mut cache, epoch, estimation);
            return Ok(estimation);
        }
        let blocks_len = blocks.len();
        let remaining = max_block_history - blocks_len;

        // 2. Get gas prices per block
        let mut min_inclusion_prices = vec![];
        // TODO: if multiple calls to db is a perf issue, combine into a single call and then split
        for (first, last) in blocks {
            let min_inclusion_price = self
                .block_min_inclusion_price(ledger_info, first, last, config, &execution_config)
                .unwrap_or(min_gas_unit_price);
            min_inclusion_prices.push(min_inclusion_price);
            cache
                .min_inclusion_prices
                .insert((epoch, last), min_inclusion_price);
        }
        if cached_blocks_hit {
            for (_, v) in cache
                .min_inclusion_prices
                .range((Included(&(epoch, 0)), Included(&(epoch, lookup_version))))
                .rev()
                .take(remaining)
            {
                min_inclusion_prices.push(*v);
            }
        }
```

**File:** config/global-constants/src/lib.rs (L26-26)
```rust
pub const GAS_UNIT_PRICE: u64 = 100;
```

**File:** crates/aptos-faucet/core/src/funder/transfer.rs (L112-112)
```rust
    gas_unit_price_manager: GasUnitPriceManager,
```
