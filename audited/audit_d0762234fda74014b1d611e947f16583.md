# Audit Report

## Title
No Retry Mechanism for Failed Mempool Commit Notifications Causes Resource Waste and Potential Liveness Degradation

## Summary
When `notify_new_commit()` fails to send commit notifications to mempool (due to channel full or receiver dropped), there is no retry mechanism. Failed notifications cause mempool to indefinitely retain already-committed transactions, wasting resources and potentially degrading system liveness. However, the impact is mitigated by mempool's storage-based validation, which prevents permanent state divergence.

## Finding Description

When consensus commits transactions, state sync notifies mempool via an async channel to remove those transactions from its pending pool. The notification flow is:

1. State sync calls `notify_new_commit()` which sends to a bounded channel (default capacity: 100) [1](#0-0) 

2. If the send fails, `CommitNotificationError` is returned [2](#0-1) 

3. The error propagates to `notify_mempool_of_committed_transactions` where it's logged but not retried [3](#0-2) 

4. The error propagates further to `handle_committed_transactions` where it's only logged [4](#0-3) 

5. Consensus receives `Ok(())` response regardless of notification failure [5](#0-4) 

**Consequences:**

Without notification, mempool continues holding committed transactions until:
- A new transaction from the same account triggers storage-based validation (which fetches updated sequence numbers) [6](#0-5) 
- Transaction expires via TTL-based garbage collection [7](#0-6) 

**Critical Discovery - Mitigating Factor:**

Mempool validates incoming transactions by querying storage for current sequence numbers. This prevents permanent state divergence, as mempool will eventually learn committed transactions are stale when validating new ones. [8](#0-7) 

**Remaining Issues:**

1. **Resource Waste**: Between notification failure and next validation, mempool unnecessarily holds and broadcasts committed transactions
2. **Memory Leak**: If no new transactions arrive for an account, committed transactions remain until TTL expiration
3. **Liveness Risk**: Async channel send blocks if full, potentially delaying commit notifications

## Impact Explanation

**Medium Severity** - This qualifies as "State inconsistencies requiring intervention" because:

1. Mempool's view diverges from storage temporarily
2. Resources are wasted (memory, CPU, network bandwidth) holding and broadcasting already-committed transactions
3. In extreme cases, if many notifications fail, mempool could fill up requiring operator intervention
4. Channel blocking could cause temporary slowdowns in the commit notification pipeline

However, this is NOT Critical/High because:
- No funds are lost or at risk
- Consensus safety is not violated
- State divergence is temporary and self-healing via storage validation
- No permanent network partition occurs

## Likelihood Explanation

**Medium Likelihood** - The vulnerability can manifest under realistic conditions:

1. **Channel Full Scenario**: With default capacity of 100 notifications, if mempool processing slows down (e.g., under heavy load) or the mempool handler task is delayed, the channel can fill [9](#0-8) 

2. **Receiver Dropped Scenario**: If the mempool notification handler task panics or crashes, the receiver is dropped and all subsequent notifications immediately fail [10](#0-9) 

3. **Test Evidence**: The codebase explicitly tests both scenarios (channel full and receiver closed), confirming these are known failure modes [11](#0-10) 

The likelihood increases under:
- High transaction throughput
- System resource constraints
- Mempool processing delays

## Recommendation

Implement a retry mechanism with exponential backoff for failed mempool notifications:

```rust
async fn notify_new_commit(
    &self,
    committed_transactions: Vec<Transaction>,
    block_timestamp_usecs: u64,
) -> Result<(), Error> {
    // Prepare notification
    let user_transactions: Vec<CommittedTransaction> = /* ... */;
    let commit_notification = MempoolCommitNotification { /* ... */ };
    
    // Retry with exponential backoff
    const MAX_RETRIES: u32 = 3;
    const BASE_DELAY_MS: u64 = 100;
    
    for attempt in 0..MAX_RETRIES {
        match self.notification_sender.clone().try_send(commit_notification.clone()) {
            Ok(_) => return Ok(()),
            Err(e) if e.is_full() => {
                // Channel full - wait and retry
                let delay = BASE_DELAY_MS * (2_u64.pow(attempt));
                tokio::time::sleep(Duration::from_millis(delay)).await;
                continue;
            },
            Err(e) => {
                // Receiver dropped or other error - fail permanently
                return Err(Error::CommitNotificationError(format!("{:?}", e)));
            }
        }
    }
    
    // All retries exhausted
    Err(Error::CommitNotificationError("Max retries exceeded".into()))
}
```

Additionally:
1. Add monitoring/alerting for notification failures
2. Increase default channel capacity if failures are frequent
3. Consider implementing a periodic reconciliation mechanism that queries storage to clean up stale transactions

## Proof of Concept

The following test demonstrates the vulnerability by filling the notification channel and showing that subsequent commits silently fail to notify mempool:

```rust
#[tokio::test]
async fn test_mempool_notification_failure_causes_resource_waste() {
    use aptos_mempool_notifications::{MempoolNotificationSender, new_mempool_notifier_listener_pair};
    use aptos_types::transaction::Transaction;
    
    // Create a channel with capacity 1 to easily trigger the issue
    let (mempool_notifier, mut mempool_listener) = new_mempool_notifier_listener_pair(1);
    
    // Create test transactions
    let txn1 = create_user_transaction(); // Helper function to create test transaction
    let txn2 = create_user_transaction();
    
    // Send first notification - should succeed
    let result1 = mempool_notifier.notify_new_commit(vec![txn1.clone()], 1000).await;
    assert!(result1.is_ok(), "First notification should succeed");
    
    // Don't process the notification - leave it in the channel
    // Now the channel is full (capacity 1, 1 pending)
    
    // Try to send second notification - this will block indefinitely
    let notify_task = tokio::spawn({
        let notifier = mempool_notifier.clone();
        async move {
            notifier.notify_new_commit(vec![txn2.clone()], 2000).await
        }
    });
    
    // Wait a short time to verify it's blocked
    tokio::time::sleep(Duration::from_millis(100)).await;
    assert!(!notify_task.is_finished(), "Second notification should be blocked");
    
    // This demonstrates that commit notifications can be delayed indefinitely
    // if mempool processing is slow, causing resource waste and potential liveness issues
    
    // Cleanup: process first notification to unblock
    let _ = mempool_listener.next().await;
}
```

This test confirms that when the notification channel is full, the commit notification path blocks, demonstrating the liveness concern. In production, this means committed transactions remain in mempool, wasting resources until either TTL expiration or a new transaction triggers storage-based validation.

**Notes**

The security impact is real but more limited than the question premise suggests:

1. **No Permanent State Divergence**: Storage-based validation prevents permanent inconsistency
2. **Self-Healing**: System recovers when new transactions trigger validation
3. **Resource Waste**: Main impact is inefficient resource usage, not security compromise
4. **Liveness Concern**: Channel blocking could temporarily slow commit processing

The vulnerability qualifies as Medium severity due to resource waste and potential operational impact requiring intervention, but does not constitute a critical security flaw affecting consensus safety or fund security.

### Citations

**File:** state-sync/inter-component/mempool-notifications/src/lib.rs (L103-113)
```rust
        if let Err(error) = self
            .notification_sender
            .clone()
            .send(commit_notification)
            .await
        {
            return Err(Error::CommitNotificationError(format!(
                "Failed to notify mempool of committed transactions! Error: {:?}",
                error
            )));
        }
```

**File:** state-sync/inter-component/mempool-notifications/src/lib.rs (L202-219)
```rust
    async fn test_mempool_not_listening() {
        // Create runtime and mempool notifier
        let (mempool_notifier, mut mempool_listener) =
            crate::new_mempool_notifier_listener_pair(100);

        // Send a notification and expect no failures
        let notify_result = mempool_notifier
            .notify_new_commit(vec![create_user_transaction()], 0)
            .await;
        assert_ok!(notify_result);

        // Drop the receiver and try again (this time we expect a failure)
        mempool_listener.notification_receiver.close();
        let notify_result = mempool_notifier
            .notify_new_commit(vec![create_user_transaction()], 0)
            .await;
        assert_matches!(notify_result, Err(Error::CommitNotificationError(_)));
    }
```

**File:** state-sync/state-sync-driver/src/notification_handlers.rs (L528-541)
```rust
        let result = self
            .mempool_notification_sender
            .notify_new_commit(committed_transactions, block_timestamp_usecs)
            .await;

        if let Err(error) = result {
            let error = Error::NotifyMempoolError(format!("{:?}", error));
            error!(LogSchema::new(LogEntry::NotificationHandler)
                .error(&error)
                .message("Failed to notify mempool of committed transactions!"));
            Err(error)
        } else {
            Ok(())
        }
```

**File:** state-sync/state-sync-driver/src/utils.rs (L356-370)
```rust
    if let Err(error) = CommitNotification::handle_transaction_notification(
        committed_transactions.events,
        committed_transactions.transactions,
        latest_synced_version,
        latest_synced_ledger_info,
        mempool_notification_handler,
        event_subscription_service,
        storage_service_notification_handler,
    )
    .await
    {
        error!(LogSchema::new(LogEntry::SynchronizerNotification)
            .error(&error)
            .message("Failed to handle a transaction commit notification!"));
    }
```

**File:** state-sync/state-sync-driver/src/driver.rs (L343-345)
```rust
        // Respond successfully
        self.consensus_notification_handler
            .respond_to_commit_notification(commit_notification, Ok(()))?;
```

**File:** mempool/src/shared_mempool/tasks.rs (L329-350)
```rust
    let state_view = smp
        .db
        .latest_state_checkpoint_view()
        .expect("Failed to get latest state checkpoint view.");

    // Track latency: fetching seq number
    let account_seq_numbers = IO_POOL.install(|| {
        transactions
            .par_iter()
            .map(|(t, _, _)| match t.replay_protector() {
                ReplayProtector::Nonce(_) => Ok(None),
                ReplayProtector::SequenceNumber(_) => {
                    get_account_sequence_number(&state_view, t.sender())
                        .map(Some)
                        .inspect_err(|e| {
                            error!(LogSchema::new(LogEntry::DBError).error(e));
                            counters::DB_ERROR.inc();
                        })
                },
            })
            .collect::<Vec<_>>()
    });
```

**File:** mempool/src/shared_mempool/tasks.rs (L362-375)
```rust
            if let Ok(account_sequence_num) = account_seq_numbers[idx] {
                match account_sequence_num {
                    Some(sequence_num) => {
                        if t.sequence_number() >= sequence_num {
                            return Some((t, Some(sequence_num), ready_time_at_sender, priority));
                        } else {
                            statuses.push((
                                t,
                                (
                                    MempoolStatus::new(MempoolStatusCode::VmError),
                                    Some(DiscardedVMStatus::SEQUENCE_NUMBER_TOO_OLD),
                                ),
                            ));
                        }
```

**File:** mempool/src/core_mempool/mempool.rs (L590-593)
```rust
    pub(crate) fn gc(&mut self) {
        let now = aptos_infallible::duration_since_epoch();
        self.transactions.gc_by_system_ttl(now);
    }
```

**File:** config/src/config/state_sync_config.rs (L147-147)
```rust
            max_pending_mempool_notifications: 100,
```

**File:** mempool/src/shared_mempool/coordinator.rs (L152-162)
```rust
    tokio::spawn(async move {
        while let Some(commit_notification) = mempool_listener.next().await {
            handle_commit_notification(
                &mempool,
                &mempool_validator,
                &use_case_history,
                commit_notification,
                &num_committed_txns_received_since_peers_updated,
            );
        }
    });
```
