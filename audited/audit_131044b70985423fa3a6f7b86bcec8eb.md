# Audit Report

## Title
Indexer Ownership History Loss Due to TransferEvent Overwrite in Multi-Hop Transfers

## Summary
The Aptos indexer contains a bug where multiple `TransferEvent` emissions for the same object within a single transaction result in incomplete ownership history records. While on-chain state and consensus remain correct, the indexer's off-chain database loses intermediate ownership records, creating inconsistent historical data for NFT provenance tracking.

## Finding Description

**Note on Scope**: This finding relates to the indexer infrastructure (`crates/indexer/`), which is auxiliary to the core blockchain. The on-chain consensus, execution, and state management remain secure and deterministic.

**Event Ordering is NOT Manipulable**

First, addressing the core security question: **Event ordering within a transaction cannot be manipulated**. Events are:
1. Emitted deterministically during Move VM execution [1](#0-0) 
2. Collected in a `Vec<ContractEvent>` preserving insertion order [2](#0-1) 
3. Cryptographically committed via `event_root_hash` in `TransactionInfo` [3](#0-2) 
4. Validated by consensus (all validators must agree on identical event_root_hash)

The Move VM's `transfer_raw_inner` function emits events deterministically [4](#0-3) 

**Indexer Processing Bug**

However, the indexer has a bug when processing multiple `TransferEvent`s for the same object. When iterating through events, it overwrites the `transfer_event` field instead of collecting all events: [5](#0-4) 

This causes the ownership tracking logic to only see the last `TransferEvent`, losing intermediate owners: [6](#0-5) 

**Concrete Example**:
Transaction transfers NFT from Alice‚ÜíBob‚ÜíCarol:
- On-chain: Two `TransferEvent`s emitted in order, NFT correctly owned by Carol
- Indexer: Only retains the second event (Bob‚ÜíCarol), creates ownership records showing Bob‚ÜíCarol but missing Alice entirely

This is confirmed by mainnet transaction 550582915 which contains multiple `TransferEvent`s for different objects [7](#0-6) 

## Impact Explanation

**Severity Assessment: Does Not Meet Bounty Criteria**

While this is a real bug with user impact, it does not meet the Aptos bug bounty severity criteria:

- **NOT Critical**: No loss of funds, no consensus violations, no network issues. On-chain state is correct.
- **NOT High**: No validator slowdowns, no API crashes, no protocol violations. The blockchain operates correctly.
- **NOT Medium**: No funds loss. The "state inconsistency" is in the indexer's off-chain database, not the blockchain state.

**Actual Impact**:
- Indexer queries return incomplete NFT ownership history
- Provenance tracking shows gaps for multi-hop transfers
- Historical ownership data is misleading but not financially damaging
- On-chain operations (transfers, sales, burns) function correctly

The indexer is auxiliary infrastructure for querying convenience, not part of the consensus protocol.

## Likelihood Explanation

Multi-hop transfers in a single transaction are rare but possible:
- Batch operations in NFT marketplaces
- Automated trading/routing contracts
- Malicious actors deliberately creating incomplete history

However, since this doesn't affect on-chain security or funds, the security impact is limited to data presentation inconsistencies.

## Recommendation

Modify the indexer to collect ALL `TransferEvent`s per object instead of keeping only the last one:

```rust
// In token_v2_metadata_helper structure, change from:
pub transfer_event: Option<(EventIndex, TransferEvent)>,

// To:
pub transfer_events: Vec<(EventIndex, TransferEvent)>,

// In event processing loop:
aggregated_data.transfer_events.push((index as i64, transfer_event));
```

Then update ownership tracking to process all transfer events in sequence, creating historical records for each intermediate owner.

## Proof of Concept

```move
#[test(creator = @0x123, alice = @0xA11CE, bob = @0xB0B, carol = @0xCA201)]
fun test_multi_hop_transfer_same_txn(
    creator: &signer, 
    alice: &signer,
    bob: &signer, 
    carol: &signer
) acquires ObjectCore {
    let constructor_ref = create_named_object(creator, b"nft");
    let object = object_from_constructor_ref<ObjectCore>(&constructor_ref);
    
    // Transfer alice -> bob -> carol in same transaction
    transfer(alice, object, signer::address_of(bob));
    transfer(bob, object, signer::address_of(carol));
    
    // On-chain state is correct: carol owns it
    assert!(owner(object) == signer::address_of(carol), 0);
    
    // Two TransferEvents were emitted
    // But indexer will only record bob->carol, losing alice's ownership
}
```

**Notes**

1. **Event ordering is deterministic and cannot be manipulated** - The original security question's premise is **not exploitable**. Events are emitted in execution order, cryptographically committed, and validated by consensus.

2. **The indexer bug is real but out of primary scope** - The vulnerability exists in off-chain indexing infrastructure (`crates/indexer/`), not in the core blockchain components (consensus, execution, storage, governance, staking) that are the focus of critical security analysis.

3. **On-chain security is maintained** - All blockchain invariants hold: deterministic execution, consensus safety, state consistency, and cryptographic correctness remain intact.

4. **Limited security impact** - While the bug creates data quality issues for historical queries, it does not enable theft, consensus attacks, or protocol violations that would warrant bounty classification.

### Citations

**File:** aptos-move/framework/src/natives/event.rs (L33-36)
```rust
#[derive(Default, Tid)]
pub struct NativeEventContext {
    events: Vec<(ContractEvent, Option<MoveTypeLayout>)>,
}
```

**File:** aptos-move/framework/src/natives/event.rs (L102-151)
```rust
fn native_write_to_event_store(
    context: &mut SafeNativeContext,
    ty_args: &[Type],
    mut arguments: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    debug_assert!(ty_args.len() == 1);
    debug_assert!(arguments.len() == 3);

    let ty = &ty_args[0];
    let msg = arguments.pop_back().unwrap();
    let seq_num = safely_pop_arg!(arguments, u64);
    let guid = safely_pop_arg!(arguments, Vec<u8>);

    // TODO(Gas): Get rid of abstract memory size
    context.charge(
        EVENT_WRITE_TO_EVENT_STORE_BASE
            + EVENT_WRITE_TO_EVENT_STORE_PER_ABSTRACT_VALUE_UNIT * context.abs_val_size(&msg)?,
    )?;
    let ty_tag = context.type_to_type_tag(ty)?;
    let (layout, contains_delayed_fields) = context
        .type_to_type_layout_with_delayed_fields(ty)?
        .unpack();

    let function_value_extension = context.function_value_extension();
    let max_value_nest_depth = context.max_value_nest_depth();
    let blob = ValueSerDeContext::new(max_value_nest_depth)
        .with_delayed_fields_serde()
        .with_func_args_deserialization(&function_value_extension)
        .serialize(&msg, &layout)?
        .ok_or_else(|| {
            SafeNativeError::InvariantViolation(PartialVMError::new(
                StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR,
            ))
        })?;
    let key = bcs::from_bytes(guid.as_slice()).map_err(|_| {
        SafeNativeError::InvariantViolation(PartialVMError::new(StatusCode::EVENT_KEY_MISMATCH))
    })?;

    let ctx = context.extensions_mut().get_mut::<NativeEventContext>();
    let event =
        ContractEvent::new_v1(key, seq_num, ty_tag, blob).map_err(|_| SafeNativeError::Abort {
            abort_code: ECANNOT_CREATE_EVENT,
        })?;
    // TODO(layouts): avoid cloning layouts for events with delayed fields.
    ctx.events.push((
        event,
        contains_delayed_fields.then(|| layout.as_ref().clone()),
    ));
    Ok(smallvec![])
}
```

**File:** types/src/transaction/mod.rs (L1767-1783)
```rust
pub struct TransactionOutput {
    /// The list of writes this transaction intends to do.
    write_set: WriteSet,

    /// The list of events emitted during this transaction.
    events: Vec<ContractEvent>,

    /// The amount of gas used during execution.
    gas_used: u64,

    /// The execution status. The detailed error info will not be stored here instead will be stored in the auxiliary data.
    status: TransactionStatus,

    /// The transaction auxiliary data that includes detail error info that is not used for calculating the hash
    #[serde(skip)]
    auxiliary_data: TransactionAuxiliaryData,
}
```

**File:** aptos-move/framework/aptos-framework/sources/object.move (L548-571)
```text
    inline fun transfer_raw_inner(object: address, to: address) {
        let object_core = borrow_global_mut<ObjectCore>(object);
        if (object_core.owner != to) {
            if (std::features::module_event_migration_enabled()) {
                event::emit(
                    Transfer {
                        object,
                        from: object_core.owner,
                        to,
                    },
                );
            } else {
                event::emit_event(
                    &mut object_core.transfer_events,
                    TransferEvent {
                        object,
                        from: object_core.owner,
                        to,
                    },
                );
            };
            object_core.owner = to;
        };
    }
```

**File:** crates/indexer/src/processors/token_processor.rs (L1172-1184)
```rust
                if let Some(transfer_event) = TransferEvent::from_event(event, txn_version).unwrap()
                {
                    if let Some(aggregated_data) =
                        token_v2_metadata_helper.get_mut(&transfer_event.get_object_address())
                    {
                        // we don't want index to be 0 otherwise we might have collision with write set change index
                        let index = if index == 0 {
                            user_txn.events.len()
                        } else {
                            index
                        };
                        aggregated_data.transfer_event = Some((index as i64, transfer_event));
                    }
```

**File:** crates/indexer/src/models/token_models/v2_token_ownerships.rs (L165-214)
```rust
        // check if token was transferred
        if let Some((event_index, transfer_event)) = &metadata.transfer_event {
            // If it's a self transfer then skip
            if transfer_event.get_to_address() == transfer_event.get_from_address() {
                return Ok(Some((ownership, current_ownership, None, None)));
            }
            Ok(Some((
                ownership,
                current_ownership,
                Some(Self {
                    transaction_version: token_data.transaction_version,
                    // set to negative of event index to avoid collison with write set index
                    write_set_change_index: -1 * event_index,
                    token_data_id: token_data_id.clone(),
                    property_version_v1: BigDecimal::zero(),
                    // previous owner
                    owner_address: Some(transfer_event.get_from_address()),
                    storage_id: storage_id.clone(),
                    // soft delete
                    amount: BigDecimal::zero(),
                    table_type_v1: None,
                    token_properties_mutated_v1: None,
                    is_soulbound_v2: Some(is_soulbound),
                    token_standard: TokenStandard::V2.to_string(),
                    is_fungible_v2: token_data.is_fungible_v2,
                    transaction_timestamp: token_data.transaction_timestamp,
                    non_transferrable_by_owner: Some(is_soulbound),
                }),
                Some(CurrentTokenOwnershipV2 {
                    token_data_id,
                    property_version_v1: BigDecimal::zero(),
                    // previous owner
                    owner_address: transfer_event.get_from_address(),
                    storage_id,
                    // soft delete
                    amount: BigDecimal::zero(),
                    table_type_v1: None,
                    token_properties_mutated_v1: None,
                    is_soulbound_v2: Some(is_soulbound),
                    token_standard: TokenStandard::V2.to_string(),
                    is_fungible_v2: token_data.is_fungible_v2,
                    last_transaction_version: token_data.transaction_version,
                    last_transaction_timestamp: token_data.transaction_timestamp,
                    non_transferrable_by_owner: Some(is_soulbound),
                }),
            )))
        } else {
            Ok(Some((ownership, current_ownership, None, None)))
        }
    }
```

**File:** ecosystem/indexer-grpc/indexer-test-transactions/src/json_transactions/imported_mainnet_txns/550582915_multiple_transfer_event.json (L1-100)
```json
{
  "timestamp": {
    "seconds": "1713006073",
    "nanos": 392195000
  },
  "version": "550582915",
  "info": {
    "hash": "Y8sSsdDoUhRI06rYDJc4mNp+hqb3/H66esTx/OVDS/k=",
    "stateChangeHash": "Q7/yfYbUuVFO6R25D+TNJD/rL8+gjvOWyL4SJIZtpw4=",
    "eventRootHash": "Xuty3xKBPiRePBoPVU/13PR7BQOprs/h5ncJhL5tWzs=",
    "gasUsed": "1129",
    "success": true,
    "vmStatus": "Executed successfully",
    "accumulatorRootHash": "vYYQPG75A76TDBC2rc7gN1PaV5CI2e6xyGbhjB039WI=",
    "changes": [
      {
        "type": "TYPE_WRITE_RESOURCE",
        "writeResource": {
          "address": "0xa29064debdf40962abec633e081e173978994005b263bfd1b077052f693f5dd",
          "stateKeyHash": "/9ZAn6dPJmyhtLndaQfHEWU2VzDQd4q76rc2HFpUzxU=",
          "type": {
            "address": "0x1",
            "module": "object",
            "name": "ObjectCore"
          },
          "typeStr": "0x1::object::ObjectCore",
          "data": "{\"allow_ungated_transfer\":true,\"guid_creation_num\":\"1125899906842626\",\"owner\":\"0x494690aa79cb6a257f55969e2a91f63c03d2dd98501b7498389bdfad6cefa5b2\",\"transfer_events\":{\"counter\":\"1\",\"guid\":{\"id\":{\"addr\":\"0xa29064debdf40962abec633e081e173978994005b263bfd1b077052f693f5dd\",\"creation_num\":\"1125899906842624\"}}}}"
        }
      },
      {
        "type": "TYPE_WRITE_RESOURCE",
        "writeResource": {
          "address": "0xa29064debdf40962abec633e081e173978994005b263bfd1b077052f693f5dd",
          "stateKeyHash": "/9ZAn6dPJmyhtLndaQfHEWU2VzDQd4q76rc2HFpUzxU=",
          "type": {
            "address": "0x4",
            "module": "aptos_token",
            "name": "AptosToken"
          },
          "typeStr": "0x4::aptos_token::AptosToken",
          "data": "{\"burn_ref\":{\"vec\":[{\"inner\":{\"vec\":[{\"self\":\"0xa29064debdf40962abec633e081e173978994005b263bfd1b077052f693f5dd\"}]},\"self\":{\"vec\":[]}}]},\"mutator_ref\":{\"vec\":[{\"self\":\"0xa29064debdf40962abec633e081e173978994005b263bfd1b077052f693f5dd\"}]},\"property_mutator_ref\":{\"self\":\"0xa29064debdf40962abec633e081e173978994005b263bfd1b077052f693f5dd\"},\"transfer_ref\":{\"vec\":[{\"self\":\"0xa29064debdf40962abec633e081e173978994005b263bfd1b077052f693f5dd\"}]}}"
        }
      },
      {
        "type": "TYPE_WRITE_RESOURCE",
        "writeResource": {
          "address": "0xa29064debdf40962abec633e081e173978994005b263bfd1b077052f693f5dd",
          "stateKeyHash": "/9ZAn6dPJmyhtLndaQfHEWU2VzDQd4q76rc2HFpUzxU=",
          "type": {
            "address": "0x4",
            "module": "property_map",
            "name": "PropertyMap"
          },
          "typeStr": "0x4::property_map::PropertyMap",
          "data": "{\"inner\":{\"data\":[]}}"
        }
      },
      {
        "type": "TYPE_WRITE_RESOURCE",
        "writeResource": {
          "address": "0xa29064debdf40962abec633e081e173978994005b263bfd1b077052f693f5dd",
          "stateKeyHash": "/9ZAn6dPJmyhtLndaQfHEWU2VzDQd4q76rc2HFpUzxU=",
          "type": {
            "address": "0x4",
            "module": "token",
            "name": "Token"
          },
          "typeStr": "0x4::token::Token",
          "data": "{\"collection\":{\"inner\":\"0x39b61bdc5088c71bc496103af399ff79be45b9974cfd234a69beb726dd720df3\"},\"description\":\"A Commemorative NFT: Wapal X Aptos Galxe Campaign.\",\"index\":\"603559\",\"mutation_events\":{\"counter\":\"0\",\"guid\":{\"id\":{\"addr\":\"0xa29064debdf40962abec633e081e173978994005b263bfd1b077052f693f5dd\",\"creation_num\":\"1125899906842625\"}}},\"name\":\"Make Every Müåêve Count. #603558\",\"uri\":\"https://arweave.net/M0qCJ4i07oQli5hoq1MRBkvvwz6dGBTt4r6Wp3RhuLI/\"}"
        }
      },
      {
        "type": "TYPE_WRITE_RESOURCE",
        "writeResource": {
          "address": "0x305d730682a5311fbfc729a51b8eec73924b40849bff25cf9fdb4348cc0a719a",
          "stateKeyHash": "HekGdoecZZ3+664GjaiK35n+1tiUAhuRe3/FwefIgfw=",
          "type": {
            "address": "0x1",
            "module": "coin",
            "name": "CoinStore",
            "genericTypeParams": [
              {
                "type": "MOVE_TYPES_STRUCT",
                "struct": {
                  "address": "0x1",
                  "module": "aptos_coin",
                  "name": "AptosCoin"
                }
              }
            ]
          },
          "typeStr": "0x1::coin::CoinStore<0x1::aptos_coin::AptosCoin>",
          "data": "{\"coin\":{\"value\":\"41047895432\"},\"deposit_events\":{\"counter\":\"961313\",\"guid\":{\"id\":{\"addr\":\"0x305d730682a5311fbfc729a51b8eec73924b40849bff25cf9fdb4348cc0a719a\",\"creation_num\":\"2\"}}},\"frozen\":false,\"withdraw_events\":{\"counter\":\"13\",\"guid\":{\"id\":{\"addr\":\"0x305d730682a5311fbfc729a51b8eec73924b40849bff25cf9fdb4348cc0a719a\",\"creation_num\":\"3\"}}}}"
        }
      },
      {
        "type": "TYPE_WRITE_RESOURCE",
        "writeResource": {
          "address": "0x39b61bdc5088c71bc496103af399ff79be45b9974cfd234a69beb726dd720df3",
          "stateKeyHash": "T9IPmgM4xvwF4DG6KTVwnE1nysscfay1e2vVlfq2qFI=",
```
