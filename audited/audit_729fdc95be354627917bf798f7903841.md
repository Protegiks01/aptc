# Audit Report

## Title
Randomness Share Attribution Error: Network Sender Not Validated Against Claimed Author in Proactive Path

## Summary
In the consensus randomness generation system, the proactive (push-based) share distribution path fails to validate that the network sender matches the share's claimed author field. This creates attribution errors in security audit logs, where shares are incorrectly attributed to the claimed author rather than the actual network peer who transmitted them.

## Finding Description

The `LogSchema` struct defines both `author` and `remote_peer` fields as `Option<Author>`: [1](#0-0) 

During randomness share processing, there are two distinct paths:

**1. Reactive Path (Pull-based via ReliableBroadcast):**
The reactive path correctly validates that the share's claimed author matches the network peer: [2](#0-1) 

**2. Proactive Path (Push-based via RandMessage::Share):**
However, the proactive path has a critical gap. During verification, the network sender is available but not used to validate shares: [3](#0-2) 

The `RandMessage::Share` verification only calls `share.verify(rand_config)` without passing the `sender` parameter. Compare this to `AugData` verification which correctly passes the sender: [4](#0-3) 

After verification, the network sender information is discarded when creating the `RpcRequest`: [5](#0-4) 

Note that the `RpcRequest` struct does not include a sender field: [6](#0-5) 

When processing the share, the logging uses the share's claimed author as `remote_peer`: [7](#0-6) 

**Attack Scenario:**
1. Validator A creates and sends a valid share with `author: A`
2. Malicious Validator B intercepts or receives this share
3. Validator B re-broadcasts the share to Validator C
4. Validator C's logs show: `LogEvent::ReceiveProactiveRandShare` with `remote_peer: A`
5. But the actual network sender was Validator B, not A

This violates the security invariant that **audit logs must accurately reflect network peer behavior** for forensic analysis and validator accountability.

## Impact Explanation

This qualifies as **Medium Severity** per the Aptos bug bounty criteria under "State inconsistencies requiring intervention":

While the cryptographic validity of shares is preserved (preventing consensus safety violations), the attribution inconsistency creates:

1. **Forensic Audit Failures**: Security teams investigating malicious behavior cannot trust log attribution
2. **Validator Accountability Gaps**: Impossible to determine which validator actually transmitted specific messages
3. **Relay Attack Masking**: Malicious validators can hide their forwarding/relay behavior
4. **False Attribution**: Honest validators may be falsely implicated in suspicious network patterns

This is not Critical (no consensus safety break, no funds at risk) but exceeds Low severity because it undermines the audit trail required for validator accountability and security monitoring.

## Likelihood Explanation

**Likelihood: High**

This occurs in normal operation whenever:
- A validator receives shares and forwards them to others (standard gossip behavior)
- Any validator acts as a relay for randomness shares
- Network topology causes shares to be transmitted via intermediate nodes

No special attack setup is required - the attribution error occurs naturally in the current implementation. Any validator running the current consensus code will experience this issue.

## Recommendation

Add sender validation to the proactive share path, consistent with the reactive path:

1. **Modify `RpcRequest` to include sender:**
```rust
pub struct RpcRequest<S, D> {
    pub req: RandMessage<S, D>,
    pub protocol: ProtocolId,
    pub response_sender: oneshot::Sender<Result<Bytes, RpcError>>,
    pub sender: Author,  // ADD THIS FIELD
}
```

2. **Update `RandMessage::verify` to validate sender for shares:**
```rust
pub fn verify(
    &self,
    epoch_state: &EpochState,
    rand_config: &RandConfig,
    fast_rand_config: &Option<RandConfig>,
    sender: Author,
) -> anyhow::Result<()> {
    ensure!(self.epoch() == epoch_state.epoch);
    match self {
        RandMessage::RequestShare(_) => Ok(()),
        RandMessage::Share(share) => {
            ensure!(share.author() == &sender, "Share author does not match sender");
            share.verify(rand_config)
        },
        // ... rest unchanged
    }
}
```

3. **Update logging to use actual sender:**
```rust
RandMessage::Share(share) => {
    trace!(LogSchema::new(LogEvent::ReceiveProactiveRandShare)
        .author(self.author)
        .epoch(share.epoch())
        .round(share.metadata().round)
        .remote_peer(request.sender));  // Use actual sender, not claimed author
    // ...
}
```

## Proof of Concept

```rust
// Test demonstrating attribution error
#[tokio::test]
async fn test_share_attribution_error() {
    // Setup: 3 validators A, B, C
    let (validator_a, validator_b, validator_c) = setup_test_validators();
    
    // Step 1: Validator A creates valid share
    let share_from_a = create_valid_share(validator_a.author());
    
    // Step 2: Validator B receives and re-broadcasts A's share
    let network_msg = RandMessage::Share(share_from_a.clone());
    
    // Step 3: C receives from B but logs show A as remote_peer
    // Expected: remote_peer should be B (actual sender)
    // Actual: remote_peer is A (claimed author from share)
    
    let logs = validator_c.process_share(
        network_msg, 
        sender: validator_b.author()  // B is actual sender
    ).await;
    
    // BUG: Log shows remote_peer = A instead of B
    assert_eq!(logs.remote_peer, validator_b.author()); // FAILS
    assert_eq!(logs.remote_peer, share_from_a.author()); // Currently true (BUG)
}
```

## Notes

This vulnerability demonstrates a critical inconsistency between the reactive and proactive randomness share distribution paths. The reactive path (via `ShareAggregateState`) correctly validates `share.author() == &peer`, while the proactive path does not. This inconsistency suggests the validation was intentionally added to the reactive path to address a known concern but was not applied uniformly across all code paths.

The `Author` type being used for both `author` (local node) and `remote_peer` (network sender) fields with identical type signatures makes this confusion easier to introduce during development, as suggested by the security question.

### Citations

**File:** consensus/src/logging.rs (L10-18)
```rust
#[derive(Schema)]
pub struct LogSchema {
    event: LogEvent,
    author: Option<Author>,
    remote_peer: Option<Author>,
    epoch: Option<u64>,
    round: Option<Round>,
    id: Option<HashValue>,
}
```

**File:** consensus/src/rand/rand_gen/reliable_broadcast_state.rs (L131-143)
```rust
    fn add(&self, peer: Author, share: Self::Response) -> anyhow::Result<Option<()>> {
        ensure!(share.author() == &peer, "Author does not match");
        ensure!(
            share.metadata() == &self.rand_metadata,
            "Metadata does not match: local {:?}, received {:?}",
            self.rand_metadata,
            share.metadata()
        );
        share.verify(&self.rand_config)?;
        info!(LogSchema::new(LogEvent::ReceiveReactiveRandShare)
            .epoch(share.epoch())
            .round(share.metadata().round)
            .remote_peer(*share.author()));
```

**File:** consensus/src/rand/rand_gen/network_messages.rs (L36-46)
```rust
    pub fn verify(
        &self,
        epoch_state: &EpochState,
        rand_config: &RandConfig,
        fast_rand_config: &Option<RandConfig>,
        sender: Author,
    ) -> anyhow::Result<()> {
        ensure!(self.epoch() == epoch_state.epoch);
        match self {
            RandMessage::RequestShare(_) => Ok(()),
            RandMessage::Share(share) => share.verify(rand_config),
```

**File:** consensus/src/rand/rand_gen/network_messages.rs (L124-128)
```rust
pub struct RpcRequest<S, D> {
    pub req: RandMessage<S, D>,
    pub protocol: ProtocolId,
    pub response_sender: oneshot::Sender<Result<Bytes, RpcError>>,
}
```

**File:** consensus/src/rand/rand_gen/types.rs (L487-497)
```rust
    pub fn verify(
        &self,
        rand_config: &RandConfig,
        fast_rand_config: &Option<RandConfig>,
        sender: Author,
    ) -> anyhow::Result<()> {
        ensure!(self.author == sender, "Invalid author");
        self.data
            .verify(rand_config, fast_rand_config, &self.author)?;
        Ok(())
    }
```

**File:** consensus/src/rand/rand_gen/rand_manager.rs (L221-261)
```rust
    async fn verification_task(
        epoch_state: Arc<EpochState>,
        mut incoming_rpc_request: aptos_channel::Receiver<Author, IncomingRandGenRequest>,
        verified_msg_tx: UnboundedSender<RpcRequest<S, D>>,
        rand_config: RandConfig,
        fast_rand_config: Option<RandConfig>,
        bounded_executor: BoundedExecutor,
    ) {
        while let Some(rand_gen_msg) = incoming_rpc_request.next().await {
            let tx = verified_msg_tx.clone();
            let epoch_state_clone = epoch_state.clone();
            let config_clone = rand_config.clone();
            let fast_config_clone = fast_rand_config.clone();
            bounded_executor
                .spawn(async move {
                    match bcs::from_bytes::<RandMessage<S, D>>(rand_gen_msg.req.data()) {
                        Ok(msg) => {
                            if msg
                                .verify(
                                    &epoch_state_clone,
                                    &config_clone,
                                    &fast_config_clone,
                                    rand_gen_msg.sender,
                                )
                                .is_ok()
                            {
                                let _ = tx.unbounded_send(RpcRequest {
                                    req: msg,
                                    protocol: rand_gen_msg.protocol,
                                    response_sender: rand_gen_msg.response_sender,
                                });
                            }
                        },
                        Err(e) => {
                            warn!("Invalid rand gen message: {}", e);
                        },
                    }
                })
                .await;
        }
    }
```

**File:** consensus/src/rand/rand_gen/rand_manager.rs (L414-423)
```rust
                        RandMessage::Share(share) => {
                            trace!(LogSchema::new(LogEvent::ReceiveProactiveRandShare)
                                .author(self.author)
                                .epoch(share.epoch())
                                .round(share.metadata().round)
                                .remote_peer(*share.author()));

                            if let Err(e) = self.rand_store.lock().add_share(share, PathType::Slow) {
                                warn!("[RandManager] Failed to add share: {}", e);
                            }
```
