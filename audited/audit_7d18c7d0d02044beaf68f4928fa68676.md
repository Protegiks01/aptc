# Audit Report

## Title
Non-Deterministic Governance Proposal Generation Due to Build-Time Environment Dependencies

## Summary
The gas schedule updator tool generates governance proposals with machine-specific absolute paths embedded in the Move.toml file, making proposals non-reproducible across different machines and preventing independent verification by governance participants.

## Finding Description

The `aptos-gas-schedule-updator` tool is designed to generate governance proposals for updating the on-chain gas schedule. However, it contains a critical reproducibility flaw that breaks **Governance Integrity** guarantees.

The root cause lies in the `aptos_framework_path()` function [1](#0-0)  which uses the compile-time environment variable `env!("CARGO_MANIFEST_DIR")` to construct an absolute path to the AptosFramework dependency.

When the tool generates a proposal package, it calls `add_local_dep()` with this absolute path [2](#0-1) , which the `PackageBuilder` then embeds into the Move.toml file [3](#0-2) .

This creates two critical problems:

1. **Non-Reproducibility**: When two users build the tool from source in different directories (e.g., `/home/alice/aptos-core` vs `/opt/bob/aptos-core`) and run it with identical arguments, they generate different Move.toml files containing different absolute paths. This means the same input produces different proposal packages.

2. **Compilation Failure on Other Machines**: When a governance participant receives a proposal package generated on another machine, they cannot compile it to verify the bytecode because the hardcoded absolute path (e.g., `/home/alice/aptos-core/aptos-move/framework/aptos-framework`) does not exist on their system.

The governance workflow expects participants to independently verify proposals before voting [4](#0-3) . This vulnerability completely breaks that verification capability, as validators cannot compile and inspect the proposal to confirm what they're voting on.

## Impact Explanation

This vulnerability is classified as **Medium Severity** because it creates state inconsistencies in the governance process that require intervention:

- **Governance Integrity Violation**: The fundamental principle that governance participants can independently verify proposals is broken. Voters cannot reproduce or compile proposals generated by others, forcing them to trust the proposer's claims without verification.

- **Voter Confusion**: Different machines produce different proposal artifacts for the same inputs, making it impossible to establish a canonical "correct" proposal. This could lead to vote splitting, where different validators compile different versions thinking they're voting on the same proposal.

- **Trust Erosion**: The inability to independently verify proposals undermines the trustless nature of on-chain governance, potentially causing legitimate proposals to be rejected due to lack of confidence.

While this does not directly cause loss of funds or consensus violations, it falls under "State inconsistencies requiring intervention" per the Medium severity category, as the governance system cannot function properly without manual coordination outside the protocol.

## Likelihood Explanation

This issue occurs with **HIGH likelihood**:

- **Automatic Manifestation**: Every time the tool is built from source in different locations (which is standard practice), it will produce non-reproducible outputs. No attacker action is required.

- **Common Scenario**: Core developers, validators, and governance participants typically build tools from their own cloned repositories in different filesystem locations. This is the normal workflow, not an edge case.

- **Affects All Proposals**: Any gas schedule update proposal generated with this tool will have this issue. Given that gas schedule updates are critical governance actions that happen regularly, this affects a significant portion of governance activity.

- **No Workaround**: Users cannot easily work around this issue without modifying the source code, as the path is baked in at compile time.

## Recommendation

Replace the compile-time absolute path with a relative path or make the framework dependency path configurable at runtime:

**Option 1: Use Relative Paths**
```rust
fn aptos_framework_path() -> PathBuf {
    // Use a relative path that works from the generated proposal directory
    PathBuf::from("../../framework/aptos-framework")
}
```

**Option 2: Make Path Configurable (Recommended)**
```rust
#[derive(Debug, Parser)]
pub struct GenArgs {
    #[clap(short, long)]
    pub output: Option<String>,

    #[clap(short, long)]
    pub gas_feature_version: Option<u64>,
    
    // Add configurable framework path
    #[clap(long, default_value = "../framework/aptos-framework")]
    pub framework_path: String,
}

pub fn generate_update_proposal(args: &GenArgs) -> Result<()> {
    let mut pack = PackageBuilder::new("GasScheduleUpdate");
    
    let feature_version = args
        .gas_feature_version
        .unwrap_or(LATEST_GAS_FEATURE_VERSION);
    
    pack.add_source(
        "update_gas_schedule.move",
        &generate_script(&current_gas_schedule(feature_version))?,
    );
    
    // Use runtime-provided path instead of compile-time path
    pack.add_local_dep("AptosFramework", &args.framework_path);
    
    pack.write_to_disk(args.output.as_deref().unwrap_or("./proposal"))?;
    
    Ok(())
}
```

**Option 3: Use Git Dependencies**
As a more robust solution, use git dependencies that reference a specific commit hash:
```rust
// In PackageBuilder, add support for git dependencies
pub fn add_git_dep(&mut self, name: &str, git_url: &str, rev: &str) {
    self.git_deps.push((name.to_string(), git_url.to_string(), rev.to_string()))
}

// In Move.toml generation
git_deps.into_iter()
    .map(|(name, url, rev)| format!("{} = {{ git = \"{}\", rev = \"{}\" }}", name, url, rev))
    .join("\n")
```

## Proof of Concept

**Reproduction Steps:**

1. **On Machine A** (e.g., path `/home/alice/aptos-core`):
```bash
cd /home/alice/aptos-core/aptos-move/aptos-gas-schedule-updator
cargo build --release
./target/release/aptos-gas-schedule-updator --output /tmp/proposal_a
cat /tmp/proposal_a/Move.toml
```

Expected Move.toml on Machine A:
```toml
[dependencies]
AptosFramework = { local = "/home/alice/aptos-core/aptos-move/framework/aptos-framework" }
```

2. **On Machine B** (e.g., path `/opt/bob/aptos-core`):
```bash
cd /opt/bob/aptos-core/aptos-move/aptos-gas-schedule-updator
cargo build --release
./target/release/aptos-gas-schedule-updator --output /tmp/proposal_b
cat /tmp/proposal_b/Move.toml
```

Expected Move.toml on Machine B:
```toml
[dependencies]
AptosFramework = { local = "/opt/bob/aptos-core/aptos-move/framework/aptos-framework" }
```

3. **Verify Non-Reproducibility:**
```bash
diff /tmp/proposal_a/Move.toml /tmp/proposal_b/Move.toml
# Shows different paths despite identical tool arguments
```

4. **Verify Compilation Failure on Machine C:**
```bash
# Copy proposal_a to Machine C
scp -r /tmp/proposal_a machine_c:/tmp/

# On Machine C, attempt to compile
cd /tmp/proposal_a
aptos move compile
# FAILS: dependency path /home/alice/aptos-core/... does not exist
```

This demonstrates that:
- Same inputs produce different outputs (non-reproducibility)
- Proposals cannot be compiled on other machines (verification failure)
- Governance participants cannot independently verify what they're voting on

### Citations

**File:** aptos-move/aptos-gas-schedule-updator/src/lib.rs (L98-103)
```rust
fn aptos_framework_path() -> PathBuf {
    Path::join(
        Path::new(env!("CARGO_MANIFEST_DIR")),
        "../framework/aptos-framework",
    )
}
```

**File:** aptos-move/aptos-gas-schedule-updator/src/lib.rs (L136-136)
```rust
    pack.add_local_dep("AptosFramework", &aptos_framework_path().to_string_lossy());
```

**File:** aptos-move/package-builder/src/lib.rs (L71-74)
```rust
                self.deps
                    .into_iter()
                    .map(|(name, dep_path)| format!("{} = {{ local = \"{}\" }}", name, dep_path))
                    .join("\n")
```

**File:** crates/aptos/src/governance/mod.rs (L326-339)
```rust
    pub async fn compile_proposals(&self) -> CliTypedResult<(HashValue, HashValue)> {
        let (_bytecode, script_hash) = self
            .compile_proposal_args
            .compile("SubmitProposal", self.txn_options.prompt_options)?;

        // Validate the proposal metadata
        let (metadata, metadata_hash) = self.get_metadata().await?;

        println!(
            "{}\n\tMetadata Hash: {}\n\tScript Hash: {}",
            metadata, metadata_hash, script_hash
        );
        Ok((script_hash, metadata_hash))
    }
```
