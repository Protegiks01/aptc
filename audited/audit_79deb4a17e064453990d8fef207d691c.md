# Audit Report

## Title
Control Character Injection in Legacy Move Package Manifest Parser Bypasses Validation

## Summary
The Move package system contains two different `PackageName` implementations with inconsistent validation. While the newer `move-package-manifest` parser properly rejects control characters through `is_valid_package_name()`, the legacy `move-package` parser accepts arbitrary strings including ASCII control characters (0x00-0x1F, 0x7F) without validation, enabling log injection and file system manipulation attacks.

## Finding Description
The codebase contains two implementations of package name handling:

1. **Validated Implementation** in `move-package-manifest`: [1](#0-0) 

The `is_valid_package_name()` function properly restricts package names to ASCII alphanumeric characters, hyphens, and underscores, which implicitly rejects all control characters since `is_ascii_alphabetic()` and `is_ascii_alphanumeric()` only match `a-z`, `A-Z`, and `0-9`.

2. **Unvalidated Implementation** in `move-package`: [2](#0-1) 

This defines `PackageName` as a simple type alias to `Symbol` with no validation.

The legacy manifest parser uses the unvalidated version: [3](#0-2) 

This parser is actively used in production dependency resolution: [4](#0-3) 

**Attack Vector:**
An attacker creates a malicious Move.toml file:
```toml
[package]
name = "malicious\nFAKE_LOG_ENTRY"
version = "1.0.0"
```

When processed, the package name with embedded newlines is used in:
- **Logging operations**: [5](#0-4) 
- **Error messages**: [6](#0-5) 
- **File path operations**: [7](#0-6) 

## Impact Explanation
**Medium Severity** - This vulnerability enables:

1. **Log Injection**: Newlines and carriage returns in package names inject fake log entries, potentially hiding malicious activity or confusing monitoring systems
2. **Terminal Manipulation**: Control characters (especially ANSI escape sequences with CR/LF) can manipulate terminal display when build output is shown
3. **File System Inconsistencies**: Control characters in filenames cause failures on Windows (which rejects them) while succeeding on Unix-like systems, potentially causing non-deterministic build behavior across platforms

While this doesn't directly compromise consensus or funds, it affects the **integrity of the development and build pipeline**, which is critical for supply chain security of Move packages. Malicious dependencies with injected control characters could mask their true behavior in logs and error messages.

## Likelihood Explanation
**High Likelihood** - The attack is feasible through:
- Git dependencies (attacker publishes malicious package)
- Local dependencies (if attacker compromises a developer's machine)
- Any untrusted Move.toml processed by the build system

The legacy parser is the primary parser used in production code paths, making exploitation straightforward for any package with malicious dependencies.

## Recommendation
Apply the same validation from `is_valid_package_name()` to the legacy parser:

```rust
// In manifest_parser.rs, after line 126:
let name = name
    .as_str()
    .ok_or_else(|| format_err!("Package name must be a string"))?;

// Add validation before creating Symbol:
if !is_valid_package_name(name) {
    bail!("Invalid package name '{}' - must start with letter or _, contain only alphanumeric/hyphen/underscore", name);
}

let name = PM::PackageName::from(name);
```

Where `is_valid_package_name` enforces the same rules as the validated implementation.

## Proof of Concept
Create a malicious `Move.toml`:
```toml
[package]
name = "test\nFAKE: [INFO] Build succeeded"
version = "1.0.0"

[addresses]
std = "_"
```

When this manifest is parsed and built:
1. The package name will contain an embedded newline
2. Build logs will show: `BUILDING test` followed by a fake log line
3. On Windows, file creation will fail with invalid filename errors
4. On Unix, a directory with a newline in its name will be created

**Test command:**
```bash
# Create malicious package
echo -e '[package]\nname = "evil\\nFAKE_LOG"\nversion = "1.0.0"' > Move.toml
mkdir sources
# Try to build - observe log injection in output
aptos move compile
```

## Notes
The vulnerability exists specifically in the **legacy manifest parser** used for dependency resolution. The newer `move-package-manifest` crate has proper validation but is not yet fully adopted across the codebase. This creates an inconsistent security boundary where some code paths are protected while others remain vulnerable to control character injection.

### Citations

**File:** third_party/move/tools/move-package-manifest/src/package_name.rs (L58-67)
```rust
fn is_valid_package_name(s: &str) -> bool {
    let mut chars = s.chars();

    match chars.next() {
        Some(c) if c.is_ascii_alphabetic() || c == '_' => (),
        _ => return false,
    }

    chars.all(|c| c.is_ascii_alphanumeric() || c == '-' || c == '_')
}
```

**File:** third_party/move/tools/move-package/src/source_package/parsed_manifest.rs (L10-10)
```rust
pub type PackageName = Symbol;
```

**File:** third_party/move/tools/move-package/src/source_package/manifest_parser.rs (L124-127)
```rust
            let name = name
                .as_str()
                .ok_or_else(|| format_err!("Package name must be a string"))?;
            let name = PM::PackageName::from(name);
```

**File:** third_party/move/tools/move-package/src/resolution/resolution_graph.rs (L449-454)
```rust
        if dep_name_in_pkg != dep_package.package.name {
            bail!("Name of dependency declared in package '{}' does not match dependency's package name '{}'",
                dep_name_in_pkg,
                dep_package.package.name
            );
        }
```

**File:** third_party/move/tools/move-package/src/resolution/resolution_graph.rs (L499-517)
```rust
    fn parse_package_manifest(
        dep: &Dependency,
        dep_name: &PackageName,
        mut root_path: PathBuf,
    ) -> Result<(SourceManifest, PathBuf)> {
        root_path.push(&dep.local);
        match fs::read_to_string(root_path.join(SourcePackageLayout::Manifest.path())) {
            Ok(contents) => {
                let source_package: SourceManifest =
                    parse_move_manifest_string(contents).and_then(parse_source_manifest)?;
                Ok((source_package, root_path))
            },
            Err(_) => Err(anyhow::format_err!(
                "Unable to find package manifest for '{}' at {:?}",
                dep_name,
                SourcePackageLayout::Manifest.path().join(root_path),
            )),
        }
    }
```

**File:** third_party/move/tools/move-package/src/compilation/compiled_package.rs (L307-310)
```rust
            self.root_path
                .join(CompiledPackageLayout::Dependencies.path())
                .join(package_name.as_str())
        };
```

**File:** third_party/move/tools/move-package/src/compilation/compiled_package.rs (L574-575)
```rust
        let root_package_name = resolved_package.source_package.package.name;
        writeln!(w, "{} {}", "BUILDING".bold().green(), root_package_name)?;
```
