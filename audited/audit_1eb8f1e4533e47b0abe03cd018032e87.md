# Audit Report

## Title
Module Encapsulation Violation via `std::cmp::compare` Native Function Bypassing Field Visibility

## Summary
The `std::cmp::compare<T>` native function violates Move's field visibility guarantees by directly reading private struct fields from outside their defining module. While this does not violate resource safety properties (no implicit copying or dropping occurs), it breaks Move's encapsulation model, potentially leaking sensitive information from private fields.

## Finding Description

The Move language guarantees that **struct fields can only be accessed within the module that defines the struct**. However, the `std::cmp::compare<T>` function, defined as a public native function with no ability constraints, bypasses this guarantee. [1](#0-0) 

The native implementation directly reads all struct fields recursively to perform lexicographic comparison: [2](#0-1) 

This implementation borrows the struct container and iterates through **all fields** without checking whether the caller has visibility rights to those fields. The bytecode verifier only checks ability constraints for type parameters, not field visibility: [3](#0-2) 

### Attack Scenario

```move
// Module A defines a resource with private fields
module 0x1::vault {
    struct SecretVault has key {
        private_balance: u64,  // Private field
        secret_key: u256,      // Private field
    }
    
    public fun borrow_vault(addr: address): &SecretVault acquires SecretVault {
        borrow_global<SecretVault>(addr)
    }
}

// Module B (attacker) can observe private fields
module 0x2::attacker {
    use 0x1::vault;
    use std::cmp;
    
    public fun leak_info(addr1: address, addr2: address) {
        let vault1 = vault::borrow_vault(addr1);
        let vault2 = vault::borrow_vault(addr2);
        
        // Compare reads private_balance and secret_key fields!
        let ordering = cmp::compare(vault1, vault2);
        // Attacker now knows the relative ordering of private fields
    }
}
```

## Impact Explanation

**Severity Assessment: Medium to Low**

This issue does **NOT** violate resource safety in the strict sense:
- No implicit copying occurs (values accessed by reference only)
- No implicit dropping occurs (references don't consume values)  
- Reading via references is explicitly allowed in Move's semantics

However, it **DOES** violate Move's encapsulation model:
- Breaks the documented guarantee that fields are only accessible within their defining module
- Enables information disclosure about private field contents
- Could allow attackers to learn sensitive values through binary search comparisons

**Realistic Impact:**
- Information disclosure: Attackers can determine relative ordering of private fields
- Limited to comparison operations (not direct value extraction)
- Most sensitive data (keys, secrets) shouldn't be stored on-chain regardless
- Primarily affects modules that rely on field privacy for security assumptions

This does not meet **Critical** severity (no fund loss, no consensus violation, no network partition). It marginally qualifies for **Medium** severity as "limited information leak" but the practical exploitability is limited.

## Likelihood Explanation

**Likelihood: Medium**

The attack requires:
1. A module with resources containing private fields ✓ (common)
2. Public functions that return references to those resources ✓ (common pattern)
3. Private fields containing sensitive information ✗ (uncommon for on-chain data)
4. Attacker able to compare multiple instances ✓ (straightforward)

While the technical attack path is straightforward, the **practical impact is limited** because:
- Most on-chain data is not truly "secret" (blockchain is public)
- Sensitive keys should not be stored on-chain
- Comparison only reveals ordering, not exact values (though binary search is possible)
- Module authors can avoid exposing references to sensitive resources

## Recommendation

**Option 1: Add Ability Constraint (Breaking Change)**
Require type parameter `T` to have `drop` ability, similar to equality operators:

```move
native public fun compare<T: drop>(first: &T, second: &T): Ordering;
```

This prevents comparing resources with private fields unless they have `drop`.

**Option 2: Add Runtime Visibility Check (Complex)**
Modify the native implementation to check field visibility at runtime: [4](#0-3) 

Add checks in the native function to verify the caller has visibility rights before reading fields.

**Option 3: Document Current Behavior (Minimal)**
Clearly document that `compare` can observe private fields and advise module authors accordingly.

**Recommended Approach:** Option 1 (add `drop` constraint) is the cleanest solution, though it's a breaking API change. For resources without `drop`, modules should provide explicit comparison functions that respect their encapsulation.

## Proof of Concept

```move
module 0x1::secret {
    struct Secret has key {
        value: u64
    }
    
    public fun create(account: &signer, val: u64) {
        move_to(account, Secret { value: val });
    }
    
    public fun borrow_secret(addr: address): &Secret acquires Secret {
        borrow_global<Secret>(addr)
    }
}

module 0x2::exploit {
    use 0x1::secret;
    use std::cmp;
    
    // This function can determine the relative ordering of private 'value' fields
    public fun compare_secrets(addr1: address, addr2: address): u8 acquires secret::Secret {
        let s1 = secret::borrow_secret(addr1);
        let s2 = secret::borrow_secret(addr2);
        
        let result = cmp::compare(s1, s2);
        if (result.is_lt()) { 0 }
        else if (result.is_eq()) { 1 }
        else { 2 }
        // Returns ordering of private fields without direct access!
    }
}
```

## Notes

**Critical Clarification:** This issue is **NOT** a resource safety violation in the strict sense. Resource safety in Move refers to the linear type properties (no implicit copy/drop), which are preserved. The `compare` function:
- Takes references (`&T`), not owned values ✓
- Does not copy the resource ✓  
- Does not drop the resource ✓
- Reads contents via reference (allowed in Move) ✓

The issue is an **encapsulation/visibility violation**, not a resource safety violation. The security question asks specifically about resource safety, and the answer is: **No, `compare` does not violate resource safety**. However, it does violate field visibility guarantees, which is a separate (and less severe) concern.

Given Move's design allows comparison on all types (no ability constraints), this may be **intentional behavior** rather than a bug. The language designers may have accepted this tradeoff to enable universal comparison. Without clear evidence this was unintended, and given the limited practical exploitability, this falls below the threshold for a high-severity vulnerability report.

### Citations

**File:** aptos-move/framework/move-stdlib/sources/cmp.move (L17-17)
```text
    native public fun compare<T>(first: &T, second: &T): Ordering;
```

**File:** third_party/move/move-vm/types/src/values/values_impl.rs (L1125-1137)
```rust
            (Vec(l), Vec(r)) | (Struct(l), Struct(r)) => {
                let l = &l.borrow();
                let r = &r.borrow();

                for (v1, v2) in l.iter().zip(r.iter()) {
                    let value_cmp = v1.compare_with_depth(v2, depth + 1, max_depth)?;
                    if value_cmp.is_ne() {
                        return Ok(value_cmp);
                    }
                }

                l.len().cmp(&r.len())
            },
```

**File:** third_party/move/move-vm/types/src/loaded_data/runtime_types.rs (L449-453)
```rust
        for (ty, expected_ability_set) in ty_args.iter().zip(ty_param_abilities) {
            if !expected_ability_set.is_subset(ty.abilities()?) {
                return Err(PartialVMError::new(StatusCode::CONSTRAINT_NOT_SATISFIED));
            }
        }
```

**File:** aptos-move/framework/move-stdlib/src/natives/cmp.rs (L36-64)
```rust
fn native_compare(
    context: &mut SafeNativeContext,
    _ty_args: &[Type],
    args: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    debug_assert!(args.len() == 2);
    if args.len() != 2 {
        return Err(SafeNativeError::InvariantViolation(PartialVMError::new(
            StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR,
        )));
    }

    let cost = CMP_COMPARE_BASE
        + CMP_COMPARE_PER_ABS_VAL_UNIT
            * (context.abs_val_size_dereferenced(&args[0])?
                + context.abs_val_size_dereferenced(&args[1])?);
    context.charge(cost)?;

    let ordering = args[0].compare(&args[1])?;
    let ordering_move_variant = match ordering {
        std::cmp::Ordering::Less => ORDERING_LESS_THAN_VARIANT,
        std::cmp::Ordering::Equal => ORDERING_EQUAL_VARIANT,
        std::cmp::Ordering::Greater => ORDERING_GREATER_THAN_VARIANT,
    };

    Ok(smallvec![Value::struct_(Struct::pack(vec![Value::u16(
        ordering_move_variant
    )]))])
}
```
