# Audit Report

## Title
Script Complexity Metering Completely Bypassed - All Scripts Execute Without Complexity Validation

## Summary
The `check_script_complexity()` function exists but is never invoked during script execution or verification, allowing scripts with arbitrarily complex parameters and signatures to bypass complexity metering entirely. This affects all script executions in Aptos.

## Finding Description

The Move binary format includes a complexity checking mechanism to prevent resource exhaustion from overly complex bytecode structures. For modules, this is enforced via `check_module_complexity()` during publishing. [1](#0-0) 

However, scripts completely bypass this protection. The `check_script_complexity()` function exists [2](#0-1)  but is **never called** in the codebase.

During script execution, the `validate_and_execute_script()` function performs various checks but omits complexity validation entirely. [3](#0-2) 

Similarly, the bytecode verifier's `verify_script_with_config()` runs multiple verification passes but does not include complexity checking. [4](#0-3) 

**Regarding script parameters specifically**: If complexity checking were enabled, script parameters WOULD be counted because `meter_signatures()` iterates through all signatures in the signature pool, including the signature referenced by `script.parameters`. [5](#0-4)  However, since the entire complexity check is skipped, parameters (and all other script components) bypass metering.

An attacker can craft scripts with:
- Deeply nested generic type parameters
- Extremely large signature pools with complex instantiations  
- Complex struct and function handles
- All without triggering complexity limits that modules must satisfy

## Impact Explanation

**Severity: Low**

This breaks the **Resource Limits** invariant (all operations must respect computational limits) but with limited impact:

1. **Potential DoS during script processing**: Complex scripts could cause CPU/memory spikes during deserialization, verification, and loading phases
2. **Unfair resource consumption**: Scripts consume more validator resources than they should be allowed
3. **Limited by gas metering**: Runtime execution is still gas-metered, preventing unbounded execution
4. **Scripts are deprecated**: The `DeprecatedPayload` marker and comments indicate scripts are legacy functionality, reducing real-world impact

This does not qualify for higher severity because:
- No funds loss or consensus violation
- No permanent network disruption
- Scripts are deprecated functionality with limited usage
- Gas metering provides fallback protection during execution

## Likelihood Explanation

**Likelihood: Low to Medium**

- Scripts are still executable in Aptos despite being deprecated
- No special privileges required - any transaction sender can submit scripts
- The attack is straightforward: craft a complex script and submit it
- However, scripts are rarely used in practice (entry functions are preferred)
- The missing validation represents a clear implementation gap

## Recommendation

Integrate complexity checking into the script validation pipeline:

1. **In `verify_script_with_config()`**: Add complexity checking after bounds verification:

```rust
pub fn verify_script_with_config(config: &VerifierConfig, script: &CompiledScript) -> VMResult<()> {
    // ... existing checks ...
    
    // Add complexity checking with appropriate budget
    let budget = 2048 + script.code.code.len() as u64 * 20;
    move_binary_format::check_complexity::check_script_complexity(script, budget)
        .map_err(|e| e.finish(Location::Script))?;
    
    // ... continue with remaining checks ...
}
```

2. **Alternative**: If scripts are truly deprecated, consider removing script execution support entirely or gating it behind a feature flag that is disabled by default.

## Proof of Concept

```rust
// Create a script with extremely complex nested generic parameters
// that would exceed module complexity limits but passes script validation

use move_binary_format::file_format::*;

fn create_complex_script() -> CompiledScript {
    let mut script = CompiledScript::default();
    
    // Create deeply nested generic signatures (100+ levels deep)
    let mut complex_sig = Signature(vec![]);
    for _ in 0..100 {
        complex_sig.0.push(SignatureToken::Vector(Box::new(
            SignatureToken::Vector(Box::new(SignatureToken::U64))
        )));
    }
    
    script.signatures.push(complex_sig.clone());
    script.parameters = SignatureIndex(0);
    
    // Add minimal required fields to make script valid
    script.code = CodeUnit {
        locals: SignatureIndex(0),
        code: vec![Bytecode::Ret],
    };
    
    script.version = VERSION_DEFAULT;
    
    // This script would fail check_script_complexity() with a reasonable budget
    // but currently passes all verification because complexity checking is skipped
    script
}

// Verify that check_script_complexity is never called:
// $ grep -r "check_script_complexity(" --include="*.rs" aptos-core/
// Only returns the function definition, no call sites
```

## Notes

The security question asks specifically whether script parameters count toward complexity. The technical answer is: **script parameters WOULD count if complexity checking were enabled** (via the `meter_signatures()` call that processes all signatures including the parameter signature), **but complexity checking is entirely bypassed for scripts**, making the question moot in practice.

The real vulnerability is broader than just parameters - it's that **all script complexity is unmetered**, including parameters, signatures, function handles, struct handles, and code complexity.

### Citations

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L879-943)
```rust
    fn validate_and_execute_script<'a>(
        &self,
        session: &mut SessionExt<impl AptosMoveResolver>,
        serialized_signers: &SerializedSigners,
        code_storage: &impl AptosCodeStorage,
        // Note: cannot use AptosGasMeter because it is not implemented for
        //       UnmeteredGasMeter.
        gas_meter: &mut impl GasMeter,
        traversal_context: &mut TraversalContext<'a>,
        serialized_script: &'a Script,
        trace_recorder: &mut impl TraceRecorder,
    ) -> Result<(), VMStatus> {
        if !self
            .features()
            .is_enabled(FeatureFlag::ALLOW_SERIALIZED_SCRIPT_ARGS)
        {
            for arg in serialized_script.args() {
                if let TransactionArgument::Serialized(_) = arg {
                    return Err(PartialVMError::new(StatusCode::FEATURE_UNDER_GATING)
                        .finish(Location::Script)
                        .into_vm_status());
                }
            }
        }

        dispatch_loader!(code_storage, loader, {
            let legacy_loader_config = LegacyLoaderConfig {
                charge_for_dependencies: self.gas_feature_version() >= RELEASE_V1_10,
                charge_for_ty_tag_dependencies: self.gas_feature_version() >= RELEASE_V1_27,
            };
            let func = loader.load_script(
                &legacy_loader_config,
                gas_meter,
                traversal_context,
                serialized_script.code(),
                serialized_script.ty_args(),
            )?;

            // Check that unstable bytecode cannot be executed on mainnet and verify events.
            let script = func.owner_as_script()?;
            self.reject_unstable_bytecode_for_script(script)?;
            event_validation::verify_no_event_emission_in_compiled_script(script)?;

            let args = dispatch_transaction_arg_validation!(
                session,
                &loader,
                gas_meter,
                traversal_context,
                serialized_signers,
                convert_txn_args(serialized_script.args()),
                &func,
                self.features().is_enabled(FeatureFlag::STRUCT_CONSTRUCTORS),
            )?;

            session.execute_loaded_function(
                func,
                args,
                gas_meter,
                traversal_context,
                &loader,
                trace_recorder,
            )?;
            Ok(())
        })
    }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1557-1558)
```rust
            move_binary_format::check_complexity::check_module_complexity(module, budget)
                .map_err(|err| err.finish(Location::Undefined))?;
```

**File:** third_party/move/move-binary-format/src/check_complexity.rs (L104-109)
```rust
    fn meter_signatures(&self) -> PartialVMResult<()> {
        for sig_idx in 0..self.resolver.signatures().len() {
            self.meter_signature(SignatureIndex(sig_idx as u16))?;
        }
        Ok(())
    }
```

**File:** third_party/move/move-binary-format/src/check_complexity.rs (L422-438)
```rust
pub fn check_script_complexity(script: &CompiledScript, budget: u64) -> PartialVMResult<u64> {
    let meter = BinaryComplexityMeter {
        resolver: BinaryIndexedView::Script(script),
        cached_signature_costs: RefCell::new(BTreeMap::new()),
        balance: RefCell::new(budget),
    };

    meter.meter_signatures()?;
    meter.meter_function_instantiations()?;

    meter.meter_function_handles()?;
    meter.meter_struct_handles()?;
    meter.meter_code(&script.code)?;

    let used = budget - *meter.balance.borrow();
    Ok(used)
}
```

**File:** third_party/move/move-bytecode-verifier/src/verifier.rs (L189-222)
```rust
pub fn verify_script_with_config(config: &VerifierConfig, script: &CompiledScript) -> VMResult<()> {
    if config.verify_nothing() {
        return Ok(());
    }
    let prev_state = move_core_types::state::set_state(VMState::VERIFIER);
    let result = std::panic::catch_unwind(|| {
        // Always needs to run bound checker first as subsequent passes depend on it
        BoundsChecker::verify_script(script).map_err(|e| {
            // We can't point the error at the script, because if bounds-checking
            // failed, we cannot safely index into script
            e.finish(Location::Undefined)
        })?;
        FeatureVerifier::verify_script(config, script)?;
        LimitsVerifier::verify_script(config, script)?;
        DuplicationChecker::verify_script(script)?;

        signature_v2::verify_script(config, script)?;

        InstructionConsistency::verify_script(script)?;
        constants::verify_script(script)?;
        CodeUnitVerifier::verify_script(config, script)?;
        script_signature::verify_script(script, no_additional_script_signature_checks)
    })
    .unwrap_or_else(|_| {
        Err(
            PartialVMError::new(StatusCode::VERIFIER_INVARIANT_VIOLATION)
                .with_message("[VM] bytecode verifier panicked for script".to_string())
                .finish(Location::Undefined),
        )
    });
    move_core_types::state::set_state(prev_state);

    result
}
```
