# Audit Report

## Title
Sharded Block Executor Deadlock Due to Write Hints Overestimation in Cross-Shard Dependencies

## Summary
The sharded block executor contains a critical deadlock vulnerability where transaction aborts cause dependent shards to wait indefinitely for state updates that will never arrive. This occurs because cross-shard dependencies are initialized based on overestimated `write_hints`, but actual cross-shard messages are sent based on the real `write_set`, creating a mismatch when transactions fail. This causes complete loss of network liveness.

## Finding Description

The sharded block executor uses `write_hints` to establish cross-shard dependencies during the partitioning phase. These hints are explicitly documented as potentially "strictly overestimated" [1](#0-0) .

The vulnerability arises from three critical design elements:

**1. Initialization Phase:** `CrossShardStateView::create_cross_shard_state_view` extracts ALL state keys from `required_edges` (derived from write_hints) and initializes each to `RemoteValueStatus::Waiting` [2](#0-1) . The initialization specifically sets each key to waiting status [3](#0-2) .

**2. Execution Phase:** After transaction execution, `CrossShardCommitSender::send_remote_update_for_success` sends updates based on the ACTUAL `write_set` from the transaction output [4](#0-3) . Critically, it only sends messages for keys present in BOTH the actual write_set AND dependent_edges [5](#0-4) .

**3. Reception Phase:** When reading cross-shard state, `RemoteStateValue::get_value` blocks indefinitely using a condition variable with NO timeout [6](#0-5) .

**Attack Scenario:**

For `coin::transfer` transactions, write_hints always include both sender and receiver `CoinStore` resources [7](#0-6) .

1. Transaction A (Shard 0): `coin::transfer` from Alice to Bob
2. Transaction B (Shard 1): Reads Bob's CoinStore  
3. Partitioner creates dependency: B requires A's output for Bob's CoinStore
4. Transaction A executes but fails (insufficient balance)
5. The failure epilogue charges gas but only writes to the sender's account [8](#0-7) 
6. `CrossShardCommitSender` iterates the actual write_set, which excludes Bob's CoinStore
7. No message is sent for Bob's CoinStore (not in write_set)
8. Shard 1 calls `get_value()` and blocks forever on the condition variable
9. **Complete blockchain halt** - all shards freeze

This breaks the **Liveness** invariant (the system must make progress) and affects all validators deterministically.

## Impact Explanation

**Severity: Critical** (up to $1,000,000)

This vulnerability causes **total loss of liveness/network availability** as defined in the Aptos bug bounty Critical severity category:

- **All validators halt:** Every validator running the sharded executor experiences identical deterministic deadlock
- **No timeout mechanism:** The condition variable wait has no timeout, causing indefinite blocking
- **Complete block production halt:** Once any shard deadlocks, the entire block execution freezes
- **Non-recoverable without manual intervention:** Requires restarting all validator nodes
- **Consensus safety preserved but liveness lost:** No chain fork occurs, but no progress possible

The impact directly matches the Critical severity criterion: "Total loss of liveness/network availability - Network halts due to protocol bug, all validators unable to progress."

## Likelihood Explanation

**Likelihood: Medium**

**Triggers:**
- Any transaction that aborts during execution (insufficient balance, authorization failures, etc.)
- Transaction aborts occur regularly in normal blockchain operation
- Requires sharded executor to be enabled

**Requirements:**
- No privileged access needed - any user can submit transactions
- No special timing or race conditions required  
- Deterministic - same conditions always cause same deadlock
- Simple single-transaction attack

**Mitigating factors:**
- Sharded executor appears to be experimental/not fully deployed in production yet
- Limited transaction type support (only `coin::transfer`, `aptos_account::transfer`, `aptos_account::create_account`) [9](#0-8) 
- Other transaction types trigger `todo!()` panics before reaching this code

However, once the sharded executor is production-ready with full transaction support, this becomes highly likely to occur.

## Recommendation

Implement one of the following fixes:

**Option 1: Send notifications for all initialized keys**
When a transaction completes, send cross-shard messages for ALL keys in `dependent_edges`, not just those in the actual write_set. Include a flag indicating whether the key was actually written.

**Option 2: Add timeout mechanism**
Modify `RemoteStateValue::get_value` to use `wait_timeout` instead of `wait`, and implement retry/fallback logic when timeouts occur.

**Option 3: Eagerly validate write_hints accuracy**
Before partitioning, perform lightweight pre-execution to determine actual write sets, eliminating the mismatch between hints and reality.

**Option 4: Pessimistic initialization**
Only initialize `RemoteStateValue::Waiting` for keys that will definitely be written, requiring more sophisticated static analysis of transaction behavior.

The recommended approach is **Option 1** combined with **Option 2** as defense-in-depth, ensuring both correct protocol behavior and graceful degradation on errors.

## Proof of Concept

While a complete end-to-end PoC requires setting up the sharded executor environment, the vulnerability can be demonstrated through the following logic:

```rust
// 1. Create coin::transfer transaction with insufficient balance
// 2. Partition into shards with cross-shard dependency on receiver's CoinStore  
// 3. Execute transaction - it will abort
// 4. Observe that epilogue only writes to sender's account
// 5. Observe that dependent shard's RemoteStateValue remains in Waiting status
// 6. Dependent shard blocks indefinitely on get_value()
```

The vulnerability is deterministic and guaranteed to occur given the documented code paths.

## Notes

This vulnerability only affects the sharded block executor, which appears to be an experimental feature not yet fully deployed in production. The standard Block-STM parallel executor is not affected. However, the severity remains Critical because once deployed, this will cause guaranteed network halts. The `on_execution_aborted` method with `todo!()` [10](#0-9)  is not the root cause - normal transaction aborts call `on_transaction_committed`, not `on_execution_aborted`.

### Citations

**File:** types/src/transaction/analyzed_transaction.rs (L28-32)
```rust
    /// This can be accurate or strictly overestimated.
    pub read_hints: Vec<StorageLocation>,
    /// Set of storage locations that are written by the transaction. This can be accurate or strictly
    /// overestimated.
    pub write_hints: Vec<StorageLocation>,
```

**File:** types/src/transaction/analyzed_transaction.rs (L200-206)
```rust
    let mut write_hints = vec![
        account_resource_location(sender_address),
        coin_store_location(sender_address),
    ];
    if sender_address != receiver_address {
        write_hints.push(coin_store_location(receiver_address));
    }
```

**File:** types/src/transaction/analyzed_transaction.rs (L254-269)
```rust
                (AccountAddress::ONE, "coin", "transfer") => {
                    let receiver_address = bcs::from_bytes(&func.args()[0]).unwrap();
                    rw_set_for_coin_transfer(sender_address, receiver_address, true)
                },
                (AccountAddress::ONE, "aptos_account", "transfer") => {
                    let receiver_address = bcs::from_bytes(&func.args()[0]).unwrap();
                    rw_set_for_coin_transfer(sender_address, receiver_address, false)
                },
                (AccountAddress::ONE, "aptos_account", "create_account") => {
                    let receiver_address = bcs::from_bytes(&func.args()[0]).unwrap();
                    rw_set_for_create_account(sender_address, receiver_address)
                },
                _ => todo!(
                    "Only coin transfer and create account transactions are supported for now"
                ),
            }
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/cross_shard_state_view.rs (L32-34)
```rust
        for key in cross_shard_keys {
            cross_shard_data.insert(key, RemoteStateValue::waiting());
        }
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/cross_shard_state_view.rs (L58-71)
```rust
    pub fn create_cross_shard_state_view(
        base_view: &'a S,
        transactions: &[TransactionWithDependencies<AnalyzedTransaction>],
    ) -> CrossShardStateView<'a, S> {
        let mut cross_shard_state_key = HashSet::new();
        for txn in transactions {
            for (_, storage_locations) in txn.cross_shard_dependencies.required_edges_iter() {
                for storage_location in storage_locations {
                    cross_shard_state_key.insert(storage_location.clone().into_state_key());
                }
            }
        }
        CrossShardStateView::new(cross_shard_state_key, base_view)
    }
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/cross_shard_client.rs (L109-112)
```rust
        let write_set = txn_output
            .get()
            .expect("Committed output must be set")
            .write_set();
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/cross_shard_client.rs (L114-133)
```rust
        for (state_key, write_op) in write_set.expect_write_op_iter() {
            if let Some(dependent_shard_ids) = edges.get(state_key) {
                for (dependent_shard_id, round_id) in dependent_shard_ids.iter() {
                    trace!("Sending remote update for success for shard id {:?} and txn_idx: {:?}, state_key: {:?}, dependent shard id: {:?}", self.shard_id, txn_idx, state_key, dependent_shard_id);
                    let message = RemoteTxnWriteMsg(RemoteTxnWrite::new(
                        state_key.clone(),
                        Some(write_op.clone()),
                    ));
                    if *round_id == GLOBAL_ROUND_ID {
                        self.cross_shard_client.send_global_msg(message);
                    } else {
                        self.cross_shard_client.send_cross_shard_msg(
                            *dependent_shard_id,
                            *round_id,
                            message,
                        );
                    }
                }
            }
        }
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/cross_shard_client.rs (L149-151)
```rust
    fn on_execution_aborted(&self, _txn_idx: TxnIndex) {
        todo!("on_transaction_aborted not supported for sharded execution yet")
    }
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/remote_state_value.rs (L29-39)
```rust
    pub fn get_value(&self) -> Option<StateValue> {
        let (lock, cvar) = &*self.value_condition;
        let mut status = lock.lock().unwrap();
        while let RemoteValueStatus::Waiting = *status {
            status = cvar.wait(status).unwrap();
        }
        match &*status {
            RemoteValueStatus::Ready(value) => value.clone(),
            RemoteValueStatus::Waiting => unreachable!(),
        }
    }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L689-702)
```rust
    fn finish_aborted_transaction(
        &self,
        prologue_session_change_set: SystemSessionChangeSet,
        gas_meter: &mut impl AptosGasMeter,
        txn_data: &TransactionMetadata,
        resolver: &impl AptosMoveResolver,
        module_storage: &impl AptosModuleStorage,
        serialized_signers: &SerializedSigners,
        status: ExecutionStatus,
        log_context: &AdapterLogSchema,
        change_set_configs: &ChangeSetConfigs,
        traversal_context: &mut TraversalContext,
    ) -> Result<VMOutput, VMStatus> {
        // Storage refund is zero since no slots are deleted in aborted transactions.
```
