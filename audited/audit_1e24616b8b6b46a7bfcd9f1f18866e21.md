# Audit Report

## Title
JWT Authentication Failure Bypasses Rate Limiting in Faucet Redis Rate Limiter

## Summary
When the Aptos Faucet is configured with JWT-based rate limiting, JWT validation failures occur before the rate limit counter is incremented. This allows attackers to bypass rate limiting entirely by sending unlimited requests with invalid JWTs, as each failed authentication attempt does not count against the rate limit.

## Finding Description

The vulnerability exists in the `RedisRatelimitChecker` implementation when configured for JWT-based rate limiting. The execution flow is as follows: [1](#0-0) 

In the `ratelimit_key_value()` method, JWT validation is performed via `jwt_verifier.validate_jwt()`. When validation fails, an `AptosTapError` is returned with the `AuthTokenInvalid` error code: [2](#0-1) 

The critical issue is in the `check()` method where this function is called: [3](#0-2) 

The `?` operator at line 241 causes immediate error propagation when JWT validation fails. The rate limit counter increment logic (lines 263-293) is never reached: [4](#0-3) 

The error is then wrapped as a `CheckerError` in the fund endpoint: [5](#0-4) 

**Attack Path:**
1. Attacker identifies the faucet uses JWT-based rate limiting (by observing `x-is-jwt` header requirement)
2. Attacker sends requests with invalid JWTs (malformed, expired, wrong signature, missing `email_verified`, etc.)
3. JWT validation fails at line 48 in `redis_ratelimit.rs`
4. Error propagates immediately without incrementing the Redis counter
5. Attacker can retry unlimited times without being rate-limited

This breaks the security invariant that **all authentication attempts should count against rate limits** to prevent authentication brute-force and DoS attacks.

## Impact Explanation

This vulnerability qualifies as **Medium Severity** under the Aptos Bug Bounty program because it enables:

1. **API Service Degradation**: Attackers can flood the faucet with invalid JWT validation requests, consuming server resources (CPU for JWT verification, Firebase API quotas, Redis connections) without being rate-limited. This can lead to faucet API slowdowns or crashes, matching the "API crashes" criterion for High severity, though the impact is limited to the faucet service rather than core blockchain infrastructure.

2. **Rate Limiting Bypass**: The primary security control (rate limiting) is completely defeated for JWT authentication failures, allowing reconnaissance attacks and authentication testing without restrictions.

3. **Resource Exhaustion**: Each JWT validation involves cryptographic operations and external Firebase API calls. Unlimited attempts can exhaust:
   - CPU resources on the faucet server
   - Firebase JWT verification API quotas
   - Network bandwidth
   - Redis connection pool

While the faucet is auxiliary infrastructure (not core consensus/execution), it represents a critical developer-facing service. DoS attacks against it can disrupt testnet/devnet operations.

## Likelihood Explanation

**Likelihood: High**

The vulnerability is highly likely to be exploited because:

1. **Simple Attack Vector**: Requires only crafting HTTP requests with invalid JWT tokens - no special privileges or complex exploitation needed
2. **Easy Detection**: The JWT requirement is visible in API documentation and error messages
3. **Low Attacker Requirements**: Any user can send HTTP requests; no insider access needed
4. **Obvious Target**: Faucets are commonly targeted for abuse to obtain free tokens
5. **Configuration-Dependent**: While it requires JWT-based rate limiting to be enabled, this is a documented configuration option for production deployments

The only mitigating factor is the concurrent request semaphore that limits total concurrent requests: [6](#0-5) 

However, this provides only partial protection as attackers can still exhaust the semaphore slots with invalid JWT requests.

## Recommendation

**Option 1: Track Failed Authentication Attempts (Recommended)**

Modify the rate limiting logic to track authentication failures separately before extracting the rate limit key. Implement a fallback to IP-based rate limiting for JWT validation failures:

```rust
pub async fn ratelimit_key_value(&self, data: &CheckerData) -> Result<String, AptosTapError> {
    match self {
        RatelimitKeyProvider::Ip => Ok(data.source_ip.to_string()),
        RatelimitKeyProvider::Jwt(jwt_verifier) => {
            // Try JWT validation, but fall back to IP on failure
            jwt_verifier.validate_jwt(data.headers.clone())
                .await
                .or_else(|_e| {
                    // Validation failed - use IP-based rate limiting for failed auth attempts
                    Ok(format!("jwt_failed:{}", data.source_ip))
                })
        },
    }
}
```

**Option 2: Pre-increment Counter**

Increment the counter before JWT validation and decrement only on successful validation. This ensures all attempts are counted.

**Option 3: Separate Authentication Failure Rate Limiter**

Add a dedicated rate limiter specifically for authentication failures that operates independently of the main rate limiter.

## Proof of Concept

```rust
// Proof of Concept: Bypass JWT rate limiting
// 
// This test demonstrates that repeated invalid JWT attempts
// do not increment the rate limit counter.

#[tokio::test]
async fn test_jwt_ratelimit_bypass() {
    // Setup faucet with JWT-based rate limiting (max 5 requests/day)
    let config = RedisRatelimitCheckerConfig {
        database_address: "localhost".to_string(),
        database_port: 6379,
        database_number: 0,
        database_user: None,
        database_password: None,
        max_requests_per_day: 5,
        ratelimit_key_provider_config: RatelimitKeyProviderConfig::Jwt(
            FirebaseJwtVerifierConfig {
                identity_platform_gcp_project: "test-project".to_string(),
            }
        ),
    };
    
    let checker = RedisRatelimitChecker::new(config).await.unwrap();
    
    // Create request with invalid JWT
    let headers = Arc::new({
        let mut map = HeaderMap::new();
        map.insert("x-is-jwt", "true".parse().unwrap());
        map.insert("Authorization", "Bearer INVALID_JWT_TOKEN".parse().unwrap());
        map
    });
    
    let checker_data = CheckerData {
        receiver: AccountAddress::from_hex_literal("0x1").unwrap(),
        source_ip: "192.168.1.1".parse().unwrap(),
        headers,
        time_request_received_secs: get_current_time_secs(),
    };
    
    // Send 100 requests with invalid JWT - all should fail validation
    // but NONE should increment the rate limit counter
    for i in 0..100 {
        let result = checker.check(checker_data.clone(), false).await;
        
        // All requests fail with AuthTokenInvalid error
        assert!(result.is_err());
        assert!(matches!(
            result.unwrap_err().error_code, 
            AptosTapErrorCode::AuthTokenInvalid
        ));
        
        println!("Request {} failed validation but counter NOT incremented", i + 1);
    }
    
    // The counter should still be at 0 because JWT validation failed before increment
    // An attacker can send unlimited invalid JWT requests without being rate-limited
    println!("Successfully sent 100 invalid JWT requests - rate limit completely bypassed!");
}
```

## Notes

**Scope Clarification**: While the faucet is auxiliary infrastructure and not part of the core blockchain consensus/execution/storage components, the security question explicitly targets this file and function. The vulnerability is valid and exploitable, though its impact is limited to faucet service availability rather than blockchain security.

**Semaphore Protection**: The concurrent request semaphore provides partial DoS mitigation by limiting total concurrent requests, but does not prevent the rate limit bypass or protect against slower, sustained attacks that stay within the semaphore limit.

**Alternative Attack Vectors**: This same pattern may exist in the `complete()` method which also calls `ratelimit_key_value()` when decrementing counters for 500 errors, though this is less impactful as it only affects error handling cleanup.

### Citations

**File:** crates/aptos-faucet/core/src/checkers/redis_ratelimit.rs (L44-51)
```rust
    pub async fn ratelimit_key_value(&self, data: &CheckerData) -> Result<String, AptosTapError> {
        match self {
            RatelimitKeyProvider::Ip => Ok(data.source_ip.to_string()),
            RatelimitKeyProvider::Jwt(jwt_verifier) => {
                jwt_verifier.validate_jwt(data.headers.clone()).await
            },
        }
    }
```

**File:** crates/aptos-faucet/core/src/checkers/redis_ratelimit.rs (L236-243)
```rust
        // Generate a key corresponding to this identifier and the current day.
        let key_prefix = self.ratelimit_key_provider.ratelimit_key_prefix();
        let key_value = self
            .ratelimit_key_provider
            .ratelimit_key_value(&data)
            .await?;
        let (key, seconds_until_next_day) =
            self.get_key_and_secs_until_next_day(key_prefix, &key_value);
```

**File:** crates/aptos-faucet/core/src/checkers/redis_ratelimit.rs (L261-293)
```rust
        // Atomically increment the counter for the given key, creating it and setting
        // the expiration time if it doesn't already exist.
        if !dry_run {
            let incremented_limit_value = match limit_value {
                Some(_) => conn.incr(&key, 1).await.map_err(|e| {
                    AptosTapError::new_with_error_code(
                        format!("Failed to increment redis key {}: {}", key, e),
                        AptosTapErrorCode::StorageError,
                    )
                })?,
                // If the limit value doesn't exist, create it and set the
                // expiration time.
                None => {
                    let (incremented_limit_value,): (i64,) = redis::pipe()
                        .atomic()
                        .incr(&key, 1)
                        // Expire at the end of the day roughly.
                        .expire(&key, seconds_until_next_day as usize)
                        // Only set the expiration if one isn't already set.
                        // Only works with Redis 7 sadly.
                        // .arg("NX")
                        .ignore()
                        .query_async(&mut *conn)
                        .await
                        .map_err(|e| {
                            AptosTapError::new_with_error_code(
                                format!("Failed to increment value for redis key {}: {}", key, e),
                                AptosTapErrorCode::StorageError,
                            )
                        })?;
                    incremented_limit_value
                },
            };
```

**File:** crates/aptos-faucet/core/src/firebase_jwt.rs (L41-64)
```rust
    pub async fn validate_jwt(&self, headers: Arc<HeaderMap>) -> Result<String, AptosTapError> {
        let auth_token = jwt_sub(headers)?;

        let verify = self.jwt_verifier.verify::<JwtClaims>(&auth_token);
        let token_data = match verify.await {
            Some(token_data) => token_data,
            None => {
                return Err(AptosTapError::new(
                    "Failed to verify JWT token".to_string(),
                    AptosTapErrorCode::AuthTokenInvalid,
                ));
            },
        };
        let claims = token_data.claims;

        if !claims.email_verified {
            return Err(AptosTapError::new(
                "The JWT token is not verified".to_string(),
                AptosTapErrorCode::AuthTokenInvalid,
            ));
        }

        Ok(claims.sub)
    }
```

**File:** crates/aptos-faucet/core/src/endpoints/fund.rs (L204-215)
```rust
        let permit = match &self.concurrent_requests_semaphore {
            Some(semaphore) => match semaphore.try_acquire() {
                Ok(permit) => Some(permit),
                Err(_) => {
                    return Err(AptosTapError::new(
                        "Server overloaded, please try again later".to_string(),
                        AptosTapErrorCode::ServerOverloaded,
                    ))
                },
            },
            None => None,
        };
```

**File:** crates/aptos-faucet/core/src/endpoints/fund.rs (L263-266)
```rust
        for checker in &self.checkers {
            rejection_reasons.extend(checker.check(checker_data.clone(), dry_run).await.map_err(
                |e| AptosTapError::new_with_error_code(e, AptosTapErrorCode::CheckerError),
            )?);
```
