# Audit Report

## Title
Missing Event Emission for Stake State Transitions During Epoch Changes

## Summary
The `StakePool` resource in the Aptos staking system fails to emit events when stake transitions from `pending_active` to `active` and from `pending_inactive` to `inactive` during epoch boundaries. This causes off-chain systems (indexers, explorers, wallets) to have stale state until they actively poll the blockchain state.

## Finding Description
During epoch transitions, the `update_stake_pool` function performs critical state changes without emitting corresponding events: [1](#0-0) 

The pending_active stake is merged into active stake without any event emission. Similarly, pending_inactive stake transitions to inactive: [2](#0-1) 

The only event emitted during this process is `DistributeRewards`, which contains only the pool address and rewards amount: [3](#0-2) 

The `StakePool` struct defines event handles for user-initiated actions (add_stake, unlock_stake, withdraw_stake, reactivate_stake) but has no event handles for system-triggered state transitions: [4](#0-3) 

Off-chain systems rely on events to track state. The indexer only processes events that exist: [5](#0-4) 

There is no `ActivateStakeEvent` or `InactivateStakeEvent` type defined.

## Impact Explanation
This issue causes **off-chain observability gaps** leading to:
- **Incorrect voting power displays**: UIs show outdated voting power until state is refreshed
- **Wrong withdrawal availability**: Users see incorrect amounts available for withdrawal
- **Stale delegation information**: Delegation pool interfaces show pending stakes as still pending
- **Governance calculation errors**: External systems calculating voting power from events have incorrect totals

This meets the **Low Severity** classification: "Minor information leaks" and "Non-critical implementation bugs." The on-chain state remains correct; only off-chain systems have temporary staleness.

## Likelihood Explanation
**Likelihood: Very High**

This occurs on **every epoch transition** (approximately every 2 hours) for **every validator** with pending_active or pending_inactive stake. Given hundreds of validators on mainnet, this happens thousands of times per day.

However, the impact is limited because:
- Off-chain systems can poll state directly as a workaround
- The `DistributeRewards` event serves as a signal that an epoch ended
- The staleness is temporary (until next poll/refresh)
- No on-chain security properties are violated

## Recommendation
Add dedicated events for stake state transitions during epoch changes:

```move
#[event]
struct ActivatePendingStake has drop, store {
    pool_address: address,
    amount_activated: u64,
}

#[event]
struct InactivatePendingStake has drop, store {
    pool_address: address,
    amount_inactivated: u64,
}
```

Emit these events in `update_stake_pool`:

```move
// After line 1727, add:
let activated_amount = coin::value(&pending_active_coins);
if (activated_amount > 0) {
    event::emit(ActivatePendingStake { 
        pool_address, 
        amount_activated: activated_amount 
    });
}

// After line 1735, add:
if (get_reconfig_start_time_secs() >= current_lockup_expiration) {
    let inactivated_amount = coin::value(&pending_inactive_coins);
    if (inactivated_amount > 0) {
        event::emit(InactivatePendingStake { 
            pool_address, 
            amount_inactivated: inactivated_amount 
        });
    }
    coin::merge(&mut stake_pool.inactive, pending_inactive_coins);
}
```

Add corresponding event handles to the `StakePool` struct.

## Proof of Concept

The following Move test demonstrates the missing events:

```move
#[test(aptos_framework = @aptos_framework, validator = @0x123)]
public entry fun test_missing_state_transition_events(
    aptos_framework: &signer,
    validator: &signer,
) acquires StakePool, ValidatorSet, ValidatorPerformance, AptosCoinCapabilities {
    // Setup
    initialize_for_test(aptos_framework);
    let validator_address = signer::address_of(validator);
    
    // Initialize validator and add stake
    initialize_validator(validator, x"pubkey", x"pop", x"network", x"fullnode");
    add_stake(validator, 1000000);
    
    // Capture events before epoch transition
    let events_before = event::emitted_events<DistributeRewards>();
    
    // Join validator set (stake goes to pending_active)
    join_validator_set(validator, validator_address);
    
    // Trigger epoch transition (pending_active should move to active)
    end_epoch();
    
    // Check events after - only DistributeRewards event exists
    let events_after = event::emitted_events<DistributeRewards>();
    assert!(vector::length(&events_after) > vector::length(&events_before), 0);
    
    // Verify: No ActivateStake event type exists (compilation would fail)
    // This demonstrates the missing event emission
    
    // Verify stake actually moved from pending_active to active
    let (active, _, pending_active, _) = get_stake(validator_address);
    assert!(active == 1000000, 1);  // Stake is now active
    assert!(pending_active == 0, 2); // Pending is empty
    
    // But off-chain systems only saw DistributeRewards event,
    // not the actual state transition details
}
```

## Notes
This is classified as **Low Severity** as explicitly marked in the security question. While the issue is real and affects off-chain observability, it does not:
- Violate consensus safety or liveness
- Enable theft or loss of funds
- Break any critical on-chain invariants
- Require special privileges to trigger

Off-chain systems can mitigate this by polling state directly or using the `DistributeRewards` event as a trigger to refresh cached state. The on-chain state remains correct at all times.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1726-1727)
```text
        // Pending active stake can now be active.
        coin::merge(&mut stake_pool.active, coin::extract_all(&mut stake_pool.pending_active));
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1729-1736)
```text
        // Pending inactive stake is only fully unlocked and moved into inactive if the current lockup cycle has expired
        let current_lockup_expiration = stake_pool.locked_until_secs;
        if (get_reconfig_start_time_secs() >= current_lockup_expiration) {
            coin::merge(
                &mut stake_pool.inactive,
                coin::extract_all(&mut stake_pool.pending_inactive),
            );
        };
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1738-1748)
```text
        if (std::features::module_event_migration_enabled()) {
            event::emit(DistributeRewards { pool_address, rewards_amount });
        } else {
            event::emit_event(
                &mut stake_pool.distribute_rewards_events,
                DistributeRewardsEvent {
                    pool_address,
                    rewards_amount,
                },
            );
        };
```

**File:** types/src/stake_pool.rs (L7-29)
```rust
#[derive(Debug, Serialize, Deserialize)]
pub struct StakePool {
    pub active: u64,
    pub inactive: u64,
    pub pending_active: u64,
    pub pending_inactive: u64,
    pub locked_until_secs: u64,
    pub operator_address: AccountAddress,
    pub delegated_voter: AccountAddress,

    pub initialize_validator_events: EventHandle,
    pub set_operator_events: EventHandle,
    pub add_stake_events: EventHandle,
    pub reactivate_stake_events: EventHandle,
    pub rotate_consensus_key_events: EventHandle,
    pub update_network_and_fullnode_addresses_events: EventHandle,
    pub increase_lockup_events: EventHandle,
    pub join_validator_set_events: EventHandle,
    pub distribute_rewards_events: EventHandle,
    pub unlock_stake_events: EventHandle,
    pub withdraw_stake_events: EventHandle,
    pub leave_validator_set_events: EventHandle,
}
```

**File:** crates/indexer/src/models/stake_models/stake_utils.rs (L174-181)
```rust
pub enum StakeEvent {
    GovernanceVoteEvent(GovernanceVoteEvent),
    DistributeRewardsEvent(DistributeRewardsEvent),
    AddStakeEvent(AddStakeEvent),
    UnlockStakeEvent(UnlockStakeEvent),
    WithdrawStakeEvent(WithdrawStakeEvent),
    ReactivateStakeEvent(ReactivateStakeEvent),
}
```
