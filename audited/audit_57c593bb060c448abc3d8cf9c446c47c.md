# Audit Report

## Title
Stale Module Cache Size Accounting Due to Overridden Modules Remaining in Cache

## Summary
The `GlobalModuleCache::size_in_bytes()` function returns incorrect inflated values because overridden modules remain in the cache with their sizes still counted in `self.size`, even though they are no longer usable. This leads to incorrect metrics and premature cache eviction.

## Finding Description

The vulnerability exists in the size accounting mechanism of `GlobalModuleCache`. When a module is published during block execution, the global cache marks the old version as "overridden" but does not remove it or adjust the size counter. [1](#0-0) 

The `mark_overridden()` function only sets an atomic boolean flag on the entry, leaving the module in the HashMap with its size still counted: [2](#0-1) 

The `size_in_bytes()` function simply returns the stored size field, which includes all modules regardless of their overridden status: [3](#0-2) 

During block execution, when modules are published, `add_module_write_to_module_cache()` marks them as overridden in the global cache: [4](#0-3) 

These overridden modules remain in the cache until they are explicitly replaced via `insert_verified()`, which only happens at specific times (e.g., during framework prefetching). Meanwhile, `get()` correctly returns `None` for overridden modules, making them unusable: [5](#0-4) 

The inflated size is used in cache management decisions: [6](#0-5) 

**Attack Scenario:**
1. Attacker deploys multiple large modules to build up the global cache
2. Attacker publishes new versions of these modules in subsequent blocks
3. Old versions are marked overridden but remain in cache with sizes counted
4. `size_in_bytes()` returns inflated value
5. Cache hits `max_module_cache_size_in_bytes` threshold prematurely
6. Entire cache is flushed, removing all useful cached modules
7. Performance degrades as cache must be rebuilt
8. Attacker can repeat to cause sustained performance issues

## Impact Explanation

This is a **Medium severity** vulnerability per Aptos bug bounty criteria because:

1. **Incorrect State Metrics**: The `GLOBAL_MODULE_CACHE_SIZE_IN_BYTES` monitoring metric reports inflated values, leading to incorrect observability
2. **Premature Cache Eviction**: The cache may be flushed earlier than necessary based on inflated size calculations, causing unnecessary performance degradation
3. **Performance Impact**: After premature flushes, all cached modules (including valid ones) are lost and must be reloaded, impacting validator node performance
4. **Localized DOS Potential**: An attacker publishing many modules can intentionally trigger premature cache flushes, degrading node performance

This fits the Medium severity category: "State inconsistencies requiring intervention" and validator node performance issues. It does not affect consensus safety, fund security, or cause network-wide failures, but creates operational issues that require monitoring and potential intervention.

## Likelihood Explanation

**High Likelihood** - This issue occurs automatically whenever modules are published during block execution:

1. **Automatic Trigger**: Every module publication during block execution triggers `mark_overridden()`, creating the condition
2. **No Cleanup**: Overridden modules persist in cache until specifically replaced or cache is flushed
3. **Cumulative Effect**: Multiple module publications in a block or across blocks compound the size inflation
4. **Common Operation**: Module deployments and upgrades are normal blockchain operations

The severity of impact scales with the number and size of modules published, but the underlying accounting bug occurs consistently.

## Recommendation

**Option 1: Update size when marking as overridden (Recommended)**

Modify `mark_overridden()` to decrement the size counter when marking a module as overridden:

```rust
pub fn mark_overridden(&mut self, key: &K) {
    if let Some(entry) = self.module_cache.get(key) {
        if entry.is_not_overridden() {
            self.size -= entry.module_code().extension().size_in_bytes();
            entry.mark_overridden();
        }
    }
}
```

This requires changing the method signature to `&mut self` and updating all call sites.

**Option 2: Calculate size dynamically**

Change `size_in_bytes()` to iterate over non-overridden modules only:

```rust
pub fn size_in_bytes(&self) -> usize {
    self.module_cache
        .values()
        .filter(|entry| entry.is_not_overridden())
        .map(|entry| entry.module_code().extension().size_in_bytes())
        .sum()
}
```

This has runtime cost but ensures accuracy.

**Option 3: Immediate removal of overridden modules**

Remove overridden modules immediately from the cache rather than just marking them. This would require adjusting the validation logic that checks overridden status.

## Proof of Concept

```rust
#[cfg(test)]
mod test_size_accounting_bug {
    use super::*;
    use move_vm_types::code::{mock_verified_code, MockExtension};

    #[test]
    fn test_overridden_modules_inflate_size() {
        let mut cache = GlobalModuleCache::empty();
        
        // Insert initial modules
        cache.insert(0, mock_verified_code(0, MockExtension::new(100)));
        cache.insert(1, mock_verified_code(1, MockExtension::new(200)));
        cache.insert(2, mock_verified_code(2, MockExtension::new(300)));
        
        assert_eq!(cache.num_modules(), 3);
        assert_eq!(cache.size_in_bytes(), 600);
        
        // Simulate module republishing during block execution
        cache.mark_overridden(&0);
        cache.mark_overridden(&1);
        
        // BUG: Size still reports 600 even though only module 2 is usable
        assert_eq!(cache.size_in_bytes(), 600); // INCORRECT - should be 300
        
        // Verify that overridden modules are not accessible
        assert!(cache.get(&0).is_none());
        assert!(cache.get(&1).is_none());
        assert!(cache.get(&2).is_some());
        
        // The cache appears to have 600 bytes but only 300 bytes are actually usable
        // This can cause premature cache eviction based on inflated size
        
        println!("BUG CONFIRMED: Cache reports {} bytes but only {} bytes are usable",
                 cache.size_in_bytes(), 300);
    }
}
```

This test demonstrates that after marking modules as overridden, `size_in_bytes()` returns 600 bytes even though only 300 bytes worth of modules are accessible via `get()`. This proves the accounting bug and its potential to trigger premature cache eviction.

## Notes

The vulnerability is exacerbated in scenarios where:
- Many user modules are deployed and subsequently upgraded
- The global cache has limited size thresholds configured
- Module sizes are large (e.g., framework modules)

The issue does not affect consensus safety or determinism, as the per-block module cache handles the new versions correctly. However, it creates operational overhead and performance degradation through unnecessary cache invalidations.

### Citations

**File:** aptos-move/block-executor/src/code_cache_global.rs (L56-58)
```rust
    fn mark_overridden(&self) {
        self.overridden.store(true, Ordering::Release)
    }
```

**File:** aptos-move/block-executor/src/code_cache_global.rs (L124-128)
```rust
    pub fn mark_overridden(&self, key: &K) {
        if let Some(entry) = self.module_cache.get(key) {
            entry.mark_overridden();
        }
    }
```

**File:** aptos-move/block-executor/src/code_cache_global.rs (L132-138)
```rust
    pub fn get(&self, key: &K) -> Option<Arc<ModuleCode<D, V, E>>> {
        self.module_cache.get(key).and_then(|entry| {
            entry
                .is_not_overridden()
                .then(|| Arc::clone(entry.module_code()))
        })
    }
```

**File:** aptos-move/block-executor/src/code_cache_global.rs (L151-153)
```rust
    pub fn size_in_bytes(&self) -> usize {
        self.size
    }
```

**File:** aptos-move/block-executor/src/code_cache_global.rs (L317-317)
```rust
    global_module_cache.mark_overridden(write.module_id());
```

**File:** aptos-move/block-executor/src/code_cache_global_manager.rs (L168-175)
```rust
        let module_cache_size_in_bytes = self.module_cache.size_in_bytes();
        GLOBAL_MODULE_CACHE_SIZE_IN_BYTES.set(module_cache_size_in_bytes as i64);
        GLOBAL_MODULE_CACHE_NUM_MODULES.set(self.module_cache.num_modules() as i64);

        // If module cache stores too many modules, flush it as well.
        if module_cache_size_in_bytes > config.max_module_cache_size_in_bytes {
            self.module_cache.flush();
        }
```
