# Audit Report

## Title
Consensus Observer Accepts Unverified Future-Epoch Commit Decisions Leading to DoS and State Corruption

## Summary
The consensus observer processes `CommitDecision` messages for future epochs without cryptographic verification of the commit proof signatures. An attacker can send malicious commit decisions with manipulated `BlockInfo` that will be accepted, logged, used to update internal state, and trigger resource-intensive state synchronization to invalid targets.

## Finding Description

The `CommitDecision::proof_block_info()` function returns a reference to `BlockInfo` extracted from the `commit_proof` field. Due to the `Deserialize` trait implementation, an attacker can construct arbitrary `CommitDecision` messages containing manipulated `BlockInfo` values via network messages. [1](#0-0) 

The critical vulnerability occurs when processing commit decisions for **future epochs**. The verification logic only checks commit proofs for the **current epoch**: [2](#0-1) 

For future epoch commits (bypassing the current epoch check), the unverified commit decision proceeds to:

1. **Update metrics with manipulated data** (called BEFORE any verification): [3](#0-2) [4](#0-3) 

2. **Update observer block data root with unverified commit proof**: [5](#0-4) [6](#0-5) 

3. **Initiate state sync to invalid target**: [7](#0-6) 

The TODO comment acknowledges this design flaw: [8](#0-7) 

**Attack Path:**
1. Attacker creates `CommitDecision` with `commit_epoch = current_epoch + 1`
2. Attacker sets arbitrary/malicious values in `BlockInfo` (invalid block ID, manipulated round/timestamp)
3. Attacker provides invalid/empty signatures in `commit_proof` (irrelevant since unverified)
4. Attacker sends message to consensus observer over P2P network
5. Observer accepts message, updates root to fake commit proof, initiates state sync
6. State sync fails (no peers have data for fake target), consuming resources
7. Attacker repeats to cause sustained DoS

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos bug bounty criteria for multiple reasons:

1. **Validator Node Slowdowns**: The observer repeatedly attempts resource-intensive state synchronization to invalid targets, consuming network bandwidth, CPU cycles, and storage I/O. Failed sync attempts can take significant time before timing out.

2. **Significant Protocol Violations**: 
   - Observer's internal state (`root` ledger info) is corrupted with unverified data
   - Metrics and monitoring systems receive polluted data, hiding real network state
   - Observer may fail to process legitimate commits while stuck syncing to invalid targets

3. **Denial of Service**: While a single invalid commit triggers one state sync attempt, an attacker can send multiple malicious commits targeting different future epochs or rounds to maintain continuous resource exhaustion.

The vulnerability does NOT directly cause fund loss or consensus safety violations (observers are passive nodes), preventing it from reaching Critical severity.

## Likelihood Explanation

**Likelihood: High**

- **Attacker Requirements**: Any network peer can send `ConsensusObserverDirectSend` messages. No special privileges, stake, or validator status required.
- **Attack Complexity**: Low. Attacker constructs a single serialized `CommitDecision` message with future epoch number and arbitrary `BlockInfo`.
- **Detection Difficulty**: Moderate. Invalid messages are logged but may be mistaken for normal network errors. Metrics pollution could mislead operators.
- **Exploitability**: The vulnerability is immediately exploitable on all nodes running consensus observer (both fullnodes and validators using observer mode).

## Recommendation

**Immediate Fix**: Verify commit proof signatures for ALL epochs, not just the current epoch. If the future epoch's `EpochState` is unavailable, reject the commit decision rather than accepting it unverified.

**Code Fix**:
```rust
// In process_commit_decision_message(), replace lines 466-527 with:

// Verify the commit decision regardless of epoch
let epoch_state = if commit_epoch == self.get_epoch_state().epoch {
    self.get_epoch_state()
} else {
    // For future epochs, we cannot verify yet - reject the commit
    warn!(
        LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
            "Rejecting commit decision for future epoch {}. Current epoch: {}",
            commit_epoch,
            self.get_epoch_state().epoch
        ))
    );
    increment_invalid_message_counter(&peer_network_id, metrics::COMMIT_DECISION_LABEL);
    return;
};

// Verify the commit decision
if let Err(error) = commit_decision.verify_commit_proof(&epoch_state) {
    error!(
        LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
            "Failed to verify commit decision! Ignoring: {:?}, Error: {:?}",
            commit_decision.proof_block_info(),
            error
        ))
    );
    increment_invalid_message_counter(&peer_network_id, metrics::COMMIT_DECISION_LABEL);
    return;
}

// Process the verified commit...
```

**Alternative**: Verify commit proof signatures in `update_metrics_for_commit_decision_message()` BEFORE accessing `proof_block_info()`, and validate signatures in state sync's `initialize_sync_target_request()`.

## Proof of Concept

```rust
#[test]
fn test_unverified_future_epoch_commit_accepted() {
    use aptos_types::{
        block_info::BlockInfo,
        ledger_info::{LedgerInfo, LedgerInfoWithSignatures},
        aggregate_signature::AggregateSignature,
    };
    use aptos_crypto::HashValue;
    
    // Create a malicious commit decision for a future epoch
    let malicious_epoch = 999;
    let malicious_round = 12345;
    let malicious_block_id = HashValue::zero(); // Attacker-controlled value
    
    // Create fake BlockInfo with manipulated values
    let fake_block_info = BlockInfo::new(
        malicious_epoch,
        malicious_round,
        malicious_block_id,
        HashValue::random(), // fake executed state
        0,
        1234567890, // fake timestamp
        None,
    );
    
    // Create LedgerInfo with fake BlockInfo (no verification)
    let fake_ledger_info = LedgerInfo::new(
        fake_block_info,
        HashValue::random(),
    );
    
    // Create commit proof with EMPTY signatures (won't be verified)
    let fake_commit_proof = LedgerInfoWithSignatures::new(
        fake_ledger_info,
        AggregateSignature::empty(),
    );
    
    // Create malicious CommitDecision
    let malicious_commit = CommitDecision::new(fake_commit_proof);
    
    // Verify proof_block_info() returns our manipulated BlockInfo
    assert_eq!(malicious_commit.proof_block_info().epoch(), malicious_epoch);
    assert_eq!(malicious_commit.proof_block_info().round(), malicious_round);
    assert_eq!(malicious_commit.proof_block_info().id(), malicious_block_id);
    
    // This commit decision would be accepted and processed for future epochs
    // without signature verification, triggering state sync to invalid target
}
```

## Notes

This vulnerability stems from an architectural decision to defer verification of future epoch commits to the state synchronization layer. However, state sync does not verify the INITIAL target signaturesâ€”it only verifies data received from peers during the sync process. This creates a gap where unverified commit decisions are accepted and acted upon, enabling DoS attacks and state corruption.

The issue affects all consensus observer nodes, including validators operating in observer mode and fullnodes using the consensus observer protocol for fast sync.

### Citations

**File:** consensus/src/consensus_observer/network/observer_message.rs (L336-359)
```rust
#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
pub struct CommitDecision {
    commit_proof: LedgerInfoWithSignatures,
}

impl CommitDecision {
    pub fn new(commit_proof: LedgerInfoWithSignatures) -> Self {
        Self { commit_proof }
    }

    /// Returns a reference to the commit proof
    pub fn commit_proof(&self) -> &LedgerInfoWithSignatures {
        &self.commit_proof
    }

    /// Returns the epoch of the commit proof
    pub fn epoch(&self) -> u64 {
        self.commit_proof.ledger_info().epoch()
    }

    /// Returns a reference to the commit proof block info
    pub fn proof_block_info(&self) -> &BlockInfo {
        self.commit_proof.commit_info()
    }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L463-465)
```rust
        // Update the metrics for the received commit decision
        update_metrics_for_commit_decision_message(peer_network_id, &commit_decision);

```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L466-482)
```rust
        // If the commit decision is for the current epoch, verify and process it
        let epoch_state = self.get_epoch_state();
        if commit_epoch == epoch_state.epoch {
            // Verify the commit decision
            if let Err(error) = commit_decision.verify_commit_proof(&epoch_state) {
                // Log the error and update the invalid message counter
                error!(
                    LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                        "Failed to verify commit decision! Ignoring: {:?}, from peer: {:?}. Error: {:?}",
                        commit_decision.proof_block_info(),
                        peer_network_id,
                        error
                    ))
                );
                increment_invalid_message_counter(&peer_network_id, metrics::COMMIT_DECISION_LABEL);
                return;
            }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L497-498)
```rust
        // TODO: identify the best way to handle an invalid commit decision
        // for a future epoch. In such cases, we currently rely on state sync.
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L518-526)
```rust
            // Otherwise, we should start the state sync process for the commit.
            // Update the block data (to the commit decision).
            self.observer_block_data
                .lock()
                .update_blocks_for_state_sync_commit(&commit_decision);

            // Start state syncing to the commit decision
            self.state_sync_manager
                .sync_to_commit(commit_decision, epoch_changed);
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L1208-1226)
```rust
fn update_metrics_for_commit_decision_message(
    peer_network_id: PeerNetworkId,
    commit_decision: &CommitDecision,
) {
    // Log the received commit decision message
    let log_message = format!(
        "Received commit decision: {}, from peer: {}!",
        commit_decision.proof_block_info(),
        peer_network_id
    );
    log_received_message(log_message);

    // Update the metrics for the received commit decision
    metrics::set_gauge_with_label(
        &metrics::OBSERVER_RECEIVED_MESSAGE_ROUNDS,
        metrics::COMMIT_DECISION_LABEL,
        commit_decision.round(),
    );
}
```

**File:** consensus/src/consensus_observer/observer/block_data.rs (L275-291)
```rust
    pub fn update_blocks_for_state_sync_commit(&mut self, commit_decision: &CommitDecision) {
        // Get the commit proof, epoch and round
        let commit_proof = commit_decision.commit_proof();
        let commit_epoch = commit_decision.epoch();
        let commit_round = commit_decision.round();

        // Update the root
        self.update_root(commit_proof.clone());

        // Update the block payload store
        self.block_payload_store
            .remove_blocks_for_epoch_round(commit_epoch, commit_round);

        // Update the ordered block store
        self.ordered_block_store
            .remove_blocks_for_commit(commit_proof);
    }
```

**File:** consensus/src/consensus_observer/observer/state_sync_manager.rs (L190-197)
```rust
    pub fn sync_to_commit(&mut self, commit_decision: CommitDecision, epoch_changed: bool) {
        // Log that we're starting to sync to the commit decision
        info!(
            LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                "Started syncing to commit: {}!",
                commit_decision.proof_block_info()
            ))
        );
```
