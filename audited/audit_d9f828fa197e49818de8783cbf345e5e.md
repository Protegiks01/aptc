# Audit Report

## Title
Zero Stake Requirement Allows Governance Proposal Spam via Unvalidated `required_proposer_stake` Configuration

## Summary
The `required_proposer_stake` parameter in the genesis configuration can be set to 0 without any validation, allowing accounts with zero staked tokens to create unlimited governance proposals. This completely bypasses the economic security model designed to prevent governance spam.

## Finding Description

The Aptos governance system is designed to require proposers to have a minimum amount of staked APT tokens before creating governance proposals. However, there are critical validation gaps in both the genesis initialization and runtime update paths for the `required_proposer_stake` parameter.

**Configuration Vulnerability:**

The `Layout` struct defines `required_proposer_stake` without any validation constraints: [1](#0-0) 

Test networks default this value to 0: [2](#0-1) 

The genesis initialization directly passes this value to the Move governance module without validation: [3](#0-2) 

**Runtime Update Vulnerability:**

The `update_governance_config` function accepts any `required_proposer_stake` value without validation: [4](#0-3) 

**Proposal Creation Check Bypass:**

When creating proposals, the system checks if stake balance >= required_proposer_stake: [5](#0-4) 

When `required_proposer_stake = 0`, this check becomes `stake_balance >= 0`, which always passes for any non-negative stake balance (including 0).

**Governance Permission Bypass:**

The permission check uses `check_permission_exists` which automatically returns `true` for master signers (most regular accounts): [6](#0-5) 

**Attack Path:**

1. **Create Zero-Stake Pool**: An attacker calls `initialize_stake_owner` with 0 initial stake: [7](#0-6) 

2. **Establish Lockup**: The stake pool is created with zero lockup initially: [8](#0-7) 

   The attacker increases lockup (no stake required): [9](#0-8) 

3. **Spam Proposals**: With `required_proposer_stake = 0`, the attacker creates unlimited proposals with zero economic cost beyond gas fees.

This breaks the **Governance Integrity** invariant that voting power and proposal creation rights should be tied to economic stake, allowing unbounded governance spam.

## Impact Explanation

This vulnerability qualifies as **Medium Severity** under the Aptos Bug Bounty criteria for the following reasons:

**Governance System Degradation:**
- Attackers can flood the governance system with spam proposals at minimal cost
- Legitimate proposals become difficult to discover and track
- Governance participants must expend resources reviewing spam proposals
- The system's reputation and usability are severely damaged

**Economic Barrier Removal:**
- Mainnet normally requires 1M APT (~$10M+ USD at typical valuations) in stake
- With zero requirement, only gas fees (~$0.01 per proposal) are needed
- The economic security model is completely undermined

**State Inconsistencies:**
- Governance state grows unbounded with spam proposals
- Storage costs increase for all nodes tracking governance
- Requires manual intervention to mitigate ongoing attacks

This does not rise to Critical or High severity because:
- No direct loss or theft of funds
- No consensus safety violations
- No permanent network unavailability
- Requires misconfiguration (not exploitable on mainnet by default)

However, it clearly exceeds Low severity as it enables significant protocol degradation and requires governance intervention to resolve.

## Likelihood Explanation

**On Test Networks: HIGH**
- Test genesis configurations set `required_proposer_stake = 0` by default
- Any user can immediately exploit this to spam proposals
- Test networks are publicly accessible

**On Mainnet/Production: MEDIUM**
- Default configuration is 1M APT (secure)
- Requires either:
  - Malicious genesis configuration (unlikely for mainnet)
  - Successful governance attack to pass a proposal setting value to 0
  - Accidental misconfiguration during network upgrades

**Attack Complexity: LOW**
- No specialized knowledge required
- Standard staking and governance functions
- Can be scripted and automated
- Gas costs are negligible ($0.01 per proposal vs normally $10M in stake)

**Detection: EASY**
- On-chain governance config is publicly readable
- Unusual proposal volume easily detected
- Can be monitored via `get_required_proposer_stake()` view function

## Recommendation

**Immediate Fixes:**

1. **Add Validation to Genesis Configuration**

In `crates/aptos-genesis/src/config.rs`, add validation when loading Layout:

```rust
impl Layout {
    pub fn from_disk(path: &Path) -> anyhow::Result<Self> {
        // ... existing code ...
        let layout: Layout = serde_yaml::from_str(&contents)?;
        
        // Validate required_proposer_stake
        if !layout.is_test && layout.required_proposer_stake == 0 {
            return Err(anyhow::Error::msg(
                "required_proposer_stake cannot be 0 for non-test networks"
            ));
        }
        
        Ok(layout)
    }
}
```

2. **Add Validation to Runtime Updates**

In `aptos-move/framework/aptos-framework/sources/aptos_governance.move`:

```move
public fun update_governance_config(
    aptos_framework: &signer,
    min_voting_threshold: u128,
    required_proposer_stake: u64,
    voting_duration_secs: u64,
) acquires GovernanceConfig, GovernanceEvents {
    system_addresses::assert_aptos_framework(aptos_framework);
    
    // Add validation
    assert!(
        required_proposer_stake > 0,
        error::invalid_argument(EINVALID_GOVERNANCE_CONFIG)
    );
    
    // Consider minimum threshold based on network type
    let min_required_stake = if (features::is_mainnet()) {
        1_000_000 * 100_000_000 // 1M APT minimum
    } else {
        1 * 100_000_000 // 1 APT minimum for testnets
    };
    
    assert!(
        required_proposer_stake >= min_required_stake,
        error::invalid_argument(EINVALID_GOVERNANCE_CONFIG)
    );

    // ... rest of function ...
}
```

3. **Add New Error Code**

```move
const EINVALID_GOVERNANCE_CONFIG: u64 = 17;
```

**Additional Recommendations:**

- Add governance config change events for monitoring
- Implement rate limiting on proposal creation per account
- Consider time-based cooldowns between proposals from the same stake pool
- Add governance dashboard warnings when config values approach dangerous thresholds

## Proof of Concept

```move
#[test_only]
module aptos_framework::governance_spam_test {
    use std::signer;
    use aptos_framework::aptos_governance;
    use aptos_framework::stake;
    use aptos_framework::coin;
    use aptos_framework::aptos_coin::AptosCoin;
    use aptos_framework::timestamp;
    use aptos_framework::account;

    #[test(aptos_framework = @aptos_framework, attacker = @0xBAD)]
    public entry fun test_zero_stake_proposal_spam(
        aptos_framework: signer,
        attacker: signer,
    ) {
        // Setup: Initialize governance with required_proposer_stake = 0
        account::create_account_for_test(signer::address_of(&aptos_framework));
        account::create_account_for_test(signer::address_of(&attacker));
        
        // Initialize governance with 0 stake requirement (simulating test genesis)
        aptos_governance::initialize(
            &aptos_framework,
            100_000_000_000_000, // min_voting_threshold
            0,                    // required_proposer_stake = 0 (VULNERABLE!)
            43200                 // voting_duration_secs
        );
        
        // Initialize timestamp
        timestamp::set_time_has_started_for_testing(&aptos_framework);
        
        // Attacker creates stake pool with ZERO stake
        stake::initialize_stake_owner(
            &attacker,
            0,  // initial_stake_amount = 0
            signer::address_of(&attacker), // operator
            signer::address_of(&attacker)  // voter
        );
        
        // Attacker increases lockup (no stake required!)
        stake::increase_lockup(&attacker);
        
        // ATTACK: Attacker creates multiple proposals with zero stake!
        let proposal_count = 0;
        while (proposal_count < 10) {
            aptos_governance::create_proposal(
                &attacker,
                signer::address_of(&attacker), // stake_pool with 0 stake
                b"malicious_code_hash",
                b"spam_proposal_metadata",
                b"spam_hash"
            );
            proposal_count = proposal_count + 1;
        };
        
        // Verify: Attacker created 10 proposals with ZERO staked tokens
        // In a properly configured system, this should require millions of APT
        assert!(proposal_count == 10, 0);
    }
}
```

**Notes:**

This vulnerability is particularly concerning because:
1. **Test networks are vulnerable by default**, potentially misleading developers about security assumptions
2. **No validation exists** at any layer (genesis, runtime update, or proposal creation)
3. **The attack is trivial** - requires only standard staking operations
4. **Economic security model is completely bypassed** - the whole point of stake requirements is defeated

The fix is straightforward: add validation to prevent zero or unreasonably low values, with different thresholds for mainnet vs. testnets.

### Citations

**File:** crates/aptos-genesis/src/config.rs (L58-59)
```rust
    /// Required amount of stake to create proposals.
    pub required_proposer_stake: u64,
```

**File:** aptos-move/vm-genesis/src/lib.rs (L900-903)
```rust
            MoveValue::Signer(CORE_CODE_ADDRESS),
            MoveValue::U128(genesis_config.min_voting_threshold),
            MoveValue::U64(genesis_config.required_proposer_stake),
            MoveValue::U64(genesis_config.voting_duration_secs),
```

**File:** aptos-move/vm-genesis/src/lib.rs (L1433-1433)
```rust
            required_proposer_stake: 0,
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L243-254)
```text
    public fun update_governance_config(
        aptos_framework: &signer,
        min_voting_threshold: u128,
        required_proposer_stake: u64,
        voting_duration_secs: u64,
    ) acquires GovernanceConfig, GovernanceEvents {
        system_addresses::assert_aptos_framework(aptos_framework);

        let governance_config = borrow_global_mut<GovernanceConfig>(@aptos_framework);
        governance_config.voting_duration_secs = voting_duration_secs;
        governance_config.min_voting_threshold = min_voting_threshold;
        governance_config.required_proposer_stake = required_proposer_stake;
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L420-426)
```text
        // The proposer's stake needs to be at least the required bond amount.
        let governance_config = borrow_global<GovernanceConfig>(@aptos_framework);
        let stake_balance = get_voting_power(stake_pool);
        assert!(
            stake_balance >= governance_config.required_proposer_stake,
            error::invalid_argument(EINSUFFICIENT_PROPOSER_STAKE),
        );
```

**File:** aptos-move/framework/aptos-framework/sources/permissioned_signer.move (L561-563)
```text
        if (!is_permissioned_signer(s)) {
            // master signer has all permissions
            return true
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L656-658)
```text
        if (initial_stake_amount > 0) {
            add_stake(owner, initial_stake_amount);
        };
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L705-705)
```text
            locked_until_secs: 0,
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1008-1017)
```text
    public fun increase_lockup_with_cap(owner_cap: &OwnerCapability) acquires StakePool {
        let pool_address = owner_cap.pool_address;
        assert_stake_pool_exists(pool_address);
        let config = staking_config::get();

        let stake_pool = borrow_global_mut<StakePool>(pool_address);
        let old_locked_until_secs = stake_pool.locked_until_secs;
        let new_locked_until_secs = timestamp::now_seconds() + staking_config::get_recurring_lockup_duration(&config);
        assert!(old_locked_until_secs < new_locked_until_secs, error::invalid_argument(EINVALID_LOCKUP));
        stake_pool.locked_until_secs = new_locked_until_secs;
```
