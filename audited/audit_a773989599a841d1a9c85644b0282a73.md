# Audit Report

## Title
Storage Service UnexpectedErrorEncountered Catch-All Creates Security Monitoring Blind Spot and Information Disclosure

## Summary
The `UnexpectedErrorEncountered` error variant in the storage service acts as an indiscriminate catch-all that lumps together benign errors (overflow, serialization failures) with security-critical errors (database permission failures, IO errors with file paths). This creates two problems: (1) all error types receive the same metric label "unexpected_error", making security-relevant errors undetectable in monitoring systems, and (2) detailed internal error messages including file paths and database details are exposed to untrusted network peers.

## Finding Description

The storage service error handling implements a catch-all pattern that masks security-relevant information: [1](#0-0) [2](#0-1) 

All errors converted to `UnexpectedErrorEncountered` receive the same metric label, preventing differentiation: [3](#0-2) 

These errors are then exposed to network clients with full details: [4](#0-3) 

The storage service accepts requests from untrusted network peers: [5](#0-4) 

RocksDB errors containing file paths and internal details get converted through this path: [6](#0-5) [7](#0-6) 

In contrast, consensus SafetyRules implements security-conscious error handling by panicking on permission errors rather than propagating them: [8](#0-7) 

**Attack Path:**
1. Attacker sends crafted storage requests designed to trigger internal errors (e.g., requests for invalid version ranges, malformed state proofs)
2. Storage service encounters database errors, permission failures, or IO errors
3. These errors are converted to `UnexpectedErrorEncountered` with full error details
4. Full error messages (including file paths like `/var/aptos/db/LOCK: Permission denied`) are sent back to attacker over network
5. Attacker uses reconnaissance data to identify vulnerable configurations or plan targeted attacks
6. Security-relevant errors remain undetected in metrics, appearing only as generic "unexpected_error" counts

## Impact Explanation

This constitutes **High Severity** due to:

1. **Information Disclosure**: Internal implementation details (file paths, database names, storage structure) are exposed to untrusted network peers, violating the principle of least privilege and enabling reconnaissance attacks.

2. **Monitoring Blind Spot**: Security-critical errors (permission denied, authentication failures, access control violations) are indistinguishable from benign errors (overflow, serialization) in the `STORAGE_ERRORS_ENCOUNTERED` metric. Operators cannot configure proper alerting for security events, allowing attacks to proceed undetected.

3. **Protocol Violation**: The storage service is critical infrastructure for state synchronization - new validators joining the network and nodes recovering from crashes depend on it. The inability to monitor security-relevant errors represents a significant protocol violation in operational security practices.

While this does not directly cause consensus breaks or fund loss, it significantly degrades the security posture of the network by:
- Enabling attacker reconnaissance 
- Preventing detection of security events
- Violating defense-in-depth principles

## Likelihood Explanation

**High likelihood** because:
- Storage service is exposed to all network peers (including untrusted public fullnodes)
- No special permissions or validator access required to trigger errors
- Attackers can send arbitrary storage requests to probe for errors
- The catch-all pattern affects all error paths unconditionally
- Database/IO errors can occur naturally under load, providing cover for malicious probing

## Recommendation

Implement fine-grained error categorization with security-conscious handling:

```rust
#[derive(Clone, Debug, Deserialize, Error, PartialEq, Eq, Serialize)]
pub enum Error {
    #[error("Invalid request received: {0}")]
    InvalidRequest(String),
    #[error("Storage error encountered: {0}")]
    StorageErrorEncountered(String),
    #[error("Too many invalid requests: {0}")]
    TooManyInvalidRequests(String),
    // Split into specific error types
    #[error("Serialization error")]
    SerializationError,
    #[error("Compression error")]
    CompressionError,
    #[error("Arithmetic overflow error")]
    OverflowError,
    #[error("Database permission error")]
    DatabasePermissionError,
    #[error("Internal error")]  // Generic catch-all as last resort
    InternalError,
}

impl Error {
    pub fn get_label(&self) -> &'static str {
        match self {
            Error::InvalidRequest(_) => "invalid_request",
            Error::StorageErrorEncountered(_) => "storage_error",
            Error::TooManyInvalidRequests(_) => "too_many_invalid_requests",
            Error::SerializationError => "serialization_error",
            Error::CompressionError => "compression_error",
            Error::OverflowError => "overflow_error",
            Error::DatabasePermissionError => "database_permission_error",
            Error::InternalError => "internal_error",
        }
    }
}

// Sanitize error messages sent to clients
impl From<Error> for StorageServiceError {
    fn from(error: Error) -> Self {
        match error {
            Error::InvalidRequest(e) => StorageServiceError::InvalidRequest(e),
            Error::TooManyInvalidRequests(e) => StorageServiceError::TooManyInvalidRequests(e),
            Error::DatabasePermissionError => {
                // Panic for critical security errors like SafetyRules does
                panic!("Database permission error detected - requires operator intervention");
            }
            // Don't expose internal details to clients
            _ => StorageServiceError::InternalError("Internal processing error".to_string()),
        }
    }
}
```

## Proof of Concept

```rust
// Add to state-sync/storage-service/server/src/tests/
#[tokio::test]
async fn test_error_information_disclosure() {
    // Setup storage service with mocked DB that returns permission error
    let mock_storage = MockStorageReader::with_permission_error("/sensitive/path/db");
    
    // Create request from untrusted peer
    let peer = PeerNetworkId::new(NetworkId::Public, PeerId::random());
    let request = StorageServiceRequest::new(
        DataRequest::GetTransactionsWithProof(TransactionsWithProofRequest {
            proof_version: 1000,
            start_version: 0,
            end_version: 100,
            include_events: false,
        }),
        false,
    );
    
    // Process request
    let response = handler.process_request(&peer, request, false);
    
    // Verify error exposes internal file path
    match response {
        Err(StorageServiceError::InternalError(msg)) => {
            assert!(msg.contains("/sensitive/path/db"), 
                   "Internal file path should not be exposed to untrusted peers");
        },
        _ => panic!("Expected InternalError with path disclosure"),
    }
    
    // Verify metric label doesn't distinguish error type
    let metrics = STORAGE_ERRORS_ENCOUNTERED.collect();
    assert_eq!(metrics.get("unexpected_error").unwrap(), 1);
    assert!(metrics.get("database_permission_error").is_none(),
           "Permission errors should be separately metered");
}
```

**Notes:**
- The vulnerability affects all storage service error paths that convert to `UnexpectedErrorEncountered`
- Impact is amplified because storage service is exposed to untrusted public network peers
- The lack of security-conscious error handling (compared to SafetyRules) is a design flaw
- Fix requires both error categorization and message sanitization to prevent information disclosure

### Citations

**File:** state-sync/storage-service/server/src/error.rs (L19-29)
```rust
impl Error {
    /// Returns a summary label for the error type
    pub fn get_label(&self) -> &'static str {
        match self {
            Error::InvalidRequest(_) => "invalid_request",
            Error::StorageErrorEncountered(_) => "storage_error",
            Error::TooManyInvalidRequests(_) => "too_many_invalid_requests",
            Error::UnexpectedErrorEncountered(_) => "unexpected_error",
        }
    }
}
```

**File:** state-sync/storage-service/server/src/error.rs (L31-35)
```rust
impl From<aptos_storage_service_types::responses::Error> for Error {
    fn from(error: aptos_storage_service_types::responses::Error) -> Self {
        Error::UnexpectedErrorEncountered(error.to_string())
    }
}
```

**File:** state-sync/storage-service/server/src/error.rs (L37-41)
```rust
impl From<anyhow::Error> for Error {
    fn from(error: anyhow::Error) -> Self {
        Error::UnexpectedErrorEncountered(error.to_string())
    }
}
```

**File:** state-sync/storage-service/server/src/handler.rs (L196-202)
```rust
        process_result.map_err(|error| match error {
            Error::InvalidRequest(error) => StorageServiceError::InvalidRequest(error),
            Error::TooManyInvalidRequests(error) => {
                StorageServiceError::TooManyInvalidRequests(error)
            },
            error => StorageServiceError::InternalError(error.to_string()),
        })
```

**File:** state-sync/storage-service/server/src/moderator.rs (L49-69)
```rust
    /// Note: we only ignore peers on the public network.
    pub fn increment_invalid_request_count(&mut self, peer_network_id: &PeerNetworkId) {
        // Increment the invalid request count
        self.invalid_request_count += 1;

        // If the peer is a PFN and has sent too many invalid requests, start ignoring it
        if self.ignore_start_time.is_none()
            && peer_network_id.network_id().is_public_network()
            && self.invalid_request_count >= self.max_invalid_requests
        {
            // TODO: at some point we'll want to terminate the connection entirely

            // Start ignoring the peer
            self.ignore_start_time = Some(self.time_service.now());

            // Log the fact that we're now ignoring the peer
            warn!(LogSchema::new(LogEntry::RequestModeratorIgnoredPeer)
                .peer_network_id(peer_network_id)
                .message("Ignoring peer due to too many invalid requests!"));
        }
    }
```

**File:** storage/schemadb/src/lib.rs (L389-408)
```rust
fn to_db_err(rocksdb_err: rocksdb::Error) -> AptosDbError {
    match rocksdb_err.kind() {
        ErrorKind::Incomplete => AptosDbError::RocksDbIncompleteResult(rocksdb_err.to_string()),
        ErrorKind::NotFound
        | ErrorKind::Corruption
        | ErrorKind::NotSupported
        | ErrorKind::InvalidArgument
        | ErrorKind::IOError
        | ErrorKind::MergeInProgress
        | ErrorKind::ShutdownInProgress
        | ErrorKind::TimedOut
        | ErrorKind::Aborted
        | ErrorKind::Busy
        | ErrorKind::Expired
        | ErrorKind::TryAgain
        | ErrorKind::CompactionTooLarge
        | ErrorKind::ColumnFamilyDropped
        | ErrorKind::Unknown => AptosDbError::OtherRocksDbError(rocksdb_err.to_string()),
    }
}
```

**File:** storage/storage-interface/src/errors.rs (L39-43)
```rust
impl From<anyhow::Error> for AptosDbError {
    fn from(error: anyhow::Error) -> Self {
        Self::Other(format!("{}", error))
    }
}
```

**File:** consensus/safety-rules/src/error.rs (L78-99)
```rust
impl From<aptos_secure_storage::Error> for Error {
    fn from(error: aptos_secure_storage::Error) -> Self {
        match error {
            aptos_secure_storage::Error::PermissionDenied => {
                // If a storage error is thrown that indicates a permission failure, we
                // want to panic immediately to alert an operator that something has gone
                // wrong. For example, this error is thrown when a storage (e.g., vault)
                // token has expired, so it makes sense to fail fast and require a token
                // renewal!
                panic!(
                    "A permission error was thrown: {:?}. Maybe the storage token needs to be renewed?",
                    error
                );
            },
            aptos_secure_storage::Error::KeyVersionNotFound(_, _)
            | aptos_secure_storage::Error::KeyNotSet(_) => {
                Self::SecureStorageMissingDataError(error.to_string())
            },
            _ => Self::SecureStorageUnexpectedError(error.to_string()),
        }
    }
}
```
