# Audit Report

## Title
Missing Validation in save_config() Allows Disabling State Pruning Through Overrides, Causing Unbounded Storage Growth and Validator Resource Exhaustion

## Summary
The `save_config()` function in `OverrideNodeConfig` does not validate storage pruning configurations before saving, allowing operators to create and deploy configurations with pruning completely disabled. This can lead to unbounded storage growth and validator resource exhaustion, as there is no enforcement preventing pruning from being disabled on mainnet validators. [1](#0-0) 

## Finding Description
When an operator creates a node configuration override using `OverrideNodeConfig`, the `save_config()` method serializes and writes the configuration to disk without performing any validation. Critically, this allows the creation of configurations where all storage pruners are disabled (`enable: false`).

The storage pruning system consists of three components defined in `PrunerConfig`: [2](#0-1) 

Each pruner configuration has an `enable` boolean flag: [3](#0-2) 

When configurations are loaded, the `StorageConfig::sanitize()` method only validates that prune window sizes aren't too small but **does not prevent pruning from being entirely disabled**: [4](#0-3) 

When pruning is disabled, the pruner managers check the `enable` flag and set `pruner_worker` to `None`: [5](#0-4) [6](#0-5) 

With pruning disabled, storage grows unboundedly as ALL transaction history and state are retained permanently. At mainnet transaction rates (~5,000 TPS), this results in:
- ~432 million transactions per day
- Continuous growth without cleanup
- Eventual disk exhaustion
- Validator node becomes unresponsive or crashes

## Impact Explanation
This qualifies as **Medium Severity** per Aptos bug bounty criteria for the following reasons:

1. **Validator Resource Exhaustion**: Validators with disabled pruning will experience unbounded storage growth, eventually exhausting disk space and becoming unavailable.

2. **State Inconsistencies Requiring Intervention**: When validators run out of disk space, they require manual intervention to restore service, causing network disruption.

3. **Network Availability Impact**: If multiple validators are affected by this misconfiguration, it can degrade network performance and availability.

4. **No Runtime Protection**: Unlike other critical configurations (e.g., `SafetyRulesConfig`, `ExecutionConfig`) that enforce mainnet-specific requirements, storage pruning configuration has no mandatory validation preventing dangerous states.

The issue meets the Medium severity threshold of "State inconsistencies requiring intervention" as validators will need manual recovery when disk space is exhausted.

## Likelihood Explanation
This issue has **HIGH** likelihood of occurrence because:

1. **No Validation at Save Time**: The `save_config()` function provides no warnings or errors when pruning is disabled.

2. **Accidental Misconfiguration**: Operators may inadvertently disable pruning while testing configurations or copying from test environments to production.

3. **Incomplete Documentation**: The configuration system allows setting `enable: false` without clear warnings about the consequences for long-running validators.

4. **Delayed Detection**: Storage exhaustion may take weeks or months to manifest, by which time the root cause (disabled pruning) may not be immediately obvious.

5. **Monitoring is Reactive, Not Preventive**: While disk space monitoring exists, it only alerts after the problem has begun, rather than preventing the misconfiguration. [7](#0-6) 

## Recommendation

Add mandatory validation in `StorageConfig::sanitize()` to prevent pruning from being disabled on mainnet validators. This follows the pattern used by other safety-critical configurations:

The fix should:

1. **Add Error Check in Sanitizer**: Modify `StorageConfig::sanitize()` to return an error (not just warn) when pruning is disabled on mainnet validators:

```rust
// In storage_config.rs, within sanitize() method:
if let Some(chain_id) = chain_id {
    if chain_id.is_mainnet() || chain_id.is_testnet() {
        if !config.storage_pruner_config.ledger_pruner_config.enable {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "Ledger pruning must be enabled on mainnet and testnet to prevent unbounded storage growth.".to_string(),
            ));
        }
        if !config.storage_pruner_config.state_merkle_pruner_config.enable {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "State merkle pruning must be enabled on mainnet and testnet to prevent unbounded storage growth.".to_string(),
            ));
        }
        if !config.storage_pruner_config.epoch_snapshot_pruner_config.enable {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "Epoch snapshot pruning must be enabled on mainnet and testnet to prevent unbounded storage growth.".to_string(),
            ));
        }
    }
}
```

2. **Add Validation in save_config()**: Optionally add a pre-save validation step in `OverrideNodeConfig::save_config()` to catch issues earlier.

This approach provides defense-in-depth by preventing dangerous configurations from being deployed to production validators.

## Proof of Concept

```rust
use aptos_config::config::{
    LedgerPrunerConfig, StateMerklePrunerConfig, EpochSnapshotPrunerConfig,
    PrunerConfig, StorageConfig, NodeConfig, OverrideNodeConfig, 
    PersistableConfig, NodeType
};
use aptos_config::config::config_sanitizer::ConfigSanitizer;
use aptos_types::chain_id::ChainId;
use std::path::PathBuf;

#[test]
fn test_pruning_disabled_passes_validation() {
    // Create a config with all pruning disabled
    let mut node_config = NodeConfig::default();
    node_config.storage.storage_pruner_config = PrunerConfig {
        ledger_pruner_config: LedgerPrunerConfig {
            enable: false,  // DISABLED
            prune_window: 0,
            batch_size: 0,
            user_pruning_window_offset: 0,
        },
        state_merkle_pruner_config: StateMerklePrunerConfig {
            enable: false,  // DISABLED
            prune_window: 0,
            batch_size: 0,
        },
        epoch_snapshot_pruner_config: EpochSnapshotPrunerConfig {
            enable: false,  // DISABLED
            prune_window: 0,
            batch_size: 0,
        },
    };

    // Create an override config
    let override_config = OverrideNodeConfig::new_with_default_base(node_config.clone());
    
    // VULNERABILITY: save_config() succeeds without validation
    let temp_path = PathBuf::from("/tmp/dangerous_config.yaml");
    override_config.save_config(&temp_path).expect("Should save without error");
    
    // Load the config back
    let loaded_override = OverrideNodeConfig::load_config(&temp_path).expect("Should load");
    
    // VULNERABILITY: Sanitizer only warns, doesn't prevent this dangerous configuration
    // This would allow a mainnet validator to run without pruning!
    let sanitize_result = StorageConfig::sanitize(
        loaded_override.override_config(),
        NodeType::Validator,
        Some(ChainId::mainnet())
    );
    
    // Currently passes validation (only warnings emitted to logs)
    assert!(sanitize_result.is_ok(), "Dangerous config passes validation!");
    
    // This validator would now run without pruning, causing unbounded storage growth
    println!("VULNERABILITY CONFIRMED: Pruning disabled config was saved and validated successfully");
}
```

This PoC demonstrates that a configuration with all pruning disabled can be saved via `save_config()` and passes validation, allowing it to be deployed to production validators where it would cause unbounded storage growth and eventual resource exhaustion.

## Notes

The vulnerability stems from a defense-in-depth failure where the configuration system trusts operators completely without enforcing safety invariants for critical infrastructure. While disk space monitoring alerts exist, they are reactive rather than preventive. The recommended fix brings storage configuration validation in line with other safety-critical components like `SafetyRulesConfig` and `ExecutionConfig` that do enforce mainnet requirements. [8](#0-7)

### Citations

**File:** config/src/config/override_node_config.rs (L142-152)
```rust
    fn save_config<P: AsRef<Path>>(&self, output_file: P) -> Result<(), Error> {
        let yaml_value = self.get_yaml()?;
        let yaml_string = serde_yaml::to_string(&yaml_value).map_err(|e| {
            Error::Yaml(
                "Unable to serialize override config to yaml. Error: {}".to_string(),
                e,
            )
        })?;
        let yaml_bytes = yaml_string.as_bytes().to_vec();
        Self::write_file(yaml_bytes, output_file)
    }
```

**File:** config/src/config/storage_config.rs (L306-323)
```rust
pub const NO_OP_STORAGE_PRUNER_CONFIG: PrunerConfig = PrunerConfig {
    ledger_pruner_config: LedgerPrunerConfig {
        enable: false,
        prune_window: 0,
        batch_size: 0,
        user_pruning_window_offset: 0,
    },
    state_merkle_pruner_config: StateMerklePrunerConfig {
        enable: false,
        prune_window: 0,
        batch_size: 0,
    },
    epoch_snapshot_pruner_config: EpochSnapshotPrunerConfig {
        enable: false,
        prune_window: 0,
        batch_size: 0,
    },
};
```

**File:** config/src/config/storage_config.rs (L327-341)
```rust
pub struct LedgerPrunerConfig {
    /// Boolean to enable/disable the ledger pruner. The ledger pruner is responsible for pruning
    /// everything else except for states (e.g. transactions, events etc.)
    pub enable: bool,
    /// This is the default pruning window for any other store except for state store. State store
    /// being big in size, we might want to configure a smaller window for state store vs other
    /// store.
    pub prune_window: u64,
    /// Batch size of the versions to be sent to the ledger pruner - this is to avoid slowdown due to
    /// issuing too many DB calls and batch prune instead. For ledger pruner, this means the number
    /// of versions to prune a time.
    pub batch_size: usize,
    /// The offset for user pruning window to adjust
    pub user_pruning_window_offset: u64,
}
```

**File:** config/src/config/storage_config.rs (L379-385)
```rust
#[derive(Clone, Copy, Debug, Deserialize, Eq, PartialEq, Serialize, Default)]
#[serde(default, deny_unknown_fields)]
pub struct PrunerConfig {
    pub ledger_pruner_config: LedgerPrunerConfig,
    pub state_merkle_pruner_config: StateMerklePrunerConfig,
    pub epoch_snapshot_pruner_config: EpochSnapshotPrunerConfig,
}
```

**File:** config/src/config/storage_config.rs (L682-717)
```rust
impl ConfigSanitizer for StorageConfig {
    fn sanitize(
        node_config: &NodeConfig,
        _node_type: NodeType,
        _chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();
        let config = &node_config.storage;

        let ledger_prune_window = config
            .storage_pruner_config
            .ledger_pruner_config
            .prune_window;
        let state_merkle_prune_window = config
            .storage_pruner_config
            .state_merkle_pruner_config
            .prune_window;
        let epoch_snapshot_prune_window = config
            .storage_pruner_config
            .epoch_snapshot_pruner_config
            .prune_window;
        let user_pruning_window_offset = config
            .storage_pruner_config
            .ledger_pruner_config
            .user_pruning_window_offset;

        if ledger_prune_window < 50_000_000 {
            warn!("Ledger prune_window is too small, harming network data availability.");
        }
        if state_merkle_prune_window < 100_000 {
            warn!("State Merkle prune_window is too small, node might stop functioning.");
        }
        if epoch_snapshot_prune_window < 50_000_000 {
            warn!("Epoch snapshot prune_window is too small, harming network data availability.");
        }
        if user_pruning_window_offset > 1_000_000 {
```

**File:** storage/aptosdb/src/pruner/ledger_pruner/ledger_pruner_manager.rs (L113-121)
```rust
        let pruner_worker = if ledger_pruner_config.enable {
            Some(Self::init_pruner(
                Arc::clone(&ledger_db),
                ledger_pruner_config,
                internal_indexer_db,
            ))
        } else {
            None
        };
```

**File:** storage/aptosdb/src/pruner/state_merkle_pruner/state_merkle_pruner_manager.rs (L110-117)
```rust
        let pruner_worker = if state_merkle_pruner_config.enable {
            Some(Self::init_pruner(
                Arc::clone(&state_merkle_db),
                state_merkle_pruner_config,
            ))
        } else {
            None
        };
```
