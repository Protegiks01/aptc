# Audit Report

## Title
Global Invariants Can Hide Memory Dependencies Through Uninterpreted Lambda-Derived Spec Functions

## Summary
The Move Prover's memory usage tracking for global invariants is incomplete when spec functions derived from lambda expressions are marked as uninterpreted. When a lambda's implementation body contains imperative expressions, the spec function is set to uninterpreted with `body = None`, but its `used_memory` field is computed only from the (now absent) body, completely ignoring the lambda's spec block which may contain `global<T>()` or `exists<T>()` memory accesses. This allows global invariants to hide memory dependencies, bypassing memory access analysis. [1](#0-0) 

## Finding Description

The vulnerability exists in how the Move Prover computes memory usage (`mem_usage`) for global invariants when they transitively depend on lambda-derived spec functions.

**Vulnerability Path:**

1. **Lambda with Spec Block**: A lambda expression is written with an implementation body containing imperative code and a spec block accessing global memory through `global<T>(addr)` or `exists<T>(addr)`. [2](#0-1) 

2. **Lambda Lifting**: During inlining, the lambda is lifted into a function, preserving its spec block.

3. **Spec Function Creation**: `run_spec_rewriter_inline` creates a `SpecFunDecl` from the lifted function with `for_inline=true`, attaching the spec block. [3](#0-2) 

4. **Uninterpreted Marking**: If the implementation body contains imperative expressions, the function is marked as uninterpreted and `body` is set to `None`, **but this happens before `used_memory` is computed**. [4](#0-3) 

5. **Memory Usage Computation**: Later, `run_spec_rewriter` computes `used_memory` for all spec functions. For functions with `body = None`, it sets `used_memory` to an empty set, **completely ignoring the spec block**. [5](#0-4) 

6. **Incomplete Memory Tracking**: The `used_memory` method only examines the body, not the spec block. [6](#0-5) 

7. **Global Invariant Impact**: When a global invariant (directly or transitively) calls this lambda-derived spec function, its `mem_usage` is computed using the spec function's (empty) `used_memory` field. [7](#0-6) 

8. **Bypass**: The global invariant's `mem_usage` doesn't include the memory types accessed in the lambda's spec block, causing memory access analysis to miss these dependencies. [8](#0-7) 

**Root Cause**: The `used_memory` computation logic only examines the `body` field of a spec function, never the `spec` field. For lambda-derived functions marked as uninterpreted, the body is erased before memory usage is calculated, losing all memory dependency information from the spec block.

## Impact Explanation

This vulnerability allows verification bypass in the Move Prover, which is a critical component of Move's security model. The impact is **High Severity** based on "significant protocol violations":

1. **Verification Incompleteness**: Global invariants with hidden memory dependencies won't be instrumented at the correct program points during verification. The prover will fail to check these invariants when the hidden memory is accessed.

2. **False Verification Success**: Code that violates global invariants may pass verification because the prover doesn't know which memory accesses should trigger invariant checks.

3. **Deployment of Buggy Code**: Since the Aptos Framework and other critical Move modules rely on the Move Prover for security guarantees, this bypass could allow deployment of code with invariant violations.

4. **Potential Consensus Impact**: If buggy code with invariant violations is deployed to the blockchain, it could lead to state inconsistencies, which in a multi-validator environment could cause consensus divergence if validators' implementations differ in how they handle the violation.

While the immediate impact is on the verification layer (not runtime execution), the Move Prover is explicitly part of Aptos's security model for ensuring Move code correctness before deployment.

## Likelihood Explanation

**Moderate Likelihood**:

- **Occurrence**: The vulnerability requires specific code patterns (inline functions with lambdas containing spec blocks and imperative code), which are less common but not impossible in real Move code.

- **Discoverability**: The issue is subtle and unlikely to be noticed during normal development, as the prover will silently accept code without properly checking invariants.

- **Exploitation Complexity**: Low - once the pattern is understood, creating code that triggers the vulnerability is straightforward. The attacker only needs to write Move code with the appropriate structure.

- **Attack Requirements**: No special privileges needed - any Move developer can create modules with this pattern.

The likelihood increases if lambda expressions with spec blocks become more common in Move code, particularly in inline functions used for abstraction.

## Recommendation

**Fix Option 1 - Compute used_memory from spec block for uninterpreted functions:**

Modify the memory usage computation in `run_spec_rewriter` to check the spec block when the body is None:

In `third_party/move/move-compiler-v2/src/env_pipeline/spec_rewriter.rs`, around line 174:

```rust
let (initial_callees, initial_usage) = if let Some(def) = &env.get_spec_fun(qid).body {
    // Existing logic for functions with bodies
    let callees = def.called_spec_funs(env);
    for callee in &callees {
        graph.add_edge(qid, callee.to_qualified_id(), ());
    }
    (callees, def.directly_used_memory(env))
} else {
    // NEW: For uninterpreted functions, check if there's a spec block
    let spec_fun = env.get_spec_fun(qid);
    let spec = spec_fun.spec.borrow();
    let mut spec_usage = BTreeSet::new();
    for cond in &spec.conditions {
        let usage = cond.exp.used_memory(env);
        spec_usage.extend(usage.into_iter().map(|(mem, _)| mem));
    }
    (BTreeSet::new(), spec_usage)
};
```

**Fix Option 2 - Compute and preserve used_memory before marking as uninterpreted:**

In `run_spec_rewriter_inline`, compute `used_memory` from the body before setting it to None:

```rust
if converter.contains_imperative_expression {
    let spec_fun = converter.env.get_spec_fun_mut(*id);
    // Compute used_memory from body before erasing it
    if let Some(body) = &spec_fun.body {
        spec_fun.used_memory = body.directly_used_memory(converter.env);
    }
    spec_fun.uninterpreted = true;
    spec_fun.body = None;
}
```

**Recommendation**: Implement both fixes for defense-in-depth. Fix Option 1 is more robust as it handles all cases where spec blocks contain memory accesses, while Fix Option 2 captures memory usage before information is lost.

## Proof of Concept

Create a Move module demonstrating the vulnerability:

```move
module 0x1::HiddenMemoryDep {
    struct Resource has key { value: u64 }
    
    // Inline function with lambda that has spec block
    inline fun check_with_lambda(addr: address, checker: |address|bool): bool {
        checker(addr)
    }
    
    // Function using the inline function
    public fun test_function(addr: address): bool {
        check_with_lambda(addr, |a| {
            // Imperative code in body
            let x = 5;
            x > 0
        } spec {
            // Spec block accesses global memory
            requires exists<Resource>(a);
            ensures result == true;
            aborts_if !exists<Resource>(a);
            ensures global<Resource>(a).value > 0;
        })
    }
    
    spec module {
        // Global invariant that calls test_function via spec function
        invariant forall addr: address where exists<Resource>(addr):
            global<Resource>(addr).value > 0;
    }
}
```

**Reproduction Steps**:

1. Compile the module with the Move Prover enabled
2. During `run_spec_rewriter_inline`, the lambda is lifted and marked as uninterpreted (body contains imperative `let` statement)
3. The `used_memory` is computed from the (now None) body, resulting in empty set
4. The global invariant's `mem_usage` doesn't include `Resource`, even though the lambda's spec block accesses `global<Resource>(a)`
5. The prover won't properly instrument checks for the global invariant when `Resource` is accessed

**Verification**: Add debug logging in `spec_rewriter.rs` line 184 to print `used_memory` for lambda-derived spec functions - it will be empty despite the spec block accessing `Resource`.

## Notes

This vulnerability specifically affects the Move Prover's verification phase, not runtime execution. However, since the Move Prover is a critical security component for ensuring Move code correctness before deployment on the Aptos blockchain, verification bypasses are considered significant security issues. The vulnerability could allow deployment of code with invariant violations that should have been caught during verification.

### Citations

**File:** third_party/move/move-model/src/ast.rs (L515-525)
```rust
/// Describes a global invariant.
#[derive(Debug, Clone)]
pub struct GlobalInvariant {
    pub id: GlobalId,
    pub loc: Loc,
    pub kind: ConditionKind,
    pub mem_usage: BTreeSet<QualifiedInstId<StructId>>,
    pub declaring_module: ModuleId,
    pub properties: PropertyBag,
    pub cond: Exp,
}
```

**File:** third_party/move/move-model/src/ast.rs (L1093-1124)
```rust
    pub fn used_memory(
        &self,
        env: &GlobalEnv,
    ) -> BTreeSet<(QualifiedInstId<StructId>, Option<MemoryLabel>)> {
        let mut result = BTreeSet::new();
        let mut visitor = |e: &ExpData| {
            use ExpData::*;
            use Operation::*;
            match e {
                Call(id, Exists(label), _) | Call(id, Global(label), _) => {
                    let inst = &env.get_node_instantiation(*id);
                    let (mid, sid, sinst) = inst[0].require_struct();
                    result.insert((mid.qualified_inst(sid, sinst.to_owned()), label.to_owned()));
                },
                Call(id, SpecFunction(mid, fid, labels), _) => {
                    let inst = &env.get_node_instantiation(*id);
                    let module = env.get_module(*mid);
                    let fun = module.get_spec_fun(*fid);
                    for (i, mem) in fun.used_memory.iter().enumerate() {
                        result.insert((
                            mem.to_owned().instantiate(inst),
                            labels.as_ref().map(|l| l[i]),
                        ));
                    }
                },
                _ => {},
            }
            true // keep going
        };
        self.visit_post_order(&mut visitor);
        result
    }
```

**File:** third_party/move/move-compiler-v2/src/env_pipeline/lambda_lifter.rs (L723-737)
```rust
        let spec = if let Some(spec_exp) = spec_opt {
            if let ExpData::SpecBlock(_, _) = spec_exp.as_ref() {
                let new_spec_exp =
                    ExpRewriter::new(env, &mut spec_replacer).rewrite_exp(spec_exp.clone());
                if let ExpData::SpecBlock(_, new_spec) = new_spec_exp.as_ref() {
                    Some(new_spec.clone())
                } else {
                    None
                }
            } else {
                None
            }
        } else {
            None
        };
```

**File:** third_party/move/move-compiler-v2/src/env_pipeline/spec_rewriter.rs (L174-182)
```rust
        let (initial_callees, initial_usage) = if let Some(def) = &env.get_spec_fun(qid).body {
            let callees = def.called_spec_funs(env);
            for callee in &callees {
                graph.add_edge(qid, callee.to_qualified_id(), ());
            }
            (callees, def.directly_used_memory(env))
        } else {
            Default::default()
        };
```

**File:** third_party/move/move-compiler-v2/src/env_pipeline/spec_rewriter.rs (L266-271)
```rust
            // If the spec function contains imperative expressions, set it to uninterpreted
            if converter.contains_imperative_expression {
                let spec_fun = converter.env.get_spec_fun_mut(*id);
                spec_fun.uninterpreted = true;
                spec_fun.body = None;
            } else if !ExpData::ptr_eq(&new_exp, &exp) {
```

**File:** third_party/move/move-compiler-v2/src/env_pipeline/spec_rewriter.rs (L314-336)
```rust
    // Currently we only attach the spec block when it is generated during inlining
    let spec = if for_inline {
        fun.get_spec().clone()
    } else {
        Default::default()
    };
    let decl = SpecFunDecl {
        loc: fun.get_loc(),
        name,
        type_params: fun.get_type_parameters(),
        params,
        context_params: None,
        result_type,
        used_memory: BTreeSet::new(),
        uninterpreted: false,
        is_move_fun: true,
        is_native,
        body,
        callees: BTreeSet::new(),
        is_recursive: RefCell::new(None),
        insts_using_generic_type_reflection: Default::default(),
        spec: RefCell::new(spec),
    };
```

**File:** third_party/move/move-compiler-v2/src/env_pipeline/spec_rewriter.rs (L645-650)
```rust
                    mem_usage: cond
                        .exp
                        .used_memory(env)
                        .into_iter()
                        .map(|(mem, _)| mem.clone())
                        .collect(),
```

**File:** third_party/move/move-prover/bytecode-pipeline/src/global_invariant_analysis.rs (L433-443)
```rust
                for inv_mem in &inv.mem_usage {
                    let inv_ty = inv_mem.to_type();

                    // make sure these two types unify before trying to instantiate them
                    let adapter = TypeUnificationAdapter::new_pair(&rel_ty, &inv_ty, true, true);
                    if adapter
                        .unify(&mut NoUnificationContext, Variance::SpecVariance, false)
                        .is_none()
                    {
                        continue;
                    }
```
