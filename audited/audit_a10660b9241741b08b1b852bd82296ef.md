# Audit Report

## Title
Race Condition in Indexer Object Deletion Causes Stale Data Corruption Due to Non-Transactional Read

## Summary
The indexer's object deletion processing reads object state from the database outside of transaction boundaries, creating a race condition where concurrent processor tasks can cause permanently incorrect ownership data to be written to the `current_objects` table.

## Finding Description

The vulnerability exists in the interaction between three code locations:

1. **Non-transactional database read**: [1](#0-0) 

2. **Pre-transaction processing**: [2](#0-1) 

3. **Transaction boundary**: [3](#0-2) 

The issue occurs because the indexer spawns multiple concurrent processor tasks [4](#0-3)  that process different transaction batches in parallel. When processing object deletions, the code reads the previous object state from the database to determine the owner before deletion. However, this read happens **before** the database transaction begins.

**Attack scenario:**
- Task A processes versions 1000-1499, encounters deletion of object X at version 1200
- Task A reads from database: object X has owner=Alice (version 400) - **READ OUTSIDE TRANSACTION**
- Task B processes versions 500-999, updates object X to owner=Bob (version 700)
- Task B commits its transaction successfully
- Task A starts its transaction and writes deletion with stale owner=Alice
- The WHERE clause at [5](#0-4)  checks `last_transaction_version (700) <= excluded (1200)` which passes
- Database permanently stores incorrect owner=Alice for the deleted object

The PostgreSQL isolation level is READ COMMITTED [6](#0-5) , which does not prevent this issue because the read occurs outside any transaction.

## Impact Explanation

This qualifies as **Medium Severity** under "State inconsistencies requiring intervention":

- The indexer's `current_objects` table contains permanently incorrect ownership data
- APIs serving object queries return wrong historical ownership information
- Requires full reindexing to correct the corrupted data
- Affects data integrity of the indexer subsystem, though does not impact blockchain consensus or on-chain state

While the indexer is not part of the consensus layer, it provides critical data services to applications, wallets, and explorers. Corrupted ownership data can mislead users about NFT/object provenance and ownership history.

## Likelihood Explanation

**High likelihood** of occurrence:
- The indexer runs multiple concurrent processor tasks by default
- The race window exists between every object deletion operation
- No synchronization prevents concurrent reads and writes
- Production deployments commonly use multiple processor tasks for performance
- The issue is deterministically reproducible under concurrent load

## Recommendation

Wrap the database read operation inside the same transaction as the write operations. Modify the code flow:

**Option 1**: Move the object lookup into the transaction:
```rust
// In default_processor.rs, pass a connection that's already in a transaction
// to from_delete_resource, or delay the lookup until inside insert_to_db_impl
```

**Option 2**: Use SELECT FOR UPDATE to lock the row:
```rust
// In v2_objects.rs get_object_owner
current_objects::table
    .filter(current_objects::object_address.eq(object_address))
    .for_update()
    .first::<Self>(conn)
```

**Option 3**: Use SERIALIZABLE isolation level for the entire transaction to detect conflicts.

**Recommended fix**: Refactor to perform all database reads within the same transaction as writes, ensuring atomicity of the read-modify-write operation.

## Proof of Concept

```rust
// Reproduction steps:
// 1. Configure indexer with processor_tasks > 1
// 2. Process transactions with object operations across multiple batches
// 3. Ensure batches overlap in time but not in version ranges
// 4. Monitor current_objects table for inconsistencies

// Example concurrent scenario:
// Terminal 1: Process versions 0-1000 slowly
// Terminal 2: Process versions 1001-2000 quickly
// Terminal 3: Query current_objects during processing
// Expected: Objects deleted in version 1500 should have owner from version 1499
// Actual: May have stale owner from version 500 due to race condition

// Database query to detect corruption:
// SELECT * FROM current_objects co1
// WHERE EXISTS (
//   SELECT 1 FROM objects o
//   WHERE o.object_address = co1.object_address
//   AND o.transaction_version > co1.last_transaction_version
//   AND o.owner_address != co1.owner_address
// );
```

**Notes**

This vulnerability affects the **indexer subsystem** specifically, not the core blockchain consensus or on-chain state. The indexer is an off-chain component that provides query APIs by indexing blockchain data into PostgreSQL. While this creates data integrity issues in the indexer database requiring intervention (reindexing), it does not compromise blockchain security, consensus safety, or on-chain funds. The corrupted data is limited to the indexer's view of the blockchain state and can be corrected by reindexing from the authoritative blockchain storage.

### Citations

**File:** crates/indexer/src/models/v2_objects.rs (L167-192)
```rust
    fn get_object_owner(
        conn: &mut PgPoolConnection,
        object_address: &str,
    ) -> anyhow::Result<CurrentObject> {
        let mut retried = 0;
        while retried < QUERY_RETRIES {
            retried += 1;
            match CurrentObjectQuery::get_by_address(object_address, conn) {
                Ok(res) => {
                    return Ok(CurrentObject {
                        object_address: res.object_address,
                        owner_address: res.owner_address,
                        state_key_hash: res.state_key_hash,
                        allow_ungated_transfer: res.allow_ungated_transfer,
                        last_guid_creation_num: res.last_guid_creation_num,
                        last_transaction_version: res.last_transaction_version,
                        is_deleted: res.is_deleted,
                    })
                },
                Err(_) => {
                    std::thread::sleep(std::time::Duration::from_millis(QUERY_RETRY_DELAY_MS));
                },
            }
        }
        Err(anyhow::anyhow!("Failed to get object owner"))
    }
```

**File:** crates/indexer/src/processors/default_processor.rs (L125-148)
```rust
    match conn
        .build_transaction()
        .read_write()
        .run::<_, Error, _>(|pg_conn| {
            insert_to_db_impl(
                pg_conn,
                &txns,
                (
                    &user_transactions,
                    &signatures,
                    &block_metadata_transactions,
                ),
                &events,
                &wscs,
                (
                    &move_modules,
                    &move_resources,
                    &table_items,
                    &current_table_items,
                    &table_metadata,
                ),
                (&objects, &current_objects),
            )
        }) {
```

**File:** crates/indexer/src/processors/default_processor.rs (L466-466)
```rust
                Some(" WHERE current_objects.last_transaction_version <= excluded.last_transaction_version "),
```

**File:** crates/indexer/src/processors/default_processor.rs (L560-566)
```rust
                        if let Some((object, current_object)) = Object::from_delete_resource(
                            inner,
                            txn_version,
                            index,
                            &all_current_objects,
                            &mut conn,
                        )
```

**File:** crates/indexer/src/runtime.rs (L210-219)
```rust
        let mut tasks = vec![];
        for _ in 0..processor_tasks {
            let other_tailer = tailer.clone();
            let task = tokio::spawn(async move { other_tailer.process_next_batch().await });
            tasks.push(task);
        }
        let batches = match futures::future::try_join_all(tasks).await {
            Ok(res) => res,
            Err(err) => panic!("Error processing transaction batches: {:?}", err),
        };
```

**File:** crates/aptos-localnet/src/hasura_metadata.json (L2419-2419)
```json
            "isolation_level": "read-committed",
```
