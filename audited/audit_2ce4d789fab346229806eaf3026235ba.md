# Audit Report

## Title
Depth Limit Inconsistency Between Constant Verification and Runtime Deserialization Enables Consensus-Breaking VERIFIER_INVARIANT_VIOLATION

## Summary
A critical inconsistency exists between constant depth checking during bytecode verification and runtime execution. Constants with deeply nested vectors (depth > 128 but < ~300) can pass verification but fail at runtime with `VERIFIER_INVARIANT_VIOLATION`, breaking the deterministic execution invariant and potentially causing consensus divergence.

## Finding Description

The Move bytecode verifier and runtime interpreter use different deserialization paths for constants, with incompatible depth limit enforcement:

**Verification Path:** When modules are published, `constants::verify_module()` validates each constant by calling `Constant::deserialize_constant()`. [1](#0-0) 

This function uses `MoveValue::simple_deserialize()` which directly calls BCS deserialization without any explicit depth limit: [2](#0-1) 

The only depth protection comes from the BCS library's default serde recursion limit (typically ~300 levels).

**Runtime Path:** When the `LdConst` instruction executes, it calls `Value::deserialize_constant()` which explicitly enforces `DEFAULT_MAX_VM_VALUE_NESTED_DEPTH` (128): [3](#0-2) 

This creates a 128-level depth limit that is stricter than the verification path.

**Exploitation:** An attacker publishes a module containing a constant with nested vector type depth between 128 and ~300 (e.g., `vector<vector<vector<...<u8>>>> ` with 150 levels). The module passes verification because the BCS library accepts it, but when a transaction attempts to execute code loading this constant, deserialization fails and triggers: [4](#0-3) 

The `VERIFIER_INVARIANT_VIOLATION` error should never occur for verified modules, indicating a critical verification failure that breaks the consensus invariant.

## Impact Explanation

This vulnerability meets **Critical Severity** criteria (Consensus/Safety violations):

1. **Consensus Divergence:** Validators executing transactions that load the malformed constant will crash with `VERIFIER_INVARIANT_VIOLATION`, while validators not yet executing that code path continue normally. This breaks the deterministic execution guarantee where all validators must produce identical state roots.

2. **Verification Bypass:** Successfully bypasses the bytecode verifier's safety guarantees, allowing modules that should be rejected to be published and later cause runtime failures.

3. **Network Disruption:** Published modules become "landmines" that crash validator nodes when executed, potentially causing widespread network instability if the module's functions are invoked by popular dApps or system operations.

4. **State Inconsistency:** Different validators may have different views of valid vs. failing transactions, leading to potential chain splits or requiring emergency intervention.

## Likelihood Explanation

**Likelihood: High**

- **Attacker Requirements:** Only requires ability to publish modules (standard transaction capability)
- **Complexity: Low:** Creating deeply nested vector types is trivial in Move source code or can be manually crafted in bytecode
- **Detection: Difficult:** The malicious constant appears valid during verification and only fails at runtime when loaded
- **Impact Amplification:** A single published module can affect all validators when any transaction invokes functions using the constant

## Recommendation

Add explicit depth checking during constant verification to match runtime limits:

```rust
// In third_party/move/move-binary-format/src/constant.rs
impl Constant {
    pub fn deserialize_constant(&self) -> Option<MoveValue> {
        let ty = sig_to_ty(&self.type_)?;
        // Add depth validation before deserialization
        if self.calculate_type_depth() > MAX_CONSTANT_DEPTH {
            return None;
        }
        MoveValue::simple_deserialize(&self.data, &ty).ok()
    }
    
    fn calculate_type_depth(&self) -> u64 {
        self.type_.calculate_depth()
    }
}

// Add to SignatureToken implementation
impl SignatureToken {
    fn calculate_depth(&self) -> u64 {
        match self {
            SignatureToken::Vector(inner) => 1 + inner.calculate_depth(),
            _ => 1,
        }
    }
}
```

Additionally, ensure verification uses the same `ValueSerDeContext` with depth limits as runtime: [5](#0-4) 

## Proof of Concept

```move
// malicious_module.move
module 0x1::DeepConstant {
    // Create a constant with vector nesting depth of 150
    // Type: vector<vector<vector<...<u8>>>> (150 levels)
    const DEEP_VECTOR: vector<vector<vector<vector<vector<vector<vector<vector<
        vector<vector<vector<vector<vector<vector<vector<vector<vector<vector<
        vector<vector<vector<vector<vector<vector<vector<vector<vector<vector<
        // ... continue nesting to 150 levels
        vector<u8>
    >>>>>>>>>>>>>>>>>>>>>>>>>>>>>> = /* deeply nested empty vectors */;
    
    public fun trigger_crash(): vector<u8> {
        // Attempting to use this constant will cause VERIFIER_INVARIANT_VIOLATION at runtime
        DEEP_VECTOR
    }
}
```

**Execution Steps:**
1. Compile and publish the module (passes verification)
2. Submit transaction calling `DeepConstant::trigger_crash()`
3. When `LdConst` executes, `Value::deserialize_constant()` fails due to depth > 128
4. Runtime returns `VERIFIER_INVARIANT_VIOLATION` error
5. Consensus breaks as validators diverge on transaction execution results

## Notes

The vulnerability stems from an architectural mismatch where verification and runtime use different value deserialization implementations (`MoveValue` vs `Value`) with different depth enforcement strategies. The comment in the runtime code explicitly acknowledges this should be prevented by verification but the verification path lacks the enforcement: [6](#0-5) 

This breaks Aptos Critical Invariant #1: "Deterministic Execution: All validators must produce identical state roots for identical blocks."

### Citations

**File:** third_party/move/move-bytecode-verifier/src/constants.rs (L55-63)
```rust
fn verify_constant_data(idx: usize, constant: &Constant) -> PartialVMResult<()> {
    match constant.deserialize_constant() {
        Some(_) => Ok(()),
        None => Err(verification_error(
            StatusCode::MALFORMED_CONSTANT_DATA,
            IndexKind::ConstantPool,
            idx as TableIndex,
        )),
    }
```

**File:** third_party/move/move-binary-format/src/constant.rs (L71-74)
```rust
    pub fn deserialize_constant(&self) -> Option<MoveValue> {
        let ty = sig_to_ty(&self.type_)?;
        MoveValue::simple_deserialize(&self.data, &ty).ok()
    }
```

**File:** third_party/move/move-vm/types/src/values/values_impl.rs (L57-57)
```rust
pub const DEFAULT_MAX_VM_VALUE_NESTED_DEPTH: u64 = 128;
```

**File:** third_party/move/move-vm/types/src/values/values_impl.rs (L5442-5449)
```rust
    pub fn deserialize_constant(constant: &Constant) -> Option<Value> {
        let layout = Self::constant_sig_token_to_layout(&constant.type_)?;
        // INVARIANT:
        //   For constants, layout depth is bounded and cannot contain function values. Hence,
        //   serialization depth is bounded. We still enable depth checks as a precaution.
        ValueSerDeContext::new(Some(DEFAULT_MAX_VM_VALUE_NESTED_DEPTH))
            .deserialize(&constant.data, &layout)
    }
```

**File:** third_party/move/move-vm/runtime/src/interpreter.rs (L2146-2152)
```rust
                        let val = Value::deserialize_constant(constant).ok_or_else(|| {
                            PartialVMError::new(StatusCode::VERIFIER_INVARIANT_VIOLATION)
                                .with_message(
                                    "Verifier failed to verify the deserialization of constants"
                                        .to_owned(),
                                )
                        })?;
```
