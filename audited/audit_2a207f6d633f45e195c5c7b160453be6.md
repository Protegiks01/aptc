# Audit Report

## Title
Remote Executor gRPC Connections Lack Encryption - All Historical Messages Exposed in Plaintext

## Summary
The remote executor's gRPC connections between coordinator and executor shards use unencrypted HTTP transport without TLS. This completely eliminates forward secrecy and exposes all transaction execution data in plaintext to any attacker with network-level access.

## Finding Description

The remote executor service facilitates distributed transaction execution across multiple shards, with a coordinator dispatching work to remote executor processes. All communication occurs over gRPC, but the implementation lacks any encryption or TLS configuration.

**Vulnerable Code Locations:**

The client connection establishment uses plain HTTP without TLS: [1](#0-0) 

The server setup has no TLS configuration: [2](#0-1) 

**What Gets Exposed:**

The remote executor transmits sensitive execution data including:
- `ExecuteBlockCommand` containing partitioned transactions and sub-blocks
- `RemoteExecutionResult` containing transaction outputs and state changes
- State view requests and responses for transaction execution
- All data is serialized via BCS and sent in plaintext [3](#0-2) 

**Forward Secrecy Analysis:**

The security question asks: "If long-lived gRPC connections are compromised, can historical messages be decrypted?"

The answer is **YES, trivially** - but not because decryption is needed. The connections use `connect_lazy()` which creates persistent channels reused for multiple requests. Since there is no encryption at all, an attacker who:
1. Captures network traffic (via tcpdump, wireshark, network tap)
2. Compromises a node with network access
3. Has internal network access to the cluster

Can read ALL historical messages in plaintext. There is no forward secrecy because there is no encryption to begin with.

**Attack Vector:**

The remote executor is deployed as standalone processes with network addresses configured via command-line arguments: [4](#0-3) 

An attacker with network-level access can passively capture all communication between these processes, exposing:
- Transaction contents before consensus finalization
- Execution results and state transitions
- Performance and timing information
- Internal cluster topology

**Cryptographic Correctness Invariant Violation:**

This breaks invariant #10: "Cryptographic Correctness: BLS signatures, VRF, and hash operations must be secure." While BLS and hash operations may be secure, the lack of transport encryption violates the principle that sensitive data should be protected both at rest and in transit.

## Impact Explanation

**Severity: MEDIUM** per Aptos Bug Bounty categories

This qualifies as Medium severity because:

1. **Information Disclosure**: Exposes transaction execution data, state transitions, and cluster internals to network-level attackers
2. **No Forward Secrecy**: All historical network traffic remains readable indefinitely if captured
3. **Attack Surface**: Enables potential MITM attacks on remote executor communication
4. **Limited Scope**: Requires network-level access (compromised node, internal network attacker, or physical network tap) rather than being remotely exploitable

The impact is NOT Critical because:
- It does not directly lead to consensus violations
- It does not enable theft or minting of funds
- It requires privileged network access, not remote exploitation
- The data exposure is limited to execution internals

However, it represents a significant defense-in-depth failure that could facilitate more sophisticated attacks when combined with other vulnerabilities.

## Likelihood Explanation

**Likelihood: MEDIUM-HIGH for certain threat models**

The likelihood depends on the deployment environment:

1. **Cloud Deployments**: MEDIUM-HIGH - Cloud providers have infrastructure access, and lateral movement after initial compromise is common
2. **Co-located Infrastructure**: MEDIUM - Physical access or network taps are possible attack vectors
3. **Distributed Clusters**: HIGH - Multiple network hops increase exposure surface

The attack is **certain to succeed** if the attacker gains network access, as no encryption means no defense. The question is only whether the attacker can achieve that network position.

Common scenarios enabling this attack:
- Compromised monitoring/logging infrastructure with network visibility
- Insider threat (datacenter staff, cloud provider employees)
- Lateral movement after initial system compromise
- Misconfigured network segmentation

## Recommendation

Implement TLS encryption for all remote executor gRPC connections, following the pattern established in the indexer gRPC services:

**Server-Side Configuration:** [5](#0-4) [6](#0-5) 

**Required Changes:**

1. **Add TLS Configuration Structure** in `secure/net/src/grpc_network_service/mod.rs`:
   - Add `TlsConfig` with cert_path and key_path fields
   - Modify `GRPCNetworkMessageServiceServerWrapper::new()` to accept TLS config
   - Modify `GRPCNetworkMessageServiceClientWrapper::new()` to use HTTPS

2. **Update Server Initialization** to load certificates and configure TLS:
   - Read cert and key files using `tokio::fs::read()`
   - Create `tonic::transport::Identity::from_pem(cert, key)`
   - Apply via `.tls_config(ServerTlsConfig::new().identity(identity))`

3. **Update Client Connections** to use HTTPS scheme and verify certificates:
   - Change from `format!("http://{}", remote_addr)` to `format!("https://{}", remote_addr)`
   - Configure client-side TLS with appropriate CA certificates

4. **Update Configuration** in `execution/executor-service/src/main.rs`:
   - Add command-line arguments for cert_path and key_path
   - Pass TLS configuration through the service initialization

This provides:
- **Encryption in transit**: Protects all messages from eavesdropping
- **Forward secrecy**: Modern TLS cipher suites provide forward secrecy by default
- **Authentication**: Mutual TLS can verify both coordinator and shard identities
- **Defense in depth**: Reduces impact of network-level compromise

## Proof of Concept

**Step 1: Deploy Remote Executor (Current Vulnerable Setup)**

```bash
# Start coordinator
./executor-service --shard-id 0 --num-shards 2 \
  --coordinator-address 127.0.0.1:52200 \
  --remote-executor-addresses 127.0.0.1:52201 127.0.0.1:52202

# Start executor shards
./executor-service --shard-id 1 --num-shards 2 \
  --coordinator-address 127.0.0.1:52200 \
  --remote-executor-addresses 127.0.0.1:52201 127.0.0.1:52202
```

**Step 2: Capture Network Traffic**

```bash
# Capture all traffic between coordinator and shards
tcpdump -i lo -w remote_executor.pcap 'port 52200 or port 52201 or port 52202'
```

**Step 3: Analyze Captured Traffic**

```bash
# View captured packets in wireshark
wireshark remote_executor.pcap

# Or use tshark to decode gRPC messages
tshark -r remote_executor.pcap -Y 'tcp.port == 52200' -T fields -e data
```

**Expected Result**: All `ExecuteBlockCommand` and `RemoteExecutionResult` messages are visible in plaintext, including:
- Transaction payloads serialized in BCS format
- Execution results and state changes
- Message types and routing information

**Verification**: The captured traffic contains human-readable gRPC HTTP/2 headers and BCS-serialized payloads that can be decoded to extract transaction data without any decryption.

---

## Notes

This vulnerability represents a critical defense-in-depth failure. While the remote executor system is designed for internal cluster communication, the lack of encryption creates unnecessary risk. Modern best practices mandate encryption for all sensitive network communication, regardless of whether it crosses trust boundaries. The fix is straightforward and follows established patterns already present in the codebase for indexer gRPC services.

### Citations

**File:** secure/net/src/grpc_network_service/mod.rs (L57-88)
```rust
    async fn start_async(
        self,
        server_addr: SocketAddr,
        rpc_timeout_ms: u64,
        server_shutdown_rx: oneshot::Receiver<()>,
    ) {
        let reflection_service = tonic_reflection::server::Builder::configure()
            .register_encoded_file_descriptor_set(FILE_DESCRIPTOR_SET)
            .build_v1()
            .unwrap();

        info!("Starting Server async at {:?}", server_addr);
        // NOTE: (1) serve_with_shutdown() starts the server, if successful the task does not return
        //           till the server is shutdown. Hence this should be called as a separate
        //           non-blocking task. Signal handler 'server_shutdown_rx' is needed to shutdown
        //           the server
        //       (2) There is no easy way to know if/when the server has started successfully. Hence
        //           we may need to implement a healthcheck service to check if the server is up
        Server::builder()
            .timeout(std::time::Duration::from_millis(rpc_timeout_ms))
            .add_service(
                NetworkMessageServiceServer::new(self).max_decoding_message_size(MAX_MESSAGE_SIZE),
            )
            .add_service(reflection_service)
            .serve_with_shutdown(server_addr, async {
                server_shutdown_rx.await.ok();
                info!("Received signal to shutdown server at {:?}", server_addr);
            })
            .await
            .unwrap();
        info!("Server shutdown at {:?}", server_addr);
    }
```

**File:** secure/net/src/grpc_network_service/mod.rs (L124-138)
```rust
    pub fn new(rt: &Runtime, remote_addr: SocketAddr) -> Self {
        Self {
            remote_addr: remote_addr.to_string(),
            remote_channel: rt
                .block_on(async { Self::get_channel(format!("http://{}", remote_addr)).await }),
        }
    }

    async fn get_channel(remote_addr: String) -> NetworkMessageServiceClient<Channel> {
        info!("Trying to connect to remote server at {:?}", remote_addr);
        let conn = tonic::transport::Endpoint::new(remote_addr)
            .unwrap()
            .connect_lazy();
        NetworkMessageServiceClient::new(conn).max_decoding_message_size(MAX_MESSAGE_SIZE)
    }
```

**File:** execution/executor-service/src/remote_executor_client.rs (L186-212)
```rust
    ) -> Result<ShardedExecutionOutput, VMStatus> {
        trace!("RemoteExecutorClient Sending block to shards");
        self.state_view_service.set_state_view(state_view);
        let (sub_blocks, global_txns) = transactions.into();
        if !global_txns.is_empty() {
            panic!("Global transactions are not supported yet");
        }
        for (shard_id, sub_blocks) in sub_blocks.into_iter().enumerate() {
            let senders = self.command_txs.clone();
            let execution_request = RemoteExecutionRequest::ExecuteBlock(ExecuteBlockCommand {
                sub_blocks,
                concurrency_level: concurrency_level_per_shard,
                onchain_config: onchain_config.clone(),
            });

            senders[shard_id]
                .lock()
                .unwrap()
                .send(Message::new(bcs::to_bytes(&execution_request).unwrap()))
                .unwrap();
        }

        let execution_results = self.get_output_from_shards()?;

        self.state_view_service.drop_state_view();
        Ok(ShardedExecutionOutput::new(execution_results, vec![]))
    }
```

**File:** execution/executor-service/src/main.rs (L9-25)
```rust
#[derive(Debug, Parser)]
struct Args {
    #[clap(long, default_value_t = 8)]
    pub num_executor_threads: usize,

    #[clap(long)]
    pub shard_id: usize,

    #[clap(long)]
    pub num_shards: usize,

    #[clap(long, num_args = 1..)]
    pub remote_executor_addresses: Vec<SocketAddr>,

    #[clap(long)]
    pub coordinator_address: SocketAddr,
}
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service/src/config.rs (L32-39)
```rust
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct TlsConfig {
    /// The address for the TLS GRPC server to listen on.
    pub data_service_grpc_listen_address: SocketAddr,
    pub cert_path: String,
    pub key_path: String,
}
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service/src/config.rs (L215-234)
```rust
        if let Some(config) = &self.data_service_grpc_tls_config {
            let listen_address = config.data_service_grpc_listen_address;
            let cert = tokio::fs::read(config.cert_path.clone()).await?;
            let key = tokio::fs::read(config.key_path.clone()).await?;
            let identity = tonic::transport::Identity::from_pem(cert, key);
            tracing::info!(
                grpc_address = listen_address.to_string().as_str(),
                "[Data Service] Starting gRPC server with TLS."
            );
            tasks.push(tokio::spawn(async move {
                Server::builder()
                    .http2_keepalive_interval(Some(HTTP2_PING_INTERVAL_DURATION))
                    .http2_keepalive_timeout(Some(HTTP2_PING_TIMEOUT_DURATION))
                    .tls_config(tonic::transport::ServerTlsConfig::new().identity(identity))?
                    .add_service(svc)
                    .add_service(reflection_service)
                    .serve(listen_address)
                    .await
                    .map_err(|e| anyhow::anyhow!(e))
            }));
```
