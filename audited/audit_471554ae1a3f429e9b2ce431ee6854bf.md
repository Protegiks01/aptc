# Audit Report

## Title
Sequence Number Reset Race Condition in Faucet Leading to Stale Value Assignment

## Summary
The `update_sequence_numbers()` function in the faucet contains a race condition where multiple threads can detect expired transactions and attempt to reset the sequence number. While a double-check pattern prevents multiple resets, it allows one thread to reset based on stale blockchain data, causing the LocalAccount sequence number to be set behind the actual blockchain state. [1](#0-0) 

## Finding Description

The vulnerability occurs in the sequence number reset logic when transactions expire. The code implements a double-check pattern:

1. **First check** (line 288): Verifies if local sequence is too far ahead using `our_funder_seq` and `funder_seq`
2. **Acquire write lock** (line 290)
3. **Second check** (line 291): Re-verifies using current `funder_account.sequence_number()` and the **same** `funder_seq` variable
4. **Reset** (line 293): Sets sequence to `funder_seq` [2](#0-1) 

The critical issue: `funder_seq` is a **local variable** captured from the blockchain fetch at line 283-284. Different threads have different local copies with potentially different values. [3](#0-2) 

**Exploitation Scenario:**
- Thread A at T1: fetches `funder_seq_A = 100`, detects expiration
- Blockchain advances to 105 (other transactions processed)
- Thread B at T2: fetches `funder_seq_B = 105`, detects expiration  
- Thread A acquires lock, checks against 100, resets to 100
- Thread A releases lock
- Thread B acquires lock, checks: `100 >= 105 + 15` = FALSE, doesn't reset

**Result:** LocalAccount is now at 100, but blockchain is at 105. The account is 5 sequences behind.

**Impact on Transaction Building:**

After `update_sequence_numbers()` returns, the caller (MintFunder or TransferFunder) builds transactions using `sign_with_transaction_builder()` which increments the sequence number. [4](#0-3) 

The LocalAccount's `increment_sequence_number()` atomically increments using `fetch_add`: [5](#0-4) 

With LocalAccount at 100 but blockchain at 105:
- Next transaction uses sequence 100 → Rejected (already consumed)
- Subsequent transactions use 101-104 → All rejected
- Faucet fails until next call to `update_sequence_numbers()` corrects it [6](#0-5) 

## Impact Explanation

**Severity Assessment: High → Medium**

This qualifies as **High Severity** under "API crashes" but is actually closer to **Medium** because:

**Positive factors (High):**
- Causes faucet API to fail and return errors to users
- Exploitable by unprivileged attackers via concurrent requests
- Breaks transaction sequence number invariant

**Mitigating factors (reduces to Medium):**
- **Self-healing**: The next `update_sequence_numbers()` call fixes the inconsistency at lines 220-223
- **Limited scope**: Only affects faucet service, not blockchain consensus
- **Temporary**: Typically resolved within seconds when next request arrives
- **No fund loss**: Testnet tokens have no value
- **No consensus impact**: Doesn't affect validator operations or blockchain state

The faucet is an auxiliary service for testnet token distribution, not a consensus-critical component. While frustrating for users, this doesn't compromise blockchain security, consensus safety, or actual funds.

## Likelihood Explanation

**Likelihood: Moderate to High**

**Triggering conditions:**
1. High concurrent load with many faucet requests
2. Sustained queue of outstanding transactions (15+)
3. Transaction expiration timeout reached (30 seconds)
4. Blockchain processing transactions during the wait period

**Ease of exploitation:**
- **Simple attack**: Attacker sends burst of concurrent requests
- **No special permissions**: Any user can access faucet API
- **Repeatable**: Can be triggered repeatedly under load
- **Natural occurrence**: Can happen organically during high usage

**Frequency in production:**
- Testnet faucets experience high load regularly
- Multiple concurrent users are common
- 30-second timeout is reasonable duration for race window

## Recommendation

**Solution: Refresh blockchain sequence number before reset**

Fetch the latest blockchain sequence number inside the write lock, immediately before the reset:

```rust
// If after 30 seconds we still have not caught up, we are likely unhealthy.
if our_funder_seq >= funder_seq + MAX_NUM_OUTSTANDING_TRANSACTIONS {
    error!("We are unhealthy, transactions have likely expired.");
    let mut funder_account = funder_account.write().await;
    
    // Refresh funder_seq inside the lock to get latest blockchain state
    let latest_funder_seq = match client.get_account(funder_account.address()).await {
        Ok(account) => account.inner().sequence_number,
        Err(_) => funder_seq, // Fall back to previous value if fetch fails
    };
    
    if funder_account.sequence_number() >= latest_funder_seq + MAX_NUM_OUTSTANDING_TRANSACTIONS {
        info!("Resetting the sequence number counter to {}", latest_funder_seq);
        funder_account.set_sequence_number(latest_funder_seq);
    } else {
        info!("Sequence number is now {} (blockchain at {}), no reset needed", 
              funder_account.sequence_number(), latest_funder_seq);
    }
}
```

This ensures the reset uses current blockchain state, preventing stale value assignment.

## Proof of Concept

```rust
// Concurrent test to trigger the race condition
#[tokio::test]
async fn test_sequence_number_reset_race() {
    use std::sync::Arc;
    use tokio::sync::RwLock;
    
    // Setup: Create faucet account with high local sequence
    let faucet = Arc::new(RwLock::new(LocalAccount::generate(&mut rng)));
    faucet.write().await.set_sequence_number(120);
    
    // Simulate blockchain at sequence 100
    let client = create_test_client_with_mock_sequence(100);
    
    // Spawn Thread A - will fetch blockchain seq 100
    let faucet_a = Arc::clone(&faucet);
    let client_a = client.clone();
    let handle_a = tokio::spawn(async move {
        // Simulate expiration detection
        tokio::time::sleep(Duration::from_millis(100)).await;
        update_sequence_numbers(&client_a, &faucet_a, ...).await
    });
    
    // Advance blockchain to 105 (simulate other transactions)
    client.advance_sequence_to(105);
    
    // Spawn Thread B - will fetch blockchain seq 105  
    let faucet_b = Arc::clone(&faucet);
    let client_b = client.clone();
    let handle_b = tokio::spawn(async move {
        tokio::time::sleep(Duration::from_millis(150)).await;
        update_sequence_numbers(&client_b, &faucet_b, ...).await
    });
    
    // Wait for both threads
    let _ = tokio::join!(handle_a, handle_b);
    
    // Verify: Sequence should be 105, but race causes it to be 100
    let final_seq = faucet.read().await.sequence_number();
    assert_eq!(final_seq, 100); // Demonstrates the bug: should be 105
    
    // Verify impact: Next transaction will fail
    let next_txn = build_transaction(&faucet, 100).await;
    let result = client.submit(&next_txn).await;
    assert!(result.is_err()); // Fails with "sequence number too old"
}
```

**Expected behavior without fix:** Test shows LocalAccount at 100 when blockchain is at 105, causing transaction failures.

**Expected behavior with fix:** LocalAccount correctly set to 105, transactions succeed.

---

## Notes

This vulnerability is **real but limited in scope**. The double-check pattern successfully prevents multiple simultaneous resets, but doesn't prevent reset to stale values. The self-healing mechanism at the function's start provides defense-in-depth, limiting impact duration. 

For a production-critical component, this would be Critical severity. For a testnet faucet service, it's Medium severity - a legitimate bug worth fixing, but not a blockchain security emergency.

### Citations

**File:** crates/aptos-faucet/core/src/funder/common.rs (L220-223)
```rust
        if funder_seq > funder_account.sequence_number() {
            funder_account.set_sequence_number(funder_seq);
        }
        funder_account.sequence_number()
```

**File:** crates/aptos-faucet/core/src/funder/common.rs (L282-284)
```rust
        tokio::time::sleep(tokio::time::Duration::from_millis(500)).await;
        (funder_seq, receiver_seq) =
            get_sequence_numbers(client, funder_account, receiver_address).await?;
```

**File:** crates/aptos-faucet/core/src/funder/common.rs (L287-297)
```rust
    // If after 30 seconds we still have not caught up, we are likely unhealthy.
    if our_funder_seq >= funder_seq + MAX_NUM_OUTSTANDING_TRANSACTIONS {
        error!("We are unhealthy, transactions have likely expired.");
        let funder_account = funder_account.write().await;
        if funder_account.sequence_number() >= funder_seq + MAX_NUM_OUTSTANDING_TRANSACTIONS {
            info!("Resetting the sequence number counter.");
            funder_account.set_sequence_number(funder_seq);
        } else {
            info!("Someone else reset the sequence number counter ahead of us.");
        }
    }
```

**File:** crates/aptos-faucet/core/src/funder/mint.rs (L433-495)
```rust
        let txn = {
            let faucet_account = self.get_asset_account(asset_name)?.write().await;

            let payload = match &asset_config.transaction_method {
                TransactionMethod::EntryFunction(entry_function_id) => {
                    // Create ModuleId from module_address and module_name
                    let module_id = ModuleId::new(
                        entry_function_id.module_address,
                        Identifier::new(entry_function_id.module_name.as_str()).map_err(|e| {
                            AptosTapError::new(
                                format!(
                                    "Invalid module_name '{}': {}",
                                    entry_function_id.module_name, e
                                ),
                                AptosTapErrorCode::InvalidRequest,
                            )
                        })?,
                    );

                    // Create function identifier
                    let function_identifier =
                        Identifier::new(entry_function_id.function_name.as_str()).map_err(|e| {
                            AptosTapError::new(
                                format!(
                                    "Invalid function_name '{}': {}",
                                    entry_function_id.function_name, e
                                ),
                                AptosTapErrorCode::InvalidRequest,
                            )
                        })?;

                    // Serialize arguments (receiver_address and amount)
                    use aptos_sdk::bcs;
                    let args = vec![
                        bcs::to_bytes(&receiver_address).map_err(|e| {
                            AptosTapError::new(
                                format!("Failed to serialize receiver_address: {}", e),
                                AptosTapErrorCode::InvalidRequest,
                            )
                        })?,
                        bcs::to_bytes(&amount).map_err(|e| {
                            AptosTapError::new(
                                format!("Failed to serialize amount: {}", e),
                                AptosTapErrorCode::InvalidRequest,
                            )
                        })?,
                    ];

                    let entry_function =
                        EntryFunction::new(module_id, function_identifier, vec![], args);

                    TransactionPayload::EntryFunction(entry_function)
                },
                TransactionMethod::Script => {
                    // Default script-based approach
                    TransactionPayload::Script(Script::new(MINTER_SCRIPT.to_vec(), vec![], vec![
                        TransactionArgument::Address(receiver_address),
                        TransactionArgument::U64(amount),
                    ]))
                },
            };

            faucet_account.sign_with_transaction_builder(transaction_factory.payload(payload))
```

**File:** sdk/src/types.rs (L546-548)
```rust
    pub fn increment_sequence_number(&self) -> u64 {
        self.sequence_number.fetch_add(1, Ordering::SeqCst)
    }
```
