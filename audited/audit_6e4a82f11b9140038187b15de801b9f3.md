# Audit Report

## Title
Round Reuse Violation: Validators Can Derive Multiple Decryption Key Shares for the Same Round via Sync Path

## Summary
A validator can be tricked into deriving multiple decryption key shares for the same round with different digests by exploiting the block synchronization path. The sync path bypasses the `UnequivocalProposerElection` check, allowing equivocal blocks to be inserted and processed. Each inserted block triggers independent pipeline execution that derives a new key share BEFORE the `SecretShareStore` validation occurs, violating the critical security invariant stated in the batch encryption traits.

## Finding Description

The security comment in the batch encryption traits explicitly states: "For security to hold, validators must only generate a single decryption key corresponding to a round number." [1](#0-0) 

However, this invariant can be violated through the following attack path:

**Normal Proposal Path (First Block):**
When a block is received through normal consensus, it passes through the `UnequivocalProposerElection` validation: [2](#0-1) 

This check maintains local state to reject duplicate proposals for the same round: [3](#0-2) 

After passing validation, the block is inserted and a pipeline is built: [4](#0-3) 

**Sync Path Bypass (Second Block):**
However, when blocks are retrieved through synchronization, they bypass the `is_valid_proposal` check entirely: [5](#0-4) 

The `BlockTree.insert_block` function allows multiple blocks for the same round, only logging a warning: [6](#0-5) 

**Pipeline Execution and Key Derivation:**
Each inserted block triggers independent pipeline construction: [7](#0-6) 

The pipeline spawns a `decrypt_encrypted_txns` task for each block: [8](#0-7) 

Critically, the key share derivation occurs BEFORE any storage validation: [9](#0-8) 

The actual cryptographic operation happens here: [10](#0-9) 

**Store Validation Happens Too Late:**
The `SecretShareStore` validation only occurs after the key share has already been derived: [11](#0-10) 

The store check prevents ADDING a duplicate share but not DERIVING it: [12](#0-11) 

**Attack Scenario:**
1. Byzantine validator creates Block A and Block B for round R with different ciphertexts (C1 and C2)
2. Block A is proposed normally to Validator Alice → passes validation → pipeline built → derives key share for digest(C1, R)
3. Block B is sent to Validator Bob (equivocation by Byzantine proposer)
4. Alice later syncs with Bob and retrieves Block B through the sync path
5. Block B bypasses `is_valid_proposal` check → inserted into BlockTree → pipeline built
6. Alice's validator derives a second key share for digest(C2, R) using the same master secret key
7. **Invariant violated:** Alice has now derived two different decryption key shares for the same round R

## Impact Explanation

This is a **Critical** severity vulnerability per the Aptos bug bounty program because it breaks a fundamental cryptographic security guarantee of the batch threshold encryption scheme.

The batch encryption scheme relies on the property that each validator derives exactly one decryption key share per round. Violating this allows an attacker to:

1. **Compromise the threshold encryption scheme**: Multiple key shares for the same round but different digests can potentially be used to break the security of the encrypted transactions
2. **Enable selective decryption attacks**: An attacker who controls which digest gets aggregated could decrypt different sets of transactions
3. **Violate consensus safety assumptions**: The encrypted transaction system assumes deterministic decryption, but multiple key shares for the same round breaks this property

This meets the "Consensus/Safety violations" category for Critical severity, potentially affecting the integrity of the encrypted transaction system that Aptos uses for MEV resistance and transaction privacy.

## Likelihood Explanation

**High Likelihood** - This vulnerability can be triggered under normal network conditions:

1. **Byzantine validator required**: Only requires a single Byzantine validator (which is within the <1/3 Byzantine tolerance assumption)
2. **Natural occurrence**: Block equivocation can happen through the sync mechanism whenever validators receive different blocks for the same round
3. **No special privileges needed**: The attack exploits normal sync operations that occur regularly in consensus
4. **No race conditions required**: The vulnerability is deterministic based on the code paths

The attack is feasible because:
- Byzantine validators can equivocate (propose different blocks for the same round to different peers)
- The sync mechanism is a normal part of consensus operation
- No coordination between multiple attackers is required

## Recommendation

Implement proper round-based deduplication checks BEFORE pipeline construction and key derivation:

**Solution 1: Check in Pipeline Builder**
Add a check in `insert_block_inner` to prevent building pipelines for blocks with rounds that already have active pipelines:

```rust
// In block_store.rs, insert_block_inner():
if let Some(pipeline_builder) = &self.pipeline_builder {
    // Check if we already have a pipeline for this round
    if let Some(existing_block) = self.inner.read().get_block_for_round(pipelined_block.round()) {
        if existing_block.id() != pipelined_block.id() {
            warn!(
                "Refusing to build pipeline for equivocal block at round {}: existing {}, new {}",
                pipelined_block.round(),
                existing_block.id(),
                pipelined_block.id()
            );
            // Return without building pipeline
            return Ok(Arc::new(pipelined_block));
        }
    }
    // ... continue with pipeline building
}
```

**Solution 2: Add Validation in decrypt_encrypted_txns**
Add a check at the beginning of `decrypt_encrypted_txns` to verify this is the only block being processed for this round:

```rust
// In decryption_pipeline_builder.rs:
pub(crate) async fn decrypt_encrypted_txns(...) -> TaskResult<DecryptionResult> {
    // Check if we should derive a key share for this round
    if let Some(secret_share_config) = &secret_share_config {
        // Query if we already have a derived share for this round
        // If yes, skip derivation and use existing share
    }
    // ... continue with existing logic
}
```

**Solution 3: Extend UnequivocalProposerElection to Sync Path**
Apply the equivocation check to all block insertions, not just proposals:

```rust
// In block_store.rs:
pub async fn insert_block(&self, block: Block) -> anyhow::Result<Arc<PipelinedBlock>> {
    // Add validation for all insertions
    if let Some(proposer_election) = &self.proposer_election {
        ensure!(
            proposer_election.is_valid_proposal(&block),
            "Block validation failed: possible equivocation for round {}",
            block.round()
        );
    }
    // ... continue with existing logic
}
```

## Proof of Concept

```rust
// Rust integration test demonstrating the vulnerability
#[tokio::test]
async fn test_round_reuse_via_sync() {
    // Setup: Create two blocks for the same round with different ciphertexts
    let round = 100;
    let epoch = 1;
    
    // Block A with ciphertext set C1
    let block_a = create_test_block(round, epoch, vec![ciphertext_1]);
    
    // Block B with different ciphertext set C2 (equivocation)
    let block_b = create_test_block(round, epoch, vec![ciphertext_2]);
    
    // Validator processes Block A through normal path
    round_manager.process_proposal(block_a.clone()).await.unwrap();
    
    // Verify first key share was derived
    let shares_after_first = get_derived_shares_for_round(&secret_share_store, round);
    assert_eq!(shares_after_first.len(), 1);
    let first_digest = shares_after_first[0].metadata.digest.clone();
    
    // Simulate sync: Insert Block B through sync path
    block_store.insert_block(block_b.clone()).await.unwrap();
    
    // Wait for pipeline to execute
    tokio::time::sleep(Duration::from_millis(100)).await;
    
    // Vulnerability: Second key share was derived for the same round
    let shares_after_second = get_all_derived_shares_for_round(round);
    assert_eq!(shares_after_second.len(), 2); // Two derivations occurred!
    
    let second_digest = shares_after_second[1].digest.clone();
    assert_ne!(first_digest, second_digest); // Different digests!
    
    // Both derivations used the same master secret key share
    // This violates the security invariant
    println!("Vulnerability confirmed: Derived {} key shares for round {}", 
             shares_after_second.len(), round);
}
```

**Notes**
- The vulnerability exploits the asynchronous nature of pipeline execution where key derivation happens before storage validation
- The sync path is a legitimate code path that validators use during normal operation to fetch missing blocks
- Byzantine validators can exploit this by equivocating (sending different blocks for the same round to different validators)
- The fix requires adding round-based deduplication checks at the pipeline construction level, not just at the storage level

### Citations

**File:** crates/aptos-batch-encryption/src/traits.rs (L30-31)
```rust
    /// The round number used when generating a digest. For security to hold, validators must only
    /// generate a single decryption key corresponding to a round number.
```

**File:** consensus/src/round_manager.rs (L1195-1200)
```rust
        ensure!(
            self.proposer_election.is_valid_proposal(&proposal),
            "[RoundManager] Proposer {} for block {} is not a valid proposer for this round or created duplicate proposal",
            author,
            proposal,
        );
```

**File:** consensus/src/round_manager.rs (L1256-1259)
```rust
        self.block_store
            .insert_block(proposal.clone())
            .await
            .context("[RoundManager] Failed to insert the block into BlockStore")?;
```

**File:** consensus/src/liveness/unequivocal_proposer_election.rs (L63-86)
```rust
            match block.round().cmp(&already_proposed.0) {
                Ordering::Greater => {
                    already_proposed.0 = block.round();
                    already_proposed.1 = block.id();
                    true
                },
                Ordering::Equal => {
                    if already_proposed.1 != block.id() {
                        error!(
                            SecurityEvent::InvalidConsensusProposal,
                            "Multiple proposals from {} for round {}: {} and {}",
                            author,
                            block.round(),
                            already_proposed.1,
                            block.id()
                        );
                        false
                    } else {
                        true
                    }
                },
                Ordering::Less => false,
            }
        })
```

**File:** consensus/src/block_storage/sync_manager.rs (L264-268)
```rust
        while let Some(block) = pending.pop() {
            let block_qc = block.quorum_cert().clone();
            self.insert_single_quorum_cert(block_qc)?;
            self.insert_block(block).await?;
        }
```

**File:** consensus/src/block_storage/block_tree.rs (L326-335)
```rust
            // Note: the assumption is that we have/enforce unequivocal proposer election.
            if let Some(old_block_id) = self.round_to_ids.get(&arc_block.round()) {
                warn!(
                    "Multiple blocks received for round {}. Previous block id: {}",
                    arc_block.round(),
                    old_block_id
                );
            } else {
                self.round_to_ids.insert(arc_block.round(), block_id);
            }
```

**File:** consensus/src/block_storage/block_store.rs (L463-497)
```rust
        // build pipeline
        if let Some(pipeline_builder) = &self.pipeline_builder {
            let parent_block = self
                .get_block(pipelined_block.parent_id())
                .ok_or_else(|| anyhow::anyhow!("Parent block not found"))?;

            // need weak pointer to break the cycle between block tree -> pipeline block -> callback
            let block_tree = Arc::downgrade(&self.inner);
            let storage = self.storage.clone();
            let id = pipelined_block.id();
            let round = pipelined_block.round();
            let window_size = self.window_size;
            let callback = Box::new(
                move |finality_proof: WrappedLedgerInfo,
                      commit_decision: LedgerInfoWithSignatures| {
                    if let Some(tree) = block_tree.upgrade() {
                        tree.write().commit_callback(
                            storage,
                            id,
                            round,
                            finality_proof,
                            commit_decision,
                            window_size,
                        );
                    }
                },
            );
            pipeline_builder.build_for_consensus(
                &pipelined_block,
                parent_block.pipeline_futs().ok_or_else(|| {
                    anyhow::anyhow!("Parent future doesn't exist, potentially epoch ended")
                })?,
                callback,
            );
        }
```

**File:** consensus/src/pipeline/pipeline_builder.rs (L461-471)
```rust
        let decryption_fut = spawn_shared_fut(
            Self::decrypt_encrypted_txns(
                materialize_fut,
                block.clone(),
                self.signer.author(),
                self.secret_share_config.clone(),
                derived_self_key_share_tx,
                secret_shared_key_rx,
            ),
            Some(&mut abort_handles),
        );
```

**File:** consensus/src/pipeline/decryption_pipeline_builder.rs (L91-110)
```rust
        let encryption_round = block.round();
        let (digest, proofs_promise) =
            FPTXWeighted::digest(&digest_key, &txn_ciphertexts, encryption_round)?;

        let metadata = SecretShareMetadata::new(
            block.epoch(),
            block.round(),
            block.timestamp_usecs(),
            block.id(),
            digest.clone(),
        );

        let derived_key_share = FPTXWeighted::derive_decryption_key_share(&msk_share, &digest)?;
        derived_self_key_share_tx
            .send(Some(SecretShare::new(
                author,
                metadata.clone(),
                derived_key_share,
            )))
            .expect("must send properly");
```

**File:** crates/aptos-batch-encryption/src/shared/key_derivation.rs (L107-115)
```rust
    pub fn derive_decryption_key_share(&self, digest: &Digest) -> Result<BIBEDecryptionKeyShare> {
        let hashed_encryption_key: G1Affine = symmetric::hash_g2_element(self.mpk_g2)?;

        Ok((self.player, BIBEDecryptionKeyShareValue {
            signature_share_eval: G1Affine::from(
                (digest.as_g1() + hashed_encryption_key) * self.shamir_share_eval,
            ),
        }))
    }
```

**File:** consensus/src/rand/secret_sharing/secret_share_manager.rs (L134-148)
```rust
        let self_secret_share = futures
            .secret_sharing_derive_self_fut
            .await
            .expect("Decryption share computation is expected to succeed")
            .expect("Must not be None");
        let metadata = self_secret_share.metadata().clone();

        // Now acquire lock and update store
        {
            let mut secret_share_store = self.secret_share_store.lock();
            secret_share_store.update_highest_known_round(block.round());
            secret_share_store
                .add_self_share(self_secret_share.clone())
                .expect("Add self dec share should succeed");
        }
```

**File:** consensus/src/rand/secret_sharing/secret_share_store.rs (L175-177)
```rust
            SecretShareItem::PendingDecision { .. } => {
                bail!("Cannot add self share in PendingDecision state");
            },
```
