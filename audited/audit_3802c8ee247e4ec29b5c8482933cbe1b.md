Audit Report

## Title
Critical Consensus Safety Break via Timeout Certificate Highest HQC Round Forgery

## Summary
Aptos Core's Two-Chain Safety Rules accept Timeout Certificates (TCs) whose highest_hqc_round can be artificially set to a stale value, enabling malicious proposers to bypass fundamental voting safety rules. This allows voting to extend blocks that are built atop older quorum certificates, despite the validator locally knowing a much higher certified round—violating core AptosBFT safety invariants and enabling consensus forks.

## Finding Description
The cross-function validation between `verify_tc` and `safe_to_vote` in `consensus/safety-rules/src/safety_rules_2chain.rs` is insufficient. While `verify_tc` checks the cryptographic integrity and internal consistency of the TC (valid signatures, highest HQC among the aggregated timeouts), it does **not** validate that the TC’s `highest_hqc_round` is at least as recent as the local safety state’s `one_chain_round` (the highest round for which the validator has seen a QC).

`safe_to_vote` then allows voting if any of these hold:
- block.round == block.qc.round + 1
- block.round == tc.round + 1 && block.qc.round >= tc.highest_hqc_round

Without linking TC's `highest_hqc_round` to the local known round, a malicious proposer can present an otherwise valid TC for round N, with artificially stale highest_hqc_round, and a new proposal with block.qc.round >= tc.highest_hqc_round, but **lower than** the validator's own latest QC round.

As a result, the validator may incorrectly vote to extend a stale fork, even if it knows of a much more recent commit. This directly breaks consensus safety.

## Impact Explanation
This is a **critical consensus violation**. It enables an attacker (with control of 2f+1 voting power to create malicious TCs) to partition honest validators, cause chain splits, and violate the “at-most one committed block per height” property—precisely the core safety guarantee of AptosBFT.

Anyone able to produce TCs (e.g., by colluding with a threshold of validators, or replaying staler TCs) can exploit this to make target validators equivocate or build on forks, which will later lead to a network-wide safety crisis and possible hard fork to recover.

## Likelihood Explanation
All that is required is that a malicious proposer collects signatures for timeouts from a crypto-valid set of authorities but aggregates only stale HQC data (i.e., old quorum certs) from a subset. There are no checks in place to ensure this data is consistent with what the honest validator locally knows (`one_chain_round`), so the attack can be conducted by a remote malicious actor or coalition of 2f+1 compromised validators.

## Recommendation
Add a contextual safety check when voting (either in `verify_tc` or, more properly, in `safe_to_vote`): the TC’s `highest_hqc_round()` must be at least as large as the safety data’s `one_chain_round`. This mirrors the additional safety invariant already enforced in safe_to_timeout.

Example fix:
```rust
let safety_data = self.persistent_storage.safety_data()?;
if let Some(tc) = maybe_tc {
    if tc.highest_hqc_round() < safety_data.one_chain_round {
        return Err(Error::TCStaleRelativeToOneChain(tc.highest_hqc_round(), safety_data.one_chain_round));
    }
}
```

## Proof of Concept

1. Assume a validator node V has seen a QC for round 100 (`one_chain_round=100`).
2. Malicious coalition creates a TC for round 101, but the highest HQC recorded in the TC is only round 50 (because they aggregate only from signers with stale QCs or construct fraudulent evidence).
3. Proposer creates a new proposal at round 102, with a block QC for round 60 (>=50), and the stale TC.
4. V receives this and, per current rules, will consider it "safe to vote" and issue a vote at round 102, building atop a block chain rooted at round 60, **despite knowing a valid certified chain at round 100**.

This exploit can be reproduced in Rust by instrumenting the safety rules as above and verifying this acceptance path—demonstrating consensus fork or equivocation.

---

## Citations [1](#0-0) [2](#0-1) [3](#0-2) [4](#0-3) [5](#0-4) [6](#0-5)

### Citations

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L121-145)
```rust
    /// Core safety timeout rule for 2-chain protocol. Return success if 1 and 2 are true
    /// 1. round == timeout.qc.round + 1 || round == tc.round + 1
    /// 2. timeout.qc.round >= one_chain_round
    fn safe_to_timeout(
        &self,
        timeout: &TwoChainTimeout,
        maybe_tc: Option<&TwoChainTimeoutCertificate>,
        safety_data: &SafetyData,
    ) -> Result<(), Error> {
        let round = timeout.round();
        let qc_round = timeout.hqc_round();
        let tc_round = maybe_tc.map_or(0, |tc| tc.round());
        if (round == next_round(qc_round)? || round == next_round(tc_round)?)
            && qc_round >= safety_data.one_chain_round
        {
            Ok(())
        } else {
            Err(Error::NotSafeToTimeout(
                round,
                qc_round,
                tc_round,
                safety_data.one_chain_round,
            ))
        }
    }
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L150-166)
```rust
    fn safe_to_vote(
        &self,
        block: &Block,
        maybe_tc: Option<&TwoChainTimeoutCertificate>,
    ) -> Result<(), Error> {
        let round = block.round();
        let qc_round = block.quorum_cert().certified_block().round();
        let tc_round = maybe_tc.map_or(0, |tc| tc.round());
        let hqc_round = maybe_tc.map_or(0, |tc| tc.highest_hqc_round());
        if round == next_round(qc_round)?
            || (round == next_round(tc_round)? && qc_round >= hqc_round)
        {
            Ok(())
        } else {
            Err(Error::NotSafeToVote(round, qc_round, tc_round, hqc_round))
        }
    }
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L180-188)
```rust
    fn verify_tc(&self, tc: &TwoChainTimeoutCertificate) -> Result<(), Error> {
        let epoch_state = self.epoch_state()?;

        if !self.skip_sig_verify {
            tc.verify(&epoch_state.verifier)
                .map_err(|e| Error::InvalidTimeoutCertificate(e.to_string()))?;
        }
        Ok(())
    }
```

**File:** consensus-types/src/timeout_2chain.rs (L141-183)
```rust

```

**File:** consensus/consensus-types/src/safety_data.rs (L10-41)
```rust
pub struct SafetyData {
    pub epoch: u64,
    pub last_voted_round: u64,
    // highest 2-chain round, used for 3-chain
    pub preferred_round: u64,
    // highest 1-chain round, used for 2-chain
    #[serde(default)]
    pub one_chain_round: u64,
    pub last_vote: Option<Vote>,
    #[serde(default)]
    pub highest_timeout_round: u64,
}

impl SafetyData {
    pub fn new(
        epoch: u64,
        last_voted_round: u64,
        preferred_round: u64,
        one_chain_round: u64,
        last_vote: Option<Vote>,
        highest_timeout_round: u64,
    ) -> Self {
        Self {
            epoch,
            last_voted_round,
            preferred_round,
            one_chain_round,
            last_vote,
            highest_timeout_round,
        }
    }
}
```

**File:** consensus/safety-rules/src/safety_rules.rs (L213-232)
```rust
    pub(crate) fn verify_and_update_last_vote_round(
        &self,
        round: Round,
        safety_data: &mut SafetyData,
    ) -> Result<(), Error> {
        if round <= safety_data.last_voted_round {
            return Err(Error::IncorrectLastVotedRound(
                round,
                safety_data.last_voted_round,
            ));
        }

        safety_data.last_voted_round = round;
        trace!(
            SafetyLogSchema::new(LogEntry::LastVotedRound, LogEvent::Update)
                .last_voted_round(safety_data.last_voted_round)
        );

        Ok(())
    }
```
