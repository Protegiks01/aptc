# Audit Report

## Title
Rosetta API Error Handler Returns Non-Compliant Responses Enabling Client Retry Loop DoS

## Summary
The `handle_rejection()` function in the Aptos Rosetta API returns error responses that violate the Rosetta API specification. Instead of returning properly formatted Rosetta errors with a `retriable` boolean field, it returns generic HTTP 500 errors in an incompatible format. This causes Rosetta clients to fail parsing error responses and potentially enter infinite retry loops, leading to resource exhaustion and distributed DoS against Rosetta infrastructure. [1](#0-0) 

## Finding Description

The Rosetta API specification requires all error responses to follow a specific format with mandatory fields including `code` (u32), `message` (String), and `retriable` (bool). The Aptos Rosetta implementation correctly defines this error structure: [2](#0-1) 

However, the `handle_rejection()` function catches ALL warp framework rejections (including client errors like malformed JSON, invalid Content-Type, method not allowed, etc.) and incorrectly converts them to the `aptos_warp_webserver::Error` format instead of the Rosetta `Error` format: [3](#0-2) 

This creates a critical mismatch. The Rosetta error format has a `retriable` field, while the `aptos_warp_webserver::Error` does not. Furthermore, all rejections are converted to HTTP 500 (Internal Server Error) regardless of whether they are client errors (4xx) or server errors (5xx).

**Attack Path:**

1. Attacker sends malformed requests to Rosetta endpoints (invalid JSON body, wrong Content-Type header, invalid HTTP method, oversized payload, etc.)
2. Warp framework generates built-in rejections: `BodyDeserializeError`, `UnsupportedMediaType`, `MethodNotAllowed`, `PayloadTooLarge`, etc.
3. The `.recover(handle_rejection)` filter catches these rejections
4. `handle_rejection()` returns HTTP 500 with `aptos_warp_webserver::Error` format lacking the `retriable` field
5. Rosetta clients receive non-compliant error responses that don't match the expected schema
6. Clients cannot parse errors properly or determine if they should retry
7. Clients default to retrying on HTTP 500 status codes (common behavior for server errors)
8. Since the underlying issue is persistent (malformed request will always fail the same way), clients retry indefinitely
9. Multiple affected clients create sustained load on Rosetta nodes, causing resource exhaustion and service degradation

**Comparison with Correct Implementation:**

The aptos-telemetry-service demonstrates the correct pattern for handling rejections: [4](#0-3) 

This implementation properly:
- Extracts specific rejection types using `err.find::<T>()`
- Returns appropriate HTTP status codes (400 for client errors, 500 for server errors)
- Maintains consistent error response format

The Rosetta implementation should follow this pattern to properly handle rejections and return spec-compliant error responses with the `retriable` field.

## Impact Explanation

This vulnerability qualifies as **Medium severity** under the Aptos bug bounty program for several reasons:

1. **API Availability Impact**: The Rosetta API is critical infrastructure used by exchanges, block explorers, and analytics services. Degradation or unavailability affects the entire ecosystem's ability to interact with the Aptos blockchain.

2. **Resource Exhaustion**: Clients entering retry loops consume both client-side and server-side resources, potentially exhausting connection limits, memory, and CPU on Rosetta nodes.

3. **Distributed Nature**: Multiple independent clients affected simultaneously create a distributed DoS effect, amplifying the impact.

4. **Specification Violation**: The Rosetta API spec requires proper error formatting to enable client decision-making. Violating this breaks the protocol contract that clients depend on.

While this is an application-level availability issue rather than a consensus or state integrity violation, it meets Medium severity criteria as "state inconsistencies requiring intervention" (service availability requiring operational intervention to restore).

## Likelihood Explanation

**Likelihood: HIGH**

The vulnerability is highly likely to be exploited because:

1. **Zero Authentication Required**: Rosetta API endpoints are publicly accessible without authentication
2. **Trivial Exploitation**: Sending malformed requests requires no specialized knowledge or tools
3. **Common Client Behavior**: Many HTTP clients and libraries default to retrying on 5xx errors
4. **No Rate Limiting**: The codebase shows no rate limiting on Rosetta endpoints: [5](#0-4) 

5. **Unintentional Triggers**: Even legitimate clients with bugs could accidentally trigger this by sending malformed requests

## Recommendation

Rewrite `handle_rejection()` to properly handle different rejection types and return Rosetta-compliant error responses:

```rust
async fn handle_rejection(err: Rejection) -> Result<impl Reply, Infallible> {
    debug!("Failed with: {:?}", err);
    
    let api_error = if let Some(api_err) = err.find::<ApiError>() {
        // ApiError was properly raised from handler
        api_err.clone()
    } else if err.is_not_found() {
        ApiError::InvalidInput(Some("Endpoint not found".to_string()))
    } else if let Some(_) = err.find::<warp::reject::MethodNotAllowed>() {
        ApiError::InvalidInput(Some("Method not allowed".to_string()))
    } else if let Some(cause) = err.find::<warp::body::BodyDeserializeError>() {
        ApiError::DeserializationFailed(Some(cause.to_string()))
    } else if let Some(_) = err.find::<warp::reject::UnsupportedMediaType>() {
        ApiError::InvalidInput(Some("Unsupported media type".to_string()))
    } else if let Some(_) = err.find::<warp::reject::PayloadTooLarge>() {
        ApiError::InvalidInput(Some("Payload too large".to_string()))
    } else if let Some(_) = err.find::<warp::reject::LengthRequired>() {
        ApiError::InvalidInput(Some("Length required".to_string()))
    } else if let Some(cause) = err.find::<warp::reject::InvalidHeader>() {
        ApiError::InvalidInput(Some(cause.to_string()))
    } else {
        // Unknown rejection type - treat as internal error
        ApiError::InternalError(Some(format!("Unexpected error: {:?}", err)))
    };
    
    // Convert to Rosetta Error format with retriable field
    let status = api_error.status_code();
    let rosetta_error = api_error.into_error();
    let body = reply::json(&rosetta_error);
    let mut rep = reply::with_status(body, status).into_response();
    rep.headers_mut()
        .insert("access-control-allow-origin", HeaderValue::from_static("*"));
    Ok(rep)
}
```

Additionally, consider implementing rate limiting to prevent abuse of the API.

## Proof of Concept

```bash
# Test 1: Send malformed JSON body
curl -X POST http://localhost:8080/account/balance \
  -H "Content-Type: application/json" \
  -d '{invalid json'

# Expected current behavior:
# HTTP 500 with {"code": 500, "message": "unexpected error: ..."}
# Missing "retriable" field, client cannot determine if retry is appropriate

# Test 2: Send wrong content type
curl -X POST http://localhost:8080/account/balance \
  -H "Content-Type: text/plain" \
  -d 'some text'

# Expected current behavior:
# HTTP 500 for what should be HTTP 415 (Unsupported Media Type)

# Test 3: Use wrong HTTP method
curl -X DELETE http://localhost:8080/account/balance

# Expected current behavior:
# HTTP 500 for what should be HTTP 405 (Method Not Allowed)

# All of these return HTTP 500 (retriable server error) instead of
# HTTP 4xx (non-retriable client error), causing clients to retry
# indefinitely on requests that will never succeed.
```

To simulate the client retry loop impact:
```bash
# Attacker script to trigger continuous retry loops
for i in {1..1000}; do
  curl -X POST http://localhost:8080/account/balance \
    -H "Content-Type: application/json" \
    -d '{malformed' &
done
# This creates 1000 concurrent malformed requests
# Each causes a 500 error, clients retry, creating sustained load
```

## Notes

The vulnerability is specific to how warp framework rejections are handled in the Rosetta API layer. The core ApiError types are correctly defined with the `retriable` field, but the integration point with warp's rejection system bypasses this proper error formatting. The telemetry service in the same codebase demonstrates the correct implementation pattern that should be adopted.

### Citations

**File:** crates/aptos-rosetta/src/lib.rs (L163-189)
```rust
/// Collection of all routes for the server
pub fn routes(
    context: RosettaContext,
) -> impl Filter<Extract = (impl Reply,), Error = Infallible> + Clone {
    account::routes(context.clone())
        .or(block::block_route(context.clone()))
        .or(construction::combine_route(context.clone()))
        .or(construction::derive_route(context.clone()))
        .or(construction::hash_route(context.clone()))
        .or(construction::metadata_route(context.clone()))
        .or(construction::parse_route(context.clone()))
        .or(construction::payloads_route(context.clone()))
        .or(construction::preprocess_route(context.clone()))
        .or(construction::submit_route(context.clone()))
        .or(network::list_route(context.clone()))
        .or(network::options_route(context.clone()))
        .or(network::status_route(context.clone()))
        .or(health_check_route(context))
        .with(
            warp::cors()
                .allow_any_origin()
                .allow_methods(vec![Method::GET, Method::POST])
                .allow_headers(vec![warp::http::header::CONTENT_TYPE]),
        )
        .with(logger())
        .recover(handle_rejection)
}
```

**File:** crates/aptos-rosetta/src/lib.rs (L192-202)
```rust
async fn handle_rejection(err: Rejection) -> Result<impl Reply, Infallible> {
    debug!("Failed with: {:?}", err);
    let body = reply::json(&Error::new(
        StatusCode::INTERNAL_SERVER_ERROR,
        format!("unexpected error: {:?}", err),
    ));
    let mut rep = reply::with_status(body, StatusCode::INTERNAL_SERVER_ERROR).into_response();
    rep.headers_mut()
        .insert("access-control-allow-origin", HeaderValue::from_static("*"));
    Ok(rep)
}
```

**File:** crates/aptos-rosetta/src/types/misc.rs (L34-44)
```rust
pub struct Error {
    /// Error code
    pub code: u32,
    /// Message that always matches the error code
    pub message: String,
    /// Whether a call can retry on the error
    pub retriable: bool,
    /// Specific details of the error e.g. stack trace
    #[serde(skip_serializing_if = "Option::is_none")]
    pub details: Option<ErrorDetails>,
}
```

**File:** crates/aptos-warp-webserver/src/error.rs (L13-19)
```rust
pub struct Error {
    pub code: u16,
    pub message: String,
    /// Aptos blockchain latest onchain ledger version.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub aptos_ledger_version: Option<U64>,
}
```

**File:** crates/aptos-telemetry-service/src/index.rs (L88-130)
```rust
pub async fn handle_rejection(err: Rejection) -> std::result::Result<impl Reply, Infallible> {
    let code;
    let body;

    if let Some(error) = err.find::<ServiceError>() {
        code = error.http_status_code();
        body = reply::json(&ErrorResponse::from(error));

        SERVICE_ERROR_COUNTS
            .with_label_values(&[&format!("{:?}", error.error_code())])
            .inc();
    } else if err.is_not_found() {
        code = StatusCode::NOT_FOUND;
        body = reply::json(&ErrorResponse::new(code, "Not Found".to_owned()));
    } else if let Some(cause) = err.find::<BodyDeserializeError>() {
        code = StatusCode::BAD_REQUEST;
        body = reply::json(&ErrorResponse::new(code, cause.to_string()));
    } else if let Some(cause) = err.find::<InvalidHeader>() {
        code = StatusCode::BAD_REQUEST;
        body = reply::json(&ErrorResponse::new(code, cause.to_string()));
    } else if let Some(cause) = err.find::<LengthRequired>() {
        code = StatusCode::LENGTH_REQUIRED;
        body = reply::json(&ErrorResponse::new(code, cause.to_string()));
    } else if let Some(cause) = err.find::<PayloadTooLarge>() {
        code = StatusCode::PAYLOAD_TOO_LARGE;
        body = reply::json(&ErrorResponse::new(code, cause.to_string()));
    } else if let Some(cause) = err.find::<UnsupportedMediaType>() {
        code = StatusCode::UNSUPPORTED_MEDIA_TYPE;
        body = reply::json(&ErrorResponse::new(code, cause.to_string()));
    } else if let Some(cause) = err.find::<MethodNotAllowed>() {
        code = StatusCode::METHOD_NOT_ALLOWED;
        body = reply::json(&ErrorResponse::new(code, cause.to_string()));
    } else {
        code = StatusCode::INTERNAL_SERVER_ERROR;
        body = reply::json(&ErrorResponse::new(
            code,
            format!("unexpected error: {:?}", err),
        ));
    }

    debug!("returning an error with status code {}: {:?}", code, err);

    Ok(reply::with_status(body, code).into_response())
```
