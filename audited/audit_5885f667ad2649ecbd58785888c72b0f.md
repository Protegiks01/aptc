# Audit Report

## Title
OptQS Exclusion Bomb: Malicious Proposer Can Disable Optimistic Quorum Store via Fake Batch Inclusion

## Summary
A Byzantine validator acting as proposer can create an `OptQuorumStorePayload` containing fabricated batch references for all validators. This causes honest validators to report all validators as having unavailable payloads, triggering a cascading exclusion mechanism that disables OptQS's optimistic batch feature for multiple rounds, significantly degrading consensus throughput.

## Finding Description
The vulnerability exists in the interaction between payload verification, availability checking, and the failure tracking mechanism in OptQS.

**Attack Flow:**

1. **Weak Validation**: The `verify_opt_batches` function only validates that batch authors are legitimate validators, but does not verify batch existence or authenticity. [1](#0-0) 

2. **Fake Batch Creation**: A malicious proposer creates an `OptQuorumStorePayload` with `opt_batches` containing `BatchInfo` entries for all validators with non-existent digests. The payload passes verification since authors are valid.

3. **Availability Check Failure**: When honest validators receive this block, they execute `check_payload_availability`, which checks if batches exist locally via `batch_reader.exists()`. Since the digests are fake, all batches are missing, causing all validator indices to be set in the `missing_authors` BitVec. [2](#0-1) 

4. **Timeout Aggregation**: Honest validators timeout with `RoundTimeoutReason::PayloadUnavailable { missing_authors }` where all bits are set. When f+1 validators report the same missing authors, the aggregation logic preserves all bits in the aggregated timeout reason. [3](#0-2) 

5. **Exclusion Bomb**: The `ExponentialWindowFailureTracker` receives this timeout and updates its failure window. The `get_exclude_authors()` method iterates through failed rounds and adds ALL validators to the exclusion set. [4](#0-3) 

6. **OptQS Disabled**: When pulling optimistic batches, the `pull_batches` method filters out all authors from the exclusion set, resulting in empty `opt_batches`. [5](#0-4) 

7. **Prolonged Impact**: The exclusion persists for `window` consecutive successful rounds (starting at 2, doubling on each failure, up to `max_window`). The attack can be repeated whenever the Byzantine validator becomes proposer.

## Impact Explanation
This vulnerability qualifies as **High Severity** under the Aptos bug bounty program category "Validator node slowdowns" and "Significant protocol violations":

- **Performance Degradation**: OptQS's primary optimization (speculative batch inclusion without proofs) is disabled, reducing consensus throughput to only using proofs and inline batches
- **Prolonged Effect**: Exclusion persists for `window` rounds (exponentially increasing on repeated attacks), causing sustained performance degradation
- **Repeatable Attack**: Any Byzantine validator can execute this attack when they become proposer (which happens regularly in round-robin or random leader selection)
- **Network-Wide Impact**: All validators experience reduced throughput during exclusion periods
- **No Safety Violation**: Consensus safety is maintained (honest validators continue making progress), but liveness/performance is significantly degraded

## Likelihood Explanation
**Likelihood: High**

- **Attack Requirements**: Only requires being a validator and becoming proposer for a single round (no collusion needed, within < 1/3 Byzantine assumption)
- **Technical Complexity**: Low - attacker simply includes fake `BatchInfo` entries in their proposal
- **Detection Difficulty**: Attack appears as legitimate payload unavailability; distinguishing malicious fake batches from actual network issues is challenging
- **Feasibility**: Can be executed whenever Byzantine validator becomes proposer (statistically guaranteed in rotating leader protocols)

## Recommendation
Implement cryptographic proof requirements for optimistic batches to prevent fake batch inclusion:

**Option 1 - Batch Signature Verification:**
Add signature verification for `opt_batches` in `verify_opt_batches`:

```rust
pub fn verify_opt_batches<T: TBatchInfo>(
    verifier: &ValidatorVerifier,
    opt_batches: &OptBatches<T>,
) -> anyhow::Result<()> {
    let authors = verifier.address_to_validator_index();
    for batch in &opt_batches.batch_summary {
        ensure!(
            authors.contains_key(&batch.author()),
            "Invalid author {} for batch {}",
            batch.author(),
            batch.digest()
        );
        
        // NEW: Verify batch has valid signature from author
        batch.verify_signature(verifier)?;
    }
    Ok(())
}
```

**Option 2 - Minimum Voting Power Threshold:**
Modify `aggregated_timeout_reason` to require higher voting power threshold (e.g., 2f+1) before marking an author as missing, making it harder to falsely exclude honest validators.

**Option 3 - Batch Age Verification:**
Require `opt_batches` to reference batches older than a minimum age, preventing inclusion of non-existent batches that haven't had time to propagate.

## Proof of Concept

```rust
// Rust test demonstrating the vulnerability
#[test]
fn test_optqs_exclusion_bomb() {
    use aptos_bitvec::BitVec;
    use aptos_consensus_types::proof_of_store::BatchInfo;
    use aptos_types::validator_verifier::random_validator_verifier;
    
    let (signers, verifier) = random_validator_verifier(4, None, false);
    let ordered_authors = verifier.get_ordered_account_addresses();
    
    // Malicious proposer creates fake opt_batches for all validators
    let fake_batches: Vec<BatchInfo> = ordered_authors.iter()
        .map(|author| BatchInfo::new(
            *author,
            1, // epoch
            0, // batch_id
            HashValue::random(), // fake digest
            100, // num_txns
            1000, // expiration
            0, // gas_bucket
        ))
        .collect();
    
    // When validators check availability, all batches are missing
    // missing_authors BitVec will have all bits set
    let mut missing_authors = BitVec::with_num_bits(4);
    for i in 0..4 {
        missing_authors.set(i);
    }
    
    // Create timeout reason
    let timeout_reason = RoundTimeoutReason::PayloadUnavailable { missing_authors };
    
    // Push to failure tracker
    let mut tracker = ExponentialWindowFailureTracker::new(100, ordered_authors.clone());
    tracker.push(NewRoundReason::Timeout(timeout_reason));
    
    // Verify ALL validators are excluded
    let exclude_authors = tracker.get_exclude_authors();
    assert_eq!(exclude_authors.len(), 4, "All validators should be excluded");
    
    // Verify OptQS is disabled (window check fails)
    assert!(tracker.last_consecutive_success_count < tracker.window,
            "OptQS should be disabled due to window requirement");
}
```

## Notes
This vulnerability represents a **protocol-level DoS attack** rather than a consensus safety violation. While Aptos consensus continues operating correctly under this attack (maintaining safety and eventual liveness), the performance degradation is significant and can be sustained by a single Byzantine validator exploiting their proposer turns. The attack is particularly concerning because it targets an optimization mechanism designed to improve throughput, effectively weaponizing the failure recovery logic against itself.

### Citations

**File:** consensus/consensus-types/src/common.rs (L558-572)
```rust
    pub fn verify_opt_batches<T: TBatchInfo>(
        verifier: &ValidatorVerifier,
        opt_batches: &OptBatches<T>,
    ) -> anyhow::Result<()> {
        let authors = verifier.address_to_validator_index();
        for batch in &opt_batches.batch_summary {
            ensure!(
                authors.contains_key(&batch.author()),
                "Invalid author {} for batch {}",
                batch.author(),
                batch.digest()
            );
        }
        Ok(())
    }
```

**File:** consensus/src/payload_manager/quorum_store_payload_manager.rs (L409-424)
```rust
            Payload::OptQuorumStore(OptQuorumStorePayload::V1(p)) => {
                let mut missing_authors = BitVec::with_num_bits(self.ordered_authors.len() as u16);
                for batch in p.opt_batches().deref() {
                    if self.batch_reader.exists(batch.digest()).is_none() {
                        let index = *self
                            .address_to_validator_index
                            .get(&batch.author())
                            .expect("Payload author should have been verified");
                        missing_authors.set(index as u16);
                    }
                }
                if missing_authors.all_zeros() {
                    Ok(())
                } else {
                    Err(missing_authors)
                }
```

**File:** consensus/src/pending_votes.rs (L135-147)
```rust
                if matches!(reason, RoundTimeoutReason::PayloadUnavailable { .. }) {
                    let mut aggregated_bitvec = BitVec::with_num_bits(verifier.len() as u16);
                    for (author_idx, voting_power) in missing_batch_authors {
                        if verifier
                            .check_aggregated_voting_power(voting_power, false)
                            .is_ok()
                        {
                            aggregated_bitvec.set(author_idx as u16);
                        }
                    }
                    RoundTimeoutReason::PayloadUnavailable {
                        missing_authors: aggregated_bitvec,
                    }
```

**File:** consensus/src/liveness/proposal_status_tracker.rs (L80-98)
```rust
    fn get_exclude_authors(&self) -> HashSet<Author> {
        let mut exclude_authors = HashSet::new();

        let limit = self.window;
        for round_reason in self.past_round_statuses.iter().rev().take(limit) {
            if let NewRoundReason::Timeout(RoundTimeoutReason::PayloadUnavailable {
                missing_authors,
            }) = round_reason
            {
                for author_idx in missing_authors.iter_ones() {
                    if let Some(author) = self.ordered_authors.get(author_idx) {
                        exclude_authors.insert(*author);
                    }
                }
            }
        }

        exclude_authors
    }
```

**File:** consensus/src/quorum_store/batch_proof_queue.rs (L596-600)
```rust
        for (_, batches) in self
            .author_to_batches
            .iter()
            .filter(|(author, _)| !exclude_authors.contains(author))
        {
```
