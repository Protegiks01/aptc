# Audit Report

## Title
StructKey Collision Enables Type Confusion in Layout Cache During Module Republishing

## Summary
The `StructKey` used to index the global layout cache does not incorporate module versioning, allowing stale struct layouts to be cached after `flush_layout_cache()` clears the cache during module republishing. This creates a race condition where transactions using old module versions can insert outdated layouts into the cache after it's been flushed, causing subsequent transactions to deserialize structs with incorrect layouts—breaking deterministic execution and potentially causing consensus failures. [1](#0-0) 

## Finding Description

The vulnerability stems from the interaction between three components:

1. **StructKey Definition**: `StructKey` contains only `StructNameIndex` and `TypeVecId`, with no module version information. [1](#0-0) 

2. **StructNameIndex Stability**: When modules are republished, the same struct name receives the same `StructNameIndex` value, as documented in the safety comment. [2](#0-1) 

3. **Layout Cache Flushing**: When modules are published, `flush_layout_cache()` attempts to invalidate cached layouts. [3](#0-2) [4](#0-3) 

**The Race Condition:**

During parallel block execution:

**Thread 1** (Transaction computing layout for old module version):
1. Requests layout for struct `Foo<u64>` from module version 1 with layout `{value: u64}`
2. Computes `StructKey = (idx: 5, ty_args_id: 10)` 
3. Begins layout computation
4. **[PREEMPTED]**

**Thread 2** (Transaction publishing new module):
5. Publishes module version 2 redefining `Foo<u64>` with layout `{value: u64, extra: bool}`
6. Calls `flush_layout_cache()` → clears all cached layouts [5](#0-4) 

**Thread 1** (Resumes):
7. Completes layout computation for OLD version
8. Calls `store_struct_layout_entry(StructKey(5, 10), old_layout)`
9. Cache entry is `Vacant` (just cleared!) → inserts OLD layout [6](#0-5) 

**Thread 3** (Transaction using new module):
10. Requests layout for `Foo<u64>` (version 2)
11. Computes same `StructKey = (idx: 5, ty_args_id: 10)` (struct name unchanged, type args unchanged)
12. **Cache HIT** - retrieves OLD layout `{value: u64}`
13. Uses old layout to deserialize NEW struct `{value: u64, extra: bool}`
14. **TYPE CONFUSION** - missing the `extra` field, reading incorrect memory

The layout cache is shared globally via `LatestView`: [7](#0-6) 

## Impact Explanation

**Critical Severity** - This vulnerability breaks the fundamental **Deterministic Execution** invariant:

1. **Consensus Failure**: Different validators may cache different layouts depending on transaction execution timing, leading to different state roots for the same block. This violates the requirement that "all validators must produce identical state roots for identical blocks."

2. **Type Confusion**: Using an old layout to deserialize a new struct definition causes:
   - Reading beyond struct boundaries if fields were removed
   - Missing fields if new fields were added
   - Incorrect field interpretation if types changed
   - Memory corruption and undefined behavior

3. **State Divergence**: Non-deterministic layout caching means validators executing the same transactions in slightly different orders will compute different results, potentially causing chain splits.

4. **Validator Consensus Breakdown**: If some validators cache the old layout and others compute the new layout, they will disagree on transaction outputs, breaking consensus safety.

This meets the **Critical Severity** criteria: "Consensus/Safety violations" and "Non-recoverable network partition (requires hardfork)".

## Likelihood Explanation

**High Likelihood** - The vulnerability is readily exploitable:

1. **Common Operation**: Module republishing is a standard operation for upgrades, available to any account that owns a module or through governance proposals.

2. **Parallel Execution**: Aptos uses parallel transaction execution by default via BlockSTM, creating natural race conditions.

3. **Timing Window**: The race window exists during any block containing:
   - One transaction that republishes a module with changed struct definitions
   - Other transactions that use structs from that module

4. **No Special Privileges Required**: Any user can:
   - Publish a module with a struct definition
   - Submit a transaction using that struct
   - Republish the module with a modified struct
   - Submit another transaction using the modified struct
   - All within the same block

5. **Realistic Attack Vector**: An attacker could deliberately craft transactions to maximize the race window by:
   - Submitting many parallel transactions using the old module
   - Interspersing module republish transactions
   - Forcing layout cache pollution with stale entries

## Recommendation

**Primary Fix**: Add a module generation/version identifier to `StructKey` to distinguish between different versions of the same struct:

```rust
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub struct StructKey {
    pub idx: StructNameIndex,
    pub ty_args_id: TypeVecId,
    pub module_generation: u64,  // NEW: incremented on module republish
}
```

When modules are republished, increment a generation counter so the new version gets a different `StructKey`, preventing cache collisions.

**Alternative Fix**: Ensure atomic cache flush by preventing insertions during/after flush:

```rust
pub fn flush_layout_cache(&self) {
    // Mark cache as being flushed
    self.cache_generation.fetch_add(1, Ordering::SeqCst);
    self.struct_layouts.clear();
}

pub(crate) fn store_struct_layout_entry(&self, key: &StructKey, entry: LayoutCacheEntry) -> PartialVMResult<()> {
    let generation = self.cache_generation.load(Ordering::SeqCst);
    // Only insert if generation hasn't changed since layout computation started
    if entry.generation == generation {
        if let dashmap::Entry::Vacant(e) = self.struct_layouts.entry(*key) {
            e.insert(entry);
        }
    }
    Ok(())
}
```

**Short-term Mitigation**: Flush type pools when flushing layout cache to force new `StructKey` values: [8](#0-7) 

Modify to flush type pools alongside layout cache when modules are published.

## Proof of Concept

**Rust Unit Test Demonstrating Race Condition:**

```rust
#[test]
fn test_layout_cache_race_on_module_republish() {
    use std::sync::{Arc, Barrier};
    use std::thread;
    
    let global_cache = Arc::new(GlobalModuleCache::empty());
    let barrier = Arc::new(Barrier::new(3));
    
    // Simulate old module version with Foo{x: u64}
    let old_layout = create_layout(vec![MoveTypeLayout::U64]);
    let struct_key = StructKey { idx: StructNameIndex::new(5), ty_args_id: TypeVecId(10) };
    
    // Thread 1: Computing layout for old version
    let cache1 = Arc::clone(&global_cache);
    let barrier1 = Arc::clone(&barrier);
    let key1 = struct_key;
    let old_layout1 = old_layout.clone();
    let handle1 = thread::spawn(move || {
        barrier1.wait(); // Synchronize start
        // Simulate layout computation delay
        thread::sleep(Duration::from_millis(10));
        // Try to insert old layout
        cache1.store_struct_layout_entry(&key1, old_layout1).unwrap();
    });
    
    // Thread 2: Publishing new module and flushing cache
    let cache2 = Arc::clone(&global_cache);
    let barrier2 = Arc::clone(&barrier);
    let handle2 = thread::spawn(move || {
        barrier2.wait(); // Synchronize start
        thread::sleep(Duration::from_millis(5)); // Let Thread 1 start
        // Module republish - flush cache
        cache2.flush_layout_cache();
    });
    
    // Thread 3: Using new module version
    let cache3 = Arc::clone(&global_cache);
    let barrier3 = Arc::clone(&barrier);
    let key3 = struct_key;
    let handle3 = thread::spawn(move || {
        barrier3.wait(); // Synchronize start
        thread::sleep(Duration::from_millis(20)); // Wait for race
        // Try to get layout - should be for NEW version but gets OLD
        cache3.get_struct_layout_entry(&key3)
    });
    
    handle1.join().unwrap();
    handle2.join().unwrap();
    let cached_layout = handle3.join().unwrap();
    
    // VULNERABILITY: Old layout cached after flush!
    assert!(cached_layout.is_some(), "Race allowed old layout to persist after flush");
}
```

**Move Integration Test:**

```move
module 0x1::TestModuleV1 {
    struct Foo<T> has key, drop {
        value: T
    }
    
    public fun create_foo<T>(value: T): Foo<T> {
        Foo { value }
    }
}

// In separate transaction: republish module
module 0x1::TestModuleV2 {
    struct Foo<T> has key, drop {
        value: T,
        extra: bool  // NEW FIELD
    }
    
    public fun create_foo<T>(value: T): Foo<T> {
        Foo { value, extra: true }
    }
}

// Parallel transactions trigger race:
// T1: Uses Foo<u64> from V1, caches layout
// T2: Publishes V2, flushes cache  
// T1: Inserts old layout after flush
// T3: Uses Foo<u64> from V2, gets old layout → type confusion
```

**Notes**

The vulnerability is rooted in a fundamental design assumption that `StructKey` uniquely identifies a struct's layout. This assumption breaks when modules are republished because:

- The struct name (and thus `StructNameIndex`) remains constant across versions
- Type arguments (and thus `TypeVecId`) remain constant for the same instantiation  
- But the actual struct definition and layout changes
- The cache flush mechanism is not atomic with respect to concurrent insertions
- No synchronization prevents stale layouts from being cached after a flush

This is exacerbated by the global nature of the layout cache and the parallel execution model, which creates natural race conditions during module upgrades.

### Citations

**File:** third_party/move/move-vm/runtime/src/storage/layout_cache.rs (L79-83)
```rust
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub struct StructKey {
    pub idx: StructNameIndex,
    pub ty_args_id: TypeVecId,
}
```

**File:** third_party/move/move-vm/types/src/loaded_data/struct_name_indexing.rs (L67-99)
```rust
    /// Maps the struct identifier into an index. If the identifier already exists returns the
    /// corresponding index. This function guarantees that for any struct identifiers A and B,
    /// if A == B, they have the same indices.
    pub fn struct_name_to_idx(
        &self,
        struct_name: &StructIdentifier,
    ) -> PartialVMResult<StructNameIndex> {
        {
            let index_map = self.0.read();
            if let Some(idx) = index_map.forward_map.get(struct_name) {
                return Ok(StructNameIndex(*idx));
            }
        }

        // Possibly need to insert, so make the copies outside of the lock.
        let forward_key = struct_name.clone();
        let backward_value = Arc::new(struct_name.clone());

        let idx = {
            let mut index_map = self.0.write();

            if let Some(idx) = index_map.forward_map.get(struct_name) {
                return Ok(StructNameIndex(*idx));
            }

            let idx = index_map.backward_map.len() as u32;
            index_map.backward_map.push(backward_value);
            index_map.forward_map.insert(forward_key, idx);
            idx
        };

        Ok(StructNameIndex(idx))
    }
```

**File:** aptos-move/block-executor/src/code_cache_global.rs (L155-160)
```rust
    /// Flushes all caches.
    pub fn flush(&mut self) {
        self.module_cache.clear();
        self.size = 0;
        self.struct_layouts.clear();
    }
```

**File:** aptos-move/block-executor/src/code_cache_global.rs (L162-168)
```rust
    /// Flushes only layout caches.
    pub fn flush_layout_cache(&self) {
        // TODO(layouts):
        //   Flushing is only needed because of enums. Once we refactor layouts to store a single
        //   variant instead, this can be removed.
        self.struct_layouts.clear();
    }
```

**File:** aptos-move/block-executor/src/code_cache_global.rs (L181-190)
```rust
    pub(crate) fn store_struct_layout_entry(
        &self,
        key: &StructKey,
        entry: LayoutCacheEntry,
    ) -> PartialVMResult<()> {
        if let dashmap::Entry::Vacant(e) = self.struct_layouts.entry(*key) {
            e.insert(entry);
        }
        Ok(())
    }
```

**File:** aptos-move/block-executor/src/txn_last_input_output.rs (L572-577)
```rust
        if published {
            // Record validation requirements after the modules are published.
            global_module_cache.flush_layout_cache();
            scheduler.record_validation_requirements(txn_idx, module_ids_for_v2)?;
        }
        Ok(published)
```

**File:** aptos-move/block-executor/src/code_cache.rs (L254-264)
```rust
impl<T: Transaction, S: TStateView<Key = T::Key>> LayoutCache for LatestView<'_, T, S> {
    fn get_struct_layout(&self, key: &StructKey) -> Option<LayoutCacheEntry> {
        self.global_module_cache.get_struct_layout_entry(key)
    }

    fn store_struct_layout(&self, key: &StructKey, entry: LayoutCacheEntry) -> PartialVMResult<()> {
        self.global_module_cache
            .store_struct_layout_entry(key, entry)?;
        Ok(())
    }
}
```

**File:** aptos-move/block-executor/src/code_cache_global_manager.rs (L143-146)
```rust
        if struct_name_index_map_size > config.max_struct_name_index_map_num_entries {
            runtime_environment.flush_all_caches();
            self.module_cache.flush();
        }
```
