# Audit Report

## Title
Zero-Cost Storage Gas Schedule Allows Network-Wide DoS via Governance Configuration

## Summary

The Aptos storage gas system lacks validation to prevent zero-cost gas schedules from being applied via governance. If a `StorageGasConfig` with all gas curves set to `min_gas=0` and `max_gas=0` is deployed through governance (either maliciously or accidentally), all storage operations become free, enabling attackers to spam unlimited state writes and exhaust validator storage. This causes permanent network degradation requiring a hard fork to recover. [1](#0-0) 

## Finding Description

The vulnerability exists in the storage gas configuration system where multiple validation gaps allow zero-cost gas schedules to be deployed:

**1. Missing Validation in Gas Curve Creation**

The `new_gas_curve()` function only validates that `max_gas >= min_gas` but does not prevent both from being zero: [2](#0-1) 

**2. No Validation in Configuration Update**

The `set_config()` function only checks the signer authority but performs no validation on the configuration values: [3](#0-2) 

**3. Governance Execution Path**

Governance proposals can call `set_storage_gas_config()` which directly invokes the unvalidated `set_config()`: [4](#0-3) 

**4. Zero-Cost Gas Charging**

When storage gas parameters are zero, the `IoPricingV2` implementation charges zero gas for all operations: [5](#0-4) 

The `io_gas_per_write()` method calculates costs based on these parameters, resulting in zero charges: [6](#0-5) 

**5. Gas Charging Enforcement**

The VM's `charge_io()` function accepts zero amounts without any minimum threshold: [7](#0-6) 

**Attack Scenario:**

1. A governance proposal is created (maliciously or with buggy tooling) containing a `StorageGasConfig` where all gas curves have `min_gas=0, max_gas=0`
2. The proposal passes governance voting (through collusion, mistake, or poor review)
3. The proposal executes via `resolve()` which obtains the `aptos_framework` signer
4. `gas_schedule::set_storage_gas_config()` is called, updating the configuration
5. At the next epoch, `on_reconfig()` calculates new gas values from the zero curves: [8](#0-7) 

6. All storage operations now charge zero gas
7. Attackers submit transactions creating unlimited resources and table entries
8. Validator disk space fills up, causing:
   - Database performance degradation
   - Validator crashes
   - Network becomes unusable
   - Requires coordinated hard fork to restore service

**Broken Invariants:**
- **Resource Limits**: "All operations must respect gas, storage, and computational limits" - violated because storage operations have no cost limit
- **Move VM Safety**: "Bytecode execution must respect gas limits and memory constraints" - violated because storage gas limits are bypassed

## Impact Explanation

This vulnerability meets **CRITICAL** severity under the Aptos bug bounty program:

1. **"Non-recoverable network partition (requires hardfork)"** - Once validators' storage is exhausted, the network cannot recover without a hard fork to:
   - Fix the gas configuration
   - Potentially prune spam data
   - Coordinate validator restarts

2. **"Total loss of liveness/network availability"** - The network becomes completely unusable as validators:
   - Cannot process transactions due to storage exhaustion
   - Cannot sync state
   - Cannot participate in consensus

The attack has network-wide impact affecting all validators simultaneously, making it far more severe than single-validator DoS attacks.

## Likelihood Explanation

**Likelihood: Low-Medium**

**Barriers:**
- Requires a governance proposal to pass
- Governance participants are generally trusted
- Validators would likely notice and reject obviously malicious proposals

**Realistic Scenarios:**
1. **Human Error**: A well-intentioned proposal to "temporarily disable storage fees for testing" or "migration purposes" contains buggy parameters
2. **Tooling Bug**: Governance proposal generation tooling has a bug that produces zero values
3. **Poor Review**: A complex multi-step proposal hides the malicious configuration change
4. **Compromised Tooling**: An attacker compromises governance tooling to inject malicious configurations

The key issue is that the system provides **no safety net**. Even though governance is trusted, defense-in-depth principles require validation of dangerous configurations. Without validation, a single mistake or tooling bug can cause catastrophic network failure.

## Recommendation

**Add validation to prevent zero or near-zero gas costs:**

```move
public fun new_gas_curve(min_gas: u64, max_gas: u64, points: vector<Point>): GasCurve {
    // Existing validations
    assert!(max_gas >= min_gas, error::invalid_argument(EINVALID_GAS_RANGE));
    assert!(max_gas <= MAX_U64 / BASIS_POINT_DENOMINATION, error::invalid_argument(EINVALID_GAS_RANGE));
    
    // NEW: Prevent zero or dangerously low gas costs
    const MIN_REASONABLE_GAS: u64 = 100; // Define minimum threshold
    assert!(min_gas >= MIN_REASONABLE_GAS, error::invalid_argument(EGAS_TOO_LOW));
    
    validate_points(&points);
    GasCurve {
        min_gas,
        max_gas,
        points
    }
}
```

**Additional safeguards:**

1. Add validation in `set_config()` to check configuration sanity
2. Add governance proposal validation to detect obviously dangerous configurations
3. Implement rate limiting for storage operations as a defense-in-depth measure
4. Add monitoring alerts for abnormal storage growth patterns

## Proof of Concept

```move
#[test(framework = @aptos_framework)]
fun test_zero_cost_storage_gas_vulnerability(framework: signer) acquires StorageGas, StorageGasConfig {
    use aptos_framework::state_storage;
    
    // Initialize storage tracking and storage gas
    state_storage::initialize(&framework);
    initialize(&framework);
    
    // Create malicious configuration with zero gas costs
    let zero_curve = new_gas_curve(0, 0, vector[]); // min=0, max=0 - NO VALIDATION PREVENTS THIS
    
    let item_config = new_usage_gas_config(
        100, // target_usage (required > 0)
        copy zero_curve, // read_curve
        copy zero_curve, // create_curve
        copy zero_curve  // write_curve
    );
    
    let byte_config = new_usage_gas_config(
        1000,
        copy zero_curve,
        copy zero_curve,
        copy zero_curve
    );
    
    // Create and apply zero-cost storage config
    let malicious_config = new_storage_gas_config(item_config, byte_config);
    set_config(&framework, malicious_config);
    
    // Simulate reconfiguration
    state_storage::set_for_test(0, 50, 500);
    on_reconfig();
    
    // Verify all storage gas costs are now ZERO
    let gas_params = borrow_global<StorageGas>(@aptos_framework);
    assert!(gas_params.per_item_read == 0, 1);
    assert!(gas_params.per_item_create == 0, 2);
    assert!(gas_params.per_item_write == 0, 3);
    assert!(gas_params.per_byte_read == 0, 4);
    assert!(gas_params.per_byte_create == 0, 5);
    assert!(gas_params.per_byte_write == 0, 6);
    
    // At this point, all storage operations are FREE
    // Attackers can spam unlimited state writes until validator storage is exhausted
}
```

**Expected Result:** The test compiles and runs successfully, demonstrating that zero-cost gas schedules can be configured without any validation errors, confirming the vulnerability.

## Notes

The formal verification specifications confirm the lack of protection - the `NewGasCurveAbortsIf` schema only prevents `max_gas < min_gas`, not zero values: [9](#0-8) 

While the `StorageGasSchedule::zeros()` function exists in the Rust codebase, it appears to be a utility function. The actual vulnerability is in the Move framework's lack of validation when governance applies configurations, which could inadvertently use zero values through bugs or mistakes in proposal creation.

### Citations

**File:** types/src/on_chain_config/gas_schedule.rs (L36-47)
```rust
impl StorageGasSchedule {
    pub fn zeros() -> Self {
        Self {
            per_item_read: 0,
            per_item_create: 0,
            per_item_write: 0,
            per_byte_read: 0,
            per_byte_create: 0,
            per_byte_write: 0,
        }
    }
}
```

**File:** aptos-move/framework/aptos-framework/sources/storage_gas.move (L334-343)
```text
    public fun new_gas_curve(min_gas: u64, max_gas: u64, points: vector<Point>): GasCurve {
        assert!(max_gas >= min_gas, error::invalid_argument(EINVALID_GAS_RANGE));
        assert!(max_gas <= MAX_U64 / BASIS_POINT_DENOMINATION, error::invalid_argument(EINVALID_GAS_RANGE));
        validate_points(&points);
        GasCurve {
            min_gas,
            max_gas,
            points
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/storage_gas.move (L363-366)
```text
    public(friend) fun set_config(aptos_framework: &signer, config: StorageGasConfig) acquires StorageGasConfig {
        system_addresses::assert_aptos_framework(aptos_framework);
        *borrow_global_mut<StorageGasConfig>(@aptos_framework) = config;
    }
```

**File:** aptos-move/framework/aptos-framework/sources/storage_gas.move (L515-533)
```text
    public(friend) fun on_reconfig() acquires StorageGas, StorageGasConfig {
        assert!(
            exists<StorageGasConfig>(@aptos_framework),
            error::not_found(ESTORAGE_GAS_CONFIG)
        );
        assert!(
            exists<StorageGas>(@aptos_framework),
            error::not_found(ESTORAGE_GAS)
        );
        let (items, bytes) = state_storage::current_items_and_bytes();
        let gas_config = borrow_global<StorageGasConfig>(@aptos_framework);
        let gas = borrow_global_mut<StorageGas>(@aptos_framework);
        gas.per_item_read = calculate_read_gas(&gas_config.item_config, items);
        gas.per_item_create = calculate_create_gas(&gas_config.item_config, items);
        gas.per_item_write = calculate_write_gas(&gas_config.item_config, items);
        gas.per_byte_read = calculate_read_gas(&gas_config.byte_config, bytes);
        gas.per_byte_create = calculate_create_gas(&gas_config.byte_config, bytes);
        gas.per_byte_write = calculate_write_gas(&gas_config.byte_config, bytes);
    }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L147-152)
```text
    public fun set_storage_gas_config(aptos_framework: &signer, config: StorageGasConfig) {
        storage_gas::set_config(aptos_framework, config);
        // Need to trigger reconfiguration so the VM is guaranteed to load the new gas fee starting from the next
        // transaction.
        reconfiguration::reconfigure();
    }
```

**File:** aptos-move/aptos-vm-types/src/storage/io_pricing.rs (L94-110)
```rust
impl IoPricingV2 {
    pub fn new_with_storage_curves(
        feature_version: u64,
        storage_gas_schedule: &StorageGasSchedule,
        gas_params: &AptosGasParameters,
    ) -> Self {
        Self {
            feature_version,
            free_write_bytes_quota: Self::get_free_write_bytes_quota(feature_version, gas_params),
            per_item_read: storage_gas_schedule.per_item_read.into(),
            per_item_create: storage_gas_schedule.per_item_create.into(),
            per_item_write: storage_gas_schedule.per_item_write.into(),
            per_byte_read: storage_gas_schedule.per_byte_read.into(),
            per_byte_create: storage_gas_schedule.per_byte_create.into(),
            per_byte_write: storage_gas_schedule.per_byte_write.into(),
        }
    }
```

**File:** aptos-move/aptos-vm-types/src/storage/io_pricing.rs (L142-157)
```rust
    fn io_gas_per_write(&self, key: &StateKey, op_size: &WriteOpSize) -> InternalGas {
        use aptos_types::write_set::WriteOpSize::*;

        match op_size {
            Creation { write_len } => {
                self.per_item_create * NumArgs::new(1)
                    + self.write_op_size(key, *write_len) * self.per_byte_create
            },
            Modification { write_len } => {
                self.per_item_write * NumArgs::new(1)
                    + self.write_op_size(key, *write_len) * self.per_byte_write
            },
            Deletion => 0.into(),
        }
    }
}
```

**File:** aptos-move/aptos-gas-meter/src/algebra.rs (L211-237)
```rust
    fn charge_io(
        &mut self,
        abstract_amount: impl GasExpression<VMGasParameters, Unit = InternalGasUnit>,
    ) -> PartialVMResult<()> {
        let amount = abstract_amount.evaluate(self.feature_version, &self.vm_gas_params);

        match self.balance.checked_sub(amount) {
            Some(new_balance) => {
                self.balance = new_balance;
                self.io_gas_used += amount;
            },
            None => {
                let old_balance = self.balance;
                self.balance = 0.into();
                if self.feature_version >= 12 {
                    self.io_gas_used += old_balance;
                }
                return Err(PartialVMError::new(StatusCode::OUT_OF_GAS));
            },
        };

        if self.feature_version >= 7 && self.io_gas_used > self.max_io_gas {
            Err(PartialVMError::new(StatusCode::IO_LIMIT_REACHED))
        } else {
            Ok(())
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/storage_gas.spec.move (L182-188)
```text
    spec schema NewGasCurveAbortsIf {
        min_gas: u64;
        max_gas: u64;

        aborts_if max_gas < min_gas;
        aborts_if max_gas > MAX_U64 / BASIS_POINT_DENOMINATION;
    }
```
