# Audit Report

## Title
Mutual Authentication Downgrade Allows Untrusted Peers to Connect to Validators via VFN Network

## Summary
The VFN (Validator Full Node) and Public networks have mutual authentication disabled by default, allowing any peer with a valid keypair to connect to validators and participate in critical network protocols (mempool, storage service, peer monitoring) without being in the trusted peer set. These untrusted peers are neither evicted nor penalized, enabling network abuse and manipulation of validator operations.

## Finding Description

The vulnerability stems from a fundamental misconfiguration in how network authentication is handled across different network types.

**Root Cause 1: Mutual Authentication Disabled for Non-Validator Networks**

By default, only the Validator network has mutual authentication enabled: [1](#0-0) 

**Root Cause 2: MaybeMutual Mode Accepts Untrusted Peers**

When `mutual_authentication = false`, the handshake uses `MaybeMutual` mode which accepts peers NOT in the trusted peer set, only requiring that their peer ID matches their public key (trivially satisfied): [2](#0-1) 

These untrusted peers are assigned `PeerRole::ValidatorFullNode` or `PeerRole::Unknown` and allowed to connect.

**Root Cause 3: Untrusted Peers Are Never Evicted**

The connectivity manager explicitly preserves inbound connections from ValidatorFullNode/Unknown roles when mutual authentication is disabled: [3](#0-2) 

**Root Cause 4: Validators Accept ValidatorFullNode Connections on VFN Network**

Validators are configured to accept connections from the ValidatorFullNode role on their VFN network: [4](#0-3) 

**Root Cause 5: No Penalty for VFN Network Abuse**

The storage service request moderator only ignores misbehaving peers on the Public network, NOT on the VFN network: [5](#0-4) 

**Attack Path:**
1. Attacker generates a valid keypair
2. Attacker connects to a validator's VFN network port
3. Gets accepted with `PeerRole::ValidatorFullNode` despite not being in trusted peers
4. Remains connected indefinitely (won't be evicted as stale)
5. Can spam mempool with invalid transactions
6. Can provide false network topology information via peer monitoring service
7. Can abuse storage service requests without penalty
8. Can potentially manipulate consensus observer subscriptions

This violates the fundamental security invariant that validators should only accept connections from their own trusted VFNs.

## Impact Explanation

This is a **High Severity** vulnerability per the Aptos bug bounty criteria:

1. **Significant Protocol Violations**: Validators are designed to only communicate with trusted VFNs on the VFN network. This vulnerability allows arbitrary untrusted peers to connect and participate in validator operations.

2. **Validator Node Degradation**: Malicious peers can:
   - Spam mempool with invalid transactions, wasting validator resources
   - Make excessive storage service requests without being rate-limited
   - Pollute peer discovery information leading to network topology manipulation
   - Consume network bandwidth and processing capacity

3. **Network Integrity Compromise**: The peer monitoring service allows malicious nodes to:
   - Learn the complete network topology by querying legitimate nodes
   - Provide false information about connected peers and distances from validators
   - Enable targeted attacks on specific validators or network partitions

4. **Trust Model Violation**: The VFN network is supposed to be a trusted communication channel between validators and their fullnodes. This vulnerability completely undermines that trust model.

While this doesn't directly lead to consensus safety violations or loss of funds, it enables significant degradation of validator performance and network integrity, qualifying as **High Severity** under "Significant protocol violations" and "Validator node slowdowns."

## Likelihood Explanation

**Likelihood: HIGH**

1. **Trivial to Exploit**: An attacker only needs to:
   - Generate a keypair (standard cryptographic operation)
   - Know the VFN network port of a validator (often publicly discoverable)
   - Establish a TCP connection

2. **No Special Privileges Required**: No validator operator access, insider knowledge, or special permissions needed.

3. **Persistent Exploitation**: Once connected, the malicious peer remains connected indefinitely and can continuously abuse the connection.

4. **Widespread Vulnerability**: This affects ALL validators running default configurations, as the VFN network has `mutual_authentication = false` by design.

5. **No Detection Mechanisms**: The current implementation has no way to distinguish legitimate VFNs from malicious peers connecting to the VFN network.

## Recommendation

**Short-term Fix**: Enable mutual authentication for the VFN network

Modify the default configuration to enforce mutual authentication for VFN networks:

```rust
// In config/src/config/network_config.rs, line 136
pub fn network_with_id(network_id: NetworkId) -> NetworkConfig {
    // VFN network should also use mutual authentication
    let mutual_authentication = network_id.is_validator_network() || network_id.is_vfn_network();
    // ... rest of function
}
```

And enforce this in the config sanitizer:

```rust
// In config/src/config/config_sanitizer.rs, add validation for VFN networks
fn sanitize_fullnode_network_config(...) -> Result<(), Error> {
    for fullnode_network_config in fullnode_networks {
        let network_id = fullnode_network_config.network_id;
        
        // VFN networks must have mutual authentication enabled
        if network_id.is_vfn_network() && !fullnode_network_config.mutual_authentication {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "Mutual authentication must be enabled for VFN networks!".into(),
            ));
        }
        // ... rest of validation
    }
}
```

**Long-term Solution**: Implement proper peer authentication hierarchy
1. Maintain separate trusted peer sets for each network type
2. Explicitly configure which VFNs are authorized to connect to each validator
3. Enforce strict authentication on VFN network using onchain validator set data
4. Add monitoring and alerting for unauthorized connection attempts
5. Implement connection limits per peer to prevent resource exhaustion

## Proof of Concept

```rust
// Proof of Concept: Unauthorized VFN Connection
// This demonstrates how an attacker can connect to a validator's VFN network
// without being in the trusted peer set

use aptos_config::config::{NetworkConfig, Peer, PeerRole, PeerSet};
use aptos_config::network_id::NetworkId;
use aptos_crypto::x25519;
use aptos_types::account_address::from_identity_public_key;
use aptos_types::network_address::NetworkAddress;
use aptos_types::PeerId;
use rand::SeedableRng;

#[test]
fn test_unauthorized_vfn_connection() {
    // Step 1: Attacker generates a keypair
    let mut rng = rand::rngs::StdRng::from_entropy();
    let attacker_private_key = x25519::PrivateKey::generate(&mut rng);
    let attacker_public_key = attacker_private_key.public_key();
    let attacker_peer_id = from_identity_public_key(attacker_public_key);
    
    // Step 2: Check that VFN network has mutual_authentication = false
    let vfn_config = NetworkConfig::network_with_id(NetworkId::Vfn);
    assert_eq!(vfn_config.mutual_authentication, false, 
        "VFN network should have mutual_authentication disabled by default");
    
    // Step 3: Verify that validator network accepts ValidatorFullNode role
    let validator_role = aptos_config::config::RoleType::Validator;
    let downstream_roles = NetworkId::Vfn.downstream_roles(&validator_role);
    assert!(downstream_roles.contains(&PeerRole::ValidatorFullNode),
        "Validators accept ValidatorFullNode connections on VFN network");
    
    // Step 4: In a real attack, the attacker would:
    // - Connect to validator's VFN network port
    // - Complete Noise handshake with attacker_private_key
    // - Get assigned PeerRole::ValidatorFullNode (handshake.rs:410)
    // - Stay connected (won't be evicted per connectivity_manager.rs:494-498)
    // - Abuse mempool, storage service, peer monitoring protocols
    
    println!("PoC: Attacker with peer_id {} can connect to VFN network", 
        aptos_short_hex_str::AsShortHexStr::short_str(&attacker_peer_id));
    println!("The attacker will be assigned ValidatorFullNode role without being trusted");
    println!("The connection will persist indefinitely without eviction");
}

// To run this PoC:
// 1. Save to network/framework/src/connectivity_manager/test.rs
// 2. Run: cargo test test_unauthorized_vfn_connection -- --nocapture
// 
// Expected output demonstrates that:
// - VFN network has mutual_authentication = false
// - Validators accept ValidatorFullNode connections
// - Attacker can connect and persist without being in trusted peers
```

## Notes

The vulnerability is particularly severe because:

1. **Design vs Implementation**: This appears to be a design-level issue where the VFN network was intended to be semi-trusted but the implementation allows completely untrusted access.

2. **Configuration Inconsistency**: The config sanitizer enforces mutual authentication for the Validator network but not for VFN networks, creating an asymmetric security posture.

3. **Multiple Attack Vectors**: The vulnerability enables multiple types of abuse across different protocol layers (mempool spam, storage service abuse, peer discovery manipulation).

4. **No Compensating Controls**: There are no rate limits, connection limits per peer, or other defenses that would mitigate unauthorized VFN connections.

The immediate priority should be enabling mutual authentication for VFN networks and ensuring that only explicitly authorized VFNs can connect to validators.

### Citations

**File:** config/src/config/network_config.rs (L136-136)
```rust
        let mutual_authentication = network_id.is_validator_network();
```

**File:** network/framework/src/noise/handshake.rs (L384-426)
```rust
            HandshakeAuthMode::MaybeMutual(peers_and_metadata) => {
                let trusted_peers = peers_and_metadata.get_trusted_peers(&network_id)?;
                let trusted_peer = trusted_peers.get(&remote_peer_id).cloned();
                match trusted_peer {
                    Some(peer) => {
                        Self::authenticate_inbound(remote_peer_short, &peer, &remote_public_key)
                    },
                    None => {
                        // The peer is not in the trusted peer set. Verify that the Peer ID is
                        // constructed correctly from the public key.
                        let derived_remote_peer_id =
                            aptos_types::account_address::from_identity_public_key(
                                remote_public_key,
                            );
                        if derived_remote_peer_id != remote_peer_id {
                            // The peer ID is not constructed correctly from the public key
                            Err(NoiseHandshakeError::ClientPeerIdMismatch(
                                remote_peer_short,
                                remote_peer_id,
                                derived_remote_peer_id,
                            ))
                        } else {
                            // Try to infer the role from the network context
                            if self.network_context.role().is_validator() {
                                if network_id.is_vfn_network() {
                                    // Inbound connections to validators on the VFN network must be VFNs
                                    Ok(PeerRole::ValidatorFullNode)
                                } else {
                                    // Otherwise, they're unknown. Validators will connect through
                                    // authenticated channels (on the validator network) so shouldn't hit
                                    // this, and PFNs will connect on public networks (which aren't common).
                                    Ok(PeerRole::Unknown)
                                }
                            } else {
                                // We're a VFN or PFN. VFNs get no inbound connections on the vfn network
                                // (so the peer won't be a validator). Thus, we're on the public network
                                // so mark the peer as unknown.
                                Ok(PeerRole::Unknown)
                            }
                        }
                    },
                }
            },
```

**File:** network/framework/src/connectivity_manager/mod.rs (L494-503)
```rust
                    if !self.mutual_authentication
                        && metadata.origin == ConnectionOrigin::Inbound
                        && (metadata.role == PeerRole::ValidatorFullNode
                            || metadata.role == PeerRole::Unknown)
                    {
                        None
                    } else {
                        Some(*peer_id) // The peer is stale
                    }
                });
```

**File:** config/src/network_id.rs (L199-200)
```rust
            NetworkId::Vfn => match role {
                RoleType::Validator => &[PeerRole::ValidatorFullNode],
```

**File:** state-sync/storage-service/server/src/moderator.rs (L54-58)
```rust
        // If the peer is a PFN and has sent too many invalid requests, start ignoring it
        if self.ignore_start_time.is_none()
            && peer_network_id.network_id().is_public_network()
            && self.invalid_request_count >= self.max_invalid_requests
        {
```
