# Audit Report

## Title
Validator Network Peers Bypass Storage Service Rate Limiting Through TooManyInvalidRequests Exemption

## Summary
The `TooManyInvalidRequests` rate limiting mechanism in the storage service explicitly excludes validator and VFN network peers from enforcement, allowing malicious validators to send unlimited invalid storage requests without consequences, potentially causing resource exhaustion and validator node slowdowns.

## Finding Description

The storage service implements a request moderation system to track and limit invalid requests from peers. When a peer exceeds the configured threshold of invalid requests (`max_invalid_requests_per_peer`, default 500), they should be temporarily ignored for a duration (`min_time_to_ignore_peers_secs`, default 300 seconds) with exponential backoff.

However, the rate limiting check contains a critical exemption: [1](#0-0) 

The `increment_invalid_request_count` method only marks peers for ignoring when `peer_network_id.network_id().is_public_network()` returns true. The `is_public_network()` method only returns true for `NetworkId::Public`: [2](#0-1) [3](#0-2) 

This means validators (`NetworkId::Validator`) and VFN peers (`NetworkId::Vfn`) are never subject to the ignore mechanism, regardless of how many invalid requests they send. The invalid request counter increments, but the peer is never blocked.

The request validation flow confirms this: [4](#0-3) 

The moderator's `validate_request` checks if a peer should be ignored: [5](#0-4) 

But since validator/VFN peers are never marked as ignored, they always pass this check.

**Attack Scenario:**
1. A Byzantine validator (or compromised validator node) sends continuous invalid storage service requests
2. Examples: requesting transaction versions beyond the synced range, requesting non-existent state values, requesting epochs that don't exist
3. Each invalid request triggers validation logic, database queries, logging, and metric updates
4. The validator's invalid request counter increments but they are never ignored
5. This continues indefinitely, consuming CPU, I/O, and memory resources on the storage service
6. Other legitimate peers experience degraded performance as resources are exhausted

The official test suite explicitly validates this behavior as intentional: [6](#0-5) 

## Impact Explanation

This vulnerability qualifies as **High Severity** per the Aptos bug bounty program criteria:

**"Validator node slowdowns"** is explicitly listed as a High Severity impact. A malicious validator can abuse this exemption to:

1. **Resource Exhaustion**: Each invalid request consumes CPU cycles for validation, database I/O for checking storage summaries, memory for tracking state, and network bandwidth
2. **Degraded Performance**: Honest validators and VFNs sharing the same storage service will experience slower response times
3. **DoS Amplification**: Multiple colluding Byzantine validators (up to < 1/3) can amplify the attack
4. **State Probing**: Attackers can probe for data availability without consequences, potentially discovering synchronization state

The storage service handles critical data requests including: [7](#0-6) 

All these request types can be abused with invalid parameters to trigger validation failures while consuming resources.

## Likelihood Explanation

**Likelihood: Medium to High**

This attack is realistic because:

1. **Byzantine Validator Assumption**: Aptos BFT assumes < 1/3 Byzantine validators, so having a malicious validator is within the threat model
2. **Low Attack Complexity**: Simply requires sending invalid storage requests with out-of-range versions or non-existent data
3. **No Detection**: The invalid request counter increments but triggers no blocking or alerting for validator peers
4. **Persistent Impact**: Can continue indefinitely without consequences
5. **Configuration**: Default thresholds (500 requests, 5 minutes) are intended for public peers but don't apply to validators

The attack requires:
- Control of a validator node (or VFN)
- Knowledge of storage service API (publicly documented)
- Basic network connectivity

No sophisticated exploit or timing requirements are needed.

## Recommendation

**Apply rate limiting to all network types, with potentially higher thresholds for trusted networks:**

```rust
pub fn increment_invalid_request_count(&mut self, peer_network_id: &PeerNetworkId) {
    // Increment the invalid request count
    self.invalid_request_count += 1;

    // Determine if peer should be ignored based on network type
    // For validators and VFNs, use a higher threshold but still enforce limits
    let should_ignore = if self.ignore_start_time.is_none() 
        && self.invalid_request_count >= self.max_invalid_requests 
    {
        match peer_network_id.network_id() {
            NetworkId::Public => true,
            NetworkId::Vfn => {
                // Higher threshold for VFNs (e.g., 10x)
                self.invalid_request_count >= self.max_invalid_requests * 10
            },
            NetworkId::Validator => {
                // Even higher threshold for validators but still limit (e.g., 20x)
                self.invalid_request_count >= self.max_invalid_requests * 20
            },
        }
    } else {
        false
    };

    if should_ignore {
        // Start ignoring the peer
        self.ignore_start_time = Some(self.time_service.now());

        // Log the fact that we're now ignoring the peer
        warn!(LogSchema::new(LogEntry::RequestModeratorIgnoredPeer)
            .peer_network_id(peer_network_id)
            .message("Ignoring peer due to too many invalid requests!"));
    }
}
```

**Alternative approach:** Implement separate configuration parameters:
- `max_invalid_requests_per_pfn` (default: 500)
- `max_invalid_requests_per_vfn` (default: 5000)  
- `max_invalid_requests_per_validator` (default: 10000)

This provides defense-in-depth while acknowledging trusted networks deserve higher thresholds.

**Additional mitigations:**
1. Add alerting when validator/VFN peers exceed thresholds (even if not ignored)
2. Implement circuit breakers for total invalid request rate across all peers
3. Add metrics tracking invalid requests per network type

## Proof of Concept

The existing test suite already demonstrates this vulnerability: [8](#0-7) 

**To exploit this vulnerability:**

1. Deploy a validator node on the Aptos network
2. Configure the validator to send invalid storage service requests in a loop:

```rust
// Pseudocode for attack
let storage_client = StorageServiceClient::new(validator_network_id);

loop {
    // Request versions beyond the synced range
    let invalid_request = StorageServiceRequest::new(
        DataRequest::GetTransactionsWithProof(TransactionsWithProofRequest {
            start_version: u64::MAX - 1000,
            end_version: u64::MAX,
            proof_version: u64::MAX,
            include_events: false,
        }),
        false, // no compression
    );
    
    // This will fail validation but never result in rate limiting
    let _ = storage_client.send_request(invalid_request).await;
    
    // Optionally add small delay to avoid triggering network-level rate limits
    tokio::time::sleep(Duration::from_millis(10)).await;
}
```

3. Monitor target validator nodes for performance degradation (increased latency, CPU usage)
4. Observe that the attacking validator is never ignored despite unlimited invalid requests

The validator can sustain this attack indefinitely while honest validators suffer degraded storage service performance.

## Notes

This vulnerability breaks the **Resource Limits** invariant: "All operations must respect gas, storage, and computational limits." By exempting validator peers from rate limiting, the system allows unlimited resource consumption through invalid requests.

The design appears to assume validators are trusted and won't abuse the storage service. However, under the Byzantine fault tolerance model (< 1/3 malicious validators), this assumption is insufficient. Defense-in-depth requires rate limiting even for trusted networks, albeit with higher thresholds.

### Citations

**File:** state-sync/storage-service/server/src/moderator.rs (L50-69)
```rust
    pub fn increment_invalid_request_count(&mut self, peer_network_id: &PeerNetworkId) {
        // Increment the invalid request count
        self.invalid_request_count += 1;

        // If the peer is a PFN and has sent too many invalid requests, start ignoring it
        if self.ignore_start_time.is_none()
            && peer_network_id.network_id().is_public_network()
            && self.invalid_request_count >= self.max_invalid_requests
        {
            // TODO: at some point we'll want to terminate the connection entirely

            // Start ignoring the peer
            self.ignore_start_time = Some(self.time_service.now());

            // Log the fact that we're now ignoring the peer
            warn!(LogSchema::new(LogEntry::RequestModeratorIgnoredPeer)
                .peer_network_id(peer_network_id)
                .message("Ignoring peer due to too many invalid requests!"));
        }
    }
```

**File:** state-sync/storage-service/server/src/moderator.rs (L134-149)
```rust
    pub fn validate_request(
        &self,
        peer_network_id: &PeerNetworkId,
        request: &StorageServiceRequest,
    ) -> Result<(), Error> {
        // Validate the request and time the operation
        let validate_request = || {
            // If the peer is being ignored, return an error
            if let Some(peer_state) = self.unhealthy_peer_states.get(peer_network_id) {
                if peer_state.is_ignored() {
                    return Err(Error::TooManyInvalidRequests(format!(
                        "Peer is temporarily ignored. Unable to handle request: {:?}",
                        request
                    )));
                }
            }
```

**File:** config/src/network_id.rs (L79-83)
```rust
pub enum NetworkId {
    Validator = 0,
    Vfn = 3,
    Public = 4,
}
```

**File:** config/src/network_id.rs (L160-162)
```rust
    pub fn is_public_network(&self) -> bool {
        self == &NetworkId::Public
    }
```

**File:** state-sync/storage-service/server/src/handler.rs (L206-214)
```rust
    fn validate_and_handle_request(
        &self,
        peer_network_id: &PeerNetworkId,
        request: &StorageServiceRequest,
    ) -> Result<StorageServiceResponse, Error> {
        // Validate the request with the moderator
        self.request_moderator
            .validate_request(peer_network_id, request)?;

```

**File:** state-sync/storage-service/server/src/tests/request_moderator.rs (L29-117)
```rust
#[tokio::test]
async fn test_request_moderator_ignore_pfn() {
    // Create test data
    let highest_synced_version = 100;
    let highest_synced_epoch = 10;

    // Create a storage service config for testing
    let max_invalid_requests_per_peer = 5;
    let storage_service_config = StorageServiceConfig {
        max_invalid_requests_per_peer,
        ..Default::default()
    };

    // Create the storage client and server
    let (mut mock_client, mut service, _, _, _) =
        MockClient::new(None, Some(storage_service_config));
    utils::update_storage_server_summary(
        &mut service,
        highest_synced_version,
        highest_synced_epoch,
    );

    // Get the request moderator and verify the initial state
    let request_moderator = service.get_request_moderator();
    let unhealthy_peer_states = request_moderator.get_unhealthy_peer_states();
    assert!(unhealthy_peer_states.is_empty());

    // Spawn the server
    tokio::spawn(service.start());

    // Process several invalid PFN requests
    let pfn_peer_network_id = PeerNetworkId::new(NetworkId::Public, PeerId::random());
    for _ in 0..max_invalid_requests_per_peer {
        // Send the invalid request
        let response = send_invalid_transaction_request(
            highest_synced_version,
            &mut mock_client,
            pfn_peer_network_id,
        )
        .await;

        // Verify we get an invalid request error
        assert_matches!(
            response.unwrap_err(),
            StorageServiceError::InvalidRequest(_)
        );
    }

    // Send another request and verify the PFN is now ignored
    let response = send_invalid_transaction_request(
        highest_synced_version,
        &mut mock_client,
        pfn_peer_network_id,
    )
    .await;
    assert_matches!(
        response.unwrap_err(),
        StorageServiceError::TooManyInvalidRequests(_)
    );

    // Process many invalid requests from a VFN and verify it is never ignored
    let vfn_peer_network_id = PeerNetworkId::new(NetworkId::Vfn, PeerId::random());
    for _ in 0..max_invalid_requests_per_peer * 2 {
        // Send the invalid request
        let response = send_invalid_transaction_request(
            highest_synced_version,
            &mut mock_client,
            vfn_peer_network_id,
        )
        .await;

        // Verify we get an invalid request error
        assert_matches!(
            response.unwrap_err(),
            StorageServiceError::InvalidRequest(_)
        );
    }

    // Verify the unhealthy peer states
    assert_eq!(unhealthy_peer_states.len(), 2);

    // Verify the unhealthy peer state for the PFN
    let unhealthy_pfn_state = unhealthy_peer_states.get(&pfn_peer_network_id).unwrap();
    assert!(unhealthy_pfn_state.is_ignored());

    // Verify the unhealthy peer state for the VFN
    let unhealthy_vfn_state = unhealthy_peer_states.get(&vfn_peer_network_id).unwrap();
    assert!(!unhealthy_vfn_state.is_ignored());
}
```

**File:** state-sync/storage-service/types/src/requests.rs (L33-56)
```rust
/// A single data request.
#[derive(Clone, Debug, Deserialize, Eq, Hash, PartialEq, Serialize)]
pub enum DataRequest {
    GetEpochEndingLedgerInfos(EpochEndingLedgerInfoRequest), // Fetches a list of epoch ending ledger infos
    GetNewTransactionOutputsWithProof(NewTransactionOutputsWithProofRequest), // Optimistically fetches new transaction outputs
    GetNewTransactionsWithProof(NewTransactionsWithProofRequest), // Optimistically fetches new transactions
    GetNumberOfStatesAtVersion(Version), // Fetches the number of states at the specified version
    GetServerProtocolVersion,            // Fetches the protocol version run by the server
    GetStateValuesWithProof(StateValuesWithProofRequest), // Fetches a list of states with a proof
    GetStorageServerSummary,             // Fetches a summary of the storage server state
    GetTransactionOutputsWithProof(TransactionOutputsWithProofRequest), // Fetches a list of transaction outputs with a proof
    GetTransactionsWithProof(TransactionsWithProofRequest), // Fetches a list of transactions with a proof
    GetNewTransactionsOrOutputsWithProof(NewTransactionsOrOutputsWithProofRequest), // Optimistically fetches new transactions or outputs
    GetTransactionsOrOutputsWithProof(TransactionsOrOutputsWithProofRequest), // Fetches a list of transactions or outputs with a proof
    SubscribeTransactionOutputsWithProof(SubscribeTransactionOutputsWithProofRequest), // Subscribes to transaction outputs with a proof
    SubscribeTransactionsOrOutputsWithProof(SubscribeTransactionsOrOutputsWithProofRequest), // Subscribes to transactions or outputs with a proof
    SubscribeTransactionsWithProof(SubscribeTransactionsWithProofRequest), // Subscribes to transactions with a proof

    // All the requests listed below are for transaction data v2 (i.e., transactions with auxiliary information).
    // TODO: eventually we should deprecate all the old request types.
    GetTransactionDataWithProof(GetTransactionDataWithProofRequest), // Fetches transaction data with a proof
    GetNewTransactionDataWithProof(GetNewTransactionDataWithProofRequest), // Optimistically fetches new transaction data with a proof
    SubscribeTransactionDataWithProof(SubscribeTransactionDataWithProofRequest), // Subscribes to transaction data with a proof
}
```
