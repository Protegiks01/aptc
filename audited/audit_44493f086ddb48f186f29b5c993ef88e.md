# Audit Report

## Title
Unhandled Panic in DKG Transcript Verification Causes Validator Crash

## Summary
A malicious DKG transcript with empty or malformed vectors can cause validator nodes to panic and crash during peer transcript verification, as `verify_transcript_extra()` accesses vector elements without bounds checking before `verify_transcript()` validates vector sizes.

## Finding Description

The DKG transcript verification process violates the exception handling security guarantee by calling `.unwrap()` on potentially empty vectors before size validation occurs.

During DKG peer transcript aggregation, the verification flow is: [1](#0-0) 

Notice that `verify_transcript_extra` is called **before** `verify_transcript`. Within `verify_transcript_extra`, when a fast path transcript exists, the code compares dealt public keys: [2](#0-1) 

The `get_dealt_public_key()` implementation unsafely accesses the last element: [3](#0-2) 

The critical issue: `check_sizes()` which validates that `V_hat` is non-empty only executes inside `verify_transcript()`: [4](#0-3) [5](#0-4) 

Since `verify_transcript_extra` executes first, a malicious transcript with empty `V_hat` (or empty `fast.V_hat`) will cause `.last()` to return `None`, and `.unwrap()` will panic, crashing the validator.

**Attack Path:**
1. Attacker crafts a DKG transcript with `main.V_hat = []` or `fast.V_hat = []` 
2. Attacker sends transcript to validators during DKG peer aggregation
3. Validator deserializes transcript successfully (BCS allows empty vectors)
4. `verify_transcript_extra` is called first
5. If transcript has fast path, line 326 calls `get_dealt_public_key()` on both transcripts
6. `get_dealt_public_key()` calls `.last().unwrap()` on empty vector
7. **Panic!** Validator crashes with "called `Option::unwrap()` on a `None` value"

## Impact Explanation

This is a **High Severity** vulnerability per Aptos bug bounty criteria:
- **Validator node crashes**: Direct availability impact
- **API crashes**: The validator becomes unresponsive 
- **Significant protocol violations**: DKG cannot complete if validators crash

While not Critical (doesn't cause consensus splits or fund loss), it allows attackers to disrupt DKG completion and potentially delay epoch transitions, affecting network liveness. Multiple validators can be targeted simultaneously by broadcasting malicious transcripts.

## Likelihood Explanation

**Very High Likelihood:**
- Attack requires zero special privileges (any network peer can send DKG transcripts)
- Exploit is trivial: create transcript with empty vectors
- Attack surface is always exposed during DKG phase
- No cryptographic operations required - just malformed data structure
- Fast path transcripts are commonly used in production based on on-chain configuration

The only requirement is network access during DKG, which all validators have.

## Recommendation

**Fix:** Validate vector sizes in `verify_transcript_extra` before accessing elements, or reorder to call `verify_transcript` first.

**Option 1 - Add size checks in `verify_transcript_extra`:**

```rust
fn verify_transcript_extra(
    trx: &Self::Transcript,
    verifier: &ValidatorVerifier,
    checks_voting_power: bool,
    ensures_single_dealer: Option<AccountAddress>,
) -> anyhow::Result<()> {
    // Validate sizes early
    let all_validator_addrs = verifier.get_ordered_account_addresses();
    let main_trx_dealers = trx.main.get_dealers();
    
    // Add bounds check before accessing elements
    ensure!(!trx.main.V_hat.is_empty(), "main transcript V_hat is empty");
    if let Some(fast_trx) = &trx.fast {
        ensure!(!fast_trx.V_hat.is_empty(), "fast transcript V_hat is empty");
    }
    
    // ... rest of validation
}
```

**Option 2 - Use safe access:**

```rust
fn get_dealt_public_key(&self) -> Self::DealtPubKey {
    Self::DealtPubKey::new(
        *self.V_hat.last()
            .ok_or_else(|| anyhow!("V_hat is empty"))
            .unwrap()
    )
}
```

**Option 3 - Reorder verification (preferred):** [1](#0-0) 

Change to call `verify_transcript` first, which includes `check_sizes()`, then `verify_transcript_extra`.

## Proof of Concept

```rust
#[test]
fn test_empty_vhat_panic() {
    use types::dkg::{RealDKG, DKGTrait};
    use crates::aptos_dkg::pvss::das::WeightedTranscript;
    
    // Create malicious transcript with empty V_hat
    let mut malicious_trx = WeightedTranscript {
        soks: vec![],
        R: vec![],
        R_hat: vec![],
        V: vec![G1Projective::identity()], // At least one element
        V_hat: vec![], // EMPTY - will cause panic
        C: vec![],
    };
    
    let fast_trx = Some(WeightedTranscript {
        soks: vec![],
        R: vec![],
        R_hat: vec![],
        V: vec![G1Projective::identity()],
        V_hat: vec![], // EMPTY
        C: vec![],
    });
    
    let trx = Transcripts {
        main: malicious_trx,
        fast: fast_trx,
    };
    
    // This will panic when accessing .last().unwrap() on empty V_hat
    let result = RealDKG::verify_transcript_extra(
        &trx,
        &verifier,
        false,
        Some(sender_addr)
    );
    // Expected: panic with "called `Option::unwrap()` on a `None` value"
}
```

## Notes

The blstrs point deserialization is properly handled with `TryFrom` returning `Result`, as confirmed in the README: [6](#0-5) 

However, the uncaught exception occurs not during cryptographic operations but during basic vector access without bounds checking. This represents a classic ordering bug where validation happens after unsafe access.

### Citations

**File:** dkg/src/transcript_aggregation/mod.rs (L96-101)
```rust
        S::verify_transcript_extra(&transcript, &self.epoch_state.verifier, false, Some(sender))
            .context("extra verification failed")?;

        S::verify_transcript(&self.dkg_pub_params, &transcript).map_err(|e| {
            anyhow!("[DKG] adding peer transcript failed with trx verification failure: {e}")
        })?;
```

**File:** types/src/dkg/real_dkg/mod.rs (L324-327)
```rust
        if let Some(fast_trx) = &trx.fast {
            ensure!(fast_trx.get_dealers() == main_trx_dealers);
            ensure!(trx.main.get_dealt_public_key() == fast_trx.get_dealt_public_key());
        }
```

**File:** crates/aptos-dkg/src/pvss/das/weighted_protocol.rs (L215-217)
```rust
    fn get_dealt_public_key(&self) -> Self::DealtPubKey {
        Self::DealtPubKey::new(*self.V_hat.last().unwrap())
    }
```

**File:** crates/aptos-dkg/src/pvss/das/weighted_protocol.rs (L288-293)
```rust
        self.check_sizes(sc)?;
        let n = sc.get_total_num_players();
        if eks.len() != n {
            bail!("Expected {} encryption keys, but got {}", n, eks.len());
        }
        let W = sc.get_total_weight();
```

**File:** crates/aptos-dkg/src/pvss/das/weighted_protocol.rs (L415-432)
```rust
    fn check_sizes(&self, sc: &WeightedConfigBlstrs) -> anyhow::Result<()> {
        let W = sc.get_total_weight();

        if self.V.len() != W + 1 {
            bail!(
                "Expected {} G_2 (polynomial) commitment elements, but got {}",
                W + 1,
                self.V.len()
            );
        }

        if self.V_hat.len() != W + 1 {
            bail!(
                "Expected {} G_2 (polynomial) commitment elements, but got {}",
                W + 1,
                self.V_hat.len()
            );
        }
```

**File:** crates/aptos-dkg/README.md (L55-58)
```markdown
We (mostly) rely on the `aptos-crypto` `SerializeKey` and `DeserializeKey` derives for safety during deserialization.
Specifically, each cryptographic object (e.g., public key, public parameters, etc) must implement `ValidCryptoMaterial` for serialization and `TryFrom` for deserialization when these derives are used.

The G1/G2 group elements in `blstrs` are deserialized safely via calls to `from_[un]compressed` rather than calls to `from_[un]compressed_unchecked` which does not check prime-order subgroup membership.
```
