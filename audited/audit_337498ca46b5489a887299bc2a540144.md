# Audit Report

## Title
Missing Grandparent-Parent Chain Validation in OptimisticProposal Allows Inconsistent QC Relationships

## Summary
The OptimisticProposal validation in the Aptos consensus layer cryptographically verifies both `grandparent_qc` and `quorum_cert` independently but fails to validate that the `grandparent_qc` actually certifies the parent of the block certified by `quorum_cert`. This allows a Byzantine proposer to construct an OptimisticProposal with a valid but semantically incorrect grandparent QC, violating chain integrity assumptions and corrupting historical voting data.

## Finding Description

In the Aptos consensus protocol, an OptimisticProposal contains two quorum certificates: a `quorum_cert` (for the parent block) embedded in the resulting Block, and a `grandparent_qc` (for the grandparent block) stored in the block's OptBlockBody. The system validates these QCs independently through multiple validation layers.

**Validation Flow:**

1. **OptBlockData Well-Formedness Check** [1](#0-0) 
   - Validates `grandparent_qc.round() + 1 == parent.round()`
   - Validates `parent.round() + 1 == self.round()`
   - Ensures epoch consistency and timestamp monotonicity
   - **Missing**: No check that `grandparent_qc.certified_block().id()` matches the actual parent of the parent block

2. **Signature Validation** [2](#0-1) 
   - Verifies cryptographic signatures on both `grandparent_qc` and `quorum_cert`
   - Both QCs independently verified for 2f+1 validator signatures

3. **OptProposal Processing** [3](#0-2) 
   - Validates `hqc.certified_block().round() + 1 == opt_block_data.round()`
   - Validates `hqc.certified_block().id() == opt_block_data.parent_id()`
   - **Missing**: No check that `grandparent_qc.certified_block().id() == hqc.parent_block().id()`

**Critical Missing Check:** 

The system never validates that the block certified by `grandparent_qc` is the same as the parent of the block certified by `hqc` (the quorum_cert). The QuorumCert structure contains a VoteData with both proposed and parent BlockInfo [4](#0-3) , and the QuorumCert provides `parent_block()` method [5](#0-4) , but this relationship is never validated against `grandparent_qc`.

**Attack Scenario:**

In a Byzantine scenario where equivocation produces two different blocks at round r-2:
- Block A at round r-2 (honest chain)
- Block B at round r-2 (equivocated block with valid QC)
- Block C at round r-1 with parent = Block A
- Block D at round r extending Block C

A Byzantine proposer crafts OptBlockData with:
- `parent`: BlockInfo for Block C (round r-1)
- `grandparent_qc`: Valid QC certifying Block B (round r-2)

When processed:
1. Round check passes: `(r-2) + 1 == (r-1)` ✓
2. HQC check passes: `hqc.certified_block().id() == Block C` ✓
3. Block created with `quorum_cert` (containing VoteData with parent=Block A) and `grandparent_qc` certifying Block B
4. Block accepted despite `B ≠ A`

**Consequences:**

1. **Incorrect Voter Attribution**: The `previous_bitvec()` function specifically returns grandparent_qc voters for OptimisticProposals [6](#0-5) . This returns voters from Block B instead of Block A (the actual grandparent), corrupting historical voting records.

2. **Event Data Corruption**: BlockMetadata emitted on-chain uses `previous_bitvec()` [7](#0-6) , embedding incorrect `previous_block_votes_bitvec` in blockchain state that affects indexers, analytics, and reputation systems.

3. **Block Hash Inconsistency**: The block hash computation includes the `block_type` which contains the `grandparent_qc` [8](#0-7) . While all nodes receiving the same OptProposalMsg compute identical hashes, different malicious proposals with different grandparent_qcs would produce different block IDs, enabling potential chain divergence scenarios.

## Impact Explanation

This vulnerability constitutes **Medium severity** per Aptos bug bounty criteria:

**Why Medium:**
- **State inconsistencies requiring intervention**: Incorrect voter data in events and block metadata creates historical data corruption affecting off-chain infrastructure (indexers, analytics, reputation systems)
- **Protocol invariant violation**: The semantic invariant that OptimisticProposal's grandparent_qc certifies the actual grandparent is violated without immediate detection
- **Potential for cascading issues**: Other protocol components or future upgrades assuming correct grandparent_qc relationships could be compromised

**Why NOT Critical/High:**
- Does NOT cause immediate consensus safety violation (all nodes seeing identical proposal accept it identically)
- Does NOT enable direct fund theft or minting
- Does NOT cause network halt or permanent liveness loss
- Requires Byzantine conditions (equivocation with valid QCs for different blocks at same round)

## Likelihood Explanation

**Likelihood: Low to Medium**

The attack requires:
1. **Byzantine proposer**: Must be a validator selected to propose (< 1/3 Byzantine threshold)
2. **Equivocation prerequisite**: Two valid QCs for different blocks at the same round must exist, requiring Byzantine validators to have produced conflicting QCs
3. **Network visibility**: Attacker must obtain both QCs from equivocation
4. **Timing window**: Must propose during OptimisticProposal acceptance window

While Byzantine behavior up to 1/3 threshold is the explicit threat model, equivocation detection mechanisms and economic disincentives (slashing) make sustained attacks costly. However, during network partitions, targeted attacks on specific rounds, or sophisticated multi-validator collusion, this becomes more feasible.

## Recommendation

Add validation in `process_opt_proposal()` to ensure grandparent_qc certifies the actual grandparent:

```rust
// In consensus/src/round_manager.rs, process_opt_proposal function
// After line 863, add:
ensure!(
    opt_block_data.grandparent_qc().certified_block().id() == hqc.parent_block().id(),
    "Opt proposal grandparent QC certifies block {} but parent's actual parent is {}",
    opt_block_data.grandparent_qc().certified_block().id(),
    hqc.parent_block().id()
);
```

This ensures that the grandparent_qc provided in OptBlockData actually certifies the parent of the block certified by the highest QC, maintaining chain integrity invariants.

## Proof of Concept

A complete PoC would require:
1. Setting up a test consensus network with multiple validators
2. Simulating Byzantine behavior to create equivocated QCs at the same round
3. Crafting a malicious OptProposalMsg with mismatched grandparent_qc
4. Demonstrating acceptance and resulting voter attribution corruption

The conceptual exploit is verified through code analysis showing the missing validation path, but a full executable PoC would require consensus test infrastructure setup beyond the scope of this report.

## Notes

This vulnerability represents a subtle protocol invariant violation that doesn't immediately break consensus safety but corrupts historical data and violates assumptions about block chain structure. The impact is amplified by the fact that `previous_bitvec()` is used to construct on-chain BlockMetadata, permanently recording incorrect voting information in blockchain state. While not critical, this warrants fixing to maintain protocol integrity and prevent potential issues in dependent systems or future protocol upgrades.

### Citations

**File:** consensus/consensus-types/src/opt_block_data.rs (L75-116)
```rust
    pub fn verify_well_formed(&self) -> anyhow::Result<()> {
        let parent = self.parent();
        let grandparent_qc = self.grandparent_qc().certified_block();
        ensure!(
            grandparent_qc.round() + 1 == parent.round(),
            "Block's parent's round {} must be one more than grandparent's round {}",
            parent.round(),
            grandparent_qc.round(),
        );
        ensure!(
            parent.round() + 1 == self.round(),
            "Block's round {} must be one more than parent's round {}",
            self.round(),
            parent.round(),
        );
        ensure!(
            grandparent_qc.epoch() == self.epoch() && parent.epoch() == self.epoch(),
            "Block's parent and grantparent should be in the same epoch"
        );
        ensure!(
            !grandparent_qc.has_reconfiguration(),
            "Optimistic proposals are disallowed after the reconfiguration block"
        );

        self.payload().verify_epoch(self.epoch())?;

        ensure!(
            self.timestamp_usecs() > parent.timestamp_usecs()
                && parent.timestamp_usecs() > grandparent_qc.timestamp_usecs(),
            "Blocks must have strictly increasing timestamps"
        );

        let current_ts = duration_since_epoch();

        // we can say that too far is 5 minutes in the future
        const TIMEBOUND: u64 = 300_000_000;
        ensure!(
            self.timestamp_usecs() <= (current_ts.as_micros() as u64).saturating_add(TIMEBOUND),
            "Blocks must not be too far in the future"
        );
        Ok(())
    }
```

**File:** consensus/consensus-types/src/block.rs (L453-461)
```rust
            BlockType::OptimisticProposal(p) => {
                // Note: Optimistic proposal is not signed by proposer unlike normal proposal
                let (res1, res2) = rayon::join(
                    || p.grandparent_qc().verify(validator),
                    || self.quorum_cert().verify(validator),
                );
                res1?;
                res2
            },
```

**File:** consensus/consensus-types/src/block.rs (L570-578)
```rust
    fn previous_bitvec(&self) -> BitVec {
        match self.block_data.block_type() {
            BlockType::DAGBlock { parents_bitvec, .. } => parents_bitvec.clone(),
            BlockType::OptimisticProposal(p) => {
                p.grandparent_qc().ledger_info().get_voters_bitvec().clone()
            },
            _ => self.quorum_cert().ledger_info().get_voters_bitvec().clone(),
        }
    }
```

**File:** consensus/consensus-types/src/block.rs (L580-595)
```rust
    pub fn new_block_metadata(&self, validators: &[AccountAddress]) -> BlockMetadata {
        BlockMetadata::new(
            self.id(),
            self.epoch(),
            self.round(),
            self.author().unwrap_or(AccountAddress::ZERO),
            self.previous_bitvec().into(),
            // For nil block, we use 0x0 which is convention for nil address in move.
            self.block_data()
                .failed_authors()
                .map_or(vec![], |failed_authors| {
                    Self::failed_authors_to_indices(validators, failed_authors)
                }),
            self.timestamp_usecs(),
        )
    }
```

**File:** consensus/src/round_manager.rs (L843-875)
```rust
    async fn process_opt_proposal(&mut self, opt_block_data: OptBlockData) -> anyhow::Result<()> {
        ensure!(
            self.block_store
                .get_block_for_round(opt_block_data.round())
                .is_none(),
            "Proposal has already been processed for round: {}",
            opt_block_data.round()
        );
        let hqc = self.block_store.highest_quorum_cert().as_ref().clone();
        ensure!(
            hqc.certified_block().round() + 1 == opt_block_data.round(),
            "Opt proposal round {} is not the next round after the highest qc round {}",
            opt_block_data.round(),
            hqc.certified_block().round()
        );
        ensure!(
            hqc.certified_block().id() == opt_block_data.parent_id(),
            "Opt proposal parent id {} is not the same as the highest qc certified block id {}",
            opt_block_data.parent_id(),
            hqc.certified_block().id()
        );
        let proposal = Block::new_from_opt(opt_block_data, hqc);
        observe_block(proposal.timestamp_usecs(), BlockStage::PROCESS_OPT_PROPOSAL);
        info!(
            self.new_log(LogEvent::ProcessOptProposal),
            block_author = proposal.author(),
            block_epoch = proposal.epoch(),
            block_round = proposal.round(),
            block_hash = proposal.id(),
            block_parent_hash = proposal.quorum_cert().certified_block().id(),
        );
        self.process_proposal(proposal).await
    }
```

**File:** consensus/consensus-types/src/vote_data.rs (L9-16)
```rust
/// VoteData keeps the information about the block, and its parent.
#[derive(Deserialize, Serialize, Clone, Debug, PartialEq, Eq, CryptoHasher, BCSCryptoHash)]
pub struct VoteData {
    /// Contains all the block information needed for voting for the proposed round.
    proposed: BlockInfo,
    /// Contains all the block information for the block the proposal is extending.
    parent: BlockInfo,
}
```

**File:** consensus/consensus-types/src/quorum_cert.rs (L62-64)
```rust
    pub fn parent_block(&self) -> &BlockInfo {
        self.vote_data().parent()
    }
```

**File:** consensus/consensus-types/src/block_data.rs (L110-133)
```rust
        if self.is_opt_block() {
            #[derive(Serialize)]
            struct OptBlockDataForHash<'a> {
                epoch: u64,
                round: Round,
                timestamp_usecs: u64,
                quorum_cert_vote_data: &'a VoteData,
                block_type: &'a BlockType,
            }

            let opt_block_data_for_hash = OptBlockDataForHash {
                epoch: self.epoch,
                round: self.round,
                timestamp_usecs: self.timestamp_usecs,
                quorum_cert_vote_data: self.quorum_cert.vote_data(),
                block_type: &self.block_type,
            };
            bcs::serialize_into(&mut state, &opt_block_data_for_hash)
                .expect("OptBlockDataForHash must be serializable");
        } else {
            bcs::serialize_into(&mut state, &self).expect("BlockData must be serializable");
        }
        state.finish()
    }
```
