# Audit Report

## Title
Unbounded Memory Exhaustion in batch_generator via Remote Batch Flooding

## Summary
The `batch_generator` module lacks size limits on its in-memory `batches_in_progress` HashMap and `txns_in_progress_sorted` BTreeMap, allowing a malicious validator to exhaust memory on honest validators by flooding them with remote batches that pass per-message validation but accumulate unboundedly before expiration, causing validator slowdowns and liveness degradation.

## Finding Description

The batch_generator module maintains two critical in-memory data structures without enforcing global capacity limits: [1](#0-0) 

When a remote batch is received from the network, it flows through the following path:

1. **Network Reception**: The NetworkListener receives `VerifiedEvent::BatchMsg` from a peer validator and round-robins it to BatchCoordinator workers: [2](#0-1) 

2. **Batch Coordination**: The BatchCoordinator validates per-message size limits, then immediately sends the batch to BatchGenerator: [3](#0-2) 

3. **Immediate Memory Insertion**: The BatchGenerator's `handle_remote_batch` method unconditionally calls `insert_batch`, which adds all batches to `batches_in_progress` and all transactions to `txns_in_progress_sorted` **without any capacity checks**: [4](#0-3) [5](#0-4) 

**The Critical Flaw**: While per-message limits exist (20 batches per message, 100 transactions per batch), there is **no limit on the total number of batches** across all messages or the total number of transactions tracked in memory.

The BatchStore has a quota system per peer: [6](#0-5) 

However, this quota only applies to **persistent storage**, not to BatchGenerator's in-memory structures. The insertion into BatchGenerator happens **before** the quota check in BatchStore, creating a decoupling where memory exhaustion can occur regardless of storage quotas.

**Attack Scenario**:
1. A malicious validator sends batch messages at high rate (limited only by network bandwidth and channel capacity of 1000 messages)
2. Each message contains 20 batches with 100 transactions each (within limits per configuration): [7](#0-6) 

3. Each batch is immediately added to `batches_in_progress` with all 100 transactions added to `txns_in_progress_sorted`
4. While batches expire after 500ms: [8](#0-7) 

If the attacker sends batches faster than the 500ms expiration window, memory accumulates. For example:
- Sending 100 messages/second (well within network capacity)
- 20 batches × 100 txns × 100 msg/s = 200,000 transactions/second
- Steady state: 200,000 × 0.5s = 100,000 transactions in memory
- This grows the BTreeMap to 100,000+ entries, consuming significant memory

The cleanup only occurs on `CommitNotification` based on block timestamps: [9](#0-8) 

But if block production is slow or delayed (which is the goal of the attack), cleanup is also delayed, allowing further accumulation.

## Impact Explanation

This vulnerability qualifies as **High Severity** under Aptos bug bounty criteria:
- **"Validator node slowdowns"** - Memory exhaustion causes garbage collection pressure, CPU contention, and potential OOM conditions
- Violates the **Resource Limits** invariant (Invariant #9): "All operations must respect gas, storage, and computational limits"
- Threatens **consensus liveness**: Resource-exhausted validators cannot participate effectively in consensus, potentially blocking the 2/3 threshold needed for progress

Multiple malicious validators coordinating this attack could degrade network-wide liveness without requiring > 1/3 Byzantine stake, as honest validators become unresponsive due to resource exhaustion rather than explicit Byzantine behavior.

## Likelihood Explanation

**Likelihood: Medium-High**

**Attacker Requirements**:
- Must be a validator in the active validator set (or compromise one)
- Requires no special privileges beyond normal validator network access
- Byzantine validators (up to 1/3) are explicitly assumed in BFT threat model

**Attack Complexity**: Low
- Simple flood attack with valid messages
- No cryptographic breaks or complex timing required
- Can be automated easily

**Detection Difficulty**: Medium
- Attack traffic looks like legitimate batch propagation
- Only observable through memory metrics and node performance degradation
- No invalid signatures or protocol violations to detect

## Recommendation

Implement a global capacity limit on `batches_in_progress` and `txns_in_progress_sorted` in BatchGenerator:

```rust
pub struct BatchGenerator {
    // ... existing fields ...
    
    // Add configuration-based limits
    max_batches_in_progress: usize,  // e.g., 10,000
    max_txns_in_progress: usize,     // e.g., 500,000
}

fn insert_batch(
    &mut self,
    author: PeerId,
    batch_id: BatchId,
    txns: Vec<SignedTransaction>,
    expiry_time_usecs: u64,
) {
    if self.batches_in_progress.contains_key(&(author, batch_id)) {
        return;
    }
    
    // NEW: Check global limits before insertion
    if self.batches_in_progress.len() >= self.max_batches_in_progress {
        counters::BATCH_GENERATOR_CAPACITY_EXCEEDED.inc();
        warn!("Batch generator capacity exceeded, dropping batch {} from {}", 
              batch_id, author);
        return;
    }
    
    if self.txns_in_progress_sorted.len() + txns.len() > self.max_txns_in_progress {
        counters::BATCH_GENERATOR_TXN_CAPACITY_EXCEEDED.inc();
        warn!("Transaction tracking capacity exceeded, dropping batch {} from {}", 
              batch_id, author);
        return;
    }
    
    // ... rest of existing insertion logic ...
}
```

Additionally, consider:
1. **Per-peer rate limiting** on remote batch acceptance (e.g., max batches per peer per second)
2. **Exponential backoff** when repeatedly exceeding limits from the same peer
3. **Priority-based eviction** when at capacity (e.g., prefer recent batches from well-behaved peers)
4. **Enhanced monitoring** with alerts when approaching capacity thresholds

## Proof of Concept

```rust
#[cfg(test)]
mod resource_exhaustion_test {
    use super::*;
    use aptos_types::transaction::SignedTransaction;
    
    #[tokio::test]
    async fn test_remote_batch_memory_exhaustion() {
        // Setup batch generator with default config
        let config = QuorumStoreConfig::default();
        let (mempool_tx, _) = futures_channel::mpsc::channel(100);
        let db = Arc::new(MockQuorumStoreDB::new());
        let batch_writer = Arc::new(MockBatchWriter::new());
        
        let mut generator = BatchGenerator::new(
            1, // epoch
            PeerId::random(),
            config,
            db,
            batch_writer,
            mempool_tx,
            1000,
        );
        
        // Simulate malicious validator flooding with batches
        let malicious_peer = PeerId::random();
        let mut memory_consumed = 0;
        
        // Send 10,000 batches with 100 transactions each
        for i in 0..10_000 {
            let batch_id = BatchId::new(i);
            let txns: Vec<SignedTransaction> = (0..100)
                .map(|_| create_test_transaction())
                .collect();
            
            generator.handle_remote_batch(
                malicious_peer,
                batch_id,
                txns,
            );
            
            memory_consumed = generator.batches_in_progress.len() 
                + generator.txns_in_progress_sorted.len();
        }
        
        // Verify unbounded growth
        println!("Batches in progress: {}", generator.batches_in_progress.len());
        println!("Transactions tracked: {}", generator.txns_in_progress_sorted.len());
        
        // Without limits, this will show 10,000 batches and 1,000,000 transactions
        // causing significant memory pressure
        assert!(generator.batches_in_progress.len() > 5000, 
                "Should accumulate many batches without limits");
    }
}
```

## Notes

This vulnerability is particularly concerning because:

1. **Defense-in-depth failure**: The BatchStore quota system exists but doesn't protect BatchGenerator's in-memory structures
2. **Time-of-check vs time-of-use**: Batches are committed to memory before quota validation
3. **Asymmetric attack cost**: Attacker sends small network messages but causes large memory allocations on victims
4. **Compounding effect**: Multiple Byzantine validators can amplify the attack across all honest validators simultaneously

The 500ms expiration provides some natural rate limiting, but is insufficient against determined attackers with sufficient network bandwidth. The absence of hard limits violates the principle of bounded resource consumption in consensus-critical paths.

### Citations

**File:** consensus/src/quorum_store/batch_generator.rs (L68-69)
```rust
    batches_in_progress: HashMap<(PeerId, BatchId), BatchInProgress>,
    txns_in_progress_sorted: BTreeMap<TransactionSummary, TransactionInProgress>,
```

**File:** consensus/src/quorum_store/batch_generator.rs (L165-170)
```rust
        self.batches_in_progress.insert(
            (author, batch_id),
            BatchInProgress::new(txns, updated_expiry_time_usecs),
        );
        self.batch_expirations
            .add_item((author, batch_id), updated_expiry_time_usecs);
```

**File:** consensus/src/quorum_store/batch_generator.rs (L392-401)
```rust
    pub(crate) fn handle_remote_batch(
        &mut self,
        author: PeerId,
        batch_id: BatchId,
        txns: Vec<SignedTransaction>,
    ) {
        let expiry_time_usecs = aptos_infallible::duration_since_epoch().as_micros() as u64
            + self.config.remote_batch_expiry_gap_when_init_usecs;
        self.insert_batch(author, batch_id, txns, expiry_time_usecs);
    }
```

**File:** consensus/src/quorum_store/batch_generator.rs (L536-552)
```rust
                            for (author, batch_id) in self.batch_expirations.expire(block_timestamp) {
                                if let Some(batch_in_progress) = self.batches_in_progress.get(&(author, batch_id)) {
                                    // If there is an identical batch with higher expiry time, re-insert it.
                                    if batch_in_progress.expiry_time_usecs > block_timestamp {
                                        self.batch_expirations.add_item((author, batch_id), batch_in_progress.expiry_time_usecs);
                                        continue;
                                    }
                                }
                                if self.remove_batch_in_progress(author, batch_id) {
                                    counters::BATCH_IN_PROGRESS_EXPIRED.inc();
                                    debug!(
                                        "QS: logical time based expiration batch w. id {} from batches_in_progress, new size {}",
                                        batch_id,
                                        self.batches_in_progress.len(),
                                    );
                                }
                            }
```

**File:** consensus/src/quorum_store/network_listener.rs (L68-93)
```rust
                    VerifiedEvent::BatchMsg(batch_msg) => {
                        counters::QUORUM_STORE_MSG_COUNT
                            .with_label_values(&["NetworkListener::batchmsg"])
                            .inc();
                        // Batch msg verify function alreay ensures that the batch_msg is not empty.
                        let author = batch_msg.author().expect("Empty batch message");
                        let batches = batch_msg.take();
                        counters::RECEIVED_BATCH_MSG_COUNT.inc();

                        // Round-robin assignment to batch coordinator.
                        let idx = next_batch_coordinator_idx;
                        next_batch_coordinator_idx = (next_batch_coordinator_idx + 1)
                            % self.remote_batch_coordinator_tx.len();
                        trace!(
                            "QS: peer_id {:?},  # network_worker {}, hashed to idx {}",
                            author,
                            self.remote_batch_coordinator_tx.len(),
                            idx
                        );
                        counters::BATCH_COORDINATOR_NUM_BATCH_REQS
                            .with_label_values(&[&idx.to_string()])
                            .inc();
                        self.remote_batch_coordinator_tx[idx]
                            .send(BatchCoordinatorCommand::NewBatches(author, batches))
                            .await
                            .expect("Could not send remote batch");
```

**File:** consensus/src/quorum_store/batch_coordinator.rs (L228-237)
```rust
        let mut persist_requests = vec![];
        for batch in batches.into_iter() {
            // TODO: maybe don't message batch generator if the persist is unsuccessful?
            if let Err(e) = self
                .sender_to_batch_generator
                .send(BatchGeneratorCommand::RemoteBatch(batch.clone()))
                .await
            {
                warn!("Failed to send batch to batch generator: {}", e);
            }
```

**File:** consensus/src/quorum_store/batch_store.rs (L383-391)
```rust
            let value_to_be_stored = if self
                .peer_quota
                .entry(author)
                .or_insert(QuotaManager::new(
                    self.db_quota,
                    self.memory_quota,
                    self.batch_quota,
                ))
                .update_quota(value.num_bytes() as usize)?
```

**File:** config/src/config/quorum_store_config.rs (L120-123)
```rust
            receiver_max_batch_txns: 100,
            receiver_max_batch_bytes: 1024 * 1024 + BATCH_PADDING_BYTES,
            receiver_max_num_batches: 20,
            receiver_max_total_txns: 2000,
```

**File:** config/src/config/quorum_store_config.rs (L132-132)
```rust
            remote_batch_expiry_gap_when_init_usecs: Duration::from_millis(500).as_micros() as u64,
```
