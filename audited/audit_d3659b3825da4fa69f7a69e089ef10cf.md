# Audit Report

## Title
State Sync Stream Cleanup Failure Causes Persistent Node Degradation

## Summary
When `handle_storage_synchronizer_error()` fails during stream termination in the state sync driver, the error is only logged but critical cleanup operations are skipped. This leaves the node in an inconsistent state with stale stream references that cannot be cleared, preventing the creation of new streams and causing persistent sync failures requiring manual node restart.

## Finding Description

The vulnerability exists in the error-within-error handling path of the state sync driver. When the storage synchronizer encounters an error and sends an `ErrorNotification`, the driver attempts to clean up by terminating active data streams. [1](#0-0) 

The critical flaw is in how both `continuous_syncer.handle_storage_synchronizer_error()` and `bootstrapper.handle_storage_synchronizer_error()` handle failures. Both methods call `reset_active_stream()` which performs stream termination. [2](#0-1) [3](#0-2) 

The `reset_active_stream()` method has a fatal design flaw where the `?` operator causes early return if `terminate_stream_with_feedback()` fails, preventing the cleanup of `active_data_stream` and `speculative_stream_state`. [4](#0-3) [5](#0-4) 

The stream termination can fail when the streaming service channel is closed (SendError), which gets converted to `Error::UnexpectedErrorEncountered`. [6](#0-5) [7](#0-6) 

Once the cleanup fails, the `active_data_stream` field remains non-None with a stale reference. On subsequent `drive_progress()` calls, the check `if self.active_data_stream.is_some()` succeeds, preventing initialization of new streams. [8](#0-7) [9](#0-8) 

This creates a cascading failure loop: attempts to fetch notifications from the stale stream repeatedly timeout, triggering more failed cleanup attempts. [10](#0-9) 

## Impact Explanation

This vulnerability falls under **Medium Severity** per the Aptos bug bounty criteria as it causes "State inconsistencies requiring intervention." Specifically:

- **Node Liveness Degradation**: The affected node cannot synchronize state, falling behind the network
- **Availability Impact**: The node becomes unable to serve current state queries or participate in validation
- **Manual Intervention Required**: Recovery requires node restart, as there is no automatic recovery mechanism
- **Does NOT Cause**: Direct fund loss, consensus safety violations, or network-wide disruption

The impact is limited to individual nodes experiencing the error condition, not systemic network failure. However, if multiple nodes encounter this simultaneously (e.g., from malicious peer sending invalid data to many nodes), it could degrade network capacity.

## Likelihood Explanation

**Likelihood: Medium to High**

This vulnerability can be triggered through multiple realistic scenarios:

1. **Malicious Peer Attack**: An attacker controlling a peer node can deliberately send invalid transaction data or proofs that cause storage synchronizer errors, then close connections to cause stream termination failures
   
2. **Network Instability**: Natural network disruptions causing streaming service channels to close during error recovery

3. **Server-Side State Mismatch**: Race conditions where the server terminates a stream just before the client attempts cleanup

The vulnerability requires no special privileges - any network peer can trigger storage synchronizer errors by providing invalid data. The error handling path is exercised regularly in production environments, making exploitation highly feasible.

## Recommendation

The fix should ensure cleanup operations complete even if stream termination fails. Replace the early-return `?` operator with explicit error handling:

```rust
pub async fn reset_active_stream(
    &mut self,
    notification_and_feedback: Option<NotificationAndFeedback>,
) -> Result<(), Error> {
    if let Some(active_data_stream) = &self.active_data_stream {
        let data_stream_id = active_data_stream.data_stream_id;
        // Log error but don't propagate - cleanup must continue
        if let Err(error) = utils::terminate_stream_with_feedback(
            &mut self.streaming_client,
            data_stream_id,
            notification_and_feedback,
        )
        .await {
            warn!("Failed to terminate stream {}: {:?}", data_stream_id, error);
        }
    }

    // Always perform cleanup regardless of termination result
    self.active_data_stream = None;
    self.speculative_stream_state = None;
    Ok(())
}
```

Apply this fix to both `continuous_syncer.rs` and `bootstrapper.rs`.

## Proof of Concept

While a full PoC would require setting up a malicious peer to trigger the exact error conditions, the vulnerability is evident from the code structure itself. The critical issue is the unreachable cleanup code at lines 539-540 in `continuous_syncer.rs` and lines 1553-1554 in `bootstrapper.rs` when the `?` operator at line 536 and 1550 respectively causes early return. This is a classic error handling bug where essential cleanup operations are skipped on failure.

### Citations

**File:** state-sync/state-sync-driver/src/driver.rs (L495-533)
```rust
    async fn handle_error_notification(&mut self, error_notification: ErrorNotification) {
        warn!(LogSchema::new(LogEntry::SynchronizerNotification)
            .error_notification(error_notification.clone())
            .message("Received an error notification from the storage synchronizer!"));

        // Terminate the currently active streams
        let notification_id = error_notification.notification_id;
        let notification_feedback = NotificationFeedback::InvalidPayloadData;
        if self.bootstrapper.is_bootstrapped() {
            if let Err(error) = self
                .continuous_syncer
                .handle_storage_synchronizer_error(NotificationAndFeedback::new(
                    notification_id,
                    notification_feedback,
                ))
                .await
            {
                error!(LogSchema::new(LogEntry::SynchronizerNotification)
                    .message(&format!(
                        "Failed to terminate the active stream for the continuous syncer! Error: {:?}",
                        error
                    )));
            }
        } else if let Err(error) = self
            .bootstrapper
            .handle_storage_synchronizer_error(NotificationAndFeedback::new(
                notification_id,
                notification_feedback,
            ))
            .await
        {
            error!(
                LogSchema::new(LogEntry::SynchronizerNotification).message(&format!(
                    "Failed to terminate the active stream for the bootstrapper! Error: {:?}",
                    error
                ))
            );
        };
    }
```

**File:** state-sync/state-sync-driver/src/continuous_syncer.rs (L77-97)
```rust
    pub async fn drive_progress(
        &mut self,
        consensus_sync_request: Arc<Mutex<Option<ConsensusSyncRequest>>>,
    ) -> Result<(), Error> {
        if self.active_data_stream.is_some() {
            // We have an active data stream. Process any notifications!
            self.process_active_stream_notifications(consensus_sync_request)
                .await
        } else if self.storage_synchronizer.pending_storage_data() {
            // Wait for any pending data to be processed
            sample!(
                SampleRate::Duration(Duration::from_secs(PENDING_DATA_LOG_FREQ_SECS)),
                info!("Waiting for the storage synchronizer to handle pending data!")
            );
            Ok(())
        } else {
            // Fetch a new data stream to start streaming data
            self.initialize_active_data_stream(consensus_sync_request)
                .await
        }
    }
```

**File:** state-sync/state-sync-driver/src/continuous_syncer.rs (L183-198)
```rust
    async fn fetch_next_data_notification(&mut self) -> Result<DataNotification, Error> {
        let max_stream_wait_time_ms = self.driver_configuration.config.max_stream_wait_time_ms;
        let max_num_stream_timeouts = self.driver_configuration.config.max_num_stream_timeouts;
        let result = utils::get_data_notification(
            max_stream_wait_time_ms,
            max_num_stream_timeouts,
            self.active_data_stream.as_mut(),
        )
        .await;
        if matches!(result, Err(Error::CriticalDataStreamTimeout(_))) {
            // If the stream has timed out too many times, we need to reset it
            warn!("Resetting the currently active data stream due to too many timeouts!");
            self.reset_active_stream(None).await?;
        }
        result
    }
```

**File:** state-sync/state-sync-driver/src/continuous_syncer.rs (L501-522)
```rust
    pub async fn handle_storage_synchronizer_error(
        &mut self,
        notification_and_feedback: NotificationAndFeedback,
    ) -> Result<(), Error> {
        // Reset the active stream
        self.reset_active_stream(Some(notification_and_feedback))
            .await?;

        // Fallback to output syncing if we need to
        if let ContinuousSyncingMode::ExecuteTransactionsOrApplyOutputs =
            self.get_continuous_syncing_mode()
        {
            self.output_fallback_handler.fallback_to_outputs();
            metrics::set_gauge(
                &metrics::DRIVER_FALLBACK_MODE,
                ExecutingComponent::ContinuousSyncer.get_label(),
                1,
            );
        }

        Ok(())
    }
```

**File:** state-sync/state-sync-driver/src/continuous_syncer.rs (L525-542)
```rust
    pub async fn reset_active_stream(
        &mut self,
        notification_and_feedback: Option<NotificationAndFeedback>,
    ) -> Result<(), Error> {
        if let Some(active_data_stream) = &self.active_data_stream {
            let data_stream_id = active_data_stream.data_stream_id;
            utils::terminate_stream_with_feedback(
                &mut self.streaming_client,
                data_stream_id,
                notification_and_feedback,
            )
            .await?;
        }

        self.active_data_stream = None;
        self.speculative_stream_state = None;
        Ok(())
    }
```

**File:** state-sync/state-sync-driver/src/bootstrapper.rs (L414-441)
```rust
    pub async fn drive_progress(
        &mut self,
        global_data_summary: &GlobalDataSummary,
    ) -> Result<(), Error> {
        if self.is_bootstrapped() {
            return Err(Error::AlreadyBootstrapped(
                "The bootstrapper should not attempt to make progress!".into(),
            ));
        }

        if self.active_data_stream.is_some() {
            // We have an active data stream. Process any notifications!
            self.process_active_stream_notifications().await?;
        } else if self.storage_synchronizer.pending_storage_data() {
            // Wait for any pending data to be processed
            sample!(
                SampleRate::Duration(Duration::from_secs(PENDING_DATA_LOG_FREQ_SECS)),
                info!("Waiting for the storage synchronizer to handle pending data!")
            );
        } else {
            // Fetch a new data stream to start streaming data
            self.initialize_active_data_stream(global_data_summary)
                .await?;
        }

        // Check if we've now bootstrapped
        self.notify_listeners_if_bootstrapped().await
    }
```

**File:** state-sync/state-sync-driver/src/bootstrapper.rs (L1517-1536)
```rust
    pub async fn handle_storage_synchronizer_error(
        &mut self,
        notification_and_feedback: NotificationAndFeedback,
    ) -> Result<(), Error> {
        // Reset the active stream
        self.reset_active_stream(Some(notification_and_feedback))
            .await?;

        // Fallback to output syncing if we need to
        if let BootstrappingMode::ExecuteOrApplyFromGenesis = self.get_bootstrapping_mode() {
            self.output_fallback_handler.fallback_to_outputs();
            metrics::set_gauge(
                &metrics::DRIVER_FALLBACK_MODE,
                ExecutingComponent::Bootstrapper.get_label(),
                1,
            );
        }

        Ok(())
    }
```

**File:** state-sync/state-sync-driver/src/bootstrapper.rs (L1539-1556)
```rust
    pub async fn reset_active_stream(
        &mut self,
        notification_and_feedback: Option<NotificationAndFeedback>,
    ) -> Result<(), Error> {
        if let Some(active_data_stream) = &self.active_data_stream {
            let data_stream_id = active_data_stream.data_stream_id;
            utils::terminate_stream_with_feedback(
                &mut self.streaming_client,
                data_stream_id,
                notification_and_feedback,
            )
            .await?;
        }

        self.active_data_stream = None;
        self.speculative_stream_state = None;
        Ok(())
    }
```

**File:** state-sync/data-streaming-service/src/error.rs (L47-50)
```rust
impl From<SendError> for Error {
    fn from(error: SendError) -> Self {
        Error::UnexpectedErrorEncountered(error.to_string())
    }
```

**File:** state-sync/data-streaming-service/src/streaming_client.rs (L311-324)
```rust
    async fn send_stream_request(
        &self,
        client_request: StreamRequest,
    ) -> Result<oneshot::Receiver<Result<DataStreamListener, Error>>, Error> {
        let mut request_sender = self.request_sender.clone();
        let (response_sender, response_receiver) = oneshot::channel();
        let request_message = StreamRequestMessage {
            stream_request: client_request,
            response_sender,
        };
        request_sender.send(request_message).await?;

        Ok(response_receiver)
    }
```
