# Audit Report

## Title
Protocol Incompatibility Risk During Rolling Upgrades: VFN Message Format Causes Deserialization Failures on Older Downstream Nodes

## Summary
VFNs automatically enable `include_ready_time_in_broadcast`, causing them to send `BroadcastTransactionsRequestWithReadyTime` messages to downstream nodes. During rolling upgrades, older nodes lacking this enum variant will fail BCS deserialization, silently dropping mempool broadcasts and disrupting transaction propagation. [1](#0-0) 

## Finding Description

When the `optimize()` function runs for VFN nodes, it unconditionally sets `include_ready_time_in_broadcast = true` if not explicitly configured locally. This causes VFNs to construct and send `BroadcastTransactionsRequestWithReadyTime` messages rather than the original `BroadcastTransactionsRequest` format. [2](#0-1) 

The protocol negotiation occurs at the `ProtocolId` level (specifically `ProtocolId::MempoolDirectSend`), not at the message variant level. Both old and new nodes advertise support for the same protocol ID during handshake. [3](#0-2) 

When an older node receives a `BroadcastTransactionsRequestWithReadyTime` message, the BCS deserialization fails at the application layer because the enum variant doesn't exist in the older codebase. This failure occurs in `request_to_network_event()`, which calls `request.to_message()`. [4](#0-3) 

The deserialization error causes the message to be logged and silently dropped (returns `None`), preventing transaction propagation from VFNs to older downstream nodes during the upgrade window. [5](#0-4) 

## Impact Explanation

This is a **Medium severity** operational issue that could cause:

1. **Transaction Propagation Failures**: During rolling upgrades, transactions broadcast from upgraded VFNs will not reach downstream nodes running older software versions, creating a temporary network partition for transaction dissemination.

2. **Service Degradation**: Public fullnodes and validator fullnodes running older versions would not receive mempool updates from upgraded VFNs, potentially degrading user transaction submission experience.

3. **Network Fragmentation**: The network could fragment into two mempool pools (upgraded vs. non-upgraded) until all nodes complete the upgrade.

However, this does NOT constitute:
- A consensus violation (consensus uses separate protocols)
- Funds loss or theft
- State corruption
- A persistent availability issue (resolves post-upgrade)

The Aptos network employs rolling upgrade strategies where nodes of different versions coexist temporarily. [6](#0-5) 

## Likelihood Explanation

**High Likelihood** during any deployment that:
1. Introduces the `BroadcastTransactionsRequestWithReadyTime` variant to VFNs
2. Uses rolling upgrade procedures where not all nodes upgrade simultaneously
3. Has VFNs broadcasting to downstream nodes running older software

The default VFN configuration automatically enables this feature without explicit opt-in, making it unavoidable during version transitions.

## Recommendation

Implement a **two-phase deployment strategy** for protocol-breaking message format changes:

**Phase 1: Add receiving capability**
- Deploy code with `BroadcastTransactionsRequestWithReadyTime` enum variant
- Keep `include_ready_time_in_broadcast = false` as default
- All nodes can now deserialize both message formats

**Phase 2: Enable transmission**
- After ensuring network-wide deployment of Phase 1
- Change VFN default to `include_ready_time_in_broadcast = true`
- Now safe to send new message format

**Alternative**: Implement protocol version negotiation at message-variant granularity:
```rust
// In ConnectionMetadata or PeerMetadata
pub struct MempoolCapabilities {
    supports_ready_time_broadcast: bool,
}

// In send_batch_to_peer
let request = if self.mempool_config.include_ready_time_in_broadcast 
    && peer_supports_ready_time_broadcast(peer) {
    MempoolSyncMsg::BroadcastTransactionsRequestWithReadyTime { ... }
} else {
    MempoolSyncMsg::BroadcastTransactionsRequest { ... }
}
```

## Proof of Concept

This incompatibility manifests during multi-version deployments. To reproduce:

1. Deploy cluster with Version A (without `BroadcastTransactionsRequestWithReadyTime`)
2. Upgrade VFN to Version B (with the variant and `include_ready_time_in_broadcast=true`)
3. Observe logs on Version A nodes showing deserialization errors:
   ```
   SecurityEvent::InvalidNetworkEvent, protocol_id = MempoolDirectSend
   ```
4. Monitor mempool metrics showing dropped broadcasts from VFN to old nodes
5. Verify transactions submitted to upgraded VFNs don't propagate to non-upgraded nodes

The existing compatibility test framework demonstrates this scenario: [7](#0-6) 

## Notes

While this represents a legitimate **operational compatibility concern** for production deployments, it does **not** constitute an exploitable security vulnerability per the strict validation criteria:

- Not exploitable by unprivileged attackers (requires deployment timing)
- No attack path exists (happens passively during upgrades)  
- Does not break critical invariants (consensus, state consistency, funds security)
- Temporary issue resolving post-upgrade completion

This finding is valuable for deployment planning and should inform release procedures, but falls outside traditional security vulnerability categories. The Medium severity rating in the original question appropriately reflects its operational impact rather than security exploitability.

### Citations

**File:** config/src/config/mempool_config.rs (L234-238)
```rust
            // Set the include_ready_time_in_broadcast to true (default is false)
            if local_mempool_config_yaml["include_ready_time_in_broadcast"].is_null() {
                mempool_config.include_ready_time_in_broadcast = true;
                modified_config = true;
            }
```

**File:** mempool/src/shared_mempool/network.rs (L580-590)
```rust
        let request = if self.mempool_config.include_ready_time_in_broadcast {
            MempoolSyncMsg::BroadcastTransactionsRequestWithReadyTime {
                message_id,
                transactions,
            }
        } else {
            MempoolSyncMsg::BroadcastTransactionsRequest {
                message_id,
                transactions: transactions.into_iter().map(|(txn, _, _)| txn).collect(),
            }
        };
```

**File:** network/framework/src/protocols/wire/handshake/v1/mod.rs (L45-48)
```rust
pub enum ProtocolId {
    ConsensusRpcBcs = 0,
    ConsensusDirectSendBcs = 1,
    MempoolDirectSend = 2,
```

**File:** network/framework/src/protocols/network/mod.rs (L303-321)
```rust
fn request_to_network_event<TMessage: Message, Request: IncomingRequest>(
    peer_id: PeerId,
    request: &Request,
) -> Option<TMessage> {
    match request.to_message() {
        Ok(msg) => Some(msg),
        Err(err) => {
            let data = request.data();
            warn!(
                SecurityEvent::InvalidNetworkEvent,
                error = ?err,
                remote_peer_id = peer_id.short_str(),
                protocol_id = request.protocol_id(),
                data_prefix = hex::encode(&data[..min(16, data.len())]),
            );
            None
        },
    }
}
```

**File:** network/framework/src/protocols/wire/messaging/v1/mod.rs (L225-241)
```rust
    fn poll_next(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<Self::Item>> {
        match self.project().framed_read.poll_next(cx) {
            Poll::Ready(Some(Ok(frame))) => {
                let frame = frame.freeze();

                match bcs::from_bytes(&frame) {
                    Ok(message) => Poll::Ready(Some(Ok(message))),
                    // Failed to deserialize the NetworkMessage
                    Err(err) => {
                        let mut frame = frame;
                        let frame_len = frame.len();
                        // Keep a few bytes from the frame for debugging
                        frame.truncate(8);
                        let err = ReadError::DeserializeError(err, frame_len, frame);
                        Poll::Ready(Some(Err(err)))
                    },
                }
```

**File:** testsuite/testcases/src/compatibility_test.rs (L26-50)
```rust
    async fn run<'a>(&self, ctxa: NetworkContextSynchronizer<'a>) -> Result<()> {
        let upgrade_wait_for_healthy = true;
        let upgrade_node_delay = Duration::from_secs(20);
        let upgrade_max_wait = Duration::from_secs(40);

        let epoch_duration = Duration::from_secs(Self::EPOCH_DURATION_SECS);

        // Get the different versions we're testing with
        let (old_version, new_version) = {
            let mut versions = ctxa
                .ctx
                .lock()
                .await
                .swarm
                .read()
                .await
                .versions()
                .collect::<Vec<_>>();
            versions.sort();
            if versions.len() != 2 {
                bail!("exactly two different versions needed to run compat test");
            }

            (versions[0].clone(), versions[1].clone())
        };
```

**File:** testsuite/testcases/src/compatibility_test.rs (L83-100)
```rust
        let mut first_batch = all_validators.clone();
        let second_batch = first_batch.split_off(first_batch.len() / 2);
        let first_node = first_batch.pop().unwrap();
        let duration = Duration::from_secs(30);

        let msg = format!(
            "1. Check liveness of validators at old version: {}",
            old_version
        );
        info!("{}", msg);
        ctxa.report_text(msg).await;

        // Generate some traffic
        {
            let mut ctx_locker = ctxa.ctx.lock().await;
            let ctx = ctx_locker.deref_mut();
            let txn_stat_prior = generate_traffic(ctx, &all_validators, duration).await?;
            ctx.report
```
