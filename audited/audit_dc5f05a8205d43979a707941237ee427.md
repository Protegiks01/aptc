# Audit Report

## Title
Missing Validation for batch_expiry_gap_when_init_usecs Allows Premature Batch Expiry Leading to Consensus Liveness Degradation

## Summary
The `batch_expiry_gap_when_init_usecs` configuration parameter in QuorumStoreConfig lacks minimum value validation, allowing validators to set arbitrarily small values (e.g., 1 microsecond) that cause locally created batches to expire before they can be used in consensus, resulting in wasted computational work, network bandwidth, and potential liveness degradation.

## Finding Description

The QuorumStoreConfig struct defines `batch_expiry_gap_when_init_usecs` with a default value of 60 seconds, but the ConfigSanitizer implementation only validates batch size and count limitsâ€”it does not enforce any minimum value for batch expiry timing. [1](#0-0) [2](#0-1) [3](#0-2) 

When a batch is created, its expiration time is calculated by adding `batch_expiry_gap_when_init_usecs` to the current timestamp: [4](#0-3) 

If this value is set to 1 microsecond, batches expire almost instantly. Since network latency is typically 1-100 milliseconds (1,000-100,000 microseconds) and consensus latency is 100ms-1s, the batches will expire before they can be:
1. Broadcast to other validators
2. Collected into quorum certificates (proofs of store)
3. Included in block proposals

The system actively rejects expired batches at multiple points: [5](#0-4) [6](#0-5) [7](#0-6) 

The batch creation timestamp is reverse-engineered from the expiration time in multiple places, making the system dependent on reasonable expiry gap values: [8](#0-7) [9](#0-8) 

## Impact Explanation

This vulnerability meets **High Severity** criteria per the Aptos bug bounty program:

1. **Validator node slowdowns**: Continuous creation of immediately-expired batches wastes CPU cycles, network bandwidth, and storage I/O without contributing to consensus progress.

2. **Significant protocol violations**: Batches that should contribute to consensus liveness become unusable, reducing effective network throughput. If multiple validators misconfigure this parameter, the network's transaction processing capacity degrades proportionally.

3. **Resource exhaustion**: Transactions are repeatedly pulled from mempool, processed, signed, and broadcast, only to expire before use. This creates a resource consumption loop without productive output.

4. **Consensus liveness degradation**: While not causing complete liveness failure, misconfigured validators cannot contribute batches to proposals, reducing overall network capacity and increasing transaction confirmation latency.

## Likelihood Explanation

**Likelihood: Medium to High**

This issue can occur through:

1. **Configuration errors**: A validator operator mistakenly entering microseconds instead of seconds (e.g., typing `60` instead of `60000000`), or making an order-of-magnitude error in unit conversion.

2. **Config file corruption**: Automated configuration management tools or manual edits could inadvertently modify this value.

3. **Copy-paste errors**: Copying configuration from one context to another without understanding the unit requirements.

4. **Lack of safeguards**: Unlike other QuorumStore parameters that have explicit validation, this critical timing parameter has no lower bounds, making it a "footgun" for operators.

The absence of validation is particularly concerning because:
- The default value is in microseconds (60,000,000), making it easy to confuse with seconds
- Other timing parameters in the same config use milliseconds, creating unit inconsistency
- The ConfigSanitizer explicitly validates other parameters but omits this one, suggesting incomplete security hardening

## Recommendation

Add minimum value validation for `batch_expiry_gap_when_init_usecs` in the ConfigSanitizer implementation:

```rust
impl ConfigSanitizer for QuorumStoreConfig {
    fn sanitize(
        node_config: &NodeConfig,
        _node_type: NodeType,
        _chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();

        // Sanitize the send/recv batch limits
        Self::sanitize_send_recv_batch_limits(
            &sanitizer_name,
            &node_config.consensus.quorum_store,
        )?;

        // Sanitize the batch total limits
        Self::sanitize_batch_total_limits(&sanitizer_name, &node_config.consensus.quorum_store)?;

        // NEW: Sanitize batch expiry timing parameters
        Self::sanitize_batch_expiry_timing(&sanitizer_name, &node_config.consensus.quorum_store)?;

        Ok(())
    }
}

impl QuorumStoreConfig {
    // ... existing methods ...

    fn sanitize_batch_expiry_timing(
        sanitizer_name: &str,
        config: &QuorumStoreConfig,
    ) -> Result<(), Error> {
        // Minimum 10 seconds to account for network latency and consensus delays
        const MIN_BATCH_EXPIRY_GAP_USECS: u64 = Duration::from_secs(10).as_micros() as u64;
        
        if config.batch_expiry_gap_when_init_usecs < MIN_BATCH_EXPIRY_GAP_USECS {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name.to_owned(),
                format!(
                    "batch_expiry_gap_when_init_usecs too small: {} < {} (minimum 10 seconds)",
                    config.batch_expiry_gap_when_init_usecs,
                    MIN_BATCH_EXPIRY_GAP_USECS
                ),
            ));
        }

        if config.remote_batch_expiry_gap_when_init_usecs < MIN_BATCH_EXPIRY_GAP_USECS {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name.to_owned(),
                format!(
                    "remote_batch_expiry_gap_when_init_usecs too small: {} < {} (minimum 10 seconds)",
                    config.remote_batch_expiry_gap_when_init_usecs,
                    MIN_BATCH_EXPIRY_GAP_USECS
                ),
            ));
        }

        Ok(())
    }
}
```

The minimum value of 10 seconds provides sufficient margin for:
- Network propagation delays (typically <100ms)
- Signature collection for proofs (hundreds of milliseconds)
- Consensus round progression (seconds)
- Clock drift between validators

## Proof of Concept

```rust
#[cfg(test)]
mod test {
    use super::*;
    use crate::config::ConsensusConfig;

    #[test]
    fn test_batch_expiry_gap_too_small() {
        // Create a node config with dangerously small batch_expiry_gap_when_init_usecs
        let node_config = NodeConfig {
            consensus: ConsensusConfig {
                quorum_store: QuorumStoreConfig {
                    batch_expiry_gap_when_init_usecs: 1, // 1 microsecond - will cause immediate expiry
                    ..Default::default()
                },
                ..Default::default()
            },
            ..Default::default()
        };

        // Sanitize the config and verify that it fails
        let error = QuorumStoreConfig::sanitize(
            &node_config,
            NodeType::Validator,
            Some(ChainId::mainnet()),
        )
        .unwrap_err();
        
        assert!(matches!(error, Error::ConfigSanitizerFailed(_, _)));
        assert!(error.to_string().contains("batch_expiry_gap_when_init_usecs too small"));
    }

    #[test]
    fn test_remote_batch_expiry_gap_too_small() {
        // Create a node config with dangerously small remote_batch_expiry_gap_when_init_usecs
        let node_config = NodeConfig {
            consensus: ConsensusConfig {
                quorum_store: QuorumStoreConfig {
                    remote_batch_expiry_gap_when_init_usecs: 100, // 100 microseconds - too small
                    ..Default::default()
                },
                ..Default::default()
            },
            ..Default::default()
        };

        // Sanitize the config and verify that it fails
        let error = QuorumStoreConfig::sanitize(
            &node_config,
            NodeType::Validator,
            Some(ChainId::mainnet()),
        )
        .unwrap_err();
        
        assert!(matches!(error, Error::ConfigSanitizerFailed(_, _)));
    }

    #[test]
    fn test_valid_batch_expiry_gaps() {
        // Create a node config with reasonable expiry gaps
        let node_config = NodeConfig {
            consensus: ConsensusConfig {
                quorum_store: QuorumStoreConfig {
                    batch_expiry_gap_when_init_usecs: Duration::from_secs(30).as_micros() as u64,
                    remote_batch_expiry_gap_when_init_usecs: Duration::from_secs(10).as_micros() as u64,
                    ..Default::default()
                },
                ..Default::default()
            },
            ..Default::default()
        };

        // This should pass validation
        assert!(QuorumStoreConfig::sanitize(
            &node_config,
            NodeType::Validator,
            Some(ChainId::mainnet()),
        ).is_ok());
    }
}
```

## Notes

While this vulnerability primarily affects validators who misconfigure their own nodes (a form of self-inflicted harm), the lack of validation represents a systemic weakness in the configuration sanitization layer. The impact extends beyond individual misconfiguration because:

1. Multiple validators with this misconfiguration reduce overall network throughput proportionally
2. The issue can occur through honest mistakes, not just malicious intent
3. The ConfigSanitizer pattern exists specifically to prevent such misconfigurations
4. Other parameters have explicit validation, making the omission of timing parameter validation an inconsistent security posture

This finding aligns with defense-in-depth principles: critical system parameters should have validation at configuration load time, not just rely on operators to provide correct values.

### Citations

**File:** config/src/config/quorum_store_config.rs (L89-91)
```rust
    pub batch_expiry_gap_when_init_usecs: u64,
    /// Duration for expiring remotely created batches. The txns are filtered to prevent dupliation across validators.
    pub remote_batch_expiry_gap_when_init_usecs: u64,
```

**File:** config/src/config/quorum_store_config.rs (L131-132)
```rust
            batch_expiry_gap_when_init_usecs: Duration::from_secs(60).as_micros() as u64,
            remote_batch_expiry_gap_when_init_usecs: Duration::from_millis(500).as_micros() as u64,
```

**File:** config/src/config/quorum_store_config.rs (L253-272)
```rust
impl ConfigSanitizer for QuorumStoreConfig {
    fn sanitize(
        node_config: &NodeConfig,
        _node_type: NodeType,
        _chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();

        // Sanitize the send/recv batch limits
        Self::sanitize_send_recv_batch_limits(
            &sanitizer_name,
            &node_config.consensus.quorum_store,
        )?;

        // Sanitize the batch total limits
        Self::sanitize_batch_total_limits(&sanitizer_name, &node_config.consensus.quorum_store)?;

        Ok(())
    }
}
```

**File:** consensus/src/quorum_store/batch_generator.rs (L383-384)
```rust
        let expiry_time = aptos_infallible::duration_since_epoch().as_micros() as u64
            + self.config.batch_expiry_gap_when_init_usecs;
```

**File:** consensus/src/quorum_store/batch_generator.rs (L536-552)
```rust
                            for (author, batch_id) in self.batch_expirations.expire(block_timestamp) {
                                if let Some(batch_in_progress) = self.batches_in_progress.get(&(author, batch_id)) {
                                    // If there is an identical batch with higher expiry time, re-insert it.
                                    if batch_in_progress.expiry_time_usecs > block_timestamp {
                                        self.batch_expirations.add_item((author, batch_id), batch_in_progress.expiry_time_usecs);
                                        continue;
                                    }
                                }
                                if self.remove_batch_in_progress(author, batch_id) {
                                    counters::BATCH_IN_PROGRESS_EXPIRED.inc();
                                    debug!(
                                        "QS: logical time based expiration batch w. id {} from batches_in_progress, new size {}",
                                        batch_id,
                                        self.batches_in_progress.len(),
                                    );
                                }
                            }
```

**File:** consensus/src/quorum_store/batch_proof_queue.rs (L176-179)
```rust
        if proof.expiration() <= self.latest_block_timestamp {
            counters::inc_rejected_pos_count(counters::POS_EXPIRED_LABEL);
            return;
        }
```

**File:** consensus/src/quorum_store/batch_proof_queue.rs (L603-612)
```rust
                    let batch_create_ts_usecs =
                        item.info.expiration() - self.batch_expiry_gap_when_init_usecs;

                    // Ensure that the batch was created at least `min_batch_age_usecs` ago to
                    // reduce the chance of inline fetches.
                    if max_batch_creation_ts_usecs
                        .is_some_and(|max_create_ts| batch_create_ts_usecs > max_create_ts)
                    {
                        return None;
                    }
```

**File:** consensus/src/quorum_store/batch_proof_queue.rs (L729-759)
```rust
        let expired = self.expirations.expire(block_timestamp);
        let mut num_expired_but_not_committed = 0;
        for key in &expired {
            if let Some(mut queue) = self.author_to_batches.remove(&key.author()) {
                if let Some(batch) = queue.remove(key) {
                    let item = self
                        .items
                        .get(&key.batch_key)
                        .expect("Entry for unexpired batch must exist");
                    if item.proof.is_some() {
                        // not committed proof that is expired
                        num_expired_but_not_committed += 1;
                        counters::GAP_BETWEEN_BATCH_EXPIRATION_AND_CURRENT_TIME_WHEN_COMMIT
                            .observe((block_timestamp - batch.expiration()) as f64);
                        if let Some(ref txn_summaries) = item.txn_summaries {
                            for txn_summary in txn_summaries {
                                if let Some(count) =
                                    self.txn_summary_num_occurrences.get_mut(txn_summary)
                                {
                                    *count -= 1;
                                    if *count == 0 {
                                        self.txn_summary_num_occurrences.remove(txn_summary);
                                    }
                                };
                            }
                        }
                        self.dec_remaining_proofs(&batch.author(), batch.num_txns());
                        counters::GARBAGE_COLLECTED_IN_PROOF_QUEUE_COUNTER
                            .with_label_values(&["expired_proof"])
                            .inc();
                    }
```

**File:** consensus/src/quorum_store/batch_coordinator.rs (L215-218)
```rust
        let approx_created_ts_usecs = batch
            .info()
            .expiration()
            .saturating_sub(self.batch_expiry_gap_when_init_usecs);
```
