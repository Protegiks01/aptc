# Audit Report

## Title
Authorization Bypass in Consensus Publisher Subscribe Handler Allows Unauthorized Access to Real-Time Consensus Updates

## Summary
The consensus observer publisher's `process_network_message()` function accepts Subscribe requests from any connected peer without validating whether the requesting peer is an authorized validator or observer. This allows malicious non-validator nodes to subscribe to real-time consensus updates, gaining access to ordered blocks, commit decisions, and transaction payloads before they are publicly committed.

## Finding Description

The vulnerability exists in the Subscribe request handler within the `ConsensusPublisher::process_network_message()` function. When a peer sends a `ConsensusObserverRequest::Subscribe` message, the function immediately adds the peer to the active subscribers set without performing any authorization checks. [1](#0-0) 

The critical flaw is at lines 181-193, where the Subscribe request handler unconditionally accepts any subscription request:
- It receives the `peer_network_id` from the network message
- Immediately calls `add_active_subscriber(peer_network_id)` without validation
- Sends a SubscribeAck response

Once a peer is added to the active subscribers, the `publish_message()` function broadcasts all consensus updates to that peer: [2](#0-1) 

The consensus observer is registered on **all network types** (validator, VFN, and public networks) when enabled: [3](#0-2) 

This means the publisher operates on multiple networks simultaneously, including public-facing networks that do not require mutual authentication. The network handler forwards all Subscribe requests to the publisher without network-specific filtering: [4](#0-3) 

The handler only checks if the publisher is enabled (line 201), not whether the peer is authorized.

**Attack Path:**
1. Validator Fullnode (VFN) has publisher enabled by default and accepts connections on public network
2. Malicious peer connects to the VFN's public network endpoint
3. Peer sends `ConsensusObserverRequest::Subscribe` RPC
4. Network handler forwards request to publisher (no authorization check)
5. Publisher adds peer to `active_subscribers` (no validation)
6. Peer receives all consensus updates including:
   - OrderedBlock messages with blocks and proofs
   - CommitDecision messages with commit proofs
   - BlockPayload messages with transactions and batch info [5](#0-4) 

The consensus messages contain sensitive information about ongoing consensus: [6](#0-5) 

## Impact Explanation

This vulnerability qualifies as **HIGH severity** under the Aptos bug bounty criteria for the following reasons:

1. **Significant Protocol Violation**: The consensus observer pattern is designed to allow authorized observers (primarily VFNs and validators) to receive consensus updates. Allowing unauthorized peers to subscribe violates the intended access control model.

2. **Information Disclosure**: Attackers gain access to:
   - Real-time consensus decisions before public commitment
   - Full transaction payloads including user transactions
   - Block ordering information and proofs
   - Execution pool window data

3. **Potential for Front-Running**: With access to ordered blocks before they are committed, malicious actors could:
   - Front-run transactions by observing pending transactions in ordered blocks
   - Gain unfair market advantages in DeFi applications
   - Predict consensus outcomes before finalization

4. **Widespread Exposure**: Validator Fullnodes (VFNs) are commonly deployed with publisher enabled by default: [7](#0-6) 

VFNs typically have public network connections, making them vulnerable to this attack.

While this does not directly cause loss of funds or consensus violations (the messages are signed and cannot be tampered with), it represents a significant information leak that undermines the security model and enables potential economic attacks.

## Likelihood Explanation

**Likelihood: HIGH**

This vulnerability is highly likely to be exploited because:

1. **Trivial to Exploit**: The attack requires only:
   - Network connectivity to a VFN's public endpoint
   - Sending a single Subscribe RPC request
   - No special privileges or insider access required

2. **Common Configuration**: VFNs with publisher enabled are deployed throughout the Aptos network, and many accept public connections for serving fullnode clients.

3. **No Detection**: There are no authorization checks or logging to detect unauthorized subscriptions. The only constraint is the garbage collection mechanism that removes disconnected peers: [8](#0-7) 

But this only removes disconnected peers, not unauthorized ones.

4. **Clear Economic Incentive**: Access to real-time consensus information provides significant advantages for MEV extraction and trading strategies, creating strong motivation for exploitation.

## Recommendation

Implement authorization validation in the `process_network_message()` function to verify that requesting peers are authorized validators or observers before accepting Subscribe requests.

**Recommended Fix:**

Add authorization check before accepting subscriptions:

```rust
fn process_network_message(&self, network_message: ConsensusPublisherNetworkMessage) {
    let (peer_network_id, message, response_sender) = network_message.into_parts();
    
    metrics::increment_counter(
        &metrics::PUBLISHER_RECEIVED_REQUESTS,
        message.get_label(),
        &peer_network_id,
    );
    
    match message {
        ConsensusObserverRequest::Subscribe => {
            // **FIX: Add authorization check**
            if !self.is_peer_authorized(&peer_network_id) {
                warn!(LogSchema::new(LogEntry::ConsensusPublisher)
                    .event(LogEvent::Subscription)
                    .message(&format!(
                        "Rejected unauthorized subscription request from peer: {:?}",
                        peer_network_id
                    )));
                response_sender.send(ConsensusObserverResponse::UnauthorizedError);
                return;
            }
            
            self.add_active_subscriber(peer_network_id);
            // ... rest of existing code
        },
        // ... rest of handler
    }
}

// Add new method to verify peer authorization
fn is_peer_authorized(&self, peer_network_id: &PeerNetworkId) -> bool {
    // Check if peer is on validator network or authenticated VFN
    match peer_network_id.network_id() {
        NetworkId::Validator => true, // Validator network requires mutual auth
        NetworkId::Vfn | NetworkId::Public => {
            // For VFN/public networks, verify peer is in trusted set
            let peers_and_metadata = self.consensus_observer_client.get_peers_and_metadata();
            peers_and_metadata.is_peer_trusted(peer_network_id)
        }
        _ => false,
    }
}
```

Additionally, consider:
1. Adding explicit configuration for authorized observer peers
2. Implementing rate limiting for subscription requests
3. Adding metrics to monitor subscription patterns
4. Restricting publisher to validator network only for high-security deployments

## Proof of Concept

```rust
#[tokio::test]
async fn test_unauthorized_subscription_bypass() {
    use aptos_config::network_id::{NetworkId, PeerNetworkId};
    use aptos_network::application::storage::PeersAndMetadata;
    use aptos_types::PeerId;
    
    // Create a network client with a public network
    let network_id = NetworkId::Public;
    let peers_and_metadata = PeersAndMetadata::new(&[network_id]);
    let network_client = NetworkClient::new(
        vec![],
        vec![],
        hashmap!{},
        peers_and_metadata.clone()
    );
    let consensus_observer_client = Arc::new(ConsensusObserverClient::new(network_client));
    
    // Create a consensus publisher
    let (consensus_publisher, _) = ConsensusPublisher::new(
        ConsensusObserverConfig::default(),
        consensus_observer_client,
    );
    
    // Create an UNAUTHORIZED peer (not in validator set, not authenticated)
    let malicious_peer = PeerNetworkId::new(network_id, PeerId::random());
    
    // Malicious peer sends Subscribe request
    let network_message = ConsensusPublisherNetworkMessage::new(
        malicious_peer,
        ConsensusObserverRequest::Subscribe,
        ResponseSender::new_for_test(),
    );
    
    // Process the subscription request
    consensus_publisher.process_network_message(network_message);
    
    // VULNERABILITY: Unauthorized peer is now an active subscriber!
    let active_subscribers = consensus_publisher.get_active_subscribers();
    assert!(active_subscribers.contains(&malicious_peer));
    
    // Publish a consensus message
    let ordered_block = ConsensusObserverMessage::new_ordered_block_message(
        vec![],
        LedgerInfoWithSignatures::new(
            LedgerInfo::new(BlockInfo::empty(), HashValue::zero()),
            AggregateSignature::empty(),
        ),
    );
    
    // VULNERABILITY: Unauthorized peer receives consensus updates!
    consensus_publisher.publish_message(ordered_block);
    
    // The malicious peer now has access to real-time consensus information
    println!("EXPLOIT SUCCESS: Unauthorized peer subscribed and receiving consensus updates");
}
```

## Notes

This vulnerability represents a fundamental access control failure in the consensus observer subsystem. While the consensus messages themselves are cryptographically signed and cannot be tampered with, the unauthorized access to real-time consensus information before public commitment enables information asymmetry that can be exploited for economic gain. The fix requires implementing proper peer authorization before accepting subscriptions, particularly on public-facing networks.

### Citations

**File:** consensus/src/consensus_observer/publisher/consensus_publisher.rs (L98-155)
```rust
    /// Garbage collect inactive subscriptions by removing peers that are no longer connected
    fn garbage_collect_subscriptions(&self) {
        // Get the set of active subscribers
        let active_subscribers = self.get_active_subscribers();

        // Get the connected peers and metadata
        let peers_and_metadata = self.consensus_observer_client.get_peers_and_metadata();
        let connected_peers_and_metadata =
            match peers_and_metadata.get_connected_peers_and_metadata() {
                Ok(connected_peers_and_metadata) => connected_peers_and_metadata,
                Err(error) => {
                    // We failed to get the connected peers and metadata
                    warn!(LogSchema::new(LogEntry::ConsensusPublisher)
                        .event(LogEvent::UnexpectedError)
                        .message(&format!(
                            "Failed to get connected peers and metadata! Error: {:?}",
                            error
                        )));
                    return;
                },
            };

        // Identify the active subscribers that are no longer connected
        let connected_peers: HashSet<PeerNetworkId> =
            connected_peers_and_metadata.keys().cloned().collect();
        let disconnected_subscribers: HashSet<PeerNetworkId> = active_subscribers
            .difference(&connected_peers)
            .cloned()
            .collect();

        // Remove any subscriptions from peers that are no longer connected
        for peer_network_id in &disconnected_subscribers {
            self.remove_active_subscriber(peer_network_id);
            info!(LogSchema::new(LogEntry::ConsensusPublisher)
                .event(LogEvent::Subscription)
                .message(&format!(
                    "Removed peer subscription due to disconnection! Peer: {:?}",
                    peer_network_id
                )));
        }

        // Update the number of active subscribers for each network
        let active_subscribers = self.get_active_subscribers();
        for network_id in peers_and_metadata.get_registered_networks() {
            // Calculate the number of active subscribers for the network
            let num_active_subscribers = active_subscribers
                .iter()
                .filter(|peer_network_id| peer_network_id.network_id() == network_id)
                .count() as i64;

            // Update the active subscriber metric
            metrics::set_gauge(
                &metrics::PUBLISHER_NUM_ACTIVE_SUBSCRIBERS,
                &network_id,
                num_active_subscribers,
            );
        }
    }
```

**File:** consensus/src/consensus_observer/publisher/consensus_publisher.rs (L168-208)
```rust
    fn process_network_message(&self, network_message: ConsensusPublisherNetworkMessage) {
        // Unpack the network message
        let (peer_network_id, message, response_sender) = network_message.into_parts();

        // Update the RPC request counter
        metrics::increment_counter(
            &metrics::PUBLISHER_RECEIVED_REQUESTS,
            message.get_label(),
            &peer_network_id,
        );

        // Handle the message
        match message {
            ConsensusObserverRequest::Subscribe => {
                // Add the peer to the set of active subscribers
                self.add_active_subscriber(peer_network_id);
                info!(LogSchema::new(LogEntry::ConsensusPublisher)
                    .event(LogEvent::Subscription)
                    .message(&format!(
                        "New peer subscribed to consensus updates! Peer: {:?}",
                        peer_network_id
                    )));

                // Send a simple subscription ACK
                response_sender.send(ConsensusObserverResponse::SubscribeAck);
            },
            ConsensusObserverRequest::Unsubscribe => {
                // Remove the peer from the set of active subscribers
                self.remove_active_subscriber(&peer_network_id);
                info!(LogSchema::new(LogEntry::ConsensusPublisher)
                    .event(LogEvent::Subscription)
                    .message(&format!(
                        "Peer unsubscribed from consensus updates! Peer: {:?}",
                        peer_network_id
                    )));

                // Send a simple unsubscription ACK
                response_sender.send(ConsensusObserverResponse::UnsubscribeAck);
            },
        }
    }
```

**File:** consensus/src/consensus_observer/publisher/consensus_publisher.rs (L212-232)
```rust
    pub fn publish_message(&self, message: ConsensusObserverDirectSend) {
        // Get the active subscribers
        let active_subscribers = self.get_active_subscribers();

        // Send the message to all active subscribers
        for peer_network_id in &active_subscribers {
            // Send the message to the outbound receiver for publishing
            let mut outbound_message_sender = self.outbound_message_sender.clone();
            if let Err(error) =
                outbound_message_sender.try_send((*peer_network_id, message.clone()))
            {
                // The message send failed
                warn!(LogSchema::new(LogEntry::ConsensusPublisher)
                        .event(LogEvent::SendDirectSendMessage)
                        .message(&format!(
                            "Failed to send outbound message to the receiver for peer {:?}! Error: {:?}",
                            peer_network_id, error
                    )));
            }
        }
    }
```

**File:** aptos-node/src/network.rs (L336-358)
```rust
        // Register consensus observer (both client and server) with the network
        if node_config
            .consensus_observer
            .is_observer_or_publisher_enabled()
        {
            // Create the network handle for this network type
            let network_handle = register_client_and_service_with_network(
                &mut network_builder,
                network_id,
                &network_config,
                consensus_observer_network_configuration(node_config),
                false,
            );

            // Add the network handle to the set of handles
            if let Some(consensus_observer_network_handles) =
                &mut consensus_observer_network_handles
            {
                consensus_observer_network_handles.push(network_handle);
            } else {
                consensus_observer_network_handles = Some(vec![network_handle]);
            }
        }
```

**File:** consensus/src/consensus_observer/network/network_handler.rs (L193-232)
```rust
    /// Handles a publisher message by forwarding it to the consensus publisher
    fn handle_publisher_message(
        &mut self,
        peer_network_id: PeerNetworkId,
        request: ConsensusObserverRequest,
        response_sender: Option<ResponseSender>,
    ) {
        // Drop the message if the publisher is not enabled
        if !self.consensus_observer_config.publisher_enabled {
            return;
        }

        // Ensure that the response sender is present
        let response_sender = match response_sender {
            Some(response_sender) => response_sender,
            None => {
                error!(
                    LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                        "Missing response sender for the RPC request: {:?}",
                        request
                    ))
                );
                return; // Something has gone wrong!
            },
        };

        // Create the consensus publisher message
        let network_message =
            ConsensusPublisherNetworkMessage::new(peer_network_id, request, response_sender);

        // Send the message to the consensus publisher
        if let Err(error) = self.publisher_message_sender.push((), network_message) {
            error!(
                LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                    "Failed to forward the publisher request to the consensus publisher! Error: {:?}",
                    error
                ))
            );
        }
    }
```

**File:** consensus/src/consensus_observer/network/observer_message.rs (L128-147)
```rust
/// Types of direct sends that can be sent between the consensus publisher and observer
#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
pub enum ConsensusObserverDirectSend {
    OrderedBlock(OrderedBlock),
    CommitDecision(CommitDecision),
    BlockPayload(BlockPayload),
    OrderedBlockWithWindow(OrderedBlockWithWindow),
}

impl ConsensusObserverDirectSend {
    /// Returns a summary label for the direct send
    pub fn get_label(&self) -> &'static str {
        match self {
            ConsensusObserverDirectSend::OrderedBlock(_) => "ordered_block",
            ConsensusObserverDirectSend::CommitDecision(_) => "commit_decision",
            ConsensusObserverDirectSend::BlockPayload(_) => "block_payload",
            ConsensusObserverDirectSend::OrderedBlockWithWindow(_) => "ordered_block_with_window",
        }
    }
}
```

**File:** consensus/src/consensus_observer/network/observer_message.rs (L179-224)
```rust
/// OrderedBlock message contains the ordered blocks and the proof of the ordering
#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
pub struct OrderedBlock {
    blocks: Vec<Arc<PipelinedBlock>>,
    ordered_proof: LedgerInfoWithSignatures,
}

impl OrderedBlock {
    pub fn new(blocks: Vec<Arc<PipelinedBlock>>, ordered_proof: LedgerInfoWithSignatures) -> Self {
        Self {
            blocks,
            ordered_proof,
        }
    }

    /// Returns a reference to the ordered blocks
    pub fn blocks(&self) -> &Vec<Arc<PipelinedBlock>> {
        &self.blocks
    }

    /// Returns a copy of the first ordered block
    pub fn first_block(&self) -> Arc<PipelinedBlock> {
        self.blocks
            .first()
            .cloned()
            .expect("At least one block is expected!")
    }

    /// Returns a copy of the last ordered block
    pub fn last_block(&self) -> Arc<PipelinedBlock> {
        self.blocks
            .last()
            .cloned()
            .expect("At least one block is expected!")
    }

    /// Returns a reference to the ordered proof
    pub fn ordered_proof(&self) -> &LedgerInfoWithSignatures {
        &self.ordered_proof
    }

    /// Returns a reference to the ordered proof block info
    pub fn proof_block_info(&self) -> &BlockInfo {
        self.ordered_proof.commit_info()
    }

```

**File:** config/src/config/consensus_observer_config.rs (L119-128)
```rust
            NodeType::ValidatorFullnode => {
                if ENABLE_ON_VALIDATOR_FULLNODES
                    && !observer_manually_set
                    && !publisher_manually_set
                {
                    // Enable both the observer and the publisher for VFNs
                    consensus_observer_config.observer_enabled = true;
                    consensus_observer_config.publisher_enabled = true;
                    modified_config = true;
                }
```
