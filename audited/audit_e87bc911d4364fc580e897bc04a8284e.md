# Audit Report

## Title
Mempool Garbage Collection Configuration Unit Mismatch Allows Expired Transaction Accumulation and Resource Exhaustion

## Summary
The mempool configuration uses different time units for `system_transaction_timeout_secs` (seconds) and `system_transaction_gc_interval_ms` (milliseconds) without validation, allowing configurations where the GC interval exceeds the transaction timeout period. This causes expired transactions to accumulate in memory between GC runs, leading to resource exhaustion and potential denial of service.

## Finding Description

The vulnerability exists in the mempool's garbage collection system, which uses two separate configuration parameters with different time units: [1](#0-0) 

When a transaction is added to mempool, its expiration time is calculated based on `system_transaction_timeout`: [2](#0-1) 

The garbage collection coordinator runs periodically based on `system_transaction_gc_interval_ms`: [3](#0-2) 

The GC process removes transactions where `expiration_time < now`: [4](#0-3) 

**Critical Issue**: There is NO validation to ensure `system_transaction_gc_interval_ms` â‰¤ `system_transaction_timeout_secs * 1000`: [5](#0-4) 

**Attack Scenario:**
If misconfigured with `system_transaction_gc_interval_ms` > `system_transaction_timeout_secs * 1000`:
- Transaction timeout: 60 seconds (60,000 ms)
- GC interval: 120,000 ms (120 seconds)

Expired transactions accumulate for 60+ seconds between GC runs. These transactions remain in:
1. The main transaction HashMap
2. The priority_index (used by consensus to pull transactions)
3. The timeline_index (used for broadcasting to peers)
4. The system_ttl_index

During this window, expired transactions:
- Consume memory (default capacity: 2M transactions, 2GB)
- Are still iterated over in `get_batch()` for consensus
- Are still broadcast to peers via `read_timeline()`
- Waste CPU cycles during all mempool operations

**Exploitation Path:**
1. Operator misconfigures due to unit mismatch (easy mistake: seconds vs milliseconds)
2. OR attacker with config access deliberately sets: `timeout=10s, gc_interval=600000ms`
3. Attacker floods mempool with transactions
4. Transactions expire quickly but remain in mempool for extended period
5. Memory and CPU resources are exhausted
6. Validator node performance degrades significantly

## Impact Explanation

This vulnerability qualifies as **MEDIUM Severity** per Aptos Bug Bounty criteria:

1. **Resource Exhaustion**: With default capacity of 2M transactions and 2GB, an attacker can force nodes to maintain expired transactions consuming significant memory

2. **State Inconsistencies**: Expired transactions that should be removed remain in mempool state, causing inconsistencies between expected and actual mempool contents

3. **Node Performance Degradation**: Iterating over large numbers of expired transactions during `get_batch()` operations slows consensus block creation, and broadcasting expired transactions wastes network bandwidth

4. **Cascading Effects**: If multiple validator nodes are misconfigured, the entire network performance degrades as expired transactions are repeatedly broadcast and processed

The issue breaks the "Resource Limits" invariant - all operations must respect storage and computational limits. This directly impacts validator node availability and performance.

## Likelihood Explanation

**HIGH Likelihood** due to:

1. **Unit Mismatch**: The configuration uses different units (seconds vs milliseconds), making misconfiguration highly probable. A typical operator might set:
   - `system_transaction_timeout_secs: 60` (meaning 60 seconds)
   - `system_transaction_gc_interval_ms: 120` (intending 120ms but effectively 0.12 seconds!)
   
   OR conversely set `gc_interval_ms: 120000` thinking it matches but it's 120 seconds vs 60 seconds timeout.

2. **No Validation**: The `ConfigSanitizer::sanitize()` explicitly has a TODO comment indicating validation is missing

3. **Default Values Show Proper Ratio**: Default config has timeout=600s and gc_interval=60000ms (60s), showing 10:1 ratio. However, nothing enforces this relationship

4. **Operator Error**: Configuration files are typically edited manually, making typos or unit confusion common

5. **No Runtime Warning**: Even if misconfigured, the system provides no warning that GC runs less frequently than expiration

## Recommendation

Implement strict validation in `ConfigSanitizer::sanitize()`:

```rust
impl ConfigSanitizer for MempoolConfig {
    fn sanitize(
        _node_config: &NodeConfig,
        _node_type: NodeType,
        _chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        // Validate that GC runs at least as frequently as transactions expire
        let timeout_ms = self.system_transaction_timeout_secs * 1000;
        if self.system_transaction_gc_interval_ms > timeout_ms {
            return Err(Error::ConfigSanitizerFailed(format!(
                "Invalid mempool config: system_transaction_gc_interval_ms ({}) must be <= system_transaction_timeout_secs ({}) * 1000 ({}ms). \
                Expired transactions would accumulate for {}ms between GC runs.",
                self.system_transaction_gc_interval_ms,
                self.system_transaction_timeout_secs,
                timeout_ms,
                self.system_transaction_gc_interval_ms - timeout_ms
            )));
        }
        
        // Additional safety check: ensure GC runs reasonably frequently
        if self.system_transaction_gc_interval_ms > 300_000 { // 5 minutes
            return Err(Error::ConfigSanitizerFailed(format!(
                "system_transaction_gc_interval_ms ({}) is too large (max 300000ms). \
                Frequent GC is necessary to prevent memory exhaustion.",
                self.system_transaction_gc_interval_ms
            )));
        }
        
        Ok(())
    }
}
```

**Additional Recommendations:**
1. Standardize time units (use milliseconds for both, or add strongly-typed Duration wrappers)
2. Add runtime metrics tracking the number of expired transactions in mempool
3. Add alerts when expired transaction count exceeds threshold

## Proof of Concept

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use aptos_types::chain_id::ChainId;

    #[test]
    #[should_panic(expected = "must be <= system_transaction_timeout_secs")]
    fn test_misconfigured_gc_interval_exceeds_timeout() {
        let mut config = NodeConfig::default();
        
        // Misconfigure: timeout is 60 seconds, but GC runs every 120 seconds
        config.mempool.system_transaction_timeout_secs = 60;
        config.mempool.system_transaction_gc_interval_ms = 120_000; // 120 seconds
        
        // This should fail validation
        MempoolConfig::sanitize(
            &config,
            NodeType::Validator,
            Some(ChainId::test()),
        ).expect("Should fail: GC interval exceeds timeout");
    }
    
    #[test]
    fn test_correct_gc_interval_configuration() {
        let mut config = NodeConfig::default();
        
        // Correct configuration: GC runs every 30 seconds, timeout is 60 seconds
        config.mempool.system_transaction_timeout_secs = 60;
        config.mempool.system_transaction_gc_interval_ms = 30_000; // 30 seconds
        
        // This should pass validation
        MempoolConfig::sanitize(
            &config,
            NodeType::Validator,
            Some(ChainId::test()),
        ).expect("Valid configuration should pass");
    }
    
    #[test]
    fn test_expired_transaction_accumulation() {
        use std::time::{Duration, SystemTime};
        use std::thread;
        
        let mut config = NodeConfig::default();
        // Deliberately misconfigure for demonstration
        config.mempool.system_transaction_timeout_secs = 1; // 1 second
        config.mempool.system_transaction_gc_interval_ms = 5_000; // 5 seconds
        
        let mempool = Arc::new(Mutex::new(CoreMempool::new(&config)));
        
        // Add transactions that will expire quickly
        for i in 0..100 {
            let txn = generate_test_transaction(i);
            mempool.lock().add_txn(
                txn,
                100,
                Some(0),
                TimelineState::Ready(0),
                true,
                None,
                None,
            );
        }
        
        // Wait for transactions to expire (1 second)
        thread::sleep(Duration::from_secs(2));
        
        // Check that expired transactions are still in mempool
        // because GC hasn't run yet (scheduled for 5 seconds)
        let mempool_size = mempool.lock().get_transaction_store().transactions.len();
        assert!(mempool_size > 0, "Expired transactions should still be in mempool");
        
        // Wait for GC to run
        thread::sleep(Duration::from_secs(4));
        
        // Manually trigger GC (in real system, gc_coordinator would do this)
        mempool.lock().gc();
        
        // Now transactions should be removed
        let mempool_size_after_gc = mempool.lock().get_transaction_store().transactions.len();
        assert_eq!(mempool_size_after_gc, 0, "Transactions should be removed after GC");
    }
}
```

## Notes

The vulnerability is exacerbated by the fact that there's a secondary GC mechanism that runs during `GetBatch` operations from consensus: [6](#0-5) 

However, this doesn't fully mitigate the issue because:
1. Between `GetBatch` calls, expired transactions still accumulate
2. Shared mempool broadcasting to peers operates independently and will broadcast expired transactions
3. Memory consumption occurs regardless of whether consensus is actively pulling

The default configuration is safe (timeout=600s, gc_interval=60000ms), but the lack of validation means operators can easily misconfigure, especially given the unit mismatch between the two parameters.

### Citations

**File:** config/src/config/mempool_config.rs (L79-83)
```rust
    ///
    /// This ensures that the Mempool isn't just full of non-expiring transactions that are way off into the future.
    pub system_transaction_timeout_secs: u64,
    /// Interval to garbage collect and remove transactions that have expired from the Mempool.
    pub system_transaction_gc_interval_ms: u64,
```

**File:** config/src/config/mempool_config.rs (L176-183)
```rust
impl ConfigSanitizer for MempoolConfig {
    fn sanitize(
        _node_config: &NodeConfig,
        _node_type: NodeType,
        _chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        Ok(()) // TODO: add reasonable verifications
    }
```

**File:** mempool/src/core_mempool/mempool.rs (L332-334)
```rust
        let now = SystemTime::now();
        let expiration_time =
            aptos_infallible::duration_since_epoch_at(&now) + self.system_transaction_timeout;
```

**File:** mempool/src/shared_mempool/runtime.rs (L78-81)
```rust
    executor.spawn(gc_coordinator(
        mempool.clone(),
        config.mempool.system_transaction_gc_interval_ms,
    ));
```

**File:** mempool/src/core_mempool/index.rs (L247-261)
```rust
    pub(crate) fn gc(&mut self, now: Duration) -> Vec<TTLOrderingKey> {
        // Ideally, we should garbage collect all transactions with expiration time < now.
        let max_expiration_time = now.saturating_sub(Duration::from_micros(1));
        let ttl_key = TTLOrderingKey {
            expiration_time: max_expiration_time,
            address: AccountAddress::ZERO,
            replay_protector: ReplayProtector::Nonce(0),
        };

        let mut active = self.data.split_off(&ttl_key);
        let ttl_transactions = self.data.iter().cloned().collect();
        self.data.clear();
        self.data.append(&mut active);
        ttl_transactions
    }
```

**File:** mempool/src/shared_mempool/tasks.rs (L664-665)
```rust
                    let curr_time = aptos_infallible::duration_since_epoch();
                    mempool.gc_by_expiration_time(curr_time);
```
