# Audit Report

## Title
Consensus Safety Violation: Order Votes Can Be Signed for Timed-Out Rounds Due to Missing Timeout Certificate Tracking

## Summary

The `highest_timeout_round` field in `SafetyData` only tracks timeouts that the local validator has personally signed, not timeouts observed from the network via timeout certificates. This allows validators who didn't participate in signing a timeout to later sign order votes for rounds that were collectively timed out by the network, violating consensus safety guarantees.

## Finding Description

The AptosBFT 2-chain consensus protocol uses `highest_timeout_round` to prevent validators from signing order votes for rounds that have been timed out. However, this tracking mechanism has a critical flaw. [1](#0-0) 

The `highest_timeout_round` field is only updated in one location: [2](#0-1) 

This update occurs exclusively when a validator signs a timeout via `guarded_sign_timeout_with_qc`: [3](#0-2) 

Crucially, when validators process timeout certificates from other validators (via `VoteProposal` or `SyncInfo` messages), they do NOT update their local `highest_timeout_round`. For example, in the voting flow: [4](#0-3) 

The timeout certificate is verified (line 63) and used in safety checks (line 81), but `highest_timeout_round` is never updated from it.

Similarly, when signing order votes: [5](#0-4) 

The `observe_qc()` call (line 108) only updates `one_chain_round` and `preferred_round`: [6](#0-5) 

The safety check `safe_for_order_vote()` then compares against the outdated `highest_timeout_round`: [7](#0-6) 

**Attack Scenario:**

1. Network forms timeout certificate TC4 for round 4 (2f+1 validators sign timeouts)
2. Validator A did not participate in signing the timeout, so `safety_data.highest_timeout_round = 0`
3. Validator A receives a VoteProposal for round 5 with TC4 attached
4. Validator A votes on round 5 (valid per 2-chain rules: round 5 = TC4.round + 1)
5. Malicious proposer sends Validator A an OrderVoteProposal for round 3
6. `safe_for_order_vote()` checks: round 3 > highest_timeout_round (0) ✓
7. Validator A signs an order vote for round 3, **even though the network collectively timed out round 4**

This violates the consensus invariant that blocks in timed-out rounds should not be orderable, as demonstrated by the existing test expectations: [8](#0-7) 

## Impact Explanation

**Critical Severity - Consensus Safety Violation**

This vulnerability breaks the fundamental consensus safety guarantee that timed-out rounds cannot be ordered. When 2f+1 validators form a timeout certificate for round R, consensus has collectively decided to skip that round. However, validators who didn't personally sign the timeout can later be tricked into signing order votes for rounds ≤ R.

This can lead to:
- **Consensus disagreement** about which blocks are ordered
- **Chain splits** where different validators have different views of block ordering
- **Double-ordering attacks** where timed-out blocks get ordered after being skipped
- Violation of the BFT safety property under < 1/3 Byzantine validators

Per Aptos bug bounty criteria, this qualifies as **Critical** severity as it is a direct "Consensus/Safety violation" that can cause non-recoverable state divergence.

## Likelihood Explanation

**High Likelihood**

This vulnerability is highly likely to be exploited because:

1. **Natural occurrence**: In any network with variable latency, some validators will not participate in every timeout, leaving their `highest_timeout_round` outdated
2. **No insider access required**: Any node can send OrderVoteProposal messages
3. **No cryptographic bypass needed**: All signatures are valid; the issue is logical
4. **Deterministic exploitation**: If a validator has outdated `highest_timeout_round`, the attack succeeds with certainty
5. **Byzantine fault amplification**: A single Byzantine proposer can exploit multiple honest validators with outdated timeout tracking

## Recommendation

Update `highest_timeout_round` whenever a validator observes a valid timeout certificate from the network, not just when signing timeouts locally.

**Fix for `guarded_construct_and_sign_vote_two_chain`:**

Add timeout certificate observation before voting: [9](#0-8) 

After line 63, add:
```rust
if let Some(tc) = timeout_cert {
    if tc.round() > safety_data.highest_timeout_round {
        safety_data.highest_timeout_round = tc.round();
    }
}
```

**Fix for SyncInfo processing:**

When processing timeout certificates via SyncInfo: [10](#0-9) 

After inserting the TC into block storage, also update SafetyRules:
```rust
if let Some(tc) = sync_info.highest_2chain_timeout_cert() {
    self.insert_2chain_timeout_certificate(Arc::new(tc.clone()))?;
    // Add: Update safety rules highest_timeout_round
    safety_rules.lock().observe_timeout_certificate(tc)?;
}
```

Add new method to SafetyRules:
```rust
pub fn observe_timeout_certificate(&mut self, tc: &TwoChainTimeoutCertificate) -> Result<(), Error> {
    let mut safety_data = self.persistent_storage.safety_data()?;
    if tc.round() > safety_data.highest_timeout_round {
        safety_data.highest_timeout_round = tc.round();
        self.persistent_storage.set_safety_data(safety_data)?;
    }
    Ok(())
}
```

## Proof of Concept

Extend the existing test suite by adding this test to `consensus/safety-rules/src/tests/suite.rs`:

```rust
fn test_order_vote_without_signing_timeout(safety_rules: &Callback) {
    let (mut safety_rules, signer) = safety_rules();
    let (proof, genesis_qc) = test_utils::make_genesis(&signer);
    let round = genesis_qc.certified_block().round();
    let epoch = genesis_qc.certified_block().epoch();

    // Create blocks: genesis -> p1 -> p2 -> p3
    let p1 = test_utils::make_proposal_with_qc(round + 1, genesis_qc.clone(), &signer);
    let p2 = test_utils::make_proposal_with_parent(
        random_payload(2048), round + 2, &p1, None, &signer
    );
    let p3 = test_utils::make_proposal_with_parent(
        random_payload(2048), round + 3, &p2, None, &signer
    );
    
    // Create TC for round 3 (simulating 2f+1 validators signed timeout)
    let tc3 = test_utils::make_timeout_cert(round + 3, p3.block().quorum_cert(), &signer);
    
    // Create proposal for round 4 with TC3
    let p4 = test_utils::make_proposal_with_parent(
        random_payload(2048), round + 4, &p2, None, &signer
    );

    safety_rules.initialize(&proof).unwrap();
    
    // Validator votes on p4 with TC3, but never signs timeout themselves
    safety_rules.construct_and_sign_vote_two_chain(&p4, Some(&tc3)).unwrap();
    
    // Create OrderVoteProposal for p2 (round 2, which is < TC3.round = 3)
    let ov2 = OrderVoteProposal::new(
        p2.block().clone(),
        p3.block().quorum_cert().certified_block().clone(),
        Arc::new(p3.block().quorum_cert().clone()),
    );
    
    // BUG: This should fail because network timed out round 3,
    // so ordering round 2 should be disallowed.
    // But it succeeds because highest_timeout_round was never updated from TC3!
    let result = safety_rules.construct_and_sign_order_vote(&ov2);
    
    // This assertion will FAIL with current code, demonstrating the vulnerability
    assert_err!(result); // Expected: Error::NotSafeForOrderVote
    // Actual: Success (order vote signed for timed-out round)
}
```

This PoC demonstrates that a validator who observes but doesn't sign a timeout can later sign order votes for rounds that were collectively timed out by the network.

### Citations

**File:** consensus/consensus-types/src/safety_data.rs (L10-21)
```rust
pub struct SafetyData {
    pub epoch: u64,
    pub last_voted_round: u64,
    // highest 2-chain round, used for 3-chain
    pub preferred_round: u64,
    // highest 1-chain round, used for 2-chain
    #[serde(default)]
    pub one_chain_round: u64,
    pub last_vote: Option<Vote>,
    #[serde(default)]
    pub highest_timeout_round: u64,
}
```

**File:** consensus/safety-rules/src/safety_rules.rs (L135-156)
```rust
    pub(crate) fn observe_qc(&self, qc: &QuorumCert, safety_data: &mut SafetyData) -> bool {
        let mut updated = false;
        let one_chain = qc.certified_block().round();
        let two_chain = qc.parent_block().round();
        if one_chain > safety_data.one_chain_round {
            safety_data.one_chain_round = one_chain;
            trace!(
                SafetyLogSchema::new(LogEntry::OneChainRound, LogEvent::Update)
                    .preferred_round(safety_data.one_chain_round)
            );
            updated = true;
        }
        if two_chain > safety_data.preferred_round {
            safety_data.preferred_round = two_chain;
            trace!(
                SafetyLogSchema::new(LogEntry::PreferredRound, LogEvent::Update)
                    .preferred_round(safety_data.preferred_round)
            );
            updated = true;
        }
        updated
    }
```

**File:** consensus/safety-rules/src/safety_rules.rs (L158-170)
```rust
    pub(crate) fn update_highest_timeout_round(
        &self,
        timeout: &TwoChainTimeout,
        safety_data: &mut SafetyData,
    ) {
        if timeout.round() > safety_data.highest_timeout_round {
            safety_data.highest_timeout_round = timeout.round();
            trace!(
                SafetyLogSchema::new(LogEntry::HighestTimeoutRound, LogEvent::Update)
                    .highest_timeout_round(safety_data.highest_timeout_round)
            );
        }
    }
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L19-51)
```rust
    pub(crate) fn guarded_sign_timeout_with_qc(
        &mut self,
        timeout: &TwoChainTimeout,
        timeout_cert: Option<&TwoChainTimeoutCertificate>,
    ) -> Result<bls12381::Signature, Error> {
        self.signer()?;
        let mut safety_data = self.persistent_storage.safety_data()?;
        self.verify_epoch(timeout.epoch(), &safety_data)?;
        if !self.skip_sig_verify {
            timeout
                .verify(&self.epoch_state()?.verifier)
                .map_err(|e| Error::InvalidTimeout(e.to_string()))?;
        }
        if let Some(tc) = timeout_cert {
            self.verify_tc(tc)?;
        }

        self.safe_to_timeout(timeout, timeout_cert, &safety_data)?;
        if timeout.round() < safety_data.last_voted_round {
            return Err(Error::IncorrectLastVotedRound(
                timeout.round(),
                safety_data.last_voted_round,
            ));
        }
        if timeout.round() > safety_data.last_voted_round {
            self.verify_and_update_last_vote_round(timeout.round(), &mut safety_data)?;
        }
        self.update_highest_timeout_round(timeout, &mut safety_data);
        self.persistent_storage.set_safety_data(safety_data)?;

        let signature = self.sign(&timeout.signing_format())?;
        Ok(signature)
    }
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L53-95)
```rust
    pub(crate) fn guarded_construct_and_sign_vote_two_chain(
        &mut self,
        vote_proposal: &VoteProposal,
        timeout_cert: Option<&TwoChainTimeoutCertificate>,
    ) -> Result<Vote, Error> {
        // Exit early if we cannot sign
        self.signer()?;

        let vote_data = self.verify_proposal(vote_proposal)?;
        if let Some(tc) = timeout_cert {
            self.verify_tc(tc)?;
        }
        let proposed_block = vote_proposal.block();
        let mut safety_data = self.persistent_storage.safety_data()?;

        // if already voted on this round, send back the previous vote
        // note: this needs to happen after verifying the epoch as we just check the round here
        if let Some(vote) = safety_data.last_vote.clone() {
            if vote.vote_data().proposed().round() == proposed_block.round() {
                return Ok(vote);
            }
        }

        // Two voting rules
        self.verify_and_update_last_vote_round(
            proposed_block.block_data().round(),
            &mut safety_data,
        )?;
        self.safe_to_vote(proposed_block, timeout_cert)?;

        // Record 1-chain data
        self.observe_qc(proposed_block.quorum_cert(), &mut safety_data);
        // Construct and sign vote
        let author = self.signer()?.author();
        let ledger_info = self.construct_ledger_info_2chain(proposed_block, vote_data.hash())?;
        let signature = self.sign(&ledger_info)?;
        let vote = Vote::new_with_signature(vote_data, author, ledger_info, signature);

        safety_data.last_vote = Some(vote.clone());
        self.persistent_storage.set_safety_data(safety_data)?;

        Ok(vote)
    }
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L97-119)
```rust
    pub(crate) fn guarded_construct_and_sign_order_vote(
        &mut self,
        order_vote_proposal: &OrderVoteProposal,
    ) -> Result<OrderVote, Error> {
        // Exit early if we cannot sign
        self.signer()?;
        self.verify_order_vote_proposal(order_vote_proposal)?;
        let proposed_block = order_vote_proposal.block();
        let mut safety_data = self.persistent_storage.safety_data()?;

        // Record 1-chain data
        self.observe_qc(order_vote_proposal.quorum_cert(), &mut safety_data);

        self.safe_for_order_vote(proposed_block, &safety_data)?;
        // Construct and sign order vote
        let author = self.signer()?.author();
        let ledger_info =
            LedgerInfo::new(order_vote_proposal.block_info().clone(), HashValue::zero());
        let signature = self.sign(&ledger_info)?;
        let order_vote = OrderVote::new_with_signature(author, ledger_info.clone(), signature);
        self.persistent_storage.set_safety_data(safety_data)?;
        Ok(order_vote)
    }
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L168-178)
```rust
    fn safe_for_order_vote(&self, block: &Block, safety_data: &SafetyData) -> Result<(), Error> {
        let round = block.round();
        if round > safety_data.highest_timeout_round {
            Ok(())
        } else {
            Err(Error::NotSafeForOrderVote(
                round,
                safety_data.highest_timeout_round,
            ))
        }
    }
```

**File:** consensus/safety-rules/src/tests/suite.rs (L313-324)
```rust
    // Cannot sign order vote for round 3 after signing timeout for round 4
    assert_err!(safety_rules.construct_and_sign_order_vote(&ov3));

    // Cannot sign vote for round 4 after signing timeout for round 4
    assert_err!(safety_rules.construct_and_sign_vote_two_chain(&p3, None));

    safety_rules
        .construct_and_sign_vote_two_chain(&p4b, Some(&tc3))
        .unwrap();

    // Cannot sign order vote for round 4 after signing timeoiut for round 4
    assert_err!(safety_rules.construct_and_sign_order_vote(&ov4));
```

**File:** consensus/src/block_storage/sync_manager.rs (L169-172)
```rust
        if let Some(tc) = sync_info.highest_2chain_timeout_cert() {
            self.insert_2chain_timeout_certificate(Arc::new(tc.clone()))?;
        }
        Ok(())
```
