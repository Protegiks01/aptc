# Audit Report

## Title
Missing Length Validation in DeKART Range Proof Verification Causes Denial of Service

## Summary
The `verify()` function in the DeKART univariate range proof implementation fails to validate that `self.c` and `self.c_hat` vectors have equal lengths, allowing an attacker to submit malformed proofs that cause validator nodes to panic during verification.

## Finding Description
The duality check in the range proof verification (lines 611-628) uses both MSMs with identical alpha values from the same source. However, there is a critical missing validation: [1](#0-0) 

At line 594, `alphas` is generated with length `self.c.len()`. Due to an earlier constraint at line 581, `self.c.len()` must equal `ell` for the verification to proceed: [2](#0-1) 

However, `self.c_hat` is only constrained to have length `>= ell` (by the h_check accessing indices 0 through ell-1): [3](#0-2) 

When the duality check executes: [4](#0-3) 

If `self.c_hat.len() != ell`, line 617 calls `VariableBaseMSM::msm()` with mismatched vector lengths. The arkworks library's MSM implementation requires equal-length inputs and returns an error when lengths mismatch, causing the `.unwrap()` to panic and crash the verifier.

**Answering the Security Question:** Both MSMs DO use identical alpha values and ordering (from the same `alphas` variable). The vulnerability is NOT a duality bypass - it's that length mismatches cause crashes before the duality check can complete. No cryptographic bypass occurs.

## Impact Explanation
**High Severity** - This qualifies as "Validator node crashes" under the Aptos bug bounty program. An attacker can submit a malformed proof during DKG operations, causing any validator attempting verification to panic. This could:
- Disrupt DKG ceremonies during epoch transitions
- Prevent validator onboarding
- Cause temporary liveness issues if multiple validators crash simultaneously

This does NOT qualify as Critical because it doesn't cause permanent network partition, consensus violations, or fund loss.

## Likelihood Explanation
**Medium Likelihood** - The Proof struct derives `CanonicalDeserialize` without custom validation: [5](#0-4) 

Any actor participating in DKG can submit arbitrary-length vectors. However, exploitation requires:
1. Access to DKG protocol participation
2. Knowledge of the validation gap
3. Timing the attack during DKG ceremonies

## Recommendation
Add explicit length validation at the start of `verify()`:

```rust
fn verify(...) -> anyhow::Result<()> {
    let mut fs_t = merlin::Transcript::new(Self::DST);
    
    // Validate proof structure
    ensure!(
        self.c.len() == ell,
        "c length mismatch: got {}, expected {}",
        self.c.len(),
        ell
    );
    ensure!(
        self.c_hat.len() == ell,
        "c_hat length mismatch: got {}, expected {}",
        self.c_hat.len(),
        ell
    );
    
    assert!(ell <= vk.max_ell, ...);
    // ... rest of function
}
```

This returns a proper error instead of panicking, allowing graceful handling of malformed proofs.

## Proof of Concept
```rust
#[test]
fn test_malformed_proof_dos() {
    let mut rng = thread_rng();
    let group_generators = GroupGenerators::default();
    let (pk, vk) = UnivariateDeKART::<Bn254>::setup(15, 8, group_generators, &mut rng);
    
    // Create valid proof
    let (values, comm, r) = test_utils::range_proof_random_instance(&pk, 7, 3, &mut rng);
    let mut proof = UnivariateDeKART::<Bn254>::prove(&pk, &values, 3, &comm, &r, &mut rng);
    
    // Malform proof by adding extra c_hat elements
    proof.c_hat.push(G2Affine::generator());
    proof.c_hat.push(G2Affine::generator());
    
    // Verification panics instead of returning error
    let result = std::panic::catch_unwind(|| {
        proof.verify(&vk, 7, 3, &comm)
    });
    
    assert!(result.is_err(), "Verifier should panic on length mismatch");
}
```

**Notes:**
The security question asks specifically about duality bypass. The answer is: **No duality bypass exists** - both MSMs correctly use identical alpha values and ordering. The vulnerability is a separate DoS issue from missing length validation, not a cryptographic flaw in the duality check itself.

### Citations

**File:** crates/aptos-dkg/src/range_proofs/dekart_univariate.rs (L31-36)
```rust
#[derive(CanonicalSerialize, CanonicalDeserialize, Debug, Clone, PartialEq, Eq)]
pub struct Proof<E: Pairing> {
    d: E::G1,                // commitment to h(X) = \sum_{j=0}^{\ell-1} beta_j h_j(X)
    c: Vec<E::G1Affine>,     // of size \ell
    c_hat: Vec<E::G2Affine>, // of size \ell
}
```

**File:** crates/aptos-dkg/src/range_proofs/dekart_univariate.rs (L580-582)
```rust
        let commitment_recomputed: E::G1 =
            VariableBaseMSM::msm(&self.c, &vk.powers_of_two[..ell]).expect("Failed to compute msm");
        ensure!(comm.0 == commitment_recomputed);
```

**File:** crates/aptos-dkg/src/range_proofs/dekart_univariate.rs (L590-596)
```rust
        let (alphas, betas) = fiat_shamir_challenges(
            &vk,
            public_statement,
            &bit_commitments,
            self.c.len(),
            &mut fs_t,
        );
```

**File:** crates/aptos-dkg/src/range_proofs/dekart_univariate.rs (L599-609)
```rust
        let h_check = E::multi_pairing(
            (0..ell)
                .map(|j| self.c[j] * betas[j]) // E::G1
                .chain(once(-self.d)) // add -d
                .collect::<Vec<_>>(), // collect into Vec<E::G1>
            (0..ell)
                .map(|j| self.c_hat[j] - vk.tau_2) // E::G2
                .chain(once(vk.vanishing_com)) // add vanishing commitment
                .collect::<Vec<_>>(), // collect into Vec<E::G2>
        );
        ensure!(PairingOutput::<E>::ZERO == h_check);
```

**File:** crates/aptos-dkg/src/range_proofs/dekart_univariate.rs (L613-628)
```rust
        // Compute MSM in G1: sum_j (alphas[j] * proof.c[j])
        let g1_comb = VariableBaseMSM::msm(&self.c, &alphas).unwrap();

        // Compute MSM in G2: sum_j (alphas[j] * proof.c_hat[j])
        let g2_comb = VariableBaseMSM::msm(&self.c_hat, &alphas).unwrap();
        let c_check = E::multi_pairing(
            vec![
                g1_comb,   // from MSM in G1
                -vk.tau_1, // subtract tau_1
            ],
            vec![
                vk.tau_2, // tau_2
                g2_comb,  // from MSM in G2
            ],
        );
        ensure!(PairingOutput::<E>::ZERO == c_check);
```
