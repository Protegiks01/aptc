# Audit Report

## Title
Vote Replacement Attack via Optimistic Signature Verification in CommitVote Deduplication

## Summary
The Aptos consensus pipeline combines optimistic signature verification with a last-write-wins deduplication strategy that allows a malicious validator to replace their valid CommitVote with an invalid one, causing signature aggregation to fail and temporarily stalling consensus until additional votes are collected.

## Finding Description

The CommitVote processing pipeline contains three interacting components that create a liveness vulnerability:

**1. Optimistic Signature Verification**

Optimistic signature verification is enabled by default [1](#0-0)  and when active, the `optimistic_verify` function skips cryptographic signature verification unless the author is in the `pessimistic_verify_set` [2](#0-1) . This means CommitVotes from validators not in the pessimistic set pass verification without actual signature validation.

**2. Vote Deduplication via BTreeMap::insert**

The `SignatureAggregator::add_signature` method uses `BTreeMap::insert` to store signatures [3](#0-2) . When multiple votes arrive from the same validator, the last vote unconditionally replaces all previous votes without validating that the replacement signature is cryptographically correct.

**3. Vote Processing Flow**

The BufferManager spawns an asynchronous verification task that validates incoming CommitMessages using `optimistic_verify` [4](#0-3) . Verified messages are then processed via `process_commit_message` which calls `add_signature_if_matched` [5](#0-4) . This method directly adds signatures to the aggregator for Executed and Signed buffer items [6](#0-5) .

**Attack Execution:**

1. Malicious validator M sends CommitVote_1 with VALID signature → passes `optimistic_verify` → stored in BTreeMap
2. Honest validators send valid votes → system reaches quorum (e.g., 5/7 validators)
3. M sends CommitVote_2 with INVALID signature → also passes `optimistic_verify` → replaces M's valid signature
4. System attempts aggregation via `aggregate_and_verify` [7](#0-6) 
5. Multi-signature verification fails due to M's invalid signature
6. System calls `filter_invalid_signatures` which removes M's vote [8](#0-7) [9](#0-8) 
7. Voting power drops to 4 validators, below quorum threshold
8. Second `try_aggregate` fails → consensus cannot proceed until another validator votes

The vulnerability is mitigated after the first occurrence when the malicious validator is added to `pessimistic_verify_set` [10](#0-9) , forcing immediate verification of future votes. However, the pessimistic set is stored in a per-epoch ValidatorVerifier instance [11](#0-10)  and resets at epoch boundaries.

## Impact Explanation

**Severity: Medium** - This vulnerability enables a temporary liveness attack on consensus:

- **Consensus Delay**: A single Byzantine validator can force the system to wait for additional honest validator votes, delaying block commitment
- **Repeated Attacks**: The attack can be executed once per block within an epoch before the validator is added to the pessimistic verification set
- **Epoch Boundary Reset**: At epoch transitions, the pessimistic_verify_set is cleared when new ValidatorVerifier instances are created, allowing the attack to resume

This qualifies as "Limited Protocol Violations - Temporary liveness issues" under Medium severity per Aptos bug bounty criteria. The attack does NOT compromise safety (no chain splits or invalid blocks), but it violates liveness guarantees by artificially delaying consensus progression. The issue is self-healing once additional votes arrive and does not require manual intervention, distinguishing it from Critical severity issues.

## Likelihood Explanation

**Likelihood: Medium**

- **Attack Complexity**: LOW - The attacker simply broadcasts two CommitVotes in sequence with the second containing an invalid signature
- **Attacker Requirements**: Must be an active validator (within Byzantine fault assumption of < 1/3 malicious)
- **Timing Window**: Attack succeeds if the second (invalid) vote is received before aggregation completes after reaching quorum
- **Detection**: MEDIUM - The attack appears as legitimate voting until aggregation fails; malicious validator is then added to pessimistic_verify_set
- **Persistence**: Attack can be repeated on subsequent blocks until detection, and resets at epoch boundaries

The attack is practically executable in production networks with Byzantine validators and has realistic timing requirements given network message propagation characteristics.

## Recommendation

Implement signature validation before replacement in the deduplication logic:

```rust
pub fn add_signature(&mut self, validator: AccountAddress, signature: &SignatureWithStatus) {
    // Only replace if new signature is verified or existing is unverified
    if let Some(existing) = self.signatures.get(&validator) {
        if existing.is_verified() && !signature.is_verified() {
            // Don't replace verified signature with unverified one
            return;
        }
    }
    self.signatures.insert(validator, signature.clone());
}
```

Alternatively, enforce single-vote-per-validator semantics by rejecting replacement attempts:

```rust
pub fn add_signature(&mut self, validator: AccountAddress, signature: &SignatureWithStatus) -> Result<()> {
    if self.signatures.contains_key(&validator) {
        return Err(anyhow!("Validator {} already submitted a vote", validator));
    }
    self.signatures.insert(validator, signature.clone());
    Ok(())
}
```

Additionally, consider making the pessimistic_verify_set persistent across epochs or implementing rate limiting on vote replacement attempts.

## Proof of Concept

The vulnerability can be demonstrated by constructing a test scenario where:
1. Create a 7-validator network with quorum threshold of 5
2. Have 5 validators (including malicious M) submit valid CommitVotes
3. Have M immediately submit a second CommitVote with an invalid signature
4. Observe that aggregation fails and voting power drops below quorum
5. Verify consensus stalls until a 6th honest validator submits a vote

The key components shown in the code analysis confirm this execution path is possible in the current implementation.

## Notes

This vulnerability demonstrates a timing-dependent liveness attack that exploits the interaction between optimistic verification and vote deduplication. While the impact is limited to temporary consensus delays rather than permanent network halt or safety violations, it represents a genuine protocol weakness that could be exploited by Byzantine validators to degrade network performance. The automatic mitigation through pessimistic_verify_set provides partial protection but resets at epoch boundaries, allowing repeated exploitation.

### Citations

**File:** config/src/config/consensus_config.rs (L382-382)
```rust
            optimistic_sig_verification: true,
```

**File:** types/src/validator_verifier.rs (L156-156)
```rust
    pessimistic_verify_set: DashSet<AccountAddress>,
```

**File:** types/src/validator_verifier.rs (L269-285)
```rust
    pub fn optimistic_verify<T: Serialize + CryptoHash>(
        &self,
        author: AccountAddress,
        message: &T,
        signature_with_status: &SignatureWithStatus,
    ) -> std::result::Result<(), VerifyError> {
        if self.get_public_key(&author).is_none() {
            return Err(VerifyError::UnknownAuthor);
        }
        if (!self.optimistic_sig_verification || self.pessimistic_verify_set.contains(&author))
            && !signature_with_status.is_verified()
        {
            self.verify(author, message, signature_with_status.signature())?;
            signature_with_status.set_verified();
        }
        Ok(())
    }
```

**File:** types/src/validator_verifier.rs (L287-311)
```rust
    pub fn filter_invalid_signatures<T: Send + Sync + Serialize + CryptoHash>(
        &self,
        message: &T,
        signatures: BTreeMap<AccountAddress, SignatureWithStatus>,
    ) -> BTreeMap<AccountAddress, SignatureWithStatus> {
        signatures
            .into_iter()
            .collect_vec()
            .into_par_iter()
            .with_min_len(4) // At least 4 signatures are verified in each task
            .filter_map(|(account_address, signature)| {
                if signature.is_verified()
                    || self
                        .verify(account_address, message, signature.signature())
                        .is_ok()
                {
                    signature.set_verified();
                    Some((account_address, signature))
                } else {
                    self.add_pessimistic_verify_set(account_address);
                    None
                }
            })
            .collect()
    }
```

**File:** types/src/ledger_info.rs (L460-462)
```rust
    pub fn add_signature(&mut self, validator: AccountAddress, signature: &SignatureWithStatus) {
        self.signatures.insert(validator, signature.clone());
    }
```

**File:** types/src/ledger_info.rs (L510-513)
```rust
    fn filter_invalid_signatures(&mut self, verifier: &ValidatorVerifier) {
        let signatures = mem::take(&mut self.signatures);
        self.signatures = verifier.filter_invalid_signatures(&self.data, signatures);
    }
```

**File:** types/src/ledger_info.rs (L517-536)
```rust
    pub fn aggregate_and_verify(
        &mut self,
        verifier: &ValidatorVerifier,
    ) -> Result<(T, AggregateSignature), VerifyError> {
        let aggregated_sig = self.try_aggregate(verifier)?;

        match verifier.verify_multi_signatures(&self.data, &aggregated_sig) {
            Ok(_) => {
                // We are not marking all the signatures as "verified" here, as two malicious
                // voters can collude and create a valid aggregated signature.
                Ok((self.data.clone(), aggregated_sig))
            },
            Err(_) => {
                self.filter_invalid_signatures(verifier);

                let aggregated_sig = self.try_aggregate(verifier)?;
                Ok((self.data.clone(), aggregated_sig))
            },
        }
    }
```

**File:** consensus/src/pipeline/buffer_manager.rs (L754-761)
```rust
                    let new_item = match item.add_signature_if_matched(vote) {
                        Ok(()) => {
                            let response =
                                ConsensusMsg::CommitMessage(Box::new(CommitMessage::Ack(())));
                            if let Ok(bytes) = protocol.to_bytes(&response) {
                                let _ = response_sender.send(Ok(bytes.into()));
                            }
                            item.try_advance_to_aggregated(&self.epoch_state.verifier)
```

**File:** consensus/src/pipeline/buffer_manager.rs (L919-934)
```rust
        spawn_named!("buffer manager verification", async move {
            while let Some((sender, commit_msg)) = commit_msg_rx.next().await {
                let tx = verified_commit_msg_tx.clone();
                let epoch_state_clone = epoch_state.clone();
                bounded_executor
                    .spawn(async move {
                        match commit_msg.req.verify(sender, &epoch_state_clone.verifier) {
                            Ok(_) => {
                                let _ = tx.unbounded_send(commit_msg);
                            },
                            Err(e) => warn!("Invalid commit message: {}", e),
                        }
                    })
                    .await;
            }
        });
```

**File:** consensus/src/pipeline/buffer_item.rs (L393-405)
```rust
            Self::Executed(executed) => {
                if executed.commit_info == *target_commit_info {
                    executed
                        .partial_commit_proof
                        .add_signature(author, signature);
                    return Ok(());
                }
            },
            Self::Signed(signed) => {
                if signed.partial_commit_proof.data().commit_info() == target_commit_info {
                    signed.partial_commit_proof.add_signature(author, signature);
                    return Ok(());
                }
```
