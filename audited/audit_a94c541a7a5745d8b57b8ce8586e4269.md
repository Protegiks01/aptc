# Audit Report

## Title
Indexer Prometheus Metric Version Rollback Due to Concurrent Processing

## Summary
The `LATEST_PROCESSED_VERSION` Prometheus metric in the indexer can move backwards when multiple concurrent processor tasks complete out of order, violating monotonicity assumptions. However, this does NOT cause transaction re-processing as the security question claims, because the database state is properly protected and the transaction fetcher reads from the database, not from the metric.

## Finding Description

The indexer runtime spawns multiple concurrent processor tasks to improve throughput. [1](#0-0) 

Each task independently calls `process_transactions_with_status()`, which upon successful completion calls `update_status_success()` to update the Prometheus metric. [2](#0-1) 

The metric is updated with an unconditional `.set()` operation: [3](#0-2) 

When tasks complete out of order (e.g., task processing versions 201-300 finishes before task processing versions 100-200), the metric can move backwards from 300 to 200.

**However, transaction re-processing does NOT occur** because:

1. The database update has protection against version rollback via a WHERE clause: [4](#0-3) 

2. The transaction fetcher determines the starting version from the database, not from the Prometheus metric: [5](#0-4) 

3. The runtime coordinates all concurrent tasks and updates the database with the maximum version across all completed batches: [6](#0-5) 

## Impact Explanation

This issue does **NOT** meet the Aptos bug bounty severity criteria:

- **Not Critical**: No consensus violations, no loss of funds, no network partition, no liveness impact
- **Not High**: No validator node slowdowns (indexer is separate from validators), no API crashes, no protocol violations
- **Not Medium**: No actual state inconsistencies requiring intervention (database state is correct)

The impact is limited to **observability and monitoring**:
- External monitoring systems may see backwards metric movement
- Dashboards may display confusing data
- False alerts may trigger

The actual indexer functionality remains correct - the database state is consistent and no transaction re-processing occurs.

## Likelihood Explanation

This occurs **naturally** whenever:
- The `processor_tasks` configuration is set > 1 (enabling concurrent processing)
- Multiple batches are processed concurrently
- The batches complete out of order due to varying processing times

This is not an exploitable attack vector, but rather a race condition in metric reporting.

## Recommendation

Update the `update_status_success()` function to use an atomic maximum operation for the Prometheus gauge instead of an unconditional set:

```rust
fn update_status_success(&self, processing_result: &ProcessingResult) {
    // ... existing logging ...
    
    // Use a loop to atomically update only if the new value is higher
    loop {
        let current = LATEST_PROCESSED_VERSION
            .with_label_values(&[self.name()])
            .get();
        if processing_result.end_version as i64 <= current {
            break; // Don't update if not higher
        }
        // Note: IntGauge doesn't have compare_and_swap, so we need to
        // accept potential race conditions or add external synchronization
        LATEST_PROCESSED_VERSION
            .with_label_values(&[self.name()])
            .set(processing_result.end_version as i64);
        break;
    }
    
    // ... rest of function ...
}
```

Alternatively, use external synchronization (Mutex/RwLock) around metric updates, though this may impact performance.

## Proof of Concept

```rust
// Configuration setup to reproduce:
// In indexer config, set processor_tasks = 2 or higher

// The race condition will naturally occur during normal operation:
// 1. Start indexer with processor_tasks > 1
// 2. Monitor the LATEST_PROCESSED_VERSION metric
// 3. Observe that the metric occasionally moves backwards
// 4. Verify that the database processor_status.last_success_version 
//    continues to increase monotonically despite the metric rollback
```

---

**Note**: While this is a legitimate implementation bug that should be fixed for operational clarity, it does **NOT** constitute a security vulnerability per the bug bounty criteria. The security question's claim about "causing re-processing of transactions" is **incorrect** - the database protection mechanisms prevent this from occurring. The actual indexer state remains consistent, and only the Prometheus metric for external monitoring is affected.

### Citations

**File:** crates/indexer/src/runtime.rs (L209-219)
```rust
    loop {
        let mut tasks = vec![];
        for _ in 0..processor_tasks {
            let other_tailer = tailer.clone();
            let task = tokio::spawn(async move { other_tailer.process_next_batch().await });
            tasks.push(task);
        }
        let batches = match futures::future::try_join_all(tasks).await {
            Ok(res) => res,
            Err(err) => panic!("Error processing transaction batches: {:?}", err),
        };
```

**File:** crates/indexer/src/runtime.rs (L245-252)
```rust
            batch_start_version =
                std::cmp::min(batch_start_version, processed_result.start_version);
            batch_end_version = std::cmp::max(batch_end_version, processed_result.end_version);
            num_res += num_txn;
        }

        tailer
            .update_last_processed_version(&processor_name, batch_end_version)
```

**File:** crates/indexer/src/indexer/transaction_processor.rs (L86-88)
```rust
        match res.as_ref() {
            Ok(processing_result) => self.update_status_success(processing_result),
            Err(tpe) => self.update_status_err(tpe),
```

**File:** crates/indexer/src/indexer/transaction_processor.rs (L120-122)
```rust
        LATEST_PROCESSED_VERSION
            .with_label_values(&[self.name()])
            .set(processing_result.end_version as i64);
```

**File:** crates/indexer/src/indexer/tailer.rs (L177-189)
```rust
        execute_with_better_error(
            &mut conn,
            diesel::insert_into(processor_status::table)
                .values(&status)
                .on_conflict(processor_status::processor)
                .do_update()
                .set((
                    processor_status::last_success_version
                        .eq(excluded(processor_status::last_success_version)),
                    processor_status::last_updated.eq(excluded(processor_status::last_updated)),
                )),
            Some(" WHERE processor_status.last_success_version <= EXCLUDED.last_success_version "),
        )?;
```

**File:** crates/indexer/src/indexer/tailer.rs (L194-200)
```rust
    pub fn get_start_version(&self, processor_name: &String) -> Result<Option<i64>> {
        let mut conn = self.connection_pool.get()?;

        match ProcessorStatusV2Query::get_by_processor(processor_name, &mut conn)? {
            Some(status) => Ok(Some(status.last_success_version + 1)),
            None => Ok(None),
        }
```
