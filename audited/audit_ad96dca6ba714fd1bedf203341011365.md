# Audit Report

## Title
Remote State View Cache Miss Causes Synchronous Blocking Leading to Parallelism Degradation

## Summary
The `RemoteStateViewClient::get_state_value()` implementation handles cache misses by synchronously fetching state values, causing worker threads to block while waiting for network I/O. Under high cache miss rates, this degrades parallel transaction execution to serial execution, eliminating parallelism benefits in remote sharded block execution.

## Finding Description

The vulnerability exists in the non-prefetch path of `RemoteStateViewClient::get_state_value()`. [1](#0-0) 

When a transaction execution thread reads a state key that was not prefetched, the following occurs:

1. The thread acquires a read lock on `state_view`
2. Checks if the key exists in cache via `has_state_key()` (returns false for cache miss)
3. Calls `pre_fetch_state_values(vec![state_key.clone()], true)` with `sync_insert_keys=true`
4. Calls `state_view_reader.get_state_value(state_key)` which blocks via condition variable wait

The blocking mechanism uses `RemoteStateValue::get_value()` which waits on a condition variable: [2](#0-1) 

**Root Cause - Race Condition with Async Prefetch:**

The `init_for_block()` method initiates asynchronous prefetching: [3](#0-2) 

With `sync_insert_keys=false`, prefetch is spawned asynchronously on the thread pool: [4](#0-3) 

This creates a race condition: if transaction execution begins before the async prefetch task completes inserting keys into the cache, worker threads encounter cache misses and block synchronously.

**Parallel Execution Context:**

During sharded block execution, multiple worker threads execute transactions in parallel using `BlockExecutor`. These threads read state via `LatestView::get_raw_base_value()`: [5](#0-4) 

When multiple threads simultaneously hit cache misses, they all block waiting for remote state, eliminating parallelism.

## Impact Explanation

**Severity: Medium (as indicated in the security question)**

While the bug bounty criteria classify "Validator node slowdowns" as High Severity ($50,000), several factors reduce this to Medium:

1. **Limited Scope**: Remote sharded execution is configuration-based and appears experimental, with hint extraction only supporting specific transaction types (coin transfers, account creation) and panicking on others with `todo!()`: [6](#0-5) 

2. **No Direct Exploitability**: Attackers cannot directly force cache misses. The issue manifests as a race condition under high load rather than a directly exploitable vulnerability.

3. **No Consensus Impact**: All validators experience the same slowdown deterministically, so there's no state divergence or safety violation.

4. **Mitigation Exists**: Complete and accurate prefetch hints eliminate cache misses under normal operation.

The performance degradation could affect validator liveness under extreme load but doesn't constitute a critical security flaw.

## Likelihood Explanation

**Likelihood: Low to Medium**

Occurrence depends on:
- Remote sharded execution being enabled (requires explicit configuration)
- High transaction concurrency triggering race conditions
- Incomplete or delayed prefetch operations
- Current implementation limitations (only specific transaction types supported)

In production deployments with complete prefetch and moderate load, cache misses should be rare. However, under stress testing or high-throughput scenarios, the race window widens and likelihood increases.

## Recommendation

**Immediate Fix**: Implement non-blocking fallback for cache misses instead of synchronous fetching.

**Option 1 - Fail Fast Approach**:
Return an error on cache miss and let the parallel executor retry the transaction after prefetch completes.

**Option 2 - Optimistic Continuation**:
Use speculative execution with delayed validation, similar to cross-shard dependencies.

**Option 3 - Synchronous Prefetch Completion**:
Wait for all prefetch operations to complete before starting transaction execution:

```rust
pub fn init_for_block(&self, state_keys: Vec<StateKey>) {
    *self.state_view.write().unwrap() = RemoteStateView::new();
    REMOTE_EXECUTOR_REMOTE_KV_COUNT
        .with_label_values(&[&self.shard_id.to_string(), "prefetch_kv"])
        .inc_by(state_keys.len() as u64);
    // Wait for prefetch to complete before returning
    self.pre_fetch_state_values_sync(state_keys);
}
```

**Long-term Fix**: Complete the hint extraction implementation to support all transaction types and ensure hints are comprehensive.

## Proof of Concept

```rust
#[test]
fn test_cache_miss_blocks_parallel_execution() {
    use std::sync::{Arc, Barrier};
    use std::thread;
    
    // Setup: Create RemoteStateViewClient with slow network
    let state_view_client = Arc::new(setup_remote_state_view_client());
    
    // Spawn prefetch task asynchronously (simulates init_for_block)
    let state_keys = vec![StateKey::raw(b"key1"), StateKey::raw(b"key2")];
    state_view_client.init_for_block(state_keys);
    
    // Immediately start parallel execution (before prefetch completes)
    let barrier = Arc::new(Barrier::new(4));
    let mut handles = vec![];
    
    for i in 0..4 {
        let client = state_view_client.clone();
        let b = barrier.clone();
        handles.push(thread::spawn(move || {
            b.wait(); // Synchronize thread start
            let start = std::time::Instant::now();
            
            // This will hit cache miss and block
            let _value = client.get_state_value(&StateKey::raw(format!("key{}", i).as_bytes()));
            
            start.elapsed()
        }));
    }
    
    // Collect execution times
    let times: Vec<_> = handles.into_iter().map(|h| h.join().unwrap()).collect();
    
    // Assertion: If parallel, total time ≈ max(times)
    // If serial (blocked), total time ≈ sum(times)
    let sum: Duration = times.iter().sum();
    let max = times.iter().max().unwrap();
    
    // Evidence of serialization: sum is significantly larger than max
    assert!(sum > max * 3, "Execution did not parallelize - threads blocked serially");
}
```

## Notes

This issue represents a **design trade-off** rather than a critical security vulnerability. The synchronous blocking behavior on cache misses is a conservative approach that ensures correctness but sacrifices performance under adverse conditions.

The remote sharded execution feature appears to be under active development, as evidenced by incomplete hint extraction and `todo!()` placeholders. Production deployments should:
1. Verify prefetch completeness before enabling remote execution
2. Monitor cache miss rates via the metrics at lines 199-201
3. Consider using local sharded execution until remote execution matures

The vulnerability does NOT:
- Allow fund theft or minting
- Cause consensus divergence or safety violations  
- Enable permanent network partition or liveness loss
- Require validator insider access to exploit

### Citations

**File:** execution/executor-service/src/remote_state_view.rs (L118-124)
```rust
    pub fn init_for_block(&self, state_keys: Vec<StateKey>) {
        *self.state_view.write().unwrap() = RemoteStateView::new();
        REMOTE_EXECUTOR_REMOTE_KV_COUNT
            .with_label_values(&[&self.shard_id.to_string(), "prefetch_kv"])
            .inc_by(state_keys.len() as u64);
        self.pre_fetch_state_values(state_keys, false);
    }
```

**File:** execution/executor-service/src/remote_state_view.rs (L147-170)
```rust
    fn pre_fetch_state_values(&self, state_keys: Vec<StateKey>, sync_insert_keys: bool) {
        let state_view_clone = self.state_view.clone();
        let thread_pool_clone = self.thread_pool.clone();
        let kv_tx_clone = self.kv_tx.clone();
        let shard_id = self.shard_id;

        let insert_and_fetch = move || {
            Self::insert_keys_and_fetch_values(
                state_view_clone,
                thread_pool_clone,
                kv_tx_clone,
                shard_id,
                state_keys,
            );
        };
        if sync_insert_keys {
            // we want to insert keys synchronously here because when called from get_state_value()
            // it expects the key to be in the table while waiting for the value to be fetched from
            // remote state view.
            insert_and_fetch();
        } else {
            self.thread_pool.spawn(insert_and_fetch);
        }
    }
```

**File:** execution/executor-service/src/remote_state_view.rs (L186-204)
```rust
    fn get_state_value(&self, state_key: &StateKey) -> StateViewResult<Option<StateValue>> {
        let state_view_reader = self.state_view.read().unwrap();
        if state_view_reader.has_state_key(state_key) {
            // If the key is already in the cache then we return it.
            let _timer = REMOTE_EXECUTOR_TIMER
                .with_label_values(&[&self.shard_id.to_string(), "prefetch_wait"])
                .start_timer();
            return state_view_reader.get_state_value(state_key);
        }
        // If the value is not already in the cache then we pre-fetch it and wait for it to arrive.
        let _timer = REMOTE_EXECUTOR_TIMER
            .with_label_values(&[&self.shard_id.to_string(), "non_prefetch_wait"])
            .start_timer();
        REMOTE_EXECUTOR_REMOTE_KV_COUNT
            .with_label_values(&[&self.shard_id.to_string(), "non_prefetch_kv"])
            .inc();
        self.pre_fetch_state_values(vec![state_key.clone()], true);
        state_view_reader.get_state_value(state_key)
    }
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/remote_state_value.rs (L29-39)
```rust
    pub fn get_value(&self) -> Option<StateValue> {
        let (lock, cvar) = &*self.value_condition;
        let mut status = lock.lock().unwrap();
        while let RemoteValueStatus::Waiting = *status {
            status = cvar.wait(status).unwrap();
        }
        match &*status {
            RemoteValueStatus::Ready(value) => value.clone(),
            RemoteValueStatus::Waiting => unreachable!(),
        }
    }
```

**File:** aptos-move/block-executor/src/view.rs (L1140-1163)
```rust
    pub(crate) fn get_raw_base_value(
        &self,
        state_key: &T::Key,
    ) -> PartialVMResult<Option<StateValue>> {
        let ret = self.base_view.get_state_value(state_key).map_err(|e| {
            PartialVMError::new(StatusCode::STORAGE_ERROR).with_message(format!(
                "Unexpected storage error for {:?}: {:?}",
                state_key, e
            ))
        });

        if ret.is_err() {
            // Even speculatively, reading from base view should not return an error.
            // Thus, this critical error log and count does not need to be buffered.
            let log_context = AdapterLogSchema::new(self.base_view.id(), self.txn_idx as usize);
            alert!(
                log_context,
                "[VM, StateView] Error getting data from storage for {:?}",
                state_key
            );
        }

        ret
    }
```

**File:** types/src/transaction/analyzed_transaction.rs (L244-283)
```rust
impl AnalyzedTransactionProvider for Transaction {
    fn get_read_write_hints(&self) -> (Vec<StorageLocation>, Vec<StorageLocation>) {
        let process_entry_function = |func: &EntryFunction,
                                      sender_address: AccountAddress|
         -> (Vec<StorageLocation>, Vec<StorageLocation>) {
            match (
                *func.module().address(),
                func.module().name().as_str(),
                func.function().as_str(),
            ) {
                (AccountAddress::ONE, "coin", "transfer") => {
                    let receiver_address = bcs::from_bytes(&func.args()[0]).unwrap();
                    rw_set_for_coin_transfer(sender_address, receiver_address, true)
                },
                (AccountAddress::ONE, "aptos_account", "transfer") => {
                    let receiver_address = bcs::from_bytes(&func.args()[0]).unwrap();
                    rw_set_for_coin_transfer(sender_address, receiver_address, false)
                },
                (AccountAddress::ONE, "aptos_account", "create_account") => {
                    let receiver_address = bcs::from_bytes(&func.args()[0]).unwrap();
                    rw_set_for_create_account(sender_address, receiver_address)
                },
                _ => todo!(
                    "Only coin transfer and create account transactions are supported for now"
                ),
            }
        };
        match self {
            Transaction::UserTransaction(signed_txn) => match signed_txn.payload().executable_ref()
            {
                Ok(TransactionExecutableRef::EntryFunction(func))
                    if !signed_txn.payload().is_multisig() =>
                {
                    process_entry_function(func, signed_txn.sender())
                },
                _ => todo!("Only entry function transactions are supported for now"),
            },
            _ => empty_rw_set(),
        }
    }
```
