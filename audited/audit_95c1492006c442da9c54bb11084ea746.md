# Audit Report

## Title
Coin Info Silent Data Loss Due to Truncated HashMap Key Collision in Indexer

## Summary
The coin processor deduplicates coin information using a HashMap keyed by truncated coin type strings (5000 char limit), while the database uses SHA-256 hashes of the full coin type as the primary key. When two coins have type strings exceeding 5000 characters with identical prefixes but different suffixes, they collide in the HashMap, causing one coin's metadata to be silently dropped during indexing. [1](#0-0) 

## Finding Description

The vulnerability occurs in the coin indexing pipeline where coin metadata is collected and deduplicated before database insertion.

**Step 1: Coin Type Construction**
When coin metadata is extracted from write resources, the full coin type string is used to compute two values:
- `coin_type_hash`: SHA-256 hash of the complete type string (used as database primary key)
- `coin_type`: Truncated version limited to 5000 characters (used for display) [2](#0-1) [3](#0-2) 

**Step 2: In-Transaction Deduplication**
Within a single transaction's processing, coin infos are stored in a HashMap using the **truncated** `coin_type` string as the key: [4](#0-3) [1](#0-0) 

The `.insert()` method **overwrites** any previous value with the same key. If two coins have type strings that both exceed 5000 characters and share the same first 5000 characters, they produce identical HashMap keys but different `coin_type_hash` values.

**Step 3: Cross-Transaction Deduplication**
The coin processor then merges coin infos across multiple transactions: [5](#0-4) [6](#0-5) 

**Attack Scenario:**
1. Attacker creates Coin A with type `0x1::module::Coin<Generic<...5010 chars total...ABC>>`
2. In the same transaction, creates Coin B with type `0x1::module::Coin<Generic<...5010 chars total...XYZ>>`
3. Both truncate to identical 5000-char strings but have different SHA-256 hashes
4. During processing, Coin B's `.insert()` overwrites Coin A in the HashMap
5. Only Coin B reaches database insertion; Coin A is permanently lost from the indexer

**Move VM Constraints:**
The Move VM production configuration allows type strings to exceed 5000 characters:
- `max_type_nodes`: 128-256 nodes per type
- `max_generic_instantiation_length`: 32 type parameters per struct
- `max_type_depth`: 20 levels of nesting [7](#0-6) [8](#0-7) 

With 256 type nodes each averaging 150 characters, a type can reach 38,400 characters, far exceeding the 5000-char truncation limit.

## Impact Explanation

This vulnerability causes **permanent data loss in the indexer database**, meeting Medium severity criteria for "State inconsistencies requiring intervention":

1. **Data Integrity Violation**: Legitimate coin metadata is silently dropped without error logging
2. **Indexer Completeness**: The indexer provides incomplete blockchain data to dependent applications
3. **Operational Impact**: 
   - Wallet applications cannot display the missing coin
   - Block explorers show incomplete coin listings
   - DeFi protocols miss coin discovery events
   - Security monitoring systems have blind spots

4. **Manual Intervention Required**: Since the coin info is never indexed, historical reindexing from blockchain state is required to recover the missing data

While this does not affect blockchain consensus or on-chain state (which remains correct), the indexer is critical infrastructure that many applications depend on for querying blockchain data. The silent nature of the failure makes detection difficult.

## Likelihood Explanation

**Likelihood: Low to Medium**

**Factors Increasing Likelihood:**
- Move VM explicitly allows type strings exceeding 5000 characters through production configuration
- An attacker could intentionally craft colliding coin types to hide malicious coins from indexer-based monitoring
- Complex generic types in legitimate DeFi protocols could accidentally trigger collisions

**Factors Decreasing Likelihood:**
- Requires type strings > 5000 characters with identical 5000-char prefixes
- Most real-world coin types are much shorter (< 200 chars)
- Multiple coins with colliding names in the same transaction batch is unusual

**Exploitation Complexity**: Low - attacker only needs to deploy Move modules with carefully crafted generic type parameters.

## Recommendation

**Fix 1: Use coin_type_hash for Deduplication**
Change the HashMap key from truncated `coin_type` to `coin_type_hash` to match the database primary key:

```rust
// In coin_activities.rs, line 84 and 160:
let mut coin_infos: HashMap<String, CoinInfo> = HashMap::new(); // Current
// Change to:
let mut coin_infos: HashMap<String, CoinInfo> = HashMap::new(); // Key is now coin_type_hash

// Line 160:
coin_infos.insert(coin_info.coin_type_hash.clone(), coin_info);
```

**Fix 2: Add Collision Detection**
Add validation to detect when different `coin_type_hash` values map to the same truncated `coin_type`:

```rust
if let Some(existing) = coin_infos.get(&coin_info.coin_type) {
    if existing.coin_type_hash != coin_info.coin_type_hash {
        aptos_logger::error!(
            "Coin type collision detected: {} vs {}",
            existing.coin_type_hash,
            coin_info.coin_type_hash
        );
    }
}
```

**Fix 3: Increase Truncation Limit**
Increase `COIN_TYPE_HASH_LENGTH` from 5000 to a value exceeding realistic type string lengths (e.g., 50000), though this requires database schema migration. [9](#0-8) 

## Proof of Concept

```rust
#[cfg(test)]
mod test {
    use super::*;
    use std::collections::HashMap;

    #[test]
    fn test_coin_type_collision() {
        // Simulate two coins with types > 5000 chars, identical first 5000 chars
        let long_prefix = "0x1::coin::Coin<".to_string() + &"A".repeat(4990);
        
        let coin_type_a = long_prefix.clone() + "ABC>";
        let coin_type_b = long_prefix.clone() + "XYZ>";
        
        // Both truncate to same 5000 chars
        let truncated_a = coin_type_a[..5000].to_string();
        let truncated_b = coin_type_b[..5000].to_string();
        assert_eq!(truncated_a, truncated_b, "Truncated types should match");
        
        // But hashes differ
        let hash_a = hash_str(&coin_type_a);
        let hash_b = hash_str(&coin_type_b);
        assert_ne!(hash_a, hash_b, "Hashes should differ");
        
        // Simulate HashMap behavior - second insert overwrites first
        let mut coin_infos: HashMap<String, String> = HashMap::new();
        coin_infos.insert(truncated_a.clone(), hash_a.clone());
        coin_infos.insert(truncated_b.clone(), hash_b.clone());
        
        // Only one entry exists - the second one overwrote the first
        assert_eq!(coin_infos.len(), 1, "Should have only one entry due to collision");
        assert_eq!(coin_infos.get(&truncated_a).unwrap(), &hash_b, 
                   "First coin's data was silently dropped");
    }
}
```

**Notes**

This vulnerability specifically affects the **Aptos Indexer**, an off-chain data indexing service that processes blockchain events and stores them in PostgreSQL for efficient querying. While the indexer is not part of consensus and does not affect on-chain state correctness, it is critical infrastructure that wallets, explorers, and DeFi protocols depend on for querying coin metadata.

The root cause is a mismatch between deduplication logic (using truncated strings) and database identity (using cryptographic hashes). This is a data integrity issue specific to the indexer's implementation, not a blockchain consensus vulnerability.

### Citations

**File:** crates/indexer/src/models/coin_models/coin_activities.rs (L84-84)
```rust
        let mut coin_infos: HashMap<CoinType, CoinInfo> = HashMap::new();
```

**File:** crates/indexer/src/models/coin_models/coin_activities.rs (L160-160)
```rust
                coin_infos.insert(coin_info.coin_type.clone(), coin_info);
```

**File:** crates/indexer/src/models/coin_models/coin_infos.rs (L67-68)
```rust
                    coin_type_hash: coin_info_type.to_hash(),
                    coin_type: coin_info_type.get_coin_type_trunc(),
```

**File:** crates/indexer/src/models/coin_models/coin_utils.rs (L16-16)
```rust
const COIN_TYPE_HASH_LENGTH: usize = 5000;
```

**File:** crates/indexer/src/models/coin_models/coin_utils.rs (L169-175)
```rust
    pub fn to_hash(&self) -> String {
        hash_str(&self.coin_type.to_string())
    }

    pub fn get_coin_type_trunc(&self) -> String {
        truncate_str(&self.coin_type, COIN_TYPE_HASH_LENGTH)
    }
```

**File:** crates/indexer/src/processors/coin_processor.rs (L290-290)
```rust
        let mut all_coin_infos: HashMap<String, CoinInfo> = HashMap::new();
```

**File:** crates/indexer/src/processors/coin_processor.rs (L309-311)
```rust
            for (key, value) in coin_infos {
                all_coin_infos.entry(key).or_insert(value);
            }
```

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L158-166)
```rust
        max_generic_instantiation_length: Some(32),
        max_function_parameters: Some(128),
        max_basic_blocks: Some(1024),
        max_value_stack_size: 1024,
        max_type_nodes: if enable_function_values {
            Some(128)
        } else {
            Some(256)
        },
```

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L188-192)
```rust
        max_type_depth: if enable_function_values {
            Some(20)
        } else {
            None
        },
```
