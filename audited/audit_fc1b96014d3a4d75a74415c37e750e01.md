# Audit Report

## Title
Unsafe Directory Permissions in CLI Binary Installation Allows Local Privilege Escalation

## Summary
The `build_updater()` function in the Aptos CLI update mechanism creates installation directories without explicitly setting restrictive permissions, relying instead on the user's umask. On multi-user systems where users have permissive umask settings (e.g., 0002 or 0000), this allows other local users to replace the Aptos CLI binary with malicious code, leading to arbitrary code execution when the victim runs the CLI.

## Finding Description

The vulnerability exists in the directory creation logic used by the CLI update mechanism. [1](#0-0) 

The installation directory is determined by `get_additional_binaries_dir()`, which returns platform-specific paths. [2](#0-1) 

On Unix-like systems, this defaults to `$HOME/.local/bin`. When `std::fs::create_dir_all()` is called without explicit permission settings, directories are created with permissions determined by `0777 & !umask`. 

**Attack Scenario:**

1. **Permissive Environment**: On a multi-user system (e.g., shared development server, CI/CD runner, academic computing environment), a user has a permissive umask:
   - umask `0002` → directories created with `0775` (rwxrwxr-x) - group-writable
   - umask `0000` → directories created with `0777` (rwxrwxrwx) - world-writable

2. **Victim Runs Update**: When the victim user runs `aptos update` or installs additional binaries, the installation directory is created with these permissive permissions.

3. **Binary Replacement**: An attacker (another user on the system, or a user in the same group for umask 0002) replaces the legitimate `aptos` binary with malicious code in the world/group-writable directory.

4. **Code Execution**: When the victim runs the `aptos` CLI, they unknowingly execute the attacker's code with their own privileges, potentially exposing:
   - Private keys stored on the system
   - Validator operator credentials
   - Access to blockchain operations with the victim's authority

The same vulnerability pattern exists in the prover dependencies installer. [3](#0-2) 

The codebase demonstrates awareness of permission security in other contexts (e.g., private key files use mode 0600), but this principle is not applied to binary installation directories. [4](#0-3) 

## Impact Explanation

**Severity: High**

This vulnerability enables **local privilege escalation** with potential for **validator compromise**. While it requires local system access (making it distinct from remote exploits), the impact is severe when considering validator infrastructure:

1. **Validator Operator Compromise**: If a validator operator's CLI is compromised, an attacker gains the ability to:
   - Extract validator private keys
   - Execute unauthorized validator operations
   - Submit malicious transactions with validator authority
   - Potentially violate consensus safety through malicious validator behavior

2. **Supply Chain Attack Vector**: On shared CI/CD systems used to build or deploy Aptos infrastructure, this could enable supply chain attacks affecting multiple users.

3. **Direct Code Execution**: Unlike information disclosure vulnerabilities, this provides arbitrary code execution in the victim's security context.

According to the Aptos bug bounty severity categories, this qualifies as **High Severity** because it can lead to validator node compromise and significant protocol violations when validator infrastructure is affected.

## Likelihood Explanation

**Likelihood: Medium**

The vulnerability requires specific conditions to be exploitable:

**Prerequisites:**
- Multi-user system (shared servers, CI/CD environments, academic systems)
- User with permissive umask (0002 for group-writable, 0000 for world-writable)
- Attacker with local access to the same system
- Victim running Aptos CLI update/installation

**Likelihood Factors:**

**Increases Likelihood:**
- Shared development servers and CI/CD runners commonly have permissive umasks for collaboration
- Academic and research computing environments often use group-writable defaults
- Validator operators may use shared infrastructure for cost efficiency
- Default umask varies by Linux distribution; some use 0002 by default

**Decreases Likelihood:**
- Requires local system access (not exploitable remotely)
- Single-user systems and isolated validators are not affected
- Many modern systems use more restrictive default umasks (0022)

## Recommendation

Explicitly set restrictive permissions (mode 0700) when creating binary installation directories to ensure only the owner can write to them, regardless of umask settings:

```rust
pub fn build_updater(
    info: &UpdateRequiredInfo,
    install_dir: Option<PathBuf>,
    // ... other parameters
) -> Result<Box<dyn ReleaseUpdate>> {
    // ... existing code ...
    
    let install_dir = match install_dir.clone() {
        Some(dir) => dir,
        None => {
            let dir = get_additional_binaries_dir();
            
            // Create directory with secure permissions (owner-only access)
            #[cfg(unix)]
            {
                use std::fs::DirBuilder;
                use std::os::unix::fs::DirBuilderExt;
                
                let mut builder = DirBuilder::new();
                builder.mode(0o700);
                builder.recursive(true);
                builder.create(&dir)
                    .with_context(|| format!("Failed to create directory: {:?}", dir))?;
            }
            
            #[cfg(not(unix))]
            {
                std::fs::create_dir_all(&dir)
                    .with_context(|| format!("Failed to create directory: {:?}", dir))?;
            }
            
            dir
        },
    };
    
    // ... rest of function
}
```

Apply the same fix to `prover_dependencies.rs` at the equivalent location. Additionally, consider setting restrictive permissions on the binaries themselves after download.

## Proof of Concept

**Setup on Linux:**

```bash
# Terminal 1 (Victim user)
# Set permissive umask to simulate vulnerable environment
umask 0000

# Run Aptos update to create directory
aptos update aptos

# Check directory permissions
ls -la ~/.local/bin
# Expected with vulnerability: drwxrwxrwx (777)
# Expected after fix: drwx------ (700)

# Terminal 2 (Attacker user on same system)
# Replace binary with malicious version
cd /home/victim/.local/bin
mv aptos aptos.real
cat > aptos << 'EOF'
#!/bin/bash
echo "Malicious binary executed!"
echo "Private keys would be stolen here"
./aptos.real "$@"
EOF
chmod +x aptos

# Terminal 1 (Victim)
# Run Aptos CLI - executes attacker's code
aptos --version
# Output: "Malicious binary executed!"
```

**Reproduction Steps:**

1. Set up a Linux system with two user accounts
2. As victim user, set `umask 0000` or `umask 0002`
3. Run `aptos update aptos` or any binary installation
4. Verify installation directory has world/group-writable permissions
5. As attacker user (or same group member), replace the binary
6. As victim user, execute the CLI and observe malicious code execution

This demonstrates that under permissive umask conditions, the binary installation directory allows unauthorized modification, enabling privilege escalation attacks on multi-user systems.

---

## Notes

This vulnerability is a traditional OS-level permission issue rather than a blockchain protocol vulnerability. However, it presents significant risk in the context of validator infrastructure security, where compromise of the CLI can lead to validator key theft and consensus-level attacks. The issue is particularly relevant for validators or developers using shared computing environments.

While the attack requires local system access (limiting remote exploitation), the severity is justified by the potential for validator compromise and the fact that the codebase already demonstrates awareness of permission security in other contexts but fails to apply it here.

### Citations

**File:** crates/aptos/src/update/update_helper.rs (L51-59)
```rust
    let install_dir = match install_dir.clone() {
        Some(dir) => dir,
        None => {
            let dir = get_additional_binaries_dir();
            // Make the directory if it doesn't already exist.
            std::fs::create_dir_all(&dir)
                .with_context(|| format!("Failed to create directory: {:?}", dir))?;
            dir
        },
```

**File:** crates/aptos/src/update/helpers.rs (L9-21)
```rust
pub fn get_additional_binaries_dir() -> PathBuf {
    #[cfg(windows)]
    {
        let home_dir = std::env::var("USERPROFILE").unwrap_or_else(|_| "".into());
        PathBuf::from(home_dir).join(".aptoscli/bin")
    }

    #[cfg(not(windows))]
    {
        let home_dir = std::env::var("HOME").unwrap_or_else(|_| "".into());
        PathBuf::from(home_dir).join(".local/bin")
    }
}
```

**File:** crates/aptos/src/update/prover_dependencies.rs (L105-114)
```rust
        let install_dir = match self.install_dir.clone() {
            Some(dir) => dir,
            None => {
                let dir = get_additional_binaries_dir();
                // Make the directory if it doesn't already exist.
                std::fs::create_dir_all(&dir)
                    .with_context(|| format!("Failed to create directory: {:?}", dir))?;
                dir
            },
        };
```

**File:** crates/aptos/src/common/utils.rs (L223-229)
```rust
/// Write a User only read / write file
pub fn write_to_user_only_file(path: &Path, name: &str, bytes: &[u8]) -> CliTypedResult<()> {
    let mut opts = OpenOptions::new();
    #[cfg(unix)]
    opts.mode(0o600);
    write_to_file_with_opts(path, name, bytes, &mut opts)
}
```
