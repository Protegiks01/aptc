# Audit Report

## Title
Missing Ancestry Validation in OptimisticProposal Allows Inconsistent Grandparent QC from Different Chain Fork

## Summary
OptimisticProposal blocks fail to validate that the `grandparent_qc` actually certifies the grandparent of the parent block, allowing a malicious validator to reuse a valid QC from a different chain fork. This creates blocks with inconsistent ancestry that pass all validation checks.

## Finding Description

OptimisticProposal blocks contain two quorum certificates:
1. `quorum_cert` (parent QC) - certifies the parent block at round r-1
2. `grandparent_qc` - claims to certify the grandparent block at round r-2

The parent QC's `VoteData` contains both the parent block info and the actual grandparent block info (`parent` field). However, validation never checks that `grandparent_qc.certified_block().id()` matches `quorum_cert.parent_block().id()`. [1](#0-0) 

The validate_signature function only verifies the cryptographic validity of both QCs independently, without checking their logical consistency. [2](#0-1) 

The verify_well_formed function only checks that rounds are consecutive (`grandparent_qc.round() + 1 == parent.round()`), not that the grandparent_qc actually certifies the parent's parent. [3](#0-2) 

When processing an optimistic proposal, the receiver uses its own highest QC as the parent QC, but never validates that this matches the grandparent_qc provided by the sender.

**Attack Scenario:**
1. Network partition causes temporary fork at round r-2: Chain A has block G_A, Chain B has block G_B (both get valid QCs in their partitions)
2. Partition heals, Chain B becomes canonical: G_B (r-2) → P (r-1)  
3. Byzantine validator holds valid QC for G_A from abandoned fork
4. Validator sends OptimisticProposal for round r with:
   - `grandparent_qc` = QC for G_A (from old fork)
   - `parent` BlockInfo = P (from canonical chain)
5. Receiver syncs to G_A via sync_info, later advances HQC to P
6. When processing pending proposal, receiver creates block with:
   - `quorum_cert` = QC for P (where P's parent is G_B per VoteData)
   - `grandparent_qc` = QC for G_A  
7. Block accepted despite G_A ≠ G_B (inconsistent ancestry)

## Impact Explanation

**Severity Assessment: Unclear / Potentially Non-Critical**

While this represents a clear protocol invariant violation (blocks should have consistent ancestry), the actual security impact is ambiguous:

1. **No Direct Consensus Safety Violation**: The actual blockchain chain is determined by following `quorum_cert` relationships, not `grandparent_qc`. The inconsistent grandparent may not affect commit decisions or cause chain splits.

2. **Protocol Integrity Violation**: Blocks contain provably false ancestry claims, violating protocol specifications and potentially enabling future exploits.

3. **Limited Exploitability**: Attack requires either:
   - Network partition (natural but rare event) + 1 Byzantine validator
   - OR > 1/3 Byzantine validators (outside threat model)

4. **Unclear Downstream Impact**: The grandparent_qc appears to be primarily for validation, not for determining the canonical chain. Further analysis needed to determine if inconsistent ancestry could be exploited in commit logic, state sync, or other subsystems.

## Likelihood Explanation

**Likelihood: Low to Medium**

Required conditions:
- Network partition or > 1/3 Byzantine validators to create fork with multiple QCs at same round
- Byzantine validator as proposer for target round
- Specific timing for receiver's state transitions

While technically feasible, requires rare network conditions or violates < 1/3 Byzantine assumption.

## Recommendation

Add explicit validation that grandparent QC certifies the actual grandparent:

```rust
// In Block::validate_signature() for OptimisticProposal case:
BlockType::OptimisticProposal(p) => {
    let (res1, res2) = rayon::join(
        || p.grandparent_qc().verify(validator),
        || self.quorum_cert().verify(validator),
    );
    res1?;
    res2?;
    
    // NEW: Validate ancestry consistency
    ensure!(
        p.grandparent_qc().certified_block().id() 
            == self.quorum_cert().parent_block().id(),
        "OptimisticProposal grandparent_qc does not match parent's parent"
    );
    Ok(())
}
```

## Proof of Concept

Due to the complexity of simulating network partitions and the ambiguity of actual security impact, a full PoC demonstrating exploitable harm cannot be provided. The missing validation check is confirmed, but demonstrating that it leads to consensus safety violations, fund loss, or other critical impacts requires deeper analysis of the commit logic and state management subsystems.

---

## Notes

After thorough investigation, while the missing validation check is confirmed in the codebase, the **actual exploitability and security impact remain ambiguous**. The attack requires specific network conditions and the downstream consequences of inconsistent ancestry are unclear. The grandparent_qc appears to be primarily for validation rather than determining the canonical chain.

**Critical Gap**: Without confirmation that inconsistent ancestry causes concrete security harm (consensus violations, fund loss, chain splits), this may not meet the **"EXTREMELY high bar for validity"** specified in the audit requirements.

**Recommendation**: Further investigation needed to determine if this protocol invariant violation leads to exploitable security issues in practice.

### Citations

**File:** consensus/consensus-types/src/block.rs (L453-461)
```rust
            BlockType::OptimisticProposal(p) => {
                // Note: Optimistic proposal is not signed by proposer unlike normal proposal
                let (res1, res2) = rayon::join(
                    || p.grandparent_qc().verify(validator),
                    || self.quorum_cert().verify(validator),
                );
                res1?;
                res2
            },
```

**File:** consensus/consensus-types/src/opt_block_data.rs (L75-89)
```rust
    pub fn verify_well_formed(&self) -> anyhow::Result<()> {
        let parent = self.parent();
        let grandparent_qc = self.grandparent_qc().certified_block();
        ensure!(
            grandparent_qc.round() + 1 == parent.round(),
            "Block's parent's round {} must be one more than grandparent's round {}",
            parent.round(),
            grandparent_qc.round(),
        );
        ensure!(
            parent.round() + 1 == self.round(),
            "Block's round {} must be one more than parent's round {}",
            self.round(),
            parent.round(),
        );
```

**File:** consensus/src/round_manager.rs (L843-864)
```rust
    async fn process_opt_proposal(&mut self, opt_block_data: OptBlockData) -> anyhow::Result<()> {
        ensure!(
            self.block_store
                .get_block_for_round(opt_block_data.round())
                .is_none(),
            "Proposal has already been processed for round: {}",
            opt_block_data.round()
        );
        let hqc = self.block_store.highest_quorum_cert().as_ref().clone();
        ensure!(
            hqc.certified_block().round() + 1 == opt_block_data.round(),
            "Opt proposal round {} is not the next round after the highest qc round {}",
            opt_block_data.round(),
            hqc.certified_block().round()
        );
        ensure!(
            hqc.certified_block().id() == opt_block_data.parent_id(),
            "Opt proposal parent id {} is not the same as the highest qc certified block id {}",
            opt_block_data.parent_id(),
            hqc.certified_block().id()
        );
        let proposal = Block::new_from_opt(opt_block_data, hqc);
```
