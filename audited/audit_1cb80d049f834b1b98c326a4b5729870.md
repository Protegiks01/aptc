# Audit Report

## Title
Indexer Fails to Mark Objects as Deleted When ObjectCore is Removed While Other ObjectGroup Resources Remain

## Summary
The indexer's `current_objects` table can incorrectly maintain `is_deleted=false` for objects whose `ObjectCore` resource has been deleted on-chain, but where other resources in the `ObjectGroup` resource group remain. This causes applications relying on the indexer to reference non-existent objects, leading to failed transactions and incorrect application state. [1](#0-0) 

## Finding Description
The Aptos object model uses resource groups to co-locate multiple resources under a single address. `ObjectCore` is a member of the `ObjectGroup` resource group, alongside other resources like `Token`, `FungibleStore`, `Collection`, and custom extension resources. [2](#0-1) 

When `object::delete()` is called with a `DeleteRef`, it only removes `ObjectCore` and optionally `Untransferable` from storage: [3](#0-2) 

However, other resources in the `ObjectGroup` may remain. During transaction execution, resource groups with remaining members are serialized and written as a **modification** operation, not a deletion: [4](#0-3) 

When the API layer converts these write operations to `WriteSetChange` objects, a resource group with bytes (remaining content) is decomposed into individual `WriteResource` changes for each memberâ€”ObjectCore's deletion is **not** represented as a `DeleteResource`: [5](#0-4) 

Only when the entire `ObjectGroup` is deleted (all members removed) does it create a `DeleteResource` for the group: [6](#0-5) 

The indexer only detects object deletions when it sees a `DeleteResource` with the specific resource type `"0x1::object::ObjectGroup"`: [7](#0-6) 

**Attack Scenario:**
1. Create an object with `ObjectCore` and additional resources (e.g., custom extension resources)
2. Call `object::delete()` to remove `ObjectCore`
3. Leave other `ObjectGroup` member resources in storage
4. The indexer processes a `WriteResource` modification (not `DeleteResource`)
5. The `current_objects` table retains `is_deleted=false`
6. Applications query the indexer and believe the object exists
7. Applications submit transactions referencing the object
8. Transactions fail because `ObjectCore` doesn't exist, breaking the application invariant `exists<ObjectCore>(address)` [8](#0-7) 

## Impact Explanation
This constitutes a **Medium severity** state inconsistency per the Aptos bug bounty criteria. Applications relying on the indexer for object existence checks will receive incorrect data, causing:

- Transaction failures when applications attempt to interact with "existing" objects
- Broken NFT marketplaces showing deleted items as available
- Incorrect inventory displays in applications
- Cascading failures in applications that cache indexer state

While this doesn't directly cause loss of funds or consensus violations, it creates systematic state divergence between the indexer and on-chain reality that requires manual intervention to detect and correct.

## Likelihood Explanation
This issue occurs whenever:
1. Developers call `object::delete()` without cleaning up all extension resources
2. Smart contracts add custom resources to objects and don't properly clean them up on deletion
3. Third-party extensions add resources to objects created by other contracts

The likelihood is **moderate** because proper object deletion patterns (like in `token::burn`) manually delete all known resources. However, the extensible nature of the object model means developers can add arbitrary resources, and partial deletions are a valid operation that the system must handle correctly.

## Recommendation
The indexer should detect object deletions by checking whether `ObjectCore` was removed, not just whether the entire `ObjectGroup` was deleted. Implement one of these solutions:

**Option 1:** During write set processing, explicitly check for `ObjectCore` deletions by examining the serialized resource group contents and detecting when `ObjectCore` is absent.

**Option 2:** Add specialized handling for resource groups to detect which individual members were deleted, not just when the entire group is deleted.

**Option 3:** Track `ObjectCore` existence separately by processing all `WriteResource` changes for resources at object addresses and checking if the resource type is `0x1::object::ObjectCore`.

Recommended fix in `v2_objects.rs`:

```rust
pub fn from_write_resource(
    write_resource: &WriteResource,
    txn_version: i64,
    write_set_change_index: i64,
) -> anyhow::Result<Option<(Self, CurrentObject)>> {
    if let Some(inner) = ObjectWithMetadata::from_write_resource(write_resource, txn_version)? {
        // Check if ObjectCore exists in the resource data
        let has_object_core = inner.object_core.is_some();
        
        // If ObjectCore is missing, treat as deleted
        let is_deleted = !has_object_core;
        
        // ... rest of the logic
    }
}
```

## Proof of Concept

```move
module test_addr::object_deletion_poc {
    use aptos_framework::object::{Self, Object, ConstructorRef, DeleteRef};
    use std::signer;

    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct CustomExtension has key {
        data: u64,
    }

    public fun create_object_with_extension(creator: &signer): (DeleteRef, address) {
        let constructor_ref = object::create_object(signer::address_of(creator));
        let object_signer = object::generate_signer(&constructor_ref);
        let delete_ref = object::generate_delete_ref(&constructor_ref);
        let object_addr = object::address_from_constructor_ref(&constructor_ref);
        
        // Add custom extension resource
        move_to(&object_signer, CustomExtension { data: 42 });
        
        (delete_ref, object_addr)
    }

    public fun delete_object_only(delete_ref: DeleteRef) {
        // This only deletes ObjectCore, not CustomExtension
        object::delete(delete_ref);
        // Bug: CustomExtension remains in ObjectGroup
        // Indexer will NOT mark object as deleted
    }

    #[test(creator = @test_addr)]
    fun test_partial_deletion(creator: &signer) {
        let (delete_ref, object_addr) = create_object_with_extension(creator);
        
        // Verify object exists
        assert!(object::is_object(object_addr), 0);
        
        // Delete ObjectCore only
        delete_object_only(delete_ref);
        
        // ObjectCore is gone
        assert!(!object::is_object(object_addr), 1);
        
        // But CustomExtension still exists
        assert!(exists<CustomExtension>(object_addr), 2);
        
        // Indexer will show is_deleted=false
        // Applications will try to use this object and fail
    }
}
```

## Notes
This vulnerability is explicitly acknowledged in the codebase with a TODO comment indicating awareness that partial deletions are not properly handled. The current implementation only detects full `ObjectGroup` deletions, missing the critical case where `ObjectCore` is removed but extension resources remain.

### Citations

**File:** crates/indexer/src/models/v2_objects.rs (L109-110)
```rust
    /// TODO: We need to detect if an object is only partially deleted
    /// using KV store
```

**File:** crates/indexer/src/models/v2_objects.rs (L118-163)
```rust
        if delete_resource.resource.to_string() == "0x1::object::ObjectGroup" {
            let resource = MoveResource::from_delete_resource(
                delete_resource,
                0, // Placeholder, this isn't used anyway
                txn_version,
                0, // Placeholder, this isn't used anyway
            );
            let previous_object = if let Some(object) = object_mapping.get(&resource.address) {
                object.clone()
            } else {
                match Self::get_object_owner(conn, &resource.address) {
                    Ok(owner) => owner,
                    Err(_) => {
                        aptos_logger::error!(
                            transaction_version = txn_version,
                            lookup_key = &resource.address,
                            "Missing object owner for object. You probably should backfill db.",
                        );
                        return Ok(None);
                    },
                }
            };
            Ok(Some((
                Self {
                    transaction_version: txn_version,
                    write_set_change_index,
                    object_address: resource.address.clone(),
                    owner_address: previous_object.owner_address.clone(),
                    state_key_hash: resource.state_key_hash.clone(),
                    guid_creation_num: previous_object.last_guid_creation_num.clone(),
                    allow_ungated_transfer: previous_object.allow_ungated_transfer,
                    is_deleted: true,
                },
                CurrentObject {
                    object_address: resource.address,
                    owner_address: previous_object.owner_address.clone(),
                    state_key_hash: resource.state_key_hash,
                    last_guid_creation_num: previous_object.last_guid_creation_num.clone(),
                    allow_ungated_transfer: previous_object.allow_ungated_transfer,
                    last_transaction_version: txn_version,
                    is_deleted: true,
                },
            )))
        } else {
            Ok(None)
        }
```

**File:** aptos-move/framework/aptos-framework/sources/object.move (L96-108)
```text
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    /// The core of the object model that defines ownership, transferability, and events.
    struct ObjectCore has key {
        /// Used by guid to guarantee globally unique objects and create event streams
        guid_creation_num: u64,
        /// The address (object or account) that owns this object
        owner: address,
        /// Object transferring is a common operation, this allows for disabling and enabling
        /// transfers bypassing the use of a TransferRef.
        allow_ungated_transfer: bool,
        /// Emitted events upon transferring of ownership.
        transfer_events: event::EventHandle<TransferEvent>,
    }
```

**File:** aptos-move/framework/aptos-framework/sources/object.move (L198-202)
```text
    public fun address_to_object<T: key>(object: address): Object<T> {
        assert!(exists<ObjectCore>(object), error::not_found(EOBJECT_DOES_NOT_EXIST));
        assert!(exists_at<T>(object), error::not_found(ERESOURCE_DOES_NOT_EXIST));
        Object<T> { inner: object }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/object.move (L414-428)
```text
    public fun delete(self: DeleteRef) acquires Untransferable, ObjectCore {
        let object_core = move_from<ObjectCore>(self.self);
        let ObjectCore {
            guid_creation_num: _,
            owner: _,
            allow_ungated_transfer: _,
            transfer_events,
        } = object_core;

        if (exists<Untransferable>(self.self)) {
            let Untransferable {} = move_from<Untransferable>(self.self);
        };

        event::destroy_handle(transfer_events);
    }
```

**File:** aptos-move/block-executor/src/executor_utilities.rs (L140-148)
```rust
                let btree: BTreeMap<T::Tag, Bytes> = finalized_group
                    .into_iter()
                    .map(|(resource_tag, arc_v)| {
                        let bytes = arc_v
                            .extract_raw_bytes()
                            .expect("Deletions should already be applied");
                        (resource_tag, bytes)
                    })
                    .collect();
```

**File:** api/types/src/convert.rs (L486-490)
```rust
                Path::ResourceGroup(typ) => vec![WriteSetChange::DeleteResource(DeleteResource {
                    address: access_path.address.into(),
                    state_key_hash,
                    resource: typ.into(),
                })],
```

**File:** api/types/src/convert.rs (L503-513)
```rust
                Path::ResourceGroup(_) => self
                    .try_into_resources_from_resource_group(bytes)?
                    .into_iter()
                    .map(|data| {
                        WriteSetChange::WriteResource(WriteResource {
                            address: access_path.address.into(),
                            state_key_hash: state_key_hash.clone(),
                            data,
                        })
                    })
                    .collect::<Vec<_>>(),
```
