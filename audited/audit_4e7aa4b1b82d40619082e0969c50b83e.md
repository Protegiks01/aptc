# Audit Report

## Title
Unvalidated Transitive Dependencies Allow Supply Chain Attacks via Manifest Manipulation

## Summary
The `resolve_custom_dependency()` function downloads packages from the blockchain and saves their Move.toml manifests without validating that the manifest dependencies match the on-chain validated `deps` field. This allows attackers to inject arbitrary transitive dependencies into downstream projects by publishing packages with manipulated manifests that declare dependencies never validated during on-chain publication.

## Finding Description

When a Move package is published on-chain, two separate dependency representations are stored in `PackageMetadata`:

1. **The `deps` field** - populated from actual compiled bytecode dependencies and validated by `check_dependencies()` [1](#0-0) 

2. **The `manifest` field** - the raw Move.toml file compressed as a blob, with NO validation that its dependencies match `deps` [2](#0-1) 

The on-chain `publish_package()` function only validates dependencies declared in the `deps` field: [3](#0-2) 

When `resolve_custom_dependency()` downloads a package, it saves the unvalidated manifest to disk: [4](#0-3) [5](#0-4) 

The Move compiler then parses this manifest and recursively downloads ALL declared dependencies: [6](#0-5) 

**Attack Path:**
1. Attacker publishes `MaliciousPackage` at address 0xbad
2. Attacker creates `TrojanPackage` with:
   - Move.toml declaring: `dependencies = { AptosFramework, MaliciousPackage }`
   - Source code that ONLY uses AptosFramework modules
   - When compiled: `deps = [AptosFramework]` (only actually-used dependencies)
   - Publishes with only AptosFramework validated by `check_dependencies()`
3. Victim adds TrojanPackage as dependency in their project
4. During compilation, TrojanPackage's manifest is parsed and MaliciousPackage is downloaded
5. MaliciousPackage is now in the victim's dependency tree, despite never being validated as a dependency of TrojanPackage

**Bypassed Validations:**
- Upgrade policy compatibility checks (deps with weaker policies should be rejected) [7](#0-6) 
- Existence validation (dependencies must exist on-chain) [8](#0-7) 
- The entire `check_dependencies()` security model [9](#0-8) 

## Impact Explanation

**Severity: High**

This vulnerability enables supply chain attacks against Aptos Move developers by bypassing the on-chain dependency validation system. While the malicious package itself must pass publication validation, the DEPENDENCY RELATIONSHIP between packages is never validated, allowing:

1. **Upgrade Policy Bypasses**: A package with `immutable` policy can covertly depend on packages with `arbitrary` policy, violating the security model that prevents immutable packages from depending on unstable code
2. **Unvetted Transitive Dependencies**: Developers unknowingly pull in dependencies that were never validated as part of the package's dependency graph
3. **Build Environment Compromise**: Malicious code is downloaded into developers' local build directories, potentially executing during compilation or through init_module functions

The impact qualifies as **High Severity** per Aptos bug bounty criteria as it represents a significant protocol violation that could lead to widespread compromise of developer environments and introduction of vulnerabilities into production contracts.

## Likelihood Explanation

**Likelihood: Medium-High**

The attack is practical and requires no special privileges:
- Any attacker can publish Move packages on-chain
- Creating a package with unused dependencies in Move.toml is straightforward (no compiler errors for unused dependencies)
- The discrepancy between manifest and deps is not detected by any validation
- Developers routinely add third-party packages as dependencies
- The attack is stealthy - victims have no indication that transitive dependencies were unvalidated

The main limitation is that the malicious package itself must still pass publication validation, but this doesn't prevent the dependency relationship bypass.

## Recommendation

Add validation in `resolve_custom_dependency()` to ensure the manifest dependencies match the on-chain validated `deps` field:

```rust
async fn maybe_download_package(info: &CustomDepInfo) -> anyhow::Result<()> {
    if !info.download_to.join(CompiledPackageLayout::BuildInfo.path()).exists() {
        let registry = CachedPackageRegistry::create(
            Url::parse(info.node_url.as_str())?,
            load_account_arg(info.package_address.as_str())?,
            false,
        ).await?;
        let package = registry.get_package(info.package_name).await?;
        
        // NEW: Validate manifest dependencies against on-chain deps
        let manifest_str = package.manifest()?;
        let manifest: SourceManifest = parse_move_manifest_string(manifest_str)
            .and_then(parse_source_manifest)?;
        
        let manifest_deps: BTreeSet<_> = manifest.dependencies.keys().collect();
        let metadata_deps: BTreeSet<_> = package.metadata.deps
            .iter()
            .map(|d| &d.package_name)
            .collect();
        
        if manifest_deps != metadata_deps {
            bail!("Package manifest dependencies do not match on-chain validated dependencies");
        }
        
        package.save_package_to_disk(info.download_to.as_path())
    } else {
        Ok(())
    }
}
```

Additionally, strengthen validation during package publication to ensure manifest dependencies match extracted deps before allowing publication.

## Proof of Concept

```move
// 1. Publish MaliciousPackage at 0xbad
module 0xbad::malicious {
    public fun backdoor() {
        // Malicious functionality
    }
}

// 2. Create TrojanPackage with Move.toml:
// [package]
// name = "TrojanPackage"
// 
// [dependencies]
// AptosFramework = { git = "...", rev = "..." }
// MaliciousPackage = { aptos = "0xbad" }  // Declared but not used
//
// [addresses]
// trojan = "0xcafe"

// 3. TrojanPackage source (DOES NOT use MaliciousPackage):
module 0xcafe::trojan {
    use std::signer;
    
    public fun legitimate_function(account: &signer) {
        // Only uses AptosFramework
        let _ = signer::address_of(account);
    }
}

// 4. When compiled:
// - deps = [AptosFramework]  // Only AptosFramework validated
// - manifest contains both AptosFramework AND MaliciousPackage

// 5. When victim adds TrojanPackage as dependency:
// - MaliciousPackage is downloaded without validation
// - Supply chain attack successful
```

## Notes

The vulnerability exists because the Move package system stores dependencies in two separate, unreconciled formats. The `deps` field undergoes strict validation during publication, but the `manifest` field (which drives dependency resolution) does not. This creates a trust boundary violation where unvalidated dependencies can enter the build system. The `CODE_DEPENDENCY_CHECK` feature flag validates bytecode-to-metadata consistency but does not address manifest-to-deps consistency, leaving this attack vector open.

### Citations

**File:** aptos-move/framework/src/built_package.rs (L523-526)
```rust
        let manifest_file = self.package_path.join("Move.toml");
        let manifest = std::fs::read_to_string(manifest_file)?;
        let custom_props = extract_custom_fields(&manifest)?;
        let manifest = zip_metadata_str(&manifest)?;
```

**File:** aptos-move/framework/src/built_package.rs (L552-580)
```rust
        let deps = self
            .package
            .deps_compiled_units
            .iter()
            .flat_map(|(name, unit)| match &unit.unit {
                CompiledUnit::Module(m) => {
                    let package_name = name.as_str().to_string();
                    let account = AccountAddress::new(m.address.into_bytes());

                    Some(PackageDep {
                        account,
                        package_name,
                    })
                },
                CompiledUnit::Script(_) => None,
            })
            .chain(
                self.package
                    .bytecode_deps
                    .iter()
                    .map(|(name, module)| PackageDep {
                        account: NumericalAddress::from_account_address(*module.self_addr())
                            .into_inner(),
                        package_name: name.as_str().to_string(),
                    }),
            )
            .collect::<BTreeSet<_>>()
            .into_iter()
            .collect();
```

**File:** aptos-move/framework/aptos-framework/sources/code.move (L181-182)
```text
        // Checks for valid dependencies to other packages
        let allowed_deps = check_dependencies(addr, &pack);
```

**File:** aptos-move/framework/aptos-framework/sources/code.move (L298-343)
```text
    fun check_dependencies(publish_address: address, pack: &PackageMetadata): vector<AllowedDep>
    acquires PackageRegistry {
        let allowed_module_deps = vector::empty();
        let deps = &pack.deps;
        vector::for_each_ref(deps, |dep| {
            let dep: &PackageDep = dep;
            assert!(exists<PackageRegistry>(dep.account), error::not_found(EPACKAGE_DEP_MISSING));
            if (is_policy_exempted_address(dep.account)) {
                // Allow all modules from this address, by using "" as a wildcard in the AllowedDep
                let account: address = dep.account;
                let module_name = string::utf8(b"");
                vector::push_back(&mut allowed_module_deps, AllowedDep { account, module_name });
            } else {
                let registry = borrow_global<PackageRegistry>(dep.account);
                let found = vector::any(&registry.packages, |dep_pack| {
                    let dep_pack: &PackageMetadata = dep_pack;
                    if (dep_pack.name == dep.package_name) {
                        // Check policy
                        assert!(
                            dep_pack.upgrade_policy.policy >= pack.upgrade_policy.policy,
                            error::invalid_argument(EDEP_WEAKER_POLICY)
                        );
                        if (dep_pack.upgrade_policy == upgrade_policy_arbitrary()) {
                            assert!(
                                dep.account == publish_address,
                                error::invalid_argument(EDEP_ARBITRARY_NOT_SAME_ADDRESS)
                            )
                        };
                        // Add allowed deps
                        let account = dep.account;
                        let k = 0;
                        let r = vector::length(&dep_pack.modules);
                        while (k < r) {
                            let module_name = vector::borrow(&dep_pack.modules, k).name;
                            vector::push_back(&mut allowed_module_deps, AllowedDep { account, module_name });
                            k = k + 1;
                        };
                        true
                    } else {
                        false
                    }
                });
                assert!(found, error::not_found(EPACKAGE_DEP_MISSING));
            };
        });
        allowed_module_deps
```

**File:** crates/aptos/src/move_tool/package_hooks.rs (L29-35)
```rust
    fn resolve_custom_dependency(
        &self,
        _dep_name: Symbol,
        info: &CustomDepInfo,
    ) -> anyhow::Result<()> {
        block_on(maybe_download_package(info))
    }
```

**File:** crates/aptos/src/move_tool/stored_package.rs (L161-166)
```rust
    pub fn save_package_to_disk(&self, path: &Path) -> anyhow::Result<()> {
        fs::create_dir_all(path)?;
        fs::write(
            path.join("Move.toml"),
            unzip_metadata_str(&self.metadata.manifest)?,
        )?;
```

**File:** third_party/move/tools/move-package/src/resolution/resolution_graph.rs (L263-289)
```rust
        for (dep_name, mut dep) in package
            .dependencies
            .clone()
            .into_iter()
            .chain(additional_deps.into_iter())
        {
            if let Some(std_version) = &override_std {
                if let Some(std_lib) = StdLib::from_package_name(dep_name) {
                    dep = std_lib.dependency(std_version);
                }
            }
            let dep_node_id = self.get_or_add_node(dep_name).with_context(|| {
                format!(
                    "Cycle between packages {} and {} found",
                    package_name, dep_name
                )
            })?;
            self.graph.add_edge(package_node_id, dep_node_id, ());

            let dep_resolution_table = self
                .process_dependency(dep_name, dep, package_path.clone(), override_std, writer)
                .with_context(|| {
                    format!(
                        "While resolving dependency '{}' in package '{}'",
                        dep_name, package_name
                    )
                })?;
```
