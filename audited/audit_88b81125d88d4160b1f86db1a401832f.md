# Audit Report

## Title
Rosetta API Crash via Malformed Fungible Asset Address Input

## Summary
The `get_base_balances()` function in the Aptos Rosetta API contains unsafe error handling that allows an attacker to crash the API service by providing a malformed fungible asset address. The vulnerability exists at line 335 where `AccountAddress::from_str()` is called with `.unwrap()` on user-controlled input, causing a panic when parsing fails. [1](#0-0) 

## Finding Description
The Rosetta API's `/account/balance` endpoint accepts an `AccountBalanceRequest` that includes an optional `currencies` field for filtering which asset balances to return. This field is user-controlled and can contain `CurrencyMetadata` with an `fa_address` (Fungible Asset address) string. [2](#0-1) 

When processing fungible asset balances, the code directly calls `AccountAddress::from_str(fa_address).unwrap()` without validating the input format. The `AccountAddress::from_str()` function can fail when provided with:
- Invalid hex characters (e.g., "0xZZZZ", "invalid")
- Empty strings or malformed addresses
- Addresses that are too long [3](#0-2) 

The attack flow is:
1. Attacker sends POST request to `/account/balance` with a malformed `fa_address` in the `currencies` field
2. Request is deserialized successfully (JSON parsing succeeds)
3. Code reaches line 335 in `get_base_balances()`
4. `AccountAddress::from_str(fa_address)` returns `Err(AccountAddressParseError)`
5. The `.unwrap()` panics, crashing the API thread

This vulnerability demonstrates inconsistent error handling - line 362 in the same function correctly uses `?` for error propagation, while lines 334-335 use `.unwrap()`. [4](#0-3) 

## Impact Explanation
This is a **High Severity** vulnerability per the Aptos bug bounty criteria, specifically under "API crashes". The Rosetta API is a critical infrastructure component used by exchanges and wallet providers for blockchain integration. A crash can:

- Cause service disruption for exchanges integrating with Aptos via Rosetta
- Enable DoS attacks with minimal resources (single HTTP request)
- Impact availability of balance queries and transaction construction
- Require manual service restart to restore functionality

While this doesn't affect consensus or cause fund loss, it violates the availability invariant for critical API infrastructure.

## Likelihood Explanation
Likelihood: **High**

- Attack requires no authentication or privileged access
- Exploitation is trivial - a single malformed API request
- No rate limiting can prevent the initial crash
- Attacker can repeatedly crash the service
- Common attack vector (malformed input causing panics in Rust)

The vulnerability is actively exploitable by anyone who can reach the Rosetta API endpoint.

## Recommendation
Replace `.unwrap()` with proper error handling using the `?` operator, consistent with line 362. The error will be propagated as an `ApiResult` and returned to the client as a proper error response instead of crashing.

**Fixed code for lines 333-336:**
```rust
vec![
    bcs::to_bytes(&owner_address)?,
    bcs::to_bytes(&AccountAddress::from_str(fa_address)?)?,
],
```

Additionally, consider adding validation at the input layer or using a helper function that provides better error messages:

```rust
fn parse_fa_address(addr_str: &str) -> ApiResult<AccountAddress> {
    AccountAddress::from_str(addr_str)
        .map_err(|e| ApiError::InvalidInput(Some(format!("Invalid FA address: {}", e))))
}
```

The codebase already has a pattern for this - the `encode_bcs()` function in `common.rs` properly handles BCS errors. [5](#0-4) 

## Proof of Concept
**HTTP Request to crash the API:**

```bash
curl -X POST http://localhost:8080/account/balance \
  -H "Content-Type: application/json" \
  -d '{
    "network_identifier": {
      "blockchain": "aptos",
      "network": "mainnet"
    },
    "account_identifier": {
      "address": "0x1"
    },
    "currencies": [
      {
        "symbol": "FA",
        "decimals": 8,
        "metadata": {
          "fa_address": "INVALID_ADDRESS"
        }
      }
    ]
  }'
```

**Expected behavior**: API crashes with panic message like:
```
thread 'tokio-runtime-worker' panicked at 'called `Result::unwrap()` on an `Err` value: ...'
```

**Rust reproduction steps:**
1. Deploy Aptos Rosetta API service
2. Send the malformed request shown above
3. Observe service crash in logs
4. Service requires restart to restore functionality

## Notes

While the security question focuses on "BCS serialization" causing the panic, the actual exploitable vulnerability occurs during **address parsing** before serialization. Specifically:

- The first `.unwrap()` on line 335 (on `AccountAddress::from_str()`) is the exploitable panic point
- The second `.unwrap()` on line 335 (on `bcs::to_bytes()`) is technically unsafe but not exploitable in practice, as BCS serialization of a valid `AccountAddress` (a simple `[u8; 32]` wrapper) cannot fail except in theoretical OOM scenarios
- Line 334 also uses `.unwrap()` on `bcs::to_bytes()` but `owner_address` is already validated at that point

The vulnerability violates the principle of never using `.unwrap()` on user-controlled input and demonstrates the importance of consistent error handling patterns across the codebase.

### Citations

**File:** crates/aptos-rosetta/src/account.rs (L333-336)
```rust
                    vec![
                        bcs::to_bytes(&owner_address).unwrap(),
                        bcs::to_bytes(&AccountAddress::from_str(fa_address).unwrap()).unwrap(),
                    ],
```

**File:** crates/aptos-rosetta/src/account.rs (L362-363)
```rust
                        vec![bcs::to_bytes(&owner_address)?],
                    )
```

**File:** crates/aptos-rosetta/src/types/objects.rs (L177-185)
```rust
#[derive(Clone, Debug, Deserialize, Eq, Hash, PartialEq, Serialize)]
pub struct CurrencyMetadata {
    /// Move coin type e.g. 0x1::aptos_coin::AptosCoin
    #[serde(skip_serializing_if = "Option::is_none")]
    pub move_type: Option<String>,
    /// Fungible Asset Address e.g. 0xA
    #[serde(skip_serializing_if = "Option::is_none")]
    pub fa_address: Option<String>,
}
```

**File:** third_party/move/move-core/types/src/account_address.rs (L369-404)
```rust
impl FromStr for AccountAddress {
    type Err = AccountAddressParseError;

    /// NOTE: This function has relaxed parsing behavior. For strict behavior, please use
    /// the `from_str_strict` function. Where possible use `from_str_strict` rather than
    /// this function.
    ///
    /// Create an instance of AccountAddress by parsing a hex string representation.
    ///
    /// This function allows all formats defined by AIP-40. In short this means the
    /// following formats are accepted:
    ///
    /// - LONG, with or without leading 0x
    /// - SHORT, with or without leading 0x
    ///
    /// Where:
    ///
    /// - LONG is 64 hex characters.
    /// - SHORT is 1 to 63 hex characters inclusive.
    ///
    /// Learn more about the different address formats by reading AIP-40:
    /// <https://github.com/aptos-foundation/AIPs/blob/main/aips/aip-40.md>.
    fn from_str(s: &str) -> Result<Self, AccountAddressParseError> {
        if !s.starts_with("0x") {
            if s.is_empty() {
                return Err(AccountAddressParseError::TooShort);
            }
            AccountAddress::from_hex_literal(&format!("0x{}", s))
        } else {
            if s.len() == 2 {
                return Err(AccountAddressParseError::TooShort);
            }
            AccountAddress::from_hex_literal(s)
        }
    }
}
```

**File:** crates/aptos-rosetta/src/common.rs (L128-132)
```rust
/// Encodes the object into BCS, handling errors
pub fn encode_bcs<T: Serialize>(obj: &T) -> ApiResult<String> {
    let bytes = bcs::to_bytes(obj)?;
    Ok(hex::encode(bytes))
}
```
