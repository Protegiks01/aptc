# Audit Report

## Title
Missing X25519 Public Key Validation Allows Weak Cryptographic Keys in Node Health Checker

## Summary
The Node Health Checker (NHC) accepts arbitrary x25519 public keys without cryptographic validation, only checking the byte length. This allows attackers to provide weak or malicious keys (such as all-zero keys or small-order points) that can compromise the Noise protocol handshake authentication, enabling security bypasses in node health monitoring.

## Finding Description

The vulnerability exists in the x25519 public key validation flow used by the Node Health Checker. When a public key is provided for noise connection validation, the system performs only length validation without cryptographic verification. [1](#0-0) 

The `TryFrom<&[u8]>` implementation for `x25519::PublicKey` only validates that the input is exactly 32 bytes, wrapping any 32-byte array into a `PublicKey` without checking if it represents a valid curve point. This contrasts sharply with Ed25519 validation in the same codebase, which explicitly checks for small-order points.

When NHC processes a health check request with a public key parameter, the validation occurs here: [2](#0-1) 

The `from_encoded_string` method only performs hex decoding and length validation: [3](#0-2) 

This validated (but cryptographically weak) key is then used in the Noise IK handshake for establishing authenticated connections: [4](#0-3) 

**Attack Scenario:**
1. Attacker provides a weak x25519 public key (e.g., `0x0000000000000000000000000000000000000000000000000000000000000000`)
2. NHC accepts this key as "valid" since it's 32 bytes
3. During the Noise handshake, the Diffie-Hellman operations `e.diffie_hellman(&rs)` and `s.diffie_hellman(&rs)` use this weak remote static key `rs`
4. With an all-zero or small-order point public key, these DH operations produce predictable or zero shared secrets
5. An attacker can predict the derived encryption keys and potentially forge valid handshake responses
6. NHC incorrectly reports that the node is running with the specified public key, when in reality the attacker has bypassed authentication

This breaks the **Cryptographic Correctness** invariant: X25519 operations are expected to be performed with valid, high-entropy public keys, not weak or malicious values.

## Impact Explanation

This is a **High Severity** issue under the Aptos bug bounty program category "Significant protocol violations." The vulnerability violates the Noise protocol's security assumptions by accepting cryptographically weak keys.

**Concrete Impacts:**
- **Authentication Bypass**: Attackers can make NHC believe a node is running with legitimate keys when it is not
- **Monitoring Deception**: Health check results become unreliable for operational decision-making
- **Reputation Gaming**: If NHC results feed into validator reputation or scoring systems, attackers could manipulate their scores

While this does not directly affect consensus or cause loss of funds, it compromises the operational security infrastructure that node operators rely on for monitoring and validation purposes.

## Likelihood Explanation

The likelihood is **HIGH** because:
1. The attack requires no special privileges - any user can call NHC with arbitrary parameters
2. Weak keys like all-zeros are trivial to construct
3. No additional validation exists in the code path
4. The vulnerability exists in production code that is actively used for node monitoring

## Recommendation

Implement cryptographic validation for x25519 public keys before use in security-critical operations. The validation should reject:
- All-zero keys
- Small-order/low-order points
- Invalid curve points

**Recommended Fix:**

```rust
impl std::convert::TryFrom<&[u8]> for PublicKey {
    type Error = traits::CryptoMaterialError;

    fn try_from(public_key_bytes: &[u8]) -> Result<Self, Self::Error> {
        let public_key_bytes: [u8; PUBLIC_KEY_SIZE] = public_key_bytes
            .try_into()
            .map_err(|_| traits::CryptoMaterialError::WrongLengthError)?;
        
        // Reject all-zero public key
        if public_key_bytes == [0u8; PUBLIC_KEY_SIZE] {
            return Err(traits::CryptoMaterialError::ValidationError);
        }
        
        // Reject known small-order points
        // The X25519 small-order points are: 
        // 0, 1, 325606250916557431795983626356110631294008115727848805560023387167927233504 (order 8)
        // 39382357235489614581723060781553021112529911719440698176882885853963445705823 (order 4)
        // etc.
        const SMALL_ORDER_POINTS: &[[u8; 32]] = &[
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
             0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
             0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            // Add other known small-order points
        ];
        
        for weak_point in SMALL_ORDER_POINTS {
            if &public_key_bytes == weak_point {
                return Err(traits::CryptoMaterialError::SmallSubgroupError);
            }
        }
        
        Ok(Self(public_key_bytes))
    }
}
```

Alternatively, perform validation at the NHC API layer before using keys in the Noise handshake.

## Proof of Concept

```rust
#[cfg(test)]
mod tests {
    use aptos_crypto::{x25519, traits::ValidCryptoMaterialStringExt};
    
    #[test]
    fn test_weak_x25519_key_accepted() {
        // All-zero key should be rejected but is currently accepted
        let all_zero_key = "0x0000000000000000000000000000000000000000000000000000000000000000";
        
        // This succeeds but should fail
        let weak_key = x25519::PublicKey::from_encoded_string(all_zero_key);
        assert!(weak_key.is_ok(), "Weak key was accepted!");
        
        // The key can be used in cryptographic operations
        let weak_pubkey = weak_key.unwrap();
        
        // Generate a private key and perform DH with the weak public key
        use aptos_crypto::Uniform;
        let mut rng = rand::rngs::OsRng;
        let priv_key = x25519::PrivateKey::generate(&mut rng);
        
        // This DH operation will produce a predictable result
        let shared_secret = priv_key.diffie_hellman(&weak_pubkey);
        
        // The shared secret will be all zeros or highly predictable
        println!("Shared secret with weak key: {:?}", shared_secret);
        
        // An attacker can exploit this in the Noise handshake
    }
    
    #[test]
    fn test_small_order_point_accepted() {
        // Point with order 1 (identity)
        let identity_point = "0x0100000000000000000000000000000000000000000000000000000000000000";
        
        let weak_key = x25519::PublicKey::from_encoded_string(identity_point);
        assert!(weak_key.is_ok(), "Small-order point was accepted!");
    }
}
```

To demonstrate the NHC bypass, an attacker would:
1. Call NHC API with `public_key=0x0000...0000`
2. Run a malicious server that exploits the predictable DH results to complete the handshake
3. NHC reports success even though proper authentication did not occur

## Notes

This vulnerability is specific to the Node Health Checker ecosystem tool and does not directly affect Aptos consensus or core blockchain operations. However, it represents a significant protocol violation that could impact operational security and monitoring reliability. The fix should be implemented in the `x25519::PublicKey` validation layer to protect all consumers of this cryptographic primitive, not just NHC.

### Citations

**File:** crates/aptos-crypto/src/x25519.rs (L228-236)
```rust
impl std::convert::TryFrom<&[u8]> for PublicKey {
    type Error = traits::CryptoMaterialError;

    fn try_from(public_key_bytes: &[u8]) -> Result<Self, Self::Error> {
        let public_key_bytes: [u8; PUBLIC_KEY_SIZE] = public_key_bytes
            .try_into()
            .map_err(|_| traits::CryptoMaterialError::WrongLengthError)?;
        Ok(Self(public_key_bytes))
    }
```

**File:** ecosystem/node-checker/src/server/api.rs (L46-58)
```rust
        // Ensure the public key, if given, is in a valid format.
        let public_key = match public_key.0 {
            Some(public_key) => match x25519::PublicKey::from_encoded_string(&public_key) {
                Ok(public_key) => Some(public_key),
                Err(e) => {
                    return Err(poem::Error::from((
                        StatusCode::BAD_REQUEST,
                        anyhow!("Invalid public key \"{}\": {:#}", public_key, e),
                    )))
                },
            },
            None => None,
        };
```

**File:** crates/aptos-crypto/src/traits/mod.rs (L85-99)
```rust
    fn from_encoded_string(encoded_str: &str) -> std::result::Result<Self, CryptoMaterialError> {
        let mut str = encoded_str;
        // First strip the AIP-80 prefix
        str = str.strip_prefix(Self::AIP_80_PREFIX).unwrap_or(str);

        // Strip 0x at beginning if there is one
        str = str.strip_prefix("0x").unwrap_or(str);

        let bytes_out = ::hex::decode(str);
        // We defer to `try_from` to make sure we only produce valid crypto materials.
        bytes_out
            // We reinterpret a failure to serialize: key is mangled someway.
            .or(Err(CryptoMaterialError::DeserializationError))
            .and_then(|ref bytes| Self::try_from(bytes))
    }
```

**File:** crates/aptos-crypto/src/noise.rs (L309-328)
```rust
        // -> es
        let dh_output = e.diffie_hellman(&rs);
        let k = mix_key(&mut ck, &dh_output)?;

        // -> s
        let aead = aes_key(&k[..]);
        let mut in_out = self.public_key.to_bytes();
        let nonce = aead::Nonce::assume_unique_for_key([0u8; AES_NONCE_SIZE]);

        aead.seal_in_place_append_tag(nonce, Aad::from(&h), &mut in_out)
            .map_err(|_| NoiseError::Encrypt)?;

        mix_hash(&mut h, &in_out[..]);
        response_buffer
            .write(&in_out[..])
            .map_err(|_| NoiseError::ResponseBufferTooSmall)?;

        // -> ss
        let dh_output = self.private_key.diffie_hellman(&rs);
        let k = mix_key(&mut ck, &dh_output)?;
```
