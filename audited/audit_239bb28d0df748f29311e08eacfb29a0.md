# Audit Report

## Title
Memory Exhaustion via Oversized DataPayload Notifications in State Sync Data Streaming Service

## Summary
The data streaming service lacks client-side validation of response sizes before queueing DataNotification objects in bounded channels. A malicious peer can send oversized responses (up to 64 MiB each, limited only by network layer constraints) that get queued without size validation, potentially consuming up to 3.2 GiB of memory and causing validator node crashes or severe performance degradation.

## Finding Description
The vulnerability exists in the state sync data streaming service's handling of network responses. When the `DataStream` receives responses from network peers via the `AptosDataClient`, it transforms them into `DataNotification` objects and queues them in a bounded mpsc channel. [1](#0-0) 

The channel has a default size limit of 50 notifications: [2](#0-1) 

The network layer permits messages up to 64 MiB: [3](#0-2) 

While the storage service is supposed to enforce a 40 MiB limit on responses: [4](#0-3) 

However, **there is no client-side validation** to verify that received responses respect these limits before they are queued as DataNotifications. The only validation performed is a type check: [5](#0-4) 

This function only validates that the response type matches the request type, not that the response size is within acceptable bounds.

**Attack Path:**
1. Validator node requests data from network peers during state synchronization
2. Malicious peer responds with oversized payloads (e.g., TransactionListWithProofV2 with each transaction near the maximum size, or with more transactions than requested)
3. Responses are deserialized by the StorageServiceClient without size validation
4. Stream engine transforms responses into DataNotification objects without checking byte size
5. DataNotifications are queued in the bounded channel (up to 50 notifications)
6. Memory consumption: 50 notifications × 64 MiB = **3.2 GiB** in worst case
7. If consumer is slow or blocked, memory exhaustion occurs, causing node crash or severe performance degradation

The vulnerability breaks the **Resource Limits** invariant: "All operations must respect gas, storage, and computational limits."

## Impact Explanation
This vulnerability qualifies as **Medium severity** per Aptos bug bounty criteria for the following reasons:

1. **Validator Node Slowdowns**: Excessive memory consumption from oversized notifications can cause garbage collection pressure, memory swapping, and severe performance degradation on validator nodes

2. **Potential Node Crashes**: In extreme cases with limited memory, the accumulation of 3.2 GiB worth of notifications can trigger Out-Of-Memory (OOM) kills, causing validator nodes to crash

3. **State Sync Disruption**: Affected validators cannot properly synchronize state, requiring manual intervention to identify and ban malicious peers

While this doesn't directly cause consensus safety violations or fund loss, it affects network availability and validator operations, making it a Medium severity issue with potential escalation to High if crashes are frequent.

## Likelihood Explanation
**Likelihood: Medium to High**

The attack is feasible because:

1. **No Special Access Required**: Any peer can connect to validators during state sync operations
2. **Network Layer Permits Large Messages**: The 64 MiB limit is sufficient to cause significant memory consumption
3. **No Client-Side Validation**: The vulnerability is directly exploitable without bypassing any checks
4. **Multiple Attack Vectors**: Attackers can exploit this through various data types (transactions, outputs, state values)

Mitigating factors:
- Bounded channel provides backpressure after 50 notifications
- Dynamic prefetching may reduce concurrent requests if errors are detected
- Validators can eventually disconnect malicious peers (but after damage is done)

However, even with these mitigations, an attacker can cause temporary but severe resource exhaustion before being detected.

## Recommendation
Implement client-side validation of response sizes before queueing DataNotifications. Add a check in the `send_data_notification_to_client` method to validate that the serialized size of the response payload does not exceed expected limits.

**Recommended Fix:**

Add a validation function in `data_stream.rs`:

```rust
fn validate_response_size(
    client_response_payload: &ResponsePayload,
    max_response_bytes: u64,
) -> Result<(), Error> {
    let response_bytes = bcs::serialized_size(client_response_payload)
        .map_err(|e| Error::UnexpectedErrorEncountered(format!("Failed to calculate response size: {}", e)))?;
    
    if response_bytes as u64 > max_response_bytes {
        return Err(Error::AptosDataClientResponseIsInvalid(format!(
            "Response size {} bytes exceeds maximum {} bytes",
            response_bytes, max_response_bytes
        )));
    }
    
    Ok(())
}
```

Then call this validation before queueing:

```rust
async fn send_data_notification_to_client(
    &mut self,
    data_client_request: &DataClientRequest,
    data_client_response: Response<ResponsePayload>,
) -> Result<(), Error> {
    let (response_context, response_payload) = data_client_response.into_parts();

    // Validate response size before queueing
    let max_response_bytes = self.streaming_service_config.max_response_bytes_v2;
    validate_response_size(&response_payload, max_response_bytes)?;

    // Create a new data notification
    if let Some(data_notification) = self
        .stream_engine
        .transform_client_response_into_notification(
            data_client_request,
            response_payload,
            self.notification_id_generator.clone(),
        )?
    {
        // ... rest of the function
    }
    
    Ok(())
}
```

Additionally, add configuration for `max_response_bytes_v2` to `DataStreamingServiceConfig` with a default value of 40 MiB to align with storage service limits.

## Proof of Concept
A Rust-based reproduction would involve:

1. **Setup**: Create a malicious peer that implements the storage service protocol
2. **Malicious Response**: When requested for transactions, respond with a TransactionListWithProofV2 containing transactions with large payloads (each transaction near the maximum allowable size)
3. **Trigger**: Connect the malicious peer to a validator node during state sync
4. **Observe**: Monitor validator memory consumption as notifications are queued
5. **Result**: Observe memory exhaustion and potential OOM crashes

```rust
// Pseudocode for malicious peer response
fn create_oversized_response() -> TransactionListWithProofV2 {
    let mut large_transactions = vec![];
    
    // Create transactions with large payloads
    for _ in 0..3000 {  // MAX_TRANSACTION_CHUNK_SIZE
        let large_payload = vec![0u8; 20_000];  // 20 KB per transaction
        let txn = create_transaction_with_payload(large_payload);
        large_transactions.push(txn);
    }
    
    // Total size: 3000 × 20 KB = 60 MB per response
    // With 50 notifications: 50 × 60 MB = 3 GB memory consumption
    TransactionListWithProofV2::new(large_transactions, /* proofs */)
}
```

The vulnerability can be confirmed by:
1. Measuring validator memory usage before and after connecting malicious peer
2. Observing channel queue depth metrics
3. Detecting OOM events or severe performance degradation in validator logs

**Notes**

The vulnerability is exacerbated by the fact that the bounded channel provides backpressure only **after** 50 notifications are queued, meaning the memory is already consumed before the protection mechanism activates. The lack of byte-level size validation at the client side creates a direct path for resource exhaustion attacks.

### Citations

**File:** state-sync/data-streaming-service/src/data_stream.rs (L140-141)
```rust
        let (notification_sender, notification_receiver) =
            mpsc::channel(data_stream_config.max_data_stream_channel_sizes as usize);
```

**File:** state-sync/data-streaming-service/src/data_stream.rs (L1292-1370)
```rust
fn sanity_check_client_response_type(
    data_client_request: &DataClientRequest,
    data_client_response: &Response<ResponsePayload>,
) -> bool {
    match data_client_request {
        DataClientRequest::EpochEndingLedgerInfos(_) => {
            matches!(
                data_client_response.payload,
                ResponsePayload::EpochEndingLedgerInfos(_)
            )
        },
        DataClientRequest::NewTransactionOutputsWithProof(_) => {
            matches!(
                data_client_response.payload,
                ResponsePayload::NewTransactionOutputsWithProof(_)
            )
        },
        DataClientRequest::NewTransactionsWithProof(_) => {
            matches!(
                data_client_response.payload,
                ResponsePayload::NewTransactionsWithProof(_)
            )
        },
        DataClientRequest::NewTransactionsOrOutputsWithProof(_) => {
            matches!(
                data_client_response.payload,
                ResponsePayload::NewTransactionsWithProof(_)
            ) || matches!(
                data_client_response.payload,
                ResponsePayload::NewTransactionOutputsWithProof(_)
            )
        },
        DataClientRequest::NumberOfStates(_) => {
            matches!(
                data_client_response.payload,
                ResponsePayload::NumberOfStates(_)
            )
        },
        DataClientRequest::StateValuesWithProof(_) => {
            matches!(
                data_client_response.payload,
                ResponsePayload::StateValuesWithProof(_)
            )
        },
        DataClientRequest::SubscribeTransactionsWithProof(_) => {
            matches!(
                data_client_response.payload,
                ResponsePayload::NewTransactionsWithProof(_)
            )
        },
        DataClientRequest::SubscribeTransactionOutputsWithProof(_) => {
            matches!(
                data_client_response.payload,
                ResponsePayload::NewTransactionOutputsWithProof(_)
            )
        },
        DataClientRequest::SubscribeTransactionsOrOutputsWithProof(_) => {
            matches!(
                data_client_response.payload,
                ResponsePayload::NewTransactionsWithProof(_)
            ) || matches!(
                data_client_response.payload,
                ResponsePayload::NewTransactionOutputsWithProof(_)
            )
        },
        DataClientRequest::TransactionsWithProof(_) => {
            matches!(
                data_client_response.payload,
                ResponsePayload::TransactionsWithProof(_)
            )
        },
        DataClientRequest::TransactionOutputsWithProof(_) => {
            matches!(
                data_client_response.payload,
                ResponsePayload::TransactionOutputsWithProof(_)
            )
        },
        DataClientRequest::TransactionsOrOutputsWithProof(_) => {
            matches!(
```

**File:** config/src/config/state_sync_config.rs (L20-21)
```rust
const CLIENT_MAX_MESSAGE_SIZE_V2: usize = 20 * 1024 * 1024; // 20 MiB (used for v2 data requests)
const SERVER_MAX_MESSAGE_SIZE_V2: usize = 40 * 1024 * 1024; // 40 MiB (used for v2 data requests)
```

**File:** config/src/config/state_sync_config.rs (L273-273)
```rust
            max_data_stream_channel_sizes: 50,
```

**File:** network/framework/src/constants.rs (L20-21)
```rust
pub const MAX_FRAME_SIZE: usize = 4 * 1024 * 1024; /* 4 MiB */
pub const MAX_MESSAGE_SIZE: usize = 64 * 1024 * 1024; /* 64 MiB */
```
