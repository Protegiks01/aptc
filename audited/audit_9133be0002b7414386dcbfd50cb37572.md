# Audit Report

## Title
Missing Signature Verification in Oneoff Epoch Ending Restore Allows Malicious Epoch History Injection

## Summary
The `db-tool restore oneoff epoch-ending` command unconditionally passes `None` for the `previous_epoch_ending_ledger_info` parameter when calling `EpochEndingRestoreController::run()`, bypassing critical signature verification checks. When combined with the absence of trusted waypoints (which are optional CLI parameters), this allows an attacker to inject fraudulent epoch-ending ledger infos with invalid validator signatures into a restored database. [1](#0-0) 

## Finding Description

The vulnerability occurs at the integration point between the db-tool CLI and the EpochEndingRestoreController. When the `previous_epoch_ending_ledger_info` parameter is `None`, the critical continuity and signature verification logic is completely skipped. [2](#0-1) 

This validation block (which only executes when `previous_epoch_ending_ledger_info` is `Some`) performs two essential security checks:

1. **Epoch Continuity Check**: Verifies that `previous_li.next_block_epoch() == manifest.first_epoch`
2. **Signature Verification**: If no trusted waypoint exists for the first ledger info, it verifies signatures using `previous_li.next_epoch_state().verify(first_li)`

The `preheat_impl` function does perform some validation, but it has a critical weakness: [3](#0-2) 

The `previous_li` in this context is the previous ledger info **within the backup being restored**, not from the existing chain state. For a backup starting at epoch 0 (genesis), `previous_li` is initially `None`, so only trusted waypoint verification occurs. [4](#0-3) 

Since trusted waypoints are optional CLI parameters (not enforced), an operator could restore without providing them: [5](#0-4) 

**Attack Scenario:**
1. Attacker creates a malicious epoch-ending backup starting from epoch 0
2. Attacker uses fake/invalid validator signatures for the first epoch's LedgerInfoWithSignatures
3. Victim operator runs: `db-tool restore oneoff epoch-ending --epoch-ending-manifest=<malicious_backup> --target-db-dir=<db_dir>` **without** `--trust-waypoint` parameters
4. The restore succeeds, writing fraudulent epoch-ending information to the database
5. If the node uses this database, it operates with an invalid epoch history, potentially accepting invalid validator sets and violating consensus safety

In contrast, the `RestoreCoordinator` (used by `bootstrap-db`) correctly uses `EpochHistoryRestoreController`, which properly chains the `previous_li` parameter: [6](#0-5) [7](#0-6) 

The `save_ledger_infos` function performs no signature validation, it simply writes the ledger infos to the database.

## Impact Explanation

This vulnerability represents a **High Severity** issue under the Aptos bug bounty criteria for the following reasons:

1. **Significant Protocol Violation**: The validator set and epoch boundaries are fundamental to AptosBFT consensus. Fraudulent epoch-ending information could cause nodes to accept invalid validator sets, leading to consensus safety violations.

2. **Chain Integrity Compromise**: A node operating with manipulated epoch history could diverge from the canonical chain, potentially causing network partitions or accepting invalid blocks.

3. **Trust Boundary Violation**: While the attack requires operator error (not providing trusted waypoints), the tool design makes this misconfiguration easy and provides no warnings. The security depends entirely on optional parameters.

4. **Consensus Safety Risk**: This breaks the **Consensus Safety** invariant that "AptosBFT must prevent double-spending and chain splits under < 1/3 Byzantine" by allowing nodes to operate with fraudulent validator set information.

The impact is slightly mitigated because:
- Operators performing critical restore operations should use trusted waypoints as a security best practice
- The `bootstrap-db` command (full restore coordinator) is not affected
- Once the node attempts to sync with the network, the fraudulent epoch history would likely be detected

However, the misconfiguration vulnerability remains serious.

## Likelihood Explanation

**Likelihood: Medium**

The attack requires:
1. **Malicious Backup Provider**: Attacker must control or compromise a backup source
2. **Operator Error**: Operator must not provide `--trust-waypoint` parameters
3. **Social Engineering**: Convince operator to use attacker's backup

Factors increasing likelihood:
- Trusted waypoints are optional CLI parameters with no enforcement
- No warnings are displayed when restoring without waypoints
- Documentation emphasis on waypoints may not be universally followed
- Disaster recovery scenarios may prioritize speed over security
- Test/development environments may skip security parameters

Factors decreasing likelihood:
- Best practices documentation recommends using waypoints
- The `bootstrap-db` command (recommended for production) is not vulnerable
- Network sync would eventually detect inconsistencies
- Most operators use automated restore procedures that include waypoints

## Recommendation

**Immediate Fix**: Require trusted waypoints or query existing DB state for epoch continuity validation.

**Option 1 - Require Trusted Waypoint for First Epoch:**

```rust
// In storage/db-tool/src/restore.rs, lines 70-82
Oneoff::EpochEnding {
    storage,
    opt,
    global,
} => {
    let global_opt = global.try_into()?;
    let storage = storage.init_storage().await?;
    
    // Query the database for the last epoch ending ledger info
    // This requires access to the restore handler
    let previous_li = if let RestoreRunMode::Restore { restore_handler } = global_opt.run_mode.as_ref() {
        restore_handler.get_latest_ledger_info()
            .ok()
            .filter(|li| li.ledger_info().ends_epoch())
            .map(|li| li.ledger_info().clone())
    } else {
        None
    };
    
    EpochEndingRestoreController::new(
        opt,
        global_opt,
        storage,
    )
    .run(previous_li.as_ref())
    .await?;
},
```

**Option 2 - Enforce Trusted Waypoint Requirement:**

```rust
// In storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs
// Add validation in EpochEndingRestoreController::new or run
pub async fn run(
    self,
    previous_epoch_ending_ledger_info: Option<&LedgerInfo>,
) -> Result<Vec<LedgerInfo>> {
    let preheat_data = self.preheat().await;
    
    // If no previous_li is provided, require trusted waypoint for first epoch
    if previous_epoch_ending_ledger_info.is_none() {
        let first_li = preheat_data.preheat_result.as_ref()
            .ok()
            .and_then(|data| data.ledger_infos.first());
        
        if let Some(first_li) = first_li {
            let first_version = first_li.ledger_info().version();
            ensure!(
                self.trusted_waypoints.contains_key(&first_version),
                "Restoring from epoch {} without previous ledger info requires a trusted waypoint at version {}. \
                Use --trust-waypoint to specify the expected waypoint.",
                first_li.ledger_info().epoch(),
                first_version
            );
        }
    }
    
    preheat_data.run(previous_epoch_ending_ledger_info).await
}
```

**Best Practice Documentation:**
Add clear warnings in the CLI help text and documentation that epoch-ending restore without trusted waypoints or previous ledger info is unsafe and should only be used in test environments.

## Proof of Concept

```rust
// This PoC demonstrates the vulnerability by showing that a restore
// can succeed without signature verification

use aptos_backup_cli::{
    backup_types::epoch_ending::{
        manifest::EpochEndingBackup,
        restore::{EpochEndingRestoreController, EpochEndingRestoreOpt},
    },
    storage::{local_fs::LocalFs, BackupStorage},
    utils::{GlobalRestoreOpt, TrustedWaypointOpt, ConcurrentDownloadsOpt, 
            ReplayConcurrencyLevelOpt, RocksdbOpt},
};
use aptos_temppath::TempPath;
use aptos_types::{
    aggregate_signature::AggregateSignature,
    ledger_info::{LedgerInfo, LedgerInfoWithSignatures},
    block_info::BlockInfo,
};
use std::{convert::TryInto, sync::Arc};

#[tokio::test]
async fn test_epoch_restore_without_validation() {
    // Create a malicious backup with invalid signatures
    let backup_dir = TempPath::new();
    backup_dir.create_as_dir().unwrap();
    let restore_dir = TempPath::new();
    restore_dir.create_as_dir().unwrap();
    
    // Create a fake epoch 0 ledger info with EMPTY signatures
    let genesis_li = LedgerInfo::new(
        BlockInfo::genesis(/* ... */),
        HashValue::zero(),
    );
    
    // Use empty signature (would be invalid in real scenario)
    let malicious_li = LedgerInfoWithSignatures::new(
        genesis_li,
        AggregateSignature::empty(), // Invalid signature!
    );
    
    // Create and save malicious backup manifest
    // ... (create manifest with malicious_li)
    
    // Attempt restore WITHOUT trusted waypoint - should fail but currently succeeds
    let store: Arc<dyn BackupStorage> = Arc::new(
        LocalFs::new(backup_dir.path().to_path_buf())
    );
    
    let result = EpochEndingRestoreController::new(
        EpochEndingRestoreOpt { /* ... */ },
        GlobalRestoreOpt {
            db_dir: Some(restore_dir.path().to_path_buf()),
            dry_run: false,
            target_version: None,
            trusted_waypoints: TrustedWaypointOpt::default(), // NO WAYPOINTS!
            rocksdb_opt: RocksdbOpt::default(),
            concurrent_downloads: ConcurrentDownloadsOpt::default(),
            replay_concurrency_level: ReplayConcurrencyLevelOpt::default(),
            enable_state_indices: false,
        }
        .try_into()
        .unwrap(),
        store,
    )
    .run(None) // Passing None - this is the vulnerability!
    .await;
    
    // This should fail but currently succeeds, accepting the invalid signatures
    assert!(result.is_ok(), "Restore succeeded with invalid signatures!");
}
```

## Notes

The vulnerability exists specifically in the `oneoff epoch-ending` restore path, not in the full `bootstrap-db` restore coordinator. Production deployments should use the `bootstrap-db` command which properly maintains epoch continuity. However, the oneoff command is still part of the supported tooling and should not silently accept invalid data.

The test file at `storage/backup/backup-cli/src/backup_types/epoch_ending/tests.rs` line 96 shows that even the existing tests call `.run(None)`, demonstrating that this pattern is used but not properly validated for security implications. [8](#0-7)

### Citations

**File:** storage/db-tool/src/restore.rs (L75-81)
```rust
                        EpochEndingRestoreController::new(
                            opt,
                            global.try_into()?,
                            storage.init_storage().await?,
                        )
                        .run(None)
                        .await?;
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L129-135)
```rust
                if let Some(wp_trusted) = self.trusted_waypoints.get(&wp_li.version()) {
                    ensure!(
                        *wp_trusted == wp_li,
                        "Waypoints don't match. In backup: {}, trusted: {}",
                        wp_li,
                        wp_trusted,
                    );
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L136-146)
```rust
                } else if let Some(pre_li) = previous_li {
                    pre_li
                        .ledger_info()
                        .next_epoch_state()
                        .ok_or_else(|| {
                            anyhow!(
                                "Next epoch state not found from LI at epoch {}.",
                                pre_li.ledger_info().epoch()
                            )
                        })?
                        .verify(&li)?;
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L218-240)
```rust
        if let Some(li) = previous_epoch_ending_ledger_info {
            ensure!(
                li.next_block_epoch() == preheat_data.manifest.first_epoch,
                "Previous epoch ending LedgerInfo is not the one expected. \
                My first epoch: {}, previous LedgerInfo next_block_epoch: {}",
                preheat_data.manifest.first_epoch,
                li.next_block_epoch(),
            );
            // Waypoint has been verified in preheat if it's trusted, otherwise try to check
            // the signatures.
            if self
                .controller
                .trusted_waypoints
                .get(&first_li.ledger_info().version())
                .is_none()
            {
                li.next_epoch_state()
                    .ok_or_else(|| {
                        anyhow!("Previous epoch ending LedgerInfo doesn't end an epoch")
                    })?
                    .verify(first_li)?;
            }
        }
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L379-381)
```rust
        while let Some(preheated_restore) = futs_stream.next().await {
            let manifest_handle = preheated_restore.controller.manifest_handle.clone();
            let lis = preheated_restore.run(previous_li).await?;
```

**File:** storage/backup/backup-cli/src/utils/mod.rs (L331-345)
```rust
#[derive(Clone, Default, Parser)]
pub struct TrustedWaypointOpt {
    #[clap(
        long,
        help = "(multiple) When provided, an epoch ending LedgerInfo at the waypoint version will be \
        checked against the hash in the waypoint, but signatures on it are NOT checked. \
        Use this for two purposes: \
        1. set the genesis or the latest waypoint to confirm the backup is compatible. \
        2. set waypoints at versions where writeset transactions were used to overwrite the \
        validator set, so that the signature check is skipped. \
        N.B. LedgerInfos are verified only when restoring / verifying the epoch ending backups, \
        i.e. they are NOT checked at all when doing one-shot restoring of the transaction \
        and state backups."
    )]
    pub trust_waypoint: Vec<Waypoint>,
```

**File:** storage/aptosdb/src/backup/restore_utils.rs (L41-57)
```rust
pub(crate) fn save_ledger_infos(
    ledger_metadata_db: &LedgerMetadataDb,
    ledger_infos: &[LedgerInfoWithSignatures],
    existing_batch: Option<&mut SchemaBatch>,
) -> Result<()> {
    ensure!(!ledger_infos.is_empty(), "No LedgerInfos to save.");

    if let Some(existing_batch) = existing_batch {
        save_ledger_infos_impl(ledger_metadata_db, ledger_infos, existing_batch)?;
    } else {
        let mut batch = SchemaBatch::new();
        save_ledger_infos_impl(ledger_metadata_db, ledger_infos, &mut batch)?;
        ledger_metadata_db.write_schemas(batch)?;
        update_latest_ledger_info(ledger_metadata_db, ledger_infos)?;
    }

    Ok(())
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/tests.rs (L79-98)
```rust
    rt.block_on(
        EpochEndingRestoreController::new(
            EpochEndingRestoreOpt { manifest_handle },
            GlobalRestoreOpt {
                db_dir: Some(tgt_db_dir.path().to_path_buf()),
                dry_run: false,
                target_version: Some(target_version),
                trusted_waypoints: TrustedWaypointOpt::default(),
                rocksdb_opt: RocksdbOpt::default(),
                concurrent_downloads: ConcurrentDownloadsOpt::default(),
                replay_concurrency_level: ReplayConcurrencyLevelOpt::default(),
                enable_state_indices: false,
            }
            .try_into()
            .unwrap(),
            store,
        )
        .run(None),
    )
    .unwrap();
```
