# Audit Report

## Title
Consensus Observer Complete Liveness Failure When Execution Pool is Enabled

## Summary
When execution pool is enabled network-wide, consensus observer nodes cannot process any blocks, resulting in complete loss of functionality. The incomplete execution pool integration causes regular ordered blocks to be rejected and execution pool blocks to be dropped, preventing all block processing.

## Finding Description

The consensus observer has incomplete execution pool integration with two critical TODOs that create a complete denial of service:

**Issue 1: Regular blocks rejected when execution pool enabled** [1](#0-0) 

When execution pool is enabled (window_size is Some), the observer rejects all regular `OrderedBlock` messages.

**Issue 2: Execution pool blocks completely dropped** [2](#0-1) 

The `OrderedBlockWithWindow` messages are received, validated, but then completely dropped with a TODO comment indicating the processing is not implemented.

**Issue 3: Pending blocks cannot handle execution pool dependencies** [3](#0-2) 

The `remove_ready_block` function has a TODO indicating it doesn't know how to handle execution pool blocks. It only checks payload availability, not execution pool window dependencies.

**Execution Flow:**
1. Network enables execution pool (sets `execution_pool_window_size` to Some value)
2. Validators send `OrderedBlockWithWindow` messages instead of regular `OrderedBlock`
3. Observer checks if execution pool is enabled
4. If enabled and receives `OrderedBlock`: rejected at line 655
5. If enabled and receives `OrderedBlockWithWindow`: dropped at line 895
6. Result: NO blocks are processed, observer becomes non-functional

**Root Cause:**
The execution pool window contains dependencies (parent block hashes) needed for parallel execution context. The consensus observer architecture was not designed to handle this, as observers don't maintain the full BlockStore tree structure that normal consensus nodes use. When blocks arrive with execution pool windows, the observer has no mechanism to:
- Track and store the parent blocks referenced in the window
- Verify all dependencies are available before processing
- Reconstruct the execution pool context needed for proper execution

## Impact Explanation

**Severity: High** (potentially Critical depending on network deployment)

This vulnerability causes **total loss of liveness** for all consensus observer nodes when execution pool is enabled network-wide, meeting the Critical severity criteria: "Total loss of liveness/network availability" [4](#0-3) 

While the default window size is `None` (disabled), there is also `DEFAULT_ENABLED_WINDOW_SIZE` of `Some(1)`, indicating execution pool can be enabled on-chain.

**Affected Components:**
- All consensus observer nodes become unable to process blocks
- Any services depending on observers for real-time consensus updates fail
- Reduced network redundancy and observability

**Invariant Violations:**
- Breaks **Consensus Liveness**: Observers cannot progress the chain
- Violates **Availability**: Observer nodes provide no value to the network

## Likelihood Explanation

**Likelihood: Medium-to-High**

The vulnerability triggers automatically when:
1. Execution pool is enabled via on-chain governance (no attacker needed)
2. Any consensus observer node is running

The incomplete implementation is documented in TODOs, suggesting developers are aware execution pool support is missing but may not realize it creates a complete DoS condition.

**Triggering Conditions:**
- No malicious actor required
- Happens during normal protocol upgrades
- Affects all observers simultaneously
- Cannot be mitigated without code changes

## Recommendation

Implement complete execution pool support for consensus observers or explicitly disable observers when execution pool is enabled:

**Option 1: Short-term mitigation**
```rust
// In consensus_observer.rs, add startup validation:
pub fn new(...) -> Result<Self, Error> {
    // Check if execution pool is enabled
    if observer_epoch_state.execution_pool_window_size().is_some() {
        return Err(Error::ConfigurationError(
            "Consensus observers are not compatible with execution pool. \
             Please disable execution pool or use a full validator node.".into()
        ));
    }
    // ... rest of initialization
}
```

**Option 2: Long-term fix**
Implement full execution pool support:

1. **Process OrderedBlockWithWindow messages:** [2](#0-1) 

Replace the TODO with logic to store blocks with their execution pool windows.

2. **Verify execution pool dependencies in remove_ready_block:** [5](#0-4) 

```rust
pub fn remove_ready_block(
    &mut self,
    received_payload_epoch: u64,
    received_payload_round: Round,
    block_payload_store: &mut BlockPayloadStore,
    execution_pool_window: Option<&ExecutionPoolWindow>,
) -> Option<Arc<PendingBlockWithMetadata>> {
    // ... existing split logic ...
    
    if let Some((epoch_and_round, pending_block)) = self.blocks_without_payloads.pop_last() {
        // Check payloads exist
        if block_payload_store.all_payloads_exist(pending_block.ordered_block().blocks()) {
            // NEW: If execution pool enabled, verify dependencies
            if let Some(window) = execution_pool_window {
                if !self.verify_execution_pool_dependencies(pending_block, window) {
                    // Dependencies not ready, keep waiting
                    blocks_at_higher_rounds.insert(epoch_and_round, pending_block);
                    ready_block = None;
                } else {
                    ready_block = Some(pending_block);
                }
            } else {
                ready_block = Some(pending_block);
            }
        }
        // ... rest of logic
    }
    // ...
}
```

## Proof of Concept

**Reproduction Steps:**

1. Enable execution pool in consensus configuration:
```rust
// In test or configuration
let consensus_config = ConsensusConfig {
    execution_pool_window_size: Some(1), // Enable execution pool
    ..Default::default()
};
```

2. Start a consensus observer node

3. Attempt to process blocks:
```rust
// Observer receives OrderedBlock when execution pool is enabled
let ordered_block = create_test_ordered_block();
observer.process_ordered_block_message(
    peer_id,
    Instant::now(),
    ordered_block
).await;

// Expected: Block is rejected with warning (line 648-655)
// Observer cannot make progress

// Observer receives OrderedBlockWithWindow
let ordered_block_with_window = create_test_ordered_block_with_window();
observer.process_ordered_block_with_window_message(
    peer_id,
    Instant::now(),
    ordered_block_with_window
).await;

// Expected: Block is dropped after validation (line 895)
// Observer still cannot make progress

// Result: Observer processes zero blocks when execution pool enabled
```

**Verification:**
Monitor observer metrics for block processing - it will remain at 0 when execution pool is enabled, while full validator nodes continue processing normally.

## Notes

The vulnerability stems from architectural assumptions in the consensus observer design. Observers were designed to passively receive and forward ordered blocks without maintaining the full consensus tree structure. The execution pool feature requires tracking parent block dependencies across a window, which the observer's simplified architecture cannot support without significant refactoring.

The presence of multiple TODOs indicates this is a known incomplete feature, but the severity of creating a complete DoS for observers when execution pool is enabled may not have been fully appreciated.

### Citations

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L645-656)
```rust
        // If execution pool is enabled, ignore the message
        if self.get_execution_pool_window_size().is_some() {
            // Log the failure and update the invalid message counter
            warn!(
                LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                    "Received ordered block message from peer: {:?}, but execution pool is enabled! Ignoring: {:?}",
                    peer_network_id, ordered_block.proof_block_info()
                ))
            );
            increment_invalid_message_counter(&peer_network_id, metrics::ORDERED_BLOCK_LABEL);
            return;
        }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L895-896)
```rust
        // TODO: process the ordered block with window message (instead of just dropping it!)
    }
```

**File:** consensus/src/consensus_observer/observer/pending_blocks.rs (L197-205)
```rust
    /// Removes and returns the block from the store that is now ready
    /// to be processed (after the new payload has been received).
    // TODO: identify how this will work with execution pool blocks!
    pub fn remove_ready_block(
        &mut self,
        received_payload_epoch: u64,
        received_payload_round: Round,
        block_payload_store: &mut BlockPayloadStore,
    ) -> Option<Arc<PendingBlockWithMetadata>> {
```

**File:** types/src/on_chain_config/consensus_config.rs (L10-13)
```rust
/// Default Window Size for Execution Pool.
/// This describes the number of blocks in the Execution Pool Window
pub const DEFAULT_WINDOW_SIZE: Option<u64> = None;
pub const DEFAULT_ENABLED_WINDOW_SIZE: Option<u64> = Some(1);
```
