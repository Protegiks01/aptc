# Audit Report

## Title
IPFS Authentication Token Leakage in NFT Metadata Crawler Logs

## Summary
The NFT metadata crawler logs IPFS URIs containing authentication tokens in plaintext through info-level logging statements, potentially exposing credentials to anyone with access to application logs, monitoring systems, or log aggregation tools.

## Finding Description

The NFT metadata crawler's `ParserConfig` supports optional IPFS gateway authentication via the `ipfs_auth_key` field [1](#0-0) . When configured, this authentication token is appended as a query parameter to IPFS URIs by the `URIParser::parse()` function [2](#0-1) .

The security issue occurs because the resulting URIs (containing the authentication token) are logged in plaintext at multiple points in the codebase:

1. **In JSONParser**: When fetching JSON metadata, the URI with embedded auth token is logged [3](#0-2) 

2. **In ImageOptimizer**: When fetching and optimizing images, the URI with embedded auth token is logged [4](#0-3) 

When `ipfs_prefix` is empty or invalid, the situation is exacerbated because:
- The resulting URI becomes malformed (e.g., "Qm.../path?pinataGatewayToken=secret_token")
- HTTP requests to this malformed URI will fail
- Error handling in the worker logs failures with error context [5](#0-4) , which may include the malformed URI with the authentication token in the error chain

**Attack Path:**
1. NFT metadata crawler is configured with `ipfs_auth_key` but `ipfs_prefix` is empty or invalid
2. System processes NFT metadata containing IPFS URIs
3. URIParser constructs URIs with authentication tokens appended
4. These URIs are logged via `info!()` macros in JSONParser and ImageOptimizer
5. Attacker with access to logs (through compromised monitoring systems, log aggregation tools, or misconfigured log exports) extracts the authentication tokens
6. Attacker uses stolen tokens to access the private IPFS gateway

## Impact Explanation

This issue qualifies as **Low Severity** per the Aptos bug bounty criteria: "Minor information leaks." The impact is limited to:

- **Credential Exposure**: IPFS gateway authentication tokens are exposed in application logs
- **Unauthorized Gateway Access**: Stolen tokens could allow unauthorized access to private IPFS gateway resources
- **Service-Level Issue**: This affects the NFT metadata crawler service, not the core Aptos blockchain consensus, execution, or state management

This does NOT affect blockchain consensus, validator operations, Move VM execution, or on-chain state. It is an infrastructure security issue in an auxiliary indexing service.

## Likelihood Explanation

**Likelihood: Medium to High** when authentication is configured.

The vulnerability triggers automatically whenever:
- The NFT metadata crawler is configured with `ipfs_auth_key`
- Any NFT with IPFS URIs is processed
- No additional attacker interaction is required for the leakage to occur

However, exploitation requires:
- Attacker access to application logs (monitoring dashboards, log aggregation systems, or log files)
- The service to be configured with IPFS authentication (which is optional)

## Recommendation

Implement credential sanitization in logging statements:

```rust
// In json_parser.rs and image_optimizer.rs, sanitize URIs before logging
fn sanitize_uri_for_logging(uri: &str) -> String {
    if let Ok(mut url) = Url::parse(uri) {
        // Remove sensitive query parameters
        let query_pairs: Vec<_> = url.query_pairs()
            .filter(|(key, _)| key != "pinataGatewayToken" && key != IPFS_AUTH_KEY)
            .map(|(k, v)| (k.to_string(), v.to_string()))
            .collect();
        
        if !query_pairs.is_empty() {
            url.set_query(Some(&query_pairs.iter()
                .map(|(k, v)| format!("{}={}", k, v))
                .collect::<Vec<_>>()
                .join("&")));
        } else {
            url.set_query(None);
        }
        url.to_string()
    } else {
        uri.to_string()
    }
}

// Then in logging:
info!(asset_uri = sanitize_uri_for_logging(&uri), "Sending request for asset_uri");
```

Additionally, add configuration validation to warn when `ipfs_auth_key` is provided but `ipfs_prefix` is empty or invalid.

## Proof of Concept

```rust
#[cfg(test)]
mod credential_leak_test {
    use super::*;
    
    #[tokio::test]
    async fn test_ipfs_auth_token_in_logs() {
        // Configure with auth key and empty prefix
        let config = ParserConfig {
            ipfs_prefix: "".to_string(), // Empty prefix
            ipfs_auth_key: Some("secret_token_12345".to_string()),
            // ... other fields
        };
        
        // Parse an IPFS URI
        let test_uri = "ipfs://QmTestCID/image.png";
        let parsed = URIParser::parse(
            &config.ipfs_prefix,
            test_uri,
            config.ipfs_auth_key.as_deref()
        );
        
        // The resulting URI contains the secret token
        match parsed {
            Ok(uri) => {
                assert!(uri.contains("secret_token_12345"));
                // This URI would be logged in plaintext
                println!("Parsed URI (would be logged): {}", uri);
            },
            Err(_) => {
                // Even on error, the malformed URI with token may appear in logs
            }
        }
    }
}
```

## Notes

**Important Context:**
- This vulnerability is in the NFT metadata crawler (`ecosystem/nft-metadata-crawler`), which is an off-chain indexing service, not part of the core Aptos blockchain consensus layer
- It does not affect validator operations, consensus safety, Move VM execution, or on-chain state
- The issue is specific to infrastructure/operational security for the metadata crawler service
- While marked as Low severity, proper credential management is still important for preventing unauthorized gateway access and potential service abuse

### Citations

**File:** ecosystem/nft-metadata-crawler/src/parser/config.rs (L17-17)
```rust
    pub ipfs_auth_key: Option<String>,
```

**File:** ecosystem/nft-metadata-crawler/src/utils/uri_parser.rs (L33-37)
```rust
        let ipfs_auth_param = if ipfs_auth_key.is_some() {
            Some(format!("?{}={}", IPFS_AUTH_KEY, ipfs_auth_key.unwrap()))
        } else {
            None
        };
```

**File:** ecosystem/nft-metadata-crawler/src/utils/json_parser.rs (L53-53)
```rust
                info!(asset_uri = uri, "Sending request for asset_uri");
```

**File:** ecosystem/nft-metadata-crawler/src/utils/image_optimizer.rs (L54-54)
```rust
                info!(image_uri = uri, "Sending request for image");
```

**File:** ecosystem/nft-metadata-crawler/src/parser/worker.rs (L129-134)
```rust
                    .unwrap_or_else(|e| {
                        // Increment retry count if JSON parsing fails
                        self.log_warn("JSON parsing failed", Some(&e));
                        self.model.increment_json_parser_retry_count();
                        (None, None, Value::Null)
                    });
```
