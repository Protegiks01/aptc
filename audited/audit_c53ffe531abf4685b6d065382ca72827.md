# Audit Report

## Title
Missing Validation Allows Deployment of Test Verification Key Enabling Keyless Account Compromise

## Summary
The `set_groth16_verification_key_for_next_epoch()` function lacks validation to prevent deployment of known test verification keys to production. If the hardcoded test VK from `prepared_vk_for_testing()` is deployed to mainnet via governance, and its trapdoor is accessible, attackers can forge arbitrary Groth16 proofs to compromise all keyless accounts.

## Finding Description

The keyless account system relies on a Groth16 verification key (VK) to verify zero-knowledge proofs. The production VK should come from a secure trusted setup ceremony where the trapdoor (secret parameters alpha, beta, gamma, delta) is destroyed. However, the codebase contains a hardcoded test VK from the public `devnet-groth16-keys` repository. [1](#0-0) [2](#0-1) 

This test VK can be deployed to mainnet through the governance function: [3](#0-2) 

**Critical Security Gap**: The function performs NO validation to prevent deploying known test VKs. While a `validate_groth16_vk()` function exists, it only checks point validity, not identity: [4](#0-3) 

More importantly, `set_groth16_verification_key_for_next_epoch()` never calls this validation function at all.

**Exploitation Path**:

1. **Governance Mistake**: Through governance error, social engineering, or compromised governance process, the test VK is proposed and accepted for deployment to mainnet
2. **VK Deployment**: The test VK becomes the active on-chain verification key
3. **Trapdoor Access**: Attackers access the trapdoor for the devnet VK (likely stored in the devnet-groth16-keys repository or known to circuit developers)
4. **Proof Forgery**: With the trapdoor, attackers can forge valid Groth16 proofs for arbitrary public inputs
5. **Account Compromise**: Attackers create fake keyless signatures for any user, bypassing all JWT validation
6. **Fund Theft**: All keyless accounts on the network can be drained

The production code fetches the VK from on-chain state without any runtime checks: [5](#0-4) [6](#0-5) 

## Impact Explanation

**Severity: CRITICAL** (up to $1,000,000 per Aptos Bug Bounty)

This vulnerability enables:
- **Complete Loss of Funds**: All keyless account balances can be stolen
- **Cryptographic Correctness Violation**: The zero-knowledge proof system becomes completely compromised
- **Transaction Validation Bypass**: Attackers can forge signatures for any keyless account
- **No Recovery Path**: Once funds are stolen, they cannot be recovered without hard fork

The impact affects ALL keyless account users on the network. Given that keyless accounts are designed for mainstream adoption, this could affect millions of users and billions of dollars in assets.

## Likelihood Explanation

**Likelihood: Low to Medium**

The vulnerability requires:
1. A governance proposal deploying the test VK (requires governance majority vote)
2. Access to the trapdoor for the devnet VK

While governance mistakes are rare, they are not impossible:
- Complex governance processes can have errors
- Social engineering could target governance participants  
- Emergency situations might lead to rushed decisions
- The warning comment exists but may be overlooked

The devnet VK's trapdoor is likely accessible because:
- It's from a public "devnet-groth16-keys" repository
- Sample proofs exist in the codebase, suggesting proof generation capability
- Devnet keys are typically generated with less rigorous security than production keys
- The trapdoor may be stored for testing purposes

## Recommendation

Add validation to prevent deploying known test VKs:

**In Move (keyless_account.move)**:
```move
// Add a constant with hash of known test VKs
const TEST_VK_HASH_1: vector<u8> = x"<hash_of_prepared_vk_for_testing>";
const E_TEST_VK_DEPLOYED: u64 = 4;

fun validate_not_test_vk(vk: &Groth16VerificationKey) {
    use std::hash;
    let vk_bytes = bcs::to_bytes(vk);
    let vk_hash = hash::sha3_256(vk_bytes);
    assert!(vk_hash != TEST_VK_HASH_1, E_TEST_VK_DEPLOYED);
}

public fun set_groth16_verification_key_for_next_epoch(fx: &signer, vk: Groth16VerificationKey) {
    system_addresses::assert_aptos_framework(fx);
    validate_groth16_vk(&vk);  // Add this call
    validate_not_test_vk(&vk);  // Add this call
    config_buffer::upsert<Groth16VerificationKey>(vk);
}
```

**Additional Safeguards**:
1. Implement multi-signature approval for VK changes
2. Add time delays before VK changes take effect
3. Document known test VK hashes in governance materials
4. Implement VK rotation attestation from multiple independent parties

## Proof of Concept

```move
#[test_only]
module aptos_framework::test_vk_deployment {
    use aptos_framework::keyless_account;
    use std::signer;
    
    #[test(framework = @aptos_framework)]
    #[expected_failure(abort_code = 0x10004)] // Should fail with E_TEST_VK_DEPLOYED
    fun test_prevents_test_vk_deployment(framework: &signer) {
        // Get the test VK (in reality, attacker would reconstruct this)
        let test_vk = get_test_vk_from_circuit_constants();
        
        // Attempt to deploy via governance
        // This should FAIL with proper validation
        keyless_account::set_groth16_verification_key_for_next_epoch(
            framework,
            test_vk
        );
    }
    
    #[test(framework = @aptos_framework)]
    fun test_allows_production_vk_deployment(framework: &signer) {
        // Get a different VK (not the test one)
        let production_vk = get_different_vk();
        
        // This should succeed
        keyless_account::set_groth16_verification_key_for_next_epoch(
            framework,
            production_vk
        );
    }
}
```

**Rust Test to Demonstrate Vulnerability**:
```rust
#[test]
fn test_no_validation_on_vk_update() {
    // Show that the test VK can be deployed without any checks
    let test_vk = prepared_vk_for_testing();
    let move_vk = Groth16VerificationKey::from(&test_vk);
    
    // In a real scenario, this would go through governance
    // But there's NO code preventing the test VK from being used
    assert!(is_valid_elliptic_curve_points(&move_vk)); // Only checks this
    // Missing: assert!(!is_known_test_vk(&move_vk));
}
```

## Notes

The vulnerability exists at the governance/operational level rather than in the runtime verification logic itself. The production code correctly fetches and uses the on-chain VK, but there's no protection against deploying an insecure VK to that on-chain location.

The warning comment acknowledges the risk but provides no technical enforcement. This is a classic example of security-critical validation being documented but not implemented.

### Citations

**File:** types/src/keyless/circuit_constants.rs (L4-4)
```rust
//! These constants are from commit 125522b4b226f8ece3e3162cecfefe915d13bc30 of keyless-circuit.
```

**File:** types/src/keyless/circuit_constants.rs (L30-99)
```rust
pub fn prepared_vk_for_testing() -> PreparedVerifyingKey<Bn254> {
    // Convert the projective points to affine.
    let alpha_g1 = g1_projective_str_to_affine(
        "20491192805390485299153009773594534940189261866228447918068658471970481763042",
        "9383485363053290200918347156157836566562967994039712273449902621266178545958",
    )
    .unwrap();

    let beta_g2 = g2_projective_str_to_affine(
        [
            "6375614351688725206403948262868962793625744043794305715222011528459656738731",
            "4252822878758300859123897981450591353533073413197771768651442665752259397132",
        ],
        [
            "10505242626370262277552901082094356697409835680220590971873171140371331206856",
            "21847035105528745403288232691147584728191162732299865338377159692350059136679",
        ],
    )
    .unwrap();

    let gamma_g2 = g2_projective_str_to_affine(
        [
            "10857046999023057135944570762232829481370756359578518086990519993285655852781",
            "11559732032986387107991004021392285783925812861821192530917403151452391805634",
        ],
        [
            "8495653923123431417604973247489272438418190587263600148770280649306958101930",
            "4082367875863433681332203403145435568316851327593401208105741076214120093531",
        ],
    )
    .unwrap();

    let delta_g2 = g2_projective_str_to_affine(
        [
            "6309950375468367434079888575625734658722834850554198467265341412057133512289",
            "290788916745604303732014379515714703987358626088033030814233237684691015915",
        ],
        [
            "18062633083579661887564610476476551517623934510295133920710347041696656037149",
            "18531177357310703535722548657431805690263733685063962985389260695754645724386",
        ],
    )
    .unwrap();

    let mut gamma_abc_g1 = Vec::new();
    for points in [
        g1_projective_str_to_affine(
            "3314139460766150258181182511839382093976747705712051605578952681462625768062",
            "15177929890957116336235565528373348502554233971408496072173139426537995658198",
        )
        .unwrap(),
        g1_projective_str_to_affine(
            "11040819149070528816396253292991080175919431363817777522273571096667537087166",
            "13976660124609527451731647657081915019685631850685519260597009755390746148997",
        )
        .unwrap(),
    ] {
        gamma_abc_g1.push(points);
    }

    let vk = VerifyingKey {
        alpha_g1,
        beta_g2,
        gamma_g2,
        delta_g2,
        gamma_abc_g1,
    };

    PreparedVerifyingKey::from(vk)
}
```

**File:** aptos-move/framework/aptos-framework/sources/keyless_account.move (L183-192)
```text
    fun validate_groth16_vk(vk: &Groth16VerificationKey) {
        // Could be leveraged to speed up the VM deserialization of the VK by 2x, since it can assume the points are valid.
        assert!(option::is_some(&crypto_algebra::deserialize<bn254_algebra::G1, bn254_algebra::FormatG1Compr>(&vk.alpha_g1)), E_INVALID_BN254_G1_SERIALIZATION);
        assert!(option::is_some(&crypto_algebra::deserialize<bn254_algebra::G2, bn254_algebra::FormatG2Compr>(&vk.beta_g2)), E_INVALID_BN254_G2_SERIALIZATION);
        assert!(option::is_some(&crypto_algebra::deserialize<bn254_algebra::G2, bn254_algebra::FormatG2Compr>(&vk.gamma_g2)), E_INVALID_BN254_G2_SERIALIZATION);
        assert!(option::is_some(&crypto_algebra::deserialize<bn254_algebra::G2, bn254_algebra::FormatG2Compr>(&vk.delta_g2)), E_INVALID_BN254_G2_SERIALIZATION);
        for (i in 0..vector::length(&vk.gamma_abc_g1)) {
            assert!(option::is_some(&crypto_algebra::deserialize<bn254_algebra::G1, bn254_algebra::FormatG1Compr>(vector::borrow(&vk.gamma_abc_g1, i))), E_INVALID_BN254_G1_SERIALIZATION);
        };
    }
```

**File:** aptos-move/framework/aptos-framework/sources/keyless_account.move (L263-266)
```text
    public fun set_groth16_verification_key_for_next_epoch(fx: &signer, vk: Groth16VerificationKey) {
        system_addresses::assert_aptos_framework(fx);
        config_buffer::upsert<Groth16VerificationKey>(vk);
    }
```

**File:** aptos-move/aptos-vm-environment/src/environment.rs (L289-293)
```rust
        let keyless_pvk =
            Groth16VerificationKey::fetch_keyless_config(state_view).and_then(|(vk, vk_bytes)| {
                sha3_256.update(&vk_bytes);
                vk.try_into().ok()
            });
```

**File:** aptos-move/aptos-vm/src/keyless_validation.rs (L347-347)
```rust
                        let result = zksig.verify_groth16_proof(public_inputs_hash, pvk.unwrap());
```
