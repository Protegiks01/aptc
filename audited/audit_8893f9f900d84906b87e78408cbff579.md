# Audit Report

## Title
Multisig Transaction Module Upgrade TOCTOU Vulnerability Enables Bait-and-Switch Attacks

## Summary
Multisig transactions in Aptos do not bind to specific module versions when referencing external entry functions. An attacker can deploy a benign module, create a multisig transaction calling it, obtain owner approvals, upgrade the module to malicious code with compatible signatures, and execute the transaction with the malicious versionâ€”stealing funds or manipulating state without re-approval.

## Finding Description

The Aptos multisig account system allows owners to create, approve, and execute transactions collectively. When creating a multisig transaction with an `EntryFunction` payload, the system stores the serialized payload containing a `ModuleId` (address + module name) but **no module version or code hash**. [1](#0-0) [2](#0-1) 

The `EntryFunction` struct only contains the module identifier, not any version information: [3](#0-2) 

During transaction execution, the VM loads the **current on-chain version** of the module from storage at execution time, not the version that existed when owners approved the transaction: [4](#0-3) [5](#0-4) 

The module loading process uses `get_module_or_build_with` which fetches from current storage state without version validation: [6](#0-5) 

**Attack Vector:**

1. **Attacker deploys benign module** at address `0xATTACKER::vault_manager` with entry function `withdraw_to(recipient: address, amount: u64)` that appears to implement proper access control
2. **Attacker creates multisig transaction** with payload referencing `0xATTACKER::vault_manager::withdraw_to` 
3. **Multisig owners review the module code** on-chain, verify it's safe, and approve the transaction
4. **Attacker upgrades the module** with malicious implementation that ignores access control and sends funds to attacker (maintaining same function signature for compatibility)
5. **Transaction executes** - the VM loads the NEW malicious module version and executes it, draining multisig funds

The module compatibility system allows this because it only checks signatures and layouts, not internal logic: [7](#0-6) 

The upgrade compatibility checks permit changing function implementations as long as public signatures remain compatible. An attacker can completely change the internal logic while maintaining the function signature.

## Impact Explanation

**Severity: Critical (Loss of Funds)**

This vulnerability enables direct theft of funds from multisig accounts, which are commonly used for:
- Protocol treasuries holding millions of dollars
- Governance-controlled fund pools
- Multi-signature custody solutions
- DAO asset management

**Impact Categories:**
- **Loss of Funds**: Attacker can steal all assets from multisig accounts by executing pre-approved transactions with swapped malicious code
- **Governance Integrity Violation**: Breaks the fundamental assumption that "what owners approve is what executes"
- **Transaction Validation Bypass**: Circumvents the multi-signature approval process by changing code after approval

The attack does NOT affect consensus (validators still agree on execution) but violates the application-layer security guarantee that multisig approvals are binding to specific code behavior.

Per Aptos Bug Bounty criteria, this qualifies as **Critical Severity** due to enabling theft/loss of funds without requiring privileged access.

## Likelihood Explanation

**Likelihood: Medium to High**

**Attacker Requirements:**
- Deploy a module to any address they control (no special permissions needed)
- Social engineer or legitimately create a multisig transaction proposal
- Wait for owner approvals (multisig transactions often take days/weeks)
- Upgrade the module (allowed for non-immutable upgrade policies)

**Feasibility:**
- **High**: Module deployment is permissionless on Aptos
- **High**: Most modules use `upgrade_policy_compat()` not `upgrade_policy_immutable()` for flexibility
- **Medium**: Requires patience to wait between approval and execution
- **Medium**: Requires crafting compatible but malicious upgrade

**Real-World Scenarios:**
1. **Malicious DeFi Protocol**: A protocol creates a multisig proposal to integrate with a "trusted" external vault, gets approval, then upgrades vault to be malicious
2. **Compromised Dependency**: A legitimate module used by multisig gets compromised and upgraded before transaction executes
3. **Long-Pending Transactions**: In governance with slow approval processes, months may pass between creation and execution

## Recommendation

**Immediate Fix: Bind transactions to module code hash**

Modify `MultisigTransaction` to store the code hash of referenced modules:

```move
struct MultisigTransaction has copy, drop, store {
    payload: Option<vector<u8>>,
    payload_hash: Option<vector<u8>>,
    // ADD: Hash of all referenced module bytecode at creation time
    module_code_hashes: vector<vector<u8>>,
    votes: SimpleMap<address, bool>,
    creator: address,
    creation_time_secs: u64,
}
```

During transaction creation, extract all `ModuleId`s from the `EntryFunction` payload, fetch their current code hashes, and store them. During execution, validate that current on-chain module hashes match the stored hashes before executing.

**Alternative: Add module version numbers to EntryFunction**

Extend `EntryFunction` to include module upgrade numbers:

```rust
pub struct EntryFunction {
    module: ModuleId,
    module_version: Option<u64>, // NEW: upgrade_number from PackageMetadata
    function: Identifier,
    ty_args: Vec<TypeTag>,
    args: Vec<Vec<u8>>,
}
```

During execution, verify the current `upgrade_number` matches the stored version.

**Long-term: Module Immutability Requirements**

Consider requiring that multisig transactions can only reference modules with `upgrade_policy_immutable()` or implement a "module pinning" mechanism where specific versions can be referenced by hash.

## Proof of Concept

```move
// File: sources/exploit_module.move
module attacker::vault_manager {
    use std::signer;
    use aptos_framework::coin;
    use aptos_framework::aptos_coin::AptosCoin;

    // VERSION 1 (Benign - shown to multisig owners)
    public entry fun withdraw_to(multisig_account: &signer, recipient: address, amount: u64) {
        // Proper access control - only allows withdrawals to approved recipients
        assert!(is_approved_recipient(recipient), 1);
        coin::transfer<AptosCoin>(multisig_account, recipient, amount);
    }
    
    fun is_approved_recipient(addr: address): bool {
        // Some legitimate check
        true
    }
}

// VERSION 2 (Malicious - deployed after approval)
module attacker::vault_manager {
    use std::signer;
    use aptos_framework::coin;
    use aptos_framework::aptos_coin::AptosCoin;

    // Same signature - passes compatibility check!
    public entry fun withdraw_to(multisig_account: &signer, recipient: address, amount: u64) {
        // MALICIOUS: Ignores recipient parameter, sends to attacker
        let attacker = @0xATTACKER_ADDRESS;
        coin::transfer<AptosCoin>(multisig_account, attacker, amount);
    }
    
    fun is_approved_recipient(addr: address): bool {
        true  // Function kept for compatibility but unused
    }
}
```

**Exploitation Steps:**

1. Deploy VERSION 1 of `vault_manager` module
2. Create multisig transaction: `create_transaction(owner, multisig_addr, bcs::to_bytes(EntryFunction::new(module_id("attacker", "vault_manager"), ident_str("withdraw_to"), vec![], serialize_args(&[legitimate_recipient, 1000000]))))`
3. Multisig owners inspect module at `attacker::vault_manager`, see proper access control
4. Owners approve transaction via `approve_transaction()`
5. Attacker upgrades module to VERSION 2 via `code::publish_package()`
6. Execute multisig transaction - funds go to attacker instead of legitimate recipient

## Notes

**Key Evidence Files:**
- Multisig transaction storage: `aptos-move/framework/aptos-framework/sources/multisig_account.move`
- Module loading: `third_party/move/move-vm/runtime/src/storage/module_storage.rs`
- Entry function structure: `types/src/transaction/script.rs`
- Module upgrade system: `aptos-move/framework/aptos-framework/sources/code.move`

**Why This Wasn't Caught:**
- No existing tests cover module upgrades during pending multisig transactions
- The feature flag `ABORT_IF_MULTISIG_PAYLOAD_MISMATCH` only validates payload bytes, not referenced module versions
- Module versioning exists (`upgrade_number` in `PackageMetadata`) but is never checked during transaction execution

This vulnerability affects all multisig accounts that reference external modules with non-immutable upgrade policies, which represents the majority of real-world usage.

### Citations

**File:** types/src/transaction/multisig.rs (L11-24)
```rust
#[derive(Clone, Debug, Hash, Eq, PartialEq, Serialize, Deserialize)]
pub struct Multisig {
    pub multisig_address: AccountAddress,

    // Transaction payload is optional if already stored on chain.
    pub transaction_payload: Option<MultisigTransactionPayload>,
}

// We use an enum here for extensibility so we can add Script payload support
// in the future for example.
#[derive(Clone, Debug, Hash, Eq, PartialEq, Serialize, Deserialize)]
pub enum MultisigTransactionPayload {
    EntryFunction(EntryFunction),
}
```

**File:** aptos-move/framework/aptos-framework/sources/multisig_account.move (L147-158)
```text
    /// A transaction to be executed in a multisig account.
    /// This must contain either the full transaction payload or its hash (stored as bytes).
    struct MultisigTransaction has copy, drop, store {
        payload: Option<vector<u8>>,
        payload_hash: Option<vector<u8>>,
        // Mapping from owner adress to vote (yes for approve, no for reject). Uses a simple map to deduplicate.
        votes: SimpleMap<address, bool>,
        // The owner who created this transaction.
        creator: address,
        // The timestamp in seconds when the transaction was created.
        creation_time_secs: u64,
    }
```

**File:** types/src/transaction/script.rs (L107-130)
```rust
/// Call a Move entry function.
#[derive(Clone, Debug, Hash, Eq, PartialEq, Serialize, Deserialize)]
pub struct EntryFunction {
    module: ModuleId,
    function: Identifier,
    ty_args: Vec<TypeTag>,
    #[serde(with = "vec_bytes")]
    args: Vec<Vec<u8>>,
}

impl EntryFunction {
    pub fn new(
        module: ModuleId,
        function: Identifier,
        ty_args: Vec<TypeTag>,
        args: Vec<Vec<u8>>,
    ) -> Self {
        EntryFunction {
            module,
            function,
            ty_args,
            args,
        }
    }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1363-1399)
```rust
    fn execute_multisig_entry_function(
        &self,
        resolver: &impl AptosMoveResolver,
        module_storage: &impl AptosModuleStorage,
        mut session: UserSession,
        gas_meter: &mut impl AptosGasMeter,
        traversal_context: &mut TraversalContext,
        multisig_address: AccountAddress,
        payload: &EntryFunction,
        change_set_configs: &ChangeSetConfigs,
        trace_recorder: &mut impl TraceRecorder,
    ) -> Result<UserSessionChangeSet, VMStatus> {
        // If txn args are not valid, we'd still consider the transaction as executed but
        // failed. This is primarily because it's unrecoverable at this point.
        session.execute(|session| {
            self.validate_and_execute_entry_function(
                module_storage,
                session,
                &SerializedSigners::new(vec![serialized_signer(&multisig_address)], None),
                gas_meter,
                traversal_context,
                payload,
                trace_recorder,
            )
        })?;

        // Resolve any pending module publishes in case the multisig transaction is deploying
        // modules.
        self.resolve_pending_code_publish_and_finish_user_session(
            session,
            resolver,
            module_storage,
            gas_meter,
            traversal_context,
            change_set_configs,
        )
    }
```

**File:** third_party/move/move-vm/runtime/src/storage/module_storage.rs (L295-329)
```rust
    fn unmetered_get_lazily_verified_module(
        &self,
        module_id: &ModuleId,
    ) -> VMResult<Option<Arc<Module>>> {
        let (module, version) = match self.get_module_or_build_with(module_id, self)? {
            Some(module_and_version) => module_and_version,
            None => return Ok(None),
        };

        if module.code().is_verified() {
            return Ok(Some(module.code().verified().clone()));
        }

        let _timer = VM_TIMER.timer_with_label("unmetered_get_lazily_verified_module [cache miss]");
        let runtime_environment = self.runtime_environment();
        runtime_environment.paranoid_check_module_address_and_name(
            module.code().deserialized(),
            module_id.address(),
            module_id.name(),
        )?;
        let locally_verified_code = runtime_environment.build_locally_verified_module(
            module.code().deserialized().clone(),
            module.extension().size_in_bytes(),
            module.extension().hash(),
        )?;
        let verified_code =
            runtime_environment.build_verified_module_skip_linking_checks(locally_verified_code)?;
        let verified_module = self.insert_verified_module(
            module_id.clone(),
            verified_code,
            module.extension().clone(),
            version,
        )?;
        Ok(Some(verified_module.code().verified().clone()))
    }
```

**File:** third_party/move/move-vm/runtime/src/storage/implementations/unsync_module_storage.rs (L136-160)
```rust
    fn build(
        &self,
        key: &Self::Key,
    ) -> VMResult<Option<ModuleCode<Self::Deserialized, Self::Verified, Self::Extension>>> {
        let mut bytes = match self.ctx.fetch_module_bytes(key.address(), key.name())? {
            Some(bytes) => bytes,
            None => return Ok(None),
        };
        // TODO: remove this once framework on mainnet is using the new option module
        if let Some(replaced_bytes) = self
            .ctx
            .runtime_environment()
            .get_module_bytes_override(key.address(), key.name())
        {
            bytes = replaced_bytes;
        }
        let compiled_module = self
            .ctx
            .runtime_environment()
            .deserialize_into_compiled_module(&bytes)?;
        let hash = sha3_256(&bytes);
        let extension = Arc::new(BytesWithHash::new(bytes, hash));
        let module = ModuleCode::from_deserialized(compiled_module, extension);
        Ok(Some(module))
    }
```

**File:** aptos-move/framework/aptos-framework/sources/code.move (L129-146)
```text
    /// Whether unconditional code upgrade with no compatibility check is allowed. This
    /// publication mode should only be used for modules which aren't shared with user others.
    /// The developer is responsible for not breaking memory layout of any resources he already
    /// stored on chain.
    public fun upgrade_policy_arbitrary(): UpgradePolicy {
        UpgradePolicy { policy: 0 }
    }

    /// Whether a compatibility check should be performed for upgrades. The check only passes if
    /// a new module has (a) the same public functions (b) for existing resources, no layout change.
    public fun upgrade_policy_compat(): UpgradePolicy {
        UpgradePolicy { policy: 1 }
    }

    /// Whether the modules in the package are immutable and cannot be upgraded.
    public fun upgrade_policy_immutable(): UpgradePolicy {
        UpgradePolicy { policy: 2 }
    }
```
