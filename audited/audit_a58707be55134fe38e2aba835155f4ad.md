# Audit Report

## Title
Insufficient Constant-Time Testing Coverage for DKG Batch Multi-Scalar Multiplication Operations

## Summary
The constant-time verification in `is_blstrs_constant_time.rs` only tests single scalar multiplication (`base.mul(scalar)`), but Aptos DKG production code uses batch multi-scalar multiplication (`G1Projective::multi_exp(bases, scalars)`) with secret data. These operations use fundamentally different code paths and algorithms, so testing one provides no guarantee about the other's constant-time properties.

## Finding Description

The Aptos codebase implements constant-time verification for BLS12-381 scalar multiplication operations to protect against timing side-channel attacks. However, there is a critical testing coverage gap:

**What is tested:** [1](#0-0) 

This tests single scalar multiplication using the `mul` operator on a single base-scalar pair.

**What is used in production:** [2](#0-1) 

The `g1_multi_exp` function uses `G1Projective::multi_exp(bases, scalars)` for batch operations with 2+ scalars, which is a completely different code path using multi-scalar multiplication (MSM) algorithms like Pippenger's algorithm.

**Critical DKG usage with secret data:** [3](#0-2) 

This reconstructs the dealt secret key using `g1_multi_exp` with Lagrange coefficients and secret shares. [4](#0-3) 

This aggregates signature shares using `g1_multi_exp` with secret Lagrange coefficients and share data.

**Evidence of awareness:** [5](#0-4) 

The codebase explicitly documents that scalar multiplication operations involving secret keys must be constant-time.

**Comparison with known variable-time implementations:** [6](#0-5) [7](#0-6) 

The Ristretto255 implementation explicitly uses variable-time multi-scalar multiplication algorithms (Strauss/Pippenger), demonstrating that batch MSM operations can use different algorithms than single scalar multiplication.

## Impact Explanation

While this represents a significant testing coverage gap, under the stated trust model that "Cryptographic primitives (Rust crypto crates, BLS implementations) are assumed secure," this issue does not meet the threshold for a reportable vulnerability. 

**Why this would be High Severity IF exploitable:**
- Secret shares and Lagrange coefficients used in DKG could leak via timing side-channels
- Could compromise the security of the distributed key generation protocol
- Could allow identification of which validators are participating in key reconstruction
- Violates the cryptographic correctness invariant

**However:**
- No concrete evidence that blstrs's `multi_exp` is non-constant-time (only that it's untested)
- Practical timing attacks require precise remote measurements, many samples, and favorable network conditions
- The trust model explicitly assumes cryptographic primitives are secure

## Likelihood Explanation

**Testing Gap Likelihood:** CERTAIN - The gap exists definitively.

**Exploitation Likelihood:** Cannot be assessed without violating the trust model assumptions about cryptographic primitive security.

## Recommendation

Extend the constant-time testing framework to include batch multi-scalar multiplication:

1. Add a new test file `is_blstrs_multi_exp_constant_time.rs` that tests `G1Projective::multi_exp` with varying numbers of scalars
2. Test batch operations with 2, 4, 8, 16, 32+ scalar-base pairs
3. Use the same dudect statistical framework with different scalar bit patterns
4. Include this in production startup verification alongside existing tests [8](#0-7) 

## Proof of Concept

This is a testing coverage issue rather than a directly exploitable vulnerability under the stated trust model. A proper PoC would require:

1. Demonstrating that blstrs's `multi_exp` implementation is NOT constant-time (contradicts trust model)
2. Showing measurable timing differences in DKG operations (requires infrastructure access)
3. Extracting secret information from timing measurements (requires cryptanalysis)

Without concrete evidence that the underlying blstrs library's `multi_exp` is non-constant-time, and given the trust model assumption that cryptographic primitives are secure, I cannot provide a working exploit.

---

## Notes

This finding highlights a critical **testing methodology gap** rather than a proven vulnerability. The constant-time testing verifies only single scalar multiplication while production DKG code uses batch multi-scalar multiplication via different code paths. Best practice would dictate testing the actual code paths used in production with secret data. However, under the stated security review constraints that assume cryptographic primitives are secure, this does not constitute a reportable vulnerability without additional evidence of actual non-constant-time behavior in blstrs's `multi_exp` implementation.

### Citations

**File:** crates/aptos-crypto/src/constant_time/blstrs_scalar_mul.rs (L119-123)
```rust
    for (class, _k, sk, base) in inputs {
        runner.run_one(class, || {
            let _ = black_box(base.mul(&sk));
        })
    }
```

**File:** crates/aptos-dkg/src/utils/mod.rs (L58-72)
```rust
pub fn g1_multi_exp(bases: &[G1Projective], scalars: &[blstrs::Scalar]) -> G1Projective {
    if bases.len() != scalars.len() {
        panic!(
            "blstrs's multiexp has heisenbugs when the # of bases != # of scalars ({} != {})",
            bases.len(),
            scalars.len()
        );
    }

    match bases.len() {
        0 => G1Projective::identity(),
        1 => bases[0].mul(scalars[0]),
        _ => G1Projective::multi_exp(bases, scalars),
    }
}
```

**File:** crates/aptos-dkg/src/pvss/dealt_secret_key.rs (L89-122)
```rust
            /// Reconstructs the `DealtSecretKey` given a sufficiently-large subset of shares from players.
            /// Mainly used for testing the PVSS transcript dealing and decryption.
            fn reconstruct(sc: &ThresholdConfigBlstrs, shares: &[ShamirShare<Self::ShareValue>]) -> anyhow::Result<Self> {
                assert_ge!(shares.len(), sc.get_threshold());
                assert_le!(shares.len(), sc.get_total_num_players());

                let ids = shares.iter().map(|(p, _)| p.id).collect::<Vec<usize>>();
                let lagr = lagrange_coefficients(
                    sc.get_batch_evaluation_domain(),
                    ids.as_slice(),
                    &Scalar::ZERO,
                );
                let bases = shares
                    .iter()
                    .map(|(_, share)| *share.as_group_element())
                    .collect::<Vec<$GTProjective>>();

                // println!();
                // println!("Lagrange IDs: {:?}", ids);
                // println!("Lagrange coeffs");
                // for l in lagr.iter() {
                // println!(" + {}", hex::encode(l.to_bytes_le()));
                // }
                // println!("Bases: ");
                // for b in bases.iter() {
                // println!(" + {}", hex::encode(b.to_bytes()));
                // }

                assert_eq!(lagr.len(), bases.len());

                Ok(DealtSecretKey {
                    h_hat: $gt_multi_exp(bases.as_slice(), lagr.as_slice()),
                })
            }
```

**File:** crates/aptos-dkg/src/weighted_vuf/bls/mod.rs (L108-136)
```rust
    fn aggregate_shares(
        wc: &WeightedConfigBlstrs,
        apks_and_proofs: &[(Player, Self::AugmentedPubKeyShare, Self::ProofShare)],
    ) -> Self::Proof {
        // Collect all the evaluation points associated with each player
        let mut sub_player_ids = Vec::with_capacity(wc.get_total_weight());

        for (player, _, _) in apks_and_proofs {
            for j in 0..wc.get_player_weight(player) {
                sub_player_ids.push(wc.get_virtual_player(player, j).id);
            }
        }

        // Compute the Lagrange coefficients associated with those evaluation points
        let batch_dom = wc.get_batch_evaluation_domain();
        let lagr = lagrange_coefficients(batch_dom, &sub_player_ids[..], &Scalar::ZERO);

        // Interpolate the signature
        let mut bases = Vec::with_capacity(apks_and_proofs.len());
        for (_, _, share) in apks_and_proofs {
            // println!(
            //     "Flattening {} share(s) for player {player}",
            //     sub_shares.len()
            // );
            bases.extend_from_slice(share.as_slice())
        }

        g1_multi_exp(bases.as_slice(), lagr.as_slice())
    }
```

**File:** keyless/pepper/common/src/vuf/bls12381_g1_bls.rs (L81-87)
```rust
    /// WARNING: This function must remain constant-time w.r.t. to `sk` and `input`.
    fn eval(sk: &Scalar, input: &[u8]) -> anyhow::Result<(Vec<u8>, Vec<u8>)> {
        let input_g1 = Self::hash_to_g1(input);
        let output_g1 = input_g1.mul(sk);
        let output_bytes = output_g1.to_compressed().to_vec();
        Ok((output_bytes, vec![]))
    }
```

**File:** aptos-move/framework/src/natives/cryptography/ristretto255_point.rs (L18-22)
```rust
use curve25519_dalek::{
    constants::RISTRETTO_BASEPOINT_TABLE,
    ristretto::{CompressedRistretto, RistrettoPoint},
    traits::{Identity, VartimeMultiscalarMul},
};
```

**File:** aptos-move/framework/src/natives/cryptography/ristretto255_point.rs (L641-646)
```rust
        // NOTE: The variable-time multiscalar multiplication (MSM) algorithm for a size-n MSM employed in curve25519 is:
        //  1. Strauss, when n <= 190, see https://www.jstor.org/stable/2310929
        //  2. Pippinger, when n > 190, which roughly requires O(n / log_2 n) scalar multiplications
        // For simplicity, we estimate the complexity as O(n / log_2 n)
        RistrettoPoint::vartime_multiscalar_mul(scalars.iter(), points)
    };
```

**File:** keyless/pepper/service/src/main.rs (L379-392)
```rust
    // Run the constant time benchmarks for fixed bases
    let abs_max_t = ctbench::run_bench(
        &BenchName("blstrs_scalar_mul/fixed_bases"),
        constant_time::blstrs_scalar_mul::run_bench_with_fixed_bases,
        None,
    )
    .1
    .max_t
    .abs()
    .ceil()
    .to_i64()
    .expect("Floating point arithmetic went awry.");
    assert_le!(abs_max_t, ABS_MAX_T);
}
```
