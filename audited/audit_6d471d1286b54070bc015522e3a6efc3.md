# Audit Report

## Title
Missing Chain ID Validation During Genesis Creation Allows Network Misconfiguration

## Summary
The genesis creation process lacks validation to ensure that the `chain_id` parameter matches the intended network type (mainnet vs testnet). This allows accidental or malicious misconfiguration where mainnet could be initialized with testnet's chain ID (2) or vice versa, potentially enabling cross-chain transaction replay attacks and network confusion.

## Finding Description
During genesis creation, the `chain_id` is read from the `Layout` configuration file and passed directly to genesis transaction generation without validation that it matches the intended network. [1](#0-0) 

The `Layout` struct accepts any `ChainId` value in the `chain_id` field. When mainnet genesis is generated, this value flows through to the genesis transaction: [2](#0-1) 

The genesis validation function checks various parameters but does NOT validate the chain_id: [3](#0-2) 

While mainnet genesis has an assertion for `is_test`: [4](#0-3) 

There is NO corresponding check like `assert!(chain_id.is_mainnet(), "Mainnet must use chain_id 1")`.

The network handshake validates chain_id equality between peers but not correctness: [5](#0-4) 

**Attack Scenario:**
1. During genesis ceremony, operator accidentally sets `chain_id: 2` in mainnet's Layout YAML (or `chain_id: 1` in testnet's)
2. Genesis transaction is generated with incorrect chain_id
3. All validators bootstrap with this genesis
4. Validators successfully connect to each other (handshake checks equality, not correctness)
5. Both networks now have the same chain_id, enabling cross-chain replay

**Broken Invariants:**
- **Transaction Validation**: Chain ID-based replay protection fails when networks share the same ID [6](#0-5) 

## Impact Explanation
This qualifies as **High Severity** under the Aptos bug bounty program:
- **Significant protocol violation**: Cross-chain replay protection is compromised
- **Network integrity**: Validators operate on wrong network without detection
- **Transaction safety**: Transactions signed for one network execute on another

If mainnet and testnet have identical chain IDs:
- Users' testnet transactions could be replayed on mainnet (or vice versa)
- Assets could be stolen if an attacker captures signed testnet transactions and replays them on mainnet
- Network identification becomes unreliable

## Likelihood Explanation
**Medium likelihood** for accidental occurrence:
- Genesis ceremonies involve manual YAML configuration
- No automated validation catches chain_id mismatches
- Human error during network setup is realistic
- New network deployments (devnet, custom networks) are frequent

**Low likelihood** for malicious exploitation:
- Requires insider access to genesis ceremony
- Hardcoded waypoints provide partial protection for mainnet/testnet: [7](#0-6) 

However, waypoint protection only works if nodes use those specific values, and doesn't prevent new networks from being misconfigured.

## Recommendation
Add explicit chain_id validation during genesis creation:

```rust
// In aptos-move/vm-genesis/src/lib.rs, in encode_aptos_mainnet_genesis_transaction:
pub fn encode_aptos_mainnet_genesis_transaction(
    accounts: &[AccountBalance],
    employees: &[EmployeePool],
    validators: &[ValidatorWithCommissionRate],
    framework: &ReleaseBundle,
    chain_id: ChainId,
    genesis_config: &GenesisConfiguration,
) -> Transaction {
    assert!(!genesis_config.is_test, "This is mainnet!");
    assert!(chain_id.is_mainnet(), "Mainnet genesis must use chain_id 1"); // ADD THIS
    validate_genesis_config(genesis_config);
    // ... rest of function
}
```

Similarly, add validation in testnet genesis creation paths, and consider adding a `validate_chain_id_for_network` function in the Layout validation logic:

```rust
// In crates/aptos-genesis/src/config.rs
impl Layout {
    pub fn validate_chain_id_for_network(&self, expected_network: &str) -> Result<(), Error> {
        match expected_network {
            "mainnet" => {
                if self.chain_id != ChainId::mainnet() {
                    return Err(anyhow!("Mainnet genesis must use chain_id 1, got {}", self.chain_id));
                }
            }
            "testnet" => {
                if self.chain_id != ChainId::testnet() {
                    return Err(anyhow!("Testnet genesis must use chain_id 2, got {}", self.chain_id));
                }
            }
            _ => {} // Allow custom chain_ids for other networks
        }
        Ok(())
    }
}
```

## Proof of Concept

```yaml
# malicious_mainnet_layout.yaml
# Create this file with testnet's chain_id for "mainnet"
users: ["validator1"]
chain_id: 2  # WRONG! Should be 1 for mainnet
allow_new_validators: true
epoch_duration_secs: 7200
is_test: false  # Claims to be mainnet
min_stake: 1000000000000
# ... other mainnet parameters
```

```rust
// Reproduction steps (Rust pseudo-code):
use aptos_genesis::config::Layout;
use aptos_types::chain_id::ChainId;

#[test]
fn test_chain_id_validation_missing() {
    // Load malicious layout
    let layout = Layout::from_disk("malicious_mainnet_layout.yaml").unwrap();
    
    // This should fail but doesn't - no validation!
    assert_eq!(layout.chain_id, ChainId::testnet()); // chain_id is 2
    assert_eq!(layout.is_test, false); // Claims to be mainnet
    
    // Generate mainnet genesis with wrong chain_id
    // This will succeed without any error!
    let genesis_info = MainnetGenesisInfo::new(
        layout.chain_id, // Using testnet's chain_id for "mainnet"
        root_key,
        validators,
        framework,
        &genesis_config,
    ).unwrap();
    
    // Genesis transaction created with chain_id=2 for "mainnet"
    // No validation catches this error!
}
```

The genesis generation will complete successfully, creating a mainnet genesis with testnet's chain_id, violating the invariant that mainnet must have chain_id=1.

## Notes
While hardcoded genesis waypoints provide some protection for the official mainnet and testnet networks, this vulnerability remains relevant for:
1. New network deployments (custom testnets, devnets)
2. Network resets or upgrades requiring new genesis
3. Third-party forks of Aptos
4. Operational errors during legitimate deployments

The missing validation represents a gap in defense-in-depth security practices for genesis ceremony operations.

### Citations

**File:** crates/aptos-genesis/src/config.rs (L30-90)
```rust
pub struct Layout {
    /// Root key for the blockchain only for test chains
    #[serde(default)]
    pub root_key: Option<Ed25519PublicKey>,
    /// List of usernames or identifiers
    pub users: Vec<String>,
    /// ChainId for the target network
    pub chain_id: ChainId,
    /// Whether to allow new validators to join the set after genesis
    ///
    /// Ignored for mainnet
    #[serde(default)]
    pub allow_new_validators: bool,
    /// Duration of an epoch
    pub epoch_duration_secs: u64,
    /// Whether this is a test network or not
    ///
    /// Ignored for mainnet
    #[serde(default)]
    pub is_test: bool,
    /// Minimum stake to be in the validator set
    pub min_stake: u64,
    /// Minimum number of votes to consider a proposal valid.
    pub min_voting_threshold: u128,
    /// Maximum stake to be in the validator set
    pub max_stake: u64,
    /// Minimum number of seconds to lockup staked coins
    pub recurring_lockup_duration_secs: u64,
    /// Required amount of stake to create proposals.
    pub required_proposer_stake: u64,
    /// Percentage of stake given out as rewards a year (0-100%).
    pub rewards_apy_percentage: u64,
    /// Voting duration for a proposal in seconds.
    pub voting_duration_secs: u64,
    /// % of current epoch's total voting power that can be added in this epoch.
    pub voting_power_increase_limit: u64,
    /// Total supply of coins
    pub total_supply: Option<u64>,
    /// Timestamp (in seconds) when employee vesting starts.
    pub employee_vesting_start: Option<u64>,
    /// Duration of each vesting period (in seconds).
    pub employee_vesting_period_duration: Option<u64>,
    /// Onchain Consensus Config
    #[serde(default = "OnChainConsensusConfig::default_for_genesis")]
    pub on_chain_consensus_config: OnChainConsensusConfig,
    /// Onchain Execution Config
    #[serde(default = "OnChainExecutionConfig::default_for_genesis")]
    pub on_chain_execution_config: OnChainExecutionConfig,

    /// An optional JWK consensus config to use, instead of `default_for_genesis()`.
    #[serde(default)]
    pub jwk_consensus_config_override: Option<OnChainJWKConsensusConfig>,

    /// JWKs to patch in genesis.
    #[serde(default)]
    pub initial_jwks: Vec<IssuerJWK>,

    /// Keyless Groth16 verification key to install in genesis.
    #[serde(default)]
    pub keyless_groth16_vk_override: Option<Groth16VerificationKey>,
}
```

**File:** crates/aptos/src/genesis/mod.rs (L237-238)
```rust
    Ok(MainnetGenesisInfo::new(
        layout.chain_id,
```

**File:** aptos-move/vm-genesis/src/lib.rs (L143-144)
```rust
    assert!(!genesis_config.is_test, "This is mainnet!");
    validate_genesis_config(genesis_config);
```

**File:** aptos-move/vm-genesis/src/lib.rs (L405-439)
```rust
fn validate_genesis_config(genesis_config: &GenesisConfiguration) {
    assert!(
        genesis_config.min_stake <= genesis_config.max_stake,
        "Min stake must be smaller than or equal to max stake"
    );
    assert!(
        genesis_config.epoch_duration_secs > 0,
        "Epoch duration must be > 0"
    );
    assert!(
        genesis_config.recurring_lockup_duration_secs > 0,
        "Recurring lockup duration must be > 0"
    );
    assert!(
        genesis_config.recurring_lockup_duration_secs >= genesis_config.epoch_duration_secs,
        "Recurring lockup duration must be at least as long as epoch duration"
    );
    assert!(
        genesis_config.rewards_apy_percentage > 0 && genesis_config.rewards_apy_percentage < 100,
        "Rewards APY must be > 0% and < 100%"
    );
    assert!(
        genesis_config.voting_duration_secs > 0,
        "On-chain voting duration must be > 0"
    );
    assert!(
        genesis_config.voting_duration_secs < genesis_config.recurring_lockup_duration_secs,
        "Voting duration must be strictly smaller than recurring lockup"
    );
    assert!(
        genesis_config.voting_power_increase_limit > 0
            && genesis_config.voting_power_increase_limit <= 50,
        "voting_power_increase_limit must be > 0 and <= 50"
    );
}
```

**File:** network/framework/src/protocols/wire/handshake/v1/mod.rs (L435-441)
```rust
        // verify that both peers are on the same chain
        if self.chain_id != other.chain_id {
            return Err(HandshakeError::InvalidChainId(
                other.chain_id,
                self.chain_id,
            ));
        }
```

**File:** aptos-move/framework/aptos-framework/sources/transaction_validation.move (L143-143)
```text
        assert!(chain_id::get() == chain_id, error::invalid_argument(PROLOGUE_EBAD_CHAIN_ID));
```

**File:** config/src/config/execution_config.rs (L25-28)
```rust
const MAINNET_GENESIS_WAYPOINT: &str =
    "0:6072b68a942aace147e0655c5704beaa255c84a7829baa4e72a500f1516584c4";
const TESTNET_GENESIS_WAYPOINT: &str =
    "0:4b56f15c1dcef7f9f3eb4b4798c0cba0f1caacc0d35f1c80ad9b7a21f1f8b454";
```
