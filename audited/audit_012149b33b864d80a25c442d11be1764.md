# Audit Report

## Title
Panic-Based Denial of Service in DKG Verification Due to Unvalidated Tuple Component Sizes

## Summary
A Byzantine validator can craft a malicious DKG transcript with mismatched proof component sizes, causing other validators to panic during cryptographic verification. The vulnerability exists in the sigma protocol's `merge_msm_terms` function, which assumes matching sizes between the prover's first message and the public statement without validation.

## Finding Description

The vulnerability exists in the DKG transcript verification flow where a `PairingTupleHomomorphism` proof is verified without size validation between deserialized components.

**Root Cause**: The `TupleCodomainShape<A, B>` deserialization independently deserializes components A and B without cross-validation of their sizes: [1](#0-0) 

**Vulnerable Code Path**: During verification, the `merge_msm_terms` function assumes matching element counts between `prover_first_message` and `statement`. The function first zips these iterators to collect points for normalization: [2](#0-1) 

If `prover_first_message` has fewer elements than `statement`, the zip creates fewer pairs, resulting in `affine_iter` having fewer elements than needed. The subsequent loop iterates based on `powers_of_beta`, which is sized according to `statement`: [3](#0-2) 

Each iteration calls `affine_iter.next().unwrap()` twice (lines 173-174). When `affine_iter` is exhausted before the loop completes, the `unwrap()` panics, crashing the validator.

**Attack Trigger Point**: The vulnerability is reached when verifying DKG transcripts in the VM: [4](#0-3) 

This calls the transcript verification which eventually invokes the vulnerable sigma protocol verification: [5](#0-4) 

The `PairingTupleHomomorphism::verify` method computes `powers_of_beta` based on the public statement size, then calls `merge_msm_terms` for each homomorphism: [6](#0-5) 

**Attack Path:**
1. Byzantine validator crafts DKG transcript with malformed `SharingProof.SoK`
2. The proof's `first_proof_item` contains a `TupleCodomainShape` where the second component has fewer elements than the corresponding public statement component
3. Validator receives transcript (via block proposal or validator transaction pool)
4. During verification, the size mismatch causes iterator exhaustion
5. The `.unwrap()` call panics, crashing the validator node

## Impact Explanation

**Severity: HIGH**

This qualifies as HIGH severity under Aptos bug bounty criteria for "Validator Node Slowdowns/Crashes":

- **Validator crashes**: Malicious DKG transcripts cause immediate validator node panics during verification
- **DKG protocol disruption**: Multiple validators can be crashed, preventing DKG completion required for epoch transitions and validator set updates
- **Network impact**: While not total network failure (validators can restart), this significantly disrupts critical epoch transition functionality
- **Reproducible**: Any Byzantine validator can trigger this repeatedly during DKG sessions

The impact does not reach CRITICAL because:
- Network can recover (not permanent partition)
- Does not affect consensus on existing blocks
- Requires validator restart, not hard fork
- Limited to DKG-participating validators during DKG sessions

## Likelihood Explanation

**Likelihood: HIGH**

- **Attack Complexity: Low** - Attacker only needs to serialize a proof with mismatched vector sizes in the `TupleCodomainShape` components
- **Attacker Requirements: Minimal** - Any validator participating in DKG can craft and submit malicious transcripts
- **No Sophisticated Knowledge Required** - Does not require cryptographic expertise beyond understanding serialization format
- **Detection: Difficult** - Malformed proof passes all prior validation checks and is only detected during MSM term computation
- **Threat Model: Within Scope** - Byzantine validators with <1/3 stake are within the Aptos threat model

## Recommendation

Add size validation in the verification flow to ensure `prover_first_message` and `public_statement` have matching element counts before calling `merge_msm_terms`:

```rust
// In PairingTupleHomomorphism::msm_terms_for_verify or merge_msm_terms
let prover_msg_len = prover_first_message.clone().into_iter().count();
let statement_len = statement.clone().into_iter().count();
anyhow::ensure!(
    prover_msg_len == statement_len,
    "Prover first message length {} does not match statement length {}",
    prover_msg_len,
    statement_len
);
```

Alternatively, modify `merge_msm_terms` to handle size mismatches gracefully by using iterators that return `Option` and validating before unwrapping.

## Proof of Concept

A proof of concept would involve:

1. Creating a DKG transcript with valid structure but malformed `SharingProof.SoK`
2. Setting `first_proof_item` to a `TupleCodomainShape` where the second component (`chunked_scalar_mul::CodomainShape`) has fewer vectors than the transcript's `Vs` field
3. Submitting this transcript as a `ValidatorTransaction::DKGResult`
4. Observing validator panic when verification reaches `merge_msm_terms`

The panic would occur at the `affine_iter.next().unwrap()` calls when the iterator is exhausted.

## Notes

This vulnerability breaks the assumption that sigma protocol proofs from Byzantine actors will fail verification gracefully with an error, rather than causing panics. The deserialization succeeds for structurally valid but semantically inconsistent proofs, bypassing all validation until the MSM term computation phase. The fix should validate size consistency immediately after deserialization or at the start of verification, before any iterator operations that assume matching sizes.

### Citations

**File:** crates/aptos-dkg/src/sigma_protocol/homomorphism/tuple.rs (L122-130)
```rust
    fn deserialize_with_mode<R: Read>(
        mut reader: R,
        compress: Compress,
        validate: ark_serialize::Validate,
    ) -> Result<Self, SerializationError> {
        let a = A::deserialize_with_mode(&mut reader, compress, validate)?;
        let b = B::deserialize_with_mode(&mut reader, compress, validate)?;
        Ok(Self(a, b))
    }
```

**File:** crates/aptos-dkg/src/sigma_protocol/homomorphism/tuple.rs (L353-373)
```rust
        let len1 = public_statement.0.clone().into_iter().count(); // hmm maybe pass the into_iter version in merge_msm_terms?
        let len2 = public_statement.1.clone().into_iter().count();
        let powers_of_beta = utils::powers(beta, len1 + len2);
        let (first_powers_of_beta, second_powers_of_beta) = powers_of_beta.split_at(len1);

        let (first_msm_terms_of_response, second_msm_terms_of_response) = self.msm_terms(&proof.z);

        let first_input = H1::merge_msm_terms(
            first_msm_terms_of_response.into_iter().collect(),
            &prover_first_message.0,
            &public_statement.0,
            first_powers_of_beta,
            c,
        );
        let second_input = H2::merge_msm_terms(
            second_msm_terms_of_response.into_iter().collect(),
            &prover_first_message.1,
            &public_statement.1,
            second_powers_of_beta,
            c,
        );
```

**File:** crates/aptos-dkg/src/sigma_protocol/traits.rs (L153-161)
```rust
        for (A, P) in prover_first_message.clone().into_iter()
            .zip(statement.clone().into_iter())
        {
            all_points_to_normalize.push(A);
            all_points_to_normalize.push(P);
        }

        let affine_points = C::normalize_batch(&all_points_to_normalize);
        let mut affine_iter = affine_points.into_iter();
```

**File:** crates/aptos-dkg/src/sigma_protocol/traits.rs (L163-181)
```rust
        for (term, beta_power) in msm_terms.into_iter().zip(powers_of_beta) {
            let mut bases = term.bases().to_vec();
            let mut scalars = term.scalars().to_vec();

            // Multiply scalars by βᶦ
            for scalar in scalars.iter_mut() {
                *scalar *= beta_power;
            }

            // Add prover + statement contributions
            bases.push(affine_iter.next().unwrap()); // this is the element `A` from the prover's first message
            bases.push(affine_iter.next().unwrap()); // this is the element `P` from the statement, but we'll need `P^c`

            scalars.push(- (*beta_power));
            scalars.push(-c * beta_power);

            final_basis.extend(bases);
            final_scalars.extend(scalars);
        }
```

**File:** aptos-move/aptos-vm/src/validator_txns/dkg.rs (L111-112)
```rust
        DefaultDKG::verify_transcript(&pub_params, &transcript)
            .map_err(|_| Expected(TranscriptVerificationFailed))?;
```

**File:** crates/aptos-dkg/src/pvss/chunky/weighted_transcriptv2.rs (L514-529)
```rust
            if let Err(err) = hom.verify(
                &TupleCodomainShape(
                    TupleCodomainShape(
                        self.sharing_proof.range_proof_commitment.clone(),
                        chunked_elgamal::WeightedCodomainShape {
                            chunks: self.subtrs.Cs.clone(),
                            randomness: self.subtrs.Rs.clone(),
                        },
                    ),
                    chunked_scalar_mul::CodomainShape(self.subtrs.Vs.clone()),
                ),
                &self.sharing_proof.SoK,
                &sok_cntxt,
            ) {
                bail!("PoK verification failed: {:?}", err);
            }
```
