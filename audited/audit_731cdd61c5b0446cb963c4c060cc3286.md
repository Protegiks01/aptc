# Audit Report

## Title
UnsupportedJWK Type Migration Requires Hard Fork Due to BCS Incompatibility in Consensus-Critical Path

## Summary
The `UnsupportedJWK` struct stored on-chain has no safe migration path for format changes due to BCS (Binary Canonical Serialization) incompatibility. Any attempt to modify the struct format (e.g., adding/removing fields) would cause consensus divergence during the transition period, requiring a coordinated hard fork with risk of state loss.

## Finding Description

The `UnsupportedJWK` type is stored on-chain within the `ObservedJWKs` resource and is deserialized during consensus-critical validator transaction processing. The vulnerability exists in the type migration mechanism:

**1. BCS Serialization Format Lock-in:**

The `UnsupportedJWK` struct is serialized using BCS and stored in the `Any.data` field: [1](#0-0) 

This data is embedded in on-chain state at the framework address: [2](#0-1) 

**2. Critical Deserialization in Consensus Path:**

The `copyable_any::unpack<UnsupportedJWK>()` function is called in two critical locations within `upsert_into_observed_jwks`, which processes validator transactions: [3](#0-2) [4](#0-3) 

This function calls the native `from_bytes<T>()` implementation: [5](#0-4) 

**3. Native Function Abort on Format Mismatch:**

The native implementation returns `None` on deserialization failure, causing an abort: [6](#0-5) 

**4. Validator Transaction Error Propagation:**

The abort is caught as an "Unexpected" error during validator transaction processing: [7](#0-6) 

This unexpected error is mapped to `UNEXPECTED_ERROR_FROM_KNOWN_MOVE_FUNCTION`: [8](#0-7) 

**5. Consensus Divergence Scenario:**

During a format migration:
- Validators upgrade their code to expect a new `UnsupportedJWK` format (e.g., adding a `version: u64` field)
- On-chain `ObservedJWKs` still contains old 2-field format in BCS bytes
- When a validator transaction calls `upsert_into_observed_jwks`:
  - **Upgraded validators**: `from_bytes` fails → abort with EFROM_BYTES → UNEXPECTED_ERROR_FROM_KNOWN_MOVE_FUNCTION
  - **Non-upgraded validators**: Deserialization succeeds normally
- Different validators produce different execution results for the same transaction
- **Consensus safety invariant violated**: Validators cannot agree on the correct state root

## Impact Explanation

This qualifies as **Critical Severity** under the Aptos Bug Bounty program because it represents a **Non-recoverable network partition requiring hardfork**:

1. **Consensus Safety Violation**: Breaks the fundamental "Deterministic Execution" invariant - validators produce different state roots for identical blocks
2. **Network Partition**: The network splits between upgraded and non-upgraded validators, unable to reach quorum
3. **Requires Hard Fork**: Cannot be resolved through normal governance - requires coordinated network halt, state migration, and restart
4. **State Loss Risk**: If migration is not executed correctly, existing `UnsupportedJWK` data becomes permanently inaccessible due to BCS deserialization failures

The lack of any versioning mechanism in the `Any` wrapper (only `type_name` and `data` fields) means there's no way to distinguish between format versions at runtime.

## Likelihood Explanation

**Medium Likelihood** that this issue would manifest:

1. **Requires Governance Action**: Only occurs if developers decide to modify the `UnsupportedJWK` format
2. **Known Design Constraint**: The codebase comments acknowledge this limitation: [9](#0-8) 
3. **No Current Migration Need**: No immediate reason to change the format
4. **High Impact if Occurs**: If attempted without proper coordination, would cause catastrophic consensus failure

However, the issue is **inevitable** if the JWK system needs to evolve (e.g., supporting new key types with additional metadata).

## Recommendation

**Primary Recommendation: Implement Versioned Type System**

Add explicit version tracking for on-chain types that may need migration:

```rust
// New versioned wrapper
pub struct VersionedUnsupportedJWK {
    pub version: u64,
    pub data: Vec<u8>,  // BCS-serialized version-specific data
}
```

In Move:
```move
struct VersionedAny has drop, store, copy {
    version: u64,
    type_name: String,
    data: vector<u8>
}
```

**Alternative Recommendation: Hard Fork Migration Protocol**

If format change is needed, implement a coordinated migration:

1. **Pre-fork phase**: Deploy new code with dual-format support (reads old format, writes new format)
2. **Migration transaction**: Execute special genesis transaction that reads all `ObservedJWKs`, deserializes old format, re-serializes new format
3. **Post-fork phase**: Remove old format support

**Immediate Mitigation**

Document the constraint clearly and establish a formal hard fork protocol for any future type format changes in consensus-critical paths.

## Proof of Concept

The following demonstrates the BCS incompatibility:

```rust
// Test showing BCS deserialization failure with struct format change
#[test]
fn test_unsupported_jwk_format_migration_failure() {
    // Original format (2 fields)
    #[derive(Serialize, Deserialize)]
    struct UnsupportedJWKV1 {
        id: Vec<u8>,
        payload: Vec<u8>,
    }
    
    // New format (3 fields) - INCOMPATIBLE
    #[derive(Serialize, Deserialize)]
    struct UnsupportedJWKV2 {
        id: Vec<u8>,
        payload: Vec<u8>,
        version: u64,  // NEW FIELD
    }
    
    // Serialize with old format
    let old_jwk = UnsupportedJWKV1 {
        id: b"key123".to_vec(),
        payload: b"payload".to_vec(),
    };
    let serialized = bcs::to_bytes(&old_jwk).unwrap();
    
    // Try to deserialize with new format - FAILS
    let result = bcs::from_bytes::<UnsupportedJWKV2>(&serialized);
    assert!(result.is_err()); // Deserialization fails!
    
    // This failure would occur in copyable_any::unpack during consensus
    // Different validators (upgraded vs non-upgraded) get different results
    // => Consensus safety violation
}
```

**Notes**

This issue represents a fundamental design constraint of BCS-serialized on-chain types in consensus-critical paths. While not an actively exploitable vulnerability by malicious actors, it poses a severe operational risk during system evolution. The lack of a versioning mechanism in the `Any` type wrapper makes any format changes to consensus-critical structs require coordinated hard forks. Future protocol designs should incorporate versioning from inception to enable safe migrations.

### Citations

**File:** types/src/jwks/unsupported/mod.rs (L13-17)
```rust
#[derive(Clone, PartialEq, Eq, Serialize, Deserialize, Object)]
pub struct UnsupportedJWK {
    pub id: Vec<u8>,
    pub payload: Vec<u8>,
}
```

**File:** aptos-move/framework/aptos-framework/sources/jwks.move (L3-7)
```text
/// Note: An important design constraint for this module is that the JWK consensus Rust code is unable to
/// spawn a VM and make a Move function call. Instead, the JWK consensus Rust code will have to directly
/// write some of the resources in this file. As a result, the structs in this file are declared so as to
/// have a simple layout which is easily accessible in Rust.
module aptos_framework::jwks {
```

**File:** aptos-move/framework/aptos-framework/sources/jwks.move (L68-73)
```text
    /// An JWK variant that represents the JWKs which were observed but not yet supported by Aptos.
    /// Observing `UnsupportedJWK`s means the providers adopted a new key type/format, and the system should be updated.
    struct UnsupportedJWK has copy, drop, store {
        id: vector<u8>,
        payload: vector<u8>,
    }
```

**File:** aptos-move/framework/aptos-framework/sources/jwks.move (L481-483)
```text
                    let is_delete = if (variant_type_name == b"0x1::jwks::UnsupportedJWK") {
                        let repr = copyable_any::unpack<UnsupportedJWK>(jwk.variant);
                        &repr.payload == &DELETE_COMMAND_INDICATOR
```

**File:** aptos-move/framework/aptos-framework/sources/jwks.move (L567-569)
```text
        } else if (variant_type_name == b"0x1::jwks::UnsupportedJWK") {
            let unsupported = copyable_any::unpack<UnsupportedJWK>(jwk.variant);
            unsupported.id
```

**File:** aptos-move/framework/aptos-stdlib/sources/copyable_any.move (L27-30)
```text
    public fun unpack<T>(self: Any): T {
        assert!(type_info::type_name<T>() == self.type_name, error::invalid_argument(ETYPE_MISMATCH));
        from_bytes<T>(self.data)
    }
```

**File:** aptos-move/framework/src/natives/util.rs (L48-59)
```rust
    let val = match ValueSerDeContext::new(max_value_nest_depth)
        .with_legacy_signer()
        .with_func_args_deserialization(&function_value_extension)
        .deserialize(&bytes, &layout)
    {
        Some(val) => val,
        None => {
            return Err(SafeNativeError::Abort {
                abort_code: EFROM_BYTES,
            })
        },
    };
```

**File:** aptos-move/aptos-vm/src/validator_txns/jwk.rs (L153-166)
```rust
        session
            .execute_function_bypass_visibility(
                &JWKS_MODULE,
                UPSERT_INTO_OBSERVED_JWKS,
                vec![],
                serialize_values(&args),
                &mut gas_meter,
                &mut TraversalContext::new(&traversal_storage),
                module_storage,
            )
            .map_err(|e| {
                expect_only_successful_execution(e, UPSERT_INTO_OBSERVED_JWKS.as_str(), log_context)
            })
            .map_err(|r| Unexpected(r.unwrap_err()))?;
```

**File:** aptos-move/aptos-vm/src/errors.rs (L275-304)
```rust
pub fn expect_only_successful_execution(
    error: VMError,
    function_name: &str,
    log_context: &AdapterLogSchema,
) -> Result<(), VMStatus> {
    let status = error.into_vm_status();
    Err(match status {
        VMStatus::Executed => VMStatus::Executed,
        // Speculative errors are returned for caller to handle.
        e @ VMStatus::Error {
            status_code:
                StatusCode::SPECULATIVE_EXECUTION_ABORT_ERROR
                | StatusCode::DELAYED_FIELD_OR_BLOCKSTM_CODE_INVARIANT_ERROR,
            ..
        } => e,
        status => {
            // Only trigger a warning here as some errors could be a result of the speculative parallel execution.
            // We will report the errors after we obtained the final transaction output in update_counters_for_processed_chunk
            let err_msg = format!(
                "[aptos_vm] Unexpected error from known Move function, '{}'. Error: {:?}",
                function_name, status
            );
            speculative_warn!(log_context, err_msg.clone());
            VMStatus::Error {
                status_code: StatusCode::UNEXPECTED_ERROR_FROM_KNOWN_MOVE_FUNCTION,
                sub_status: status.sub_status(),
                message: Some(err_msg),
            }
        },
    })
```
