# Audit Report

## Title
Speculative Execution Logging Fails to Distinguish Discarded Transactions from Committed Ones

## Summary
The speculative logging system in the block executor incorrectly flushes logs from discarded transactions (transactions that failed validation and were reverted) alongside logs from successfully committed transactions. This makes it impossible for operators and monitoring systems to distinguish between committed and reverted transaction logs, potentially hiding transactions that should have been discarded.

## Finding Description
The Aptos block executor implements speculative logging to buffer transaction logs during parallel execution and only flush them for committed transactions. However, the log flushing logic in `AptosBlockExecutorWrapper::execute_block_on_thread_pool` only checks for `Retry` status when determining which logs to flush, failing to exclude transactions with `Discard` status. [1](#0-0) 

The code uses `partition_point(|o| !o.status().is_retry())` to find the boundary for log flushing. This predicate returns `true` for both `Keep` and `Discard` status transactions, but only `Keep` transactions should have their logs flushed. [2](#0-1) 

Transactions can receive `Discard` status for various validation failures including invalid authentication keys, sequence number mismatches, insufficient balance, expired transactions, and bad chain IDs. These transactions execute enough code to generate logs through `speculative_log()` calls, but their state changes are reverted. [3](#0-2) 

The vulnerability occurs because:

1. **Transactions with Discard status still generate logs**: During prologue execution or validation, transactions call `speculative_log()` which buffers logs with the transaction index.

2. **Logs are not cleared for Discard transactions**: Unlike parallel execution aborts (which call `clear_speculative_txn_logs`), transactions that complete with `Discard` status do not have their logs cleared. [4](#0-3) 

3. **Flush logic is incorrect**: The partition point check only excludes `Retry` status, allowing both `Keep` and `Discard` logs to be flushed together.

4. **Separation happens too late**: The `extract_retries_and_discards` function properly separates transactions by status, but this occurs AFTER logs have already been flushed to the logging system. [5](#0-4) 

## Impact Explanation
This is a **Medium severity** issue per the Aptos bug bounty criteria because it creates state inconsistencies requiring operational intervention:

1. **Audit Trail Corruption**: Operators cannot distinguish logs from committed vs. discarded transactions, making post-mortem analysis unreliable.

2. **Monitoring System Confusion**: Alert systems monitoring transaction logs will trigger on discarded transactions as if they were committed, causing false positives.

3. **Attack Surface**: An attacker can deliberately submit transactions designed to fail with `Discard` status (e.g., wrong sequence number, expired timestamp) to pollute logs with misleading information, obscuring actual transaction execution patterns.

4. **Debugging Difficulty**: When investigating transaction failures or system behavior, logs from discarded transactions appear alongside committed ones, making root cause analysis significantly harder.

While this does not directly cause consensus violations or fund loss, it breaks operational observability guarantees and creates a vector for log pollution attacks.

## Likelihood Explanation
This vulnerability triggers **automatically** for every block that contains at least one transaction with `Discard` status. Such transactions occur frequently in normal operation:
- Transactions with incorrect sequence numbers
- Expired transactions in the mempool
- Transactions from accounts with insufficient balance
- Transactions with authentication failures

The attack is **trivial to execute**: Any user can submit transactions that will be discarded (e.g., with an already-used sequence number or intentionally expired timestamp), causing their logs to be flushed alongside committed transactions.

## Recommendation
Modify the log flushing logic to only flush logs for transactions with `Keep` status, not all non-`Retry` transactions:

```rust
// In aptos-move/aptos-vm/src/block_executor/mod.rs, around line 567:
// Instead of:
let pos = output_vec.partition_point(|o| !o.status().is_retry());

// Use:
let pos = output_vec.partition_point(|o| o.status().is_kept());
``` [6](#0-5) 

This leverages the existing `is_kept()` method which returns `true` only for `Keep` status transactions, properly excluding both `Discard` and `Retry` transactions from log flushing.

Additionally, consider adding explicit log clearing for discarded transactions to be defensive:

```rust
// After determining transaction status but before returning output
if matches!(txn_status, TransactionStatus::Discard(_)) {
    clear_speculative_txn_logs(txn_idx);
}
```

## Proof of Concept

**Rust Test Demonstrating the Issue:**

```rust
#[test]
fn test_discarded_transaction_logs_incorrectly_flushed() {
    use aptos_types::transaction::{TransactionStatus, TransactionOutput};
    use aptos_vm_logging::{init_speculative_logs, flush_speculative_logs};
    
    // Initialize speculative logging for 3 transactions
    init_speculative_logs(3);
    
    // Simulate transaction outputs: Keep, Discard, Retry
    let outputs = vec![
        TransactionOutput::new(
            WriteSet::default(),
            vec![],
            0,
            TransactionStatus::Keep(ExecutionStatus::Success),
            TransactionAuxiliaryData::default(),
        ),
        TransactionOutput::new(
            WriteSet::default(),
            vec![],
            0,
            TransactionStatus::Discard(StatusCode::SEQUENCE_NUMBER_TOO_OLD),
            TransactionAuxiliaryData::default(),
        ),
        TransactionOutput::new(
            WriteSet::default(),
            vec![],
            0,
            TransactionStatus::Retry,
            TransactionAuxiliaryData::default(),
        ),
    ];
    
    // Current (buggy) logic: flushes first 2 transactions (Keep + Discard)
    let pos = outputs.partition_point(|o| !o.status().is_retry());
    assert_eq!(pos, 2); // BUG: Includes the Discard transaction
    
    // Correct logic: should only flush 1 transaction (Keep only)
    let correct_pos = outputs.partition_point(|o| o.status().is_kept());
    assert_eq!(correct_pos, 1); // Only the Keep transaction
}
```

**Exploitation Scenario:**
1. Attacker submits a transaction with sequence number already used
2. Transaction executes prologue, generates logs via `speculative_log()`
3. Prologue fails with `SEQUENCE_NUMBER_TOO_OLD` error
4. Transaction receives `TransactionStatus::Discard` status
5. Block executor calls `flush_speculative_logs(pos)` where `pos` includes the discarded transaction
6. Logs from the discarded transaction are flushed to monitoring systems
7. Operators see logs from a transaction that was never committed, causing confusion

## Notes

This vulnerability affects the operational integrity of the Aptos blockchain rather than consensus safety directly. However, reliable logging is critical for:
- Security incident response
- Performance monitoring
- Transaction debugging
- Compliance and audit requirements

The fix is straightforward and should be applied to ensure logs accurately reflect only committed transactions.

### Citations

**File:** aptos-move/aptos-vm/src/block_executor/mod.rs (L567-572)
```rust
                let pos = output_vec.partition_point(|o| !o.status().is_retry());

                if state_view.id() != StateViewId::Miscellaneous {
                    // Speculation is disabled in Miscellaneous context, which is used by testing and
                    // can even lead to concurrent execute_block invocations, leading to errors on flush.
                    flush_speculative_logs(pos);
```

**File:** types/src/transaction/mod.rs (L1578-1611)
```rust
pub enum TransactionStatus {
    /// Discard the transaction output
    Discard(DiscardedVMStatus),

    /// Keep the transaction output
    Keep(ExecutionStatus),

    /// Retry the transaction, e.g., after a reconfiguration
    Retry,
}

impl TransactionStatus {
    pub fn status(&self) -> Result<ExecutionStatus, StatusCode> {
        match self {
            Self::Keep(status) => Ok(status.clone()),
            Self::Discard(code) => Err(*code),
            Self::Retry => Err(StatusCode::UNKNOWN_VALIDATION_STATUS),
        }
    }

    pub fn is_discarded(&self) -> bool {
        match self {
            Self::Discard(_) | Self::Retry => true,
            Self::Keep(_) => false,
        }
    }

    pub fn is_kept(&self) -> bool {
        !self.is_discarded()
    }

    pub fn is_retry(&self) -> bool {
        matches!(self, Self::Retry)
    }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L596-628)
```rust
        let txn_status = TransactionStatus::from_vm_status(
            error_vm_status.clone(),
            self.features(),
            self.gas_feature_version() >= RELEASE_V1_38,
        );

        match txn_status {
            TransactionStatus::Keep(status) => {
                // The transaction should be kept. Run the appropriate post transaction workflows
                // including epilogue. This runs a new session that ignores any side effects that
                // might abort the execution (e.g., spending additional funds needed to pay for
                // gas). Even if the previous failure occurred while running the epilogue, it
                // should not fail now. If it somehow fails here, there is no choice but to
                // discard the transaction.
                let output = self
                    .finish_aborted_transaction(
                        prologue_session_change_set,
                        gas_meter,
                        txn_data,
                        resolver,
                        module_storage,
                        serialized_signers,
                        status,
                        log_context,
                        change_set_configs,
                        traversal_context,
                    )
                    .unwrap_or_else(|status| discarded_output(status.status_code()));
                (error_vm_status, output)
            },
            TransactionStatus::Discard(status_code) => {
                let discarded_output = discarded_output(status_code);
                (error_vm_status, discarded_output)
```

**File:** aptos-move/block-executor/src/executor_utilities.rs (L308-319)
```rust
pub(crate) fn update_transaction_on_abort<T, E>(
    txn_idx: TxnIndex,
    last_input_output: &TxnLastInputOutput<T, E::Output>,
    versioned_cache: &MVHashMap<T::Key, T::Tag, T::Value, DelayedFieldID>,
) where
    T: Transaction,
    E: ExecutorTask<Txn = T>,
{
    counters::SPECULATIVE_ABORT_COUNT.inc();

    // Any logs from the aborted execution should be cleared and not reported.
    clear_speculative_txn_logs(txn_idx as usize);
```

**File:** execution/executor/src/workflow/do_get_execution_output.rs (L460-493)
```rust
    fn extract_retries_and_discards(
        transactions: &mut Vec<Transaction>,
        transaction_outputs: &mut Vec<TransactionOutput>,
        persisted_auxiliary_infos: &mut Vec<PersistedAuxiliaryInfo>,
    ) -> (TransactionsWithOutput, TransactionsWithOutput) {
        let _timer = OTHER_TIMERS.timer_with(&["parse_raw_output__retries_and_discards"]);

        let mut to_discard = TransactionsWithOutput::new_empty();
        let mut to_retry = TransactionsWithOutput::new_empty();

        let mut num_keep_txns = 0;

        for idx in 0..transactions.len() {
            match transaction_outputs[idx].status() {
                TransactionStatus::Keep(_) => {
                    if num_keep_txns != idx {
                        transactions[num_keep_txns] = transactions[idx].clone();
                        transaction_outputs[num_keep_txns] = transaction_outputs[idx].clone();
                        persisted_auxiliary_infos[num_keep_txns] = persisted_auxiliary_infos[idx];
                    }
                    num_keep_txns += 1;
                },
                TransactionStatus::Retry => to_retry.push(
                    transactions[idx].clone(),
                    transaction_outputs[idx].clone(),
                    persisted_auxiliary_infos[idx],
                ),
                TransactionStatus::Discard(_) => to_discard.push(
                    transactions[idx].clone(),
                    transaction_outputs[idx].clone(),
                    persisted_auxiliary_infos[idx],
                ),
            }
        }
```
