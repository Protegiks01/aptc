# Audit Report

## Title
Validator Set State Corruption Undetectable by verify_state_kvs() Allowing Unauthorized Validator Participation

## Summary
The `verify_state_kvs()` function only validates state key existence but does not verify the integrity or semantic correctness of state values. This allows corrupted ValidatorSet state to go undetected, potentially enabling unauthorized validators to participate in consensus and break network security.

## Finding Description

The `verify_state_kvs()` function performs only superficial validation by checking if state key hashes exist in both the internal indexer database and the state_kv database. [1](#0-0) [2](#0-1) 

The function only checks key existence (line 174), never retrieving or validating actual state values. It performs no deserialization, no semantic validation, and no cryptographic verification against Merkle proofs.

The ValidatorSet is stored as a BCS-serialized state value at a specific StateKey: [3](#0-2) [4](#0-3) 

When ValidatorSet is loaded from storage, it uses simple deserialization without proof verification: [5](#0-4) [6](#0-5) 

The ValidatorVerifier is then constructed from this ValidatorSet with only basic structural checks: [7](#0-6) 

**Attack Scenario:**
1. An attacker gains write access to AptosDB storage (through validator node compromise, storage layer vulnerability, or backup manipulation)
2. Attacker modifies the StateValue for the ValidatorSet key, adding unauthorized validators with attacker-controlled consensus public keys
3. The state key hash remains unchanged (still `0x1::stake::ValidatorSet`)
4. `verify_state_kvs()` executes and passes - it only verifies the key hash exists
5. At the next epoch transition or when ValidatorSet is loaded, the corrupted data is deserialized and used without validation
6. Unauthorized validators participate in consensus with their malicious keys

This breaks the **State Consistency** invariant: "State transitions must be atomic and verifiable via Merkle proofs" - the validation function fails to verify state integrity.

## Impact Explanation

This is **Critical Severity** under Aptos bug bounty criteria as a **Consensus/Safety violation**. If unauthorized validators join the network through undetected ValidatorSet corruption, they can:

- Participate in AptosBFT consensus with malicious keys
- Sign blocks and votes affecting consensus decisions  
- Potentially break BFT safety guarantees if enough unauthorized validators join
- Manipulate voting power distribution
- Compromise network security and integrity

The validation function's failure to detect such corruption means the network operates without critical integrity protection for validator set state.

## Likelihood Explanation

**Likelihood: Medium**

While the attack requires database-level write access, this can occur through:
- Compromised validator operator (insider threat)
- Storage layer vulnerabilities or bugs
- Backup/restore manipulation attacks
- Hardware failures causing corruption
- Database replication errors

The validation tool `verify_state_kvs()` is specifically designed to detect such corruption, so its failure to do so is a direct security gap regardless of how corruption occurs. The function runs during database validation and debugging, precisely when such corruption needs detection.

## Recommendation

Add comprehensive state value validation to `verify_state_kvs()`:

1. **Retrieve and deserialize state values** - Don't just check key existence
2. **Validate ValidatorSet-specific constraints**:
   - Verify all consensus public keys are valid BLS keys
   - Check voting power is non-zero and reasonable
   - Validate validator addresses are well-formed
   - Ensure total voting power calculations are correct
3. **Verify Merkle proofs** against the committed state root hash from LedgerInfo
4. **Perform semantic validation** for critical on-chain configs

Add a new validation function:
```rust
fn verify_validator_set_integrity(
    db: &AptosDB,
    state_key: &StateKey,
    version: u64,
) -> Result<()> {
    // Get state value WITH proof
    let (state_value_opt, proof) = db.get_state_value_with_proof_by_version(state_key, version)?;
    
    // Get expected root hash from ledger info
    let txn_info = db.get_transaction_info(version)?;
    let expected_root = txn_info.state_checkpoint_hash();
    
    // Verify Merkle proof
    proof.verify(expected_root, state_key.hash(), state_value_opt.as_ref())?;
    
    // Deserialize and validate ValidatorSet
    if let Some(state_value) = state_value_opt {
        let validator_set: ValidatorSet = bcs::from_bytes(state_value.bytes())?;
        
        // Validate structure
        ensure!(!validator_set.active_validators.is_empty(), "Empty validator set");
        
        // Validate each validator
        for validator in validator_set.payload() {
            ensure!(validator.consensus_voting_power() > 0, "Invalid voting power");
            // Verify BLS key is valid
            validator.consensus_public_key().verify(&[0u8], &Default::default())
                .map_err(|_| anyhow!("Invalid consensus public key"))?;
        }
    }
    
    Ok(())
}
```

Integrate this into the main validation loop to check critical state keys like ValidatorSet, ensuring content integrity beyond just key existence.

## Proof of Concept

```rust
#[cfg(test)]
mod test {
    use super::*;
    use aptos_types::{
        on_chain_config::ValidatorSet,
        validator_info::ValidatorInfo,
        state_store::state_key::StateKey,
        state_store::state_value::StateValue,
    };
    use aptos_crypto::bls12381;
    
    #[test]
    fn test_corrupted_validator_set_undetected() {
        // Setup: Create a test database with ValidatorSet
        let db = setup_test_db();
        let internal_db = setup_internal_indexer_db();
        
        // Create a corrupted ValidatorSet with unauthorized validator
        let mut corrupted_validator_set = ValidatorSet::empty();
        let malicious_key = bls12381::PrivateKey::generate_for_testing();
        let malicious_validator = ValidatorInfo::new_with_test_network_keys(
            AccountAddress::random(),
            malicious_key.public_key(),
            1000, // High voting power
            0,
        );
        corrupted_validator_set.active_validators.push(malicious_validator);
        
        // Serialize and write corrupted ValidatorSet to database
        let state_key = StateKey::on_chain_config::<ValidatorSet>().unwrap();
        let corrupted_bytes = bcs::to_bytes(&corrupted_validator_set).unwrap();
        let state_value = StateValue::new_legacy(corrupted_bytes.into());
        
        db.write_state_value(state_key.clone(), 1000, state_value);
        
        // Run verify_state_kvs - it should detect corruption but DOESN'T
        let result = verify_state_kvs(
            db.path(),
            &internal_db,
            1000
        );
        
        // BUG: Validation passes even though ValidatorSet is corrupted
        assert!(result.is_ok()); // This should fail but doesn't!
        
        // Load the corrupted ValidatorSet - it will be used as-is
        let loaded_set = ValidatorSet::fetch_config(&db.latest_state_view()).unwrap();
        
        // Unauthorized validator is now in the set
        assert!(loaded_set.active_validators.iter()
            .any(|v| v.consensus_public_key() == &malicious_key.public_key()));
    }
}
```

This demonstrates that `verify_state_kvs()` fails to detect ValidatorSet corruption, allowing unauthorized validators to remain in the database and potentially join consensus.

## Notes

While Merkle proof verification infrastructure exists in the codebase, it is not utilized by the `verify_state_kvs()` validation function. The function only performs key existence checks, leaving a critical gap in database integrity validation that could allow compromised validator set state to persist undetected. This is particularly concerning for the ValidatorSet resource, as corruption here directly impacts consensus security by determining which validators can participate in block production and signing.

### Citations

**File:** storage/aptosdb/src/db_debugger/validation.rs (L114-146)
```rust
pub fn verify_state_kvs(
    db_root_path: &Path,
    internal_db: &DB,
    target_ledger_version: u64,
) -> Result<()> {
    println!("Validating db statekeys");
    let storage_dir = StorageDirPaths::from_path(db_root_path);
    let state_kv_db =
        StateKvDb::open_sharded(&storage_dir, RocksdbConfig::default(), None, None, false)?;

    //read all statekeys from internal db and store them in mem
    let mut all_internal_keys = HashSet::new();
    let mut iter = internal_db.iter::<StateKeysSchema>()?;
    iter.seek_to_first();
    for (key_ind, state_key_res) in iter.enumerate() {
        let state_key = state_key_res?.0;
        let state_key_hash = state_key.hash();
        all_internal_keys.insert(state_key_hash);
        if key_ind % 10_000_000 == 0 {
            println!("Processed {} keys", key_ind);
        }
    }
    println!(
        "Number of state keys in internal db: {}",
        all_internal_keys.len()
    );
    for shard_id in 0..16 {
        let shard = state_kv_db.db_shard(shard_id);
        println!("Validating state_kv for shard {}", shard_id);
        verify_state_kv(shard, &all_internal_keys, target_ledger_version)?;
    }
    Ok(())
}
```

**File:** storage/aptosdb/src/db_debugger/validation.rs (L157-191)
```rust
fn verify_state_kv(
    shard: &DB,
    all_internal_keys: &HashSet<HashValue>,
    target_ledger_version: u64,
) -> Result<()> {
    let read_opts = ReadOptions::default();
    let mut iter = shard.iter_with_opts::<StateValueByKeyHashSchema>(read_opts)?;
    // print a message every 10k keys
    let mut counter = 0;
    iter.seek_to_first();
    let mut missing_keys = 0;
    for value in iter {
        let (state_key_hash, version) = value?.0;
        if version > target_ledger_version {
            continue;
        }
        // check if the state key hash is present in the internal db
        if !all_internal_keys.contains(&state_key_hash) {
            missing_keys += 1;
            println!(
                "State key hash not found in internal db: {:?}, version: {}",
                state_key_hash, version
            );
        }
        counter += 1;
        if counter as usize % SAMPLE_RATE == 0 {
            println!(
                "Processed {} keys, the current sample is {} at version {}",
                counter, state_key_hash, version
            );
        }
    }
    println!("Number of missing keys: {}", missing_keys);
    Ok(())
}
```

**File:** types/src/state_store/state_key/mod.rs (L156-158)
```rust
    pub fn on_chain_config<T: OnChainConfig>() -> Result<Self> {
        Self::resource(T::address(), &T::struct_tag())
    }
```

**File:** types/src/on_chain_config/validator_set.rs (L96-100)
```rust
impl OnChainConfig for ValidatorSet {
    // validator_set_address
    const MODULE_IDENTIFIER: &'static str = "stake";
    const TYPE_IDENTIFIER: &'static str = "ValidatorSet";
}
```

**File:** types/src/on_chain_config/mod.rs (L162-173)
```rust
    fn deserialize_default_impl(bytes: &[u8]) -> Result<Self> {
        bcs::from_bytes::<Self>(bytes)
            .map_err(|e| format_err!("[on-chain config] Failed to deserialize into config: {}", e))
    }

    // Function for deserializing bytes to `Self`
    // It will by default try one round of BCS deserialization directly to `Self`
    // The implementation for the concrete type should override this function if this
    // logic needs to be customized
    fn deserialize_into_config(bytes: &[u8]) -> Result<Self> {
        Self::deserialize_default_impl(bytes)
    }
```

**File:** types/src/on_chain_config/mod.rs (L204-210)
```rust
impl<S: StateView> ConfigStorage for S {
    fn fetch_config_bytes(&self, state_key: &StateKey) -> Option<Bytes> {
        self.get_state_value(state_key)
            .ok()?
            .map(|s| s.bytes().clone())
    }
}
```

**File:** types/src/validator_verifier.rs (L563-586)
```rust
impl From<&ValidatorSet> for ValidatorVerifier {
    fn from(validator_set: &ValidatorSet) -> Self {
        let sorted_validator_infos: BTreeMap<u64, ValidatorConsensusInfo> = validator_set
            .payload()
            .map(|info| {
                (
                    info.config().validator_index,
                    ValidatorConsensusInfo::new(
                        info.account_address,
                        info.consensus_public_key().clone(),
                        info.consensus_voting_power(),
                    ),
                )
            })
            .collect();
        let validator_infos: Vec<_> = sorted_validator_infos.values().cloned().collect();
        for info in validator_set.payload() {
            assert_eq!(
                validator_infos[info.config().validator_index as usize].address,
                info.account_address
            );
        }
        ValidatorVerifier::new(validator_infos)
    }
```
