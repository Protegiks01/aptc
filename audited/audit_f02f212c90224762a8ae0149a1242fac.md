# Audit Report

## Title
Case Sensitivity Vulnerability in Transaction Filter Address Standardization Causes Filter Mismatches for Special Addresses

## Summary
The `standardize_address()` function in the indexer-grpc transaction filter preserves the case of hexadecimal characters for special addresses (0x0-0xf), while `AccountAddress::to_standard_string()` always outputs lowercase. This causes filter mismatches when users specify uppercase special addresses (0xA-0xF) in filters, as these will never match actual transactions.

## Finding Description
The vulnerability exists in how special addresses (0x0 through 0xf per AIP-40) are standardized in the transaction filtering system. [1](#0-0) 

The `standardize_address()` function preserves the input case when returning short-form special addresses. However, transaction data is populated from `AccountAddress::to_string()`: [2](#0-1) 

Which calls `to_standard_string()` that uses `hex::encode()` returning lowercase: [3](#0-2) [4](#0-3) 

During filter matching, both sides are standardized but case differences are preserved: [5](#0-4) 

**Attack Scenario:**
1. User creates filter with `sender: "0xA"` (uppercase)
2. Filter standardization: `standardize_address("0xA")` → `"0xA"` (case preserved)
3. Transaction arrives with sender from `AccountAddress(10).to_string()` → `"0xa"` (lowercase)
4. Transaction standardization: `standardize_address("0xa")` → `"0xa"` (case preserved)
5. Comparison: `"0xA" != "0xa"` → **No match** despite representing the same address

This affects addresses 0xA/0xa through 0xF/0xf (decimal 10-15). Addresses 0x0-0x9 are unaffected as digits have no case.

## Impact Explanation
This is a **Medium severity** issue per Aptos bug bounty criteria ("State inconsistencies requiring intervention"):

- **Indexer Data Incompleteness**: Filters using uppercase special addresses will silently fail to match valid transactions, resulting in incomplete indexed data
- **Application Impact**: Downstream applications relying on filtered transaction streams will miss critical transactions
- **Silent Failure**: No error is raised; filters simply don't match, making this difficult to detect
- **Scope**: Affects any indexer operator or application using uppercase hex letters (A-F) in special address filters

While this doesn't affect consensus, execution, or funds directly, it compromises the integrity of indexed blockchain data, requiring manual intervention to correct filtering configurations.

## Likelihood Explanation
**Likelihood: Medium to High**

- Users commonly write hex addresses in uppercase (e.g., `0xA`, `0xDEADBEEF`)
- Special addresses (0x1 for coin module, 0x3 for token, etc.) are frequently used in filters
- AIP-40 parsing accepts both cases, giving no indication that uppercase won't work
- No validation warnings alert users to case-sensitivity issues
- Tests don't cover uppercase inputs [6](#0-5) 

## Recommendation
Normalize all hex characters to lowercase in `standardize_address()` to match AIP-40 canonical form:

```rust
pub fn standardize_address(address: &str) -> String {
    let trimmed = address.strip_prefix("0x").unwrap_or(address);
    
    if let Some(last_char) = trimmed.chars().last() {
        if trimmed[..trimmed.len().saturating_sub(1)]
            .chars()
            .all(|c| c == '0')
            && last_char.is_ascii_hexdigit()
            && last_char <= 'f'
        {
            let mut result = String::with_capacity(3);
            result.push_str("0x");
            result.push(last_char.to_ascii_lowercase()); // FIX: normalize to lowercase
            return result;
        }
    }
    
    let mut result = String::with_capacity(66);
    result.push_str("0x");
    result.push_str(&ZEROS[..64 - trimmed.len()]);
    result.push_str(&trimmed.to_lowercase()); // FIX: normalize to lowercase
    result
}
```

## Proof of Concept
```rust
#[cfg(test)]
mod test_case_sensitivity_bug {
    use super::*;

    #[test]
    fn test_uppercase_special_address_mismatch() {
        // This demonstrates the bug: uppercase and lowercase don't match
        let uppercase = standardize_address("0xA");
        let lowercase = standardize_address("0xa");
        
        assert_eq!(uppercase, "0xA"); // Currently returns uppercase (BUG)
        assert_eq!(lowercase, "0xa"); // Returns lowercase
        assert_ne!(uppercase, lowercase); // MISMATCH!
        
        // After fix, both should return "0xa"
    }
    
    #[test]
    fn test_filter_mismatch_scenario() {
        // Simulate filter with uppercase address
        let filter_address = "0xF"; // User provides uppercase
        let filter_standardized = standardize_address(filter_address);
        
        // Simulate transaction with lowercase (from AccountAddress)
        let tx_address = "0xf"; // From AccountAddress::to_string()
        let tx_standardized = standardize_address(tx_address);
        
        // This comparison would fail in the matching logic
        assert_ne!(filter_standardized, tx_standardized); // BUG: No match!
    }
}
```

To test with actual AccountAddress behavior:
```rust
use move_core_types::account_address::AccountAddress;

#[test]
fn test_account_address_always_lowercase() {
    let addr = AccountAddress::new([0u8; 31].into_iter().chain([15u8]).collect::<Vec<_>>().try_into().unwrap());
    assert_eq!(addr.to_standard_string(), "0xf"); // Always lowercase
    
    // But if filter has "0xF", it won't match
    assert_ne!(standardize_address("0xF"), addr.to_standard_string());
}
```

**Notes**

This vulnerability only affects the indexer-grpc transaction filtering system, not core consensus or execution. However, it causes real operational issues where filtered indexing becomes unreliable. The fix is straightforward: normalize hex characters to lowercase to align with AIP-40 canonical representation. Additional test coverage should include uppercase hex inputs for all address-handling functions.

### Citations

**File:** ecosystem/indexer-grpc/transaction-filter/src/utils.rs (L10-36)
```rust
pub fn standardize_address(address: &str) -> String {
    // Remove "0x" prefix if it exists
    let trimmed = address.strip_prefix("0x").unwrap_or(address);

    // Check if the address is a special address by seeing if the first 31 bytes are zero and the last byte is smaller than 0b10000
    if let Some(last_char) = trimmed.chars().last() {
        if trimmed[..trimmed.len().saturating_sub(1)]
            .chars()
            .all(|c| c == '0')
            && last_char.is_ascii_hexdigit()
            && last_char <= 'f'
        {
            // Return special addresses in short format
            let mut result = String::with_capacity(3);
            result.push_str("0x");
            result.push(last_char);
            return result;
        }
    }

    // Return non-special addresses in long format
    let mut result = String::with_capacity(66);
    result.push_str("0x");
    result.push_str(&ZEROS[..64 - trimmed.len()]);
    result.push_str(trimmed);
    result
}
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/utils.rs (L42-62)
```rust
    #[test]
    fn test_standardize_special_address() {
        assert_eq!(standardize_address("0x1"), "0x1");
        assert_eq!(standardize_address("0x01"), "0x1");
        assert_eq!(standardize_address("0x001"), "0x1");
        assert_eq!(standardize_address("0x000000001"), "0x1");
        assert_eq!(standardize_address("0xf"), "0xf");
        assert_eq!(standardize_address("0x0f"), "0xf");
        assert_eq!(
            standardize_address(
                "0x0000000000000000000000000000000000000000000000000000000000000001"
            ),
            "0x1"
        );

        assert_eq!(standardize_address("1"), "0x1");
        assert_eq!(
            standardize_address("0000000000000000000000000000000000000000000000000000000000000001"),
            "0x1"
        );
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/convert.rs (L860-861)
```rust
                request: Some(transaction::UserTransactionRequest {
                    sender: ut.request.sender.to_string(),
```

**File:** third_party/move/move-core/types/src/account_address.rs (L101-108)
```rust
    pub fn to_standard_string(&self) -> String {
        let suffix = if self.is_special() {
            self.short_str_lossless()
        } else {
            self.to_canonical_string()
        };
        format!("0x{}", suffix)
    }
```

**File:** third_party/move/move-core/types/src/account_address.rs (L138-145)
```rust
    pub fn short_str_lossless(&self) -> String {
        let hex_str = hex::encode(self.0).trim_start_matches('0').to_string();
        if hex_str.is_empty() {
            "0".to_string()
        } else {
            hex_str
        }
    }
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/filters/user_transaction.rs (L94-98)
```rust
        if let Some(sender_filter) = self.get_standardized_sender() {
            if &standardize_address(&user_request.sender) != sender_filter {
                return false;
            }
        }
```
