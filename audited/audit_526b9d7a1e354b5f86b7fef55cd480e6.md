# Audit Report

## Title
Validator Network Topology Information Disclosure via Peer Monitoring Service

## Summary
The peer monitoring service server exposes all connected peers across all networks without access control or filtering based on the requesting peer's network. If a validator has a public network interface configured, any public peer can request network information and receive details about all the validator's connections, including private validator network peers.

## Finding Description

The vulnerability consists of three interconnected issues:

**1. Server-Side Lack of Access Control:**

The `get_network_information()` function returns all connected peers across all networks without filtering based on the requesting peer's network_id. [1](#0-0) 

The function calls `get_connected_peers_and_metadata()` which iterates through ALL networks and returns ALL connected peers regardless of which network the request originated from. [2](#0-1) 

The `network_id` parameter passed to the handler is only used for metrics tracking, not for access control or response filtering. [3](#0-2) 

**2. Configuration Gap:**

The configuration sanitizer does not explicitly forbid validators from having public networks in their `full_node_networks`. It only prevents `NetworkId::Validator` from being used. [4](#0-3) 

This means a validator could configure a public network interface, which while not following best practices, is not prevented by the sanitizer.

**3. Client-Side Validation Gap:**

The validation logic in `handle_monitoring_service_response()` performs strict network and role validation only for peers at distance 0 and 1 from validators. For distance >= 2, it only validates that the distance is within the maximum allowed bounds. [5](#0-4) 

**Attack Scenario:**
1. A validator misconfigures a public network interface in `full_node_networks` (not prevented by config sanitizer)
2. A malicious public peer connects to the validator's public network
3. The public peer sends a `GetNetworkInformation` request
4. The validator's server responds with ALL connected peers, including private validator network peers with their PeerIds, network addresses, and roles
5. The attacker captures this topology information for reconnaissance

The `NetworkInformationResponse` structure exposes sensitive metadata including peer network addresses, peer IDs, and peer roles. [6](#0-5) 

## Impact Explanation

This is a **LOW severity** information disclosure vulnerability as categorized in the Aptos bug bounty program under "Minor information leaks" (up to $1,000).

**Impact:**
- **Information Leakage**: Exposes validator network topology, including PeerIds and network addresses of validators on the private validator_network
- **Network Reconnaissance**: Enables attackers to map the validator network structure for potential targeted attacks
- **Privacy Violation**: Reveals which validators are connected to each other

**Why Not Higher Severity:**
- Does not directly compromise consensus, funds, or availability
- Does not leak cryptographic keys or authentication credentials
- Does not enable direct attacks on consensus protocol or state integrity
- Requires validator misconfiguration to be exploitable

## Likelihood Explanation

**Likelihood: LOW**

**Factors Increasing Likelihood:**
- No explicit prohibition in config sanitizer against validators having public networks
- Configuration gap allows this setup without warnings

**Factors Decreasing Likelihood:**
- Best practices dictate validators should only use VFN networks (`NetworkId::Vfn`) for fullnode connections, as shown in standard validator configurations [7](#0-6) 
- Default validator configurations use VFN networks, not public networks [8](#0-7) 
- Properly configured validators typically don't expose public network interfaces

**Attacker Requirements:**
- Ability to connect to a validator's public network (requires validator misconfiguration)
- No special privileges required
- Simple RPC request to peer monitoring service

## Recommendation

**Fix 1: Implement Server-Side Access Control**

Modify `get_network_information()` to filter connected peers based on the requesting peer's network_id. Only return peers from the same network as the requester, preventing cross-network information leakage.

**Fix 2: Strengthen Configuration Sanitizer**

Add explicit validation in `sanitize_fullnode_network_configs()` to warn or prevent validators from configuring public networks in `full_node_networks`, as this violates security best practices.

**Fix 3: Enhance Client-Side Validation**

Extend the strict network and role validation to all distance levels, not just distance 0 and 1, to ensure consistency checks apply universally.

## Proof of Concept

This vulnerability requires a specific network configuration to demonstrate. The PoC would involve:

1. Configuring a validator with a public network in `full_node_networks`
2. Connecting as a public peer to that network
3. Sending a `PeerMonitoringServiceRequest::GetNetworkInformation` request
4. Observing that the response contains peers from the private validator network

Due to the configuration requirement, this is best validated through code inspection showing the lack of access control in the server implementation and the permissive configuration sanitizer.

---

**Notes:**

This vulnerability represents a **logic flaw** in the peer monitoring service's access control model. While practical exploitation requires validator misconfiguration (which decreases likelihood), the underlying design issue is that the server-side code does not implement network-aware filtering of sensitive information. The configuration sanitizer's permissiveness compounds this by not enforcing security best practices. This qualifies as a valid LOW severity vulnerability under the Aptos bug bounty program's "Minor information leaks" category.

### Citations

**File:** peer-monitoring-service/server/src/lib.rs (L155-173)
```rust
    pub fn call(
        &self,
        network_id: NetworkId,
        request: PeerMonitoringServiceRequest,
    ) -> Result<PeerMonitoringServiceResponse> {
        // Update the request count
        increment_counter(
            &metrics::PEER_MONITORING_REQUESTS_RECEIVED,
            network_id,
            request.get_label(),
        );

        // Time the request processing (the timer will stop when it's dropped)
        let _timer = start_timer(
            &metrics::PEER_MONITORING_REQUEST_PROCESSING_LATENCY,
            network_id,
            request.get_label(),
        );

```

**File:** peer-monitoring-service/server/src/lib.rs (L217-248)
```rust
    fn get_network_information(&self) -> Result<PeerMonitoringServiceResponse, Error> {
        // Get the connected peers
        let connected_peers_and_metadata =
            self.peers_and_metadata.get_connected_peers_and_metadata()?;
        let connected_peers = connected_peers_and_metadata
            .into_iter()
            .map(|(peer, metadata)| {
                let connection_metadata = metadata.get_connection_metadata();
                (
                    peer,
                    ConnectionMetadata::new(
                        connection_metadata.addr,
                        connection_metadata.remote_peer_id,
                        connection_metadata.role,
                    ),
                )
            })
            .collect();

        // Get the distance from the validators
        let distance_from_validators =
            get_distance_from_validators(&self.base_config, self.peers_and_metadata.clone());

        // Create and return the response
        let network_information_response = NetworkInformationResponse {
            connected_peers,
            distance_from_validators,
        };
        Ok(PeerMonitoringServiceResponse::NetworkInformation(
            network_information_response,
        ))
    }
```

**File:** network/framework/src/application/storage.rs (L108-125)
```rust
    pub fn get_connected_peers_and_metadata(
        &self,
    ) -> Result<HashMap<PeerNetworkId, PeerMetadata>, Error> {
        // Get the cached peers and metadata
        let cached_peers_and_metadata = self.cached_peers_and_metadata.load();

        // Collect all connected peers
        let mut connected_peers_and_metadata = HashMap::new();
        for (network_id, peers_and_metadata) in cached_peers_and_metadata.iter() {
            for (peer_id, peer_metadata) in peers_and_metadata.iter() {
                if peer_metadata.is_connected() {
                    let peer_network_id = PeerNetworkId::new(*network_id, *peer_id);
                    connected_peers_and_metadata.insert(peer_network_id, peer_metadata.clone());
                }
            }
        }
        Ok(connected_peers_and_metadata)
    }
```

**File:** config/src/config/config_sanitizer.rs (L128-139)
```rust
    // Check each fullnode network config and ensure uniqueness
    let mut fullnode_network_ids = HashSet::new();
    for fullnode_network_config in fullnode_networks {
        let network_id = fullnode_network_config.network_id;

        // Verify that the fullnode network config is not a validator network config
        if network_id.is_validator_network() {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "Fullnode network configs cannot include a validator network!".into(),
            ));
        }
```

**File:** peer-monitoring-service/client/src/peer_states/network_info.rs (L116-141)
```rust
        // Sanity check the response depth from the peer metadata
        let network_id = peer_network_id.network_id();
        let is_valid_depth = match network_info_response.distance_from_validators {
            0 => {
                // Verify the peer is a validator and has the correct network id
                let peer_is_validator = peer_metadata.get_connection_metadata().role.is_validator();
                let peer_has_correct_network = match self.base_config.role {
                    RoleType::Validator => network_id.is_validator_network(), // We're a validator
                    RoleType::FullNode => network_id.is_vfn_network(),        // We're a VFN
                };
                peer_is_validator && peer_has_correct_network
            },
            1 => {
                // Verify the peer is a VFN and has the correct network id
                let peer_is_vfn = peer_metadata.get_connection_metadata().role.is_vfn();
                let peer_has_correct_network = match self.base_config.role {
                    RoleType::Validator => network_id.is_vfn_network(), // We're a validator
                    RoleType::FullNode => network_id.is_public_network(), // We're a VFN or PFN
                };
                peer_is_vfn && peer_has_correct_network
            },
            distance_from_validators => {
                // The distance must be less than or equal to the max
                distance_from_validators <= MAX_DISTANCE_FROM_VALIDATORS
            },
        };
```

**File:** peer-monitoring-service/types/src/response.rs (L50-75)
```rust
/// A response for the network information request
#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
pub struct NetworkInformationResponse {
    pub connected_peers: BTreeMap<PeerNetworkId, ConnectionMetadata>, // Connected peers
    pub distance_from_validators: u64, // The distance of the peer from the validator set
}

// Display formatting provides a high-level summary of the response
impl Display for NetworkInformationResponse {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "{{ num_connected_peers: {:?}, distance_from_validators: {:?} }}",
            self.connected_peers.len(),
            self.distance_from_validators,
        )
    }
}

/// Simple connection metadata associated with each peer
#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
pub struct ConnectionMetadata {
    pub network_address: NetworkAddress,
    pub peer_id: PeerId,
    pub peer_role: PeerRole,
}
```

**File:** config/src/config/test_data/validator.yaml (L24-38)
```yaml
full_node_networks:
    - listen_address: "/ip4/0.0.0.0/tcp/6181"
      max_outbound_connections: 0
      identity:
          type: "from_storage"
          key_name: "fullnode_network"
          peer_id_name: "owner_account"
          backend:
              type: "vault"
              server: "https://127.0.0.1:8200"
              ca_certificate: "/full/path/to/certificate"
              token:
                  from_disk: "/full/path/to/token"
      network_id:
          private: "vfn"
```

**File:** terraform/helm/aptos-node/files/configs/validator-base.yaml (L27-34)
```yaml
full_node_networks:
  - network_id:
      private: "vfn"
    listen_address: "/ip4/0.0.0.0/tcp/6181"
    identity:
      type: "from_config"
      key: "b0f405a3e75516763c43a2ae1d70423699f34cd68fa9f8c6bb2d67aa87d0af69"
      peer_id: "00000000000000000000000000000000d58bc7bb154b38039bc9096ce04e1237"
```
