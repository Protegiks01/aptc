# Audit Report

## Title
Delayed Field Delta Validation Bypass Enables Performance Degradation Attack in BlockSTM V2

## Summary
A malicious transaction can exploit the delayed field delta application mechanism to force parallel execution failures by crafting deterministic aggregator operations that will overflow/underflow at commit time. This causes unnecessary re-execution and forces the system to fall back to sequential execution, significantly degrading validator performance.

## Finding Description

The vulnerability exists in the BlockSTM V2 execution flow where delayed field (aggregator) delta values are recorded during execution without validation, but only checked during commit. When a malicious transaction deterministically produces deltas that violate bounds, it triggers a flawed error handling path: [1](#0-0) 

During `process_delayed_field_output()`, when `record_change()` encounters an error, it captures `DeltaApplicationFailure` in the read set but allows execution to continue: [2](#0-1) 

The actual delta application and validation occurs later during commit in `try_commit()`: [3](#0-2) 

When delta application fails with overflow/underflow, it returns `CommitError::ReExecutionNeeded`. This triggers re-execution: [4](#0-3) 

However, if the transaction is deterministic and produces the same overflowing delta on re-execution, the second validation failure results in a `code_invariant_error`: [5](#0-4) 

This error halts parallel execution and forces fallback to sequential execution: [6](#0-5) [7](#0-6) 

**Attack Vector**: An attacker crafts a Move transaction that:
1. Creates an aggregator with a maximum limit (e.g., max_value = 100)
2. Applies a delta that will deterministically overflow (e.g., delta = +1000)
3. On every execution (including re-execution), produces the same overflowing delta
4. This forces parallel execution to fail and fall back to sequential execution

## Impact Explanation

**Severity: High** - Validator Node Slowdowns

This vulnerability enables a **performance degradation attack** against validator nodes:

- **Throughput Impact**: Each malicious transaction forces one block to execute sequentially instead of in parallel, reducing throughput from N×speedup to 1×speedup for affected blocks
- **Resource Waste**: Parallel execution resources are consumed before failure, then sequential execution must re-do all work
- **Sustained Attack**: An attacker submitting multiple such transactions per block can sustain performance degradation
- **Validator Impact**: All validators must perform the same fallback, degrading network-wide performance

While this does NOT prevent block finalization (due to the sequential execution fallback), it qualifies as **"Validator node slowdowns"** under the High severity category, as it forces expensive computational overhead and degrades validator performance.

## Likelihood Explanation

**Likelihood: High**

This attack is highly likely to succeed because:

1. **Low Barrier to Entry**: Any transaction sender can submit such a transaction without special privileges
2. **Deterministic Construction**: Easy to craft a deterministic transaction that always overflows (e.g., create aggregator with limit 100, apply delta +1000)
3. **No Pre-execution Validation**: Delta values are not validated during execution, only at commit time
4. **Predictable Behavior**: The error path is deterministic and reliably triggers fallback
5. **No Detection Mechanism**: System treats this as a normal execution failure requiring fallback

The attacker complexity is LOW - requires only basic understanding of Move aggregators and delta operations.

## Recommendation

**Primary Fix**: Add delta validation during execution to fail fast before commit:

In `process_delayed_field_output()`, validate delta bounds before recording:

```rust
fn process_delayed_field_output(
    maybe_output: Option<&E::Output>,
    idx_to_execute: TxnIndex,
    read_set: &mut CapturedReads<...>,
    last_input_output: &TxnLastInputOutput<T, E::Output>,
    versioned_cache: &MVHashMap<...>,
    is_v2: bool,
) -> Result<(), PanicError> {
    // ... existing code ...
    
    if let Some(output) = maybe_output {
        let output_before_guard = output.before_materialization()?;
        for (id, change) in output_before_guard.delayed_field_change_set().into_iter() {
            prev_modified_delayed_fields.remove(&id);
            let entry = change.into_entry_no_additional_history();
            
            // **ADD VALIDATION HERE**
            // Validate delta can be applied to current base value
            if let DelayedEntry::Apply(apply) = &entry {
                if let Err(validation_error) = validate_delta_bounds(
                    &id, 
                    apply, 
                    versioned_cache.delayed_fields()
                ) {
                    // Fail execution early instead of recording invalid delta
                    return Err(code_invariant_error(format!(
                        "Delta validation failed: {:?}", validation_error
                    )));
                }
            }
            
            // ... rest of existing code ...
        }
    }
    // ... rest of existing code ...
}
```

**Secondary Fix**: Add incarnation limit check in `execute_txn_after_commit` to prevent infinite loops: [8](#0-7) 

Add before execution:

```rust
fn execute_txn_after_commit(
    txn: &T,
    auxiliary_info: &A,
    txn_idx: TxnIndex,
    incarnation: Incarnation,
    // ... other params ...
) -> Result<(), PanicError> {
    // **ADD INCARNATION CHECK**
    const MAX_COMMIT_REEXECUTION_INCARNATION: u32 = 2;
    if incarnation > MAX_COMMIT_REEXECUTION_INCARNATION {
        return Err(code_invariant_error(format!(
            "Transaction {} exceeded maximum commit re-executions at incarnation {}",
            txn_idx, incarnation
        )));
    }
    // ... rest of existing code ...
}
```

**Tertiary Fix**: Handle repeated validation failures more gracefully by aborting the transaction instead of returning code_invariant_error:

Replace the code_invariant_error with a proper transaction abort that gets included in the block output.

## Proof of Concept

```move
// File: malicious_aggregator_overflow.move
module attacker::overflow_dos {
    use aptos_framework::aggregator_v2;
    
    /// Attack transaction that always produces overflowing delta
    public entry fun trigger_overflow_attack(attacker: &signer) {
        // Create aggregator with low limit
        let agg = aggregator_v2::create_aggregator(100);
        
        // Read some state to make execution deterministic
        let addr = signer::address_of(attacker);
        
        // Apply delta that will ALWAYS overflow regardless of base value
        // This will succeed during execution but fail at commit
        aggregator_v2::add(&mut agg, 1000);
        
        // Store for persistence (causes commit to attempt delta application)
        move_to(attacker, AggregatorHolder { agg });
    }
    
    struct AggregatorHolder has key {
        agg: aggregator_v2::Aggregator
    }
}
```

**Attack Steps**:
1. Deploy the `overflow_dos` module
2. Submit multiple transactions calling `trigger_overflow_attack` 
3. Each transaction forces parallel execution to fail and fall back to sequential
4. Network throughput degrades proportional to number of malicious transactions per block

**Expected Behavior**: 
- Parallel execution records the delta successfully
- Commit fails with overflow error
- Re-execution produces same delta
- Second commit fails, returns code_invariant_error
- Falls back to sequential execution
- Block throughput reduced significantly

## Notes

**Key Insight**: The vulnerability is NOT that block finalization is prevented (as claimed in the security question), but rather that deterministic delta overflow can be weaponized to force expensive sequential execution fallback, causing performance degradation.

**Invariant Broken**: The system should validate transaction outputs during execution to fail fast, not defer validation to commit time where failures are more expensive. The delayed validation creates an attack surface for performance degradation.

**Mitigation Status**: The `allow_fallback: true` default configuration prevents this from being a Critical severity issue (block finalization prevention), but it remains High severity due to performance impact on validators.

### Citations

**File:** aptos-move/block-executor/src/executor.rs (L358-376)
```rust
                if let Err(e) =
                    versioned_cache
                        .delayed_fields()
                        .record_change(id, idx_to_execute, entry)
                {
                    match e {
                        PanicOr::CodeInvariantError(m) => {
                            return Err(code_invariant_error(format!(
                                "Record change failed with CodeInvariantError: {:?}",
                                m
                            )));
                        },
                        PanicOr::Or(_) => {
                            read_set.capture_delayed_field_read_error(&PanicOr::Or(
                                MVDelayedFieldsError::DeltaApplicationFailure,
                            ));
                        },
                    };
                }
```

**File:** aptos-move/block-executor/src/executor.rs (L444-451)
```rust
        Self::process_delayed_field_output(
            maybe_output,
            idx_to_execute,
            &mut read_set,
            last_input_output,
            versioned_cache,
            true,
        )?;
```

**File:** aptos-move/block-executor/src/executor.rs (L896-916)
```rust
    fn execute_txn_after_commit(
        txn: &T,
        auxiliary_info: &A,
        txn_idx: TxnIndex,
        incarnation: Incarnation,
        scheduler: SchedulerWrapper,
        versioned_cache: &MVHashMap<T::Key, T::Tag, T::Value, DelayedFieldID>,
        last_input_output: &TxnLastInputOutput<T, E::Output>,
        start_shared_counter: u32,
        shared_counter: &AtomicU32,
        executor: &E,
        base_view: &S,
        global_module_cache: &GlobalModuleCache<
            ModuleId,
            CompiledModule,
            Module,
            AptosModuleExtension,
        >,
        runtime_environment: &RuntimeEnvironment,
        block_gas_limit_type: &BlockGasLimitType,
    ) -> Result<(), PanicError> {
```

**File:** aptos-move/block-executor/src/executor.rs (L965-975)
```rust
        if !Self::validate_and_commit_delayed_fields(
            txn_idx,
            versioned_cache,
            last_input_output,
            scheduler.is_v2(),
        )? {
            return Err(code_invariant_error(format!(
                "Delayed field validation after re-execution failed for txn {}",
                txn_idx
            )));
        }
```

**File:** aptos-move/block-executor/src/executor.rs (L1009-1041)
```rust
        if !Self::validate_and_commit_delayed_fields(
            txn_idx,
            versioned_cache,
            last_input_output,
            scheduler.is_v2(),
        )? {
            // Transaction needs to be re-executed, one final time.
            side_effect_at_commit = true;

            scheduler.abort_pre_final_reexecution::<T, E>(
                txn_idx,
                incarnation,
                last_input_output,
                versioned_cache,
            )?;

            Self::execute_txn_after_commit(
                block.get_txn(txn_idx),
                &block.get_auxiliary_info(txn_idx),
                txn_idx,
                incarnation + 1,
                scheduler,
                versioned_cache,
                last_input_output,
                shared_sync_params.start_shared_counter,
                shared_sync_params.delayed_field_id_counter,
                executor,
                shared_sync_params.base_view,
                global_module_cache,
                runtime_environment,
                &self.config.onchain.block_gas_limit_type,
            )?;
        }
```

**File:** aptos-move/block-executor/src/executor.rs (L1778-1799)
```rust
                    if let Err(err) = self.worker_loop_v2(
                        &executor,
                        signature_verified_block,
                        environment,
                        *worker_id,
                        num_workers,
                        &scheduler,
                        &shared_sync_params,
                    ) {
                        // If there are multiple errors, they all get logged: FatalVMError is
                        // logged at construction, below we log CodeInvariantErrors.
                        if let PanicOr::CodeInvariantError(err_msg) = err {
                            alert!(
                                "[BlockSTMv2] worker loop: CodeInvariantError({:?})",
                                err_msg
                            );
                        }
                        shared_maybe_error.store(true, Ordering::SeqCst);

                        // Make sure to halt the scheduler if it hasn't already been halted.
                        scheduler.halt();
                    }
```

**File:** aptos-move/block-executor/src/executor.rs (L2576-2597)
```rust
            // If parallel gave us result, return it
            if let Ok(output) = parallel_result {
                return Ok(output);
            }

            if !self.config.local.allow_fallback {
                panic!("Parallel execution failed and fallback is not allowed");
            }

            // All logs from the parallel execution should be cleared and not reported.
            // Clear by re-initializing the speculative logs.
            init_speculative_logs(signature_verified_block.num_txns() + 1);

            // Flush all caches to re-run from the "clean" state.
            module_cache_manager_guard
                .environment()
                .runtime_environment()
                .flush_all_caches();
            module_cache_manager_guard.module_cache_mut().flush();

            info!("parallel execution requiring fallback");
        }
```

**File:** aptos-move/mvhashmap/src/versioned_delayed_fields.rs (L580-595)
```rust
                VersionEntry::Apply(AggregatorDelta { delta }) => {
                    let prev_value = versioned_value.read_latest_predicted_value(idx_to_commit)
                        .map_err(|e| CommitError::CodeInvariantError(format!("Cannot read latest committed value for Apply(AggregatorDelta) during commit: {:?}", e)))?;
                    if let DelayedFieldValue::Aggregator(base) = prev_value {
                        let new_value = delta.apply_to(base).map_err(|e| {
                            CommitError::ReExecutionNeeded(format!(
                                "Failed to apply delta to base: {:?}",
                                e
                            ))
                        })?;
                        Some(DelayedFieldValue::Aggregator(new_value))
                    } else {
                        return Err(CommitError::CodeInvariantError(
                            "Cannot apply delta to non-DelayedField::Aggregator".to_string(),
                        ));
                    }
```
