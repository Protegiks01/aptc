# Audit Report

## Title
Silent Backup Data Loss Due to Ignored Error in BytesSender::finish() Call

## Summary
The `abort_on_error` wrapper function in the backup service explicitly ignores errors returned by `BytesSender::finish()`, which can result in the final chunk of backup data (up to 10KB) being silently lost when the HTTP client disconnects or the response stream is dropped. This creates incomplete backups with no error indication, violating backup integrity guarantees.

## Finding Description

The backup service uses a `BytesSender` struct to buffer and stream backup data over HTTP. When a backup operation completes successfully, the `finish()` method is called to flush any remaining buffered data. However, the caller of this method intentionally suppresses any errors that occur. [1](#0-0) 

The explicit comment on line 74 confirms this design: `// ignore error from finish() and abort()`. The result is assigned to `_res` (underscore-prefixed to indicate intentional discard) and never checked or logged.

The `finish()` method properly propagates errors from `flush_buffer()`: [2](#0-1) 

And `flush_buffer()` can fail when sending through the channel: [3](#0-2) 

The `send_res()` method returns an error if the channel receiver has been dropped: [4](#0-3) 

**Attack Scenario:**
1. An operator initiates a backup of state snapshot, transactions, or epoch-ending ledger infos
2. The backup handler iterates through records, buffering them in 10KB chunks
3. During the final phase, less than 10KB of data remains in the buffer
4. The HTTP client disconnects (network interruption, client crash, or attacker-induced connection drop)
5. The channel receiver is dropped, closing the mpsc channel
6. `finish()` attempts to flush the final buffer via `send_res()`
7. `blocking_send()` fails with error "Failed to send to response stream"
8. The error is suppressed by `abort_on_error`, assigned to `_res` and discarded
9. The backup task completes without any error indication
10. The final chunk of backup data (potentially hundreds of records) is permanently lost
11. No logs, metrics, or alerts indicate the incomplete backup

This affects all streaming backup endpoints: [5](#0-4) 

## Impact Explanation

**Medium Severity** - This meets the Aptos bug bounty criterion for "State inconsistencies requiring intervention":

1. **Data Loss**: Up to 10KB (production) of backup data can be silently lost per backup operation
2. **Silent Failure**: No error propagation, logging, or monitoring indicates the incomplete backup
3. **False Confidence**: Operators believe backups are complete when they are corrupted
4. **Disaster Recovery Risk**: Incomplete backups may fail during critical restoration scenarios
5. **Scope**: Affects state snapshots, transaction backups, and epoch-ending ledger infos - all critical for node recovery

While this doesn't directly affect consensus or cause fund loss, it undermines the reliability of the backup system, which is essential for disaster recovery and network resilience.

## Likelihood Explanation

**Moderate to High Likelihood:**

1. **Common Trigger**: Network disconnections during backup operations are common in production environments
2. **Timing Window**: Any disconnect in the final moments of a backup (between iteration completion and `finish()` call) triggers data loss
3. **No Mitigation**: No retry logic, error handling, or validation checks exist to detect or recover from this condition
4. **Production Impact**: Under unreliable network conditions or high load, this could occur regularly
5. **Attacker Amplification**: An adversary with network-level access (MitM position) could deliberately trigger this by timing connection drops

The vulnerability is particularly concerning because it's invisible - operators have no way to know backups are incomplete without manually validating data integrity.

## Recommendation

**Immediate Fix**: Log errors from `finish()` and `abort()` at minimum:

```rust
pub(super) fn abort_on_error<F>(
    f: F,
) -> impl FnOnce(BackupHandler, bytes_sender::BytesSender) + Send + 'static
where
    F: FnOnce(BackupHandler, &mut bytes_sender::BytesSender) -> DbResult<()> + Send + 'static,
{
    move |bh: BackupHandler, mut sender: bytes_sender::BytesSender| {
        let res = match f(bh, &mut sender) {
            Ok(()) => sender.finish(),
            Err(e) => sender.abort(e),
        };
        
        if let Err(e) = res {
            error!("Backup stream completion failed: {:#}", e);
            // Optionally: increment error metric for monitoring
        }
    }
}
```

**Better Fix**: Propagate the error through the stream to signal incomplete backup:

```rust
pub(super) fn abort_on_error<F>(
    f: F,
) -> impl FnOnce(BackupHandler, bytes_sender::BytesSender) + Send + 'static
where
    F: FnOnce(BackupHandler, &mut bytes_sender::BytesSender) -> DbResult<()> + Send + 'static,
{
    move |bh: BackupHandler, mut sender: bytes_sender::BytesSender| {
        match f(bh, &mut sender) {
            Ok(()) => {
                if let Err(e) = sender.finish() {
                    error!("Failed to finish backup stream: {:#}", e);
                    let _ = sender.abort(e);
                }
            },
            Err(e) => {
                let _ = sender.abort(e);
            }
        };
    }
}
```

## Proof of Concept

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use tokio::sync::mpsc;
    
    #[tokio::test]
    async fn test_finish_error_suppression() {
        // Create BytesSender with channel
        let (sender, mut stream) = BytesSender::new("test_endpoint");
        
        // Drop the receiver to close the channel
        drop(stream);
        
        // Add data to buffer
        let mut sender = sender;
        sender.send_bytes(bytes::Bytes::from("test data")).unwrap();
        
        // Call finish() - this should fail because receiver is dropped
        // but abort_on_error would suppress this error
        let result = sender.finish();
        
        // Verify the error exists (it would be suppressed in abort_on_error)
        assert!(result.is_err());
        assert!(result.unwrap_err().to_string().contains("Failed to send to response stream"));
        
        println!("POC: finish() returns error when receiver dropped, but abort_on_error suppresses it");
    }
    
    #[tokio::test]
    async fn test_data_loss_scenario() {
        use tokio::sync::mpsc;
        use tokio_stream::StreamExt;
        
        let (sender, mut stream) = BytesSender::new("test_endpoint");
        
        // Simulate backup operation in separate task
        let handle = tokio::spawn(async move {
            let mut sender = sender;
            
            // Send first chunk (will succeed)
            for i in 0..100 {
                sender.send_size_prefixed_bcs_bytes(&format!("record_{}", i)).unwrap();
            }
            
            // Simulate client disconnect here by dropping stream on main thread
            tokio::time::sleep(tokio::time::Duration::from_millis(10)).await;
            
            // Try to finish - this will fail silently in production
            sender.finish()
        });
        
        // Receive some data, then drop the stream (simulating disconnect)
        let first_chunk = stream.next().await;
        assert!(first_chunk.is_some());
        
        // Drop stream to simulate client disconnect
        drop(stream);
        
        // Wait for backup task to complete
        let result = handle.await.unwrap();
        
        // In production, abort_on_error would suppress this error
        assert!(result.is_err());
        println!("POC: Final buffer data lost when client disconnects before finish()");
    }
}
```

## Notes

The vulnerability exists at the interface between the `BytesSender` implementation and its caller. While `finish()` correctly returns errors, the `abort_on_error` wrapper violates error handling best practices by explicitly suppressing them. This creates a gap in backup integrity validation that could lead to undetected data loss in production environments.

The fix requires minimal code changes but provides significant operational value by making backup failures visible and actionable.

### Citations

**File:** storage/backup/backup-service/src/handlers/utils.rs (L67-80)
```rust
pub(super) fn abort_on_error<F>(
    f: F,
) -> impl FnOnce(BackupHandler, bytes_sender::BytesSender) + Send + 'static
where
    F: FnOnce(BackupHandler, &mut bytes_sender::BytesSender) -> DbResult<()> + Send + 'static,
{
    move |bh: BackupHandler, mut sender: bytes_sender::BytesSender| {
        // ignore error from finish() and abort()
        let _res = match f(bh, &mut sender) {
            Ok(()) => sender.finish(),
            Err(e) => sender.abort(e),
        };
    }
}
```

**File:** storage/backup/backup-service/src/handlers/bytes_sender.rs (L68-73)
```rust
    pub fn flush_buffer(&mut self) -> DbResult<()> {
        let bytes = self.buffer.split().freeze();
        THROUGHPUT_COUNTER.inc_with_by(&[self.endpoint], bytes.len() as u64);

        self.send_res(Ok(bytes))
    }
```

**File:** storage/backup/backup-service/src/handlers/bytes_sender.rs (L75-77)
```rust
    pub fn finish(mut self) -> DbResult<()> {
        self.flush_buffer()
    }
```

**File:** storage/backup/backup-service/src/handlers/bytes_sender.rs (L83-87)
```rust
    pub fn send_res(&self, item: BytesResult) -> DbResult<()> {
        self.bytes_tx
            .blocking_send(item)
            .map_err(|e| AptosDbError::Other(format!("Failed to send to response stream. {e}")))
    }
```

**File:** storage/backup/backup-service/src/handlers/mod.rs (L46-65)
```rust

    // GET state_snapshot/<version>
    let bh = backup_handler.clone();
    let state_snapshot = warp::path!(Version)
        .map(move |version| {
            reply_with_bytes_sender(&bh, STATE_SNAPSHOT, move |bh, sender| {
                bh.get_state_item_iter(version, 0, usize::MAX)?
                    .try_for_each(|record_res| sender.send_size_prefixed_bcs_bytes(record_res?))
            })
        })
        .recover(handle_rejection);

    // GET state_item_count/<version>
    let bh = backup_handler.clone();
    let state_item_count = warp::path!(Version)
        .map(move |version| {
            reply_with_bcs_bytes(
                STATE_ITEM_COUNT,
                &(bh.get_state_item_count(version)? as u64),
            )
```
