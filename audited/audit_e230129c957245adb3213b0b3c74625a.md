# Audit Report

## Title
Hardcoded NotificationFeedback Causes Incorrect Peer Scoring and Penalization for Local System Errors

## Summary
The `handle_error_notification()` function in the state sync driver hardcodes `NotificationFeedback::InvalidPayloadData` for all storage synchronizer errors, regardless of their actual cause. This causes the data streaming service to incorrectly penalize peers for local system failures (such as internal channel send failures or storage commit errors), leading to unfair peer downscoring and potential loss of valid data sources. [1](#0-0) 

## Finding Description
The state sync driver receives error notifications from the storage synchronizer containing various error types wrapped in an `ErrorNotification` structure. These errors can range from peer-caused issues (invalid data, proof failures) to purely local system issues (channel send failures, storage commit errors). [2](#0-1) 

However, the `handle_error_notification()` function at line 502 hardcodes the notification feedback as `NotificationFeedback::InvalidPayloadData` for ALL error types: [3](#0-2) 

Storage synchronizer errors include both peer-caused and local system issues:
- "Failed to notify the committer" - purely local channel issue
- "Failed to notify the commit post-processor" - purely local channel issue  
- "Failed to execute/apply the data chunk" - could be peer-caused OR local
- "Failed to commit executed chunk" - typically local storage issue
- "Failed to update the ledger" - typically local issue [4](#0-3) [5](#0-4) 

This hardcoded `InvalidPayloadData` feedback gets converted through the following chain:
1. `NotificationFeedback::InvalidPayloadData` 
2. → `ResponseError::InvalidData` (via `extract_response_error()`)
3. → `ErrorType::NotUseful` (via `From<ResponseError> for ErrorType`)
4. → 0.95 score multiplier applied to the peer [6](#0-5) [7](#0-6) [8](#0-7) 

When a peer's score drops below 25.0 (the `IGNORE_PEER_THRESHOLD`), they are temporarily ignored and cannot service requests: [9](#0-8) 

**The Critical Flaw:** Peers are being penalized (0.95 multiplier applied) for the local node's internal system failures that have nothing to do with the peer's data quality or behavior. Errors like "Failed to notify the committer" are purely internal channel send failures, yet they trigger peer penalties through the hardcoded feedback mechanism.

## Impact Explanation
This qualifies as **Medium Severity** under the Aptos Bug Bounty criteria: "State inconsistencies requiring intervention."

The incorrect feedback causes:
1. **Unfair Peer Downscoring:** Good peers providing valid data are penalized when the local node experiences internal failures (channel backpressure, storage issues, etc.)
2. **Loss of Valid Data Sources:** Repeated local errors can cause peer scores to drop below 25.0, causing them to be ignored even though they're providing correct data
3. **Degraded State Sync Performance:** The system loses access to valid peers and may struggle to find alternative data sources
4. **Incorrect Peer State:** The global peer scoring state becomes corrupted with penalties that don't reflect actual peer behavior

While this doesn't directly cause fund loss or consensus violations, it creates state inconsistencies in the peer scoring system that require manual intervention or node restarts to resolve, fitting the Medium severity category.

## Likelihood Explanation
**Likelihood: High**

This issue will occur naturally during normal node operation:
1. Storage synchronizer processes thousands of transactions continuously
2. Internal system issues (channel backpressure, temporary storage delays, resource contention) occur regularly in production
3. Each such error incorrectly penalizes the peer that provided the (potentially valid) data
4. Over time, this accumulates and causes good peers to be downscored and eventually ignored

The issue doesn't require any attacker action - it's a natural consequence of the hardcoded feedback mechanism combined with normal system operation under load.

## Recommendation
The driver should inspect the actual error type from the `ErrorNotification` and choose appropriate feedback:

```rust
async fn handle_error_notification(&mut self, error_notification: ErrorNotification) {
    warn!(LogSchema::new(LogEntry::SynchronizerNotification)
        .error_notification(error_notification.clone())
        .message("Received an error notification from the storage synchronizer!"));

    // Determine appropriate feedback based on error type
    let notification_id = error_notification.notification_id;
    let notification_feedback = match &error_notification.error {
        Error::VerificationError(_) => NotificationFeedback::PayloadProofFailed,
        Error::InvalidPayload(_) => NotificationFeedback::InvalidPayloadData,
        // Local system errors should not penalize peers
        Error::CallbackSendFailed(_) | 
        Error::StorageError(_) | 
        Error::UnexpectedError(msg) if msg.contains("Failed to notify") => {
            // For local system errors, terminate stream without peer penalty
            // by not providing feedback (or using a dedicated no-penalty feedback)
            self.reset_streams_without_penalty(notification_id).await;
            return;
        },
        _ => NotificationFeedback::InvalidPayloadData,
    };

    // Terminate the currently active streams with appropriate feedback
    if self.bootstrapper.is_bootstrapped() {
        if let Err(error) = self
            .continuous_syncer
            .handle_storage_synchronizer_error(NotificationAndFeedback::new(
                notification_id,
                notification_feedback,
            ))
            .await
        {
            error!(LogSchema::new(LogEntry::SynchronizerNotification)
                .message(&format!(
                    "Failed to terminate the active stream for the continuous syncer! Error: {:?}",
                    error
                )));
        }
    } else if let Err(error) = self
        .bootstrapper
        .handle_storage_synchronizer_error(NotificationAndFeedback::new(
            notification_id,
            notification_feedback,
        ))
        .await
    {
        error!(
            LogSchema::new(LogEntry::SynchronizerNotification).message(&format!(
                "Failed to terminate the active stream for the bootstrapper! Error: {:?}",
                error
            ))
        );
    };
}
```

Alternatively, the storage synchronizer should be modified to distinguish between peer-caused errors and local system errors, sending different notification types accordingly.

## Proof of Concept
A proof of concept would involve:

1. Setting up a state sync driver with instrumentation
2. Simulating channel backpressure or storage delays to trigger "Failed to notify" errors
3. Observing that peers providing valid data receive score penalties (0.95 multiplier)
4. Demonstrating that repeated local errors cause peer scores to drop below 25.0
5. Verifying that these peers are then ignored for subsequent requests

```rust
// Pseudo-test demonstrating the issue
#[tokio::test]
async fn test_local_error_incorrectly_penalizes_peer() {
    // Setup: Create driver with peer at score 30.0 (close to ignore threshold)
    let peer = create_test_peer_with_score(30.0);
    
    // Simulate storage synchronizer sending error for internal failure
    let error = Error::UnexpectedError("Failed to notify the committer: channel full".into());
    let notification = ErrorNotification {
        error,
        notification_id: test_notification_id(),
    };
    
    // Driver processes the error with hardcoded InvalidPayloadData feedback
    driver.handle_error_notification(notification).await;
    
    // Assert: Peer score is reduced even though error was local
    assert!(peer.get_score() < 30.0); // Score reduced to ~28.5
    
    // After a few more local errors, peer is ignored
    for _ in 0..5 {
        driver.handle_error_notification(create_local_error()).await;
    }
    
    assert!(peer.get_score() < 25.0); // Below ignore threshold
    assert!(peer.is_ignored()); // Peer now ignored despite providing valid data
}
```

**Notes:**
The vulnerability demonstrates a clear design flaw where the system incorrectly attributes blame for internal failures to external peers, violating the principle that peer scoring should reflect peer behavior. This causes the data streaming service to make wrong decisions about peer selection and availability.

### Citations

**File:** state-sync/state-sync-driver/src/driver.rs (L495-533)
```rust
    async fn handle_error_notification(&mut self, error_notification: ErrorNotification) {
        warn!(LogSchema::new(LogEntry::SynchronizerNotification)
            .error_notification(error_notification.clone())
            .message("Received an error notification from the storage synchronizer!"));

        // Terminate the currently active streams
        let notification_id = error_notification.notification_id;
        let notification_feedback = NotificationFeedback::InvalidPayloadData;
        if self.bootstrapper.is_bootstrapped() {
            if let Err(error) = self
                .continuous_syncer
                .handle_storage_synchronizer_error(NotificationAndFeedback::new(
                    notification_id,
                    notification_feedback,
                ))
                .await
            {
                error!(LogSchema::new(LogEntry::SynchronizerNotification)
                    .message(&format!(
                        "Failed to terminate the active stream for the continuous syncer! Error: {:?}",
                        error
                    )));
            }
        } else if let Err(error) = self
            .bootstrapper
            .handle_storage_synchronizer_error(NotificationAndFeedback::new(
                notification_id,
                notification_feedback,
            ))
            .await
        {
            error!(
                LogSchema::new(LogEntry::SynchronizerNotification).message(&format!(
                    "Failed to terminate the active stream for the bootstrapper! Error: {:?}",
                    error
                ))
            );
        };
    }
```

**File:** state-sync/state-sync-driver/src/notification_handlers.rs (L470-474)
```rust
#[derive(Clone, Debug, Serialize)]
pub struct ErrorNotification {
    pub error: Error,
    pub notification_id: NotificationId,
}
```

**File:** state-sync/state-sync-driver/src/storage_synchronizer.rs (L653-668)
```rust
                    if let Err(error) = send_and_monitor_backpressure(
                        &mut committer_notifier,
                        metrics::STORAGE_SYNCHRONIZER_COMMITTER,
                        notification_metadata,
                    )
                    .await
                    {
                        // Send an error notification to the driver (we failed to notify the committer)
                        let error = format!("Failed to notify the committer! Error: {:?}", error);
                        handle_storage_synchronizer_error(
                            notification_metadata,
                            error,
                            &error_notification_sender,
                            &pending_data_chunks,
                        )
                        .await;
```

**File:** state-sync/state-sync-driver/src/storage_synchronizer.rs (L743-761)
```rust
                    if let Err(error) = send_and_monitor_backpressure(
                        &mut commit_post_processor_notifier,
                        metrics::STORAGE_SYNCHRONIZER_COMMIT_POST_PROCESSOR,
                        notification,
                    )
                    .await
                    {
                        // Send an error notification to the driver (we failed to notify the commit post-processor)
                        let error = format!(
                            "Failed to notify the commit post-processor! Error: {:?}",
                            error
                        );
                        handle_storage_synchronizer_error(
                            notification_metadata,
                            error,
                            &error_notification_sender,
                            &pending_data_chunks,
                        )
                        .await;
```

**File:** state-sync/data-streaming-service/src/data_stream.rs (L1383-1395)
```rust
fn extract_response_error(
    notification_feedback: &NotificationFeedback,
) -> Result<ResponseError, Error> {
    match notification_feedback {
        NotificationFeedback::InvalidPayloadData => Ok(ResponseError::InvalidData),
        NotificationFeedback::PayloadTypeIsIncorrect => Ok(ResponseError::InvalidPayloadDataType),
        NotificationFeedback::PayloadProofFailed => Ok(ResponseError::ProofVerificationError),
        _ => Err(Error::UnexpectedErrorEncountered(format!(
            "Invalid notification feedback given: {:?}",
            notification_feedback
        ))),
    }
}
```

**File:** state-sync/aptos-data-client/src/peer_states.rs (L54-63)
```rust
impl From<ResponseError> for ErrorType {
    fn from(error: ResponseError) -> Self {
        match error {
            ResponseError::InvalidData | ResponseError::InvalidPayloadDataType => {
                ErrorType::NotUseful
            },
            ResponseError::ProofVerificationError => ErrorType::Malicious,
        }
    }
}
```

**File:** state-sync/aptos-data-client/src/peer_states.rs (L151-160)
```rust
    /// Returns true iff the peer is currently ignored
    fn is_ignored(&self) -> bool {
        // Only ignore peers if the config allows it
        if !self.data_client_config.ignore_low_score_peers {
            return false;
        }

        // Otherwise, ignore peers with a low score
        self.score <= IGNORE_PEER_THRESHOLD
    }
```

**File:** state-sync/aptos-data-client/src/peer_states.rs (L167-174)
```rust
    /// Updates the score of the peer according to an error
    fn update_score_error(&mut self, error: ErrorType) {
        let multiplier = match error {
            ErrorType::NotUseful => NOT_USEFUL_MULTIPLIER,
            ErrorType::Malicious => MALICIOUS_MULTIPLIER,
        };
        self.score = f64::max(self.score * multiplier, MIN_SCORE);
    }
```
