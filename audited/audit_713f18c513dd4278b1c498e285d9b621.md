# Audit Report

## Title
Indexer Gap Detection Mechanism Exists But Is Never Invoked, Allowing Silent Transaction Skipping

## Summary
The Aptos indexer contains a sophisticated gap detection mechanism (`get_start_version_long`) that can identify missing transactions within a configurable lookback window, but this code is never called by the runtime. Instead, the system uses `get_start_version` which blindly returns `last_success_version + 1` without any gap checking. When the `last_success_version` jumps (via `STARTING_VERSION` configuration or manual database modification), missing transactions in the gap are silently skipped and never indexed.

## Finding Description
The indexer system tracks processed versions in the `processor_status` table using the `ProcessorStatusV2` model. On startup, the runtime determines where to resume indexing by calling `get_start_version`: [1](#0-0) 

This method simply returns `last_success_version + 1`: [2](#0-1) 

However, there exists a more sophisticated method `get_start_version_long` with comprehensive gap detection logic using SQL queries: [3](#0-2) 

This gap detection code is **never invoked** in the codebase. The runtime extracts the `gap_lookback_versions` configuration but never uses it for actual gap detection: [4](#0-3) 

**Attack Vector:**

An operator can force the indexer to skip transactions by:

1. Setting the `STARTING_VERSION` environment variable to jump ahead: [5](#0-4) 

2. Manually updating the `processor_status` table to set `last_success_version` to a higher value

When the indexer restarts, it will begin processing from the new version without detecting or reporting the gap. The code comment incorrectly assumes gaps would cause panics: [6](#0-5) 

However, no such validation exists in the transaction processing pipeline: [7](#0-6) 

## Impact Explanation
This qualifies as **Medium Severity** per the Aptos bug bounty criteria: "State inconsistencies requiring intervention."

The impact includes:

1. **Silent Data Loss**: Transactions in gaps are never indexed, creating incomplete historical records
2. **Incorrect Application State**: Wallets, block explorers, and dApps relying on indexer data will show incorrect balances, missing NFT transfers, and incomplete event histories
3. **Financial Risk**: Users may make decisions based on incomplete data (e.g., selling an NFT they don't actually own according to the indexer)
4. **Operational Overhead**: Detecting and recovering from gaps requires manual database inspection and re-indexing

While this doesn't affect blockchain consensus or validator operations, the indexer is critical infrastructure that many ecosystem applications depend on for accurate historical data.

## Likelihood Explanation
**Likelihood: Medium to High**

Scenarios where gaps occur:

1. **Operational Error**: An operator setting `STARTING_VERSION` to skip problematic transactions without realizing gaps won't be detected
2. **Database Manipulation**: Accidental or intentional updates to `processor_status` during maintenance
3. **Configuration Mistakes**: Misunderstanding that the gap detection code exists but isn't used

The vulnerability is not actively exploited maliciously, but operational errors leading to gaps are realistic given the configuration options available.

## Recommendation

**Immediate Fix**: Replace `get_start_version` with `get_start_version_long` in the runtime:

```rust
// In runtime.rs, line 163-172, change from:
let starting_version_from_db_short = tailer
    .get_start_version(&processor_name)
    // ... 

// To:
let starting_version_from_db = tailer
    .get_start_version_long(&processor_name, lookback_versions)
    .unwrap_or_else(|| {
        info!(
            processor_name = processor_name,
            "No starting version from db so starting from version 0"
        );
        0
    }) as u64;
```

**Additional Safeguards**:

1. Add validation in `process_transactions` to verify sequential versions within batches
2. Log warnings when `STARTING_VERSION` is set to a value that creates a gap
3. Add metrics to track gap detection events
4. Consider deprecating `get_start_version` entirely to prevent future misuse

## Proof of Concept

**Reproduction Steps:**

```bash
# Step 1: Start indexer and let it process some transactions
export INDEXER_DATABASE_URL="postgresql://user:pass@localhost/indexer"
export PROCESSOR_NAME="default_processor"
# Indexer processes transactions 0-1000

# Step 2: Stop the indexer
# Current state: processor_status.last_success_version = 1000

# Step 3: Force a jump by setting STARTING_VERSION
export STARTING_VERSION="2000"

# Step 4: Restart the indexer
# Indexer will start from version 2000
# Transactions 1001-1999 are NEVER processed
# No error, no warning, silent gap

# Step 5: Verify gap exists
psql $INDEXER_DATABASE_URL -c "
SELECT COUNT(*) FROM transactions 
WHERE version >= 1001 AND version <= 1999;
"
# Result: 0 rows (gap confirmed)

# Step 6: Verify get_start_version_long would have detected this
psql $INDEXER_DATABASE_URL -c "
SELECT processor, last_success_version FROM processor_status;
"
# Shows: last_success_version = 2000+
# But versions 1001-1999 don't exist in the database
```

The gap detection SQL in `get_start_version_long` would have returned version 1001 as the start point, but since it's never called, the gap goes unnoticed.

## Notes

The vulnerability is confirmed by verifying that `get_start_version_long` appears only once in the codebase (its definition) and is never called: [8](#0-7) 

This represents a regression where gap detection was implemented but integration was never completed, leaving the indexer vulnerable to silent data loss through version skipping.

### Citations

**File:** crates/indexer/src/runtime.rs (L115-115)
```rust
    let lookback_versions = config.gap_lookback_versions.unwrap() as i64;
```

**File:** crates/indexer/src/runtime.rs (L163-172)
```rust
    let starting_version_from_db_short = tailer
        .get_start_version(&processor_name)
        .unwrap_or_else(|e| panic!("Failed to get starting version: {:?}", e))
        .unwrap_or_else(|| {
            info!(
                processor_name = processor_name,
                "No starting version from db so starting from version 0"
            );
            0
        }) as u64;
```

**File:** crates/indexer/src/runtime.rs (L173-176)
```rust
    let start_version = match config.starting_version {
        None => starting_version_from_db_short,
        Some(version) => version,
    };
```

**File:** crates/indexer/src/indexer/tailer.rs (L168-169)
```rust
    /// Store last processed version from database. We can assume that all previously processed
    /// versions are successful because any gap would cause the processor to panic
```

**File:** crates/indexer/src/indexer/tailer.rs (L194-201)
```rust
    pub fn get_start_version(&self, processor_name: &String) -> Result<Option<i64>> {
        let mut conn = self.connection_pool.get()?;

        match ProcessorStatusV2Query::get_by_processor(processor_name, &mut conn)? {
            Some(status) => Ok(Some(status.last_success_version + 1)),
            None => Ok(None),
        }
    }
```

**File:** crates/indexer/src/indexer/tailer.rs (L205-288)
```rust
    pub fn get_start_version_long(
        &self,
        processor_name: &String,
        lookback_versions: i64,
    ) -> Option<i64> {
        let mut conn = self
            .connection_pool
            .get()
            .expect("DB connection should be available to get starting version");

        // This query gets the first version that isn't equal to the next version (versions would be sorted of course).
        // There's also special handling if the gap happens in the beginning.
        let sql = "
        WITH raw_boundaries AS
        (
            SELECT
                MAX(version) AS MAX_V,
                MIN(version) AS MIN_V
            FROM
                processor_statuses
            WHERE
                name = $1
                AND success = TRUE
        ),
        boundaries AS
        (
            SELECT
                MAX(version) AS MAX_V,
                MIN(version) AS MIN_V
            FROM
                processor_statuses, raw_boundaries
            WHERE
                name = $1
                AND success = true
                and version >= GREATEST(MAX_V - $2, 0)
        ),
        gap AS
        (
            SELECT
                MIN(version) + 1 AS maybe_gap
            FROM
                (
                    SELECT
                        version,
                        LEAD(version) OVER (
                    ORDER BY
                        version ASC) AS next_version
                    FROM
                        processor_statuses,
                        boundaries
                    WHERE
                        name = $1
                        AND success = TRUE
                        AND version >= GREATEST(MAX_V - $2, 0)
                ) a
            WHERE
                version + 1 <> next_version
        )
        SELECT
            CASE
                WHEN
                    MIN_V <> GREATEST(MAX_V - $2, 0)
                THEN
                    GREATEST(MAX_V - $2, 0)
                ELSE
                    COALESCE(maybe_gap, MAX_V + 1)
            END
            AS version
        FROM
            gap, boundaries
        ";
        #[derive(Debug, QueryableByName)]
        pub struct Gap {
            #[diesel(sql_type = BigInt)]
            pub version: i64,
        }
        let mut res: Vec<Option<Gap>> = sql_query(sql)
            .bind::<Text, _>(processor_name)
            // This is the number used to determine how far we look back for gaps. Increasing it may result in slower startup
            .bind::<BigInt, _>(lookback_versions)
            .get_results(&mut conn)
            .unwrap();
        res.pop().unwrap().map(|g| g.version)
    }
```

**File:** crates/indexer/src/processors/default_processor.rs (L478-483)
```rust
    async fn process_transactions(
        &self,
        transactions: Vec<Transaction>,
        start_version: u64,
        end_version: u64,
    ) -> Result<ProcessingResult, TransactionProcessingError> {
```
