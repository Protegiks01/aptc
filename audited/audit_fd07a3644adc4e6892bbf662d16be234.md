# Audit Report

## Title
Indexer Query Atomicity Violation: Incomplete Results Due to Index-Specific Version Mismatch

## Summary
The indexer reader performs non-atomic multi-database operations where the version coverage check uses a global `LatestVersion` metadata field, but individual index types (events, transactions, state keys) maintain separate version metadata that may lag behind. This allows queries to proceed and return incomplete results when the requested `ledger_version` exceeds the actual coverage of the specific index being queried.

## Finding Description

The indexer maintains separate version metadata for different index types:
- `LatestVersion` - always updated during batch processing
- `EventVersion` - only updated when `enable_event = true`
- `TransactionVersion` - only updated when `enable_transaction = true`  
- `StateVersion` - only updated when `enable_statekeys = true` [1](#0-0) 

All query functions use `ensure_cover_ledger_version()` which checks only `LatestVersion`: [2](#0-1) [3](#0-2) 

However, queries access index-specific data without verifying the index-specific version. For example, `get_events_by_event_key` checks `LatestVersion` but reads from the event index: [4](#0-3) 

**Attack Scenario:**
1. Node operator starts indexer with `enable_event = false`
2. Indexer processes versions 0-1000, setting `LatestVersion = 1000` (but `EventVersion` is not set/updated)
3. Node operator changes configuration to `enable_event = true` and restarts
4. Indexer processes versions 1001-2000, setting both `EventVersion = 2000` and `LatestVersion = 2000`
5. Client queries events at `ledger_version = 1500`
6. `ensure_cover_ledger_version(1500)` passes because `LatestVersion = 2000 >= 1500`
7. Query returns only events from versions 1001-1500, **missing all events from versions 0-1000**

This violates the State Consistency invariant: queries spanning multiple database operations are not atomic and can return partial results from inconsistent states.

## Impact Explanation

**Severity: High** (up to $50,000 per Aptos Bug Bounty)

This vulnerability causes **state inconsistencies requiring intervention**:

1. **Incomplete Query Results**: Clients requesting data at a specific ledger version receive partial/incomplete results without error indication
2. **Application Logic Failures**: Applications relying on complete event history (e.g., token transfers, governance votes, staking operations) will have incorrect state
3. **Financial Impact**: Missing transfer events could lead to incorrect balance calculations or lost funds tracking
4. **Data Integrity Violation**: Breaks the fundamental guarantee that queries at `ledger_version` L provide a complete, consistent point-in-time snapshot

Affected queries:
- `get_events` / `get_events_by_event_key` (event index)
- `get_account_ordered_transactions` (transaction index)  
- `get_prefixed_state_value_iterator` (state keys index) [5](#0-4) [6](#0-5) 

## Likelihood Explanation

**Likelihood: Medium-High**

This issue is highly likely to occur in production environments because:

1. **Common Operational Pattern**: Node operators frequently start with minimal indexing enabled for faster initial sync, then enable additional indices later
2. **Configuration-Driven**: The vulnerability is triggered by normal configuration changes, not malicious input
3. **No Warning**: The system provides no indication that queries are returning incomplete results
4. **Default State**: All indices are disabled by default, meaning any node that enables indices after initial sync is vulnerable [7](#0-6) 

The vulnerability requires no attacker sophisticationâ€”it occurs through normal node operations.

## Recommendation

Replace the generic `ensure_cover_ledger_version()` check with index-specific version checks. Each query function should verify that the relevant index has been built up to the requested `ledger_version`:

**For event queries:**
```rust
pub fn get_events_by_event_key(..., ledger_version: Version) -> Result<...> {
    // Check event-specific version instead of LatestVersion
    let event_version = self.indexer_db.get_event_version()?;
    ensure!(
        event_version.map_or(false, |v| v >= ledger_version),
        "Event index not synced to requested ledger_version"
    );
    // ... rest of query
}
```

**For transaction queries:**
```rust
pub fn get_account_ordered_transactions(..., ledger_version: Version) -> Result<...> {
    let txn_version = self.indexer_db.get_transaction_version()?;
    ensure!(
        txn_version.map_or(false, |v| v >= ledger_version),
        "Transaction index not synced to requested ledger_version"
    );
    // ... rest of query
}
```

**For state key queries:**
```rust
pub fn get_prefixed_state_value_iterator(..., ledger_version: Version) -> Result<...> {
    let state_version = self.indexer_db.get_state_version()?;
    ensure!(
        state_version.map_or(false, |v| v >= ledger_version),
        "State keys index not synced to requested ledger_version"
    );
    // ... rest of query
}
```

## Proof of Concept

```rust
#[test]
fn test_incomplete_event_query_after_enabling_indexing() {
    // Setup: Create indexer with events disabled
    let mut config = InternalIndexerDBConfig::default();
    config.enable_event = false;
    config.enable_transaction = true; // Other index enabled
    
    let indexer_db = InternalIndexerDB::new(db.clone(), config);
    let indexer = DBIndexer::new(indexer_db, main_db_reader.clone());
    
    // Process versions 0-100 without event indexing
    indexer.process(0, 101).unwrap();
    
    // Verify LatestVersion = 100 but EventVersion is None
    assert_eq!(indexer.indexer_db.get_persisted_version().unwrap(), Some(100));
    assert_eq!(indexer.indexer_db.get_event_version().unwrap(), None);
    
    // Enable event indexing
    let mut config = InternalIndexerDBConfig::default();
    config.enable_event = true;
    indexer.indexer_db.config = config;
    
    // Process versions 101-200 with event indexing
    indexer.process(101, 201).unwrap();
    
    // Verify EventVersion = 200 and LatestVersion = 200
    assert_eq!(indexer.indexer_db.get_persisted_version().unwrap(), Some(200));
    assert_eq!(indexer.indexer_db.get_event_version().unwrap(), Some(200));
    
    // Query events at ledger_version = 150 (before event indexing was enabled)
    let event_key = create_test_event_key();
    let result = indexer.get_events_by_event_key(
        &event_key,
        0,
        Order::Ascending,
        200,
        150, // ledger_version in the gap
    );
    
    // BUG: Query succeeds even though events for versions 0-100 were never indexed
    assert!(result.is_ok());
    let events = result.unwrap();
    
    // Events from versions 0-100 are missing (should have been indexed but weren't)
    // Only events from 101-150 are returned, leading to incomplete results
    assert!(events.len() < expected_event_count_for_version_range(0, 150));
}
```

**Notes**

This vulnerability represents a fundamental flaw in the indexer's atomicity guarantees. The separation of index-specific version metadata from the global version check creates a TOCTOU (Time-Of-Check-Time-Of-Use) vulnerability where the coverage assertion (`ensure_cover_ledger_version`) is decoupled from the actual data coverage of the index being queried.

The issue is particularly insidious because:
1. It produces no errors or warnings
2. Results appear valid but are silently incomplete
3. It can affect historical queries long after the configuration change
4. Different nodes with different indexing histories will return different results for the same query

This breaks the critical State Consistency invariant and can lead to non-deterministic behavior across the network if different nodes have different indexing histories.

### Citations

**File:** storage/indexer/src/db_indexer.rs (L110-112)
```rust
    pub fn get_persisted_version(&self) -> Result<Option<Version>> {
        self.get_version(&MetadataKey::LatestVersion)
    }
```

**File:** storage/indexer/src/db_indexer.rs (L163-172)
```rust
    pub fn ensure_cover_ledger_version(&self, ledger_version: Version) -> Result<()> {
        let indexer_latest_version = self.get_persisted_version()?;
        if let Some(indexer_latest_version) = indexer_latest_version {
            if indexer_latest_version >= ledger_version {
                return Ok(());
            }
        }

        bail!("ledger version too new")
    }
```

**File:** storage/indexer/src/db_indexer.rs (L524-545)
```rust
        if self.indexer_db.transaction_enabled() {
            batch.put::<InternalIndexerMetadataSchema>(
                &MetadataKey::TransactionVersion,
                &MetadataValue::Version(version - 1),
            )?;
        }
        if self.indexer_db.event_enabled() {
            batch.put::<InternalIndexerMetadataSchema>(
                &MetadataKey::EventVersion,
                &MetadataValue::Version(version - 1),
            )?;
        }
        if self.indexer_db.statekeys_enabled() {
            batch.put::<InternalIndexerMetadataSchema>(
                &MetadataKey::StateVersion,
                &MetadataValue::Version(version - 1),
            )?;
        }
        batch.put::<InternalIndexerMetadataSchema>(
            &MetadataKey::LatestVersion,
            &MetadataValue::Version(version - 1),
        )?;
```

**File:** storage/indexer/src/db_indexer.rs (L644-653)
```rust
    pub fn get_events_by_event_key(
        &self,
        event_key: &EventKey,
        start_seq_num: u64,
        order: Order,
        limit: u64,
        ledger_version: Version,
    ) -> Result<Vec<EventWithVersion>> {
        self.indexer_db
            .ensure_cover_ledger_version(ledger_version)?;
```

**File:** storage/indexer/src/indexer_reader.rs (L68-90)
```rust
    fn get_events(
        &self,
        event_key: &EventKey,
        start: u64,
        order: Order,
        limit: u64,
        ledger_version: Version,
    ) -> anyhow::Result<Vec<EventWithVersion>> {
        if let Some(db_indexer_reader) = &self.db_indexer_reader {
            if db_indexer_reader.indexer_db.event_enabled() {
                return Ok(db_indexer_reader.get_events(
                    event_key,
                    start,
                    order,
                    limit,
                    ledger_version,
                )?);
            } else {
                anyhow::bail!("Internal event index is not enabled")
            }
        }
        anyhow::bail!("DB Indexer reader is not available")
    }
```

**File:** storage/indexer/src/indexer_reader.rs (L116-138)
```rust
    fn get_account_ordered_transactions(
        &self,
        address: AccountAddress,
        start_seq_num: u64,
        limit: u64,
        include_events: bool,
        ledger_version: Version,
    ) -> anyhow::Result<AccountOrderedTransactionsWithProof> {
        if let Some(db_indexer_reader) = &self.db_indexer_reader {
            if db_indexer_reader.indexer_db.transaction_enabled() {
                return Ok(db_indexer_reader.get_account_ordered_transactions(
                    address,
                    start_seq_num,
                    limit,
                    include_events,
                    ledger_version,
                )?);
            } else {
                anyhow::bail!("Interal transaction by account index is not enabled")
            }
        }
        anyhow::bail!("DB indexer reader is not available")
    }
```

**File:** config/src/config/internal_indexer_db_config.rs (L69-80)
```rust
impl Default for InternalIndexerDBConfig {
    fn default() -> Self {
        Self {
            enable_transaction: false,
            enable_event: false,
            enable_event_v2_translation: false,
            event_v2_translation_ignores_below_version: 0,
            enable_statekeys: false,
            batch_size: 10_000,
        }
    }
}
```
