# Audit Report

## Title
Multiple Network Keys Per Validator Enable Consensus Splitting via DNS/IP Address Duality

## Summary
A malicious validator can publish multiple network addresses with different NoiseIK public keys, causing different validators to connect to different physical hosts. This violates the consensus assumption that all connections to a single validator PeerId reach the same logical entity, enabling consensus splitting attacks.

## Finding Description

The vulnerability exists in how validators publish and authenticate network addresses. While a single `NetworkAddress` cannot contain both DNS and IP protocols (validated at parse time), a validator can publish a `Vec<NetworkAddress>` containing multiple addresses with **different NoiseIK public keys**. [1](#0-0) 

The validation in `from_protocols()` only ensures each individual address has proper structure (network layer → transport layer → session layer → handshake layer), but does NOT prevent multiple addresses with different keys.

When validators update their network addresses via the Move contract, there is no validation that all addresses contain the same NoiseIK key: [2](#0-1) 

The Move function simply accepts `vector<u8>` (BCS-serialized `Vec<NetworkAddress>`) without any key consistency checks.

When the validator set is extracted, all NoiseIK keys from all addresses are collected into a single set: [3](#0-2) 

The `from_addrs()` function extracts ALL NoiseIK keys from the addresses using `find_noise_proto()` and stores them in a `HashSet`.

During connection establishment, validators round-robin through all available addresses: [4](#0-3) 

The `next_addr()` function cycles through addresses using modulo wrapping: [5](#0-4) 

During Noise handshake authentication, any key in the peer's key set is accepted: [6](#0-5) 

The `authenticate_inbound()` function only checks if the remote public key is in the allowed set—it does NOT validate that the key derives to the expected PeerId.

**Attack Scenario:**
1. Malicious validator publishes: `["/dns/evil.com/tcp/6180/noise-ik/<KEY_A>/handshake/1", "/ip4/1.2.3.4/tcp/6180/noise-ik/<KEY_B>/handshake/1"]`
2. Where `evil.com` resolves to `5.6.7.8` (different from `1.2.3.4`)
3. Host at `5.6.7.8` has private key for KEY_A; host at `1.2.3.4` has private key for KEY_B
4. Both keys are added to the peer's allowed key set
5. Different validators connect to different physical hosts based on round-robin timing
6. The attacker can make these hosts behave differently (send different votes, drop messages selectively)
7. This causes validators to have inconsistent views, violating consensus safety

## Impact Explanation

This is **Critical Severity** - it enables consensus safety violations, which can lead to:
- Double-spending via equivocation
- Network partition without Byzantine threshold being reached
- Inconsistent state across validators
- Potential chain splits requiring hard fork to resolve

The attack breaks the fundamental invariant that all connections to a validator PeerId reach the same logical entity. With different validators connected to different physical hosts controlled by the attacker, consensus assumptions are violated even with <1/3 Byzantine validators.

## Likelihood Explanation

**High Likelihood**:
- Any validator can exploit this by calling `update_network_and_fullnode_addresses`
- No special permissions required beyond being a validator operator
- Attack is deterministic and does not require timing exploitation
- DNS resolution naturally provides address ambiguity
- Round-robin address selection ensures validators will connect to different addresses over time
- No monitoring exists to detect this condition

## Recommendation

Add validation to ensure all network addresses for a single validator contain the same NoiseIK public key:

1. **In Move contract** (`stake.move`): Add validation before accepting address updates:
```move
// Validate all addresses have the same NoiseIK key
let addresses: vector<NetworkAddress> = bcs::deserialize(new_network_addresses);
assert!(all_addresses_have_same_key(addresses), EINCONSISTENT_NETWORK_KEYS);
```

2. **In Rust validation** (`config/network_config.rs`): Add a check in `Peer::from_addrs()`:
```rust
pub fn from_addrs(role: PeerRole, addresses: Vec<NetworkAddress>) -> Result<Peer, Error> {
    let keys: HashSet<x25519::PublicKey> = addresses
        .iter()
        .filter_map(NetworkAddress::find_noise_proto)
        .collect();
    
    // Ensure all addresses use the same key
    if keys.len() > 1 {
        return Err(Error::InvariantViolation(
            "All network addresses for a peer must have the same NoiseIK key".to_string()
        ));
    }
    
    Ok(Peer::new(addresses, keys, role))
}
```

3. **Additional safeguard**: In handshake authentication, validate that the public key derives to the expected PeerId for all peers (not just untrusted ones): [7](#0-6) 

This check should be mandatory for all peers to prevent key mismatches.

## Proof of Concept

```rust
// Reproduction steps (pseudo-code for test):

// 1. Create malicious validator with multiple addresses
let key_a = x25519::PrivateKey::generate_for_testing();
let key_b = x25519::PrivateKey::generate_for_testing();

let addr1 = NetworkAddress::from_str(&format!(
    "/dns/malicious.com/tcp/6180/noise-ik/{}/handshake/1",
    key_a.public_key().to_encoded_string()
)).unwrap();

let addr2 = NetworkAddress::from_str(&format!(
    "/ip4/1.2.3.4/tcp/6180/noise-ik/{}/handshake/1", 
    key_b.public_key().to_encoded_string()
)).unwrap();

let addrs = vec![addr1, addr2];

// 2. Publish these addresses via stake.move update_network_and_fullnode_addresses
let serialized = bcs::to_bytes(&addrs).unwrap();
// Call stake::update_network_and_fullnode_addresses(operator, pool_addr, serialized, vec![])

// 3. Verify both keys are accepted
let peer = Peer::from_addrs(PeerRole::Validator, addrs);
assert_eq!(peer.keys.len(), 2); // VULNERABILITY: Two different keys accepted!

// 4. Simulate different validators connecting to different addresses
// Validator1 dials addr_idx=0 → connects with key_a to malicious.com (5.6.7.8)
// Validator2 dials addr_idx=1 → connects with key_b to 1.2.3.4
// Both authenticate successfully but reach different physical hosts

// 5. Attacker controls both hosts and makes them send different consensus votes
// Result: Consensus split without reaching Byzantine threshold
```

## Notes

This vulnerability is particularly dangerous because:
1. It bypasses all existing key uniqueness checks (which only validate across validators, not within a validator's addresses)
2. The PeerId is derived from the account address (on-chain), not the network keys, allowing multiple keys per PeerId
3. DNS resolution provides natural address ambiguity that attackers can exploit
4. No runtime monitoring detects when validators connect to different physical hosts for the same logical peer

The fix requires validation at multiple layers: Move contract, Rust configuration parsing, and potentially runtime monitoring to detect inconsistent connections.

### Citations

**File:** types/src/network_address/mod.rs (L263-310)
```rust
    pub fn from_protocols(protocols: Vec<Protocol>) -> Result<Self, ParseError> {
        use Protocol::*;

        let mut iter = protocols.iter();

        let mut p = iter.next();

        if p.is_none() {
            return Ok(Self(protocols));
        }

        if !is_network_layer(p) {
            return Err(ParseError::NetworkLayerMissing);
        }

        if !matches!(p, Some(Memory(_))) {
            p = iter.next();
            if p.is_none() {
                return Ok(Self(protocols));
            }
            if !is_transport_layer(p) {
                return Err(ParseError::TransportLayerMissing);
            }
        }

        p = iter.next();
        if p.is_none() {
            return Ok(Self(protocols));
        }
        if !is_session_layer(p, true) {
            return Err(ParseError::SessionLayerMissing);
        }

        p = iter.next();
        if p.is_none() {
            return Ok(Self(protocols));
        }
        if !is_handshake_layer(p, true) {
            return Err(ParseError::HandshakeLayerMissing);
        }

        p = iter.next();
        if p.is_none() {
            Ok(Self(protocols))
        } else {
            Err(ParseError::RedundantLayer)
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L955-995)
```text
    public entry fun update_network_and_fullnode_addresses(
        operator: &signer,
        pool_address: address,
        new_network_addresses: vector<u8>,
        new_fullnode_addresses: vector<u8>,
    ) acquires StakePool, ValidatorConfig {
        check_stake_permission(operator);
        assert_reconfig_not_in_progress();
        assert_stake_pool_exists(pool_address);
        let stake_pool = borrow_global_mut<StakePool>(pool_address);
        assert!(signer::address_of(operator) == stake_pool.operator_address, error::unauthenticated(ENOT_OPERATOR));
        assert!(exists<ValidatorConfig>(pool_address), error::not_found(EVALIDATOR_CONFIG));
        let validator_info = borrow_global_mut<ValidatorConfig>(pool_address);
        let old_network_addresses = validator_info.network_addresses;
        validator_info.network_addresses = new_network_addresses;
        let old_fullnode_addresses = validator_info.fullnode_addresses;
        validator_info.fullnode_addresses = new_fullnode_addresses;

        if (std::features::module_event_migration_enabled()) {
            event::emit(
                UpdateNetworkAndFullnodeAddresses {
                    pool_address,
                    old_network_addresses,
                    new_network_addresses,
                    old_fullnode_addresses,
                    new_fullnode_addresses,
                },
            );
        } else {
            event::emit_event(
                &mut stake_pool.update_network_and_fullnode_addresses_events,
                UpdateNetworkAndFullnodeAddressesEvent {
                    pool_address,
                    old_network_addresses,
                    new_network_addresses,
                    old_fullnode_addresses,
                    new_fullnode_addresses,
                },
            );
        };
    }
```

**File:** config/src/config/network_config.rs (L498-504)
```rust
    pub fn from_addrs(role: PeerRole, addresses: Vec<NetworkAddress>) -> Peer {
        let keys: HashSet<x25519::PublicKey> = addresses
            .iter()
            .filter_map(NetworkAddress::find_noise_proto)
            .collect();
        Peer::new(addresses, keys, role)
    }
```

**File:** network/framework/src/connectivity_manager/mod.rs (L743-750)
```rust
        // Choose the next addr to dial for this peer. Currently, we just
        // round-robin the selection, i.e., try the sequence:
        // addr[0], .., addr[len-1], addr[0], ..
        let addr = match dial_state.next_addr(&peer.addrs) {
            Some(addr) => addr.clone(),
            None => {
                warn!(
                    NetworkSchema::new(&self.network_context).remote_peer(&peer_id),
```

**File:** network/framework/src/connectivity_manager/mod.rs (L1365-1369)
```rust
    fn next_addr<'a>(&mut self, addrs: &'a Addresses) -> Option<&'a NetworkAddress> {
        let curr_addr = self.get_addr_at_index(self.addr_idx, addrs);
        self.addr_idx = self.addr_idx.wrapping_add(1);
        curr_addr
    }
```

**File:** network/framework/src/noise/handshake.rs (L394-404)
```rust
                        let derived_remote_peer_id =
                            aptos_types::account_address::from_identity_public_key(
                                remote_public_key,
                            );
                        if derived_remote_peer_id != remote_peer_id {
                            // The peer ID is not constructed correctly from the public key
                            Err(NoiseHandshakeError::ClientPeerIdMismatch(
                                remote_peer_short,
                                remote_peer_id,
                                derived_remote_peer_id,
                            ))
```

**File:** network/framework/src/noise/handshake.rs (L488-500)
```rust
    fn authenticate_inbound(
        remote_peer_short: ShortHexStr,
        peer: &Peer,
        remote_public_key: &x25519::PublicKey,
    ) -> Result<PeerRole, NoiseHandshakeError> {
        if !peer.keys.contains(remote_public_key) {
            return Err(NoiseHandshakeError::UnauthenticatedClientPubkey(
                remote_peer_short,
                hex::encode(remote_public_key.as_slice()),
            ));
        }
        Ok(peer.role)
    }
```
