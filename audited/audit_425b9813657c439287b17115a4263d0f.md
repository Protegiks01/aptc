# Audit Report

## Title
Missing Vary: Accept Header in API Responses Enables Cache Poisoning Attack

## Summary
The Aptos Node API implements content negotiation to serve responses in either JSON (`application/json`) or BCS (`application/x-bcs`) format based on the client's `Accept` header, but fails to set the `Vary: Accept` response header. This violates RFC 7231 Section 7.1.4 and enables cache poisoning attacks where intermediate caches (CDNs, reverse proxies, browser caches) serve incorrect content formats to clients, causing API integrity violations and client application failures.

## Finding Description

The Aptos API implements content negotiation through the `AcceptType` enum which parses the `Accept` request header to determine the response format. [1](#0-0) 

Every API endpoint that supports content negotiation accepts an `accept_type: AcceptType` parameter and returns fundamentally different response content:
- **JSON format**: Deserialized, type-resolved objects with human-readable structure
- **BCS format**: Raw binary-encoded bytes with minimal processing [2](#0-1) 

The OpenAPI specification explicitly documents both content types as valid response formats. [3](#0-2) 

However, when responses are generated, only the `Content-Type` header is set - **no `Vary: Accept` header is added**. The BCS payload implementation only sets Content-Type: [4](#0-3) 

The response generation macros that add custom Aptos headers (`X-APTOS-CHAIN-ID`, `X-APTOS-LEDGER-VERSION`, etc.) do not include any `Vary` header. [5](#0-4) 

No middleware adds cache-related headers. [6](#0-5) 

**Attack Scenario:**
1. Client A requests `/v1/accounts/0x1/resources` with `Accept: application/json`
2. Intermediate cache (CDN, HAProxy with caching, corporate proxy) caches the JSON response using only the URL as cache key
3. Client B requests `/v1/accounts/0x1/resources` with `Accept: application/x-bcs`
4. Cache serves the stored JSON response to Client B
5. Client B's BCS parser fails, or attempts to deserialize JSON as binary data, causing application errors

In production, Aptos nodes use HAProxy as a reverse proxy, [7](#0-6)  and may be deployed behind CDNs or other caching layers that would be vulnerable to this attack.

## Impact Explanation

This vulnerability is classified as **Medium Severity** per Aptos bug bounty criteria for the following reasons:

1. **API Integrity Violation**: Clients receive incorrect data formats, violating the API contract defined in the OpenAPI specification
2. **Client Application Failures**: Critical infrastructure like indexers, wallets, explorers, and SDKs that rely on specific response formats will malfunction when receiving cached incorrect formats
3. **Data Accuracy Impact**: In a blockchain context where data integrity is paramount, serving wrong formats to clients represents a significant reliability issue
4. **State Inconsistency from Client Perspective**: While not affecting on-chain state, clients experience inconsistent API behavior, which qualifies as "state inconsistencies requiring intervention" per Medium severity criteria

The vulnerability does not directly affect consensus, execution, or storage layers, but compromises the API layer that serves as the primary interface for all external interactions with the blockchain.

## Likelihood Explanation

**Likelihood: High**

1. **Common Infrastructure Pattern**: Many production deployments use CDNs (Cloudflare, Fastly, AWS CloudFront) or reverse proxies with caching enabled for performance and DDoS protection
2. **No Attacker Sophistication Required**: Any user making requests with different `Accept` headers can trigger cache pollution
3. **Persistent Effect**: Once a cache entry is created with the wrong format, all subsequent clients requesting that format will be affected until cache expiration
4. **Default Browser Behavior**: Browsers may cache API responses, affecting multiple users of the same browser/device
5. **Universal Endpoint Impact**: Every content-negotiated endpoint across the entire API surface (`/accounts/*`, `/transactions/*`, `/blocks/*`, `/events/*`, etc.) is vulnerable

## Recommendation

Add the `Vary: Accept` header to all API responses that support content negotiation. This instructs caches to create separate cache entries for different `Accept` header values.

**Implementation approach:**

Modify the `IntoResponse` implementation for `Bcs` to include the Vary header:

```rust
// In api/src/bcs_payload.rs
impl IntoResponse for Bcs {
    fn into_response(self) -> Response {
        Response::builder()
            .header(header::CONTENT_TYPE, Self::CONTENT_TYPE)
            .header(header::VARY, "Accept")  // Add this line
            .body(self.0)
    }
}
```

Similarly, ensure the JSON response path also sets the Vary header. Alternatively, implement this globally via middleware for all endpoints that accept `AcceptType` parameter:

```rust
// Add to api/src/runtime.rs middleware chain
pub async fn middleware_vary_header<E: Endpoint>(next: E, request: Request) -> Result<Response> {
    let mut response = next.get_response(request).await;
    // Add Vary: Accept header for all content-negotiated endpoints
    response.headers_mut().insert(
        header::VARY,
        HeaderValue::from_static("Accept")
    );
    Ok(response)
}
```

## Proof of Concept

**Test demonstrating cache poisoning vulnerability:**

```rust
#[tokio::test]
async fn test_missing_vary_header_cache_poisoning() {
    let context = new_test_context("test_cache_poisoning");
    
    // Request 1: Client requests JSON format
    let resp1 = context
        .get("/accounts/0x1/resources")
        .header("Accept", "application/json")
        .await;
    
    assert_eq!(resp1.status(), 200);
    assert_eq!(
        resp1.headers().get("Content-Type").unwrap(),
        "application/json"
    );
    
    // VULNERABILITY: Verify Vary header is missing
    assert!(resp1.headers().get("Vary").is_none());
    
    // Request 2: Different client requests BCS format for same URL
    let resp2 = context
        .get("/accounts/0x1/resources")
        .header("Accept", "application/x-bcs")
        .await;
    
    assert_eq!(resp2.status(), 200);
    assert_eq!(
        resp2.headers().get("Content-Type").unwrap(),
        "application/x-bcs"
    );
    
    // VULNERABILITY: Also missing Vary header
    assert!(resp2.headers().get("Vary").is_none());
    
    // In presence of intermediate cache without Vary header:
    // - Cache uses URL as sole key
    // - Second request would receive cached JSON response
    // - BCS client receives JSON, causing parsing failure
}
```

**Manual reproduction:**
```bash
# Terminal 1: Request JSON format (gets cached)
curl -H "Accept: application/json" https://fullnode.testnet.aptoslabs.com/v1/

# Terminal 2: Request BCS format (receives cached JSON if behind caching proxy)
curl -H "Accept: application/x-bcs" https://fullnode.testnet.aptoslabs.com/v1/

# Check response headers - Vary: Accept will be missing
curl -I -H "Accept: application/json" https://fullnode.testnet.aptoslabs.com/v1/
```

## Notes

This vulnerability affects the API infrastructure layer rather than core blockchain components (consensus, execution, storage). While it doesn't directly compromise on-chain state or validator operations, it represents a significant API integrity issue that can cause widespread client application failures. The fix is straightforward (adding a single HTTP header) and follows standard HTTP best practices for content negotiation as specified in RFC 7231.

### Citations

**File:** api/src/accept_type.rs (L29-41)
```rust
fn parse_accept(accept: &Accept) -> Result<AcceptType> {
    for mime in &accept.0 {
        if matches!(mime.as_ref(), JSON) {
            return Ok(AcceptType::Json);
        }
        if matches!(mime.as_ref(), BCS) {
            return Ok(AcceptType::Bcs);
        }
    }

    // Default to returning content as JSON.
    Ok(AcceptType::Json)
}
```

**File:** api/src/accounts.rs (L473-508)
```rust
        match accept_type {
            AcceptType::Json => {
                // Resolve the BCS encoded versions into `MoveResource`s
                let state_view = self
                    .context
                    .latest_state_view_poem(&self.latest_ledger_info)?;
                let converter = state_view
                    .as_converter(self.context.db.clone(), self.context.indexer_reader.clone());
                let converted_resources = converter
                    .try_into_resources(resources.iter().map(|(k, v)| (k.clone(), v.as_slice())))
                    .context("Failed to build move resource response from data in DB")
                    .map_err(|err| {
                        BasicErrorWith404::internal_with_code(
                            err,
                            AptosErrorCode::InternalError,
                            &self.latest_ledger_info,
                        )
                    })?;
                BasicResponse::try_from_json((
                    converted_resources,
                    &self.latest_ledger_info,
                    BasicResponseStatus::Ok,
                ))
                .map(|v| v.with_cursor(next_state_key))
            },
            AcceptType::Bcs => {
                // Put resources in a BTreeMap to ensure they're ordered the same every time
                let resources: BTreeMap<StructTag, Vec<u8>> = resources.into_iter().collect();
                BasicResponse::try_from_bcs((
                    resources,
                    &self.latest_ledger_info,
                    BasicResponseStatus::Ok,
                ))
                .map(|v| v.with_cursor(next_state_key))
            },
        }
```

**File:** api/doc/spec.yaml (L64-73)
```yaml
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AccountData'
            application/x-bcs:
              schema:
                type: array
                items:
                  type: integer
                  format: uint8
```

**File:** api/src/bcs_payload.rs (L61-67)
```rust
impl IntoResponse for Bcs {
    fn into_response(self) -> Response {
        Response::builder()
            .header(header::CONTENT_TYPE, Self::CONTENT_TYPE)
            .body(self.0)
    }
}
```

**File:** api/src/response.rs (L322-349)
```rust
        pub enum $enum_name<T: poem_openapi::types::ToJSON + Send + Sync> {
            $(
            #[oai(status = $status)]
            $name(
                // We use just regular u64 here instead of U64 since all header
                // values are implicitly strings anyway.
                $crate::response::AptosResponseContent<T>,
                /// Chain ID of the current chain
                #[oai(header = "X-Aptos-Chain-Id")] u8,
                /// Current ledger version of the chain
                #[oai(header = "X-Aptos-Ledger-Version")] u64,
                /// Oldest non-pruned ledger version of the chain
                #[oai(header = "X-Aptos-Ledger-Oldest-Version")] u64,
                /// Current timestamp of the chain
                #[oai(header = "X-Aptos-Ledger-TimestampUsec")] u64,
                /// Current epoch of the chain
                #[oai(header = "X-Aptos-Epoch")] u64,
                /// Current block height of the chain
                #[oai(header = "X-Aptos-Block-Height")] u64,
                /// Oldest non-pruned block height of the chain
                #[oai(header = "X-Aptos-Oldest-Block-Height")] u64,
                /// The cost of the call in terms of gas
                #[oai(header = "X-Aptos-Gas-Used")] Option<u64>,
                /// Cursor to be used for endpoints that support cursor-based
                /// pagination. Pass this to the `start` field of the endpoint
                /// on the next call to get the next page of results.
                #[oai(header = "X-Aptos-Cursor")] Option<String>,
            ),
```

**File:** api/src/log.rs (L54-141)
```rust
pub async fn middleware_log<E: Endpoint>(next: E, request: Request) -> Result<Response> {
    let start = std::time::Instant::now();

    let (trace_id, span_id) = extract_trace_context(&request);

    let mut log = HttpRequestLog {
        remote_addr: request.remote_addr().as_socket_addr().cloned(),
        method: request.method().clone(),
        path: request.uri().path().to_string(),
        status: 0,
        referer: request
            .headers()
            .get(header::REFERER)
            .and_then(|v| v.to_str().ok().map(|v| v.to_string())),
        user_agent: request
            .headers()
            .get(header::USER_AGENT)
            .and_then(|v| v.to_str().ok().map(|v| v.to_string())),
        aptos_client: request
            .headers()
            .get(X_APTOS_CLIENT)
            .and_then(|v| v.to_str().ok().map(|v| v.to_string())),
        elapsed: Duration::from_secs(0),
        forwarded: request
            .headers()
            .get(header::FORWARDED)
            .and_then(|v| v.to_str().ok().map(|v| v.to_string())),
        content_length: request
            .headers()
            .get(header::CONTENT_LENGTH)
            .and_then(|v| v.to_str().ok().map(|v| v.to_string())),
        trace_id,
        span_id,
    };

    let response = next.get_response(request).await;

    let elapsed = start.elapsed();

    log.status = response.status().as_u16();
    log.elapsed = elapsed;

    if log.status >= 500 {
        sample!(SampleRate::Duration(Duration::from_secs(1)), warn!(log));
    } else if log.status >= 400 {
        sample!(SampleRate::Duration(Duration::from_secs(60)), info!(log));
    } else {
        sample!(SampleRate::Duration(Duration::from_secs(1)), debug!(log));
    }

    // Log response statuses generally.
    RESPONSE_STATUS
        .with_label_values(&[log.status.to_string().as_str()])
        .observe(elapsed.as_secs_f64());

    let operation_id = response
        .data::<OperationId>()
        .map(|operation_id| operation_id.0)
        .unwrap_or("operation_id_not_set");

    // Log response status per-endpoint + method.
    HISTOGRAM
        .with_label_values(&[
            log.method.as_str(),
            operation_id,
            log.status.to_string().as_str(),
        ])
        .observe(elapsed.as_secs_f64());

    // Push a counter based on the request source, sliced up by endpoint + method.
    REQUEST_SOURCE_CLIENT
        .with_label_values(&[
            determine_request_source_client(&log.aptos_client),
            operation_id,
            log.status.to_string().as_str(),
        ])
        .inc();

    if log.method == Method::POST {
        if let Some(length) = log.content_length.and_then(|l| l.parse::<u32>().ok()) {
            POST_BODY_BYTES
                .with_label_values(&[operation_id, log.status.to_string().as_str()])
                .observe(length as f64);
        }
    }

    Ok(response)
}
```

**File:** docker/compose/aptos-node/haproxy.cfg (L108-124)
```text
## Specify the API frontend
frontend validator-api
    mode http
    option httplog
    bind :8180
    default_backend validator-api

    # Deny requests from blocked IPs
    tcp-request connection reject if { src -n -f /usr/local/etc/haproxy/blocked.ips }

    ## Add the forwarded header
    http-request add-header Forwarded "for=%ci"

## Specify the API backend
backend validator-api
    mode http
    server validator validator:8080
```
