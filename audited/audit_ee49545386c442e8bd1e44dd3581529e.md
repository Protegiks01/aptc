# Audit Report

## Title
Path Traversal Vulnerability in LocalFs BackupStorage via Unvalidated FileHandles

## Summary
The `LocalFs` implementation of `BackupStorage` does not validate `FileHandle` values before using them in filesystem operations, allowing path traversal attacks that can read arbitrary files outside the intended backup directory.

## Finding Description

The `BackupStorage` trait defines methods that return `FileHandle` values (type alias for `String`) without any validation requirements. [1](#0-0) 

The `LocalFs::open_for_read()` implementation directly joins the unvalidated `file_handle` parameter with the base directory and opens the resulting path without any security checks: [2](#0-1) 

Similarly, `LocalFs::backup_metadata_file()` uses the unvalidated file_handle in a filesystem rename operation: [3](#0-2) 

During backup operations, `FileHandle` values are stored in manifest structures like `StateSnapshotChunk`: [4](#0-3) 

During restore operations, these `FileHandle` values are loaded from manifests and used directly without validation: [5](#0-4) 

The `CommandAdapter` implementation reads `FileHandle` values from command stdout without validation, allowing arbitrary strings to be returned: [6](#0-5) 

**Attack Scenario:**
1. Attacker creates backups using a malicious `CommandAdapter` configuration where `create_for_write` returns FileHandles like `"../../../../etc/passwd"` or `"../../../../root/.ssh/id_rsa"`
2. These malicious FileHandles are stored in backup manifests
3. Victim obtains these backup files (via backup migration, shared storage, or compromised cloud provider)
4. Victim attempts to restore using `LocalFs` storage backend pointing to a local directory
5. When `LocalFs::open_for_read("../../../../etc/passwd")` is called, it resolves to a path outside the backup directory and reads sensitive system files

## Impact Explanation

**High Severity** - This vulnerability enables arbitrary file read on systems performing backup restoration, which can lead to:

- **Credential Theft**: Reading validator private keys from `~/.aptos/` or other config directories, enabling validator compromise
- **Configuration Exposure**: Leaking database credentials, API keys, and network topology information
- **State Database Access**: Reading raw database files could expose transaction history and state data

While this requires specific conditions (mixed storage backends or manifest from untrusted source), the impact of private key theft elevates this to High severity per the bug bounty criteria for "Significant protocol violations" that could lead to validator compromise.

## Likelihood Explanation

**Medium Likelihood** - The vulnerability requires one of these scenarios:

1. **Backup Migration**: Organization migrates backups from cloud storage (CommandAdapter) to local filesystem (LocalFs), and the cloud storage was previously compromised
2. **Shared Storage with Mixed Backends**: Multiple nodes share backup storage, with one using malicious CommandAdapter and another using LocalFs for restore
3. **Manifest Tampering**: Attacker gains access to modify manifest JSON files in transit or at rest

While these scenarios are not trivial, they are realistic in production deployments with complex backup strategies or when backup data is obtained from third parties.

## Recommendation

Add validation in `LocalFs` methods before using `file_handle` in filesystem operations:

```rust
async fn open_for_read(
    &self,
    file_handle: &FileHandleRef,
) -> Result<Box<dyn AsyncRead + Send + Unpin>> {
    // Validate no path traversal sequences
    ensure!(
        !file_handle.contains(".."),
        "Path traversal detected in file_handle: {}",
        file_handle
    );
    
    // Validate not an absolute path
    ensure!(
        !Path::new(file_handle).is_absolute(),
        "Absolute paths not allowed in file_handle: {}",
        file_handle
    );
    
    let path = self.dir.join(file_handle);
    
    // Canonicalize and verify it's within the backup directory
    let canonical = path.canonicalize()
        .map_err(|e| anyhow!("Failed to canonicalize path: {}", e))?;
    let base_canonical = self.dir.canonicalize()
        .map_err(|e| anyhow!("Failed to canonicalize base dir: {}", e))?;
    
    ensure!(
        canonical.starts_with(&base_canonical),
        "File access outside backup directory attempted"
    );
    
    let file = OpenOptions::new()
        .read(true)
        .open(&canonical)
        .await
        .err_notes(&canonical)?;
    Ok(Box::new(file))
}
```

Apply similar validation to `backup_metadata_file()` and consider adding validation in the `BackupStorage` trait documentation or via a validated wrapper type.

## Proof of Concept

```rust
#[tokio::test]
async fn test_path_traversal_vulnerability() {
    use tempfile::TempDir;
    use std::fs;
    
    // Create backup directory
    let backup_dir = TempDir::new().unwrap();
    let storage = LocalFs::new(backup_dir.path().to_path_buf());
    
    // Create a sensitive file outside backup directory
    let sensitive_dir = TempDir::new().unwrap();
    let sensitive_file = sensitive_dir.path().join("secret.txt");
    fs::write(&sensitive_file, b"SENSITIVE_DATA").unwrap();
    
    // Calculate relative path from backup_dir to sensitive_file
    let relative_path = format!(
        "../{}/secret.txt",
        sensitive_dir.path().file_name().unwrap().to_str().unwrap()
    );
    
    // Attempt to read file outside backup directory
    let result = storage.open_for_read(&relative_path).await;
    
    // Currently this SUCCEEDS (vulnerability) - it should FAIL
    assert!(result.is_ok(), "Path traversal successful - vulnerability confirmed");
    
    let mut reader = result.unwrap();
    let mut contents = String::new();
    reader.read_to_string(&mut contents).await.unwrap();
    assert_eq!(contents, "SENSITIVE_DATA");
}
```

## Notes

This vulnerability affects the **LocalFs** storage backend specifically. The **CommandAdapter** backend passes FileHandles to shell commands, which have their own security considerations but don't have the same direct path traversal issue. The core problem is the mismatch between the trust model (BackupStorage implementations are trusted) and the reality that FileHandles can cross trust boundaries through manifest files.

### Citations

**File:** storage/backup/backup-cli/src/storage/mod.rs (L40-41)
```rust
pub type FileHandle = String;
pub type FileHandleRef = str;
```

**File:** storage/backup/backup-cli/src/storage/local_fs/mod.rs (L98-109)
```rust
    async fn open_for_read(
        &self,
        file_handle: &FileHandleRef,
    ) -> Result<Box<dyn AsyncRead + Send + Unpin>> {
        let path = self.dir.join(file_handle);
        let file = OpenOptions::new()
            .read(true)
            .open(&path)
            .await
            .err_notes(&path)?;
        Ok(Box::new(file))
    }
```

**File:** storage/backup/backup-cli/src/storage/local_fs/mod.rs (L127-147)
```rust
    async fn backup_metadata_file(&self, file_handle: &FileHandleRef) -> Result<()> {
        let dir = self.metadata_backup_dir();

        // Check if the backup directory exists, create it if it doesn't
        if !dir.exists() {
            create_dir_all(&dir).await?;
        }

        // Get the file name and the backup file path
        let name = Path::new(file_handle)
            .file_name()
            .and_then(OsStr::to_str)
            .ok_or_else(|| format_err!("cannot extract filename from {}", file_handle))?;
        let mut backup_path = PathBuf::from(&dir);
        backup_path.push(name);

        // Move the file to the backup directory
        rename(&self.dir.join(file_handle), &backup_path).await?;

        Ok(())
    }
```

**File:** storage/backup/backup-cli/src/backup_types/state_snapshot/manifest.rs (L22-27)
```rust
    /// `(key, state_value)`
    pub blobs: FileHandle,
    /// BCS serialized `SparseMerkleRangeProof` that proves this chunk adds up to the root hash
    /// indicated in the backup (`StateSnapshotBackup::root_hash`).
    pub proof: FileHandle,
}
```

**File:** storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs (L253-266)
```rust
    async fn read_state_value(
        storage: &Arc<dyn BackupStorage>,
        file_handle: FileHandle,
    ) -> Result<Vec<(StateKey, StateValue)>> {
        let mut file = storage.open_for_read(&file_handle).await?;

        let mut chunk = vec![];

        while let Some(record_bytes) = file.read_record_bytes().await? {
            chunk.push(bcs::from_bytes(&record_bytes)?);
        }

        Ok(chunk)
    }
```

**File:** storage/backup/backup-cli/src/storage/command_adapter/mod.rs (L93-112)
```rust
    async fn create_for_write(
        &self,
        backup_handle: &BackupHandleRef,
        name: &ShellSafeName,
    ) -> Result<(FileHandle, Box<dyn AsyncWrite + Send + Unpin>)> {
        let mut child = self
            .cmd(&self.config.commands.create_for_write, vec![
                EnvVar::backup_handle(backup_handle.to_string()),
                EnvVar::file_name(name.as_ref()),
            ])
            .spawn()?;
        let mut file_handle = FileHandle::new();
        child
            .stdout()
            .read_to_string(&mut file_handle)
            .await
            .err_notes(backup_handle)?;
        file_handle.truncate(file_handle.trim_end().len());
        Ok((file_handle, Box::new(child.into_data_sink())))
    }
```
