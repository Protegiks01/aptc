# Audit Report

## Title
Consensus Safety Violation: Non-Persisted QC Observation in Order Vote Allows Unsafe Timeout Signing

## Summary
The `guarded_construct_and_sign_order_vote` function in the 2-chain safety rules implementation observes a Quorum Certificate (QC) and updates critical consensus state (`one_chain_round`, `preferred_round`) before performing safety checks. When the safety check fails, these state modifications are not persisted, causing the validator to "forget" it observed the QC. This allows the validator to subsequently sign timeouts that violate 2-chain consensus safety rules, potentially leading to chain forks.

## Finding Description

The vulnerability exists in the order vote signing flow where state observation occurs before validation: [1](#0-0) 

The problematic sequence is:

1. **Line 105**: SafetyData is loaded from persistent storage with current `one_chain_round` value
2. **Line 108**: `observe_qc()` modifies the local SafetyData, updating `one_chain_round` and `preferred_round` to higher values based on the QC in the OrderVoteProposal [2](#0-1) 
3. **Line 110**: `safe_for_order_vote()` check is performed and can fail [3](#0-2) 
4. **If failure**: The function returns the error early, and the modified SafetyData is NEVER persisted (line 117 never executes)

The `one_chain_round` field is critical for 2-chain timeout safety checks: [4](#0-3) 

The `safe_to_timeout` function at line 134 requires that `qc_round >= safety_data.one_chain_round`. If a validator has observed a QC with round R but this observation was not persisted due to the bug, subsequent timeout requests with `qc_round < R` will incorrectly pass the safety check.

**Attack Scenario:**

1. **Initial state**: Validator's persisted SafetyData has `one_chain_round = 5`, `highest_timeout_round = 7`

2. **Malicious OrderVoteProposal**: An attacker (or normal network participant) sends an OrderVoteProposal containing:
   - Block at round 7 (fails `round > highest_timeout_round` check)
   - QC certifying round 15
   
3. **Order vote processing fails**:
   - Function loads SafetyData: `one_chain_round = 5`
   - `observe_qc` updates local copy: `one_chain_round = 15`
   - `safe_for_order_vote` check fails: `7 > 7` is false
   - Error returned, modifications NOT persisted
   - Persistent SafetyData still has `one_chain_round = 5`

4. **Timeout request exploits stale state**:
   - Attacker/network sends Timeout for round 10 with QC certifying round 8
   - Validator loads SafetyData: `one_chain_round = 5` (stale!)
   - `safe_to_timeout` checks: `8 >= 5` ✓ PASSES
   - Validator signs timeout violating 2-chain safety

5. **Consensus safety broken**: The validator signed a timeout it should have rejected because it had already observed a QC for round 15 > 8. If multiple validators have this bug, they can create conflicting timeout certificates, leading to chain forks.

## Impact Explanation

This is a **Critical Severity** consensus safety violation per Aptos bug bounty criteria:

- **Breaks Consensus Safety Invariant**: Validators can sign conflicting messages that violate AptosBFT 2-chain safety rules
- **Potential for Chain Forks**: Multiple validators with stale `one_chain_round` can sign conflicting timeouts/votes, creating permanent chain splits
- **No Byzantine Threshold Required**: This bug affects honest validators processing normal network traffic; no collusion needed
- **Violates 2-Chain Protocol Specification**: The entire purpose of tracking `one_chain_round` is to prevent validators from timing out on rounds where they've seen higher certified blocks

The 2-chain consensus protocol's safety depends on validators monotonically tracking the highest QC they've observed. This bug breaks that monotonicity property, allowing the protocol to violate its safety guarantees even with all validators acting honestly according to the buggy code.

## Likelihood Explanation

**HIGH likelihood** of occurrence:

1. **Normal Network Conditions**: OrderVoteProposals are part of standard 2-chain consensus operation
2. **Legitimate Failure Cases**: The `safe_for_order_vote` check legitimately fails when `block.round <= highest_timeout_round`, which can occur during normal consensus rounds with timeouts
3. **No Adversarial Action Required**: The bug triggers during regular consensus operation when:
   - A validator has issued a timeout at round T
   - It receives an OrderVoteProposal for round <= T with a QC for a higher round
   - The proposal is rejected, but the QC observation is lost
4. **Persistent Impact**: Once triggered, the stale state persists until the validator observes another QC through a successful vote/order-vote path
5. **Compound Effect**: In networks with multiple validators experiencing timeouts, this bug creates systematic under-estimation of `one_chain_round` across the validator set

## Recommendation

**Immediate Fix**: Move the `observe_qc` call to occur AFTER all safety checks pass and immediately before persistence.

Modified `guarded_construct_and_sign_order_vote`:

```rust
pub(crate) fn guarded_construct_and_sign_order_vote(
    &mut self,
    order_vote_proposal: &OrderVoteProposal,
) -> Result<OrderVote, Error> {
    // Exit early if we cannot sign
    self.signer()?;
    self.verify_order_vote_proposal(order_vote_proposal)?;
    let proposed_block = order_vote_proposal.block();
    let mut safety_data = self.persistent_storage.safety_data()?;

    // PERFORM SAFETY CHECK FIRST
    self.safe_for_order_vote(proposed_block, &safety_data)?;
    
    // ONLY OBSERVE QC AFTER ALL CHECKS PASS
    self.observe_qc(order_vote_proposal.quorum_cert(), &mut safety_data);

    // Construct and sign order vote
    let author = self.signer()?.author();
    let ledger_info =
        LedgerInfo::new(order_vote_proposal.block_info().clone(), HashValue::zero());
    let signature = self.sign(&ledger_info)?;
    let order_vote = OrderVote::new_with_signature(author, ledger_info.clone(), signature);
    self.persistent_storage.set_safety_data(safety_data)?;
    Ok(order_vote)
}
```

**Additional Hardening**: Ensure all functions that modify SafetyData follow this pattern:
1. Load SafetyData
2. Perform ALL validation checks (no state modifications)
3. Modify SafetyData only after validation
4. Persist immediately after modifications

Review `guarded_construct_and_sign_vote_two_chain` for similar issues (appears safe as `observe_qc` is called after both `verify_and_update_last_vote_round` and `safe_to_vote` checks).

## Proof of Concept

**Rust Test Reproducing the Vulnerability:**

```rust
#[test]
fn test_order_vote_qc_observation_lost_on_failure() {
    // Setup validator with SafetyRules
    let (mut safety_rules, signer) = create_safety_rules();
    let (proof, genesis_qc) = make_genesis(&signer);
    safety_rules.initialize(&proof).unwrap();
    
    // Initial state: one_chain_round = 0, highest_timeout_round = 0
    
    // Step 1: Sign a timeout at round 5 to set highest_timeout_round = 5
    let timeout_5 = TwoChainTimeout::new(1, 5, genesis_qc.clone());
    safety_rules.sign_timeout_with_qc(&timeout_5, None).unwrap();
    // Now: last_voted_round = 5, highest_timeout_round = 5, one_chain_round = 0
    
    // Step 2: Create OrderVoteProposal with block at round 5 but QC for round 10
    let high_round_block = make_block_with_qc(10, genesis_qc.clone(), &signer);
    let qc_round_10 = make_qc_for_block(&high_round_block, &signer);
    let block_round_5 = make_block_with_qc_at_round(5, qc_round_10.clone(), &signer);
    let order_proposal = OrderVoteProposal::new(
        block_round_5.block_info(),
        qc_round_10.clone(),
        &signer
    );
    
    // Step 3: Attempt order vote - should fail safe_for_order_vote check
    // (round 5 is NOT > highest_timeout_round 5)
    // But observe_qc will update one_chain_round = 10 before the check!
    let result = safety_rules.construct_and_sign_order_vote(&order_proposal);
    assert!(result.is_err());
    assert!(matches!(result.unwrap_err(), Error::NotSafeForOrderVote(5, 5)));
    
    // Step 4: Verify one_chain_round was NOT persisted (bug symptom)
    let current_state = safety_rules.consensus_state().unwrap();
    assert_eq!(current_state.safety_data().one_chain_round, 0); // Still 0!
    
    // Step 5: Now attempt timeout with qc_round = 8, which is < 10
    // This SHOULD fail (8 < 10) but WILL PASS due to stale one_chain_round = 0
    let timeout_9_qc8 = TwoChainTimeout::new(1, 9, make_qc_at_round(8, &signer));
    let tc_round_6 = make_timeout_cert(6, &genesis_qc, &signer);
    
    // BUG: This succeeds when it should fail!
    // safe_to_timeout checks: qc_round(8) >= one_chain_round(0) - PASSES
    // But validator had observed QC for round 10 in step 2!
    let result = safety_rules.sign_timeout_with_qc(&timeout_9_qc8, Some(&tc_round_6));
    assert!(result.is_ok()); // BUG: Should have failed!
    
    // Expected behavior: Should return Error::NotSafeToTimeout(9, 8, 6, 10)
    // Actual behavior: Returns Ok, violating 2-chain safety
}
```

**Test Execution**: This test demonstrates that after a failed order vote attempt, the validator's `one_chain_round` remains stale, allowing it to sign timeouts that should be rejected based on previously observed QCs.

## Notes

- This vulnerability is specific to the **2-chain consensus implementation** and affects the `guarded_construct_and_sign_order_vote` function
- The similar function `guarded_construct_and_sign_vote_two_chain` does NOT have this issue because `observe_qc` is called at line 84 AFTER both voting rule checks (lines 77-81) have passed
- The root cause is incorrect ordering: state observation should occur after validation, not before
- The bug requires no malicious actors—it triggers during normal consensus operation when order vote proposals are rejected for legitimate reasons
- Impact multiplies across the validator set: if multiple validators have stale `one_chain_round`, they collectively create an unsafe network state

### Citations

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L97-119)
```rust
    pub(crate) fn guarded_construct_and_sign_order_vote(
        &mut self,
        order_vote_proposal: &OrderVoteProposal,
    ) -> Result<OrderVote, Error> {
        // Exit early if we cannot sign
        self.signer()?;
        self.verify_order_vote_proposal(order_vote_proposal)?;
        let proposed_block = order_vote_proposal.block();
        let mut safety_data = self.persistent_storage.safety_data()?;

        // Record 1-chain data
        self.observe_qc(order_vote_proposal.quorum_cert(), &mut safety_data);

        self.safe_for_order_vote(proposed_block, &safety_data)?;
        // Construct and sign order vote
        let author = self.signer()?.author();
        let ledger_info =
            LedgerInfo::new(order_vote_proposal.block_info().clone(), HashValue::zero());
        let signature = self.sign(&ledger_info)?;
        let order_vote = OrderVote::new_with_signature(author, ledger_info.clone(), signature);
        self.persistent_storage.set_safety_data(safety_data)?;
        Ok(order_vote)
    }
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L121-145)
```rust
    /// Core safety timeout rule for 2-chain protocol. Return success if 1 and 2 are true
    /// 1. round == timeout.qc.round + 1 || round == tc.round + 1
    /// 2. timeout.qc.round >= one_chain_round
    fn safe_to_timeout(
        &self,
        timeout: &TwoChainTimeout,
        maybe_tc: Option<&TwoChainTimeoutCertificate>,
        safety_data: &SafetyData,
    ) -> Result<(), Error> {
        let round = timeout.round();
        let qc_round = timeout.hqc_round();
        let tc_round = maybe_tc.map_or(0, |tc| tc.round());
        if (round == next_round(qc_round)? || round == next_round(tc_round)?)
            && qc_round >= safety_data.one_chain_round
        {
            Ok(())
        } else {
            Err(Error::NotSafeToTimeout(
                round,
                qc_round,
                tc_round,
                safety_data.one_chain_round,
            ))
        }
    }
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L168-178)
```rust
    fn safe_for_order_vote(&self, block: &Block, safety_data: &SafetyData) -> Result<(), Error> {
        let round = block.round();
        if round > safety_data.highest_timeout_round {
            Ok(())
        } else {
            Err(Error::NotSafeForOrderVote(
                round,
                safety_data.highest_timeout_round,
            ))
        }
    }
```

**File:** consensus/safety-rules/src/safety_rules.rs (L135-156)
```rust
    pub(crate) fn observe_qc(&self, qc: &QuorumCert, safety_data: &mut SafetyData) -> bool {
        let mut updated = false;
        let one_chain = qc.certified_block().round();
        let two_chain = qc.parent_block().round();
        if one_chain > safety_data.one_chain_round {
            safety_data.one_chain_round = one_chain;
            trace!(
                SafetyLogSchema::new(LogEntry::OneChainRound, LogEvent::Update)
                    .preferred_round(safety_data.one_chain_round)
            );
            updated = true;
        }
        if two_chain > safety_data.preferred_round {
            safety_data.preferred_round = two_chain;
            trace!(
                SafetyLogSchema::new(LogEntry::PreferredRound, LogEvent::Update)
                    .preferred_round(safety_data.preferred_round)
            );
            updated = true;
        }
        updated
    }
```
