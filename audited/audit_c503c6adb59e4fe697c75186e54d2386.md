# Audit Report

## Title
Critical Consensus Halt via Governance-Triggered Complete Validator Set Removal

## Summary
The `remove_validators` function in stake.move lacks a runtime check to prevent emptying the active validator set, allowing governance to inadvertently cause a complete consensus halt requiring a hard fork to recover.

## Finding Description

The `remove_validators` function can be called by on-chain governance (requiring the `@aptos_framework` signer) to move validators from the active set to pending_inactive. While this function has a formal verification invariant specifying that `active_validators` length must remain greater than zero, **this invariant is not enforced at runtime**. [1](#0-0) 

The function iterates through all provided validator addresses and moves each from `active_validators` to `pending_inactive` without any check ensuring at least one validator remains active. In contrast, the `leave_validator_set` function includes an explicit runtime assertion after removing a validator: [2](#0-1) 

This check prevents the last validator from leaving voluntarily. However, `remove_validators` has no such protection.

The formal verification specification indicates this invariant should exist: [3](#0-2) 

But specification invariants in Move are only checked during formal verification, not at runtime.

**Attack Scenario:**
1. Governance passes a proposal calling `remove_validators` with all active validator addresses (could be due to error, bug in proposal logic, or compromised governance)
2. All validators are moved to `pending_inactive`, leaving `active_validators` empty
3. Validators in `pending_inactive` continue operating in the current epoch
4. At epoch transition, `on_new_epoch` executes:
   - Clears `pending_inactive` completely
   - Attempts to activate `pending_active` validators (but none exist)
   - Results in an empty `active_validators` set [4](#0-3) 

5. Consensus attempts to start the new epoch with an empty validator set, creating a `ValidatorVerifier` with quorum requirement of 0: [5](#0-4) 

6. With no validators and invalid quorum requirements, consensus cannot produce blocks, causing complete network halt.

## Impact Explanation

**Severity: Critical** - This vulnerability meets the "Non-recoverable network partition (requires hardfork)" category from the Aptos bug bounty program. The impact includes:

- **Complete consensus halt**: No blocks can be produced with zero active validators
- **Network-wide outage**: All validator nodes cannot make progress
- **Hard fork required**: Recovery requires coordinating a hard fork to restore the validator set, which is extremely disruptive
- **Economic damage**: Extended downtime affects all users and applications on the network

This breaks the critical invariant that the system must maintain liveness and always have at least one active validator for consensus.

## Likelihood Explanation

**Likelihood: Medium**

While this requires governance action (privileged access), it's realistic because:

1. **Governance errors**: Complex proposals involving validator management could mistakenly specify all validators
2. **Proposal execution bugs**: Bugs in proposal execution logic could lead to unintended `remove_validators` calls
3. **No runtime safeguard**: Unlike `leave_validator_set`, there's no defensive check preventing this catastrophic state
4. **Clear precedent**: The existence of the `ELAST_VALIDATOR` check in `leave_validator_set` shows this scenario was considered for voluntary exits but not for governance-initiated removals

The formal verification invariant exists but provides no runtime protection, creating a dangerous gap between intended behavior and actual enforcement.

## Recommendation

Add a runtime assertion in `remove_validators` similar to the one in `leave_validator_set`:

```move
public fun remove_validators(
    aptos_framework: &signer,
    validators: &vector<address>,
) acquires ValidatorSet {
    assert_reconfig_not_in_progress();
    system_addresses::assert_aptos_framework(aptos_framework);
    let validator_set = borrow_global_mut<ValidatorSet>(@aptos_framework);
    let active_validators = &mut validator_set.active_validators;
    let pending_inactive = &mut validator_set.pending_inactive;
    
    let len_validators = vector::length(validators);
    let i = 0;
    while (i < len_validators) {
        let validator = *vector::borrow(validators, i);
        let validator_index = find_validator(active_validators, validator);
        if (option::is_some(&validator_index)) {
            let validator_info = vector::swap_remove(active_validators, *option::borrow(&validator_index));
            // ADD THIS CHECK:
            assert!(
                vector::length(active_validators) > 0, 
                error::invalid_state(ELAST_VALIDATOR)
            );
            vector::push_back(pending_inactive, validator_info);
        };
        i = i + 1;
    };
}
```

This ensures at least one validator always remains in the active set, preventing the catastrophic empty validator set scenario.

## Proof of Concept

```move
#[test(aptos_framework = @aptos_framework, validator1 = @0x123, validator2 = @0x456)]
#[expected_failure(abort_code = 0x60006, location = aptos_framework::stake)]
fun test_cannot_remove_all_validators(
    aptos_framework: &signer,
    validator1: &signer,
    validator2: &signer,
) {
    // Initialize framework and two validators
    initialize_for_test(aptos_framework);
    
    let (sk1, pk1, pop1) = generate_identity();
    let (sk2, pk2, pop2) = generate_identity();
    
    initialize_test_validator(&pk1, &pop1, validator1, 100 * ONE_APT, true, true);
    initialize_test_validator(&pk2, &pop2, validator2, 100 * ONE_APT, true, true);
    
    // Both validators are now active
    end_epoch();
    
    // Attempt to remove ALL validators - this should fail but currently doesn't
    let validator1_addr = signer::address_of(validator1);
    let validator2_addr = signer::address_of(validator2);
    
    stake::remove_validators(
        aptos_framework, 
        &vector[validator1_addr, validator2_addr]
    );
    
    // At this point, active_validators is empty!
    // Next epoch transition would cause consensus halt
    
    // This test should abort with ELAST_VALIDATOR but currently doesn't
}
```

## Notes

This vulnerability requires governance access to trigger, which is a privileged operation. However, it represents a critical safety invariant violation where the code allows a catastrophic system state that should be impossible. The missing runtime check creates an unacceptable risk given the severe consequences of triggering this condition, even if accidentally. The existence of the formal verification invariant indicates this protection was intended but not properly implemented at runtime.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L542-582)
```text
    /// Allow on chain governance to remove validators from the validator set.
    public fun remove_validators(
        aptos_framework: &signer,
        validators: &vector<address>,
    ) acquires ValidatorSet {
        assert_reconfig_not_in_progress();
        system_addresses::assert_aptos_framework(aptos_framework);
        let validator_set = borrow_global_mut<ValidatorSet>(@aptos_framework);
        let active_validators = &mut validator_set.active_validators;
        let pending_inactive = &mut validator_set.pending_inactive;
        spec {
            update ghost_active_num = len(active_validators);
            update ghost_pending_inactive_num = len(pending_inactive);
        };
        let len_validators = vector::length(validators);
        let i = 0;
        // Remove each validator from the validator set.
        while ({
            spec {
                invariant i <= len_validators;
                invariant spec_validators_are_initialized(active_validators);
                invariant spec_validator_indices_are_valid(active_validators);
                invariant spec_validators_are_initialized(pending_inactive);
                invariant spec_validator_indices_are_valid(pending_inactive);
                invariant ghost_active_num + ghost_pending_inactive_num == len(active_validators) + len(pending_inactive);
            };
            i < len_validators
        }) {
            let validator = *vector::borrow(validators, i);
            let validator_index = find_validator(active_validators, validator);
            if (option::is_some(&validator_index)) {
                let validator_info = vector::swap_remove(active_validators, *option::borrow(&validator_index));
                vector::push_back(pending_inactive, validator_info);
                spec {
                    update ghost_active_num = ghost_active_num - 1;
                    update ghost_pending_inactive_num = ghost_pending_inactive_num + 1;
                };
            };
            i = i + 1;
        };
    }
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1250-1256)
```text
            // Validate that the validator is already part of the validator set.
            let maybe_active_index = find_validator(&validator_set.active_validators, pool_address);
            assert!(option::is_some(&maybe_active_index), error::invalid_state(ENOT_VALIDATOR));
            let validator_info = vector::swap_remove(
                &mut validator_set.active_validators, option::extract(&mut maybe_active_index));
            assert!(vector::length(&validator_set.active_validators) > 0, error::invalid_state(ELAST_VALIDATOR));
            vector::push_back(&mut validator_set.pending_inactive, validator_info);
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1363-1403)
```text
        // Activate currently pending_active validators.
        append(&mut validator_set.active_validators, &mut validator_set.pending_active);

        // Officially deactivate all pending_inactive validators. They will now no longer receive rewards.
        validator_set.pending_inactive = vector::empty();

        // Update active validator set so that network address/public key change takes effect.
        // Moreover, recalculate the total voting power, and deactivate the validator whose
        // voting power is less than the minimum required stake.
        let next_epoch_validators = vector::empty();
        let (minimum_stake, _) = staking_config::get_required_stake(&config);
        let vlen = vector::length(&validator_set.active_validators);
        let total_voting_power = 0;
        let i = 0;
        while ({
            spec {
                invariant spec_validators_are_initialized(next_epoch_validators);
                invariant i <= vlen;
            };
            i < vlen
        }) {
            let old_validator_info = vector::borrow_mut(&mut validator_set.active_validators, i);
            let pool_address = old_validator_info.addr;
            let validator_config = borrow_global<ValidatorConfig>(pool_address);
            let stake_pool = borrow_global<StakePool>(pool_address);
            let new_validator_info = generate_validator_info(pool_address, stake_pool, *validator_config);

            // A validator needs at least the min stake required to join the validator set.
            if (new_validator_info.voting_power >= minimum_stake) {
                spec {
                    assume total_voting_power + new_validator_info.voting_power <= MAX_U128;
                };
                total_voting_power = total_voting_power + (new_validator_info.voting_power as u128);
                vector::push_back(&mut next_epoch_validators, new_validator_info);
            };
            i = i + 1;
        };

        validator_set.active_validators = next_epoch_validators;
        validator_set.total_voting_power = total_voting_power;
        validator_set.total_joining_power = 0;
```

**File:** aptos-move/framework/aptos-framework/sources/stake.spec.move (L675-687)
```text
    spec remove_validators {
        requires chain_status::is_operating();
        let validator_set = global<ValidatorSet>(@aptos_framework);
        let post post_validator_set = global<ValidatorSet>(@aptos_framework);
        let active_validators = validator_set.active_validators;
        let post post_active_validators = post_validator_set.active_validators;
        let pending_inactive_validators = validator_set.pending_inactive;
        let post post_pending_inactive_validators = post_validator_set.pending_inactive;

        invariant len(active_validators) > 0;
        ensures len(active_validators) + len(pending_inactive_validators) == len(post_active_validators)
            + len(post_pending_inactive_validators);
    }
```

**File:** types/src/validator_verifier.rs (L206-214)
```rust
    pub fn new(validator_infos: Vec<ValidatorConsensusInfo>) -> Self {
        let total_voting_power = sum_voting_power(&validator_infos);
        let quorum_voting_power = if validator_infos.is_empty() {
            0
        } else {
            total_voting_power * 2 / 3 + 1
        };
        Self::build_index(validator_infos, quorum_voting_power, total_voting_power)
    }
```
