# Audit Report

## Title
SecretShareStore Constructor Lacks Config Validation Leading to Validator Node Crashes

## Summary
The `SecretShareStore::new()` constructor does not validate that the provided `SecretShareConfig` matches the validator set for the given epoch. This allows mismatched configurations to be accepted, resulting in immediate validator node crashes when secret sharing is activated due to unpopulated weight maps and potential out-of-bounds access on verification keys.

## Finding Description

The `SecretShareStore::new()` constructor accepts a `SecretShareConfig` without performing any validation to ensure the configuration matches the validator set for the specified epoch. [1](#0-0) 

This breaks multiple security guarantees:

**1. Empty Weights HashMap Causes Guaranteed Panics**

The `SecretShareConfig` initializes its `weights` field as an empty HashMap and this field is never populated anywhere in the codebase. [2](#0-1) 

When `add_self_share()` is called, it retrieves this empty weights map: [3](#0-2) 

The code then attempts to look up the author's weight from this empty map with an `expect()` call that will panic: [4](#0-3) 

A similar panic occurs in the `retain()` function: [5](#0-4) 

**2. Out-of-Bounds Access on Verification Keys**

The `SecretShare::verify()` function accesses `config.verification_keys[index]` without bounds checking, as explicitly noted by a TODO comment: [6](#0-5) 

If the validator set has more validators than verification keys in the config, or if validator indices have changed, this will cause an out-of-bounds panic.

**3. No Epoch Validation**

The constructor accepts an `epoch` parameter but never validates that it matches the epoch stored in the `SecretShareConfig`: [7](#0-6) 

**4. No Threshold Validation**

There is no validation that the threshold value in the config is appropriate for the actual validator set size, which could lead to incorrect secret reconstruction behavior.

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos bug bounty criteria for the following reasons:

1. **Validator Node Crashes**: Any validator node that attempts to process secret shares will immediately crash due to panics from the empty weights HashMap. This fits the "API crashes" and "Validator node slowdowns" categories in High severity.

2. **Protocol Violation**: The secret sharing protocol cannot function correctly with mismatched configurations, constituting a "Significant protocol violation" (High severity).

3. **Non-Deterministic Failures**: Different nodes might crash at different times depending on when they process shares, potentially causing consensus disruption.

4. **Availability Impact**: If secret sharing is required for consensus progress, these crashes would prevent the network from making progress.

While the feature appears to not be currently active in production based on code inspection, the vulnerability exists in the codebase and would immediately manifest if the feature is enabled.

## Likelihood Explanation

**Current State**: The likelihood is currently LOW because secret sharing appears to be disabled in the main consensus pipeline (None is passed for secret_sharing_config). [8](#0-7) 

**If Feature is Enabled**: The likelihood becomes **CERTAIN** because:
- The weights HashMap is structurally always empty
- Any attempt to add a share will trigger the panic
- No attacker action is needed - normal consensus operation triggers it
- All validators running the affected code would experience crashes

This represents a critical implementation flaw that would be immediately discovered in any integration testing if the feature were activated.

## Recommendation

Add comprehensive validation to the `SecretShareStore::new()` constructor:

```rust
pub fn new(
    epoch: u64,
    author: Author,
    dec_config: SecretShareConfig,
    decision_tx: Sender<SecretSharedKey>,
) -> anyhow::Result<Self> {
    // Validate epoch matches
    ensure!(
        dec_config._epoch == epoch,
        "SecretShareConfig epoch {} does not match provided epoch {}",
        dec_config._epoch,
        epoch
    );
    
    // Validate weights are populated for all validators
    let validator_addrs = dec_config.validator.get_ordered_account_addresses();
    for addr in &validator_addrs {
        ensure!(
            dec_config.weights.contains_key(addr),
            "SecretShareConfig missing weight for validator {:?}",
            addr
        );
    }
    
    // Validate verification keys match validator count
    ensure!(
        dec_config.verification_keys.len() == validator_addrs.len(),
        "SecretShareConfig has {} verification keys but {} validators",
        dec_config.verification_keys.len(),
        validator_addrs.len()
    );
    
    // Validate threshold is reasonable (e.g., > 2/3 of validators)
    let threshold = dec_config.threshold();
    let num_validators = dec_config.number_of_validators();
    ensure!(
        threshold > 0 && threshold <= num_validators,
        "Invalid threshold {} for {} validators",
        threshold,
        num_validators
    );
    
    Ok(Self {
        epoch,
        self_author: author,
        secret_share_config: dec_config,
        secret_share_map: HashMap::new(),
        highest_known_round: 0,
        decision_tx,
    })
}
```

Additionally, populate the weights HashMap in `SecretShareConfig::new()` based on the validator verifier:

```rust
let weights: HashMap<Author, u64> = validator
    .get_ordered_account_addresses_iter()
    .map(|addr| (addr, 1u64)) // or use actual voting weights if available
    .collect();
```

And add bounds checking in `SecretShare::verify()`:

```rust
pub fn verify(&self, config: &SecretShareConfig) -> anyhow::Result<()> {
    let index = config.get_id(self.author());
    ensure!(
        index < config.verification_keys.len(),
        "Validator index {} out of bounds for {} verification keys",
        index,
        config.verification_keys.len()
    );
    let decryption_key_share = self.share().clone();
    config.verification_keys[index]
        .verify_decryption_key_share(&self.metadata.digest, &decryption_key_share)?;
    Ok(())
}
```

## Proof of Concept

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use aptos_types::validator_verifier::ValidatorVerifier;
    
    #[test]
    #[should_panic(expected = "Author must exist in weights")]
    fn test_empty_weights_panic() {
        // Create a validator set with one validator
        let validator_infos = vec![/* create test validator info */];
        let validator_verifier = Arc::new(ValidatorVerifier::new(validator_infos));
        
        // Create SecretShareConfig with empty weights (as done in production)
        let config = SecretShareConfig::new(
            test_author,
            1, // epoch
            validator_verifier,
            test_digest_key,
            test_msk_share,
            test_verification_keys,
            test_threshold_config,
            test_encryption_key,
        );
        // weights HashMap is empty at this point
        
        let (tx, _rx) = unbounded();
        let store = SecretShareStore::new(1, test_author, config, tx);
        
        // Create a test share
        let share = SecretShare::new(
            test_author,
            test_metadata,
            test_key_share,
        );
        
        // This will panic with "Author must exist in weights"
        store.lock().add_self_share(share).unwrap();
    }
}
```

## Notes

The vulnerability stems from incomplete implementation rather than algorithmic flaws. The code assumes weights will be populated but never does so. The TODO comment in the verification function indicates developers were aware of at least the bounds checking issue but it remains unaddressed. This represents a critical gap in defensive programming for consensus-critical code.

### Citations

**File:** consensus/src/rand/secret_sharing/secret_share_store.rs (L79-79)
```rust
            .map(|author| weights.get(author).expect("Author must exist for weight"))
```

**File:** consensus/src/rand/secret_sharing/secret_share_store.rs (L162-164)
```rust
        let share_weight = *share_weights
            .get(share.author())
            .expect("Author must exist in weights");
```

**File:** consensus/src/rand/secret_sharing/secret_share_store.rs (L217-231)
```rust
    pub fn new(
        epoch: u64,
        author: Author,
        dec_config: SecretShareConfig,
        decision_tx: Sender<SecretSharedKey>,
    ) -> Self {
        Self {
            epoch,
            self_author: author,
            secret_share_config: dec_config,
            secret_share_map: HashMap::new(),
            highest_known_round: 0,
            decision_tx,
        }
    }
```

**File:** consensus/src/rand/secret_sharing/secret_share_store.rs (L242-242)
```rust
        let peer_weights = self.secret_share_config.get_peer_weights();
```

**File:** types/src/secret_sharing.rs (L75-82)
```rust
    pub fn verify(&self, config: &SecretShareConfig) -> anyhow::Result<()> {
        let index = config.get_id(self.author());
        let decryption_key_share = self.share().clone();
        // TODO(ibalajiarun): Check index out of bounds
        config.verification_keys[index]
            .verify_decryption_key_share(&self.metadata.digest, &decryption_key_share)?;
        Ok(())
    }
```

**File:** types/src/secret_sharing.rs (L137-139)
```rust
    _author: Author,
    _epoch: u64,
    validator: Arc<ValidatorVerifier>,
```

**File:** types/src/secret_sharing.rs (L159-170)
```rust
        Self {
            _author: author,
            _epoch: epoch,
            validator,
            digest_key,
            msk_share,
            verification_keys,
            config,
            encryption_key,
            weights: HashMap::new(),
        }
    }
```

**File:** consensus/src/pipeline/execution_client.rs (L549-549)
```rust
            None,
```
