# Audit Report

## Title
Reentrancy Checker State Corruption on Frame Creation Failure

## Summary
The Move VM interpreter fails to maintain consistent reentrancy checker state when function frame creation fails. The `reentrancy_checker.enter_function()` modifies shared state before `make_call_frame()` is called, but if frame creation fails, the corresponding `exit_function()` is never called, leaving the reentrancy checker with inflated module entry counts and potentially elevated module lock levels.

## Finding Description

During function call setup in the interpreter, the execution flow follows this sequence: [1](#0-0) 

The reentrancy checker's `enter_function` modifies critical state: [2](#0-1) 

After this state modification, `make_call_frame` is invoked, which can fail at multiple points: [3](#0-2) 

Within `make_call_frame`, several operations can fail:
- Operand stack operations (popping arguments)
- Type checking and substitution
- Reference state transitions [4](#0-3) 

Additionally, `Frame::make_new_frame` itself can fail during gas charging: [5](#0-4) 

If any of these operations fail, the function returns an error immediately. However, the corresponding `exit_function` is only called on successful function returns: [6](#0-5) 

This creates an imbalanced state where:
1. `active_modules` hashmap has inflated entry counts for modules that were never actually entered
2. `module_lock_count` may be permanently elevated if the call type was locking
3. Subsequent calls within the same transaction to the same module will encounter incorrect reentrancy detection

## Impact Explanation

**Severity Assessment: Medium**

While this violates the "State Consistency" invariant, the impact is limited to the scope of a single failed transaction execution:

1. **No Consensus Violation**: The error paths are deterministic - all validators will fail at the same point with the same error, maintaining identical reentrancy checker states across the network. This preserves the "Deterministic Execution" invariant.

2. **Transaction-Local Corruption**: The corrupted reentrancy checker state exists only within the failed transaction's interpreter instance. When the transaction completes (with failure), this state is discarded and does not persist.

3. **Potential for False Rejections**: Within the failing transaction, if execution somehow continued (though current code paths all propagate errors upward), subsequent legitimate function calls could be incorrectly rejected due to false reentrancy detection.

However, this does represent a **state management bug** that violates proper error handling principles and could potentially be exploited if:
- Future code changes introduce error recovery mechanisms that allow execution to continue
- The reentrancy checker state becomes shared across transactions (current design doesn't do this)

## Likelihood Explanation

**Likelihood: High**

This issue can be triggered by any transaction that causes frame creation to fail, including:
- Gas exhaustion during type instantiation
- Type mismatches in function arguments
- Operand stack underflow conditions
- Reference state transition failures

These are common error conditions that can occur through normal operation or be intentionally triggered by an attacker. However, the security impact remains limited due to the deterministic nature of the errors and transaction-local scope of the corruption.

## Recommendation

Implement proper cleanup in `set_new_call_frame` to ensure reentrancy checker state is unwound on errors:

```rust
fn set_new_call_frame<RTTCheck: RuntimeTypeCheck, RTRCheck: RuntimeRefCheck>(
    &mut self,
    current_frame: &mut Frame,
    gas_meter: &mut impl GasMeter,
    function: Rc<LoadedFunction>,
    fn_guard: FnGuard,
    call_type: CallType,
    frame_cache: Rc<RefCell<FrameTypeCache>>,
    mask: ClosureMask,
    captured: Vec<Value>,
) -> VMResult<()> {
    self.reentrancy_checker
        .enter_function(
            Some(current_frame.function.module_or_script_id()),
            &function,
            call_type,
        )
        .map_err(|e| self.set_location(e))?;

    let mut frame = match self.make_call_frame::<RTTCheck, RTRCheck>(
        current_frame,
        gas_meter,
        function.clone(),
        fn_guard,
        call_type,
        frame_cache,
        mask,
        captured,
    ) {
        Ok(frame) => frame,
        Err(err) => {
            // CRITICAL: Unwind reentrancy checker on error
            let _ = self.reentrancy_checker.exit_function(
                current_frame.function.module_or_script_id(),
                &function,
                call_type,
            );
            return Err(self.attach_state_if_invariant_violation(
                self.set_location(err),
                current_frame,
            ));
        }
    };

    // Rest of the function remains the same...
    self.access_control
        .enter_function(&frame, &frame.function)
        .map_err(|e| self.set_location(e))?;

    std::mem::swap(current_frame, &mut frame);
    self.call_stack.push(frame).map_err(|frame| {
        let err = PartialVMError::new(StatusCode::CALL_STACK_OVERFLOW);
        let err = set_err_info!(frame, err);
        self.attach_state_if_invariant_violation(err, &frame)
    })?;
    Ok(())
}
```

## Proof of Concept

While a full runnable PoC requires setting up the entire Move VM test infrastructure, the vulnerability can be demonstrated through these steps:

1. Create a Move module with a function that has complex generic type parameters requiring substantial gas for type instantiation
2. Submit a transaction calling this function with minimal gas
3. Observe that `reentrancy_checker.enter_function()` succeeds but `make_call_frame()` fails during gas charging in `Frame::make_new_frame`
4. The transaction fails, but the reentrancy checker's `active_modules` map retains an entry count for the module
5. All validators experience identical behavior (deterministic failure)

The key observation is that while the bug is real, its security impact is minimal because the corrupted state is discarded with the failed transaction and all validators fail identically, preserving consensus.

## Notes

This finding represents a **correctness and robustness issue** rather than a critical security vulnerability. While it violates proper state management principles, the current architecture limits its exploitability because:

1. Error handling is deterministic across all validators
2. Interpreter state is per-transaction and not persisted
3. All error paths propagate upward without recovery mechanisms

However, this should still be fixed to prevent potential future security issues if the error handling or state management architecture changes.

### Citations

**File:** third_party/move/move-vm/runtime/src/interpreter.rs (L423-429)
```rust
                        self.reentrancy_checker
                            .exit_function(
                                frame.function.module_or_script_id(),
                                &current_frame.function,
                                current_frame.call_type(),
                            )
                            .map_err(|e| set_err_info!(current_frame, e))?;
```

**File:** third_party/move/move-vm/runtime/src/interpreter.rs (L892-898)
```rust
        self.reentrancy_checker
            .enter_function(
                Some(current_frame.function.module_or_script_id()),
                &function,
                call_type,
            )
            .map_err(|e| self.set_location(e))?;
```

**File:** third_party/move/move-vm/runtime/src/interpreter.rs (L900-913)
```rust
        let mut frame = self
            .make_call_frame::<RTTCheck, RTRCheck>(
                current_frame,
                gas_meter,
                function,
                fn_guard,
                call_type,
                frame_cache,
                mask,
                captured,
            )
            .map_err(|err| {
                self.attach_state_if_invariant_violation(self.set_location(err), current_frame)
            })?;
```

**File:** third_party/move/move-vm/runtime/src/interpreter.rs (L960-983)
```rust
                self.operand_stack.pop()?
            };
            locals.store_loc(i, value)?;

            if should_check && !is_captured {
                // Only perform paranoid type check for actual operands on the stack.
                // Captured arguments are already verified against function signature.
                let ty_args = function.ty_args();
                let ty = self.operand_stack.pop_ty()?;
                let expected_ty = &function.local_tys()[i];
                if !ty_args.is_empty() {
                    let expected_ty = self
                        .vm_config
                        .ty_builder
                        .create_ty_with_subst(expected_ty, ty_args)?;
                    // For parameter to argument, use assignability
                    ty.paranoid_check_assignable(&expected_ty)?;
                } else {
                    // Directly check against the expected type to save a clone here.
                    ty.paranoid_check_assignable(expected_ty)?;
                }
            }
        }
        RTRCheck::core_call_transition(&function, mask, &mut self.ref_state)?;
```

**File:** third_party/move/move-vm/runtime/src/reentrancy_checker.rs (L82-101)
```rust
            match self
                .active_modules
                .entry(callee.owner.interned_module_or_script_id())
            {
                Entry::Occupied(mut e) => {
                    if self.module_lock_count > 0 {
                        return Err(PartialVMError::new(StatusCode::RUNTIME_DISPATCH_ERROR)
                            .with_message(format!(
                                "Reentrancy disallowed: reentering `{}` via function `{}` \
                     (module lock is active)",
                                callee_module,
                                callee.name()
                            )));
                    }
                    *e.get_mut() += 1
                },
                Entry::Vacant(e) => {
                    e.insert(1);
                },
            }
```

**File:** third_party/move/move-vm/runtime/src/frame.rs (L177-179)
```rust
            for ty in function.local_tys() {
                gas_meter.charge_create_ty(NumTypeNodes::new(ty.num_nodes() as u64))?;
            }
```
