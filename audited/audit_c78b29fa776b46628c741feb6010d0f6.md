# Audit Report

## Title
Database Truncation Tool Can Set OverallCommitProgress to Partially-Committed Version Without Validation

## Summary
The database truncation tool's `run()` function in `storage/aptosdb/src/db_debugger/truncate/mod.rs` falls back to `get_usage_before_or_at()` when the target version lacks VersionData, but does not validate that the returned version contains complete transaction data before setting it as the new `OverallCommitProgress`. This can result in the database being set to a state where critical transaction data (transactions, transaction infos, events, write sets) is missing, violating the State Consistency invariant.

## Finding Description

During normal transaction commit, the `pre_commit_ledger` phase spawns multiple parallel tasks to write different database components: [1](#0-0) 

These tasks include:
1. Events (`commit_events`)
2. Write sets 
3. Transactions (`commit_transactions`)
4. Auxiliary info
5. **State KV and VersionData** (`commit_state_kv_and_ledger_metadata`)
6. Transaction infos (`commit_transaction_infos`)
7. Transaction accumulator

The VersionData is written via `put_usage` during the state KV commit: [2](#0-1) 

If a node crashes after `commit_state_kv_and_ledger_metadata` completes but before other parallel tasks finish, VersionData will exist at that version while transaction data may be incomplete. The `OverallCommitProgress` won't be updated since `commit_ledger` never runs.

The truncation tool bypasses normal database initialization by calling `open_dbs` directly, which does NOT invoke `sync_commit_progress`: [3](#0-2) 

Normal initialization would clean up partial commits via: [4](#0-3) 

When the target version lacks VersionData, the tool falls back without validation: [5](#0-4) 

The tool immediately sets `OverallCommitProgress` to this unvalidated version: [6](#0-5) 

Only AFTER setting `OverallCommitProgress` does it call `sync_commit_progress`, which now treats the potentially incomplete version as the source of truth: [7](#0-6) 

## Impact Explanation

This issue qualifies as **Medium Severity** per Aptos bug bounty criteria: "State inconsistencies requiring intervention."

If an operator uses the truncate tool on a database with partial commits, the database could end up with `OverallCommitProgress` pointing to a version missing critical data:
- Transactions (TransactionSchema)
- Transaction infos (TransactionInfoSchema)  
- Events (EventSchema)
- Write sets (WriteSetSchema)

When the node starts and attempts to serve this data, it will fail with "NotFound" errors, causing API failures and preventing the node from participating in consensus. This violates the **State Consistency** invariant: "State transitions must be atomic and verifiable via Merkle proofs."

## Likelihood Explanation

**Low to Medium likelihood:**

This requires:
1. A node crash during the narrow window when some parallel commit tasks complete but others don't
2. An operator running the truncate tool instead of normal database initialization
3. The operator choosing a target version that causes fallback to a partially-committed version

While the crash window is narrow, database corruption scenarios are precisely when operators use truncate tools, making this a realistic operational risk.

## Recommendation

Add validation after the fallback to ensure all critical transaction data exists:

```rust
if ledger_db.metadata_db().get_usage(target_version).is_err() {
    println!(
        "Unable to truncate to version {}, since there is no VersionData on that version.",
        target_version
    );
    println!(
        "Trying to fallback to the largest valid version before version {}.",
        target_version,
    );
    target_version = ledger_db
        .metadata_db()
        .get_usage_before_or_at(target_version)?
        .0;
    
    // VALIDATION: Ensure complete transaction data exists
    println!("Validating transaction data completeness at version {}...", target_version);
    ledger_db.transaction_db().get_transaction(target_version)
        .map_err(|e| anyhow::anyhow!("Transaction missing at fallback version {}: {}", target_version, e))?;
    ledger_db.transaction_info_db().get_transaction_info(target_version)
        .map_err(|e| anyhow::anyhow!("TransactionInfo missing at fallback version {}: {}", target_version, e))?;
    ledger_db.write_set_db().get_write_set(target_version)
        .map_err(|e| anyhow::anyhow!("WriteSet missing at fallback version {}: {}", target_version, e))?;
    println!("Validation passed.");
}
```

The validation methods are available: [8](#0-7) [9](#0-8) 

## Proof of Concept

```rust
// Reproduction steps:
// 1. Start a node and commit transactions to version 100
// 2. Manually edit the database to:
//    - Keep VersionData at version 100
//    - Delete transactions/transaction_infos/write_sets at version 100
//    - Set OverallCommitProgress to 99
// 3. Run: cargo run --bin db-debugger -- truncate --db-dir <path> --target-version 100 --opt-out-backup-checkpoint
// 4. The tool will fall back to version 100 (which has VersionData but no transactions)
// 5. OverallCommitProgress is set to 100
// 6. Starting the node will fail when trying to read transaction 100

// To verify the fix:
// Add validation as shown in Recommendation section
// Re-run step 3 - it should now fail with "Transaction missing at fallback version 100"
```

## Notes

While this vulnerability requires operator access to the db_debugger tool, it represents a legitimate operational risk where manual database repair could inadvertently create an inconsistent state. The fix is straightforward and should be implemented to prevent accidental database corruption during truncation operations.

### Citations

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L271-318)
```rust
        THREAD_MANAGER.get_non_exe_cpu_pool().scope(|s| {
            // TODO(grao): Write progress for each of the following databases, and handle the
            // inconsistency at the startup time.
            //
            // TODO(grao): Consider propagating the error instead of panic, if necessary.
            s.spawn(|_| {
                self.commit_events(
                    chunk.first_version,
                    chunk.transaction_outputs,
                    skip_index_and_usage,
                )
                .unwrap()
            });
            s.spawn(|_| {
                self.ledger_db
                    .write_set_db()
                    .commit_write_sets(chunk.first_version, chunk.transaction_outputs)
                    .unwrap()
            });
            s.spawn(|_| {
                self.ledger_db
                    .transaction_db()
                    .commit_transactions(
                        chunk.first_version,
                        chunk.transactions,
                        skip_index_and_usage,
                    )
                    .unwrap()
            });
            s.spawn(|_| {
                self.ledger_db
                    .persisted_auxiliary_info_db()
                    .commit_auxiliary_info(chunk.first_version, chunk.persisted_auxiliary_infos)
                    .unwrap()
            });
            s.spawn(|_| {
                self.commit_state_kv_and_ledger_metadata(chunk, skip_index_and_usage)
                    .unwrap()
            });
            s.spawn(|_| {
                self.commit_transaction_infos(chunk.first_version, chunk.transaction_infos)
                    .unwrap()
            });
            s.spawn(|_| {
                new_root_hash = self
                    .commit_transaction_accumulator(chunk.first_version, chunk.transaction_infos)
                    .unwrap()
            });
```

**File:** storage/aptosdb/src/state_store/mod.rs (L353-360)
```rust
        if !hack_for_tests && !empty_buffered_state_for_restore {
            Self::sync_commit_progress(
                Arc::clone(&ledger_db),
                Arc::clone(&state_kv_db),
                Arc::clone(&state_merkle_db),
                /*crash_if_difference_is_too_large=*/ true,
            );
        }
```

**File:** storage/aptosdb/src/state_store/mod.rs (L1017-1028)
```rust
    fn put_usage(state: &State, batch: &mut SchemaBatch) -> Result<()> {
        if let Some(version) = state.version() {
            let usage = state.usage();
            info!("Write usage at version {version}, {usage:?}.");
            batch.put::<VersionDataSchema>(&version, &usage.into())?;
        } else {
            assert_eq!(state.usage().items(), 0);
            assert_eq!(state.usage().bytes(), 0);
        }

        Ok(())
    }
```

**File:** storage/aptosdb/src/db_debugger/truncate/mod.rs (L74-82)
```rust
        let (ledger_db, hot_state_merkle_db, state_merkle_db, state_kv_db) = AptosDB::open_dbs(
            &StorageDirPaths::from_path(&self.db_dir),
            rocksdb_config,
            env,
            block_cache,
            /*readonly=*/ false,
            /*max_num_nodes_per_lru_cache_shard=*/ 0,
            /*reset_hot_state=*/ true,
        )?;
```

**File:** storage/aptosdb/src/db_debugger/truncate/mod.rs (L114-127)
```rust
        if ledger_db.metadata_db().get_usage(target_version).is_err() {
            println!(
                "Unable to truncate to version {}, since there is no VersionData on that version.",
                target_version
            );
            println!(
                "Trying to fallback to the largest valid version before version {}.",
                target_version,
            );
            target_version = ledger_db
                .metadata_db()
                .get_usage_before_or_at(target_version)?
                .0;
        }
```

**File:** storage/aptosdb/src/db_debugger/truncate/mod.rs (L130-135)
```rust
        let mut batch = SchemaBatch::new();
        batch.put::<DbMetadataSchema>(
            &DbMetadataKey::OverallCommitProgress,
            &DbMetadataValue::Version(target_version),
        )?;
        ledger_db.metadata_db().write_schemas(batch)?;
```

**File:** storage/aptosdb/src/db_debugger/truncate/mod.rs (L137-142)
```rust
        StateStore::sync_commit_progress(
            Arc::clone(&ledger_db),
            Arc::clone(&state_kv_db),
            Arc::clone(&state_merkle_db),
            /*crash_if_difference_is_too_large=*/ false,
        );
```

**File:** storage/aptosdb/src/ledger_db/transaction_db.rs (L56-60)
```rust
    pub(crate) fn get_transaction(&self, version: Version) -> Result<Transaction> {
        self.db
            .get::<TransactionSchema>(&version)?
            .ok_or_else(|| AptosDbError::NotFound(format!("Txn {version}")))
    }
```

**File:** storage/aptosdb/src/ledger_db/transaction_info_db.rs (L52-58)
```rust
    pub(crate) fn get_transaction_info(&self, version: Version) -> Result<TransactionInfo> {
        self.db
            .get::<TransactionInfoSchema>(&version)?
            .ok_or_else(|| {
                AptosDbError::NotFound(format!("No TransactionInfo at version {}", version))
            })
    }
```
