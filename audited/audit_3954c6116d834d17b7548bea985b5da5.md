# Audit Report

## Title
Race Condition in Asynchronous OIDC Provider Removal During DKG Reconfiguration

## Summary
When DKG-based reconfiguration is enabled, a critical race condition exists where a governance proposal to remove a compromised OIDC provider can be undermined during the DKG window. The provider removal from `SupportedOIDCProviders` is buffered (asynchronous), while its JWKs are immediately removed from `ObservedJWKs` (synchronous). However, validators continue watching the provider during the DKG window and can re-add malicious JWKs back into `ObservedJWKs`, making them available for transaction authentication before the provider is fully removed.

## Finding Description

The vulnerability stems from a state inconsistency during DKG-based epoch transitions. The code implements two different timing models for OIDC provider removal that create an exploitable window: [1](#0-0) 

The `upsert_oidc_provider_for_next_epoch()` and `remove_oidc_provider_for_next_epoch()` functions use the config buffer pattern, where changes are staged but only applied when `on_new_epoch()` is called during reconfiguration: [2](#0-1) 

However, governance proposals also call `remove_issuer_from_observed_jwks()` to immediately remove JWKs: [3](#0-2) 

When DKG is enabled, `aptos_governance::reconfigure()` starts the DKG process but doesn't immediately trigger the epoch change: [4](#0-3) 

During the DKG window, validators continue using the `SupportedOIDCProviders` from the current epoch (which still includes the provider to be removed): [5](#0-4) 

Validators spawn JWK observers for these providers and continuously watch them: [6](#0-5) 

The critical issue: `upsert_into_observed_jwks()` has no check preventing updates during a DKG-in-progress state: [7](#0-6) 

This function immediately calls `regenerate_patched_jwks()`, making the new JWKs available for authentication: [8](#0-7) 

Transaction authentication reads from `PatchedJWKs`: [9](#0-8) 

**Attack Scenario:**

1. Governance detects a compromised OIDC provider "malicious.com" and submits removal proposal
2. Proposal executes: `remove_oidc_provider_for_next_epoch()` buffers removal, `remove_issuer_from_observed_jwks()` immediately clears JWKs, then `reconfigure()` starts DKG
3. During DKG window (could be minutes):
   - `SupportedOIDCProviders` still lists "malicious.com" (buffered removal not applied)
   - Validators continue watching "malicious.com" based on epoch start configuration
   - Attacker publishes new malicious JWKs at "malicious.com"
   - Validators observe, reach consensus, and call `upsert_into_observed_jwks()`
   - Malicious JWKs are re-added to `ObservedJWKs` and `PatchedJWKs`
   - Transactions can now be authenticated using the malicious JWKs
4. Only when DKG completes does the provider actually get removed

## Impact Explanation

This is a **HIGH severity** vulnerability per Aptos bug bounty criteria:

- **Significant protocol violation**: The asynchronous reconfiguration mechanism fails to maintain security invariants during epoch transitions
- **Authentication bypass window**: During the DKG window (potentially several minutes), a compromised OIDC provider that governance explicitly tried to remove can have its JWKs re-introduced, allowing unauthorized transaction authentication
- **State consistency violation**: The system enters an inconsistent state where `SupportedOIDCProviders` (what validators should watch) and `ObservedJWKs` (what's used for authentication) are out of sync with governance intent

The vulnerability breaks the **Transaction Validation** invariant (prologue checks must enforce all invariants) and the **State Consistency** invariant (state transitions must be atomic).

## Likelihood Explanation

**Likelihood: HIGH**

The attack is highly feasible under realistic conditions:

1. **Triggering condition is common**: OIDC provider compromises or key rotations are regular security events requiring rapid response
2. **Attack window is substantial**: DKG can take several minutes to complete, providing ample time for exploitation
3. **No special privileges required**: Any attacker who controls or compromises an OIDC provider being removed can execute this attack
4. **Automatic validator behavior**: Validators automatically watch providers in `SupportedOIDCProviders` and submit observed JWKs without manual intervention
5. **No detection mechanism**: There's no monitoring to detect when JWKs are re-added to a provider that governance is trying to remove

The only requirement is that DKG reconfiguration is enabled and an OIDC provider is being removed for security reasons.

## Recommendation

Implement a synchronization mechanism to prevent validator JWK updates for providers pending removal. Multiple approaches:

**Option 1: Track pending removals**
Add a resource to track OIDC providers pending removal:
```move
struct PendingOIDCProviderRemovals has key {
    issuers: vector<vector<u8>>,
}
```

In `remove_oidc_provider_for_next_epoch()`, add the issuer to this list. In `upsert_into_observed_jwks()`, reject updates for issuers in the pending removal list. Clear the list in `on_new_epoch()`.

**Option 2: Block all JWK updates during DKG**
Add a check in `upsert_into_observed_jwks()`:
```move
assert!(!reconfiguration_state::is_in_progress(), error::invalid_state(ERECONFIGURATION_IN_PROGRESS));
```

This ensures no JWK updates occur during the DKG window, maintaining consistency.

**Option 3: Make removal synchronous when DKG is enabled**
Check if DKG is in progress in the governance proposal. If so, apply the removal immediately to `SupportedOIDCProviders` instead of buffering it, then call `reconfigure()`.

**Recommended fix: Option 1** - Most precise, only blocks updates for providers being removed while allowing other providers to update normally during DKG.

## Proof of Concept

```move
#[test(aptos_framework = @aptos_framework, validator = @0x123)]
fun test_oidc_provider_removal_race_condition(aptos_framework: &signer, validator: &signer) {
    // Setup: Initialize jwks and reconfiguration systems
    jwks::initialize_for_test(aptos_framework);
    reconfiguration_with_dkg::initialize_for_test(aptos_framework);
    
    // Add a provider
    jwks::upsert_oidc_provider_for_next_epoch(
        aptos_framework, 
        b"malicious.com", 
        b"https://malicious.com/.well-known/openid-configuration"
    );
    aptos_governance::force_end_epoch(aptos_framework); // Complete epoch transition
    
    // Verify provider is in ObservedJWKs with some JWKs
    let malicious_jwk = jwks::new_rsa_jwk(
        utf8(b"kid123"),
        utf8(b"RS256"),
        utf8(b"AQAB"),
        utf8(b"test_modulus")
    );
    jwks::upsert_into_observed_jwks(aptos_framework, vector[
        jwks::ProviderJWKs {
            issuer: b"malicious.com",
            version: 1,
            jwks: vector[malicious_jwk],
        }
    ]);
    
    // Governance removes the provider
    jwks::remove_oidc_provider_for_next_epoch(aptos_framework, b"malicious.com");
    jwks::remove_issuer_from_observed_jwks(aptos_framework, b"malicious.com");
    
    // Start DKG (async reconfiguration)
    enable_randomness_and_dkg(aptos_framework);
    aptos_governance::reconfigure(aptos_framework);
    
    // During DKG window: validator observes new JWKs from malicious.com
    // This should be blocked but currently succeeds
    let new_malicious_jwk = jwks::new_rsa_jwk(
        utf8(b"kid456"),
        utf8(b"RS256"),
        utf8(b"AQAB"),
        utf8(b"attacker_modulus")
    );
    jwks::upsert_into_observed_jwks(aptos_framework, vector[
        jwks::ProviderJWKs {
            issuer: b"malicious.com",
            version: 2,
            jwks: vector[new_malicious_jwk],
        }
    ]);
    
    // VULNERABILITY: JWKs from malicious.com are now available for authentication
    // even though governance tried to remove the provider
    let patched_jwk = jwks::try_get_patched_jwk(b"malicious.com", b"kid456");
    assert!(option::is_some(&patched_jwk), 1); // This passes - vulnerability confirmed!
    
    // Complete DKG and epoch transition
    aptos_governance::force_end_epoch(aptos_framework);
    
    // Now the provider is finally removed
    let patched_jwk_after = jwks::try_get_patched_jwk(b"malicious.com", b"kid456");
    assert!(option::is_none(&patched_jwk_after), 2);
}
```

This test demonstrates that during the DKG window, validators can re-add JWKs for a provider that governance is attempting to remove, creating a security window for unauthorized authentication.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/jwks.move (L317-330)
```text
    public fun upsert_oidc_provider_for_next_epoch(fx: &signer, name: vector<u8>, config_url: vector<u8>): Option<vector<u8>> acquires SupportedOIDCProviders {
        system_addresses::assert_aptos_framework(fx);

        let provider_set = if (config_buffer::does_exist<SupportedOIDCProviders>()) {
            config_buffer::extract_v2<SupportedOIDCProviders>()
        } else {
            *borrow_global<SupportedOIDCProviders>(@aptos_framework)
        };

        let old_config_url = remove_oidc_provider_internal(&mut provider_set, name);
        vector::push_back(&mut provider_set.providers, OIDCProvider { name, config_url });
        config_buffer::upsert(provider_set);
        old_config_url
    }
```

**File:** aptos-move/framework/aptos-framework/sources/jwks.move (L366-376)
```text
    public(friend) fun on_new_epoch(framework: &signer) acquires SupportedOIDCProviders {
        system_addresses::assert_aptos_framework(framework);
        if (config_buffer::does_exist<SupportedOIDCProviders>()) {
            let new_config = config_buffer::extract_v2<SupportedOIDCProviders>();
            if (exists<SupportedOIDCProviders>(@aptos_framework)) {
                *borrow_global_mut<SupportedOIDCProviders>(@aptos_framework) = new_config;
            } else {
                move_to(framework, new_config);
            }
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/jwks.move (L462-505)
```text
    public fun upsert_into_observed_jwks(fx: &signer, provider_jwks_vec: vector<ProviderJWKs>) acquires ObservedJWKs, PatchedJWKs, Patches {
        system_addresses::assert_aptos_framework(fx);
        let observed_jwks = borrow_global_mut<ObservedJWKs>(@aptos_framework);

        if (features::is_jwk_consensus_per_key_mode_enabled()) {
            vector::for_each(provider_jwks_vec, |proposed_provider_jwks|{
                let maybe_cur_issuer_jwks = remove_issuer(&mut observed_jwks.jwks, proposed_provider_jwks.issuer);
                let cur_issuer_jwks = if (option::is_some(&maybe_cur_issuer_jwks)) {
                    option::extract(&mut maybe_cur_issuer_jwks)
                } else {
                    ProviderJWKs {
                        issuer: proposed_provider_jwks.issuer,
                        version: 0,
                        jwks: vector[],
                    }
                };
                assert!(cur_issuer_jwks.version + 1 == proposed_provider_jwks.version, error::invalid_argument(EUNEXPECTED_VERSION));
                vector::for_each(proposed_provider_jwks.jwks, |jwk|{
                    let variant_type_name = *string::bytes(copyable_any::type_name(&jwk.variant));
                    let is_delete = if (variant_type_name == b"0x1::jwks::UnsupportedJWK") {
                        let repr = copyable_any::unpack<UnsupportedJWK>(jwk.variant);
                        &repr.payload == &DELETE_COMMAND_INDICATOR
                    } else {
                        false
                    };
                    if (is_delete) {
                        remove_jwk(&mut cur_issuer_jwks, get_jwk_id(&jwk));
                    } else {
                        upsert_jwk(&mut cur_issuer_jwks, jwk);
                    }
                });
                cur_issuer_jwks.version = cur_issuer_jwks.version + 1;
                upsert_provider_jwks(&mut observed_jwks.jwks, cur_issuer_jwks);
            });
        } else {
            vector::for_each(provider_jwks_vec, |provider_jwks| {
                upsert_provider_jwks(&mut observed_jwks.jwks, provider_jwks);
            });
        };

        let epoch = reconfiguration::current_epoch();
        emit(ObservedJWKsUpdated { epoch, jwks: observed_jwks.jwks });
        regenerate_patched_jwks();
    }
```

**File:** aptos-move/framework/aptos-framework/sources/jwks.move (L522-531)
```text
    /// Regenerate `PatchedJWKs` from `ObservedJWKs` and `Patches` and save the result.
    fun regenerate_patched_jwks() acquires PatchedJWKs, Patches, ObservedJWKs {
        let jwks = borrow_global<ObservedJWKs>(@aptos_framework).jwks;
        let patches = borrow_global<Patches>(@aptos_framework);
        vector::for_each_ref(&patches.patches, |obj|{
            let patch: &Patch = obj;
            apply_patch(&mut jwks, *patch);
        });
        *borrow_global_mut<PatchedJWKs>(@aptos_framework) = PatchedJWKs { jwks };
    }
```

**File:** aptos-move/aptos-release-builder/src/components/oidc_providers.rs (L64-77)
```rust
        } => {
            emitln!(
                writer,
                "jwks::remove_oidc_provider_for_next_epoch({}, b\"{}\");",
                signer_arg,
                issuer
            );
            if !keep_observed_jwks {
                emitln!(
                    writer,
                    "jwks::remove_issuer_from_observed_jwks({}, b\"{}\");",
                    signer_arg,
                    issuer
                );
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L685-692)
```text
    public entry fun reconfigure(aptos_framework: &signer) {
        system_addresses::assert_aptos_framework(aptos_framework);
        if (consensus_config::validator_txn_enabled() && randomness_config::enabled()) {
            reconfiguration_with_dkg::try_start();
        } else {
            reconfiguration_with_dkg::finish(aptos_framework);
        }
    }
```

**File:** crates/aptos-jwk-consensus/src/epoch_manager.rs (L177-195)
```rust
        let (jwk_manager_should_run, oidc_providers) = match jwk_consensus_config {
            Ok(config) => {
                let should_run =
                    config.jwk_consensus_enabled() && onchain_consensus_config.is_vtxn_enabled();
                let providers = config
                    .oidc_providers_cloned()
                    .into_iter()
                    .map(jwks::OIDCProvider::from)
                    .collect();
                (should_run, Some(SupportedOIDCProviders { providers }))
            },
            Err(_) => {
                //TODO: remove this case once the framework change of this commit is published.
                let should_run = features.is_enabled(FeatureFlag::JWK_CONSENSUS)
                    && onchain_consensus_config.is_vtxn_enabled();
                let providers = payload.get::<SupportedOIDCProviders>().ok();
                (should_run, providers)
            },
        };
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager/mod.rs (L108-134)
```rust
        this.jwk_observers = oidc_providers
            .unwrap_or_default()
            .into_provider_vec()
            .into_iter()
            .filter_map(|provider| {
                let OIDCProvider { name, config_url } = provider;
                let maybe_issuer = String::from_utf8(name);
                let maybe_config_url = String::from_utf8(config_url);
                match (maybe_issuer, maybe_config_url) {
                    (Ok(issuer), Ok(config_url)) => Some(JWKObserver::spawn(
                        this.epoch_state.epoch,
                        this.my_addr,
                        issuer,
                        config_url,
                        Duration::from_secs(10),
                        local_observation_tx.clone(),
                    )),
                    (maybe_issuer, maybe_config_url) => {
                        warn!(
                            "unable to spawn observer, issuer={:?}, config_url={:?}",
                            maybe_issuer, maybe_config_url
                        );
                        None
                    },
                }
            })
            .collect();
```

**File:** aptos-move/aptos-vm/src/keyless_validation.rs (L91-94)
```rust
fn get_jwks_onchain(resolver: &impl AptosMoveResolver) -> anyhow::Result<PatchedJWKs, VMStatus> {
    PatchedJWKs::fetch_config(resolver)
        .ok_or_else(|| value_deserialization_error!("could not deserialize PatchedJWKs"))
}
```
