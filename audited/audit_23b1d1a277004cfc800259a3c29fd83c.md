# Audit Report

## Title
Epoch Boundary Bug in Consensus Observer Causes Critical Block Drops During Epoch Transitions

## Summary
The `get_last_ordered_block()` function in the consensus observer incorrectly handles epoch boundaries due to lexicographic tuple comparison. When blocks from different epochs coexist in the `ordered_blocks` BTreeMap, the function returns blocks from newer epochs, causing legitimate blocks from previous epochs to be incorrectly marked as "out of date" and dropped. This breaks consensus observer liveness and forces unnecessary state sync operations.

## Finding Description

The vulnerability exists in the consensus observer's block ordering logic. The `OrderedBlockStore` uses a BTreeMap with keys `(epoch, round)` to store ordered blocks. [1](#0-0) 

The `get_last_ordered_block()` function retrieves the last entry using `last_key_value()`, which returns the lexicographically largest key. [2](#0-1) 

This function is used to determine if incoming blocks or payloads are "out of date" by comparing them against the last ordered block. [3](#0-2) 

**The Attack Path:**

1. Node has blocks from epoch 10 in the ordered store: `(10, 98)`, `(10, 99)` (waiting for block `(10, 100)` to complete the epoch)
2. Network transitions to epoch 11
3. Due to network latency or peer selection, the node receives block `(11, 0)` from epoch 11 BEFORE receiving the final block `(10, 100)` from epoch 10
4. Block `(11, 0)` is added to the BTreeMap: `ordered_blocks` now contains `[(10, 98), (10, 99), (11, 0)]`
5. `get_last_ordered_block()` returns block `(11, 0)` because `(11, 0) > (10, 99)` in lexicographic order
6. When block `(10, 100)` finally arrives:
   - The comparison at line 369: `(10, 100) <= (11, 0)` evaluates to TRUE
   - Block `(10, 100)` is marked as "out of date" and DROPPED
   - Same issue occurs for ordered blocks at line 679-680 [4](#0-3) 
7. Node cannot complete epoch 10 execution and must fall back to state sync

The same vulnerability affects commit decision processing, where epoch change detection relies on comparing commit epoch against the last ordered block's epoch. [5](#0-4) 

If a commit decision for epoch 10 arrives after blocks from epoch 11 are in the store, the code incorrectly determines `epoch_changed = false` because `commit_epoch (10) > last_block.epoch() (11)` is false.

## Impact Explanation

This is a **High Severity** vulnerability per Aptos bug bounty criteria:

1. **Validator Node Slowdowns**: Consensus observers experiencing this bug must fall back to state sync, significantly degrading performance during epoch transitions
2. **Network-Wide Impact**: If multiple consensus observers are affected simultaneously during an epoch transition, it creates cascading performance degradation
3. **Consensus Liveness Impact**: While not a full consensus safety violation, it affects the liveness guarantee that nodes should be able to process blocks continuously
4. **Forced State Sync**: Nodes unnecessarily invoke state sync, consuming bandwidth and computational resources

The bug affects **Consensus Safety/Liveness** invariants - specifically that all validators should be able to process ordered blocks without arbitrary drops. It violates the expectation that consensus observers can track consensus progress without gaps.

## Likelihood Explanation

**High Likelihood** - This bug will trigger during normal network operation:

1. **Frequent Occurrence**: Epoch transitions happen regularly (every few hours in Aptos)
2. **No Attacker Required**: Natural network latency and peer selection can cause blocks from different epochs to arrive out of order
3. **Race Condition**: The window is wide - any time between when the first epoch N+1 block arrives and when the last epoch N block arrives
4. **Multiple Call Sites**: The vulnerability exists in multiple locations where `get_last_ordered_block()` is used for comparison (payload handling, ordered block handling, commit decision processing)

An attacker could amplify the impact by:
- Preferentially sending epoch N+1 blocks to observers before epoch N completion
- However, this requires no special privileges - any peer can send blocks

## Recommendation

**Fix Option 1: Compare epochs separately in staleness checks**

Modify the staleness comparison logic to handle epoch boundaries explicitly:

```rust
// In consensus_observer.rs, replace simple tuple comparison with epoch-aware logic
let last_ordered_block = self.observer_block_data.lock().get_last_ordered_block();
let payload_out_of_date = if block_epoch == last_ordered_block.epoch() {
    // Same epoch: compare rounds normally
    block_round <= last_ordered_block.round()
} else {
    // Different epochs: only out of date if block is from an older epoch
    block_epoch < last_ordered_block.epoch()
};
```

**Fix Option 2: Track highest committed epoch separately**

Add a field to track the highest committed epoch and only compare blocks within the same epoch:

```rust
// In ordered_blocks.rs
pub struct OrderedBlockStore {
    consensus_observer_config: ConsensusObserverConfig,
    highest_committed_epoch_round: Option<(u64, Round)>,
    current_epoch: u64,  // Add this
    ordered_blocks: BTreeMap<(u64, Round), (ObservedOrderedBlock, Option<CommitDecision>)>,
}

// Clear old epoch blocks when advancing epochs
pub fn advance_to_epoch(&mut self, new_epoch: u64) {
    if new_epoch > self.current_epoch {
        // Remove all blocks from old epochs
        self.ordered_blocks.retain(|(epoch, _), _| *epoch >= new_epoch);
        self.current_epoch = new_epoch;
    }
}
```

**Fix Option 3: Use separate BTreeMaps per epoch**

Restructure to maintain separate stores per epoch, preventing cross-epoch contamination entirely.

## Proof of Concept

```rust
#[cfg(test)]
mod test {
    use super::*;
    
    #[test]
    fn test_epoch_boundary_bug() {
        // Create ordered block store
        let mut ordered_block_store = OrderedBlockStore::new(ConsensusObserverConfig::default());
        
        // Add blocks from epoch 10
        let epoch_10_blocks = create_and_add_ordered_blocks(&mut ordered_block_store, 2, 10);
        // Store now has: (10, 0), (10, 1)
        
        // Verify last block is from epoch 10
        let last_block = ordered_block_store.get_last_ordered_block().unwrap();
        assert_eq!(last_block.epoch(), 10);
        assert_eq!(last_block.round(), 1);
        
        // Add block from epoch 11 (simulating epoch transition where new epoch block arrives first)
        let epoch_11_blocks = create_and_add_ordered_blocks(&mut ordered_block_store, 1, 11);
        // Store now has: (10, 0), (10, 1), (11, 0)
        
        // BUG: get_last_ordered_block() now returns epoch 11 block
        let last_block = ordered_block_store.get_last_ordered_block().unwrap();
        assert_eq!(last_block.epoch(), 11); // Returns epoch 11
        assert_eq!(last_block.round(), 0);
        
        // This causes the staleness check to fail for legitimate epoch 10 blocks
        // If we tried to add block (10, 2) now, the comparison would be:
        // (10, 2) <= (11, 0) = TRUE (due to lexicographic ordering)
        // So block (10, 2) would be incorrectly dropped as "out of date"
        
        // Demonstrate the incorrect comparison
        let new_epoch_10_block = (10_u64, 2_u64);
        let last_block_tuple = (last_block.epoch(), last_block.round());
        let would_be_dropped = new_epoch_10_block <= last_block_tuple;
        
        assert!(would_be_dropped, "BUG: Legitimate epoch 10 block would be dropped!");
    }
    
    // Helper function to create blocks (same as in existing tests)
    fn create_and_add_ordered_blocks(
        ordered_block_store: &mut OrderedBlockStore,
        num_ordered_blocks: usize,
        epoch: u64,
    ) -> Vec<OrderedBlock> {
        // Implementation matches existing test helper
        // Creates and inserts blocks for the given epoch
        // Returns the created ordered blocks
        vec![] // Placeholder
    }
}
```

**Notes**

The vulnerability is particularly insidious because:
1. The existing test at line 385-400 tests epoch transitions but doesn't test the case where blocks from BOTH epochs coexist before old epoch blocks are removed [6](#0-5) 
2. The `remove_blocks_for_commit()` function correctly handles epoch boundaries when removing committed blocks, but there's a race window before commits arrive [7](#0-6) 
3. This affects consensus observers specifically, which are critical for network observability and light client operation

The fix should ensure that epoch boundaries are handled explicitly in all comparison logic, rather than relying on lexicographic tuple ordering which doesn't correctly model epoch semantics.

### Citations

**File:** consensus/src/consensus_observer/observer/ordered_blocks.rs (L26-28)
```rust
    // Ordered blocks. The key is the epoch and round of the last block in the
    // ordered block. Each entry contains the block and the commit decision (if any).
    ordered_blocks: BTreeMap<(u64, Round), (ObservedOrderedBlock, Option<CommitDecision>)>,
```

**File:** consensus/src/consensus_observer/observer/ordered_blocks.rs (L57-64)
```rust
    /// Returns the last ordered block (if any)
    pub fn get_last_ordered_block(&self) -> Option<Arc<PipelinedBlock>> {
        self.ordered_blocks
            .last_key_value()
            .map(|(_, (observed_ordered_block, _))| {
                observed_ordered_block.ordered_block().last_block()
            })
    }
```

**File:** consensus/src/consensus_observer/observer/ordered_blocks.rs (L112-124)
```rust
    pub fn remove_blocks_for_commit(&mut self, commit_ledger_info: &LedgerInfoWithSignatures) {
        // Determine the epoch and round to split off
        let split_off_epoch = commit_ledger_info.ledger_info().epoch();
        let split_off_round = commit_ledger_info.commit_info().round().saturating_add(1);

        // Remove the blocks from the ordered blocks
        self.ordered_blocks = self
            .ordered_blocks
            .split_off(&(split_off_epoch, split_off_round));

        // Update the highest committed epoch and round
        self.update_highest_committed_epoch_round(commit_ledger_info);
    }
```

**File:** consensus/src/consensus_observer/observer/ordered_blocks.rs (L385-400)
```rust
        // Insert several ordered blocks for the next epoch
        let next_epoch = current_epoch + 1;
        let num_ordered_blocks = 50;
        let ordered_blocks =
            create_and_add_ordered_blocks(&mut ordered_block_store, num_ordered_blocks, next_epoch);

        // Verify the last ordered block is the block with the highest epoch and round
        let last_ordered_block = ordered_blocks.last().unwrap();
        let last_ordered_block_info = last_ordered_block.last_block().block_info();
        assert_eq!(
            last_ordered_block_info,
            ordered_block_store
                .get_last_ordered_block()
                .unwrap()
                .block_info()
        );
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L367-380)
```rust
        let last_ordered_block = self.observer_block_data.lock().get_last_ordered_block();
        let payload_out_of_date =
            (block_epoch, block_round) <= (last_ordered_block.epoch(), last_ordered_block.round());
        let payload_exists = self
            .observer_block_data
            .lock()
            .existing_payload_entry(&block_payload);

        // If the payload is out of date or already exists, ignore it
        if payload_out_of_date || payload_exists {
            // Update the metrics for the dropped block payload
            update_metrics_for_dropped_block_payload_message(peer_network_id, &block_payload);
            return;
        }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L502-504)
```rust
        let last_block = self.observer_block_data.lock().get_last_ordered_block();
        let epoch_changed = commit_epoch > last_block.epoch();
        if epoch_changed || commit_round > last_block.round() {
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L677-691)
```rust
        // Determine if the block is behind the last ordered block, or if it is already pending
        let last_ordered_block = self.observer_block_data.lock().get_last_ordered_block();
        let block_out_of_date =
            first_block_epoch_round <= (last_ordered_block.epoch(), last_ordered_block.round());
        let block_pending = self
            .observer_block_data
            .lock()
            .existing_pending_block(&ordered_block);

        // If the block is out of date or already pending, ignore it
        if block_out_of_date || block_pending {
            // Update the metrics for the dropped ordered block
            update_metrics_for_dropped_ordered_block_message(peer_network_id, &ordered_block);
            return;
        }
```
