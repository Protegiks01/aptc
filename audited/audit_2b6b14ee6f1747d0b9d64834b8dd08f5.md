# Audit Report

## Title
Missing Eval Proof Validation in prepare_individual() Allows Batch Context Mixing

## Summary
The `prepare_individual()` function in the batch encryption module accepts a digest and eval_proof without validating that the eval_proof was derived from that specific digest. This missing validation could allow proofs from different batches to be mixed, potentially causing consensus divergence if validators use mismatched proof/digest pairs.

## Finding Description

The `prepare_individual()` function processes individual ciphertexts for decryption by computing pairing operations using both a digest and an eval_proof: [1](#0-0) 

The function performs pairing computations without validating that the eval_proof is actually valid for the provided digest. The digest module provides a verification function that can check this relationship: [2](#0-1) 

However, `prepare_individual()` never calls this verification function. In contrast, test code demonstrates that eval_proofs should be verified against their corresponding digest: [3](#0-2) 

**Consensus Impact:**

Eval_proofs are stored in the transaction payload after decryption and become part of the consensus-committed data: [4](#0-3) [5](#0-4) 

If different validators use different eval_proofs (from different batches) for the same ciphertext, they would commit different transaction payloads, violating the **Deterministic Execution** invariant and causing consensus disagreement.

**Current Mitigation:**

The current consensus code computes eval_proofs deterministically: [6](#0-5) 

All honest validators compute identical digests and eval_proofs, so the missing validation doesn't currently cause issues.

## Impact Explanation

**Severity: Medium**

This is a defensive programming vulnerability rather than a directly exploitable attack:

- **Not Critical** because there is no current attack path in the existing codebase
- **Not High** because it requires a separate bug to trigger (non-deterministic eval_proof computation)
- **Medium** because:
  1. If triggered by a future bug, it would cause consensus divergence (Critical impact)
  2. The missing validation violates defense-in-depth principles
  3. It creates a footgun for future code modifications
  4. The verification function exists but is not used where it should be

While not immediately exploitable, this represents a state inconsistency risk requiring intervention (Medium severity per bug bounty criteria).

## Likelihood Explanation

**Likelihood: Low**

- Requires a bug in eval_proof computation or batch management to trigger
- Current code paths all use matching digest/eval_proof pairs deterministically
- Would need either:
  - A non-determinism bug in eval_proof calculation, OR
  - A cache/state management bug causing proof reuse across batches, OR
  - Future code changes that introduce mismatches

## Recommendation

Add validation in `prepare_individual()` to verify the eval_proof matches the digest:

```rust
fn prepare_individual(
    &self,
    digest: &Digest,
    eval_proof: &EvalProof,
) -> Result<PreparedBIBECiphertext> {
    // ADD VALIDATION HERE - requires digest_key parameter
    // digest_key.verify_pf(digest, self.id, **eval_proof)?;
    
    let pairing_output = PairingSetting::pairing(digest.as_g1(), self.ct_g2[0])
        + PairingSetting::pairing(**eval_proof, self.ct_g2[1]);

    Ok(PreparedBIBECiphertext {
        pairing_output,
        ct_g2: self.ct_g2[2].into(),
        padded_key: self.padded_key.clone(),
        symmetric_ciphertext: self.symmetric_ciphertext.clone(),
    })
}
```

**Note:** This requires refactoring to pass `DigestKey` to the function, or performing validation at a higher level (e.g., in the consensus pipeline) before calling `prepare_individual()`.

## Proof of Concept

Cannot provide a working PoC because:
1. The current code has no path for eval_proof/digest mismatch to occur
2. Demonstrating the vulnerability would require first introducing a separate bug (non-deterministic eval_proof computation)
3. The issue is a missing defensive check, not an active vulnerability

A theoretical PoC would:
1. Compute digest_A for batch A and eval_proofs_A  
2. Compute digest_B for batch B
3. Call `ct.prepare_individual(digest_B, eval_proof_A[id])`
4. Observe that no error occurs (missing validation)
5. Show that different validators using different eval_proofs commit different transaction data

However, this scenario cannot occur in the current codebase without introducing additional bugs.

---

**Notes:**

After thorough investigation, while `prepare_individual()` does lack validation that eval_proof matches the digest, this represents a **defensive programming gap** rather than a directly exploitable vulnerability. The current consensus code ensures all validators compute identical eval_proofs deterministically, preventing actual exploitation. This issue is best classified as Medium severity due to its potential to amplify future bugs into consensus violations, but it does not constitute a standalone attack vector under the current implementation.

### Citations

**File:** crates/aptos-batch-encryption/src/shared/ciphertext/bibe.rs (L92-106)
```rust
    fn prepare_individual(
        &self,
        digest: &Digest,
        eval_proof: &EvalProof,
    ) -> Result<PreparedBIBECiphertext> {
        let pairing_output = PairingSetting::pairing(digest.as_g1(), self.ct_g2[0])
            + PairingSetting::pairing(**eval_proof, self.ct_g2[1]);

        Ok(PreparedBIBECiphertext {
            pairing_output,
            ct_g2: self.ct_g2[2].into(),
            padded_key: self.padded_key.clone(),
            symmetric_ciphertext: self.symmetric_ciphertext.clone(),
        })
    }
```

**File:** crates/aptos-batch-encryption/src/shared/digest.rs (L138-146)
```rust
    fn verify_pf(&self, digest: &Digest, id: Id, pf: G1Affine) -> Result<()> {
        // TODO use multipairing here?
        Ok((PairingSetting::pairing(
            pf,
            self.tau_g2 - G2Projective::from(G2Affine::generator() * id.x()),
        ) == PairingSetting::pairing(digest.as_g1(), G2Affine::generator()))
        .then_some(())
        .ok_or(BatchEncryptionError::EvalProofVerifyError)?)
    }
```

**File:** crates/aptos-batch-encryption/src/shared/digest.rs (L254-277)
```rust
    fn compute_and_verify_all_opening_proofs() {
        let batch_capacity = 8;
        let num_rounds = 4;
        let mut rng = thread_rng();
        let setup = DigestKey::new(&mut rng, batch_capacity, num_rounds * batch_capacity).unwrap();

        for current_batch_size in 1..=batch_capacity {
            let mut ids = IdSet::with_capacity(batch_capacity).unwrap();
            let mut counter = Fr::zero();

            for _ in 0..current_batch_size {
                ids.add(&Id::new(counter));
                counter += Fr::one();
            }

            ids.compute_poly_coeffs();

            for round in 0..num_rounds {
                let (d, pfs_promise) = setup.digest(&mut ids, round as u64).unwrap();
                let pfs = pfs_promise.compute_all(&setup);
                setup.verify_all(&d, &pfs).unwrap();
            }
        }
    }
```

**File:** types/src/transaction/encrypted_payload.rs (L54-63)
```rust
    Decrypted {
        ciphertext: Ciphertext,
        extra_config: TransactionExtraConfig,
        payload_hash: HashValue,
        eval_proof: EvalProof,

        // decrypted things
        executable: TransactionExecutable,
        decryption_nonce: u64,
    },
```

**File:** consensus/src/pipeline/decryption_pipeline_builder.rs (L92-113)
```rust
        let (digest, proofs_promise) =
            FPTXWeighted::digest(&digest_key, &txn_ciphertexts, encryption_round)?;

        let metadata = SecretShareMetadata::new(
            block.epoch(),
            block.round(),
            block.timestamp_usecs(),
            block.id(),
            digest.clone(),
        );

        let derived_key_share = FPTXWeighted::derive_decryption_key_share(&msk_share, &digest)?;
        derived_self_key_share_tx
            .send(Some(SecretShare::new(
                author,
                metadata.clone(),
                derived_key_share,
            )))
            .expect("must send properly");

        // TODO(ibalajiarun): improve perf
        let proofs = FPTXWeighted::eval_proofs_compute_all(&proofs_promise, &digest_key);
```

**File:** consensus/src/pipeline/decryption_pipeline_builder.rs (L125-137)
```rust
                let eval_proof = proofs.get(&ciphertext.id()).expect("must exist");
                if let Ok(payload) = FPTXWeighted::decrypt_individual::<DecryptedPayload>(
                    &decryption_key.key,
                    &ciphertext,
                    &digest,
                    &eval_proof,
                ) {
                    let (executable, nonce) = payload.unwrap();
                    txn.payload_mut()
                        .as_encrypted_payload_mut()
                        .map(|p| {
                            p.into_decrypted(eval_proof, executable, nonce)
                                .expect("must happen")
```
