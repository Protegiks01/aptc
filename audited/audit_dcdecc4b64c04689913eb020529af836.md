# Audit Report

## Title
Division by Zero Panic in Mempool Due to Unvalidated `num_sender_buckets` Configuration

## Summary
The `MempoolConfig` struct uses `#[serde(default)]` without proper validation in its `sanitize()` method, allowing `num_sender_buckets` to be set to zero. This causes a division by zero panic during transaction processing, resulting in complete node crashes and loss of availability. [1](#0-0) 

## Finding Description

The vulnerability exists in the configuration deserialization and validation chain:

1. **Missing Validation**: The `MempoolConfig::sanitize()` method contains only a TODO comment and performs no validation: [2](#0-1) 

2. **Critical Field**: The `num_sender_buckets` field (u8 type) controls sender bucket distribution: [3](#0-2) 

3. **Division by Zero**: The `sender_bucket()` function performs modulo operation with `num_sender_buckets`, causing panic when zero: [4](#0-3) 

4. **Empty Timeline Index**: When `num_sender_buckets` is 0, the initialization loop creates an empty `timeline_index`: [5](#0-4) 

5. **Multiple Panic Points**: The function is called during transaction processing with subsequent `.unwrap()` calls that also panic: [6](#0-5) 

**Attack Path**:
1. Node operator creates config file: `mempool: { num_sender_buckets: 0 }`
2. Config deserializes successfully due to `#[serde(default)]`
3. No validation occurs (empty `sanitize()` implementation)
4. Node initializes `CoreMempool::new(config)` successfully [7](#0-6) 
5. First transaction triggers `process_ready_transaction()` → `sender_bucket()` → **PANIC: division by zero**
6. Mempool thread crashes, node becomes unavailable

## Impact Explanation

This is a **HIGH Severity** vulnerability per Aptos Bug Bounty criteria:

- **Validator node crashes**: Any validator or fullnode with this misconfiguration crashes immediately upon receiving transactions
- **API crashes**: The mempool service becomes completely unavailable
- **Loss of liveness**: Affected nodes cannot process transactions or participate in consensus
- **No privileged access required**: Any node operator can misconfigure their own node

The vulnerability breaks the **Resource Limits** invariant (#9) which requires "all operations must respect gas, storage, and computational limits" - the configuration system should prevent invalid values that cause crashes.

While this doesn't affect the entire network (only misconfigured nodes), it represents a significant operational risk as operators may unknowingly deploy invalid configurations, especially during automated deployments or config management.

## Likelihood Explanation

**Likelihood: Medium to High**

- **Easy to trigger**: Simply setting `num_sender_buckets: 0` in the config file causes the crash
- **No security expertise required**: Any node operator can accidentally or intentionally cause this
- **Silent failure**: Config validation passes, node starts successfully, crashes only on first transaction
- **Automation risk**: Automated config generation tools could produce invalid configs
- **Similar fields at risk**: Other fields like `capacity_per_user` or `capacity_bytes` set to 0 would cause different operational issues (transaction rejection rather than crash)

The TODO comment in the sanitize method indicates this validation was always intended but never implemented: [8](#0-7) 

## Recommendation

Implement comprehensive validation in `MempoolConfig::sanitize()`:

```rust
impl ConfigSanitizer for MempoolConfig {
    fn sanitize(
        _node_config: &NodeConfig,
        _node_type: NodeType,
        _chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        // Validate num_sender_buckets is non-zero
        if self.num_sender_buckets == 0 {
            return Err(Error::ConfigSanitizerError(
                "mempool.num_sender_buckets must be greater than 0".to_string(),
            ));
        }
        
        // Validate capacity fields are non-zero
        if self.capacity == 0 {
            return Err(Error::ConfigSanitizerError(
                "mempool.capacity must be greater than 0".to_string(),
            ));
        }
        
        if self.capacity_bytes == 0 {
            return Err(Error::ConfigSanitizerError(
                "mempool.capacity_bytes must be greater than 0".to_string(),
            ));
        }
        
        if self.capacity_per_user == 0 {
            return Err(Error::ConfigSanitizerError(
                "mempool.capacity_per_user must be greater than 0".to_string(),
            ));
        }
        
        if self.orderless_txn_capacity_per_user == 0 {
            return Err(Error::ConfigSanitizerError(
                "mempool.orderless_txn_capacity_per_user must be greater than 0".to_string(),
            ));
        }
        
        // Validate batch size doesn't exceed max message size
        if self.shared_mempool_max_batch_bytes > MAX_APPLICATION_MESSAGE_SIZE as u64 {
            return Err(Error::ConfigSanitizerError(
                format!("mempool.shared_mempool_max_batch_bytes ({}) exceeds MAX_APPLICATION_MESSAGE_SIZE ({})",
                    self.shared_mempool_max_batch_bytes, MAX_APPLICATION_MESSAGE_SIZE),
            ));
        }
        
        Ok(())
    }
}
```

## Proof of Concept

```rust
#[cfg(test)]
mod test_config_vulnerability {
    use super::*;
    use aptos_config::config::NodeConfig;
    use aptos_types::transaction::{RawTransaction, Script, SignedTransaction, TransactionPayload};
    use aptos_crypto::{ed25519::Ed25519PrivateKey, PrivateKey, Uniform};
    
    #[test]
    #[should_panic(expected = "attempt to calculate the remainder with a divisor of zero")]
    fn test_num_sender_buckets_zero_causes_panic() {
        // Create config with num_sender_buckets set to 0
        let mut config = NodeConfig::generate_random_config();
        config.mempool.num_sender_buckets = 0;
        
        // This succeeds - no validation occurs
        let mempool = crate::core_mempool::CoreMempool::new(&config);
        
        // Create a test transaction
        let sender = aptos_types::account_address::AccountAddress::random();
        let private_key = Ed25519PrivateKey::generate_for_testing();
        let public_key = private_key.public_key();
        
        let raw_txn = RawTransaction::new(
            sender,
            0,
            TransactionPayload::Script(Script::new(vec![], vec![], vec![])),
            1000,
            1,
            100000,
            aptos_types::chain_id::ChainId::test(),
        );
        
        let signed_txn = SignedTransaction::new(
            raw_txn,
            public_key,
            private_key.sign(&raw_txn).unwrap(),
        );
        
        // This panics with division by zero when sender_bucket() is called
        let _ = mempool.add_txn(
            signed_txn,
            0,
            0,
            std::time::SystemTime::now(),
            aptos_types::transaction::use_case::UseCaseKey::Platform,
        );
    }
}
```

## Notes

Additional configuration fields that require validation but currently have none:
- `capacity`, `capacity_bytes`, `capacity_per_user`: Setting these to 0 causes mempool to reject all transactions
- `orderless_txn_capacity_per_user`: Setting to 0 prevents orderless transactions
- `shared_mempool_max_batch_bytes`: Should not exceed `MAX_APPLICATION_MESSAGE_SIZE`
- Various timeout and interval fields: Should have reasonable minimum/maximum bounds

The vulnerability specifically highlights the danger of using `#[serde(default)]` without corresponding validation logic, a pattern that should be reviewed across the entire configuration system.

### Citations

**File:** config/src/config/mempool_config.rs (L40-41)
```rust
#[serde(default, deny_unknown_fields)]
pub struct MempoolConfig {
```

**File:** config/src/config/mempool_config.rs (L97-97)
```rust
    pub num_sender_buckets: u8,
```

**File:** config/src/config/mempool_config.rs (L176-184)
```rust
impl ConfigSanitizer for MempoolConfig {
    fn sanitize(
        _node_config: &NodeConfig,
        _node_type: NodeType,
        _chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        Ok(()) // TODO: add reasonable verifications
    }
}
```

**File:** mempool/src/core_mempool/transaction_store.rs (L42-47)
```rust
pub fn sender_bucket(
    address: &AccountAddress,
    num_sender_buckets: MempoolSenderBucket,
) -> MempoolSenderBucket {
    address.as_ref()[address.as_ref().len() - 1] as MempoolSenderBucket % num_sender_buckets
}
```

**File:** mempool/src/core_mempool/transaction_store.rs (L104-111)
```rust
    pub(crate) fn new(config: &MempoolConfig) -> Self {
        let mut timeline_index = HashMap::new();
        for sender_bucket in 0..config.num_sender_buckets {
            timeline_index.insert(
                sender_bucket,
                MultiBucketTimelineIndex::new(config.broadcast_buckets.clone()).unwrap(),
            );
        }
```

**File:** mempool/src/core_mempool/transaction_store.rs (L554-566)
```rust
                let sender_bucket = sender_bucket(address, self.num_sender_buckets);
                let ready_for_quorum_store = !self.priority_index.contains(txn);

                self.priority_index.insert(txn);

                // If timeline_state is `NonQualified`, then the transaction is never added to the timeline_index,
                // and never broadcasted to the shared mempool.
                let ready_for_mempool_broadcast = txn.timeline_state == TimelineState::NotReady;
                if ready_for_mempool_broadcast {
                    self.timeline_index
                        .get_mut(&sender_bucket)
                        .unwrap()
                        .insert(txn);
```

**File:** mempool/src/shared_mempool/runtime.rs (L103-103)
```rust
    let mempool = Arc::new(Mutex::new(CoreMempool::new(config)));
```
