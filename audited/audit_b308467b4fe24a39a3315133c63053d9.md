# Audit Report

## Title
Speculative Cache Pollution via Shallow RuntimeEnvironment Clone in Module Publishing

## Summary
The `create_with_compat_config()` function in module publishing performs a shallow clone of the `RuntimeEnvironment`, causing global caches (`struct_name_index_map`, `ty_tag_cache`, `interned_ty_pool`) to be shared between the original and cloned environments via `Arc` pointers with interior mutability. This violates the explicitly stated design invariant that "no speculative information is cached" and allows failed/aborted module publish transactions to permanently pollute global caches with speculative data.

## Finding Description

The vulnerability exists in the module staging mechanism. When a user submits a module publish transaction, the code path is: [1](#0-0) 

This calls `create_with_compat_config()` which clones the RuntimeEnvironment: [2](#0-1) 

The comment explicitly states the intent: "we need to make sure that no speculative information is cached! By cloning the environment, we ensure that when using this new module storage with changes, global caches are not accessed."

However, the `Clone` implementation performs shallow cloning using `Arc::clone()`: [3](#0-2) 

All three critical caches use interior mutability and can be modified through shared Arc references: [4](#0-3) [5](#0-4) 

During module verification, `Module::new()` is called, which adds struct names to the SHARED cache: [6](#0-5) 

**Attack Scenario:**
1. Attacker submits module publish transaction with unique struct names
2. `StagingModuleStorage` creates cloned environment with shared caches
3. Module verification adds struct names to the global cache via `struct_name_to_idx()`
4. Transaction fails (e.g., compatibility check failure, gas exhaustion, user abort)
5. Struct name entries remain permanently in the global cache
6. Attacker repeats with different struct names to bloat cache

The code even acknowledges the need to prevent speculative caching: [7](#0-6) 

## Impact Explanation

**Medium Severity** - State inconsistencies requiring intervention:

1. **Cache Pollution**: Failed transactions permanently pollute global caches with speculative data, violating the isolation guarantee
2. **Non-Deterministic Cache States**: Different validators may process different speculative transactions (from local mempools or parallel execution), leading to divergent cache states
3. **Resource Consumption**: While there's a 1M entry limit, attackers can deliberately bloat caches by repeatedly submitting failing module publish transactions with unique struct names
4. **Protocol Invariant Violation**: The code explicitly states "extremely important for correctness" yet fails to achieve the isolation guarantee

While this doesn't directly cause consensus breaks (struct indices are runtime artifacts not persisted to state), it violates a critical design invariant that developers marked as essential for correctness. The non-deterministic cache states across validators could potentially affect validator performance differently and create operational inconsistencies.

## Likelihood Explanation

**High Likelihood**:
- Any user can submit module publish transactions
- No special privileges required
- Triggered automatically during normal module publishing flow
- Occurs on every failed module publish transaction
- Cannot be prevented by users or operators

The vulnerability is inherent in the design and affects all module publish operations.

## Recommendation

Replace the shallow clone with a deep clone that creates isolated cache instances for speculative execution:

```rust
pub fn create_with_compat_config(
    sender: &AccountAddress,
    compatibility: Compatibility,
    existing_module_storage: &'a M,
    module_bundle: Vec<Bytes>,
) -> VMResult<Self> {
    // Create a NEW runtime environment with ISOLATED caches for speculative execution
    let staged_runtime_environment = RuntimeEnvironment::new_with_config(
        existing_module_storage.runtime_environment().natives().iter(),
        existing_module_storage.runtime_environment().vm_config().clone(),
    );
    
    // Rest of function unchanged...
}
```

Alternatively, implement copy-on-write semantics for the caches or use a transaction-local cache overlay that doesn't write through to global caches until commit.

## Proof of Concept

```rust
// Rust test demonstrating cache pollution from failed transaction
#[test]
fn test_speculative_cache_pollution() {
    let env = RuntimeEnvironment::new(/* natives */);
    let initial_cache_size = env.struct_name_index_map_size().unwrap();
    
    // Simulate failed module publish transaction
    let result = StagingModuleStorage::create(
        &AccountAddress::ONE,
        &module_storage,
        vec![invalid_module_bytes], // Will fail compatibility check
    );
    assert!(result.is_err()); // Transaction fails
    
    // Verify cache was polluted despite failure
    let after_cache_size = env.struct_name_index_map_size().unwrap();
    assert!(after_cache_size > initial_cache_size); // Cache grew from failed tx!
}
```

## Notes

While this vulnerability clearly violates the stated design invariant ("no speculative information is cached"), the concrete security impact is limited because struct name indices are runtime artifacts that don't affect persisted blockchain state or consensus state roots. However, the violation of an explicitly stated "extremely important for correctness" invariant, combined with the potential for cache pollution and non-deterministic validator states, qualifies this as a Medium severity protocol violation requiring remediation.

### Citations

**File:** aptos-move/aptos-vm/src/move_vm_ext/session/user_transaction_sessions/user.rs (L97-102)
```rust
        let staging_module_storage = StagingModuleStorage::create_with_compat_config(
            &destination,
            compatability_checks,
            module_storage,
            bundle.into_bytes(),
        )?;
```

**File:** third_party/move/move-vm/runtime/src/storage/publishing.rs (L91-93)
```rust
// Very important: no caching for staging module storage so that any speculative updates are not
// accidentally cached.
impl<M> NoOpLayoutCache for StagingModuleStorage<'_, M> {}
```

**File:** third_party/move/move-vm/runtime/src/storage/publishing.rs (L118-128)
```rust
        // Create a new runtime environment, so that it is not shared with the existing one. This
        // is extremely important for correctness of module publishing: we need to make sure that
        // no speculative information is cached! By cloning the environment, we ensure that when
        // using this new module storage with changes, global caches are not accessed. Only when
        // the published module is committed, and its structs are accessed, their information will
        // be cached in the global runtime environment.
        //
        // Note: cloning the environment is relatively cheap because it only stores global caches
        // that cannot be invalidated by module upgrades using a shared pointer, so it is not a
        // deep copy. See implementation of Clone for this struct for more details.
        let staged_runtime_environment = existing_module_storage.runtime_environment().clone();
```

**File:** third_party/move/move-vm/runtime/src/storage/environment.rs (L430-441)
```rust
impl Clone for RuntimeEnvironment {
    fn clone(&self) -> Self {
        Self {
            vm_config: self.vm_config.clone(),
            natives: self.natives.clone(),
            struct_name_index_map: Arc::clone(&self.struct_name_index_map),
            ty_tag_cache: Arc::clone(&self.ty_tag_cache),
            interned_ty_pool: Arc::clone(&self.interned_ty_pool),
            interned_module_id_pool: Arc::clone(&self.interned_module_id_pool),
        }
    }
}
```

**File:** third_party/move/move-vm/types/src/loaded_data/struct_name_indexing.rs (L70-99)
```rust
    pub fn struct_name_to_idx(
        &self,
        struct_name: &StructIdentifier,
    ) -> PartialVMResult<StructNameIndex> {
        {
            let index_map = self.0.read();
            if let Some(idx) = index_map.forward_map.get(struct_name) {
                return Ok(StructNameIndex(*idx));
            }
        }

        // Possibly need to insert, so make the copies outside of the lock.
        let forward_key = struct_name.clone();
        let backward_value = Arc::new(struct_name.clone());

        let idx = {
            let mut index_map = self.0.write();

            if let Some(idx) = index_map.forward_map.get(struct_name) {
                return Ok(StructNameIndex(*idx));
            }

            let idx = index_map.backward_map.len() as u32;
            index_map.backward_map.push(backward_value);
            index_map.forward_map.insert(forward_key, idx);
            idx
        };

        Ok(StructNameIndex(idx))
    }
```

**File:** third_party/move/move-vm/runtime/src/storage/ty_tag_converter.rs (L181-211)
```rust
    pub(crate) fn insert_struct_tag(
        &self,
        idx: &StructNameIndex,
        ty_args: &[Type],
        priced_struct_tag: &PricedStructTag,
    ) -> bool {
        // Check if already cached.
        if self
            .cache
            .read()
            .contains_key(&StructKeyRef { idx, ty_args })
        {
            return false;
        }

        let key = StructKey {
            idx: *idx,
            ty_args: ty_args.to_vec(),
        };
        let priced_struct_tag = priced_struct_tag.clone();

        // Otherwise, we need to insert. We did the clones outside the lock, and also avoid the
        // double insertion.
        let mut cache = self.cache.write();
        if let Entry::Vacant(entry) = cache.entry(key) {
            entry.insert(priced_struct_tag);
            true
        } else {
            false
        }
    }
```

**File:** third_party/move/move-vm/runtime/src/loader/modules.rs (L194-203)
```rust
        // validate the correctness of struct handle references.
        for struct_handle in module.struct_handles() {
            let struct_name = module.identifier_at(struct_handle.name);
            let module_handle = module.module_handle_at(struct_handle.module);
            let module_id = module.module_id_for_handle(module_handle);
            let struct_name =
                StructIdentifier::new(module_id_pool, module_id, struct_name.to_owned());
            struct_idxs.push(struct_name_index_map.struct_name_to_idx(&struct_name)?);
            struct_names.push(struct_name)
        }
```
