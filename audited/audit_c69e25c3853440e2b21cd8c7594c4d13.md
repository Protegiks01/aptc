# Audit Report

## Title
Unlimited Consecutive Transaction Discards in Sequential Fallback Enables Block Censorship and Resource Exhaustion

## Summary
The sequential fallback execution path in `executor.rs` allows unlimited consecutive transaction discards when `resource_group_bcs_fallback` mode is enabled. When transactions fail BCS serialization checks, they are individually discarded with `DELAYED_FIELD_OR_BLOCKSTM_CODE_INVARIANT_ERROR` status without any limit on consecutive discards. An attacker can exploit this to create effectively empty blocks, waste validator resources, and enable transaction censorship.

## Finding Description

The vulnerability exists in the sequential execution fallback mechanism. When parallel execution fails, the system falls back to sequential execution. If that fails with `ResourceGroupSerializationError`, a second sequential pass runs with `resource_group_bcs_fallback=true`. [1](#0-0) 

In this fallback mode, each transaction that fails the BCS serialization check is individually discarded and the loop continues without any counter or limit. The discarded transactions receive the error code `DELAYED_FIELD_OR_BLOCKSTM_CODE_INVARIANT_ERROR`, which is the same status code produced by the `code_invariant_error()` function referenced in the security question: [2](#0-1) 

**Attack Path:**

1. Attacker crafts transactions with resource group operations that have incorrect size metadata
2. These transactions execute successfully in the VM but fail BCS serialization checks at lines 2357-2397
3. When the serialization check fails (line 2399), the transaction is discarded (line 2403)
4. Execution continues with `idx += 1; continue` (lines 2406-2407)
5. **No counter tracks consecutive discards** - the loop only exits when `idx > num_txns`
6. All transactions in the block can be discarded sequentially without any limit

The test at lines 264-411 demonstrates this behavior, where transaction 1 is successfully skipped when serialization fails: [3](#0-2) 

However, the test only validates single transaction discard, not the unlimited consecutive discard scenario.

## Impact Explanation

This vulnerability qualifies as **Medium Severity** per the Aptos bug bounty program:

1. **Transaction Censorship**: An attacker can cause legitimate user transactions to be discarded by including them in blocks with malicious transactions that trigger the fallback
2. **Validator Resource Exhaustion**: All discarded transactions still consume validator CPU and memory during execution before being discarded
3. **Network Throughput Degradation**: Blocks become effectively empty while validators waste resources processing transactions that get discarded
4. **State Inconsistencies**: While not permanently harmful, repeated empty blocks require operator intervention to investigate

This does not reach Critical or High severity because:
- No direct loss of funds occurs
- Consensus safety is maintained (deterministic execution preserved)
- Network remains available (blocks are still produced)
- No permanent state corruption occurs

## Likelihood Explanation

**Likelihood: Medium**

**Attacker Requirements:**
- Understanding of resource group serialization checks
- Ability to craft transactions with metadata mismatches that pass mempool validation
- Transactions must be selected by consensus into blocks

**Feasibility:**
- Could occur accidentally due to bugs in Move contracts (not just malicious intent)
- The `resource_group_bcs_fallback` mode is specifically designed to handle such cases
- The lack of any limit makes exploitation straightforward once the conditions are met
- Sustained attacks would be noticed but could cause significant disruption before mitigation

**Complexity: Medium** - Requires specific knowledge but no validator compromise needed.

## Recommendation

Implement a maximum threshold for consecutive transaction discards before rejecting the entire block. Add a counter in the sequential execution loop:

```rust
// In execute_transactions_sequential function, before the main loop
let mut consecutive_discards = 0;
const MAX_CONSECUTIVE_DISCARDS: usize = 10; // Configurable threshold

// Inside the loop, after line 2399:
if serialization_error {
    consecutive_discards += 1;
    if consecutive_discards >= MAX_CONSECUTIVE_DISCARDS {
        return Err(SequentialBlockExecutionError::ErrorToReturn(
            BlockExecutionError::FatalBlockExecutorError(code_invariant_error(
                format!("Too many consecutive transaction discards ({}) in sequential fallback", 
                        consecutive_discards)
            ))
        ));
    }
    alert!("Discarding transaction {} because serialization failed in bcs fallback (consecutive: {})", 
           idx, consecutive_discards);
    ret.push(E::Output::discard_output(
        StatusCode::DELAYED_FIELD_OR_BLOCKSTM_CODE_INVARIANT_ERROR,
    ));
    idx += 1;
    continue;
}
// Reset counter on successful transaction
consecutive_discards = 0;
```

Alternative approaches:
1. Reject blocks where more than X% of transactions are discarded
2. Add rate limiting on `DELAYED_FIELD_OR_BLOCKSTM_CODE_INVARIANT_ERROR` per block
3. Improve mempool validation to reject such transactions earlier

## Proof of Concept

Extend the existing test to demonstrate unlimited consecutive discards:

```rust
#[test]
fn test_unlimited_consecutive_discards() {
    // Create 100 transactions that will all trigger serialization errors
    let mut transactions = Vec::new();
    for _ in 0..100 {
        let mut group_incarnation: MockIncarnation<KeyType<u32>, MockEvent> =
            MockIncarnation::new(vec![(KeyType::<u32>(1), true)], vec![], vec![], vec![], 10);
        group_incarnation.group_writes.push((
            KeyType::<u32>(100),
            StateValueMetadata::none(),
            HashMap::from([(101, (ValueType::from_value(vec![5], true), false))]),
        ));
        transactions.push(MockTransaction::from_behavior(group_incarnation));
    }

    let scenario = FailScenario::setup();
    fail::cfg("fail-point-resource-group-serialization", "return()").unwrap();

    let data_view = NonEmptyGroupDataView::<KeyType<u32>> {
        group_keys: HashSet::new(),
        delayed_field_testing: false,
    };
    let executor_thread_pool = Arc::new(
        rayon::ThreadPoolBuilder::new()
            .num_threads(num_cpus::get())
            .build()
            .unwrap(),
    );
    let block_executor = BlockExecutor::<...>::new(...);

    let mut guard = AptosModuleCacheManagerGuard::none();
    let txn_provider = DefaultTxnProvider::new_without_info(transactions);
    
    // Execute with fallback - ALL 100 transactions will be discarded
    let result = block_executor.execute_block(
        &txn_provider,
        &data_view,
        &TransactionSliceMetadata::unknown(),
        &mut guard,
    ).unwrap();

    let txn_outputs = result.into_transaction_outputs_forced();
    assert_eq!(txn_outputs.len(), 100);
    
    // Verify all transactions were discarded (no limit enforced)
    for output in txn_outputs {
        assert!(output.skipped, "Transaction should be discarded");
    }
    
    scenario.teardown();
}
```

This test demonstrates that all 100 consecutive transactions are discarded without any limit being enforced, creating an effectively empty block while wasting validator resources.

### Citations

**File:** aptos-move/block-executor/src/executor.rs (L2399-2408)
```rust
                        if serialization_error {
                            // The corresponding error / alert must already be triggered, the goal in sequential
                            // fallback is to just skip any transactions that would cause such serialization errors.
                            alert!("Discarding transaction because serialization failed in bcs fallback");
                            ret.push(E::Output::discard_output(
                                StatusCode::DELAYED_FIELD_OR_BLOCKSTM_CODE_INVARIANT_ERROR,
                            ));
                            idx += 1;
                            continue;
                        }
```

**File:** third_party/move/move-vm/types/src/delayed_values/error.rs (L11-18)
```rust
pub fn code_invariant_error<M: std::fmt::Debug>(message: M) -> PartialVMError {
    let msg = format!(
        "Delayed logic code invariant broken (there is a bug in the code), {:?}",
        message
    );
    println!("ERROR: {}", msg);
    PartialVMError::new(StatusCode::DELAYED_FIELD_OR_BLOCKSTM_CODE_INVARIANT_ERROR)
        .with_message(msg)
```

**File:** aptos-move/block-executor/src/unit_tests/mod.rs (L399-405)
```rust
                assert_eq!(txn_outputs.len(), 3);
                assert!(!txn_outputs[0].writes.is_empty());
                assert!(!txn_outputs[2].writes.is_empty());

                // But now transaction 1 must be skipped.
                assert!(txn_outputs[1].skipped);
            },
```
