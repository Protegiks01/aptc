# Audit Report

## Title
Critical Consensus Halt via Empty ValidatorSet During Epoch Reconfiguration

## Summary
The Aptos blockchain can enter an unrecoverable halt state when all validators are filtered out during epoch reconfiguration, resulting in an empty `active_validators` set. This occurs due to missing validation in the `on_new_epoch()` function and the `update_required_stake()` governance function, combined with panic conditions in consensus proposer election logic when no validators exist.

## Finding Description

The vulnerability exists across multiple layers of the Aptos stack, creating a path to total network liveness failure:

**Layer 1: Missing Validation in Governance Parameter Updates**

The `update_required_stake()` function allows governance to update the `minimum_stake` requirement without validating that any current validator meets the new threshold: [1](#0-0) 

The validation function only checks the relationship between minimum and maximum stake, not validator viability: [2](#0-1) 

**Layer 2: Unprotected Validator Filtering in Epoch Transition**

During epoch reconfiguration, the `on_new_epoch()` function filters validators based on whether their voting power meets the minimum stake requirement, but contains NO check to ensure at least one validator remains after filtering: [3](#0-2) 

The function is specified to never abort (`aborts_if false`), meaning it will complete successfully even with zero validators: [4](#0-3) 

Note that while `leave_validator_set()` has a check to prevent removing the last validator, this only applies to explicit leave operations and NOT automatic filtering: [5](#0-4) 

**Layer 3: No Deserialization Validation**

The `ValidatorSet` struct uses derived deserialization with no custom validation, allowing empty validator sets to be deserialized: [6](#0-5) 

**Layer 4: Consensus Panic on Empty Validator Set**

When consensus initializes a new epoch with an empty `ValidatorSet`, it converts it to a `ValidatorVerifier` with zero validators and zero quorum voting power: [7](#0-6) 

The consensus `EpochManager` then attempts to create a proposer election using the empty validator list: [8](#0-7) 

For `FixedProposer` mode, the `choose_leader()` function immediately panics: [9](#0-8) 

For `RotatingProposer` mode, the first call to `get_valid_proposer()` causes a divide-by-zero panic: [10](#0-9) 

**Attack Scenario:**

1. A governance proposal increases `minimum_stake` to a value higher than all current validators' stakes (could be accidental or malicious)
2. The proposal passes governance voting
3. At the next epoch transition, `on_new_epoch()` executes
4. The filtering loop removes ALL validators from `active_validators` because none meet the new minimum
5. The empty `ValidatorSet` is committed to on-chain state
6. All consensus nodes receive the empty `ValidatorSet` via epoch change notification
7. Each consensus node panics when attempting to initialize proposer election
8. The entire network halts with no validators able to propose or validate blocks

## Impact Explanation

This vulnerability qualifies as **Critical Severity** under the Aptos bug bounty program because it results in:

- **Total loss of liveness/network availability**: The blockchain completely halts when all consensus nodes crash
- **Non-recoverable network partition (requires hardfork)**: Recovery requires manual intervention and potentially a hardfork to restore a valid validator set, as no blocks can be proposed or committed to fix the state through normal transactions

The impact affects:
- All validator nodes (crash or hang in consensus initialization)
- All full nodes (cannot sync new blocks as none are produced)
- All users (cannot submit transactions or query recent state)
- The entire Aptos ecosystem (complete service disruption)

This breaks the fundamental invariant that "the blockchain must always have at least one validator capable of proposing blocks."

## Likelihood Explanation

**Likelihood: Medium-High**

The vulnerability can be triggered through legitimate governance processes:

**Accidental Trigger:**
- A well-intentioned governance proposal to increase security by raising minimum stake requirements
- Miscalculation or lack of awareness of current validator stakes
- No system warnings or validations to prevent the invalid configuration

**Malicious Trigger:**
- An attacker who accumulates sufficient voting power through governance
- Direct attack via malicious proposal
- Social engineering to convince governance participants

**Prerequisites:**
- Governance proposal passage (requires voting power, but this is the normal governance process)
- No validator meeting the new minimum stake threshold (achievable if the increase is large enough)

**Ease of Exploitation:**
Once the invalid parameter is set, the vulnerability triggers automatically at the next epoch transition. No further attacker action is required.

## Recommendation

Implement defense-in-depth validation at multiple layers:

**Fix 1: Add Validator Viability Check to Governance Parameter Updates**

Modify `update_required_stake()` to validate that at least one active validator will still meet the new minimum:

```move
public fun update_required_stake(
    aptos_framework: &signer,
    minimum_stake: u64,
    maximum_stake: u64,
) acquires StakingConfig {
    system_addresses::assert_aptos_framework(aptos_framework);
    validate_required_stake(minimum_stake, maximum_stake);
    
    // NEW: Validate at least one validator meets new minimum
    let validator_set = borrow_global<stake::ValidatorSet>(@aptos_framework);
    let viable_validators = 0;
    let i = 0;
    while (i < vector::length(&validator_set.active_validators)) {
        let validator = vector::borrow(&validator_set.active_validators, i);
        let stake_pool = borrow_global<stake::StakePool>(validator.addr);
        if (stake::get_next_epoch_voting_power(stake_pool) >= minimum_stake) {
            viable_validators = viable_validators + 1;
        };
        i = i + 1;
    };
    assert!(viable_validators > 0, error::invalid_argument(ENO_VIABLE_VALIDATORS));
    
    let staking_config = borrow_global_mut<StakingConfig>(@aptos_framework);
    staking_config.minimum_stake = minimum_stake;
    staking_config.maximum_stake = maximum_stake;
}
```

**Fix 2: Add Validator Count Check to on_new_epoch()**

Add a defensive check after filtering to ensure at least one validator remains:

```move
validator_set.active_validators = next_epoch_validators;
assert!(
    vector::length(&validator_set.active_validators) > 0,
    error::invalid_state(ENO_VALIDATORS_REMAINING)
);
```

**Fix 3: Add Validation to ValidatorVerifier::new()**

Panic early in Rust code rather than allowing invalid state:

```rust
pub fn new(validator_infos: Vec<ValidatorConsensusInfo>) -> Self {
    assert!(
        !validator_infos.is_empty(),
        "ValidatorVerifier cannot be created with zero validators"
    );
    let total_voting_power = sum_voting_power(&validator_infos);
    let quorum_voting_power = total_voting_power * 2 / 3 + 1;
    Self::build_index(validator_infos, quorum_voting_power, total_voting_power)
}
```

## Proof of Concept

The following Move test demonstrates the vulnerability:

```move
#[test(aptos_framework = @aptos_framework)]
#[expected_failure(abort_code = 0x50003, location = consensus)] // Expect panic in consensus
public fun test_empty_validator_set_via_high_minimum_stake(
    aptos_framework: &signer
) {
    // Setup: Initialize with one validator with 1M APT stake
    stake::initialize_validator(aptos_framework, validator_address, 1_000_000);
    
    // Attack: Governance increases minimum_stake to 10M APT
    staking_config::update_required_stake(
        aptos_framework,
        10_000_000, // minimum_stake: 10M APT
        100_000_000 // maximum_stake: 100M APT
    );
    
    // Trigger: Epoch transition filters out all validators
    stake::on_new_epoch();
    
    // Result: ValidatorSet.active_validators is now empty
    let validator_set = borrow_global<stake::ValidatorSet>(@aptos_framework);
    assert!(vector::length(&validator_set.active_validators) == 0, 0);
    
    // When consensus receives this empty set, it will panic
    // in proposer election initialization (divide-by-zero or "No trusted peers found!")
}
```

Alternative Rust reproduction demonstrating the consensus panic:

```rust
#[test]
#[should_panic(expected = "No trusted peers found!")]
fn test_consensus_panic_on_empty_validator_set() {
    // Create empty ValidatorSet
    let empty_validator_set = ValidatorSet::empty();
    
    // Convert to ValidatorVerifier
    let verifier: ValidatorVerifier = (&empty_validator_set).into();
    assert!(verifier.is_empty());
    
    // Attempt to create proposer election - this panics
    let proposers = verifier.get_ordered_account_addresses_iter().collect::<Vec<_>>();
    let _proposer = choose_leader(proposers); // Panics: "No trusted peers found!"
}
```

## Notes

This vulnerability exists at genesis protection level only - there's a formal verification requirement that at least one validator must exist before genesis ends: [11](#0-10) 

However, this protection does NOT extend to post-genesis operation during normal epoch transitions, creating a critical gap in the invariant enforcement.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/configs/staking_config.move (L274-285)
```text
    public fun update_required_stake(
        aptos_framework: &signer,
        minimum_stake: u64,
        maximum_stake: u64,
    ) acquires StakingConfig {
        system_addresses::assert_aptos_framework(aptos_framework);
        validate_required_stake(minimum_stake, maximum_stake);

        let staking_config = borrow_global_mut<StakingConfig>(@aptos_framework);
        staking_config.minimum_stake = minimum_stake;
        staking_config.maximum_stake = maximum_stake;
    }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/staking_config.move (L372-374)
```text
    fun validate_required_stake(minimum_stake: u64, maximum_stake: u64) {
        assert!(minimum_stake <= maximum_stake && maximum_stake > 0, error::invalid_argument(EINVALID_STAKE_RANGE));
    }
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1253-1255)
```text
            let validator_info = vector::swap_remove(
                &mut validator_set.active_validators, option::extract(&mut maybe_active_index));
            assert!(vector::length(&validator_set.active_validators) > 0, error::invalid_state(ELAST_VALIDATOR));
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1372-1401)
```text
        let next_epoch_validators = vector::empty();
        let (minimum_stake, _) = staking_config::get_required_stake(&config);
        let vlen = vector::length(&validator_set.active_validators);
        let total_voting_power = 0;
        let i = 0;
        while ({
            spec {
                invariant spec_validators_are_initialized(next_epoch_validators);
                invariant i <= vlen;
            };
            i < vlen
        }) {
            let old_validator_info = vector::borrow_mut(&mut validator_set.active_validators, i);
            let pool_address = old_validator_info.addr;
            let validator_config = borrow_global<ValidatorConfig>(pool_address);
            let stake_pool = borrow_global<StakePool>(pool_address);
            let new_validator_info = generate_validator_info(pool_address, stake_pool, *validator_config);

            // A validator needs at least the min stake required to join the validator set.
            if (new_validator_info.voting_power >= minimum_stake) {
                spec {
                    assume total_voting_power + new_validator_info.voting_power <= MAX_U128;
                };
                total_voting_power = total_voting_power + (new_validator_info.voting_power as u128);
                vector::push_back(&mut next_epoch_validators, new_validator_info);
            };
            i = i + 1;
        };

        validator_set.active_validators = next_epoch_validators;
```

**File:** aptos-move/framework/aptos-framework/sources/stake.spec.move (L462-464)
```text
        // This function should never abort.
        /// [high-level-req-4]
        aborts_if false;
```

**File:** types/src/on_chain_config/validator_set.rs (L23-32)
```rust
#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize)]
#[cfg_attr(any(test, feature = "fuzzing"), derive(Arbitrary))]
pub struct ValidatorSet {
    pub scheme: ConsensusScheme,
    pub active_validators: Vec<ValidatorInfo>,
    pub pending_inactive: Vec<ValidatorInfo>,
    pub pending_active: Vec<ValidatorInfo>,
    pub total_voting_power: u128,
    pub total_joining_power: u128,
}
```

**File:** types/src/validator_verifier.rs (L206-214)
```rust
    pub fn new(validator_infos: Vec<ValidatorConsensusInfo>) -> Self {
        let total_voting_power = sum_voting_power(&validator_infos);
        let quorum_voting_power = if validator_infos.is_empty() {
            0
        } else {
            total_voting_power * 2 / 3 + 1
        };
        Self::build_index(validator_infos, quorum_voting_power, total_voting_power)
    }
```

**File:** consensus/src/epoch_manager.rs (L292-303)
```rust
        let proposers = epoch_state
            .verifier
            .get_ordered_account_addresses_iter()
            .collect::<Vec<_>>();
        match &onchain_config.proposer_election_type() {
            ProposerElectionType::RotatingProposer(contiguous_rounds) => {
                Arc::new(RotatingProposer::new(proposers, *contiguous_rounds))
            },
            // We don't really have a fixed proposer!
            ProposerElectionType::FixedProposer(contiguous_rounds) => {
                let proposer = choose_leader(proposers);
                Arc::new(RotatingProposer::new(vec![proposer], *contiguous_rounds))
```

**File:** consensus/src/liveness/rotating_proposer_election.rs (L20-23)
```rust
pub fn choose_leader(peers: Vec<Author>) -> Author {
    // As it is just a tmp hack function, pick the min PeerId to be a proposer.
    peers.into_iter().min().expect("No trusted peers found!")
}
```

**File:** consensus/src/liveness/rotating_proposer_election.rs (L36-39)
```rust
    fn get_valid_proposer(&self, round: Round) -> Author {
        self.proposers
            [((round / u64::from(self.contiguous_rounds)) % self.proposers.len() as u64) as usize]
    }
```

**File:** aptos-move/framework/aptos-framework/sources/genesis.spec.move (L149-150)
```text
        /// [high-level-req-4]
        requires len(global<stake::ValidatorSet>(@aptos_framework).active_validators) >= 1;
```
