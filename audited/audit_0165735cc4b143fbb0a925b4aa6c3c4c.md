# Audit Report

## Title
Improper Error Handling in Move Resource Viewer Causes Potential API DoS via Panic

## Summary
The `annotate_value` function in the move-resource-viewer library improperly handles size limit errors by using `.unwrap()` instead of propagating the error, causing a thread panic when processing complex types that exceed the 100MB limiter budget. This can lead to API server crashes when viewing certain on-chain resources.

## Finding Description

The `Limiter` struct in `limit.rs` is designed to prevent DoS attacks by limiting the size of queries to 100MB. The `charge()` function returns a `PartialVMError` when the limit is exceeded. [1](#0-0) 

Most callers properly propagate this error using the `?` operator: [2](#0-1) 

However, in the `annotate_value` function, when processing vector types, the code calls `.unwrap()` on a result that can fail: [3](#0-2) 

The `type_tag()` method recursively processes type arguments and calls `struct_tag()` for struct types, which internally calls `limiter.charge()`: [4](#0-3) 

**Attack Path:**
1. Attacker identifies or creates an on-chain resource with deeply nested vector/struct types with complex generic parameters
2. Attacker sends API request via `GET /accounts/{address}/resource/{type}` endpoint
3. API server uses `MoveConverter::try_into_resource()` which calls the move-resource-viewer
4. The viewer calls `annotate_value()` for vector fields
5. If the nested type structure is complex enough to exceed the 100MB limit during type tag generation, `type_tag()` returns an error
6. The `.unwrap()` at line 911 causes a thread panic instead of gracefully returning an error
7. This results in an API 500 error or potential service disruption depending on the server's panic handling

This breaks the **Resource Limits** invariant: "All operations must respect gas, storage, and computational limits." The limiter is meant to gracefully reject oversized operations, but the panic bypasses proper error handling.

## Impact Explanation

This issue qualifies as **High Severity** per Aptos bug bounty criteria as it can cause "API crashes." The `MoveConverter` is used by public API endpoints to view on-chain resources: [5](#0-4) 

When an API request triggers this panic, it can cause:
- HTTP 500 Internal Server Error responses to clients
- Potential thread/service disruption depending on server configuration
- Temporary API unavailability for resource viewing operations

However, the impact is somewhat mitigated because:
- It affects the API layer only, not consensus or core blockchain operations
- Most web frameworks catch panics in request handlers and convert them to 500 errors
- The issue is difficult to trigger as it requires exceeding 100MB through type metadata alone (not data)

## Likelihood Explanation

**Likelihood: Low to Medium**

The vulnerability is difficult to exploit because:
1. Exceeding the 100MB limit requires extraordinarily complex type structures with deeply nested generics and long type names
2. Move's type system has practical limits on nesting depth and complexity
3. Most real-world resources have relatively simple type structures

However, it remains exploitable if:
- An attacker can deploy Move modules with intentionally complex type hierarchies
- Existing on-chain resources happen to have sufficiently complex types
- The attacker can craft specific queries that maximize limiter consumption

The issue is more likely to occur accidentally with legitimate but complex DeFi protocols or NFT metadata structures than through deliberate attack.

## Recommendation

Replace the `.unwrap()` call with proper error propagation using the `?` operator:

```rust
_ => AnnotatedMoveValue::Vector(
    ty.type_tag(limit)?,  // Change .unwrap() to ?
    a.iter()
        .map(|v| self.annotate_value(v, ty.as_ref(), limit))
        .collect::<anyhow::Result<_>>()?,
),
```

This ensures that when the limiter is exceeded, the error propagates up the call stack and returns a proper error response to the API client instead of causing a panic.

## Proof of Concept

While a complete PoC would require deploying a Move module with complex nested generics and querying it via API, here's a conceptual reproduction:

1. Create a Move struct with deeply nested type parameters:
```move
struct Nested<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> {
    // Multiple levels of nesting with long names
}
```

2. Create resources using these types with maximum nesting depth

3. Query via API:
```bash
curl http://api.aptos.dev/v1/accounts/0x123.../resource/0x123...::module::Nested<...>
```

4. If the type tag generation exceeds 100MB during processing, the API will panic with:
```
thread 'request-handler' panicked at 'called `Result::unwrap()` on an `Err` value: PartialVMError'
```

**Notes:**

This vulnerability represents improper error handling that violates defensive programming principles. While the practical exploitability is limited by the high 100MB threshold and Move's type system constraints, the use of `.unwrap()` on a fallible operation in production API code is a clear bug that should be fixed. The proper fix is straightforward and eliminates the risk entirely.

### Citations

**File:** third_party/move/tools/move-resource-viewer/src/limit.rs (L13-20)
```rust
    pub fn charge(&mut self, cost: usize) -> PartialVMResult<()> {
        if self.0 < cost {
            return Err(PartialVMError::new(StatusCode::ABORTED)
                .with_message("Query exceeds size limit".to_string()));
        }
        self.0 -= cost;
        Ok(())
    }
```

**File:** third_party/move/tools/move-resource-viewer/src/fat_type.rs (L232-241)
```rust
    pub fn struct_tag(&self, limiter: &mut Limiter) -> PartialVMResult<StructTag> {
        let ty_args = self
            .ty_args
            .iter()
            .map(|ty| ty.type_tag(limiter))
            .collect::<PartialVMResult<Vec<_>>>()?;

        limiter.charge(std::mem::size_of::<AccountAddress>())?;
        limiter.charge(self.module.as_bytes().len())?;
        limiter.charge(self.name.as_bytes().len())?;
```

**File:** third_party/move/tools/move-resource-viewer/src/lib.rs (L910-915)
```rust
                _ => AnnotatedMoveValue::Vector(
                    ty.type_tag(limit).unwrap(),
                    a.iter()
                        .map(|v| self.annotate_value(v, ty.as_ref(), limit))
                        .collect::<anyhow::Result<_>>()?,
                ),
```

**File:** api/types/src/convert.rs (L89-90)
```rust
        data.map(|(typ, bytes)| self.inner.view_resource(&typ, bytes)?.try_into())
            .collect()
```
