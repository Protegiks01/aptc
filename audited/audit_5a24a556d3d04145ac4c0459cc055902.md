# Audit Report

## Title
Pessimistic Verify Set Not Persisted Across Epochs Allows Repeated Optimistic Verification Bypass

## Summary
The `pessimistic_verify_set` in `ValidatorVerifier` is not persisted across epoch transitions, allowing Byzantine validators who have previously submitted invalid signatures to repeatedly exploit the optimistic signature verification path in each new epoch. This forces validators to waste computational resources on failed aggregate signature verifications every epoch.

## Finding Description

The optimistic signature verification feature in Aptos consensus allows votes to bypass immediate individual verification, instead deferring verification to when signatures are aggregated. When a validator submits an invalid signature that causes aggregated verification to fail, they are added to the `pessimistic_verify_set` to force immediate verification of their future votes. [1](#0-0) 

However, this set is marked with `#[serde(skip)]`, meaning it is not serialized or persisted. When a new epoch begins, a fresh `ValidatorVerifier` is created from the `ValidatorSet`: [2](#0-1) 

The new `ValidatorVerifier` is constructed via `ValidatorVerifier::new()`, which creates an empty `pessimistic_verify_set`: [3](#0-2) 

**Attack Flow:**

1. In Epoch N, a Byzantine validator submits `OrderVote` messages with invalid BLS signatures
2. These votes pass `OrderVote::verify()` which calls `optimistic_verify()`: [4](#0-3) 

3. The `optimistic_verify()` function returns `Ok()` without verifying if optimistic verification is enabled and the validator is not in `pessimistic_verify_set`: [5](#0-4) 

4. Invalid votes accumulate in `PendingOrderVotes` until quorum is reached
5. When `aggregate_and_verify()` is called, the aggregated signature verification fails: [6](#0-5) 

6. The system calls `filter_invalid_signatures()` to verify each signature individually and adds the Byzantine validator to `pessimistic_verify_set`: [7](#0-6) 

7. In Epoch N+1, the `pessimistic_verify_set` is empty again, and the Byzantine validator can repeat steps 1-6

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos bug bounty program's "Validator node slowdowns" category. The impact includes:

1. **Computational Resource Waste**: Every epoch, Byzantine validators force honest validators to:
   - Perform failed aggregate BLS signature verification (cryptographically expensive)
   - Individually verify all accumulated signatures (very expensive for many signatures)
   - Re-aggregate remaining valid signatures

2. **Consensus Delay**: The time spent on invalid signature processing delays consensus rounds, potentially affecting block production rate

3. **Persistent Attack Surface**: The attack repeats every epoch without any persistent tracking, allowing long-term resource exhaustion

4. **No Consensus Safety Violation**: Invalid votes are correctly filtered out before QC formation, so consensus safety is maintained

The attack does not cause funds loss or consensus safety violations, but creates significant and repeatable performance degradation across the validator network.

## Likelihood Explanation

**Likelihood: High**

- Any Byzantine validator can execute this attack with minimal effort
- The attack requires no special conditions or coordination
- It repeats automatically every epoch (typical epoch duration: hours to days)
- Aptos tolerates up to 1/3 Byzantine validators, so attackers are within the threat model
- Detection is difficult as invalid signatures appear legitimate until aggregation

## Recommendation

Persist the `pessimistic_verify_set` across epoch transitions by either:

**Option 1: Serialize with ValidatorVerifier**
Remove the `#[serde(skip)]` attribute and implement proper serialization:

```rust
// In ValidatorVerifier struct definition
// Remove #[serde(skip)] from pessimistic_verify_set
pub pessimistic_verify_set: DashSet<AccountAddress>,
```

**Option 2: Carry forward across epochs**
In `epoch_manager.rs`, transfer the pessimistic set from the old verifier to the new one:

```rust
async fn start_new_epoch(&mut self, payload: OnChainConfigPayload<P>) {
    let validator_set: ValidatorSet = payload.get()
        .expect("failed to get ValidatorSet from payload");
    let mut verifier: ValidatorVerifier = (&validator_set).into();
    verifier.set_optimistic_sig_verification_flag(self.config.optimistic_sig_verification);
    
    // Transfer pessimistic_verify_set from old epoch
    if let Some(old_epoch_state) = &self.epoch_state {
        for validator in old_epoch_state.verifier.pessimistic_verify_set().iter() {
            verifier.add_pessimistic_verify_set(*validator);
        }
    }
    
    let epoch_state = Arc::new(EpochState {
        epoch: payload.epoch(),
        verifier: verifier.into(),
    });
    // ... rest of function
}
```

**Option 3: Time-based expiry**
Implement a time-based expiry mechanism that clears entries after a reasonable period (e.g., multiple epochs) rather than immediately on epoch transition.

## Proof of Concept

The existing test demonstrates the vulnerability pattern within a single epoch: [8](#0-7) 

To demonstrate the cross-epoch vulnerability, extend this test:

```rust
#[test]
fn test_pessimistic_verify_set_not_persisted_across_epochs() {
    // Setup validators
    let (signers, verifier_epoch1) = random_validator_verifier(4, Some(2), false);
    
    // Epoch 1: Submit invalid vote
    let li = random_ledger_info();
    let invalid_vote = OrderVote::new_with_signature(
        signers[0].author(),
        li.clone(),
        bls12381::Signature::dummy_signature(),
    );
    
    // Process invalid vote - triggers pessimistic_verify_set addition
    let mut pending_votes = PendingOrderVotes::new();
    // ... add valid votes from other signers to reach quorum ...
    // Verify pessimistic_verify_set contains the Byzantine validator
    assert_eq!(verifier_epoch1.pessimistic_verify_set().len(), 1);
    assert!(verifier_epoch1.pessimistic_verify_set().contains(&signers[0].author()));
    
    // Epoch 2: Create new ValidatorVerifier (simulating epoch transition)
    let verifier_epoch2 = ValidatorVerifier::new(verifier_epoch1.validator_infos.clone());
    
    // BUG: pessimistic_verify_set is empty in new epoch!
    assert_eq!(verifier_epoch2.pessimistic_verify_set().len(), 0);
    
    // The Byzantine validator can now exploit optimistic_verify again
    let result = verifier_epoch2.optimistic_verify(
        signers[0].author(),
        &li,
        &SignatureWithStatus::from(bls12381::Signature::dummy_signature())
    );
    
    // This should fail but returns Ok() due to optimistic path
    assert!(result.is_ok()); // VULNERABILITY: Invalid signature passes!
}
```

## Notes

This vulnerability affects all consensus message types using optimistic verification: `OrderVote`, `Vote`, `CommitVote`, and `SignedBatchInfo`. The root cause is the architectural decision to not persist behavioral state (`pessimistic_verify_set`) across epoch boundaries, creating a repeatable attack vector for Byzantine validators to waste honest validator resources every epoch.

### Citations

**File:** types/src/validator_verifier.rs (L149-156)
```rust
    /// With optimistic signature verification, we aggregate all the votes on a message and verify at once.
    /// We use this optimization for votes, order votes, commit votes, signed batch info. If the verification fails,
    /// we verify each vote individually, which is a time consuming process. These are the list of voters that have
    /// submitted bad votes that has resulted in having to verify each vote individually. Further votes by these validators
    /// will be verified individually bypassing the optimization.
    #[serde(skip)]
    #[derivative(PartialEq = "ignore")]
    pessimistic_verify_set: DashSet<AccountAddress>,
```

**File:** types/src/validator_verifier.rs (L194-201)
```rust
        Self {
            validator_infos,
            quorum_voting_power,
            total_voting_power,
            address_to_validator_index,
            pessimistic_verify_set: DashSet::new(),
            optimistic_sig_verification: false,
        }
```

**File:** types/src/validator_verifier.rs (L269-285)
```rust
    pub fn optimistic_verify<T: Serialize + CryptoHash>(
        &self,
        author: AccountAddress,
        message: &T,
        signature_with_status: &SignatureWithStatus,
    ) -> std::result::Result<(), VerifyError> {
        if self.get_public_key(&author).is_none() {
            return Err(VerifyError::UnknownAuthor);
        }
        if (!self.optimistic_sig_verification || self.pessimistic_verify_set.contains(&author))
            && !signature_with_status.is_verified()
        {
            self.verify(author, message, signature_with_status.signature())?;
            signature_with_status.set_verified();
        }
        Ok(())
    }
```

**File:** types/src/validator_verifier.rs (L287-311)
```rust
    pub fn filter_invalid_signatures<T: Send + Sync + Serialize + CryptoHash>(
        &self,
        message: &T,
        signatures: BTreeMap<AccountAddress, SignatureWithStatus>,
    ) -> BTreeMap<AccountAddress, SignatureWithStatus> {
        signatures
            .into_iter()
            .collect_vec()
            .into_par_iter()
            .with_min_len(4) // At least 4 signatures are verified in each task
            .filter_map(|(account_address, signature)| {
                if signature.is_verified()
                    || self
                        .verify(account_address, message, signature.signature())
                        .is_ok()
                {
                    signature.set_verified();
                    Some((account_address, signature))
                } else {
                    self.add_pessimistic_verify_set(account_address);
                    None
                }
            })
            .collect()
    }
```

**File:** consensus/src/epoch_manager.rs (L1164-1174)
```rust
    async fn start_new_epoch(&mut self, payload: OnChainConfigPayload<P>) {
        let validator_set: ValidatorSet = payload
            .get()
            .expect("failed to get ValidatorSet from payload");
        let mut verifier: ValidatorVerifier = (&validator_set).into();
        verifier.set_optimistic_sig_verification_flag(self.config.optimistic_sig_verification);

        let epoch_state = Arc::new(EpochState {
            epoch: payload.epoch(),
            verifier: verifier.into(),
        });
```

**File:** consensus/consensus-types/src/order_vote.rs (L82-93)
```rust
    /// Verifies the signature on LedgerInfo.
    pub fn verify(&self, validator: &ValidatorVerifier) -> anyhow::Result<()> {
        ensure!(
            self.ledger_info.consensus_data_hash() == HashValue::zero(),
            "Failed to verify OrderVote. Consensus data hash is not Zero"
        );
        validator
            .optimistic_verify(self.author(), &self.ledger_info, &self.signature)
            .context("Failed to verify OrderVote")?;

        Ok(())
    }
```

**File:** types/src/ledger_info.rs (L517-536)
```rust
    pub fn aggregate_and_verify(
        &mut self,
        verifier: &ValidatorVerifier,
    ) -> Result<(T, AggregateSignature), VerifyError> {
        let aggregated_sig = self.try_aggregate(verifier)?;

        match verifier.verify_multi_signatures(&self.data, &aggregated_sig) {
            Ok(_) => {
                // We are not marking all the signatures as "verified" here, as two malicious
                // voters can collude and create a valid aggregated signature.
                Ok((self.data.clone(), aggregated_sig))
            },
            Err(_) => {
                self.filter_invalid_signatures(verifier);

                let aggregated_sig = self.try_aggregate(verifier)?;
                Ok((self.data.clone(), aggregated_sig))
            },
        }
    }
```

**File:** consensus/src/pending_order_votes.rs (L273-377)
```rust
    #[test]
    fn order_vote_aggregation_with_unverified_votes() {
        ::aptos_logger::Logger::init_for_testing();

        let (signers, verifier) = random_validator_verifier(5, Some(3), false);
        let mut pending_order_votes = PendingOrderVotes::new();
        let mut partial_signatures = PartialSignatures::empty();
        let qc = QuorumCert::dummy();

        // create random vote from validator[0]
        let li = random_ledger_info();
        let li_hash = li.hash();
        let vote_0 = OrderVote::new_with_signature(
            signers[0].author(),
            li.clone(),
            signers[0].sign(&li).expect("Unable to sign ledger info"),
        );
        partial_signatures.add_signature(signers[0].author(), vote_0.signature().clone());

        let vote_1 = OrderVote::new_with_signature(
            signers[1].author(),
            li.clone(),
            signers[1].sign(&li).expect("Unable to sign ledger info"),
        );
        partial_signatures.add_signature(signers[1].author(), vote_1.signature().clone());

        let vote_2 = OrderVote::new_with_signature(
            signers[2].author(),
            li.clone(),
            bls12381::Signature::dummy_signature(),
        );

        let vote_3 = OrderVote::new_with_signature(
            signers[3].author(),
            li.clone(),
            signers[3].sign(&li).expect("Unable to sign ledger info"),
        );
        partial_signatures.add_signature(signers[3].author(), vote_3.signature().clone());

        let vote_4 = OrderVote::new_with_signature(
            signers[4].author(),
            li.clone(),
            signers[4].sign(&li).expect("Unable to sign ledger info"),
        );

        assert_eq!(
            pending_order_votes.insert_order_vote(&vote_0, &verifier, Some(qc.clone())),
            OrderVoteReceptionResult::VoteAdded(1)
        );

        assert_eq!(
            pending_order_votes.insert_order_vote(&vote_0, &verifier, None),
            OrderVoteReceptionResult::VoteAdded(1)
        );

        assert_eq!(
            pending_order_votes.insert_order_vote(&vote_1, &verifier, None),
            OrderVoteReceptionResult::VoteAdded(2)
        );

        assert_eq!(verifier.pessimistic_verify_set().len(), 0);
        assert_eq!(
            pending_order_votes.insert_order_vote(&vote_2, &verifier, None),
            OrderVoteReceptionResult::VoteAdded(2)
        );
        assert_eq!(verifier.pessimistic_verify_set().len(), 1);
        let (_, order_vote_status) = pending_order_votes
            .li_digest_to_votes
            .get(&li_hash)
            .unwrap();
        match order_vote_status {
            OrderVoteStatus::NotEnoughVotes(sig_aggregator) => {
                assert_eq!(sig_aggregator.verified_voters().count(), 2);
                assert_eq!(sig_aggregator.unverified_voters().count(), 0);
            },
            _ => {
                panic!("QC should not be formed yet.");
            },
        }

        let aggregate_sig = verifier
            .aggregate_signatures(partial_signatures.signatures_iter())
            .unwrap();
        match pending_order_votes.insert_order_vote(&vote_3, &verifier, None) {
            OrderVoteReceptionResult::NewLedgerInfoWithSignatures((_qc, li_with_sig)) => {
                assert!(li_with_sig.check_voting_power(&verifier).is_ok());

                assert_eq!(li_with_sig.signatures().clone(), aggregate_sig.clone());
            },
            _ => {
                panic!("No QC formed.");
            },
        };

        match pending_order_votes.insert_order_vote(&vote_4, &verifier, None) {
            OrderVoteReceptionResult::NewLedgerInfoWithSignatures((_qc, li_with_sig)) => {
                assert!(li_with_sig.check_voting_power(&verifier).is_ok());

                assert_eq!(li_with_sig.signatures().clone(), aggregate_sig.clone());
            },
            _ => {
                panic!("No QC formed.");
            },
        };
    }
```
