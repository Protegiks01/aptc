# Audit Report

## Title
Version Gap Detection Failure in Filtered Transaction Streams Allows Incomplete Data Delivery to Indexer Clients

## Summary
The `process_next_batch()` function in the indexer-grpc stream coordinator fails to validate version sequence continuity when transaction filters are applied. Clients receive `BatchEnd` status messages indicating complete version ranges, but filtered transactions create undetectable gaps in the actual data delivered, violating state consistency guarantees.

## Finding Description

The vulnerability exists in the interaction between transaction filtering and batch status reporting: [1](#0-0) 

The code extracts `first_version` and `end_version` from fetched transactions **before** filtering is applied. These values are then returned to the caller: [2](#0-1) 

Meanwhile, transaction filtering occurs during the conversion stage, removing transactions that don't match the filter criteria: [3](#0-2) 

The filtered transactions are sent to clients, but the `BatchEnd` status message uses the **pre-filter** version range: [4](#0-3) 

**Critical Issue**: There is **no validation** that verifies `end_version - first_version + 1 == num_transactions` to detect gaps. The comment on line 161 states "client can use the start and end version to ensure that there are no gaps," but the protocol provides insufficient information for clients to reliably detect gaps without manually tracking every transaction version. [5](#0-4) 

**Attack Scenario:**
1. Client requests transactions starting at version 1000 with a sender address filter
2. Fullnode fetches versions 1000-1999 (1000 transactions) from storage
3. Filter matches only 50 transactions: versions [1000, 1023, 1045, ..., 1987]
4. These 50 filtered transactions are sent to the client
5. `BatchEnd` status reports `start_version=1000, end_version=1999`
6. Client advances its state to version 2000, believing it has processed all 1000 transactions
7. **950 transactions (versions 1001-1022, 1024-1044, ..., 1988-1999) were silently dropped**

Indexers relying on this data would have incomplete blockchain state, potentially causing:
- Missing transaction records in databases
- Incorrect account balances
- Missing event emissions
- Smart contract state desynchronization

## Impact Explanation

This qualifies as **High Severity** under "Significant protocol violations" because:

1. **State Consistency Violation**: The indexer protocol guarantees that clients receive complete sequential blockchain data. This vulnerability breaks that guarantee when filters are applied.

2. **Systemic Impact**: All downstream indexer applications (DeFi dashboards, NFT platforms, analytics tools) relying on filtered streams receive incomplete data without any indication of gaps.

3. **Silent Failure**: Unlike errors that cause panics or retries, this issue silently serves corrupted data. Clients have no reliable mechanism to detect the gaps from the protocol alone.

4. **Data Integrity Compromise**: Indexers may serve incorrect information to end users, leading to wrong account balances, missing transactions, or incorrect contract states in applications.

While this doesn't directly affect consensus or validator operations (the core blockchain remains secure), it represents a critical failure in the indexer infrastructure that applications depend on for blockchain data access.

## Likelihood Explanation

**Likelihood: High** - This occurs in normal operation whenever:
1. A client requests transactions with any filter (sender address, event type, function name, etc.)
2. The filter excludes any transactions in the fetched range
3. The client doesn't manually validate version continuity

The transaction filter feature is documented and intentionally provided: [6](#0-5) 

Many legitimate use cases require filtering (e.g., indexing only token transfers, tracking specific smart contract calls). Every such use case is affected by this vulnerability.

## Recommendation

Add version continuity validation in `process_next_batch()` after fetching transactions:

```rust
pub async fn process_next_batch(&mut self) -> Vec<Result<EndVersion, Status>> {
    let fetching_start_time = std::time::Instant::now();
    let sorted_transactions_from_storage_with_size =
        self.fetch_transactions_from_storage().await;
    if sorted_transactions_from_storage_with_size.is_empty() {
        return vec![];
    }
    
    let first_version = sorted_transactions_from_storage_with_size
        .first()
        .map(|(txn, _)| txn.version)
        .unwrap() as i64;
    let end_version = sorted_transactions_from_storage_with_size
        .last()
        .map(|(txn, _)| txn.version)
        .unwrap() as i64;
    let num_transactions = sorted_transactions_from_storage_with_size.len();
    
    // ADD THIS VALIDATION:
    let expected_count = (end_version - first_version + 1) as usize;
    if num_transactions != expected_count {
        panic!(
            "[Indexer Fullnode] Version gap detected: expected {} transactions \
             from version {} to {}, but received {}. Missing versions in storage.",
            expected_count, first_version, end_version, num_transactions
        );
    }
    
    // Validate versions are contiguous
    for (i, (txn, _)) in sorted_transactions_from_storage_with_size.iter().enumerate() {
        let expected_version = first_version as u64 + i as u64;
        if txn.version != expected_version {
            panic!(
                "[Indexer Fullnode] Version sequence broken: expected version {}, \
                 but found {} at position {}",
                expected_version, txn.version, i
            );
        }
    }
    
    // Rest of the function...
}
```

**Alternative Solution**: Include transaction count in the `StreamStatus` message so clients can validate:

```protobuf
message StreamStatus {
  StatusType type = 1;
  uint64 start_version = 2;
  optional uint64 end_version = 3;
  optional uint64 num_transactions = 4;  // ADD THIS FIELD
}
```

Then clients can verify: `num_transactions == end_version - start_version + 1` to detect gaps.

## Proof of Concept

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use aptos_transaction_filter::{BooleanTransactionFilter, Filterable};
    
    #[tokio::test]
    async fn test_filtered_stream_gap_detection() {
        // Setup: Create a mock context with 100 transactions (versions 0-99)
        // where only transactions at versions [0, 10, 20, ..., 90] match the filter
        
        // Create a filter that only matches every 10th transaction
        let filter = create_every_10th_transaction_filter();
        
        let mut coordinator = IndexerStreamCoordinator::new(
            context,
            0,  // start_version
            100,  // end_version
            4,  // processor_task_count
            25,  // processor_batch_size
            10,  // output_batch_size
            tx,
            Some(filter),
            None,
        );
        
        let results = coordinator.process_next_batch().await;
        let end_version = IndexerStreamCoordinator::get_max_batch_version(results).unwrap();
        
        // BUG: end_version will be 99, suggesting all transactions 0-99 were processed
        assert_eq!(end_version, 99);
        
        // But only 10 transactions were actually sent: [0, 10, 20, ..., 90]
        // Versions 1-9, 11-19, 21-29, ..., 91-99 are missing!
        
        // A client would now set current_version = 100, believing it processed
        // all 100 transactions, when it only received 10.
        
        // This test demonstrates the gap detection failure.
    }
}
```

## Notes

The related backfiller component implements proper gap detection, demonstrating awareness of this issue class: [7](#0-6) 

This validation should be added to the stream coordinator as well. The vulnerability specifically affects the indexer-grpc-fullnode service when serving filtered transaction streams to downstream indexer clients.

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/stream_coordinator.rs (L54-54)
```rust
    pub filter: Option<BooleanTransactionFilter>,
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/stream_coordinator.rs (L109-117)
```rust
        let first_version = sorted_transactions_from_storage_with_size
            .first()
            .map(|(txn, _)| txn.version)
            .unwrap() as i64;
        let end_version = sorted_transactions_from_storage_with_size
            .last()
            .map(|(txn, _)| txn.version)
            .unwrap() as i64;
        let num_transactions = sorted_transactions_from_storage_with_size.len();
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/stream_coordinator.rs (L174-182)
```rust
                // Apply filter if present.
                let pb_txns = if let Some(ref filter) = filter {
                    pb_txns
                        .into_iter()
                        .filter(|txn| filter.matches(txn))
                        .collect::<Vec<_>>()
                } else {
                    pb_txns
                };
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/stream_coordinator.rs (L237-237)
```rust
        vec![Ok(end_version as u64)]
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/fullnode_data_service.rs (L160-162)
```rust
                // send end batch message (each batch) upon success of the entire batch
                // client can use the start and end version to ensure that there are no gaps
                // end loop if this message fails to send because otherwise the client can't validate
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/fullnode_data_service.rs (L163-168)
```rust
                let batch_end_status = get_status(
                    StatusType::BatchEnd,
                    coordinator.current_version,
                    Some(max_version),
                    ledger_chain_id,
                );
```

**File:** ecosystem/indexer-grpc/indexer-grpc-file-store-backfiller/src/processor.rs (L345-349)
```rust
                        ensure!(t.version == version + idx as u64, "Unexpected version");
                    }

                    let mut gap_detector = gap_detector.lock().await;
                    gap_detector.insert(version);
```
