# Audit Report

## Title
Lazy Loading Mode Allows Cyclic Module Dependencies Bypassing Detection

## Summary
The Move VM's lazy loading mode (enabled by default via AIP-127) completely bypasses cyclic module dependency detection during module publishing, allowing attackers to publish modules with circular dependencies that would be rejected in eager loading mode. This breaks a fundamental invariant that module dependencies must form a directed acyclic graph (DAG).

## Finding Description

The `module_cyclic_dependency_error` macro exists to report cyclic dependency errors, but the actual cycle detection is only performed in eager loading mode, not in lazy loading mode which is now the default. [1](#0-0) 

In eager loading mode, cycles are detected via depth-first search in `visit_dependencies_and_verify`: [2](#0-1) 

However, in lazy loading mode during module publishing, the code explicitly states that cyclic dependencies are NOT checked: [3](#0-2) 

The lazy loading path calls `build_verified_module_with_linking_checks` which only performs immediate dependency linking checks via `dependencies::verify_module`, but this function does NOT detect cycles: [4](#0-3) 

A dedicated `cyclic_dependencies.rs` verifier exists with proper cycle detection logic, but it is NOT integrated into the bytecode verification pipeline: [5](#0-4) 

This is confirmed by integration tests that explicitly document the behavior: [6](#0-5) 

## Impact Explanation

This breaks the **Deterministic Execution** invariant. While the immediate impact isn't clear from runtime execution (since already-loaded modules return early), this violates a fundamental system invariant that was intentionally enforced in eager loading:

1. **Protocol Invariant Violation**: The system explicitly prevents cycles in eager mode via `visit_dependencies_and_verify`, indicating this is a required safety property
2. **Future Code Path Risks**: Any future optimization or analysis that assumes DAG structure could hang or crash when encountering cycles
3. **Potential Consensus Divergence**: Different validators might handle cyclic dependencies differently in edge cases, causing consensus failures

The severity is **High** because it represents a significant protocol violation where a fundamental safety check is bypassed, even though the immediate exploitation path is not fully clear. The test comment "(but not called)" suggests the developers knew there could be issues with execution.

## Likelihood Explanation

Likelihood is **HIGH** because:
- Lazy loading is enabled by default (AIP-127, feature flag 95)
- Any user can publish modules without special privileges
- The bypass is complete - no cycle detection occurs at all
- Publishing cyclic modules requires only standard module publishing transactions [7](#0-6) 

## Recommendation

Integrate the existing `cyclic_dependencies::verify_module` check into the lazy loading publishing path:

```rust
// In publishing.rs, after line 275, add:
move_bytecode_verifier::cyclic_dependencies::verify_module(
    compiled_module,
    |module_id| {
        // Provide closure to fetch immediate dependencies
        staged_module_storage
            .unmetered_get_existing_deserialized_module(module_id.address(), module_id.name())?
            .map(|m| m.immediate_dependencies())
            .ok_or_else(|| PartialVMError::new(StatusCode::MISSING_DEPENDENCY))
    },
    |module_id| {
        // Provide closure to fetch immediate friends
        staged_module_storage
            .unmetered_get_existing_deserialized_module(module_id.address(), module_id.name())?
            .map(|m| m.immediate_friends())
            .ok_or_else(|| PartialVMError::new(StatusCode::MISSING_DEPENDENCY))
    },
)?;
```

## Proof of Concept

The existing test demonstrates the vulnerability:

```rust
// From module_storage_tests.rs
add_module_bytes(&mut module_bytes_storage, "a", vec!["b"], vec![]);
add_module_bytes(&mut module_bytes_storage, "b", vec!["c"], vec![]);
add_module_bytes(&mut module_bytes_storage, "c", vec!["a"], vec![]);

// With lazy loading enabled, this succeeds (but shouldn't):
let module_storage = module_bytes_storage.into_unsync_module_storage();
assert_ok!(module_storage.unmetered_get_lazily_verified_module(&c_id));

// This creates: a->b->c->a cycle which violates DAG invariant
```

To demonstrate on-chain, publish three modules where A depends on B, B depends on C, and C depends on A with lazy loading enabled. The publishing will succeed when it should fail with `CYCLIC_MODULE_DEPENDENCY` error.

## Notes

This appears to be a known limitation based on the explicit comment in the code, but it still represents a security-relevant bypass of a fundamental safety check that could enable future exploits or cause consensus issues as the system evolves.

### Citations

**File:** third_party/move/move-vm/types/src/code/errors.rs (L37-50)
```rust
macro_rules! module_cyclic_dependency_error {
    ($addr:expr, $name:expr) => {
        move_binary_format::errors::PartialVMError::new(
            move_core_types::vm_status::StatusCode::CYCLIC_MODULE_DEPENDENCY,
        )
        .with_message(format!(
            "Module {}::{} forms a cyclic dependency",
            $addr, $name
        ))
        .finish(move_binary_format::errors::Location::Module(
            move_core_types::language_storage::ModuleId::new(*$addr, $name.to_owned()),
        ))
    };
}
```

**File:** third_party/move/move-vm/runtime/src/storage/module_storage.rs (L399-415)
```rust
        if visited.insert(dependency_id.clone()) {
            // Dependency is not verified, and we have not visited it yet.
            let verified_dependency = visit_dependencies_and_verify(
                dependency_id.clone(),
                dependency,
                dependency_version,
                visited,
                module_cache_with_context,
            )?;
            verified_dependencies.push(verified_dependency);
        } else {
            // We must have found a cycle otherwise.
            return Err(module_cyclic_dependency_error!(
                dependency_id.address(),
                dependency_id.name()
            ));
        }
```

**File:** third_party/move/move-vm/runtime/src/storage/publishing.rs (L259-275)
```rust
                // Linking checks to immediate dependencies. Note that we do not check cyclic
                // dependencies here.
                let mut verified_dependencies = vec![];
                for (dep_addr, dep_name) in locally_verified_code.immediate_dependencies_iter() {
                    // INVARIANT:
                    //   Immediate dependency of the module in a bundle must be metered at the
                    //   caller side.
                    let dependency =
                        staged_module_storage.unmetered_get_existing_lazily_verified_module(
                            &ModuleId::new(*dep_addr, dep_name.to_owned()),
                        )?;
                    verified_dependencies.push(dependency);
                }
                staged_runtime_environment.build_verified_module_with_linking_checks(
                    locally_verified_code,
                    &verified_dependencies,
                )?;
```

**File:** third_party/move/move-bytecode-verifier/src/dependencies.rs (L173-195)
```rust
pub fn verify_module<'a>(
    config: &VerifierConfig,
    module: &CompiledModule,
    dependencies: impl IntoIterator<Item = &'a CompiledModule>,
) -> VMResult<()> {
    if config.verify_nothing() {
        return Ok(());
    }
    verify_module_impl(module, dependencies)
        .map_err(|e| e.finish(Location::Module(module.self_id())))
}

fn verify_module_impl<'a>(
    module: &CompiledModule,
    dependencies: impl IntoIterator<Item = &'a CompiledModule>,
) -> PartialVMResult<()> {
    let context = &Context::module(module, dependencies);

    verify_imported_modules(context)?;
    verify_imported_structs(context)?;
    verify_imported_functions(context)?;
    verify_all_script_visibility_usage(context)
}
```

**File:** third_party/move/move-bytecode-verifier/src/cyclic_dependencies.rs (L68-94)
```rust
pub fn verify_module<D, F>(module: &CompiledModule, imm_deps: D, imm_friends: F) -> VMResult<()>
where
    D: Fn(&ModuleId) -> PartialVMResult<Vec<ModuleId>>,
    F: Fn(&ModuleId) -> PartialVMResult<Vec<ModuleId>>,
{
    verify_module_impl(module, imm_deps, imm_friends)
        .map_err(|e| e.finish(Location::Module(module.self_id())))
}

fn verify_module_impl<D, F>(
    module: &CompiledModule,
    imm_deps: D,
    imm_friends: F,
) -> PartialVMResult<()>
where
    D: Fn(&ModuleId) -> PartialVMResult<Vec<ModuleId>>,
    F: Fn(&ModuleId) -> PartialVMResult<Vec<ModuleId>>,
{
    let self_id = module.self_id();

    // collect and check that there is no cyclic dependency relation
    let all_deps = collect_all_with_cycle_detection(
        &self_id,
        &module.immediate_dependencies(),
        &imm_deps,
        StatusCode::CYCLIC_MODULE_DEPENDENCY,
    )?;
```

**File:** third_party/move/move-vm/integration-tests/src/tests/module_storage_tests.rs (L228-239)
```rust
    if enable_lazy_loading {
        // With lazy loading, cyclic dependencies are allowed to be published (but not called).
        assert_ok!(module_storage.unmetered_get_lazily_verified_module(&c_id));
        module_storage.assert_cached_state(vec![], vec![&c_id]);
    } else {
        let result =
            module_storage.unmetered_get_eagerly_verified_module(c_id.address(), c_id.name());
        assert_eq!(
            assert_err!(result).major_status(),
            StatusCode::CYCLIC_MODULE_DEPENDENCY
        );
    }
```

**File:** types/src/on_chain_config/aptos_features.rs (L145-148)
```rust
    /// With lazy loading, modules are loaded lazily (as opposed to loading the transitive closure
    /// of dependencies). For more details, see:
    ///   AIP-127 (https://github.com/aptos-foundation/AIPs/blob/main/aips/aip-127.md)
    ENABLE_LAZY_LOADING = 95,
```
