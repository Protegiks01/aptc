# Audit Report

## Title
TranslatedV1EventSchema Entries Are Not Pruned, Causing Unbounded Storage Growth and Query Inconsistencies

## Summary
When historical ledger data is pruned from AptosDB, corresponding `TranslatedV1EventSchema` entries in the internal indexer database are not deleted, leading to orphaned translation data that wastes storage and creates query inconsistencies over time.

## Finding Description

The Aptos internal indexer maintains a `TranslatedV1EventSchema` that stores V1 translations of V2 events for backward compatibility. When `enable_event_v2_translation` is enabled, the system creates these translation entries during transaction indexing. [1](#0-0) 

However, the `EventStorePruner` responsible for pruning historical event data does not include logic to prune these translated events. The pruner only deletes entries from `EventByKeySchema`, `EventByVersionSchema`, and the main `EventSchema`: [2](#0-1) 

As shown above, the `prune_event_indices` method only iterates through V1 events and deletes their indices from `EventByKeySchema` and `EventByVersionSchema`. There is no logic to delete the corresponding `TranslatedV1EventSchema` entries keyed by `(version, index)`.

This gap is acknowledged in the codebase with a TODO comment: [3](#0-2) 

**Attack/Exploitation Path:**
1. Configure a node with `enable_event_v2_translation: true` and ledger pruning enabled
2. As the chain progresses and pruning occurs, main event data (EventSchema) gets deleted
3. TranslatedV1EventSchema entries remain indefinitely, consuming disk space
4. Over months of operation, orphaned translations accumulate without bound
5. Query attempts may encounter inconsistent state where translated events exist but original events are pruned

**Broken Invariants:**
- **Resource Limits**: Storage should be bounded by the pruning window, but TranslatedV1EventSchema violates this expectation
- **State Consistency**: The indexer database becomes inconsistent with the main ledger database, as it retains data for pruned versions

## Impact Explanation

This qualifies as **Low Severity** per the Aptos bug bounty program for the following reasons:

1. **Storage Waste**: Orphaned translations accumulate unbounded over time, wasting disk space on nodes that enable both pruning and event V2 translation. However, this does not cause immediate operational failure.

2. **Query Inconsistencies**: APIs may retrieve translated events for versions where the original transaction data has been pruned, creating confusion. The `get_translated_v1_event_by_version_and_index` function can succeed for pruned versions: [4](#0-3) 

3. **No Critical Impact**: This does not affect consensus, state commitment, fund security, or network liveness. It's a resource management issue rather than a security vulnerability.

4. **Gradual Degradation**: The impact grows slowly over time as more data is indexed and pruned, making it a non-critical operational concern.

Per the bug bounty categories, this falls under "Non-critical implementation bugs" (Low Severity, up to $1,000).

## Likelihood Explanation

**Very High Likelihood** when both features are enabled:
- `enable_event_v2_translation` is explicitly supported in the configuration
- Ledger pruning is commonly enabled on production nodes to manage disk usage
- The bug occurs automatically without any attacker intervention
- Every pruning cycle that processes V2 events will leave orphaned translations [5](#0-4) 

## Recommendation

Modify the `EventStorePruner::prune` method to also delete `TranslatedV1EventSchema` entries when pruning event data. The fix should:

1. Add deletion logic in the `prune_event_indices` method or create a separate method for the internal indexer
2. Iterate through the version range being pruned and delete all `(version, index)` entries from `TranslatedV1EventSchema`
3. Since we don't know the exact number of events per version beforehand, we'd need to iterate until no more entries exist for each version

**Recommended Code Fix:**

In `storage/aptosdb/src/ledger_db/event_db.rs`, add a new pruning method and call it from `EventStorePruner::prune`:

```rust
// In EventDb
pub(crate) fn prune_translated_v1_events(
    &self,
    num_events_per_version: &[usize],
    start: Version,
    indices_batch: &mut SchemaBatch,
) -> Result<()> {
    let mut current_version = start;
    for &num_events in num_events_per_version {
        for idx in 0..num_events {
            indices_batch.delete::<TranslatedV1EventSchema>(
                &(current_version, idx as u64)
            )?;
        }
        current_version += 1;
    }
    Ok(())
}
```

Then in `storage/aptosdb/src/pruner/ledger_pruner/event_store_pruner.rs`, modify the `prune` method to call this new function when the internal indexer is enabled and event V2 translation is active.

## Proof of Concept

**Steps to Reproduce:**

1. Configure a node with:
```yaml
indexer_db_config:
  enable_event: true
  enable_event_v2_translation: true
  
storage:
  storage_pruner_config:
    ledger_pruner_config:
      enable: true
      prune_window: 100000000  # 100M versions
```

2. Run the node and allow it to index transactions with V2 events
3. Wait for pruning to occur (when ledger grows beyond prune_window)
4. Query the internal indexer DB directly to count `TranslatedV1EventSchema` entries
5. Compare the version range of TranslatedV1EventSchema entries with the pruned range from the main ledger
6. Observe that TranslatedV1EventSchema contains entries for versions that have been pruned from EventSchema

**Expected Result:** TranslatedV1EventSchema should only contain entries within the pruning window

**Actual Result:** TranslatedV1EventSchema contains entries for all indexed versions, including pruned ones

**Verification Query (pseudo-code):**
```rust
// Get min readable version from ledger (after pruning)
let min_readable = ledger_db.get_min_readable_version();

// Query internal indexer for translated events below min_readable
let mut iter = indexer_db.iter::<TranslatedV1EventSchema>()?;
iter.seek(&(0, 0))?;

let mut orphaned_count = 0;
while let Some(((version, _idx), _event)) = iter.next().transpose()? {
    if version < min_readable {
        orphaned_count += 1;
    }
}

assert!(orphaned_count > 0, "Orphaned translations found!");
```

## Notes

This issue has been explicitly acknowledged in the codebase with a TODO comment but remains unimplemented. While it doesn't pose an immediate security risk, it represents a storage leak that will accumulate over time on nodes using event V2 translation with pruning enabled. The fix should be straightforward by following the existing patterns used for pruning other event-related schemas.

### Citations

**File:** storage/indexer/src/db_indexer.rs (L294-302)
```rust
    pub fn get_translated_v1_event_by_version_and_index(
        &self,
        version: Version,
        index: u64,
    ) -> Result<ContractEventV1> {
        self.db
            .get::<TranslatedV1EventSchema>(&(version, index))?
            .ok_or_else(|| AptosDbError::NotFound(format!("Event {} of Txn {}", index, version)))
    }
```

**File:** storage/indexer/src/db_indexer.rs (L476-481)
```rust
                                batch
                                    .put::<TranslatedV1EventSchema>(
                                        &(version, idx as u64),
                                        &translated_v1_event,
                                    )
                                    .expect("Failed to put translated v1 events to a batch");
```

**File:** storage/aptosdb/src/ledger_db/event_db.rs (L192-222)
```rust
    pub(crate) fn prune_event_indices(
        &self,
        start: Version,
        end: Version,
        mut indices_batch: Option<&mut SchemaBatch>,
    ) -> Result<Vec<usize>> {
        let mut ret = Vec::new();

        let mut current_version = start;

        for events in self.get_events_by_version_iter(start, (end - start) as usize)? {
            let events = events?;
            ret.push(events.len());

            if let Some(ref mut batch) = indices_batch {
                for event in events {
                    if let ContractEvent::V1(v1) = event {
                        batch.delete::<EventByKeySchema>(&(*v1.key(), v1.sequence_number()))?;
                        batch.delete::<EventByVersionSchema>(&(
                            *v1.key(),
                            current_version,
                            v1.sequence_number(),
                        ))?;
                    }
                }
            }
            current_version += 1;
        }

        Ok(ret)
    }
```

**File:** storage/aptosdb/src/utils/truncation_helper.rs (L535-538)
```rust
                // Assuming same data will be overwritten into indices, we don't bother to deal
                // with the existence or placement of indices
                // TODO: prune data from internal indices
                None,
```

**File:** config/src/config/internal_indexer_db_config.rs (L10-19)
```rust
#[derive(Clone, Copy, Debug, Deserialize, PartialEq, Eq, Serialize)]
#[serde(default, deny_unknown_fields)]
pub struct InternalIndexerDBConfig {
    pub enable_transaction: bool,
    pub enable_event: bool,
    pub enable_event_v2_translation: bool,
    pub event_v2_translation_ignores_below_version: u64,
    pub enable_statekeys: bool,
    pub batch_size: usize,
}
```
