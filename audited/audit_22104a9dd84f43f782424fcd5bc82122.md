# Audit Report

## Title
Table Natives Use Production Assertions That Can Crash Validator Nodes

## Summary
The table-natives implementation uses production `assert!` and `assert_eq!` macros instead of debug-only assertions or safe error handling. If triggered due to a Move VM bug or unexpected runtime state, these assertions would panic and crash validator nodes, causing network disruption.

## Finding Description

The table-natives module contains multiple assertions that check type argument counts, regular argument counts, and runtime state invariants. Unlike other native function implementations in the codebase, these use production `assert!` macros that cause process panics rather than gracefully returning errors. [1](#0-0) [2](#0-1) [3](#0-2) [4](#0-3) [5](#0-4) 

The codebase provides `safely_assert_eq!` macro specifically for this purpose - it returns a `SafeNativeError::InvariantViolation` instead of panicking: [6](#0-5) 

Other native functions follow the correct pattern using either `debug_assert!` (debug-only) or `safely_assert_eq!` (returns error): [7](#0-6) [8](#0-7) [9](#0-8) 

While the bytecode verifier should prevent incorrect type argument counts, and the Move VM's calling convention should guarantee correct argument counts, these defensive checks could be triggered if:

1. **VM Implementation Bug**: A bug in the Move VM's native function calling code could pass incorrect arguments
2. **Bytecode Verifier Bug**: A bug in bytecode verification could allow invalid function instantiations  
3. **Runtime State Issues**: The assertions at lines 378-381 and 639 check runtime state that could theoretically conflict due to logic bugs

## Impact Explanation

**Severity: Medium** 

If these assertions are triggered, validator nodes will panic and crash. This violates the **Deterministic Execution** invariant - if some validators crash while others don't due to timing or state differences, it could cause network disruption.

The impact qualifies as Medium severity per the bug bounty criteria:
- Not a direct loss of funds
- Requires a separate VM/verifier bug to trigger
- Could cause validator node crashes and temporary network disruption
- Would require manual intervention to recover affected nodes

## Likelihood Explanation

**Likelihood: Low to Medium**

The likelihood depends on the existence of bugs in other components:
- **Low** if we assume the Move VM and bytecode verifier are bug-free
- **Medium** considering that VM implementation bugs have historically occurred in blockchain systems
- The existence of `safely_assert_eq!` in the codebase suggests the developers anticipated this risk

Historical precedent shows that VM bugs are discovered over time, and defensive assertions should fail gracefully rather than crashing production nodes.

## Recommendation

Replace all production `assert!` and `assert_eq!` macros with either:

1. **`safely_assert_eq!`** for runtime safety checks:
```rust
fn native_new_table_handle(
    context: &mut SafeNativeContext,
    ty_args: &[Type],
    args: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    safely_assert_eq!(ty_args.len(), 2);
    safely_assert_eq!(args.len(), 0);
    // ... rest of implementation
}
```

2. **`debug_assert!`** if confident in VM guarantees (like other natives):
```rust
fn native_new_table_handle(
    context: &mut SafeNativeContext,
    ty_args: &[Type],
    args: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    debug_assert_eq!(ty_args.len(), 2);
    debug_assert!(args.is_empty());
    // ... rest of implementation
}
```

For runtime state checks (lines 378-381, 639), use explicit error handling:
```rust
if table_data.new_tables.insert(
    TableHandle(handle), 
    TableInfo::new(key_type, value_type)
).is_some() {
    return Err(SafeNativeError::InvariantViolation(
        PartialVMError::new(StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR)
            .with_message("Duplicate table handle generated".to_string())
    ));
}
```

## Proof of Concept

This vulnerability cannot be demonstrated with a standalone PoC because it requires triggering a bug in the Move VM or bytecode verifier to call native functions with incorrect arguments. However, the issue can be verified by:

1. **Code Pattern Analysis**: Compare with other native functions that use `debug_assert!` or `safely_assert_eq!`
2. **Compiler Check**: Verify these assertions compile into production binaries (not stripped like `debug_assert!`)
3. **Hypothetical Trigger**: If a bytecode verifier bug allowed calling `new_table_handle<K>()` with 1 type argument instead of 2, the assertion at line 358 would panic the node

The fix should be applied as a defensive hardening measure regardless of whether a triggering bug currently exists, following the principle of defense-in-depth and consistency with other native implementations.

---

## Notes

While this finding represents an **inconsistency in defensive coding practices** rather than a directly exploitable vulnerability, it merits attention because:

1. Other native functions in the codebase use safer patterns
2. The framework provides `safely_assert_eq!` specifically for this use case
3. Node crashes from assertion failures would impact network availability
4. Defense-in-depth principles suggest graceful error handling over panics

The severity is rated Medium because exploitation requires a prerequisite bug in the Move VM or bytecode verifier, but the impact of node crashes justifies fixing this inconsistency proactively.

### Citations

**File:** aptos-move/framework/table-natives/src/lib.rs (L358-359)
```rust
    assert_eq!(ty_args.len(), 2);
    assert!(args.is_empty());
```

**File:** aptos-move/framework/table-natives/src/lib.rs (L378-381)
```rust
    assert!(table_data
        .new_tables
        .insert(TableHandle(handle), TableInfo::new(key_type, value_type))
        .is_none());
```

**File:** aptos-move/framework/table-natives/src/lib.rs (L391-392)
```rust
    assert_eq!(ty_args.len(), 3);
    assert_eq!(args.len(), 3);
```

**File:** aptos-move/framework/table-natives/src/lib.rs (L452-453)
```rust
    assert_eq!(ty_args.len(), 3);
    assert_eq!(args.len(), 2);
```

**File:** aptos-move/framework/table-natives/src/lib.rs (L639-639)
```rust
    assert!(table_data.removed_tables.insert(handle));
```

**File:** aptos-move/aptos-native-interface/src/helpers.rs (L56-72)
```rust
/// Like `assert_eq!` but for safe natives that return `SafeNativeResult<T>`. Instead of panicking,
/// will return a `SafeNativeError::InvariantViolation(UNKNOWN_INVARIANT_VIOLATION_ERROR)`.
#[macro_export]
macro_rules! safely_assert_eq {
    ($left:expr, $right:expr $(,)?) => {{
        use $crate::reexports::move_vm_types::natives::function::{PartialVMError, StatusCode};
        match (&$left, &$right) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                    return Err($crate::SafeNativeError::InvariantViolation(
                        PartialVMError::new(StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR),
                    ));
                }
            },
        }
    }};
}
```

**File:** aptos-move/framework/src/natives/event.rs (L107-108)
```rust
    debug_assert!(ty_args.len() == 1);
    debug_assert!(arguments.len() == 3);
```

**File:** aptos-move/framework/src/natives/type_info.rs (L52-53)
```rust
    debug_assert!(ty_args.len() == 1);
    debug_assert!(arguments.is_empty());
```

**File:** aptos-move/framework/src/natives/cryptography/multi_ed25519.rs (L35-36)
```rust
    safely_assert_eq!(ty_args.len(), 0);
    safely_assert_eq!(arguments.len(), 1);
```
