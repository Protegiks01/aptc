# Audit Report

## Title
Storage Corruption Bypass During Bootstrapping Allows Nodes to Operate with Unverified State

## Summary
The Aptos bootstrapper completes initialization without performing cryptographic state integrity verification when local storage reports a version equal to or greater than the network's highest known version. This allows a node with corrupted storage to bypass waypoint verification and all state validity checks, potentially causing consensus divergence and state inconsistencies.

## Finding Description

The vulnerability exists in three interconnected bypass mechanisms:

**Bypass 1: Waypoint Verification Bypass in State Sync**

In `verify_waypoint_is_satisfiable()`, when storage version is >= waypoint version, the waypoint is marked as "verified" without cryptographically validating the waypoint hash: [1](#0-0) 

The waypoint structure contains a cryptographic hash (`value: HashValue`) that includes the transaction accumulator root hash, epoch, timestamp, and next epoch state. The `Waypoint::verify()` method exists to check this hash: [2](#0-1) 

However, the bootstrapper only checks the **version number**, not the **cryptographic hash**, effectively bypassing the primary trust anchor mechanism.

**Bypass 2: Genesis Bootstrap Bypass**

In the executor's `maybe_bootstrap()` function, waypoint verification is skipped entirely if storage already contains data at or past the waypoint version: [3](#0-2) 

This means the actual waypoint hash verification at line 62-67 never executes when storage is already populated.

**Bypass 3: Bootstrapping Completion Without State Validation**

In `initialize_active_data_stream()`, if the local storage version is >= the network's highest known version, bootstrapping completes immediately without any state integrity checks: [4](#0-3) 

The `highest_synced_version` is simply read from storage metadata without verification: [5](#0-4) 

This function retrieves a version number from the database without validating the underlying state integrity, Merkle tree structure, or transaction data correctness.

**Attack Scenario:**

1. Attacker gains file system access to a validator/fullnode's AptosDB storage
2. Attacker corrupts the storage (modifies state values in StateKV, corrupts Merkle tree nodes, alters transaction data)
3. Attacker keeps or inflates the version numbers in storage metadata
4. Node restarts and begins bootstrapping
5. `maybe_bootstrap` returns early (storage version already past waypoint)
6. Waypoint marked as "verified" without hash check (only version comparison)
7. Bootstrapping completes without state validation (version comparison only)
8. Node enters consensus/continuous-sync with corrupted state

**Why This Breaks Security Invariants:**

- **State Consistency Invariant Violated**: State transitions are not verified via cryptographic proofs during bootstrapping
- **Deterministic Execution Invariant Violated**: Corrupted state leads to different execution results across validators
- **Trust Anchor Bypassed**: The waypoint's cryptographic guarantee is completely circumvented

During normal operation, state values are read directly from RocksDB without proof verification: [6](#0-5) 

The implementation reads from the database without cryptographic verification: [7](#0-6) 

## Impact Explanation

**Severity: Critical** (per Aptos Bug Bounty criteria)

This vulnerability meets multiple Critical severity criteria:

1. **Consensus/Safety Violations**: A validator with corrupted state would:
   - Execute transactions based on incorrect state
   - Propose blocks with invalid state roots
   - Vote on blocks using corrupted state as the base
   - Create consensus divergence when honest validators reject its proposals

2. **State Inconsistencies Requiring Hardfork**: If multiple validators are compromised:
   - Different validators could have different views of state
   - Could lead to network partition if sufficient validators disagree
   - Recovery might require manual intervention or rollback

3. **Loss of Funds (Indirect)**: Corrupted account balances or smart contract state could:
   - Allow unauthorized token transfers
   - Break DeFi protocol invariants
   - Enable double-spending scenarios

The vulnerability completely bypasses the waypoint mechanism, which is designed to be the trust anchor preventing exactly this type of attack. The waypoint is documented as providing "an off-chain mechanism to verify the sync process right after the restart."

## Likelihood Explanation

**Likelihood: Medium-High**

**Attacker Requirements:**
- File system access to the node's storage directory
- Ability to restart the node
- Knowledge of AptosDB structure

**Attack Feasibility:**
- **For Cloud-hosted Validators**: Moderate - requires compromising the host OS or storage volumes
- **For Physical Validators**: Moderate - requires physical access or remote access to the machine
- **For Fullnodes**: High - many fullnodes run with less strict security

**Detection Difficulty:**
The corrupted node would likely be detected when:
- It tries to participate in consensus (other validators would reject its proposals)
- It tries to sync new blocks (state root mismatch would be caught during commit)

However, the detection happens **after** the node has already accepted corrupted state as valid and potentially participated in voting, which could cause temporary consensus disruption.

**Real-World Scenarios:**
- Compromised cloud storage snapshots
- Backup/restore procedures that corrupt data
- Hardware failures causing silent data corruption
- Malicious insiders with access to validator infrastructure

## Recommendation

Implement mandatory cryptographic state verification during bootstrapping:

```rust
fn verify_waypoint_is_satisfiable(
    &mut self,
    global_data_summary: &GlobalDataSummary,
) -> Result<(), Error> {
    // If our storage has already synced beyond our waypoint, 
    // VERIFY the waypoint hash instead of blindly accepting it
    let latest_ledger_info = utils::fetch_latest_synced_ledger_info(self.storage.clone())?;
    let waypoint_version = self.driver_configuration.waypoint.version();
    
    if latest_ledger_info.ledger_info().version() >= waypoint_version {
        // NEW: Actually verify the waypoint against stored ledger info
        if latest_ledger_info.ledger_info().version() == waypoint_version {
            // Exact match: verify the cryptographic hash
            self.driver_configuration.waypoint.verify(latest_ledger_info.ledger_info())
                .map_err(|error| Error::VerificationError(format!(
                    "Storage ledger info at waypoint version failed verification: {:?}", error
                )))?;
        } else {
            // Storage is ahead: fetch the ledger info at waypoint version and verify
            let waypoint_ledger_info = self.storage
                .get_ledger_info_by_version(waypoint_version)
                .map_err(|error| Error::StorageError(format!(
                    "Failed to fetch ledger info at waypoint version {}: {:?}",
                    waypoint_version, error
                )))?;
            
            self.driver_configuration.waypoint.verify(waypoint_ledger_info.ledger_info())
                .map_err(|error| Error::VerificationError(format!(
                    "Storage ledger info failed waypoint verification: {:?}", error
                )))?;
        }
        
        self.verified_epoch_states.set_verified_waypoint(waypoint_version);
        return Ok(());
    }
    
    // Rest of the function remains the same...
}
```

Additionally, in `initialize_active_data_stream()`, add state root verification:

```rust
} else if highest_synced_version >= highest_known_ledger_version {
    // NEW: Verify state integrity before completing bootstrapping
    let stored_ledger_info = utils::fetch_latest_synced_ledger_info(self.storage.clone())?;
    let stored_state_root = self.storage.get_state_checkpoint_hash(highest_synced_version)?;
    let expected_state_root = stored_ledger_info.ledger_info().transaction_accumulator_hash();
    
    if stored_state_root != expected_state_root {
        return Err(Error::VerificationError(format!(
            "State root mismatch at version {}: stored {:?} vs ledger info {:?}",
            highest_synced_version, stored_state_root, expected_state_root
        )));
    }
    
    info!(LogSchema::new(LogEntry::Bootstrapper)
        .message(&format!("Verified state integrity at version {}. Bootstrapping complete.",
            highest_synced_version)));
    return self.bootstrapping_complete().await;
}
```

## Proof of Concept

**Reproduction Steps:**

1. **Setup**: Start a validator/fullnode and let it sync to a recent version (e.g., version 1000)

2. **Corrupt Storage**: Stop the node and corrupt the storage database:
```bash
# Backup original storage
cp -r /opt/aptos/data/db /opt/aptos/data/db.backup

# Use a hex editor or custom tool to modify state values in the StateKvDb
# For example, modify account balances in state storage
# Keep the version metadata intact or inflate it

# Specifically corrupt: storage/aptosdb/state_kv_db/
# Modify some state key-value pairs while preserving the RocksDB structure
```

3. **Restart Node**: Restart the node with the corrupted storage

4. **Observe Bypasses**:
```rust
// The following code paths execute without detecting corruption:

// 1. maybe_bootstrap returns early (line 56-59)
// because ledger_summary.version() >= waypoint.version()

// 2. verify_waypoint_is_satisfiable marks waypoint as verified (line 887-890)
// without calling waypoint.verify()

// 3. initialize_active_data_stream completes bootstrapping (line 483-489)
// without state validation

// 4. Node enters operational state with corrupted storage
```

5. **Verification**:
    - Check logs for "Waypoint has been verified" (from line 89) - should appear without actual cryptographic verification
    - Check logs for "nothing needs to be done" (from line 486) - confirms early completion
    - Check logs for "The node has successfully bootstrapped!" (from line 375) - confirms bypassed validation

6. **Demonstrate Impact**:
```rust
// When the node tries to execute new transactions:
// - It reads corrupted state values
// - Produces different execution results
// - Computes different state roots
// - Fails to match other validators' state roots
// - But the node itself doesn't detect its own corruption until attempting sync
```

**Expected vs Actual Behavior:**

**Expected**: Node should verify waypoint hash and state integrity before completing bootstrapping, rejecting corrupted storage.

**Actual**: Node accepts corrupted storage as valid and completes bootstrapping without cryptographic verification.

**Notes**

This vulnerability fundamentally undermines the waypoint trust model. The waypoint is designed to provide a cryptographic guarantee that the state at a specific version is correct. By bypassing waypoint verification and state validation during bootstrapping, the system allows nodes to operate with unverified and potentially corrupted state, defeating the entire purpose of the waypoint mechanism.

The fix must ensure that:
1. Waypoint hash is **always** cryptographically verified against stored data
2. State root hashes are verified before completing bootstrapping
3. No early-return paths bypass these critical security checks

### Citations

**File:** state-sync/state-sync-driver/src/bootstrapper.rs (L483-489)
```rust
        } else if highest_synced_version >= highest_known_ledger_version {
            // Otherwise, if we've already synced to the highest known version, there's nothing to do
            info!(LogSchema::new(LogEntry::Bootstrapper)
                .message(&format!("Highest synced version {} is >= highest known ledger version {}, nothing needs to be done.",
                    highest_synced_version, highest_known_ledger_version)));
            return self.bootstrapping_complete().await;
        }
```

**File:** state-sync/state-sync-driver/src/bootstrapper.rs (L884-890)
```rust
        // If our storage has already synced beyond our waypoint, nothing needs to be checked
        let latest_ledger_info = utils::fetch_latest_synced_ledger_info(self.storage.clone())?;
        let waypoint_version = self.driver_configuration.waypoint.version();
        if latest_ledger_info.ledger_info().version() >= waypoint_version {
            self.verified_epoch_states
                .set_verified_waypoint(waypoint_version);
            return Ok(());
```

**File:** types/src/waypoint.rs (L62-79)
```rust
    pub fn verify(&self, ledger_info: &LedgerInfo) -> Result<()> {
        ensure!(
            ledger_info.version() == self.version(),
            "Waypoint version mismatch: waypoint version = {}, given version = {}",
            self.version(),
            ledger_info.version()
        );
        let converter = Ledger2WaypointConverter::new(ledger_info);
        ensure!(
            converter.hash() == self.value(),
            format!(
                "Waypoint value mismatch: waypoint value = {}, given value = {}",
                self.value().to_hex(),
                converter.hash().to_hex()
            )
        );
        Ok(())
    }
```

**File:** execution/executor/src/db_bootstrapper/mod.rs (L56-59)
```rust
    if ledger_summary.version().map_or(0, |v| v + 1) != waypoint.version() {
        info!(waypoint = %waypoint, "Skip genesis txn.");
        return Ok(None);
    }
```

**File:** state-sync/state-sync-driver/src/utils.rs (L280-284)
```rust
pub fn fetch_pre_committed_version(storage: Arc<dyn DbReader>) -> Result<Version, Error> {
    storage.ensure_pre_committed_version().map_err(|e| {
        Error::StorageError(format!("Failed to get latest version from storage: {e:?}"))
    })
}
```

**File:** storage/storage-interface/src/state_store/state_view/cached_state_view.rs (L244-247)
```rust
            StateSlot::from_db_get(
                self.cold
                    .get_state_value_with_version_by_version(state_key, base_version)?,
            )
```

**File:** storage/aptosdb/src/db/aptosdb_reader.rs (L137-141)
```rust
    fn get_pre_committed_version(&self) -> Result<Option<Version>> {
        gauged_api("get_pre_committed_version", || {
            Ok(self.state_store.current_state_locked().version())
        })
    }
```
