# Audit Report

## Title
IndexerTableInfoConfig Sanitizer Bypass Allows Node Crash via Zero parser_batch_size

## Summary
The `IndexerGrpcConfig` sanitizer fails to validate numeric fields in `IndexerTableInfoConfig`, allowing a zero value for `parser_batch_size` to bypass sanitization and cause a panic when the table info service attempts to chunk transactions, crashing the node.

## Finding Description

The `IndexerTableInfoConfig` struct contains two critical numeric configuration parameters that control transaction processing parallelism:
- `parser_task_count: u16` - Number of parallel processing tasks
- `parser_batch_size: u16` - Transactions per batch [1](#0-0) 

The configuration sanitization process validates `IndexerGrpcConfig` but only checks whether `table_info_service_mode.is_enabled()` returns true, without validating the numeric field values: [2](#0-1) 

Critically, `IndexerTableInfoConfig` itself has **no** `ConfigSanitizer` implementationâ€”this was confirmed by searching the codebase, which returned zero matches for any sanitizer implementation for this config struct.

The main sanitization entry point calls `IndexerGrpcConfig::sanitize()` but never validates `IndexerTableInfoConfig` fields directly: [3](#0-2) 

When the table info service starts, it uses the unchecked `parser_batch_size` value directly in `process_transactions_in_parallel()`: [4](#0-3) 

In Rust, calling `slice::chunks(0)` **always panics** with the error "chunk size must be non-zero", regardless of whether the slice is empty. This panic is unrecoverable and crashes the node.

**Attack Path:**
1. Attacker/misconfigured operator creates a node config with `indexer_table_info.parser_batch_size: 0`
2. Configuration is loaded via serde deserialization without validation
3. `IndexerGrpcConfig::sanitize()` runs but only checks `table_info_service_mode`, not numeric values
4. Configuration passes all sanitization checks
5. Node starts and table info service begins processing at runtime
6. `process_transactions_in_parallel()` is called with any transaction batch
7. Line 259 executes: `transactions.chunks(0)` 
8. Rust runtime panics: "chunk size must be non-zero"
9. Node crashes with unrecoverable panic

## Impact Explanation

**Severity: High** - This vulnerability meets the "High Severity" criteria per the Aptos bug bounty program for the following reasons:

1. **Validator/Fullnode Crash**: Any node operator who sets `parser_batch_size: 0` (either through misconfiguration or malicious intent) will experience a node crash when the table info service attempts to process transactions. This represents a clear "API crashes" and "Validator node slowdowns" impact.

2. **Availability Impact**: The crash is deterministic and unrecoverable without configuration changes. If deployed to production, this would cause immediate node downtime.

3. **Bypasses Security Controls**: The sanitizer framework exists specifically to prevent invalid configurations from causing runtime failures. This bypass violates the fundamental security guarantee that "sanitized configs are safe to use."

While this doesn't directly affect consensus safety or cause fund loss, it represents a significant **protocol violation** where the config sanitization layer fails to fulfill its designed purpose of catching invalid configurations before they cause runtime failures.

## Likelihood Explanation

**Likelihood: Medium-to-High**

This vulnerability is moderately likely to occur in practice:

1. **Easy to Trigger**: Any node operator can trigger this by setting a single configuration value to 0
2. **Realistic Misconfiguration**: Zero values are common typos/mistakes in YAML configs
3. **No Warning**: The sanitizer provides no feedback that zero is invalid
4. **Deterministic**: Once configured, the crash is guaranteed on first transaction processing

The vulnerability requires:
- Node operator to have write access to their own config file (standard)
- `indexer_grpc.enabled = true` and table info service enabled
- No privileged validator access required

## Recommendation

Add a dedicated `ConfigSanitizer` implementation for `IndexerTableInfoConfig` that validates numeric fields are non-zero:

```rust
impl ConfigSanitizer for IndexerTableInfoConfig {
    fn sanitize(
        node_config: &NodeConfig,
        _node_type: NodeType,
        _chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();
        let config = &node_config.indexer_table_info;

        // Only validate if the service is enabled
        if !config.table_info_service_mode.is_enabled() {
            return Ok(());
        }

        // Validate parser_task_count is non-zero
        if config.parser_task_count == 0 {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name.clone(),
                "indexer_table_info.parser_task_count must be greater than 0".to_string(),
            ));
        }

        // Validate parser_batch_size is non-zero
        if config.parser_batch_size == 0 {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "indexer_table_info.parser_batch_size must be greater than 0".to_string(),
            ));
        }

        Ok(())
    }
}
```

Then register this sanitizer in the main sanitization flow:

```rust
// In config/src/config/config_sanitizer.rs, add after line 59:
IndexerTableInfoConfig::sanitize(node_config, node_type, chain_id)?;
```

## Proof of Concept

Create a malicious node configuration file (`fullnode_malicious.yaml`):

```yaml
base:
  role: "full_node"
  
indexer_grpc:
  enabled: true
  use_data_service_interface: false
  address: "0.0.0.0:50051"

indexer_table_info:
  parser_task_count: 10
  parser_batch_size: 0  # MALICIOUS: Zero value bypasses sanitizer
  table_info_service_mode: 
    IndexingOnly: null

storage:
  enable_indexer: true
```

**Steps to Reproduce:**

1. Start an Aptos fullnode with the above configuration
2. Configuration will pass sanitization (no error during startup)
3. Wait for the table info service to receive its first transaction batch
4. Node will panic with: `thread 'table-info' panicked at 'chunk size must be non-zero'`
5. Node process terminates

**Expected Behavior:**
The sanitizer should reject this configuration during node startup with a clear error message: `"indexer_table_info.parser_batch_size must be greater than 0"`

**Actual Behavior:**
Configuration passes sanitization, and the node crashes at runtime when processing transactions.

## Notes

This vulnerability demonstrates a gap in the defense-in-depth strategy where the configuration sanitization layer (the first line of defense against invalid configs) fails to validate critical numeric constraints. While the immediate impact is limited to node availability rather than consensus or funds, it represents a violation of the system's invariant that "sanitized configurations are safe to execute."

The fix is straightforward and should be applied alongside similar validation for other numeric configuration fields that have implicit non-zero requirements.

### Citations

**File:** config/src/config/indexer_table_info_config.rs (L29-36)
```rust
pub struct IndexerTableInfoConfig {
    /// Number of processor tasks to fan out
    pub parser_task_count: u16,

    /// Number of transactions each parser will process
    pub parser_batch_size: u16,
    pub table_info_service_mode: TableInfoServiceMode,
}
```

**File:** config/src/config/indexer_grpc_config.rs (L103-127)
```rust
impl ConfigSanitizer for IndexerGrpcConfig {
    fn sanitize(
        node_config: &NodeConfig,
        _node_type: NodeType,
        _chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();

        if !node_config.indexer_grpc.enabled {
            return Ok(());
        }

        if !node_config.storage.enable_indexer
            && !node_config
                .indexer_table_info
                .table_info_service_mode
                .is_enabled()
        {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "storage.enable_indexer must be true or indexer_table_info.table_info_service_mode must be IndexingOnly if indexer_grpc.enabled is true".to_string(),
            ));
        }
        Ok(())
    }
```

**File:** config/src/config/config_sanitizer.rs (L59-59)
```rust
        IndexerGrpcConfig::sanitize(node_config, node_type, chain_id)?;
```

**File:** ecosystem/indexer-grpc/indexer-grpc-table-info/src/table_info_service.rs (L258-262)
```rust
        for (chunk_idx, batch_size) in transactions
            .chunks(self.parser_batch_size as usize)
            .enumerate()
            .map(|(idx, chunk)| (idx, chunk.len()))
        {
```
