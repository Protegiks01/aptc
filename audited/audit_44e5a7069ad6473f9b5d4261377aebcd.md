# Audit Report

## Title
State Snapshot Finalization Fails to Write StateKvCommitProgress Leading to Panic on Restart

## Summary
The `finalize_state_snapshot()` function commits ledger database batches but fails to commit state KV database batches, leaving `StateKvCommitProgress` unwritten. On restart, `sync_commit_progress()` expects this progress marker to exist and panics with "State K/V commit progress cannot be None", preventing node recovery.

## Finding Description

The vulnerability exists in the state snapshot finalization code path where state KV batches are created but never committed to disk.

When `finalize_state_snapshot()` executes, it creates both ledger and state KV batches: [1](#0-0) 

These batches are passed to `save_transactions()` with the `existing_batch` parameter set to `Some`: [2](#0-1) 

However, when `save_transactions()` receives `Some(existing_batch)`, it only populates the batches without committing them: [3](#0-2) 

The function then only commits the ledger database batch: [4](#0-3) 

The state KV batches (`sharded_kv_batch` and `state_kv_metadata_batch`) are never committed. `StateKvCommitProgress` is only written when `state_kv_db.commit()` is called: [5](#0-4) 

In contrast, normal transaction processing correctly commits state KV batches: [6](#0-5) 

On node restart, `StateStore::new()` calls `sync_commit_progress()`: [7](#0-6) 

The `sync_commit_progress()` function expects `StateKvCommitProgress` to exist when `OverallCommitProgress` exists: [8](#0-7) 

Since `StateKvCommitProgress` was never written, the node panics at line 434, preventing restart.

## Impact Explanation

**HIGH Severity** - This vulnerability causes validator node crashes meeting the "API Crashes" category from the Aptos bug bounty program (up to $50,000):

1. **Validator Node Crashes**: Any validator performing state sync via snapshot restoration will crash on restart with an unrecoverable panic
2. **Loss of Network Liveness**: Affected validators cannot participate in consensus, reducing the active validator set
3. **State Database Inconsistency**: The database contains ledger progress markers but missing state KV progress markers, violating atomicity guarantees
4. **Manual Intervention Required**: Recovery requires database-level manual intervention or complete resync from genesis

This is called during normal state synchronization operations: [9](#0-8) 

## Likelihood Explanation

**HIGH Likelihood** - This bug triggers during normal node operations:

1. State snapshot restoration is the standard "fast sync" mechanism for nodes catching up to the network
2. The bootstrapping configuration explicitly supports snapshot-based sync as a primary sync mode
3. Any node performing state sync will deterministically trigger this bug
4. The bug occurs automatically on the next restart after snapshot finalizationâ€”no attacker action required
5. This is a pure logic bug in the commit flow, not a race condition or timing issue

The combination of high likelihood and high impact makes this a critical operational vulnerability affecting validator availability.

## Recommendation

Commit the state KV batches in `finalize_state_snapshot()` after writing the ledger batch. Add the following code after line 223:

```rust
self.state_kv_db.commit(
    version,
    Some(state_kv_metadata_batch),
    sharded_kv_batch,
)?;
```

This ensures `StateKvCommitProgress` is written atomically with `OverallCommitProgress` and `LedgerCommitProgress`, maintaining database consistency across restarts.

## Proof of Concept

While a full end-to-end PoC would require setting up state sync infrastructure, the bug can be demonstrated by code inspection:

1. Run a node that performs state snapshot synchronization (DownloadLatestStates bootstrapping mode)
2. Allow `finalize_state_snapshot()` to complete
3. Verify `OverallCommitProgress` exists in ledger metadata DB but `StateKvCommitProgress` does not exist in state KV metadata DB
4. Restart the node
5. Observe panic in `sync_commit_progress()` at the `.expect()` call on line 434

The code paths are deterministic and the bug is clearly present in the implementation.

### Citations

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L163-165)
```rust
            let mut ledger_db_batch = LedgerDbSchemaBatches::new();
            let mut sharded_kv_batch = self.state_kv_db.new_sharded_native_batches();
            let mut state_kv_metadata_batch = SchemaBatch::new();
```

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L183-198)
```rust
            restore_utils::save_transactions(
                self.state_store.clone(),
                self.ledger_db.clone(),
                version,
                &transactions,
                &persisted_aux_info,
                &transaction_infos,
                &events,
                wsets,
                Some((
                    &mut ledger_db_batch,
                    &mut sharded_kv_batch,
                    &mut state_kv_metadata_batch,
                )),
                false,
            )?;
```

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L223-223)
```rust
            self.ledger_db.write_schemas(ledger_db_batch)?;
```

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L376-380)
```rust
            s.spawn(|_| {
                self.state_kv_db
                    .commit(chunk.expect_last_version(), None, sharded_state_kv_batches)
                    .unwrap();
            });
```

**File:** storage/aptosdb/src/backup/restore_utils.rs (L131-144)
```rust
    if let Some((ledger_db_batch, state_kv_batches, _state_kv_metadata_batch)) = existing_batch {
        save_transactions_impl(
            state_store,
            ledger_db,
            first_version,
            txns,
            persisted_aux_info,
            txn_infos,
            events,
            write_sets.as_ref(),
            ledger_db_batch,
            state_kv_batches,
            kv_replay,
        )?;
```

**File:** storage/aptosdb/src/state_kv_db.rs (L207-215)
```rust
        self.write_progress(version)
    }

    pub(crate) fn write_progress(&self, version: Version) -> Result<()> {
        self.state_kv_metadata_db.put::<DbMetadataSchema>(
            &DbMetadataKey::StateKvCommitProgress,
            &DbMetadataValue::Version(version),
        )
    }
```

**File:** storage/aptosdb/src/state_store/mod.rs (L353-359)
```rust
        if !hack_for_tests && !empty_buffered_state_for_restore {
            Self::sync_commit_progress(
                Arc::clone(&ledger_db),
                Arc::clone(&state_kv_db),
                Arc::clone(&state_merkle_db),
                /*crash_if_difference_is_too_large=*/ true,
            );
```

**File:** storage/aptosdb/src/state_store/mod.rs (L430-435)
```rust
            let state_kv_commit_progress = state_kv_db
                .metadata_db()
                .get::<DbMetadataSchema>(&DbMetadataKey::StateKvCommitProgress)
                .expect("Failed to read state K/V commit progress.")
                .expect("State K/V commit progress cannot be None.")
                .expect_version();
```

**File:** state-sync/state-sync-driver/src/storage_synchronizer.rs (L1129-1136)
```rust
    storage
        .writer
        .finalize_state_snapshot(
            version,
            target_output_with_proof.clone(),
            epoch_change_proofs,
        )
        .map_err(|error| format!("Failed to finalize the state snapshot! Error: {:?}", error))?;
```
