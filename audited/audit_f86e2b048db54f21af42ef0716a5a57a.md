# Audit Report

## Title
Gas Feature Version Manipulation Enables Permanent Governance Denial-of-Service

## Summary
The `aptos-gas-schedule-updator` tool accepts arbitrary gas feature version values without validation, and the on-chain gas schedule update function only validates that new versions are greater than or equal to the current version. This allows setting an artificially inflated version number (e.g., 99999999) that would permanently block all future legitimate gas schedule updates, requiring a hard fork to recover.

## Finding Description
The vulnerability exists across two components:

1. **Tool-side (Proposal Generation)**: The `generate_update_proposal` function accepts any u64 value via `--gas-feature-version` without validating it against `LATEST_GAS_FEATURE_VERSION` (currently 45). [1](#0-0) 

The tool simply uses the provided version or defaults to `LATEST_GAS_FEATURE_VERSION`, with no upper bound validation.

2. **On-chain (Update Validation)**: The `set_for_next_epoch` function only validates that the new version is greater than or equal to the current version, with no upper bound check. [2](#0-1) 

**Attack Scenario:**
1. An attacker (or well-meaning developer making a typo) runs: `aptos-gas-schedule-updator --gas-feature-version 99999999`
2. The tool generates a valid-looking governance proposal with version 99999999
3. If the proposal is approved through governance (either through social engineering or accidental approval by core developers)
4. The on-chain validation passes: `99999999 >= 45` ✓
5. The gas schedule version is permanently set to 99999999
6. **All future legitimate gas schedule updates with versions 46, 47, 48, etc. are now rejected** because they fail the check: `46 >= 99999999` ✗
7. The network cannot update gas parameters through normal governance procedures
8. Recovery requires a hard fork

**Why This Doesn't Cause Gas Metering Issues:**
While the question asks about "undefined behavior in gas metering," the actual gas metering would function correctly even with an inflated version:
- All gas parameters use open-ended version ranges like `{ 12.. => "key" }` [3](#0-2) 
- Version checks in the runtime use `>=` comparisons that would all pass [4](#0-3) 
- Parameter values come from hardcoded initial values, not the version number [5](#0-4) 

**The actual vulnerability is governance DoS, not gas metering corruption.**

## Impact Explanation
This vulnerability meets **Critical** severity under the Aptos bug bounty criteria:
- **"Non-recoverable network partition (requires hardfork)"**: Once an inflated version is set, the network cannot update gas parameters through normal governance, requiring a hard fork to fix.
- **Governance Integrity Violation**: Breaks the critical invariant that "Voting power must be correctly calculated from stake" by making governance proposals ineffective for gas schedule updates.

The impact is permanent and irreversible without a hard fork, making this a critical governance failure.

## Likelihood Explanation
**High Likelihood** - This vulnerability can occur through:
1. **Accidental triggering**: A developer making a typo (e.g., `--gas-feature-version 450` instead of `45`) would trigger this without realizing the consequences
2. **Malicious exploitation**: An attacker could socially engineer approval of a malicious proposal
3. **No technical barriers**: The attack requires no special privileges beyond running a public tool

The lack of any validation makes this vulnerability easily triggerable, especially in the accidental case.

## Recommendation
Add validation at both the tool level and on-chain:

**Tool-side fix** (aptos-move/aptos-gas-schedule-updator/src/lib.rs):
```rust
pub fn generate_update_proposal(args: &GenArgs) -> Result<()> {
    let mut pack = PackageBuilder::new("GasScheduleUpdate");

    let feature_version = args
        .gas_feature_version
        .unwrap_or(LATEST_GAS_FEATURE_VERSION);
    
    // ADD THIS VALIDATION
    if feature_version > LATEST_GAS_FEATURE_VERSION {
        return Err(anyhow::anyhow!(
            "Invalid gas feature version: {}. Maximum allowed: {}",
            feature_version,
            LATEST_GAS_FEATURE_VERSION
        ));
    }
    
    pack.add_source(
        "update_gas_schedule.move",
        &generate_script(&current_gas_schedule(feature_version))?,
    );
    pack.add_local_dep("AptosFramework", &aptos_framework_path().to_string_lossy());
    pack.write_to_disk(args.output.as_deref().unwrap_or("./proposal"))?;
    Ok(())
}
```

**On-chain fix** (gas_schedule.move) - Add a reasonable upper bound:
```move
const MAX_REASONABLE_GAS_FEATURE_VERSION: u64 = 1000; // or another reasonable limit

public fun set_for_next_epoch(aptos_framework: &signer, gas_schedule_blob: vector<u8>) acquires GasScheduleV2 {
    system_addresses::assert_aptos_framework(aptos_framework);
    assert!(!vector::is_empty(&gas_schedule_blob), error::invalid_argument(EINVALID_GAS_SCHEDULE));
    let new_gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
    
    // ADD THIS VALIDATION
    assert!(
        new_gas_schedule.feature_version <= MAX_REASONABLE_GAS_FEATURE_VERSION,
        error::invalid_argument(EINVALID_GAS_FEATURE_VERSION)
    );
    
    if (exists<GasScheduleV2>(@aptos_framework)) {
        let cur_gas_schedule = borrow_global<GasScheduleV2>(@aptos_framework);
        assert!(
            new_gas_schedule.feature_version >= cur_gas_schedule.feature_version,
            error::invalid_argument(EINVALID_GAS_FEATURE_VERSION)
        );
    };
    config_buffer::upsert(new_gas_schedule);
}
```

## Proof of Concept
```bash
# Step 1: Generate malicious proposal with inflated version
cd aptos-core/aptos-move/aptos-gas-schedule-updator
cargo run -- --gas-feature-version 99999999 --output ./malicious_proposal

# Step 2: Observe that the tool succeeds without validation error
# The generated proposal contains:
# feature_version: 99999999
# entries: [valid gas parameter entries with standard values]

# Step 3: Deploy and execute the proposal through governance
# (Assuming governance approval is obtained)

# Step 4: Attempt to submit a legitimate future update with version 46
cargo run -- --gas-feature-version 46 --output ./legitimate_update

# Step 5: When this legitimate proposal is executed on-chain, it will fail with:
# Error: EINVALID_GAS_FEATURE_VERSION (0x010002)
# Because: 46 >= 99999999 is false

# The network is now permanently stuck at version 99999999
# All future gas schedule governance updates are blocked
# Recovery requires a hard fork to reset the version
```

## Notes
While the security question asks about "undefined behavior in gas metering," the actual vulnerability is a **governance denial-of-service attack** rather than incorrect gas charging. The gas metering system would function correctly even with an inflated version number due to the forward-compatible design of version checks. However, the governance process would be permanently compromised, requiring a hard fork to recover—making this a Critical severity finding under "Non-recoverable network partition (requires hardfork)."

### Citations

**File:** aptos-move/aptos-gas-schedule-updator/src/lib.rs (L116-121)
```rust
pub fn current_gas_schedule(feature_version: u64) -> GasScheduleV2 {
    GasScheduleV2 {
        feature_version,
        entries: AptosGasParameters::initial().to_on_chain_gas_schedule(feature_version),
    }
}
```

**File:** aptos-move/aptos-gas-schedule-updator/src/lib.rs (L124-130)
```rust
pub fn generate_update_proposal(args: &GenArgs) -> Result<()> {
    let mut pack = PackageBuilder::new("GasScheduleUpdate");

    let feature_version = args
        .gas_feature_version
        .unwrap_or(LATEST_GAS_FEATURE_VERSION);

```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L95-101)
```text
        if (exists<GasScheduleV2>(@aptos_framework)) {
            let cur_gas_schedule = borrow_global<GasScheduleV2>(@aptos_framework);
            assert!(
                new_gas_schedule.feature_version >= cur_gas_schedule.feature_version,
                error::invalid_argument(EINVALID_GAS_FEATURE_VERSION)
            );
        };
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/instr.rs (L37-41)
```rust
        [ld_u16: InternalGas, { 5.. => "ld_u16" }, 220],
        [ld_u32: InternalGas, { 5.. => "ld_u32" }, 220],
        [ld_u64: InternalGas, "ld_u64", 220],
        [ld_u128: InternalGas, "ld_u128", 294],
        [ld_u256: InternalGas, { 5.. => "ld_u256" }, 294],
```

**File:** aptos-move/aptos-gas-meter/src/algebra.rs (L204-208)
```rust
        if self.feature_version >= 7 && self.execution_gas_used > self.max_execution_gas {
            Err(PartialVMError::new(StatusCode::EXECUTION_LIMIT_REACHED))
        } else {
            Ok(())
        }
```
