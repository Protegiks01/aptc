# Audit Report

## Title
Unauthenticated Remote Executor Command Injection via Missing Authentication in gRPC Service

## Summary
The remote executor service's gRPC endpoint accepts arbitrary execution commands without authentication or authorization, allowing attackers with internal network access to inject malicious execution requests, causing denial of service, resource exhaustion, or potentially poisoning execution results.

## Finding Description

The security question references `simple_msg_exchange()` at lines 92-118 in `aptos.remote_executor.v1.tonic.rs`, which is auto-generated gRPC **client** code. However, the actual vulnerability exists in the **server** implementation. [1](#0-0) 

The server-side implementation is in `GRPCNetworkMessageServiceServerWrapper`, which accepts incoming `NetworkMessage` requests without any authentication or authorization checks: [2](#0-1) 

The implementation only checks if a handler exists for the message type, but does not validate:
- Sender identity or authentication credentials
- Authorization to send execution commands  
- Message signature or cryptographic proof
- Source IP address or network boundary enforcement

The service uses plain HTTP without TLS: [3](#0-2) 

When executor shards receive `execute_command_{shard_id}` messages, they directly deserialize and execute them without validation: [4](#0-3) 

This remote execution path is used in the actual blockchain execution workflow when remote addresses are configured: [5](#0-4) 

The executor service processes these commands and executes arbitrary transactions: [6](#0-5) 

**Attack Scenario:**

1. Attacker gains access to internal cluster network (e.g., compromised container, lateral movement)
2. Attacker discovers executor shard addresses (enumerable via port scanning)
3. Attacker crafts malicious `NetworkMessage` with:
   - `message_type = "execute_command_0"` (or other shard IDs)
   - `message = BCS-serialized RemoteExecutionRequest` containing arbitrary transactions or malformed data
4. Attacker sends messages to `/aptos.remote_executor.v1.NetworkMessageService/SimpleMsgExchange` endpoint
5. Executor shard deserializes and attempts to execute attacker's commands

**Impact:** 
- Denial of service by flooding executor with garbage commands
- Resource exhaustion through malicious transaction execution
- Race conditions with legitimate coordinator commands
- Potential execution result poisoning if attacker's commands are processed before legitimate ones
- Crash potential with malformed BCS-serialized data

## Impact Explanation

This vulnerability qualifies as **HIGH severity** per Aptos bug bounty criteria:
- **Validator node slowdowns**: Flooding executors with malicious commands degrades performance
- **Significant protocol violations**: Execution commands processed without authentication violates fundamental security principles
- **Potential for execution disruption**: Could interfere with legitimate block execution

While not CRITICAL (does not directly cause fund theft or consensus violation), it enables serious attacks on execution infrastructure that could lead to:
- Liveness degradation or temporary unavailability
- Resource exhaustion requiring node restarts
- Execution result inconsistencies if malicious commands are processed

## Likelihood Explanation

**Likelihood: MEDIUM**

Requirements for exploitation:
1. Attacker must gain internal cluster network access (e.g., compromised pod/container)
2. Attacker must discover executor shard addresses (may be enumerable)
3. Attacker must craft valid BCS-serialized messages (format is public)

While not trivially exploitable from external networks, the complete absence of authentication means any attacker who achieves internal network access can immediately exploit this. Common attack vectors include:
- Container escape vulnerabilities
- Compromised application pods in same cluster
- Lateral movement after initial breach
- Insider threats

Defense-in-depth principles require authentication even for internal services, especially those controlling transaction execution.

## Recommendation

Implement authentication and authorization for the remote executor gRPC service:

1. **Add mutual TLS (mTLS)**: 
   - Require TLS certificates for all connections
   - Validate client certificates against known coordinator/shard identities
   - Use certificate pinning to prevent MitM attacks

2. **Implement message signing**:
   - Sign all `NetworkMessage` payloads with coordinator's private key
   - Verify signatures before processing messages
   - Include nonce/timestamp to prevent replay attacks

3. **Add authorization checks**:
   - Maintain allowlist of authorized coordinator addresses
   - Reject messages from unknown sources
   - Log all authentication failures

4. **Network segmentation**:
   - Use NetworkPolicies to restrict gRPC endpoints to known coordinator IPs
   - Implement firewall rules at infrastructure level
   - Deploy executor shards in isolated network segments

Example fix for authentication check in `simple_msg_exchange()`:

```rust
async fn simple_msg_exchange(
    &self,
    request: Request<NetworkMessage>,
) -> Result<Response<Empty>, Status> {
    // Add authentication check
    if !self.verify_sender_authorization(&request) {
        return Err(Status::unauthenticated("Invalid credentials"));
    }
    
    let network_message = request.into_inner();
    
    // Add signature verification
    if !self.verify_message_signature(&network_message) {
        return Err(Status::unauthenticated("Invalid message signature"));
    }
    
    // Proceed with message handling...
}
```

## Proof of Concept

```rust
// PoC: Unauthenticated Execution Command Injection
// This demonstrates how an attacker with network access can inject commands

use aptos_protos::remote_executor::v1::{
    network_message_service_client::NetworkMessageServiceClient,
    NetworkMessage,
};
use tonic::transport::Channel;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Attacker connects to executor shard (assumes internal network access)
    let executor_addr = "http://executor-shard-0:52201"; // Example shard address
    
    let mut client = NetworkMessageServiceClient::connect(executor_addr).await?;
    
    // Craft malicious execution request
    let malicious_request = create_malicious_execution_request();
    
    let network_message = NetworkMessage {
        message: bcs::to_bytes(&malicious_request)?,
        message_type: "execute_command_0".to_string(), // Target shard 0
    };
    
    // Send unauthenticated command - will be processed without validation
    let response = client.simple_msg_exchange(network_message).await?;
    
    println!("Malicious command accepted without authentication: {:?}", response);
    Ok(())
}

fn create_malicious_execution_request() -> RemoteExecutionRequest {
    // Attacker can craft arbitrary execution commands
    // Could include: resource-intensive transactions, malformed data, etc.
    RemoteExecutionRequest::ExecuteBlock(ExecuteBlockCommand {
        sub_blocks: create_malicious_transactions(),
        concurrency_level: 1,
        onchain_config: Default::default(),
    })
}
```

**Test Steps:**
1. Deploy executor service with remote execution enabled
2. Run PoC from pod/container in same network
3. Observe that unauthenticated commands are processed
4. Monitor executor for DoS, resource exhaustion, or crashes
5. Verify no authentication errors are returned

## Notes

The vulnerability exists in the **server** implementation, not the client code referenced in the original question. The fundamental issue is the complete absence of authentication/authorization in a critical execution control path. While designed for internal trusted networks, this violates defense-in-depth principles and creates exploitable attack surface for any attacker achieving internal network access.

### Citations

**File:** protos/rust/src/pb/aptos.remote_executor.v1.tonic.rs (L92-118)
```rust
        pub async fn simple_msg_exchange(
            &mut self,
            request: impl tonic::IntoRequest<super::NetworkMessage>,
        ) -> std::result::Result<tonic::Response<super::Empty>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/aptos.remote_executor.v1.NetworkMessageService/SimpleMsgExchange",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "aptos.remote_executor.v1.NetworkMessageService",
                        "SimpleMsgExchange",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
```

**File:** secure/net/src/grpc_network_service/mod.rs (L92-115)
```rust
impl NetworkMessageService for GRPCNetworkMessageServiceServerWrapper {
    async fn simple_msg_exchange(
        &self,
        request: Request<NetworkMessage>,
    ) -> Result<Response<Empty>, Status> {
        let _timer = NETWORK_HANDLER_TIMER
            .with_label_values(&[&self.self_addr.to_string(), "inbound_msgs"])
            .start_timer();
        let remote_addr = request.remote_addr();
        let network_message = request.into_inner();
        let msg = Message::new(network_message.message);
        let message_type = MessageType::new(network_message.message_type);

        if let Some(handler) = self.inbound_handlers.lock().unwrap().get(&message_type) {
            // Send the message to the registered handler
            handler.send(msg).unwrap();
        } else {
            error!(
                "No handler registered for sender: {:?} and msg type {:?}",
                remote_addr, message_type
            );
        }
        Ok(Response::new(Empty {}))
    }
```

**File:** secure/net/src/grpc_network_service/mod.rs (L124-138)
```rust
    pub fn new(rt: &Runtime, remote_addr: SocketAddr) -> Self {
        Self {
            remote_addr: remote_addr.to_string(),
            remote_channel: rt
                .block_on(async { Self::get_channel(format!("http://{}", remote_addr)).await }),
        }
    }

    async fn get_channel(remote_addr: String) -> NetworkMessageServiceClient<Channel> {
        info!("Trying to connect to remote server at {:?}", remote_addr);
        let conn = tonic::transport::Endpoint::new(remote_addr)
            .unwrap()
            .connect_lazy();
        NetworkMessageServiceClient::new(conn).max_decoding_message_size(MAX_MESSAGE_SIZE)
    }
```

**File:** execution/executor-service/src/remote_cordinator_client.rs (L80-112)
```rust
    fn receive_execute_command(&self) -> ExecutorShardCommand<RemoteStateViewClient> {
        match self.command_rx.recv() {
            Ok(message) => {
                let _rx_timer = REMOTE_EXECUTOR_TIMER
                    .with_label_values(&[&self.shard_id.to_string(), "cmd_rx"])
                    .start_timer();
                let bcs_deser_timer = REMOTE_EXECUTOR_TIMER
                    .with_label_values(&[&self.shard_id.to_string(), "cmd_rx_bcs_deser"])
                    .start_timer();
                let request: RemoteExecutionRequest = bcs::from_bytes(&message.data).unwrap();
                drop(bcs_deser_timer);

                match request {
                    RemoteExecutionRequest::ExecuteBlock(command) => {
                        let init_prefetch_timer = REMOTE_EXECUTOR_TIMER
                            .with_label_values(&[&self.shard_id.to_string(), "init_prefetch"])
                            .start_timer();
                        let state_keys = Self::extract_state_keys(&command);
                        self.state_view_client.init_for_block(state_keys);
                        drop(init_prefetch_timer);

                        let (sub_blocks, concurrency, onchain_config) = command.into();
                        ExecutorShardCommand::ExecuteSubBlocks(
                            self.state_view_client.clone(),
                            sub_blocks,
                            concurrency,
                            onchain_config,
                        )
                    },
                }
            },
            Err(_) => ExecutorShardCommand::Stop,
        }
```

**File:** execution/executor/src/workflow/do_get_execution_output.rs (L261-267)
```rust
        if !get_remote_addresses().is_empty() {
            Ok(V::execute_block_sharded(
                &REMOTE_SHARDED_BLOCK_EXECUTOR.lock(),
                partitioned_txns,
                state_view,
                onchain_config,
            )?)
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/sharded_executor_service.rs (L215-260)
```rust
    pub fn start(&self) {
        trace!(
            "Shard starting, shard_id={}, num_shards={}.",
            self.shard_id,
            self.num_shards
        );
        let mut num_txns = 0;
        loop {
            let command = self.coordinator_client.receive_execute_command();
            match command {
                ExecutorShardCommand::ExecuteSubBlocks(
                    state_view,
                    transactions,
                    concurrency_level_per_shard,
                    onchain_config,
                ) => {
                    num_txns += transactions.num_txns();
                    trace!(
                        "Shard {} received ExecuteBlock command of block size {} ",
                        self.shard_id,
                        num_txns
                    );
                    let exe_timer = SHARDED_EXECUTOR_SERVICE_SECONDS
                        .timer_with(&[&self.shard_id.to_string(), "execute_block"]);
                    let ret = self.execute_block(
                        transactions,
                        state_view.as_ref(),
                        BlockExecutorConfig {
                            local: BlockExecutorLocalConfig::default_with_concurrency_level(
                                concurrency_level_per_shard,
                            ),
                            onchain: onchain_config,
                        },
                    );
                    drop(state_view);
                    drop(exe_timer);

                    let _result_tx_timer = SHARDED_EXECUTOR_SERVICE_SECONDS
                        .timer_with(&[&self.shard_id.to_string(), "result_tx"]);
                    self.coordinator_client.send_execution_result(ret);
                },
                ExecutorShardCommand::Stop => {
                    break;
                },
            }
        }
```
