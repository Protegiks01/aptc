# Audit Report

## Title
RuntimeEnvironment Inconsistency During State View Updates Causes Consensus Violations

## Summary
The `CachedModuleView::reset_state_view()` method updates the underlying state view without checking if the RuntimeEnvironment (which contains VM configuration and feature flags) has changed. This causes transactions to be validated and executed with stale VM configurations when on-chain feature flags are updated via governance, leading to non-deterministic execution across validators and potential consensus violations.

## Finding Description
The vulnerability exists in the state view update mechanism used by both the VM validator and consensus pipeline. When on-chain configuration changes (specifically feature flags in the `Features` resource), the system needs to update both the state view AND the runtime environment to maintain consistency. [1](#0-0) 

The `reset_state_view()` method only updates the state view reference without invalidating or updating the cached environment. This is problematic because the `AptosEnvironment` is created once from a state view and caches the VM configuration derived from feature flags at that point in time. [2](#0-1) 

The environment construction process reads feature flags from the state view and uses them to build a `VMConfig` with settings like `enable_lazy_loading`, `enable_enum_option`, `enable_function_caches`, etc. These configurations fundamentally change how the Move VM behaves. [3](#0-2) 

The critical vulnerability manifests in the VM validator's `notify_commit()` method, which is called after each block commit: [4](#0-3) 

The logic checks if state views form a "linear history" based only on version numbers (ledger versions), not on whether the execution environment has changed. When `old_version <= new_version`, it calls `reset_state_view()` which updates only the state view, leaving the stale environment in place.

When transactions are subsequently validated, the VM is created with the old environment but operates on the new state view: [5](#0-4) 

The same vulnerability pattern exists in the consensus pipeline: [6](#0-5) 

**Attack Scenario:**

1. **Initial State (Epoch N):** Feature flag `ENABLE_LAZY_LOADING` = false. VMValidator has Environment_A with `VMConfig { enable_lazy_loading: false }`.

2. **Governance Action:** A governance proposal passes to enable `ENABLE_LAZY_LOADING` feature flag. The feature change is committed at version V1.

3. **State Commit:** The new state view (V1) now contains `Features` resource with `ENABLE_LAZY_LOADING` = true.

4. **notify_commit() Called:** The validator's `notify_commit()` method executes:
   - Fetches new state view with version V1 (contains new features)
   - Compares old version (V0) <= new version (V1) → TRUE
   - Calls `reset_state_view(state_view_V1)` → Updates ONLY state view
   - Environment_A still has `enable_lazy_loading = false`!

5. **Transaction Validation:** New transactions are validated:
   - `AptosVM::new(&Environment_A)` creates VM with old config
   - Validates against state_view_V1 with new features
   - Module loading, bytecode verification, and execution use wrong configuration

6. **Non-Determinism:** Different validators may have different timing:
   - Validator_X's `notify_commit()` is called immediately → uses wrong config
   - Validator_Y's `restart()` is called first → uses correct config
   - Same transaction produces different results on different validators [7](#0-6) 

## Impact Explanation
This vulnerability qualifies as **HIGH severity** under the Aptos bug bounty program because it causes:

1. **Consensus Violations:** The core invariant "All validators must produce identical state roots for identical blocks" is broken. Validators executing with different VM configurations will produce different execution results, leading to consensus disagreements.

2. **Non-Deterministic Execution:** Feature flags like `ENABLE_LAZY_LOADING` fundamentally change VM behavior:
   - With lazy loading: modules loaded on-demand
   - Without lazy loading: all dependencies loaded upfront
   - Different module loading order can affect gas consumption and execution traces

3. **Chain Split Risk:** If validators cannot agree on block execution results due to configuration mismatches, the chain may fork or require manual intervention to resolve.

4. **Feature Flag Impact:** The vulnerability affects all feature flags that modify VM behavior, including: [8](#0-7) 

These flags control critical VM behaviors like lazy loading, function values, enum types, and resource access control. Executing with mismatched configurations violates the deterministic execution requirement.

## Likelihood Explanation
The likelihood is **HIGH** because:

1. **Frequent Feature Flag Updates:** Governance regularly updates feature flags to roll out new functionality. Each update triggers this vulnerability.

2. **Automatic Trigger:** The vulnerability is triggered automatically by the normal operation of `notify_commit()` after any block commit following a feature flag change.

3. **Timing-Dependent:** Different validators have different timing for when `notify_commit()` vs `restart()` is called, creating a race condition window where some validators use stale environments.

4. **No Special Privileges Required:** Any governance participant can propose feature flag changes through normal governance procedures.

5. **Observable in Production:** This happens in production whenever governance updates feature flags between epochs.

## Recommendation
The fix requires checking if the environment has changed before deciding to use `reset_state_view()`. The `AptosEnvironment` already implements equality comparison based on configuration hash: [9](#0-8) 

**Recommended Fix for `vm_validator.rs`:**

```rust
fn notify_commit(&mut self) {
    let db_state_view = self.db_state_view();
    
    // Create new environment from the new state view
    let new_environment = AptosEnvironment::new(&db_state_view);
    
    // Check if environment changed (e.g., feature flags updated)
    if self.state.environment != new_environment {
        // Environment changed - must reset everything
        self.state.reset_all(db_state_view.into());
        return;
    }
    
    // Environment unchanged - can optimize by only updating state view
    let base_view_id = self.state.state_view_id();
    let new_view_id = db_state_view.id();
    match (base_view_id, new_view_id) {
        (
            StateViewId::TransactionValidation { base_version: old_version },
            StateViewId::TransactionValidation { base_version: new_version },
        ) => {
            if old_version <= new_version {
                self.state.reset_state_view(db_state_view.into());
            } else {
                self.state.reset_all(db_state_view.into());
            }
        },
        _ => self.state.reset_all(db_state_view.into()),
    }
}
```

The same fix should be applied to `pipeline_builder.rs` for the consensus module cache.

## Proof of Concept
```rust
// This is a conceptual PoC showing the vulnerability
// Place in vm-validator/src/vm_validator.rs tests

#[test]
fn test_environment_inconsistency_on_feature_change() {
    use aptos_types::on_chain_config::{Features, FeatureFlag};
    use aptos_types::state_store::{state_key::StateKey, state_value::StateValue, MockStateView};
    use std::collections::HashMap;
    
    // Create initial state with ENABLE_LAZY_LOADING disabled
    let mut features = Features::default();
    features.disable(FeatureFlag::ENABLE_LAZY_LOADING);
    
    let initial_state = MockStateView::new(HashMap::from([(
        StateKey::resource(Features::address(), &Features::struct_tag()).unwrap(),
        StateValue::new_legacy(bcs::to_bytes(&features).unwrap().into()),
    )]));
    
    // Create validator with initial environment
    let db_reader = Arc::new(MockDbReader::new(initial_state));
    let mut validator = VMValidator::new(db_reader.clone());
    
    // Verify initial environment has lazy loading disabled
    assert!(!validator.state.environment.vm_config().enable_lazy_loading);
    
    // Simulate governance enabling ENABLE_LAZY_LOADING
    features.enable(FeatureFlag::ENABLE_LAZY_LOADING);
    let new_state = MockStateView::new(HashMap::from([(
        StateKey::resource(Features::address(), &Features::struct_tag()).unwrap(),
        StateValue::new_legacy(bcs::to_bytes(&features).unwrap().into()),
    )]));
    
    // Update db_reader to return new state
    db_reader.update(new_state);
    
    // Call notify_commit() - this triggers the vulnerability
    validator.notify_commit();
    
    // BUG: Environment still has old config, but state view has new features
    assert!(!validator.state.environment.vm_config().enable_lazy_loading); // Old config
    
    // But if we create a new environment from current state view, it would have new config
    let correct_env = AptosEnvironment::new(&validator.state.state_view);
    assert!(correct_env.vm_config().enable_lazy_loading); // New config
    
    // This inconsistency causes consensus violations!
}
```

## Notes
- The vulnerability exists because version-based linearity checks don't account for environment changes
- The `restart()` method correctly calls `reset_all()` but is only invoked on explicit reconfiguration events, not on every commit
- This creates a timing window where stale environments are used with new state data
- The fix is straightforward: check environment equality before optimization
- All uses of `reset_state_view()` should be audited for similar issues

### Citations

**File:** aptos-move/aptos-resource-viewer/src/module_view.rs (L121-125)
```rust
    /// Resets the state view snapshot to the new one. Does not invalidate the module cache, nor
    /// the VM.
    pub fn reset_state_view(&mut self, state_view: S) {
        self.state_view = state_view;
    }
```

**File:** aptos-move/aptos-vm-environment/src/environment.rs (L152-158)
```rust
impl PartialEq for AptosEnvironment {
    fn eq(&self, other: &Self) -> bool {
        self.0.hash == other.0.hash
    }
}

impl Eq for AptosEnvironment {}
```

**File:** aptos-move/aptos-vm-environment/src/environment.rs (L212-285)
```rust
    fn new(
        state_view: &impl StateView,
        inject_create_signer_for_gov_sim: bool,
        gas_hook: Option<Arc<dyn Fn(DynamicExpression) + Send + Sync>>,
    ) -> Self {
        // We compute and store a hash of configs in order to distinguish different environments.
        let mut sha3_256 = Sha3_256::new();
        let features =
            fetch_config_and_update_hash::<Features>(&mut sha3_256, state_view).unwrap_or_default();

        // If no chain ID is in storage, we assume we are in a testing environment.
        let chain_id = fetch_config_and_update_hash::<ChainId>(&mut sha3_256, state_view)
            .unwrap_or_else(ChainId::test);
        let timestamp_micros =
            fetch_config_and_update_hash::<ConfigurationResource>(&mut sha3_256, state_view)
                .map(|config| config.last_reconfiguration_time_micros())
                .unwrap_or(0);

        let mut timed_features_builder = TimedFeaturesBuilder::new(chain_id, timestamp_micros);
        if let Some(profile) = get_timed_feature_override() {
            // We need to ensure the override is taken into account for the hash.
            let profile_bytes = bcs::to_bytes(&profile)
                .expect("Timed features override should always be serializable");
            sha3_256.update(&profile_bytes);

            timed_features_builder = timed_features_builder.with_override_profile(profile)
        }
        let timed_features = timed_features_builder.build();

        // TODO(Gas):
        //   Right now, we have to use some dummy values for gas parameters if they are not found
        //   on-chain. This only happens in a edge case that is probably related to write set
        //   transactions or genesis, which logically speaking, shouldn't be handled by the VM at
        //   all. We should clean up the logic here once we get that refactored.
        let (gas_params, storage_gas_params, gas_feature_version) =
            get_gas_parameters(&mut sha3_256, &features, state_view);
        let (native_gas_params, misc_gas_params, ty_builder) = match &gas_params {
            Ok(gas_params) => {
                let ty_builder = aptos_prod_ty_builder(gas_feature_version, gas_params);
                (
                    gas_params.natives.clone(),
                    gas_params.vm.misc.clone(),
                    ty_builder,
                )
            },
            Err(_) => {
                let ty_builder = aptos_default_ty_builder();
                (
                    NativeGasParameters::zeros(),
                    MiscGasParameters::zeros(),
                    ty_builder,
                )
            },
        };

        let mut builder = SafeNativeBuilder::new(
            gas_feature_version,
            native_gas_params,
            misc_gas_params,
            timed_features.clone(),
            features.clone(),
            gas_hook,
        );
        let natives = aptos_natives_with_builder(&mut builder, inject_create_signer_for_gov_sim);
        let vm_config = aptos_prod_vm_config(
            chain_id,
            gas_feature_version,
            &features,
            &timed_features,
            ty_builder,
        );
        let verifier_bytes =
            bcs::to_bytes(&vm_config.verifier_config).expect("Verifier config is serializable");
        let runtime_environment = RuntimeEnvironment::new_with_config(natives, vm_config);
```

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L198-276)
```rust
pub fn aptos_prod_vm_config(
    chain_id: ChainId,
    gas_feature_version: u64,
    features: &Features,
    timed_features: &TimedFeatures,
    ty_builder: TypeBuilder,
) -> VMConfig {
    let paranoid_type_checks = get_paranoid_type_checks();
    let paranoid_ref_checks = get_paranoid_ref_checks();
    let enable_layout_caches = get_layout_caches();
    let enable_debugging = get_debugging_enabled();

    let deserializer_config = aptos_prod_deserializer_config(features);
    let verifier_config = aptos_prod_verifier_config(gas_feature_version, features);
    let enable_enum_option = features.is_enabled(FeatureFlag::ENABLE_ENUM_OPTION);
    let enable_framework_for_option = features.is_enabled(FeatureFlag::ENABLE_FRAMEWORK_FOR_OPTION);

    let layout_max_size = if gas_feature_version >= RELEASE_V1_30 {
        512
    } else {
        256
    };

    // Value runtime depth checks have been introduced together with function values and are only
    // enabled when the function values are enabled. Previously, checks were performed over types
    // to bound the value depth (checking the size of a packed struct type bounds the value), but
    // this no longer applies once function values are enabled. With function values, types can be
    // shallow while the value can be deeply nested, thanks to captured arguments not visible in a
    // type. Hence, depth checks have been adjusted to operate on values.
    let enable_depth_checks = features.is_enabled(FeatureFlag::ENABLE_FUNCTION_VALUES);
    let enable_capture_option = !timed_features.is_enabled(TimedFeatureFlag::DisabledCaptureOption)
        || features.is_enabled(FeatureFlag::ENABLE_CAPTURE_OPTION);

    // Some feature gating was missed, so for native dynamic dispatch the feature is always on for
    // testnet after 1.38 release.
    let enable_function_caches = features.is_call_tree_and_instruction_vm_cache_enabled();
    let enable_function_caches_for_native_dynamic_dispatch =
        enable_function_caches || (chain_id.is_testnet() && gas_feature_version >= RELEASE_V1_38);

    let config = VMConfig {
        verifier_config,
        deserializer_config,
        paranoid_type_checks,
        legacy_check_invariant_in_swap_loc: false,
        // Note: if updating, make sure the constant is in-sync.
        max_value_nest_depth: Some(DEFAULT_MAX_VM_VALUE_NESTED_DEPTH),
        layout_max_size,
        layout_max_depth: 128,
        // 5000 limits type tag total size < 5000 bytes and < 50 nodes.
        type_max_cost: 5000,
        type_base_cost: 100,
        type_byte_cost: 1,
        // By default, do not use delayed field optimization. Instead, clients should enable it
        // manually where applicable.
        delayed_field_optimization_enabled: false,
        ty_builder,
        enable_function_caches,
        enable_lazy_loading: features.is_lazy_loading_enabled(),
        enable_depth_checks,
        optimize_trusted_code: features.is_trusted_code_enabled(),
        paranoid_ref_checks,
        enable_capture_option,
        enable_enum_option,
        enable_layout_caches,
        propagate_dependency_limit_error: gas_feature_version >= RELEASE_V1_38,
        enable_framework_for_option,
        enable_function_caches_for_native_dynamic_dispatch,
        enable_debugging,
    };

    // Note: if max_value_nest_depth changed, make sure the constant is in-sync. Do not remove this
    // assertion as it ensures the constant value is set correctly.
    assert_eq!(
        config.max_value_nest_depth,
        Some(DEFAULT_MAX_VM_VALUE_NESTED_DEPTH)
    );

    config
}
```

**File:** vm-validator/src/vm_validator.rs (L76-99)
```rust
    fn notify_commit(&mut self) {
        let db_state_view = self.db_state_view();

        // On commit, we need to update the state view so that we can see the latest resources.
        let base_view_id = self.state.state_view_id();
        let new_view_id = db_state_view.id();
        match (base_view_id, new_view_id) {
            (
                StateViewId::TransactionValidation {
                    base_version: old_version,
                },
                StateViewId::TransactionValidation {
                    base_version: new_version,
                },
            ) => {
                // if the state view forms a linear history, just update the state view
                if old_version <= new_version {
                    self.state.reset_state_view(db_state_view.into());
                }
            },
            // if the version is incompatible, we flush the cache
            _ => self.state.reset_all(db_state_view.into()),
        }
    }
```

**File:** vm-validator/src/vm_validator.rs (L146-165)
```rust
    fn validate_transaction(&self, txn: SignedTransaction) -> Result<VMValidatorResult> {
        let vm_validator = self.get_next_vm();

        fail_point!("vm_validator::validate_transaction", |_| {
            Err(anyhow::anyhow!(
                "Injected error in vm_validator::validate_transaction"
            ))
        });

        let result = std::panic::catch_unwind(move || {
            let vm_validator_locked = vm_validator.lock().unwrap();

            use aptos_vm::VMValidator;
            let vm = AptosVM::new(&vm_validator_locked.state.environment);
            vm.validate_transaction(
                txn,
                &vm_validator_locked.state.state_view,
                &vm_validator_locked.state,
            )
        });
```

**File:** consensus/src/pipeline/pipeline_builder.rs (L713-726)
```rust
                // flush the cache if the execution state view is not linear
                // in case of speculative executing a forked block
                let previous_state_view = cache_mut.state_view_id();
                let expected_state_view = StateViewId::BlockExecution {
                    block_id: grand_parent_id,
                };
                if previous_state_view == expected_state_view {
                    cache_mut.reset_state_view(parent_state_view);
                } else {
                    counters::RAND_BLOCK
                        .with_label_values(&["reset_cache"])
                        .inc();
                    cache_mut.reset_all(parent_state_view);
                }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L313-325)
```rust
impl AptosVM {
    /// Creates a new VM instance based on the runtime environment. The VM can then be used by
    /// block executor to create multiple tasks sharing the same execution configurations extracted
    /// from the environment.
    pub fn new(env: &AptosEnvironment) -> Self {
        Self {
            is_simulation: false,
            move_vm: MoveVmExt::new(env),
            // There is no tracing by default because it can only be done if there is access to
            // Block-STM.
            async_runtime_checks_enabled: false,
        }
    }
```

**File:** types/src/on_chain_config/aptos_features.rs (L145-150)
```rust
    /// With lazy loading, modules are loaded lazily (as opposed to loading the transitive closure
    /// of dependencies). For more details, see:
    ///   AIP-127 (https://github.com/aptos-foundation/AIPs/blob/main/aips/aip-127.md)
    ENABLE_LAZY_LOADING = 95,
    CALCULATE_TRANSACTION_FEE_FOR_DISTRIBUTION = 96,
    DISTRIBUTE_TRANSACTION_FEE = 97,
```
