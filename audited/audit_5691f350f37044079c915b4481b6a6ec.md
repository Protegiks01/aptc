# Audit Report

## Title
Lack of Versioning in WeightedVUF PublicParameters Enables Consensus Liveness Failure During Mixed-Version Upgrades

## Summary
The `PublicParameters` structures used in WeightedVUF implementations (BLS and Pinkas) lack version identifiers, creating a risk of undetected parameter incompatibility when validators run different code versions during protocol upgrades. This absence of versioning means validators cannot distinguish between cryptographically incompatible parameter sets, leading to consensus liveness failures that require manual intervention.

## Finding Description

The WeightedVUF trait defines `PublicParameters` as an associated type without any version field requirement: [1](#0-0) 

Both concrete implementations lack versioning:

**Pinkas Implementation:** [2](#0-1) 

**BLS Implementation:** [3](#0-2) 

These parameters are derived from hardcoded domain-separation tags (DST) and seeds: [4](#0-3) [5](#0-4) 

During epoch initialization, validators derive VUF parameters locally: [6](#0-5) [7](#0-6) 

**Attack Scenario:**

1. A protocol upgrade modifies cryptographic constants (e.g., `PINKAS_WVUF_DST` changes from `"APTOS_PINKAS_WVUF_DST"` to `"APTOS_PINKAS_WVUF_DST_V2"`)
2. 40% of validators upgrade immediately, 60% remain on old code
3. Each validator derives different `PublicParameters` based on their code version
4. When validators create randomness shares, they use their local parameters
5. Share verification fails when validators with different parameters cross-verify: [8](#0-7) 

6. The pairing check uses `pp.g_neg` which differs between parameter sets, causing verification failure
7. No quorum can be reached as validators reject each other's shares with generic error "PinkasWVUF ProofShare failed to verify"
8. Consensus cannot progress; randomness generation fails

The error message provides no indication that parameter mismatch is the root cause, making diagnosis difficult.

## Impact Explanation

This qualifies as **Medium Severity** under the Aptos bug bounty program's definition of "State inconsistencies requiring intervention":

- **Consensus Liveness Failure**: The network cannot make progress when validators have incompatible parameters
- **Randomness Generation Failure**: The distributed randomness beacon fails completely
- **Requires Manual Intervention**: Recovery requires coordinated rollback or forced completion of upgrades
- **Diagnostic Difficulty**: Generic cryptographic errors obscure the actual cause (parameter version mismatch)
- **Chain Split Risk**: If validator sets with each version have sufficient stake, a temporary fork could occur

While this does not cause direct fund loss or permanent consensus safety violations, it creates a temporary but severe availability impact requiring emergency operator intervention.

## Likelihood Explanation

**Likelihood: Medium-Low**

This issue manifests when:
1. A protocol upgrade intentionally modifies cryptographic constants (to address a vulnerability or improve the scheme)
2. Validators upgrade asynchronously over hours or days (common in decentralized networks)
3. The mixed-version period overlaps with a DKG session initialization

While Aptos has upgrade coordination mechanisms, real-world validator upgrades are often gradual due to:
- Validators operated by different organizations with varying response times
- Testing and validation periods before production deployment
- Geographic distribution and time zones
- Automated upgrade systems with staggered rollouts

The absence of parameter versioning means there's no safety net if upgrade coordination fails, converting an operational challenge into a consensus-level incident.

## Recommendation

Add explicit versioning to `PublicParameters` and validate compatibility:

```rust
// In weighted_vuf/traits.rs
pub trait WeightedVUF {
    type PublicParameters: VersionedParameters;
    // ... rest of trait
}

pub trait VersionedParameters {
    fn version(&self) -> u32;
    fn is_compatible_with(&self, other: &Self) -> bool;
}

// In pinkas/mod.rs
#[derive(Clone, Debug, PartialEq, Eq)]
pub struct PublicParameters {
    version: u32,  // Add version field
    g: G1Projective,
    g_neg: G1Projective,
    g_hat: G2Projective,
}

impl PublicParameters {
    const CURRENT_VERSION: u32 = 1;
    
    pub fn new(g: G1Projective, g_hat: G2Projective) -> Self {
        Self {
            version: Self::CURRENT_VERSION,
            g: g.clone(),
            g_neg: g.neg(),
            g_hat,
        }
    }
}

// In verify_share
fn verify_share(
    pp: &Self::PublicParameters,
    apk: &Self::AugmentedPubKeyShare,
    msg: &[u8],
    proof: &Self::ProofShare,
) -> anyhow::Result<()> {
    // Add version check
    ensure!(
        pp.version == PublicParameters::CURRENT_VERSION,
        "PublicParameters version {} incompatible with current version {}",
        pp.version,
        PublicParameters::CURRENT_VERSION
    );
    // ... rest of verification
}
```

Additionally, include the parameter version in epoch state to detect mismatches early:

```rust
// In DKGPvssConfig
pub struct DKGPvssConfig {
    pub epoch: u64,
    pub pp_version: u32,  // Add this
    pub wconfig: SSConfig,
    pub pp: DkgPP,
    // ... rest of fields
}
```

## Proof of Concept

```rust
// Test demonstrating parameter incompatibility
#[test]
fn test_parameter_version_mismatch() {
    use aptos_dkg::pvss::das::PublicParameters as DasPP;
    use aptos_dkg::weighted_vuf::pinkas::{PinkasWUF, PublicParameters};
    use aptos_dkg::weighted_vuf::traits::WeightedVUF;
    
    // Simulate two different parameter sets
    // (In reality, these would come from different DST constants)
    let das_pp_v1 = DasPP::default_with_bls_base();
    let pp_v1 = PublicParameters::from(&das_pp_v1);
    
    // Manually create "v2" parameters with different base
    let seed_v2 = b"APTOS_DISTRIBUTED_RANDOMNESS_SEED_V2";
    let das_pp_v2 = DasPP::new_from_seed(seed_v2);
    let pp_v2 = PublicParameters::from(&das_pp_v2);
    
    // Create key pair with v1 parameters
    let mut rng = rand::thread_rng();
    let sk = vec![random_scalar(&mut rng)];
    let pk = vec![/* derive from sk */];
    let (ask, apk) = PinkasWUF::augment_key_pair(&pp_v1, sk, pk, &mut rng);
    
    // Create share with v1 parameters
    let msg = b"test_message";
    let share = PinkasWUF::create_share(&ask, msg);
    
    // Verification with v1 parameters succeeds
    assert!(PinkasWUF::verify_share(&pp_v1, &apk, msg, &share).is_ok());
    
    // Verification with v2 parameters fails silently
    // (This is the bug - no version mismatch error)
    let result = PinkasWUF::verify_share(&pp_v2, &apk, msg, &share);
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("ProofShare failed to verify"));
    // Note: Error message doesn't indicate version mismatch!
}
```

**Notes**

While this vulnerability is real, its exploitation requires a specific scenario: validators must be running different code versions with modified cryptographic constants during the same epoch. The primary mitigation is coordinated upgrades, but the lack of versioning removes a critical defense-in-depth layer. Adding parameter versioning would enable early detection of mismatches with clear error messages, significantly improving operational safety during upgrades.

### Citations

**File:** crates/aptos-dkg/src/weighted_vuf/traits.rs (L16-16)
```rust
    type PublicParameters;
```

**File:** crates/aptos-dkg/src/weighted_vuf/pinkas/mod.rs (L27-27)
```rust
pub const PINKAS_WVUF_DST: &[u8; 21] = b"APTOS_PINKAS_WVUF_DST";
```

**File:** crates/aptos-dkg/src/weighted_vuf/pinkas/mod.rs (L44-49)
```rust
#[derive(Clone, Debug, PartialEq, Eq)]
pub struct PublicParameters {
    g: G1Projective,
    g_neg: G1Projective,
    g_hat: G2Projective,
}
```

**File:** crates/aptos-dkg/src/weighted_vuf/pinkas/mod.rs (L51-59)
```rust
impl From<&pvss::das::PublicParameters> for PublicParameters {
    fn from(pp: &pvss::das::PublicParameters) -> Self {
        let g = pp.get_encryption_public_params().message_base().clone();
        PublicParameters {
            g,
            g_neg: g.neg(),
            g_hat: pp.get_commitment_base().clone(),
        }
    }
```

**File:** crates/aptos-dkg/src/weighted_vuf/pinkas/mod.rs (L153-170)
```rust
    fn verify_share(
        pp: &Self::PublicParameters,
        apk: &Self::AugmentedPubKeyShare,
        msg: &[u8],
        proof: &Self::ProofShare,
    ) -> anyhow::Result<()> {
        let delta = Self::get_public_delta(apk);

        let h = Self::hash_to_curve(msg);

        if multi_pairing([&delta.pi, &pp.g_neg].into_iter(), [proof, &h].into_iter())
            != Gt::identity()
        {
            bail!("PinkasWVUF ProofShare failed to verify.");
        }

        Ok(())
    }
```

**File:** crates/aptos-dkg/src/weighted_vuf/bls/mod.rs (L24-27)
```rust
#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]
pub struct PublicParameters {
    g: G2Projective,
}
```

**File:** crates/aptos-dkg/src/pvss/das/public_parameters.rs (L21-25)
```rust
/// "Nothing up my sleeve" domain-separator tag (DST) for the hash-to-curve operation used
/// to pick our PVSS public parameters (group elements) as `hash_to_curve(seed, dst, group_element_name)`.
pub const DST_PVSS_PUBLIC_PARAMS: &[u8; 32] = b"APTOS_DISTRIBUTED_RANDOMNESS_DST";
/// "Nothing up my sleeve" seed to deterministically-derive the public parameters.
pub const SEED_PVSS_PUBLIC_PARAMS: &[u8; 33] = b"APTOS_DISTRIBUTED_RANDOMNESS_SEED";
```

**File:** consensus/src/epoch_manager.rs (L1061-1061)
```rust
        let vuf_pp = WvufPP::from(&dkg_pub_params.pvss_config.pp);
```
