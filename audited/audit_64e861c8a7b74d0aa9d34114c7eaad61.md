# Audit Report

## Title
State Consistency Bypass via Replay Version None Allows Consensus-Breaking State Divergence

## Summary
The transaction restore functionality allows bypassing transaction replay by omitting the `replay_from_version` parameter, which returns `Version::MAX`. This causes transactions to be saved without replaying their state changes, while falsely updating the `StateKvCommitProgress` marker. Nodes can restore to inconsistent states where transaction data exists but corresponding state updates are missing, breaking deterministic execution and causing consensus failures. [1](#0-0) 

## Finding Description
The vulnerability exists in the transaction restore flow when `replay_from_version` is `None`. The `replay_from_version()` helper returns `Version::MAX` in this case, which causes all transactions to be saved without replay in the `save_before_replay_version` method. [2](#0-1) 

When `replay_from_version` is `None`, `first_to_replay` becomes `Version::MAX`. Since all transaction versions are less than `Version::MAX`, they all get saved without replay. The critical issue occurs in the save process: [3](#0-2) 

When `kv_replay` is `false`, state updates are skipped (lines 269-277). However, the commit progress is still updated: [4](#0-3) 

And critically, `StateKvCommitProgress` is falsely advanced: [5](#0-4) 

The `StateKvDb::commit` function updates the progress marker regardless of whether actual state data was written: [6](#0-5) 

**Attack Scenario:**
1. Node operator restores a state snapshot at version V=1000 using `db-tool restore oneoff state-snapshot`
2. Operator runs `db-tool restore oneoff transaction --transaction-manifest <manifest>` WITHOUT specifying `--replay-transactions-from-version`
3. Transactions 1001-2000 are saved to database without state replay
4. Database now has:
   - Actual state at version 1000
   - `LedgerCommitProgress` = 2000
   - `StateKvCommitProgress` = 2000 (falsely!)
   - `OverallCommitProgress` = 2000
5. Node restarts, `sync_commit_progress` validation passes all assertions because progress markers are consistent [7](#0-6) 

6. Node attempts to execute new block at version 2001
7. Execution reads state at version 1000 (actual state), not 2000 (expected state)
8. Computes incorrect state root hash
9. **Consensus breaks** - different nodes compute different state roots for identical blocks

This breaks the **Deterministic Execution** invariant: validators no longer produce identical state roots for identical blocks.

## Impact Explanation
**Severity: CRITICAL** - Consensus Safety Violation

This vulnerability enables a consensus-breaking attack that causes network partition requiring a hardfork to recover. Per the Aptos bug bounty categories, this qualifies as Critical Severity due to:

1. **Consensus/Safety violations**: Different nodes compute different state roots for the same block
2. **Non-recoverable network partition**: Validators disagree on state, requiring manual intervention or hardfork
3. **Deterministic Execution failure**: Violates the fundamental invariant that all validators must produce identical state roots

Unlike temporary liveness issues, this creates permanent divergence in the canonical chain state. Affected nodes cannot reconcile without full re-synchronization or state reset.

## Likelihood Explanation
**Likelihood: Medium-to-High**

The vulnerability can be triggered through normal operational procedures:

1. **Common scenario**: Node operators regularly restore from backups during disaster recovery, node migration, or initial sync
2. **Easy to trigger**: Simply omitting the `--replay-transactions-from-version` flag triggers the bug
3. **No validation**: The CLI help text describes replay as optional, not required
4. **Silent failure**: No runtime checks detect the inconsistency; `sync_commit_progress` passes validation [8](#0-7) 

The parameter is marked `Option<Version>`, suggesting it's optional. Operators might reasonably believe transactions will be properly restored without specifying replay, unaware they're creating state inconsistency.

However, this requires manual use of the oneoff restore commands rather than the coordinated `BootstrapDB` command, which properly sets replay versions. Most production deployments use `BootstrapDB`, reducing real-world exposure.

## Recommendation
**Fix 1: Make replay_from_version required when restoring to non-empty database**

Modify `TransactionRestoreOpt` to validate that replay is specified when the database already contains state:

```rust
impl TransactionRestoreOpt {
    pub fn replay_from_version(&self) -> Version {
        self.replay_from_version.unwrap_or(Version::MAX)
    }
    
    pub fn validate(&self, db_has_state: bool) -> Result<()> {
        if db_has_state && self.replay_from_version.is_none() {
            bail!(
                "Database contains existing state. You must specify \
                --replay-transactions-from-version to replay state changes. \
                Otherwise, transaction data will be saved without corresponding \
                state updates, causing consensus failures."
            );
        }
        Ok(())
    }
}
```

**Fix 2: Prevent StateKvCommitProgress update without actual state updates**

Modify `save_transactions` in `restore_utils.rs` to NOT commit progress when `kv_replay` is false:

```rust
// Only commit state KV progress if we actually replayed state
if kv_replay {
    state_store
        .state_db
        .state_kv_db
        .commit(last_version, None, sharded_kv_schema_batch)?;
} else {
    // Don't advance StateKvCommitProgress without actual state updates
    // Just commit empty batches without progress update
    for (shard_id, batch) in sharded_kv_schema_batch.into_iter().enumerate() {
        state_store.state_db.state_kv_db.db_shard(shard_id).write(batch)?;
    }
}
```

**Fix 3: Add runtime consistency check**

Add validation in `sync_commit_progress` that checks actual state version matches progress markers:

```rust
// Verify actual state data version matches StateKvCommitProgress
let actual_state_version = state_store.get_current_version()?;
ensure!(
    actual_state_version == state_kv_commit_progress,
    "State data version {} does not match StateKvCommitProgress {}. \
    Database may have been restored incorrectly without transaction replay.",
    actual_state_version,
    state_kv_commit_progress
);
```

## Proof of Concept

**Step 1: Create test database with state snapshot at version 100**
```bash
# Create backup storage with state snapshot at v100 and transactions 0-200
db-tool backup oneoff state-snapshot \
  --state-snapshot-epoch 10 \
  --target-db-dir /path/to/source/db \
  --backup-storage-config /path/to/backup/config
  
db-tool backup oneoff transaction \
  --start-version 0 \
  --num-transactions 200 \
  --target-db-dir /path/to/source/db \
  --backup-storage-config /path/to/backup/config
```

**Step 2: Restore with vulnerability trigger**
```bash
# Initialize fresh target database
rm -rf /path/to/target/db

# Restore state snapshot at v100
db-tool restore oneoff state-snapshot \
  --state-snapshot-manifest <manifest_v100> \
  --target-db-dir /path/to/target/db \
  --backup-storage-config /path/to/backup/config

# Trigger vulnerability: restore transactions WITHOUT replay
db-tool restore oneoff transaction \
  --transaction-manifest <manifest_txns> \
  --target-db-dir /path/to/target/db \
  --backup-storage-config /path/to/backup/config
  # NOTE: --replay-transactions-from-version NOT specified!
```

**Step 3: Verify inconsistency**
```bash
# Check database versions
db-tool examine print-db-versions \
  --target-db-dir /path/to/target/db

# Expected output shows inconsistency:
# LedgerCommitProgress: 200
# StateKvCommitProgress: 200  <-- FALSELY advanced
# Actual state data version: 100  <-- State is stale!

# Try executing new transaction at v201
# Will read state at v100, not v200, causing wrong state root
```

**Expected behavior**: Command should fail with error requiring `--replay-transactions-from-version`, or progress markers should reflect actual state version (100, not 200).

**Actual behavior**: Restore succeeds, progress markers show v200, but actual state data remains at v100, creating silent inconsistency that breaks consensus.

## Notes
This vulnerability specifically affects manual restoration workflows using the oneoff commands in `db-tool`. The coordinated `BootstrapDB` command properly manages replay versions through `RestoreCoordinator`, which always sets appropriate replay parameters. [9](#0-8) [10](#0-9) 

However, the oneoff commands are documented tools that operators may use for disaster recovery or custom restore scenarios. The lack of validation makes this a realistic operational hazard.

The verify mode is not affected as it uses `RestoreRunMode::Verify` which doesn't write to the database: [11](#0-10)

### Citations

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L68-77)
```rust
    #[clap(
        long = "replay-transactions-from-version",
        help = "Transactions with this version and above will be replayed so state and events are \
        gonna pop up. Requires state at the version right before this to exist, either by \
        recovering a state snapshot, or previous transaction replay."
    )]
    pub replay_from_version: Option<Version>,
    #[clap(long)]
    pub kv_only_replay: Option<bool>,
}
```

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L79-83)
```rust
impl TransactionRestoreOpt {
    pub fn replay_from_version(&self) -> Version {
        self.replay_from_version.unwrap_or(Version::MAX)
    }
}
```

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L453-457)
```rust
        let first_to_replay = max(
            self.replay_from_version
                .map_or(Version::MAX, |(version, _)| version),
            next_expected_version,
        );
```

**File:** storage/aptosdb/src/backup/restore_utils.rs (L166-170)
```rust
        let last_version = first_version + txns.len() as u64 - 1;
        state_store
            .state_db
            .state_kv_db
            .commit(last_version, None, sharded_kv_schema_batch)?;
```

**File:** storage/aptosdb/src/backup/restore_utils.rs (L269-277)
```rust
    if kv_replay && first_version > 0 && state_store.get_usage(Some(first_version - 1)).is_ok() {
        let (ledger_state, _hot_state_updates) = state_store.calculate_state_and_put_updates(
            &StateUpdateRefs::index_write_sets(first_version, write_sets, write_sets.len(), vec![]),
            &mut ledger_db_batch.ledger_metadata_db_batches, // used for storing the storage usage
            state_kv_batches,
        )?;
        // n.b. ideally this is set after the batches are committed
        state_store.set_state_ignoring_summary(ledger_state);
    }
```

**File:** storage/aptosdb/src/backup/restore_utils.rs (L279-291)
```rust
    let last_version = first_version + txns.len() as u64 - 1;
    ledger_db_batch
        .ledger_metadata_db_batches
        .put::<DbMetadataSchema>(
            &DbMetadataKey::LedgerCommitProgress,
            &DbMetadataValue::Version(last_version),
        )?;
    ledger_db_batch
        .ledger_metadata_db_batches
        .put::<DbMetadataSchema>(
            &DbMetadataKey::OverallCommitProgress,
            &DbMetadataValue::Version(last_version),
        )?;
```

**File:** storage/aptosdb/src/state_kv_db.rs (L210-215)
```rust
    pub(crate) fn write_progress(&self, version: Version) -> Result<()> {
        self.state_kv_metadata_db.put::<DbMetadataSchema>(
            &DbMetadataKey::StateKvCommitProgress,
            &DbMetadataValue::Version(version),
        )
    }
```

**File:** storage/aptosdb/src/state_store/mod.rs (L425-436)
```rust
            let ledger_commit_progress = ledger_metadata_db
                .get_ledger_commit_progress()
                .expect("Failed to read ledger commit progress.");
            assert_ge!(ledger_commit_progress, overall_commit_progress);

            let state_kv_commit_progress = state_kv_db
                .metadata_db()
                .get::<DbMetadataSchema>(&DbMetadataKey::StateKvCommitProgress)
                .expect("Failed to read state K/V commit progress.")
                .expect("State K/V commit progress cannot be None.")
                .expect_version();
            assert_ge!(state_kv_commit_progress, overall_commit_progress);
```

**File:** storage/backup/backup-cli/src/coordinators/restore.rs (L289-300)
```rust
            TransactionRestoreBatchController::new(
                transaction_restore_opt,
                Arc::clone(&self.storage),
                txn_manifests,
                Some(db_next_version),
                Some((kv_replay_version, true /* only replay KV */)),
                epoch_history.clone(),
                VerifyExecutionMode::NoVerify,
                None,
            )
            .run()
            .await?;
```

**File:** storage/backup/backup-cli/src/coordinators/restore.rs (L360-371)
```rust
            TransactionRestoreBatchController::new(
                self.global_opt,
                self.storage,
                txn_manifests,
                first_version,
                replay_version,
                epoch_history,
                VerifyExecutionMode::NoVerify,
                None,
            )
            .run()
            .await?;
```

**File:** storage/backup/backup-cli/src/coordinators/verify.rs (L145-156)
```rust
        TransactionRestoreBatchController::new(
            global_opt,
            self.storage,
            txn_manifests,
            None,
            None, /* replay_from_version */
            epoch_history,
            VerifyExecutionMode::NoVerify,
            self.output_transaction_analysis,
        )
        .run()
        .await?;
```
