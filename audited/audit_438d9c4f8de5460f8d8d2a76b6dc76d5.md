# Audit Report

## Title
Insufficient Minimum Reconstruction Threshold Validation Allows Byzantine Fault Tolerance Violation in DKG Randomness Configuration

## Summary
The DKG rounding validation logic fails to enforce a minimum reconstruction threshold for Byzantine fault tolerance. While the code validates that `reconstruction_threshold ≤ 2/3`, it does not enforce a lower bound near 2/3. This allows governance to set dangerously low thresholds (e.g., 40%) that enable a minority Byzantine coalition to compromise on-chain randomness, violating the core BFT security assumption of tolerating up to 1/3 Byzantine validators.

## Finding Description

The Aptos randomness system uses threshold cryptography via PVSS (Publicly Verifiable Secret Sharing) to generate unpredictable randomness for consensus. The security of this system depends on proper threshold configuration that aligns with BFT assumptions.

**Vulnerability Location:** [1](#0-0) 

The validation enforces:
- `secrecy_threshold > 1/3` (correct - prevents Byzantine minority from learning secrets)
- `secrecy_threshold < reconstruction_threshold` (correct - ensures gap between secrecy and reconstruction)  
- `reconstruction_threshold ≤ 2/3` (INCOMPLETE - only upper bound, missing lower bound!)

**Missing Validation:** There is no check ensuring `reconstruction_threshold ≥ 2/3 - ε` to guarantee that only supermajorities can reconstruct randomness.

**Attack Path:**

1. **Governance Configuration:** An attacker with governance control (or accidental misconfiguration) creates a randomness config: [2](#0-1) 
   
   Example: `new_v1(secrecy: 34%, reconstruction: 40%)`

2. **No Move-Level Validation:** The Move code accepts any threshold values without validation: [3](#0-2) 

3. **Rust Validation Passes:** When DKG session starts, the Rust validation accepts 40% reconstruction threshold because `0.40 * 3 = 1.2 ≤ 2.0`: [4](#0-3) 

4. **Unsafe Config Applied:** The weak threshold config flows through to `WeightedConfigBlstrs`: [5](#0-4) 

5. **Byzantine Coalition Attacks:** A Byzantine coalition controlling just >40% of stake can reconstruct randomness secrets, compromising:
   - Leader election in consensus (affects who proposes blocks)
   - Any on-chain randomness APIs used by smart contracts
   - Transaction ordering and fairness guarantees

**Broken Invariant:** The randomness config violates "Consensus Safety: AptosBFT must prevent double-spending and chain splits under < 1/3 Byzantine" because randomness can be compromised by a minority coalition.

## Impact Explanation

**Severity: Critical**

This vulnerability enables Byzantine actors with >40% stake (or any threshold below 2/3 if configured) to:

1. **Compromise Randomness Generation:** Reconstruct the shared secret used for randomness, predicting future random values
2. **Manipulate Leader Election:** Since consensus uses randomness for leader selection, attackers can bias or predict leadership
3. **Break Consensus Fairness:** Transaction ordering and inclusion can be manipulated
4. **Violate BFT Safety Assumptions:** The system claims to tolerate ≤1/3 Byzantine validators but actually becomes vulnerable at much lower thresholds

According to Aptos bug bounty categories, this qualifies as **Critical Severity** because it represents a "Consensus/Safety violation" - the core BFT security guarantee is violated when reconstruction thresholds are set below the 2/3 supermajority requirement.

## Likelihood Explanation

**Likelihood: Medium-High**

While this requires governance action to exploit, the likelihood is elevated because:

1. **Accidental Misconfiguration:** Governance could accidentally set unsafe thresholds without realizing the security implications
2. **Governance Compromise:** An attacker who gains governance voting power (through stake accumulation or exploiting governance bugs) can propose malicious configs
3. **No Defense in Depth:** The Rust validation layer should reject unsafe configs regardless of who proposes them, but it currently allows thresholds as low as ~34%
4. **Silent Failure:** There are no warnings or safeguards preventing dangerous threshold configurations

The default values are secure (50% secrecy, 67% reconstruction), but the system allows arbitrary deviations through governance proposals: [6](#0-5) 

## Recommendation

**Immediate Fix:** Add a minimum reconstruction threshold validation in `DKGRoundingProfile::new()`:

```rust
// After line 199 in types/src/dkg/real_dkg/rounding/mod.rs
ensure!(
    reconstruct_threshold_in_stake_ratio * U64F64::from_num(3) >= U64F64::from_num(2) - U64F64::DELTA,
    "reconstruction_threshold must be >= 2/3 for Byzantine fault tolerance"
);
```

This ensures the reconstruction threshold is at least ~66.67%, preventing minority coalitions from compromising randomness.

**Defense in Depth:** Add validation at multiple layers:

1. **Move Contract Level:** Validate thresholds in `randomness_config::new_v1()` and `new_v2()` before accepting configs
2. **Rust Type Level:** Make the validation in `ThresholdConfigBlstrs::new()` BFT-aware: [7](#0-6) 
   
   Add: `ensure!(t * 3 >= n * 2, "threshold must be >= 2n/3 for BFT security");`

3. **Documentation:** Clearly document the security requirements for threshold parameters

## Proof of Concept

**Scenario:** Governance sets unsafe randomness config that passes validation but breaks BFT security.

**Step 1 - Malicious Governance Proposal:**
```move
// In Move governance proposal
script {
    use aptos_framework::randomness_config;
    use aptos_framework::aptos_governance;
    use aptos_std::fixed_point64;
    
    fun configure_unsafe_randomness(governance: &signer) {
        // Set reconstruction threshold to only 40% (should be ~67%)
        let unsafe_config = randomness_config::new_v1(
            fixed_point64::create_from_rational(34, 100),  // secrecy: 34%
            fixed_point64::create_from_rational(40, 100),  // reconstruct: 40% <- UNSAFE!
        );
        randomness_config::set_for_next_epoch(governance, unsafe_config);
        aptos_governance::reconfigure(governance);
    }
}
```

**Step 2 - Validation Passes:**
The Rust validation at line 199 checks: `0.40 * 3 = 1.2 ≤ 2.0` ✓ (PASSES)

**Step 3 - Byzantine Coalition Exploits:**
```rust
// Pseudo-code showing exploitation
// Byzantine validators control 41% of stake
let byzantine_stake_ratio = 0.41;
let reconstruction_threshold = 0.40;

if byzantine_stake_ratio > reconstruction_threshold {
    // Byzantine coalition can reconstruct randomness!
    let secret = reconstruct_from_shares(byzantine_shares);
    let future_randomness = predict_randomness(secret, epoch);
    manipulate_leader_election(future_randomness);
}
```

**Expected Result:** The unsafe configuration is accepted by all validation layers, allowing a 41% Byzantine coalition to compromise randomness and consensus safety.

**Current Behavior:** No validation prevents this attack.

**Expected Behavior:** Validation should reject reconstruction_threshold < 2/3 with an error like:
```
"reconstruction_threshold (40%) violates BFT security: must be >= 66.67% to tolerate ≤33% Byzantine validators"
```

---

**Notes:**

The vulnerability exists because the validation logic only enforces an upper bound on reconstruction threshold (to ensure liveness when 1/3 of validators are offline) but fails to enforce the critical lower bound needed for security (to prevent minority Byzantine coalitions from reconstructing secrets). The defaults are secure, but the lack of validation creates a dangerous configuration surface that violates defense-in-depth principles.

### Citations

**File:** types/src/dkg/real_dkg/rounding/mod.rs (L98-106)
```rust
        let wconfig = WeightedConfigBlstrs::new(
            profile.reconstruct_threshold_in_weights as usize,
            profile
                .validator_weights
                .iter()
                .map(|w| *w as usize)
                .collect(),
        )
        .unwrap();
```

**File:** types/src/dkg/real_dkg/rounding/mod.rs (L186-199)
```rust
impl DKGRoundingProfile {
    pub fn new(
        validator_stakes: &Vec<u64>,
        total_weight_min: usize,
        total_weight_max: usize,
        secrecy_threshold_in_stake_ratio: U64F64,
        reconstruct_threshold_in_stake_ratio: U64F64,
        fast_secrecy_threshold_in_stake_ratio: Option<U64F64>,
    ) -> anyhow::Result<Self> {
        ensure!(total_weight_min >= validator_stakes.len());
        ensure!(total_weight_max >= total_weight_min);
        ensure!(secrecy_threshold_in_stake_ratio * U64F64::from_num(3) > U64F64::from_num(1));
        ensure!(secrecy_threshold_in_stake_ratio < reconstruct_threshold_in_stake_ratio);
        ensure!(reconstruct_threshold_in_stake_ratio * U64F64::from_num(3) <= U64F64::from_num(2));
```

**File:** aptos-move/framework/aptos-framework/sources/configs/randomness_config.move (L93-99)
```text
    public fun new_v1(secrecy_threshold: FixedPoint64, reconstruction_threshold: FixedPoint64): RandomnessConfig {
        RandomnessConfig {
            variant: copyable_any::pack( ConfigV1 {
                secrecy_threshold,
                reconstruction_threshold
            } )
        }
```

**File:** types/src/on_chain_config/randomness_config.rs (L101-115)
```rust
    pub fn new_v1(
        secrecy_threshold_in_percentage: u64,
        reconstruct_threshold_in_percentage: u64,
    ) -> Self {
        let secrecy_threshold = FixedPoint64MoveStruct::from_u64f64(
            U64F64::from_num(secrecy_threshold_in_percentage) / U64F64::from_num(100),
        );
        let reconstruction_threshold = FixedPoint64MoveStruct::from_u64f64(
            U64F64::from_num(reconstruct_threshold_in_percentage) / U64F64::from_num(100),
        );
        Self::V1(ConfigV1 {
            secrecy_threshold,
            reconstruction_threshold,
        })
    }
```

**File:** aptos-move/aptos-release-builder/src/components/randomness_config.rs (L77-97)
```rust
                ReleaseFriendlyRandomnessConfig::V1 {
                    secrecy_threshold_in_percentage,
                    reconstruct_threshold_in_percentage,
                } => {
                    emitln!(writer, "let v1 = randomness_config::new_v1(");
                    emitln!(
                        writer,
                        "    fixed_point64::create_from_rational({}, 100),",
                        secrecy_threshold_in_percentage
                    );
                    emitln!(
                        writer,
                        "    fixed_point64::create_from_rational({}, 100),",
                        reconstruct_threshold_in_percentage
                    );
                    emitln!(writer, ");");
                    emitln!(
                        writer,
                        "randomness_config::set_for_next_epoch({}, v1);",
                        signer_arg
                    );
```

**File:** crates/aptos-crypto/src/blstrs/threshold_config.rs (L109-132)
```rust
    fn new(t: usize, n: usize) -> anyhow::Result<Self> {
        if t == 0 {
            return Err(anyhow!("expected the reconstruction threshold to be > 0"));
        }

        if n == 0 {
            return Err(anyhow!("expected the number of shares to be > 0"));
        }

        if t > n {
            return Err(anyhow!(
                "expected the reconstruction threshold {t} to be < than the number of shares {n}"
            ));
        }

        let batch_dom = BatchEvaluationDomain::new(n);
        let dom = batch_dom.get_subdomain(n);
        Ok(ThresholdConfigBlstrs {
            t,
            n,
            dom,
            batch_dom,
        })
    }
```
