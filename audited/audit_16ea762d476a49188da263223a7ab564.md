# Audit Report

## Title
Trust Anchor Bypass: Waypoint Verification Skipped When Storage Already Synced

## Summary
The waypoint verification logic in the state sync bootstrapper contains a critical bypass that allows nodes to skip cryptographic verification of their trust anchor (waypoint) when starting from an existing database. If storage has already synced beyond the configured waypoint version, the waypoint is marked as "verified" without checking its hash against the stored ledger info, allowing malicious database snapshots to completely bypass the trust anchor mechanism. [1](#0-0) 

## Finding Description

The waypoint serves as a cryptographic trust anchor for bootstrapping Aptos nodes. When a node syncs from genesis or from a known checkpoint, it must verify that received ledger infos match the configured waypoint by checking both the version and hash. [2](#0-1) 

During normal operation, when fetching epoch ending ledger infos from the network, the bootstrapper correctly:
1. Verifies signatures using the epoch state's validator set
2. Verifies the waypoint hash matches the ledger info [3](#0-2) 

However, there is a bypass in the `verify_waypoint_is_satisfiable()` function. When checking if the waypoint can be satisfied, if the storage has already synced beyond the waypoint version, the code immediately marks the waypoint as verified without performing any cryptographic verification: [4](#0-3) 

The verification at lines 887-890 only checks that `latest_ledger_info.ledger_info().version() >= waypoint_version`, then calls `set_verified_waypoint()` without ever calling `waypoint.verify()` to check the hash. This bypasses the core security property of waypoints.

**Attack Scenario:**
1. Attacker creates a malicious blockchain fork and syncs a database to version 1000
2. Attacker distributes this database through a compromised snapshot service or via social engineering
3. Victim operator downloads the malicious database and configures their node with the legitimate waypoint (e.g., version 500 from official Aptos documentation)
4. When the node starts, `verify_waypoint_is_satisfiable()` sees storage version 1000 â‰¥ waypoint version 500
5. The waypoint is marked as "verified" without checking if the hash matches
6. The node loads the malicious epoch state and validator set from the fake database
7. The trust anchor has been completely bypassed

While subsequent network syncing may fail due to signature mismatches, the node has already accepted a fake chain state as its trusted starting point, violating the fundamental security guarantee of waypoints.

## Impact Explanation

This is a **High Severity** issue that could escalate to **Critical** depending on the deployment scenario:

**Immediate Impact:**
- **Trust Anchor Bypass**: The waypoint mechanism, designed to cryptographically anchor nodes to the correct chain state, is completely bypassed
- **State Inconsistency**: Nodes can start with a database that doesn't match their configured waypoint, leading to state inconsistencies

**Potential Critical Impact:**
If exploited at scale via compromised snapshot services:
- **Consensus Safety Violation**: Multiple nodes operating with different trusted validator sets could cause chain splits
- **Network Partition**: Nodes bootstrapped from malicious snapshots would be unable to sync with honest nodes
- **Loss of Liveness**: Validator nodes starting from fake databases would fail to participate in consensus

The issue meets **High Severity** criteria per Aptos bug bounty program:
- Significant protocol violation (trust anchor bypass)
- Validator node could be affected if using database snapshots

It could reach **Critical** if:
- Multiple validators are tricked into using malicious snapshots
- Results in non-recoverable network partition or consensus safety violation

## Likelihood Explanation

**Likelihood: Medium to High**

**Factors Increasing Likelihood:**
1. **Common Practice**: Database snapshots are widely used in blockchain ecosystems to speed up node bootstrapping
2. **Realistic Attack Vector**: Compromising a snapshot distribution service or performing man-in-the-middle attacks during snapshot downloads is feasible
3. **No Cryptographic Defense**: The vulnerability provides no cryptographic protection once a malicious database is in place
4. **Operator Trust**: Operators may trust snapshot sources without independent verification, especially from seemingly legitimate providers

**Factors Decreasing Likelihood:**
1. **Requires Database Access**: Attacker must convince operators to use a malicious database
2. **Network Sync Failure**: Subsequent network syncing would likely fail due to validator signature mismatches, potentially alerting the operator
3. **Multiple Attack Steps**: Requires both database distribution and operator acceptance

The vulnerability is exploitable without validator access or network-level attacks, making it accessible to attackers who can compromise snapshot services or conduct social engineering.

## Recommendation

The fix is to verify the waypoint hash against the stored ledger info when storage is already past the waypoint version:

```rust
fn verify_waypoint_is_satisfiable(
    &mut self,
    global_data_summary: &GlobalDataSummary,
) -> Result<(), Error> {
    // If our storage has already synced beyond our waypoint, verify it matches
    let latest_ledger_info = utils::fetch_latest_synced_ledger_info(self.storage.clone())?;
    let waypoint_version = self.driver_configuration.waypoint.version();
    if latest_ledger_info.ledger_info().version() >= waypoint_version {
        // NEW: Fetch the ledger info at the waypoint version and verify the hash
        let waypoint_ledger_info = self.storage
            .get_epoch_ending_ledger_info(waypoint_version)
            .map_err(|error| {
                Error::StorageError(format!(
                    "Failed to get epoch ending ledger info at waypoint version {}: {:?}",
                    waypoint_version, error
                ))
            })?;
        
        // Verify the waypoint hash matches the stored ledger info
        self.driver_configuration.waypoint
            .verify(waypoint_ledger_info.ledger_info())
            .map_err(|error| {
                Error::VerificationError(format!(
                    "Waypoint verification failed against stored ledger info: {:?}",
                    error
                ))
            })?;
        
        self.verified_epoch_states
            .set_verified_waypoint(waypoint_version);
        return Ok(());
    }
    
    // ... rest of function remains the same
}
``` [5](#0-4) 

This ensures that even when storage is already synced past the waypoint, the waypoint hash is cryptographically verified against the actual stored data, maintaining the trust anchor security property.

## Proof of Concept

```rust
// Proof of Concept: Demonstrate waypoint bypass with malicious database
// This would be added to state-sync/state-sync-driver/src/tests/bootstrapper.rs

#[tokio::test]
async fn test_waypoint_bypass_with_fake_database() {
    use aptos_types::{
        block_info::BlockInfo,
        ledger_info::LedgerInfo,
        waypoint::Waypoint,
    };
    
    // Setup: Create a fake ledger info at version 1000 with wrong hash
    let fake_ledger_info = LedgerInfo::new(
        BlockInfo::new(
            10, // epoch
            0,  // round
            HashValue::random(), // different from real chain
            HashValue::random(),
            1000, // version
            1000000,
            Some(EpochState::empty()),
        ),
        HashValue::zero(),
    );
    
    // Setup: Create legitimate waypoint for version 500 (from real chain)
    let legitimate_waypoint = Waypoint::new_any(&real_ledger_info_at_500);
    
    // Setup: Create storage mock with fake database at version 1000
    let mut mock_storage = MockDbReader::new();
    mock_storage.set_latest_ledger_info(fake_ledger_info.clone());
    
    // Setup: Create bootstrapper with legitimate waypoint but fake database
    let driver_config = DriverConfiguration::new(
        config,
        consensus_observer_config,
        RoleType::FullNode,
        legitimate_waypoint, // Using legitimate waypoint!
    );
    
    let mut bootstrapper = create_bootstrapper_with_storage(
        driver_config,
        Arc::new(mock_storage),
    );
    
    // Attack: Call verify_waypoint_is_satisfiable
    // Expected: Should fail because waypoint hash doesn't match database
    // Actual: Succeeds and marks waypoint as verified!
    let result = bootstrapper.verify_waypoint_is_satisfiable(&global_summary);
    
    // Vulnerability demonstrated: waypoint is marked as verified
    // even though the database doesn't match the waypoint hash
    assert!(result.is_ok()); // Bug: should fail but succeeds
    assert!(bootstrapper.verified_epoch_states.verified_waypoint()); // Bug: marked as verified
    
    // The node has bypassed its trust anchor and accepted a fake database!
}
```

**Note:** This demonstrates that the waypoint verification is bypassed when storage version >= waypoint version, allowing a malicious database to be accepted without cryptographic verification of the waypoint hash.

## Notes

- The vulnerability exists in the optimization path where storage has already synced past the waypoint
- Normal network syncing does properly verify signatures before checking waypoint hashes
- The fix is straightforward: verify the waypoint hash even when storage is already synced
- This represents a defense-in-depth failure where the trust anchor can be completely bypassed
- Database snapshot distribution is a realistic attack vector in blockchain ecosystems

### Citations

**File:** state-sync/state-sync-driver/src/bootstrapper.rs (L98-129)
```rust
    pub fn update_verified_epoch_states(
        &mut self,
        epoch_ending_ledger_info: &LedgerInfoWithSignatures,
        waypoint: &Waypoint,
    ) -> Result<(), Error> {
        // Verify the ledger info against the latest epoch state
        self.latest_epoch_state
            .verify(epoch_ending_ledger_info)
            .map_err(|error| {
                Error::VerificationError(format!("Ledger info failed verification: {:?}", error))
            })?;

        // Update the latest epoch state with the next epoch
        if let Some(next_epoch_state) = epoch_ending_ledger_info.ledger_info().next_epoch_state() {
            self.highest_fetched_epoch_ending_version =
                epoch_ending_ledger_info.ledger_info().version();
            self.latest_epoch_state = next_epoch_state.clone();
            self.insert_new_epoch_ending_ledger_info(epoch_ending_ledger_info.clone())?;

            trace!(LogSchema::new(LogEntry::Bootstrapper).message(&format!(
                "Updated the latest epoch state to epoch: {:?}",
                self.latest_epoch_state.epoch
            )));
        } else {
            return Err(Error::VerificationError(
                "The ledger info was not epoch ending!".into(),
            ));
        }

        // Check if the ledger info corresponds to the trusted waypoint
        self.verify_waypoint(epoch_ending_ledger_info, waypoint)
    }
```

**File:** state-sync/state-sync-driver/src/bootstrapper.rs (L880-915)
```rust
    fn verify_waypoint_is_satisfiable(
        &mut self,
        global_data_summary: &GlobalDataSummary,
    ) -> Result<(), Error> {
        // If our storage has already synced beyond our waypoint, nothing needs to be checked
        let latest_ledger_info = utils::fetch_latest_synced_ledger_info(self.storage.clone())?;
        let waypoint_version = self.driver_configuration.waypoint.version();
        if latest_ledger_info.ledger_info().version() >= waypoint_version {
            self.verified_epoch_states
                .set_verified_waypoint(waypoint_version);
            return Ok(());
        }

        // Get the highest advertised synced ledger info version
        let highest_advertised_ledger_info = global_data_summary
            .advertised_data
            .highest_synced_ledger_info()
            .ok_or_else(|| {
                Error::UnsatisfiableWaypoint(
                    "Unable to check waypoint satisfiability! No highest advertised ledger info found in the network!".into(),
                )
            })?;
        let highest_advertised_version = highest_advertised_ledger_info.ledger_info().version();

        // Compare the highest advertised version with our waypoint
        if highest_advertised_version < waypoint_version {
            Err(Error::UnsatisfiableWaypoint(
                format!(
                    "The waypoint is not satisfiable! No advertised version higher than our waypoint! Highest version: {:?}, waypoint version: {:?}.",
                    highest_advertised_version, waypoint_version
                )
            ))
        } else {
            Ok(())
        }
    }
```

**File:** types/src/waypoint.rs (L24-35)
```rust
/// Waypoint keeps information about the LedgerInfo on a given version, which provides an
/// off-chain mechanism to verify the sync process right after the restart.
/// At high level, a trusted waypoint verifies the LedgerInfo for a certain epoch change.
/// For more information, please refer to the Waypoints documentation.
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
#[cfg_attr(any(test, feature = "fuzzing"), derive(Arbitrary))]
pub struct Waypoint {
    /// The version of the reconfiguration transaction that is being approved by this waypoint.
    version: Version,
    /// The hash of the chosen fields of LedgerInfo.
    value: HashValue,
}
```

**File:** storage/aptosdb/src/db/aptosdb_reader.rs (L563-570)
```rust
    /// Gets ledger info at specified version and ensures it's an epoch ending.
    fn get_epoch_ending_ledger_info(&self, version: u64) -> Result<LedgerInfoWithSignatures> {
        gauged_api("get_epoch_ending_ledger_info", || {
            self.ledger_db
                .metadata_db()
                .get_epoch_ending_ledger_info(version)
        })
    }
```
