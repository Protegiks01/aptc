# Audit Report

## Title
Hot State LRU Cache Corruption via Uninitialized Entry Ambiguity in delete()

## Summary
The `delete()` function in `HotStateLRU` cannot distinguish between an uninitialized `LRUEntry` (with both `prev` and `next` as `None`) and a legitimate head/tail entry. If an uninitialized entry exists in the cache, calling `delete()` on it incorrectly interprets it as both the head and tail simultaneously, clearing both pointers and corrupting the entire LRU state even when other valid entries exist.

## Finding Description
The vulnerability lies in the semantic ambiguity of `LRUEntry::uninitialized()`. This function creates entries where both `prev` and `next` are set to `None`: [1](#0-0) 

The `delete()` function in `HotStateLRU` uses `None` values to identify head and tail positions: [2](#0-1) 

When `prev` is `None`, the code assumes the entry is the head and sets `self.head = old_slot.next().cloned()`. When `next` is `None`, it assumes the entry is the tail and sets `self.tail = old_slot.prev().cloned()`.

For an uninitialized entry where both are `None`:
- Line 126 executes: `self.head = None` (since `next` is `None`)
- Line 138 executes: `self.tail = None` (since `prev` is `None`)

This clears the entire LRU metadata, orphaning all other entries in the cache and breaking the LRU eviction invariant.

**Attack Vector:**

While normal operations properly initialize LRU info through `insert_as_head()`, entries can enter the system with uninitialized LRU info through:

1. `StateSlot::to_hot()` creates slots with uninitialized LRU info: [3](#0-2) 

2. `StateUpdateRef::to_result_slot()` also creates uninitialized slots: [4](#0-3) 

3. These are passed to `lru.insert()` which calls `delete()` before proper initialization: [5](#0-4) 

The `delete()` call on line 54 fetches the OLD slot from overlay/committed via `get_slot()`. If that old slot has corrupted/uninitialized LRU info (from a previous bug, deserialization error, or race condition), the corruption propagates.

**Critical Weakness:**

LRU validation only runs in debug mode: [6](#0-5) 

In production builds, corrupted LRU linkage is never detected, allowing silent cache corruption.

## Impact Explanation
**Medium Severity** per Aptos Bug Bounty criteria: State inconsistencies requiring intervention.

The hot state cache is critical for state management and consensus. Corrupting the LRU metadata causes:

1. **State Consistency Violation**: The cache loses track of which entries are hot, breaking the LRU eviction policy
2. **Deterministic Execution Risk**: Different validators might have different hot state caches, potentially leading to divergent state roots
3. **Resource Exhaustion**: Without proper eviction, hot state could grow unbounded
4. **Silent Failure**: Production builds don't validate LRU integrity, allowing corruption to persist undetected

While this requires a precondition (corrupted entry in cache), the impact is severe once triggered.

## Likelihood Explanation
**Low to Medium Likelihood**

The vulnerability requires an uninitialized hot entry to exist in the overlay/committed cache, which normally shouldn't happen due to proper initialization in `insert_as_head()`. However:

- Complex concurrent operations on hot state across multiple shards
- Bugs in persistence/deserialization layer
- Race conditions during state updates
- Edge cases in the layered state management

could potentially introduce corrupted entries. The lack of production validation makes detection difficult.

## Recommendation
**Solution 1: Eliminate Ambiguity in delete()**

Add an assertion to detect uninitialized entries being deleted:

```rust
fn delete(&mut self, key: &StateKey) -> Option<StateSlot> {
    let old_slot = match self.get_slot(key) {
        Some(slot) if slot.is_hot() => slot,
        _ => return None,
    };
    
    // NEW: Detect uninitialized entries
    assert!(
        old_slot.prev().is_some() || old_slot.next().is_some() || 
        (self.head.as_ref() == Some(key) && self.tail.as_ref() == Some(key)),
        "Attempting to delete entry with uninitialized LRU info (both prev and next are None) \
         that is not the sole entry in the list. This indicates cache corruption. Key: {:?}",
        key
    );
    
    match old_slot.prev() {
        // ... rest of function
    }
}
```

**Solution 2: Enable Validation in Production**

Replace `debug_assert!` with a regular check:

```rust
// In Committer::commit()
if let Err(e) = self.validate_lru(shard_id) {
    error!("LRU validation failed for shard {}: {:?}", shard_id, e);
    panic!("Hot state LRU corruption detected");
}
```

**Solution 3: Eager Initialization**

Ensure all hot slots are initialized immediately upon creation, before entering any data structure.

## Proof of Concept

```rust
#[cfg(test)]
mod hot_state_corruption_test {
    use super::*;
    use aptos_types::state_store::{
        hot_state::LRUEntry,
        state_key::StateKey,
        state_slot::StateSlot,
    };
    use std::collections::HashMap;
    
    #[test]
    #[should_panic(expected = "LRU corruption")]
    fn test_uninitialized_entry_corrupts_lru() {
        // Setup: Create an LRU with properly linked entries
        let key_a = StateKey::raw(b"key_a");
        let key_b = StateKey::raw(b"key_b");
        let key_c = StateKey::raw(b"key_c");
        
        let mut lru = HotStateLRU::new(
            NonZeroUsize::new(10).unwrap(),
            Arc::new(MockHotStateView::new()),
            &LayeredMap::new_empty(),
            Some(key_a.clone()),
            Some(key_c.clone()),
            3,
        );
        
        // Insert three properly linked entries
        lru.insert(key_a.clone(), create_hot_slot());
        lru.insert(key_b.clone(), create_hot_slot());
        lru.insert(key_c.clone(), create_hot_slot());
        
        assert_eq!(lru.head, Some(key_c.clone()));
        assert_eq!(lru.tail, Some(key_a.clone()));
        assert_eq!(lru.num_items, 3);
        
        // Simulate corrupted entry: manually insert an uninitialized hot slot
        // into the overlay that bypasses insert_as_head()
        let corrupted_key = StateKey::raw(b"corrupted");
        let corrupted_slot = StateSlot::HotOccupied {
            value_version: 1,
            value: StateValue::new_legacy(vec![1, 2, 3].into()),
            hot_since_version: 1,
            lru_info: LRUEntry::uninitialized(), // Both prev and next are None!
        };
        
        // Force corrupted entry into cache (simulating deserialization bug)
        lru.pending.insert(corrupted_key.clone(), corrupted_slot);
        
        // Now delete the corrupted entry
        lru.delete(&corrupted_key);
        
        // BUG: This corrupts the entire LRU!
        assert!(lru.head.is_none(), "LRU corruption: head cleared");
        assert!(lru.tail.is_none(), "LRU corruption: tail cleared");
        
        // The three original entries are now orphaned
        panic!("LRU corruption: all metadata cleared despite valid entries remaining");
    }
}
```

### Citations

**File:** types/src/state_store/hot_state.rs (L23-30)
```rust
impl<K> LRUEntry<K> {
    pub fn uninitialized() -> Self {
        Self {
            prev: None,
            next: None,
        }
    }
}
```

**File:** storage/storage-interface/src/state_store/hot_state.rs (L49-58)
```rust
    pub fn insert(&mut self, key: StateKey, slot: StateSlot) {
        assert!(
            slot.is_hot(),
            "Should not insert cold slots into hot state."
        );
        if self.delete(&key).is_none() {
            self.num_items += 1;
        }
        self.insert_as_head(key, slot);
    }
```

**File:** storage/storage-interface/src/state_store/hot_state.rs (L118-140)
```rust
        match old_slot.prev() {
            Some(prev_key) => {
                let mut prev_slot = self.expect_hot_slot(prev_key);
                prev_slot.set_next(old_slot.next().cloned());
                self.pending.insert(prev_key.clone(), prev_slot);
            },
            None => {
                // There is no newer entry. The current key was the head.
                self.head = old_slot.next().cloned();
            },
        }

        match old_slot.next() {
            Some(next_key) => {
                let mut next_slot = self.expect_hot_slot(next_key);
                next_slot.set_prev(old_slot.prev().cloned());
                self.pending.insert(next_key.clone(), next_slot);
            },
            None => {
                // There is no older entry. The current key was the tail.
                self.tail = old_slot.prev().cloned();
            },
        }
```

**File:** types/src/state_store/state_slot.rs (L197-214)
```rust
    pub fn to_hot(self, hot_since_version: Version) -> Self {
        match self {
            ColdOccupied {
                value_version,
                value,
            } => HotOccupied {
                value_version,
                value,
                hot_since_version,
                lru_info: LRUEntry::uninitialized(),
            },
            ColdVacant => HotVacant {
                hot_since_version,
                lru_info: LRUEntry::uninitialized(),
            },
            _ => panic!("Should not be called on hot slots."),
        }
    }
```

**File:** storage/storage-interface/src/state_store/versioned_state_value.rs (L18-35)
```rust
    /// NOTE: the lru_info in the result is not initialized yet.
    pub fn to_result_slot(&self) -> Option<StateSlot> {
        match self.state_op.clone() {
            BaseStateOp::Creation(value) | BaseStateOp::Modification(value) => {
                Some(StateSlot::HotOccupied {
                    value_version: self.version,
                    value,
                    hot_since_version: self.version,
                    lru_info: LRUEntry::uninitialized(),
                })
            },
            BaseStateOp::Deletion(_) => Some(StateSlot::HotVacant {
                hot_since_version: self.version,
                lru_info: LRUEntry::uninitialized(),
            }),
            BaseStateOp::MakeHot => None,
        }
    }
```

**File:** storage/aptosdb/src/state_store/hot_state.rs (L269-269)
```rust
            debug_assert!(self.validate_lru(shard_id).is_ok());
```
