# Audit Report

## Title
Insecure File Permissions on Network Identity Keys Allow Local Attacker to Impersonate Nodes

## Summary
The node configuration loader creates and stores network identity keys (x25519 private keys) without setting appropriate file permissions, leaving them world-readable on Unix systems. This allows local attackers to steal cryptographic key material and impersonate nodes on the Aptos network.

## Finding Description

The vulnerability exists in the node startup flow where identity keys are persisted to disk without proper permission validation or restrictive file modes.

**Vulnerable Code Path:**

1. When a node starts, `load_and_sanitize_config()` is called [1](#0-0) 

2. At line 83, `set_data_dir` is called without any permission validation on the data directory [2](#0-1) 

3. Subsequently, `optimize_and_sanitize_node_config` executes various optimizers [3](#0-2) 

4. For public fullnode networks, `optimize_public_network_config` handles auto-generated identity keys [4](#0-3) 

5. The critical flaw occurs in `Identity::save_private_key` which creates files using `File::create()` without setting restrictive permissions [5](#0-4) 

**The Security Violation:**

- `fs::create_dir_all()` creates parent directories with default Unix permissions (typically 0o755 - world-readable)
- `File::create()` creates the key file with default Unix permissions (typically 0o644 - world-readable)
- No validation checks if existing directories have appropriate permissions
- The x25519 private keys are used for network authentication and peer identification

**Contrast with Secure Implementation:**

The codebase contains proper secure file writing functions that set mode 0o600 (user read/write only):
- `write_to_user_only_file` [6](#0-5) 
- `save_to_file_confidential` [7](#0-6) 

However, these secure functions are not used for identity key persistence.

## Impact Explanation

**Severity: Medium**

This vulnerability meets the Medium severity criteria: "State inconsistencies requiring intervention" and "Node security compromise requiring key rotation."

**Impact Details:**

1. **Cryptographic Key Exposure**: x25519 private keys used for network identity are readable by any local user on the system
2. **Node Impersonation**: An attacker who obtains these keys can impersonate the node on the network, establishing authenticated connections as that node
3. **Man-in-the-Middle Attacks**: Stolen keys enable network-level attacks against node communications
4. **Violation of Cryptographic Correctness Invariant**: The system fails to maintain confidentiality of cryptographic material

**Why Medium (not High/Critical):**
- Requires local file system access (not remotely exploitable)
- Does not directly cause fund loss or consensus safety violations
- Does not cause network-wide outages
- Requires operator intervention (key rotation) to remediate

## Likelihood Explanation

**Likelihood: High**

This vulnerability is highly likely to manifest in production environments:

1. **Default Behavior**: The insecure file permissions are created by default during normal node operation
2. **Common Deployment Scenarios**: Many node operators run nodes on shared systems or containers where multiple users/processes have file system access
3. **No Warning or Detection**: The system provides no indication that key material is improperly secured
4. **Persistent Exposure**: Once created with weak permissions, the vulnerability persists across node restarts

**Attack Requirements:**
- Local file system read access to the node's data directory
- No special privileges or insider access needed
- No complex exploitation technique required

## Recommendation

**Immediate Fix:**

Modify `Identity::save_private_key` to use restrictive file permissions:

```rust
pub fn save_private_key(path: &PathBuf, key: &x25519::PrivateKey) -> anyhow::Result<()> {
    // Create the parent directory
    let parent_path = path.parent().unwrap();
    fs::create_dir_all(parent_path)?;
    
    // Save the private key with restrictive permissions (0o600 on Unix)
    let mut opts = OpenOptions::new();
    opts.write(true).create(true).truncate(true);
    
    #[cfg(unix)]
    opts.mode(0o600);
    
    let mut file = opts.open(path)?;
    file.write_all(&key.to_bytes())
        .map_err(|error| error.into())
}
```

**Additional Hardening:**

1. Add permission validation in `load_and_sanitize_config()` before line 83 to check that the data directory has appropriate permissions
2. Consider setting directory permissions to 0o700 (user-only access) when creating parent directories
3. Add startup warnings if existing key files have overly permissive permissions
4. Document security requirements for data directory permissions in deployment guides

## Proof of Concept

**Rust Test Demonstrating Vulnerability:**

```rust
#[cfg(unix)]
#[test]
fn test_identity_key_file_permissions_vulnerability() {
    use std::os::unix::fs::PermissionsExt;
    use tempfile::tempdir;
    use aptos_crypto::x25519;
    use aptos_crypto::Uniform;
    use rand::rngs::OsRng;
    use config::config::identity_config::Identity;
    
    // Create temporary directory
    let temp_dir = tempdir().unwrap();
    let key_path = temp_dir.path().join("identity_key");
    
    // Generate and save identity key
    let private_key = x25519::PrivateKey::generate(&mut OsRng);
    Identity::save_private_key(&key_path, &private_key).unwrap();
    
    // Check file permissions
    let metadata = std::fs::metadata(&key_path).unwrap();
    let permissions = metadata.permissions();
    let mode = permissions.mode();
    
    // Extract permission bits (last 9 bits)
    let file_mode = mode & 0o777;
    
    // VULNERABILITY: File is world-readable (mode 0o644)
    println!("File created with mode: {:o}", file_mode);
    assert_eq!(file_mode, 0o644, "File has insecure default permissions!");
    
    // This should be 0o600 (user read/write only) for security
    // Expected: file_mode == 0o600
    // Actual: file_mode == 0o644 (world-readable!)
}
```

**Attack Simulation:**

```bash
# Attacker with local access reads the identity key
cd /opt/aptos/data/
cat ephemeral_identity_key

# Attacker now has 32 bytes of x25519 private key material
# Can reconstruct the private key and impersonate the node
```

## Notes

This vulnerability violates the **Cryptographic Correctness** invariant which requires that "BLS signatures, VRF, and hash operations must be secure." While this specifically affects x25519 network identity keys rather than BLS consensus keys, the principle of cryptographic key confidentiality is compromised.

The fix is straightforward and follows patterns already established in the codebase for handling confidential data. The security team should also audit other locations where cryptographic material is persisted to ensure consistent use of restrictive file permissions.

### Citations

**File:** config/src/config/node_config_loader.rs (L72-90)
```rust
    pub fn load_and_sanitize_config(&self) -> Result<NodeConfig, Error> {
        // Load the node config from disk
        let mut node_config = NodeConfig::load_config(&self.node_config_path)?;

        // Load the execution config
        let input_dir = RootPath::new(&self.node_config_path);
        node_config.execution.load_from_path(&input_dir)?;

        // Update the data directory. This needs to be done before
        // we optimize and sanitize the node configs (because some optimizers
        // rely on the data directory for file reading/writing).
        node_config.set_data_dir(node_config.get_data_dir().to_path_buf());

        // Optimize and sanitize the node config
        let local_config_yaml = get_local_config_yaml(&self.node_config_path)?;
        optimize_and_sanitize_node_config(&mut node_config, local_config_yaml)?;

        Ok(node_config)
    }
```

**File:** config/src/config/config_optimizer.rs (L220-232)
```rust
            if let Identity::FromConfig(IdentityFromConfig {
                source: IdentitySource::AutoGenerated,
                key: config_key,
                ..
            }) = &fullnode_network_config.identity
            {
                let path = node_config.storage.dir().join(IDENTITY_KEY_FILE);
                if let Some(loaded_identity) = Identity::load_identity(&path)? {
                    fullnode_network_config.identity = loaded_identity;
                } else {
                    Identity::save_private_key(&path, &config_key.private_key())?;
                }
            }
```

**File:** config/src/config/identity_config.rs (L117-126)
```rust
    pub fn save_private_key(path: &PathBuf, key: &x25519::PrivateKey) -> anyhow::Result<()> {
        // Create the parent directory
        let parent_path = path.parent().unwrap();
        fs::create_dir_all(parent_path)?;

        // Save the private key to the specified path
        File::create(path)?
            .write_all(&key.to_bytes())
            .map_err(|error| error.into())
    }
```

**File:** crates/aptos/src/common/utils.rs (L224-229)
```rust
pub fn write_to_user_only_file(path: &Path, name: &str, bytes: &[u8]) -> CliTypedResult<()> {
    let mut opts = OpenOptions::new();
    #[cfg(unix)]
    opts.mode(0o600);
    write_to_file_with_opts(path, name, bytes, &mut opts)
}
```

**File:** crates/aptos/src/common/types.rs (L1084-1089)
```rust
    pub fn save_to_file_confidential(&self, name: &str, bytes: &[u8]) -> CliTypedResult<()> {
        let mut opts = OpenOptions::new();
        #[cfg(unix)]
        opts.mode(0o600);
        write_to_file_with_opts(self.output_file.as_path(), name, bytes, &mut opts)
    }
```
