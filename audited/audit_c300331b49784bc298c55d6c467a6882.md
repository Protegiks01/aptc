# Audit Report

## Title
Time-of-Check-Time-of-Use Race in API Transaction Retrieval Causes State View Version Mismatch

## Summary
The `get_transaction_by_hash_inner()` function contains a TOCTOU race condition where the ledger info is retrieved at one version, but the state view used for transaction decoding is retrieved at a potentially newer version, causing inconsistent API responses.

## Finding Description

The vulnerability exists in the async flow of `get_transaction_by_hash_inner()`: [1](#0-0) 

The function retrieves ledger info through the first `api_spawn_blocking` call, then performs an async `get_by_hash()` operation, followed by a second `api_spawn_blocking` call to convert the transaction. During the time between these operations, the blockchain can advance to newer versions.

The critical issue occurs in `get_transaction_inner()`: [2](#0-1) 

This function calls `latest_state_view_poem(ledger_info)` which retrieves the CURRENT latest state from the database: [3](#0-2) 

The `latest_state_checkpoint_view()` implementation always fetches the latest version: [4](#0-3) 

This state view is then used by `MoveConverter` to decode resources and transaction payloads by reading Move modules: [5](#0-4) 

**Breaking the State Consistency Invariant**: The API returns a response where `ledger_info.version` indicates version V₁, but the transaction details are decoded using Move module ABIs from version V₂ > V₁. If modules were upgraded between these versions, the decoded resource structures will not match what actually existed at V₁.

## Impact Explanation

This violates the **State Consistency** invariant and qualifies as **Medium Severity** per the bug bounty criteria ("State inconsistencies requiring intervention"):

1. **Data Integrity Violation**: Clients receive transaction data where the version metadata doesn't match the actual state used for decoding
2. **Incorrect Resource Interpretation**: If Move modules are upgraded between V₁ and V₂, resources may be decoded with the wrong schema, producing incorrect field names/values
3. **Client-Side Cascading Errors**: Clients caching this data based on the claimed version will propagate inconsistencies through their systems
4. **API Contract Breach**: The API's implicit contract that response data matches the ledger_info version is violated

## Likelihood Explanation

**Moderate Likelihood**:
- The race window exists during every `get_transaction_by_hash` call that takes more than one block time
- Under high load or slow I/O, the async `get_by_hash()` operation provides sufficient time for blockchain advancement
- Module upgrades are governance events that do occur in production
- No attacker action is required - this can happen naturally during normal operations
- More likely in high-throughput scenarios or when querying historical transactions

## Recommendation

Pin the state view to the same version as the ledger_info. Modify `get_transaction_inner()` to use a versioned state view:

```rust
fn get_transaction_inner(
    &self,
    accept_type: &AcceptType,
    transaction_data: TransactionData,
    ledger_info: &LedgerInfo,
) -> BasicResultWith404<Transaction> {
    match accept_type {
        AcceptType::Json => {
            // Use state view at the ledger_info version, not latest
            let state_view = self.context
                .state_view_at_version(ledger_info.version())
                .map_err(|err| {
                    BasicErrorWith404::internal_with_code(
                        err,
                        AptosErrorCode::InternalError,
                        ledger_info,
                    )
                })?;
            // ... rest of conversion logic
        }
    }
}
```

Alternatively, retrieve the ledger_info inside the second `api_spawn_blocking` call immediately before creating the state view to minimize the race window.

## Proof of Concept

```rust
// Rust reproduction demonstrating the race
#[tokio::test]
async fn test_transaction_state_view_race() {
    // Setup: Create blockchain at V1 with module M at schema S1
    let mut harness = create_test_harness();
    let txn = submit_transaction_with_resource(&harness, schema_v1);
    harness.commit_block(); // Now at V1
    
    let txn_hash = txn.hash();
    
    // Start API call to get transaction
    let api_handle = tokio::spawn(async move {
        api.get_transaction_by_hash(txn_hash).await
    });
    
    // Simulate race: upgrade module to schema S2
    tokio::time::sleep(Duration::from_millis(10)).await;
    harness.upgrade_module_schema(schema_v2);
    harness.commit_block(); // Now at V2
    
    // Complete API call
    let response = api_handle.await.unwrap();
    
    // Verify the vulnerability:
    assert_eq!(response.ledger_info.version, V1); // Claims V1
    // But resource fields match schema_v2, not schema_v1
    assert!(resource_decoded_with_v2_schema(&response.transaction));
}
```

**Notes:**
- The race window is typically microseconds to milliseconds but widens under load
- Module upgrades changing resource schemas are the most impactful trigger
- This affects all transaction query endpoints using `get_transaction_inner()`
- The issue is confined to the API layer and does not affect consensus or on-chain state integrity

### Citations

**File:** api/src/transactions.rs (L942-978)
```rust
    async fn get_transaction_by_hash_inner(
        &self,
        accept_type: &AcceptType,
        hash: HashValue,
    ) -> BasicResultWith404<Transaction> {
        let context = self.context.clone();
        let accept_type = accept_type.clone();

        let (internal_ledger_info_opt, storage_ledger_info) =
            api_spawn_blocking(move || context.get_latest_internal_and_storage_ledger_info())
                .await?;
        let storage_version = storage_ledger_info.ledger_version.into();
        let internal_indexer_version = internal_ledger_info_opt
            .as_ref()
            .map(|info| info.ledger_version.into());
        let latest_ledger_info = internal_ledger_info_opt.unwrap_or(storage_ledger_info);

        let txn_data = self
            .get_by_hash(hash.into(), storage_version, internal_indexer_version)
            .await
            .context(format!("Failed to get transaction by hash {}", hash))
            .map_err(|err| {
                BasicErrorWith404::internal_with_code(
                    err,
                    AptosErrorCode::InternalError,
                    &latest_ledger_info,
                )
            })?
            .context(format!("Failed to find transaction with hash: {}", hash))
            .map_err(|_| transaction_not_found_by_hash(hash, &latest_ledger_info))?;

        let api = self.clone();
        api_spawn_blocking(move || {
            api.get_transaction_inner(&accept_type, txn_data, &latest_ledger_info)
        })
        .await
    }
```

**File:** api/src/transactions.rs (L1009-1058)
```rust
    fn get_transaction_inner(
        &self,
        accept_type: &AcceptType,
        transaction_data: TransactionData,
        ledger_info: &LedgerInfo,
    ) -> BasicResultWith404<Transaction> {
        match accept_type {
            AcceptType::Json => {
                let state_view = self.context.latest_state_view_poem(ledger_info)?;
                let transaction = match transaction_data {
                    TransactionData::OnChain(txn) => {
                        let timestamp =
                            self.context.get_block_timestamp(ledger_info, txn.version)?;
                        state_view
                            .as_converter(
                                self.context.db.clone(),
                                self.context.indexer_reader.clone(),
                            )
                            .try_into_onchain_transaction(timestamp, txn)
                            .context("Failed to convert on chain transaction to Transaction")
                            .map_err(|err| {
                                BasicErrorWith404::internal_with_code(
                                    err,
                                    AptosErrorCode::InternalError,
                                    ledger_info,
                                )
                            })?
                    },
                    TransactionData::Pending(txn) => state_view
                        .as_converter(self.context.db.clone(), self.context.indexer_reader.clone())
                        .try_into_pending_transaction(*txn)
                        .context("Failed to convert on pending transaction to Transaction")
                        .map_err(|err| {
                            BasicErrorWith404::internal_with_code(
                                err,
                                AptosErrorCode::InternalError,
                                ledger_info,
                            )
                        })?,
                };

                BasicResponse::try_from_json((transaction, ledger_info, BasicResponseStatus::Ok))
            },
            AcceptType::Bcs => BasicResponse::try_from_bcs((
                transaction_data,
                ledger_info,
                BasicResponseStatus::Ok,
            )),
        }
    }
```

**File:** api/src/context.rs (L160-168)
```rust
    pub fn latest_state_view_poem<E: InternalError>(
        &self,
        ledger_info: &LedgerInfo,
    ) -> Result<DbStateView, E> {
        self.db
            .latest_state_checkpoint_view()
            .context("Failed to read latest state checkpoint from DB")
            .map_err(|e| E::internal_with_code(e, AptosErrorCode::InternalError, ledger_info))
    }
```

**File:** storage/storage-interface/src/state_store/state_view/db_state_view.rs (L82-90)
```rust
    fn latest_state_checkpoint_view(&self) -> StateViewResult<DbStateView> {
        Ok(DbStateView {
            db: self.clone(),
            version: self
                .get_latest_state_checkpoint_version()
                .map_err(Into::<StateViewError>::into)?,
            maybe_verify_against_state_root_hash: None,
        })
    }
```

**File:** aptos-move/aptos-resource-viewer/src/module_view.rs (L56-87)
```rust
    fn view_compiled_module(&self, module_id: &ModuleId) -> anyhow::Result<Option<Self::Item>> {
        let mut module_cache = self.module_cache.borrow_mut();
        if let Some(module) = module_cache.get(module_id) {
            return Ok(Some(module.clone()));
        }

        let state_key = StateKey::module_id(module_id);
        Ok(
            match self
                .state_view
                .get_state_value_bytes(&state_key)
                .map_err(|e| anyhow!("Error retrieving module {:?}: {:?}", module_id, e))?
            {
                Some(bytes) => {
                    let compiled_module =
                        CompiledModule::deserialize_with_config(&bytes, &self.deserializer_config)
                            .map_err(|status| {
                                anyhow!(
                                    "Module {:?} deserialize with error code {:?}",
                                    module_id,
                                    status
                                )
                            })?;

                    let compiled_module = Arc::new(compiled_module);
                    module_cache.insert(module_id.clone(), compiled_module.clone());
                    Some(compiled_module)
                },
                None => None,
            },
        )
    }
```
