# Audit Report

## Title
Path Traversal and Symlink Vulnerability in Backup Restore Allows Arbitrary File Read

## Summary
The `LocalFs::open_for_read()` method in the backup-cli component does not validate `FileHandle` paths before using them to open files. This allows an attacker who can modify backup manifests to inject malicious paths containing path traversal sequences or symlinks, enabling arbitrary file read on the validator's filesystem during restore operations.

## Finding Description

The backup-cli system stores backup manifests as JSON files containing `FileHandle` values (type alias for `String`) that reference data files. During state snapshot restore operations, these manifests are deserialized and the FileHandles are used to open files without any validation. [1](#0-0) 

The `StateSnapshotBackup` manifest structure contains multiple FileHandle fields that point to chunk data and proofs: [2](#0-1) 

During restore, the manifest is deserialized from JSON without cryptographic verification: [3](#0-2) 

The FileHandles from the manifest are then used to open files for reading: [4](#0-3) 

The critical vulnerability is in `LocalFs::open_for_read()`, which directly joins the FileHandle to the base directory without any validation: [5](#0-4) 

Rust's `PathBuf::join()` does not prevent path traversal - it will preserve `../` components. Additionally, `OpenOptions::open()` will follow symlinks by default.

**Attack Flow:**
1. Attacker gains access to backup storage (e.g., compromised S3 credentials, misconfigured bucket permissions, malicious backup provider)
2. Attacker modifies a state snapshot manifest JSON file, changing FileHandle values to malicious paths:
   - Path traversal: `"../../../config/consensus_keypair.json"`
   - Symlink: Creates a symlink within the backup directory pointing to sensitive files
3. When a validator operator initiates a restore operation, the malicious manifest is loaded
4. The restore process attempts to read state data using the malicious FileHandle
5. The `open_for_read()` method constructs a path like `/backup/dir/../../../config/consensus_keypair.json`
6. The validator's private keys or other sensitive files are read and processed as "state data"
7. Depending on subsequent processing, this could expose sensitive information or cause corruption

## Impact Explanation

**Severity: High** per Aptos bug bounty criteria.

This vulnerability breaks the **Access Control** invariant - system files and validator secrets should not be accessible through the backup restore interface. The impact includes:

1. **Confidentiality Breach**: Arbitrary file read allows exfiltration of:
   - Validator consensus private keys
   - Validator network keys
   - Node configuration files containing sensitive credentials
   - Database files with blockchain state

2. **Potential Escalation**: If consensus keys are compromised, an attacker could:
   - Sign malicious blocks (consensus safety violation)
   - Perform Byzantine actions
   - Potentially steal staked funds

3. **No Defense-in-Depth**: Manifest files lack cryptographic authentication (signatures, MACs, or integrity checks), meaning any compromise of backup storage immediately enables this attack.

While this does not directly cause "Loss of Funds" or "Consensus/Safety violations" (Critical severity), it enables **significant protocol violations** through key compromise, qualifying as High severity. The lack of input validation on untrusted data (deserialized manifests) represents a fundamental security weakness.

## Likelihood Explanation

**Likelihood: Medium**

Prerequisites for exploitation:
1. **Backup storage compromise**: Attacker needs write access to modify manifest files
2. **Restore operation**: Attacker needs to wait for or trigger a restore

Realistic attack scenarios:
- **Cloud storage misconfiguration**: S3 buckets with overly permissive ACLs (common vulnerability)
- **Credential leakage**: Backup storage credentials leaked through logs, environment variables, or insider access
- **Supply chain attack**: Malicious backup service provider or compromised backup tooling
- **Shared infrastructure**: Multi-tenant backup environments where isolation is weak

The attack is **moderately likely** because:
- Backup storage often has weaker security posture than validator nodes themselves
- Cloud storage misconfigurations are a well-documented class of vulnerabilities
- Backup credentials may be shared among multiple operators or services
- No cryptographic verification means a single compromise has full impact

## Recommendation

Implement defense-in-depth for manifest integrity and path validation:

**1. Validate FileHandle paths before use:**
```rust
async fn open_for_read(
    &self,
    file_handle: &FileHandleRef,
) -> Result<Box<dyn AsyncRead + Send + Unpin>> {
    // Validate: no path traversal, no absolute paths
    let file_path = Path::new(file_handle);
    ensure!(
        file_path.is_relative(),
        "FileHandle must be relative: {}",
        file_handle
    );
    ensure!(
        !file_handle.contains(".."),
        "FileHandle contains path traversal: {}",
        file_handle
    );
    
    // Canonicalize to resolve symlinks and verify it's within backup dir
    let path = self.dir.join(file_handle);
    let canonical_path = tokio::fs::canonicalize(&path).await
        .err_notes(&path)?;
    let canonical_dir = tokio::fs::canonicalize(&self.dir).await
        .err_notes(&self.dir)?;
    
    ensure!(
        canonical_path.starts_with(&canonical_dir),
        "FileHandle escapes backup directory: {}",
        file_handle
    );
    
    let file = OpenOptions::new()
        .read(true)
        .open(&canonical_path)
        .await
        .err_notes(&canonical_path)?;
    Ok(Box::new(file))
}
```

**2. Cryptographically sign manifests:**
- Add a digital signature field to manifest structures
- Sign manifests during backup creation using validator keys
- Verify signatures before deserialization during restore
- Reject unsigned or invalidly signed manifests

**3. Apply similar validation to CommandAdapter:** [6](#0-5) 

Ensure shell commands properly validate the FILE_HANDLE environment variable.

## Proof of Concept

**Rust PoC (integration test):**

```rust
#[tokio::test]
async fn test_path_traversal_in_restore() {
    use tempfile::TempDir;
    use std::fs::File;
    use std::io::Write;
    use std::path::PathBuf;
    
    // Setup: Create backup directory and a sensitive file outside it
    let temp_root = TempDir::new().unwrap();
    let backup_dir = temp_root.path().join("backups");
    let sensitive_file = temp_root.path().join("sensitive_key.pem");
    
    std::fs::create_dir_all(&backup_dir).unwrap();
    let mut f = File::create(&sensitive_file).unwrap();
    f.write_all(b"PRIVATE_KEY_CONTENT").unwrap();
    
    // Create malicious manifest
    let malicious_manifest = serde_json::json!({
        "version": 100,
        "epoch": 1,
        "root_hash": "0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef",
        "chunks": [{
            "first_idx": 0,
            "last_idx": 0,
            "first_key": "0x0000000000000000000000000000000000000000000000000000000000000000",
            "last_key": "0x0000000000000000000000000000000000000000000000000000000000000000",
            "blobs": "../sensitive_key.pem",  // Path traversal
            "proof": "dummy.proof"
        }],
        "proof": "state.proof"
    });
    
    // Write malicious manifest
    let manifest_path = backup_dir.join("malicious.manifest");
    std::fs::write(&manifest_path, serde_json::to_string(&malicious_manifest).unwrap()).unwrap();
    
    // Attempt to restore
    let storage = LocalFs::new(backup_dir.clone());
    let manifest_handle = "malicious.manifest";
    
    // This will successfully open and read the sensitive file
    let result = storage.open_for_read(manifest_handle).await;
    
    assert!(result.is_ok(), "Path traversal succeeded - vulnerability confirmed");
    
    let mut content = String::new();
    result.unwrap().read_to_string(&mut content).await.unwrap();
    assert_eq!(content, "PRIVATE_KEY_CONTENT", "Sensitive file was read through path traversal");
}
```

**Note**: The "overwrite system files" aspect mentioned in the security question is **NOT exploitable** because `create_for_write()` uses `create_new(true)`, which prevents overwriting existing files. Only arbitrary file **read** is possible, not write.

---

**Notes**: 

This vulnerability requires the attacker to first compromise backup storage access (write permissions to modify manifests). While this is a prerequisite, the lack of path validation and manifest authentication represents a failure of defense-in-depth that transforms a backup storage compromise into a validator filesystem read vulnerability. The backup-cli should treat all deserialized data as untrusted and validate it accordingly.

### Citations

**File:** storage/backup/backup-cli/src/storage/mod.rs (L36-41)
```rust
/// URI pointing to a file in a backup storage, like "s3:///bucket/path/file".
/// These are created by the storage when `create_for_write()`, stored in manifests by the backup
/// controller, and passed back to the storage when `open_for_read()` by the restore controller
/// to retrieve a file referred to in the manifest.
pub type FileHandle = String;
pub type FileHandleRef = str;
```

**File:** storage/backup/backup-cli/src/backup_types/state_snapshot/manifest.rs (L9-51)
```rust
/// A chunk of a state snapshot manifest, representing accounts in the key range
/// [`first_key`, `last_key`] (right side inclusive).
#[derive(Deserialize, Serialize)]
pub struct StateSnapshotChunk {
    /// index of the first account in this chunk over all accounts.
    pub first_idx: usize,
    /// index of the last account in this chunk over all accounts.
    pub last_idx: usize,
    /// key of the first account in this chunk.
    pub first_key: HashValue,
    /// key of the last account in this chunk.
    pub last_key: HashValue,
    /// Repeated `len(record) + record` where `record` is BCS serialized tuple
    /// `(key, state_value)`
    pub blobs: FileHandle,
    /// BCS serialized `SparseMerkleRangeProof` that proves this chunk adds up to the root hash
    /// indicated in the backup (`StateSnapshotBackup::root_hash`).
    pub proof: FileHandle,
}

/// State snapshot backup manifest, representing a complete state view at specified version.
#[derive(Deserialize, Serialize)]
pub struct StateSnapshotBackup {
    /// Version at which this state snapshot is taken.
    pub version: Version,
    /// Epoch in which this state snapshot is taken.
    pub epoch: u64,
    /// Hash of the state tree root.
    pub root_hash: HashValue,
    /// All account blobs in chunks.
    pub chunks: Vec<StateSnapshotChunk>,
    /// BCS serialized
    /// `Tuple(TransactionInfoWithProof, LedgerInfoWithSignatures)`.
    ///   - The `TransactionInfoWithProof` is at `Version` above, and carries the same `root_hash`
    /// above; It proves that at specified version the root hash is as specified in a chain
    /// represented by the LedgerInfo below.
    ///   - The signatures on the `LedgerInfoWithSignatures` has a version greater than or equal to
    /// the version of this backup but is within the same epoch, so the signatures on it can be
    /// verified by the validator set in the same epoch, which can be provided by an
    /// `EpochStateBackup` recovered prior to this to the DB; Requiring it to be in the same epoch
    /// limits the requirement on such `EpochStateBackup` to no older than the same epoch.
    pub proof: FileHandle,
}
```

**File:** storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs (L123-124)
```rust
        let manifest: StateSnapshotBackup =
            self.storage.load_json_file(&self.manifest_handle).await?;
```

**File:** storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs (L253-257)
```rust
    async fn read_state_value(
        storage: &Arc<dyn BackupStorage>,
        file_handle: FileHandle,
    ) -> Result<Vec<(StateKey, StateValue)>> {
        let mut file = storage.open_for_read(&file_handle).await?;
```

**File:** storage/backup/backup-cli/src/storage/local_fs/mod.rs (L98-109)
```rust
    async fn open_for_read(
        &self,
        file_handle: &FileHandleRef,
    ) -> Result<Box<dyn AsyncRead + Send + Unpin>> {
        let path = self.dir.join(file_handle);
        let file = OpenOptions::new()
            .read(true)
            .open(&path)
            .await
            .err_notes(&path)?;
        Ok(Box::new(file))
    }
```

**File:** storage/backup/backup-cli/src/storage/command_adapter/mod.rs (L114-124)
```rust
    async fn open_for_read(
        &self,
        file_handle: &FileHandleRef,
    ) -> Result<Box<dyn AsyncRead + Send + Unpin>> {
        let child = self
            .cmd(&self.config.commands.open_for_read, vec![
                EnvVar::file_handle(file_handle.to_string()),
            ])
            .spawn()?;
        Ok(Box::new(child.into_data_source()))
    }
```
