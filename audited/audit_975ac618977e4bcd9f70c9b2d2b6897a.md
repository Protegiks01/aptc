# Audit Report

## Title
Hardcoded Test Mode in Genesis Transaction Generation Enables Unlimited APT Minting and Governance Bypass

## Summary
The `generate_genesis_txn()` function in `crates/aptos-genesis/src/lib.rs` hardcodes `is_test: true` on line 145, ignoring the configured `self.is_test` value. This forces all non-mainnet genesis transactions into test mode, granting the `@core_resources` account unlimited APT minting capability and version update privileges, even when the network operator explicitly configures `is_test: false` for production-like security. [1](#0-0) 

## Finding Description

The vulnerability exists due to a configuration override in the genesis generation flow:

1. **Configuration Properly Initialized**: The `GenesisInfo` struct correctly stores the `is_test` parameter from configuration [2](#0-1) 

2. **Configuration Ignored**: When generating the genesis transaction, line 145 hardcodes `is_test: true`, completely ignoring `self.is_test` [3](#0-2) 

3. **Test Privileges Activated**: When `is_test: true`, the genesis process executes `initialize_core_resources_and_aptos_coin` instead of the standard `initialize_aptos_coin` [4](#0-3) 

4. **Unlimited Mint Capability Granted**: This test initialization mints maximum u64 APT coins and grants `MintCapStore` to `@core_resources` [5](#0-4) 

5. **Version Control Granted**: The test mode also grants `SetVersionCapability` to `@core_resources` [6](#0-5) 

**Attack Scenario:**
- A testnet/devnet operator configures `is_test: false` expecting production security [7](#0-6) 
- The code ignores this and forces test mode
- The `@core_resources` account is created with the `root_key` authentication [8](#0-7) 
- Anyone with the root_key private key (genesis operator or attacker who compromises it) can:
  - Mint unlimited APT via `aptos_coin::mint()`
  - Force protocol version changes via `version::set_version()`
  - Delegate mint capability to other addresses
  - Bypass all governance mechanisms

## Impact Explanation

**Critical Severity** - This vulnerability meets multiple critical impact categories:

1. **Loss of Funds (Unlimited Minting)**: The attacker can mint arbitrary amounts of APT, inflating supply and devaluing the currency [9](#0-8) 

2. **Consensus/Safety Violations**: By forcing version upgrades without consensus, the attacker can break validator agreement and cause chain splits [10](#0-9) 

3. **Governance Bypass**: All on-chain governance is circumvented, violating the Governance Integrity invariant

**Affected Networks:**
- All testnets using `GenesisInfo` (NOT mainnet, which uses separate `MainnetGenesisInfo`)
- All devnets using `GenesisInfo`  
- All custom/private chains using `GenesisInfo`

**Mainnet Protection**: Mainnet uses `MainnetGenesisInfo` which correctly sets `is_test: false` and uses `encode_aptos_mainnet_genesis_transaction` that asserts test mode is disabled [11](#0-10) [12](#0-11) 

## Likelihood Explanation

**High Likelihood** for the following reasons:

1. **Configuration Exists But Is Ignored**: The `is_test` field exists in configuration files, indicating operators expect to control this behavior [13](#0-12) 

2. **Key Compromise Scenarios**: 
   - Genesis keys for testnets/devnets may be less securely managed than mainnet
   - Keys may be shared across multiple operators
   - Keys could be compromised through supply chain attacks, insider threats, or system breaches

3. **Defense-in-Depth Violation**: Even if genesis operators are trusted, security principles dictate that test privileges should not exist in production environments

4. **Silent Failure**: Operators configuring `is_test: false` receive no warning that their configuration is being ignored

## Recommendation

**Fix**: Replace the hardcoded `is_test: true` on line 145 with `self.is_test` to respect the configured value:

```rust
fn generate_genesis_txn(&self) -> Transaction {
    aptos_vm_genesis::encode_genesis_transaction(
        self.root_key.clone(),
        &self.validators,
        &self.framework,
        self.chain_id,
        &aptos_vm_genesis::GenesisConfiguration {
            allow_new_validators: self.allow_new_validators,
            epoch_duration_secs: self.epoch_duration_secs,
            is_test: self.is_test,  // CHANGED: Use configured value instead of hardcoded true
            min_stake: self.min_stake,
            // ... rest of configuration
        },
        &self.consensus_config,
        &self.execution_config,
        &self.gas_schedule,
    )
}
```

**Additional Hardening**:
1. Add validation that warns or fails if `is_test: true` is used for non-local chains
2. Document that `is_test: true` should ONLY be used for local development
3. Add integration tests verifying `is_test: false` genesis does not create `@core_resources` account

## Proof of Concept

**Reproduction Steps:**

1. Create a genesis configuration with `is_test: false`:
```rust
let genesis_config = GenesisConfiguration {
    is_test: false,  // Explicitly set to false for production
    // ... other config
};

let mut genesis_info = GenesisInfo::new(
    ChainId::testnet(),
    root_key,
    validators,
    framework,
    &genesis_config,
)?;
```

2. Generate the genesis transaction:
```rust
let genesis_tx = genesis_info.get_genesis();
```

3. Examine the resulting genesis transaction's write set - it will contain:
   - `@core_resources` account with `MintCapStore` resource
   - Maximum u64 APT pre-minted to `@core_resources`  
   - `SetVersionCapability` granted to `@core_resources`

4. With the root_key private key, mint unlimited APT:
```rust
// Using the Move entry function
aptos_coin::mint(
    &core_resources_signer,  // Derived from root_key
    target_address,
    u64::MAX,  // Mint maximum amount
)
```

**Validation**: Compare with mainnet genesis which correctly uses `is_test: false` and does NOT create the `@core_resources` account or grant test privileges.

## Notes

- **Mainnet is NOT affected**: This vulnerability only impacts non-mainnet chains (testnets, devnets, custom chains) that use `GenesisInfo` rather than `MainnetGenesisInfo`
- **Root cause**: Copy-paste error or incomplete refactoring where the hardcoded value was not updated when the configuration field was added
- **Severity justification**: While requiring privileged access (root_key), the combination of unlimited minting and governance bypass qualifies as Critical per Aptos bug bounty criteria

### Citations

**File:** crates/aptos-genesis/src/lib.rs (L107-107)
```rust
            is_test: genesis_config.is_test,
```

**File:** crates/aptos-genesis/src/lib.rs (L136-166)
```rust
    fn generate_genesis_txn(&self) -> Transaction {
        aptos_vm_genesis::encode_genesis_transaction(
            self.root_key.clone(),
            &self.validators,
            &self.framework,
            self.chain_id,
            &aptos_vm_genesis::GenesisConfiguration {
                allow_new_validators: self.allow_new_validators,
                epoch_duration_secs: self.epoch_duration_secs,
                is_test: true,
                min_stake: self.min_stake,
                min_voting_threshold: self.min_voting_threshold,
                max_stake: self.max_stake,
                recurring_lockup_duration_secs: self.recurring_lockup_duration_secs,
                required_proposer_stake: self.required_proposer_stake,
                rewards_apy_percentage: self.rewards_apy_percentage,
                voting_duration_secs: self.voting_duration_secs,
                voting_power_increase_limit: self.voting_power_increase_limit,
                employee_vesting_start: 1663456089,
                employee_vesting_period_duration: 5 * 60, // 5 minutes
                initial_features_override: self.initial_features_override.clone(),
                randomness_config_override: self.randomness_config_override.clone(),
                jwk_consensus_config_override: self.jwk_consensus_config_override.clone(),
                initial_jwks: self.initial_jwks.clone(),
                keyless_groth16_vk: self.keyless_groth16_vk.clone(),
            },
            &self.consensus_config,
            &self.execution_config,
            &self.gas_schedule,
        )
    }
```

**File:** aptos-move/vm-genesis/src/lib.rs (L143-143)
```rust
    assert!(!genesis_config.is_test, "This is mainnet!");
```

**File:** aptos-move/vm-genesis/src/lib.rs (L312-321)
```rust
    if genesis_config.is_test {
        initialize_core_resources_and_aptos_coin(
            &mut session,
            &module_storage,
            &mut traversal_context,
            core_resources_key,
        );
    } else {
        initialize_aptos_coin(&mut session, &module_storage, &mut traversal_context);
    }
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_coin.move (L73-89)
```text
    public(friend) fun configure_accounts_for_test(
        aptos_framework: &signer,
        core_resources: &signer,
        mint_cap: MintCapability<AptosCoin>,
    ) {
        system_addresses::assert_aptos_framework(aptos_framework);

        // Mint the core resource account AptosCoin for gas so it can execute system transactions.
        let coins = coin::mint<AptosCoin>(
            18446744073709551615,
            &mint_cap,
        );
        coin::deposit<AptosCoin>(signer::address_of(core_resources), coins);

        move_to(core_resources, MintCapStore { mint_cap });
        move_to(core_resources, Delegations { inner: vector::empty() });
    }
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_coin.move (L93-108)
```text
    public entry fun mint(
        account: &signer,
        dst_addr: address,
        amount: u64,
    ) acquires MintCapStore {
        let account_addr = signer::address_of(account);

        assert!(
            exists<MintCapStore>(account_addr),
            error::not_found(ENO_CAPABILITIES),
        );

        let mint_cap = &borrow_global<MintCapStore>(account_addr).mint_cap;
        let coins_minted = coin::mint<AptosCoin>(amount, mint_cap);
        coin::deposit<AptosCoin>(dst_addr, coins_minted);
    }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/version.move (L41-53)
```text
    public entry fun set_version(account: &signer, major: u64) acquires Version {
        assert!(exists<SetVersionCapability>(signer::address_of(account)), error::permission_denied(ENOT_AUTHORIZED));
        chain_status::assert_genesis();

        let old_major = borrow_global<Version>(@aptos_framework).major;
        assert!(old_major < major, error::invalid_argument(EINVALID_MAJOR_VERSION_NUMBER));

        let config = borrow_global_mut<Version>(@aptos_framework);
        config.major = major;

        // Need to trigger reconfiguration so validator nodes can sync on the updated version.
        reconfiguration::reconfigure();
    }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/version.move (L81-84)
```text
    fun initialize_for_test(core_resources: &signer) {
        system_addresses::assert_core_resource(core_resources);
        move_to(core_resources, SetVersionCapability {});
    }
```

**File:** crates/aptos/src/genesis/mod.rs (L291-291)
```rust
            is_test: layout.is_test,
```

**File:** aptos-move/framework/aptos-framework/sources/genesis.move (L169-172)
```text
        let core_resources = account::create_account(@core_resources);
        account::rotate_authentication_key_internal(&core_resources, core_resources_auth_key);
        aptos_account::register_apt(&core_resources); // registers APT store
        aptos_coin::configure_accounts_for_test(aptos_framework, &core_resources, mint_cap);
```

**File:** crates/aptos-genesis/src/mainnet.rs (L131-131)
```rust
                is_test: false,
```

**File:** crates/aptos-genesis/src/builder.rs (L429-429)
```rust
    pub is_test: bool,
```
