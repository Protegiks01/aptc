# Audit Report

## Title
Precision Loss in Nested Vector JSON Conversion Causes Silent Data Corruption

## Summary
The `ArgWithType::to_json()` function in `crates/aptos/src/move_tool/mod.rs` fails to preserve precision for large integer types (u64, u128, u256, i64, i128, i256) when serializing nested vectors (depth ≥ 2) to JSON. Valid BCS-encoded data is silently corrupted during conversion, as values exceeding 2^53 lose precision when represented as JSON numbers instead of strings.

## Finding Description
The codebase implements special handling to convert large integer types to strings when serializing to JSON, specifically to avoid IEEE 754 double precision limitations (±2^53 range). However, this protection is only applied to scalar values (vector depth 0) and single-level vectors (depth 1). [1](#0-0) 

For scalar values and depth-1 vectors, the code correctly converts large integers to strings: [2](#0-1) [3](#0-2) 

However, for vector depths 2 through 7, the special handling is completely absent: [4](#0-3) 

This causes `serde_json::to_value()` to serialize u64/u128/u256 values directly as JSON numbers. When these JSON values are parsed by standard JSON parsers (browsers, Node.js, REST clients), they are interpreted as IEEE 754 doubles, causing precision loss for values outside the safe integer range.

**Attack Path:**

1. User calls view function via CLI: `aptos move view --function-id 0x1::module::func --args 'u64:[[9007199254740993]]'`
2. Input is parsed into `ArgWithType` with `_ty: U64`, `_vector_depth: 2`, valid BCS data
3. Conversion to `ViewRequest` calls `to_json()` at line 2575 in types.rs: [5](#0-4) 

4. The `to_json()` method calls `bcs_value_to_json::<u64>()` which matches depth 2, directly serializing as JSON number
5. Value 9007199254740993 (2^53 + 1) becomes corrupted in JSON
6. API receives corrupted value, view function executes with wrong arguments
7. User receives incorrect view result and may construct transactions based on corrupted data

## Impact Explanation
This qualifies as **Medium Severity** under Aptos bug bounty criteria: "Limited funds loss or manipulation."

The vulnerability enables silent data corruption in view function calls, which can lead to:
- Users receiving incorrect on-chain data queries
- Construction of transactions with wrong parameters based on corrupted view results
- Potential financial loss when users act on incorrect data (e.g., wrong balance checks, incorrect price calculations)

While view functions themselves are read-only and don't affect consensus, their results influence user decisions and transaction construction. A user relying on a view call to check staking rewards, token balances, or governance voting thresholds could suffer financial loss if the returned data is corrupted.

## Likelihood Explanation
**High Likelihood** - This bug will trigger whenever:
1. A view function accepts nested vector arguments (Vec<Vec<T>> or deeper)
2. The inner type is a large integer (u64, u128, u256, i64, i128, i256)
3. Any value in the nested structure exceeds 2^53 (common for token amounts in wei/satoshi units)

Given that u64 is commonly used for amounts, timestamps, and indices in Move contracts, and that modern DeFi applications frequently deal with values exceeding 2^53 (e.g., 10^18 wei = 1 ETH equivalent), this bug will manifest regularly in production usage.

## Recommendation
Extend the string conversion logic to handle all vector depths consistently. Modify the `bcs_value_to_json` function to recursively convert large integer types to strings regardless of nesting depth:

```rust
// For depths 2-7, add specialized handling for large integer types
2 => match self._ty.clone() {
    FunctionArgType::U64 => {
        let data: Vec<Vec<u64>> = bcs::from_bytes(&self.arg)?;
        let converted: Vec<Vec<String>> = data.iter()
            .map(|inner| inner.iter().map(ToString::to_string).collect())
            .collect();
        serde_json::to_value(converted).map_err(|err| CliError::UnexpectedError(err.to_string()))
    },
    // Repeat for U128, U256, I64, I128, I256
    _ => serde_json::to_value(bcs::from_bytes::<Vec<Vec<T>>>(&self.arg)?)
        .map_err(|err| CliError::UnexpectedError(err.to_string())),
},
// Apply same pattern to depths 3-7
```

Alternatively, implement a generic recursive solution that automatically converts large integers at any depth.

## Proof of Concept

```rust
use aptos::move_tool::{ArgWithType, FunctionArgType};
use move_core_types::int256::U256;

#[test]
fn test_precision_loss_nested_vectors() {
    // Create nested vector with value exceeding 2^53
    let large_value: u64 = 9_007_199_254_740_993; // 2^53 + 1
    let nested_data: Vec<Vec<u64>> = vec![vec![large_value]];
    
    // Create ArgWithType with proper BCS encoding
    let arg = ArgWithType {
        _ty: FunctionArgType::U64,
        _vector_depth: 2,
        arg: bcs::to_bytes(&nested_data).unwrap(),
    };
    
    // Convert to JSON
    let json_value = arg.to_json().unwrap();
    
    // Parse back as number - this would happen in JSON parser
    let parsed_number = json_value[0][0].as_f64().unwrap() as u64;
    
    // Verify precision loss occurred
    assert_ne!(parsed_number, large_value, 
        "Precision loss: {} became {} after JSON round-trip", 
        large_value, parsed_number);
}

#[test]
fn test_u256_nested_precision_loss() {
    let large_u256 = U256::from(u128::MAX);
    let nested: Vec<Vec<U256>> = vec![vec![large_u256]];
    
    let arg = ArgWithType {
        _ty: FunctionArgType::U256,
        _vector_depth: 2,
        arg: bcs::to_bytes(&nested).unwrap(),
    };
    
    let json = arg.to_json().unwrap();
    
    // JSON cannot represent U256 accurately as number
    // This will either lose precision or fail parsing
    assert!(json[0][0].is_number(), "U256 incorrectly serialized as number");
}
```

## Notes
This vulnerability affects all large integer types (u64, u128, u256, i64, i128, i256) when used in nested vector structures of depth 2 or greater. The issue is particularly severe for u256 values which cannot be accurately represented in JSON numbers at all. The bug breaks the documented behavior implied by the code comments explaining why string conversion is necessary for these types, but this protection was incompletely implemented.

### Citations

**File:** crates/aptos/src/move_tool/mod.rs (L2794-2796)
```rust
                // Why specially handle u64/u128/u256/i64/i128/i256:
                // many JSON parsers (including browsers and Node.js) treat numbers as Double Precision Floating Point (IEEE 754)
                // which can only safely represent integers range: $-(2^{53} - 1)$ to $2^{53} - 1$
```

**File:** crates/aptos/src/move_tool/mod.rs (L2797-2820)
```rust
                FunctionArgType::U64 => {
                    serde_json::to_value(bcs::from_bytes::<u64>(&self.arg)?.to_string())
                        .map_err(|err| CliError::UnexpectedError(err.to_string()))
                },
                FunctionArgType::U128 => {
                    serde_json::to_value(bcs::from_bytes::<u128>(&self.arg)?.to_string())
                        .map_err(|err| CliError::UnexpectedError(err.to_string()))
                },
                FunctionArgType::U256 => {
                    serde_json::to_value(bcs::from_bytes::<U256>(&self.arg)?.to_string())
                        .map_err(|err| CliError::UnexpectedError(err.to_string()))
                },
                FunctionArgType::I64 => {
                    serde_json::to_value(bcs::from_bytes::<i64>(&self.arg)?.to_string())
                        .map_err(|err| CliError::UnexpectedError(err.to_string()))
                },
                FunctionArgType::I128 => {
                    serde_json::to_value(bcs::from_bytes::<i128>(&self.arg)?.to_string())
                        .map_err(|err| CliError::UnexpectedError(err.to_string()))
                },
                FunctionArgType::I256 => {
                    serde_json::to_value(bcs::from_bytes::<I256>(&self.arg)?.to_string())
                        .map_err(|err| CliError::UnexpectedError(err.to_string()))
                },
```

**File:** crates/aptos/src/move_tool/mod.rs (L2827-2868)
```rust
                FunctionArgType::U64 => {
                    let u64_vector: Vec<u64> = bcs::from_bytes::<Vec<u64>>(&self.arg)?;
                    let string_vector: Vec<String> =
                        u64_vector.iter().map(ToString::to_string).collect();
                    serde_json::to_value(string_vector)
                        .map_err(|err| CliError::UnexpectedError(err.to_string()))
                },
                FunctionArgType::U128 => {
                    let u128_vector: Vec<u128> = bcs::from_bytes::<Vec<u128>>(&self.arg)?;
                    let string_vector: Vec<String> =
                        u128_vector.iter().map(ToString::to_string).collect();
                    serde_json::to_value(string_vector)
                        .map_err(|err| CliError::UnexpectedError(err.to_string()))
                },
                FunctionArgType::U256 => {
                    let u256_vector: Vec<U256> = bcs::from_bytes::<Vec<U256>>(&self.arg)?;
                    let string_vector: Vec<String> =
                        u256_vector.iter().map(ToString::to_string).collect();
                    serde_json::to_value(string_vector)
                        .map_err(|err| CliError::UnexpectedError(err.to_string()))
                },
                FunctionArgType::I64 => {
                    let i64_vector: Vec<i64> = bcs::from_bytes::<Vec<i64>>(&self.arg)?;
                    let string_vector: Vec<String> =
                        i64_vector.iter().map(ToString::to_string).collect();
                    serde_json::to_value(string_vector)
                        .map_err(|err| CliError::UnexpectedError(err.to_string()))
                },
                FunctionArgType::I128 => {
                    let i128_vector: Vec<i128> = bcs::from_bytes::<Vec<i128>>(&self.arg)?;
                    let string_vector: Vec<String> =
                        i128_vector.iter().map(ToString::to_string).collect();
                    serde_json::to_value(string_vector)
                        .map_err(|err| CliError::UnexpectedError(err.to_string()))
                },
                FunctionArgType::I256 => {
                    let i256_vector: Vec<I256> = bcs::from_bytes::<Vec<I256>>(&self.arg)?;
                    let string_vector: Vec<String> =
                        i256_vector.iter().map(ToString::to_string).collect();
                    serde_json::to_value(string_vector)
                        .map_err(|err| CliError::UnexpectedError(err.to_string()))
                },
```

**File:** crates/aptos/src/move_tool/mod.rs (L2875-2895)
```rust
            2 => serde_json::to_value(bcs::from_bytes::<Vec<Vec<T>>>(&self.arg)?)
                .map_err(|err| CliError::UnexpectedError(err.to_string())),

            3 => serde_json::to_value(bcs::from_bytes::<Vec<Vec<Vec<T>>>>(&self.arg)?)
                .map_err(|err| CliError::UnexpectedError(err.to_string())),

            4 => serde_json::to_value(bcs::from_bytes::<Vec<Vec<Vec<Vec<T>>>>>(&self.arg)?)
                .map_err(|err| CliError::UnexpectedError(err.to_string())),
            5 => serde_json::to_value(bcs::from_bytes::<Vec<Vec<Vec<Vec<Vec<T>>>>>>(&self.arg)?)
                .map_err(|err| CliError::UnexpectedError(err.to_string())),
            6 => serde_json::to_value(bcs::from_bytes::<Vec<Vec<Vec<Vec<Vec<Vec<T>>>>>>>(
                &self.arg,
            )?)
            .map_err(|err| CliError::UnexpectedError(err.to_string())),
            7 => serde_json::to_value(bcs::from_bytes::<Vec<Vec<Vec<Vec<Vec<Vec<Vec<T>>>>>>>>(
                &self.arg,
            )?)
            .map_err(|err| CliError::UnexpectedError(err.to_string())),
            depth => Err(CliError::UnexpectedError(format!(
                "Vector of depth {depth} is overly nested"
            ))),
```

**File:** crates/aptos/src/common/types.rs (L2563-2577)
```rust
impl TryInto<ViewRequest> for EntryFunctionArguments {
    type Error = CliError;

    fn try_into(self) -> Result<ViewRequest, Self::Error> {
        let entry_function_args = self.check_input_style()?;
        let function_id: MemberId = (&entry_function_args).try_into()?;
        Ok(ViewRequest {
            function: EntryFunctionId {
                module: function_id.module_id.into(),
                name: function_id.member_id.into(),
            },
            type_arguments: entry_function_args.type_arg_vec.type_args,
            arguments: entry_function_args.arg_vec.try_into()?,
        })
    }
```
