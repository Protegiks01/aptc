# Audit Report

## Title
BatchKind Validation Bypass Allows Malicious Validators to Create Semantically Invalid Batches

## Summary
The `Batch::verify()` method in `consensus/src/quorum_store/types.rs` fails to validate that the `batch_kind` field in `BatchInfoExt` is consistent with the actual transaction payload types. This allows a malicious validator to create batches with `BatchKind::Encrypted` containing only normal (non-encrypted) transactions, which pass validation and can be signed by honest validators, violating the semantic integrity of the batch type system.

## Finding Description
The vulnerability exists in the batch verification logic where the `batch_kind` field is not validated against the actual transaction contents. [1](#0-0) 

The verification method checks that encrypted transactions are not supported (line 285-287), but does not validate that:
- If `batch_kind` is `BatchKind::Normal`, all transactions must be non-encrypted (implicitly satisfied)
- If `batch_kind` is `BatchKind::Encrypted`, all transactions must be encrypted (NOT validated)

The `BatchKind` enum is defined with two variants: [2](#0-1) 

The `batch_kind` is stored in `ExtraBatchInfo` and included in the `BatchInfoExt::V2` variant: [3](#0-2) 

Since `BatchInfoExt` derives `BCSCryptoHash`, the `batch_kind` field is part of the cryptographic hash, meaning the same transactions with different `batch_kind` values produce different digests.

**Attack Path:**
1. Malicious validator calls `Batch::new_v2()` with `batch_kind = BatchKind::Encrypted` but provides only normal transactions [4](#0-3) 

2. The batch is broadcast via network and received by honest validators [5](#0-4) 

3. Honest validators verify the batch using `Batch::verify()`, which passes because it only checks `!txn.payload().is_encrypted_variant()` returns true for normal transactions

4. Honest validators sign this semantically invalid batch, creating `SignedBatchInfo` objects

5. Signatures are aggregated into a `ProofOfStore` containing the incorrect `batch_kind`

## Impact Explanation
**Severity: Medium**

This vulnerability allows a malicious validator to:

1. **Hash Malleability**: Create multiple valid batches with identical transactions but different cryptographic hashes by manipulating `batch_kind`, potentially causing consensus confusion when validators receive different versions of the "same" batch.

2. **Semantic Integrity Violation**: Force honest validators to sign batches with incorrect type annotations, violating the invariant that `batch_kind` should accurately reflect transaction contents.

3. **Forward Compatibility Risk**: When encrypted transaction support is enabled (currently blocked at line 285-287), existing code may check `batch_kind` to determine processing logic, leading to incorrect handling of batches with mismatched types.

This meets **Medium Severity** criteria as it represents a "significant protocol violation" that creates state inconsistencies in batch type semantics, though it does not currently cause direct fund loss or immediate consensus failure.

## Likelihood Explanation
**Likelihood: Medium**

- Requires a malicious validator (privileged position but not requiring collusion)
- Easy to exploit: simply call `Batch::new_v2()` with incorrect `batch_kind` parameter  
- Currently mitigated because honest validators always use `BatchKind::Normal` via batch generator: [6](#0-5) 

However, when encrypted transaction support is enabled, this validation gap will become exploitable for causing processing errors.

## Recommendation
Add validation in `Batch::verify()` to ensure `batch_kind` is consistent with transaction payload types:

```rust
pub fn verify(&self) -> anyhow::Result<()> {
    ensure!(
        self.payload.author() == self.author(),
        "Payload author doesn't match the info"
    );
    ensure!(
        self.payload.hash() == *self.digest(),
        "Payload hash doesn't match the digest"
    );
    ensure!(
        self.payload.num_txns() as u64 == self.num_txns(),
        "Payload num txns doesn't match batch info"
    );
    ensure!(
        self.payload.num_bytes() as u64 == self.num_bytes(),
        "Payload num bytes doesn't match batch info"
    );
    
    // NEW VALIDATION: Check batch_kind consistency
    let has_encrypted = self.payload.txns().iter().any(|txn| txn.payload().is_encrypted_variant());
    if let Some(kind) = self.batch_kind() {
        match kind {
            BatchKind::Normal => {
                ensure!(
                    !has_encrypted,
                    "Batch marked as Normal but contains encrypted transactions"
                );
            },
            BatchKind::Encrypted => {
                ensure!(
                    has_encrypted,
                    "Batch marked as Encrypted but contains no encrypted transactions"
                );
            }
        }
    }
    
    for txn in self.payload.txns() {
        ensure!(
            txn.gas_unit_price() >= self.gas_bucket_start(),
            "Payload gas unit price doesn't match batch info"
        );
        ensure!(
            !txn.payload().is_encrypted_variant(),
            "Encrypted transaction is not supported yet"
        );
    }
    Ok(())
}
```

Add helper method to extract `batch_kind` from `BatchInfoExt`:
```rust
impl<T: TBatchInfo> Batch<T> {
    fn batch_kind(&self) -> Option<&BatchKind> {
        match &self.batch_info {
            BatchInfoExt::V2 { extra, .. } => Some(&extra.batch_kind),
            _ => None
        }
    }
}
```

## Proof of Concept
```rust
#[cfg(test)]
mod tests {
    use super::*;
    use aptos_types::transaction::SignedTransaction;
    use aptos_types::PeerId;
    
    #[test]
    fn test_batch_kind_validation_bypass() {
        // Create normal transactions (non-encrypted)
        let txns: Vec<SignedTransaction> = create_test_transactions(); // Helper function
        let batch_author = PeerId::random();
        
        // Malicious validator creates batch with ENCRYPTED kind but normal transactions
        let malicious_batch = Batch::new_v2(
            BatchId::new(1),
            txns.clone(),
            0, // epoch
            1000, // expiration
            batch_author,
            0, // gas_bucket_start
            BatchKind::Encrypted, // WRONG: transactions are not encrypted
        );
        
        // Verification should fail but currently passes
        let result = malicious_batch.verify();
        assert!(result.is_ok(), "Batch with mismatched BatchKind passed verification!");
        
        // For comparison: honest batch with correct BatchKind
        let honest_batch = Batch::new_v2(
            BatchId::new(1),
            txns,
            0,
            1000,
            batch_author,
            0,
            BatchKind::Normal, // CORRECT
        );
        
        // Both batches have different hashes despite identical transactions
        assert_ne!(
            malicious_batch.digest(),
            honest_batch.digest(),
            "Batches with different BatchKind should have different digests"
        );
    }
}
```

## Notes
This vulnerability is currently of limited immediate impact because `batch_kind` is not used in processing decisions. However, it violates critical semantic invariants and creates a validation gap that will become exploitable when encrypted transaction support is fully enabled. The issue requires validator access but is easily exploitable once that access is obtained.

### Citations

**File:** consensus/src/quorum_store/types.rs (L207-229)
```rust
    pub fn new_v2(
        batch_id: BatchId,
        payload: Vec<SignedTransaction>,
        epoch: u64,
        expiration: u64,
        batch_author: PeerId,
        gas_bucket_start: u64,
        batch_kind: BatchKind,
    ) -> Self {
        let payload = BatchPayload::new(batch_author, payload);
        let batch_info = BatchInfoExt::new_v2(
            batch_author,
            batch_id,
            epoch,
            expiration,
            payload.hash(),
            payload.num_txns() as u64,
            payload.num_bytes() as u64,
            gas_bucket_start,
            batch_kind,
        );
        Self::new_generic(batch_info, payload)
    }
```

**File:** consensus/src/quorum_store/types.rs (L262-290)
```rust
    pub fn verify(&self) -> anyhow::Result<()> {
        ensure!(
            self.payload.author() == self.author(),
            "Payload author doesn't match the info"
        );
        ensure!(
            self.payload.hash() == *self.digest(),
            "Payload hash doesn't match the digest"
        );
        ensure!(
            self.payload.num_txns() as u64 == self.num_txns(),
            "Payload num txns doesn't match batch info"
        );
        ensure!(
            self.payload.num_bytes() as u64 == self.num_bytes(),
            "Payload num bytes doesn't match batch info"
        );
        for txn in self.payload.txns() {
            ensure!(
                txn.gas_unit_price() >= self.gas_bucket_start(),
                "Payload gas unit price doesn't match batch info"
            );
            ensure!(
                !txn.payload().is_encrypted_variant(),
                "Encrypted transaction is not supported yet"
            );
        }
        Ok(())
    }
```

**File:** consensus/consensus-types/src/proof_of_store.rs (L230-254)
```rust
    pub fn new_v2(
        author: PeerId,
        batch_id: BatchId,
        epoch: u64,
        expiration: u64,
        digest: HashValue,
        num_txns: u64,
        num_bytes: u64,
        gas_bucket_start: u64,
        kind: BatchKind,
    ) -> Self {
        Self::V2 {
            info: BatchInfo::new(
                author,
                batch_id,
                epoch,
                expiration,
                digest,
                num_txns,
                num_bytes,
                gas_bucket_start,
            ),
            extra: ExtraBatchInfo { batch_kind: kind },
        }
    }
```

**File:** consensus/consensus-types/src/proof_of_store.rs (L342-348)
```rust
#[derive(
    Clone, Debug, Deserialize, Serialize, CryptoHasher, BCSCryptoHash, PartialEq, Eq, Hash,
)]
pub enum BatchKind {
    Normal,
    Encrypted,
}
```

**File:** consensus/src/quorum_store/batch_coordinator.rs (L173-245)
```rust
    pub(crate) async fn handle_batches_msg(
        &mut self,
        author: PeerId,
        batches: Vec<Batch<BatchInfoExt>>,
    ) {
        if let Err(e) = self.ensure_max_limits(&batches) {
            error!("Batch from {}: {}", author, e);
            counters::RECEIVED_BATCH_MAX_LIMIT_FAILED.inc();
            return;
        }

        let Some(batch) = batches.first() else {
            error!("Empty batch received from {}", author.short_str().as_str());
            return;
        };

        // Filter the transactions in the batches. If any transaction is rejected,
        // the message will be dropped, and all batches will be rejected.
        if self.transaction_filter_config.is_enabled() {
            let transaction_filter = &self.transaction_filter_config.batch_transaction_filter();
            for batch in batches.iter() {
                for transaction in batch.txns() {
                    if !transaction_filter.allows_transaction(
                        batch.batch_info().batch_id(),
                        batch.author(),
                        batch.digest(),
                        transaction,
                    ) {
                        error!(
                            "Transaction {}, in batch {}, from {}, was rejected by the filter. Dropping {} batches!",
                            transaction.committed_hash(),
                            batch.batch_info().batch_id(),
                            author.short_str().as_str(),
                            batches.len()
                        );
                        counters::RECEIVED_BATCH_REJECTED_BY_FILTER.inc();
                        return;
                    }
                }
            }
        }

        let approx_created_ts_usecs = batch
            .info()
            .expiration()
            .saturating_sub(self.batch_expiry_gap_when_init_usecs);

        if approx_created_ts_usecs > 0 {
            observe_batch(
                approx_created_ts_usecs,
                batch.author(),
                BatchStage::RECEIVED,
            );
        }

        let mut persist_requests = vec![];
        for batch in batches.into_iter() {
            // TODO: maybe don't message batch generator if the persist is unsuccessful?
            if let Err(e) = self
                .sender_to_batch_generator
                .send(BatchGeneratorCommand::RemoteBatch(batch.clone()))
                .await
            {
                warn!("Failed to send batch to batch generator: {}", e);
            }
            persist_requests.push(batch.into());
        }
        counters::RECEIVED_BATCH_COUNT.inc_by(persist_requests.len() as u64);
        if author != self.my_peer_id {
            counters::RECEIVED_REMOTE_BATCH_COUNT.inc_by(persist_requests.len() as u64);
        }
        self.persist_and_send_digests(persist_requests, approx_created_ts_usecs);
    }
```

**File:** consensus/src/quorum_store/batch_generator.rs (L190-201)
```rust
        if self.config.enable_batch_v2 {
            // TODO(ibalajiarun): Specify accurate batch kind
            let batch_kind = BatchKind::Normal;
            Batch::new_v2(
                batch_id,
                txns,
                self.epoch,
                expiry_time,
                self.my_peer_id,
                bucket_start,
                batch_kind,
            )
```
