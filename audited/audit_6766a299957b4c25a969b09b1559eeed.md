# Audit Report

## Title
Validator Private Keys Exported Without Encryption During Genesis and Backup Operations

## Summary
The `PrivateIdentity` structure containing critical validator keys (account, consensus, and network private keys) is serialized and exported to disk in plaintext YAML format without any encryption mechanism. This creates operational security risks when validators back up their keys as recommended by official documentation.

## Finding Description

The `PrivateIdentity` struct stores all critical validator cryptographic material in a single structure. [1](#0-0) 

When keys are generated during genesis or validator setup, they are written to disk as plaintext YAML files. [2](#0-1) 

The `write_yaml` function performs no encryption, only standard YAML serialization. [3](#0-2) 

The CLI command that generates validator keys also writes plaintext YAML files using `write_to_user_only_file`, which only sets file permissions to 0o600 but applies no encryption. [4](#0-3) 

The `write_to_user_only_file` function implementation confirms it only sets Unix file permissions without encrypting the content. [5](#0-4) 

Official deployment documentation explicitly instructs validators to "Backup your key files somewhere safe" but provides no guidance on encryption. [6](#0-5) 

Even the `OnDiskStorage` backend used for secure storage explicitly documents it provides "no security guarantees (e.g., encryption before writing to disk)" and "should not be used in production." [7](#0-6) 

The `OnDiskStorage` implementation confirms plaintext JSON storage without encryption. [8](#0-7) 

Even the Vault backup mechanism uses only base64 encoding (not encryption) for key export. [9](#0-8) 

**Attack Scenario:**
1. Validator generates keys using `aptos genesis generate-keys`
2. Keys saved to `private-keys.yaml` in plaintext YAML format
3. Validator backs up these files (as instructed) to cloud storage, USB drives, or network shares
4. Attacker compromises backup location through cloud account breach, stolen device, or insider access
5. Attacker decodes plaintext YAML and obtains all validator keys
6. Attacker can steal staking rewards, perform malicious consensus actions, or damage validator reputation

## Impact Explanation

**Medium Severity** - This meets the "Limited funds loss or manipulation" criteria because:

- Compromised `account_private_key` allows theft of validator staking rewards
- Compromised `consensus_private_key` enables malicious consensus participation attributed to legitimate validator
- Compromised network keys enable validator impersonation attacks
- All validators following official documentation are affected during key generation and backup procedures
- No built-in mechanism exists for password-encrypted key export

However, it does not reach High/Critical severity because:
- Requires access to backup files or filesystem (not purely remote exploitation)
- File permissions (0o600) provide some protection on live systems
- Production deployments can use Vault (though genesis ceremony still uses files)

## Likelihood Explanation

**High Likelihood** of occurrence because:

1. **Universal exposure**: ALL validators must generate keys using this mechanism during genesis
2. **Documentation mandates backup**: Official docs explicitly tell validators to backup these files
3. **No encryption guidance**: Documentation provides zero guidance on encrypting backups
4. **Common attack vectors** for backup compromise:
   - Cloud storage breaches (common in industry)
   - Stolen devices (laptops, USB drives)
   - Compromised backup servers
   - Insider threats (system administrators)
   - Forensic recovery from disposed hardware
5. **No alternative**: No built-in encrypted export functionality exists as an alternative

The combination of mandatory backup requirements with no encryption mechanism makes plaintext key exposure highly likely during normal operations.

## Recommendation

**Immediate Fix**: Implement password-based encrypted key export/import functionality

**Option 1**: Add encrypted keystore format (similar to Ethereum's keystore format):
- Use scrypt/PBKDF2 for password derivation
- Encrypt private keys with AES-256-GCM
- Store encrypted keys in JSON/YAML with salt and cipher parameters
- Implement in `aptos genesis generate-keys --encrypted` with password prompt

**Option 2**: Integrate GPG encryption into key export workflow:
- Add `--encrypt` flag to key generation commands
- Prompt for GPG recipient or password
- Automatically encrypt output files before writing
- Provide decryption utility for key restoration

**Option 3**: Enhanced documentation:
- Add prominent warnings about plaintext key storage
- Provide step-by-step guide for encrypting backups using standard tools
- Include example scripts for secure backup procedures

**Minimum Required Action**: Update documentation to explicitly warn about plaintext keys and provide encryption guidance for backups.

## Proof of Concept

```bash
# Step 1: Generate validator keys (creates plaintext files)
aptos genesis generate-keys --output-dir ./validator

# Step 2: Examine the plaintext private keys
cat ./validator/private-keys.yaml
# Output shows:
# account_address: "0x..."
# account_private_key: "<plaintext Ed25519 key>"
# consensus_private_key: "<plaintext BLS12-381 key>"
# full_node_network_private_key: "<plaintext x25519 key>"
# validator_network_private_key: "<plaintext x25519 key>"

# Step 3: Simulate backup compromise
# Attacker gains access to backup file and can directly read all keys
# No password, no encryption - immediate key compromise

# Step 4: Verify OnDiskStorage also stores plaintext
# Check any OnDiskStorage JSON file to confirm plaintext key storage

# Impact: All private keys exposed in plaintext to anyone with file access
```

**Notes**

While file permissions (0o600) provide basic protection on the live system, this protection is completely bypassed during backup operations. The documentation explicitly instructs validators to backup these files, but the lack of encryption guidance means most validators will store plaintext backups in cloud storage or other locations vulnerable to compromise. This represents a systemic operational security risk affecting all validators in the network.

The exclusion of Vault as a production alternative doesn't fully mitigate the risk, as the initial genesis ceremony and key generation process still requires handling plaintext keys, and not all validators may have Vault infrastructure configured during initial setup.

### Citations

**File:** crates/aptos-genesis/src/keys.rs (L14-22)
```rust
/// Type for serializing private keys file
#[derive(Deserialize, Serialize)]
pub struct PrivateIdentity {
    pub account_address: AccountAddress,
    pub account_private_key: Ed25519PrivateKey,
    pub consensus_private_key: bls12381::PrivateKey,
    pub full_node_network_private_key: x25519::PrivateKey,
    pub validator_network_private_key: x25519::PrivateKey,
}
```

**File:** crates/aptos-genesis/src/builder.rs (L144-148)
```rust
            // Write identities in files
            write_yaml(val_identity_file.as_path(), &validator_identity)?;
            write_yaml(vfn_identity_file.as_path(), &vfn_identity)?;
            write_yaml(private_identity_file.as_path(), &private_identity)?;
            write_yaml(public_identity_file.as_path(), &public_identity)?;
```

**File:** crates/aptos-genesis/src/builder.rs (L418-421)
```rust
fn write_yaml<T: Serialize>(path: &Path, object: &T) -> anyhow::Result<()> {
    File::create(path)?.write_all(serde_yaml::to_string(object)?.as_bytes())?;
    Ok(())
}
```

**File:** crates/aptos/src/genesis/keys.rs (L82-97)
```rust
        write_to_user_only_file(
            private_keys_file.as_path(),
            PRIVATE_KEYS_FILE,
            to_yaml(&private_identity)?.as_bytes(),
        )?;
        write_to_user_only_file(
            public_keys_file.as_path(),
            PUBLIC_KEYS_FILE,
            to_yaml(&public_identity)?.as_bytes(),
        )?;
        write_to_user_only_file(
            validator_file.as_path(),
            VALIDATOR_FILE,
            to_yaml(&validator_blob)?.as_bytes(),
        )?;
        write_to_user_only_file(vfn_file.as_path(), VFN_FILE, to_yaml(&vfn_blob)?.as_bytes())?;
```

**File:** crates/aptos/src/common/utils.rs (L224-246)
```rust
pub fn write_to_user_only_file(path: &Path, name: &str, bytes: &[u8]) -> CliTypedResult<()> {
    let mut opts = OpenOptions::new();
    #[cfg(unix)]
    opts.mode(0o600);
    write_to_file_with_opts(path, name, bytes, &mut opts)
}

/// Write a `&[u8]` to a file with the given options
pub fn write_to_file_with_opts(
    path: &Path,
    name: &str,
    bytes: &[u8],
    opts: &mut OpenOptions,
) -> CliTypedResult<()> {
    let mut file = opts
        .write(true)
        .create(true)
        .truncate(true)
        .open(path)
        .map_err(|e| CliError::IO(name.to_string(), e))?;
    file.write_all(bytes)
        .map_err(|e| CliError::IO(name.to_string(), e))
}
```

**File:** terraform/aptos-node/aws/README.md (L108-108)
```markdown
    This will create three files: `private-keys.yaml`, `validator-identity.yaml`, `validator-full-node-identity.yaml` for you. Backup your key files somewhere safe, this is important for you to establish ownership of your node, and it will be used to claim your rewards later if eligible. Very important!!
```

**File:** secure/storage/README.md (L37-42)
```markdown
- `OnDisk`: Similar to InMemory, the OnDisk secure storage implementation provides another
useful testing implementation: an on-disk storage engine, where the storage backend is
implemented using a single file written to local disk. In a similar fashion to the in-memory
storage, on-disk should not be used in production environments as it provides no security
guarantees (e.g., encryption before writing to disk). Moreover, OnDisk storage does not
currently support concurrent data accesses.
```

**File:** secure/storage/src/on_disk.rs (L53-70)
```rust
    fn read(&self) -> Result<HashMap<String, Value>, Error> {
        let mut file = File::open(&self.file_path)?;
        let mut contents = String::new();
        file.read_to_string(&mut contents)?;
        if contents.is_empty() {
            return Ok(HashMap::new());
        }
        let data = serde_json::from_str(&contents)?;
        Ok(data)
    }

    fn write(&self, data: &HashMap<String, Value>) -> Result<(), Error> {
        let contents = serde_json::to_vec(data)?;
        let mut file = File::create(self.temp_path.path())?;
        file.write_all(&contents)?;
        fs::rename(&self.temp_path, &self.file_path)?;
        Ok(())
    }
```

**File:** secure/storage/vault/src/lib.rs (L778-810)
```rust
    pub fn new(key: &Ed25519PrivateKey) -> Self {
        let mut key_bytes = key.to_bytes().to_vec();
        let pub_key_bytes = key.public_key().to_bytes();
        key_bytes.extend(pub_key_bytes);

        let now = chrono::Utc::now();
        let time_as_str = now.to_rfc3339();

        let info = KeyBackupInfo {
            key: Some(base64::encode(key_bytes)),
            public_key: Some(base64::encode(pub_key_bytes)),
            creation_time: now.timestamp_subsec_millis(),
            time: time_as_str.clone(),
            ..Default::default()
        };

        let mut key_backup = Self {
            policy: KeyBackupPolicy {
                exportable: true,
                min_decryption_version: 1,
                latest_version: 1,
                archive_version: 1,
                backup_type: 2,
                backup_info: BackupInfo {
                    time: time_as_str,
                    version: 1,
                },
                ..Default::default()
            },
        };
        key_backup.policy.keys.insert(1, info);
        key_backup
    }
```
