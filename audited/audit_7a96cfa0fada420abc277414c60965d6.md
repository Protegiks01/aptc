# Audit Report

## Title
Delta History Merge Creates Impossible Overflow-Underflow Constraint Window

## Summary
The `offset_and_merge_history()` function in `delta_math.rs` can produce a merged delta history where the overflow and underflow boundaries create contradictory constraints that no base value can satisfy. This occurs because the function validates overflow and underflow boundaries independently against achieved deltas, but never checks whether the boundaries themselves are mutually compatible.

## Finding Description

The `offset_and_merge_history()` function merges two delta histories from parallel transaction executions in Aptos aggregators. [1](#0-0) 

The function performs two critical validation checks at the end: [2](#0-1) 

These checks ensure:
1. The overflow boundary (`min_overflow_positive_delta`) is strictly greater than the achieved positive delta
2. The underflow boundary (`max_underflow_negative_delta`) is strictly greater than the achieved negative delta

However, these checks are **independent** and do not validate the interaction between overflow and underflow boundaries themselves.

For a merged history to be valid against a base value `B`, the following constraints must be satisfied (from `validate_against_base_value`): [3](#0-2) 

When both `min_overflow` and `max_underflow` exist, the constraints become:
- From overflow: `B > max_value - min_overflow`
- From underflow: `B < max_underflow`

For any valid `B` to exist: **`max_value - min_overflow < max_underflow`**, which is equivalent to **`min_overflow + max_underflow > max_value`**

This condition is **never checked** in `offset_and_merge_history()`, allowing creation of merged histories where no valid base value exists.

**Attack Scenario:**

1. Transaction T1 executes with `prev_delta = Negative(20)` and creates `prev_history`:
   - Valid for base values: `0 ≤ B < 30`
   - Sets `max_underflow_negative_delta = Some(30)`

2. Transaction T2 executes speculatively and creates `next_history`:
   - Valid for base values: `B > 50` (since overflow occurs at +50 with max=100)
   - Sets `min_overflow_positive_delta = Some(50)`

3. When merged with `prev_delta = Negative(20)`:
   - `new_min_overflow = 50 + (-20) = 30`
   - `new_max_underflow = 30` (from prev_history)
   - Both checks pass: `30 > 0` ✓ and `30 > 0` ✓

4. **Result:** Merged history requires `B > 70` (from `B + 30 > 100`) AND `B < 30` simultaneously - **IMPOSSIBLE!**

The merged history will **always** fail `validate_against_base_value()` for any base value, yet the merge itself succeeds without error.

## Impact Explanation

**Severity: Medium** (up to $10,000 per Aptos Bug Bounty)

This vulnerability causes:

1. **State Inconsistency**: Merged histories that can never be materialized create inconsistent transaction execution states
2. **Transaction Execution Failures**: Transactions that should succeed independently fail when merged during parallel execution
3. **Re-execution Overhead**: Failed materializations force unnecessary transaction re-execution, degrading throughput
4. **Potential Consensus Issues**: Different validators may handle these impossible histories differently, risking state root divergence

This breaks the **State Consistency** invariant (atomic and verifiable state transitions) and the **Deterministic Execution** invariant (identical state roots for identical blocks).

While not directly causing fund loss or network partition, this creates opportunities for griefing attacks and can impact network performance and reliability.

## Likelihood Explanation

**Likelihood: Medium**

This vulnerability requires:
- Parallel transaction execution on the same aggregator
- Specific history patterns (one with overflow boundary, one with underflow boundary)
- Appropriate offset delta between transactions

These conditions occur naturally in high-throughput scenarios where multiple transactions interact with popular aggregators (e.g., token supply counters, fee accumulators). An attacker could deliberately craft transactions to trigger this condition by:
1. Understanding the current aggregator state
2. Submitting parallel transactions with calculated deltas
3. Exploiting the merge logic during transaction sequencing

The attack is feasible without special privileges and could be automated for repeated exploitation.

## Recommendation

Add an additional validation check in `offset_and_merge_history()` after line 305 to verify that overflow and underflow boundaries don't create impossible constraints:

```rust
// After line 305, add:
if let (Some(min_overflow), Some(max_underflow)) = (new_min_overflow, new_max_underflow) {
    // For a valid base value to exist, we need:
    // max_value - min_overflow < max_underflow
    // Equivalently: min_overflow + max_underflow > max_value
    if min_overflow.saturating_add(max_underflow) <= max_value {
        return Err(
            DelayedFieldsSpeculativeError::DeltaHistoryMergeAchievedAndFailureOverlap {
                achieved: SignedU128::Positive(max_value.saturating_sub(min_overflow)),
                overflow: SignedU128::Negative(max_underflow),
            },
        );
    }
}
```

This ensures that when both overflow and underflow boundaries exist, their intersection creates a non-empty valid range for base values.

## Proof of Concept

```rust
#[test]
fn test_impossible_overflow_underflow_window() {
    use crate::delta_math::DeltaHistory;
    use crate::bounded_math::SignedU128;
    
    let max_value = 100u128;
    
    // prev_history: valid for base in [0, 30)
    let prev_history = DeltaHistory {
        max_achieved_positive_delta: 0,
        min_achieved_negative_delta: 0,
        min_overflow_positive_delta: None,
        max_underflow_negative_delta: Some(30), // underflow at -30
    };
    
    let prev_delta = SignedU128::Negative(20);
    
    // next_history: valid for base > 50 (since base + 50 > 100)
    let next_history = DeltaHistory {
        max_achieved_positive_delta: 0,
        min_achieved_negative_delta: 0,
        min_overflow_positive_delta: Some(50), // overflow at +50
        max_underflow_negative_delta: None,
    };
    
    // Merge should succeed according to current logic
    let merged = next_history.offset_and_merge_history(
        &prev_delta,
        &prev_history,
        max_value,
    ).expect("Merge should succeed");
    
    // Merged history has min_overflow = 30 and max_underflow = 30
    assert_eq!(merged.min_overflow_positive_delta, Some(30));
    assert_eq!(merged.max_underflow_negative_delta, Some(30));
    
    // But NO base value can satisfy this!
    // Need: B > 100 - 30 = 70 (from overflow)
    //   AND: B < 30 (from underflow)
    // This is impossible: 70 < B < 30
    
    // Verify that ALL base values fail validation
    for base in 0..=100 {
        let result = merged.validate_against_base_value(base, max_value);
        assert!(result.is_err(), 
            "Base {} should fail validation but succeeded", base);
    }
    
    // This merged history can NEVER be materialized!
}
```

## Notes

This vulnerability specifically affects the aggregator merge logic used during parallel transaction execution. The missing validation allows histories that pass individual boundary checks but create impossible combined constraints. The fix requires checking that `min_overflow + max_underflow > max_value` when both boundaries exist, ensuring the valid base value range is non-empty.

### Citations

**File:** aptos-move/aptos-aggregator/src/delta_math.rs (L148-197)
```rust
    pub fn validate_against_base_value(
        &self,
        base_value: u128,
        max_value: u128,
    ) -> Result<(), DelayedFieldsSpeculativeError> {
        let math = BoundedMath::new(max_value);
        // We need to make sure the following 4 conditions are satisified.
        //     base_value + max_achieved_positive_delta <= self.max_value
        //     base_value >= min_achieved_negative_delta
        //     base_value + min_overflow_positive_delta > self.max_value
        //     base_value < max_underflow_negative_delta
        math.unsigned_add(base_value, self.max_achieved_positive_delta)
            .map_err(|_e| DelayedFieldsSpeculativeError::DeltaApplication {
                base_value,
                max_value,
                delta: SignedU128::Positive(self.max_achieved_positive_delta),
                reason: DeltaApplicationFailureReason::Overflow,
            })?;
        math.unsigned_subtract(base_value, self.min_achieved_negative_delta)
            .map_err(|_e| DelayedFieldsSpeculativeError::DeltaApplication {
                base_value,
                max_value,
                delta: SignedU128::Negative(self.min_achieved_negative_delta),
                reason: DeltaApplicationFailureReason::Underflow,
            })?;

        if let Some(min_overflow_positive_delta) = self.min_overflow_positive_delta {
            if base_value <= max_value - min_overflow_positive_delta {
                return Err(DelayedFieldsSpeculativeError::DeltaApplication {
                    base_value,
                    max_value,
                    delta: SignedU128::Positive(min_overflow_positive_delta),
                    reason: DeltaApplicationFailureReason::ExpectedOverflow,
                });
            }
        }

        if let Some(max_underflow_negative_delta) = self.max_underflow_negative_delta {
            if base_value >= max_underflow_negative_delta {
                return Err(DelayedFieldsSpeculativeError::DeltaApplication {
                    base_value,
                    max_value,
                    delta: SignedU128::Negative(max_underflow_negative_delta),
                    reason: DeltaApplicationFailureReason::ExpectedUnderflow,
                });
            }
        }

        Ok(())
    }
```

**File:** aptos-move/aptos-aggregator/src/delta_math.rs (L248-313)
```rust
    pub fn offset_and_merge_history(
        &self,
        prev_delta: &SignedU128,
        prev_history: &Self,
        max_value: u128,
    ) -> Result<DeltaHistory, DelayedFieldsSpeculativeError> {
        let math = BoundedMath::new(max_value);

        let new_min_overflow = Self::offset_and_merge_min_overflow(
            &self.min_overflow_positive_delta,
            prev_delta,
            &prev_history.min_overflow_positive_delta,
            &math,
        )?;
        // max_underflow is identical to min_overflow, except that we offset in the opposite direction.
        let new_max_underflow = Self::offset_and_merge_min_overflow(
            &self.max_underflow_negative_delta,
            &prev_delta.minus(),
            &prev_history.max_underflow_negative_delta,
            &math,
        )?;

        // new_max_achieved = max(prev_max_achieved, max_achieved + prev_delta)
        // When adjusting max_achieved, if underflow - than the other is bigger,
        // but if overflow - we fail the merge, as we cannot successfully achieve
        // delta larger than max_value.
        let new_max_achieved = Self::offset_and_merge_max_achieved(
            self.max_achieved_positive_delta,
            prev_delta,
            prev_history.max_achieved_positive_delta,
            &math,
        )?;

        // new_min_achieved = max(prev_min_achieved, min_achieved - prev_delta)
        // Same as above, except for offsetting in the opposite direction.
        let new_min_achieved = Self::offset_and_merge_max_achieved(
            self.min_achieved_negative_delta,
            &prev_delta.minus(),
            prev_history.min_achieved_negative_delta,
            &math,
        )?;

        if new_min_overflow.is_some_and(|v| v <= new_max_achieved) {
            return Err(
                DelayedFieldsSpeculativeError::DeltaHistoryMergeAchievedAndFailureOverlap {
                    achieved: SignedU128::Positive(new_max_achieved),
                    overflow: SignedU128::Positive(new_min_overflow.unwrap()),
                },
            );
        }
        if new_max_underflow.is_some_and(|v| v <= new_min_achieved) {
            return Err(
                DelayedFieldsSpeculativeError::DeltaHistoryMergeAchievedAndFailureOverlap {
                    achieved: SignedU128::Negative(new_min_achieved),
                    overflow: SignedU128::Negative(new_max_underflow.unwrap()),
                },
            );
        }

        Ok(Self {
            max_achieved_positive_delta: new_max_achieved,
            min_achieved_negative_delta: new_min_achieved,
            min_overflow_positive_delta: new_min_overflow,
            max_underflow_negative_delta: new_max_underflow,
        })
    }
```
