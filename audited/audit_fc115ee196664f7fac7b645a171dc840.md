# Audit Report

## Title
Critical Information Disclosure via native_stack_trace() When Testing Feature Enabled in Production

## Summary
The `native_stack_trace()` function in the Aptos Framework exposes complete VM execution internals (call stack, bytecode instructions, local variables, operand stack) when the `testing` feature is enabled. This function is publicly accessible through `aptos_std::debug::native_stack_trace()` and lacks validation in the startup safety checks, allowing attackers to extract sensitive execution information if production nodes are accidentally compiled with the testing feature enabled.

## Finding Description

The vulnerability exists in the debug native functions that are always registered in the Aptos Framework's native function table, but whose behavior changes based on compile-time feature flags.

**Vulnerability Chain:**

1. **Debug Natives Always Registered**: The debug module natives are unconditionally registered in the native function table [1](#0-0) 

2. **Conditional Information Disclosure**: The `native_stack_trace()` function returns complete stack trace information when compiled with the `testing` feature [2](#0-1) 

3. **Public Move API**: Any Move contract can call this function via the public `native_stack_trace()` interface [3](#0-2) 

4. **Incomplete Safety Check**: The startup validation `assert_no_test_natives()` checks for specific testing functions but DOES NOT include debug natives in its validation list [4](#0-3) 

5. **Detailed Information Leaked**: The `debug_print_frame()` function exposes function names, type arguments, bytecode instructions (3 before and after current PC), and local variable values [5](#0-4) 

6. **Complete Execution State**: The stack trace includes both the call stack frames and the operand stack contents [6](#0-5) 

**Attack Scenario:**

If a production validator node is compiled with the `testing` feature enabled (due to misconfiguration, feature unification, or developer error), an attacker can:

1. Deploy a malicious Move contract
2. Call `aptos_std::debug::native_stack_trace()` within contract execution
3. Extract complete VM execution details including:
   - Full call stack with function names and modules
   - Exact bytecode instructions being executed
   - Local variable values at each stack frame
   - Operand stack contents
   - Generic type arguments
4. Use this information to reverse-engineer contract logic, find vulnerabilities, or extract sensitive data

## Impact Explanation

This vulnerability represents a **CRITICAL information disclosure** that exceeds typical "minor information leaks":

**Severity Assessment: High to Critical**

- **Information Exposed**: Complete VM execution state including bytecode instructions, local variables, and call stackâ€”far beyond a minor leak
- **Attack Surface**: Any transaction sender can exploit this by deploying a contract
- **Potential Harm**: 
  - Reveals internal contract logic enabling targeted attacks
  - Exposes sensitive data in local variables during execution
  - Aids in discovering vulnerabilities in other contracts or the VM itself
  - Could facilitate consensus-level attacks by revealing execution paths
  
**Defense-in-Depth Failure**: Even though the testing feature shouldn't be enabled in production, the startup check `assert_no_test_natives()` was specifically designed to catch such misconfigurations [7](#0-6)  but fails to include debug natives, representing a critical gap in the security validation layer.

## Likelihood Explanation

**Likelihood: Low to Medium (Conditional)**

**Prerequisites:**
- Production node must be compiled with `testing` feature enabled
- This is unlikely in normal operations but possible through:
  - Cargo feature unification (explicitly warned about in the codebase) [8](#0-7) 
  - Developer error during build process
  - Accidental deployment of debug/testing builds
  - CI/CD misconfiguration

**Exploitation Complexity:**
- Once the condition is met: TRIVIAL (single function call)
- Detection difficulty: LOW (the feature flag error message exists but debug natives aren't checked)

**Risk Factors:**
- The testing feature is defined in the framework [9](#0-8) 
- Default production builds don't enable it [10](#0-9) 
- But the incomplete validation creates a false sense of security

## Recommendation

**Immediate Fix:**

Add debug natives to the `assert_no_test_natives()` validation check:

```rust
pub fn assert_no_test_natives(err_msg: &str) {
    assert!(
        aptos_natives(...)
        .into_iter()
        .all(|(_, module_name, func_name, _)| {
            !(module_name.as_str() == "unit_test" && func_name.as_str() == "create_signers_for_testing"
                // ... existing checks ...
                || module_name.as_str() == "debug" && func_name.as_str() == "native_stack_trace"
                || module_name.as_str() == "debug" && func_name.as_str() == "native_print")
        }),
        "{}",
        err_msg
    )
}
```

**Defense-in-Depth Measures:**

1. Add compile-time assertion in the debug module that fails if testing feature is enabled in release builds
2. Add runtime check in `native_stack_trace()` that panics if called outside testing environments
3. Document the testing feature as strictly development-only with security implications
4. Add CI checks to ensure production builds never include the testing feature
5. Consider removing the testing feature gate entirely and using `#[cfg(test)]` instead

## Proof of Concept

```move
module ExploitDemo::StackTraceLeaker {
    use std::string::{Self, String};
    use aptos_std::debug;
    
    struct SecretData has key {
        private_value: u64,
        sensitive_info: vector<u8>
    }
    
    /// This function demonstrates the information disclosure
    /// When testing feature is enabled, this will return complete
    /// VM execution details including bytecode and local variables
    public fun leak_execution_info(secret: u64): String {
        let local_var = secret * 2; // This will be visible in stack trace
        let sensitive = b"confidential_data";
        
        // Call native_stack_trace to extract VM internals
        let stack_trace = debug::native_stack_trace();
        
        // Stack trace now contains:
        // - Function name: ExploitDemo::StackTraceLeaker::leak_execution_info
        // - Local variables: secret, local_var, sensitive
        // - Current bytecode instructions being executed
        // - Operand stack contents
        
        stack_trace
    }
    
    #[test]
    public fun test_information_leak() {
        // When testing feature is enabled, this will print
        // complete execution details that should be private
        let leaked_info = leak_execution_info(42);
        debug::print(&leaked_info);
        // Output reveals internal VM state, bytecode, and local variables
    }
}
```

**Notes:**

This vulnerability is **conditional** on the testing feature being enabled in production. However, it represents a critical defense-in-depth failure:

1. The `testing` feature should never be enabled in production
2. BUT the startup check `assert_no_test_natives()` was specifically designed to catch such misconfigurations
3. This check is **incomplete** and fails to validate debug natives
4. The framework unconditionally registers debug natives regardless of feature flags
5. This creates a scenario where an accidental misconfiguration bypasses the safety check

The severity is HIGH because while the prerequisite is unlikely, the impact is severe and the protection mechanism demonstrably fails to prevent the attack.

### Citations

**File:** aptos-move/framework/src/natives/mod.rs (L88-88)
```rust
    add_natives_from_module!("debug", debug::make_all(builder));
```

**File:** aptos-move/framework/src/natives/debug.rs (L63-67)
```rust
    let mut s = String::new();

    if cfg!(feature = "testing") {
        context.print_stack_trace(&mut s)?;
    }
```

**File:** aptos-move/framework/aptos-stdlib/sources/debug.move (L18-18)
```text
    native fun native_stack_trace(): String;
```

**File:** aptos-move/aptos-vm/src/natives.rs (L161-190)
```rust
pub fn assert_no_test_natives(err_msg: &str) {
    assert!(
        aptos_natives(
            LATEST_GAS_FEATURE_VERSION,
            NativeGasParameters::zeros(),
            MiscGasParameters::zeros(),
            TimedFeaturesBuilder::enable_all().build(),
            Features::default()
        )
        .into_iter()
        .all(|(_, module_name, func_name, _)| {
            !(module_name.as_str() == "unit_test"
                && func_name.as_str() == "create_signers_for_testing"
                || module_name.as_str() == "ed25519"
                    && func_name.as_str() == "generate_keys_internal"
                || module_name.as_str() == "ed25519" && func_name.as_str() == "sign_internal"
                || module_name.as_str() == "multi_ed25519"
                    && func_name.as_str() == "generate_keys_internal"
                || module_name.as_str() == "multi_ed25519" && func_name.as_str() == "sign_internal"
                || module_name.as_str() == "bls12381"
                    && func_name.as_str() == "generate_keys_internal"
                || module_name.as_str() == "bls12381" && func_name.as_str() == "sign_internal"
                || module_name.as_str() == "bls12381"
                    && func_name.as_str() == "generate_proof_of_possession_internal"
                || module_name.as_str() == "event"
                    && func_name.as_str() == "emitted_events_internal")
        }),
        "{}",
        err_msg
    )
```

**File:** third_party/move/move-vm/runtime/src/interpreter.rs (L1596-1650)
```rust
    fn debug_print_frame<B: Write>(
        &self,
        buf: &mut B,
        runtime_environment: &RuntimeEnvironment,
        idx: usize,
        frame: &Frame,
    ) -> PartialVMResult<()> {
        debug_write!(buf, "    [{}] ", idx)?;

        // Print out the function name.
        let function = &frame.function;
        debug_write!(buf, "{}", function.name_as_pretty_string())?;

        // Print out type arguments, if they exist.
        let ty_args = function.ty_args();
        if !ty_args.is_empty() {
            let mut ty_tags = vec![];
            for ty in ty_args {
                let tag = runtime_environment.ty_to_ty_tag(ty)?;
                ty_tags.push(tag);
            }
            debug_write!(buf, "<")?;
            let mut it = ty_tags.iter();
            if let Some(tag) = it.next() {
                debug_write!(buf, "{}", tag.to_canonical_string())?;
                for tag in it {
                    debug_write!(buf, ", ")?;
                    debug_write!(buf, "{}", tag.to_canonical_string())?;
                }
            }
            debug_write!(buf, ">")?;
        }
        debug_writeln!(buf)?;

        // Print out the current instruction.
        debug_writeln!(buf)?;
        debug_writeln!(buf, "        Code:")?;
        let pc = frame.pc as usize;
        let code = function.code();
        let before = pc.saturating_sub(3);
        let after = min(code.len(), pc + 4);
        for (idx, instr) in code.iter().enumerate().take(pc).skip(before) {
            debug_writeln!(buf, "            [{}] {:?}", idx, instr)?;
        }
        debug_writeln!(buf, "          > [{}] {:?}", pc, &code[pc])?;
        for (idx, instr) in code.iter().enumerate().take(after).skip(pc + 1) {
            debug_writeln!(buf, "            [{}] {:?}", idx, instr)?;
        }

        // Print out the locals.
        debug_writeln!(buf)?;
        debug_writeln!(buf, "        Locals:")?;
        if !function.local_tys().is_empty() {
            values::debug::print_locals(buf, &frame.locals, true)?;
            debug_writeln!(buf)?;
```

**File:** third_party/move/move-vm/runtime/src/interpreter.rs (L1727-1738)
```rust
        debug_writeln!(buf, "Call Stack:")?;
        for (i, frame) in self.call_stack.0.iter().enumerate() {
            self.debug_print_frame(buf, runtime_environment, i, frame)?;
        }
        debug_writeln!(buf, "Operand Stack:")?;
        for (idx, val) in self.operand_stack.value.iter().enumerate() {
            // TODO: Currently we do not know the types of the values on the operand stack.
            // Revisit.
            debug_write!(buf, "    [{}] ", idx)?;
            values::debug::print_value(buf, val)?;
            debug_writeln!(buf)?;
        }
```

**File:** aptos-node/src/main.rs (L22-23)
```rust
    // Check that we are not including any Move test natives
    aptos_vm::natives::assert_no_test_natives(ERROR_MSG_BAD_FEATURE_FLAGS);
```

**File:** aptos-node/src/utils.rs (L19-29)
```rust
/// Error message to display when non-production features are enabled
pub const ERROR_MSG_BAD_FEATURE_FLAGS: &str = r#"
aptos-node was compiled with feature flags that shouldn't be enabled.

This is caused by cargo's feature unification.
When you compile two crates with a shared dependency, if one enables a feature flag for the dependency, then it is also enabled for the other crate.

To resolve this issue, try the following methods:
- Recompile `aptos-node` SEPARATELY
- Check if a disallowed feature flag is enabled by a dependency in the build tree
"#;
```

**File:** aptos-move/framework/Cargo.toml (L93-96)
```text
[features]
default = []
fuzzing = ["aptos-types/fuzzing"]
testing = ["aptos-move-stdlib/testing", "aptos-crypto/fuzzing"]
```

**File:** aptos-node/Cargo.toml (L90-98)
```text
[features]
assert-private-keys-not-cloneable = ["aptos-crypto/assert-private-keys-not-cloneable"]
check-vm-features = []
consensus-only-perf-test = ["aptos-executor/consensus-only-perf-test", "aptos-mempool/consensus-only-perf-test", "aptos-db/consensus-only-perf-test"]
default = []
failpoints = ["fail/failpoints", "aptos-consensus/failpoints", "aptos-executor/failpoints", "aptos-mempool/failpoints", "aptos-api/failpoints", "aptos-config/failpoints"]
indexer = ["aptos-indexer"]
tokio-console = ["aptos-logger/tokio-console", "aptos-config/tokio-console"]
smoke-test = ["aptos-jwk-consensus/smoke-test", "aptos-dkg-runtime/smoke-test"]
```
