# Audit Report

## Title
Insecure Temporary Directory Permissions Allow Local Validator Key Theft During Configuration Generation

## Summary
The `TempPath::create_as_dir()` method creates temporary directories without setting secure Unix permissions, defaulting to world-readable permissions (0755). When `generate_random_config_with_template()` uses these directories to store validator configurations containing private keys, local attackers on the same machine can steal consensus keys and network identity keys during initialization.

## Finding Description

The vulnerability exists in the interaction between two components:

1. **Insecure Directory Creation**: [1](#0-0) 
   
   The `create_as_dir()` method uses `fs::DirBuilder::new().create()` without setting Unix-specific permissions. On Unix systems, this creates directories with permissions 0777 modified by the process umask (typically resulting in 0755 permissions: rwxr-xr-x), making them world-readable.

2. **Sensitive Data Storage**: [2](#0-1) 
   
   The `generate_random_config_with_template()` function creates a temporary directory for validator configuration data and generates sensitive cryptographic material including BLS12-381 consensus keys and x25519 network identity keys.

3. **Insecure File Persistence**: [3](#0-2) 
   
   When configurations are saved using `write_file()`, it uses `File::create()` without setting secure permissions, defaulting to 0644 (readable by all users).

**Attack Flow:**

1. Validator operator runs configuration generation (genesis setup, validator swarm creation, or testing) on a shared machine
2. `TempPath::new()` creates a path in `/tmp` with a random hex name [4](#0-3) 
3. `create_as_dir()` creates the directory with insecure 0755 permissions
4. Validator private keys are generated and stored in the `NodeConfig` [5](#0-4) 
5. If `save_to_path()` is called, keys are serialized to YAML files with 0644 permissions [6](#0-5) 
6. Local attacker monitors `/tmp`, detects new directories, and reads configuration files containing validator private keys

The vulnerability violates the **Cryptographic Correctness** invariant: "BLS signatures, VRF, and hash operations must be secure" and the **Access Control** invariant: "System addresses and validator keys must be protected."

The codebase already demonstrates awareness of secure file permissions for confidential data: [7](#0-6) 

However, this pattern is not applied to temporary directories or configuration file writes.

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos bug bounty criteria for the following reasons:

1. **Significant Protocol Violation**: Theft of validator consensus keys (BLS12-381 private keys) allows an attacker to forge block signatures and votes, potentially enabling consensus attacks or validator impersonation.

2. **Network Identity Compromise**: Theft of network identity keys (x25519 private keys) allows an attacker to impersonate validators in the P2P network, intercepting or manipulating consensus messages.

3. **Broad Attack Surface**: The insecure `TempPath` pattern is used throughout the codebase for temporary file operations [8](#0-7) , affecting validator initialization, genesis ceremonies, and development workflows.

4. **Real-World Scenarios**: While primarily affecting test/development environments, this impacts:
   - Genesis ceremony preparations on shared infrastructure
   - Validator setup on cloud VMs with multiple users
   - Development environments where multiple developers share systems
   - Staging and testnet environments

## Likelihood Explanation

The likelihood is **Medium-to-High** because:

1. **Attacker Requirements**: Only requires unprivileged local access to the same machine - no validator-level privileges needed.

2. **Common Scenarios**: Developers and operators frequently work on shared infrastructure (cloud VMs, CI/CD systems, development servers) where multiple user accounts exist.

3. **Exploitation Complexity**: Low - simply monitoring `/tmp` for new directories and reading files is trivial for any local user.

4. **Detection Window**: The temp directory exists from creation until process termination or explicit cleanup, providing an adequate window for exploitation.

5. **Production Impact**: While `generate_random_config_with_template()` is primarily used in testing contexts, the underlying `TempPath` pattern is used throughout the codebase and could be exploited in production-adjacent scenarios.

## Recommendation

Implement secure Unix permissions for temporary directories by modifying `create_as_dir()` to use mode 0700 (owner-only access):

```rust
pub fn create_as_dir(&self) -> io::Result<()> {
    let mut builder = fs::DirBuilder::new();
    
    #[cfg(unix)]
    {
        use std::os::unix::fs::DirBuilderExt;
        builder.mode(0o700);
    }
    
    builder.create(self.path())?;
    Ok(())
}
```

Similarly, update `write_file()` in the `PersistableConfig` trait to use secure permissions for configuration files containing sensitive data:

```rust
fn write_file<P: AsRef<Path>>(serialized_config: Vec<u8>, output_file: P) -> Result<(), Error> {
    let mut opts = std::fs::OpenOptions::new();
    opts.write(true).create(true).truncate(true);
    
    #[cfg(unix)]
    {
        use std::os::unix::fs::OpenOptionsExt;
        opts.mode(0o600);
    }
    
    let mut file = opts.open(output_file.as_ref())
        .map_err(|e| Error::IO(output_file.as_ref().to_str().unwrap().to_string(), e))?;
    file.write_all(&serialized_config)
        .map_err(|e| Error::IO(output_file.as_ref().to_str().unwrap().to_string(), e))?;
    
    Ok(())
}
```

## Proof of Concept

```rust
// PoC demonstrating the vulnerability
// File: config/src/config/test_temp_permissions.rs

#[cfg(test)]
mod temp_permission_test {
    use crate::config::NodeConfig;
    use rand::{rngs::StdRng, SeedableRng};
    use std::fs;
    use std::os::unix::fs::PermissionsExt;

    #[test]
    fn test_temp_directory_permissions_vulnerability() {
        // Generate a random validator config (as an attacker would observe)
        let mut rng = StdRng::from_seed([42u8; 32]);
        let template = NodeConfig::get_default_validator_config();
        let node_config = NodeConfig::generate_random_config_with_template(&template, &mut rng);
        
        // Check the temporary directory permissions
        let temp_dir = node_config.get_data_dir();
        let metadata = fs::metadata(temp_dir).expect("Failed to read temp dir metadata");
        let permissions = metadata.permissions();
        let mode = permissions.mode();
        
        // Extract permission bits (last 9 bits)
        let perm_bits = mode & 0o777;
        
        println!("Temp directory: {:?}", temp_dir);
        println!("Permissions: {:o}", perm_bits);
        
        // VULNERABILITY: Directory is world-readable (group and others have read+execute)
        // Expected: 0o700 (rwx------)
        // Actual: 0o755 (rwxr-xr-x) with default umask
        assert!(perm_bits & 0o077 != 0, 
            "VULNERABILITY CONFIRMED: Temp directory has insecure permissions {:o}, \
             should be 0o700 but allows other users to access", perm_bits);
        
        // Demonstrate that config with keys could be saved to this insecure directory
        if let Some(consensus_key) = &node_config.consensus.safety_rules.test.as_ref().unwrap().consensus_key {
            println!("Consensus key present in config: exposed in insecure temp directory");
        }
        
        // If save_to_path() were called here, private keys would be written 
        // to YAML files in this world-readable directory
    }
}
```

**Exploitation Steps:**

1. Attacker runs: `watch -n 0.1 'ls -la /tmp | grep -E "^drwxr"'` to monitor for new world-readable directories
2. Victim runs validator setup using `generate_random_config_with_template()`
3. Attacker identifies new temp directory and runs: `find /tmp/[hex_name] -type f -exec cat {} \;`
4. Attacker extracts validator private keys from YAML configuration files
5. Attacker can now impersonate the validator in consensus

## Notes

This vulnerability is particularly concerning because:

1. The codebase already demonstrates awareness of secure permissions through `save_to_file_confidential()` but doesn't apply this pattern consistently
2. The insecure `TempPath` pattern affects multiple components beyond just validator configuration
3. Many development and testing workflows occur on shared infrastructure where this is directly exploitable
4. The fix is straightforward and follows established Unix security best practices (CWE-732: Incorrect Permission Assignment for Critical Resource)

### Citations

**File:** crates/aptos-temppath/src/lib.rs (L32-48)
```rust
    pub fn new() -> Self {
        Self::new_with_temp_dir(std::env::temp_dir())
    }

    /// Create new, uninitialized temporary path in the specified directory.
    pub fn new_with_temp_dir(temp_dir: PathBuf) -> Self {
        let mut temppath = temp_dir;
        let mut rng = rand::thread_rng();
        let mut bytes = [0_u8; 16];
        rng.fill_bytes(&mut bytes);
        temppath.push(hex::encode(bytes));

        TempPath {
            path_buf: temppath,
            persist: false,
        }
    }
```

**File:** crates/aptos-temppath/src/lib.rs (L67-71)
```rust
    pub fn create_as_dir(&self) -> io::Result<()> {
        let builder = fs::DirBuilder::new();
        builder.create(self.path())?;
        Ok(())
    }
```

**File:** config/src/config/node_config.rs (L171-181)
```rust
    pub fn save_to_path<P: AsRef<Path>>(&mut self, output_path: P) -> Result<(), Error> {
        // Save the execution config to disk.
        let output_dir = RootPath::new(&output_path);
        self.execution.save_to_path(&output_dir)?;

        // Write the node config to disk. Note: this must be called last
        // as calling save_to_path() on subconfigs may change fields.
        self.save_config(&output_path)?;

        Ok(())
    }
```

**File:** config/src/config/node_config.rs (L224-226)
```rust
            let mut safety_rules_test_config = SafetyRulesTestConfig::new(peer_id);
            safety_rules_test_config.random_consensus_key(rng);
            node_config.consensus.safety_rules.test = Some(safety_rules_test_config);
```

**File:** config/src/config/node_config.rs (L238-249)
```rust
        // Create and use a temp directory for the data directory
        let temp_dir = TempPath::new();
        temp_dir.create_as_dir().unwrap_or_else(|error| {
            panic!(
                "Failed to create a temporary directory at {}! Error: {:?}",
                temp_dir.path().display(),
                error
            )
        });
        node_config.set_data_dir(temp_dir.path().to_path_buf());

        node_config
```

**File:** config/src/config/persistable_config.rs (L43-49)
```rust
    fn write_file<P: AsRef<Path>>(serialized_config: Vec<u8>, output_file: P) -> Result<(), Error> {
        let mut file = File::create(output_file.as_ref())
            .map_err(|e| Error::IO(output_file.as_ref().to_str().unwrap().to_string(), e))?;
        file.write_all(&serialized_config)
            .map_err(|e| Error::IO(output_file.as_ref().to_str().unwrap().to_string(), e))?;

        Ok(())
```

**File:** crates/aptos/src/common/types.rs (L1083-1089)
```rust
    /// Save to the `output_file` with restricted permissions (mode 0600)
    pub fn save_to_file_confidential(&self, name: &str, bytes: &[u8]) -> CliTypedResult<()> {
        let mut opts = OpenOptions::new();
        #[cfg(unix)]
        opts.mode(0o600);
        write_to_file_with_opts(self.output_file.as_path(), name, bytes, &mut opts)
    }
```
