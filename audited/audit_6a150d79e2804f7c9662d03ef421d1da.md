# Audit Report

## Title
Hidden Panic Calls in Database Initialization Code Path Can Crash Debugger Tools on Corrupted Database States

## Summary
The `check_range_proof.rs` debugger tool uses a `?` operator chain that hides multiple `unwrap()` and `expect()` calls in the database initialization path. When storage sharding is enabled or when reading the latest ledger info fails, these panics bypass proper error handling, causing the tool to crash instead of returning informative errors.

## Finding Description

The `check_range_proof::run()` function calls `self.db_dir.open_ledger_db()?` expecting proper error propagation. However, the underlying `LedgerDb::new()` and `LedgerMetadataDb::new()` contain hidden panic calls that are not converted to `Result` errors:

**Path 1 - Always executed (both sharded and non-sharded):** [1](#0-0) 

When `LedgerMetadataDb::new()` is called, it attempts to read the latest ledger info and uses `.expect("DB read failed.")` which panics on failure instead of propagating an error.

**Path 2 - When storage sharding is enabled:** [2](#0-1) 

Multiple database opens are performed in parallel threads, each using `.unwrap()` on the result. If any database fails to open (corrupted files, missing directories, permission errors), the panic occurs inside the parallel scope. [3](#0-2) 

After parallel execution, the `Option` values are unwrapped again, which would panic if the parallel tasks failed.

The call chain from the debugger tool is: [4](#0-3) 

## Impact Explanation

This issue qualifies as **Low Severity** per the Aptos bug bounty program as a "Non-critical implementation bug." 

While this does not affect consensus, validator operation, or production code paths, it violates the error handling contract expected when using the `?` operator. The impact is limited to:

1. **Debugger/Operational Tools**: The `check_range_proof` and other db_debugger tools will crash with a panic instead of providing actionable error messages
2. **Diagnostic Difficulty**: Operators investigating database issues receive unhelpful panic traces instead of clear error messages indicating which database component failed and why
3. **Robustness**: Violates Rust best practices of avoiding panics in library code and preferring `Result` types for recoverable errors

This does NOT affect production validator nodes during normal operation, as the db_debugger tools are separate diagnostic utilities.

## Likelihood Explanation

**High likelihood** in scenarios where:
- Database corruption occurs (hardware failure, incomplete writes, storage issues)
- The debugger is run against partial or migrating database states
- Incorrect file permissions or missing database directories exist
- Storage sharding configuration mismatches occur between database creation and debugging

**Low likelihood** in normal operation, as production nodes typically have well-maintained databases and don't run debugger tools during consensus.

## Recommendation

Replace all `unwrap()` and `expect()` calls in the database initialization path with proper error propagation:

**For `LedgerMetadataDb::new()`:**
```rust
pub(super) fn new(db: Arc<DB>) -> Result<Self> {
    let latest_ledger_info = get_latest_ledger_info_in_db_impl(&db)?;
    let latest_ledger_info = ArcSwap::from(Arc::new(latest_ledger_info));

    Ok(Self {
        db,
        latest_ledger_info,
    })
}
```

**For `LedgerDb::new()` parallel opens:**
```rust
// Change spawn closures to return Result and propagate errors
let mut event_db_result = None;
s.spawn(|_| {
    event_db_result = Some(Self::open_rocksdb(...));
});
// ... after scope
let event_db_raw = Arc::new(event_db_result.unwrap()?);
```

Update the signature of `LedgerMetadataDb::new()` to return `Result<Self>` and adjust all call sites accordingly.

## Proof of Concept

```rust
// Simulate database corruption or missing files
use std::fs;
use tempfile::TempDir;

#[test]
fn test_panics_on_corrupted_db() {
    let tmp_dir = TempDir::new().unwrap();
    let db_path = tmp_dir.path();
    
    // Create minimal directory structure but with corrupted/missing DB files
    fs::create_dir_all(db_path.join("ledger_db")).unwrap();
    
    // Attempt to open ledger_db - this will panic instead of returning Err
    let result = std::panic::catch_unwind(|| {
        let db_dir = DbDir {
            db_dir: db_path.to_path_buf(),
            sharding_config: ShardingConfig { enable_storage_sharding: false },
        };
        db_dir.open_ledger_db()
    });
    
    // Expected: result should be Ok(Err(...)) for proper error handling
    // Actual: result is Err(panic) demonstrating the bug
    assert!(result.is_err(), "Should panic on corrupted DB");
}
```

**Notes**

This vulnerability is specific to the db_debugger tooling and does not affect production consensus or execution paths. The issue stems from initialization code that predates proper error handling patterns. The TODO comment at line 281 of `mod.rs` ("TODO(grao): Handle data inconsistency.") indicates awareness of this technical debt.

While marked as Low severity, fixing this issue would significantly improve the debugging experience for node operators investigating database problems and align with Rust best practices for library error handling.

### Citations

**File:** storage/aptosdb/src/ledger_db/ledger_metadata_db.rs (L43-44)
```rust
    pub(super) fn new(db: Arc<DB>) -> Self {
        let latest_ledger_info = get_latest_ledger_info_in_db_impl(&db).expect("DB read failed.");
```

**File:** storage/aptosdb/src/ledger_db/mod.rs (L183-279)
```rust
        THREAD_MANAGER.get_non_exe_cpu_pool().scope(|s| {
            s.spawn(|_| {
                let event_db_raw = Arc::new(
                    Self::open_rocksdb(
                        ledger_db_folder.join(EVENT_DB_NAME),
                        EVENT_DB_NAME,
                        &rocksdb_configs.ledger_db_config,
                        env,
                        block_cache,
                        readonly,
                    )
                    .unwrap(),
                );
                event_db = Some(EventDb::new(
                    event_db_raw.clone(),
                    EventStore::new(event_db_raw),
                ));
            });
            s.spawn(|_| {
                persisted_auxiliary_info_db = Some(PersistedAuxiliaryInfoDb::new(Arc::new(
                    Self::open_rocksdb(
                        ledger_db_folder.join(PERSISTED_AUXILIARY_INFO_DB_NAME),
                        PERSISTED_AUXILIARY_INFO_DB_NAME,
                        &rocksdb_configs.ledger_db_config,
                        env,
                        block_cache,
                        readonly,
                    )
                    .unwrap(),
                )));
            });
            s.spawn(|_| {
                transaction_accumulator_db = Some(TransactionAccumulatorDb::new(Arc::new(
                    Self::open_rocksdb(
                        ledger_db_folder.join(TRANSACTION_ACCUMULATOR_DB_NAME),
                        TRANSACTION_ACCUMULATOR_DB_NAME,
                        &rocksdb_configs.ledger_db_config,
                        env,
                        block_cache,
                        readonly,
                    )
                    .unwrap(),
                )));
            });
            s.spawn(|_| {
                transaction_auxiliary_data_db = Some(TransactionAuxiliaryDataDb::new(Arc::new(
                    Self::open_rocksdb(
                        ledger_db_folder.join(TRANSACTION_AUXILIARY_DATA_DB_NAME),
                        TRANSACTION_AUXILIARY_DATA_DB_NAME,
                        &rocksdb_configs.ledger_db_config,
                        env,
                        block_cache,
                        readonly,
                    )
                    .unwrap(),
                )))
            });
            s.spawn(|_| {
                transaction_db = Some(TransactionDb::new(Arc::new(
                    Self::open_rocksdb(
                        ledger_db_folder.join(TRANSACTION_DB_NAME),
                        TRANSACTION_DB_NAME,
                        &rocksdb_configs.ledger_db_config,
                        env,
                        block_cache,
                        readonly,
                    )
                    .unwrap(),
                )));
            });
            s.spawn(|_| {
                transaction_info_db = Some(TransactionInfoDb::new(Arc::new(
                    Self::open_rocksdb(
                        ledger_db_folder.join(TRANSACTION_INFO_DB_NAME),
                        TRANSACTION_INFO_DB_NAME,
                        &rocksdb_configs.ledger_db_config,
                        env,
                        block_cache,
                        readonly,
                    )
                    .unwrap(),
                )));
            });
            s.spawn(|_| {
                write_set_db = Some(WriteSetDb::new(Arc::new(
                    Self::open_rocksdb(
                        ledger_db_folder.join(WRITE_SET_DB_NAME),
                        WRITE_SET_DB_NAME,
                        &rocksdb_configs.ledger_db_config,
                        env,
                        block_cache,
                        readonly,
                    )
                    .unwrap(),
                )));
            });
        });
```

**File:** storage/aptosdb/src/ledger_db/mod.rs (L285-291)
```rust
            event_db: event_db.unwrap(),
            persisted_auxiliary_info_db: persisted_auxiliary_info_db.unwrap(),
            transaction_accumulator_db: transaction_accumulator_db.unwrap(),
            transaction_auxiliary_data_db: transaction_auxiliary_data_db.unwrap(),
            transaction_db: transaction_db.unwrap(),
            transaction_info_db: transaction_info_db.unwrap(),
            write_set_db: write_set_db.unwrap(),
```

**File:** storage/aptosdb/src/db_debugger/ledger/check_range_proof.rs (L25-26)
```rust
    pub fn run(self) -> Result<()> {
        let ledger_db = Arc::new(self.db_dir.open_ledger_db()?);
```
