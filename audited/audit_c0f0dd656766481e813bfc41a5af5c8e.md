# Audit Report

## Title
Encrypted Transaction Payload Bypasses TransactionFilter Rules Leading to Security Policy Violations

## Summary
The `TransactionFilter` implementation fails to properly evaluate filter rules against encrypted transactions in the `Encrypted` or `FailedDecryption` state. When matchers attempt to inspect the transaction payload (e.g., `EntryFunction`, `ModuleAddress`), they call `executable_ref()` which returns an error for non-decrypted payloads. This causes Deny rules to fail matching, allowing encrypted malicious transactions to bypass mempool and consensus filters, violating the security guarantees of `TransactionFilterConfig`. [1](#0-0) 

## Finding Description
The `TransactionFilterConfig` wrapper provides security by filtering transactions at multiple stages (mempool, consensus, execution). However, the underlying `TransactionMatcher` logic contains a critical flaw when handling encrypted payloads.

**The Core Vulnerability:**

When a transaction filter is configured with Deny rules targeting specific entry functions or module addresses, the matchers inspect the transaction payload by calling `matches_entry_function()` or `matches_entry_function_module_address()`. For `EncryptedPayload` transactions, these functions attempt to access the payload contents: [2](#0-1) 

The `executable_ref()` method only succeeds when the payload is in the `Decrypted` state: [3](#0-2) 

For encrypted transactions in the `Encrypted` or `FailedDecryption` state, `executable_ref()` returns an error, causing the matcher to return `false`. Since the matcher doesn't match, Deny rules fail to apply, and the transaction is allowed by default: [4](#0-3) 

**Attack Flow:**

1. A node operator configures a filter to deny transactions calling `0x1::malicious_module::exploit()`
2. Attacker creates a transaction calling that function and encrypts it using threshold encryption
3. The encrypted transaction (in `Encrypted` state) is submitted to mempool
4. Mempool filter checks the transaction via `filter_transactions()`: [5](#0-4) 

5. The `EntryFunction` or `ModuleAddress` matcher fails to match because `executable_ref()` returns an error
6. The Deny rule doesn't apply, so the transaction is **allowed by default**
7. The encrypted transaction enters mempool, consumes resources, and propagates to validators
8. In consensus, the same bypass occurs with `check_denied_inline_transactions()`: [6](#0-5) 

9. Only after decryption in the execution pipeline does the filter work correctly: [7](#0-6) 

By this point, the malicious transaction has already consumed mempool space, network bandwidth, and consensus resources.

**The Three EncryptedPayload States:** [8](#0-7) 

Only the `Decrypted` state allows inspection, but transactions enter mempool in the `Encrypted` state and are only decrypted during consensus execution.

## Impact Explanation
This vulnerability qualifies as **HIGH severity** under the Aptos bug bounty program for the following reasons:

1. **Security Policy Bypass**: The fundamental security guarantee of transaction filtering is violated. Operators who configure filters to block specific modules or functions find their policies completely bypassed by encrypted transactions.

2. **Resource Exhaustion**: Malicious actors can flood mempool with encrypted transactions that should be denied, consuming:
   - Mempool storage capacity
   - Network bandwidth for transaction propagation
   - Validator CPU cycles for processing and propagation
   - Consensus resources until decryption reveals the denied payload

3. **Consensus Disruption Potential**: If validators have different decryption capabilities or timing, encrypted malicious transactions could cause inconsistencies in block proposals, potentially affecting consensus liveness.

4. **Validator Node Impact**: This creates validator node slowdowns through resource consumption, which aligns with the HIGH severity category ($50,000) in the bug bounty program.

5. **Significant Protocol Violation**: The filter mechanism is a core security feature. Its bypass represents a significant protocol violation affecting the security guarantees provided to node operators.

## Likelihood Explanation
The likelihood of exploitation is **HIGH** because:

1. **No Special Privileges Required**: Any user can submit encrypted transactions using the standard threshold encryption mechanism.

2. **Easy to Execute**: The attack requires only:
   - Creating a transaction calling a denied function
   - Encrypting it using the standard encryption scheme
   - Submitting it to any node's mempool

3. **Immediate Impact**: The bypass occurs automatically whenever:
   - A node has transaction filters configured
   - An attacker submits encrypted transactions
   - No additional conditions or timing requirements exist

4. **Detection Difficulty**: The bypass is silent until decryption. Operators monitoring for denied transactions won't see rejections at the mempool/consensus stage.

5. **Widespread Applicability**: Any filter rule using `EntryFunction`, `ModuleAddress`, `AccountAddress` (when checking entry functions), or `EncryptedTransaction` (for inverted logic) matchers is vulnerable.

## Recommendation
Implement proper handling of encrypted transactions in the filter logic. There are two approaches:

**Option 1: Fail-Secure for Encrypted Transactions (Recommended)**

Modify the filter logic to explicitly deny encrypted transactions when Deny rules target payload-specific matchers that cannot be evaluated:

```rust
// In transaction_filter.rs, modify matches_entry_function_module_address
fn matches_entry_function_module_address(
    signed_transaction: &SignedTransaction,
    module_address: &AccountAddress,
) -> bool {
    match signed_transaction.payload() {
        // ... existing cases ...
        TransactionPayload::EncryptedPayload(payload) => {
            // If the payload is not decrypted, we cannot verify it doesn't match
            // For security, treat undecryptable payloads as potentially matching deny rules
            payload.executable_ref()
                .ok()
                .and_then(|executable| match executable {
                    TransactionExecutableRef::EntryFunction(entry_function) => {
                        Some(compare_entry_function_module_address(entry_function, module_address))
                    },
                    _ => Some(false),
                })
                .unwrap_or(true) // Return true for encrypted payloads to match deny rules
        },
    }
}
```

**Option 2: Add Explicit EncryptedTransaction Handling to Filter Configuration**

Require filter configurations to explicitly specify how to handle encrypted transactions:

```rust
pub enum EncryptedTransactionPolicy {
    AllowAll,      // Encrypted transactions always pass (current behavior)
    DenyAll,       // Encrypted transactions always fail
    RequireDecryption, // Error if transaction cannot be inspected
}

impl TransactionFilterConfig {
    pub fn new(
        filter_enabled: bool, 
        transaction_filter: TransactionFilter,
        encrypted_policy: EncryptedTransactionPolicy
    ) -> Self {
        // ...
    }
}
```

**Option 3: Apply Filters After Decryption Only**

Move all transaction filtering to occur after the decryption stage in the consensus pipeline. This ensures filters can always inspect transaction contents but requires architectural changes to the pipeline.

The recommended approach is **Option 1** as it provides fail-secure behavior without requiring configuration changes, maintains backward compatibility, and prevents the resource exhaustion attack vector.

## Proof of Concept
```rust
#[cfg(test)]
mod test {
    use super::*;
    use aptos_crypto::HashValue;
    use aptos_types::{
        chain_id::ChainId,
        secret_sharing::{Ciphertext, EvalProof},
        transaction::{
            encrypted_payload::EncryptedPayload, RawTransaction, Script, SignedTransaction,
            TransactionExtraConfig, TransactionPayload,
        },
    };
    use aptos_crypto::{ed25519::Ed25519PrivateKey, PrivateKey, SigningKey, Uniform};
    use move_core_types::account_address::AccountAddress;

    #[test]
    fn test_encrypted_transaction_bypasses_entry_function_filter() {
        // Create a filter that denies transactions to module 0x1::forbidden
        let denied_module = AccountAddress::from_hex_literal("0x1").unwrap();
        let filter = TransactionFilter::empty()
            .add_module_address_filter(false, denied_module)
            .add_all_filter(true); // Allow everything else

        // Create a plaintext transaction calling the denied module
        let entry_function = EntryFunction::new(
            ModuleId::new(denied_module, Identifier::new("forbidden").unwrap()),
            Identifier::new("exploit").unwrap(),
            vec![],
            vec![],
        );
        let plaintext_payload = TransactionPayload::EntryFunction(entry_function.clone());
        let plaintext_txn = create_signed_transaction(plaintext_payload);

        // Verify the plaintext transaction is DENIED by the filter
        assert!(!filter.allows_transaction(&plaintext_txn));

        // Create an encrypted version of the same transaction
        let encrypted_payload = EncryptedPayload::Encrypted {
            ciphertext: Ciphertext::random(),
            extra_config: TransactionExtraConfig::V1 {
                multisig_address: None,
                replay_protection_nonce: None,
            },
            payload_hash: HashValue::random(),
        };
        let encrypted_txn = create_signed_transaction(
            TransactionPayload::EncryptedPayload(encrypted_payload)
        );

        // VULNERABILITY: The encrypted transaction BYPASSES the filter
        // and is allowed, even though it calls the denied module
        assert!(filter.allows_transaction(&encrypted_txn));
        // ^ This assertion passes, demonstrating the bypass

        // After decryption, create the decrypted state with the same entry function
        let executable = TransactionExecutable::EntryFunction(entry_function);
        let decrypted_payload = EncryptedPayload::Decrypted {
            ciphertext: Ciphertext::random(),
            extra_config: TransactionExtraConfig::V1 {
                multisig_address: None,
                replay_protection_nonce: None,
            },
            payload_hash: HashValue::random(),
            eval_proof: EvalProof::random(),
            executable,
            decryption_nonce: 0,
        };
        let decrypted_txn = create_signed_transaction(
            TransactionPayload::EncryptedPayload(decrypted_payload)
        );

        // After decryption, the filter correctly denies it
        assert!(!filter.allows_transaction(&decrypted_txn));

        // This proves that encrypted transactions bypass filters that
        // would otherwise deny them based on their actual payload content
    }

    fn create_signed_transaction(payload: TransactionPayload) -> SignedTransaction {
        let private_key = Ed25519PrivateKey::generate_for_testing();
        let sender = AccountAddress::random();
        let raw_txn = RawTransaction::new(
            sender,
            0,
            payload,
            0,
            0,
            0,
            ChainId::new(10),
        );
        SignedTransaction::new(
            raw_txn.clone(),
            private_key.public_key(),
            private_key.sign(&raw_txn).unwrap(),
        )
    }
}
```

## Notes
- This vulnerability affects all filter rules using payload-inspection matchers: `EntryFunction`, `ModuleAddress`, and `AccountAddress` (when checking entry functions)
- The execution filter (applied after decryption) works correctly, but by then resources are already consumed
- The `EncryptedTransaction` matcher itself works correctly (it matches all EncryptedPayload variants), but inverted logic doesn't prevent the bypass for other matchers
- Threshold encryption is designed for privacy, but the filter architecture incorrectly assumes all transactions are inspectable at filter time
- This impacts both mempool and consensus filtering stages, which occur before decryption

### Citations

**File:** config/src/config/transaction_filters_config.rs (L20-44)
```rust
#[derive(Clone, Debug, Deserialize, PartialEq, Eq, Serialize)]
#[serde(default, deny_unknown_fields)]
pub struct TransactionFilterConfig {
    filter_enabled: bool,                  // Whether the filter is enabled
    transaction_filter: TransactionFilter, // The transaction filter to apply
}

impl TransactionFilterConfig {
    pub fn new(filter_enabled: bool, transaction_filter: TransactionFilter) -> Self {
        Self {
            filter_enabled,
            transaction_filter,
        }
    }

    /// Returns true iff the filter is enabled and not empty
    pub fn is_enabled(&self) -> bool {
        self.filter_enabled && !self.transaction_filter.is_empty()
    }

    /// Returns a reference to the transaction filter
    pub fn transaction_filter(&self) -> &TransactionFilter {
        &self.transaction_filter
    }
}
```

**File:** crates/aptos-transaction-filters/src/transaction_filter.rs (L29-47)
```rust
    /// Returns true iff the filter allows the transaction
    pub fn allows_transaction(&self, signed_transaction: &SignedTransaction) -> bool {
        // If the filter is empty, allow the transaction by default
        if self.is_empty() {
            return true;
        }

        // Check if any rule matches the transaction
        for transaction_rule in &self.transaction_rules {
            if transaction_rule.matches(signed_transaction) {
                return match transaction_rule {
                    TransactionRule::Allow(_) => true,
                    TransactionRule::Deny(_) => false,
                };
            }
        }

        true // No rules match (allow the transaction by default)
    }
```

**File:** crates/aptos-transaction-filters/src/transaction_filter.rs (L362-374)
```rust
        TransactionPayload::EncryptedPayload(payload) => {
            if let Ok(executable) = payload.executable_ref() {
                match executable {
                    TransactionExecutableRef::Script(_) | TransactionExecutableRef::Empty => false,
                    TransactionExecutableRef::EntryFunction(entry_function) => {
                        compare_entry_function(entry_function, address, module_name, function)
                    },
                }
            } else {
                false
            }
        },
    }
```

**File:** types/src/transaction/encrypted_payload.rs (L42-64)
```rust
pub enum EncryptedPayload {
    Encrypted {
        ciphertext: Ciphertext,
        extra_config: TransactionExtraConfig,
        payload_hash: HashValue,
    },
    FailedDecryption {
        ciphertext: Ciphertext,
        extra_config: TransactionExtraConfig,
        payload_hash: HashValue,
        eval_proof: EvalProof,
    },
    Decrypted {
        ciphertext: Ciphertext,
        extra_config: TransactionExtraConfig,
        payload_hash: HashValue,
        eval_proof: EvalProof,

        // decrypted things
        executable: TransactionExecutable,
        decryption_nonce: u64,
    },
}
```

**File:** types/src/transaction/encrypted_payload.rs (L82-87)
```rust
    pub fn executable_ref(&self) -> Result<TransactionExecutableRef<'_>> {
        let Self::Decrypted { executable, .. } = self else {
            bail!("Transaction is encrypted");
        };
        Ok(executable.as_ref())
    }
```

**File:** mempool/src/shared_mempool/tasks.rs (L408-466)
```rust
fn filter_transactions(
    transaction_filter_config: &TransactionFilterConfig,
    transactions: Vec<(
        SignedTransaction,
        Option<u64>,
        Option<BroadcastPeerPriority>,
    )>,
    statuses: &mut Vec<(SignedTransaction, (MempoolStatus, Option<StatusCode>))>,
) -> Vec<(
    SignedTransaction,
    Option<u64>,
    Option<BroadcastPeerPriority>,
)> {
    // If the filter is not enabled, return early
    if !transaction_filter_config.is_enabled() {
        return transactions;
    }

    // Start the filter processing timer
    let transaction_filter_timer = counters::PROCESS_TXN_BREAKDOWN_LATENCY
        .with_label_values(&[counters::FILTER_TRANSACTIONS_LABEL])
        .start_timer();

    // Filter the transactions and update the statuses accordingly
    let transactions = transactions
        .into_iter()
        .filter_map(|(transaction, account_sequence_number, priority)| {
            if transaction_filter_config
                .transaction_filter()
                .allows_transaction(&transaction)
            {
                Some((transaction, account_sequence_number, priority))
            } else {
                info!(LogSchema::event_log(
                    LogEntry::TransactionFilter,
                    LogEvent::TransactionRejected
                )
                .message(&format!(
                    "Transaction {} rejected by filter",
                    transaction.committed_hash()
                )));

                statuses.push((
                    transaction.clone(),
                    (
                        MempoolStatus::new(MempoolStatusCode::RejectedByFilter),
                        None,
                    ),
                ));
                None
            }
        })
        .collect();

    // Update the filter processing latency metrics
    transaction_filter_timer.stop_and_record();

    transactions
}
```

**File:** consensus/src/payload_manager/direct_mempool_payload_manager.rs (L30-70)
```rust
    fn check_denied_inline_transactions(
        &self,
        block: &Block,
        block_txn_filter_config: &BlockTransactionFilterConfig,
    ) -> anyhow::Result<()> {
        // If the filter is disabled, return early
        if !block_txn_filter_config.is_enabled() {
            return Ok(());
        }

        // Get the inline transactions for the block proposal. Note: all
        // transactions in a direct mempool payload are inline transactions.
        let (inline_transactions, _, _) = get_transactions_from_block(block)?;
        if inline_transactions.is_empty() {
            return Ok(());
        }

        // Fetch the block metadata
        let block_id = block.id();
        let block_author = block.author();
        let block_epoch = block.epoch();
        let block_timestamp = block.timestamp_usecs();

        // Identify any denied inline transactions
        let block_transaction_filter = block_txn_filter_config.block_transaction_filter();
        let denied_inline_transactions = block_transaction_filter.get_denied_block_transactions(
            block_id,
            block_author,
            block_epoch,
            block_timestamp,
            inline_transactions,
        );
        if !denied_inline_transactions.is_empty() {
            return Err(anyhow::anyhow!(
                "Inline transactions for DirectMempoolPayload denied by block transaction filter: {:?}",
                denied_inline_transactions
            ));
        }

        Ok(()) // No transactions were denied
    }
```

**File:** consensus/src/block_preparer.rs (L122-146)
```rust
/// Filters transactions in a block based on the filter configuration
fn filter_block_transactions(
    txn_filter_config: Arc<BlockTransactionFilterConfig>,
    block_id: HashValue,
    block_author: Option<AccountAddress>,
    block_epoch: u64,
    block_timestamp_usecs: u64,
    txns: Vec<SignedTransaction>,
) -> Vec<SignedTransaction> {
    // If the transaction filter is disabled, return early
    if !txn_filter_config.is_enabled() {
        return txns;
    }

    // Otherwise, filter the transactions
    txn_filter_config
        .block_transaction_filter()
        .filter_block_transactions(
            block_id,
            block_author,
            block_epoch,
            block_timestamp_usecs,
            txns,
        )
}
```
