# Audit Report

## Title
Error Swallowing in Database Restore Leads to Unrecoverable Corrupted State

## Summary
The `unpack_tar_gz` function in the indexer table-info backup/restore system silently swallows critical filesystem errors during database restoration. When removal of the old database fails, the error is suppressed via `.unwrap_or(())`, causing subsequent operations to fail and leaving the system in an unrecoverable corrupted state requiring manual intervention. [1](#0-0) 

## Finding Description
The `unpack_tar_gz` function is responsible for unpacking database snapshots during restore operations. The function follows this sequence:

1. Creates a temporary directory with `.tmp` extension
2. Unpacks the tar.gz archive into the temporary directory
3. Attempts to remove the old target database directory
4. Renames the temporary directory to the target path

The critical flaw occurs at step 3, where `fs::remove_dir_all(target_db_path).unwrap_or(())` silently swallows any error that occurs during removal of the old database. [1](#0-0) 

When this removal fails (due to permissions errors, I/O errors, locked files, or partial corruption), the subsequent `fs::rename` operation fails because the target directory still exists and is non-empty. [2](#0-1) 

This leaves the filesystem in a corrupted state:
- The temporary directory exists with the unpacked new database
- The target directory remains (potentially corrupted or locked)
- On retry, the function immediately fails at temp directory creation because it already exists from the previous attempt [3](#0-2) 

The caller in `gcs.rs` uses `.expect()` which causes a panic, but this happens AFTER the corrupted state is created. [4](#0-3) 

## Impact Explanation
This issue constitutes **Medium Severity** per Aptos bug bounty criteria: "State inconsistencies requiring intervention."

The indexer table-info service provides critical metadata about on-chain tables to applications and clients. When the restore operation fails and leaves corrupted state:
- The indexer service cannot recover automatically
- Manual filesystem cleanup is required
- Subsequent restore attempts fail immediately
- The service remains unavailable until manual intervention

While this affects auxiliary infrastructure (not consensus), the table-info indexer is essential for:
- Applications querying Move table metadata
- Smart contract interactions requiring table information
- Full historical data access for clients

The corrupted state is **non-recoverable** without manual intervention, violating the principle that error cases should "properly propagate with sufficient context for recovery."

## Likelihood Explanation
This issue is **highly likely** to occur in production environments:
- Database restore operations happen during node startup/recovery
- I/O errors, permission issues, and disk failures are common in production
- The error handling pattern `.unwrap_or(())` guarantees silent failure
- No automated recovery mechanism exists

The triggering conditions are routine operational scenarios, not requiring any malicious action.

## Recommendation
Replace the error-swallowing pattern with proper error propagation and atomic cleanup:

```rust
pub fn unpack_tar_gz(temp_file_path: &PathBuf, target_db_path: &PathBuf) -> anyhow::Result<()> {
    let temp_dir_path = target_db_path.with_extension("tmp");
    
    // Clean up any stale temp directory from previous failed attempts
    if temp_dir_path.exists() {
        fs::remove_dir_all(&temp_dir_path)
            .context("Failed to remove stale temporary directory")?;
    }
    
    fs::create_dir(&temp_dir_path)?;

    let file = File::open(temp_file_path)?;
    let gz_decoder = GzDecoder::new(file);
    let mut archive = Archive::new(gz_decoder);
    archive.unpack(&temp_dir_path)?;

    // Properly propagate removal errors with context
    fs::remove_dir_all(target_db_path)
        .context(format!("Failed to remove old database at {:?}", target_db_path))?;
    
    fs::rename(&temp_dir_path, target_db_path)
        .context("Failed to rename temporary directory to target path")?;
    
    Ok(())
}
```

Additionally, implement proper cleanup in the error path by wrapping the operation:

```rust
// In gcs.rs, add cleanup on failure
match task::spawn_blocking(move || unpack_tar_gz(&temp_file_path_clone, &db_path)).await? {
    Ok(_) => {},
    Err(e) => {
        // Clean up temp directory on failure
        let temp_dir = db_path.with_extension("tmp");
        let _ = fs::remove_dir_all(&temp_dir).await;
        return Err(e);
    }
}
```

## Proof of Concept

```rust
#[test]
fn test_unpack_fails_with_locked_target() {
    use std::fs::{self, File};
    use tempfile::tempdir;
    use std::io::Write;

    // Create temporary directories
    let source_dir = tempdir().unwrap();
    let target_dir = tempdir().unwrap();
    let target_path = target_dir.path().to_path_buf();
    
    // Create a tar.gz file
    let test_file = source_dir.path().join("test.txt");
    let mut f = File::create(&test_file).unwrap();
    writeln!(f, "test data").unwrap();
    
    let tar_path = create_tar_gz(source_dir.path().to_path_buf(), "test").unwrap();
    
    // Simulate a locked/inaccessible target directory
    // On Unix: remove write permissions
    #[cfg(unix)]
    {
        use std::os::unix::fs::PermissionsExt;
        let mut perms = fs::metadata(&target_path).unwrap().permissions();
        perms.set_mode(0o444); // Read-only
        fs::set_permissions(&target_path, perms).unwrap();
    }
    
    // First attempt should fail with corrupted state
    let result = unpack_tar_gz(&tar_path, &target_path);
    assert!(result.is_err(), "Should fail when target cannot be removed");
    
    // Verify corrupted state: temp directory exists
    let temp_dir = target_path.with_extension("tmp");
    assert!(temp_dir.exists(), "Temp directory should exist after failure");
    
    // Restore permissions for cleanup
    #[cfg(unix)]
    {
        use std::os::unix::fs::PermissionsExt;
        let mut perms = fs::metadata(&target_path).unwrap().permissions();
        perms.set_mode(0o755);
        fs::set_permissions(&target_path, perms).unwrap();
    }
    
    // Second attempt fails immediately due to existing temp directory
    let result2 = unpack_tar_gz(&tar_path, &target_path);
    assert!(result2.is_err(), "Retry should fail due to existing temp dir");
    
    // Manual cleanup required
    fs::remove_dir_all(&temp_dir).unwrap();
}
```

## Notes
This vulnerability demonstrates a violation of proper error propagation principles. The `.unwrap_or(())` pattern converts a critical failure into silent success, breaking the invariant that "all error cases properly propagate with sufficient context for recovery." The system enters a corrupted state that cannot be recovered through normal retry logic, requiring manual operator intervention to restore service availability.

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-table-info/src/backup_restore/fs_ops.rs (L103-103)
```rust
    fs::create_dir(&temp_dir_path)?;
```

**File:** ecosystem/indexer-grpc/indexer-grpc-table-info/src/backup_restore/fs_ops.rs (L110-110)
```rust
    fs::remove_dir_all(target_db_path).unwrap_or(());
```

**File:** ecosystem/indexer-grpc/indexer-grpc-table-info/src/backup_restore/fs_ops.rs (L111-111)
```rust
    fs::rename(&temp_dir_path, target_db_path)?; // Atomically replace the directory
```

**File:** ecosystem/indexer-grpc/indexer-grpc-table-info/src/backup_restore/gcs.rs (L303-305)
```rust
                task::spawn_blocking(move || unpack_tar_gz(&temp_file_path_clone, &db_path))
                    .await?
                    .expect("Failed to unpack gzipped tar file");
```
