# Audit Report

## Title
Integer Overflow and Memory Exhaustion in ThresholdConfigBlstrs Deserialization with Extremely Large Values

## Summary
The `ThresholdConfigBlstrs` deserialization implementation validates basic constraints (t > 0, n > 0, t ≤ n) but fails to check upper bounds on the `n` parameter. When extremely large `n` values are deserialized, they trigger either an infinite loop due to integer overflow in `smallest_power_of_2_greater_than_or_eq()` or catastrophic memory allocation failures in `BatchEvaluationDomain::new()`, causing validator node crashes.

## Finding Description
The custom `Deserialize` implementation for `ThresholdConfigBlstrs` deserializes the `t` and `n` fields, then reconstructs the evaluation domains by calling `ThresholdConfigBlstrs::new(t, n)`: [1](#0-0) 

The `new()` function performs three validation checks: [2](#0-1) 

These checks only verify t > 0, n > 0, and t ≤ n, but critically **do not validate upper bounds on n**. After validation passes, the function calls `BatchEvaluationDomain::new(n)`: [3](#0-2) 

`BatchEvaluationDomain::new()` has **no upper bound checks** and directly calls `smallest_power_of_2_greater_than_or_eq(n)`: [4](#0-3) 

The `smallest_power_of_2_greater_than_or_eq()` function contains a critical vulnerability: [5](#0-4) 

**Attack Scenario 1: Integer Overflow (Infinite Loop)**
- Attacker deserializes data with n = usize::MAX (0xFFFFFFFFFFFFFFFF on 64-bit)
- t = 1 (passes validation t ≤ n)
- In `smallest_power_of_2_greater_than_or_eq()`, N starts at 1 and doubles
- After 63 iterations, N = 2^63
- On iteration 64, `N <<= 1` overflows, wrapping to 0 (in release mode)
- Condition `N < n` remains true (0 < usize::MAX)
- Loop continues indefinitely: 0 << 1 = 0
- **Validator node hangs, cannot process blocks**

**Attack Scenario 2: Memory Exhaustion**
- Attacker deserializes data with n = 2^62
- t = 1 (passes validation)
- Function computes N = 2^62 (next power of 2)
- At line 124, attempts `Vec::with_capacity(2^62)`: [6](#0-5) 

- Each `Scalar` element is 32 bytes
- Total allocation: 2^62 × 32 = 2^67 bytes = **128 petabytes**
- **Immediate OOM crash, node terminates**

Note that while `EvaluationDomain::new()` includes a size check: [7](#0-6) 

`BatchEvaluationDomain::new()` **lacks this critical protection**.

While I could not identify a direct network-accessible deserialization endpoint in the current codebase, the types involved (`ThresholdConfigBlstrs`, `WeightedConfigBlstrs`, `DKGPvssConfig`) all derive `Serialize` and `Deserialize`: [8](#0-7) [9](#0-8) 

This creates a latent vulnerability that could be triggered through future API endpoints, state synchronization mechanisms, or configuration management interfaces.

## Impact Explanation
**Critical Severity (DOS leading to network liveness failure)**

This vulnerability breaks two critical invariants:
1. **Resource Limits**: Operations must respect computational and memory constraints
2. **Liveness**: The network must continue processing transactions

Impact assessment:
- **Single validator**: Node crash/hang, cannot participate in consensus
- **Multiple validators**: If exploitable via broadcast (e.g., gossip, state sync), could affect >1/3 of validators
- **Network impact**: Loss of liveness if sufficient validators are affected
- **Recovery**: Requires node restart or code fix, potentially affecting epoch transitions

While I could not confirm a currently exploitable network path, the vulnerability severity is Critical due to:
- Guaranteed crash/hang when triggered
- Affects core cryptographic infrastructure used in consensus randomness
- Could enable targeted DOS attacks on validators
- No rate limiting or resource bounds protection

## Likelihood Explanation
**Current Likelihood: Low** (no confirmed network-accessible deserialization path found)

**Future Likelihood: Medium to High** if these types become exposed through:
- RPC endpoints for DKG configuration
- State synchronization of validator configurations  
- Checkpoint/snapshot restoration mechanisms
- Future API additions

The vulnerability is **trivial to exploit** once a deserialization vector exists:
- Requires only crafting malicious BCS/JSON bytes with large n value
- No cryptographic signatures or authentication needed
- Deterministic crash/hang on all affected nodes
- Can be tested locally to verify impact

## Recommendation
Add upper bound validation in `BatchEvaluationDomain::new()` consistent with `EvaluationDomain::new()`:

```rust
impl BatchEvaluationDomain {
    pub fn new(n: usize) -> Result<Self, CryptoMaterialError> {
        let (N, log_N) = smallest_power_of_2_greater_than_or_eq(n);
        
        // Add this critical check (same as EvaluationDomain::new)
        if log_N >= Scalar::S as usize {
            return Err(CryptoMaterialError::WrongLengthError);
        }
        
        // Additional safety check for reasonable upper bound
        if N > (1 << 30) {  // 1 billion elements max
            return Err(CryptoMaterialError::WrongLengthError);
        }
        
        let omega = EvaluationDomain::get_Nth_root_of_unity(log_N);
        // ... rest of implementation
    }
}
```

Additionally, update `ThresholdConfigBlstrs::new()` to propagate errors:

```rust
pub fn new(t: usize, n: usize) -> anyhow::Result<Self> {
    // ... existing checks ...
    
    let batch_dom = BatchEvaluationDomain::new(n)
        .map_err(|e| anyhow!("Failed to create batch evaluation domain: {:?}", e))?;
    let dom = batch_dom.get_subdomain(n);
    
    Ok(ThresholdConfigBlstrs { t, n, dom, batch_dom })
}
```

## Proof of Concept

```rust
#[test]
#[should_panic(expected = "infinite loop or OOM")]
fn test_threshold_config_dos_large_n() {
    use aptos_crypto::blstrs::threshold_config::ThresholdConfigBlstrs;
    use aptos_crypto::traits::ThresholdConfig;
    
    // Attack: extremely large n value
    let malicious_n = usize::MAX;
    let malicious_t = 1;
    
    // This should fail but currently hangs or crashes
    let result = ThresholdConfigBlstrs::new(malicious_t, malicious_n);
    
    // Never reaches here in current implementation
    assert!(result.is_err(), "Should reject extremely large n values");
}

#[test]
#[should_panic(expected = "OOM")]
fn test_threshold_config_dos_oom() {
    use aptos_crypto::blstrs::threshold_config::ThresholdConfigBlstrs;
    use aptos_crypto::traits::ThresholdConfig;
    
    // Attack: n = 2^62 causes 128 PB allocation
    let malicious_n = 1usize << 62;
    let malicious_t = 1;
    
    // This will attempt massive allocation and crash
    let result = ThresholdConfigBlstrs::new(malicious_t, malicious_n);
    
    assert!(result.is_err(), "Should reject values causing OOM");
}

#[test]
fn test_deserialization_dos() {
    use aptos_crypto::blstrs::threshold_config::ThresholdConfigBlstrs;
    
    // Craft malicious serialized data
    #[derive(serde::Serialize)]
    struct MaliciousData {
        t: usize,
        n: usize,
    }
    
    let malicious = MaliciousData {
        t: 1,
        n: usize::MAX,
    };
    
    let bytes = bcs::to_bytes(&malicious).unwrap();
    
    // Attempt deserialization - will hang/crash
    let result: Result<ThresholdConfigBlstrs, _> = bcs::from_bytes(&bytes);
    
    // Should fail gracefully but currently doesn't
    assert!(result.is_err(), "Deserialization should reject malicious input");
}
```

**Notes**
- The vulnerability exists in the core cryptographic library used for consensus randomness and DKG
- While no current network-accessible deserialization path was confirmed, the vulnerability is latent and severe
- The issue stems from missing upper bound validation that exists in `EvaluationDomain::new()` but not in `BatchEvaluationDomain::new()`
- Exploitation requires only basic serialization knowledge, no advanced cryptographic attacks
- Fix is straightforward: add consistent validation across all evaluation domain constructors

### Citations

**File:** crates/aptos-crypto/src/blstrs/threshold_config.rs (L37-54)
```rust
impl<'de> Deserialize<'de> for ThresholdConfigBlstrs {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        // Deserialize only the serializable fields (t, n)
        #[derive(Deserialize)]
        struct SerializedFields {
            t: usize,
            n: usize,
        }

        let serialized = SerializedFields::deserialize(deserializer)?;

        // Rebuild the skipped fields using `new`
        ThresholdConfigBlstrs::new(serialized.t, serialized.n).map_err(serde::de::Error::custom)
    }
}
```

**File:** crates/aptos-crypto/src/blstrs/threshold_config.rs (L109-122)
```rust
    fn new(t: usize, n: usize) -> anyhow::Result<Self> {
        if t == 0 {
            return Err(anyhow!("expected the reconstruction threshold to be > 0"));
        }

        if n == 0 {
            return Err(anyhow!("expected the number of shares to be > 0"));
        }

        if t > n {
            return Err(anyhow!(
                "expected the reconstruction threshold {t} to be < than the number of shares {n}"
            ));
        }
```

**File:** crates/aptos-crypto/src/blstrs/threshold_config.rs (L124-125)
```rust
        let batch_dom = BatchEvaluationDomain::new(n);
        let dom = batch_dom.get_subdomain(n);
```

**File:** crates/aptos-crypto/src/blstrs/evaluation_domain.rs (L48-64)
```rust
/// Returns the highest $N = 2^k$ such that $N \ge n$.
#[allow(non_snake_case)]
pub fn smallest_power_of_2_greater_than_or_eq(n: usize) -> (usize, usize) {
    let mut N = 1;
    let mut log_N: usize = 0;

    while N < n {
        N <<= 1;
        log_N += 1;
    }

    (N, log_N)
    // TODO: Replace with:
    // let N = n.next_power_of_two();
    // let log_N = N.trailing_zeros() as usize;
    // (N, log_N)
}
```

**File:** crates/aptos-crypto/src/blstrs/evaluation_domain.rs (L79-81)
```rust
        if log_N >= Scalar::S as usize {
            return Err(CryptoMaterialError::WrongLengthError);
        }
```

**File:** crates/aptos-crypto/src/blstrs/evaluation_domain.rs (L120-125)
```rust
    pub fn new(n: usize) -> Self {
        let (N, log_N) = smallest_power_of_2_greater_than_or_eq(n);
        let omega = EvaluationDomain::get_Nth_root_of_unity(log_N);

        let mut omegas = Vec::with_capacity(N);
        omegas.push(Scalar::ONE);
```

**File:** crates/aptos-crypto/src/weighted_config.rs (L38-42)
```rust
#[derive(Clone, Deserialize, Serialize, Debug, PartialEq, Eq)]
pub struct WeightedConfig<TC: ThresholdConfig> {
    /// A weighted config is a $w$-out-of-$W$ threshold config, where $w$ is the minimum weight
    /// needed to reconstruct the secret and $W$ is the total weight.
    tc: TC,
```

**File:** types/src/dkg/real_dkg/mod.rs (L43-49)
```rust
#[derive(Deserialize, Serialize, Clone, Debug)]
pub struct DKGPvssConfig {
    pub epoch: u64,
    // weighted config for randomness generation
    pub wconfig: SSConfig,
    // weighted config for randomness generation in fast path
    pub fast_wconfig: Option<SSConfig>,
```
