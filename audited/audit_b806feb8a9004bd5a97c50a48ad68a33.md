# Audit Report

## Title
Transaction Accumulator Pruner Leaves Even-Versioned Nodes Unpruned at Odd Version Boundaries

## Summary
The transaction accumulator pruning algorithm fails to delete tree nodes for even-numbered versions when the target pruning version is odd. This occurs because the algorithm skips even versions expecting them to be pruned when processing `version+1`, but when `target_version` is odd, `target_version-1` (even) is the last version in the range `[begin, target_version)` and is never actually processed by the subsequent odd version's cleanup logic.

## Finding Description

The vulnerability exists in the interaction between two components:

1. **TransactionAccumulatorDb::prune()** [1](#0-0) 

This function processes versions in the range `[begin, end)` (exclusive of `end`). For even versions, it skips tree node deletion with the assumption: "The even version will be pruned in the iteration of version + 1" [2](#0-1) 

2. **LedgerPrunerManager::set_pruner_target_db_version()** [3](#0-2) 

This calculates `min_readable_version = latest_version - prune_window`, which can result in any value including odd numbers.

**The Bug Flow:**

When `min_readable_version` is odd (e.g., 99):
1. `prune(0, 99)` is called, processing range `[0, 99)` = versions 0-98
2. Version 98 (even) skips tree node deletion at line 153-155
3. The comment assumes version 99 will handle it
4. **But version 99 is NOT in the range** `[0, 99)` - it's excluded!
5. Version 98's tree nodes (TransactionAccumulatorSchema entries) are never deleted
6. Only the root hash entry (TransactionAccumulatorRootHashSchema) is deleted at line 151

**Test Acknowledgment:**

The test file explicitly acknowledges this bug: [4](#0-3) 

The test skips verification that the last even version is pruned, confirming the implementation is aware of but does not fix this issue.

## Impact Explanation

**Severity: Medium** (up to $10,000 per Aptos bug bounty)

This vulnerability causes **storage inconsistencies requiring intervention**:

1. **Storage Leakage**: Tree nodes (Position entries in TransactionAccumulatorSchema) accumulate in the database without being pruned, consuming storage indefinitely
2. **Inconsistent State**: Root hash entries are deleted but corresponding tree nodes remain, creating an inconsistent database state
3. **Accumulated Impact**: Over months of operation, this can accumulate significant unpruned data (every odd pruning boundary leaves one version's tree nodes)

This does NOT affect:
- Consensus safety (nodes can still read existing data)
- Transaction execution (execution doesn't depend on pruned data)
- Validator operations (functional correctness is maintained)

However, it breaks the **State Consistency** invariant by creating storage inconsistencies that will accumulate over time, eventually requiring manual database cleanup intervention.

## Likelihood Explanation

**Likelihood: High**

This occurs automatically in production without any attacker action:

1. **Frequent Occurrence**: The `min_readable_version` calculation uses `latest_version - prune_window`, which has a 50% probability of being odd
2. **Default Behavior**: Happens during normal pruning operations on all nodes
3. **No Special Conditions**: Requires no specific blockchain state or attacker manipulation
4. **Continuous Accumulation**: Each time an odd boundary is reached, one version's tree nodes are leaked

Example scenarios:
- `latest_version=1001, prune_window=2` → `min_readable_version=999` (odd) → version 998's nodes leaked
- `latest_version=5000, prune_window=1` → `min_readable_version=4999` (odd) → version 4998's nodes leaked

## Recommendation

**Fix the range boundary handling** by ensuring even versions at the boundary are processed:

```rust
pub(crate) fn prune(begin: Version, end: Version, db_batch: &mut SchemaBatch) -> Result<()> {
    for version_to_delete in begin..end {
        db_batch.delete::<TransactionAccumulatorRootHashSchema>(&version_to_delete)?;
        
        // Process tree nodes for even versions if they're at the boundary
        if version_to_delete % 2 == 0 {
            // If this is the last version and it's even, we need to process it
            // since the next odd version won't be in this batch
            if version_to_delete == end - 1 {
                // Process this even version's tree nodes
                let leaf_pos = Position::from_leaf_index(version_to_delete);
                db_batch.delete::<TransactionAccumulatorSchema>(&leaf_pos)?;
            }
            continue;
        }
        
        // Existing odd version logic...
        let first_ancestor_that_is_a_left_child =
            Self::find_first_ancestor_that_is_a_left_child(version_to_delete);
        assert!(!first_ancestor_that_is_a_left_child.is_leaf());
        
        let mut current = first_ancestor_that_is_a_left_child;
        while !current.is_leaf() {
            db_batch.delete::<TransactionAccumulatorSchema>(&current.left_child())?;
            db_batch.delete::<TransactionAccumulatorSchema>(&current.right_child())?;
            current = current.right_child();
        }
    }
    Ok(())
}
```

**Alternative approach**: Adjust the pruning range to always end at an even version: [5](#0-4) 

```rust
let min_readable_version = latest_version.saturating_sub(self.prune_window);
// Ensure target is even to avoid boundary issues
let adjusted_target = if min_readable_version % 2 == 1 {
    min_readable_version - 1
} else {
    min_readable_version
};
```

## Proof of Concept

```rust
#[test]
fn test_even_version_boundary_pruning_bug() {
    use crate::{AptosDB, LedgerPrunerManager};
    use aptos_config::config::LedgerPrunerConfig;
    use aptos_temppath::TempPath;
    use aptos_types::proof::position::Position;
    use aptos_storage_interface::DbReader;
    
    let tmp_dir = TempPath::new();
    let aptos_db = AptosDB::new_for_test(&tmp_dir);
    
    // Setup: Create transactions 0-10
    let num_txns = 11;
    let txn_infos = (0..num_txns).map(|_| TransactionInfo::new_placeholder()).collect::<Vec<_>>();
    
    // Write transactions to DB
    let mut batch = SchemaBatch::new();
    aptos_db.ledger_store.put_transaction_infos(0, &txn_infos, &mut batch, &mut batch).unwrap();
    aptos_db.ledger_db.transaction_accumulator_db().write_schemas(batch).unwrap();
    
    // Initialize pruner with prune_window=0 to prune aggressively
    let pruner = LedgerPrunerManager::new(
        Arc::clone(&aptos_db.ledger_db),
        LedgerPrunerConfig {
            enable: true,
            prune_window: 0,
            batch_size: 1000,
            user_pruning_window_offset: 0,
        }
    );
    
    // Prune with target_version = 9 (ODD)
    // This will process [0, 9), which is versions 0-8
    // Version 8 is EVEN and will be skipped
    pruner.wake_and_wait_pruner(9).unwrap();
    
    // BUG: Version 8's tree nodes should be deleted but are not
    let version_8_leaf_pos = Position::from_leaf_index(8);
    
    // This should fail (position should be pruned) but SUCCEEDS due to the bug
    let result = aptos_db.ledger_db
        .transaction_accumulator_db()
        .get(version_8_leaf_pos);
    
    // EXPECTED: Err (position should be deleted)
    // ACTUAL: Ok (position still exists) - THIS IS THE BUG
    assert!(result.is_ok(), "BUG CONFIRMED: Version 8's tree nodes were not pruned!");
}
```

This test demonstrates that when pruning with an odd target version, the preceding even version's tree nodes remain in the database, confirming the vulnerability.

### Citations

**File:** storage/aptosdb/src/ledger_db/transaction_accumulator_db.rs (L149-172)
```rust
    pub(crate) fn prune(begin: Version, end: Version, db_batch: &mut SchemaBatch) -> Result<()> {
        for version_to_delete in begin..end {
            db_batch.delete::<TransactionAccumulatorRootHashSchema>(&version_to_delete)?;
            // The even version will be pruned in the iteration of version + 1.
            if version_to_delete % 2 == 0 {
                continue;
            }

            let first_ancestor_that_is_a_left_child =
                Self::find_first_ancestor_that_is_a_left_child(version_to_delete);

            // This assertion is true because we skip the leaf nodes with address which is a
            // a multiple of 2.
            assert!(!first_ancestor_that_is_a_left_child.is_leaf());

            let mut current = first_ancestor_that_is_a_left_child;
            while !current.is_leaf() {
                db_batch.delete::<TransactionAccumulatorSchema>(&current.left_child())?;
                db_batch.delete::<TransactionAccumulatorSchema>(&current.right_child())?;
                current = current.right_child();
            }
        }
        Ok(())
    }
```

**File:** storage/aptosdb/src/pruner/ledger_pruner/ledger_pruner_manager.rs (L162-176)
```rust
    fn set_pruner_target_db_version(&self, latest_version: Version) {
        assert!(self.pruner_worker.is_some());
        let min_readable_version = latest_version.saturating_sub(self.prune_window);
        self.min_readable_version
            .store(min_readable_version, Ordering::SeqCst);

        PRUNER_VERSIONS
            .with_label_values(&["ledger_pruner", "min_readable"])
            .set(min_readable_version as i64);

        self.pruner_worker
            .as_ref()
            .unwrap()
            .set_target_db_version(min_readable_version);
    }
```

**File:** storage/aptosdb/src/pruner/ledger_pruner/test.rs (L139-146)
```rust
            // Note: we only prune versions which are odd numbers because the even versions will be
            // pruned in the iteration of even_version + 1. So if the end version, i - 1, is an even
            // version, it will not be pruned.
            if j != i - 1 || j % 2 == 1 {
                assert!(ledger_store
                    .get_transaction_proof(j as u64, ledger_version)
                    .is_err());
            }
```
