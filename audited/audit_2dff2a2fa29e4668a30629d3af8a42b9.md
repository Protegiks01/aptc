# Audit Report

## Title
Information Disclosure via Debug Logging of Peer Monitoring Service Responses Exposes Network Topology and Validator Identities

## Summary
The peer monitoring service logs complete response data using Debug formatting at trace level, exposing sensitive network topology information including peer IDs, network addresses, and validator roles. This defeats the security-conscious Display implementations that were designed to redact this sensitive data, allowing attackers with log access to map the network and identify validator nodes.

## Finding Description

The `log_monitoring_service_response` function uses Debug formatting to log peer monitoring responses, which exposes complete network topology data that should be redacted. [1](#0-0) 

The logging at line 348 uses `format!("{:?}", response)`, which applies Debug formatting to the entire `PeerMonitoringServiceResponse`. When the response is a `NetworkInformationResponse`, this exposes:

1. **Complete list of connected peer IDs** - allowing identification of all peers in the network
2. **Network addresses** (IP addresses and ports) - enabling targeted network attacks
3. **Peer roles** (including `PeerRole::Validator`) - allowing identification of validator nodes
4. **Distance from validators** - revealing network topology structure [2](#0-1) 

The `NetworkInformationResponse` contains a `BTreeMap<PeerNetworkId, ConnectionMetadata>` where each `ConnectionMetadata` includes: [3](#0-2) 

**Evidence of Security-Conscious Design Being Defeated:**

The developers clearly anticipated this risk and implemented a custom Display trait for `NetworkInformationResponse` that **deliberately redacts** sensitive information by only logging the count: [4](#0-3) 

This Display implementation only exposes `num_connected_peers` (the count) and `distance_from_validators`, carefully avoiding logging the actual peer IDs, network addresses, and roles. However, the logging code bypasses this protection by using Debug formatting instead.

**Attack Path:**

1. Attacker gains read access to log files through system compromise, misconfiguration, insider access, or log aggregation service access
2. Trace logging is enabled (either intentionally for debugging or through misconfiguration via `RUST_LOG=trace`)
3. Peer monitoring requests occur during normal network operation
4. Attacker extracts logged responses containing complete network topology
5. Attacker identifies validator nodes via `peer_role: Validator` field
6. Attacker obtains network addresses for targeted DoS, eclipse attacks, or validator-specific attacks

## Impact Explanation

**Severity: Medium** ($10,000 tier per Aptos Bug Bounty)

This vulnerability falls under **Medium severity** as it enables **information disclosure** that facilitates network-level attacks:

- **Network Topology Mapping**: Complete visibility into peer connections enables adversaries to understand network structure and plan targeted attacks
- **Validator Identification**: Direct exposure of validator roles allows attackers to specifically target consensus-critical nodes
- **Attack Surface Expansion**: Network addresses enable targeted DoS, eclipse attacks, or validator isolation attempts
- **Reduced Defense-in-Depth**: Even with log access restrictions, logs should not contain sensitive operational data

While this does not directly cause loss of funds or consensus violations, it significantly weakens the security posture by providing attackers with reconnaissance information for more sophisticated attacks. The Aptos Bug Bounty program explicitly includes "State inconsistencies requiring intervention" under Medium severity, and this vulnerability could facilitate attacks leading to such states.

## Likelihood Explanation

**Likelihood: Medium**

While the vulnerability requires two conditions to be exploited, both are realistic:

1. **Log Access (Moderate Barrier)**:
   - System compromise or misconfiguration
   - Insider access (disgruntled operator, contractor)
   - Log aggregation service compromise
   - Backup or archived logs with insufficient access controls

2. **Trace Logging Enabled (Common Scenario)**:
   - Default log level is Info, but operators frequently enable trace logging for debugging [5](#0-4) 
   - Trace logs may be left enabled after troubleshooting
   - Development/staging environments often run with trace logging

The combination of these factors results in **Medium likelihood**. Defense-in-depth principles dictate that sensitive data should not be logged even at trace level, as operators often enable detailed logging without fully understanding security implications.

## Recommendation

**Fix:** Use Display formatting instead of Debug formatting when logging peer monitoring responses.

Change line 348 in `peer-monitoring-service/server/src/lib.rs` from:
```rust
format!("{:?}", response)
```

To:
```rust
format!("{}", response)
```

This will utilize the security-conscious Display implementations that redact sensitive data. Additionally, implement Display for `PeerMonitoringServiceResponse` to ensure all response types are properly formatted:

```rust
impl Display for PeerMonitoringServiceResponse {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::LatencyPing(response) => write!(f, "LatencyPing(counter: {})", response.ping_counter),
            Self::NetworkInformation(response) => Display::fmt(response, f),
            Self::NodeInformation(response) => Display::fmt(response, f),
            Self::ServerProtocolVersion(response) => write!(f, "ServerProtocolVersion({})", response.version),
        }
    }
}
```

**Additional Hardening:**
- Consider using `info!` or `debug!` level instead of `trace!` for response logging if it's operationally necessary
- Audit all other logging points in the peer monitoring service for similar issues
- Document in code comments that Debug formatting must never be used for responses containing sensitive data

## Proof of Concept

The vulnerability can be demonstrated by enabling trace logging and observing the logged output:

**Step 1: Enable trace logging**
```bash
RUST_LOG=trace cargo run --bin aptos-node
```

**Step 2: Trigger a network information request**
Any peer can send a `GetNetworkInformation` request to the node.

**Step 3: Observe logs**
The trace logs will contain entries like:
```
TRACE peer_monitoring_service: SentPeerMonitoringResponse { 
  response: "NetworkInformation(NetworkInformationResponse { 
    connected_peers: {
      PeerNetworkId { network_id: Validator, peer_id: 0x1234... }: ConnectionMetadata { 
        network_address: /ip4/192.168.1.100/tcp/6180, 
        peer_id: 0x1234..., 
        peer_role: Validator 
      },
      PeerNetworkId { network_id: Validator, peer_id: 0x5678... }: ConnectionMetadata { 
        network_address: /ip4/192.168.1.101/tcp/6180, 
        peer_id: 0x5678..., 
        peer_role: Validator 
      },
      ...
    }, 
    distance_from_validators: 0 
  })"
}
```

Compare this to the intended Display output which would show:
```
TRACE peer_monitoring_service: SentPeerMonitoringResponse { 
  response: "NetworkInformation({ num_connected_peers: 25, distance_from_validators: 0 })"
}
```

The Debug formatting exposes complete peer information while Display formatting only reveals aggregate statistics, demonstrating the security-conscious design being bypassed.

**Notes**

This vulnerability demonstrates a common anti-pattern where security-conscious abstractions (Display implementations for safe logging) are defeated by implementation choices (using Debug formatting). The fix is straightforward and preserves operational visibility while eliminating the information disclosure risk. The existence of the Display implementations shows clear security awareness by the original developers, making this a high-confidence finding where the intended design is known but not consistently applied.

### Citations

**File:** peer-monitoring-service/server/src/lib.rs (L343-355)
```rust
fn log_monitoring_service_response(
    monitoring_service_response: &Result<PeerMonitoringServiceResponse, PeerMonitoringServiceError>,
) {
    let response = match monitoring_service_response {
        Ok(response) => {
            format!("{:?}", response)
        },
        Err(error) => {
            format!("{:?}", error)
        },
    };
    trace!(LogSchema::new(LogEntry::SentPeerMonitoringResponse).response(&response));
}
```

**File:** peer-monitoring-service/types/src/response.rs (L51-55)
```rust
#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
pub struct NetworkInformationResponse {
    pub connected_peers: BTreeMap<PeerNetworkId, ConnectionMetadata>, // Connected peers
    pub distance_from_validators: u64, // The distance of the peer from the validator set
}
```

**File:** peer-monitoring-service/types/src/response.rs (L57-67)
```rust
// Display formatting provides a high-level summary of the response
impl Display for NetworkInformationResponse {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "{{ num_connected_peers: {:?}, distance_from_validators: {:?} }}",
            self.connected_peers.len(),
            self.distance_from_validators,
        )
    }
}
```

**File:** peer-monitoring-service/types/src/response.rs (L69-75)
```rust
/// Simple connection metadata associated with each peer
#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
pub struct ConnectionMetadata {
    pub network_address: NetworkAddress,
    pub peer_id: PeerId,
    pub peer_role: PeerRole,
}
```

**File:** config/src/config/logger_config.rs (L47-49)
```rust
            enable_telemetry_remote_log: true,
            enable_telemetry_flush: true,
            telemetry_level: Level::Error,
```
