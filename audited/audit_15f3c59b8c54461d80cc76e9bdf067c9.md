# Audit Report

## Title
Protocol Confusion Attack: Inbound Messages Not Validated Against Negotiated Protocols

## Summary
The network layer accepts and processes inbound messages with any valid `ProtocolId`, even if that protocol was not negotiated during the handshake. This violates the handshake agreement and enables protocol confusion attacks where malicious peers can send messages over protocols they never advertised support for.

## Finding Description

During the AptosNet handshake, peers exchange `HandshakeMsg` structures containing their supported protocols and negotiate a common set via `perform_handshake()`. [1](#0-0)  The negotiated protocols are stored in `ConnectionMetadata.application_protocols`. [2](#0-1) 

When sending messages, the code properly validates that the peer supports the protocol by calling `get_preferred_protocol_for_peer()`. [3](#0-2) 

**The Critical Flaw:** When receiving messages in `handle_inbound_network_message()`, there is NO validation that the incoming message's `protocol_id` matches the negotiated `application_protocols`. [4](#0-3)  The function only checks if a local upstream handler exists (`upstream_handlers.get(&protocol_id)`), but never verifies the protocol was agreed upon during handshake.

**Attack Scenario:**
1. Attacker peer advertises support for `[ProtocolId::MempoolDirectSend]` during handshake
2. Victim peer advertises support for `[ProtocolId::ConsensusRpcBcs, ProtocolId::MempoolDirectSend]`
3. Handshake negotiates intersection: `[ProtocolId::MempoolDirectSend]`
4. **Attack:** Attacker sends a message with `protocol_id = ProtocolId::ConsensusRpcBcs`
5. Victim processes it because they have a local handler for `ConsensusRpcBcs`
6. This bypasses the handshake agreement and protocol negotiation security guarantees

The codebase defines `ErrorCode::NotSupported` specifically for this scenario, [5](#0-4)  but this error is never used in production code to reject non-negotiated protocols.

## Impact Explanation

This vulnerability meets **Medium Severity** criteria per the Aptos bug bounty program:

1. **Protocol Confusion:** Enables messages to be sent over protocols not agreed upon, breaking protocol isolation guarantees
2. **Security Control Bypass:** Protocol-specific rate limits, permissions, or security checks can be circumvented
3. **Consensus Attack Surface:** If consensus protocols are accessible, malicious peers could potentially inject consensus messages from unauthorized nodes
4. **Resource Exhaustion:** Activates handlers that should not be active for a given connection, potentially causing unexpected resource consumption
5. **State Inconsistencies:** Different nodes may process different protocol messages from the same peer, potentially requiring intervention

This qualifies as "State inconsistencies requiring intervention" and "Significant protocol violations" under Medium/High severity.

## Likelihood Explanation

**Likelihood: Medium to High**

- **Ease of Exploitation:** Simple to execute - attacker just needs to establish a network connection and send crafted messages
- **No Special Requirements:** Does not require validator access, stake, or insider knowledge
- **Detection:** May be difficult to detect as messages appear valid and are processed normally
- **Prerequisites:** Attacker must be able to establish a peer connection, which is feasible for public network nodes

The attack is straightforward and requires minimal sophistication, making it a realistic threat.

## Recommendation

Add protocol validation in `handle_inbound_network_message()` to verify that incoming messages only use protocols negotiated during handshake:

```rust
fn handle_inbound_network_message(
    &mut self,
    message: NetworkMessage,
) -> Result<(), PeerManagerError> {
    // Extract protocol_id based on message type
    let protocol_id = match &message {
        NetworkMessage::DirectSendMsg(msg) => msg.protocol_id,
        NetworkMessage::RpcRequest(req) => req.protocol_id,
        NetworkMessage::Error(_) => return Ok(()), // Error messages don't need validation
        NetworkMessage::RpcResponse(_) => return self.handle_rpc_response(message), // Handled separately
    };
    
    // SECURITY CHECK: Verify protocol was negotiated during handshake
    if !self.connection_metadata.application_protocols.contains(protocol_id) {
        warn!(
            NetworkSchema::new(&self.network_context)
                .connection_metadata(&self.connection_metadata),
            protocol_id = ?protocol_id,
            "{} Peer {} attempted to use non-negotiated protocol: {:?}",
            self.network_context,
            self.remote_peer_id().short_str(),
            protocol_id,
        );
        
        // Send NotSupported error back to peer
        let error_msg = match &message {
            NetworkMessage::DirectSendMsg(_) => 
                NetworkMessage::Error(ErrorCode::NotSupported(NotSupportedType::DirectSendMsg(protocol_id))),
            NetworkMessage::RpcRequest(_) => 
                NetworkMessage::Error(ErrorCode::NotSupported(NotSupportedType::RpcRequest(protocol_id))),
            _ => unreachable!(),
        };
        
        let _ = write_reqs_tx.push((), error_msg);
        return Err(PeerManagerError::NotSupported(protocol_id));
    }
    
    // Continue with existing handler logic...
    match &message {
        NetworkMessage::DirectSendMsg(direct) => { /* existing code */ },
        NetworkMessage::RpcRequest(request) => { /* existing code */ },
        // ...
    }
}
```

## Proof of Concept

```rust
#[tokio::test]
async fn test_protocol_confusion_attack() {
    use crate::protocols::wire::handshake::v1::{ProtocolId, ProtocolIdSet, MessagingProtocolVersion};
    use crate::protocols::wire::messaging::v1::{NetworkMessage, DirectSendMsg};
    use std::collections::BTreeMap;

    // Setup: Attacker negotiates only MempoolDirectSend
    let mut attacker_protocols = BTreeMap::new();
    attacker_protocols.insert(
        MessagingProtocolVersion::V1,
        ProtocolIdSet::from_iter([ProtocolId::MempoolDirectSend])
    );
    
    // Victim supports both Mempool and Consensus protocols
    let mut victim_protocols = BTreeMap::new();
    victim_protocols.insert(
        MessagingProtocolVersion::V1,
        ProtocolIdSet::from_iter([
            ProtocolId::MempoolDirectSend,
            ProtocolId::ConsensusRpcBcs
        ])
    );
    
    // Handshake negotiates only MempoolDirectSend
    let attacker_handshake = HandshakeMsg {
        supported_protocols: attacker_protocols,
        chain_id: ChainId::test(),
        network_id: NetworkId::Validator,
    };
    
    let victim_handshake = HandshakeMsg {
        supported_protocols: victim_protocols,
        chain_id: ChainId::test(),
        network_id: NetworkId::Validator,
    };
    
    let (negotiated_version, negotiated_protocols) = 
        attacker_handshake.perform_handshake(&victim_handshake).unwrap();
    
    // Verify only MempoolDirectSend was negotiated
    assert!(negotiated_protocols.contains(ProtocolId::MempoolDirectSend));
    assert!(!negotiated_protocols.contains(ProtocolId::ConsensusRpcBcs));
    
    // ATTACK: Attacker sends message with ConsensusRpcBcs protocol
    let malicious_message = NetworkMessage::DirectSendMsg(DirectSendMsg {
        protocol_id: ProtocolId::ConsensusRpcBcs, // NOT NEGOTIATED!
        priority: 0,
        raw_msg: vec![1, 2, 3, 4],
    });
    
    // This message will be processed if victim has a ConsensusRpcBcs handler,
    // despite it never being negotiated during handshake.
    // The victim's handle_inbound_network_message() only checks:
    // - if upstream_handlers.get(&ProtocolId::ConsensusRpcBcs) exists
    // It does NOT check if ConsensusRpcBcs is in negotiated_protocols!
}
```

## Notes

The vulnerability exists because the receiving side trusts the `protocol_id` field in inbound messages without verifying it against the negotiated protocols stored in `ConnectionMetadata.application_protocols`. [6](#0-5)  The sending side correctly uses `supports_protocol()` checks, but the receiving side has no equivalent validation, creating an asymmetric security model that can be exploited.

### Citations

**File:** network/framework/src/protocols/wire/handshake/v1/mod.rs (L428-465)
```rust
    /// This function:
    /// 1. verifies that both HandshakeMsg are compatible and
    /// 2. finds out the intersection of protocols that is supported
    pub fn perform_handshake(
        &self,
        other: &HandshakeMsg,
    ) -> Result<(MessagingProtocolVersion, ProtocolIdSet), HandshakeError> {
        // verify that both peers are on the same chain
        if self.chain_id != other.chain_id {
            return Err(HandshakeError::InvalidChainId(
                other.chain_id,
                self.chain_id,
            ));
        }

        // verify that both peers are on the same network
        if self.network_id != other.network_id {
            return Err(HandshakeError::InvalidNetworkId(
                other.network_id,
                self.network_id,
            ));
        }

        // find the greatest common MessagingProtocolVersion where we both support
        // at least one common ProtocolId.
        for (our_handshake_version, our_protocols) in self.supported_protocols.iter().rev() {
            if let Some(their_protocols) = other.supported_protocols.get(our_handshake_version) {
                let common_protocols = our_protocols.intersect(their_protocols);

                if !common_protocols.is_empty() {
                    return Ok((*our_handshake_version, common_protocols));
                }
            }
        }

        // no intersection found
        Err(HandshakeError::NoCommonProtocols)
    }
```

**File:** network/framework/src/transport/mod.rs (L99-108)
```rust
#[derive(Clone, Deserialize, Eq, PartialEq, Serialize)]
pub struct ConnectionMetadata {
    pub remote_peer_id: PeerId,
    pub connection_id: ConnectionId,
    pub addr: NetworkAddress,
    pub origin: ConnectionOrigin,
    pub messaging_protocol: MessagingProtocolVersion,
    pub application_protocols: ProtocolIdSet,
    pub role: PeerRole,
}
```

**File:** network/framework/src/application/interface.rs (L142-158)
```rust
    fn get_preferred_protocol_for_peer(
        &self,
        peer: &PeerNetworkId,
        preferred_protocols: &[ProtocolId],
    ) -> Result<ProtocolId, Error> {
        let protocols_supported_by_peer = self.get_supported_protocols(peer)?;
        for protocol in preferred_protocols {
            if protocols_supported_by_peer.contains(*protocol) {
                return Ok(*protocol);
            }
        }
        Err(Error::NetworkError(format!(
            "None of the preferred protocols are supported by this peer! \
            Peer: {:?}, supported protocols: {:?}",
            peer, protocols_supported_by_peer
        )))
    }
```

**File:** network/framework/src/peer/mod.rs (L447-541)
```rust
    fn handle_inbound_network_message(
        &mut self,
        message: NetworkMessage,
    ) -> Result<(), PeerManagerError> {
        match &message {
            NetworkMessage::DirectSendMsg(direct) => {
                let data_len = direct.raw_msg.len();
                network_application_inbound_traffic(
                    self.network_context,
                    direct.protocol_id,
                    data_len as u64,
                );
                match self.upstream_handlers.get(&direct.protocol_id) {
                    None => {
                        counters::direct_send_messages(&self.network_context, UNKNOWN_LABEL).inc();
                        counters::direct_send_bytes(&self.network_context, UNKNOWN_LABEL)
                            .inc_by(data_len as u64);
                    },
                    Some(handler) => {
                        let key = (self.connection_metadata.remote_peer_id, direct.protocol_id);
                        let sender = self.connection_metadata.remote_peer_id;
                        let network_id = self.network_context.network_id();
                        let sender = PeerNetworkId::new(network_id, sender);
                        match handler.push(key, ReceivedMessage::new(message, sender)) {
                            Err(_err) => {
                                // NOTE: aptos_channel never returns other than Ok(()), but we might switch to tokio::sync::mpsc and then this would work
                                counters::direct_send_messages(
                                    &self.network_context,
                                    DECLINED_LABEL,
                                )
                                .inc();
                                counters::direct_send_bytes(&self.network_context, DECLINED_LABEL)
                                    .inc_by(data_len as u64);
                            },
                            Ok(_) => {
                                counters::direct_send_messages(
                                    &self.network_context,
                                    RECEIVED_LABEL,
                                )
                                .inc();
                                counters::direct_send_bytes(&self.network_context, RECEIVED_LABEL)
                                    .inc_by(data_len as u64);
                            },
                        }
                    },
                }
            },
            NetworkMessage::Error(error_msg) => {
                warn!(
                    NetworkSchema::new(&self.network_context)
                        .connection_metadata(&self.connection_metadata),
                    error_msg = ?error_msg,
                    "{} Peer {} sent an error message: {:?}",
                    self.network_context,
                    self.remote_peer_id().short_str(),
                    error_msg,
                );
            },
            NetworkMessage::RpcRequest(request) => {
                match self.upstream_handlers.get(&request.protocol_id) {
                    None => {
                        counters::direct_send_messages(&self.network_context, UNKNOWN_LABEL).inc();
                        counters::direct_send_bytes(&self.network_context, UNKNOWN_LABEL)
                            .inc_by(request.raw_request.len() as u64);
                    },
                    Some(handler) => {
                        let sender = self.connection_metadata.remote_peer_id;
                        let network_id = self.network_context.network_id();
                        let sender = PeerNetworkId::new(network_id, sender);
                        if let Err(err) = self
                            .inbound_rpcs
                            .handle_inbound_request(handler, ReceivedMessage::new(message, sender))
                        {
                            warn!(
                                NetworkSchema::new(&self.network_context)
                                    .connection_metadata(&self.connection_metadata),
                                error = %err,
                                "{} Error handling inbound rpc request: {}",
                                self.network_context,
                                err
                            );
                        }
                    },
                }
            },
            NetworkMessage::RpcResponse(_) => {
                // non-reference cast identical to this match case
                let NetworkMessage::RpcResponse(response) = message else {
                    unreachable!("NetworkMessage type changed between match and let")
                };
                self.outbound_rpcs.handle_inbound_response(response)
            },
        };
        Ok(())
    }
```

**File:** network/framework/src/protocols/wire/messaging/v1/mod.rs (L66-97)
```rust
#[derive(Clone, Debug, PartialEq, Eq, Deserialize, Serialize)]
#[cfg_attr(any(test, feature = "fuzzing"), derive(Arbitrary))]
pub enum ErrorCode {
    /// Failed to parse NetworkMessage when interpreting according to provided protocol version.
    ParsingError(ParsingErrorType),
    /// A message was received for a protocol that is not supported over this connection.
    NotSupported(NotSupportedType),
}

impl ErrorCode {
    pub fn parsing_error(message: u8, protocol: u8) -> Self {
        ErrorCode::ParsingError(ParsingErrorType { message, protocol })
    }
}

/// Flags an invalid network message with as much header information as possible. This is a message
/// that this peer cannot even parse its header information.
#[derive(Clone, Debug, PartialEq, Eq, Deserialize, Serialize)]
#[cfg_attr(any(test, feature = "fuzzing"), derive(Arbitrary))]
pub struct ParsingErrorType {
    message: u8,
    protocol: u8,
}

/// Flags an unsupported network message.  This is a message that a peer can parse its header
/// information but does not have a handler.
#[derive(Clone, Debug, PartialEq, Eq, Deserialize, Serialize)]
#[cfg_attr(any(test, feature = "fuzzing"), derive(Arbitrary))]
pub enum NotSupportedType {
    RpcRequest(ProtocolId),
    DirectSendMsg(ProtocolId),
}
```

**File:** network/framework/src/application/metadata.rs (L55-76)
```rust
    /// Returns true iff the peer has advertised support for the given protocol
    pub fn supports_protocol(&self, protocol_id: ProtocolId) -> bool {
        self.connection_metadata
            .application_protocols
            .contains(protocol_id)
    }

    /// Returns true iff the peer has advertised support for at least
    /// one of the given protocols.
    pub fn supports_any_protocol(&self, protocol_ids: &[ProtocolId]) -> bool {
        let protocol_id_set = ProtocolIdSet::from_iter(protocol_ids);
        !self
            .connection_metadata
            .application_protocols
            .intersect(&protocol_id_set)
            .is_empty()
    }

    /// Returns the set of supported protocols for the peer
    pub fn get_supported_protocols(&self) -> ProtocolIdSet {
        self.connection_metadata.application_protocols.clone()
    }
```
