# Audit Report

## Title
Unvalidated Eval Proof Usage in Batch Encryption State Transitions Enables Invalid State Persistence

## Summary
The batch encryption system's `prepare_individual()` method accepts eval proofs without validation, allowing state transitions to invalid intermediate states during error conditions. When decryption fails with an unvalidated eval proof, the invalid proof is permanently stored in the transaction's `FailedDecryption` state with no recovery mechanism, violating state consistency guarantees.

## Finding Description

The core vulnerability exists in the state transition flow from `Ciphertext` → `PreparedCiphertext` → decryption. The system fails to validate eval proofs before using them, breaking the principle of validated state transitions.

**The vulnerable code path:** [1](#0-0) 

This method accepts any `EvalProof` without validation and computes cryptographic pairings using it. If the eval proof is incorrect (due to computation bugs, wrong digest key, or round mismatch), the pairing output will be wrong, but the state transition succeeds.

**Validation exists but is never used:** [2](#0-1) 

The `DigestKey` provides a `verify_pf()` method to validate eval proofs against a digest, but this is never called before state transitions.

**Consensus layer usage without validation:** [3](#0-2) 

Eval proofs are computed and immediately used for decryption without intermediate validation. When decryption fails, the system cannot distinguish between:
- Invalid eval proof (wrong digest, wrong round, computation bug)
- Legitimate decryption failure (wrong key, corrupted ciphertext)

**Invalid state persistence:** [4](#0-3) 

When decryption fails, the unvalidated eval proof is stored in the `FailedDecryption` state. Since `EncryptedPayload` is serializable, this invalid state persists in storage. [5](#0-4) 

## Impact Explanation

**High Severity** - This issue causes:

1. **State Consistency Violation**: Transactions can transition to invalid intermediate states (`PreparedCiphertext` with wrong pairing output) without detection, violating the "State Consistency" invariant.

2. **Liveness Impact**: If eval proof computation has bugs (wrong digest key selection, round mismatch), all encrypted transactions in a block will fail decryption and be marked as `FailedDecryption` with no recovery path. This degrades consensus functionality.

3. **Deterministic Execution Risk**: Different validators computing slightly different eval proofs (due to timing, rounding, or implementation variations) would produce different decryption results, potentially violating deterministic execution.

4. **No Error Recovery**: Once an incorrect eval proof is stored in `FailedDecryption` state, there's no mechanism to retry with correct parameters, permanently marking valid transactions as failed.

This meets **High Severity** criteria for "Significant protocol violations" and "Validator node slowdowns" as encrypted transaction processing would fail systematically if eval proof computation has any bugs.

## Likelihood Explanation

**Moderate likelihood** - This occurs when:

1. **Implementation bugs in eval proof computation** - Any bug in the FFT domain computation, polynomial evaluation, or multi-point evaluation could produce incorrect eval proofs that pass through unvalidated.

2. **Configuration mismatches** - If the digest key's round number doesn't match the encryption round, eval proofs will be wrong but accepted.

3. **Serialization/deserialization errors** - Eval proofs are serialized in `EncryptedPayload`. Any corruption during storage or network transmission would be undetected.

4. **Race conditions** - If the digest changes between eval proof computation and usage (concurrent modifications), wrong eval proofs would be used.

While the current implementation computes eval proofs locally, the lack of validation means any future bug or edge case will not be caught until after state transitions occur.

## Recommendation

**Add mandatory eval proof validation before state transitions:**

```rust
fn prepare_individual(
    &self,
    digest: &Digest,
    eval_proof: &EvalProof,
) -> Result<PreparedBIBECiphertext> {
    // VALIDATION: Verify eval proof before using it
    // This requires access to DigestKey, so it should be passed as parameter
    // or verification should be done by caller before prepare_individual
    
    let pairing_output = PairingSetting::pairing(digest.as_g1(), self.ct_g2[0])
        + PairingSetting::pairing(**eval_proof, self.ct_g2[1]);

    Ok(PreparedBIBECiphertext {
        pairing_output,
        ct_g2: self.ct_g2[2].into(),
        padded_key: self.padded_key.clone(),
        symmetric_ciphertext: self.symmetric_ciphertext.clone(),
    })
}
```

**Add validation in consensus decryption pipeline:** [6](#0-5) 

After this line, add:
```rust
// Verify all eval proofs before using them
digest_key.verify_all(&digest, &proofs)?;
```

**Alternative: Make prepare() validate by default:**

Modify the API so that only the batch `prepare()` method exists, which internally validates:

```rust
fn prepare(&self, digest: &Digest, eval_proofs: &EvalProofs, digest_key: &DigestKey) -> Result<PreparedBIBECiphertext> {
    let pf = eval_proofs
        .get(&self.id)
        .ok_or(BatchEncryptionError::UncomputedEvalProofError)?;
    
    // Verify before using
    digest_key.verify(digest, eval_proofs, self.id)?;
    
    self.prepare_individual(digest, &pf)
}
```

## Proof of Concept

```rust
#[test]
fn test_unvalidated_eval_proof_creates_invalid_state() {
    use aptos_batch_encryption::{
        schemes::fptx::FPTX,
        traits::BatchThresholdEncryption,
        shared::{
            ciphertext::StandardCiphertext,
            digest::{DigestKey, EvalProof},
            ids::{Id, IdSet},
        },
    };
    use aptos_crypto::arkworks::shamir::ShamirThresholdConfig;
    use ark_std::rand::thread_rng;
    
    let mut rng = thread_rng();
    let tc = ShamirThresholdConfig::new(1, 1);
    let (ek, dk, _, _) = FPTX::setup_for_testing(rng.gen(), 8, 1, &tc).unwrap();
    
    // Encrypt a ciphertext
    let ct: StandardCiphertext = ek.encrypt(&mut rng, 
        &String::from("test"), 
        &String::from("data")).unwrap();
    
    // Create correct digest and eval proofs
    let mut ids = IdSet::with_capacity(8).unwrap();
    ids.add(&ct.id());
    ids.compute_poly_coeffs();
    let (digest, proofs_promise) = dk.digest(&mut ids, 0).unwrap();
    let correct_proofs = proofs_promise.compute_all(&dk);
    
    // Create WRONG digest (different round)
    let (wrong_digest, wrong_proofs_promise) = dk.digest(&mut ids, 0).unwrap();
    let wrong_eval_proof = wrong_proofs_promise.compute_all(&dk)
        .get(&ct.id()).unwrap();
    
    // BUG: prepare_individual accepts wrong eval proof without validation
    let prepared = ct.prepare_individual(&digest, &wrong_eval_proof).unwrap();
    
    // State is now INVALID - prepared ciphertext has wrong pairing output
    // Decryption will fail but error doesn't indicate eval proof was wrong
    
    // Verify that using wrong proof causes decryption to fail
    let dk = reconstruct_decryption_key(...);
    let result: Result<String> = dk.decrypt(&prepared);
    
    // This will fail, but we can't tell if it's because:
    // 1. Wrong eval proof (should be retryable)
    // 2. Wrong decryption key (legitimate failure)
    // 3. Corrupted ciphertext (legitimate failure)
    assert!(result.is_err());
    
    // Meanwhile, correct eval proof would work:
    let correct_prepared = ct.prepare_individual(&digest, 
        &correct_proofs.get(&ct.id()).unwrap()).unwrap();
    let correct_result: String = dk.decrypt(&correct_prepared).unwrap();
    assert_eq!(correct_result, "test");
}
```

## Notes

The vulnerability is subtle because eval proofs are computed locally rather than received from untrusted sources in the current implementation. However, the lack of validation creates several risks:

1. **Future bugs undetected**: Any bug in eval proof computation will not be caught until after invalid state transitions
2. **No defensive programming**: The system assumes all eval proofs are correct, violating defense-in-depth principles
3. **Poor error handling**: Cannot distinguish between different failure modes during decryption
4. **State consistency risk**: If validators compute slightly different eval proofs due to implementation variations, consensus determinism could break

The fix is straightforward: validate eval proofs before using them for state transitions, using the existing `verify_pf()` method.

### Citations

**File:** crates/aptos-batch-encryption/src/shared/ciphertext/bibe.rs (L92-106)
```rust
    fn prepare_individual(
        &self,
        digest: &Digest,
        eval_proof: &EvalProof,
    ) -> Result<PreparedBIBECiphertext> {
        let pairing_output = PairingSetting::pairing(digest.as_g1(), self.ct_g2[0])
            + PairingSetting::pairing(**eval_proof, self.ct_g2[1]);

        Ok(PreparedBIBECiphertext {
            pairing_output,
            ct_g2: self.ct_g2[2].into(),
            padded_key: self.padded_key.clone(),
            symmetric_ciphertext: self.symmetric_ciphertext.clone(),
        })
    }
```

**File:** crates/aptos-batch-encryption/src/shared/digest.rs (L138-146)
```rust
    fn verify_pf(&self, digest: &Digest, id: Id, pf: G1Affine) -> Result<()> {
        // TODO use multipairing here?
        Ok((PairingSetting::pairing(
            pf,
            self.tau_g2 - G2Projective::from(G2Affine::generator() * id.x()),
        ) == PairingSetting::pairing(digest.as_g1(), G2Affine::generator()))
        .then_some(())
        .ok_or(BatchEncryptionError::EvalProofVerifyError)?)
    }
```

**File:** consensus/src/pipeline/decryption_pipeline_builder.rs (L113-130)
```rust
        let proofs = FPTXWeighted::eval_proofs_compute_all(&proofs_promise, &digest_key);

        let maybe_decryption_key = secret_shared_key_rx
            .await
            .expect("decryption key should be available");
        // TODO(ibalajiarun): account for the case where decryption key is not available
        let decryption_key = maybe_decryption_key.expect("decryption key should be available");

        let decrypted_txns = encrypted_txns
            .into_par_iter()
            .zip(txn_ciphertexts)
            .map(|(mut txn, ciphertext)| {
                let eval_proof = proofs.get(&ciphertext.id()).expect("must exist");
                if let Ok(payload) = FPTXWeighted::decrypt_individual::<DecryptedPayload>(
                    &decryption_key.key,
                    &ciphertext,
                    &digest,
                    &eval_proof,
```

**File:** consensus/src/pipeline/decryption_pipeline_builder.rs (L140-145)
```rust
                } else {
                    txn.payload_mut()
                        .as_encrypted_payload_mut()
                        .map(|p| p.into_failed_decryption(eval_proof).expect("must happen"))
                        .expect("must exist");
                }
```

**File:** types/src/transaction/encrypted_payload.rs (L48-53)
```rust
    FailedDecryption {
        ciphertext: Ciphertext,
        extra_config: TransactionExtraConfig,
        payload_hash: HashValue,
        eval_proof: EvalProof,
    },
```
