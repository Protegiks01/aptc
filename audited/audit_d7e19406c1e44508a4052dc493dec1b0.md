# Audit Report

## Title
Unauthenticated Remote Executor Service Enables Message Injection and Consensus Disruption

## Summary
The remote executor service (`secure/net` and `execution/executor-service`) lacks cryptographic authentication on its gRPC-based network protocol, allowing any network-accessible attacker to send arbitrary block execution commands to executor shards. This bypasses the intended coordinator-shard trust model and can disrupt consensus by causing denial of service or state inconsistencies.

## Finding Description

The security question asks about the `NetworkMessage.sender` SocketAddr field having cryptographic authentication. Investigation reveals that this struct is actually **dead code** marked with `#[allow(dead_code)]` and never used in the codebase. [1](#0-0) 

The actual network protocol uses a protobuf `NetworkMessage` that contains only `message: bytes` and `message_type: string` - **no sender field exists at all**: [2](#0-1) 

The gRPC server implementation obtains the TCP connection's `remote_addr` but **only uses it for error logging**, not for authorization: [3](#0-2) 

Notice at line 100 the `remote_addr` is retrieved, but it's only referenced in the error message at line 110-112. The actual message forwarded to handlers (line 107) contains no sender information.

The executor service receives these unauthenticated messages and **directly deserializes and executes them without verification**: [4](#0-3) 

At line 89, the message data is blindly deserialized as a `RemoteExecutionRequest` and executed. There is no cryptographic signature verification, no authentication token, and no validation of the sender's identity.

This remote executor is used in **production consensus flow** when remote addresses are configured: [5](#0-4) 

**Attack Flow:**
1. Attacker gains network access to an executor shard's gRPC endpoint (ports like 52200)
2. Attacker crafts a malicious `ExecuteBlockCommand` with arbitrary transactions
3. Attacker sends this via gRPC to the executor shard
4. Shard receives and deserializes the command without authentication
5. Shard executes the malicious transactions, consuming resources and blocking legitimate commands
6. Coordinator's real commands time out or receive wrong results
7. Block execution fails, consensus cannot progress

**Broken Invariants:**
- **Deterministic Execution** (Invariant #1): Different nodes may execute different blocks if attackers interfere with remote executors
- **Consensus Safety** (Invariant #2): Consensus can be disrupted if executor shards are unresponsive or return incorrect results

## Impact Explanation

**Severity: High** (up to $50,000 per Aptos bug bounty)

This vulnerability meets the **High Severity** criteria:
- **"Validator node slowdowns"**: Malicious commands can cause executor shards to waste resources on attacker's transactions, delaying legitimate block execution
- **"Significant protocol violations"**: Bypasses the intended coordinator-shard authorization model

The attack can cause:
1. **Denial of Service**: Legitimate coordinator commands delayed or dropped while shard processes attacker's commands
2. **Resource Exhaustion**: Attacker sends computationally expensive transactions to exhaust CPU/memory
3. **State Confusion**: Shard may be in inconsistent state when real commands arrive
4. **Consensus Liveness Impact**: If multiple shards are attacked, block execution fails and consensus cannot progress

This does not qualify as **Critical** because:
- It requires network access to internal services (not completely external)
- It doesn't directly cause fund loss or permanent state corruption
- It's a liveness/availability issue rather than safety violation

## Likelihood Explanation

**Likelihood: Medium-High**

**Requirements for exploitation:**
- Network access to executor shard gRPC endpoints
- Knowledge of port numbers and message format
- Ability to craft BCS-serialized messages

**Mitigating factors:**
- Executor services are likely deployed in private/internal networks
- Proper network segmentation would prevent external access

**Aggravating factors:**
- No authentication means ANY network peer can exploit this
- The code provides no defense-in-depth if network isolation fails
- Cloud misconfigurations (exposed ports) are common
- Internal attackers (compromised services in same network) can easily exploit

The lack of authentication is a **defense-in-depth failure**. Even if network isolation is intended, cryptographic authentication should be present to prevent exploitation if network controls fail.

## Recommendation

Implement cryptographic authentication for all remote executor service communications:

**1. Add mutual TLS (mTLS) to gRPC connections:**
- Configure TLS certificates for coordinator and all shards
- Verify peer certificates on both client and server sides
- Use certificate-based identity verification

**2. Add message-level authentication:**
- Sign each `NetworkMessage` with the sender's private key
- Include sender's public key or certificate in message header
- Verify signature before deserializing and executing commands

**3. Implement allowlist-based authorization:**
- Maintain allowlist of authorized coordinator addresses
- Reject connections/messages from non-allowlisted peers
- Use certificate Subject/CN for identity matching

**Example fix for gRPC server (pseudocode):**

```rust
// In grpc_network_service/mod.rs
async fn simple_msg_exchange(
    &self,
    request: Request<NetworkMessage>,
) -> Result<Response<Empty>, Status> {
    // Verify peer certificate
    let peer_cert = request
        .peer_certs()
        .ok_or_else(|| Status::unauthenticated("No peer certificate"))?;
    
    // Verify peer is authorized coordinator
    if !self.is_authorized_coordinator(&peer_cert) {
        return Err(Status::permission_denied("Unauthorized peer"));
    }
    
    // Verify message signature
    let network_message = request.into_inner();
    if !verify_message_signature(&network_message) {
        return Err(Status::invalid_argument("Invalid signature"));
    }
    
    // Proceed with message handling...
}
```

## Proof of Concept

```rust
// PoC: Unauthenticated remote executor exploitation
// Run against a deployed executor service to demonstrate vulnerability

use aptos_protos::remote_executor::v1::{
    network_message_service_client::NetworkMessageServiceClient,
    NetworkMessage,
};
use tonic::Request;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Connect to victim executor shard (no TLS, no authentication)
    let victim_addr = "http://192.168.1.100:52201"; // Example shard address
    let mut client = NetworkMessageServiceClient::connect(victim_addr).await?;
    
    // Craft malicious ExecuteBlockCommand
    // (In real exploit, would craft valid BCS-serialized command with
    // resource-intensive transactions to cause DoS)
    let malicious_payload = vec![0xde, 0xad, 0xbe, 0xef]; // Placeholder
    
    let message = NetworkMessage {
        message: malicious_payload,
        message_type: "execute_command_0".to_string(), // Target shard 0
    };
    
    // Send unauthenticated message - no signature, no certificate check
    // The server will accept and attempt to execute this!
    let response = client.simple_msg_exchange(Request::new(message)).await?;
    
    println!("Attack successful! Server accepted unauthenticated message: {:?}", response);
    println!("Executor shard is now processing our malicious command,");
    println!("blocking legitimate coordinator commands and disrupting consensus.");
    
    Ok(())
}
```

**To reproduce:**
1. Deploy remote executor service with `cargo run --bin executor-service`
2. Configure remote addresses in coordinator
3. Run this PoC against a shard's gRPC endpoint
4. Observe that messages are accepted without authentication
5. Monitor that legitimate block execution is delayed/failed

**Notes**

The investigation revealed that the `NetworkMessage.sender` field mentioned in the security question is actually unused dead code. The real vulnerability is the complete absence of authentication in the protobuf `NetworkMessage` protocol and gRPC implementation. The TCP-level `remote_addr` is retrieved but never used for authorization decisions.

This represents a systemic design flaw in the `secure/net` module that violates the principle of defense-in-depth. While network isolation may be the primary security control, the lack of application-layer authentication means any network control failure (misconfiguration, internal compromise, cloud exposure) immediately exposes the system to exploitation.

### Citations

**File:** secure/net/src/network_controller/mod.rs (L22-28)
```rust
#[derive(Clone, Debug, Deserialize, Serialize)]
#[allow(dead_code)]
pub struct NetworkMessage {
    pub sender: SocketAddr,
    pub message: Message,
    pub message_type: MessageType,
}
```

**File:** protos/rust/src/pb/aptos.remote_executor.v1.rs (L7-13)
```rust
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetworkMessage {
    #[prost(bytes="vec", tag="1")]
    pub message: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, tag="2")]
    pub message_type: ::prost::alloc::string::String,
}
```

**File:** secure/net/src/grpc_network_service/mod.rs (L93-115)
```rust
    async fn simple_msg_exchange(
        &self,
        request: Request<NetworkMessage>,
    ) -> Result<Response<Empty>, Status> {
        let _timer = NETWORK_HANDLER_TIMER
            .with_label_values(&[&self.self_addr.to_string(), "inbound_msgs"])
            .start_timer();
        let remote_addr = request.remote_addr();
        let network_message = request.into_inner();
        let msg = Message::new(network_message.message);
        let message_type = MessageType::new(network_message.message_type);

        if let Some(handler) = self.inbound_handlers.lock().unwrap().get(&message_type) {
            // Send the message to the registered handler
            handler.send(msg).unwrap();
        } else {
            error!(
                "No handler registered for sender: {:?} and msg type {:?}",
                remote_addr, message_type
            );
        }
        Ok(Response::new(Empty {}))
    }
```

**File:** execution/executor-service/src/remote_cordinator_client.rs (L80-113)
```rust
    fn receive_execute_command(&self) -> ExecutorShardCommand<RemoteStateViewClient> {
        match self.command_rx.recv() {
            Ok(message) => {
                let _rx_timer = REMOTE_EXECUTOR_TIMER
                    .with_label_values(&[&self.shard_id.to_string(), "cmd_rx"])
                    .start_timer();
                let bcs_deser_timer = REMOTE_EXECUTOR_TIMER
                    .with_label_values(&[&self.shard_id.to_string(), "cmd_rx_bcs_deser"])
                    .start_timer();
                let request: RemoteExecutionRequest = bcs::from_bytes(&message.data).unwrap();
                drop(bcs_deser_timer);

                match request {
                    RemoteExecutionRequest::ExecuteBlock(command) => {
                        let init_prefetch_timer = REMOTE_EXECUTOR_TIMER
                            .with_label_values(&[&self.shard_id.to_string(), "init_prefetch"])
                            .start_timer();
                        let state_keys = Self::extract_state_keys(&command);
                        self.state_view_client.init_for_block(state_keys);
                        drop(init_prefetch_timer);

                        let (sub_blocks, concurrency, onchain_config) = command.into();
                        ExecutorShardCommand::ExecuteSubBlocks(
                            self.state_view_client.clone(),
                            sub_blocks,
                            concurrency,
                            onchain_config,
                        )
                    },
                }
            },
            Err(_) => ExecutorShardCommand::Stop,
        }
    }
```

**File:** execution/executor/src/workflow/do_get_execution_output.rs (L256-276)
```rust
    fn execute_block_sharded<V: VMBlockExecutor>(
        partitioned_txns: PartitionedTransactions,
        state_view: Arc<CachedStateView>,
        onchain_config: BlockExecutorConfigFromOnchain,
    ) -> Result<Vec<TransactionOutput>> {
        if !get_remote_addresses().is_empty() {
            Ok(V::execute_block_sharded(
                &REMOTE_SHARDED_BLOCK_EXECUTOR.lock(),
                partitioned_txns,
                state_view,
                onchain_config,
            )?)
        } else {
            Ok(V::execute_block_sharded(
                &SHARDED_BLOCK_EXECUTOR.lock(),
                partitioned_txns,
                state_view,
                onchain_config,
            )?)
        }
    }
```
