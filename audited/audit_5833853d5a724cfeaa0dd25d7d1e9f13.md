# Audit Report

## Title
API Key and Authentication Header Exposure in Faucet Configuration Debug Logging

## Summary
The `FaucetManager` struct and its nested configuration structures derive the standard `Debug` trait without redacting sensitive API credentials. When the faucet service starts, it logs the entire `RunConfig` using debug formatting, which exposes `api_key` and `additional_headers` fields in plain text. While private keys are properly protected via `SilentDebug`, API keys and authentication headers are not redacted.

## Finding Description

The vulnerability exists in a chain of derived `Debug` implementations across multiple configuration structures:

**Entry Point - FaucetManager:** [1](#0-0) 

**Logging Location - RunConfig:** [2](#0-1) 

This logging statement executes on every faucet startup and outputs the entire configuration with pretty-print debug formatting (`{:#?}`), which traverses all nested structures.

**The Exposure Path:**

1. `FaucetManager` contains `config: RunConfig`
2. `RunConfig` derives Debug and contains `funder_config: FunderConfig` [3](#0-2) 

3. `FunderConfig` can be `MintFunder(MintFunderConfig)` which derives Debug: [4](#0-3) 

4. `MintFunderConfig` derives Debug and contains (via flattening) `ApiConnectionConfig`: [5](#0-4) 

5. **Critical Issue**: `ApiConnectionConfig` derives standard Debug and contains unredacted sensitive fields: [6](#0-5) 

The `api_key: Option<String>` (line 63) and `additional_headers: Option<HashMap<String, String>>` (line 68) fields use standard Debug formatting, which outputs their values in plain text.

**What IS Properly Protected:**

Private keys are properly redacted because `Ed25519PrivateKey` uses the `SilentDebug` derive macro: [7](#0-6) 

The `SilentDebug` implementation outputs `<elided secret for Ed25519PrivateKey>` instead of the actual key: [8](#0-7) 

Even when wrapped in `ConfigKey<Ed25519PrivateKey>`, the inner `SilentDebug` implementation is respected, so private keys are safe.

**What IS NOT Protected:**

API keys and authentication headers in `ApiConnectionConfig` have no such protection and will be logged in plain text, potentially exposing:
- Node API access credentials
- Bearer tokens in additional_headers
- Custom authentication headers

## Impact Explanation

This qualifies as **Medium Severity** per Aptos bug bounty criteria as an information disclosure vulnerability:

**Information Leak:** API keys and authentication credentials are exposed in application logs, which are typically:
- Aggregated to centralized logging systems
- Accessible to operations staff and potentially contractors
- Stored long-term and may be backed up to less secure storage
- Sometimes exposed in error reports or monitoring dashboards

**Potential Attack Escalation:** An attacker with access to these logs could:
1. Use the exposed API key to access the node API directly
2. Submit unauthorized transactions via the compromised credentials
3. Query sensitive blockchain state information
4. Potentially identify and exploit further vulnerabilities in the node

While this doesn't directly cause consensus violations or funds loss, it provides attackers with credentials that could enable such attacks, making it a Medium severity finding rather than Low.

## Likelihood Explanation

**High Likelihood of Occurrence:**

1. **Automatic Execution**: The logging occurs unconditionally on line 86 of `run_impl()`, which is called on every faucet startup via the public `run()` method
2. **Production Code**: This is not test-only code - the logging is active in production builds (not behind `#[cfg(test)]`)
3. **Frequent Operations**: Faucet services are regularly started, stopped, and restarted during development and testing
4. **Wide Log Distribution**: Application logs are typically distributed to multiple systems and personnel

**Attacker Requirements:**
- Access to log files or logging infrastructure (common for insiders, contractors, or via log aggregation system compromise)
- No special privileges required on the blockchain itself

## Recommendation

Implement custom `Debug` trait implementations that redact sensitive fields:

**For ApiConnectionConfig:**
```rust
impl fmt::Debug for ApiConnectionConfig {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("ApiConnectionConfig")
            .field("node_url", &self.node_url)
            .field("api_key", &self.api_key.as_ref().map(|_| "<redacted>"))
            .field("additional_headers", &self.additional_headers.as_ref().map(|_| "<redacted>"))
            .field("chain_id", &self.chain_id)
            .finish()
    }
}
```

Remove the `Debug` derive from `ApiConnectionConfig` and implement the manual version above.

**For Higher-Level Structs:**

Consider whether `FaucetManager` and `RunConfig` should derive Debug at all, or implement custom Debug that's more selective about what gets logged.

**Alternative Approach:**

Create a `SecretString` wrapper type that automatically redacts itself in Debug output:
```rust
#[derive(Clone, Serialize, Deserialize)]
pub struct SecretString(String);

impl fmt::Debug for SecretString {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "<redacted>")
    }
}
```

Then use `Option<SecretString>` instead of `Option<String>` for sensitive fields.

## Proof of Concept

**Setup:**
1. Configure a faucet with an API key in the config
2. Start the faucet service

**Expected Vulnerable Output:**
```
INFO Running with config: RunConfig {
    ...
    funder_config: MintFunder(MintFunderConfig {
        api_connection_config: ApiConnectionConfig {
            node_url: Url { ... },
            api_key: Some("secret-api-key-12345"),
            additional_headers: Some({
                "Authorization": "Bearer sensitive-token-xyz"
            }),
            ...
        },
        ...
    }),
    ...
}
```

**Verification Steps:**
1. Create a minimal test configuration with API credentials
2. Call `RunConfig::run()` 
3. Check the log output for exposed credentials
4. Confirm that API key and headers appear in plain text

**Code to Reproduce:**
```rust
use aptos_faucet_core::server::RunConfig;

#[tokio::test]
async fn test_credential_exposure() {
    // Load or create a RunConfig with API key set
    let config = /* ... config with api_key = Some("secret123") ... */;
    
    // This will log the config with exposed credentials
    // Check logs for "secret123" appearing in plain text
    let result = config.run().await;
}
```

The vulnerability is confirmed when sensitive API credentials appear unredacted in the log output.

## Notes

- **Private keys are SAFE**: The `Ed25519PrivateKey` type properly uses `SilentDebug` and will show `<elided secret for Ed25519PrivateKey>` instead of actual key material
- **Scope limitation**: This issue affects the local testnet faucet tooling, not core consensus/execution components
- **Real-world impact**: While this is tooling code, API credentials could provide access to production or testnet nodes if misconfigured
- **Defense in depth**: Even for test/dev tooling, credential hygiene is important as these systems often have elevated access rights

### Citations

**File:** crates/aptos/src/node/local_testnet/faucet.rs (L41-45)
```rust
#[derive(Clone, Debug)]
pub struct FaucetManager {
    pub config: RunConfig,
    pub prerequisite_health_checkers: HashSet<HealthChecker>,
}
```

**File:** crates/aptos-faucet/core/src/server/run.rs (L55-74)
```rust
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct RunConfig {
    /// API server config.
    pub server_config: ServerConfig,

    /// Metrics server config.
    metrics_server_config: MetricsServerConfig,

    /// Configs for any Bypassers we might want to enable.
    bypasser_configs: Vec<BypasserConfig>,

    /// Configs for any Checkers we might want to enable.
    checker_configs: Vec<CheckerConfig>,

    /// Config for the Funder component.
    funder_config: FunderConfig,

    /// General args for the runner / handler.
    handler_config: HandlerConfig,
}
```

**File:** crates/aptos-faucet/core/src/server/run.rs (L85-86)
```rust
    async fn run_impl(self, port_tx: Option<OneShotSender<u16>>) -> Result<()> {
        info!("Running with config: {:#?}", self);
```

**File:** crates/aptos-faucet/core/src/funder/mod.rs (L67-79)
```rust
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(tag = "type")]
pub enum FunderConfig {
    /// This funder does nothing and returns nothing.
    FakeFunder(FakeFunderConfig),

    /// This funder uses the delegation + minting mechanism to fund.
    MintFunder(MintFunderConfig),

    /// This funder creates and funds accounts by using + transferring
    /// coins from a pre-funded account provided in configuration.
    TransferFunder(TransferFunderConfig),
}
```

**File:** crates/aptos-faucet/core/src/funder/mint.rs (L101-120)
```rust
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct MintFunderConfig {
    #[serde(flatten)]
    pub api_connection_config: ApiConnectionConfig,

    #[serde(flatten)]
    pub transaction_submission_config: TransactionSubmissionConfig,

    pub assets: HashMap<String, MintAssetConfig>,

    /// Default asset to use when no asset is specified in requests.
    /// If not provided, defaults to "apt".
    #[serde(default = "MintFunderConfig::get_default_asset_name")]
    pub default_asset: String,

    /// Default amount of coins to fund.
    /// If not provided, defaults to 100_000_000_000.
    #[serde(default = "MintFunderConfig::get_default_amount_to_fund")]
    pub amount_to_fund: u64,
}
```

**File:** crates/aptos-faucet/core/src/funder/common.rs (L54-75)
```rust
#[derive(Clone, Debug, Deserialize, Parser, Serialize)]
pub struct ApiConnectionConfig {
    /// Aptos node (any node type with an open API) server URL.
    /// Include the port in this if not using the default for the scheme.
    #[clap(long, default_value = "https://fullnode.testnet.aptoslabs.com/")]
    pub node_url: Url,

    /// API key for talking to the node API.
    #[clap(long)]
    pub api_key: Option<String>,

    /// Any additional headers to send with the request. We don't accept this on the
    /// CLI.
    #[clap(skip)]
    pub additional_headers: Option<HashMap<String, String>>,

    /// Chain ID of the network this client is connecting to. For example, for mainnet:
    /// "MAINNET" or 1, testnet: "TESTNET" or 2. If there is no predefined string
    /// alias (e.g. "MAINNET"), just use the number. Note: Chain ID of 0 is not allowed.
    #[clap(long, default_value_t = ChainId::testnet())]
    pub chain_id: ChainId,
}
```

**File:** crates/aptos-crypto/src/ed25519/ed25519_keys.rs (L23-24)
```rust
#[derive(DeserializeKey, SerializeKey, SilentDebug, SilentDisplay)]
pub struct Ed25519PrivateKey(pub(crate) ed25519_dalek::SecretKey);
```

**File:** crates/aptos-crypto-derive/src/lib.rs (L134-140)
```rust
    quote! {
        // In order to ensure that secrets are never leaked, Debug is elided
        impl #impl_generics ::std::fmt::Debug for #name #ty_generics #where_clause {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                write!(f, "<elided secret for {}>", stringify!(#name))
            }
        }
```
