# Audit Report

## Title
Missing Chain ID Validation and Protocol Version Negotiation in Indexer-GRPC Heartbeat Protocol

## Summary
The HeartbeatRequest/Response protocol in the indexer-grpc system lacks both protocol version negotiation and chain ID validation. This allows data services from different chains to register with a GrpcManager, potentially causing cross-chain data contamination and service routing failures.

## Finding Description

The indexer-grpc system implements a heartbeat protocol where data services periodically send `HeartbeatRequest` messages to a `GrpcManager`. The protocol has two critical security gaps:

**1. No Protocol Version Negotiation:**
The protobuf schema defines `HeartbeatRequest` and `HeartbeatResponse` without any protocol version field: [1](#0-0) 

**2. No Chain ID Validation:**
When the `GrpcManager` receives heartbeats containing `ServiceInfo` with chain-specific information (including `chain_id`), it stores this information without validating that the `chain_id` matches the manager's configured chain: [2](#0-1) 

The handler functions (`handle_live_data_service_info`, `handle_historical_data_service_info`, `handle_fullnode_info`, `handle_grpc_manager_info`) accept and store service information without chain ID validation: [3](#0-2) 

**Contrast with Other Components:**
Other indexer components explicitly validate chain IDs. For example, the cache worker validates chain ID mismatches: [4](#0-3) 

And the data service validates chain ID consistency: [5](#0-4) 

**Attack Scenario:**
1. Attacker runs a malicious data service configured for Chain A (e.g., testnet with chain_id=1)
2. GrpcManager is configured for Chain B (e.g., mainnet with chain_id=2)
3. Malicious service sends heartbeats with `LiveDataServiceInfo { chain_id: 1, ... }`
4. GrpcManager accepts and stores this service without validation
5. When clients request data, `pick_live_data_service()` may route them to the wrong-chain service: [6](#0-5) 

6. Clients receive transactions and blockchain data from Chain A when expecting Chain B

## Impact Explanation

**However, this issue does NOT meet the Aptos bug bounty severity criteria** because:

1. **Not a Core Blockchain Issue**: The indexer-grpc system is an off-chain data serving infrastructure, not part of the core blockchain consensus, execution, or state management systems.

2. **No Impact on Blockchain Security**: This vulnerability does not affect:
   - Consensus safety or liveness
   - Move VM execution
   - On-chain state integrity
   - Validator operations
   - Fund security
   - Governance or staking systems

3. **Limited to Data Service Quality**: The impact is restricted to off-chain applications that query blockchain data through the indexer API. While inconvenient, this does not compromise blockchain security.

The valid impact categories in the Aptos bug bounty program all focus on core blockchain security (consensus violations, fund loss, validator node issues), none of which apply to this indexer infrastructure issue.

## Likelihood Explanation

While technically exploitable (an attacker can easily run a malicious data service and send heartbeats), the security impact is limited to data service infrastructure quality, not blockchain security.

## Recommendation

Despite not meeting bug bounty criteria, the issue should be fixed to improve service reliability:

1. **Add Protocol Version Field**: Include a `protocol_version` field in `HeartbeatRequest`/`HeartbeatResponse`
2. **Validate Chain ID**: Add validation in `handle_heartbeat()`:

```rust
pub(crate) fn handle_heartbeat(&self, address: GrpcAddress, info: Info) -> Result<()> {
    // Validate chain_id matches
    let info_chain_id = match &info {
        Info::LiveDataServiceInfo(i) => i.chain_id,
        Info::HistoricalDataServiceInfo(i) => i.chain_id,
        Info::FullnodeInfo(i) => i.chain_id,
        Info::GrpcManagerInfo(i) => i.chain_id,
    };
    
    if info_chain_id != self.chain_id {
        bail!("Chain ID mismatch: expected {}, got {}", self.chain_id, info_chain_id);
    }
    
    // Continue with existing logic...
}
```

## Proof of Concept

This is an infrastructure issue, not a blockchain vulnerability, so a PoC demonstrating blockchain-level security impact cannot be provided.

---

**Notes:**
While there is a legitimate technical issue with the indexer-grpc heartbeat protocol (missing chain ID validation and protocol version negotiation), this component is part of the off-chain data indexing infrastructure, not the core Aptos blockchain. The security question asks about this specific component, but it does not constitute a blockchain security vulnerability per the defined scope focusing on consensus, execution, state management, governance, and staking security.

### Citations

**File:** protos/proto/aptos/indexer/v1/grpc.proto (L74-80)
```text
message HeartbeatRequest {
  optional ServiceInfo service_info = 1;
}

message HeartbeatResponse {
  optional uint64 known_latest_version = 1;
}
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L330-339)
```rust
    pub(crate) fn handle_heartbeat(&self, address: GrpcAddress, info: Info) -> Result<()> {
        match info {
            Info::LiveDataServiceInfo(info) => self.handle_live_data_service_info(address, info),
            Info::HistoricalDataServiceInfo(info) => {
                self.handle_historical_data_service_info(address, info)
            },
            Info::FullnodeInfo(info) => self.handle_fullnode_info(address, info),
            Info::GrpcManagerInfo(info) => self.handle_grpc_manager_info(address, info),
        }
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L489-509)
```rust
    fn handle_live_data_service_info(
        &self,
        address: GrpcAddress,
        mut info: LiveDataServiceInfo,
    ) -> Result<()> {
        let mut entry = self
            .live_data_services
            .entry(address.clone())
            .or_insert(LiveDataService::new(address));
        if info.stream_info.is_none() {
            info.stream_info = Some(StreamInfo {
                active_streams: vec![],
            });
        }
        entry.value_mut().recent_states.push_back(info);
        if entry.value().recent_states.len() > MAX_NUM_OF_STATES_TO_KEEP {
            entry.value_mut().recent_states.pop_front();
        }

        Ok(())
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-cache-worker/src/worker.rs (L310-322)
```rust
    // Guaranteed that chain id is here at this point because we already ensure that fileworker did the set up
    let chain_id = cache_operator.get_chain_id().await?.unwrap();
    if chain_id != fullnode_chain_id as u64 {
        bail!("[Indexer Cache] Chain ID mismatch between fullnode init signal and cache.");
    }

    // It's required to start the worker with the same version as file store.
    if file_store_metadata.version != starting_version {
        bail!("[Indexer Cache] Starting version mismatch between filestore metadata and fullnode init signal.");
    }
    if file_store_metadata.chain_id != fullnode_chain_id as u64 {
        bail!("[Indexer Cache] Chain id mismatch between filestore metadata and fullnode.");
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service/src/service.rs (L454-463)
```rust
    if metadata_chain_id != chain_id {
        let _result = tx
            .send_timeout(
                Err(Status::unavailable("[Data Service] Chain ID mismatch.")),
                RESPONSE_CHANNEL_SEND_TIMEOUT,
            )
            .await;
        error!("[Data Service] Chain ID mismatch.",);
        return;
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/service.rs (L71-88)
```rust
    fn pick_live_data_service(&self, starting_version: u64) -> Option<String> {
        let mut candidates = vec![];
        for candidate in self.metadata_manager.get_live_data_services_info() {
            if let Some(info) = candidate.1.back().as_ref() {
                // TODO(grao): Handle the case when the requested starting version is beyond the
                // latest version.
                if info.min_servable_version.is_none()
                    || starting_version < info.min_servable_version.unwrap()
                {
                    continue;
                }
                let num_active_streams = info.stream_info.as_ref().unwrap().active_streams.len();
                candidates.push((candidate.0, num_active_streams));
            }
        }

        Self::pick_data_service_from_candidate(candidates)
    }
```
