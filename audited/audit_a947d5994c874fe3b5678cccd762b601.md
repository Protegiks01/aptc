# Audit Report

## Title
PeerId Regeneration on Node Restart Due to Non-Persistent Identity Configuration

## Summary
The `prepare_identity()` function generates a new random PeerId on every node restart when `Identity::None` is configured, using a fresh random seed from `OsRng`. This breaks validator set membership and peer connectivity, causing permanent node unavailability after any restart.

## Finding Description

The vulnerability exists in the identity initialization flow for network configurations. When a node starts, the configuration is loaded and optimized, triggering identity preparation: [1](#0-0) 

The critical flaw is in the `Identity::None` branch. On line 276, `OsRng.r#gen()` generates a truly random seed on each invocation, ensuring that:
1. Each call produces a different random seed
2. A different x25519 private key is generated 
3. A different PeerId is derived from the public key

The node startup flow is: [2](#0-1) 

This retrieves the PeerId from the config: [3](#0-2) 

Which calls: [4](#0-3) 

The auto-generated identity is stored only in memory, never persisted to disk during normal node operation. On restart:
1. Config loads from disk with `Identity::None`
2. `prepare_identity()` generates a NEW random identity
3. A NEW PeerId is extracted
4. The static APTOS_NODE_IDENTITY is initialized with the NEW PeerId [5](#0-4) 

This static is initialized exactly once per process lifetime using `OnceCell`, but the process restarts on crash, resetting the static and allowing a new PeerId to be set.

**Security Invariant Broken**: Node identity must remain stable across restarts to maintain validator set membership and peer connectivity. This breaks the network layer's assumption that PeerIds are persistent identifiers.

There is no validation in the config sanitizer preventing `Identity::None` in production: [6](#0-5) 

## Impact Explanation

**High Severity** per Aptos bug bounty criteria: "Validator node slowdowns" and "Significant protocol violations"

This vulnerability causes:
1. **Validator Unavailability**: After restart, the validator cannot participate in consensus because the validator set knows the old PeerId, not the new one
2. **Peer Connection Failures**: All existing peer connections fail because peers authenticate against the expected PeerId
3. **Network Partition**: The affected node becomes permanently isolated from the network until manually reconfigured
4. **Consensus Impact**: If multiple validators are affected, it could impact consensus liveness

The impact is amplified because:
- No warning or error is generated - the node appears to start successfully
- The issue only manifests after restart, making debugging difficult
- Recovery requires manual intervention to restore the correct identity

## Likelihood Explanation

**Medium Likelihood** - This occurs when:
1. A validator operator creates a config with `identity: { type: "none" }`
2. A config is programmatically generated using `NetworkConfig::network_with_id()` without explicitly setting identity
3. A config file is corrupted or improperly edited

While production templates use persistent identity sources (`from_storage` or `from_file`), there are no safeguards preventing misconfiguration. The default constructor uses `Identity::None`, creating a dangerous footgun for operators who create configs programmatically or modify templates incorrectly.

## Recommendation

**Fix 1**: Add config validation to reject `Identity::None` in production:

```rust
// In config_sanitizer.rs, add to sanitize_validator_network_config():
if let Some(validator_network_config) = validator_network {
    // Existing checks...
    
    // NEW: Validate identity is not None
    if matches!(validator_network_config.identity, Identity::None) {
        return Err(Error::ConfigSanitizerFailed(
            sanitizer_name,
            "Identity cannot be 'none' for validator networks! Use from_storage, from_file, or from_config.".into(),
        ));
    }
}
```

**Fix 2**: If auto-generation is required, persist the identity immediately:

```rust
// In prepare_identity(), after generating identity:
Identity::None => {
    let mut rng = StdRng::from_seed(OsRng.r#gen());
    let key = x25519::PrivateKey::generate(&mut rng);
    let peer_id = from_identity_public_key(key.public_key());
    self.identity = Identity::from_config_auto_generated(key, peer_id);
    
    // NEW: Save identity to a persistent file
    let identity_path = /* derive from config data_dir */;
    Identity::save_private_key(&identity_path, &key)?;
    warn!("Auto-generated identity saved to {:?}. Consider using from_file or from_storage for production.", identity_path);
}
```

**Fix 3**: Make `Identity::None` non-serializable to prevent it from being saved to config files.

## Proof of Concept

```rust
#[test]
fn test_peer_id_changes_on_restart_with_identity_none() {
    use aptos_config::config::NetworkConfig;
    use aptos_config::network_id::NetworkId;
    
    // Create a network config with Identity::None (simulating misconfiguration)
    let mut config1 = NetworkConfig {
        identity: Identity::None,
        network_id: NetworkId::Validator,
        ..Default::default()
    };
    
    // Simulate first node start - prepare identity
    config1.prepare_identity();
    let peer_id_1 = config1.peer_id();
    
    // Simulate node restart - create new config from disk (still has Identity::None)
    let mut config2 = NetworkConfig {
        identity: Identity::None,
        network_id: NetworkId::Validator,
        ..Default::default()
    };
    
    // Prepare identity again (simulating restart)
    config2.prepare_identity();
    let peer_id_2 = config2.peer_id();
    
    // VULNERABILITY: PeerIds are different on restart!
    assert_ne!(peer_id_1, peer_id_2, "PeerId should change on restart with Identity::None");
    
    println!("First start PeerId: {:?}", peer_id_1);
    println!("After restart PeerId: {:?}", peer_id_2);
    println!("VULNERABILITY: Validator will be unreachable after restart!");
}
```

This test demonstrates that with `Identity::None`, each restart produces a different PeerId, breaking validator connectivity.

## Notes

- The vulnerability is architectural rather than implementation-specific - the design allows non-persistent identities without safeguards
- While production templates use persistent identity sources, the lack of validation creates a dangerous footgun
- The issue affects both validators and fullnodes but has more severe consequences for validators
- Genesis initialization properly handles identity generation and persistence, but normal runtime does not

### Citations

**File:** config/src/config/network_config.rs (L244-270)
```rust
    pub fn peer_id(&self) -> PeerId {
        match &self.identity {
            Identity::FromConfig(config) => Some(config.peer_id),
            Identity::FromStorage(config) => {
                let storage: Storage = (&config.backend).into();
                let peer_id = storage
                    .get::<PeerId>(&config.peer_id_name)
                    .expect("Unable to read peer id")
                    .value;
                Some(peer_id)
            },
            Identity::FromFile(config) => {
                let identity_blob: IdentityBlob = IdentityBlob::from_file(&config.path).unwrap();

                // If account is not specified, generate peer id from public key
                if let Some(address) = identity_blob.account_address {
                    Some(address)
                } else {
                    Some(from_identity_public_key(
                        identity_blob.network_private_key.public_key(),
                    ))
                }
            },
            Identity::None => None,
        }
        .expect("peer id should be present")
    }
```

**File:** config/src/config/network_config.rs (L272-288)
```rust
    fn prepare_identity(&mut self) {
        match &mut self.identity {
            Identity::FromStorage(_) => (),
            Identity::None => {
                let mut rng = StdRng::from_seed(OsRng.r#gen());
                let key = x25519::PrivateKey::generate(&mut rng);
                let peer_id = from_identity_public_key(key.public_key());
                self.identity = Identity::from_config_auto_generated(key, peer_id);
            },
            Identity::FromConfig(config) => {
                if config.peer_id == PeerId::ZERO {
                    config.peer_id = from_identity_public_key(config.key.public_key());
                }
            },
            Identity::FromFile(_) => (),
        };
    }
```

**File:** aptos-node/src/lib.rs (L240-240)
```rust
    aptos_node_identity::init(config.get_peer_id())?;
```

**File:** config/src/config/node_config.rs (L146-149)
```rust
    pub fn get_peer_id(&self) -> Option<PeerId> {
        self.get_primary_network_config()
            .map(NetworkConfig::peer_id)
    }
```

**File:** crates/aptos-node-identity/src/lib.rs (L9-32)
```rust
/// The global [AptosNodeIdentity]
static APTOS_NODE_IDENTITY: OnceCell<Arc<AptosNodeIdentity>> = OnceCell::new();

/// Structure that holds information related to a node's identity
pub struct AptosNodeIdentity {
    pub chain_id: OnceCell<ChainId>,
    pub peer_id: Option<PeerId>,
    // Holds Peer ID as String to reduce overhead for frequent lookups.
    pub peer_id_str: Option<String>,
}

/// Initializes the [AptosNodeIdentity] using the provided [PeerId] and
/// sets it globally exactly once.
pub fn init(peer_id: Option<PeerId>) -> Result<()> {
    let identity = AptosNodeIdentity {
        chain_id: OnceCell::new(),
        peer_id,
        peer_id_str: peer_id.map(|id| id.to_string()),
    };

    APTOS_NODE_IDENTITY
        .set(Arc::new(identity))
        .map_err(|_| format_err!("APTOS_NODE_IDENTITY was already set"))
}
```

**File:** config/src/config/config_sanitizer.rs (L156-201)
```rust
/// Sanitize the validator network config according to the node role and chain ID
fn sanitize_validator_network_config(
    node_config: &NodeConfig,
    node_type: NodeType,
    _chain_id: Option<ChainId>,
) -> Result<(), Error> {
    let sanitizer_name = VALIDATOR_NETWORK_SANITIZER_NAME.to_string();
    let validator_network = &node_config.validator_network;

    // Verify that the validator network config is not empty for validators
    if validator_network.is_none() && node_type.is_validator() {
        return Err(Error::ConfigSanitizerFailed(
            sanitizer_name,
            "Validator network config cannot be empty for validators!".into(),
        ));
    }

    // Check the validator network config
    if let Some(validator_network_config) = validator_network {
        let network_id = validator_network_config.network_id;
        if !network_id.is_validator_network() {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "The validator network config must have a validator network ID!".into(),
            ));
        }

        // Verify that the node is a validator
        if !node_type.is_validator() {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "The validator network config cannot be set for non-validators!".into(),
            ));
        }

        // Ensure that mutual authentication is enabled
        if !validator_network_config.mutual_authentication {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "Mutual authentication must be enabled for the validator network!".into(),
            ));
        }
    }

    Ok(())
}
```
