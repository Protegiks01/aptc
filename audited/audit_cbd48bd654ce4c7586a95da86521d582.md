# Audit Report

## Title
Indexer Object Deletion State Inconsistency - Burnt and Partially Deleted Objects Not Tracked

## Summary
The Aptos indexer's `Object` model fails to detect two critical object deletion scenarios: (1) burnt objects marked with `TombStone` resources, and (2) objects where `ObjectCore` is deleted while other resource group members remain. This causes the `is_deleted` flag in the indexer database to remain `false` while the blockchain state indicates the object should be considered deleted or inaccessible.

## Finding Description

The indexer processes blockchain write set changes to maintain a queryable database of object states. However, it only detects object deletion when the entire `ObjectGroup` resource group is deleted, missing two important cases:

**Case 1: Burnt Objects**
When the `burn()` function is called on an object, it adds a `TombStone` resource to mark the object as "hidden" per the framework documentation. [1](#0-0) 

However, the indexer's `Object::from_write_resource()` only creates/updates object records when it sees `WriteResource` containing `0x1::object::ObjectCore`. [2](#0-1) 

When `TombStone` is added, the write set contains `WriteResource` for `TombStone` but NOT for `ObjectCore` (since `ObjectCore` wasn't modified). The indexer's `ObjectWithMetadata::from_write_resource()` checks if the resource type is supported and returns `None` for `TombStone`. [3](#0-2) 

Result: The object remains in the database with `is_deleted = false` despite having a `TombStone` on-chain.

**Case 2: Partial Deletion (Acknowledged in TODO)**
The indexer developers acknowledge this limitation in a TODO comment. [4](#0-3) 

When `ObjectCore` is deleted via the `delete()` function but other resource group members remain (e.g., custom application resources added via `ExtendRef`), the VM's resource group handling produces a `Modify` operation on the `ObjectGroup`, not a `Delete` operation. [5](#0-4) 

The API layer converts this to `WriteResource` entries for the remaining resources only. [6](#0-5) 

The indexer only sets `is_deleted = true` when it sees a `DeleteResource` for the entire `ObjectGroup`. [7](#0-6) 

Result: The object shows `is_deleted = false` in the indexer while `ObjectCore` doesn't exist on-chain.

**Exploitation Path:**
1. User calls `burn()` on an object → `TombStone` added → Indexer shows object as active
2. Contract developer calls `delete()` on object with remaining resources → `ObjectCore` removed → Indexer shows object as active
3. DApps querying the indexer display incorrect object states to users
4. Marketplace applications may show "deleted" NFTs as available for purchase
5. Asset management tools miscount actual on-chain object inventory

## Impact Explanation

This qualifies as **Medium Severity** under the Aptos bug bounty criteria: "State inconsistencies requiring intervention."

**Impact:**
- DApps relying on the indexer API receive incorrect object state information
- NFT marketplaces may display deleted/burnt tokens as active listings
- Portfolio tracking applications show incorrect asset counts
- Requires manual database updates or re-indexing to fix inconsistencies
- Persists indefinitely until corrected

**Not Critical/High because:**
- Does not affect blockchain consensus or state commitment
- Does not cause fund loss (blockchain state is correct, only indexer view is wrong)
- DApps can query full nodes directly for accurate data
- The indexer is an auxiliary service, not a consensus-critical component

## Likelihood Explanation

**High Likelihood:**
- Burning objects is a standard feature explicitly supported by the framework
- The `burn()` function is a public entry function any user can call on their objects
- Contract developers commonly add custom resources to objects via `ExtendRef`
- Poor contract design or cleanup logic can easily leave orphaned resources after `ObjectCore` deletion
- No special privileges or unusual conditions required

The issue occurs in normal operation whenever these common patterns are used.

## Recommendation

**Solution:** Implement comprehensive object state tracking that detects all deletion scenarios:

1. **Track TombStone resources:** Modify `Object::from_write_resource()` to detect when `TombStone` is added and set `is_deleted = true`:
   - Add `0x1::object::TombStone` to supported resource types
   - When `TombStone` `WriteResource` is seen, query the database for the existing object and mark it deleted

2. **Implement KV store lookup for partial deletion** (as indicated in the TODO): 
   - When processing resource group modifications, check if `ObjectCore` exists in the write set
   - If only non-`ObjectCore` resources are written, query the blockchain's KV store to verify `ObjectCore` existence
   - If `ObjectCore` doesn't exist on-chain, set `is_deleted = true`

3. **Add `is_burnt` field:** Separately track burnt objects (with `TombStone`) vs fully deleted objects for accurate querying

**Code Fix Skeleton:**
```rust
// In v2_objects.rs
pub fn from_write_resource(...) -> anyhow::Result<Option<(Self, CurrentObject)>> {
    // Check for TombStone resource
    if write_resource.data.typ.name == "TombStone" 
        && write_resource.data.typ.module == "object" 
        && write_resource.data.typ.address == "0x1" {
        // Mark existing object as deleted
        // Query database and update is_deleted = true
    }
    
    // Existing ObjectCore logic...
    if let Some(inner) = ObjectWithMetadata::from_write_resource(write_resource, txn_version)? {
        // ... existing code
    } else {
        // For resource group updates without ObjectCore, verify ObjectCore exists on-chain
        // If not, mark as deleted
        Ok(None)
    }
}
```

## Proof of Concept

**Move Test - Burnt Object Not Reflected:**

```move
#[test(owner = @0x123)]
fun test_burnt_object_indexer_inconsistency(owner: &signer) {
    use aptos_framework::object;
    
    // Create an object
    let constructor_ref = object::create_object(@0x123);
    let obj = object::object_from_constructor_ref<object::ObjectCore>(&constructor_ref);
    let obj_addr = object::address_from_constructor_ref(&constructor_ref);
    
    // Verify object exists with ObjectCore
    assert!(object::exists_at<object::ObjectCore>(obj_addr), 1);
    
    // Burn the object - adds TombStone
    object::burn(owner, obj);
    
    // On-chain: TombStone exists, object is "hidden"
    assert!(object::is_burnt(obj), 2);
    
    // Indexer behavior: WriteResource for TombStone emitted
    // Indexer's from_write_resource() returns None (TombStone not supported)
    // Object in database still shows is_deleted = false
    // INCONSISTENCY: Indexer shows active, blockchain shows burnt
}

#[test(creator = @0x123)]
fun test_partial_deletion_indexer_inconsistency(creator: &signer) {
    use aptos_framework::object;
    
    // Create object with custom resource
    let constructor_ref = object::create_object(@0x123);
    let obj_addr = object::address_from_constructor_ref(&constructor_ref);
    let extend_ref = object::generate_extend_ref(&constructor_ref);
    let delete_ref = object::generate_delete_ref(&constructor_ref);
    
    // Add custom resource to ObjectGroup
    let obj_signer = object::generate_signer_for_extending(&extend_ref);
    move_to(&obj_signer, CustomResource { data: 42 });
    
    // Delete ObjectCore (but CustomResource remains)
    object::delete(delete_ref);
    
    // On-chain state: ObjectCore gone, CustomResource remains
    assert!(!exists<object::ObjectCore>(obj_addr), 3);
    assert!(exists<CustomResource>(obj_addr), 4);
    
    // Write set: Modify operation on ObjectGroup with only CustomResource
    // Indexer: Receives WriteResource for CustomResource only
    // from_write_resource() returns None (CustomResource not ObjectCore)
    // Database still shows is_deleted = false
    // INCONSISTENCY: Indexer shows active, ObjectCore deleted on-chain
}

struct CustomResource has key {
    data: u64
}
```

**Notes:**
- This vulnerability is explicitly acknowledged in the TODO comment in the source code
- The issue affects all DApps and services relying on the indexer API for object state queries
- Manual database intervention or re-indexing required to correct inconsistencies
- The blockchain state itself remains correct; only the indexer's derived view is inconsistent

### Citations

**File:** aptos-move/framework/aptos-framework/sources/object.move (L618-628)
```text
    /// Add a TombStone to the object.  The object will then be interpreted as hidden via indexers.
    /// This only works for objects directly owned and for simplicity does not apply to indirectly owned objects.
    /// Original owners can reclaim burnt objects any time in the future by calling unburn.
    /// Please use the test only [`object::burn_object_with_transfer`] for testing with previously burned objects.
    public entry fun burn<T: key>(owner: &signer, object: Object<T>) acquires ObjectCore {
        let original_owner = signer::address_of(owner);
        assert!(object.is_owner(original_owner), error::permission_denied(ENOT_OBJECT_OWNER));
        let object_addr = object.inner;
        assert!(!exists<TombStone>(object_addr), EOBJECT_ALREADY_BURNT);
        move_to(&create_signer(object_addr), TombStone { original_owner });
    }
```

**File:** crates/indexer/src/models/token_models/v2_token_utils.rs (L89-114)
```rust
    pub fn from_write_resource(
        write_resource: &WriteResource,
        txn_version: i64,
    ) -> anyhow::Result<Option<Self>> {
        let type_str = format!(
            "{}::{}::{}",
            write_resource.data.typ.address,
            write_resource.data.typ.module,
            write_resource.data.typ.name
        );
        if !V2TokenResource::is_resource_supported(type_str.as_str()) {
            return Ok(None);
        }
        if let V2TokenResource::ObjectCore(inner) = V2TokenResource::from_resource(
            &type_str,
            &serde_json::to_value(&write_resource.data.data).unwrap(),
            txn_version,
        )? {
            Ok(Some(Self {
                object_core: inner,
                state_key_hash: standardize_address(write_resource.state_key_hash.as_str()),
            }))
        } else {
            Ok(None)
        }
    }
```

**File:** crates/indexer/src/models/token_models/v2_token_utils.rs (L453-464)
```rust
    pub fn is_resource_supported(data_type: &str) -> bool {
        matches!(
            data_type,
            "0x1::object::ObjectCore"
                | "0x4::collection::Collection"
                | "0x4::collection::FixedSupply"
                | "0x4::collection::UnlimitedSupply"
                | "0x4::aptos_token::AptosCollection"
                | "0x4::token::Token"
                | "0x4::property_map::PropertyMap"
        )
    }
```

**File:** crates/indexer/src/models/v2_objects.rs (L108-110)
```rust
    /// This handles the case where the entire object is deleted
    /// TODO: We need to detect if an object is only partially deleted
    /// using KV store
```

**File:** crates/indexer/src/models/v2_objects.rs (L118-149)
```rust
        if delete_resource.resource.to_string() == "0x1::object::ObjectGroup" {
            let resource = MoveResource::from_delete_resource(
                delete_resource,
                0, // Placeholder, this isn't used anyway
                txn_version,
                0, // Placeholder, this isn't used anyway
            );
            let previous_object = if let Some(object) = object_mapping.get(&resource.address) {
                object.clone()
            } else {
                match Self::get_object_owner(conn, &resource.address) {
                    Ok(owner) => owner,
                    Err(_) => {
                        aptos_logger::error!(
                            transaction_version = txn_version,
                            lookup_key = &resource.address,
                            "Missing object owner for object. You probably should backfill db.",
                        );
                        return Ok(None);
                    },
                }
            };
            Ok(Some((
                Self {
                    transaction_version: txn_version,
                    write_set_change_index,
                    object_address: resource.address.clone(),
                    owner_address: previous_object.owner_address.clone(),
                    state_key_hash: resource.state_key_hash.clone(),
                    guid_creation_num: previous_object.last_guid_creation_num.clone(),
                    allow_ungated_transfer: previous_object.allow_ungated_transfer,
                    is_deleted: true,
```

**File:** aptos-move/aptos-vm/src/move_vm_ext/session/mod.rs (L261-310)
```rust
    fn populate_v0_resource_group_change_set(
        change_set: &mut BTreeMap<StateKey, MoveStorageOp<BytesWithResourceLayout>>,
        state_key: StateKey,
        mut source_data: BTreeMap<StructTag, Bytes>,
        resources: BTreeMap<StructTag, MoveStorageOp<BytesWithResourceLayout>>,
    ) -> PartialVMResult<()> {
        let common_error = || {
            PartialVMError::new(StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR)
                .with_message("populate v0 resource group change set error".to_string())
        };

        let create = source_data.is_empty();

        for (struct_tag, current_op) in resources {
            match current_op {
                MoveStorageOp::Delete => {
                    source_data.remove(&struct_tag).ok_or_else(common_error)?;
                },
                MoveStorageOp::Modify((new_data, _)) => {
                    let data = source_data.get_mut(&struct_tag).ok_or_else(common_error)?;
                    *data = new_data;
                },
                MoveStorageOp::New((data, _)) => {
                    let data = source_data.insert(struct_tag, data);
                    if data.is_some() {
                        return Err(common_error());
                    }
                },
            }
        }

        let op = if source_data.is_empty() {
            MoveStorageOp::Delete
        } else if create {
            MoveStorageOp::New((
                bcs::to_bytes(&source_data)
                    .map_err(|_| common_error())?
                    .into(),
                None,
            ))
        } else {
            MoveStorageOp::Modify((
                bcs::to_bytes(&source_data)
                    .map_err(|_| common_error())?
                    .into(),
                None,
            ))
        };
        change_set.insert(state_key, op);
        Ok(())
```

**File:** api/types/src/convert.rs (L486-513)
```rust
                Path::ResourceGroup(typ) => vec![WriteSetChange::DeleteResource(DeleteResource {
                    address: access_path.address.into(),
                    state_key_hash,
                    resource: typ.into(),
                })],
            },
            Some(bytes) => match access_path.get_path() {
                Path::Code(_) => vec![WriteSetChange::WriteModule(WriteModule {
                    address: access_path.address.into(),
                    state_key_hash,
                    data: MoveModuleBytecode::new(bytes.to_vec()).try_parse_abi()?,
                })],
                Path::Resource(typ) => vec![WriteSetChange::WriteResource(WriteResource {
                    address: access_path.address.into(),
                    state_key_hash,
                    data: self.try_into_resource(&typ, bytes)?,
                })],
                Path::ResourceGroup(_) => self
                    .try_into_resources_from_resource_group(bytes)?
                    .into_iter()
                    .map(|data| {
                        WriteSetChange::WriteResource(WriteResource {
                            address: access_path.address.into(),
                            state_key_hash: state_key_hash.clone(),
                            data,
                        })
                    })
                    .collect::<Vec<_>>(),
```
