# Audit Report

## Title
Illusory Fast Path Secrecy Threshold Creates False Security Guarantee

## Summary
The fast path randomness feature claims a 2/3 secrecy threshold for enhanced security, but shares the same underlying secret with the main path (which has a 1/2 threshold). This design creates an illusory security improvement where the effective secrecy threshold remains 1/2 regardless of the fast path's nominal 2/3 threshold.

## Finding Description

The randomness configuration defines two separate secrecy thresholds:
- Main path: `secrecy_threshold = 1/2` [1](#0-0) 
- Fast path: `fast_path_secrecy_threshold = 2/3` [2](#0-1) 

The Move documentation states: "Any validator subset should not be able to reconstruct randomness via the fast path if subset_power / total_power <= fast_path_secrecy_threshold" [3](#0-2) 

However, the critical flaw is that **both paths use the identical underlying secret**. The `generate_transcript` function deals the same `input_secret` to both the main and fast path transcripts [4](#0-3)  and [5](#0-4) 

This invariant is enforced in reconstruction, where the system verifies that both paths produce identical secrets [6](#0-5) 

**Security Model Violation:**

An adversary controlling >50% but â‰¤67% of validator stake could:
1. Collect main path secret shares from compromised validators
2. Reconstruct the secret using the main path's weighted configuration (threshold ~50%)
3. Obtain the randomness value that the fast path also protects
4. Bypass the fast path's 2/3 threshold despite it being designed to prevent such reconstruction

The fast path's higher threshold provides **zero additional security** because the secret it protects is identical to the main path's secret, which has a lower threshold.

## Impact Explanation

Under standard BFT assumptions (<1/3 Byzantine validators), this creates **no immediate exploitability** since both thresholds exceed the Byzantine fraction. However, it represents a **High severity security model violation** because:

1. **False security guarantee**: The documentation and configuration suggest enhanced security through the 2/3 threshold that doesn't actually exist
2. **Degraded security margin**: If Byzantine validators exceed 33% but remain below 50% (non-standard but possible degraded scenarios), the main path becomes vulnerable while the fast path would theoretically remain secure - but this protection is illusory
3. **Protocol design flaw**: Violates the principle that separate security mechanisms with different thresholds should provide independent protection

This qualifies as **High Severity** per the bug bounty criteria: "Significant protocol violations" that affect the security model's integrity.

## Likelihood Explanation

**Under standard conditions**: Low likelihood of exploitation (requires >50% stake, violating BFT assumptions)

**Under degraded conditions**: If the network experiences partial compromise with >33% but <50% Byzantine validators, this design flaw prevents the fast path from providing its intended additional security layer.

**Governance/Configuration risk**: Operators may configure the fast path believing it provides stronger guarantees, making security-critical decisions based on false assumptions about the 2/3 threshold.

## Recommendation

**Option 1 (Architectural Fix)**: Use separate, independent secrets for fast and main paths. Generate two distinct DKG transcripts with different secrets, eliminating the shared secret vulnerability.

**Option 2 (Configuration Fix)**: Set both thresholds to the same value (2/3) to match the actual security provided. Update documentation to clarify that both paths protect the same secret with effectively the same threshold.

**Option 3 (Documentation Fix)**: If the current design is intentional, explicitly document that the fast path's 2/3 threshold only controls aggregation latency, not secret security, which remains bound by the minimum threshold (1/2).

The default configuration should be updated in [7](#0-6)  to align thresholds or use independent secrets.

## Proof of Concept

While a full exploit requires >50% validator compromise (out of scope), the security model flaw can be demonstrated:

```rust
// Conceptual demonstration (not executable without test framework)
// 
// Given: Adversary controls 60% of validator stake
// Step 1: Collect main path shares from 60% of validators
// Step 2: Reconstruct using main path wconfig (threshold = 50%)
//         pub_params.pvss_config.wconfig with 60% weight > 50% threshold
// Step 3: Successfully obtain secret despite fast path requiring 67%
//
// The secret obtained is identical to fast path secret due to:
// - Same input_secret used in generate_transcript()
// - Enforcement at line 499-501 in reconstruct_secret_from_shares()
```

The vulnerability exists in the design where `generate_transcript` uses identical secrets [8](#0-7)  combined with different threshold configurations [9](#0-8) 

## Notes

This finding represents a **security model inconsistency** rather than an immediately exploitable vulnerability under standard BFT assumptions. The fast path's 2/3 threshold is verifiable through the aggregation logic [10](#0-9)  but provides illusory security due to the shared secret design. Operators should understand that the effective secrecy threshold is determined by the minimum of all paths protecting the same secret.

### Citations

**File:** types/src/on_chain_config/randomness_config.rs (L31-32)
```rust
            secrecy_threshold: FixedPoint64MoveStruct::from_u64f64(
                U64F64::from_num(1) / U64F64::from_num(2),
```

**File:** types/src/on_chain_config/randomness_config.rs (L52-66)
```rust
impl Default for ConfigV2 {
    fn default() -> Self {
        Self {
            secrecy_threshold: FixedPoint64MoveStruct::from_u64f64(
                U64F64::from_num(1) / U64F64::from_num(2),
            ),
            reconstruction_threshold: FixedPoint64MoveStruct::from_u64f64(
                U64F64::from_num(2) / U64F64::from_num(3),
            ),
            fast_path_secrecy_threshold: FixedPoint64MoveStruct::from_u64f64(
                U64F64::from_num(2) / U64F64::from_num(3),
            ),
        }
    }
}
```

**File:** aptos-move/framework/aptos-framework/sources/configs/randomness_config.move (L40-41)
```text
        /// Any validator subset should not be able to reconstruct randomness via the fast path if `subset_power / total_power <= fast_path_secrecy_threshold`,
        fast_path_secrecy_threshold: FixedPoint64,
```

**File:** types/src/dkg/real_dkg/mod.rs (L241-286)
```rust
    fn generate_transcript<R: CryptoRng + RngCore>(
        rng: &mut R,
        pub_params: &Self::PublicParams,
        input_secret: &Self::InputSecret,
        my_index: u64,
        sk: &Self::DealerPrivateKey,
        pk: &Self::DealerPublicKey,
    ) -> Self::Transcript {
        let my_index = my_index as usize;
        let my_addr = pub_params.session_metadata.dealer_validator_set[my_index].addr;
        let aux = (pub_params.session_metadata.dealer_epoch, my_addr);

        let wtrx = WTrx::deal(
            &pub_params.pvss_config.wconfig,
            &pub_params.pvss_config.pp,
            sk,
            pk,
            &pub_params.pvss_config.eks,
            input_secret,
            &aux,
            &Player { id: my_index },
            rng,
        );
        // transcript for fast path
        let fast_wtrx = pub_params
            .pvss_config
            .fast_wconfig
            .as_ref()
            .map(|fast_wconfig| {
                WTrx::deal(
                    fast_wconfig,
                    &pub_params.pvss_config.pp,
                    sk,
                    pk,
                    &pub_params.pvss_config.eks,
                    input_secret,
                    &aux,
                    &Player { id: my_index },
                    rng,
                )
            });
        Transcripts {
            main: wtrx,
            fast: fast_wtrx,
        }
    }
```

**File:** types/src/dkg/real_dkg/mod.rs (L499-501)
```rust
            ensure!(
                reconstructed_secret == fast_reconstructed_secret,
                "real_dkg::reconstruct_secret_from_shares failed with inconsistent dealt secrets."
```

**File:** types/src/dkg/real_dkg/rounding/mod.rs (L98-120)
```rust
        let wconfig = WeightedConfigBlstrs::new(
            profile.reconstruct_threshold_in_weights as usize,
            profile
                .validator_weights
                .iter()
                .map(|w| *w as usize)
                .collect(),
        )
        .unwrap();

        let fast_wconfig = profile.fast_reconstruct_threshold_in_weights.map(
            |fast_reconstruct_threshold_in_weights| {
                WeightedConfigBlstrs::new(
                    fast_reconstruct_threshold_in_weights as usize,
                    profile
                        .validator_weights
                        .iter()
                        .map(|w| *w as usize)
                        .collect(),
                )
                .unwrap()
            },
        );
```

**File:** consensus/src/rand/rand_gen/rand_store.rs (L41-49)
```rust
    pub fn try_aggregate(
        self,
        rand_config: &RandConfig,
        rand_metadata: FullRandMetadata,
        decision_tx: Sender<Randomness>,
    ) -> Either<Self, RandShare<S>> {
        if self.total_weight < rand_config.threshold() {
            return Either::Left(self);
        }
```
