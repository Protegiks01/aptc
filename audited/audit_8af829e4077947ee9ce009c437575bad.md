# Audit Report

## Title
Memory Exhaustion Before Gas Metering in Multi-Scalar Multiplication Native Function

## Summary
The `ark_msm_internal!` macro in the cryptography algebra natives allocates large memory buffers via `Vec::with_capacity` before charging gas, violating the critical "charge gas first, then execute" invariant. This allows unprivileged attackers to trigger multi-megabyte allocations before gas limits are enforced, enabling memory exhaustion denial-of-service attacks against validator nodes through concurrent malicious transactions.

## Finding Description

The vulnerability exists in the `ark_msm_internal!` macro which implements multi-scalar multiplication (MSM) for elliptic curve cryptography operations. [1](#0-0) 

At line 206, the macro allocates a vector with capacity for `num_elements` elliptic curve points **before** charging gas at line 207. Similarly, line 218 allocates capacity for scalars before any gas charge. [2](#0-1) 

This violates the documented best practice found throughout the codebase that states "Always remember: first charge gas, then execute!" The `num_elements` value comes from user-controlled transaction arguments: [3](#0-2) 

For BLS12-381 G1 elements, each element occupies 144 bytes in memory as documented in the framework tests: [4](#0-3) 

The transaction size limit is 64 KB for regular transactions: [5](#0-4) 

This allows an attacker to pass approximately 8,000 u64 handles (64 KB / 8 bytes) in a `Vec<u64>` argument. When `multi_scalar_mul_internal` is called with 8,000 handles:

- Line 206 allocates: 8,000 × 144 bytes = 1,152,000 bytes (~1.15 MB) for bases
- Line 218 allocates: 8,000 × 32 bytes = 256,000 bytes (~256 KB) for scalars
- **Total: ~1.4 MB allocated BEFORE any gas charge**

The attacker creates duplicate handles referencing a small number of actual curve points (within the 1 MB AlgebraContext limit), so the handles are valid but repeated thousands of times.

**Attack Scenario:**
1. Attacker submits multiple concurrent transactions (or coordinates with accomplices)
2. Each transaction calls `multi_scalar_mul_internal` with ~8,000 duplicate handles
3. Each transaction allocates ~1.4 MB before gas checks
4. With 500 concurrent transactions: 700 MB allocated
5. With 1,000 concurrent transactions: 1.4 GB allocated
6. Validator node experiences memory pressure, slowdowns, or OOM crashes
7. Even if transactions later abort due to gas exhaustion, memory was already allocated during processing

This breaks the **Move VM Safety** invariant: "Bytecode execution must respect gas limits and memory constraints" and the **Resource Limits** invariant: "All operations must respect gas, storage, and computational limits."

## Impact Explanation

This qualifies as **High Severity** per the Aptos bug bounty program criteria:
- **Validator node slowdowns**: Memory pressure degrades validator performance
- **API crashes**: Out-of-memory conditions can crash validator nodes

The vulnerability enables denial-of-service attacks on validator infrastructure without requiring privileged access or validator collusion. Multiple concurrent malicious transactions can exhaust available memory on validator nodes, causing:
- Performance degradation across the network
- Potential validator node crashes requiring restart
- Reduced transaction processing capacity
- Risk of missed block proposals if validators become unresponsive

While individual transactions may fail gas checks, the cumulative memory allocation during concurrent processing creates a resource exhaustion attack surface.

## Likelihood Explanation

**Likelihood: High**

The attack is highly feasible because:
- Any unprivileged user can submit transactions calling algebra native functions
- No special permissions or validator access required
- Transaction parameters are fully attacker-controlled within documented limits
- The vulnerability triggers on every invocation of `multi_scalar_mul_internal`
- Multiple transactions can be submitted simultaneously to amplify the effect
- The 64 KB transaction size limit still permits ~8,000 element vectors
- Gas charging happens AFTER memory allocation, creating an exploitable window

The attacker only needs to:
1. Create a small number of valid curve elements (< 1 MB limit)
2. Construct transactions with large Vec<u64> containing duplicate handles
3. Submit multiple transactions concurrently to maximize memory consumption

## Recommendation

**Fix: Charge gas BEFORE allocating memory**

Reorder operations in the `ark_msm_internal!` macro to charge gas before `Vec::with_capacity`:

```rust
macro_rules! ark_msm_internal {
    // ... parameters ...
    ) => {{
        let scalar_handles = safely_pop_arg!($args, Vec<u64>);
        let element_handles = safely_pop_arg!($args, Vec<u64>);
        let num_elements = element_handles.len();
        let num_scalars = scalar_handles.len();
        if num_elements != num_scalars {
            return Err(SafeNativeError::Abort {
                abort_code: MOVE_ABORT_CODE_INPUT_VECTOR_SIZES_NOT_MATCHING,
            });
        }
        
        // CHARGE GAS FIRST, BEFORE ALLOCATIONS
        $context.charge($proj_to_affine_cost * NumArgs::from(num_elements as u64))?;
        $context.charge(ark_msm_bigint_wnaf_cost!(
            $proj_add_cost,
            $proj_double_cost,
            num_elements,
        ))?;
        
        // THEN ALLOCATE MEMORY
        let mut bases = Vec::with_capacity(num_elements);
        for handle in element_handles {
            safe_borrow_element!(
                $context,
                handle as usize,
                $element_typ,
                element_ptr,
                element
            );
            bases.push(element.into_affine());
        }
        let mut scalars = Vec::with_capacity(num_scalars);
        for handle in scalar_handles {
            safe_borrow_element!($context, handle as usize, $scalar_typ, scalar_ptr, scalar);
            scalars.push(scalar.clone());
        }
        
        // MSM operation
        let new_element: $element_typ =
            ark_ec::VariableBaseMSM::msm(bases.as_slice(), scalars.as_slice()).unwrap();
        let new_handle = store_element!($context, new_element)?;
        Ok(smallvec![Value::u64(new_handle as u64)])
    }};
}
```

This ensures transactions exceeding gas limits are rejected **before** large memory allocations occur, preventing the resource exhaustion attack.

## Proof of Concept

```move
#[test_only]
module test_addr::memory_exhaustion_poc {
    use std::vector;
    use aptos_std::bls12381_algebra::{Self, G1, Fr};
    use aptos_std::crypto_algebra;

    #[test(fx = @std)]
    fun test_memory_exhaustion_before_gas(fx: signer) {
        // Enable the feature flag
        bls12381_algebra::enable_cryptography_algebra_natives(&fx);
        
        // Create a small number of valid G1 elements (within 1MB limit)
        let elements = vector::empty<G1>();
        let scalars = vector::empty<Fr>();
        let i = 0;
        while (i < 100) {
            vector::push_back(&mut elements, crypto_algebra::from_u64<G1, Fr>(i));
            vector::push_back(&mut scalars, crypto_algebra::from_u64<Fr, Fr>(i));
            i = i + 1;
        };
        
        // Create a large vector with 8000 duplicates to trigger the vulnerability
        let large_elements = vector::empty<G1>();
        let large_scalars = vector::empty<Fr>();
        let j = 0;
        while (j < 8000) {
            // Repeat the same elements many times
            vector::push_back(&mut large_elements, *vector::borrow(&elements, j % 100));
            vector::push_back(&mut large_scalars, *vector::borrow(&scalars, j % 100));
            j = j + 1;
        };
        
        // This call will allocate ~1.4 MB BEFORE gas is charged
        // If gas limit is exceeded, memory was already allocated
        let _result = crypto_algebra::multi_scalar_mul<G1, Fr>(&large_elements, &large_scalars);
        
        // With multiple concurrent transactions, this causes memory exhaustion
    }
}
```

**Notes:**
- The vulnerability affects all elliptic curve groups (BLS12-381 G1/G2, BN254 G1/G2)
- The 1 MB AlgebraContext limit only applies to elements stored via `store_element!`, not temporary allocations in native functions
- The gas scaling factor (1,000,000 internal units per external unit) means operations can consume significant gas, but allocations still happen first
- The fix aligns with the best practice documented throughout the codebase to charge gas before executing operations

### Citations

**File:** aptos-move/framework/src/natives/cryptography/algebra/arithmetics/scalar_mul.rs (L197-199)
```rust
        let scalar_handles = safely_pop_arg!($args, Vec<u64>);
        let element_handles = safely_pop_arg!($args, Vec<u64>);
        let num_elements = element_handles.len();
```

**File:** aptos-move/framework/src/natives/cryptography/algebra/arithmetics/scalar_mul.rs (L206-207)
```rust
        let mut bases = Vec::with_capacity(num_elements);
        $context.charge($proj_to_affine_cost * NumArgs::from(num_elements as u64))?;
```

**File:** aptos-move/framework/src/natives/cryptography/algebra/arithmetics/scalar_mul.rs (L218-218)
```rust
        let mut scalars = Vec::with_capacity(num_scalars);
```

**File:** aptos-move/framework/aptos-stdlib/sources/cryptography/bls12381_algebra.move (L823-824)
```text
    /// calculated by the current memory limit (1MB) and the in-mem G1 representation size (144 bytes per element).
    const G1_NUM_MAX: u64 = 1048576 / 144;
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L73-76)
```rust
            max_transaction_size_in_bytes: NumBytes,
            "max_transaction_size_in_bytes",
            64 * 1024
        ],
```
