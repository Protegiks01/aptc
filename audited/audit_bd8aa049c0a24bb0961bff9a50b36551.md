# Audit Report

## Title
Consensus Divergence via Stale Module Cache When Switching Between Forked Blocks

## Summary
The `CachedModuleView::reset_state_view()` method updates the state view without invalidating the module cache, relying solely on version-based validation. When validators speculatively execute forked blocks that share a common grandparent, they can use stale cached modules from one fork while executing transactions on another fork, leading to consensus divergence.

## Finding Description

The vulnerability exists in the interaction between three components:

1. **Module Cache Persistence:** [1](#0-0) 
   The `reset_state_view()` method updates only the state view reference without clearing the module cache or environment.

2. **Insufficient State View ID Validation:** [2](#0-1) 
   The `state_view_id()` method returns the current ID, but there's no validation ensuring cached modules match this ID.

3. **Version-Only Cache Validation:** [3](#0-2) 
   The cache validation in `get_module_or_build_with()` compares only version numbers, not state view IDs.

4. **Grand Parent ID Checking in Consensus:** [4](#0-3) 
   The `rand_check` function checks if the previous state view ID matches the grandparent block ID (not parent), allowing `reset_state_view()` to be called when switching between different parent blocks.

5. **Identical Version Assignment Across Forks:** [5](#0-4) 
   Forked blocks extending from the same parent assign identical version numbers to state updates at the same transaction index.

**Attack Scenario:**

1. Block GP (grandparent) is committed at version 1000
2. Block P1 extends GP, modifies module `0x1::M` in transaction 0 → assigns version 1001
3. Block P2 also extends GP (fork), modifies module `0x1::M` in transaction 0 → assigns version 1001
4. Validator V executes block C1 (child of P1):
   - Caches module `0x1::M` with version 1001 (P1's content)
5. Validator V then executes block C2 (child of P2):
   - Grandparent is GP (matches cached state view ID)
   - Calls `reset_state_view()` instead of `reset_all()`
   - Cache retains P1's version of module `0x1::M`
   - Version checking: cached 1001 == P2's state 1001 → PASS
   - Executes using P1's module content instead of P2's
   - **Different execution result than validators that didn't cache P1's modules**

This breaks the **Deterministic Execution** invariant: validators produce different state roots for identical blocks.

## Impact Explanation

**Critical Severity** - Consensus Safety Violation

This vulnerability enables consensus divergence where different validators executing the same block produce different state roots. This satisfies the Critical severity criteria:
- **Consensus/Safety violations**: Breaks Byzantine Fault Tolerance guarantees
- **Potential chain split**: If validators disagree on block validity, the chain cannot progress
- May require manual intervention or hard fork to recover

The impact is amplified because:
- It occurs during normal speculative execution in consensus
- No Byzantine validators required - honest validators can diverge
- Affects the randomness detection path, which is critical for protocol security

## Likelihood Explanation

**High Likelihood** during network stress or competing proposals:

1. **Trigger Conditions:**
   - Multiple validators propose different blocks for the same round (normal in leader rotation)
   - Blocks share a common grandparent but different parents
   - Blocks modify the same modules at the same transaction indices

2. **No Attacker Control Required:**
   - Occurs during normal consensus operation
   - Triggered by timing of block proposals and execution order
   - No special permissions or Byzantine behavior needed

3. **Persistent Module Cache:** [6](#0-5) 
   The module cache persists across block executions in the same PipelineBuilder instance, making this scenario inevitable during fork resolution.

## Recommendation

**Fix 1: Validate State View ID During Cache Access**

Modify `CachedModuleView::get_module_or_build_with()` to compare state view IDs in addition to versions:

```rust
pub fn get_module_or_build_with(...) -> VMResult<...> {
    let current_view_id = self.state_view.id();
    
    // Check if the cached module's state view ID matches current state view
    let (module, version, cached_view_id) = match self.module_cache.get_module_or_build_with(key, builder)? {
        None => return Ok(None),
        Some(m) => m,
    };
    
    // If state view IDs don't match, invalidate cache and reload
    if cached_view_id != current_view_id {
        self.module_cache.invalidate(key);
        // Reload from current state view...
    }
    
    // Existing version check...
}
```

**Fix 2: Always Clear Cache When State View ID Changes**

Modify `reset_state_view()` to detect state view ID changes and clear the cache:

```rust
pub fn reset_state_view(&mut self, state_view: S) {
    let old_id = self.state_view.id();
    let new_id = state_view.id();
    
    // Clear cache if state view type or context changes
    if std::mem::discriminant(&old_id) != std::mem::discriminant(&new_id) 
        || old_id != new_id {
        self.module_cache = UnsyncModuleCache::empty();
        self.environment = AptosEnvironment::new(&state_view);
    }
    
    self.state_view = state_view;
}
```

**Fix 3: Use State-View-Specific Versioning**

Include the state view ID in the cache key to prevent cross-contamination between different state views.

## Proof of Concept

```rust
// Conceptual test demonstrating the vulnerability
#[test]
fn test_forked_block_module_cache_collision() {
    // Setup: Create grandparent block GP at version 1000
    let gp_block = create_block(1000, vec![]);
    
    // Create two forked blocks P1 and P2, both extending GP
    // Both modify module 0x1::test in transaction 0
    let p1_txns = vec![create_module_publish_txn("0x1::test", "version_1")];
    let p2_txns = vec![create_module_publish_txn("0x1::test", "version_2")];
    
    let p1_block = create_child_block(gp_block.id(), p1_txns);
    let p2_block = create_child_block(gp_block.id(), p2_txns);
    
    // Execute P1 - module gets cached
    let executor = create_executor();
    executor.execute_block(p1_block);
    
    // Create child blocks C1 (child of P1) and C2 (child of P2)
    let c1_block = create_child_block(p1_block.id(), vec![]);
    let c2_block = create_child_block(p2_block.id(), vec![]);
    
    // Execute C1 - uses P1's cached modules
    let state1 = executor.execute_block(c1_block);
    
    // Execute C2 - should use P2's modules, but due to bug uses P1's cached modules
    // Grand parent is GP for both C1 and C2, so cache is not cleared
    let state2 = executor.execute_block(c2_block);
    
    // Verify: The module content should differ but due to cache bug, they match
    let module_from_c1 = state1.get_module("0x1::test");
    let module_from_c2 = state2.get_module("0x1::test");
    
    // BUG: module_from_c2 contains P1's content instead of P2's content
    assert_ne!(module_from_c1, module_from_c2); // This would FAIL due to the bug
}
```

**Notes:**
- The vulnerability manifests when the `BlockExecution` state view ID check in `rand_check` compares against the grandparent instead of the parent
- Version-based cache validation alone is insufficient when forked blocks assign identical versions to different content
- This affects both the randomness detection path and transaction validation, potentially causing consensus divergence

### Citations

**File:** aptos-move/aptos-resource-viewer/src/module_view.rs (L123-125)
```rust
    pub fn reset_state_view(&mut self, state_view: S) {
        self.state_view = state_view;
    }
```

**File:** aptos-move/aptos-resource-viewer/src/module_view.rs (L128-130)
```rust
    pub fn state_view_id(&self) -> StateViewId {
        self.state_view.id()
    }
```

**File:** aptos-move/aptos-resource-viewer/src/module_view.rs (L244-262)
```rust
        Ok(if version == value_version {
            Some((module, version))
        } else {
            let (compiled_module, extension) = self
                .try_override_bytes_and_deserialized_into_compiled_module_with_ext(
                    state_value,
                    key.address(),
                    key.name(),
                )?;

            let new_version = value_version;
            let new_module_code = self.module_cache.insert_deserialized_module(
                key.clone(),
                compiled_module,
                extension,
                new_version,
            )?;
            Some((new_module_code, new_version))
        })
```

**File:** consensus/src/pipeline/pipeline_builder.rs (L267-267)
```rust
        let module_cache = Arc::new(Mutex::new(None));
```

**File:** consensus/src/pipeline/pipeline_builder.rs (L715-726)
```rust
                let previous_state_view = cache_mut.state_view_id();
                let expected_state_view = StateViewId::BlockExecution {
                    block_id: grand_parent_id,
                };
                if previous_state_view == expected_state_view {
                    cache_mut.reset_state_view(parent_state_view);
                } else {
                    counters::RAND_BLOCK
                        .with_label_values(&["reset_cache"])
                        .inc();
                    cache_mut.reset_all(parent_state_view);
                }
```

**File:** storage/storage-interface/src/state_store/state_update_refs.rs (L52-60)
```rust
            let version = first_version + versions_seen as Version;
            versions_seen += 1;

            for (key, write_op) in update_iter.into_iter() {
                shards[key.get_shard_id()].push((key, StateUpdateRef {
                    version,
                    state_op: write_op,
                }));
            }
```
