# Audit Report

## Title
ReleaseBundle Lacks Tamper-Evident Version Metadata Enabling Supply Chain Attacks During Genesis

## Summary
The `ReleaseBundle` structure used for framework deployment lacks tamper-evident version metadata such as Git commit hash or cryptographic signatures. This enables attackers to distribute modified framework code that validators cannot cryptographically verify against official releases, potentially leading to deployment of backdoored frameworks during genesis creation.

## Finding Description

The `ReleaseBundle` structure only contains package metadata and compiled bytecode, without any cryptographic binding to the source repository: [1](#0-0) 

The included `PackageMetadata` only contains a `source_digest` field (SHA256 of source files), which can be trivially recalculated by an attacker after modifying the sources: [2](#0-1) 

During genesis creation, the framework bundle is used directly without any verification against a known hash or signature: [3](#0-2) 

Note the explicit TODO comment on line 688 indicating missing genesis verification. The `ReleaseBundle` is created during the build process: [4](#0-3) 

And consumed as static bytes: [5](#0-4) 

**Attack Path:**
1. Attacker modifies framework source code (e.g., backdoors in `aptos_framework`, privilege escalation in access control)
2. Recompiles packages with modified code
3. Recalculates `source_digest` to match modified sources
4. Creates new `ReleaseBundle` with identical structure
5. Distributes to validators during genesis setup
6. Validators have no cryptographic mechanism to verify bundle authenticity
7. All validators execute the same modified genesis and agree on waypoint
8. Network operates normally but with compromised framework

## Impact Explanation

This issue qualifies as **HIGH severity** under the Aptos bug bounty criteria for "Significant protocol violations". While not causing immediate consensus failure, it enables:

- **Framework Backdoors**: Malicious code execution at the system level (`@aptos_framework` address)
- **Access Control Bypass**: Modified governance/staking logic allowing unauthorized operations
- **Consensus Manipulation**: Altered validator selection or voting mechanisms
- **Silent Compromise**: Network functions normally but with attacker-controlled behavior

The impact is particularly severe because:
- Framework code runs with maximum privileges
- Changes affect ALL validators uniformly
- No runtime detection mechanism exists
- Requires hard fork to recover

## Likelihood Explanation

**Medium-High Likelihood** during new network deployments:

- **Supply Chain Attacks**: Attackers could compromise build infrastructure, distribution channels, or package registries
- **Typosquatting**: Similar repository/binary names tricking validators
- **Insider Threats**: Malicious contributors submitting backdoored releases
- **Lack of Verification Culture**: Validators may not independently verify framework authenticity

The missing git commit hash makes it impossible for validators to verify they're using the official framework version from a specific, audited commit. The only verification is the `source_digest`, which attackers control by modifying sources.

## Recommendation

**Add tamper-evident metadata to ReleaseBundle:**

```rust
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub struct ReleaseBundle {
    pub packages: Vec<ReleasePackage>,
    pub source_dirs: Vec<String>,
    // NEW: Add version metadata
    pub git_commit_hash: String,      // SHA of the exact commit used
    pub build_timestamp: u64,          // Unix timestamp of build
    pub bundle_hash: HashValue,        // SHA256 of entire serialized bundle
    pub signature: Option<Signature>,  // Cryptographic signature by Aptos Foundation
}
```

**Implement verification in genesis ceremony:**

```rust
fn genesis_ceremony(
    &mut self,
    validators: &mut Vec<ValidatorNodeConfig>,
    root_key: Ed25519PublicKey,
) -> anyhow::Result<(Transaction, Waypoint)> {
    // NEW: Verify framework bundle before use
    verify_framework_bundle(&self.framework, EXPECTED_COMMIT_HASH)?;
    
    // ... rest of existing code
}

fn verify_framework_bundle(
    bundle: &ReleaseBundle, 
    expected_commit: &str
) -> anyhow::Result<()> {
    ensure!(
        bundle.git_commit_hash == expected_commit,
        "Framework commit hash mismatch: expected {}, got {}",
        expected_commit, bundle.git_commit_hash
    );
    
    // Verify bundle hash
    let computed_hash = compute_bundle_hash(bundle)?;
    ensure!(
        computed_hash == bundle.bundle_hash,
        "Bundle hash verification failed"
    );
    
    // Verify signature if present
    if let Some(sig) = &bundle.signature {
        verify_aptos_foundation_signature(bundle, sig)?;
    }
    
    Ok(())
}
```

**Publish official hashes for each release:**
- Include framework git commit hash in release notes
- Publish signed manifest of all release artifacts
- Provide CLI tool for validators to verify bundles before genesis

## Proof of Concept

```rust
// PoC: Create modified ReleaseBundle that validators cannot detect
use aptos_framework::{ReleaseBundle, ReleasePackage, BuildOptions, BuiltPackage};
use std::path::PathBuf;

fn create_backdoored_framework() -> anyhow::Result<()> {
    // Step 1: Modify framework source (e.g., add backdoor to governance)
    let framework_path = PathBuf::from("aptos-move/framework/aptos-framework");
    
    // Inject malicious code (example - actual code would be in Move files)
    // e.g., modify aptos_governance.move to allow unauthorized proposal execution
    
    // Step 2: Build modified package
    let options = BuildOptions::default();
    let built = BuiltPackage::build(framework_path, options)?;
    let package = ReleasePackage::new(built)?;
    
    // Step 3: Create ReleaseBundle
    // Note: source_digest is automatically calculated from modified sources
    let bundle = ReleaseBundle::new(vec![package], vec![]);
    
    // Step 4: Serialize and distribute
    bundle.write(PathBuf::from("malicious-framework.mrb"))?;
    
    // Validators receiving this bundle have NO way to verify it's not official
    // because there's no git commit hash or signature to check against
    
    println!("Created modified framework bundle - validators cannot detect tampering");
    Ok(())
}

// Demonstration that validators cannot verify authenticity
fn validator_verification_attempt() {
    let bundle = ReleaseBundle::read(PathBuf::from("malicious-framework.mrb")).unwrap();
    
    // Validator wants to verify this is the official v1.8.0 framework
    // Available fields to check:
    // - packages[].metadata.source_digest ✗ (attacker recalculated this)
    // - packages[].metadata.name ✗ (same as official)
    // - packages[].metadata.upgrade_policy ✗ (same as official)
    
    // Missing fields needed for verification:
    // - git_commit_hash ✗ (NOT PRESENT)
    // - cryptographic signature ✗ (NOT PRESENT)
    // - build provenance ✗ (NOT PRESENT)
    
    println!("Verification impossible - no tamper-evident metadata");
}
```

**Notes:**
- The vulnerability affects all new network deployments (testnets, devnets, private networks)
- Mainnet genesis is already established, but future framework governance upgrades also lack commit hash verification
- The `source_digest` provides integrity for source code but not authenticity (attacker controls sources)
- Waypoint mechanism ensures all validators agree on state, but doesn't prevent all validators from agreeing on a compromised state
- The TODO comment at line 688 in `builder.rs` explicitly acknowledges missing verification

### Citations

**File:** aptos-move/framework/src/release_bundle.rs (L15-24)
```rust
/// A release bundle consists of a list of release packages.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub struct ReleaseBundle {
    /// The packages in this release bundle. The order is bottom up regarding dependencies,
    /// such the packages can be deployed in order as given.
    pub packages: Vec<ReleasePackage>,
    /// A set of paths to directories where Move sources constituting this package are found.
    /// This may or not may be populated.
    pub source_dirs: Vec<String>,
}
```

**File:** aptos-move/framework/src/natives/code.rs (L60-71)
```rust
#[derive(Clone, Debug, Serialize, Deserialize, Eq, PartialEq)]
pub struct PackageMetadata {
    pub name: String,
    pub upgrade_policy: UpgradePolicy,
    pub upgrade_number: u64,
    pub source_digest: String,
    #[serde(with = "serde_bytes")]
    pub manifest: Vec<u8>,
    pub modules: Vec<ModuleMetadata>,
    pub deps: Vec<PackageDep>,
    pub extension: Option<Any>,
}
```

**File:** crates/aptos-genesis/src/builder.rs (L677-694)
```rust
        let mut genesis_info = GenesisInfo::new(
            ChainId::test(),
            root_key,
            configs,
            self.framework.clone(),
            &genesis_config,
        )?;
        let waypoint = genesis_info.generate_waypoint()?;
        let genesis = genesis_info.get_genesis();

        // Insert genesis and waypoint into validators
        // TODO: verify genesis?
        for validator in validators {
            validator.insert_waypoint(&waypoint);
            validator.insert_genesis(genesis);
        }

        Ok((genesis.clone(), waypoint))
```

**File:** aptos-move/framework/cached-packages/build.rs (L91-96)
```rust
        let path =
            PathBuf::from(std::env::var("OUT_DIR").expect("OUT_DIR defined")).join("head.mrb");

        ReleaseTarget::Head
            .create_release(true, Some(path))
            .context("Failed to create release")?;
```

**File:** aptos-move/framework/cached-packages/src/lib.rs (L13-23)
```rust
const HEAD_RELEASE_BUNDLE_BYTES: &[u8] = include_bytes!(concat!(env!("OUT_DIR"), "/head.mrb"));
#[cfg(windows)]
const HEAD_RELEASE_BUNDLE_BYTES: &[u8] = include_bytes!(concat!(env!("OUT_DIR"), "\\head.mrb"));

static HEAD_RELEASE_BUNDLE: Lazy<ReleaseBundle> = Lazy::new(|| {
    bcs::from_bytes::<ReleaseBundle>(HEAD_RELEASE_BUNDLE_BYTES).expect("bcs succeeds")
});

/// Returns the release bundle for the current code.
pub fn head_release_bundle() -> &'static ReleaseBundle {
    &HEAD_RELEASE_BUNDLE
```
