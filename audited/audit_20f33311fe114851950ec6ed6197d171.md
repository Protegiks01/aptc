# Audit Report

## Title
Missing Cross-Field Validation Between Gas Estimation and Block Capacity Configuration

## Summary
The `sanitize()` function in `gas_estimation_config.rs` fails to validate that the `full_block_txns` parameter is within reasonable bounds relative to the actual block capacity defined in the consensus configuration. This allows misconfiguration that causes systematic gas estimation failures, leading to transaction failures and inconsistent user experience across API nodes.

## Finding Description

The gas estimation subsystem uses the `full_block_txns` configuration parameter to determine whether a block should be considered "full" for gas price calculation purposes. [1](#0-0) 

The gas estimation logic classifies a block as full when the number of user transactions meets or exceeds this threshold. [2](#0-1) 

However, the actual block capacity in the consensus layer is controlled by `max_sending_block_txns_after_filtering`, which defaults to 1800 transactions. [3](#0-2) 

Under backpressure conditions, this capacity can be dynamically reduced to as low as 5 transactions per block. [4](#0-3) 

The `sanitize()` function only validates internal consistency of block history parameters, but performs no cross-field validation between `full_block_txns` and the actual block capacity from consensus configuration. [5](#0-4) 

**Attack Scenario 1: Configuration Too High**
An operator configures `full_block_txns: 5000` (exceeding the maximum block capacity of 1800). Since actual blocks never reach 5000 transactions, gas estimation never classifies blocks as "full". The system returns chronically low gas price estimates even during network congestion, causing users to systematically underpay for gas. Their transactions fail to be included or experience severe delays.

**Attack Scenario 2: Configuration Drift**
Different API nodes operate with different `full_block_txns` values (e.g., 100 vs 1000). Users receive wildly inconsistent gas estimates depending on which API node they query, leading to unpredictable transaction behavior and poor user experience.

**Attack Scenario 3: Backpressure Mismatch**
During network stress, block capacity drops to 30 transactions due to backpressure, but `full_block_txns` remains at the default 250. Gas estimation never detects congestion, creating a feedback loop where the network cannot signal price pressure through gas estimation.

## Impact Explanation

This vulnerability qualifies as **Medium Severity** under the Aptos bug bounty criteria:

1. **State inconsistencies requiring intervention**: Different configurations across nodes create inconsistent gas estimates that require operator intervention to diagnose and reconcile.

2. **Limited funds loss**: Users waste gas fees on transactions that fail due to underpricing, representing economic loss without direct fund theft.

3. **Availability impact**: Systematic transaction failures during misconfiguration reduce effective network availability for end users, though the network itself remains operational.

The issue does not reach Critical or High severity because:
- It does not enable direct fund theft or minting
- It does not break consensus safety or create chain splits
- It does not cause validator node crashes or total network unavailability
- It requires operator misconfiguration rather than exploiting a code bug

However, it clearly exceeds Low severity due to the systematic nature of transaction failures and the operational impact on users.

## Likelihood Explanation

**Likelihood: High**

This vulnerability is highly likely to manifest because:

1. **No validation prevents misconfiguration**: The `sanitize()` function provides no guard rails against setting inappropriate values for `full_block_txns`.

2. **Separate configuration domains**: Gas estimation config and consensus config are managed independently, making drift likely as operators tune one without considering the other.

3. **Dynamic capacity changes**: Block capacity changes dynamically under backpressure, but `full_block_txns` is static. A value that's reasonable under normal conditions (250) becomes meaningless when capacity drops to 5-30 transactions.

4. **Default value assumptions**: The default `full_block_txns: 250` assumes blocks can contain at least 250 transactions, but this is not enforced or validated against the actual consensus configuration.

5. **Easy to trigger**: Any operator can inadvertently misconfigure their node by modifying the gas estimation config without understanding its relationship to block capacity.

## Recommendation

Add cross-field validation in the `sanitize()` function to ensure `full_block_txns` is within reasonable bounds relative to the actual block capacity:

```rust
impl ConfigSanitizer for GasEstimationConfig {
    fn sanitize(
        node_config: &NodeConfig,
        _node_type: NodeType,
        _chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();
        let gas_estimation_config = &node_config.api.gas_estimation;

        // Existing validations...
        if gas_estimation_config.low_block_history > gas_estimation_config.aggressive_block_history
            || gas_estimation_config.market_block_history
                > gas_estimation_config.aggressive_block_history
        {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                format!(
                    "aggressive block history {} must be > low {}, market {}",
                    gas_estimation_config.aggressive_block_history,
                    gas_estimation_config.low_block_history,
                    gas_estimation_config.market_block_history
                ),
            ));
        }

        if gas_estimation_config.low_block_history == 0
            || gas_estimation_config.market_block_history == 0
            || gas_estimation_config.aggressive_block_history == 0
        {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                format!(
                    "low {}, market {}, aggressive {} block history must be > 0",
                    gas_estimation_config.low_block_history,
                    gas_estimation_config.market_block_history,
                    gas_estimation_config.aggressive_block_history
                ),
            ));
        }

        // NEW: Validate full_block_txns against consensus block capacity
        let consensus_config = &node_config.consensus;
        let min_block_capacity = consensus_config.min_max_txns_in_block_after_filtering_from_backpressure;
        let max_block_capacity = consensus_config.max_sending_block_txns_after_filtering;

        if gas_estimation_config.full_block_txns < min_block_capacity {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                format!(
                    "full_block_txns {} must be >= min_max_txns_in_block_after_filtering_from_backpressure {}",
                    gas_estimation_config.full_block_txns,
                    min_block_capacity
                ),
            ));
        }

        if gas_estimation_config.full_block_txns > max_block_capacity {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                format!(
                    "full_block_txns {} must be <= max_sending_block_txns_after_filtering {}",
                    gas_estimation_config.full_block_txns,
                    max_block_capacity
                ),
            ));
        }

        // Warn if full_block_txns is above 80% of max capacity (likely misconfigured)
        if gas_estimation_config.full_block_txns > (max_block_capacity * 4 / 5) {
            eprintln!(
                "WARNING: full_block_txns {} is above 80% of max block capacity {}. \
                 Consider using a lower value (e.g., 50-70% of capacity) for better gas estimation.",
                gas_estimation_config.full_block_txns,
                max_block_capacity
            );
        }

        Ok(())
    }
}
```

Additionally, add a comment to the `full_block_txns` field documentation explaining its relationship to block capacity:

```rust
/// Number of transactions for blocks to be classified as full for gas estimation.
/// This value should be set between min_max_txns_in_block_after_filtering_from_backpressure
/// and max_sending_block_txns_after_filtering from the consensus config.
/// Recommended: 50-70% of max_sending_block_txns_after_filtering (e.g., 900-1260 for default 1800).
pub full_block_txns: usize,
```

## Proof of Concept

```rust
#[cfg(test)]
mod vulnerability_test {
    use super::*;
    use crate::config::{ApiConfig, ConsensusConfig, NodeConfig};

    #[test]
    fn test_full_block_txns_exceeds_block_capacity_no_validation() {
        // Create a node config where full_block_txns exceeds actual block capacity
        let node_config = NodeConfig {
            api: ApiConfig {
                gas_estimation: GasEstimationConfig {
                    full_block_txns: 5000, // Way above max_sending_block_txns_after_filtering (1800)
                    ..Default::default()
                },
                ..Default::default()
            },
            consensus: ConsensusConfig {
                max_sending_block_txns_after_filtering: 1800,
                ..Default::default()
            },
            ..Default::default()
        };

        // BUG: This should fail but currently passes!
        let result = GasEstimationConfig::sanitize(
            &node_config,
            NodeType::Validator,
            Some(ChainId::mainnet()),
        );

        // This assertion demonstrates the vulnerability - sanitize() incorrectly passes
        assert!(result.is_ok(), "Sanitize should fail but currently passes!");

        // In a production scenario:
        // - Blocks will max out at ~1800 transactions
        // - Gas estimation will never classify blocks as "full" (requires 5000 txns)
        // - Users will get chronically low gas estimates
        // - Transactions will fail due to underpricing
    }

    #[test]
    fn test_full_block_txns_below_min_capacity_no_validation() {
        let node_config = NodeConfig {
            api: ApiConfig {
                gas_estimation: GasEstimationConfig {
                    full_block_txns: 1, // Way below any reasonable value
                    ..Default::default()
                },
                ..Default::default()
            },
            ..Default::default()
        };

        // BUG: This should also fail but currently passes!
        let result = GasEstimationConfig::sanitize(
            &node_config,
            NodeType::Validator,
            Some(ChainId::testnet()),
        );

        assert!(result.is_ok(), "Sanitize should fail but currently passes!");

        // In production:
        // - All blocks with >1 transaction are classified as "full"
        // - Gas estimation returns artificially inflated prices
        // - Users systematically overpay for gas
    }

    #[test]
    fn test_configuration_drift_across_nodes() {
        // Simulate two API nodes with different configurations
        let node1_config = NodeConfig {
            api: ApiConfig {
                gas_estimation: GasEstimationConfig {
                    full_block_txns: 100,
                    ..Default::default()
                },
                ..Default::default()
            },
            ..Default::default()
        };

        let node2_config = NodeConfig {
            api: ApiConfig {
                gas_estimation: GasEstimationConfig {
                    full_block_txns: 1000,
                    ..Default::default()
                },
                ..Default::default()
            },
            ..Default::default()
        };

        // Both configurations pass sanitization despite being vastly different
        assert!(GasEstimationConfig::sanitize(&node1_config, NodeType::Validator, None).is_ok());
        assert!(GasEstimationConfig::sanitize(&node2_config, NodeType::Validator, None).is_ok());

        // Result: Users get inconsistent gas estimates depending on which API node they query
    }
}
```

**Notes:**

The vulnerability stems from a fundamental architectural gap: gas estimation configuration and consensus configuration are validated independently, despite having critical interdependencies. The `full_block_txns` parameter directly controls gas price discovery, but has no validation against the actual throughput capacity of the consensus layer.

This is particularly problematic because block capacity is not staticâ€”it dynamically adjusts under backpressure conditions. The consensus layer can reduce capacity from 1800 transactions down to 5 transactions during extreme stress, but gas estimation continues using the configured `full_block_txns` value regardless of current conditions. This creates a disconnect where gas estimation cannot properly signal network congestion when capacity is constrained.

The recommended fix introduces cross-field validation that enforces invariants between these two configuration domains. The validation ensures `full_block_txns` remains within the range `[min_max_txns_in_block_after_filtering_from_backpressure, max_sending_block_txns_after_filtering]`, preventing both overly aggressive and overly conservative configurations. The warning for values above 80% of capacity helps operators choose values that provide meaningful gas price signals across the full range of backpressure conditions.

### Citations

**File:** config/src/config/gas_estimation_config.rs (L24-25)
```rust
    /// Number of transactions for blocks to be classified as full for gas estimation
    pub full_block_txns: usize,
```

**File:** config/src/config/gas_estimation_config.rs (L54-94)
```rust
    fn sanitize(
        node_config: &NodeConfig,
        _node_type: NodeType,
        _chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();
        let gas_estimation_config = &node_config.api.gas_estimation;

        // Validate aggressive price takes the most history
        if gas_estimation_config.low_block_history > gas_estimation_config.aggressive_block_history
            || gas_estimation_config.market_block_history
                > gas_estimation_config.aggressive_block_history
        {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                format!(
                    "aggressive block history {} must be > low {}, market {}",
                    gas_estimation_config.aggressive_block_history,
                    gas_estimation_config.low_block_history,
                    gas_estimation_config.market_block_history
                ),
            ));
        }

        if gas_estimation_config.low_block_history == 0
            || gas_estimation_config.market_block_history == 0
            || gas_estimation_config.aggressive_block_history == 0
        {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                format!(
                    "low {}, market {}, aggressive {} block history must be > 0",
                    gas_estimation_config.low_block_history,
                    gas_estimation_config.market_block_history,
                    gas_estimation_config.aggressive_block_history
                ),
            ));
        }

        Ok(())
    }
```

**File:** api/src/context.rs (L1253-1254)
```rust
                    } else if prices_and_used.len() >= gas_estimation_config.full_block_txns {
                        true
```

**File:** config/src/config/consensus_config.rs (L20-20)
```rust
const MAX_SENDING_BLOCK_TXNS_AFTER_FILTERING: u64 = 1800;
```

**File:** config/src/config/consensus_config.rs (L315-315)
```rust
                    max_sending_block_txns_after_filtering_override: 5,
```
