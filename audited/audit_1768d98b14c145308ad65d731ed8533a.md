# Audit Report

## Title
Panic in Secret Share Verification Causes Validator Node Crash (Remote DoS)

## Summary
The `get_id()` function in `types/src/secret_sharing.rs` uses `.expect()` which panics when a secret share with an invalid author (not in the validator set) is received. Due to Aptos's global panic handler, this panic terminates the entire validator node process, enabling a trivial remote denial-of-service attack.

## Finding Description

The vulnerability exists in the secret sharing verification flow used by consensus: [1](#0-0) 

This `get_id()` function panics via `.expect()` if the peer is not found in the validator index. It is called during secret share verification: [2](#0-1) 

Note the TODO comment on line 78 explicitly acknowledging the missing bounds check. The verification is invoked during message processing: [3](#0-2) 

This verification occurs in spawned tasks within the secret share manager: [4](#0-3) 

**Critical: Global Panic Handler**

Aptos sets up a global panic handler that terminates the entire process on any panic (except in the bytecode verifier/deserializer): [5](#0-4) 

The panic handler is installed at node startup: [6](#0-5) 

**Attack Flow:**
1. Attacker crafts a `SecretShareMessage::Share` with an `author` field set to an address NOT in the current validator set
2. Message is sent to a target validator node via the consensus network protocol
3. Message is received and deserialized successfully (line 218 in secret_share_manager.rs)
4. Verification task spawns and calls `msg.verify()` (line 220)
5. `share.verify(config)` is invoked, which calls `config.get_id(self.author())` (line 76)
6. `.expect()` panics because the author is not in the validator index
7. Global panic handler catches the panic and calls `process::exit(12)` (line 57 of crash-handler)
8. **Entire validator node terminates**

## Impact Explanation

This is a **HIGH severity** vulnerability meeting the Aptos bug bounty criteria for "Validator node slowdowns" and potentially "Total loss of liveness/network availability":

- **Single-message node crash**: Any attacker with network access can crash any validator node with a single malicious message
- **No authentication required**: The attack works before cryptographic verification
- **Non-recoverable**: The node process terminates completely (exit code 12) and requires manual restart
- **Consensus liveness impact**: If multiple validators are targeted simultaneously, consensus can halt
- **No rate limiting**: An attacker can repeatedly crash validators faster than operators can restart them

While not reaching "Critical" severity (no fund loss or permanent network partition), this represents a severe availability attack that can disrupt the entire network.

## Likelihood Explanation

**Likelihood: HIGH**

- **Trivial to exploit**: Requires only network-level access to send consensus messages to validators
- **No special privileges needed**: Any peer can craft and send the malicious message
- **Deterministic outcome**: The panic always occurs for invalid authors
- **Wide attack surface**: All validators accepting secret share messages are vulnerable
- **Existing TODO comment**: Line 78's comment shows developers are aware of the issue but haven't fixed it

The only barrier is network-level peer authentication, but once connected, any peer can send consensus messages that trigger this code path.

## Recommendation

Replace the panicking `.expect()` with proper error handling:

```rust
pub fn get_id(&self, peer: &Author) -> anyhow::Result<usize> {
    self.validator
        .address_to_validator_index()
        .get(peer)
        .copied()
        .ok_or_else(|| anyhow::anyhow!("Peer {} not found in validator index", peer))
}
```

Update the callsite in `verify()`:

```rust
pub fn verify(&self, config: &SecretShareConfig) -> anyhow::Result<()> {
    let index = config.get_id(self.author())?;  // Propagate error instead of panic
    let decryption_key_share = self.share().clone();
    ensure!(
        index < config.verification_keys.len(),
        "Index {} out of bounds for verification_keys (len: {})",
        index,
        config.verification_keys.len()
    );
    config.verification_keys[index]
        .verify_decryption_key_share(&self.metadata.digest, &decryption_key_share)?;
    Ok(())
}
```

Also update `RandConfig::get_id()` in consensus/src/rand/rand_gen/types.rs: [7](#0-6) 

This should also return `Result<usize>` instead of panicking.

## Proof of Concept

```rust
// Test demonstrating the panic
#[test]
#[should_panic(expected = "Peer should be in the index!")]
fn test_secret_share_invalid_author_panics() {
    use aptos_types::{
        account_address::AccountAddress,
        secret_sharing::{SecretShare, SecretShareConfig, SecretShareMetadata},
        validator_verifier::ValidatorVerifier,
    };
    use aptos_crypto::hash::HashValue;
    
    // Create a minimal validator set with one validator
    let validator_addr = AccountAddress::from_hex_literal("0x1").unwrap();
    let validator_verifier = ValidatorVerifier::new(vec![]);
    
    // Create secret share config
    let config = SecretShareConfig::new(
        validator_addr,
        1,
        validator_verifier.into(),
        /* digest_key */ todo!(),
        /* msk_share */ todo!(),
        /* verification_keys */ vec![],
        /* config */ todo!(),
        /* encryption_key */ todo!(),
    );
    
    // Create share with INVALID author (not in validator set)
    let invalid_author = AccountAddress::from_hex_literal("0xBAD").unwrap();
    let metadata = SecretShareMetadata::new(1, 0, 0, HashValue::zero(), vec![]);
    let share = SecretShare::new(invalid_author, metadata, /* share */ todo!());
    
    // This will panic instead of returning an error
    share.verify(&config).unwrap();
}
```

**Exploitation steps:**
1. Identify target validator node's network address
2. Establish network connection to consensus protocol port
3. Craft `SecretShareMessage::Share` with BCS-serialized data containing an invalid author address
4. Send message via RPC protocol
5. Observe validator node crash with exit code 12

### Citations

**File:** types/src/secret_sharing.rs (L75-82)
```rust
    pub fn verify(&self, config: &SecretShareConfig) -> anyhow::Result<()> {
        let index = config.get_id(self.author());
        let decryption_key_share = self.share().clone();
        // TODO(ibalajiarun): Check index out of bounds
        config.verification_keys[index]
            .verify_decryption_key_share(&self.metadata.digest, &decryption_key_share)?;
        Ok(())
    }
```

**File:** types/src/secret_sharing.rs (L172-178)
```rust
    pub fn get_id(&self, peer: &Author) -> usize {
        *self
            .validator
            .address_to_validator_index()
            .get(peer)
            .expect("Peer should be in the index!")
    }
```

**File:** consensus/src/rand/secret_sharing/network_messages.rs (L28-38)
```rust
    pub fn verify(
        &self,
        epoch_state: &EpochState,
        config: &SecretShareConfig,
    ) -> anyhow::Result<()> {
        ensure!(self.epoch() == epoch_state.epoch);
        match self {
            SecretShareMessage::RequestShare(_) => Ok(()),
            SecretShareMessage::Share(share) => share.verify(config),
        }
    }
```

**File:** consensus/src/rand/secret_sharing/secret_share_manager.rs (L205-232)
```rust
    async fn verification_task(
        epoch_state: Arc<EpochState>,
        mut incoming_rpc_request: aptos_channel::Receiver<Author, IncomingSecretShareRequest>,
        verified_msg_tx: UnboundedSender<SecretShareRpc>,
        config: SecretShareConfig,
        bounded_executor: BoundedExecutor,
    ) {
        while let Some(dec_msg) = incoming_rpc_request.next().await {
            let tx = verified_msg_tx.clone();
            let epoch_state_clone = epoch_state.clone();
            let config_clone = config.clone();
            bounded_executor
                .spawn(async move {
                    match bcs::from_bytes::<SecretShareMessage>(dec_msg.req.data()) {
                        Ok(msg) => {
                            if msg.verify(&epoch_state_clone, &config_clone).is_ok() {
                                let _ = tx.unbounded_send(SecretShareRpc {
                                    msg,
                                    protocol: dec_msg.protocol,
                                    response_sender: dec_msg.response_sender,
                                });
                            }
                        },
                        Err(e) => {
                            warn!("Invalid dec message: {}", e);
                        },
                    }
                })
```

**File:** crates/crash-handler/src/lib.rs (L26-58)
```rust
pub fn setup_panic_handler() {
    panic::set_hook(Box::new(move |pi: &PanicHookInfo<'_>| {
        handle_panic(pi);
    }));
}

// Formats and logs panic information
fn handle_panic(panic_info: &PanicHookInfo<'_>) {
    // The Display formatter for a PanicHookInfo contains the message, payload and location.
    let details = format!("{}", panic_info);
    let backtrace = format!("{:#?}", Backtrace::new());

    let info = CrashInfo { details, backtrace };
    let crash_info = toml::to_string_pretty(&info).unwrap();
    error!("{}", crash_info);
    // TODO / HACK ALARM: Write crash info synchronously via eprintln! to ensure it is written before the process exits which error! doesn't guarantee.
    // This is a workaround until https://github.com/aptos-labs/aptos-core/issues/2038 is resolved.
    eprintln!("{}", crash_info);

    // Wait till the logs have been flushed
    aptos_logger::flush();

    // Do not kill the process if the panics happened at move-bytecode-verifier.
    // This is safe because the `state::get_state()` uses a thread_local for storing states. Thus the state can only be mutated to VERIFIER by the thread that's running the bytecode verifier.
    //
    // TODO: once `can_unwind` is stable, we should assert it. See https://github.com/rust-lang/rust/issues/92988.
    if state::get_state() == VMState::VERIFIER || state::get_state() == VMState::DESERIALIZER {
        return;
    }

    // Kill the process
    process::exit(12);
}
```

**File:** aptos-node/src/lib.rs (L233-234)
```rust
    // Setup panic handler
    aptos_crash_handler::setup_panic_handler();
```

**File:** consensus/src/rand/rand_gen/types.rs (L630-636)
```rust
    pub fn get_id(&self, peer: &Author) -> usize {
        *self
            .validator
            .address_to_validator_index()
            .get(peer)
            .expect("Peer should be in the index!")
    }
```
