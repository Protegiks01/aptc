# Audit Report

## Title
Database Validation Tool Sharding Mismatch Can Cause False Negative Corruption Detection

## Summary
The validation tool in `validate_db_data()` hardcodes sharded database access regardless of how the production database was created, potentially causing it to miss corruption in non-sharded or pre-migration databases by reading from empty shard directories instead of the actual data location.

## Finding Description
The security question asks whether the parameter '1000000' causes sharding mismatches. While this parameter is actually just a cache size (`max_node_cache`) and not related to sharding boundaries [1](#0-0) , investigation revealed a **different critical issue**: the validation logic itself has a sharding configuration mismatch.

The vulnerability exists in how databases are opened:

**Production Database Opening**: Uses `StateKvDb::new()` which checks the `enable_storage_sharding` flag and conditionally opens sharded or non-sharded storage [2](#0-1) . When sharding is disabled, all 16 shard references point to the same `ledger_db`.

**Validation Tool Opening**: Directly calls `StateKvDb::open_sharded()` which ALWAYS attempts to open sharded databases [3](#0-2) , creating empty shard directories if they don't exist [4](#0-3) .

**Attack Scenario**:
1. Database was created before AIP-97 mandatory sharding or on a private network without `enable_storage_sharding=true`
2. All state data resides in `ledger_db` directory
3. Attacker corrupts shard boundary data in `ledger_db`
4. Operator runs validation tool for health check
5. Tool opens empty `state_kv_db/shard_*` directories (creating them if needed)
6. Validation reads from empty shards, reports "no corruption"
7. Corrupted data in actual `ledger_db` location goes undetected

**Sharding Mechanism**: Sharding is deterministic based on the first nibble (4 bits) of the state key's crypto hash [5](#0-4) , distributing data across exactly 16 shards [6](#0-5) .

## Impact Explanation
**Severity: Medium**

While mainnet/testnet now enforce `enable_storage_sharding=true` [7](#0-6) , this affects:

1. **Pre-migration databases**: DBs created before AIP-97 mandatory enforcement
2. **Private networks**: Non-mainnet/testnet chains without ConfigOptimizer enforcement  
3. **Operational integrity**: False confidence in database health can delay detection of actual corruption

This breaks the **State Consistency** invariant by allowing corrupted state to remain undetected through validation tools, though it doesn't directly affect runtime consensus.

The impact is medium rather than critical because:
- It's a debugging tool, not production runtime code
- Corruption would eventually be detected through consensus disagreement
- Modern production databases use sharding by default

## Likelihood Explanation
**Likelihood: Low-Medium**

- Requires operator to run validation tool on pre-migration or non-standard database
- Databases would need to have actual corruption that aligns with shard boundaries
- Migration from non-sharded to sharded storage is a known transition period with TODO comments in code
- Most current production systems enforce sharding, reducing exposure

## Recommendation
Modify `verify_state_kvs()` to detect the actual sharding configuration of the database before opening:

```rust
pub fn verify_state_kvs(
    db_root_path: &Path,
    internal_db: &DB,
    target_ledger_version: u64,
) -> Result<()> {
    println!("Validating db statekeys");
    let storage_dir = StorageDirPaths::from_path(db_root_path);
    
    // Detect if database uses sharding by checking for shard directories
    let shard_0_path = storage_dir.state_kv_db_shard_root_path(0);
    let uses_sharding = shard_0_path.exists();
    
    let state_kv_db = if uses_sharding {
        StateKvDb::open_sharded(&storage_dir, RocksdbConfig::default(), None, None, false)?
    } else {
        // Open in non-sharded mode for legacy databases
        let ledger_db = /* open ledger_db */;
        StateKvDb::new(&storage_dir, RocksdbConfig { enable_storage_sharding: false, ..Default::default() }, None, None, false, ledger_db)?
    };
    
    // Rest of validation logic...
}
```

Alternatively, require explicit `--sharding` flag when invoking the validation tool to prevent silent mismatches.

## Proof of Concept
```rust
// Reproduction steps:
// 1. Create non-sharded database
let db_path = tempdir().unwrap();
let db = AptosDB::new_without_pruner(
    &db_path,
    false,
    BUFFERED_STATE_TARGET_ITEMS_FOR_TEST,
    DEFAULT_MAX_NUM_NODES_PER_LRU_CACHE_SHARD,
    false,
    false, // enable_sharding = false
);

// 2. Write some state data
// ... commit transactions with state updates ...

// 3. Run validation - will create empty shard directories and miss data
validate_db_data(&db_path, &internal_indexer_path, target_version).unwrap();

// 4. Verify shard directories were created but are empty
assert!(db_path.join("state_kv_db/shard_0").exists());
// But actual data is in ledger_db, not shards
```

## Notes
The original question's premise about the '1000000' parameter is incorrect - this is a cache size parameter, not a sharding configuration. The actual vulnerability discovered is the unconditional use of `open_sharded()` which doesn't respect how the database was originally created. This is primarily an operational correctness issue affecting database validation tools rather than a runtime consensus vulnerability.

### Citations

**File:** storage/aptosdb/src/db/aptosdb_testonly.rs (L43-63)
```rust
    pub fn new_for_test_with_sharding<P: AsRef<Path> + Clone>(
        db_root_path: P,
        max_node_cache: usize,
    ) -> Self {
        let db_config = RocksdbConfigs {
            enable_storage_sharding: true,
            ..Default::default()
        };
        Self::open(
            StorageDirPaths::from_path(db_root_path),
            false,
            NO_OP_STORAGE_PRUNER_CONFIG, /* pruner */
            db_config,
            false, /* indexer */
            BUFFERED_STATE_TARGET_ITEMS_FOR_TEST,
            max_node_cache,
            None,
            HotStateConfig::default(),
        )
        .expect("Unable to open AptosDB")
    }
```

**File:** storage/aptosdb/src/state_kv_db.rs (L54-80)
```rust
    pub(crate) fn new(
        db_paths: &StorageDirPaths,
        rocksdb_configs: RocksdbConfigs,
        env: Option<&Env>,
        block_cache: Option<&Cache>,
        readonly: bool,
        ledger_db: Arc<DB>,
    ) -> Result<Self> {
        let sharding = rocksdb_configs.enable_storage_sharding;
        if !sharding {
            info!("State K/V DB is not enabled!");
            return Ok(Self {
                state_kv_metadata_db: Arc::clone(&ledger_db),
                state_kv_db_shards: arr![Arc::clone(&ledger_db); 16],
                hot_state_kv_db_shards: None,
                enabled_sharding: false,
            });
        }

        Self::open_sharded(
            db_paths,
            rocksdb_configs.state_kv_db_config,
            env,
            block_cache,
            readonly,
        )
    }
```

**File:** storage/aptosdb/src/db_debugger/validation.rs (L114-146)
```rust
pub fn verify_state_kvs(
    db_root_path: &Path,
    internal_db: &DB,
    target_ledger_version: u64,
) -> Result<()> {
    println!("Validating db statekeys");
    let storage_dir = StorageDirPaths::from_path(db_root_path);
    let state_kv_db =
        StateKvDb::open_sharded(&storage_dir, RocksdbConfig::default(), None, None, false)?;

    //read all statekeys from internal db and store them in mem
    let mut all_internal_keys = HashSet::new();
    let mut iter = internal_db.iter::<StateKeysSchema>()?;
    iter.seek_to_first();
    for (key_ind, state_key_res) in iter.enumerate() {
        let state_key = state_key_res?.0;
        let state_key_hash = state_key.hash();
        all_internal_keys.insert(state_key_hash);
        if key_ind % 10_000_000 == 0 {
            println!("Processed {} keys", key_ind);
        }
    }
    println!(
        "Number of state keys in internal db: {}",
        all_internal_keys.len()
    );
    for shard_id in 0..16 {
        let shard = state_kv_db.db_shard(shard_id);
        println!("Validating state_kv for shard {}", shard_id);
        verify_state_kv(shard, &all_internal_keys, target_ledger_version)?;
    }
    Ok(())
}
```

**File:** storage/rocksdb-options/src/lib.rs (L38-41)
```rust
    if !readonly {
        db_opts.create_if_missing(true);
        db_opts.create_missing_column_families(true);
    }
```

**File:** types/src/state_store/state_key/mod.rs (L217-219)
```rust
    pub fn get_shard_id(&self) -> usize {
        usize::from(self.crypto_hash_ref().nibble(0))
    }
```

**File:** types/src/state_store/mod.rs (L27-27)
```rust
pub const NUM_STATE_SHARDS: usize = 16;
```

**File:** config/src/config/storage_config.rs (L664-668)
```rust
            if (chain_id.is_testnet() || chain_id.is_mainnet())
                && config_yaml["rocksdb_configs"]["enable_storage_sharding"].as_bool() != Some(true)
            {
                panic!("Storage sharding (AIP-97) is not enabled in node config. Please follow the guide to migration your node, and set storage.rocksdb_configs.enable_storage_sharding to true explicitly in your node config. https://aptoslabs.notion.site/DB-Sharding-Migration-Public-Full-Nodes-1978b846eb7280b29f17ceee7d480730");
            }
```
