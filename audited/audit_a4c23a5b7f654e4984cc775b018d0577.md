# Audit Report

## Title
ColdVacant State Slot Causes Non-Deterministic JMT Updates Leading to Consensus Safety Violation

## Summary
The `StateSlot::ColdVacant` variant unconditionally generates Jellyfish Merkle Tree (JMT) deletions regardless of version, while `StateSlot::HotVacant` only generates deletions if `hot_since_version >= min_version`. Since validators can have different `HotStateConfig.max_items_per_shard` settings, LRU eviction timing differs across nodes, causing identical blocks to produce different state root hashes and breaking consensus safety.

## Finding Description

The vulnerability exists in the `maybe_update_cold_state` function which determines what updates should be written to the global state JMT: [1](#0-0) 

The critical flaw is at line 45: `ColdVacant => Some(None)` always returns a deletion marker, while `HotVacant` at lines 46-58 conditionally returns deletion only if `hot_since_version >= min_version`.

During checkpoint commitment, validators iterate over state deltas and call `maybe_update_jmt` on each slot to determine JMT updates: [2](#0-1) 

When hot slots are evicted from the LRU cache, they transition from `HotVacant` to `ColdVacant`: [3](#0-2) 

The `HotStateConfig` is a per-node configuration setting, not part of consensus: [4](#0-3) 

**Attack Scenario:**

1. At version 100, key K is deleted, creating `HotVacant { hot_since_version: 100 }`
2. This deletion is committed in checkpoint at version 150 (min_version becomes 151)
3. At version 300, creating new checkpoint with `min_version = 151`:
   - **Validator A** (small cache, `max_items_per_shard: 100`): The `HotVacant` gets evicted to `ColdVacant` before checkpoint
   - **Validator B** (large cache, `max_items_per_shard: 500`): The `HotVacant` remains hot

4. When calling `maybe_update_jmt(key=K, min_version=151)`:
   - **Validator A**: `ColdVacant` → returns `Some(None)` → **JMT deletion issued**
   - **Validator B**: `HotVacant{hot_since_version:100}` → checks `100 >= 151` → `false` → returns `None` → **No JMT update**

5. Result: Different JMT updates → Different state root hashes → **Consensus broken**

The vulnerability breaks the fundamental invariant: "All validators must produce identical state roots for identical blocks" because state root calculation depends on node-local cache eviction behavior rather than deterministic execution.

## Impact Explanation

This is **CRITICAL** severity per Aptos bug bounty criteria:

1. **Consensus/Safety Violation**: Different validators compute different state roots for identical blocks, violating BFT safety guarantees. This can cause:
   - Permanent chain splits requiring hard fork
   - Validator slashing due to disagreements on state
   - Total network halt if no supermajority can agree

2. **Non-Recoverable Without Hard Fork**: Once validators diverge on state roots, they cannot reconcile without manual intervention or protocol upgrade.

3. **No Byzantine Behavior Required**: This occurs naturally through legitimate configuration differences, not requiring 1/3+ Byzantine validators.

4. **Affects All Consensus Operations**: Any checkpoint involving evicted vacant slots will trigger divergence.

The TODO comments acknowledge the inefficiency of "empty deletes" but do not recognize the consensus safety violation: [5](#0-4) 

## Likelihood Explanation

**High Likelihood:**

1. **Common Scenario**: Deleted keys that remain in hot cache are common in normal operation (e.g., temporary account states, expired resources)

2. **Configuration Variance**: Validators often have different hardware specs and configure cache sizes accordingly. The default `max_items_per_shard: 250_000` is just a default - operators will tune this.

3. **Automatic Trigger**: No attacker action required. Normal block execution with deletions will eventually trigger this as caches fill and evictions occur at different times.

4. **Increasing Probability Over Time**: As the network operates longer, more vacant slots accumulate in hot caches, increasing eviction frequency.

5. **Detection Difficulty**: The divergence only manifests at checkpoint boundaries, making it hard to detect until validators start disagreeing on block proposals.

## Recommendation

The fix must ensure `ColdVacant` behaves consistently with `HotVacant` by tracking when the vacancy occurred:

**Option 1: Add version tracking to ColdVacant**

Modify `StateSlot::ColdVacant` to include the deletion version:

```rust
pub enum StateSlot {
    ColdVacant { deleted_at_version: Option<Version> },
    // ... other variants
}
```

Update `maybe_update_cold_state`:

```rust
ColdVacant { deleted_at_version } => {
    match deleted_at_version {
        Some(v) if *v >= min_version => Some(None),
        _ => None,
    }
}
```

**Option 2: Query base state before JMT update**

Implement the TODO suggestion at line 53-54:

```rust
HotVacant { hot_since_version, .. } => {
    if *hot_since_version >= min_version {
        Some(None)
    } else {
        None
    }
},
ColdVacant => {
    // Query if key existed in base state
    // Only return Some(None) if it was an actual deletion since min_version
    None  // Conservative: skip empty deletes
}
```

**Recommended Fix:** Option 2 is safer short-term as it eliminates spurious deletions without state format changes. Option 1 is better long-term for correctness but requires migration.

## Proof of Concept

```rust
// Test demonstrating consensus divergence
#[test]
fn test_consensus_break_via_cold_vacant() {
    use aptos_types::state_store::state_slot::StateSlot;
    use aptos_types::transaction::Version;
    
    // Simulate key deleted at version 100
    let hot_vacant = StateSlot::HotVacant {
        hot_since_version: 100,
        lru_info: LRUEntry::uninitialized(),
    };
    
    // Validator A: evicts to cold before checkpoint at v300
    let cold_vacant = StateSlot::ColdVacant;
    
    // Validator B: keeps hot
    let still_hot_vacant = hot_vacant.clone();
    
    let min_version = 151; // Checkpoint after deletion
    let key = StateKey::raw(b"test_key");
    
    // Validator A's JMT update
    let update_a = cold_vacant.maybe_update_jmt(key.clone(), min_version);
    
    // Validator B's JMT update  
    let update_b = still_hot_vacant.maybe_update_jmt(key, min_version);
    
    // VULNERABILITY: Different updates for same state!
    assert!(update_a.is_some()); // A issues deletion
    assert!(update_b.is_none());  // B issues nothing
    
    println!("CONSENSUS BREAK DETECTED:");
    println!("Validator A (evicted to cold): {:?}", update_a);
    println!("Validator B (kept hot): {:?}", update_b);
    println!("Same block, different state roots!");
}
```

To reproduce in live network:
1. Configure two validators with different `max_items_per_shard` (e.g., 100k vs 500k)
2. Execute transactions that delete keys
3. Wait for LRU eviction to occur on the smaller cache validator
4. Observe state root divergence at next checkpoint
5. Validators will disagree on block validity

## Notes

This vulnerability is particularly insidious because:

1. **Silent Failure**: No errors or warnings occur until validators disagree on block proposals
2. **Configuration Dependent**: Only manifests when validators have different cache configurations
3. **TODO Comment Misleading**: The code acknowledges "empty deletes" as inefficiency but doesn't recognize the consensus safety violation
4. **Testing Gap**: Standard tests likely use uniform configurations and don't test cache eviction divergence scenarios

The root cause is mixing node-local optimization (hot state caching) with consensus-critical operations (JMT root calculation) without maintaining determinism invariants across the boundary.

### Citations

**File:** types/src/state_store/state_slot.rs (L43-78)
```rust
    fn maybe_update_cold_state(&self, min_version: Version) -> Option<Option<&StateValue>> {
        match self {
            ColdVacant => Some(None),
            HotVacant {
                hot_since_version, ..
            } => {
                if *hot_since_version >= min_version {
                    // TODO(HotState): revisit after the hot state is exclusive with the cold state
                    // Can't tell if there was a deletion to the cold state here, not much harm to
                    // issue a deletion anyway.
                    // TODO(HotState): query the base version before doing the JMT update to filter
                    //                 out "empty deletes"
                    Some(None)
                } else {
                    None
                }
            },
            ColdOccupied {
                value_version,
                value,
            }
            | HotOccupied {
                value_version,
                value,
                ..
            } => {
                if *value_version >= min_version {
                    // an update happened at or after min_version, need to update
                    Some(Some(value))
                } else {
                    // cached value from before min_version, ignore
                    None
                }
            },
        }
    }
```

**File:** storage/aptosdb/src/state_store/state_snapshot_committer.rs (L111-126)
```rust
                            for (key, slot) in updates.iter() {
                                if slot.is_hot() {
                                    hot_updates.push((
                                        CryptoHash::hash(&key),
                                        Some((
                                            HotStateValueRef::from_slot(&slot).hash(),
                                            key.clone(),
                                        )),
                                    ));
                                } else {
                                    hot_updates.push((CryptoHash::hash(&key), None));
                                }
                                if let Some(value) = slot.maybe_update_jmt(key, min_version) {
                                    all_updates.push(value);
                                }
                            }
```

**File:** storage/storage-interface/src/state_store/hot_state.rs (L100-101)
```rust
            evicted.push((current.clone(), slot.clone()));
            self.pending.insert(current, slot.to_cold());
```

**File:** config/src/config/storage_config.rs (L243-254)
```rust
pub struct HotStateConfig {
    /// Max number of items in each shard.
    pub max_items_per_shard: usize,
    /// Every now and then refresh `hot_since_version` for hot items to prevent them from being
    /// evicted.
    pub refresh_interval_versions: u64,
    /// Whether to delete persisted data on disk on restart. Used during development.
    pub delete_on_restart: bool,
    /// Whether we compute root hashes for hot state in executor and commit the resulting JMT to
    /// db.
    pub compute_root_hash: bool,
}
```
