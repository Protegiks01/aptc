# Audit Report

## Title
Governance Timing Attack: Insufficient Minimum Validation for `voting_duration_secs` Enables Rapid Proposal Execution

## Summary
The `voting_duration_secs` parameter in Aptos governance lacks adequate minimum value validation at both genesis and runtime, allowing it to be set to as low as 1 second. This enables malicious validators to create and pass governance proposals within a timeframe insufficient for honest validators to review and vote against them, effectively bypassing governance oversight.

## Finding Description

The vulnerability exists across two layers:

**Genesis Layer (Rust)**: The genesis validation function only checks that `voting_duration_secs > 0` and `voting_duration_secs < recurring_lockup_duration_secs`: [1](#0-0) 

This allows `voting_duration_secs` to be set to 1 second at genesis, as it passes both checks (1 > 0 and 1 < default 86,400 seconds).

**Runtime Layer (Move)**: The `update_governance_config` function that modifies governance parameters post-genesis contains **no validation whatsoever** on the new `voting_duration_secs` value: [2](#0-1) 

**Attack Mechanism**:

When a proposal is created, its expiration is calculated as: [3](#0-2) 

If `voting_duration_secs = 1`, the proposal expires just 1 second after creation. The voting period ends when: [4](#0-3) 

While there is a flashloan protection mechanism that prevents atomic resolution in the same second as the last vote: [5](#0-4) 

This protection is **insufficient** because:
- At T=0: Malicious validators create proposal and vote YES
- At T=1: Voting period expires (`now_seconds() > expiration_secs`)
- At T=1: Can resolve (`now_seconds() (1) > resolvable_time (0)`)

**Attack Timeline**:
1. Malicious validators control genesis config OR pass one governance proposal to reduce `voting_duration_secs` to 1
2. Create malicious proposal at time T
3. Immediately vote YES with sufficient stake to meet `min_voting_threshold`
4. After 1 second, proposal voting closes
5. After ≥1 second from last vote, resolve proposal
6. **Total time: ~1-2 seconds from creation to resolution**

Honest validators have no realistic opportunity to:
- Receive proposal notifications
- Review proposal content and execution hash
- Submit counter-votes

This breaks the **Governance Integrity** invariant which requires that voting power calculations and proposal execution follow proper deliberation processes.

## Impact Explanation

**High Severity** per Aptos Bug Bounty criteria - Significant protocol violations:

1. **Governance Bypass**: Malicious actors can pass arbitrary governance proposals without meaningful oversight, including:
   - Consensus parameter changes (affecting network safety)
   - Staking configuration modifications
   - Validator set manipulation
   - Feature flag toggles
   - Fund authorization/minting capabilities

2. **Protocol Safety Risk**: Governance is a critical safety mechanism. Bypassing it can lead to:
   - Unauthorized protocol upgrades
   - Consensus rule violations
   - Economic parameter manipulation
   - Security feature disablement

3. **Realistic Attack Path**: 
   - Genesis attack: Requires compromised genesis setup
   - Post-genesis attack: Requires one successful governance proposal (needs majority stake), then all subsequent proposals can be rushed

While not reaching Critical severity (no direct fund theft or consensus safety violation), this represents a **significant protocol violation** that undermines the entire governance security model.

## Likelihood Explanation

**Medium-High Likelihood** depending on network state:

**At Genesis**:
- Requires: Control over genesis configuration
- Likelihood: Low for mainnet (established process), Higher for testnets/forks
- Impact: Complete governance bypass from network inception

**Post-Genesis**:
- Requires: 
  1. Majority stake control to pass initial config change proposal
  2. Sufficient stake (≥`min_voting_threshold`) for subsequent proposals
- Likelihood: Medium (depends on stake distribution)
- If achieved: High impact as all future proposals can be rushed

**Mitigating Factors**:
- Honest validators may notice the config change in step 1
- Requires continuous monitoring to exploit quickly
- Community/social layer might detect suspicious rapid proposals

**Aggravating Factors**:
- No on-chain enforcement of reasonable minimums
- Once `voting_duration_secs` is reduced, all honest validators face same constraint
- Coordination complexity increases for defenders as response time shrinks

## Recommendation

Implement minimum value validation at both layers:

**Rust Genesis Validation** (add to `validate_genesis_config`):
```rust
const MIN_VOTING_DURATION_SECS: u64 = 86_400; // 1 day minimum

assert!(
    genesis_config.voting_duration_secs >= MIN_VOTING_DURATION_SECS,
    "Voting duration must be at least {} seconds (1 day)", MIN_VOTING_DURATION_SECS
);
```

**Move Runtime Validation** (add to `update_governance_config`):
```move
const MIN_VOTING_DURATION_SECS: u64 = 86400; // 1 day

assert!(
    voting_duration_secs >= MIN_VOTING_DURATION_SECS,
    error::invalid_argument(EINVALID_VOTING_DURATION)
);
```

**Recommended Minimum**: 86,400 seconds (1 day) for mainnet, or at minimum 3,600 seconds (1 hour) to allow realistic human review and voting.

**Additional Hardening**:
- Add maximum value check (e.g., < 30 days) to prevent indefinite voting periods
- Consider requiring a delay between config changes and their effect
- Emit prominent events when governance config changes

## Proof of Concept

```move
#[test(aptos_framework = @0x1)]
fun test_one_second_voting_attack(aptos_framework: &signer) {
    use aptos_framework::aptos_governance;
    use aptos_framework::timestamp;
    
    // Initialize governance with 1-second voting duration
    aptos_governance::initialize(
        aptos_framework,
        100_000_000_000_000, // min_voting_threshold: 1M APT
        100_000_000_000_000, // required_proposer_stake: 1M APT  
        1                     // voting_duration_secs: 1 SECOND (VULNERABLE!)
    );
    
    // Malicious validator creates proposal at T=0
    timestamp::set_time_has_started_for_testing(aptos_framework);
    timestamp::update_global_time_for_test(1000000); // T=0 seconds
    
    // Create malicious proposal
    let proposal_id = aptos_governance::create_proposal_v2_impl(
        malicious_validator_signer,
        malicious_stake_pool,
        x"deadbeef", // malicious execution hash
        b"", b"", false
    );
    
    // Malicious validators vote immediately
    aptos_governance::vote_internal(
        malicious_validator_signer,
        malicious_stake_pool,
        proposal_id,
        1_000_000_000_000, // Vote with 1M APT
        true // YES vote
    );
    
    // Advance time by 1 second - voting period now closed
    timestamp::update_global_time_for_test(2000000); // T=1 second
    
    // Voting is now closed - honest validators had only 0-1 second to respond!
    assert!(voting::is_voting_closed<GovernanceProposal>(@aptos_framework, proposal_id), 1);
    
    // Can resolve after another second (non-atomic protection)
    timestamp::update_global_time_for_test(3000000); // T=2 seconds
    let signer = aptos_governance::resolve(proposal_id, @aptos_framework);
    
    // Malicious proposal executed successfully in ~2 seconds total!
    // Honest validators never had realistic chance to review and vote against
}
```

**Notes**:
- The current codebase's only protection (non-atomic resolution) prevents resolution in the same second as voting, but does **not** prevent the timing attack when `voting_duration_secs` is set to 1 second
- The default value of 43,200 seconds (12 hours) in test configs shows intended usage, but lack of validation allows bypass
- Real-world exploitation requires either genesis control or one successful governance proposal to reduce the duration, after which all subsequent proposals can be rushed

### Citations

**File:** aptos-move/vm-genesis/src/lib.rs (L427-433)
```rust
        genesis_config.voting_duration_secs > 0,
        "On-chain voting duration must be > 0"
    );
    assert!(
        genesis_config.voting_duration_secs < genesis_config.recurring_lockup_duration_secs,
        "Voting duration must be strictly smaller than recurring lockup"
    );
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L243-254)
```text
    public fun update_governance_config(
        aptos_framework: &signer,
        min_voting_threshold: u128,
        required_proposer_stake: u64,
        voting_duration_secs: u64,
    ) acquires GovernanceConfig, GovernanceEvents {
        system_addresses::assert_aptos_framework(aptos_framework);

        let governance_config = borrow_global_mut<GovernanceConfig>(@aptos_framework);
        governance_config.voting_duration_secs = voting_duration_secs;
        governance_config.min_voting_threshold = min_voting_threshold;
        governance_config.required_proposer_stake = required_proposer_stake;
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L429-430)
```text
        let current_time = timestamp::now_seconds();
        let proposal_expiration = current_time + governance_config.voting_duration_secs;
```

**File:** aptos-move/framework/aptos-framework/sources/voting.move (L444-445)
```text
        let resolvable_time = to_u64(*simple_map::borrow(&proposal.metadata, &utf8(RESOLVABLE_TIME_METADATA_KEY)));
        assert!(timestamp::now_seconds() > resolvable_time, error::invalid_state(ERESOLUTION_CANNOT_BE_ATOMIC));
```

**File:** aptos-move/framework/aptos-framework/sources/voting.move (L770-772)
```text
    fun is_voting_period_over<ProposalType: store>(proposal: &Proposal<ProposalType>): bool {
        timestamp::now_seconds() > proposal.expiration_secs
    }
```
