# Audit Report

## Title
Unencrypted Remote Executor Communication Exposes Transaction Data and Enables Man-in-the-Middle Attacks

## Summary
The remote executor service uses unencrypted HTTP connections for communication between the coordinator and executor shards, transmitting sensitive blockchain transaction data in plaintext. This allows network attackers to eavesdrop on transactions before execution and potentially perform man-in-the-middle attacks to manipulate execution results, violating consensus determinism.

## Finding Description

The `GRPCNetworkMessageServiceClientWrapper::get_channel()` function explicitly creates HTTP connections instead of HTTPS for remote executor communication: [1](#0-0) 

This function is called during client initialization and establishes plaintext connections for all remote executor traffic.

The remote executor architecture is used in production for distributed block execution across multiple shards. The coordinator sends execution commands containing:

1. **Full transaction data** via `ExecuteBlockCommand`: [2](#0-1) 

This includes `SubBlocksForShard<AnalyzedTransaction>`, which wraps `SignatureVerifiedTransaction` containing complete user transactions with signatures, payloads, and all transaction details: [3](#0-2) 

2. **Execution results** via `RemoteExecutionResult`: [4](#0-3) 

This contains `TransactionOutput` with write sets (state changes), events, and gas consumption.

3. **State data** via `RemoteKVRequest/RemoteKVResponse`: [5](#0-4) 

The remote executor is actively used in production when configured: [6](#0-5) 

The standalone executor service binary accepts network addresses for deployment: [7](#0-6) 

**Attack Scenario:**

An attacker positioned on the network path between the coordinator and executor shards can:

1. **Passive Eavesdropping**: Intercept and read all BCS-serialized messages containing:
   - User transactions before they're committed to the blockchain
   - Transaction execution results including state changes
   - Cross-shard coordination messages
   - State key-value pairs

2. **Active Man-in-the-Middle**: Modify messages in transit:
   - Alter execution results sent from shards to coordinator
   - Modify transaction ordering within sub-blocks
   - Drop or delay messages causing execution failures
   - Inject malicious state values

This violates the **Deterministic Execution** invariant: if different nodes receive different execution results due to MITM tampering, they will compute different state roots, breaking consensus safety.

## Impact Explanation

**Severity: CRITICAL** (up to $1,000,000 per Aptos Bug Bounty)

This vulnerability meets multiple critical impact categories:

1. **Consensus/Safety Violations**: MITM attacks can cause different validators to commit different state roots by tampering with execution results. If the coordinator receives modified results from shards, it will produce an incorrect block that other validators cannot verify, leading to consensus failures.

2. **Complete Loss of Transaction Confidentiality**: All transaction data is exposed in plaintext before commitment, including:
   - User addresses and transaction payloads
   - Smart contract interactions
   - Token transfers and balances
   - Governance votes
   - Any on-chain activity

3. **Front-Running Opportunities**: Attackers can observe transactions before execution and front-run MEV (Maximal Extractable Value) opportunities.

4. **State Inconsistencies**: Tampering with state key-value responses can cause executors to operate on incorrect state, leading to incorrect execution outputs.

The lack of encryption or authentication means there's no way to detect message tampering or validate message integrity, making these attacks undetectable at the protocol layer.

## Likelihood Explanation

**Likelihood: HIGH**

1. **Low Attack Complexity**: Network interception requires only positioning on the network path (router compromise, ISP-level access, cloud provider network access). No cryptographic breaks or protocol exploits needed.

2. **Production Deployment**: The remote executor is designed for production use across distributed machines/networks as evidenced by the standalone binary and configuration options. When shards run on different machines, network traffic traverses potentially untrusted networks.

3. **No Authentication**: The gRPC service has no authentication mechanism - any client can connect: [8](#0-7) 

4. **Persistent Exposure**: Once configured, the vulnerability persists for all execution traffic until fixed.

5. **Easy Detection**: Network traffic analysis tools can trivially identify and decode BCS-serialized transaction data.

## Recommendation

Implement TLS encryption for all remote executor communication. The Aptos codebase already has TLS implementations for other services that can be adapted:

**Solution 1: Add TLS Configuration (Preferred)**

1. Add TLS configuration to `NetworkController`:
```rust
pub struct TlsConfig {
    pub cert_path: String,
    pub key_path: String,
}

pub struct NetworkController {
    // ... existing fields
    tls_config: Option<TlsConfig>,
}
```

2. Modify `get_channel` to use HTTPS with TLS: [9](#0-8) 

Replace line 128 with:
```rust
remote_channel: rt.block_on(async { 
    Self::get_channel(format!("https://{}", remote_addr), tls_config).await 
}),
```

3. Update `get_channel` to configure TLS:
```rust
async fn get_channel(
    remote_addr: String, 
    tls_config: Option<TlsConfig>
) -> NetworkMessageServiceClient<Channel> {
    info!("Trying to connect to remote server at {:?}", remote_addr);
    let mut endpoint = tonic::transport::Endpoint::new(remote_addr).unwrap();
    
    if let Some(config) = tls_config {
        let cert = tokio::fs::read(&config.cert_path).await.unwrap();
        let key = tokio::fs::read(&config.key_path).await.unwrap();
        let identity = tonic::transport::Identity::from_pem(cert, key);
        let tls = tonic::transport::ClientTlsConfig::new()
            .identity(identity);
        endpoint = endpoint.tls_config(tls).unwrap();
    }
    
    NetworkMessageServiceClient::new(endpoint.connect_lazy())
        .max_decoding_message_size(MAX_MESSAGE_SIZE)
}
```

4. Configure server TLS similarly in `start_async`: [10](#0-9) 

**Solution 2: Use Noise Protocol (Alternative)**

Since Aptos already uses the Noise protocol for peer-to-peer networking, consider extending it to remote executor communication for consistency with the existing security architecture.

## Proof of Concept

**Network Eavesdropping PoC:**

```rust
// This demonstrates how an attacker can intercept remote executor traffic
// Run this on the network path between coordinator and shard

use std::net::TcpListener;
use std::io::{Read, Write};
use std::thread;

fn main() {
    // Assume shard is at 127.0.0.1:52201
    // Attacker intercepts on port 52201 and forwards to real shard at 52202
    let listener = TcpListener::bind("127.0.0.1:52201").unwrap();
    
    for stream in listener.incoming() {
        let mut client_stream = stream.unwrap();
        thread::spawn(move || {
            // Connect to real shard
            let mut shard_stream = std::net::TcpStream::connect("127.0.0.1:52202").unwrap();
            
            let mut buffer = [0u8; 8192];
            loop {
                // Read from client
                if let Ok(n) = client_stream.read(&mut buffer) {
                    if n == 0 { break; }
                    
                    // Log intercepted data (BCS-serialized transactions)
                    println!("Intercepted {} bytes from coordinator:", n);
                    println!("Raw data: {:?}", &buffer[..n]);
                    
                    // Attempt to deserialize as RemoteExecutionRequest
                    if let Ok(req) = bcs::from_bytes::<RemoteExecutionRequest>(&buffer[..n]) {
                        println!("Decoded execution request: {:?}", req);
                        // Attacker now has full transaction data!
                    }
                    
                    // Forward to real shard (unmodified)
                    shard_stream.write_all(&buffer[..n]).unwrap();
                }
                
                // Read response from shard
                if let Ok(n) = shard_stream.read(&mut buffer) {
                    if n == 0 { break; }
                    
                    println!("Intercepted {} bytes from shard:", n);
                    
                    // Could modify execution results here (MITM)
                    // For example, alter TransactionOutput data
                    
                    // Forward to coordinator
                    client_stream.write_all(&buffer[..n]).unwrap();
                }
            }
        });
    }
}
```

**Deployment Test:**

1. Start a coordinator with remote addresses configured
2. Start executor shards with the addresses
3. Run packet capture on the network: `tcpdump -i any -w remote_executor.pcap port 52200-52210`
4. Analyze captured packets - all transaction data visible in plaintext
5. Deserialize captured packets using BCS to extract full transaction details

**Impact Demonstration:**

```bash
# Start remote executor shard
./target/release/aptos-executor-service \
  --shard-id 0 \
  --num-shards 2 \
  --coordinator-address 127.0.0.1:52200 \
  --remote-executor-addresses 127.0.0.1:52201 127.0.0.1:52202

# Capture traffic (in another terminal)
tcpdump -i lo -X port 52200

# Submit transactions - observe plaintext transaction data in tcpdump output
```

The captured packets will show BCS-serialized transaction data that can be trivially decoded without any cryptographic operations.

## Notes

- The vulnerability exists despite the directory being named `secure/net/` - the name does not reflect actual security properties
- Other Aptos services (indexer gRPC, REST API) properly implement TLS, making this omission particularly concerning
- The peer-to-peer networking layer uses the Noise protocol for encryption, but remote executor bypasses this
- This affects only deployments using distributed remote execution; single-node execution is unaffected
- The issue is in production code paths, not test-only code

### Citations

**File:** secure/net/src/grpc_network_service/mod.rs (L57-67)
```rust
    async fn start_async(
        self,
        server_addr: SocketAddr,
        rpc_timeout_ms: u64,
        server_shutdown_rx: oneshot::Receiver<()>,
    ) {
        let reflection_service = tonic_reflection::server::Builder::configure()
            .register_encoded_file_descriptor_set(FILE_DESCRIPTOR_SET)
            .build_v1()
            .unwrap();

```

**File:** secure/net/src/grpc_network_service/mod.rs (L75-87)
```rust
        Server::builder()
            .timeout(std::time::Duration::from_millis(rpc_timeout_ms))
            .add_service(
                NetworkMessageServiceServer::new(self).max_decoding_message_size(MAX_MESSAGE_SIZE),
            )
            .add_service(reflection_service)
            .serve_with_shutdown(server_addr, async {
                server_shutdown_rx.await.ok();
                info!("Received signal to shutdown server at {:?}", server_addr);
            })
            .await
            .unwrap();
        info!("Server shutdown at {:?}", server_addr);
```

**File:** secure/net/src/grpc_network_service/mod.rs (L124-130)
```rust
    pub fn new(rt: &Runtime, remote_addr: SocketAddr) -> Self {
        Self {
            remote_addr: remote_addr.to_string(),
            remote_channel: rt
                .block_on(async { Self::get_channel(format!("http://{}", remote_addr)).await }),
        }
    }
```

**File:** secure/net/src/grpc_network_service/mod.rs (L132-138)
```rust
    async fn get_channel(remote_addr: String) -> NetworkMessageServiceClient<Channel> {
        info!("Trying to connect to remote server at {:?}", remote_addr);
        let conn = tonic::transport::Endpoint::new(remote_addr)
            .unwrap()
            .connect_lazy();
        NetworkMessageServiceClient::new(conn).max_decoding_message_size(MAX_MESSAGE_SIZE)
    }
```

**File:** execution/executor-service/src/lib.rs (L32-41)
```rust
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct RemoteExecutionResult {
    pub inner: Result<Vec<Vec<TransactionOutput>>, VMStatus>,
}

impl RemoteExecutionResult {
    pub fn new(inner: Result<Vec<Vec<TransactionOutput>>, VMStatus>) -> Self {
        Self { inner }
    }
}
```

**File:** execution/executor-service/src/lib.rs (L48-53)
```rust
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct ExecuteBlockCommand {
    pub(crate) sub_blocks: SubBlocksForShard<AnalyzedTransaction>,
    pub(crate) concurrency_level: usize,
    pub(crate) onchain_config: BlockExecutorConfigFromOnchain,
}
```

**File:** execution/executor-service/src/lib.rs (L67-92)
```rust
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct RemoteKVRequest {
    pub(crate) shard_id: ShardId,
    pub(crate) keys: Vec<StateKey>,
}

impl RemoteKVRequest {
    pub fn new(shard_id: ShardId, keys: Vec<StateKey>) -> Self {
        Self { shard_id, keys }
    }

    pub fn into(self) -> (ShardId, Vec<StateKey>) {
        (self.shard_id, self.keys)
    }
}

#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct RemoteKVResponse {
    pub(crate) inner: Vec<(StateKey, Option<StateValue>)>,
}

impl RemoteKVResponse {
    pub fn new(inner: Vec<(StateKey, Option<StateValue>)>) -> Self {
        Self { inner }
    }
}
```

**File:** types/src/transaction/analyzed_transaction.rs (L23-37)
```rust
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct AnalyzedTransaction {
    transaction: SignatureVerifiedTransaction,
    /// Set of storage locations that are read by the transaction - this doesn't include location
    /// that are written by the transactions to avoid duplication of locations across read and write sets
    /// This can be accurate or strictly overestimated.
    pub read_hints: Vec<StorageLocation>,
    /// Set of storage locations that are written by the transaction. This can be accurate or strictly
    /// overestimated.
    pub write_hints: Vec<StorageLocation>,
    /// A transaction is predictable if neither the read_hint or the write_hint have wildcards.
    predictable_transaction: bool,
    /// The hash of the transaction - this is cached for performance reasons.
    hash: HashValue,
}
```

**File:** execution/executor/src/workflow/do_get_execution_output.rs (L261-267)
```rust
        if !get_remote_addresses().is_empty() {
            Ok(V::execute_block_sharded(
                &REMOTE_SHARDED_BLOCK_EXECUTOR.lock(),
                partitioned_txns,
                state_view,
                onchain_config,
            )?)
```

**File:** execution/executor-service/src/main.rs (L9-25)
```rust
#[derive(Debug, Parser)]
struct Args {
    #[clap(long, default_value_t = 8)]
    pub num_executor_threads: usize,

    #[clap(long)]
    pub shard_id: usize,

    #[clap(long)]
    pub num_shards: usize,

    #[clap(long, num_args = 1..)]
    pub remote_executor_addresses: Vec<SocketAddr>,

    #[clap(long)]
    pub coordinator_address: SocketAddr,
}
```
