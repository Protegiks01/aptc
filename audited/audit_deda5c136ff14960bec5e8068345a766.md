# Audit Report

## Title
Path Traversal Vulnerability in State Snapshot Restore Allows Arbitrary File Read

## Summary
The state snapshot restore functionality in `aptos-core/storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs` contains a critical path traversal vulnerability. The `manifest.proof` field is not sanitized before being used to read files from the filesystem, allowing an attacker who controls or modifies a backup manifest to read arbitrary files from the validator node, including private keys and consensus state. [1](#0-0) 

## Finding Description

The vulnerability exists in the `StateSnapshotRestoreController::run_impl()` function. The restore process loads a manifest file that contains metadata about the state snapshot backup, including a `proof` field that specifies the location of the cryptographic proof file: [2](#0-1) 

The `proof` field is of type `FileHandle`, which is simply a type alias for `String` with no validation: [3](#0-2) 

When the restore process attempts to load the proof file via `load_bcs_file()`, it eventually calls the `LocalFs::open_for_read()` implementation, which directly joins the file handle to the base directory without any path sanitization: [4](#0-3) 

The vulnerability exists because `Path::join()` in Rust does not prevent path traversal. If `file_handle` contains sequences like `"../"`, they are preserved in the resulting path, allowing traversal outside the intended backup directory.

**Attack Path:**

1. Attacker creates a malicious `StateSnapshotBackup` manifest JSON file with `proof: "../../../path/to/validator/consensus_key.yaml"` (or any other sensitive file)
2. Attacker either:
   - Compromises the backup storage and replaces legitimate manifests
   - Tricks the validator operator into using the malicious manifest via social engineering
   - Performs MITM attack during manifest download from remote storage
3. When the validator operator runs the restore command pointing to the malicious manifest, the restore process calls `load_bcs_file(&manifest.proof)`
4. The `LocalFs::open_for_read()` function constructs path as: `backup_dir.join("../../../path/to/validator/consensus_key.yaml")`
5. Rust's `Path::join()` resolves this to an absolute path outside the backup directory
6. The file is opened and its entire contents read into memory via `read_to_end()`
7. Although BCS deserialization will fail for non-BCS data, the file contents have already been read and are present in memory

The same vulnerability affects chunk proof files: [5](#0-4) 

## Impact Explanation

This vulnerability qualifies as **Critical Severity** under the Aptos bug bounty program for the following reasons:

**Remote Code Execution Potential**: By reading validator private keys (consensus keys, networking keys, or validator account keys), an attacker could:
- Impersonate the validator in consensus voting
- Sign malicious blocks or votes
- Execute arbitrary consensus operations
- Potentially lead to full node compromise

**Consensus/Safety Violations**: Access to consensus state files could allow:
- Understanding the validator's voting history
- Predicting or manipulating consensus behavior
- Breaking consensus safety guarantees if combined with other attacks

**Information Disclosure**: The attacker can read:
- `/etc/passwd` and other system files for reconnaissance
- Validator configuration files containing sensitive settings
- Private keys from standard locations (`~/.aptos/`, `/opt/aptos/`, etc.)
- Consensus state from `storage/` directories
- Any file readable by the validator process user

The impact is amplified because:
1. Validator nodes typically run with elevated privileges
2. The backup/restore process has broad filesystem access
3. The file contents are fully read before any validation occurs
4. Timing differences could leak information even if deserialization fails

## Likelihood Explanation

**Likelihood: Medium to High**

The attack requires one of the following conditions:
1. **Compromised Backup Storage** (Medium likelihood): If the backup storage (S3, GCS, local NFS) has weak access controls, an attacker could modify manifest files
2. **Supply Chain Attack** (Medium likelihood): Malicious manifests could be introduced during backup transfer or distribution
3. **Operator Error** (Low to Medium likelihood): Operator uses a manifest from an untrusted source without verification

**Feasibility: High** - The exploitation is straightforward:
- No complex cryptographic operations required
- Simple path traversal strings work directly
- No race conditions or timing requirements
- Works against both LocalFs and CommandAdapter storage backends

**Detection: Low** - The attack is difficult to detect:
- File reads appear as legitimate backup restore operations
- BCS deserialization failure is expected for arbitrary files
- No obvious indicators in logs unless verbose error reporting is enabled

## Recommendation

Implement strict path validation and sanitization in the `BackupStorage` implementations:

**Solution 1: Path Canonicalization (Recommended)**
Verify that all file handles resolve to paths within the intended directory:

```rust
// In LocalFs::open_for_read()
async fn open_for_read(
    &self,
    file_handle: &FileHandleRef,
) -> Result<Box<dyn AsyncRead + Send + Unpin>> {
    // Construct the full path
    let path = self.dir.join(file_handle);
    
    // Canonicalize to resolve .. and symlinks
    let canonical_path = path.canonicalize()
        .err_notes(&path)?;
    let canonical_dir = self.dir.canonicalize()
        .map_err(|e| anyhow!("Failed to canonicalize base directory: {}", e))?;
    
    // Verify the path is within the base directory
    if !canonical_path.starts_with(&canonical_dir) {
        bail!("Path traversal detected: {} escapes base directory {}", 
              canonical_path.display(), canonical_dir.display());
    }
    
    let file = OpenOptions::new()
        .read(true)
        .open(&canonical_path)
        .await
        .err_notes(&canonical_path)?;
    Ok(Box::new(file))
}
```

**Solution 2: Reject Dangerous Sequences**
Add validation to `FileHandle` creation:

```rust
impl FileHandle {
    pub fn new(value: String) -> Result<Self> {
        // Reject path traversal sequences
        if value.contains("..") || value.starts_with('/') {
            bail!("Invalid file handle contains path traversal: {}", value);
        }
        Ok(value)
    }
}
```

**Solution 3: Use Relative Path Validation**
The codebase already has `NormalizedPath` for this purpose: [6](#0-5) 

Apply similar validation to backup file handles.

## Proof of Concept

```rust
// Create a malicious manifest file
use std::fs;
use serde_json::json;

#[tokio::test]
async fn test_path_traversal_vulnerability() {
    // Setup: Create a test backup directory
    let backup_dir = tempfile::tempdir().unwrap();
    let sensitive_file = tempfile::NamedTempFile::new().unwrap();
    fs::write(sensitive_file.path(), b"SENSITIVE_VALIDATOR_KEY").unwrap();
    
    // Create malicious manifest with path traversal
    let malicious_proof_path = format!("../../../{}", 
        sensitive_file.path().to_str().unwrap());
    
    let manifest = json!({
        "version": 100,
        "epoch": 1,
        "root_hash": "0x0000000000000000000000000000000000000000000000000000000000000000",
        "chunks": [],
        "proof": malicious_proof_path  // Path traversal here!
    });
    
    // Save malicious manifest
    let manifest_path = backup_dir.path().join("malicious_manifest.json");
    fs::write(&manifest_path, manifest.to_string()).unwrap();
    
    // Attempt restore - this will read the sensitive file
    let storage = Arc::new(LocalFs::new(backup_dir.path().to_path_buf()));
    let manifest: StateSnapshotBackup = storage
        .load_json_file(manifest_path.to_str().unwrap())
        .await
        .unwrap();
    
    // This call will read the sensitive file due to path traversal
    let result = storage.load_bcs_file::<(TransactionInfoWithProof, LedgerInfoWithSignatures)>(
        &manifest.proof
    ).await;
    
    // Even though BCS deserialization fails, the file was READ
    assert!(result.is_err(), "BCS deserialization should fail");
    // The file contents were in memory before the error
}
```

## Notes

The vulnerability also affects the `CommandAdapter` backend when shell commands process unsanitized file handles. The same fix should be applied to all `BackupStorage` implementations. [7](#0-6) 

While the immediate impact requires the attacker to control or modify the manifest file, this represents a **failure of defense in depth**. Security-critical systems should validate all external inputs, including file paths from manifests, regardless of the trust level of the backup storage.

### Citations

**File:** storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs (L123-126)
```rust
        let manifest: StateSnapshotBackup =
            self.storage.load_json_file(&self.manifest_handle).await?;
        let (txn_info_with_proof, li): (TransactionInfoWithProof, LedgerInfoWithSignatures) =
            self.storage.load_bcs_file(&manifest.proof).await?;
```

**File:** storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs (L187-196)
```rust
        let futs_iter = chunks.into_iter().enumerate().map(|(chunk_idx, chunk)| {
            let storage = storage.clone();
            async move {
                tokio::spawn(async move {
                    let blobs = Self::read_state_value(&storage, chunk.blobs.clone()).await?;
                    let proof = storage.load_bcs_file(&chunk.proof).await?;
                    Result::<_>::Ok((chunk_idx, chunk, blobs, proof))
                })
                .await?
            }
```

**File:** storage/backup/backup-cli/src/backup_types/state_snapshot/manifest.rs (L29-51)
```rust
/// State snapshot backup manifest, representing a complete state view at specified version.
#[derive(Deserialize, Serialize)]
pub struct StateSnapshotBackup {
    /// Version at which this state snapshot is taken.
    pub version: Version,
    /// Epoch in which this state snapshot is taken.
    pub epoch: u64,
    /// Hash of the state tree root.
    pub root_hash: HashValue,
    /// All account blobs in chunks.
    pub chunks: Vec<StateSnapshotChunk>,
    /// BCS serialized
    /// `Tuple(TransactionInfoWithProof, LedgerInfoWithSignatures)`.
    ///   - The `TransactionInfoWithProof` is at `Version` above, and carries the same `root_hash`
    /// above; It proves that at specified version the root hash is as specified in a chain
    /// represented by the LedgerInfo below.
    ///   - The signatures on the `LedgerInfoWithSignatures` has a version greater than or equal to
    /// the version of this backup but is within the same epoch, so the signatures on it can be
    /// verified by the validator set in the same epoch, which can be provided by an
    /// `EpochStateBackup` recovered prior to this to the DB; Requiring it to be in the same epoch
    /// limits the requirement on such `EpochStateBackup` to no older than the same epoch.
    pub proof: FileHandle,
}
```

**File:** storage/backup/backup-cli/src/storage/mod.rs (L36-41)
```rust
/// URI pointing to a file in a backup storage, like "s3:///bucket/path/file".
/// These are created by the storage when `create_for_write()`, stored in manifests by the backup
/// controller, and passed back to the storage when `open_for_read()` by the restore controller
/// to retrieve a file referred to in the manifest.
pub type FileHandle = String;
pub type FileHandleRef = str;
```

**File:** storage/backup/backup-cli/src/storage/local_fs/mod.rs (L98-109)
```rust
    async fn open_for_read(
        &self,
        file_handle: &FileHandleRef,
    ) -> Result<Box<dyn AsyncRead + Send + Unpin>> {
        let path = self.dir.join(file_handle);
        let file = OpenOptions::new()
            .read(true)
            .open(&path)
            .await
            .err_notes(&path)?;
        Ok(Box::new(file))
    }
```

**File:** third_party/move/tools/move-package-resolver/src/path.rs (L1-50)
```rust
// Copyright (c) Aptos Foundation
// SPDX-License-Identifier: Apache-2.0

use anyhow::Result;
use std::{
    ops::Deref,
    path::{Component, Path, PathBuf},
};

/// Wrapper around [`PathBuf`] that represents a canonical path, which is not only normalized,
/// but also absolute and have all symbolic links resolved.
#[derive(Debug, Clone, Eq, PartialEq, Ord, PartialOrd)]
pub struct CanonicalPath(PathBuf);

impl Deref for CanonicalPath {
    type Target = PathBuf;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl AsRef<Path> for CanonicalPath {
    fn as_ref(&self) -> &Path {
        &self.0
    }
}

impl CanonicalPath {
    pub fn new(path: impl AsRef<Path>) -> Result<Self> {
        let path = path.as_ref().canonicalize()?;
        Ok(Self(path))
    }
}

/// Normalizes a path by removing all redundant `..` and `.` components.
/// Accepts both relative and absolute paths as input.
///
/// Examples:
/// - `./foo` -> `foo`
/// - `a/b/../c` -> `a/c`
/// - `/foo/../..` -> `/`
/// - `a/../../b` -> `../b`
fn normalize_path(path: impl AsRef<Path>) -> PathBuf {
    let path = path.as_ref();
    let mut stack = vec![];

    for component in path.components() {
        match &component {
            Component::CurDir => (),
```

**File:** storage/backup/backup-cli/src/storage/command_adapter/mod.rs (L114-124)
```rust
    async fn open_for_read(
        &self,
        file_handle: &FileHandleRef,
    ) -> Result<Box<dyn AsyncRead + Send + Unpin>> {
        let child = self
            .cmd(&self.config.commands.open_for_read, vec![
                EnvVar::file_handle(file_handle.to_string()),
            ])
            .spawn()?;
        Ok(Box::new(child.into_data_source()))
    }
```
