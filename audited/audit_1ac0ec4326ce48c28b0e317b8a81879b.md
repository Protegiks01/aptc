# Audit Report

## Title
Genesis Reconfiguration Event Fails to Initialize last_reconfiguration_time, Causing Immediate Epoch Transition in First Block

## Summary
The `emit_genesis_reconfiguration_event()` function sets the epoch to 1 but leaves `last_reconfiguration_time` at 0. When the first block after genesis is executed with a timestamp >= `epoch_interval`, the `block_prologue()` function incorrectly triggers an immediate reconfiguration, transitioning from epoch 1 to epoch 2 in the first block. [1](#0-0) 

## Finding Description
During genesis, the `emit_genesis_reconfiguration_event()` function increments the epoch from 0 to 1 and emits a `NewEpochEvent`, but critically **does not update** `last_reconfiguration_time`, leaving it at its initialized value of 0. [1](#0-0) 

When the first block after genesis executes, `block_prologue()` performs a time-based reconfiguration check: [2](#0-1) 

This condition evaluates to: `timestamp - 0 >= epoch_interval`

For any block with timestamp >= `epoch_interval` (typically 7,200,000,000 microseconds = 2 hours), this condition is true, triggering `reconfiguration::reconfigure()`.

The `reconfigure()` function has guards but none prevent this scenario: [3](#0-2) 

- `chain_status::is_genesis()` returns false (genesis has ended via `set_genesis_end()`)
- `timestamp::now_microseconds() == 0` returns false (global timestamp was updated by `emit_new_block_event()`)
- The duplicate reconfiguration guard `current_time == last_reconfiguration_time` fails (timestamp != 0)

Therefore, reconfiguration proceeds, incrementing the epoch to 2 and emitting a `NewEpochEvent`. The execution layer detects this event via `has_new_epoch_event()` and populates `next_epoch_state`, triggering an immediate epoch boundary. [4](#0-3) [5](#0-4) 

## Impact Explanation
This vulnerability causes **Medium severity** state inconsistency:

1. **Premature Epoch Transition**: Epoch 1 contains only one block instead of lasting the configured `epoch_interval`
2. **Incorrect Reward Distribution**: `stake::on_new_epoch()` is called immediately, potentially distributing rewards when none should exist
3. **Validator Set Changes**: The validator set may change prematurely before any meaningful consensus work occurs
4. **Timestamp Semantics Violation**: The system compares absolute timestamps (Unix time) against relative durations (epoch_interval), which is semantically incorrect when `last_reconfiguration_time` is 0

While this doesn't cause loss of funds or consensus safety violations, it creates state inconsistencies requiring manual intervention and violates the expected epoch duration invariant.

## Likelihood Explanation
This vulnerability triggers **automatically** in the following scenarios:

1. **Production Networks**: If genesis uses `GENESIS_TIMESTAMP_USECS = 0` and the first block has any positive timestamp >= `epoch_interval`, reconfiguration triggers
2. **Testnets with Small Epoch Intervals**: If `epoch_interval` is set to a small value (e.g., 60 seconds) for testing, the first block will almost certainly exceed this threshold
3. **Standard Configuration**: With the default `epoch_interval` of 7,200 seconds (2 hours), any Unix timestamp-based block will trigger immediate reconfiguration

The code comment in `db_bootstrapper/mod.rs` suggests this is a known issue: [6](#0-5) 

The TODO indicates awareness that genesis timestamp handling is incorrect.

## Recommendation
Fix `emit_genesis_reconfiguration_event()` to initialize `last_reconfiguration_time` to match the genesis timestamp:

```move
fun emit_genesis_reconfiguration_event() acquires Configuration {
    let config_ref = borrow_global_mut<Configuration>(@aptos_framework);
    assert!(config_ref.epoch == 0 && config_ref.last_reconfiguration_time == 0, error::invalid_state(ECONFIGURATION));
    config_ref.epoch = 1;
    // FIX: Initialize last_reconfiguration_time to prevent immediate reconfiguration
    config_ref.last_reconfiguration_time = timestamp::now_microseconds();

    if (std::features::module_event_migration_enabled()) {
        event::emit(
            NewEpoch {
                epoch: config_ref.epoch,
            },
        );
    };
    event::emit_event<NewEpochEvent>(
        &mut config_ref.events,
        NewEpochEvent {
            epoch: config_ref.epoch,
        },
    );
}
```

Alternatively, add a guard in `block_prologue()` to skip the reconfiguration check if this is the first block after genesis (epoch == 1 and no previous reconfiguration has occurred).

## Proof of Concept
```move
#[test(aptos_framework = @aptos_framework, validator = @0x123)]
public entry fun test_first_block_triggers_reconfiguration(
    aptos_framework: signer,
    validator: signer,
) {
    // Setup genesis state
    timestamp::set_time_has_started_for_testing(&aptos_framework);
    reconfiguration::initialize_for_test(&aptos_framework);
    block::initialize_for_test(&aptos_framework, 7200000000); // 2 hour epoch interval
    
    // Simulate genesis reconfiguration
    // This sets epoch = 1, last_reconfiguration_time = 0
    
    // Verify initial state
    assert!(reconfiguration::current_epoch() == 1, 0);
    assert!(reconfiguration::last_reconfiguration_time() == 0, 1);
    
    // First block after genesis with timestamp 7200000001 microseconds (just over 2 hours)
    // This simulates a realistic Unix timestamp or any timestamp >= epoch_interval
    block::block_prologue(
        aptos_framework,
        @0x1,
        1, // epoch
        1, // round  
        @0x123, // proposer
        vector::empty(),
        vector::empty(),
        7200000001, // timestamp >= epoch_interval
    );
    
    // BUG: Epoch incorrectly advanced to 2 in the first block
    assert!(reconfiguration::current_epoch() == 2, 2);
    // Expected: Epoch should still be 1
}
```

This test demonstrates that when the first block has timestamp >= `epoch_interval`, it incorrectly triggers reconfiguration from epoch 1 to epoch 2, violating the invariant that epochs should last for the configured time interval.

## Notes
The vulnerability stems from an architectural mismatch: genesis uses timestamp 0 while regular blocks use timestamps representing absolute time. The `last_reconfiguration_time` comparison in `block_prologue()` assumes both values are in the same timebase, but this assumption breaks for the first block after genesis. The fix ensures `last_reconfiguration_time` is properly initialized to prevent this timing-based edge case.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/reconfiguration.move (L106-129)
```text
    public(friend) fun reconfigure() acquires Configuration {
        // Do not do anything if genesis has not finished.
        if (chain_status::is_genesis() || timestamp::now_microseconds() == 0 || !reconfiguration_enabled()) {
            return
        };

        let config_ref = borrow_global_mut<Configuration>(@aptos_framework);
        let current_time = timestamp::now_microseconds();

        // Do not do anything if a reconfiguration event is already emitted within this transaction.
        //
        // This is OK because:
        // - The time changes in every non-empty block
        // - A block automatically ends after a transaction that emits a reconfiguration event, which is guaranteed by
        //   VM spec that all transactions comming after a reconfiguration transaction will be returned as Retry
        //   status.
        // - Each transaction must emit at most one reconfiguration event
        //
        // Thus, this check ensures that a transaction that does multiple "reconfiguration required" actions emits only
        // one reconfiguration event.
        //
        if (current_time == config_ref.last_reconfiguration_time) {
            return
        };
```

**File:** aptos-move/framework/aptos-framework/sources/reconfiguration.move (L171-189)
```text
    fun emit_genesis_reconfiguration_event() acquires Configuration {
        let config_ref = borrow_global_mut<Configuration>(@aptos_framework);
        assert!(config_ref.epoch == 0 && config_ref.last_reconfiguration_time == 0, error::invalid_state(ECONFIGURATION));
        config_ref.epoch = 1;

        if (std::features::module_event_migration_enabled()) {
            event::emit(
                NewEpoch {
                    epoch: config_ref.epoch,
                },
            );
        };
        event::emit_event<NewEpochEvent>(
            &mut config_ref.events,
            NewEpochEvent {
                epoch: config_ref.epoch,
            },
        );
    }
```

**File:** aptos-move/framework/aptos-framework/sources/block.move (L215-217)
```text
        if (timestamp - reconfiguration::last_reconfiguration_time() >= epoch_interval) {
            reconfiguration::reconfigure();
        };
```

**File:** execution/executor-types/src/transactions_with_output.rs (L188-188)
```rust
        let is_reconfig = last_output.has_new_epoch_event();
```

**File:** execution/executor/src/workflow/do_get_execution_output.rs (L397-403)
```rust
        let next_epoch_state = {
            let _timer = OTHER_TIMERS.timer_with(&["parse_raw_output__next_epoch_state"]);
            to_commit
                .is_reconfig()
                .then(|| Self::ensure_next_epoch_state(&to_commit))
                .transpose()?
        };
```

**File:** execution/executor/src/db_bootstrapper/mod.rs (L157-159)
```rust
    let timestamp_usecs = if genesis_version == 0 {
        // TODO(aldenhu): fix existing tests before using real timestamp and check on-chain epoch.
        GENESIS_TIMESTAMP_USECS
```
