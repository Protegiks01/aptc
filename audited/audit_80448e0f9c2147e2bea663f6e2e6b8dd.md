# Audit Report

## Title
Genesis Fast Sync Bypass Enables Permanent Node Bootstrapping Denial of Service

## Summary
The special case handling for fast syncing to genesis at lines 473-483 in `bootstrapper.rs` bypasses the normal bootstrapping completion check, allowing attackers to permanently trap nodes in an infinite synchronization loop to version 0 (genesis) by controlling the initial network view and preventing sync completion.

## Finding Description

The vulnerability exists in the genesis fast sync handling logic within `initialize_active_data_stream()` function. [1](#0-0) 

This special case bypasses the normal completion check that would otherwise allow the node to finish bootstrapping: [2](#0-1) 

**Attack Flow:**

1. **Initial Compromise**: An attacker operates malicious peers that a fresh node connects to during initial bootstrapping
2. **Version 0 Advertisement**: Malicious peers only advertise genesis (version 0) through `global_data_summary`
3. **Waypoint Satisfaction**: For a node with waypoint at genesis, the waypoint check passes [3](#0-2) 
4. **Forced Genesis Sync**: When both `highest_synced_version` and `highest_known_ledger_version` are 0, instead of completing bootstrapping, the special case forces the node to attempt syncing to version 0
5. **Metadata Lock-In**: The node stores version 0 as its sync target in persistent metadata storage [4](#0-3) 
6. **Sync Prevention**: Attacker prevents sync completion by:
   - Not providing required state values
   - Providing invalid data that fails verification
   - Causing stream timeouts
7. **Persistent Stuck State**: On subsequent iterations and even after node restarts, the metadata remains locked to version 0 [5](#0-4) 
8. **Permanent Loop**: The node remains committed to completing the version 0 sync before proceeding, with no timeout or fallback mechanism

The metadata storage persists across restarts using RocksDB: [6](#0-5) 

**Critical Difference**: Without the special case at lines 473-482, when `highest_synced_version (0) >= highest_known_ledger_version (0)`, the condition at line 483 would trigger, calling `bootstrapping_complete()` immediately and avoiding the vulnerability.

## Impact Explanation

**High Severity** - This vulnerability enables targeted denial of service against node bootstrapping:

- **Network Availability Impact**: Attackers can prevent new nodes from joining the network by keeping them perpetually stuck at genesis synchronization
- **Validator Node Slowdowns**: Affects validator nodes attempting to bootstrap, preventing them from participating in consensus
- **Persistent Attack**: Once a node enters this state, it remains stuck across restarts until manual database deletion
- **Low Attack Barrier**: Attacker only needs to control initial network peers a node connects to, not requiring validator privileges or stake

This qualifies as "Validator node slowdowns" and "Significant protocol violations" under High Severity criteria, warranting up to $50,000 in the bug bounty program.

## Likelihood Explanation

**High Likelihood:**

- **Easy to Trigger**: Fresh nodes in fast sync mode are vulnerable during their first network connection
- **Realistic Attack Scenario**: Sybil attacks on network peer discovery are well-documented in P2P networks
- **Permanent Effect**: Single successful attack during node initialization causes permanent stuck state
- **No Remediation Path**: Victims cannot recover without manual intervention (deleting state sync metadata database)
- **Affects All Node Types**: Validators, fullnodes, and any node using fast sync mode are vulnerable

The attack complexity is low - an attacker simply needs to:
1. Run malicious peers advertising only version 0
2. Ensure victim node connects to these peers during initialization
3. Refuse to provide state value data or provide invalid data

## Recommendation

**Fix 1: Remove Unnecessary Special Case**

If the special case is not strictly necessary (i.e., nodes at version 0 don't need to re-sync to version 0), remove the special handling entirely and let the normal completion check at line 483 handle this case.

**Fix 2: Add Metadata Staleness Check**

If genesis re-syncing is necessary, add logic to detect and clear stale metadata targets:

```rust
// Check if we need to sync more data
if self.get_bootstrapping_mode().is_fast_sync()
    && highest_synced_version == GENESIS_TRANSACTION_VERSION
    && highest_known_ledger_version == GENESIS_TRANSACTION_VERSION
{
    // Check if we have a stale previous sync target that never completed
    if let Some(target) = self.metadata_storage.previous_snapshot_sync_target()? {
        if !self.metadata_storage.is_snapshot_sync_complete(&target)? {
            // Clear stale sync target after threshold (e.g., if metadata is older than 1 hour)
            warn!("Clearing potentially stale sync target and restarting genesis sync");
            self.metadata_storage.clear_snapshot_sync_metadata()?;
        }
    }
    
    info!(LogSchema::new(LogEntry::Bootstrapper).message(&format!(
        "Fast syncing to genesis! Highest synced and advertised version is {}.",
        highest_synced_version
    )));
} else if highest_synced_version >= highest_known_ledger_version {
    // ... existing code
}
```

**Fix 3: Add Sync Failure Limit**

Implement a counter for failed sync attempts and abandon the target after threshold:

```rust
// In StateValueSyncer struct, add:
sync_failure_count: u64,

// Before attempting sync, check failure count:
if self.state_value_syncer.sync_failure_count > MAX_SYNC_FAILURES {
    warn!("Too many sync failures, clearing metadata and restarting");
    self.metadata_storage.clear_snapshot_sync_metadata()?;
    self.state_value_syncer.reset();
}
```

## Proof of Concept

**Reproduction Steps:**

1. Set up malicious peer that advertises only version 0 in `GlobalDataSummary`
2. Configure fresh Aptos node with:
   - Fast sync mode enabled
   - Waypoint at genesis (version 0)
   - Network configured to connect to malicious peer
3. Start the node
4. Malicious peer responds to epoch ending ledger info requests with only genesis epoch
5. Malicious peer responds to transaction output requests but never provides state values, or provides invalid data
6. Observe node logs showing repeated attempts to sync to genesis
7. Restart node - observe it remains stuck trying to sync to version 0
8. Check metadata storage shows `StateSnapshotProgress` with `target_ledger_info` at version 0 and `snapshot_sync_completed: false`

**Expected Behavior**: Node should either complete sync to genesis if data is available, or timeout and try fresh sync with different peers, or complete bootstrapping immediately since it's already at the target version.

**Actual Behavior**: Node perpetually attempts to sync to version 0, never completes bootstrapping, and cannot be recovered without manual database deletion.

**Verification**: Check metadata storage at `<data_dir>/state_sync_db/` for persistent `StateSnapshotProgress` entry locked to version 0.

## Notes

This vulnerability specifically affects the state sync bootstrapping process and represents a liveness failure rather than a safety violation. The root cause is the combination of:
1. Special case logic that forces unnecessary re-syncing to genesis
2. Persistent metadata that locks nodes to a sync target
3. No timeout or staleness detection for incomplete sync targets
4. No maximum retry limit for failed syncs

The attack is particularly effective because it exploits the legitimate need for nodes to trust initial network peers during bootstrapping, a known challenge in permissionless P2P networks.

### Citations

**File:** state-sync/state-sync-driver/src/bootstrapper.rs (L473-482)
```rust
        if self.get_bootstrapping_mode().is_fast_sync()
            && highest_synced_version == GENESIS_TRANSACTION_VERSION
            && highest_known_ledger_version == GENESIS_TRANSACTION_VERSION
        {
            // The node is fast syncing and an epoch change isn't
            // advertised. We need to fast sync to genesis.
            info!(LogSchema::new(LogEntry::Bootstrapper).message(&format!(
                "Fast syncing to genesis! Highest synced and advertised version is {}.",
                highest_synced_version
            )));
```

**File:** state-sync/state-sync-driver/src/bootstrapper.rs (L483-488)
```rust
        } else if highest_synced_version >= highest_known_ledger_version {
            // Otherwise, if we've already synced to the highest known version, there's nothing to do
            info!(LogSchema::new(LogEntry::Bootstrapper)
                .message(&format!("Highest synced version {} is >= highest known ledger version {}, nothing needs to be done.",
                    highest_synced_version, highest_known_ledger_version)));
            return self.bootstrapping_complete().await;
```

**File:** state-sync/state-sync-driver/src/bootstrapper.rs (L522-543)
```rust
            if let Some(target) = self.metadata_storage.previous_snapshot_sync_target()? {
                if self.metadata_storage.is_snapshot_sync_complete(&target)? {
                    // Fast syncing to the target is complete. Verify that the
                    // highest synced version matches the target.
                    if target.ledger_info().version() == GENESIS_TRANSACTION_VERSION {
                        info!(LogSchema::new(LogEntry::Bootstrapper).message(&format!(
                            "The fast sync to genesis is complete! Target: {:?}",
                            target
                        )));
                        self.bootstrapping_complete().await
                    } else {
                        Err(Error::UnexpectedError(format!(
                            "The snapshot sync for the target was marked as complete but \
                        the highest synced version is genesis! Something has gone wrong! \
                        Target snapshot sync: {:?}",
                            target
                        )))
                    }
                } else {
                    // Continue snapshot syncing to the target
                    self.fetch_missing_state_values(target, true).await
                }
```

**File:** state-sync/state-sync-driver/src/bootstrapper.rs (L544-547)
```rust
            } else {
                // No snapshot sync has started. Start a new sync for the highest known ledger info.
                self.fetch_missing_state_values(highest_known_ledger_info, false)
                    .await
```

**File:** state-sync/state-sync-driver/src/bootstrapper.rs (L884-891)
```rust
        // If our storage has already synced beyond our waypoint, nothing needs to be checked
        let latest_ledger_info = utils::fetch_latest_synced_ledger_info(self.storage.clone())?;
        let waypoint_version = self.driver_configuration.waypoint.version();
        if latest_ledger_info.ledger_info().version() >= waypoint_version {
            self.verified_epoch_states
                .set_verified_waypoint(waypoint_version);
            return Ok(());
        }
```

**File:** state-sync/state-sync-driver/src/metadata_storage.rs (L66-95)
```rust
    pub fn new<P: AsRef<Path> + Clone>(db_root_path: P) -> Self {
        // Set the options to create the database if it's missing
        let mut options = Options::default();
        options.create_if_missing(true);
        options.create_missing_column_families(true);

        // Open the database
        let state_sync_db_path = db_root_path.as_ref().join(STATE_SYNC_DB_NAME);
        let instant = Instant::now();
        let database = DB::open(
            state_sync_db_path.clone(),
            "state_sync",
            vec![METADATA_CF_NAME],
            &options,
        )
        .unwrap_or_else(|error| {
            panic!(
                "Failed to open/create the state sync database at: {:?}. Error: {:?}",
                state_sync_db_path, error
            )
        });
        info!(
            "Opened the state sync database at: {:?}, in {:?} ms",
            state_sync_db_path,
            instant.elapsed().as_millis()
        );

        let database = Arc::new(database);
        Self { database }
    }
```
