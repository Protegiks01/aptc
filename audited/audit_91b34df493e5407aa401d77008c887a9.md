# Audit Report

## Title
Unbounded Metrics Exposure in Inspection Service Exposes Sensitive Validator Information

## Summary
The `/forge_metrics`, `/json_metrics`, and `/metrics` endpoints in the Aptos inspection service expose all Prometheus metrics without access control or filtering, including sensitive validator stake amounts, voting patterns, and peer connection details. Unlike other sensitive endpoints (`/configuration`, `/identity_information`, `/peer_information`, `/system_information`), these metrics endpoints lack configuration flags to control exposure, creating an information disclosure vulnerability.

## Finding Description
The inspection service provides multiple endpoints for exposing node metrics. While endpoints like `/configuration` and `/peer_information` have dedicated configuration flags (`expose_configuration`, `expose_peer_information`) to control access, the metrics endpoints are always exposed without any access control checks. [1](#0-0) 

The `handle_forge_metrics()` function calls `utils::get_all_metrics()` which retrieves ALL metrics from the Prometheus registry without filtering: [2](#0-1) [3](#0-2) 

These metrics include highly sensitive validator information:

**Voting Power Exposure:** [4](#0-3) 

The voting power for each validator is populated during epoch transitions: [5](#0-4) 

**Participation and Voting Patterns:** [6](#0-5) [7](#0-6) 

**Peer Connection Information:** [8](#0-7) 

The inspection service binds to `0.0.0.0:9101` by default, making it network-accessible: [9](#0-8) 

While other sensitive endpoints have access control: [10](#0-9) 

The metrics endpoints lack equivalent protection: [11](#0-10) 

## Impact Explanation
This vulnerability falls under **Low Severity** per Aptos bug bounty criteria ("Minor information leaks"). While the exposed information is sensitive, it does not directly cause:
- Loss of funds or consensus violations (Critical)
- Validator slowdowns or API crashes (High)  
- Fund manipulation or state inconsistencies (Medium)

The information disclosure could theoretically enable secondary attacks (targeted DoS on high-stake validators, economic attacks, network topology exploitation), but these are explicitly out of scope per the bug bounty exclusions for "Network-level DoS attacks" and "Economic attacks requiring market manipulation."

However, the lack of access control represents a security design flaw inconsistent with the protection applied to other sensitive endpoints in the same service.

## Likelihood Explanation
**HIGH** - The vulnerability is trivially exploitable:
1. Default configuration binds to `0.0.0.0:9101` (all network interfaces)
2. No authentication or authorization required
3. Simple HTTP GET request to `/forge_metrics` exposes all metrics
4. While production deployments may use firewall rules or `127.0.0.1` binding, validators running with default configuration are vulnerable

## Recommendation
Add an `expose_metrics` configuration flag to `InspectionServiceConfig` and implement access control checks in the metrics handlers, similar to other sensitive endpoints:

```rust
// In config/src/config/inspection_service_config.rs
pub struct InspectionServiceConfig {
    pub address: String,
    pub port: u16,
    pub expose_configuration: bool,
    pub expose_identity_information: bool,
    pub expose_peer_information: bool,
    pub expose_system_information: bool,
    pub expose_metrics: bool,  // NEW: Control metrics exposure
}

impl Default for InspectionServiceConfig {
    fn default() -> InspectionServiceConfig {
        InspectionServiceConfig {
            // ...
            expose_metrics: false,  // Default to disabled for security
        }
    }
}

// In crates/aptos-inspection-service/src/server/metrics.rs
pub fn handle_forge_metrics(node_config: &NodeConfig) -> (StatusCode, Body, String) {
    if !node_config.inspection_service.expose_metrics {
        return (
            StatusCode::FORBIDDEN,
            Body::from("Metrics endpoint disabled"),
            CONTENT_TYPE_TEXT.into(),
        );
    }
    
    let metrics = utils::get_all_metrics();
    // ... rest of implementation
}
```

Additionally, consider filtering sensitive metrics (voting power, peer IDs) or binding to `127.0.0.1` by default.

## Proof of Concept
```bash
# Query exposed validator metrics from a remote node
curl http://<validator-ip>:9101/forge_metrics | jq .

# Extract voting power for all validators
curl -s http://<validator-ip>:9101/forge_metrics | \
  jq 'to_entries | map(select(.key | contains("aptos_all_validators_voting_power"))) | from_entries'

# Extract peer connection graph
curl -s http://<validator-ip>:9101/forge_metrics | \
  jq 'to_entries | map(select(.key | contains("aptos_network_peer_connected"))) | from_entries'
```

**Notes:**
This is a valid information disclosure vulnerability with architectural inconsistency (no access control on metrics vs. other endpoints). However, actual exploitability for **in-scope** impacts per the bug bounty is limited, resulting in Low severity classification rather than the High severity suggested in the security question.

### Citations

**File:** crates/aptos-inspection-service/src/server/metrics.rs (L50-64)
```rust
/// Handles a new forge metrics request
pub fn handle_forge_metrics() -> (StatusCode, Body, String) {
    // Get and encode the metrics
    let metrics = utils::get_all_metrics();
    let encoded_metrics = match serde_json::to_string(&metrics) {
        Ok(encoded_metrics) => encoded_metrics,
        Err(error) => format!("Failed to get forge metrics! Error: {}", error),
    };

    (
        StatusCode::OK,
        Body::from(encoded_metrics),
        CONTENT_TYPE_JSON.into(),
    )
}
```

**File:** crates/aptos-inspection-service/src/server/utils.rs (L26-29)
```rust
pub fn get_all_metrics() -> HashMap<String, String> {
    let metric_families = get_metric_families();
    get_metrics_map(metric_families)
}
```

**File:** crates/aptos-inspection-service/src/server/utils.rs (L50-51)
```rust
fn get_metric_families() -> Vec<MetricFamily> {
    let metric_families = aptos_metrics_core::gather();
```

**File:** consensus/src/counters.rs (L520-526)
```rust
    register_int_gauge_vec!(
        "aptos_consensus_participation_status",
        "Counter for consensus participation status, 0 means no participation and 1 otherwise",
        &["peer_id"]
    )
    .unwrap()
});
```

**File:** consensus/src/counters.rs (L538-545)
```rust
pub static ALL_VALIDATORS_VOTING_POWER: Lazy<IntGaugeVec> = Lazy::new(|| {
    register_int_gauge_vec!(
        "aptos_all_validators_voting_power",
        "Voting power for all validators in current epoch",
        &["peer_id"]
    )
    .unwrap()
});
```

**File:** consensus/src/counters.rs (L557-564)
```rust
pub static CONSENSUS_CURRENT_ROUND_VOTED_POWER: Lazy<GaugeVec> = Lazy::new(|| {
    register_gauge_vec!(
        "aptos_consensus_current_round_voted_power",
        "Counter for consensus participation status, 0 means no participation and 1 otherwise",
        &["peer_id", "hash_index"]
    )
    .unwrap()
});
```

**File:** consensus/src/epoch_manager.rs (L793-797)
```rust
            .for_each(|peer_id| {
                counters::ALL_VALIDATORS_VOTING_POWER
                    .with_label_values(&[&peer_id.to_string()])
                    .set(epoch_state.verifier.get_voting_power(&peer_id).unwrap_or(0) as i64)
            });
```

**File:** network/framework/src/counters.rs (L86-93)
```rust
pub static APTOS_NETWORK_PEER_CONNECTED: Lazy<IntGaugeVec> = Lazy::new(|| {
    register_int_gauge_vec!(
        "aptos_network_peer_connected",
        "Indicates if we are connected to a particular peer",
        &["role_type", "network_id", "peer_id", "remote_peer_id"]
    )
    .unwrap()
});
```

**File:** config/src/config/inspection_service_config.rs (L26-36)
```rust
impl Default for InspectionServiceConfig {
    fn default() -> InspectionServiceConfig {
        InspectionServiceConfig {
            address: "0.0.0.0".to_string(),
            port: 9101,
            expose_configuration: false,
            expose_identity_information: true,
            expose_peer_information: true,
            expose_system_information: true,
        }
    }
```

**File:** crates/aptos-inspection-service/src/server/configuration.rs (L13-26)
```rust
pub fn handle_configuration_request(node_config: &NodeConfig) -> (StatusCode, Body, String) {
    // Only return configuration if the endpoint is enabled
    let (status_code, body) = if node_config.inspection_service.expose_configuration {
        // We format the configuration using debug formatting. This is important to
        // prevent secret/private keys from being serialized and leaked (i.e.,
        // all secret keys are marked with SilentDisplay and SilentDebug).
        let encoded_configuration = format!("{:?}", node_config);
        (StatusCode::OK, Body::from(encoded_configuration))
    } else {
        (
            StatusCode::FORBIDDEN,
            Body::from(CONFIGURATION_DISABLED_MESSAGE),
        )
    };
```

**File:** crates/aptos-inspection-service/src/server/mod.rs (L122-126)
```rust
        FORGE_METRICS_PATH => {
            // /forge_metrics
            // Exposes forge encoded metrics
            metrics::handle_forge_metrics()
        },
```
