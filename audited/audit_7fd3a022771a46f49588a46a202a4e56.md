# Audit Report

## Title
Incomplete State Checkpoint Hash Verification During State Sync Allows Consensus Divergence

## Summary
The `ensure_transaction_infos_match()` function fails to fully verify state checkpoint hashes during state sync when the local node's execution produces different checkpoint positions than the remote peer. This allows unverified `state_checkpoint_hash` values to be accepted, potentially causing consensus divergence if execution is non-deterministic.

## Finding Description

The vulnerability exists in the state sync verification flow where `TransactionInfo` objects are validated. The critical flaw is in how state checkpoint hashes are verified: [1](#0-0) 

During state sync, the node extracts `state_checkpoint_hash` values from the remote peer's `TransactionInfo` objects and passes them as `known_state_checkpoints` to the state checkpoint computation. [2](#0-1) 

The verification logic only checks that the checkpoint hash at the LOCAL node's `last_checkpoint_index` matches the locally computed value. However, if the remote peer has checkpoint hashes at OTHER positions where the local node computed `None`, those hashes are accepted WITHOUT verification.

Checkpoint positions are determined by: [3](#0-2) 

The key vulnerability: `has_new_epoch_event()` depends on execution output, which could be non-deterministic. If different validators produce different events due to non-deterministic execution:

1. Validator A produces a new epoch event at transaction T → computes `state_checkpoint_hash = Some(hashA)`
2. Validator B doesn't produce the event → computes `state_checkpoint_hash = None`
3. During state sync, Node C receives Validator A's transaction infos
4. Node C executes locally and (like Validator B) doesn't produce the epoch event
5. Node C's `last_checkpoint_index` excludes transaction T
6. The verification at lines 64-70 of `do_state_checkpoint.rs` only checks Node C's last checkpoint, not transaction T
7. Node C accepts `hashA` for transaction T without verification
8. Node C's `TransactionInfo` for T now contains unverified `state_checkpoint_hash`

The subsequent comparison passes because Node C uses the unverified remote values: [4](#0-3) [5](#0-4) 

## Impact Explanation

**Severity: Critical** (Consensus/Safety violation)

This vulnerability breaks the fundamental "Deterministic Execution" invariant. If validators execute non-deterministically and produce different `state_checkpoint_hash` values, state sync verification will NOT catch the discrepancy. This enables:

1. **Consensus Divergence**: Validators computing different checkpoint positions would produce different transaction accumulator roots, preventing consensus
2. **State Inconsistency**: Nodes syncing from different peers could accept different state checkpoint hashes, leading to permanently divergent views of ledger state
3. **Network Partition**: If significant portions of the network accept different checkpoint hashes, the network could split into irreconcilable factions requiring a hard fork

The vulnerability allows incorrect state to propagate through state sync, undermining the entire consensus safety mechanism.

## Likelihood Explanation

**Likelihood: Medium to High**

While Aptos execution is designed to be deterministic, non-determinism can occur due to:

1. **VM Implementation Bugs**: Subtle bugs in Move VM or native functions could cause different event generation
2. **Timing Dependencies**: Race conditions or timing-sensitive code paths
3. **External Dependencies**: System calls or environmental factors affecting execution
4. **Feature Flag Mismatches**: Different nodes having different feature configurations

The bug is latent and will only manifest when execution actually produces different results, but when it does, the verification bypass ensures the discrepancy goes undetected.

## Recommendation

Add comprehensive verification of ALL checkpoint hashes provided by the remote peer, not just the last one:

```rust
fn get_state_checkpoint_hashes(
    execution_output: &ExecutionOutput,
    known_state_checkpoints: Option<Vec<Option<HashValue>>>,
    state_summary: &LedgerStateSummary,
) -> Result<Vec<Option<HashValue>>> {
    let num_txns = execution_output.to_commit.len();
    let all_checkpoint_indices = execution_output
        .to_commit
        .state_update_refs()
        .all_checkpoint_versions(); // Get ALL checkpoint positions, not just last

    if let Some(known) = known_state_checkpoints {
        ensure!(
            known.len() == num_txns,
            "Bad number of known hashes. {} vs {}",
            known.len(),
            num_txns
        );
        
        // Verify ALL locally computed checkpoints match remote peer's values
        for (local_idx, local_checkpoint_version) in all_checkpoint_indices.iter().enumerate() {
            let remote_hash = known[*local_checkpoint_version as usize];
            let local_hash = state_summary.checkpoint_at_version(*local_checkpoint_version).root_hash();
            ensure!(
                remote_hash == Some(local_hash),
                "Checkpoint hash mismatch at version {}: {:?} vs {:?}",
                local_checkpoint_version,
                remote_hash,
                Some(local_hash),
            );
        }
        
        // Additionally verify that remote peer has NO checkpoints where local doesn't
        for (idx, remote_hash) in known.iter().enumerate() {
            if remote_hash.is_some() {
                let version = execution_output.first_version() + idx as u64;
                ensure!(
                    all_checkpoint_indices.contains(&version),
                    "Remote peer has checkpoint at version {} but local execution doesn't",
                    version
                );
            }
        }
        
        Ok(known)
    } else {
        // Original logic for computing checkpoints locally...
    }
}
```

## Proof of Concept

```rust
// Reproduction scenario demonstrating the vulnerability
// This would be added to execution/executor/src/workflow/do_state_checkpoint.rs tests

#[test]
fn test_unverified_checkpoint_accepted() {
    // Setup: Create transactions where one has a "phantom" checkpoint
    let mut transactions = create_test_transactions(3);
    
    // Simulate remote peer computed checkpoint at index 1 (e.g., due to epoch event)
    let remote_checkpoint_hash = HashValue::random();
    let known_checkpoints = vec![
        None,
        Some(remote_checkpoint_hash), // Remote has checkpoint here
        None,
    ];
    
    // Local execution: No checkpoint at index 1 (no epoch event generated)
    // This happens due to non-deterministic execution
    let local_execution_output = execute_locally(transactions);
    // local_execution_output.last_checkpoint_index() returns None or excludes index 1
    
    // BUG: The verification SHOULD fail here because local execution 
    // doesn't have a checkpoint at index 1, but remote peer does.
    // However, current code accepts it without verification!
    let result = DoStateCheckpoint::run(
        &local_execution_output,
        &parent_state_summary,
        &persisted_state_summary,
        Some(known_checkpoints),
    );
    
    // Current behavior: Succeeds (BUG!)
    assert!(result.is_ok());
    
    // The unverified checkpoint hash is now in the state checkpoint output
    let checkpoint_output = result.unwrap();
    assert_eq!(checkpoint_output.state_checkpoint_hashes[1], Some(remote_checkpoint_hash));
    
    // This will propagate to TransactionInfo and cause consensus divergence
}
```

**Notes**

The vulnerability specifically affects the state sync path where `known_state_checkpoints` is provided. During normal consensus execution, checkpoints are computed locally without this parameter, so the issue doesn't directly affect consensus voting. However, it critically undermines state sync verification, which is supposed to ensure nodes catching up reach the same state as the network. If a node syncs from a peer that executed non-deterministically, it will accept incorrect checkpoint hashes and permanently diverge from correctly executing nodes.

### Citations

**File:** execution/executor/src/chunk_executor/mod.rs (L346-357)
```rust
        let state_checkpoint_output = DoStateCheckpoint::run(
            &output.execution_output,
            &parent_state_summary,
            &ProvableStateSummary::new_persisted(self.db.reader.as_ref())?,
            Some(
                chunk_verifier
                    .transaction_infos()
                    .iter()
                    .map(|t| t.state_checkpoint_hash())
                    .collect_vec(),
            ),
        )?;
```

**File:** execution/executor/src/workflow/do_state_checkpoint.rs (L44-88)
```rust
    fn get_state_checkpoint_hashes(
        execution_output: &ExecutionOutput,
        known_state_checkpoints: Option<Vec<Option<HashValue>>>,
        state_summary: &LedgerStateSummary,
    ) -> Result<Vec<Option<HashValue>>> {
        let _timer = OTHER_TIMERS.timer_with(&["get_state_checkpoint_hashes"]);

        let num_txns = execution_output.to_commit.len();
        let last_checkpoint_index = execution_output
            .to_commit
            .state_update_refs()
            .last_inner_checkpoint_index();

        if let Some(known) = known_state_checkpoints {
            ensure!(
                known.len() == num_txns,
                "Bad number of known hashes. {} vs {}",
                known.len(),
                num_txns
            );
            if let Some(idx) = last_checkpoint_index {
                ensure!(
                    known[idx] == Some(state_summary.last_checkpoint().root_hash()),
                    "Root hash mismatch with known hashes passed in. {:?} vs {:?}",
                    known[idx],
                    Some(&state_summary.last_checkpoint().root_hash()),
                );
            }

            Ok(known)
        } else {
            if !execution_output.is_block {
                // We should enter this branch only in test.
                execution_output.to_commit.ensure_at_most_one_checkpoint()?;
            }

            let mut out = vec![None; num_txns];

            if let Some(index) = last_checkpoint_index {
                out[index] = Some(state_summary.last_checkpoint().root_hash());
            }

            Ok(out)
        }
    }
```

**File:** execution/executor-types/src/transactions_with_output.rs (L178-204)
```rust
    fn get_all_checkpoint_indices(
        transactions_with_output: &TransactionsWithOutput,
        must_be_block: bool,
    ) -> (Vec<usize>, bool) {
        let _timer = TIMER.timer_with(&["get_all_checkpoint_indices"]);

        let (last_txn, last_output) = match transactions_with_output.last() {
            Some((txn, output, _)) => (txn, output),
            None => return (Vec::new(), false),
        };
        let is_reconfig = last_output.has_new_epoch_event();

        if must_be_block {
            assert!(last_txn.is_non_reconfig_block_ending() || is_reconfig);
            return (vec![transactions_with_output.len() - 1], is_reconfig);
        }

        (
            transactions_with_output
                .iter()
                .positions(|(txn, output, _)| {
                    txn.is_non_reconfig_block_ending() || output.has_new_epoch_event()
                })
                .collect(),
            is_reconfig,
        )
    }
```

**File:** execution/executor-types/src/ledger_update_output.rs (L90-112)
```rust
    pub fn ensure_transaction_infos_match(
        &self,
        transaction_infos: &[TransactionInfo],
    ) -> Result<()> {
        ensure!(
            self.transaction_infos.len() == transaction_infos.len(),
            "Lengths don't match. {} vs {}",
            self.transaction_infos.len(),
            transaction_infos.len(),
        );

        let mut version = self.first_version();
        for (txn_info, expected_txn_info) in
            zip_eq(self.transaction_infos.iter(), transaction_infos.iter())
        {
            ensure!(
                txn_info == expected_txn_info,
                "Transaction infos don't match. version:{version}, txn_info:{txn_info}, expected_txn_info:{expected_txn_info}",
            );
            version += 1;
        }
        Ok(())
    }
```

**File:** execution/executor/src/workflow/do_ledger_update.rs (L47-93)
```rust
    fn assemble_transaction_infos(
        to_commit: &TransactionsWithOutput,
        state_checkpoint_hashes: Vec<Option<HashValue>>,
    ) -> (Vec<TransactionInfo>, Vec<HashValue>) {
        let _timer = OTHER_TIMERS.timer_with(&["assemble_transaction_infos"]);

        (0..to_commit.len())
            .into_par_iter()
            .with_min_len(optimal_min_len(to_commit.len(), 64))
            .map(|i| {
                let txn = &to_commit.transactions[i];
                let txn_output = &to_commit.transaction_outputs[i];
                let persisted_auxiliary_info = &to_commit.persisted_auxiliary_infos[i];
                // Use the auxiliary info hash directly from the persisted info
                let auxiliary_info_hash = match persisted_auxiliary_info {
                    PersistedAuxiliaryInfo::None => None,
                    PersistedAuxiliaryInfo::V1 { .. } => {
                        Some(CryptoHash::hash(persisted_auxiliary_info))
                    },
                    PersistedAuxiliaryInfo::TimestampNotYetAssignedV1 { .. } => None,
                };
                let state_checkpoint_hash = state_checkpoint_hashes[i];
                let event_hashes = txn_output
                    .events()
                    .iter()
                    .map(CryptoHash::hash)
                    .collect::<Vec<_>>();
                let event_root_hash =
                    InMemoryEventAccumulator::from_leaves(&event_hashes).root_hash();
                let write_set_hash = CryptoHash::hash(txn_output.write_set());
                let txn_info = TransactionInfo::new(
                    txn.hash(),
                    write_set_hash,
                    event_root_hash,
                    state_checkpoint_hash,
                    txn_output.gas_used(),
                    txn_output
                        .status()
                        .as_kept_status()
                        .expect("Already sorted."),
                    auxiliary_info_hash,
                );
                let txn_info_hash = txn_info.hash();
                (txn_info, txn_info_hash)
            })
            .unzip()
    }
```
