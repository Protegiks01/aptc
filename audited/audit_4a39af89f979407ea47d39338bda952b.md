# Audit Report

## Title
EventFilter Default Implementation Creates Invalid State Without Validation

## Summary
The `EventFilter` struct derives `Default`, which creates instances in an invalid state that violates the documented invariant in `validate_state()`. While the `OnceCell` field is properly initialized, both required filter fields are set to `None`, causing the filter to match all events when it should be invalid. This can lead to incorrect transaction stripping behavior if misconfigured.

## Finding Description

The `EventFilter` struct automatically derives `Default` [1](#0-0) , creating instances where both `data_substring_filter` and `struct_type` are `None`.

The `validate_state()` method explicitly requires at least one of these fields to be set [2](#0-1) , but default instances violate this invariant.

The critical issue is in the `matches()` implementation: when both fields are `None`, the method returns `true` at the end [3](#0-2) , causing the filter to match ALL events instead of being rejected as invalid.

This can be exploited through configuration deserialization. The `IndexerGrpcDataServiceConfig` uses this filter for `txns_to_strip_filter` [4](#0-3) , but the config validation does not validate the filter [5](#0-4) .

When used in `strip_transactions()`, any matching transaction has its payload, signature, events, and state changes removed [6](#0-5) . An invalid filter matching all transactions would strip ALL transaction data.

## Impact Explanation

This qualifies as **Low Severity** per the Aptos bug bounty criteria. While it doesn't affect blockchain consensus or validator operations, it represents a non-critical implementation bug in auxiliary indexer infrastructure. The impact is limited to:

- Potential DoS of indexer data service if misconfigured to strip all transactions
- Incorrect event filtering behavior in query infrastructure
- No impact on blockchain safety, consensus, funds, or validator operations

The indexer is off-chain query infrastructure, not core protocol security.

## Likelihood Explanation

**Likelihood: Low**

Exploitation requires:
1. Operator providing malformed YAML/JSON config with empty EventFilter
2. No validation catching the error during service startup
3. Service continuing to run with invalid configuration

There is no evidence of `EventFilter::default()` being used directly in the codebase. The default implementation in config uses a valid empty OR filter [7](#0-6) , not a default EventFilter.

## Recommendation

1. **Remove Default derive** or implement custom Default that returns a valid state
2. **Add validation** to config's validate() method:

```rust
fn validate(&self) -> Result<()> {
    // Existing validation...
    self.txns_to_strip_filter.is_valid()
        .map_err(|e| anyhow!("Invalid txns_to_strip_filter: {}", e))?;
    Ok(())
}
```

3. **Add validation** in `new_from_proto` to validate filters after conversion:

```rust
pub fn new_from_proto(...) -> Result<Self> {
    // Existing size check...
    let filter = match proto_filter.filter.ok_or(...)? {
        // Existing conversion...
    };
    filter.is_valid()?; // Add validation
    Ok(filter)
}
```

## Proof of Concept

```rust
// This compiles and creates an invalid EventFilter
use aptos_transaction_filter::filters::EventFilter;

let invalid_filter = EventFilter::default();
// Both fields are None, violating the invariant

// validate_state() would fail:
// assert!(invalid_filter.is_valid().is_err());

// But if used without validation, matches() returns true for all events:
// This would cause all transactions to be stripped in the data service
```

**Note**: While the `OnceCell` field is properly initialized to `OnceCell::new()` as shown in the `From` implementation [8](#0-7) , the semantic validity of the filter state is compromised.

### Citations

**File:** ecosystem/indexer-grpc/transaction-filter/src/filters/event.rs (L27-27)
```rust
#[derive(Clone, Default, Debug, Derivative, Serialize, Deserialize)]
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/filters/event.rs (L44-51)
```rust
impl From<aptos_protos::indexer::v1::EventFilter> for EventFilter {
    fn from(proto_filter: aptos_protos::indexer::v1::EventFilter) -> Self {
        Self {
            data_substring_filter: proto_filter.data_substring_filter,
            struct_type: proto_filter.struct_type.map(|f| f.into()),
            data_substring_finder: OnceCell::new(),
        }
    }
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/filters/event.rs (L66-68)
```rust
        if self.data_substring_filter.is_none() && self.struct_type.is_none() {
            return Err(Error::msg("At least one of data or struct_type must be set").into());
        };
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/filters/event.rs (L76-99)
```rust
    fn matches(&self, item: &Event) -> bool {
        if let Some(struct_type_filter) = &self.struct_type {
            if let Some(Content::Struct(struct_tag)) =
                &item.r#type.as_ref().and_then(|t| t.content.as_ref())
            {
                if !struct_type_filter.matches(struct_tag) {
                    return false;
                }
            } else {
                return false;
            }
        }

        if let Some(data_substring_filter) = self.data_substring_filter.as_ref() {
            let finder = self
                .data_substring_finder
                .get_or_init(|| Finder::new(data_substring_filter).into_owned());
            if finder.find(item.data.as_bytes()).is_none() {
                return false;
            }
        }

        true
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service/src/config.rs (L83-84)
```rust
    #[serde(default = "IndexerGrpcDataServiceConfig::default_txns_to_strip_filter")]
    pub txns_to_strip_filter: BooleanTransactionFilter,
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service/src/config.rs (L122-125)
```rust
    pub fn default_txns_to_strip_filter() -> BooleanTransactionFilter {
        // This filter matches no txns.
        BooleanTransactionFilter::new_or(vec![])
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service/src/config.rs (L130-138)
```rust
    fn validate(&self) -> Result<()> {
        if self.data_service_grpc_non_tls_config.is_none()
            && self.data_service_grpc_tls_config.is_none()
        {
            bail!("At least one of data_service_grpc_non_tls_config and data_service_grpc_tls_config must be set");
        }
        self.in_memory_cache_config.validate()?;
        Ok(())
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service/src/service.rs (L924-954)
```rust
fn strip_transactions(
    transactions: Vec<Transaction>,
    txns_to_strip_filter: &BooleanTransactionFilter,
) -> (Vec<Transaction>, usize) {
    let mut stripped_count = 0;

    let stripped_transactions: Vec<Transaction> = transactions
        .into_iter()
        .map(|mut txn| {
            // Note: `is_allowed` means the txn matches the filter, in which case
            // we strip it.
            if txns_to_strip_filter.matches(&txn) {
                stripped_count += 1;
                if let Some(info) = txn.info.as_mut() {
                    info.changes = vec![];
                }
                if let Some(TxnData::User(user_transaction)) = txn.txn_data.as_mut() {
                    user_transaction.events = vec![];
                    if let Some(utr) = user_transaction.request.as_mut() {
                        // Wipe the payload and signature.
                        utr.payload = None;
                        utr.signature = None;
                    }
                }
            }
            txn
        })
        .collect();

    (stripped_transactions, stripped_count)
}
```
