# Audit Report

## Title
Multisig Transaction Success Semantics in Indexer Filter - Outer Transaction Success Masks Inner Payload Failures

## Summary
The transaction filter in the indexer-grpc system correctly filters based on the transaction's execution status (`success` field), but for multisig transactions, this field represents whether the outer transaction wrapper executed successfully, not whether the inner payload operation succeeded. When a multisig transaction's inner payload fails (e.g., insufficient funds for a transfer), the outer transaction still succeeds (`success=true`), with the inner failure recorded only in emitted events. This creates a semantic gap where filtering for `success: Some(true)` includes multisig transactions whose intended operations failed.

## Finding Description

The indexer transaction filter checks the `success` field derived from `ExecutionStatus::is_success()`: [1](#0-0) 

The `success` field is populated from the transaction's execution status: [2](#0-1) 

For standard transactions, `ExecutionStatus::is_success()` correctly identifies successful execution: [3](#0-2) 

However, multisig transactions have a special two-layer execution model. The VM executes the multisig payload in Step 2, and even if it fails, the outer transaction proceeds to cleanup: [4](#0-3) 

Critically, regardless of whether the inner payload succeeded or failed, the outer transaction calls `success_transaction_cleanup`: [5](#0-4) 

This function **always** returns `ExecutionStatus::Success`: [6](#0-5) 

This behavior is documented in test comments: [7](#0-6) 

Inner payload failures are recorded via `TransactionExecutionFailed` events, not in the transaction's `success` field.

## Impact Explanation

After strict validation against the Aptos bug bounty criteria, **this does NOT meet the threshold for a security vulnerability**:

1. **No Consensus Impact**: Execution is deterministic and correct across all validators
2. **No Funds Loss**: No assets are stolen, minted, or permanently frozen
3. **No State Corruption**: On-chain state is consistent and correctly reflects what happened
4. **Information is Available**: Applications can check emitted events to determine inner payload status
5. **Working as Designed**: Test comments explicitly document this as expected behavior

This is a **semantic design decision** about what "success" means for multisig transactions (outer wrapper vs. inner payload), not a security vulnerability. While it could cause confusion for applications using the indexer filter, it does not meet Medium severity criteria of "State inconsistencies requiring intervention" because the state is consistent and complete information is available.

## Likelihood Explanation

This behavior occurs frequently in normal operation whenever:
- A multisig transaction attempts an operation that fails (e.g., insufficient balance)
- The multisig transaction wrapper itself executes successfully
- The failure is properly recorded in events

This is standard multisig functionality, not an exploitable condition.

## Recommendation

**No fix required** - this is working as designed. However, for improved clarity:

1. **Documentation Enhancement**: Add clear documentation to the indexer filter explaining that `success=true` for multisig transactions means the wrapper executed successfully, and inner payload status must be checked via events.

2. **Optional Filter Enhancement**: Consider adding an additional filter field like `inner_payload_success` specifically for multisig transactions that checks for the presence of `TransactionExecutionFailed` events.

3. **API Clarity**: Document in API responses that for multisig transactions, the `success` field represents outer transaction success, with inner payload status in events.

## Proof of Concept

The existing test demonstrates this behavior: [8](#0-7) 

This test shows a multisig transaction with a failing payload (transferring 2000 APT when only 1000 is available) that completes successfully at the transaction level, with the balance unchanged, confirming the inner operation failed but the outer transaction succeeded.

---

**Notes:**

Upon strict validation, while this behavior exists and could be confusing for users of the indexer filter, it does **not** constitute a security vulnerability according to Aptos bug bounty criteria. It is documented, intentional behavior where:

- The `success` field correctly reflects outer transaction execution status
- Inner payload failure information is available via events  
- No invariants are broken
- No security impact exists (no funds loss, consensus issues, or state corruption)

This is a semantic interpretation issue rather than a security vulnerability, and the system is functioning as designed with complete information available to applications that need it.

### Citations

**File:** ecosystem/indexer-grpc/transaction-filter/src/filters/transaction_root.rs (L59-65)
```rust
    fn matches(&self, item: &Transaction) -> bool {
        if !self
            .success
            .matches_opt(&item.info.as_ref().map(|i| i.success))
        {
            return false;
        }
```

**File:** api/types/src/convert.rs (L259-259)
```rust
            success: info.status().is_success(),
```

**File:** types/src/transaction/mod.rs (L1546-1548)
```rust
    pub fn is_success(&self) -> bool {
        matches!(self, ExecutionStatus::Success)
    }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L869-876)
```rust
        let output = epilogue_session.finish(
            fee_statement,
            ExecutionStatus::Success,
            change_set_configs,
            module_storage,
        )?;

        Ok((VMStatus::Executed, output))
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1283-1286)
```rust
        // Step 2: Execute the target payload. Transaction failure here is tolerated. In case of any
        // failures, we'll discard the session and start a new one. This ensures that any data
        // changes are not persisted.
        // The multisig transaction would still be considered executed even if execution fails.
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1351-1360)
```rust
        self.success_transaction_cleanup(
            epilogue_session,
            module_storage,
            serialized_signers,
            gas_meter,
            txn_data,
            log_context,
            change_set_configs,
            traversal_context,
        )
```

**File:** api/src/tests/multisig_transactions_test.rs (L420-458)
```rust
async fn test_multisig_transaction_with_payload_hash_and_failing_execution(
    use_txn_payload_v2_format: bool,
    use_orderless_transactions: bool,
) {
    let mut context = new_test_context_with_orderless_flags(
        current_function_name!(),
        use_txn_payload_v2_format,
        use_orderless_transactions,
    );
    let owner_account = &mut context.create_account().await;
    let multisig_account = context
        .create_multisig_account(owner_account, vec![], 1, 1000)
        .await;
    assert_eq!(1000, context.get_apt_balance(multisig_account).await);
    let multisig_payload = construct_multisig_txn_transfer_payload(owner_account.address(), 2000);
    context
        .create_multisig_transaction_with_payload_hash(
            owner_account,
            multisig_account,
            multisig_payload.clone(),
        )
        .await;

    // Target transaction execution should fail because the multisig account only has 1000 APT but
    // is requested to send 2000.
    // The transaction should still succeed with the failure tracked on chain.
    context
        .execute_multisig_transaction_with_payload(
            owner_account,
            multisig_account,
            "0x1::aptos_account::transfer",
            &[],
            &[&owner_account.address().to_hex_literal(), "2000"],
            202,
        )
        .await;
    // Balance didn't change since the target transaction failed.
    assert_eq!(1000, context.get_apt_balance(multisig_account).await);
}
```
