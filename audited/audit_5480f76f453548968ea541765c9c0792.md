# Audit Report

## Title
Sigma Protocol Soundness Violation: Missing Witness-Statement Structure Validation Allows Partial Proof Bypass

## Summary
The sigma protocol implementation in `aptos-dkg` fails to validate that the witness structure matches the statement structure during verification. An attacker can provide a witness with fewer elements than the statement, causing the verifier to only check a subset of the proof equation, thereby bypassing the proof-of-knowledge requirement for the remaining elements.

## Finding Description

The vulnerability exists in the sigma protocol verification flow within the DKG (Distributed Key Generation) module. The protocol is designed to prove knowledge of a witness `w` such that `Ψ(w) = P` for a homomorphism `Ψ` and public statement `P`.

The critical flaw occurs in the `merge_msm_terms` function where MSM (Multi-Scalar Multiplication) terms are combined for verification. [1](#0-0) 

The verification process computes `number_of_beta_powers` from the statement size, but obtains `msm_terms` from the witness without validating their lengths match. [2](#0-1) 

In `merge_msm_terms`, the code uses `zip` to iterate over MSM terms and beta powers. [3](#0-2)  The `zip` operation silently truncates to the shorter iterator's length, meaning if `msm_terms.len() < powers_of_beta.len()`, only `msm_terms.len()` iterations occur, leaving `powers_of_beta.len() - msm_terms.len()` statement elements unchecked.

In the chunked ElGamal implementation used by PVSS, the `msm_terms` function iterates over the witness's `plaintext_chunks` structure: [4](#0-3) 

**Attack Path:**
1. Attacker creates a PVSS transcript with encrypted shares for N players
2. Attacker crafts a sigma proof with a `WeightedWitness` containing only K < N elements in `plaintext_chunks`
3. During verification, `msm_terms` generates only K MSM terms (one per witness element)
4. The `merge_msm_terms` function iterates only K times due to the `zip` truncation
5. Only K out of N statement elements are verified
6. The remaining N-K players receive ciphertexts that are not cryptographically validated by the sigma proof

This breaks the fundamental soundness property: the verifier should only accept proofs when the prover knows a complete valid witness.

## Impact Explanation

**Severity: HIGH**

This vulnerability breaks the cryptographic soundness of the DKG protocol, violating the **Cryptographic Correctness** invariant. While existing validation checks in the transcript verification catch some structural mismatches, [5](#0-4)  these checks only validate the public statement structure, not the witness structure within the proof itself.

The sigma proof is meant to prove knowledge of plaintexts. Without this guarantee, a malicious dealer could:
- Provide invalid ciphertexts for some players that don't decrypt to consistent shares
- Break the threshold secret sharing scheme by providing garbage to selected players
- Cause DKG protocol failures when players attempt to reconstruct the shared secret

This qualifies as a **significant protocol violation** under the High Severity category (up to $50,000) in the Aptos bug bounty program, as it undermines the security guarantees of the DKG system used for validator key generation.

## Likelihood Explanation

**Likelihood: MEDIUM-HIGH**

The vulnerability is exploitable by any PVSS dealer without requiring validator privileges or insider access. The attack is straightforward: simply construct a `WeightedWitness` with fewer elements than expected. The code provides no runtime assertions in release builds (only `debug_assert_eq` statements that are compiled out). [6](#0-5) 

However, exploitation may be limited by:
- Other validation layers (pairing checks, low-degree tests) that might detect inconsistencies
- The complexity of crafting ciphertexts that pass these additional checks while being invalid

The vulnerability is present in production code and would be triggered during DKG ceremonies if a malicious dealer attempts exploitation.

## Recommendation

Add explicit validation that the witness structure matches the statement structure before verification. Implement this check in `merge_msm_terms`:

```rust
fn merge_msm_terms(
    msm_terms: Vec<Self::MsmInput>,
    prover_first_message: &Self::Codomain,
    statement: &Self::Codomain,
    powers_of_beta: &[C::ScalarField],
    c: C::ScalarField,
) -> Self::MsmInput
{
    // Add validation: witness structure must match statement structure
    let statement_len = statement.clone().into_iter().count();
    let commitment_len = prover_first_message.clone().into_iter().count();
    
    assert_eq!(
        msm_terms.len(),
        statement_len,
        "Witness structure mismatch: expected {} MSM terms but got {}",
        statement_len,
        msm_terms.len()
    );
    
    assert_eq!(
        commitment_len,
        statement_len,
        "Commitment structure mismatch: expected {} elements but got {}",
        statement_len,
        commitment_len
    );

    // Rest of the function unchanged...
}
```

Alternatively, replace the `debug_assert_eq` statements with runtime `assert_eq` or proper error handling to ensure these checks run in release builds.

## Proof of Concept

A proof of concept would involve:

1. Creating a PVSS transcript with N=4 players
2. Generating a proof with a `WeightedWitness` containing only K=2 elements in `plaintext_chunks`
3. Calling the verification function and observing that it passes when it should fail

```rust
// Pseudo-code PoC demonstrating the vulnerability
fn test_witness_structure_bypass() {
    let n_players = 4;
    let pp = PublicParameters::default();
    
    // Create encryption keys for 4 players
    let eks: Vec<_> = (0..n_players).map(|_| generate_encryption_key()).collect();
    
    // Create a statement with ciphertexts for all 4 players
    let full_statement = create_statement_for_n_players(n_players, &pp, &eks);
    
    // Create a malicious witness with only 2 players' plaintexts
    let malicious_witness = WeightedWitness {
        plaintext_chunks: vec![
            vec![vec![Scalar::rand(&mut rng)]],  // Player 0
            vec![vec![Scalar::rand(&mut rng)]],  // Player 1
            // Players 2 and 3 omitted!
        ],
        plaintext_randomness: vec![vec![Scalar::rand(&mut rng)]],
    };
    
    // Create homomorphism with all 4 encryption keys
    let hom = WeightedHomomorphism::new(&lagr_g1, xi_1, &pp, &eks);
    
    // Generate proof with truncated witness
    let proof = hom.prove(&malicious_witness, &full_statement, &context, &mut rng);
    
    // Verification incorrectly passes because it only checks 2 out of 4 players!
    assert!(hom.verify(&full_statement, &proof, &context).is_ok());
    // ^ This should fail but doesn't due to the vulnerability
}
```

The test would demonstrate that the verification passes even though the proof doesn't cover all statement elements, violating the soundness property of the sigma protocol.

## Notes

The vulnerability is in the core sigma protocol framework used across multiple homomorphism implementations in the DKG module. While the chunked ElGamal case is illustrated here, any homomorphism implementation using this verification framework is potentially affected. The fix should be applied at the framework level in `traits.rs` to protect all implementations.

### Citations

**File:** crates/aptos-dkg/src/sigma_protocol/traits.rs (L104-133)
```rust
    fn msm_terms_for_verify<Ct: Serialize, H>(
        &self,
        public_statement: &Self::Codomain,
        proof: &Proof<C::ScalarField, H>,
        cntxt: &Ct,
    ) -> Self::MsmInput
    where
        H: homomorphism::Trait<Domain = Self::Domain, Codomain = Self::Codomain>, // Need this because the lifetime was changed
    {
        let prover_first_message = match &proof.first_proof_item {
            FirstProofItem::Commitment(A) => A,
            FirstProofItem::Challenge(_) => {
                panic!("Missing implementation - expected commitment, not challenge")
            },
        };

        let number_of_beta_powers = public_statement.clone().into_iter().count(); // TODO: maybe pass the into_iter version in merge_msm_terms?

        let (c, powers_of_beta) = self.compute_verifier_challenges(public_statement, prover_first_message, cntxt, number_of_beta_powers);

        let msm_terms_for_prover_response = self.msm_terms(&proof.z);

        Self::merge_msm_terms(
            msm_terms_for_prover_response.into_iter().collect(),
            prover_first_message,
            public_statement,
            &powers_of_beta,
            c,
        )
    }
```

**File:** crates/aptos-dkg/src/sigma_protocol/traits.rs (L163-181)
```rust
        for (term, beta_power) in msm_terms.into_iter().zip(powers_of_beta) {
            let mut bases = term.bases().to_vec();
            let mut scalars = term.scalars().to_vec();

            // Multiply scalars by βᶦ
            for scalar in scalars.iter_mut() {
                *scalar *= beta_power;
            }

            // Add prover + statement contributions
            bases.push(affine_iter.next().unwrap()); // this is the element `A` from the prover's first message
            bases.push(affine_iter.next().unwrap()); // this is the element `P` from the statement, but we'll need `P^c`

            scalars.push(- (*beta_power));
            scalars.push(-c * beta_power);

            final_basis.extend(bases);
            final_scalars.extend(scalars);
        }
```

**File:** crates/aptos-dkg/src/pvss/chunky/chunked_elgamal.rs (L229-260)
```rust
    fn msm_terms(&self, input: &Self::Domain) -> Self::CodomainShape<Self::MsmInput> {
        // C_{i,j} = z_{i,j} * G_1 + r_j * ek[i]
        let Cs = input
            .plaintext_chunks
            .iter()
            .enumerate()
            .map(|(i, z_i)| {
                // here `i` is the player's id
                chunks_vec_msm_terms::<C>(self.pp, self.eks[i], z_i, &input.plaintext_randomness)
            })
            .collect();

        // R_j = r_j * H_1
        let Rs = input
            .plaintext_randomness
            .iter()
            .map(|inner_vec| {
                inner_vec
                    .iter()
                    .map(|&r_j| MsmInput {
                        bases: vec![self.pp.H],
                        scalars: vec![r_j.0],
                    })
                    .collect()
            })
            .collect();

        WeightedCodomainShape {
            chunks: Cs,
            randomness: Rs,
        }
    }
```

**File:** crates/aptos-dkg/src/pvss/chunky/weighted_transcript.rs (L140-153)
```rust
        if self.subtrs.Cs.len() != sc.get_total_num_players() {
            bail!(
                "Expected {} arrays of chunked ciphertexts, but got {}",
                sc.get_total_num_players(),
                self.subtrs.Cs.len()
            );
        }
        if self.subtrs.Vs.len() != sc.get_total_num_players() {
            bail!(
                "Expected {} arrays of commitment elements, but got {}",
                sc.get_total_num_players(),
                self.subtrs.Vs.len()
            );
        }
```

**File:** crates/aptos-dkg/src/pvss/chunky/weighted_transcriptv2.rs (L622-631)
```rust
        debug_assert_eq!(Cs.len(), sc.get_player_weight(player));

        if !Cs.is_empty() {
            if let Some(first_key) = self.Rs.first() {
                debug_assert_eq!(
                    first_key.len(),
                    Cs[0].len(),
                    "Number of ephemeral keys does not match the number of ciphertext chunks"
                );
            }
```
