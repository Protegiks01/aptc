# Audit Report

## Title
Database State Corruption via Unchecked Pruner Progress Regression in DBSubPruner Implementations

## Summary
The `DBSubPruner` trait implementations lack validation that `target_version >= current_progress` in their `prune()` methods. When called with reversed or equal parameters during initialization, the methods silently skip deletion operations but still update progress metadata, causing the pruner progress to regress backward. This creates a database state inconsistency where the metadata incorrectly represents what data has been pruned.

## Finding Description

The `DBSubPruner` trait defines a `prune()` method that takes `current_progress` and `target_version` parameters to delete database entries in the range `[current_progress, target_version)`. [1](#0-0) 

All seven implementations of this trait share the same vulnerability pattern - none validate the relationship between these parameters:

1. **TransactionInfoPruner** - delegates to `TransactionInfoDb::prune(begin, end, batch)` which uses `for version in begin..end` without validation [2](#0-1) 

2. **WriteSetPruner** - delegates to `WriteSetDb::prune(begin, end, batch)` with the same pattern [3](#0-2) 

3. **TransactionAccumulatorPruner** - uses `for version_to_delete in begin..end` without validation [4](#0-3) 

4. **TransactionAuxiliaryDataPruner** - same empty range pattern [5](#0-4) 

5-7. **EventStorePruner, PersistedAuxiliaryInfoPruner, TransactionPruner** - all follow the same vulnerable pattern

The critical issue occurs during sub-pruner initialization. Each sub-pruner's constructor calls: [6](#0-5) 

The `get_or_initialize_subpruner_progress()` function returns the **existing** progress value from the database if it exists, without comparing it to `metadata_progress`: [7](#0-6) 

**Attack Scenario:**

If the database reaches an inconsistent state where:
- `DbMetadataKey::LedgerPrunerProgress` = 100
- `DbMetadataKey::TransactionInfoPrunerProgress` = 150

This can occur due to:
- Database corruption or manual modification
- Crash during pruning operation with partial metadata updates  
- Backup/restore from inconsistent checkpoint
- Bugs in progress synchronization logic

During node initialization:

1. `LedgerPruner::new()` reads `metadata_progress = 100` from `LedgerMetadataPruner`
2. `TransactionInfoPruner::new(ledger_db, 100)` is called
3. `get_or_initialize_subpruner_progress()` returns `progress = 150` (existing DB value)
4. `myself.prune(150, 100)` is called **with reversed parameters**
5. `TransactionInfoDb::prune(150, 100, &mut batch)` executes `for version in 150..100` â†’ **empty range, no deletions**
6. But the metadata is still updated: `batch.put(&TransactionInfoPrunerProgress, Version(100))`
7. The pruner progress **regresses from 150 to 100**

**State Corruption Result:**
- **Metadata claims**: "Versions up to 100 have been pruned"  
- **Actual state**: "Versions up to 150 were already pruned" (from previous run)
- **Inconsistency**: The node believes it has data for versions 101-150, but that data was already deleted

This violates the **State Consistency** invariant: "State transitions must be atomic and verifiable via Merkle proofs." The pruner metadata no longer accurately reflects the actual database state.

## Impact Explanation

This vulnerability causes **database state corruption** and qualifies as **High Severity** under the Aptos bug bounty criteria for the following reasons:

1. **State Inconsistency Requiring Intervention** (Medium severity minimum): The corrupted pruner progress metadata creates an inconsistent view of what data exists in the database. Functions like `get_first_txn_version()` rely on this metadata to determine the minimum readable version [8](#0-7) 

2. **Potential Node Failures**: If state sync or other operations attempt to access versions 101-150 (believing they exist based on metadata), they will encounter missing data and fail.

3. **Significant Protocol Violation** (High severity): The lack of defensive validation in critical database operations violates basic safety principles. The pruner system is a critical component of database management that should never accept invalid inputs that could corrupt state.

4. **Silent Corruption**: The issue occurs without any error messages or warnings, making it difficult to detect and diagnose.

While this requires a pre-existing database inconsistency to trigger, such inconsistencies can occur in production systems through crashes, bugs, or operational errors. The lack of validation allows the corruption to propagate rather than being caught and reported.

## Likelihood Explanation

**Likelihood: Medium to Low, but Impact Justifies Attention**

The vulnerability requires a pre-existing database state where individual sub-pruner progress is ahead of the overall ledger pruner progress. This is not the normal case but can occur through:

1. **Crash During Pruning**: If the system crashes between updating ledger metadata and writing all sub-pruner progress values in parallel [9](#0-8) 

2. **Database Corruption**: Hardware failures, filesystem issues, or bugs in RocksDB could corrupt metadata keys

3. **Manual Database Operations**: Operators manually modifying the database for debugging or recovery

4. **Backup/Restore Issues**: Restoring from backups taken at different points in time for different database components

5. **Bugs in Metadata Management**: Future bugs that cause metadata to be updated out of order

While the normal code flow in `LedgerPruner::prune()` ensures `progress < target_version` through its while loop validation [10](#0-9) , the initialization path lacks this protection.

The lack of defensive programming (input validation) in a critical database operation makes this a security issue worth fixing, even if the trigger conditions are uncommon.

## Recommendation

Add validation in the `DBSubPruner::prune()` implementations to ensure `target_version >= current_progress` before proceeding with deletion operations. This should be added at multiple levels:

**Level 1: Add validation in the underlying database prune methods**

For example, in `TransactionInfoDb::prune()`:

```rust
pub(crate) fn prune(begin: Version, end: Version, batch: &mut SchemaBatch) -> Result<()> {
    // Add validation
    ensure!(
        end >= begin,
        "Invalid prune range: end ({}) must be >= begin ({})",
        end,
        begin
    );
    
    for version in begin..end {
        batch.delete::<TransactionInfoSchema>(&version)?;
    }
    Ok(())
}
```

**Level 2: Add validation in DBSubPruner trait implementations**

For example, in `TransactionInfoPruner::prune()`:

```rust
fn prune(&self, current_progress: Version, target_version: Version) -> Result<()> {
    // Add validation
    ensure!(
        target_version >= current_progress,
        "Invalid prune parameters for {}: target_version ({}) must be >= current_progress ({})",
        self.name(),
        target_version,
        current_progress
    );
    
    let mut batch = SchemaBatch::new();
    TransactionInfoDb::prune(current_progress, target_version, &mut batch)?;
    batch.put::<DbMetadataSchema>(
        &DbMetadataKey::TransactionInfoPrunerProgress,
        &DbMetadataValue::Version(target_version),
    )?;
    self.ledger_db.transaction_info_db().write_schemas(batch)
}
```

**Level 3: Fix initialization to use max() instead of unchecked existing value**

In `get_or_initialize_subpruner_progress()`:

```rust
pub(crate) fn get_or_initialize_subpruner_progress(
    sub_db: &DB,
    progress_key: &DbMetadataKey,
    metadata_progress: Version,
) -> Result<Version> {
    let existing_progress = sub_db
        .get::<DbMetadataSchema>(progress_key)?
        .map(|v| v.expect_version());
    
    let progress = match existing_progress {
        Some(existing) => {
            // Use max to handle inconsistent state gracefully
            let safe_progress = std::cmp::max(existing, metadata_progress);
            if existing > metadata_progress {
                warn!(
                    "Sub-pruner progress ({}) ahead of metadata progress ({}), using metadata_progress",
                    existing, metadata_progress
                );
            }
            safe_progress
        }
        None => metadata_progress,
    };
    
    // Always write the safe progress value
    sub_db.put::<DbMetadataSchema>(
        progress_key,
        &DbMetadataValue::Version(progress),
    )?;
    
    Ok(progress)
}
```

This ensures that even if the database is in an inconsistent state, the initialization will handle it gracefully by using the metadata progress as the source of truth and logging a warning for operators to investigate.

## Proof of Concept

```rust
#[cfg(test)]
mod test {
    use super::*;
    use aptos_temppath::TempPath;
    use aptos_schemadb::DB;
    
    #[test]
    #[should_panic(expected = "Invalid prune range")]
    fn test_prune_with_reversed_parameters() {
        let tmp_dir = TempPath::new();
        let db = DB::open(
            tmp_dir.path(),
            "test_db",
            &[TransactionInfoSchema::COLUMN_FAMILY_NAME],
        )
        .unwrap();
        
        // Simulate database with inconsistent state
        // Set sub-pruner progress ahead of metadata progress
        db.put::<DbMetadataSchema>(
            &DbMetadataKey::TransactionInfoPrunerProgress,
            &DbMetadataValue::Version(150),
        ).unwrap();
        
        db.put::<DbMetadataSchema>(
            &DbMetadataKey::LedgerPrunerProgress,
            &DbMetadataValue::Version(100),
        ).unwrap();
        
        // This should fail with the fix in place
        let mut batch = SchemaBatch::new();
        TransactionInfoDb::prune(150, 100, &mut batch).unwrap();
        // Without the fix, this silently corrupts state
        // With the fix, it panics with "Invalid prune range"
    }
    
    #[test]
    fn test_initialization_with_inconsistent_progress() {
        let tmp_dir = TempPath::new();
        let ledger_db = Arc::new(LedgerDb::new(tmp_dir.path()).unwrap());
        
        // Set inconsistent state
        ledger_db.metadata_db().put::<DbMetadataSchema>(
            &DbMetadataKey::LedgerPrunerProgress,
            &DbMetadataValue::Version(100),
        ).unwrap();
        
        ledger_db.transaction_info_db_raw().put::<DbMetadataSchema>(
            &DbMetadataKey::TransactionInfoPrunerProgress,
            &DbMetadataValue::Version(150),
        ).unwrap();
        
        // Without fix: This would regress progress from 150 to 100
        // With fix: This should either error or use max(150, 100) = 150
        let result = TransactionInfoPruner::new(ledger_db, 100);
        
        // Verify the fix prevents state regression
        if let Ok(pruner) = result {
            let progress = ledger_db
                .transaction_info_db_raw()
                .get::<DbMetadataSchema>(&DbMetadataKey::TransactionInfoPrunerProgress)
                .unwrap()
                .unwrap()
                .expect_version();
            
            // Progress should not have regressed
            assert!(progress >= 100, "Progress regressed!");
        }
    }
}
```

## Notes

This vulnerability demonstrates the importance of defensive programming in critical database operations. Even though the normal operation flow has safeguards, the initialization path creates a vulnerability window. The fix should be implemented at all three levels (underlying DB methods, trait implementations, and initialization logic) to provide defense in depth.

### Citations

**File:** storage/aptosdb/src/pruner/db_sub_pruner.rs (L13-13)
```rust
    fn prune(&self, current_progress: Version, target_version: Version) -> Result<()>;
```

**File:** storage/aptosdb/src/ledger_db/transaction_info_db.rs (L95-100)
```rust
    pub(crate) fn prune(begin: Version, end: Version, batch: &mut SchemaBatch) -> Result<()> {
        for version in begin..end {
            batch.delete::<TransactionInfoSchema>(&version)?;
        }
        Ok(())
    }
```

**File:** storage/aptosdb/src/ledger_db/write_set_db.rs (L158-163)
```rust
    pub(crate) fn prune(begin: Version, end: Version, db_batch: &mut SchemaBatch) -> Result<()> {
        for version in begin..end {
            db_batch.delete::<WriteSetSchema>(&version)?;
        }
        Ok(())
    }
```

**File:** storage/aptosdb/src/ledger_db/transaction_accumulator_db.rs (L149-172)
```rust
    pub(crate) fn prune(begin: Version, end: Version, db_batch: &mut SchemaBatch) -> Result<()> {
        for version_to_delete in begin..end {
            db_batch.delete::<TransactionAccumulatorRootHashSchema>(&version_to_delete)?;
            // The even version will be pruned in the iteration of version + 1.
            if version_to_delete % 2 == 0 {
                continue;
            }

            let first_ancestor_that_is_a_left_child =
                Self::find_first_ancestor_that_is_a_left_child(version_to_delete);

            // This assertion is true because we skip the leaf nodes with address which is a
            // a multiple of 2.
            assert!(!first_ancestor_that_is_a_left_child.is_leaf());

            let mut current = first_ancestor_that_is_a_left_child;
            while !current.is_leaf() {
                db_batch.delete::<TransactionAccumulatorSchema>(&current.left_child())?;
                db_batch.delete::<TransactionAccumulatorSchema>(&current.right_child())?;
                current = current.right_child();
            }
        }
        Ok(())
    }
```

**File:** storage/aptosdb/src/ledger_db/transaction_auxiliary_data_db.rs (L74-79)
```rust
    pub(crate) fn prune(begin: Version, end: Version, batch: &mut SchemaBatch) -> Result<()> {
        for version in begin..end {
            batch.delete::<TransactionAuxiliaryDataSchema>(&version)?;
        }
        Ok(())
    }
```

**File:** storage/aptosdb/src/pruner/ledger_pruner/transaction_info_pruner.rs (L40-54)
```rust
    ) -> Result<Self> {
        let progress = get_or_initialize_subpruner_progress(
            ledger_db.transaction_info_db_raw(),
            &DbMetadataKey::TransactionInfoPrunerProgress,
            metadata_progress,
        )?;

        let myself = TransactionInfoPruner { ledger_db };

        info!(
            progress = progress,
            metadata_progress = metadata_progress,
            "Catching up TransactionInfoPruner."
        );
        myself.prune(progress, metadata_progress)?;
```

**File:** storage/aptosdb/src/pruner/pruner_utils.rs (L44-60)
```rust
pub(crate) fn get_or_initialize_subpruner_progress(
    sub_db: &DB,
    progress_key: &DbMetadataKey,
    metadata_progress: Version,
) -> Result<Version> {
    Ok(
        if let Some(v) = sub_db.get::<DbMetadataSchema>(progress_key)? {
            v.expect_version()
        } else {
            sub_db.put::<DbMetadataSchema>(
                progress_key,
                &DbMetadataValue::Version(metadata_progress),
            )?;
            metadata_progress
        },
    )
}
```

**File:** storage/aptosdb/src/db/aptosdb_reader.rs (L328-333)
```rust
    /// Get the first version that txn starts existent.
    fn get_first_txn_version(&self) -> Result<Option<Version>> {
        gauged_api("get_first_txn_version", || {
            Ok(Some(self.ledger_pruner.get_min_readable_version()))
        })
    }
```

**File:** storage/aptosdb/src/pruner/ledger_pruner/mod.rs (L62-92)
```rust
    fn prune(&self, max_versions: usize) -> Result<Version> {
        let mut progress = self.progress();
        let target_version = self.target_version();

        while progress < target_version {
            let current_batch_target_version =
                min(progress + max_versions as Version, target_version);

            info!(
                progress = progress,
                target_version = current_batch_target_version,
                "Pruning ledger data."
            );
            self.ledger_metadata_pruner
                .prune(progress, current_batch_target_version)?;

            THREAD_MANAGER.get_background_pool().install(|| {
                self.sub_pruners.par_iter().try_for_each(|sub_pruner| {
                    sub_pruner
                        .prune(progress, current_batch_target_version)
                        .map_err(|err| anyhow!("{} failed to prune: {err}", sub_pruner.name()))
                })
            })?;

            progress = current_batch_target_version;
            self.record_progress(progress);
            info!(progress = progress, "Pruning ledger data is done.");
        }

        Ok(target_version)
    }
```
