# Audit Report

## Title
Insufficient Security Monitoring and Alerting for Handshake Negotiation Errors Enabling Network Reconnaissance

## Summary
Handshake negotiation errors in the Aptos network protocol are logged but lack dedicated security monitoring, specific metrics, and rate-limiting controls. This observability gap allows attackers to perform network reconnaissance by systematically triggering different error conditions without triggering security alerts, potentially aiding in planning targeted attacks.

## Finding Description

The `perform_handshake()` function validates protocol compatibility between peers and can return three distinct error types: [1](#0-0) 

When these errors occur during connection upgrades, they are handled generically as connection failures without special security treatment: [2](#0-1) 

In the inbound path, errors are similarly converted to generic I/O errors: [3](#0-2) 

These errors are eventually logged at the peer manager level with `warn!` level, but without security event classification: [4](#0-3) 

The security event enum shows that only `NoiseHandshake` errors receive special security logging treatment, while protocol handshake negotiation errors are not classified as security events: [5](#0-4) 

**Attack Scenario:**
1. Attacker connects with mismatched chain ID → triggers `InvalidChainId` error
2. Attacker connects with mismatched network ID → triggers `InvalidNetworkId` error
3. Attacker connects with incompatible protocols → triggers `NoCommonProtocols` error
4. All errors are logged at `warn!` level but mixed with normal connection failures
5. No dedicated metrics distinguish handshake negotiation failures by error type
6. No rate limiting specifically for handshake negotiation failures
7. Reconnaissance pattern goes undetected in aggregate connection failure metrics

## Impact Explanation

**Severity: Low** (as indicated in the security question)

This qualifies as LOW severity per Aptos bug bounty criteria:
- "Minor information leaks" - Reconnaissance enables information gathering about node configuration
- "Non-critical implementation bugs" - Monitoring gap doesn't directly compromise funds or consensus

While the issue doesn't directly cause fund loss, consensus violations, or availability problems, it creates an observability blind spot. Attackers can probe nodes to understand their network configuration without triggering security alerts, potentially aiding in planning more sophisticated attacks. The lack of differentiated monitoring makes it difficult for operators to detect systematic reconnaissance attempts.

## Likelihood Explanation

**Likelihood: High**

This issue affects all Aptos nodes exposed to untrusted network connections:
- Any attacker can initiate connections and trigger these errors
- No special privileges or resources required
- Reconnaissance can be performed gradually over time
- Current logging treats all connection failures equally
- Operators must manually parse log files to detect reconnaissance patterns
- No automated alerting for unusual patterns of handshake negotiation failures

## Recommendation

Implement enhanced security monitoring for handshake negotiation errors:

1. **Add Security Event Classification**:
   - Add `HandshakeNegotiationFailure` to the `SecurityEvent` enum
   - Log handshake negotiation errors as security events with structured metadata

2. **Implement Dedicated Metrics**:
   - Add counter metrics distinguishing error types: `aptos_handshake_negotiation_errors{error_type="invalid_chain_id"|"invalid_network_id"|"no_common_protocols"}`
   - Track per-peer failure rates to detect reconnaissance patterns

3. **Add Rate Limiting**:
   - Implement connection attempt tracking per remote IP/peer
   - Temporarily ban peers exceeding handshake failure thresholds
   - Add exponential backoff for repeated failures

4. **Enhanced Logging**:
   - Sample and aggregate repeated errors to reduce log volume
   - Create security dashboards for handshake negotiation failures
   - Set up alerts for unusual patterns (e.g., multiple chain ID probes from same source)

## Proof of Concept

While this is an observability issue rather than a directly exploitable vulnerability, here's a demonstration of the monitoring gap:

```rust
// Proof of Concept: Reconnaissance Script (pseudocode)
// This demonstrates how an attacker could probe a node without triggering alerts

use aptos_network::*;

async fn reconnaissance_attack(target_address: NetworkAddress) {
    let mut findings = HashMap::new();
    
    // Probe 1: Test different chain IDs
    for chain_id in 1..=10 {
        let result = attempt_connection(target_address, chain_id, NetworkId::Public, protocols);
        if matches_error_pattern(&result, "chain id") {
            findings.insert("chain_id_found", chain_id);
            break; // Found the correct chain ID
        }
    }
    
    // Probe 2: Test different network IDs
    for network_id in [NetworkId::Validator, NetworkId::Vfn, NetworkId::Public] {
        let result = attempt_connection(target_address, found_chain_id, network_id, protocols);
        if !matches_error_pattern(&result, "network id") {
            findings.insert("network_id_found", network_id);
            break;
        }
    }
    
    // All probes are logged at warn! level but not flagged as security events
    // No specific metrics are incremented for handshake negotiation failures
    // Operator sees generic "connection upgrade failed" messages
}

// Expected behavior: All these reconnaissance attempts should be:
// 1. Logged as security events (currently: only logged as warn!)
// 2. Tracked with specific metrics (currently: grouped with all connection failures)
// 3. Rate limited after threshold (currently: no handshake-specific rate limiting)
// 4. Trigger alerts for patterns (currently: no pattern detection)
```

**Notes**

This finding represents an operational security gap rather than a critical exploitable vulnerability. The handshake errors ARE logged, preventing truly "silent" reconnaissance, but the lack of specialized monitoring and alerting makes it difficult for operators to detect systematic probing attempts. The LOW severity classification is appropriate as this doesn't directly compromise funds, consensus safety, or network availability, but does reduce the effectiveness of security monitoring and incident response capabilities.

### Citations

**File:** network/framework/src/protocols/wire/handshake/v1/mod.rs (L387-398)
```rust
/// An enum to list the possible errors during the Atpos handshake negotiation
#[derive(Debug, Error, Eq, PartialEq)]
pub enum HandshakeError {
    #[error("aptos-handshake: the received message has a different chain id: {0}, expected: {1}")]
    InvalidChainId(ChainId, ChainId),
    #[error(
        "aptos-handshake: the received message has an different network id: {0}, expected: {1}"
    )]
    InvalidNetworkId(NetworkId, NetworkId),
    #[error("aptos-handshake: could not find an intersection of supported protocol with the peer")]
    NoCommonProtocols,
}
```

**File:** network/framework/src/transport/mod.rs (L307-317)
```rust
    // try to negotiate common aptosnet version and supported application protocols
    let (messaging_protocol, application_protocols) = handshake_msg
        .perform_handshake(&remote_handshake)
        .map_err(|err| {
            let err = format!(
                "handshake negotiation with peer {} failed: {}",
                remote_peer_id.short_str(),
                err
            );
            add_pp_addr(proxy_protocol_enabled, io::Error::other(err), &addr)
        })?;
```

**File:** network/framework/src/transport/mod.rs (L383-392)
```rust
    // try to negotiate common aptosnet version and supported application protocols
    let (messaging_protocol, application_protocols) = handshake_msg
        .perform_handshake(&remote_handshake)
        .map_err(|e| {
            let e = format!(
                "handshake negotiation with peer {} failed: {}",
                remote_peer_id, e
            );
            io::Error::other(e)
        })?;
```

**File:** network/framework/src/peer_manager/transport.rs (L258-276)
```rust
            Err(err) => {
                warn!(
                    NetworkSchema::new(&self.network_context)
                        .remote_peer(&peer_id)
                        .network_address(&addr),
                    error = %err,
                    "{} Outbound connection failed for peer {} at {}: {}",
                    self.network_context,
                    peer_id.short_str(),
                    addr,
                    err
                );

                counters::connection_upgrade_time(
                    &self.network_context,
                    ConnectionOrigin::Outbound,
                    FAILED_LABEL,
                )
                .observe(elapsed_time);
```

**File:** crates/aptos-logger/src/security.rs (L74-82)
```rust
    // Network
    // -------
    /// Network received an invalid message from a remote peer
    InvalidNetworkEvent,

    /// A failed noise handshake that's either a clear bug or indicates some
    /// security issue.
    NoiseHandshake,
}
```
