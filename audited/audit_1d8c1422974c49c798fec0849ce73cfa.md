# Audit Report

## Title
Multi-Step Governance Proposal Execution Hash Reuse Vulnerability

## Summary
The multi-step governance proposal system in Aptos lacks validation to prevent reuse of execution hashes, allowing malicious proposal creators to execute steps multiple times, create execution loops, or skip steps entirely, violating the intended sequential execution order.

## Finding Description

When resolving multi-step governance proposals, the system accepts a `next_execution_hash` parameter that specifies the hash of the next step to execute. However, there is **no verification** that this hash hasn't been used previously in the proposal's execution chain.

**Code Flow:**

1. The release builder generates a governance proposal script that calls `aptos_governance::resolve_multi_step_proposal()` with a `next_execution_hash` parameter [1](#0-0) 

2. The governance module passes this hash to the voting module [2](#0-1) 

3. The voting module's `resolve_proposal_v2()` function unconditionally updates the proposal's execution hash to the provided value without any uniqueness validation [3](#0-2) 

4. The only hash storage is in `ApprovedExecutionHashes`, which maps proposal_id to a single hash value that gets **replaced** (not appended to history) on each step [4](#0-3) 

**Attack Scenario:**

A malicious governance participant creates a multi-step proposal:
- Step 1: Hash H1, intended next: H2
- Step 2: Hash H2, intended next: H3  
- Step 3: Hash H3, intended next: empty (final)

The attacker can:
- Execute Step 1 (H1) → provide H2 as next (normal)
- Execute Step 2 (H2) → provide **H2 again** (reuse!)
- Execute Step 2 (H2) → provide **H2 again** (infinite loop)
- OR provide H1 to go backward
- OR skip directly to H3 bypassing Step 2

This breaks the critical invariant stated in the formal specification: "for multi-step proposals, it guarantees that the next execution hash corresponds to the hash of the next step, maintaining the integrity of the proposal execution sequence" [5](#0-4) 

## Impact Explanation

**HIGH Severity** - This constitutes a "Significant protocol violation" under the Aptos bug bounty program.

**Governance Integrity Violation:** The vulnerability breaks Critical Invariant #5 (Governance Integrity) by allowing:
- **Re-execution of critical operations**: Steps that mint tokens, grant permissions, or modify system parameters could be executed multiple times
- **Bypassing security steps**: Critical validation or cleanup steps could be skipped
- **Execution chain forking**: Multiple execution paths violating deterministic state transitions

**Concrete Harm Examples:**
- A proposal granting admin capabilities could re-grant them to multiple addresses
- A proposal transferring funds could repeat the transfer multiple times
- A proposal disabling a security feature could skip the re-enabling step

## Likelihood Explanation

**HIGH Likelihood** for the following reasons:

1. **Low Attack Complexity**: Any participant with sufficient stake to create a multi-step governance proposal can exploit this
2. **No Additional Privileges Required**: The vulnerability exists in the core proposal execution logic
3. **Undetectable Until Execution**: Hash reuse cannot be detected until the malicious step executes
4. **Realistic Attack Scenario**: Multi-step proposals are a normal governance mechanism, making this a practical attack vector

The only barrier is passing the initial proposal voting, but once approved, the execution path is fully controlled by the proposal creator.

## Recommendation

Add execution hash history tracking to prevent reuse:

**In `voting.move`**, add a new field to track executed hashes:
```move
struct Proposal<ProposalType: store> has store {
    // ... existing fields ...
    executed_hashes: vector<vector<u8>>, // NEW: Track all executed hashes
}
```

**In `resolve_proposal_v2()`**, add validation before updating the hash:
```move
// After line 537 in voting.move
if (!next_execution_hash_is_empty) {
    // Verify the next hash hasn't been used before
    let i = 0;
    let hash_count = vector::length(&proposal.executed_hashes);
    while (i < hash_count) {
        assert!(
            vector::borrow(&proposal.executed_hashes, i) != &next_execution_hash,
            error::invalid_argument(EHASH_ALREADY_EXECUTED)
        );
        i = i + 1;
    };
    
    // Record the current hash before updating
    vector::push_back(&mut proposal.executed_hashes, proposal.execution_hash);
    proposal.execution_hash = next_execution_hash;
}
```

Add new error constant:
```move
const EHASH_ALREADY_EXECUTED: u64 = 14;
```

## Proof of Concept

```move
#[test(aptos_framework = @aptos_framework, proposer = @0x123)]
#[expected_failure(abort_code = 0x1000E, location = aptos_framework::voting)]
public entry fun test_hash_reuse_prevention(
    aptos_framework: signer,
    proposer: signer,
) acquires VotingForum {
    // Setup
    account::create_account_for_test(@aptos_framework);
    timestamp::set_time_has_started_for_testing(&aptos_framework);
    
    // Create multi-step proposal
    let proposer_address = signer::address_of(&proposer);
    account::create_account_for_test(proposer_address);
    register<TestProposal>(&proposer);
    
    let execution_hash_step1 = vector::empty<u8>();
    vector::push_back(&mut execution_hash_step1, 1);
    
    let execution_hash_step2 = vector::empty<u8>();
    vector::push_back(&mut execution_hash_step2, 2);
    
    let proposal_id = create_proposal_v2<TestProposal>(
        proposer_address,
        proposer_address,
        TestProposal {},
        execution_hash_step1,
        10,
        timestamp::now_seconds() + 100000,
        option::none<u128>(),
        simple_map::create<String, vector<u8>>(),
        true, // is_multi_step
    );
    
    // Vote and resolve step 1
    let proof = TestProposal {};
    vote<TestProposal>(&proof, proposer_address, proposal_id, 10, true);
    let TestProposal {} = proof;
    
    timestamp::fast_forward_seconds(100001);
    
    // Execute step 1 with next hash = step2
    resolve_proposal_v2<TestProposal>(proposer_address, proposal_id, execution_hash_step2);
    
    // ATTACK: Try to execute step 2 with next hash = step2 AGAIN (reuse)
    // This should FAIL with the fix, but currently SUCCEEDS
    resolve_proposal_v2<TestProposal>(proposer_address, proposal_id, execution_hash_step2);
}
```

**Notes:**
- This vulnerability is exploitable only within multi-step proposals, not single-step ones
- The attack requires the proposal to pass voting first, but once approved, the execution sequence is unverified
- The `ApprovedExecutionHashes` map only stores the current hash, not the history, making it ineffective for preventing reuse
- The formal verification specification explicitly requires maintaining "integrity of the proposal execution sequence" but the implementation fails to enforce this

### Citations

**File:** aptos-move/aptos-release-builder/src/utils.rs (L69-95)
```rust
pub(crate) fn generate_governance_proposal<F>(
    writer: &CodeWriter,
    is_testnet: bool,
    next_execution_hash: Option<HashValue>,
    is_multi_step: bool,
    deps_names: &[&str],
    body: F,
) -> String
where
    F: FnOnce(&CodeWriter),
{
    assert!(
        is_multi_step || next_execution_hash.is_none(),
        "only multi-step proposals can have a next execution hash"
    );

    if is_multi_step {
        generate_governance_proposal_header(writer, deps_names, true, next_execution_hash);
    } else if is_testnet {
        generate_testnet_header(writer, deps_names);
    } else {
        generate_governance_proposal_header(writer, deps_names, false, None);
    }

    body(writer);
    finish_with_footer(writer)
}
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L622-629)
```text
        // If this is a multi-step proposal, the proposal id will already exist in the ApprovedExecutionHashes map.
        // We will update execution hash in ApprovedExecutionHashes to be the next_execution_hash.
        if (simple_map::contains_key(&approved_hashes.hashes, &proposal_id)) {
            let current_execution_hash = simple_map::borrow_mut(&mut approved_hashes.hashes, &proposal_id);
            *current_execution_hash = execution_hash;
        } else {
            simple_map::add(&mut approved_hashes.hashes, proposal_id, execution_hash);
        }
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L643-661)
```text
    /// Resolve a successful multi-step proposal. This would fail if the proposal is not successful.
    public fun resolve_multi_step_proposal(
        proposal_id: u64,
        signer_address: address,
        next_execution_hash: vector<u8>
    ): signer acquires GovernanceResponsbility, ApprovedExecutionHashes {
        voting::resolve_proposal_v2<GovernanceProposal>(@aptos_framework, proposal_id, next_execution_hash);
        // If the current step is the last step of this multi-step proposal,
        // we will remove the execution hash from the ApprovedExecutionHashes map.
        if (vector::length(&next_execution_hash) == 0) {
            remove_approved_hash(proposal_id);
        } else {
            // If the current step is not the last step of this proposal,
            // we replace the current execution hash with the next execution hash
            // in the ApprovedExecutionHashes map.
            add_approved_script_hash(proposal_id)
        };
        get_signer(signer_address)
    }
```

**File:** aptos-move/framework/aptos-framework/sources/voting.move (L562-566)
```text
        } else {
            // If the current step is not the last step,
            // update the proposal's execution hash on-chain to the execution hash of the next step.
            proposal.execution_hash = next_execution_hash;
        };
```

**File:** aptos-move/framework/aptos-framework/sources/voting.spec.move (L31-39)
```text
    /// Requirement: In the context of v2 proposal resolving, both single-step and multi-step proposals are accurately
    /// handled. It ensures that for single-step proposals, the next execution hash is empty and resolves the proposal,
    /// while for multi-step proposals, it guarantees that the next execution hash corresponds to the hash of the next
    /// step, maintaining the integrity of the proposal execution sequence.
    /// Criticality: Medium
    /// Implementation: The function resolve_proposal_v2 correctly handles both single-step and multi-step proposals.
    /// For single-step proposals, it ensures that the next_execution_hash parameter is empty and resolves the proposal.
    /// For multi-step proposals, it ensures that the next_execution_hash parameter contains the hash of the next step.
    /// Enforcement: Formally verified via [high-level-req-4](resolve_proposal_v2).
```
