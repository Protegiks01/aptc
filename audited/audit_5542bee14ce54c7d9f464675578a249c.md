# Audit Report

## Title
V2 Batch Storage Leak: Incorrect Deletion Functions Cause Unbounded Database Growth

## Summary
The quorum store batch cleanup functions contain critical bugs where V2 batches are never deleted from the database. The `gc_previous_epoch_batches_from_db_v2()` function incorrectly calls `delete_batches()` instead of `delete_batches_v2()`, and `update_certified_timestamp()` only deletes V1 batches. This causes V2 batches to accumulate indefinitely, leading to storage exhaustion and potential node failure.

## Finding Description

The quorum store maintains two separate storage schemas for batches: V1 batches stored in the "batch" column family and V2 batches in the "batch_v2" column family. However, the deletion logic contains two critical bugs:

**Bug #1 - Epoch Cleanup Bug:** [1](#0-0) 

The function `gc_previous_epoch_batches_from_db_v2` reads V2 batches from storage but calls the V1 deletion function. This means when transitioning to a new epoch, V2 batches from the previous epoch remain in the database indefinitely.

**Bug #2 - Expiration Cleanup Bug:** [2](#0-1) 

The `update_certified_timestamp` function removes expired batches from the in-memory cache (which contains both V1 and V2 batches) but only deletes V1 batches from the database. Expired V2 batches are never removed from persistent storage.

**Root Cause:**
The system uses separate column families for V1 and V2 storage: [3](#0-2) 

But cleanup functions fail to account for this separation: [4](#0-3) [5](#0-4) 

**Attack Vector:**
Once V2 batches are enabled via configuration: [6](#0-5) [7](#0-6) 

Every V2 batch created will:
1. Expire after its designated lifetime (60 seconds by default)
2. Be removed from cache but remain in database forever
3. Accumulate across epoch boundaries without cleanup
4. Consume storage resources indefinitely

## Impact Explanation

**Severity: High to Critical**

This vulnerability breaks the **Resource Limits** invariant (Invariant #9) and can lead to:

1. **Storage Exhaustion**: Database grows unbounded as V2 batches accumulate. With batches containing up to 1MB of transaction data and created continuously during normal operation, storage can fill rapidly.

2. **Performance Degradation**: As the database grows, RocksDB performance degrades due to increased compaction overhead and larger SST files, causing **validator node slowdowns** (High Severity per bug bounty).

3. **Node Crashes**: When storage is exhausted, the validator node cannot write new data and will crash, causing **loss of liveness** for that validator.

4. **Network-Wide Impact**: If this issue affects multiple validators simultaneously (all running V2-enabled configurations), it could cause **significant protocol violations** or even approach the **total loss of liveness** threshold (Critical Severity).

The impact qualifies as **High Severity** (validator node slowdowns, significant protocol violations) with potential escalation to **Critical Severity** if it causes network-wide liveness failures.

## Likelihood Explanation

**Likelihood: High (once V2 batches are enabled)**

While V2 batches are currently disabled by default, the presence of the configuration flag and V2-specific code paths indicates this feature is intended for production use. Once enabled:

- **Certainty**: 100% - Every V2 batch created will eventually expire and fail to be deleted
- **Attacker Requirements**: None - This is a passive bug triggered by normal system operation
- **Detection**: Slow - Storage growth is gradual and may not be noticed until critical levels
- **Exploitation Complexity**: Trivial - No special actions required beyond enabling the feature

The bug will manifest automatically during normal consensus operations without any attacker interaction.

## Recommendation

Fix both deletion bugs to ensure V2 batches are properly cleaned up:

**Fix for Bug #1** (line 241):
```rust
// In gc_previous_epoch_batches_from_db_v2, change:
db.delete_batches(expired_keys)  // WRONG - deletes V1
// To:
db.delete_batches_v2(expired_keys)  // CORRECT - deletes V2
```

**Fix for Bug #2** (line 536):
```rust
// In update_certified_timestamp, add V2 cleanup:
let expired_keys = self.clear_expired_payload(certified_time);
if let Err(e) = self.db.delete_batches(expired_keys.clone()) {
    debug!("Error deleting V1 batches: {:?}", e)
}
// ADD THIS:
if let Err(e) = self.db.delete_batches_v2(expired_keys) {
    debug!("Error deleting V2 batches: {:?}", e)
}
```

**Additional Validation:**
Add integration tests that verify both V1 and V2 batches are properly deleted during epoch transitions and expiration events.

## Proof of Concept

```rust
// Reproduction steps:
// 1. Enable V2 batches in config:
let config = QuorumStoreConfig {
    enable_batch_v2: true,
    ..Default::default()
};

// 2. Create and persist V2 batches through normal consensus operation
// 3. Wait for epoch transition or batch expiration
// 4. Query database for V2 batches:
let v2_batches = db.get_all_batches_v2().unwrap();
// 5. Observe that expired/old-epoch V2 batches are still present
assert!(!v2_batches.is_empty()); // This will pass, demonstrating the leak

// Expected: v2_batches should be empty after cleanup
// Actual: v2_batches still contain expired entries
```

**Notes:**
- The V1/V2 collision scenario mentioned in the original question is NOT exploitable due to proper column family separation at the database level
- However, the deletion bugs discovered during this investigation represent real, exploitable vulnerabilities that will cause operational failures once V2 batches are deployed
- This issue should be fixed before enabling the V2 batch feature in production

### Citations

**File:** consensus/src/quorum_store/batch_store.rs (L212-243)
```rust
    fn gc_previous_epoch_batches_from_db_v2(db: Arc<dyn QuorumStoreStorage>, current_epoch: u64) {
        let db_content = db
            .get_all_batches_v2()
            .expect("failed to read data from db");
        info!(
            epoch = current_epoch,
            "QS: Read batches from storage. Len: {}",
            db_content.len(),
        );

        let mut expired_keys = Vec::new();
        for (digest, value) in db_content {
            let epoch = value.epoch();

            trace!(
                "QS: Batchreader recovery content epoch {:?}, digest {}",
                epoch,
                digest
            );

            if epoch < current_epoch {
                expired_keys.push(digest);
            }
        }

        info!(
            "QS: Batch store bootstrap expired keys len {}",
            expired_keys.len()
        );
        db.delete_batches(expired_keys)
            .expect("Deletion of expired keys should not fail");
    }
```

**File:** consensus/src/quorum_store/batch_store.rs (L530-539)
```rust
    pub fn update_certified_timestamp(&self, certified_time: u64) {
        trace!("QS: batch reader updating time {:?}", certified_time);
        self.last_certified_time
            .fetch_max(certified_time, Ordering::SeqCst);

        let expired_keys = self.clear_expired_payload(certified_time);
        if let Err(e) = self.db.delete_batches(expired_keys) {
            debug!("Error deleting batches: {:?}", e)
        }
    }
```

**File:** consensus/src/quorum_store/schema.rs (L14-16)
```rust
pub(crate) const BATCH_CF_NAME: ColumnFamilyName = "batch";
pub(crate) const BATCH_ID_CF_NAME: ColumnFamilyName = "batch_ID";
pub(crate) const BATCH_V2_CF_NAME: ColumnFamilyName = "batch_v2";
```

**File:** consensus/src/quorum_store/quorum_store_db.rs (L93-101)
```rust
    fn delete_batches(&self, digests: Vec<HashValue>) -> Result<(), DbError> {
        let mut batch = SchemaBatch::new();
        for digest in digests.iter() {
            trace!("QS: db delete digest {}", digest);
            batch.delete::<BatchSchema>(digest)?;
        }
        self.db.write_schemas_relaxed(batch)?;
        Ok(())
    }
```

**File:** consensus/src/quorum_store/quorum_store_db.rs (L123-131)
```rust
    fn delete_batches_v2(&self, digests: Vec<HashValue>) -> Result<(), DbError> {
        let mut batch = SchemaBatch::new();
        for digest in digests.iter() {
            trace!("QS: db delete digest {}", digest);
            batch.delete::<BatchV2Schema>(digest)?;
        }
        self.db.write_schemas_relaxed(batch)?;
        Ok(())
    }
```

**File:** config/src/config/quorum_store_config.rs (L102-102)
```rust
    pub enable_batch_v2: bool,
```

**File:** consensus/src/quorum_store/batch_generator.rs (L190-211)
```rust
        if self.config.enable_batch_v2 {
            // TODO(ibalajiarun): Specify accurate batch kind
            let batch_kind = BatchKind::Normal;
            Batch::new_v2(
                batch_id,
                txns,
                self.epoch,
                expiry_time,
                self.my_peer_id,
                bucket_start,
                batch_kind,
            )
        } else {
            Batch::new_v1(
                batch_id,
                txns,
                self.epoch,
                expiry_time,
                self.my_peer_id,
                bucket_start,
            )
        }
```
