# Audit Report

## Title
Minimum Peers Checker Lacks Connection Origin and Service Type Validation

## Summary
The `MinimumPeersChecker` validates only the count of connections without verifying whether these connections are to legitimate external blockchain peers or to localhost services that merely satisfy protocol handshakes without providing actual blockchain functionality.

## Finding Description

The `MinimumPeersChecker.check()` function retrieves the `aptos_connections` metric and validates only that the connection count meets configured minimums. [1](#0-0) 

The metric itself is populated by counting all connections that pass the Noise and Aptos handshakes. [2](#0-1) 

While the system implements self-dial detection to prevent a node from connecting to itself (same peer_id), [3](#0-2)  this only prevents connections where `remote_peer_id == local_peer_id`. It does not prevent connections to separate services running on localhost with different peer IDs.

The connection validation in `handle_new_connection_event` checks peer roles and connection limits but performs no IP-based filtering to distinguish localhost from external peers. [4](#0-3) 

**Attack Scenario:**
1. An actor with localhost access runs multiple services that implement minimal protocol support (Noise handshake, Aptos handshake with matching chain_id/network_id, health check ping/pong)
2. These services use different peer IDs to bypass self-dial detection
3. They respond to health checks but do not participate in consensus, state sync, or mempool operations
4. The `aptos_connections` metric counts these as valid connections
5. The `MinimumPeersChecker` reports sufficient peer connectivity
6. Node operators receive false positive health signals while the node may be isolated from the actual blockchain network

## Impact Explanation

This qualifies as **Medium Severity** per the bug bounty criteria for the following reasons:
- Creates operational risk where node operators cannot reliably assess actual network connectivity
- Could lead to nodes failing to sync state or participate in consensus while reporting healthy status
- Particularly relevant for validator registration scenarios (e.g., AITs) where peer count is used as a health signal
- Does not directly cause fund loss or consensus violations but creates conditions for state inconsistencies requiring intervention

## Likelihood Explanation

**Moderate to Low Likelihood:**
- Requires actor to have localhost access to the node host
- If such access exists, this represents a limited exploitation vector compared to direct node compromise
- More likely as an unintentional misconfiguration (e.g., test/debug services) than malicious exploitation
- Could occur in containerized environments where multiple services share networking

## Recommendation

Implement multi-layered validation in `MinimumPeersChecker`:

1. **IP-based filtering:** Validate that connections are not from loopback addresses (127.0.0.0/8, ::1)
2. **Service quality metrics:** Incorporate metrics beyond connection count that validate peer participation in blockchain operations:
   - Consensus participation status [5](#0-4) 
   - State sync progress indicators
   - Mempool transaction propagation activity

3. **Enhanced metric collection:** Modify the connection counter to include labels distinguishing connection source (localhost vs external) and service quality indicators

Example enhancement to the checker:
```rust
// Additional validation after getting connection counts
if let Some(connection_details) = get_connection_details(&scrape) {
    let localhost_connections = connection_details.filter_localhost_connections();
    if localhost_connections.count() > threshold {
        return warning("Excessive localhost connections detected");
    }
}
```

## Proof of Concept

```rust
// Rust reproduction steps
// 1. Start an Aptos node with node-checker monitoring
// 2. Create fake peer service on localhost:
use aptos_crypto::x25519;
use aptos_types::chain_id::ChainId;

// Generate different peer_id to bypass self-dial detection
let fake_peer_key = x25519::PrivateKey::generate_for_testing();
let fake_peer_id = PeerId::random();

// Implement minimal protocol support:
// - Noise handshake with fake_peer_key
// - Aptos handshake with matching chain_id/network_id
// - Health check responder (Ping -> Pong)

// 3. Connect fake services to node's listening port
// 4. Observe aptos_connections metric increments
// 5. Run MinimumPeersChecker - it reports "sufficient peers"
// 6. Verify node is actually isolated by checking consensus participation
```

## Notes

The health checker protocol validates only that peers respond to pings, not that they provide blockchain services. [6](#0-5)  While separate monitoring exists for consensus participation and state sync progress, the `MinimumPeersChecker` does not integrate these quality signals, focusing solely on connection count.

This represents a gap between connection establishment (protocol-level) and functional peer validation (blockchain service-level) that could mislead node operators about their node's actual network integration status.

### Citations

**File:** ecosystem/node-checker/src/checker/minimum_peers.rs (L104-142)
```rust
    async fn check(
        &self,
        providers: &ProviderCollection,
    ) -> Result<Vec<CheckResult>, CheckerError> {
        let target_metrics_provider = get_provider!(
            providers.target_metrics_provider,
            self.config.common.required,
            MetricsProvider
        );
        let scrape = match target_metrics_provider.provide().await {
            Ok(scrape) => scrape,
            Err(e) => {
                return Ok(vec![Self::build_result(
                    "Failed to check node peers".to_string(),
                    0,
                    format!("Failed to scrape metrics from your node: {:#}", e),
                )])
            },
        };
        let (inbound_connections, outbound_connections) = match get_metrics(&scrape) {
            Ok((inbound_connections, outbound_connections)) => {
                (inbound_connections, outbound_connections)
            },
            Err(evaluation_results) => return Ok(evaluation_results),
        };

        Ok(vec![
            self.build_evaluation(
                inbound_connections,
                self.config.minimum_peers_inbound,
                &ConnectionType::Inbound,
            ),
            self.build_evaluation(
                outbound_connections,
                self.config.minimum_peers_outbound,
                &ConnectionType::Outbound,
            ),
        ])
    }
```

**File:** network/framework/src/peer_manager/mod.rs (L190-202)
```rust
    pub fn update_connected_peers_metrics(&self) {
        let total = self.active_peers.len();
        let inbound = self
            .active_peers
            .iter()
            .filter(|(_, (metadata, _))| metadata.origin == ConnectionOrigin::Inbound)
            .count();
        let outbound = total.saturating_sub(inbound);

        counters::connections(&self.network_context, ConnectionOrigin::Inbound).set(inbound as i64);
        counters::connections(&self.network_context, ConnectionOrigin::Outbound)
            .set(outbound as i64);
    }
```

**File:** network/framework/src/peer_manager/mod.rs (L331-405)
```rust
    /// Handles a new connection event
    fn handle_new_connection_event(&mut self, conn: Connection<TSocket>) {
        // Get the trusted peers
        let trusted_peers = match self
            .peers_and_metadata
            .get_trusted_peers(&self.network_context.network_id())
        {
            Ok(trusted_peers) => trusted_peers,
            Err(error) => {
                error!(
                    NetworkSchema::new(&self.network_context)
                        .connection_metadata_with_address(&conn.metadata),
                    "Failed to get trusted peers for network context: {:?}, error: {:?}",
                    self.network_context,
                    error
                );
                return;
            },
        };

        // Verify that we have not reached the max connection limit for unknown inbound peers
        if conn.metadata.origin == ConnectionOrigin::Inbound {
            // Everything below here is meant for unknown peers only. The role comes from
            // the Noise handshake and if it's not `Unknown` then it is trusted.
            if conn.metadata.role == PeerRole::Unknown {
                // TODO: Keep track of somewhere else to not take this hit in case of DDoS
                // Count unknown inbound connections
                let unknown_inbound_conns = self
                    .active_peers
                    .iter()
                    .filter(|(peer_id, (metadata, _))| {
                        metadata.origin == ConnectionOrigin::Inbound
                            && trusted_peers
                                .get(peer_id)
                                .is_none_or(|peer| peer.role == PeerRole::Unknown)
                    })
                    .count();

                // Reject excessive inbound connections made by unknown peers
                // We control outbound connections with Connectivity manager before we even send them
                // and we must allow connections that already exist to pass through tie breaking.
                if !self
                    .active_peers
                    .contains_key(&conn.metadata.remote_peer_id)
                    && unknown_inbound_conns + 1 > self.inbound_connection_limit
                {
                    info!(
                        NetworkSchema::new(&self.network_context)
                            .connection_metadata_with_address(&conn.metadata),
                        "{} Connection rejected due to connection limit: {}",
                        self.network_context,
                        conn.metadata
                    );
                    counters::connections_rejected(&self.network_context, conn.metadata.origin)
                        .inc();
                    self.disconnect(conn);
                    return;
                }
            }
        }

        // Add the new peer and update the metric counters
        info!(
            NetworkSchema::new(&self.network_context)
                .connection_metadata_with_address(&conn.metadata),
            "{} New connection established: {}", self.network_context, conn.metadata
        );
        if let Err(error) = self.add_peer(conn) {
            warn!(
                NetworkSchema::new(&self.network_context),
                "Failed to add peer. Error: {:?}", error
            )
        }
        self.update_connected_peers_metrics();
    }
```

**File:** network/framework/src/noise/handshake.rs (L341-347)
```rust
        // reject accidental self-dials
        // this situation could occur either as a result of our own discovery
        // mis-configuration or a potentially malicious discovery peer advertising
        // a (loopback ip or mirror proxy) and our public key.
        if remote_peer_id == self.network_context.peer_id() {
            return Err(NoiseHandshakeError::SelfDialDetected);
        }
```

**File:** consensus/src/counters.rs (L47-78)
```rust
    )
    .unwrap()
}

//////////////////////
// HEALTH COUNTERS
//////////////////////

/// Monitor counters, used by monitor! macro
pub static OP_COUNTERS: Lazy<aptos_metrics_core::op_counters::OpMetrics> =
    Lazy::new(|| aptos_metrics_core::op_counters::OpMetrics::new_and_registered("consensus"));

/// Count of the total number of blocks of whether randomness is required
pub static RAND_BLOCK: Lazy<IntCounterVec> = Lazy::new(|| {
    register_int_counter_vec!(
        "aptos_consensus_rand_block_count",
        "Count of the total number of blocks of whether randomness is required",
        &["type"]
    )
    .unwrap()
});

/// Counts the total number of errors
pub static ERROR_COUNT: Lazy<IntGauge> = Lazy::new(|| {
    register_int_gauge!(
        "aptos_consensus_error_count",
        "Total number of errors in main loop"
    )
    .unwrap()
});

/// This counter is set to the round of the highest committed block.
```

**File:** network/framework/src/protocols/health_checker/mod.rs (L308-342)
```rust
    async fn handle_ping_response(
        &mut self,
        peer_id: PeerId,
        round: u64,
        req_nonce: u32,
        ping_result: Result<Pong, RpcError>,
    ) {
        match ping_result {
            Ok(pong) => {
                if pong.0 == req_nonce {
                    trace!(
                        NetworkSchema::new(&self.network_context).remote_peer(&peer_id),
                        rount = round,
                        "{} Ping successful for peer: {} round: {}",
                        self.network_context,
                        peer_id.short_str(),
                        round
                    );
                    // Update last successful ping to current round.
                    // If it's not in storage, don't bother updating it
                    self.network_interface
                        .reset_peer_round_state(peer_id, round);
                } else {
                    warn!(
                        SecurityEvent::InvalidHealthCheckerMsg,
                        NetworkSchema::new(&self.network_context).remote_peer(&peer_id),
                        "{} Pong nonce doesn't match Ping nonce. Round: {}, Pong: {}, Ping: {}",
                        self.network_context,
                        round,
                        pong.0,
                        req_nonce
                    );
                    debug_assert!(false, "Pong nonce doesn't match our challenge Ping nonce");
                }
            },
```
