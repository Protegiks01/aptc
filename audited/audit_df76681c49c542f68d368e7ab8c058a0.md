# Audit Report

## Title
Multisig Account Denial of Service via Malformed Payload Deserialization Failure

## Summary
The `create_multisig_transaction()` function accepts arbitrary payload bytes without validation. When a malformed payload is stored on-chain and later executed, deserialization fails after prologue validation but before cleanup functions that mark the transaction as executed. This causes the transaction to remain permanently stuck in the pending queue, blocking all subsequent multisig transactions and rendering the multisig account unusable.

## Finding Description

The vulnerability exists in the multisig transaction creation and execution flow across multiple components:

**1. Payload Creation (SDK Layer)**

The SDK function accepts arbitrary bytes without validation: [1](#0-0) [2](#0-1) 

**2. On-Chain Storage (Move Layer)**

The Move module stores payload bytes with only a non-empty check: [3](#0-2) 

**3. Execution Flow (VM Layer)**

During execution, deserialization occurs AFTER prologue validation but BEFORE cleanup: [4](#0-3) 

**Critical Issue**: When deserialization fails at line 1280, the function returns early with `?`, skipping the cleanup functions at lines 1312-1360: [5](#0-4) 

These cleanup functions (`successful_transaction_execution_cleanup` and `failed_transaction_execution_cleanup`) are responsible for marking the transaction as executed and removing it from the queue.

**4. Sequential Execution Constraint**

Multisig transactions must execute in order: [6](#0-5) 

This means a stuck transaction blocks all subsequent transactions permanently.

**Attack Scenario:**

1. Malicious multisig owner creates transaction with invalid payload bytes (e.g., `vec![0xFF, 0xFF, 0xFF]` which cannot deserialize to `MultisigTransactionPayload`)
2. Transaction gets approved by required number of signatures
3. When executed, deserialization fails with `FAILED_TO_DESERIALIZE_ARGUMENT`
4. Transaction is NOT marked as executed (cleanup functions never called)
5. Transaction remains in pending queue forever
6. All subsequent multisig transactions are blocked (sequential execution requirement)
7. Multisig account becomes permanently unusable

**Broken Invariant**: This violates **State Consistency** - the transaction enters an inconsistent state where it has been processed by the blockchain but not marked as executed in the multisig account's internal state.

## Impact Explanation

This is a **High Severity** vulnerability according to Aptos bug bounty criteria:

- **Significant protocol violations**: The multisig account protocol is designed to allow sequential execution of approved transactions. This vulnerability breaks that core functionality.

- **State inconsistencies requiring intervention**: The stuck transaction creates a permanent inconsistency that requires coordinated action from all owners to reject the transaction.

- **Limited funds loss or manipulation**: While not direct fund theft, this effectively freezes all assets controlled by the multisig account until recovery. For high-value multisig accounts controlling treasury funds or protocol parameters, this represents significant impact.

The severity approaches **Critical** because:
- It causes permanent loss of multisig account functionality
- Funds in the account become effectively frozen during recovery
- Recovery requires coordination among all owners, which may be difficult or impossible if the attacker is an owner with veto power
- The attack is trivial to execute (single malformed transaction)

## Likelihood Explanation

**Likelihood: HIGH**

The vulnerability is highly likely to be exploited because:

1. **Low Barrier to Entry**: Any owner of a multisig account can perform this attack
2. **Simple Execution**: Attacker only needs to provide malformed bytes as payload
3. **Difficult to Detect**: Other owners may approve the transaction without realizing the payload is malformed (it's just opaque bytes)
4. **No Cost**: The attack fails during execution, so gas costs are minimal
5. **High Impact**: Complete DoS of the multisig account makes this an attractive target

The attack is especially concerning for:
- High-value treasury multisigs
- Protocol governance multisigs
- Any multisig where one owner becomes malicious

## Recommendation

**Immediate Fix**: Add payload validation during transaction creation to ensure bytes can be deserialized before storage.

In `multisig_account.move`, modify the `create_transaction` function:

```move
public entry fun create_transaction(
    owner: &signer,
    multisig_account: address,
    payload: vector<u8>,
) acquires MultisigAccount {
    assert!(vector::length(&payload) > 0, error::invalid_argument(EPAYLOAD_CANNOT_BE_EMPTY));
    
    // ADD VALIDATION: Attempt to deserialize payload to verify it's valid
    // This should be done by calling a validation function in the VM
    validate_payload_format(payload); // New native function needed
    
    assert_multisig_account_exists(multisig_account);
    assert_is_owner(owner, multisig_account);
    // ... rest of function
}
```

**Alternative Fix**: Handle deserialization errors gracefully by still marking the transaction as executed (failed state):

In `aptos_vm.rs`, modify `execute_multisig_transaction` to catch deserialization errors and call failure cleanup:

```rust
let payload = match bcs::from_bytes::<MultisigTransactionPayload>(&payload_bytes) {
    Ok(p) => p,
    Err(_) => {
        // Deserialization failed - still need to mark transaction as executed
        return self.failure_multisig_payload_cleanup(
            resolver,
            module_storage,
            prologue_session_change_set,
            deserialization_error(),
            txn_data,
            cleanup_args,
            traversal_context,
        ).map(|session| {
            self.success_transaction_cleanup(
                session,
                module_storage,
                serialized_signers,
                gas_meter,
                txn_data,
                log_context,
                change_set_configs,
                traversal_context,
            )
        }).and_then(|x| x);
    }
};
```

**Recommended Approach**: Implement upfront validation (first fix) to prevent invalid payloads from being stored, AND implement graceful error handling (second fix) as defense-in-depth.

## Proof of Concept

```rust
// Test demonstrating the vulnerability
#[test]
fn test_malformed_multisig_payload_dos() {
    // Setup: Create multisig account with 2 owners, 1 signature required
    let mut executor = setup_test_executor();
    let owner1 = create_account(&mut executor);
    let owner2 = create_account(&mut executor);
    
    let multisig_address = create_multisig_account(
        &mut executor,
        &owner1,
        vec![owner2.address()],
        1, // signatures required
    );
    
    // Step 1: Create multisig transaction with MALFORMED payload
    // Instead of valid BCS-encoded MultisigTransactionPayload, use random bytes
    let malformed_payload = vec![0xFF, 0xFF, 0xFF, 0xFF]; // Invalid BCS data
    
    create_multisig_transaction(
        &mut executor,
        &owner1,
        multisig_address,
        malformed_payload,
    );
    
    // Transaction is created and stored (no validation!)
    let pending_txns = get_pending_transactions(&executor, multisig_address);
    assert_eq!(pending_txns.len(), 1);
    
    // Step 2: Try to execute the malformed transaction
    let result = execute_multisig_transaction(
        &mut executor,
        &owner1,
        multisig_address,
        None, // payload already stored on-chain
    );
    
    // Execution FAILS with FAILED_TO_DESERIALIZE_ARGUMENT
    assert!(matches!(result, Err(StatusCode::FAILED_TO_DESERIALIZE_ARGUMENT)));
    
    // Step 3: CRITICAL BUG - Transaction is NOT marked as executed!
    let pending_txns = get_pending_transactions(&executor, multisig_address);
    assert_eq!(pending_txns.len(), 1); // Still 1 pending transaction!
    
    let last_executed = last_resolved_sequence_number(&executor, multisig_address);
    assert_eq!(last_executed, 0); // Still at 0, transaction NOT executed
    
    // Step 4: Try to create and execute a VALID transaction
    let valid_payload = create_valid_entry_function_payload();
    create_multisig_transaction(
        &mut executor,
        &owner1,
        multisig_address,
        valid_payload.clone(),
    );
    
    // Now we have 2 pending transactions
    let pending_txns = get_pending_transactions(&executor, multisig_address);
    assert_eq!(pending_txns.len(), 2);
    
    // Try to execute the second (valid) transaction
    let result = execute_multisig_transaction(
        &mut executor,
        &owner1,
        multisig_address,
        Some(valid_payload),
    );
    
    // BLOCKED! Cannot execute because sequence number 1 is stuck
    // The validation requires: sequence_number == last_resolved + 1
    // We're trying to execute sequence 2, but 1 is not resolved
    assert!(result.is_err()); // Fails validation
    
    // Step 5: MULTISIG ACCOUNT IS NOW PERMANENTLY UNUSABLE
    // The only recovery is to reject transaction 1, which requires:
    // - All owners to vote to reject
    // - Coordination among potentially adversarial parties
    // - Time during which the account is frozen
}
```

## Notes

The vulnerability can be recovered from by having owners reject the malformed transaction via `reject_transaction` and then calling `execute_rejected_transaction`. However:

1. This requires coordination among all owners
2. If the attacker is an owner, they can delay rejection
3. During recovery, the multisig account is unusable
4. The attack can be repeated after recovery

The root cause is insufficient input validation at the point of transaction creation, combined with error handling that doesn't account for deserialization failures occurring before cleanup functions are called.

### Citations

**File:** sdk/src/transaction_builder.rs (L298-307)
```rust
    pub fn create_multisig_transaction(
        &self,
        multisig_account: AccountAddress,
        payload: Vec<u8>,
    ) -> TransactionBuilder {
        self.payload(aptos_stdlib::multisig_account_create_transaction(
            multisig_account,
            payload,
        ))
    }
```

**File:** aptos-move/framework/cached-packages/src/aptos_framework_sdk_builder.rs (L3731-3750)
```rust
pub fn multisig_account_create_transaction(
    multisig_account: AccountAddress,
    payload: Vec<u8>,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("multisig_account").to_owned(),
        ),
        ident_str!("create_transaction").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&multisig_account).unwrap(),
            bcs::to_bytes(&payload).unwrap(),
        ],
    ))
}
```

**File:** aptos-move/framework/aptos-framework/sources/multisig_account.move (L408-413)
```text
    public fun can_be_executed(multisig_account: address, sequence_number: u64): bool acquires MultisigAccount {
        assert_valid_sequence_number(multisig_account, sequence_number);
        let (num_approvals, _) = num_approvals_and_rejections(multisig_account, sequence_number);
        sequence_number == last_resolved_sequence_number(multisig_account) + 1 &&
            num_approvals >= num_signatures_required(multisig_account)
    }
```

**File:** aptos-move/framework/aptos-framework/sources/multisig_account.move (L954-973)
```text
    public entry fun create_transaction(
        owner: &signer,
        multisig_account: address,
        payload: vector<u8>,
    ) acquires MultisigAccount {
        assert!(vector::length(&payload) > 0, error::invalid_argument(EPAYLOAD_CANNOT_BE_EMPTY));

        assert_multisig_account_exists(multisig_account);
        assert_is_owner(owner, multisig_account);

        let creator = address_of(owner);
        let transaction = MultisigTransaction {
            payload: option::some(payload),
            payload_hash: option::none<vector<u8>>(),
            votes: simple_map::create<address, bool>(),
            creator,
            creation_time_secs: now_seconds(),
        };
        add_transaction(creator, multisig_account, transaction);
    }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1269-1281)
```rust
        // We have to deserialize twice as the first time returns the actual return type of the
        // function, which is vec<u8>. The second time deserializes it into the correct
        // EntryFunction payload type.
        // If either deserialization fails for some reason, that means the user provided incorrect
        // payload data either during transaction creation or execution.
        let deserialization_error = || {
            PartialVMError::new(StatusCode::FAILED_TO_DESERIALIZE_ARGUMENT)
                .finish(Location::Undefined)
        };
        let payload_bytes =
            bcs::from_bytes::<Vec<u8>>(payload_bytes).map_err(|_| deserialization_error())?;
        let payload = bcs::from_bytes::<MultisigTransactionPayload>(&payload_bytes)
            .map_err(|_| deserialization_error())?;
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1302-1360)
```rust
        // Step 3: Call post transaction cleanup function in multisig account module with the result
        // from Step 2.
        // Note that we don't charge execution or writeset gas for cleanup routines. This is
        // consistent with the high-level success/failure cleanup routines for user transactions.
        let cleanup_args = serialize_values(&vec![
            MoveValue::Address(txn_data.sender),
            MoveValue::Address(multisig_address),
            MoveValue::vector_u8(payload_bytes),
        ]);

        let epilogue_session = match execution_result {
            Err(execution_error) => self.failure_multisig_payload_cleanup(
                resolver,
                module_storage,
                prologue_session_change_set,
                execution_error,
                txn_data,
                cleanup_args,
                traversal_context,
            )?,
            Ok(user_session_change_set) => {
                // Charge gas for write set before we do cleanup. This ensures we don't charge gas for
                // cleanup write set changes, which is consistent with outer-level success cleanup
                // flow. We also wouldn't need to worry that we run out of gas when doing cleanup.
                let mut epilogue_session = self.charge_change_set_and_respawn_session(
                    user_session_change_set,
                    resolver,
                    module_storage,
                    gas_meter,
                    txn_data,
                )?;
                epilogue_session.execute(|session| {
                    session
                        .execute_function_bypass_visibility(
                            &MULTISIG_ACCOUNT_MODULE,
                            SUCCESSFUL_TRANSACTION_EXECUTION_CLEANUP,
                            vec![],
                            cleanup_args,
                            &mut UnmeteredGasMeter,
                            traversal_context,
                            module_storage,
                        )
                        .map_err(|e| e.into_vm_status())
                })?;
                epilogue_session
            },
        };

        // TODO(Gas): Charge for aggregator writes
        self.success_transaction_cleanup(
            epilogue_session,
            module_storage,
            serialized_signers,
            gas_meter,
            txn_data,
            log_context,
            change_set_configs,
            traversal_context,
        )
```
