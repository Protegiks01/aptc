# Audit Report

## Title
Multi-Step Governance Proposal Early Termination via Empty Next Execution Hash

## Summary
A malicious or compromised proposer can prematurely terminate a multi-step governance proposal by generating a resolution script with an empty `next_execution_hash`, causing the proposal to be marked as fully resolved after the first step and bypassing execution of subsequent steps.

## Finding Description

The `generate_next_execution_hash_blob()` function accepts `Option<HashValue>` for the `next_execution_hash` parameter. When `None` is passed, it generates Move code that calls `resolve_multi_step_proposal` with an empty hash `x""`. [1](#0-0) 

In the governance resolution flow, the `resolve_multi_step_proposal` function passes this empty hash to the underlying `voting::resolve_proposal_v2` function: [2](#0-1) 

The critical flaw is in `voting.move` where an empty `next_execution_hash` (length 0) signals the **final step** of a multi-step proposal, causing it to be marked as fully resolved: [3](#0-2) 

**The Attack Vector:**

1. A proposer creates a legitimate 3-step governance proposal (e.g., upgrading modules A, B, and C sequentially)
2. The proposer maliciously generates the step 1 resolution script with `next_execution_hash = None` instead of the hash for step 2
3. This script's hash becomes H1 and is stored in the proposal's `execution_hash` field during creation
4. The proposal passes governance voting (voters see it's marked as multi-step but cannot verify the hash chain on-chain)
5. When step 1 executes, it passes all validation checks including the script hash match
6. However, because it calls `resolve_multi_step_proposal` with an empty `next_execution_hash`, the proposal is marked as fully resolved
7. Steps 2 and 3 are never executed, bypassing their intended changes

**Missing Validation:**

During proposal creation, there is no validation that a multi-step proposal's execution script properly specifies a non-empty next execution hash: [4](#0-3) 

The only check is that the `execution_hash` itself is non-empty, but not whether the script it represents correctly implements multi-step chaining.

## Impact Explanation

This vulnerability represents a **High Severity** governance protocol violation under the Aptos bug bounty program criteria. It enables:

1. **Governance Bypass**: Multi-step proposals are designed to execute coordinated changes atomically. Skipping steps breaks the governance integrity invariant.

2. **Security-Critical Omissions**: If step 1 contains a benign change and steps 2-3 contain security fixes or access control changes, an attacker can execute only the benign portion while avoiding scrutiny of the critical changes.

3. **Framework Inconsistency**: Partial execution of coordinated upgrades could leave the Aptos Framework in an inconsistent state, potentially breaking dependent contracts or causing consensus issues.

4. **Trust Model Violation**: While proposers are generally trusted, defense-in-depth principles require on-chain validation to detect compromised actors or supply chain attacks on script generation tools.

This qualifies as a "Significant protocol violation" affecting governance integrity, meeting the High Severity threshold.

## Likelihood Explanation

**Likelihood: Medium**

**Factors increasing likelihood:**
- Script generation tools are centralized and could be compromised (supply chain attack)
- Human error: A developer might accidentally pass `None` instead of the correct next hash
- No on-chain enforcement exists to catch this mistake

**Factors decreasing likelihood:**
- Requires access to script generation infrastructure (semi-privileged)
- Proposals still require governance voting
- Core team likely has review processes for proposal scripts
- Voters can use the `VerifyProposal` CLI command to verify script hashes, though they cannot verify the hash chain correctness on-chain

The combination of no technical barriers (once script generation access is obtained) and potential for significant impact justifies a Medium likelihood assessment.

## Recommendation

Implement on-chain validation in `voting::create_proposal_v2` to verify that multi-step proposals have valid execution scripts. This can be achieved by:

1. **During proposal creation**: Parse and validate the execution script bytecode to ensure that multi-step proposals call `resolve_proposal_v2` with a non-empty `next_execution_hash` parameter for non-final steps.

2. **Alternative approach**: Store the complete hash chain on-chain during proposal creation. Validate that each step's `next_execution_hash` matches the stored chain.

**Recommended Fix (Conceptual):**

Add validation in `create_proposal_v2` (after line 311 in voting.move):

```move
// For multi-step proposals, validate that the execution script
// properly specifies a next execution hash (implementation would require
// bytecode inspection or storing the full hash chain at creation time)
if (is_multi_step_proposal) {
    // Option 1: Store expected hash chain in metadata
    // Option 2: Parse execution_hash script to validate it contains non-empty next hash
    // Option 3: Require next_execution_hash to be provided at creation time
    assert!(/* validation logic */, error::invalid_argument(EINVALID_MULTI_STEP_CHAIN));
}
```

Additionally, update `generate_next_execution_hash_blob` to add defensive documentation: [5](#0-4) 

Add warnings that `None` should ONLY be used for the genuinely final step.

## Proof of Concept

```move
#[test_only]
module test_addr::multi_step_bypass_poc {
    use aptos_framework::voting;
    use aptos_framework::aptos_governance;
    use std::vector;
    use std::option;
    
    #[test(aptos_framework = @aptos_framework, proposer = @0x123)]
    fun test_multi_step_early_termination(
        aptos_framework: signer,
        proposer: signer,
    ) {
        // Setup: Initialize governance and create a proposer with sufficient stake
        // (Setup code omitted for brevity - would initialize voting, governance, staking)
        
        // Step 1: Create a multi-step proposal (3 steps intended)
        let execution_hash_step1 = vector[1]; // Hash of step 1 script
        let proposal_id = aptos_governance::create_proposal_v2_impl(
            &proposer,
            @0x123, // stake_pool
            execution_hash_step1,
            b"Multi-step upgrade", // metadata_location
            b"", // metadata_hash
            true // is_multi_step_proposal = TRUE
        );
        
        // Step 2: Vote and pass the proposal
        // (Voting code omitted for brevity)
        
        // Step 3: Execute step 1 with EMPTY next_execution_hash
        // This should update to step 2 hash, but instead marks as complete
        let empty_next_hash = vector::empty<u8>(); // THIS IS THE BUG
        
        aptos_governance::resolve_multi_step_proposal(
            proposal_id,
            @0x1,
            empty_next_hash // EMPTY = marks as final step!
        );
        
        // Verification: Proposal is now fully resolved after just 1 step
        assert!(voting::is_resolved<GovernanceProposal>(@aptos_framework, proposal_id), 0);
        
        // Steps 2 and 3 are never executed - GOVERNANCE BYPASS!
    }
}
```

The PoC demonstrates that passing an empty `next_execution_hash` to `resolve_multi_step_proposal` causes the proposal to be marked as fully resolved, even though it was created as a 3-step proposal. This bypasses the execution of steps 2 and 3, breaking the governance integrity invariant.

## Notes

This vulnerability exists because the system trusts the script generation process to correctly implement multi-step chaining without on-chain verification. While the `VerifyProposal` CLI tool allows voters to verify that a script matches its hash, it cannot verify that the script correctly implements the intended multi-step logic. The empty hash case at lines 292-298 of `release_bundle.rs` is intended for the legitimate final step of a multi-step proposal, but there is no enforcement that it's only used in that context.

### Citations

**File:** aptos-move/framework/src/release_bundle.rs (L286-314)
```rust
pub fn generate_next_execution_hash_blob(
    writer: &CodeWriter,
    for_address: AccountAddress,
    next_execution_hash: Option<HashValue>,
) {
    match next_execution_hash {
        None => {
            emitln!(
            writer,
            "let framework_signer = aptos_governance::resolve_multi_step_proposal(proposal_id, @{}, {});\n",
            for_address,
            "x\"\"",
        );
        },
        Some(next_execution_hash) => {
            emitln!(
                writer,
                "let framework_signer = aptos_governance::resolve_multi_step_proposal("
            );
            writer.indent();
            emitln!(writer, "proposal_id,");
            emitln!(writer, "@{},", for_address);
            generate_blob_as_hex_string(writer, next_execution_hash.as_slice());
            emit!(writer, ",");
            writer.unindent();
            emitln!(writer, ");");
        },
    }
}
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L644-661)
```text
    public fun resolve_multi_step_proposal(
        proposal_id: u64,
        signer_address: address,
        next_execution_hash: vector<u8>
    ): signer acquires GovernanceResponsbility, ApprovedExecutionHashes {
        voting::resolve_proposal_v2<GovernanceProposal>(@aptos_framework, proposal_id, next_execution_hash);
        // If the current step is the last step of this multi-step proposal,
        // we will remove the execution hash from the ApprovedExecutionHashes map.
        if (vector::length(&next_execution_hash) == 0) {
            remove_approved_hash(proposal_id);
        } else {
            // If the current step is not the last step of this proposal,
            // we replace the current execution hash with the next execution hash
            // in the ApprovedExecutionHashes map.
            add_approved_script_hash(proposal_id)
        };
        get_signer(signer_address)
    }
```

**File:** aptos-move/framework/aptos-framework/sources/voting.move (L310-311)
```text
        // Make sure the execution script's hash is not empty.
        assert!(vector::length(&execution_hash) > 0, error::invalid_argument(EPROPOSAL_EMPTY_EXECUTION_HASH));
```

**File:** aptos-move/framework/aptos-framework/sources/voting.move (L550-561)
```text
        if (next_execution_hash_is_empty) {
            proposal.is_resolved = true;
            proposal.resolution_time_secs = timestamp::now_seconds();

            // Set the `IS_MULTI_STEP_PROPOSAL_IN_EXECUTION_KEY` value to false upon successful resolution of the last step of a multi-step proposal.
            if (is_multi_step) {
                let is_multi_step_proposal_in_execution_value = simple_map::borrow_mut(
                    &mut proposal.metadata,
                    &multi_step_in_execution_key
                );
                *is_multi_step_proposal_in_execution_value = to_bytes(&false);
            };
```
