# Audit Report

## Title
Missing Validation in get_raw_block_info_by_version Allows Silent Return of Incorrect Block Information

## Summary
The function `get_raw_block_info_by_version` does not validate that the returned `BlockInfo` actually corresponds to the requested version when using the sharded storage path (default production configuration). This creates a defensive programming gap where database inconsistencies would go undetected.

## Finding Description

The function `get_raw_block_info_by_version` in [1](#0-0)  has two code paths based on the `skip_index_and_usage` flag.

When `skip_index_and_usage` is true (the default production setting with `enable_storage_sharding=true` [2](#0-1) ), the function follows the else branch [3](#0-2)  which:

1. Calls `get_block_height_by_version(version)` [4](#0-3)  to find the block height
2. Calls `get_raw_block_info_by_height(block_height)` to retrieve the BlockInfo
3. Returns the BlockInfo **without validating** that `block_info.first_version() <= version`

The `BlockInfo` struct only stores `first_version` [5](#0-4) , and the invariant that should be enforced is:
```
block_info.first_version() <= requested_version < next_block.first_version()
```

This validation is absent, meaning if `BlockByVersionSchema` and `BlockInfoSchema` become inconsistent, the function would silently return incorrect block information.

The caller `get_block_info_by_version` [6](#0-5)  and subsequent function `to_api_block_info` [7](#0-6)  also do not perform this validation.

## Impact Explanation

However, after thorough investigation, this finding does NOT meet the criteria for HIGH severity exploitation because:

1. **No unprivileged attack path exists**: Database inconsistency would require either filesystem-level access (hardware failure, disk corruption) or a bug in the storage layer. No such bug was found during investigation.

2. **Atomic writes prevent inconsistency**: The `BlockByVersionSchema` and `BlockInfoSchema` are written in the same atomic batch [8](#0-7) , making inconsistency unlikely in normal operation.

3. **Limited impact scope**: Even if triggered, this would affect API responses and indexers, but would NOT directly cause:
   - Loss of funds
   - Consensus safety violations  
   - Network partition or liveness failure
   - Direct validator compromise

This is a **defensive programming/robustness** issue rather than an exploitable vulnerability.

## Likelihood Explanation

The likelihood of this issue causing problems in production is **very low** because:
- Database writes are atomic within batches
- No code path was identified that creates the required inconsistency
- Block metadata is not pruned
- Would require external database corruption (hardware failure)

## Recommendation

Add defensive validation to detect database inconsistencies early:

```rust
pub(super) fn get_raw_block_info_by_version(
    &self,
    version: Version,
) -> Result<(u64 /* block_height */, BlockInfo)> {
    // ... existing code ...
    
    if !self.skip_index_and_usage {
        // ... existing path ...
    } else {
        let block_height = self
            .ledger_db
            .metadata_db()
            .get_block_height_by_version(version)?;

        let block_info = self.get_raw_block_info_by_height(block_height)?;
        
        // ADD THIS VALIDATION:
        ensure!(
            block_info.first_version() <= version,
            "Database inconsistency detected: BlockInfo first_version {} > requested version {}. Block height: {}",
            block_info.first_version(),
            version,
            block_height
        );
        
        Ok((block_height, block_info))
    }
}
```

## Proof of Concept

A PoC would require artificially corrupting the database to create inconsistent mappings between `BlockByVersionSchema` and `BlockInfoSchema`. Since this cannot be triggered through normal API calls or transactions without privileged access, and no code bug was found that creates this inconsistency, a realistic PoC cannot be constructed.

---

**Note**: While the validation is indeed missing and should be added for defensive programming, this does NOT constitute an exploitable HIGH severity vulnerability per the Aptos bug bounty criteria, as it:
- Cannot be exploited by unprivileged attackers
- Has no realistic attack path without database corruption
- Does not directly threaten funds, consensus, or liveness

The validation should be added to improve code robustness and enable early detection of database corruption issues.

### Citations

**File:** storage/aptosdb/src/db/aptosdb_internal.rs (L340-372)
```rust
    pub(super) fn get_raw_block_info_by_version(
        &self,
        version: Version,
    ) -> Result<(u64 /* block_height */, BlockInfo)> {
        let synced_version = self.ensure_synced_version()?;
        ensure!(
            version <= synced_version,
            "Requested version {version} > synced version {synced_version}",
        );

        if !self.skip_index_and_usage {
            let (first_version, event_index, block_height) = self
                .event_store
                .lookup_event_before_or_at_version(&new_block_event_key(), version)?
                .ok_or_else(|| AptosDbError::NotFound("NewBlockEvent".to_string()))?;
            let new_block_event = self
                .event_store
                .get_event_by_version_and_index(first_version, event_index)?;
            let new_block_event = bcs::from_bytes(new_block_event.event_data())?;
            Ok((
                block_height,
                BlockInfo::from_new_block_event(first_version, &new_block_event),
            ))
        } else {
            let block_height = self
                .ledger_db
                .metadata_db()
                .get_block_height_by_version(version)?;

            let block_info = self.get_raw_block_info_by_height(block_height)?;
            Ok((block_height, block_info))
        }
    }
```

**File:** storage/aptosdb/src/db/aptosdb_internal.rs (L374-405)
```rust
    pub(super) fn to_api_block_info(
        &self,
        block_height: u64,
        block_info: BlockInfo,
    ) -> Result<(Version, Version, NewBlockEvent)> {
        // N.b. Must use committed_version because if synced version is used, we won't be able
        // to tell the end of the latest block.
        let committed_version = self.get_latest_ledger_info_version()?;
        ensure!(
            block_info.first_version() <= committed_version,
            "block first version {} > committed version {committed_version}",
            block_info.first_version(),
        );

        // TODO(grao): Consider return BlockInfo instead of NewBlockEvent.
        let new_block_event = self
            .ledger_db
            .event_db()
            .expect_new_block_event(block_info.first_version())?;

        let last_version = match self.get_raw_block_info_by_height(block_height + 1) {
            Ok(next_block_info) => next_block_info.first_version() - 1,
            Err(AptosDbError::NotFound(..)) => committed_version,
            Err(err) => return Err(err),
        };

        Ok((
            block_info.first_version(),
            last_version,
            bcs::from_bytes(new_block_event.event_data())?,
        ))
    }
```

**File:** config/src/config/storage_config.rs (L233-233)
```rust
            enable_storage_sharding: true,
```

**File:** storage/aptosdb/src/ledger_db/ledger_metadata_db.rs (L270-280)
```rust
    pub(crate) fn get_block_height_by_version(&self, version: Version) -> Result<u64> {
        let mut iter = self.db.iter::<BlockByVersionSchema>()?;

        iter.seek_for_prev(&version)?;
        let (_, block_height) = iter
            .next()
            .transpose()?
            .ok_or_else(|| anyhow!("Block is not found at version {version}, maybe pruned?"))?;

        Ok(block_height)
    }
```

**File:** storage/aptosdb/src/ledger_db/ledger_metadata_db.rs (L296-308)
```rust
    pub(crate) fn put_block_info(
        version: Version,
        event: &ContractEvent,
        batch: &mut SchemaBatch,
    ) -> Result<()> {
        let new_block_event = NewBlockEvent::try_from_bytes(event.event_data())?;
        let block_height = new_block_event.height();
        let block_info = BlockInfo::from_new_block_event(version, &new_block_event);
        batch.put::<BlockInfoSchema>(&block_height, &block_info)?;
        batch.put::<BlockByVersionSchema>(&version, &block_height)?;

        Ok(())
    }
```

**File:** storage/storage-interface/src/block_info.rs (L53-61)
```rust
pub struct BlockInfoV0 {
    /// Block hash.
    id: HashValue,
    epoch: u64,
    round: u64,
    proposer: AccountAddress,
    first_version: Version,
    timestamp_usecs: u64,
}
```

**File:** storage/aptosdb/src/db/aptosdb_reader.rs (L779-789)
```rust
    fn get_block_info_by_version(
        &self,
        version: Version,
    ) -> Result<(Version, Version, NewBlockEvent)> {
        gauged_api("get_block_info", || {
            self.error_if_ledger_pruned("NewBlockEvent", version)?;

            let (block_height, block_info) = self.get_raw_block_info_by_version(version)?;
            self.to_api_block_info(block_height, block_info)
        })
    }
```
