# Audit Report

## Title
Chain ID Mismatch Vulnerability in GrpcManager Heartbeat Handler Enables Cross-Chain Data Contamination

## Summary
The GrpcManager's heartbeat handler does not validate that incoming data services' `chain_id` matches the manager's own `chain_id`. This allows misconfigured or malicious data services indexing different blockchains to register successfully and serve cross-chain contaminated data to clients.

## Finding Description

The vulnerability exists in the indexer-grpc infrastructure's service registration mechanism. When a data service (live or historical) sends heartbeat messages to register itself with the GrpcManager, the heartbeat includes the service's configured `chain_id`. However, the GrpcManager accepts and registers these services without verifying that the reported `chain_id` matches its own.

**Attack Flow:**

1. **Misconfiguration/Attack Setup**: An operator misconfigures a data service with the wrong `chain_id` (e.g., `chain_id=1` for testnet data when connecting to a mainnet GrpcManager with `chain_id=2`), or a malicious actor deliberately does this.

2. **Heartbeat Transmission**: The misconfigured data service sends heartbeats containing its incorrect `chain_id` embedded in `LiveDataServiceInfo` or `HistoricalDataServiceInfo`. [1](#0-0) 

3. **Unvalidated Registration**: The GrpcManager receives the heartbeat and delegates to `MetadataManager.handle_heartbeat()` without chain_id verification. [2](#0-1) 

4. **Storage Without Validation**: The `MetadataManager` routes to either `handle_live_data_service_info()` or `handle_historical_data_service_info()`, which blindly store the service information without checking the `chain_id` field. [3](#0-2) [4](#0-3) 

5. **Incorrect Routing**: When clients request data, the GrpcManager selects from registered services based on load and version availability, but not chain_id. The misconfigured service can be selected. [5](#0-4) [6](#0-5) 

6. **Data Contamination**: The selected service serves transactions from the wrong blockchain with the wrong `chain_id` in responses, causing cross-chain data contamination. [7](#0-6) 

The protocol defines `chain_id` fields in both service info messages: [8](#0-7) 

However, the MetadataManager stores a `chain_id` but never validates it against incoming heartbeats: [9](#0-8) 

## Impact Explanation

This vulnerability qualifies as **HIGH severity** per Aptos bug bounty criteria:

- **Significant Protocol Violations**: Breaks the fundamental data integrity guarantee that indexer infrastructure serves data from the correct blockchain
- **API Reliability Issues**: Clients receive incorrect chain data, potentially causing downstream application failures
- **State Inconsistencies**: Cross-chain data contamination could corrupt indexer databases and analytics systems that depend on this data

While this doesn't directly affect consensus or validator operations (the indexer is separate infrastructure), it compromises the integrity of the entire indexing layer that applications rely on for blockchain data access.

## Likelihood Explanation

**Likelihood: MEDIUM to HIGH**

This vulnerability is highly likely to manifest due to:

1. **Configuration Complexity**: Operators managing multiple environments (mainnet, testnet, devnet) can easily misconfigure chain_id values
2. **No Defense-in-Depth**: There's no validation at any layer - the system trusts the configured value completely
3. **Silent Failure**: The misconfiguration doesn't cause immediate errors; the service registers successfully and appears healthy
4. **Operational Scale**: Large indexer deployments with multiple data services increase the probability of misconfiguration

The attack requires no special privileges - any data service operator can trigger this through simple misconfiguration.

## Recommendation

Add chain_id validation in the MetadataManager's heartbeat handlers:

```rust
fn handle_live_data_service_info(
    &self,
    address: GrpcAddress,
    mut info: LiveDataServiceInfo,
) -> Result<()> {
    // Add chain_id validation
    if info.chain_id != self.chain_id {
        bail!(
            "Chain ID mismatch for live data service {}: expected {}, got {}",
            address,
            self.chain_id,
            info.chain_id
        );
    }
    
    let mut entry = self
        .live_data_services
        .entry(address.clone())
        .or_insert(LiveDataService::new(address));
    if info.stream_info.is_none() {
        info.stream_info = Some(StreamInfo {
            active_streams: vec![],
        });
    }
    entry.value_mut().recent_states.push_back(info);
    if entry.value().recent_states.len() > MAX_NUM_OF_STATES_TO_KEEP {
        entry.value_mut().recent_states.pop_front();
    }

    Ok(())
}

fn handle_historical_data_service_info(
    &self,
    address: GrpcAddress,
    mut info: HistoricalDataServiceInfo,
) -> Result<()> {
    // Add chain_id validation
    if info.chain_id != self.chain_id {
        bail!(
            "Chain ID mismatch for historical data service {}: expected {}, got {}",
            address,
            self.chain_id,
            info.chain_id
        );
    }
    
    let mut entry = self
        .historical_data_services
        .entry(address.clone())
        .or_insert(HistoricalDataService::new(address));
    if info.stream_info.is_none() {
        info.stream_info = Some(StreamInfo {
            active_streams: vec![],
        });
    }
    entry.value_mut().recent_states.push_back(info);
    if entry.value().recent_states.len() > MAX_NUM_OF_STATES_TO_KEEP {
        entry.value_mut().recent_states.pop_front();
    }

    Ok(())
}
```

Similarly, add validation in `handle_fullnode_info()` and `handle_grpc_manager_info()` for defense-in-depth.

## Proof of Concept

```rust
// Integration test demonstrating the vulnerability
// File: ecosystem/indexer-grpc/indexer-grpc-manager/tests/chain_id_mismatch_test.rs

use aptos_indexer_grpc_manager::metadata_manager::MetadataManager;
use aptos_protos::indexer::v1::{
    service_info::Info, HeartbeatRequest, LiveDataServiceInfo, ServiceInfo, StreamInfo,
};
use aptos_indexer_grpc_utils::timestamp_now_proto;

#[tokio::test]
async fn test_chain_id_mismatch_vulnerability() {
    // Setup: GrpcManager expects chain_id = 1 (mainnet)
    let mainnet_chain_id = 1u64;
    let metadata_manager = MetadataManager::new(
        mainnet_chain_id,
        "http://localhost:50051".to_string(),
        vec![],
        vec![],
        None,
    );

    // Attack: Malicious data service configured with chain_id = 2 (testnet)
    let testnet_chain_id = 2u64;
    let malicious_service_address = "http://malicious-service:50052".to_string();
    
    let malicious_info = Info::LiveDataServiceInfo(LiveDataServiceInfo {
        chain_id: testnet_chain_id, // WRONG CHAIN ID
        timestamp: Some(timestamp_now_proto()),
        known_latest_version: Some(1000),
        stream_info: Some(StreamInfo {
            active_streams: vec![],
        }),
        min_servable_version: Some(0),
    });

    // Vulnerability: This should FAIL but currently SUCCEEDS
    let result = metadata_manager.handle_heartbeat(
        malicious_service_address.clone(),
        malicious_info,
    );

    // BUG: The malicious service is registered despite chain_id mismatch
    assert!(result.is_ok(), "Service with wrong chain_id was accepted!");
    
    // Verify the service is now in the registered services list
    let services = metadata_manager.get_live_data_services_info();
    assert!(services.contains_key(&malicious_service_address));
    
    // This demonstrates that clients could now be routed to the wrong chain
    println!("VULNERABILITY CONFIRMED: Service with chain_id {} registered on manager expecting chain_id {}", 
             testnet_chain_id, mainnet_chain_id);
}
```

## Notes

This vulnerability highlights a critical gap in the indexer-grpc infrastructure's input validation. While the HistoricalDataService does validate chain_id when reading from file stores, there is no equivalent validation when services register via heartbeats. This creates an asymmetry where file-based data is protected but network-registered services are not, leading to a significant security gap in the distributed indexing architecture.

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/connection_manager.rs (L257-276)
```rust
        let info = if self.is_live_data_service {
            let min_servable_version = match LIVE_DATA_SERVICE.get() {
                Some(svc) => Some(svc.get_min_servable_version().await),
                None => None,
            };
            Some(Info::LiveDataServiceInfo(LiveDataServiceInfo {
                chain_id: self.chain_id,
                timestamp,
                known_latest_version,
                stream_info,
                min_servable_version,
            }))
        } else {
            Some(Info::HistoricalDataServiceInfo(HistoricalDataServiceInfo {
                chain_id: self.chain_id,
                timestamp,
                known_latest_version,
                stream_info,
            }))
        };
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/service.rs (L71-88)
```rust
    fn pick_live_data_service(&self, starting_version: u64) -> Option<String> {
        let mut candidates = vec![];
        for candidate in self.metadata_manager.get_live_data_services_info() {
            if let Some(info) = candidate.1.back().as_ref() {
                // TODO(grao): Handle the case when the requested starting version is beyond the
                // latest version.
                if info.min_servable_version.is_none()
                    || starting_version < info.min_servable_version.unwrap()
                {
                    continue;
                }
                let num_active_streams = info.stream_info.as_ref().unwrap().active_streams.len();
                candidates.push((candidate.0, num_active_streams));
            }
        }

        Self::pick_data_service_from_candidate(candidates)
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/service.rs (L90-105)
```rust
    async fn pick_historical_data_service(&self, starting_version: u64) -> Option<String> {
        let file_store_version = self.data_manager.get_file_store_version().await;
        if starting_version >= file_store_version {
            return None;
        }

        let mut candidates = vec![];
        for candidate in self.metadata_manager.get_historical_data_services_info() {
            if let Some(info) = candidate.1.back().as_ref() {
                let num_active_streams = info.stream_info.as_ref().unwrap().active_streams.len();
                candidates.push((candidate.0, num_active_streams));
            }
        }

        Self::pick_data_service_from_candidate(candidates)
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/service.rs (L110-127)
```rust
    async fn heartbeat(
        &self,
        request: Request<HeartbeatRequest>,
    ) -> Result<Response<HeartbeatResponse>, Status> {
        let request = request.into_inner();
        if let Some(service_info) = request.service_info {
            if let Some(address) = service_info.address {
                if let Some(info) = service_info.info {
                    return self
                        .handle_heartbeat(address, info)
                        .await
                        .map_err(|e| Status::internal(format!("Error handling heartbeat: {e}")));
                }
            }
        }

        Err(Status::invalid_argument("Bad request."))
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L127-138)
```rust
pub(crate) struct MetadataManager {
    chain_id: u64,
    self_advertised_address: GrpcAddress,
    grpc_managers: DashMap<GrpcAddress, Peer>,
    fullnodes: DashMap<GrpcAddress, Fullnode>,
    live_data_services: DashMap<GrpcAddress, LiveDataService>,
    historical_data_services: DashMap<GrpcAddress, HistoricalDataService>,
    known_latest_version: AtomicU64,
    // NOTE: We assume the master is statically configured for now.
    master_address: Mutex<Option<GrpcAddress>>,
}

```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L489-509)
```rust
    fn handle_live_data_service_info(
        &self,
        address: GrpcAddress,
        mut info: LiveDataServiceInfo,
    ) -> Result<()> {
        let mut entry = self
            .live_data_services
            .entry(address.clone())
            .or_insert(LiveDataService::new(address));
        if info.stream_info.is_none() {
            info.stream_info = Some(StreamInfo {
                active_streams: vec![],
            });
        }
        entry.value_mut().recent_states.push_back(info);
        if entry.value().recent_states.len() > MAX_NUM_OF_STATES_TO_KEEP {
            entry.value_mut().recent_states.pop_front();
        }

        Ok(())
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L511-531)
```rust
    fn handle_historical_data_service_info(
        &self,
        address: GrpcAddress,
        mut info: HistoricalDataServiceInfo,
    ) -> Result<()> {
        let mut entry = self
            .historical_data_services
            .entry(address.clone())
            .or_insert(HistoricalDataService::new(address));
        if info.stream_info.is_none() {
            info.stream_info = Some(StreamInfo {
                active_streams: vec![],
            });
        }
        entry.value_mut().recent_states.push_back(info);
        if entry.value().recent_states.len() > MAX_NUM_OF_STATES_TO_KEEP {
            entry.value_mut().recent_states.pop_front();
        }

        Ok(())
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/mod.rs (L199-206)
```rust
                let response = TransactionsResponse {
                    transactions,
                    chain_id: Some(self.chain_id),
                    processed_range: Some(ProcessedRange {
                        first_version: next_version,
                        last_version: last_processed_version,
                    }),
                };
```

**File:** protos/proto/aptos/indexer/v1/grpc.proto (L35-49)
```text
message LiveDataServiceInfo {
  uint64 chain_id = 1;
  optional aptos.util.timestamp.Timestamp timestamp = 2;
  optional uint64 known_latest_version = 3;
  optional StreamInfo stream_info = 4;
  // If not present, it means the data service is not available to serve anything yet.
  optional uint64 min_servable_version = 5;
}

message HistoricalDataServiceInfo {
  uint64 chain_id = 1;
  optional aptos.util.timestamp.Timestamp timestamp = 2;
  optional uint64 known_latest_version = 3;
  optional StreamInfo stream_info = 4;
}
```
