# Audit Report

## Title
Address Standardization Inconsistency in coin_infos Table Leading to Data Corruption and Query Failures

## Summary
The `coin_infos` table stores creator addresses without AIP-40 standardization, while other coin-related tables (`coin_activities`, `coin_balances`) normalize addresses using `standardize_address()`. This inconsistency causes the same logical address to be represented in different string formats across tables, leading to failed joins, potential duplicate entries, and data integrity violations.

## Finding Description

The vulnerability exists in how creator addresses are extracted and stored in the `coin_infos` table. The code directly uses the address string from the API without normalization: [1](#0-0) 

This creator_address is extracted from `coin_info_type.creator_address`, which is set directly from the API's address representation: [2](#0-1) 

The API serializes addresses using the `Display` trait implementation, which calls `to_hex_literal()`: [3](#0-2) 

This produces addresses with ALL leading zeros trimmed (e.g., "0x10" instead of the AIP-40 compliant long form "0x0000...0010"): [4](#0-3) 

**However, other coin-related tables DO normalize addresses** using the `standardize_address()` function, which implements AIP-40 compliance (SHORT form for special addresses 0x0-0xf, LONG form for all others): [5](#0-4) [6](#0-5) 

The `standardize_address()` function enforces AIP-40 format: [7](#0-6) 

**The Result**: For non-special addresses (â‰¥0x10), coin_infos stores them in short form (e.g., "0x10"), while coin_activities stores them in long form (e.g., "0x0000...0010"). This breaks the State Consistency invariant.

## Impact Explanation

This is a **Medium Severity** issue per Aptos bug bounty criteria: "State inconsistencies requiring intervention."

**Specific Impacts:**

1. **Failed Cross-Table Joins**: Queries joining `coin_infos` with `coin_activities` or `coin_balances` on creator/owner addresses will fail to match records for non-special addresses, producing incorrect results.

2. **Potential Duplicate Entries**: If data is imported from different sources (e.g., historical migrations, manual imports, alternative indexers) using AIP-40-compliant long-form addresses, the same logical coin creator could exist in multiple entries:
   - One with `creator_address = "0x10"` (from API)
   - One with `creator_address = "0x0000...0010"` (from standardized source)

3. **Index Inefficiency**: The database index on `(creator_address, name, symbol)` becomes fragmented with duplicate logical entries: [8](#0-7) 

4. **Analytics Corruption**: Any analytics, reporting, or UI queries filtering by creator_address will produce incomplete or incorrect results.

## Likelihood Explanation

**High Likelihood** - This issue is currently active in production code:

1. **Always Active**: Every coin creation transaction stores non-normalized addresses in `coin_infos`
2. **Cross-Table Inconsistency**: The discrepancy with `coin_activities` and `coin_balances` exists for all non-special addresses (0x10 and above)
3. **No Defensive Programming**: There's no validation or normalization at the database layer
4. **Data Source Variability**: Any historical data, migrations, or alternative indexer implementations could introduce AIP-40-compliant addresses, creating actual duplicates

## Recommendation

Normalize creator addresses using `standardize_address()` before storing in the `coin_infos` table to ensure consistency with other coin tables:

```rust
use crate::util::standardize_address;

impl CoinInfo {
    pub fn from_write_resource(
        write_resource: &APIWriteResource,
        txn_version: i64,
        txn_timestamp: chrono::NaiveDateTime,
    ) -> anyhow::Result<Option<Self>> {
        match &CoinResource::from_write_resource(write_resource, txn_version)? {
            Some(CoinResource::CoinInfoResource(inner)) => {
                let coin_info_type = &CoinInfoType::from_move_type(
                    &write_resource.data.typ.generic_type_params[0],
                    txn_version,
                )?;
                let (supply_aggregator_table_handle, supply_aggregator_table_key) = inner
                    .get_aggregator_metadata()
                    .map(|agg| (Some(agg.handle), Some(agg.key)))
                    .unwrap_or((None, None));

                Ok(Some(Self {
                    coin_type_hash: coin_info_type.to_hash(),
                    coin_type: coin_info_type.get_coin_type_trunc(),
                    transaction_version_created: txn_version,
                    // FIX: Normalize the creator address
                    creator_address: standardize_address(&coin_info_type.creator_address),
                    name: inner.get_name_trunc(),
                    symbol: inner.get_symbol_trunc(),
                    decimals: inner.decimals,
                    transaction_created_timestamp: txn_timestamp,
                    supply_aggregator_table_handle,
                    supply_aggregator_table_key,
                }))
            },
            _ => Ok(None),
        }
    }
}
```

**Additionally, run a migration** to standardize all existing creator_address values in the database:

```sql
UPDATE coin_infos 
SET creator_address = CASE 
    -- Special addresses (0x0 to 0xf): keep short form
    WHEN creator_address ~ '^0x[0-9a-f]$' THEN creator_address
    -- Non-special addresses: convert to long form
    ELSE '0x' || LPAD(SUBSTRING(creator_address FROM 3), 64, '0')
END
WHERE creator_address IS NOT NULL;
```

## Proof of Concept

**Scenario**: A coin is created by address `0x10` (non-special address).

**Step 1 - API Response**: The WriteResource contains the address in short form due to `to_hex_literal()`:
```
MoveStructTag { address: "0x10", module: "coin", name: "MyCoin" }
```

**Step 2 - coin_infos Storage**: The indexer stores it WITHOUT normalization:
```sql
INSERT INTO coin_infos (creator_address, ...) VALUES ('0x10', ...);
```

**Step 3 - coin_activities Storage**: The same address is normalized per AIP-40:
```sql
INSERT INTO coin_activities (owner_address, ...) 
VALUES ('0x0000000000000000000000000000000000000000000000000000000000000010', ...);
```

**Step 4 - Query Failure**: A join query fails to match:
```sql
SELECT ci.*, ca.* 
FROM coin_infos ci 
JOIN coin_activities ca ON ci.creator_address = ca.owner_address 
WHERE ci.coin_type LIKE '%MyCoin%';
-- Returns 0 rows despite the coin activity existing!
```

**Step 5 - Potential Duplicate**: If a migration or alternative indexer inserts using AIP-40 format:
```sql
INSERT INTO coin_infos (creator_address, coin_type, ...) 
VALUES ('0x0000000000000000000000000000000000000000000000000000000000000010', '0x10::coin::MyCoin', ...);
-- Now there are TWO entries for the same logical coin creator
```

This demonstrates concrete data corruption and query failures violating the State Consistency invariant.

## Notes

The vulnerability is exacerbated by the fact that the `standardize_address()` utility function already exists and is widely used throughout the indexer codebase, but was specifically omitted from the `coin_infos` implementation. This appears to be an oversight rather than an intentional design decision, making it a clear bug that requires fixing.

### Citations

**File:** crates/indexer/src/models/coin_models/coin_infos.rs (L70-70)
```rust
                    creator_address: coin_info_type.creator_address.clone(),
```

**File:** crates/indexer/src/models/coin_models/coin_utils.rs (L148-166)
```rust
    pub fn from_move_type(move_type: &MoveType, txn_version: i64) -> anyhow::Result<Self> {
        let coin_type = move_type.to_string();
        let (address, _, _) = if let MoveType::Struct(inner) = move_type {
            (
                inner.address.to_string(),
                inner.module.to_string(),
                inner.name.to_string(),
            )
        } else {
            Err(anyhow::anyhow!(
                "MoveType is not a struct: {:?}, version: {}",
                move_type,
                txn_version
            ))?
        };
        Ok(Self {
            coin_type,
            creator_address: address,
        })
```

**File:** api/types/src/address.rs (L40-48)
```rust
impl fmt::Display for Address {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        // While the inner type, AccountAddress, has a Display impl already, we don't
        // use it. As part of the AIP-40 migration, the Display impl of the inner
        // AccountAddress was changed to conform to AIP-40, but doing that for the API
        // would constitute a breaking change. So we keep an explicit display impl
        // here that maintains the existing address formatting behavior.
        write!(f, "{}", self.0.to_hex_literal())
    }
```

**File:** third_party/move/move-core/types/src/account_address.rs (L138-145)
```rust
    pub fn short_str_lossless(&self) -> String {
        let hex_str = hex::encode(self.0).trim_start_matches('0').to_string();
        if hex_str.is_empty() {
            "0".to_string()
        } else {
            hex_str
        }
    }
```

**File:** crates/indexer/src/models/coin_models/coin_activities.rs (L237-240)
```rust
            event_account_address: standardize_address(&event.guid.account_address.to_string()),
            event_creation_number: event.guid.creation_number.0 as i64,
            event_sequence_number: event.sequence_number.0 as i64,
            owner_address: standardize_address(&event.guid.account_address.to_string()),
```

**File:** crates/indexer/src/models/coin_models/coin_activities.rs (L264-269)
```rust
            event_account_address: standardize_address(
                &user_transaction_request.sender.to_string(),
            ),
            event_creation_number: BURN_GAS_EVENT_CREATION_NUM,
            event_sequence_number: user_transaction_request.sequence_number.0 as i64,
            owner_address: standardize_address(&user_transaction_request.sender.to_string()),
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/utils.rs (L10-36)
```rust
pub fn standardize_address(address: &str) -> String {
    // Remove "0x" prefix if it exists
    let trimmed = address.strip_prefix("0x").unwrap_or(address);

    // Check if the address is a special address by seeing if the first 31 bytes are zero and the last byte is smaller than 0b10000
    if let Some(last_char) = trimmed.chars().last() {
        if trimmed[..trimmed.len().saturating_sub(1)]
            .chars()
            .all(|c| c == '0')
            && last_char.is_ascii_hexdigit()
            && last_char <= 'f'
        {
            // Return special addresses in short format
            let mut result = String::with_capacity(3);
            result.push_str("0x");
            result.push(last_char);
            return result;
        }
    }

    // Return non-special addresses in long format
    let mut result = String::with_capacity(66);
    result.push_str("0x");
    result.push_str(&ZEROS[..64 - trimmed.len()]);
    result.push_str(trimmed);
    result
}
```

**File:** crates/indexer/migrations/2022-10-04-073529_add_coin_tables/up.sql (L51-51)
```sql
CREATE INDEX ci_ca_name_symbol_index on coin_infos (creator_address, name, symbol);
```
