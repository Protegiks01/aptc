# Audit Report

## Title
DKG Metrics Panic During Epoch Transition Causes Network Liveness Failure

## Summary
The `DKG_STAGE_SECONDS` histogram metric uses `Lazy` initialization with `.unwrap()` on the Prometheus registration result. If registration fails (e.g., due to `AlreadyReg` errors from dependency cycles), the panic occurs during first access. When this first access happens in `process_close_cmd()` during epoch transitions, it crashes the DKGManager task and blocks the epoch manager's shutdown sequence, preventing the network from transitioning to new epochs. [1](#0-0) 

## Finding Description

The DKG system uses Prometheus metrics to track stage durations. The `DKG_STAGE_SECONDS` metric is defined as a `Lazy` static that registers a histogram vector with Prometheus on first access. The registration uses `.unwrap()` which will panic if registration fails. [1](#0-0) 

During epoch transitions, the DKG epoch manager calls `shutdown_current_processor()` to cleanly shut down the current DKG manager before starting the new epoch's manager: [2](#0-1) 

The shutdown process sends a close command via a oneshot channel and waits for acknowledgment: [3](#0-2) 

The DKGManager's `process_close_cmd()` method handles this close command and accesses `DKG_STAGE_SECONDS` to record epoch change timing: [4](#0-3) 

**The vulnerability chain:**

1. If `DKG_STAGE_SECONDS` has not been accessed yet when `process_close_cmd()` is called
2. And if `register_histogram_vec!()` fails due to registry issues (AlreadyReg, corruption, etc.)
3. The `.unwrap()` panics, crashing the DKGManager task
4. The epoch manager's `ack_rx.await` never completes (sender dropped)
5. The epoch transition is permanently blocked

The codebase explicitly documents that AlreadyReg errors occur due to dependency cycles causing static variables to have multiple instances: [5](#0-4) 

The correct pattern for handling registration failures exists elsewhere in the codebase using `unwrap_or_else()` with logging: [6](#0-5) 

## Impact Explanation

**Severity: Medium** - This meets the "State inconsistencies requiring intervention" category from the Aptos bug bounty program.

When this panic occurs during an epoch transition, the entire DKG subsystem becomes stuck:
- The current epoch cannot complete its transition
- New DKG sessions cannot start
- Randomness generation is blocked
- If multiple validators are affected, the network's randomness feature becomes unavailable

The impact is limited to **liveness/availability** rather than safety - no funds are at risk, no consensus splits occur. However, it requires manual intervention (node restart) to recover, and if widespread, could impact network operations requiring randomness.

## Likelihood Explanation

**Likelihood: Low to Medium**

This is **NOT exploitable by external attackers** - they have no control over the Prometheus registry state or metric initialization. 

However, it can occur due to:

1. **Dependency cycles** (documented in the codebase) causing duplicate static initialization
2. **Test environments** where the same process runs multiple test cases
3. **Code changes** that introduce circular dependencies
4. **Edge cases** during node restarts or upgrades with improper cleanup
5. **Memory corruption** in rare failure scenarios

The codebase evidence shows this is a known issue pattern that has affected other parts of the system. [5](#0-4) 

## Recommendation

Replace `.unwrap()` with graceful error handling following the pattern used in `node-resource-metrics`:

```rust
pub static DKG_STAGE_SECONDS: Lazy<HistogramVec> = Lazy::new(|| {
    register_histogram_vec!(
        "aptos_dkg_session_stage_seconds",
        "How long it takes to reach different DKG stages",
        &["dealer", "stage"]
    )
    .unwrap_or_else(|e| {
        aptos_logger::warn!("Failed to register DKG_STAGE_SECONDS metric: {}", e);
        // Return a no-op histogram that won't panic
        HistogramVec::new(
            histogram_opts!("aptos_dkg_session_stage_seconds_fallback", "fallback"),
            &["dealer", "stage"]
        ).unwrap()
    })
});
```

Alternatively, add defensive initialization early in the DKG runtime startup to ensure the metric is registered before any epoch transitions: [7](#0-6) 

The `PENDING_SELF_MESSAGES` counter is already accessed during initialization. Add `DKG_STAGE_SECONDS` access there as well.

## Proof of Concept

This issue is difficult to trigger externally but can be demonstrated in a test environment:

```rust
#[test]
fn test_dkg_metrics_panic_blocks_epoch_transition() {
    // Simulate AlreadyReg by registering the metric twice in the same process
    // This would require modifying the test to create a dependency cycle
    // or manually register a conflicting metric name
    
    // 1. Pre-register a conflicting metric with same name but different labels
    let conflicting = register_histogram_vec!(
        "aptos_dkg_session_stage_seconds",
        "conflict",
        &["different_label"]
    ).unwrap();
    
    // 2. Create DKG manager and trigger epoch transition
    // 3. The first access to DKG_STAGE_SECONDS in process_close_cmd() will panic
    // 4. The epoch manager's shutdown_current_processor() will hang indefinitely
}
```

The practical demonstration requires creating conditions that cause `register_histogram_vec!()` to fail, which is most easily done through dependency cycles or duplicate registration attempts in test scenarios.

## Notes

This is primarily an **internal resilience issue** rather than an externally exploitable vulnerability. It represents a failure mode that could occur due to code defects, dependency issues, or edge cases in node operations, but cannot be triggered by malicious external actors. The fix is straightforward and follows existing patterns in the codebase for robust metric registration.

### Citations

**File:** dkg/src/counters.rs (L16-23)
```rust
pub static DKG_STAGE_SECONDS: Lazy<HistogramVec> = Lazy::new(|| {
    register_histogram_vec!(
        "aptos_dkg_session_stage_seconds",
        "How long it takes to reach different DKG stages",
        &["dealer", "stage"]
    )
    .unwrap()
});
```

**File:** dkg/src/epoch_manager.rs (L263-268)
```rust
    async fn on_new_epoch(&mut self, reconfig_notification: ReconfigNotification<P>) -> Result<()> {
        self.shutdown_current_processor().await;
        self.start_new_epoch(reconfig_notification.on_chain_configs)
            .await?;
        Ok(())
    }
```

**File:** dkg/src/epoch_manager.rs (L270-275)
```rust
    async fn shutdown_current_processor(&mut self) {
        if let Some(tx) = self.dkg_manager_close_tx.take() {
            let (ack_tx, ack_rx) = oneshot::channel();
            tx.send(ack_tx).unwrap();
            ack_rx.await.unwrap();
        }
```

**File:** dkg/src/dkg_manager/mod.rs (L229-242)
```rust
            } => {
                let epoch_change_time = duration_since_epoch();
                let secs_since_dkg_start =
                    epoch_change_time.as_secs_f64() - start_time.as_secs_f64();
                DKG_STAGE_SECONDS
                    .with_label_values(&[self.my_addr.to_hex().as_str(), "epoch_change"])
                    .observe(secs_since_dkg_start);
                info!(
                    epoch = self.epoch_state.epoch,
                    my_addr = self.my_addr,
                    secs_since_dkg_start = secs_since_dkg_start,
                    "[DKG] txn executed and entering new epoch.",
                );

```

**File:** aptos-move/aptos-vm/tests/sharded_block_executor.rs (L6-9)
```rust
/// It has to be integration tests because otherwise it forms an indirect dependency circle between
/// aptos-vm and aptos-language-e2e-tests, which causes static variables to have two instances in
/// the same process while testing, resulting in the counters failing to register with "AlreadyReg"
/// error.
```

**File:** crates/node-resource-metrics/src/lib.rs (L45-49)
```rust
pub fn register_collector(c: Box<dyn Collector>) {
    // If not okay, then log the error and continue.
    prometheus::register(c).unwrap_or_else(|e| {
        warn!("Failed to register collector: {}", e);
    });
```

**File:** dkg/src/lib.rs (L36-38)
```rust
) -> Runtime {
    let runtime = aptos_runtimes::spawn_named_runtime("dkg".into(), Some(4));
    let (self_sender, self_receiver) = aptos_channels::new(1_024, &counters::PENDING_SELF_MESSAGES);
```
