# Audit Report

## Title
Index Invalidation Bug in Subscriber Eviction Causes Node Panics During Concurrent Channel Closures

## Summary
The `broadcast()` function in `PeersAndMetadata` contains a critical implementation bug where it collects indices of closed subscribers and then attempts to remove them using `swap_remove()` in ascending order. This invalidates subsequent indices, leading to out-of-bounds panics when multiple subscribers close simultaneously, or incorrect eviction of active subscribers. [1](#0-0) 

## Finding Description

The vulnerability exists in the subscriber eviction logic. The function iterates through all subscribers, collecting indices of those with closed channels into a `to_del` vector. It then attempts to remove these subscribers using `swap_remove()` in the order collected (ascending indices). [2](#0-1) 

The critical flaw: `Vec::swap_remove()` swaps the element at the given index with the last element, then removes the last element. This operation changes both the length and the positions of elements in the vector, invalidating all subsequent indices in the `to_del` vector.

**Concrete Exploit Scenario:**

Initial state: Subscribers `[A, B, C, D, E]` at indices `[0, 1, 2, 3, 4]`

During broadcast, subscribers at indices 1, 2, and 4 have closed channels.
Result: `to_del = [1, 2, 4]`

Execution of eviction loop:
1. `swap_remove(1)`: Swaps index 1 with index 4, removes last → Vector becomes `[A, E, C, D]` (length 4)
2. `swap_remove(2)`: Swaps index 2 with index 3, removes last → Vector becomes `[A, E, D]` (length 3)  
3. `swap_remove(4)`: **PANIC** - Index 4 is out of bounds (vector length is only 3)

This causes an immediate node crash.

**Secondary Issue - Incorrect Eviction:**

Even when panic doesn't occur, the bug causes incorrect evictions. In the example above, subscriber E (originally at index 4, which was marked as closed) gets moved to index 1 during the first `swap_remove()` and is never actually removed from the subscribers list. This causes memory leaks and continued message delivery to closed channels.

The correct pattern for removing multiple indices is demonstrated elsewhere in the codebase in `RepeatVec::remove_all()`: [3](#0-2) 

This shows that indices should be sorted and deduplicated before removal, and removals should be done from highest to lowest index (reverse order) to prevent invalidation.

## Impact Explanation

**Severity: Medium to High**

This bug can cause validator node crashes during normal operational scenarios:

1. **Node Availability**: When multiple subscribers close simultaneously (e.g., during graceful shutdown, network reconfiguration, or component failures), the node will panic and crash. This affects validator uptime and network reliability.

2. **Component Isolation**: Critical components like consensus, mempool, and state sync subscribe to peer connection notifications. If incorrectly evicted due to this bug, they lose visibility into network topology changes, potentially affecting consensus liveness and state synchronization.

3. **Memory Leaks**: Subscribers that should be removed remain in the vector, preventing garbage collection and causing slow memory growth over time.

According to Aptos bug bounty criteria, this qualifies as **High Severity** under "API crashes" and "Validator node slowdowns", though the exploitability by an external attacker is limited since they cannot directly force multiple subscribers to close.

## Likelihood Explanation

**Likelihood: Medium**

This bug will trigger under the following scenarios:

1. **Graceful Node Shutdown**: When a validator shuts down gracefully, multiple components may drop their subscription receivers simultaneously, triggering the panic.

2. **Network Reconfiguration**: During epoch transitions or network reconfigurations when multiple services restart.

3. **Component Failures**: If multiple components crash or encounter errors simultaneously, their receivers will be dropped.

4. **High Load Conditions**: Under network stress, components may fail or restart, increasing the probability of concurrent channel closures.

The bug is NOT directly exploitable by an external attacker who cannot control when internal components close their subscription channels. However, it will occur naturally during operational scenarios, making it a reliability and availability issue rather than a direct security attack vector.

## Recommendation

**Fix: Remove indices in reverse order to prevent invalidation**

Replace the eviction loop with:

```rust
// Sort indices in descending order before removal
to_del.sort_unstable();
for evict in to_del.into_iter().rev() {
    listeners.swap_remove(evict);
}
```

Or alternatively, use a more robust approach that adjusts indices:

```rust
// Remove from highest to lowest index
to_del.sort_unstable();
to_del.dedup();
for &evict in to_del.iter().rev() {
    if evict < listeners.len() {
        listeners.swap_remove(evict);
    }
}
```

## Proof of Concept

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use tokio::sync::mpsc;

    #[tokio::test]
    async fn test_multiple_subscriber_eviction_panic() {
        // Create PeersAndMetadata with a test network
        let peers_and_metadata = PeersAndMetadata::new(&[NetworkId::Validator]);
        
        // Subscribe 5 times
        let mut receivers = vec![];
        for _ in 0..5 {
            receivers.push(peers_and_metadata.subscribe());
        }
        
        // Drop receivers at indices 1, 2, and 4 to simulate closed channels
        drop(receivers.remove(4)); // Drop index 4
        drop(receivers.remove(2)); // Drop index 2  
        drop(receivers.remove(1)); // Drop index 1
        
        // Trigger a broadcast - this should panic with "index out of bounds"
        let metadata = ConnectionMetadata::mock(PeerId::random());
        peers_and_metadata.insert_connection_metadata(
            PeerNetworkId::new(NetworkId::Validator, metadata.remote_peer_id),
            metadata,
        ).unwrap();
        
        // If we reach here without panic, the bug is fixed
        // If panic occurs, it demonstrates the vulnerability
    }
}
```

## Notes

While this is a genuine implementation bug that causes node crashes, it does not meet the threshold for Critical or High severity exploitation by an **untrusted external attacker** as defined in the trust model. The bug triggers during internal operational scenarios (shutdown, reconfiguration) rather than through external malicious input.

However, it represents a significant operational risk that could affect validator reliability and network availability, warranting immediate fix as part of defensive programming practices. The bug may be reportable under the Low to Medium severity category depending on the bug bounty program's criteria for operational/reliability issues.

### Citations

**File:** network/framework/src/application/storage.rs (L371-395)
```rust
    fn broadcast(&self, event: ConnectionNotification) {
        let mut listeners = self.subscribers.lock();
        let mut to_del = vec![];
        for i in 0..listeners.len() {
            let dest = listeners.get_mut(i).unwrap();
            if let Err(err) = dest.try_send(event.clone()) {
                match err {
                    TrySendError::Full(_) => {
                        // Tried to send to an app, but the app isn't handling its messages fast enough.
                        // Drop message. Maybe increment a metrics counter?
                        sample!(
                            SampleRate::Duration(Duration::from_secs(1)),
                            warn!("PeersAndMetadata.broadcast() failed, some app is slow"),
                        );
                    },
                    TrySendError::Closed(_) => {
                        to_del.push(i);
                    },
                }
            }
        }
        for evict in to_del.into_iter() {
            listeners.swap_remove(evict);
        }
    }
```

**File:** crates/aptos-proptest-helpers/src/repeat_vec.rs (L122-126)
```rust
    pub fn remove_all(&mut self, logical_indexes: impl IntoIterator<Item = usize>) {
        let mut logical_indexes: Vec<_> = logical_indexes.into_iter().collect();
        logical_indexes.sort_unstable();
        logical_indexes.dedup();
        self.remove_all_impl(logical_indexes)
```
