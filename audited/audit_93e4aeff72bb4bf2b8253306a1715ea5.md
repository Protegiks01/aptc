# Audit Report

## Title
Missing Validation on `sender_max_num_batches` Enables Memory Exhaustion DoS via Batch Explosion

## Summary
The `QuorumStoreConfig::sanitize()` method lacks validation for the `sender_max_num_batches` parameter, allowing validators to configure it to extremely large values (e.g., `usize::MAX`). When combined with small `sender_max_batch_txns` and large `sender_max_total_txns`, this causes the batch generator to create hundreds of thousands of tiny batches in memory before any quota checks, leading to memory exhaustion and validator node crashes.

## Finding Description

The vulnerability exists in the configuration validation logic for the Quorum Store batch generation system. [1](#0-0) 

The `ConfigSanitizer` implementation only validates sender/receiver consistency and batch/total consistency, but never validates whether `sender_max_num_batches` itself is within safe bounds. [2](#0-1) 

The batch generation logic uses `sender_max_num_batches` directly without additional checks: [3](#0-2) 

When `sender_max_num_batches` is set to `usize::MAX`, the batch creation loop at line 226-252 will continue creating batches limited only by `sender_max_total_txns` divided by `sender_max_batch_txns`. All batches are stored in a memory vector before any persistence or quota validation occurs: [4](#0-3) [5](#0-4) 

The quota enforcement only happens during persistence, AFTER all batches are created in memory: [6](#0-5) [7](#0-6) 

**Attack Scenario:**
1. Validator operator (accidentally or intentionally) configures:
   - `sender_max_num_batches: usize::MAX` (no upper bound)
   - `sender_max_batch_txns: 1` (tiny batches)
   - `sender_max_total_txns: 100000` (large transaction pull)
   
2. Every batch generation cycle (25ms interval):
   - Pull up to 100,000 transactions from mempool
   - Create up to 100,000 separate Batch objects in memory
   - Each Batch contains SignedTransaction payload (~500 bytes minimum)
   - Total memory allocation: ~50-100 MB per cycle BEFORE any validation
   
3. Over multiple cycles:
   - Memory accumulates as batches await persistence
   - Eventually exceeds available RAM
   - Validator process crashes with OOM (Out Of Memory)

While other validators would reject oversized batch messages due to receiver-side validation, the misconfigured validator has already crashed from memory exhaustion during batch creation. [8](#0-7) 

## Impact Explanation

This is a **High Severity** vulnerability per Aptos bug bounty criteria:

1. **Validator node slowdowns/crashes** (High Severity - explicitly listed): A misconfigured validator will experience severe memory thrashing and eventual OOM crash, causing complete unavailability.

2. **Network liveness impact**: If multiple validators are misconfigured or if a critical validator crashes, consensus liveness may be affected.

3. **Storage exhaustion**: The batch quota system (300,000 batches, 300MB) will be rapidly exhausted, further degrading validator performance. [9](#0-8) 

4. **Self-DoS with network consequences**: While the network has a 64 MiB message size limit that provides some protection, the validator has already crashed before attempting broadcast. [10](#0-9) 

## Likelihood Explanation

**Likelihood: Medium**

This vulnerability can occur through:
- **Honest misconfiguration**: Validator operator makes a typo or misunderstands the configuration parameters
- **Copy-paste errors**: Copying configuration snippets without understanding safe ranges
- **Testing configurations**: Accidentally deploying test configurations with extreme values to production

The lack of validation makes this a "sharp edge" in the configuration API where a simple mistake causes catastrophic failure. Well-designed systems should validate and reject obviously dangerous configurations at startup, not allow them to cause runtime crashes.

## Recommendation

Add explicit validation for `sender_max_num_batches` and `sender_max_total_txns` in the sanitization logic to prevent unreasonably large values:

```rust
fn sanitize_batch_count_limits(
    sanitizer_name: &str,
    config: &QuorumStoreConfig,
) -> Result<(), Error> {
    // Reasonable upper bound: enough to split sender_max_total_txns
    // into single-transaction batches, but capped at a safe maximum
    let max_safe_num_batches = std::cmp::min(
        config.sender_max_total_txns * 2, // 2x headroom
        10_000 // Absolute safety cap
    );
    
    if config.sender_max_num_batches > max_safe_num_batches {
        return Err(Error::ConfigSanitizerFailed(
            sanitizer_name.to_owned(),
            format!(
                "sender_max_num_batches {} exceeds safe limit {}",
                config.sender_max_num_batches,
                max_safe_num_batches
            ),
        ));
    }
    
    // Also validate sender_max_total_txns is reasonable
    const MAX_SAFE_TOTAL_TXNS: usize = 1_000_000;
    if config.sender_max_total_txns > MAX_SAFE_TOTAL_TXNS {
        return Err(Error::ConfigSanitizerFailed(
            sanitizer_name.to_owned(),
            format!(
                "sender_max_total_txns {} exceeds safe limit {}",
                config.sender_max_total_txns,
                MAX_SAFE_TOTAL_TXNS
            ),
        ));
    }
    
    Ok(())
}

impl ConfigSanitizer for QuorumStoreConfig {
    fn sanitize(
        node_config: &NodeConfig,
        _node_type: NodeType,
        _chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();
        
        Self::sanitize_send_recv_batch_limits(&sanitizer_name, &node_config.consensus.quorum_store)?;
        Self::sanitize_batch_total_limits(&sanitizer_name, &node_config.consensus.quorum_store)?;
        Self::sanitize_batch_count_limits(&sanitizer_name, &node_config.consensus.quorum_store)?; // NEW
        
        Ok(())
    }
}
```

## Proof of Concept

```rust
#[cfg(test)]
mod test {
    use super::*;
    use crate::config::ConsensusConfig;

    #[test]
    fn test_excessive_sender_max_num_batches() {
        // Create a node config with dangerously large sender_max_num_batches
        let node_config = NodeConfig {
            consensus: ConsensusConfig {
                quorum_store: QuorumStoreConfig {
                    sender_max_num_batches: usize::MAX,
                    sender_max_batch_txns: 1,
                    sender_max_total_txns: 100_000,
                    ..Default::default()
                },
                ..Default::default()
            },
            ..Default::default()
        };

        // This should fail validation but currently doesn't
        let result = QuorumStoreConfig::sanitize(
            &node_config,
            NodeType::Validator,
            Some(ChainId::mainnet()),
        );
        
        // CURRENT BEHAVIOR: Passes validation (vulnerability)
        assert!(result.is_ok()); // This demonstrates the bug
        
        // EXPECTED BEHAVIOR: Should fail with ConfigSanitizerFailed error
        // assert!(matches!(result, Err(Error::ConfigSanitizerFailed(_, _))));
    }

    #[test]
    fn test_memory_exhaustion_simulation() {
        // Simulate what happens during batch generation
        let config = QuorumStoreConfig {
            sender_max_num_batches: usize::MAX,
            sender_max_batch_txns: 1,
            sender_max_total_txns: 100_000,
            ..Default::default()
        };
        
        // Calculate potential batch count
        let max_batches_remaining = config.sender_max_num_batches as u64;
        let num_transactions = 100_000;
        let txns_per_batch = config.sender_max_batch_txns;
        
        let potential_batches = num_transactions / txns_per_batch;
        
        // This would create 100,000 batches in a single cycle
        assert_eq!(potential_batches, 100_000);
        assert!(max_batches_remaining >= potential_batches as u64);
        
        // Each batch is approximately 500 bytes minimum
        // Total memory: 100,000 * 500 = 50 MB per cycle
        // This will rapidly exhaust memory over multiple cycles
    }
}
```

## Notes

This vulnerability breaks the **Resource Limits** invariant (Invariant #9) which states: "All operations must respect gas, storage, and computational limits." The system fails to enforce reasonable limits on batch creation, allowing unbounded memory allocation that can crash validator nodes.

The issue is particularly insidious because the quota enforcement mechanisms (`batch_quota`, `memory_quota`, `db_quota`) only activate during persistence, not during batch creation in memory. By the time these safeguards trigger, the damage (memory exhaustion) has already occurred.

### Citations

**File:** config/src/config/quorum_store_config.rs (L133-135)
```rust
            memory_quota: 120_000_000,
            db_quota: 300_000_000,
            batch_quota: 300_000,
```

**File:** config/src/config/quorum_store_config.rs (L178-250)
```rust
    fn sanitize_send_recv_batch_limits(
        sanitizer_name: &str,
        config: &QuorumStoreConfig,
    ) -> Result<(), Error> {
        let send_recv_pairs = [
            (
                config.sender_max_batch_txns,
                config.receiver_max_batch_txns,
                "txns",
            ),
            (
                config.sender_max_batch_bytes,
                config.receiver_max_batch_bytes,
                "bytes",
            ),
            (
                config.sender_max_total_txns,
                config.receiver_max_total_txns,
                "total_txns",
            ),
            (
                config.sender_max_total_bytes,
                config.receiver_max_total_bytes,
                "total_bytes",
            ),
        ];
        for (send, recv, label) in &send_recv_pairs {
            if *send > *recv {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name.to_owned(),
                    format!("Failed {}: {} > {}", label, *send, *recv),
                ));
            }
        }
        Ok(())
    }

    fn sanitize_batch_total_limits(
        sanitizer_name: &str,
        config: &QuorumStoreConfig,
    ) -> Result<(), Error> {
        let batch_total_pairs = [
            (
                config.sender_max_batch_txns,
                config.sender_max_total_txns,
                "send_txns",
            ),
            (
                config.sender_max_batch_bytes,
                config.sender_max_total_bytes,
                "send_bytes",
            ),
            (
                config.receiver_max_batch_txns,
                config.receiver_max_total_txns,
                "recv_txns",
            ),
            (
                config.receiver_max_batch_bytes,
                config.receiver_max_total_bytes,
                "recv_bytes",
            ),
        ];
        for (batch, total, label) in &batch_total_pairs {
            if *batch > *total {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name.to_owned(),
                    format!("Failed {}: {} > {}", label, *batch, *total),
                ));
            }
        }
        Ok(())
    }
```

**File:** config/src/config/quorum_store_config.rs (L253-271)
```rust
impl ConfigSanitizer for QuorumStoreConfig {
    fn sanitize(
        node_config: &NodeConfig,
        _node_type: NodeType,
        _chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();

        // Sanitize the send/recv batch limits
        Self::sanitize_send_recv_batch_limits(
            &sanitizer_name,
            &node_config.consensus.quorum_store,
        )?;

        // Sanitize the batch total limits
        Self::sanitize_batch_total_limits(&sanitizer_name, &node_config.consensus.quorum_store)?;

        Ok(())
    }
```

**File:** consensus/src/quorum_store/batch_generator.rs (L247-248)
```rust
                let batch = self.create_new_batch(batch_txns, expiry_time, bucket_start);
                batches.push(batch);
```

**File:** consensus/src/quorum_store/batch_generator.rs (L273-273)
```rust
        let mut max_batches_remaining = self.config.sender_max_num_batches as u64;
```

**File:** consensus/src/quorum_store/batch_generator.rs (L274-274)
```rust
        let mut batches = vec![];
```

**File:** consensus/src/quorum_store/batch_generator.rs (L491-491)
```rust
                            self.batch_writer.persist(persist_requests);
```

**File:** consensus/src/quorum_store/batch_store.rs (L64-84)
```rust
    pub(crate) fn update_quota(&mut self, num_bytes: usize) -> anyhow::Result<StorageMode> {
        if self.batch_balance == 0 {
            counters::EXCEEDED_BATCH_QUOTA_COUNT.inc();
            bail!("Batch quota exceeded ");
        }

        if self.db_balance >= num_bytes {
            self.batch_balance -= 1;
            self.db_balance -= num_bytes;

            if self.memory_balance >= num_bytes {
                self.memory_balance -= num_bytes;
                Ok(StorageMode::MemoryAndPersisted)
            } else {
                Ok(StorageMode::PersistedOnly)
            }
        } else {
            counters::EXCEEDED_STORAGE_QUOTA_COUNT.inc();
            bail!("Storage quota exceeded ");
        }
    }
```

**File:** consensus/src/quorum_store/types.rs (L440-445)
```rust
        ensure!(
            self.batches.len() <= max_num_batches,
            "Too many batches: {} > {}",
            self.batches.len(),
            max_num_batches
        );
```

**File:** config/src/config/network_config.rs (L50-50)
```rust
pub const MAX_MESSAGE_SIZE: usize = 64 * 1024 * 1024; /* 64 MiB */
```
