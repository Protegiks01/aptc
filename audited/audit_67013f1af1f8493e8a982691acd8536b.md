# Audit Report

## Title
Information Leak via Debug Formatting in Secret Sharing Network Message Deserialization

## Summary
The `from_network_message()` function in the secret sharing protocol exposes potentially sensitive transaction data through error messages when receiving malformed network messages. When a wrong `ConsensusMsg` variant is received, the error includes the full Debug representation of the message, which can leak transaction payloads, signatures, and other consensus data.

## Finding Description

The vulnerability exists in the `SecretShareMessage::from_network_message()` implementation where error handling uses Debug formatting on the entire `ConsensusMsg` enum. [1](#0-0) 

When a malicious peer sends an unexpected message type (e.g., `ConsensusMsg::BatchMsg` instead of `ConsensusMsg::SecretShareMsg`) in response to a secret sharing RPC request, the error message includes `{:?}` formatting of the entire message. 

The `ConsensusMsg` enum derives Debug without custom implementation: [2](#0-1) 

Several message variants contain sensitive transaction data. For example, `BatchMsg<T>` contains batches of transactions: [3](#0-2) 

The `Batch` struct contains `BatchPayload`: [4](#0-3) 

And `BatchPayload` exposes full transaction data through Debug: [5](#0-4) 

The `SignedTransaction` Debug implementation exposes raw transaction details and authenticators: [6](#0-5) 

The error is propagated through RPC response handling and logged: [7](#0-6) 

## Impact Explanation

This issue is correctly classified as **Low Severity** per the Aptos bug bounty program criteria (Minor information leaks, up to $1,000). While transaction payloads are exposed in error messages, the impact is limited because:

1. The information leaked (transaction contents) becomes public once included in blocks
2. No private keys or secret cryptographic material is exposed
3. Secret share data itself has protective Debug implementations that truncate to 20 bytes
4. The attack requires network peer access to send malformed responses

However, this could enable:
- Front-running attacks by observing transactions before finalization
- MEV (Maximal Extractable Value) exploitation
- Privacy reduction for transactions in flight
- Information gathering from node logs during debugging

## Likelihood Explanation

**Likelihood: Medium to Low**

The attack requires:
1. Attacker must be a network peer capable of sending RPC responses
2. Victim node must initiate an RPC request to the attacker
3. Attacker intentionally sends wrong message type
4. Access to victim's log files or error reporting systems

While technically feasible, the attack provides limited value since transaction data becomes public shortly after. The primary risk is in environments where logs are shared with untrusted parties or where pre-transaction information is valuable for MEV.

## Recommendation

Implement a custom Debug trait for `ConsensusMsg` that sanitizes sensitive data, or avoid including the full message in error outputs. Specifically:

1. **Option 1 - Sanitized Error Messages**: Only log the message type name, not the full contents:

```rust
fn from_network_message(msg: ConsensusMsg) -> anyhow::Result<Self> {
    match msg {
        ConsensusMsg::SecretShareMsg(msg) => Ok(bcs::from_bytes(&msg.data)?),
        _ => bail!("unexpected consensus message type: {}", msg.name()),
    }
}
```

2. **Option 2 - Custom Debug for ConsensusMsg**: Implement a custom Debug that truncates or omits sensitive fields for all variants containing transaction data.

3. **Option 3 - Structured Logging**: Use structured logging that separates message metadata from payload, and only log metadata in error cases.

The same issue exists in the RandGen message handler: [8](#0-7) 

## Proof of Concept

```rust
// Proof of concept demonstrating the information leak
use consensus::network_interface::ConsensusMsg;
use consensus::rand::secret_sharing::network_messages::SecretShareMessage;
use consensus::network::TConsensusMsg;
use consensus::quorum_store::types::{Batch, BatchMsg};
use aptos_types::transaction::SignedTransaction;

// Simulate a malicious peer sending BatchMsg instead of SecretShareMsg
fn exploit_info_leak() {
    // Attacker crafts a BatchMsg with transactions
    let malicious_batch = create_batch_with_sensitive_txns();
    let wrong_msg = ConsensusMsg::BatchMsg(Box::new(
        BatchMsg::new(vec![malicious_batch])
    ));
    
    // When victim tries to deserialize expecting SecretShareMsg
    let result = SecretShareMessage::from_network_message(wrong_msg);
    
    // Error message contains full transaction details:
    // "unexpected consensus message type BatchMsg { batches: [Batch { 
    //   batch_info: ..., payload: BatchPayload { txns: [SignedTransaction { 
    //   raw_txn: RawTransaction { sender: 0x123..., payload: EntryFunction { ... }, 
    //   ... }] }] }"
    assert!(result.is_err());
    let error_msg = result.unwrap_err().to_string();
    
    // Attacker can extract transaction details from logs
    assert!(error_msg.contains("SignedTransaction"));
}
```

## Notes

- The same pattern exists in `RandMessage::from_network_message()` for randomness generation messages
- While `RandGenMessage` and `SecretShareNetworkMessage` have protective Debug implementations that truncate data, other `ConsensusMsg` variants do not
- This is an implementation quality issue rather than a fundamental protocol flaw
- The risk is elevated if node logs are exported to external monitoring systems or shared during incident response

### Citations

**File:** consensus/src/rand/secret_sharing/network_messages.rs (L51-56)
```rust
    fn from_network_message(msg: ConsensusMsg) -> anyhow::Result<Self> {
        match msg {
            ConsensusMsg::SecretShareMsg(msg) => Ok(bcs::from_bytes(&msg.data)?),
            _ => bail!("unexpected consensus message type {:?}", msg),
        }
    }
```

**File:** consensus/src/network_interface.rs (L39-105)
```rust
#[derive(Clone, Debug, Deserialize, Serialize)]
pub enum ConsensusMsg {
    /// DEPRECATED: Once this is introduced in the next release, please use
    /// [`ConsensusMsg::BlockRetrievalRequest`](ConsensusMsg::BlockRetrievalRequest) going forward
    /// This variant was renamed from `BlockRetrievalRequest` to `DeprecatedBlockRetrievalRequest`
    /// RPC to get a chain of block of the given length starting from the given block id.
    DeprecatedBlockRetrievalRequest(Box<BlockRetrievalRequestV1>),
    /// Carries the returned blocks and the retrieval status.
    BlockRetrievalResponse(Box<BlockRetrievalResponse>),
    /// Request to get a EpochChangeProof from current_epoch to target_epoch
    EpochRetrievalRequest(Box<EpochRetrievalRequest>),
    /// ProposalMsg contains the required information for the proposer election protocol to make
    /// its choice (typically depends on round and proposer info).
    ProposalMsg(Box<ProposalMsg>),
    /// This struct describes basic synchronization metadata.
    SyncInfo(Box<SyncInfo>),
    /// A vector of LedgerInfo with contiguous increasing epoch numbers to prove a sequence of
    /// epoch changes from the first LedgerInfo's epoch.
    EpochChangeProof(Box<EpochChangeProof>),
    /// VoteMsg is the struct that is ultimately sent by the voter in response for receiving a
    /// proposal.
    VoteMsg(Box<VoteMsg>),
    /// CommitProposal is the struct that is sent by the validator after execution to propose
    /// on the committed state hash root.
    CommitVoteMsg(Box<CommitVote>),
    /// CommitDecision is the struct that is sent by the validator after collecting no fewer
    /// than 2f + 1 signatures on the commit proposal. This part is not on the critical path, but
    /// it can save slow machines to quickly confirm the execution result.
    CommitDecisionMsg(Box<CommitDecision>),
    /// Quorum Store: Send a Batch of transactions.
    BatchMsg(Box<BatchMsg<BatchInfo>>),
    /// Quorum Store: Request the payloads of a completed batch.
    BatchRequestMsg(Box<BatchRequest>),
    /// Quorum Store: Response to the batch request.
    BatchResponse(Box<Batch<BatchInfo>>),
    /// Quorum Store: Send a signed batch digest. This is a vote for the batch and a promise that
    /// the batch of transactions was received and will be persisted until batch expiration.
    SignedBatchInfo(Box<SignedBatchInfoMsg<BatchInfo>>),
    /// Quorum Store: Broadcast a certified proof of store (a digest that received 2f+1 votes).
    ProofOfStoreMsg(Box<ProofOfStoreMsg<BatchInfo>>),
    /// DAG protocol message
    DAGMessage(DAGNetworkMessage),
    /// Commit message
    CommitMessage(Box<CommitMessage>),
    /// Randomness generation message
    RandGenMessage(RandGenMessage),
    /// Quorum Store: Response to the batch request.
    BatchResponseV2(Box<BatchResponse>),
    /// OrderVoteMsg is the struct that is broadcasted by a validator on receiving quorum certificate
    /// on a block.
    OrderVoteMsg(Box<OrderVoteMsg>),
    /// RoundTimeoutMsg is broadcasted by a validator once it decides to timeout the current round.
    RoundTimeoutMsg(Box<RoundTimeoutMsg>),
    /// RPC to get a chain of block of the given length starting from the given block id, using epoch and round.
    BlockRetrievalRequest(Box<BlockRetrievalRequest>),
    /// OptProposalMsg contains the optimistic proposal and sync info.
    OptProposalMsg(Box<OptProposalMsg>),
    /// Quorum Store: Send a Batch of transactions.
    BatchMsgV2(Box<BatchMsg<BatchInfoExt>>),
    /// Quorum Store: Send a signed batch digest with BatchInfoExt. This is a vote for the batch and a promise that
    /// the batch of transactions was received and will be persisted until batch expiration.
    SignedBatchInfoMsgV2(Box<SignedBatchInfoMsg<BatchInfoExt>>),
    /// Quorum Store: Broadcast a certified proof of store (a digest that received 2f+1 votes) with BatchInfoExt.
    ProofOfStoreMsgV2(Box<ProofOfStoreMsg<BatchInfoExt>>),
    /// Secret share message: Used to share secrets per consensus round
    SecretShareMsg(SecretShareNetworkMessage),
}
```

**File:** consensus/src/quorum_store/types.rs (L145-150)
```rust
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(remote = "Batch")]
pub struct Batch<T: TBatchInfo> {
    batch_info: T,
    payload: BatchPayload,
}
```

**File:** consensus/src/quorum_store/types.rs (L423-426)
```rust
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct BatchMsg<T: TBatchInfo> {
    batches: Vec<Batch<T>>,
}
```

**File:** consensus/consensus-types/src/common.rs (L707-713)
```rust
#[derive(Clone, Debug, Deserialize, Serialize, CryptoHasher)]
pub struct BatchPayload {
    author: PeerId,
    txns: Vec<SignedTransaction>,
    #[serde(skip)]
    num_bytes: OnceCell<usize>,
}
```

**File:** types/src/transaction/mod.rs (L1092-1103)
```rust
impl Debug for SignedTransaction {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "SignedTransaction {{ \n \
             {{ raw_txn: {:#?}, \n \
             authenticator: {:#?}, \n \
             }} \n \
             }}",
            self.raw_txn, self.authenticator
        )
    }
```

**File:** consensus/src/network.rs (L695-696)
```rust
        tokio::task::spawn_blocking(|| TConsensusMsg::from_network_message(response_msg)).await?
    }
```

**File:** consensus/src/rand/rand_gen/network_messages.rs (L78-83)
```rust
    fn from_network_message(msg: ConsensusMsg) -> anyhow::Result<Self> {
        match msg {
            ConsensusMsg::RandGenMessage(msg) => Ok(bcs::from_bytes(&msg.data)?),
            _ => bail!("unexpected consensus message type {:?}", msg),
        }
    }
```
