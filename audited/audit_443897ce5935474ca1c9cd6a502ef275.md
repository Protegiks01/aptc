# Audit Report

## Title
Critical Consensus Failure: Empty Validator Set Causes Division-by-Zero Panic in Proposer Election

## Summary
The `RotatingProposer::new()` function does not validate that the proposers vector is non-empty, and `get_valid_proposer()` performs a modulo operation by `proposers.len()` that causes a division-by-zero panic when the validator set is empty. A malicious governance proposal can increase the minimum stake requirement above all current validators' stakes, causing `stake::on_new_epoch()` to filter out all validators and create an empty validator set, resulting in immediate and total network halt. [1](#0-0) 

## Finding Description
The vulnerability chain consists of multiple missing validation checks:

**1. Missing Input Validation in RotatingProposer::new()**

The constructor accepts an empty proposers vector without validation: [1](#0-0) 

**2. Division-by-Zero in get_valid_proposer()**

When `proposers.len()` is 0, the modulo operation causes a panic: [2](#0-1) 

**3. Missing Empty Set Check in on_new_epoch()**

The `on_new_epoch()` function filters validators based on minimum stake but never validates that the resulting set is non-empty: [3](#0-2) 

After filtering, `next_epoch_validators` can be empty if all validators fall below the minimum stake threshold, and this empty vector is assigned to `active_validators` without any validation.

**4. Insufficient Validation in update_required_stake()**

Governance can update the minimum stake to an arbitrarily high value without checking against current validators' stakes: [4](#0-3) 

The validation only ensures `minimum_stake <= maximum_stake && maximum_stake > 0`: [5](#0-4) 

**5. ValidatorVerifier Accepts Empty Validator Set**

The `ValidatorVerifier::new()` explicitly allows empty validator sets: [6](#0-5) 

**Attack Path:**

1. Malicious governance proposal passes to call `staking_config::update_required_stake()` with a minimum_stake value higher than all current validators' stakes
2. At next epoch boundary, `reconfiguration::reconfigure()` calls `stake::on_new_epoch()`
3. All validators are filtered out because `new_validator_info.voting_power < minimum_stake`
4. `validator_set.active_validators` becomes an empty vector
5. ValidatorSet is converted to ValidatorVerifier with empty validator_infos
6. EpochManager creates RotatingProposer with empty proposers list
7. When consensus calls `get_valid_proposer()`, the operation `% self.proposers.len()` performs `% 0`, causing a division-by-zero panic
8. All validator nodes crash, causing total network halt [7](#0-6) 

## Impact Explanation
**Critical Severity** - This vulnerability causes:

- **Total loss of liveness/network availability**: All validator nodes panic when attempting to determine the proposer, immediately halting consensus
- **Non-recoverable network partition requiring hardfork**: The network cannot recover without manual intervention to restore a valid validator set, requiring coordinated hardfork
- **Consensus Safety violation**: The network cannot produce blocks or process transactions, violating the fundamental consensus liveness guarantee

This meets the Critical severity criteria per Aptos bug bounty: "Total loss of liveness/network availability" and "Non-recoverable network partition (requires hardfork)".

## Likelihood Explanation
**Medium-High Likelihood:**

While governance proposals require validator approval, several scenarios make this exploitable:

1. **Governance Bug**: A bug in proposal validation could allow unauthorized stake requirement updates
2. **Coordination Failure**: Validators might approve a proposal without understanding its impact
3. **Cascading Stake Loss**: Validators could lose stake through slashing or withdrawals, falling below a legitimately-set minimum
4. **Malicious Proposal Disguise**: A complex proposal could hide the minimum stake increase among other changes
5. **Social Engineering**: Validators could be convinced that increasing minimum stake is beneficial without realizing current stakes are below the threshold

The technical capability exists and only requires a single governance proposal to exploit.

## Recommendation

**Fix 1: Add validation in RotatingProposer::new()**

```rust
pub fn new(proposers: Vec<Author>, contiguous_rounds: u32) -> Self {
    assert!(!proposers.is_empty(), "Proposers list cannot be empty");
    Self {
        proposers,
        contiguous_rounds,
    }
}
```

**Fix 2: Add empty set check in stake::on_new_epoch()**

After line 1401 in stake.move:
```move
validator_set.active_validators = next_epoch_validators;
assert!(vector::length(&validator_set.active_validators) > 0, error::invalid_state(ELAST_VALIDATOR));
```

**Fix 3: Add validation in staking_config::update_required_stake()**

```move
public fun update_required_stake(
    aptos_framework: &signer,
    minimum_stake: u64,
    maximum_stake: u64,
) acquires StakingConfig {
    system_addresses::assert_aptos_framework(aptos_framework);
    validate_required_stake(minimum_stake, maximum_stake);
    
    // Validate that at least one current validator meets the new minimum
    let validator_set = stake::get_validator_set();
    let active_validators = stake::get_active_validators(&validator_set);
    let has_valid_validator = false;
    for validator in active_validators {
        if (stake::get_validator_stake(validator) >= minimum_stake) {
            has_valid_validator = true;
            break;
        }
    };
    assert!(has_valid_validator, error::invalid_argument(ESTAKE_REQUIREMENTS_TOO_HIGH));
    
    let staking_config = borrow_global_mut<StakingConfig>(@aptos_framework);
    staking_config.minimum_stake = minimum_stake;
    staking_config.maximum_stake = maximum_stake;
}
```

## Proof of Concept

**Rust Panic PoC:**

```rust
#[test]
#[should_panic(expected = "attempt to calculate the remainder with a divisor of zero")]
fn test_empty_proposers_causes_panic() {
    use crate::liveness::{
        proposer_election::ProposerElection, 
        rotating_proposer_election::RotatingProposer
    };
    
    // Create RotatingProposer with empty vector - no validation!
    let pe = RotatingProposer::new(vec![], 1);
    
    // This will panic with division by zero
    let _ = pe.get_valid_proposer(1);
}
```

**Move Attack Scenario:**

```move
// Governance proposal script to trigger the vulnerability
script {
    use aptos_framework::staking_config;
    use aptos_framework::reconfiguration;
    
    fun malicious_proposal(aptos_framework: &signer) {
        // Set minimum stake higher than all current validators
        // Assuming current validators have ~1M APT staked
        staking_config::update_required_stake(
            aptos_framework,
            1_000_000_000_000, // 1 trillion APT - impossible to meet
            10_000_000_000_000
        );
        
        // Trigger reconfiguration
        reconfiguration::reconfigure();
        
        // At this point, all validators are filtered out
        // Next consensus round will panic on division by zero
    }
}
```

The vulnerability is exploitable through standard governance mechanisms and causes immediate, catastrophic network failure requiring hardfork recovery.

### Citations

**File:** consensus/src/liveness/rotating_proposer_election.rs (L27-32)
```rust
    pub fn new(proposers: Vec<Author>, contiguous_rounds: u32) -> Self {
        Self {
            proposers,
            contiguous_rounds,
        }
    }
```

**File:** consensus/src/liveness/rotating_proposer_election.rs (L36-39)
```rust
    fn get_valid_proposer(&self, round: Round) -> Author {
        self.proposers
            [((round / u64::from(self.contiguous_rounds)) % self.proposers.len() as u64) as usize]
    }
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1372-1401)
```text
        let next_epoch_validators = vector::empty();
        let (minimum_stake, _) = staking_config::get_required_stake(&config);
        let vlen = vector::length(&validator_set.active_validators);
        let total_voting_power = 0;
        let i = 0;
        while ({
            spec {
                invariant spec_validators_are_initialized(next_epoch_validators);
                invariant i <= vlen;
            };
            i < vlen
        }) {
            let old_validator_info = vector::borrow_mut(&mut validator_set.active_validators, i);
            let pool_address = old_validator_info.addr;
            let validator_config = borrow_global<ValidatorConfig>(pool_address);
            let stake_pool = borrow_global<StakePool>(pool_address);
            let new_validator_info = generate_validator_info(pool_address, stake_pool, *validator_config);

            // A validator needs at least the min stake required to join the validator set.
            if (new_validator_info.voting_power >= minimum_stake) {
                spec {
                    assume total_voting_power + new_validator_info.voting_power <= MAX_U128;
                };
                total_voting_power = total_voting_power + (new_validator_info.voting_power as u128);
                vector::push_back(&mut next_epoch_validators, new_validator_info);
            };
            i = i + 1;
        };

        validator_set.active_validators = next_epoch_validators;
```

**File:** aptos-move/framework/aptos-framework/sources/configs/staking_config.move (L274-285)
```text
    public fun update_required_stake(
        aptos_framework: &signer,
        minimum_stake: u64,
        maximum_stake: u64,
    ) acquires StakingConfig {
        system_addresses::assert_aptos_framework(aptos_framework);
        validate_required_stake(minimum_stake, maximum_stake);

        let staking_config = borrow_global_mut<StakingConfig>(@aptos_framework);
        staking_config.minimum_stake = minimum_stake;
        staking_config.maximum_stake = maximum_stake;
    }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/staking_config.move (L372-374)
```text
    fun validate_required_stake(minimum_stake: u64, maximum_stake: u64) {
        assert!(minimum_stake <= maximum_stake && maximum_stake > 0, error::invalid_argument(EINVALID_STAKE_RANGE));
    }
```

**File:** types/src/validator_verifier.rs (L206-214)
```rust
    pub fn new(validator_infos: Vec<ValidatorConsensusInfo>) -> Self {
        let total_voting_power = sum_voting_power(&validator_infos);
        let quorum_voting_power = if validator_infos.is_empty() {
            0
        } else {
            total_voting_power * 2 / 3 + 1
        };
        Self::build_index(validator_infos, quorum_voting_power, total_voting_power)
    }
```

**File:** consensus/src/epoch_manager.rs (L292-298)
```rust
        let proposers = epoch_state
            .verifier
            .get_ordered_account_addresses_iter()
            .collect::<Vec<_>>();
        match &onchain_config.proposer_election_type() {
            ProposerElectionType::RotatingProposer(contiguous_rounds) => {
                Arc::new(RotatingProposer::new(proposers, *contiguous_rounds))
```
