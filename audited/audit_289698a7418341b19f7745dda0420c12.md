# Audit Report

## Title
SafetyRules.sign_proposal() Does Not Enforce Single Proposal Per Round, Allowing Potential Equivocation

## Summary
The `sign_proposal()` method in SafetyRules does not track or prevent a validator from signing multiple different proposals at the same round. While ProposalGenerator provides in-memory protection, SafetyRules—the security-critical component responsible for enforcing consensus safety invariants—lacks this enforcement, creating a defense-in-depth gap.

## Finding Description

SafetyRules is designed as the security-critical component that enforces consensus safety rules, even if other parts of the validator software are compromised. However, `sign_proposal()` only validates that the proposal round is strictly greater than `last_voted_round`, but does not track or update any state related to proposals signed. [1](#0-0) 

The critical check at line 356 compares against `last_voted_round`, which is only updated when the validator **votes** on a proposal (not when signing their own proposal): [2](#0-1) 

The `SafetyData` structure contains no field to track the last signed proposal round: [3](#0-2) 

While ProposalGenerator maintains an in-memory `last_round_generated` field: [4](#0-3) 

This protection is:
1. **Not persisted** - Lost on validator restart
2. **Not part of SafetyRules** - Can be bypassed if validator code is modified
3. **In-memory only** - Not cryptographically enforced

The round_manager.rs comment acknowledges this invariant but relies entirely on ProposalGenerator: [5](#0-4) 

**Attack Scenario:**

A Byzantine validator could:
1. Be selected as proposer for round R
2. Create two different `BlockData` instances with different transaction payloads
3. Call `sign_proposal(BlockData_A)` → receives `signature_A` 
4. Call `sign_proposal(BlockData_B)` → receives `signature_B` (succeeds because `last_voted_round` unchanged)
5. Broadcast both signed proposals to different subsets of validators

**Restart Scenario (Honest Validator):**

An honest validator could inadvertently create equivocating proposals:
1. Sign proposal for round R
2. Crash before proposal is broadcast or voted upon
3. Restart - `last_round_generated` is lost
4. Sign a different proposal for round R with different transactions
5. Two valid signatures exist for different proposals at round R

## Impact Explanation

This falls under **High Severity** ($50,000) as a "Significant protocol violation" per Aptos bug bounty criteria:

- **Protocol Violation**: Violates the documented invariant that "at most one proposal can get generated per round"
- **Defense-in-Depth Failure**: SafetyRules should be the last line of defense, but delegates critical safety enforcement to non-persisted application logic
- **Equivocation Risk**: While likely causing liveness failures rather than direct safety violations in the current protocol, proposal equivocation undermines consensus assumptions

The impact is mitigated by:
- ProposalGenerator's in-memory check preventing accidental equivocation
- AptosBFT's voting rules requiring 2f+1 votes (split votes prevent QC formation)
- Most validators running unmodified code

However, security-critical components should not rely on higher-level application logic for invariant enforcement.

## Likelihood Explanation

**Moderate Likelihood:**

- Requires Byzantine validator behavior (modifying code) OR validator restart at specific timing
- ProposalGenerator provides first-line defense in normal operation
- However, restart scenarios are realistic operational events
- Byzantine validators are explicitly part of BFT threat model (≤ f Byzantine validators)

The vulnerability is more likely to manifest as:
- Accidental equivocation during validator restarts
- Deliberate exploitation by sophisticated Byzantine actors
- Unexpected edge cases not covered by ProposalGenerator

## Recommendation

Add proposal round tracking to `SafetyData` and enforce it in `SafetyRules.sign_proposal()`:

1. **Add field to SafetyData:**
```rust
pub struct SafetyData {
    pub epoch: u64,
    pub last_voted_round: u64,
    pub last_signed_proposal_round: u64,  // NEW FIELD
    pub preferred_round: u64,
    // ... existing fields
}
```

2. **Update sign_proposal to track and enforce:**
```rust
fn guarded_sign_proposal(
    &mut self,
    block_data: &BlockData,
) -> Result<bls12381::Signature, Error> {
    self.signer()?;
    self.verify_author(block_data.author())?;
    
    let mut safety_data = self.persistent_storage.safety_data()?;
    self.verify_epoch(block_data.epoch(), &safety_data)?;
    
    // NEW: Check against last signed proposal round
    if block_data.round() <= safety_data.last_signed_proposal_round {
        return Err(Error::InvalidProposal(format!(
            "Already signed proposal at round {}",
            safety_data.last_signed_proposal_round
        )));
    }
    
    if block_data.round() <= safety_data.last_voted_round {
        return Err(Error::InvalidProposal(format!(
            "Proposed round {} is not higher than last voted round {}",
            block_data.round(),
            safety_data.last_voted_round
        )));
    }
    
    self.verify_qc(block_data.quorum_cert())?;
    self.verify_and_update_preferred_round(block_data.quorum_cert(), &mut safety_data)?;
    
    // NEW: Update and persist last signed proposal round
    safety_data.last_signed_proposal_round = block_data.round();
    self.persistent_storage.set_safety_data(safety_data)?;
    
    let signature = self.sign(block_data)?;
    Ok(signature)
}
```

This ensures SafetyRules cryptographically enforces single proposal per round, persisted to storage, independent of application-level logic.

## Proof of Concept

```rust
#[test]
fn test_double_sign_proposal_same_round() {
    // Setup
    let mut safety_rules = create_safety_rules_for_test();
    let round = 10;
    
    // Create two different BlockData for the same round
    let block_data_a = create_block_data(round, vec![txn_a]);
    let block_data_b = create_block_data(round, vec![txn_b]);
    
    // Sign first proposal - should succeed
    let sig_a = safety_rules.sign_proposal(&block_data_a).unwrap();
    
    // Sign second proposal at SAME round - currently succeeds, should fail
    let sig_b = safety_rules.sign_proposal(&block_data_b);
    
    // This assertion currently FAILS (vulnerability exists)
    assert!(sig_b.is_err(), "Should not allow signing two proposals at same round");
    
    // Verify signatures are both valid for different block hashes
    assert_ne!(block_data_a.hash(), block_data_b.hash());
    assert!(verify_signature(&sig_a, &block_data_a));
    if let Ok(sig_b) = sig_b {
        assert!(verify_signature(&sig_b, &block_data_b));
    }
}
```

## Notes

This vulnerability represents a **defense-in-depth failure** rather than an immediately exploitable safety violation. The ProposalGenerator provides adequate protection in normal operation, but SafetyRules—as the security-critical component—should independently enforce this invariant through persistent state. The lack of enforcement creates risk in restart scenarios and reduces resilience against Byzantine behavior.

### Citations

**File:** consensus/safety-rules/src/safety_rules.rs (L346-370)
```rust
    fn guarded_sign_proposal(
        &mut self,
        block_data: &BlockData,
    ) -> Result<bls12381::Signature, Error> {
        self.signer()?;
        self.verify_author(block_data.author())?;

        let mut safety_data = self.persistent_storage.safety_data()?;
        self.verify_epoch(block_data.epoch(), &safety_data)?;

        if block_data.round() <= safety_data.last_voted_round {
            return Err(Error::InvalidProposal(format!(
                "Proposed round {} is not higher than last voted round {}",
                block_data.round(),
                safety_data.last_voted_round
            )));
        }

        self.verify_qc(block_data.quorum_cert())?;
        self.verify_and_update_preferred_round(block_data.quorum_cert(), &mut safety_data)?;
        // we don't persist the updated preferred round to save latency (it'd be updated upon voting)

        let signature = self.sign(block_data)?;
        Ok(signature)
    }
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L77-80)
```rust
        self.verify_and_update_last_vote_round(
            proposed_block.block_data().round(),
            &mut safety_data,
        )?;
```

**File:** consensus/consensus-types/src/safety_data.rs (L8-21)
```rust
/// Data structure for safety rules to ensure consensus safety.
#[derive(Debug, Deserialize, Eq, PartialEq, Serialize, Clone, Default)]
pub struct SafetyData {
    pub epoch: u64,
    pub last_voted_round: u64,
    // highest 2-chain round, used for 3-chain
    pub preferred_round: u64,
    // highest 1-chain round, used for 2-chain
    #[serde(default)]
    pub one_chain_round: u64,
    pub last_vote: Option<Vote>,
    #[serde(default)]
    pub highest_timeout_round: u64,
}
```

**File:** consensus/src/liveness/proposal_generator.rs (L402-403)
```rust
    // Last round that a proposal was generated
    last_round_generated: Mutex<Round>,
```

**File:** consensus/src/round_manager.rs (L413-415)
```rust
    /// that all honest replicas can vote for.  While this method should only be invoked at most
    /// once per round, we ensure that only at most one proposal can get generated per round to
    /// avoid accidental equivocation of proposals.
```
