# Audit Report

## Title
Integer Underflow in `standardize_address()` Causes Indexer-gRPC Service Crash via Malformed Address Filters

## Summary
The `standardize_address()` function in the indexer-gRPC transaction filter contains an integer underflow vulnerability that allows any unprivileged attacker to crash the indexer service by providing an address string longer than 64 hex characters in a transaction filter.

## Finding Description

The vulnerability exists in the `standardize_address()` function which performs address normalization for transaction filtering in the indexer-gRPC service. [1](#0-0) 

The critical flaw is at the slice operation where the function attempts to pad addresses with leading zeros. When `trimmed.len() > 64`, the expression `64 - trimmed.len()` causes integer underflow:

- In debug mode: Panics with "attempt to subtract with overflow"
- In release mode: Wraps around to a value near `usize::MAX`, then `&ZEROS[..wrapped_value]` panics with "index out of bounds"

This function is called during filter construction when converting protobuf messages to Rust filter types: [2](#0-1) [3](#0-2) 

**Attack Path:**

1. Attacker sends a gRPC `GetTransactions` request to the indexer-grpc service
2. Request includes a `UserTransactionFilter` with sender address > 64 hex characters (e.g., 70 characters)
3. During filter parsing via `BooleanTransactionFilter::new_from_proto()`, the protobuf filter is converted to Rust types
4. Conversion calls `standardize_address(address)` on the malformed address
5. Function panics due to integer underflow in slice operation
6. Service thread crashes, disrupting indexer availability

The filter parsing occurs in: [4](#0-3) 

## Impact Explanation

This vulnerability qualifies as **HIGH severity** per the Aptos Bug Bounty program under the category "API crashes". The indexer-gRPC service is a critical API that developers and applications depend on to query blockchain data, monitor transactions, and build user-facing applications.

**Impact Severity:**
- **Availability**: Repeated exploitation can cause complete denial of service for the indexer-grpc API
- **Scope**: Affects all indexer-grpc instances that accept transaction filters
- **User Impact**: Applications relying on the indexer API will fail, breaking user experiences
- **Recovery**: Requires service restart after each crash

While this does not affect consensus, validator operation, or the core blockchain, it breaks a critical external interface used by the ecosystem.

## Likelihood Explanation

**Likelihood: HIGH**

- **Attack Complexity**: Trivial - requires only crafting a gRPC request with a long address string
- **Attacker Requirements**: None - any user can send gRPC requests to public indexer endpoints
- **Detection Difficulty**: Attack is indistinguishable from legitimate requests until parsing
- **Rate of Exploitation**: Can be repeated continuously to maintain denial of service
- **No Prerequisites**: No authentication, special permissions, or prior state required

## Recommendation

Add input validation to check address length before performing arithmetic operations:

```rust
#[inline]
pub fn standardize_address(address: &str) -> String {
    // Remove "0x" prefix if it exists
    let trimmed = address.strip_prefix("0x").unwrap_or(address);
    
    // Validate address length - Aptos addresses must be <= 64 hex characters
    if trimmed.len() > 64 {
        // Return the trimmed address as-is or handle error appropriately
        // For now, truncate to 64 characters to avoid panic
        let truncated = &trimmed[..64];
        return format!("0x{}", truncated);
    }

    // Check if the address is a special address
    if let Some(last_char) = trimmed.chars().last() {
        if trimmed[..trimmed.len().saturating_sub(1)]
            .chars()
            .all(|c| c == '0')
            && last_char.is_ascii_hexdigit()
            && last_char <= 'f'
        {
            let mut result = String::with_capacity(3);
            result.push_str("0x");
            result.push(last_char);
            return result;
        }
    }

    // Return non-special addresses in long format
    let mut result = String::with_capacity(66);
    result.push_str("0x");
    result.push_str(&ZEROS[..64 - trimmed.len()]);
    result.push_str(trimmed);
    result
}
```

Alternatively, return an error for invalid address lengths and handle it gracefully in the filter validation logic.

## Proof of Concept

```rust
#[cfg(test)]
mod exploit_tests {
    use super::*;

    #[test]
    #[should_panic(expected = "index out of bounds")]
    fn test_crash_with_oversized_address() {
        // Address with 70 hex characters (exceeds 64 limit)
        let malicious_address = "0x12345678901234567890123456789012345678901234567890123456789012345678901234567890";
        
        // This will panic due to integer underflow
        let _ = standardize_address(malicious_address);
    }
    
    #[test]
    #[should_panic]
    fn test_crash_with_100_char_address() {
        // Even longer address to ensure panic
        let malicious_address = format!("0x{}", "a".repeat(100));
        
        // This will panic
        let _ = standardize_address(&malicious_address);
    }
}
```

To exploit in practice, an attacker would send a gRPC request:

```rust
// Pseudocode for exploitation
let malicious_filter = UserTransactionFilter {
    sender: Some("0x".to_string() + &"f".repeat(100)), // 100+ hex chars
    payload: None,
};

// Send GetTransactions request with this filter
// The service will crash when parsing the filter
```

## Notes

- The vulnerability is present in both debug and release builds, though the exact panic message differs
- The indexer service uses the same `standardize_address()` function in multiple locations for filtering addresses
- The `ZEROS` constant has exactly 64 characters, making any attempt to slice beyond this bound result in a panic
- Similar vulnerability patterns should be checked in the regular indexer's `standardize_address()` at `crates/indexer/src/util.rs` line 15, though that implementation has different logic

### Citations

**File:** ecosystem/indexer-grpc/transaction-filter/src/utils.rs (L10-36)
```rust
pub fn standardize_address(address: &str) -> String {
    // Remove "0x" prefix if it exists
    let trimmed = address.strip_prefix("0x").unwrap_or(address);

    // Check if the address is a special address by seeing if the first 31 bytes are zero and the last byte is smaller than 0b10000
    if let Some(last_char) = trimmed.chars().last() {
        if trimmed[..trimmed.len().saturating_sub(1)]
            .chars()
            .all(|c| c == '0')
            && last_char.is_ascii_hexdigit()
            && last_char <= 'f'
        {
            // Return special addresses in short format
            let mut result = String::with_capacity(3);
            result.push_str("0x");
            result.push(last_char);
            return result;
        }
    }

    // Return non-special addresses in long format
    let mut result = String::with_capacity(66);
    result.push_str("0x");
    result.push_str(&ZEROS[..64 - trimmed.len()]);
    result.push_str(trimmed);
    result
}
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/filters/user_transaction.rs (L48-61)
```rust
impl From<aptos_protos::indexer::v1::UserTransactionFilter> for UserTransactionFilter {
    fn from(proto_filter: aptos_protos::indexer::v1::UserTransactionFilter) -> Self {
        Self {
            standardized_sender: OnceCell::with_value(
                proto_filter
                    .sender
                    .as_ref()
                    .map(|address| standardize_address(address)),
            ),
            sender: proto_filter.sender,
            payload: proto_filter.payload_filter.map(|f| f.into()),
        }
    }
}
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/filters/user_transaction.rs (L155-169)
```rust
impl From<aptos_protos::indexer::v1::EntryFunctionFilter> for EntryFunctionFilter {
    fn from(proto_filter: aptos_protos::indexer::v1::EntryFunctionFilter) -> Self {
        Self {
            standardized_address: OnceCell::with_value(
                proto_filter
                    .address
                    .as_ref()
                    .map(|address| standardize_address(address)),
            ),
            address: proto_filter.address,
            module: proto_filter.module_name,
            function: proto_filter.function,
        }
    }
}
```

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/filter_utils.rs (L7-15)
```rust
/// Parse and validate a transaction filter from its protobuf representation.
/// Returns an error Status if the filter is invalid or too large.
pub fn parse_transaction_filter(
    proto_filter: aptos_protos::indexer::v1::BooleanTransactionFilter,
    max_filter_size_bytes: usize,
) -> Result<BooleanTransactionFilter, Status> {
    BooleanTransactionFilter::new_from_proto(proto_filter, Some(max_filter_size_bytes))
        .map_err(|e| Status::invalid_argument(format!("Invalid transaction_filter: {e:?}.")))
}
```
