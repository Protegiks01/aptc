# Audit Report

## Title
Database Corruption Silently Bypassed in Replay Verification Tool Leading to Invalid Verification Results

## Summary
The `Verifier::new()` function in the replay verification tool catches panics from write-mode database opening but continues execution with only a warning, allowing verification to proceed against potentially corrupted databases when read-only mode succeeds. This invalidates the integrity guarantees of the verification process.

## Finding Description

The replay verification tool is designed to validate transaction history by replaying transactions and comparing results. However, the error handling in `Verifier::new()` contains a critical flaw that undermines this purpose. [1](#0-0) 

The code attempts to open the database in write mode to "create any new DBs necessary," but wraps this in `panic::catch_unwind`. If the write-mode open panics—which occurs when database corruption is detected—the panic is caught and only a warning is logged. Execution then continues with a read-only database open.

The vulnerability arises because write-mode and read-only mode have different validation behaviors:

**Write Mode Behavior:** [2](#0-1) [3](#0-2) 

Write mode opens all database shards including hot state shards, with `unwrap_or_else` calls that panic on any error, including corruption.

**Read-Only Mode Behavior:** [4](#0-3) 

Read-only mode intentionally skips hot state shards entirely. Additionally, the underlying RocksDB opening in read-only mode filters out missing column families: [5](#0-4) 

**Attack Scenario:**
1. Database corruption exists (e.g., in hot state shards or specific column families)
2. Write-mode open attempts validation and detects corruption
3. Corruption triggers panic in `unwrap_or_else` handlers
4. Panic is caught by `panic::catch_unwind`
5. Only warning logged: "Unable to open AptosDB in write mode"
6. Read-only mode opens successfully by either skipping corrupted hot state or filtering missing column families
7. Verification proceeds using incomplete/corrupted database
8. All verification results are invalidated because base state is untrustworthy

The code even acknowledges unhandled data inconsistency: [6](#0-5) 

This breaks the **State Consistency** invariant: "State transitions must be atomic and verifiable via Merkle proofs." If the verification tool cannot guarantee it's working with a consistent database, it cannot verify state transitions.

## Impact Explanation

**Severity: Medium to High**

This issue meets the **Medium Severity** criteria: "State inconsistencies requiring intervention" from the Aptos bug bounty program. The impact includes:

1. **Invalid Verification Results**: The tool may report successful verification when replaying against corrupted data
2. **False Confidence**: Operators gain false confidence in backup integrity
3. **Corruption Propagation**: Corrupted backups may be accepted and used to restore production systems
4. **Consensus Risk**: If corrupted data is propagated to validator nodes, could lead to state divergence

The tool's purpose is to provide assurance about transaction history integrity. Silently bypassing corruption detection defeats this purpose entirely.

## Likelihood Explanation

**Likelihood: Medium**

Database corruption, while not everyday, occurs in production systems due to:
- Hardware failures (disk errors, memory corruption)
- Ungraceful shutdowns during writes
- Software bugs in storage layer
- File system issues

When corruption does occur, this code path actively hides the problem rather than failing fast. The likelihood increases in operational scenarios where the replay tool is used precisely when corruption is suspected.

## Recommendation

The fix should fail fast when write-mode opening panics, rather than continuing with potentially corrupted data:

```rust
// Open in write mode to create any new DBs necessary and validate integrity.
{
    let write_mode_result = panic::catch_unwind(|| {
        AptosDB::open(
            StorageDirPaths::from_path(config.db_dir.as_path()),
            false,
            NO_OP_STORAGE_PRUNER_CONFIG,
            config.rocksdb_opt.clone().into(),
            false,
            BUFFERED_STATE_TARGET_ITEMS,
            DEFAULT_MAX_NUM_NODES_PER_LRU_CACHE_SHARD,
            None,
            HotStateConfig::default(),
        )
    });
    
    if let Err(e) = write_mode_result {
        bail!(
            "Failed to open AptosDB in write mode, indicating potential database corruption. \
             Cannot proceed with verification. Error: {:?}", 
            e
        );
    }
}
```

Alternatively, if write-mode open is only for creating new databases, add an explicit check for whether the database already exists and only attempt write-mode open for new databases.

## Proof of Concept

**Reproduction Steps:**

1. Create a test database with the replay tool
2. Manually corrupt one of the hot state KV DB shards (e.g., delete or corrupt a .sst file in the hot state shard directory)
3. Run the replay verification tool on this database
4. Observe that:
   - Write-mode open panics due to corruption
   - Panic is caught and only a warning is logged
   - Read-only mode opens successfully (skips hot state)
   - Verification proceeds without detecting the corruption
   - Results are reported as valid despite corrupted underlying database

**Expected Behavior:** Tool should fail immediately upon detecting corruption in write-mode open, refusing to proceed with verification.

**Actual Behavior:** Tool continues with read-only mode, silently bypassing corruption detection.

## Notes

This vulnerability is particularly insidious because it occurs in a verification tool meant to ensure data integrity. The tool's design assumes that if it can open the database and replay transactions, the database is valid. However, by catching and ignoring panics that indicate corruption, the tool may verify against incomplete or corrupted state, producing meaningless results.

The issue is compounded by architectural differences between write and read-only modes that allow read-only to succeed even when write-mode detects problems. This creates a false sense of security where verification "succeeds" despite underlying data integrity issues.

### Citations

**File:** storage/db-tool/src/replay_on_archive.rs (L151-168)
```rust
        // Open in write mode to create any new DBs necessary.
        {
            if let Err(e) = panic::catch_unwind(|| {
                AptosDB::open(
                    StorageDirPaths::from_path(config.db_dir.as_path()),
                    false,
                    NO_OP_STORAGE_PRUNER_CONFIG,
                    config.rocksdb_opt.clone().into(),
                    false,
                    BUFFERED_STATE_TARGET_ITEMS,
                    DEFAULT_MAX_NUM_NODES_PER_LRU_CACHE_SHARD,
                    None,
                    HotStateConfig::default(),
                )
            }) {
                warn!("Unable to open AptosDB in write mode: {:?}", e);
            };
        }
```

**File:** storage/aptosdb/src/state_kv_db.rs (L107-125)
```rust
        let state_kv_db_shards = (0..NUM_STATE_SHARDS)
            .into_par_iter()
            .map(|shard_id| {
                let shard_root_path = db_paths.state_kv_db_shard_root_path(shard_id);
                let db = Self::open_shard(
                    shard_root_path,
                    shard_id,
                    &state_kv_db_config,
                    env,
                    block_cache,
                    readonly,
                    /* is_hot = */ false,
                )
                .unwrap_or_else(|e| panic!("Failed to open state kv db shard {shard_id}: {e:?}."));
                Arc::new(db)
            })
            .collect::<Vec<_>>()
            .try_into()
            .unwrap();
```

**File:** storage/aptosdb/src/state_kv_db.rs (L127-130)
```rust
        let hot_state_kv_db_shards = if readonly {
            // TODO(HotState): do not open it in readonly mode yet, until we have this DB
            // everywhere.
            None
```

**File:** storage/aptosdb/src/state_kv_db.rs (L132-155)
```rust
            Some(
                (0..NUM_STATE_SHARDS)
                    .into_par_iter()
                    .map(|shard_id| {
                        let shard_root_path = db_paths.hot_state_kv_db_shard_root_path(shard_id);
                        let db = Self::open_shard(
                            shard_root_path,
                            shard_id,
                            &state_kv_db_config,
                            env,
                            block_cache,
                            readonly,
                            /* is_hot = */ true,
                        )
                        .unwrap_or_else(|e| {
                            panic!("Failed to open hot state kv db shard {shard_id}: {e:?}.")
                        });
                        Arc::new(db)
                    })
                    .collect::<Vec<_>>()
                    .try_into()
                    .unwrap(),
            )
        };
```

**File:** storage/schemadb/src/lib.rs (L174-181)
```rust
                ReadOnly => {
                    DB::open_cf_descriptors_read_only(
                        db_opts,
                        path.de_unc(),
                        all_cfds.filter(|cfd| !missing_cfs.contains(cfd.name())),
                        false, /* error_if_log_file_exist */
                    )
                },
```

**File:** storage/aptosdb/src/ledger_db/mod.rs (L281-281)
```rust
        // TODO(grao): Handle data inconsistency.
```
