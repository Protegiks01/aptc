# Audit Report

## Title
Object Ownership Transfer Events Not Parsed by Rosetta Leading to Incorrect Operation Attribution

## Summary
The Aptos Rosetta implementation does not parse `TransferEvent` or `Transfer` events emitted when objects change ownership. This causes fungible asset operations to be incorrectly attributed to the final object owner rather than the actual owner who performed the operations, breaking the integrity of Rosetta's transaction history representation.

## Finding Description

The vulnerability exists in how Rosetta constructs ownership mappings for operations involving fungible asset stores.

**The Issue:**

When objects (including fungible asset stores) are transferred, the Aptos framework emits `TransferEvent` (v1) or `Transfer` (v2) events to record ownership changes: [1](#0-0) 

However, Rosetta does not parse these events at all. A search for `TransferEvent` or `TRANSFER_EVENT` in the Rosetta codebase returns zero results, confirming these events are completely ignored.

**The Root Cause:**

Rosetta builds its `object_to_owner` mapping from the **final state** of `ObjectCore` resources in the write set during transaction processing: [2](#0-1) 

The `parse_object_owner` function extracts ownership from the post-transaction state: [3](#0-2) 

**The Exploitation:**

Fungible asset `Withdraw` and `Deposit` events only contain the store address, not the owner address: [4](#0-3) 

When Rosetta processes these events, it looks up the owner from `object_to_owner`: [5](#0-4) 

**Attack Scenario:**

1. Alice owns a fungible asset store at address `0xSTORE` containing 1000 tokens
2. Alice creates a transaction that:
   - Withdraws 100 tokens from the store (emits `Withdraw` event with `store: 0xSTORE`)
   - Transfers the store object to Bob (emits `TransferEvent`, updates `ObjectCore.owner`)
3. When Rosetta processes this transaction:
   - `preprocess_write_set` captures the **final** `ObjectCore` state showing Bob as owner
   - `object_to_owner[0xSTORE] = Bob`
   - `parse_fungible_store_changes` sees the `Withdraw` event and attributes it to Bob
4. **Result**: Rosetta shows Bob withdrew 100 tokens, when Alice actually performed the withdrawal

This misrepresentation propagates to all services using Rosetta for balance tracking, transaction history, or compliance monitoring.

## Impact Explanation

This vulnerability causes **state inconsistencies** in Rosetta's representation of blockchain history, qualifying as **Medium Severity** per Aptos bug bounty criteria.

**Concrete Impacts:**

1. **Exchange/Service Fund Tracking**: Services using Rosetta to track user balances will credit/debit the wrong accounts when object transfers occur in the same transaction as operations
2. **Compliance Violations**: Regulatory reporting based on Rosetta data will show incorrect transaction parties
3. **Audit Trail Corruption**: Historical transaction analysis will attribute operations to parties who didn't perform them
4. **Account Reconciliation Failures**: Services attempting to reconcile on-chain state with their internal records will find unexplained discrepancies

While this doesn't directly cause on-chain fund loss, it creates critical data integrity issues for off-chain services that could lead to financial losses at the application layer.

## Likelihood Explanation

**Likelihood: Medium**

The vulnerability requires:
- An object that is transferable (not marked with `Untransferable`)
- A transaction combining both object operations and object transfer
- Services relying on Rosetta for accurate history

This is feasible through:
1. Custom Move entry functions that perform operations then transfer
2. Multi-step transaction scripts
3. Any fungible asset store transfer during active usage

The attack is easily executable by any user with transferable objects. The primary limitation is that many objects may be marked untransferable, but fungible asset stores created by users are often transferable by design.

## Recommendation

**Solution: Parse TransferEvent/Transfer Events**

Rosetta must parse object ownership transfer events and use temporal ordering to correctly attribute operations:

1. **Add Transfer Event Type Tags**:
```rust
static TRANSFER_EVENT_TYPE_TAG: Lazy<TypeTag> =
    Lazy::new(|| parse_type_tag("0x1::object::TransferEvent").unwrap());
static TRANSFER_V2_EVENT_TYPE_TAG: Lazy<TypeTag> =
    Lazy::new(|| parse_type_tag("0x1::object::Transfer").unwrap());
```

2. **Parse Transfer Events Before Processing Operations**:
Build a sequential ownership history for each object within a transaction by parsing transfer events in order, then attribute operations based on the owner at the time each operation occurred (determined by event ordering).

3. **Update object_to_owner During Operation Processing**:
Instead of building the map once from final state, update it dynamically as events are processed in chronological order.

**Alternative Fix**: If temporal ordering is complex, at minimum Rosetta should **detect** when object ownership changed within a transaction and either:
- Skip generating operations for that transaction (with a warning)
- Create explicit "transfer" operations showing the ownership change
- Flag the operations as potentially misattributed

## Proof of Concept

```move
// In a custom Move module
public entry fun exploit_rosetta_misattribution(
    owner: &signer,
    store: Object<FungibleStore>,
    recipient: address,
    amount: u64
) acquires FungibleStore {
    // Step 1: Withdraw from fungible store (owner is current signer)
    let fa = fungible_asset::withdraw(owner, store, amount);
    
    // Step 2: Transfer store object to recipient
    // This updates ObjectCore.owner to recipient
    object::transfer(owner, store, recipient);
    
    // Step 3: Can also deposit elsewhere with the withdrawn assets
    fungible_asset::deposit(some_other_account, fa);
    
    // Rosetta will show:
    // - Withdraw attributed to 'recipient' (INCORRECT - was 'owner')
    // - No record of object ownership change
    // - Deposit correctly attributed (but context is lost)
}
```

When this transaction executes:
1. Blockchain correctly processes all operations
2. `TransferEvent` is emitted showing store transferred from owner to recipient
3. Rosetta ignores `TransferEvent`
4. Rosetta attributes the withdrawal to recipient instead of owner
5. External services see recipient withdrew funds they never touched

**Validation**: Deploy the above function, execute it, then query Rosetta's `/block/transaction` endpoint for the transaction. The withdrawal operation will show the wrong account.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/object.move (L172-185)
```text
    /// Emitted whenever the object's owner field is changed.
    struct TransferEvent has drop, store {
        object: address,
        from: address,
        to: address,
    }

    #[event]
    /// Emitted whenever the object's owner field is changed.
    struct Transfer has drop, store {
        object: address,
        from: address,
        to: address,
    }
```

**File:** crates/aptos-rosetta/src/types/objects.rs (L940-957)
```rust
        let mut operation_index: u64 = 0;
        if successful {
            let mut object_to_owner = HashMap::new();
            let mut store_to_currency = HashMap::new();
            let mut framework_changes = vec![];
            // Not the most efficient, parse all store owners, and assets associated with stores
            for (state_key, write_op) in txn.changes.write_op_iter() {
                let new_changes = preprocess_write_set(
                    server_context,
                    state_key,
                    write_op,
                    maybe_user_txn.map(|inner| inner.payload()),
                    txn.version,
                    &mut object_to_owner,
                    &mut store_to_currency,
                );
                framework_changes.extend(new_changes);
            }
```

**File:** crates/aptos-rosetta/src/types/objects.rs (L1520-1528)
```rust
fn parse_object_owner(
    object_address: AccountAddress,
    data: &[u8],
    object_to_owner: &mut HashMap<AccountAddress, AccountAddress>,
) {
    if let Ok(object_core) = bcs::from_bytes::<ObjectCoreResource>(data) {
        object_to_owner.insert(object_address, object_core.owner);
    }
}
```

**File:** crates/aptos-rosetta/src/types/objects.rs (L2157-2195)
```rust
fn parse_fungible_store_changes(
    object_to_owner: &HashMap<AccountAddress, AccountAddress>,
    store_to_currency: &HashMap<AccountAddress, Currency>,
    address: AccountAddress,
    events: &[ContractEvent],
    mut operation_index: u64,
) -> ApiResult<Vec<Operation>> {
    let mut operations = vec![];

    // Find the fungible asset currency association
    let maybe_currency = store_to_currency.get(&address);
    if maybe_currency.is_none() {
        return Ok(operations);
    }
    let currency = maybe_currency.unwrap();

    // If there's a currency, let's fill in operations
    // If we don't have an owner here, there's missing data on the writeset
    let maybe_owner = object_to_owner.get(&address);
    if maybe_owner.is_none() {
        warn!(
            "First pass did not catch owner for fungible store \"{}\", returning no operations",
            address
        );
        return Ok(operations);
    }

    let owner = maybe_owner.copied().unwrap();

    let withdraw_amounts = get_amount_from_fa_event(events, &WITHDRAW_TYPE_TAG, address);
    for amount in withdraw_amounts {
        operations.push(Operation::withdraw(
            operation_index,
            Some(OperationStatusType::Success),
            AccountIdentifier::base_account(owner),
            currency.clone(),
            amount,
        ));
        operation_index += 1;
```

**File:** aptos-move/framework/aptos-framework/sources/fungible_asset.move (L232-244)
```text
    #[event]
    /// Emitted when fungible assets are deposited into a store.
    struct Deposit has drop, store {
        store: address,
        amount: u64
    }

    #[event]
    /// Emitted when fungible assets are withdrawn from a store.
    struct Withdraw has drop, store {
        store: address,
        amount: u64
    }
```
