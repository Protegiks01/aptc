# Audit Report

## Title
DKG Transcript Deserialization Resource Exhaustion via Unbounded SoK Accumulation

## Summary
The DKG transcript verification process lacks size validation before deserialization, allowing a malicious validator to submit transcripts with arbitrarily large numbers of Signatures of Knowledge (SoKs), causing memory exhaustion and CPU overconsumption during verification on honest validators.

## Finding Description
The `aggregate_with()` function appends SoKs without bound checking, and while normal production flows have contributor deduplication, there is no size validation on `transcript_bytes` before deserialization in the validator transaction processing path. [1](#0-0) 

The vulnerability manifests when a malicious validator crafts a DKGTranscript containing thousands of SoKs by repeatedly calling `aggregate_with()` outside the normal flow. When this malicious transcript is submitted as a `ValidatorTransaction::DKGResult` and processed by honest validators, the following resource-intensive operations occur without prior size validation: [2](#0-1) 

During verification, `verify_transcript_extra()` calls `get_dealers()` which iterates through all SoKs: [3](#0-2) 

And then builds a HashSet by iterating through all dealers: [4](#0-3) 

Additionally, `batch_verify_soks()` performs O(n) operations on all SoKs: [5](#0-4) 

While the duplicate dealer check at line 311 eventually rejects the malicious transcript, significant memory and CPU resources are consumed during deserialization and preliminary verification steps. An attacker can repeatedly submit such transcripts to cause sustained resource exhaustion.

## Impact Explanation
This vulnerability qualifies as **High Severity** per the Aptos bug bounty program criteria for "Validator node slowdowns." A malicious validator can cause:

1. **Memory exhaustion**: Deserialization allocates memory proportional to transcript size (potentially gigabytes for millions of SoKs)
2. **CPU overload**: O(n) verification operations where n can be millions
3. **Sustained DoS**: Repeated submission in consecutive blocks causes persistent resource exhaustion
4. **API crashes**: Resource exhaustion can cause validator APIs to become unresponsive

This breaks the **Resource Limits** invariant (#9): "All operations must respect gas, storage, and computational limits."

## Likelihood Explanation
**Likelihood: Medium-High**

- **Attacker requirements**: Must be a validator (limited but realistic threat model)
- **Complexity**: Low - straightforward to craft malicious transcript via local code modification
- **Detection**: Difficult to detect until resources are consumed, as validation happens during block execution
- **Mitigation**: No existing defense-in-depth protections before deserialization

## Recommendation
Implement size validation before deserialization and add bounds checking on the number of SoKs:

```rust
// In aptos-move/aptos-vm/src/validator_txns/dkg.rs, before line 106:
const MAX_TRANSCRIPT_BYTES: usize = 10_000_000; // 10MB
const MAX_SOKS_COUNT: usize = 1000; // Based on max validator set size

if dkg_node.transcript_bytes.len() > MAX_TRANSCRIPT_BYTES {
    return Err(Expected(TranscriptTooLarge));
}

// After deserialization, before verification:
let num_dealers = transcript.main.get_dealers().len();
if num_dealers > MAX_SOKS_COUNT {
    return Err(Expected(TooManySoKs));
}
```

Additionally, add early validation in `aggregate_with()`:

```rust
// In weighted_protocol.rs, at line 388:
const MAX_SOKS_IN_TRANSCRIPT: usize = 1000;
if self.soks.len() + other.soks.len() > MAX_SOKS_IN_TRANSCRIPT {
    bail!("Transcript would exceed maximum SoK count");
}
```

## Proof of Concept
```rust
// Proof of Concept demonstrating unbounded SoK accumulation
#[test]
fn test_unbounded_sok_accumulation() {
    use aptos_dkg::pvss::das::WeightedTranscript;
    use aptos_dkg::pvss::traits::Aggregatable;
    
    let sc = /* setup weighted config */;
    let mut transcript = /* create initial transcript */;
    
    // Repeatedly aggregate to accumulate SoKs
    for i in 0..10000 {
        let another_transcript = /* create another transcript */;
        transcript.aggregate_with(&sc, &another_transcript).unwrap();
    }
    
    // Serialize - size grows unbounded
    let bytes = bcs::to_bytes(&transcript).unwrap();
    println!("Transcript size: {} MB", bytes.len() / 1_000_000);
    
    // Deserialization and verification consume excessive resources
    let deserialized = bcs::from_bytes::<WeightedTranscript>(&bytes).unwrap();
    // verify_transcript would now process 10000+ SoKs
}
```

## Notes
The vulnerability exists because the validator transaction processing path lacks defense-in-depth. While normal DKG aggregation has contributor deduplication checks, a malicious validator can bypass these by crafting transcripts outside the normal flow and submitting them directly via `ValidatorTransaction::DKGResult`.

### Citations

**File:** crates/aptos-dkg/src/pvss/das/weighted_protocol.rs (L190-195)
```rust
    fn get_dealers(&self) -> Vec<Player> {
        self.soks
            .iter()
            .map(|(p, _, _, _)| *p)
            .collect::<Vec<Player>>()
    }
```

**File:** crates/aptos-dkg/src/pvss/das/weighted_protocol.rs (L405-407)
```rust
        for sok in &other.soks {
            self.soks.push(sok.clone());
        }
```

**File:** aptos-move/aptos-vm/src/validator_txns/dkg.rs (L106-112)
```rust
        let transcript = bcs::from_bytes::<<DefaultDKG as DKGTrait>::Transcript>(
            dkg_node.transcript_bytes.as_slice(),
        )
        .map_err(|_| Expected(TranscriptDeserializationFailed))?;

        DefaultDKG::verify_transcript(&pub_params, &transcript)
            .map_err(|_| Expected(TranscriptVerificationFailed))?;
```

**File:** types/src/dkg/real_dkg/mod.rs (L302-311)
```rust
        let main_trx_dealers = trx.main.get_dealers();
        let mut dealer_set = HashSet::with_capacity(main_trx_dealers.len());
        for dealer in main_trx_dealers.iter() {
            if let Some(dealer_addr) = all_validator_addrs.get(dealer.id) {
                dealer_set.insert(*dealer_addr);
            } else {
                bail!("invalid dealer idx");
            }
        }
        ensure!(main_trx_dealers.len() == dealer_set.len());
```

**File:** crates/aptos-dkg/src/pvss/contribution.rs (L56-76)
```rust
    // First, the PoKs
    let mut c = Gr::identity();
    for (_, c_i, _, _) in soks {
        c.add_assign(c_i)
    }

    if c.ne(pk) {
        bail!(
            "The PoK does not correspond to the dealt secret. Expected {} but got {}",
            pk,
            c
        );
    }

    let poks = soks
        .iter()
        .map(|(_, c, _, pok)| (*c, *pok))
        .collect::<Vec<(Gr, schnorr::PoK<Gr>)>>();

    // TODO(Performance): 128-bit exponents instead of powers of tau
    schnorr::pok_batch_verify::<Gr>(&poks, pk_base, &tau)?;
```
