# Audit Report

## Title
Missing Peer ID Validation in Outbound Noise Handshake Enables Peer Identity Mismatch

## Summary
The `upgrade_outbound()` function in the Noise handshake implementation does not validate that the `remote_peer_id` parameter is consistent with the `remote_public_key` before initiating the handshake. This creates an asymmetry with the inbound handshake validation and could enable peer impersonation attacks if configuration data is compromised or malformed.

## Finding Description

The `NoiseUpgrader::upgrade_outbound()` function accepts both `remote_peer_id` and `remote_public_key` as independent parameters but never validates their consistency. [1](#0-0) 

The function proceeds with the handshake using `remote_public_key` cryptographically, but uses `remote_peer_id` for peer role lookup in the trusted peers set. [2](#0-1) [3](#0-2) 

In contrast, `upgrade_inbound()` explicitly validates this consistency for untrusted peers by deriving the expected peer_id from the public key and rejecting mismatches. [4](#0-3) 

The peer_id derivation function is deterministic. [5](#0-4) 

The transport layer constructs `ConnectionMetadata` using the unchecked `remote_peer_id` parameter. [6](#0-5) 

The subsequent validation in `handle_completed_outbound_upgrade()` is ineffective because it merely compares the parameter-derived metadata against the same parameter. [7](#0-6) 

**Attack Scenario:**

If an attacker can inject malformed data into the peer configuration (seed peers file, discovered peers, or validator set data), they could map a trusted validator's `peer_id` to their own malicious `public_key`. When a node dials what it believes is the trusted validator:

1. The system looks up the peer by `peer_id` and retrieves the attacker's address/key
2. `upgrade_outbound()` is called with `peer_id` = legitimate_validator, `public_key` = attacker_key  
3. No validation occurs - the handshake proceeds
4. Connection succeeds with the attacker cryptographically
5. The system treats this connection as originating from the legitimate validator
6. The attacker inherits the trusted validator's role and privileges

The discovered peers system allows external data sources to update peer mappings. [8](#0-7) 

## Impact Explanation

This is a **Medium severity** issue per Aptos bug bounty criteria. While it doesn't allow direct fund theft or immediate consensus breaks, it enables:

- **Peer impersonation** if configuration data is manipulated
- **Trust elevation attacks** where untrusted peers are treated as validators
- **Security policy bypass** through role misattribution
- **State inconsistencies** from trusting malicious peers as validators

The impact is limited to scenarios where configuration integrity is compromised, preventing classification as Critical or High severity. However, the violation of defense-in-depth principles and the asymmetry with inbound validation represents a genuine security weakness.

## Likelihood Explanation

Likelihood is **Medium to Low** because exploitation requires:

1. Compromise or manipulation of peer configuration data (seed peers, discovery data, or filesystem access)
2. OR a separate vulnerability in configuration parsing/validation
3. Absence of server-side validation for the specific connection type

The server-side (inbound) validation provides partial mitigation in mutual authentication scenarios, reducing but not eliminating risk. The missing validation creates a security gap that could be exploited in conjunction with other vulnerabilities or configuration attacks.

## Recommendation

Add peer_id validation to `upgrade_outbound()` to match the inbound behavior:

```rust
pub async fn upgrade_outbound<TSocket, F>(
    &self,
    mut socket: TSocket,
    remote_peer_id: PeerId,
    remote_public_key: x25519::PublicKey,
    time_provider: F,
) -> Result<(NoiseStream<TSocket>, PeerRole), NoiseHandshakeError>
where
    TSocket: AsyncRead + AsyncWrite + Debug + Unpin,
    F: Fn() -> [u8; AntiReplayTimestamps::TIMESTAMP_SIZE],
{
    // ADD THIS VALIDATION:
    let derived_peer_id = aptos_types::account_address::from_identity_public_key(remote_public_key);
    if derived_peer_id != remote_peer_id {
        return Err(NoiseHandshakeError::PeerIdPublicKeyMismatch(
            remote_peer_id,
            derived_peer_id,
            remote_public_key,
        ));
    }

    // ... rest of existing implementation
}
```

This ensures both inbound and outbound handshakes enforce the same security invariant: the peer_id must be correctly derived from the public key used in the handshake.

## Proof of Concept

```rust
#[test]
fn test_outbound_peer_id_mismatch_should_fail() {
    use aptos_crypto::x25519::PrivateKey;
    use rand::SeedableRng;
    
    // Create two different keypairs
    let mut rng = ::rand::rngs::StdRng::from_seed([1u8; 32]);
    let (_, pubkey_a) = (PrivateKey::generate(&mut rng), 
                         PrivateKey::generate(&mut rng).public_key());
    let (_, pubkey_b) = (PrivateKey::generate(&mut rng),
                         PrivateKey::generate(&mut rng).public_key());
    
    // Derive peer IDs
    let peer_id_a = aptos_types::account_address::from_identity_public_key(pubkey_a);
    let peer_id_b = aptos_types::account_address::from_identity_public_key(pubkey_b);
    
    assert_ne!(peer_id_a, peer_id_b);
    
    // Setup NoiseUpgrader with mutual auth
    let ((client, _), (server, _)) = build_peers(true, None);
    
    // Attempt to dial with mismatched peer_id and public_key
    // peer_id_a but pubkey_b (MISMATCH!)
    let (dialer_socket, listener_socket) = MemorySocket::new_pair();
    
    let client_task = client.upgrade_outbound(
        dialer_socket,
        peer_id_a,  // Wrong peer ID!
        pubkey_b,   // Different public key!
        AntiReplayTimestamps::now,
    );
    
    let server_task = server.upgrade_inbound(listener_socket);
    
    let (client_result, server_result) = block_on(join(client_task, server_task));
    
    // CURRENTLY: This would succeed (BUG!)
    // SHOULD: Return PeerIdPublicKeyMismatch error
    assert!(client_result.is_err(), "Outbound handshake should reject mismatched peer_id and public_key");
}
```

**Notes**

The vulnerability exists due to inconsistent validation between inbound and outbound handshakes. While the Noise IK protocol ensures cryptographic authentication of the peer's public key, the higher-level semantic association between `PeerId` and the actual connected peer is not validated on the client side. This creates a security gap exploitable through configuration manipulation attacks, violating defense-in-depth principles. The server-side validation provides partial mitigation but doesn't eliminate the risk in all network configurations.

### Citations

**File:** network/framework/src/noise/handshake.rs (L183-189)
```rust
    pub async fn upgrade_outbound<TSocket, F>(
        &self,
        mut socket: TSocket,
        remote_peer_id: PeerId,
        remote_public_key: x25519::PublicKey,
        time_provider: F,
    ) -> Result<(NoiseStream<TSocket>, PeerRole), NoiseHandshakeError>
```

**File:** network/framework/src/noise/handshake.rs (L209-218)
```rust
        let initiator_state = self
            .noise_config
            .initiate_connection(
                &mut rng,
                prologue_msg,
                remote_public_key,
                Some(&payload),
                client_noise_msg,
            )
            .map_err(NoiseHandshakeError::BuildClientHandshakeMessageFailed)?;
```

**File:** network/framework/src/noise/handshake.rs (L260-260)
```rust
        let peer_role = self.extract_peer_role_from_trusted_peers(remote_peer_id);
```

**File:** network/framework/src/noise/handshake.rs (L394-404)
```rust
                        let derived_remote_peer_id =
                            aptos_types::account_address::from_identity_public_key(
                                remote_public_key,
                            );
                        if derived_remote_peer_id != remote_peer_id {
                            // The peer ID is not constructed correctly from the public key
                            Err(NoiseHandshakeError::ClientPeerIdMismatch(
                                remote_peer_short,
                                remote_peer_id,
                                derived_remote_peer_id,
                            ))
```

**File:** types/src/account_address.rs (L140-146)
```rust
pub fn from_identity_public_key(identity_public_key: x25519::PublicKey) -> AccountAddress {
    let mut array = [0u8; AccountAddress::LENGTH];
    let pubkey_slice = identity_public_key.as_slice();
    // keep only the last 16 bytes
    array.copy_from_slice(&pubkey_slice[x25519::PUBLIC_KEY_SIZE - AccountAddress::LENGTH..]);
    AccountAddress::new(array)
}
```

**File:** network/framework/src/transport/mod.rs (L395-406)
```rust
    Ok(Connection {
        socket,
        metadata: ConnectionMetadata::new(
            remote_peer_id,
            CONNECTION_ID_GENERATOR.next(),
            addr,
            origin,
            messaging_protocol,
            application_protocols,
            peer_role,
        ),
    })
```

**File:** network/framework/src/peer_manager/transport.rs (L238-246)
```rust
                let dialed_peer_id = connection.metadata.remote_peer_id;
                if dialed_peer_id == peer_id {
                    Ok(connection)
                } else {
                    Err(PeerManagerError::from_transport_error(format_err!(
                        "Dialed PeerId '{}' differs from expected PeerId '{}'",
                        dialed_peer_id.short_str(),
                        peer_id.short_str()
                    )))
```

**File:** network/framework/src/connectivity_manager/mod.rs (L929-944)
```rust
        for (peer_id, discovered_peer) in new_discovered_peers {
            // Don't include ourselves, because we don't need to dial ourselves
            if peer_id == self.network_context.peer_id() {
                continue;
            }

            // Create the new `DiscoveredPeer`, role is set when a `Peer` is first discovered
            let mut discovered_peers = self.discovered_peers.write();
            let peer = discovered_peers
                .peer_set
                .entry(peer_id)
                .or_insert_with(|| DiscoveredPeer::new(discovered_peer.role));

            // Update the peer's pubkeys
            let mut peer_updated = false;
            if peer.keys.update(src, discovered_peer.keys) {
```
