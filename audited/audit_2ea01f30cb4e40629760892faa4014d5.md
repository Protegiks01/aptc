# Audit Report

## Title
Missing Equivocation Detection in Order Vote Aggregation Allows Byzantine Validators to Waste Network Resources

## Summary
The `PendingOrderVotes::insert_order_vote()` function lacks equivocation detection that would identify when a Byzantine validator signs conflicting order votes for different blocks in the same round. While this does not directly break consensus safety due to quorum requirements (2f+1 threshold), it allows Byzantine validators to consume network and computational resources without detection.

## Finding Description

The order vote aggregation mechanism in `PendingOrderVotes` is missing critical equivocation detection that exists in the regular vote processing system. 

**Missing Protection:**

In `consensus/src/pending_order_votes.rs`, the `insert_order_vote()` function aggregates order votes by ledger info digest only: [1](#0-0) 

The function stores votes in a `HashMap<HashValue, (QuorumCert, OrderVoteStatus)>` keyed by ledger info digest, without tracking which validators have already voted. This means the same validator can vote for multiple different ledger infos without detection.

**Contrast with Regular Votes:**

The regular vote processing in `pending_votes.rs` explicitly tracks and detects equivocation: [2](#0-1) [3](#0-2) 

Regular votes use an `author_to_vote` HashMap to detect when a validator votes for different blocks in the same round, returning `VoteReceptionResult::EquivocateVote` and logging a security event.

**Safety Rules Gap:**

The safety rules for order votes also lack the duplicate vote prevention present in regular votes: [4](#0-3) 

Unlike regular vote signing which checks and returns the previous vote if already voted in the round: [5](#0-4) 

## Impact Explanation

**Severity: Medium**

While Byzantine validators can create conflicting order votes, they **cannot break consensus safety** because:

1. Forming an ordered certificate requires 2f+1 signatures (quorum)
2. With at most f Byzantine validators (standard BFT assumption), they cannot reach quorum alone
3. Honest validators (2f+1) will only create order votes for the legitimately certified block
4. Therefore, only one ordered certificate can form per round

The actual impact is:
- **Resource exhaustion**: Byzantine validators can send multiple conflicting order votes, forcing honest nodes to process and store redundant signatures
- **Lack of Byzantine behavior detection**: The system cannot identify and report validators engaging in equivocation on order votes
- **Monitoring gaps**: Operators lose visibility into malicious validator behavior

This qualifies as **Medium Severity** per the bug bounty criteria: "State inconsistencies requiring intervention" - while not breaking consensus, it creates operational issues and prevents proper Byzantine validator identification.

## Likelihood Explanation

**Likelihood: High**

The vulnerability is highly likely to be exploitable because:
1. Byzantine validators can trivially create multiple order votes by bypassing local safety rules
2. The network layer will accept and propagate these votes without validation
3. No detection mechanism exists to identify this behavior
4. The attack requires no special network positioning or timing

However, the **impact remains limited** due to the quorum requirement preventing actual consensus safety violations.

## Recommendation

Add equivocation detection to order vote processing:

```rust
pub struct PendingOrderVotes {
    li_digest_to_votes: HashMap<HashValue, (QuorumCert, OrderVoteStatus)>,
    // Add tracking of author votes per round
    author_to_order_vote: HashMap<Author, (OrderVote, HashValue)>,
}

impl PendingOrderVotes {
    pub fn insert_order_vote(
        &mut self,
        order_vote: &OrderVote,
        validator_verifier: &ValidatorVerifier,
        verified_quorum_cert: Option<QuorumCert>,
    ) -> OrderVoteReceptionResult {
        let li_digest = order_vote.ledger_info().hash();
        
        // Check for equivocation
        if let Some((previous_vote, previous_digest)) = 
            self.author_to_order_vote.get(&order_vote.author()) 
        {
            if &li_digest != previous_digest {
                error!(
                    SecurityEvent::ConsensusEquivocatingOrderVote,
                    remote_peer = order_vote.author(),
                    order_vote = order_vote,
                    previous_order_vote = previous_vote
                );
                return OrderVoteReceptionResult::EquivocateVote;
            }
        }
        
        // Store the vote for equivocation detection
        self.author_to_order_vote.insert(
            order_vote.author(), 
            (order_vote.clone(), li_digest)
        );
        
        // Continue with existing logic...
    }
}
```

Additionally, update `OrderVoteReceptionResult` enum to include:
```rust
pub enum OrderVoteReceptionResult {
    // ... existing variants ...
    EquivocateVote,
}
```

## Proof of Concept

```rust
#[test]
fn test_order_vote_equivocation_not_detected() {
    let (signers, verifier) = random_validator_verifier(4, Some(2), false);
    let mut pending_order_votes = PendingOrderVotes::new();
    
    // Create two different ledger infos for the same round
    let li1 = LedgerInfo::new(
        BlockInfo::new(1, 0, HashValue::random(), HashValue::random(), 0, 0, None),
        HashValue::zero(),
    );
    let li2 = LedgerInfo::new(
        BlockInfo::new(1, 0, HashValue::random(), HashValue::random(), 0, 0, None),
        HashValue::zero(),
    );
    
    let qc = QuorumCert::dummy();
    
    // Same validator creates order votes for two different blocks
    let order_vote_1 = OrderVote::new_with_signature(
        signers[0].author(),
        li1.clone(),
        signers[0].sign(&li1).unwrap(),
    );
    
    let order_vote_2 = OrderVote::new_with_signature(
        signers[0].author(),  // Same author
        li2.clone(),           // Different ledger info
        signers[0].sign(&li2).unwrap(),
    );
    
    // First order vote is accepted
    let result1 = pending_order_votes.insert_order_vote(
        &order_vote_1,
        &verifier,
        Some(qc.clone())
    );
    assert!(matches!(result1, OrderVoteReceptionResult::VoteAdded(_)));
    
    // Second order vote from same author for different block should be rejected
    // but is currently ACCEPTED - demonstrating the vulnerability
    let result2 = pending_order_votes.insert_order_vote(
        &order_vote_2,
        &verifier,
        Some(qc.clone())
    );
    
    // Currently this passes (bug), should return EquivocateVote
    assert!(matches!(result2, OrderVoteReceptionResult::VoteAdded(_)));
    // With the fix, this should be: 
    // assert!(matches!(result2, OrderVoteReceptionResult::EquivocateVote));
}
```

## Notes

While this issue does not constitute a critical consensus safety violation due to the 2f+1 quorum requirement, it represents a meaningful gap in Byzantine fault detection capabilities. The fix aligns order vote handling with the security properties of regular vote handling and improves the network's ability to identify and respond to malicious validator behavior.

### Citations

**File:** consensus/src/pending_order_votes.rs (L61-81)
```rust
    pub fn insert_order_vote(
        &mut self,
        order_vote: &OrderVote,
        validator_verifier: &ValidatorVerifier,
        verified_quorum_cert: Option<QuorumCert>,
    ) -> OrderVoteReceptionResult {
        // derive data from order vote
        let li_digest = order_vote.ledger_info().hash();

        // obtain the ledger info with signatures associated to the order vote's ledger info
        let (quorum_cert, status) = self.li_digest_to_votes.entry(li_digest).or_insert_with(|| {
            // if the ledger info with signatures doesn't exist yet, create it
            (
                verified_quorum_cert.expect(
                    "Quorum Cert is expected when creating a new entry in pending order votes",
                ),
                OrderVoteStatus::NotEnoughVotes(SignatureAggregator::new(
                    order_vote.ledger_info().clone(),
                )),
            )
        });
```

**File:** consensus/src/pending_votes.rs (L173-173)
```rust
    author_to_vote: HashMap<Author, (Vote, HashValue)>,
```

**File:** consensus/src/pending_votes.rs (L287-309)
```rust
        if let Some((previously_seen_vote, previous_li_digest)) =
            self.author_to_vote.get(&vote.author())
        {
            // is it the same vote?
            if &li_digest == previous_li_digest {
                // we've already seen an equivalent vote before
                let new_timeout_vote = vote.is_timeout() && !previously_seen_vote.is_timeout();
                if !new_timeout_vote {
                    // it's not a new timeout vote
                    return VoteReceptionResult::DuplicateVote;
                }
            } else {
                // we have seen a different vote for the same round
                error!(
                    SecurityEvent::ConsensusEquivocatingVote,
                    remote_peer = vote.author(),
                    vote = vote,
                    previous_vote = previously_seen_vote
                );

                return VoteReceptionResult::EquivocateVote;
            }
        }
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L68-74)
```rust
        // if already voted on this round, send back the previous vote
        // note: this needs to happen after verifying the epoch as we just check the round here
        if let Some(vote) = safety_data.last_vote.clone() {
            if vote.vote_data().proposed().round() == proposed_block.round() {
                return Ok(vote);
            }
        }
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L97-119)
```rust
    pub(crate) fn guarded_construct_and_sign_order_vote(
        &mut self,
        order_vote_proposal: &OrderVoteProposal,
    ) -> Result<OrderVote, Error> {
        // Exit early if we cannot sign
        self.signer()?;
        self.verify_order_vote_proposal(order_vote_proposal)?;
        let proposed_block = order_vote_proposal.block();
        let mut safety_data = self.persistent_storage.safety_data()?;

        // Record 1-chain data
        self.observe_qc(order_vote_proposal.quorum_cert(), &mut safety_data);

        self.safe_for_order_vote(proposed_block, &safety_data)?;
        // Construct and sign order vote
        let author = self.signer()?.author();
        let ledger_info =
            LedgerInfo::new(order_vote_proposal.block_info().clone(), HashValue::zero());
        let signature = self.sign(&ledger_info)?;
        let order_vote = OrderVote::new_with_signature(author, ledger_info.clone(), signature);
        self.persistent_storage.set_safety_data(safety_data)?;
        Ok(order_vote)
    }
```
