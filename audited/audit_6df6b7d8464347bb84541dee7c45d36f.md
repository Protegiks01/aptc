# Audit Report

## Title
Missing Proof Root Depth Validation Enables Panic-Based Validator Crash via Malformed Merkle Proofs

## Summary
The sparse merkle tree updater fails to validate that Merkle proofs returned from the database have the correct `root_depth`, allowing malformed proofs to trigger an uncaught panic via `.unwrap()` instead of returning a proper `UpdateError`. This can crash validator nodes and potentially corrupt in-memory tree state.

## Finding Description

The `from_persisted` function retrieves Merkle proofs from the database but only validates `bottom_depth`, not `root_depth`. [1](#0-0) 

The code assumes proofs have `root_depth` matching the requested depth, but this is never checked. When a `ProofPathInternal` is created and later split into children, it calls `sibling_at_depth(depth + 1).unwrap()` which performs bounds checking: [2](#0-1) 

If `root_depth > depth`, the bounds check `depth + 1 > root_depth()` fails, returning an `Err` that gets unwrapped into a panic: [3](#0-2) 

**Attack Scenario:**
1. Database corruption or race condition causes `proof_reader.get_proof(key, depth=10)` to return a proof with `root_depth=15` and `bottom_depth=20`
2. Validation passes since `10 <= 20` (only `bottom_depth` is checked)
3. `ProofPathInternal` created since `20 > 10`
4. Later, `into_children` calls `proof.sibling_at_depth(11).unwrap()`
5. Bounds check fails: `11 > 15` is false
6. Panic occurs, crashing the node

This breaks the **State Consistency** invariant - state updates should handle errors gracefully, not crash. It also breaks **Deterministic Execution** if different nodes encounter different database states.

## Impact Explanation

**High Severity** - Meets the "Validator node slowdowns" and "Significant protocol violations" criteria. While this requires database corruption or a bug in proof generation (limiting direct exploitability), the impact is severe:

- **Consensus disruption**: If multiple validators hit this condition, the network could lose liveness
- **State inconsistency**: A panic during tree updates could leave in-memory state corrupted
- **Non-deterministic behavior**: Different nodes with different database states could diverge

This is not Critical severity because it requires pre-existing database issues rather than being directly exploitable by an external attacker under normal conditions.

## Likelihood Explanation

**Medium likelihood** in production environments due to:

1. **Database corruption**: Hardware failures, disk corruption, or software bugs could cause malformed proofs to be persisted
2. **Race conditions**: Concurrent state sync and proof retrieval could theoretically create inconsistencies
3. **Implementation bugs**: Future changes to `JellyfishMerkleTree` or `ProofRead` implementations could inadvertently violate the root_depth assumption

The test implementation explicitly allows `proof.root_depth() <= root_depth`: [4](#0-3) 

This assertion suggests the possibility of root_depth mismatches was considered but not fully defended against in production code.

## Recommendation

Add explicit validation of proof `root_depth` in the `from_persisted` function:

```rust
fn from_persisted(
    a_descendant_key: &HashValue,
    depth: usize,
    proof_reader: &impl ProofRead,
) -> Result<Self> {
    let proof = proof_reader
        .get_proof(a_descendant_key, depth)
        .ok_or(UpdateError::MissingProof)?;
    
    // ADDED: Validate proof root_depth matches requested depth
    if proof.root_depth() > depth {
        return Err(UpdateError::ShortProof {
            key: *a_descendant_key,
            num_siblings: proof.bottom_depth(),
            depth,
        });
    }
    
    if depth > proof.bottom_depth() {
        return Err(UpdateError::ShortProof {
            key: *a_descendant_key,
            num_siblings: proof.bottom_depth(),
            depth,
        });
    }
    Ok(Self::new_on_proof_path(proof, depth))
}
```

Additionally, convert the `.unwrap()` to proper error handling: [5](#0-4) 

Change to:
```rust
let sibling_child = SubTreeInfo::new_proof_sibling(
    proof.sibling_at_depth(depth + 1)
        .map_err(|_| UpdateError::ShortProof {
            key: *a_descendent_key,
            num_siblings: proof.bottom_depth(),
            depth: depth + 1,
        })?
);
```

## Proof of Concept

```rust
#[test]
#[should_panic(expected = "Proof between depth")]
fn test_malformed_proof_panics() {
    use aptos_crypto::HashValue;
    use aptos_types::proof::{SparseMerkleProofExt, NodeInProof};
    
    // Create a malformed proof with root_depth=10, bottom_depth=15
    let leaf = SparseMerkleLeafNode::new(
        HashValue::random(),
        HashValue::random(),
    );
    let siblings = vec![
        NodeInProof::Other(HashValue::random()),
        NodeInProof::Other(HashValue::random()),
        NodeInProof::Other(HashValue::random()),
        NodeInProof::Other(HashValue::random()),
        NodeInProof::Other(HashValue::random()),
    ];
    let malformed_proof = SparseMerkleProofExt::new_partial(
        Some(leaf),
        siblings,
        10, // root_depth=10
    );
    
    // Create a malicious ProofReader that returns this malformed proof
    struct MaliciousProofReader {
        proof: SparseMerkleProofExt,
    }
    
    impl ProofRead for MaliciousProofReader {
        fn get_proof(&self, _key: &HashValue, _depth: usize) -> Option<SparseMerkleProofExt> {
            Some(self.proof.clone())
        }
    }
    
    let proof_reader = MaliciousProofReader {
        proof: malformed_proof,
    };
    
    let root = InMemSubTree::Empty;
    let updates = vec![(HashValue::random(), Some(HashValue::random()))];
    
    // This will panic when it tries to call sibling_at_depth(6)
    // with a proof that has root_depth=10
    let _ = SubTreeUpdater::update(root, &updates, &proof_reader, 0);
}
```

## Notes

The `UpdateError` enum only defines two variants (`MissingProof` and `ShortProof`), confirming the security question's premise: [6](#0-5) 

Additional failure modes beyond these two errors include:
1. **Panic from `.unwrap()`** on proof validation (demonstrated above)
2. **Panic from `unreachable!()`** if invariants are violated [7](#0-6) 
3. **Out-of-memory panics** from allocations (though not exploitable as a security issue)

These panics bypass error handling and could leave the sparse merkle tree in an inconsistent state if they occur mid-update.

### Citations

**File:** storage/scratchpad/src/sparse_merkle/updater.rs (L150-166)
```rust
    fn from_persisted(
        a_descendant_key: &HashValue,
        depth: usize,
        proof_reader: &impl ProofRead,
    ) -> Result<Self> {
        let proof = proof_reader
            .get_proof(a_descendant_key, depth)
            .ok_or(UpdateError::MissingProof)?;
        if depth > proof.bottom_depth() {
            return Err(UpdateError::ShortProof {
                key: *a_descendant_key,
                num_siblings: proof.bottom_depth(),
                depth,
            });
        }
        Ok(Self::new_on_proof_path(proof, depth))
    }
```

**File:** storage/scratchpad/src/sparse_merkle/updater.rs (L251-257)
```rust
                PersistedSubTreeInfo::ProofPathInternal { proof } => {
                    let sibling_child =
                        SubTreeInfo::new_proof_sibling(proof.sibling_at_depth(depth + 1).unwrap());
                    let on_path_child =
                        SubTreeInfo::new_on_proof_path(myself.expect_into_proof(), depth + 1);
                    swap_if(on_path_child, sibling_child, a_descendent_key.bit(depth))
                },
```

**File:** storage/scratchpad/src/sparse_merkle/updater.rs (L273-275)
```rust
                PersistedSubTreeInfo::ProofPathInternal { .. } => {
                    unreachable!()
                },
```

**File:** types/src/proof/definition.rs (L223-232)
```rust
    pub fn sibling_at_depth(&self, depth: usize) -> Result<&NodeInProof> {
        ensure!(
            depth > self.root_depth() && depth <= self.bottom_depth(),
            "Proof between depth {} and {} does not cover depth {}",
            self.root_depth(),
            self.bottom_depth(),
            depth,
        );
        Ok(&self.siblings[depth - self.root_depth() - 1])
    }
```

**File:** storage/scratchpad/src/sparse_merkle/test_utils/proof_reader.rs (L18-26)
```rust
impl ProofRead for ProofReader {
    fn get_proof(&self, key: &HashValue, root_depth: usize) -> Option<SparseMerkleProofExt> {
        let ret = self.0.get(key);
        if let Some(proof) = ret {
            assert!(proof.root_depth() <= root_depth);
        }
        ret.cloned()
    }
}
```

**File:** storage/scratchpad/src/sparse_merkle/mod.rs (L583-603)
```rust
/// All errors `update` can possibly return.
#[derive(Debug, Error, Eq, PartialEq)]
pub enum UpdateError {
    /// The update intends to insert a key that does not exist in the tree, so the operation needs
    /// proof to get more information about the tree, but no proof is provided.
    #[error("Missing Proof")]
    MissingProof,
    /// At `depth` a persisted subtree was encountered and a proof was requested to assist finding
    /// details about the subtree, but the result proof indicates the subtree is empty.
    #[error(
        "Short proof: key: {}, num_siblings: {}, depth: {}",
        key,
        num_siblings,
        depth
    )]
    ShortProof {
        key: HashValue,
        num_siblings: usize,
        depth: usize,
    },
}
```
