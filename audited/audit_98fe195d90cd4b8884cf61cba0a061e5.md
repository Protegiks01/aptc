# Audit Report

## Title
Lack of Transaction Filter Transparency Enables Covert Validator Censorship

## Summary
Aptos validators can configure transaction filters at multiple stages (mempool, consensus, execution) to reject specific transactions based on sender address, entry function, or other criteria. These filter configurations are stored locally and are not publicly visible or auditable. Mainnet validators are explicitly prevented from exposing their configurations, enabling covert censorship of transactions without accountability or detection mechanisms.

## Finding Description

The Aptos transaction filtering system allows validators to configure filters that operate at different stages of transaction processing. The most concerning is the `consensus_filter` which allows validators to silently reject block proposals containing specific transactions. [1](#0-0) 

These filters support matching on multiple criteria including sender address, module address, entry function, public key, and transaction ID. [2](#0-1) 

**Critical Transparency Failures:**

1. **No Public Exposure by Default**: The inspection service's configuration endpoint is disabled by default and validators control whether to expose it. [3](#0-2) 

2. **Mainnet Validator Restriction**: Mainnet validators are explicitly prevented from exposing their node configuration, including transaction filters. [4](#0-3) 

3. **No On-Chain Record**: ValidatorConfig stored on-chain contains only consensus public key and network addresses, with no filter information. [5](#0-4) 

4. **Silent Consensus Rejection**: When a validator's consensus filter denies transactions in a block proposal, they simply don't vote on that block with only a local counter increment. [6](#0-5) 

**Attack Scenario:**

A validator configures `consensus_filter` to deny transactions from specific addresses or calling specific entry functions. When a block proposer includes these transactions:

1. The filtering validator checks inline transactions against their filter [7](#0-6) 

2. If denied transactions are found, the validator drops the proposal and doesn't vote
3. The transaction remains in mempool indefinitely with no rejection notification to the user
4. Users cannot distinguish between network congestion and covert censorship [8](#0-7) 

The test demonstrates that consensus-filtered transactions expire with "Used to be pending and now not found. Transaction expired" - indistinguishable from normal timeouts.

## Impact Explanation

This issue meets **Medium Severity** criteria as it enables:

1. **Censorship Without Accountability**: Validators can selectively censor transactions from specific users, contracts, or entry functions without public disclosure or audit trail
2. **User Harm**: Legitimate users cannot determine if their transactions are being censored versus experiencing network issues
3. **State Inconsistency Potential**: Different validators with different filters can cause inconsistent block voting patterns, though consensus still progresses
4. **No Detection Mechanism**: No on-chain governance or monitoring system can detect or audit filter usage

While this doesn't directly cause fund loss or consensus safety violations, it undermines the censorship resistance and transparency expected in a decentralized blockchain system. The lack of auditability means malicious censorship cannot be proven or challenged.

## Likelihood Explanation

**Likelihood: High**

- Filters are easily configurable in the node configuration file
- No technical barriers prevent validators from enabling filters
- No penalties or detection mechanisms exist
- Validators may face external pressure (regulatory, political) to filter certain transactions
- The system is designed to allow this behavior without visibility

The feature is production-ready and documented, making exploitation straightforward for any validator operator.

## Recommendation

Implement a multi-layered transparency and governance framework:

**1. On-Chain Filter Registration:**
Add filter configuration commitments to the ValidatorConfig resource in `stake.move`:
```move
struct ValidatorConfig has key, copy, store, drop {
    consensus_pubkey: vector<u8>,
    network_addresses: vector<u8>,
    fullnode_addresses: vector<u8>,
    validator_index: u64,
    filter_config_hash: Option<vector<u8>>, // Hash of filter configuration
    filter_policy_url: Option<String>, // URL to public filter policy
}
```

**2. Transparency Reporting:**
Add filter activity metrics that are publicly queryable:
- Number of proposals rejected due to filters
- Aggregated (privacy-preserving) statistics on filtered transaction types
- Timestamp of last filter configuration change

**3. Governance Oversight:**
Implement on-chain governance proposals that can:
- Query validator filter configurations
- Require validators to justify filtering policies
- Enable community review of filter usage patterns
- Penalize validators for undisclosed or abusive filtering

**4. User Notification:**
When transactions are filtered at consensus, emit events or return specific error codes that distinguish censorship from network issues.

**5. Mandatory Disclosure:**
Require mainnet validators to publish their filtering policies as part of validator registration, with cryptographic commitments to prevent silent changes.

## Proof of Concept

The existing smoke test demonstrates the vulnerability: [9](#0-8) 

**Steps to reproduce:**

1. Start a local Aptos network with 3 validators
2. Configure `consensus_filter` on all validators to deny transactions from a specific sender address
3. Create an account and fund it
4. Submit a transaction from the filtered address
5. Observe that:
   - Transaction is accepted by mempool (no immediate rejection)
   - Transaction is never included in any block
   - Transaction expires with generic timeout error
   - No public information reveals it was filtered
   - Inspection service endpoint (if enabled) shows filters only with debug format, easily disabled

**To verify lack of transparency:**

1. Query the ValidatorConfig on-chain - no filter information present
2. Query any public API endpoint - no filter exposure
3. Check inspection service - disabled by default on mainnet validators per sanitizer
4. Monitor consensus metrics - only local counters, not broadcasted

The system provides no mechanism for users to detect, prove, or challenge transaction censorship by validators.

## Notes

This finding reveals a fundamental transparency gap in Aptos's transaction filtering design. While filters serve legitimate purposes (spam prevention, regulatory compliance), the complete lack of visibility and auditability enables abuse without accountability. The explicit prevention of mainnet validators exposing configurations suggests this opacity is intentional rather than an oversight.

The issue is particularly concerning because:
- Consensus filters are silent (unlike mempool filters which return `RejectedByFilter` errors)
- No on-chain governance oversight mechanism exists
- Users have no recourse to detect or prove censorship
- Different validators can have different filters, creating unpredictable behavior

This undermines core blockchain principles of transparency and censorship resistance, even though it doesn't directly break consensus safety or cause fund loss.

### Citations

**File:** config/src/config/transaction_filters_config.rs (L10-18)
```rust
#[derive(Clone, Debug, Default, Deserialize, PartialEq, Eq, Serialize)]
#[serde(default, deny_unknown_fields)]
pub struct TransactionFiltersConfig {
    pub api_filter: TransactionFilterConfig, // Filter for the API (e.g., txn simulation)
    pub consensus_filter: BlockTransactionFilterConfig, // Filter for consensus (e.g., proposal voting)
    pub execution_filter: BlockTransactionFilterConfig, // Filter for execution (e.g., block execution)
    pub mempool_filter: TransactionFilterConfig,        // Filter for mempool (e.g., txn submission)
    pub quorum_store_filter: BatchTransactionFilterConfig, // Filter for quorum store (e.g., batch voting)
}
```

**File:** crates/aptos-transaction-filters/src/transaction_filter.rs (L169-180)
```rust
/// A matcher that defines the criteria for matching transactions
#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
pub enum TransactionMatcher {
    All,                                           // Matches any transaction
    TransactionId(HashValue),                      // Matches a specific transaction by its ID
    Sender(AccountAddress), // Matches any transaction sent by a specific account address
    ModuleAddress(AccountAddress), // Matches any transaction that calls a module at a specific address
    EntryFunction(AccountAddress, String, String), // Matches any transaction that calls a specific entry function in a module
    AccountAddress(AccountAddress), // Matches any transaction that involves a specific account address
    PublicKey(AnyPublicKey),        // Matches any transaction that involves a specific public key
    EncryptedTransaction,           // Matches any encrypted transaction
}
```

**File:** config/src/config/inspection_service_config.rs (L26-36)
```rust
impl Default for InspectionServiceConfig {
    fn default() -> InspectionServiceConfig {
        InspectionServiceConfig {
            address: "0.0.0.0".to_string(),
            port: 9101,
            expose_configuration: false,
            expose_identity_information: true,
            expose_peer_information: true,
            expose_system_information: true,
        }
    }
```

**File:** config/src/config/inspection_service_config.rs (L54-64)
```rust
        // Verify that mainnet validators do not expose the configuration
        if let Some(chain_id) = chain_id {
            if node_type.is_validator()
                && chain_id.is_mainnet()
                && inspection_service_config.expose_configuration
            {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "Mainnet validators should not expose the node configuration!".to_string(),
                ));
            }
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L161-168)
```text
    struct ValidatorConfig has key, copy, store, drop {
        consensus_pubkey: vector<u8>,
        network_addresses: vector<u8>,
        // to make it compatible with previous definition, remove later
        fullnode_addresses: vector<u8>,
        // Index in the active set if the validator corresponding to this stake pool is active.
        validator_index: u64,
    }
```

**File:** consensus/src/round_manager.rs (L1204-1214)
```rust
        if let Err(error) = self
            .block_store
            .check_denied_inline_transactions(&proposal, &self.block_txn_filter_config)
        {
            counters::REJECTED_PROPOSAL_DENY_TXN_COUNT.inc();
            bail!(
                "[RoundManager] Proposal for block {} contains denied inline transactions: {}. Dropping proposal!",
                proposal.id(),
                error
            );
        }
```

**File:** consensus/src/payload_manager/quorum_store_payload_manager.rs (L308-347)
```rust
    fn check_denied_inline_transactions(
        &self,
        block: &Block,
        block_txn_filter_config: &BlockTransactionFilterConfig,
    ) -> anyhow::Result<()> {
        // If the filter is disabled, return early
        if !block_txn_filter_config.is_enabled() {
            return Ok(());
        }

        // Get the inline transactions for the block proposal
        let inline_transactions = get_inline_transactions(block);
        if inline_transactions.is_empty() {
            return Ok(());
        }

        // Fetch the block metadata
        let block_id = block.id();
        let block_author = block.author();
        let block_epoch = block.epoch();
        let block_timestamp = block.timestamp_usecs();

        // Identify any denied inline transactions
        let block_transaction_filter = block_txn_filter_config.block_transaction_filter();
        let denied_inline_transactions = block_transaction_filter.get_denied_block_transactions(
            block_id,
            block_author,
            block_epoch,
            block_timestamp,
            inline_transactions,
        );
        if !denied_inline_transactions.is_empty() {
            return Err(anyhow::anyhow!(
                "Inline transactions for QuorumStorePayload denied by block transaction filter: {:?}",
                denied_inline_transactions
            ));
        }

        Ok(()) // No transactions were denied
    }
```

**File:** testsuite/smoke-test/src/transaction_filter.rs (L34-113)
```rust
async fn test_consensus_block_filter() {
    // Generate a new key pair and sender address
    let (private_key, sender_address) = create_sender_account();

    // Create a new swarm with an inline consensus filter that denies transactions
    // from the sender, and disable quorum store (to ensure the filter is applied).
    let mut swarm = SwarmBuilder::new_local(3)
        .with_aptos()
        .with_init_config(Arc::new(move |_, config, _| {
            filter_inline_transactions(config, sender_address);
        }))
        .with_init_genesis_config(Arc::new(|genesis_config| {
            genesis_config.consensus_config = OnChainConsensusConfig::V4 {
                alg: ConsensusAlgorithmConfig::default_with_quorum_store_disabled(),
                vtxn: ValidatorTxnConfig::default_for_genesis(),
                window_size: DEFAULT_WINDOW_SIZE,
            };
        }))
        .build()
        .await;

    // Execute a few regular transactions and verify that they are processed correctly
    execute_test_transactions(&mut swarm).await;

    // Prepare a transaction from the sender address
    let transaction = create_transaction_from_sender(private_key, sender_address, &mut swarm).await;

    // Submit the transaction and wait for it to be processed
    let aptos_public_info = swarm.aptos_public_info();
    let response = aptos_public_info
        .client()
        .submit_and_wait(&transaction)
        .await;

    // Verify the transaction was dropped by the consensus filter
    let error = response.unwrap_err();
    assert!(error
        .to_string()
        .contains("Used to be pending and now not found. Transaction expired."));

    // Execute a few more transactions and verify that they are processed correctly
    execute_test_transactions(&mut swarm).await;
}

#[tokio::test]
async fn test_mempool_transaction_filter() {
    // Generate a new key pair and sender address
    let (private_key, sender_address) = create_sender_account();

    // Create a new swarm with a mempool filter that denies transactions from the sender
    let mut swarm = SwarmBuilder::new_local(3)
        .with_aptos()
        .with_init_config(Arc::new(move |_, config, _| {
            filter_mempool_transactions(config, sender_address);
        }))
        .build()
        .await;

    // Execute a few regular transactions and verify that they are processed correctly
    execute_test_transactions(&mut swarm).await;

    // Prepare a transaction from the sender address
    let transaction = create_transaction_from_sender(private_key, sender_address, &mut swarm).await;

    // Submit the transaction and wait for it to be processed
    let aptos_public_info = swarm.aptos_public_info();
    let response = aptos_public_info
        .client()
        .submit_and_wait(&transaction)
        .await;

    // Verify the transaction was rejected by the mempool filter
    let error = response.unwrap_err();
    assert!(error
        .to_string()
        .contains("API error Error(RejectedByFilter)"));

    // Execute a few more transactions and verify that they are processed correctly
    execute_test_transactions(&mut swarm).await;
}
```
