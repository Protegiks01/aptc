# Audit Report

## Title
Non-Deterministic HashMap Serialization in OnChainConsensusConfig Can Cause Consensus Failure and Backup Inconsistencies

## Summary
The `ProposerElectionType::RoundProposer` variant contains a `HashMap<Round, AccountAddress>` that lacks deterministic iteration order. When serialized via BCS for storage or backup, this can produce different byte sequences across nodes, potentially causing consensus failures and guaranteed backup data inconsistencies. [1](#0-0) 

## Finding Description

The `reply_with_bcs_bytes()` function in the backup service correctly uses BCS serialization, but BCS determinism depends on the underlying Rust types implementing `Serialize` deterministically. [2](#0-1) 

The vulnerability exists in the `ProposerElectionType` enum which uses standard derive macros without custom serialization logic. The `RoundProposer` variant contains a `HashMap` that has non-deterministic iteration order in Rust.

When `OnChainConsensusConfig` (which contains `ProposerElectionType`) is stored as blockchain state or backed up, the serialization order of HashMap entries is undefined. This violates Aptos' secure coding guidelines which explicitly warn against this pattern: [3](#0-2) 

**Attack Path:**

1. A governance proposal updates `OnChainConsensusConfig` to use `ProposerElectionType::RoundProposer` with a non-empty HashMap
2. During transaction execution, each validator serializes the config to BCS bytes for storage
3. HashMap iteration order differs across validators due to non-deterministic hashing
4. Validators compute different state roots, causing consensus failure
5. Even if consensus doesn't immediately fail, backup operations will produce inconsistent data across nodes

The backup service retrieves state via `get_state_item_iter()` which returns stored `StateValue` objects containing these serialized configs: [4](#0-3) 

The consensus layer actively uses this configuration during epoch transitions: [5](#0-4) 

## Impact Explanation

This is a **Critical Severity** vulnerability that violates the fundamental "Deterministic Execution" invariant: "All validators must produce identical state roots for identical blocks."

If triggered:
- **Consensus Safety Violation**: Different validators would disagree on state root hashes, causing network partition requiring a hardfork
- **Backup Data Inconsistency**: Nodes would produce different backup files for identical logical state, preventing reliable disaster recovery
- **State Verification Failure**: Merkle proof verification would fail across nodes

Per Aptos bug bounty criteria, this qualifies as Critical Severity due to:
- Consensus/Safety violations
- Non-recoverable network partition (requires hardfork)
- State inconsistencies breaking core system invariants

## Likelihood Explanation

**Likelihood: Medium**

The vulnerability is dormant but exploitable:

- `RoundProposer` is not used in the default genesis configuration (which uses `LeaderReputation`)
- However, it IS a supported configuration option with production code paths in `epoch_manager.rs`
- Any governance proposal setting `RoundProposer` with a non-empty HashMap (2+ entries) would trigger the issue
- The code has no validation preventing this configuration
- Tests demonstrate this variant is intentionally supported [6](#0-5) 

The attack requires no special privileges beyond submitting a governance proposal, making it accessible to any governance participant.

## Recommendation

Replace `HashMap` with `BTreeMap` in `ProposerElectionType::RoundProposer` to ensure deterministic serialization order:

**File: `types/src/on_chain_config/consensus_config.rs`**

Change line 522 from:
```rust
RoundProposer(HashMap<Round, AccountAddress>),
```
to:
```rust
RoundProposer(BTreeMap<Round, AccountAddress>),
```

Update all imports and usages accordingly. `BTreeMap` maintains sorted order by keys, ensuring deterministic iteration and serialization.

This aligns with the codebase pattern used in other critical structures: [7](#0-6) 

## Proof of Concept

```rust
use std::collections::HashMap;
use aptos_types::on_chain_config::{OnChainConsensusConfig, ConsensusConfigV1, ProposerElectionType};
use move_core_types::account_address::AccountAddress;

#[test]
fn test_hashmap_serialization_non_determinism() {
    // Create two identical configs with same HashMap contents
    let addr1 = AccountAddress::from_hex_literal("0x1").unwrap();
    let addr2 = AccountAddress::from_hex_literal("0x2").unwrap();
    
    let mut map1 = HashMap::new();
    map1.insert(1u64, addr1);
    map1.insert(2u64, addr2);
    
    let mut map2 = HashMap::new();
    map2.insert(2u64, addr2);
    map2.insert(1u64, addr1);
    
    let config1 = OnChainConsensusConfig::V1(ConsensusConfigV1 {
        proposer_election_type: ProposerElectionType::RoundProposer(map1),
        ..ConsensusConfigV1::default()
    });
    
    let config2 = OnChainConsensusConfig::V1(ConsensusConfigV1 {
        proposer_election_type: ProposerElectionType::RoundProposer(map2),
        ..ConsensusConfigV1::default()
    });
    
    let bytes1 = bcs::to_bytes(&config1).unwrap();
    let bytes2 = bcs::to_bytes(&config2).unwrap();
    
    // These SHOULD be equal (same logical content) but MAY differ 
    // due to HashMap iteration order non-determinism
    // This demonstrates the vulnerability
    assert_eq!(bytes1, bytes2, "BCS serialization should be deterministic!");
}
```

This test may pass or fail depending on HashMap's internal state, demonstrating the non-determinism. With `BTreeMap`, it would consistently pass.

**Notes**

The vulnerability exists in the type system design rather than the backup service itself. The `reply_with_bcs_bytes()` function correctly uses BCS serialization, but the type safety assumption that all `Serialize` types are deterministic is violated by `HashMap` usage. This is a systemic issue that could affect other on-chain configs or state structures using HashMap, warranting a comprehensive audit of all serialized types in the codebase.

### Citations

**File:** types/src/on_chain_config/consensus_config.rs (L508-523)
```rust
#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
#[serde(rename_all = "snake_case")] // cannot use tag = "type" as nested enums cannot work, and bcs doesn't support it
pub enum ProposerElectionType {
    // Choose the smallest PeerId as the proposer
    // with specified param contiguous_rounds
    FixedProposer(u32),
    // Round robin rotation of proposers
    // with specified param contiguous_rounds
    RotatingProposer(u32),
    // Committed history based proposer election
    LeaderReputation(LeaderReputationType),
    // Pre-specified proposers for each round,
    // or default proposer if round proposer not
    // specified
    RoundProposer(HashMap<Round, AccountAddress>),
}
```

**File:** types/src/on_chain_config/consensus_config.rs (L633-648)
```rust
    fn test_config_serialization_non_default() {
        let config = OnChainConsensusConfig::V1(ConsensusConfigV1 {
            proposer_election_type: ProposerElectionType::RoundProposer(HashMap::from([(
                1,
                AccountAddress::random(),
            )])),
            ..ConsensusConfigV1::default()
        });

        let s = serde_yaml::to_string(&config).unwrap();
        let result = serde_yaml::from_str::<OnChainConsensusConfig>(&s).unwrap();
        assert!(matches!(
            result.proposer_election_type(),
            ProposerElectionType::RoundProposer(_value)
        ));
    }
```

**File:** storage/backup/backup-service/src/handlers/utils.rs (L35-44)
```rust
pub(super) fn reply_with_bcs_bytes<R: Serialize>(
    endpoint: &str,
    record: &R,
) -> DbResult<Box<dyn Reply>> {
    let bytes = bcs::to_bytes(record)?;
    THROUGHPUT_COUNTER
        .with_label_values(&[endpoint])
        .inc_by(bytes.len() as u64);
    Ok(Box::new(bytes))
}
```

**File:** RUST_SECURE_CODING.md (L121-131)
```markdown
### Data Structures with Deterministic Internal Order

Certain data structures, like HashMap and HashSet, do not guarantee a deterministic order for the elements stored within them. This lack of order can lead to problems in operations that require processing elements in a consistent sequence across multiple executions. In the Aptos blockchain, deterministic data structures help in achieving consensus, maintaining the integrity of the ledger, and ensuring that computations can be reliably reproduced across different nodes.

Below is a list of deterministic data structures available in Rust. Please note, this list may not be exhaustive:

- **BTreeMap:** maintains its elements in sorted order by their keys.
- **BinaryHeap:** It maintains its elements in a heap order, which is a complete binary tree where each parent node is less than or equal to its child nodes.
- **Vec**: It maintains its elements in the order in which they were inserted. ⚠️
- **LinkedList:** It maintains its elements in the order in which they were inserted. ⚠️
- **VecDeque:** It maintains its elements in the order in which they were inserted. ⚠️
```

**File:** storage/aptosdb/src/backup/backup_handler.rs (L144-162)
```rust
    /// Iterate through items in a state snapshot
    pub fn get_state_item_iter(
        &self,
        version: Version,
        start_idx: usize,
        limit: usize,
    ) -> Result<impl Iterator<Item = Result<(StateKey, StateValue)>> + Send + use<>> {
        let iterator = self
            .state_store
            .get_state_key_and_value_iter(version, start_idx)?
            .take(limit)
            .enumerate()
            .map(move |(idx, res)| {
                BACKUP_STATE_SNAPSHOT_VERSION.set(version as i64);
                BACKUP_STATE_SNAPSHOT_LEAF_IDX.set((start_idx + idx) as i64);
                res
            });
        Ok(Box::new(iterator))
    }
```

**File:** consensus/src/epoch_manager.rs (L396-405)
```rust
            ProposerElectionType::RoundProposer(round_proposers) => {
                // Hardcoded to the first proposer
                let default_proposer = proposers
                    .first()
                    .expect("INVARIANT VIOLATION: proposers is empty");
                Arc::new(RoundProposer::new(
                    round_proposers.clone(),
                    *default_proposer,
                ))
            },
```

**File:** types/src/write_set.rs (L745-749)
```rust
#[derive(Clone, Debug, Default, Eq, PartialEq, Serialize, Deserialize)]
pub struct WriteSetMut {
    // TODO: Change to HashMap with a stable iterator for serialization.
    write_set: BTreeMap<StateKey, WriteOp>,
}
```
