# Audit Report

## Title
Data Integrity Vulnerability in Indexer File Store Skip Operation Leading to Incorrect Transaction Delivery

## Summary
The `get_transactions_with_durations` method in the file store operator contains a data integrity vulnerability where the skip operation can silently return incorrect transactions or empty results when file contents don't match expected invariants, with no validation of starting version or transaction count. [1](#0-0) 

## Finding Description

The vulnerability exists in the transaction retrieval logic. When a client requests transactions starting at a specific version, the code:

1. Calculates which file to fetch using `version / FILE_ENTRY_TRANSACTION_COUNT * FILE_ENTRY_TRANSACTION_COUNT` [2](#0-1) 

2. Loads the entire file containing ~1000 transactions [3](#0-2) 

3. Skips `version % FILE_ENTRY_TRANSACTION_COUNT` transactions [4](#0-3) 

**Critical flaw:** There is no validation that:
- The file's `starting_version` field matches the expected starting version
- The file contains enough transactions to perform the skip operation
- The file contains exactly 1000 transactions as expected

**Attack Scenarios:**

**Scenario 1 - File Corruption/Misplacement:**
- Client requests version 1500
- File at path for version 1000 is corrupted and contains transactions 2000-2999
- Skip amount: 1500 % 1000 = 500
- **Result:** Client receives transactions 2500-2999 instead of 1500-1999

**Scenario 2 - Incomplete File:**
- Client requests version 1900  
- File contains only 200 transactions (1000-1199) due to incomplete write
- Skip amount: 1900 % 1000 = 900
- **Result:** Empty vector returned (skip exceeds available transactions)

**Scenario 3 - Attacker File Replacement:**
- Attacker with GCS/storage access replaces file
- Downstream indexers receive arbitrary transaction data
- No detection mechanism exists

The indexer-grpc data service directly uses this method and assumes returned transactions start at `starting_version`: [5](#0-4) 

The service calculates end versions assuming correctness: [6](#0-5) 

## Impact Explanation

**Severity: Medium** - While this is off-chain indexer infrastructure and doesn't directly affect consensus or validator operations, it represents a significant data integrity violation.

This qualifies as **"State inconsistencies requiring intervention"** under Medium severity because:
- External indexers consuming this data would compute incorrect derived state (balances, NFT ownership, etc.)
- The canonical on-chain state remains correct, but indexer databases become corrupted
- Detection requires manual verification against blockchain state
- Recovery requires reindexing from scratch

**Note:** This vulnerability is in auxiliary infrastructure (indexer-grpc), not core consensus/execution layers. While important for data availability, it does not threaten blockchain security directly.

## Likelihood Explanation

**Likelihood: Medium to High**

This can be triggered by:
1. **Natural causes:** Disk corruption, network interruptions during file writes, cloud storage eventual consistency issues
2. **Software bugs:** Race conditions in upload logic, incomplete error handling
3. **Malicious actors:** Compromise of GCS bucket credentials or local file system access
4. **Legacy data:** Files created by older versions with different validation

The absence of defensive validation makes this a systemic weakness rather than an edge case.

## Recommendation

Add validation in `get_transactions_with_durations` before the skip operation:

```rust
let transactions_in_storage = tokio::task::spawn_blocking(move || {
    FileEntry::new(bytes, storage_format).into_transactions_in_storage()
})
.await
.context("Converting storage bytes to FileEntry transactions thread panicked")?;

// VALIDATION: Check starting version matches expected
let expected_starting_version = 
    version / FILE_ENTRY_TRANSACTION_COUNT * FILE_ENTRY_TRANSACTION_COUNT;
let actual_starting_version = transactions_in_storage
    .starting_version
    .context("File missing starting_version field")?;
    
anyhow::ensure!(
    actual_starting_version == expected_starting_version,
    "File starting_version mismatch: expected {}, got {}",
    expected_starting_version,
    actual_starting_version
);

// VALIDATION: Check sufficient transactions for skip
let skip_amount = (version % FILE_ENTRY_TRANSACTION_COUNT) as usize;
let transaction_count = transactions_in_storage.transactions.len();

anyhow::ensure!(
    transaction_count > skip_amount,
    "Insufficient transactions in file: has {}, need to skip {}",
    transaction_count,
    skip_amount
);

Ok((
    transactions_in_storage
        .transactions
        .into_iter()
        .skip(skip_amount)
        .collect(),
    io_duration,
    decoding_duration,
))
```

## Proof of Concept

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use aptos_protos::indexer::v1::TransactionsInStorage;
    use aptos_protos::transaction::v1::Transaction;
    
    #[test]
    #[should_panic(expected = "File starting_version mismatch")]
    fn test_skip_with_wrong_starting_version() {
        // Simulate file containing wrong version range
        let wrong_transactions: Vec<Transaction> = (2000..3000)
            .map(|v| Transaction {
                version: v,
                ..Default::default()
            })
            .collect();
        
        let storage = TransactionsInStorage {
            starting_version: Some(2000), // Wrong! Should be 1000
            transactions: wrong_transactions,
        };
        
        // Request version 1500, expect skip of 500
        // With validation, this should fail
        let skip_amount = (1500 % 1000) as usize;
        let _result: Vec<Transaction> = storage
            .transactions
            .into_iter()
            .skip(skip_amount)
            .collect();
        
        // Without validation: returns versions 2500-2999 (WRONG!)
        // With validation: panics with mismatch error (CORRECT)
    }
    
    #[test]
    fn test_skip_exceeds_available_transactions() {
        // Simulate corrupted file with only 200 transactions
        let partial_transactions: Vec<Transaction> = (1000..1200)
            .map(|v| Transaction {
                version: v,
                ..Default::default()
            })
            .collect();
        
        let storage = TransactionsInStorage {
            starting_version: Some(1000),
            transactions: partial_transactions,
        };
        
        // Request version 1900, skip = 900
        let skip_amount = (1900 % 1000) as usize;
        let result: Vec<Transaction> = storage
            .transactions
            .into_iter()
            .skip(skip_amount)
            .collect();
        
        // Returns empty vector instead of expected 1900-1999!
        assert_eq!(result.len(), 0);
        // Should have failed validation before skip
    }
}
```

## Notes

This vulnerability affects the **indexer-grpc infrastructure** (off-chain data service), not core blockchain consensus or execution. While it represents a data integrity issue that could impact external indexers, it does not directly threaten:
- Consensus safety or liveness
- On-chain state correctness  
- Validator operations
- Funds or assets

The canonical blockchain state maintained by validators remains unaffected. However, external systems relying on the indexer-grpc service for transaction data could receive incorrect information, leading to corrupted derived state in their databases.

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/file_store_operator/mod.rs (L59-86)
```rust
    async fn get_transactions_with_durations(
        &self,
        version: u64,
        retries: u8,
    ) -> Result<(Vec<Transaction>, f64, f64)> {
        let io_start_time = std::time::Instant::now();
        let bytes = self.get_raw_file_with_retries(version, retries).await?;
        let io_duration = io_start_time.elapsed().as_secs_f64();
        let decoding_start_time = std::time::Instant::now();
        let storage_format = self.storage_format();

        let transactions_in_storage = tokio::task::spawn_blocking(move || {
            FileEntry::new(bytes, storage_format).into_transactions_in_storage()
        })
        .await
        .context("Converting storage bytes to FileEntry transactions thread panicked")?;

        let decoding_duration = decoding_start_time.elapsed().as_secs_f64();
        Ok((
            transactions_in_storage
                .transactions
                .into_iter()
                .skip((version % FILE_ENTRY_TRANSACTION_COUNT) as usize)
                .collect(),
            io_duration,
            decoding_duration,
        ))
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/compression_util.rs (L240-242)
```rust
    pub fn build_key(version: u64, storage_format: StorageFormat) -> String {
        let starting_version =
            version / FILE_ENTRY_TRANSACTION_COUNT * FILE_ENTRY_TRANSACTION_COUNT;
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service/src/service.rs (L785-787)
```rust
    let (transactions, io_duration, decoding_duration) = file_store_operator
        .get_transactions_with_durations(starting_version, NUM_DATA_FETCH_RETRIES)
        .await?;
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service/src/service.rs (L798-799)
```rust
        Some(starting_version as i64),
        Some(starting_version as i64 + num_of_transactions as i64 - 1),
```
