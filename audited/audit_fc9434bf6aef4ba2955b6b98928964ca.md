# Audit Report

## Title
Batch Retrieval Task Panic on V2 Batches Causes Validator DoS and Consensus Disruption

## Summary
The batch serving task unconditionally converts all retrieved batches to V1 format using `.expect()`, causing a panic when V2 batches are requested. This creates a validator DoS vulnerability and consensus disruption when validators enable the `enable_batch_v2` configuration flag.

## Finding Description

The quorum store database stores V1 and V2 batches in separate column families (`BATCH_CF_NAME` and `BATCH_V2_CF_NAME`), and batch creation is controlled by the `enable_batch_v2` configuration flag. [1](#0-0) 

When a validator enables V2 batch creation, it generates V2 batches using `BatchInfoExt::V2` variant. [2](#0-1) 

However, the batch serving task assumes all batches are V1 and unconditionally converts them using `.expect()`. [3](#0-2) 

The conversion from `Batch<BatchInfoExt>` to `Batch<BatchInfo>` explicitly fails for V2 batches. [4](#0-3) 

**Attack Scenario:**
1. Validator A enables `enable_batch_v2 = true` in configuration
2. Validator A creates and stores V2 batches in the `BATCH_V2_CF_NAME` column family
3. Validator B requests a batch from Validator A via `BatchRequest` (which doesn't specify version)
4. Validator A's batch_serve task retrieves the V2 batch from local storage
5. The task attempts to convert `Batch<BatchInfoExt>` â†’ `Batch<BatchInfo>` 
6. The `TryFrom` implementation returns error "Batch must be V1 type"
7. The `.expect()` panics, crashing the batch_serve task
8. Validator A can no longer serve ANY batch requests
9. Other validators cannot retrieve batches needed for consensus from Validator A

This violates the **Consensus Safety** invariant by preventing validators from obtaining batches required for block execution and verification.

## Impact Explanation

**Severity: HIGH** (up to $50,000 per Aptos Bug Bounty criteria)

This meets multiple HIGH severity impact categories:

1. **Validator node crashes**: The batch_serve task terminates with panic, preventing the validator from serving batch retrieval requests
2. **API crashes**: The batch retrieval RPC endpoint becomes non-functional
3. **Significant protocol violations**: Breaks the consensus protocol's batch dissemination mechanism

Additionally, this has potential **CRITICAL** impact if widespread adoption occurs:

- **Consensus disruption**: If multiple validators enable V2 simultaneously, the network could fragment
- **Network partition risk**: V2-enabled validators become unable to serve batches to other validators, potentially splitting consensus
- **Liveness degradation**: Validators may be unable to execute blocks if they cannot retrieve required batches

The vulnerability affects core consensus infrastructure and can cause cascading failures across the validator network.

## Likelihood Explanation

**Likelihood: MEDIUM-HIGH**

Factors increasing likelihood:
- Simple trigger: Just enable a configuration flag (`enable_batch_v2 = true`)
- No special permissions required: Any validator operator can modify their config
- Default configuration has the flag available [5](#0-4) 
- The feature appears ready for deployment (code exists for V2 batch creation and storage)
- No version negotiation or compatibility checking exists in the protocol

Factors decreasing likelihood:
- Current default is `false`, so requires explicit opt-in
- May be documented as experimental/unreleased feature
- Validators may coordinate upgrades through governance

However, even a single validator enabling V2 can trigger the panic on batch requests, making this a realistic threat.

## Recommendation

Implement version-aware batch serving with graceful handling of both V1 and V2 batches:

**Solution 1: Return V2 batches when appropriate**
```rust
let response = if let Ok(value) = batch_store.get_batch_from_local(&rpc_request.req.digest()) {
    let batch: Batch<BatchInfoExt> = value.try_into().unwrap();
    
    // Check if batch is V2 and return appropriate response
    if batch.batch_info().is_v2() {
        BatchResponse::BatchV2(batch)
    } else {
        let batch_v1: Batch<BatchInfo> = batch.try_into().unwrap();
        BatchResponse::Batch(batch_v1)
    }
} else {
    // ... NotFound handling
}
```

**Solution 2: Add version to BatchRequest protocol**
Extend `BatchRequest` to include a version field, allowing requesters to specify which version they support. This enables proper version negotiation.

**Solution 3: Feature gate enforcement**
Add a network-wide feature gate that prevents V2 batch creation until all validators have upgraded to support V2 batch retrieval.

The batch requester should also properly handle `BatchResponse::BatchV2` instead of just logging an error. [6](#0-5) 

## Proof of Concept

```rust
#[test]
fn test_batch_serve_v2_panic() {
    use consensus::quorum_store::{
        batch_generator::BatchGenerator,
        batch_store::BatchStore,
        quorum_store_db::QuorumStoreDB,
        types::{Batch, BatchResponse},
    };
    use aptos_config::config::QuorumStoreConfig;
    use aptos_consensus_types::proof_of_store::BatchKind;
    use aptos_types::quorum_store::BatchId;
    
    // Setup: Create a validator with V2 enabled
    let mut config = QuorumStoreConfig::default();
    config.enable_batch_v2 = true;
    
    let db = QuorumStoreDB::new(tempdir().unwrap().path());
    let batch_store = BatchStore::new(/* ... */);
    
    // Create a V2 batch
    let batch = Batch::new_v2(
        BatchId::new_for_test(0),
        vec![/* transactions */],
        1, // epoch
        1000000, // expiration
        PeerId::random(),
        0, // gas_bucket_start
        BatchKind::Normal,
    );
    
    // Persist the V2 batch
    let persisted = PersistedValue::from(batch);
    batch_store.save(&persisted).unwrap();
    
    // Simulate batch retrieval (as done in batch_serve task)
    let value = batch_store.get_batch_from_local(persisted.digest()).unwrap();
    let batch_ext: Batch<BatchInfoExt> = value.try_into().unwrap();
    
    // This will panic with "Batch retrieval requests must be for V1 batch"
    let _batch_v1: Batch<BatchInfo> = batch_ext
        .try_into()
        .expect("Batch retrieval requests must be for V1 batch");
    // PANIC OCCURS HERE
}
```

**Expected behavior:** Panic with message "Batch retrieval requests must be for V1 batch"  
**Actual impact:** batch_serve task terminates, validator cannot serve batch requests

### Citations

**File:** config/src/config/quorum_store_config.rs (L102-102)
```rust
    pub enable_batch_v2: bool,
```

**File:** config/src/config/quorum_store_config.rs (L144-144)
```rust
            enable_batch_v2: false,
```

**File:** consensus/src/quorum_store/batch_generator.rs (L190-201)
```rust
        if self.config.enable_batch_v2 {
            // TODO(ibalajiarun): Specify accurate batch kind
            let batch_kind = BatchKind::Normal;
            Batch::new_v2(
                batch_id,
                txns,
                self.epoch,
                expiry_time,
                self.my_peer_id,
                bucket_start,
                batch_kind,
            )
```

**File:** consensus/src/quorum_store/quorum_store_builder.rs (L408-415)
```rust
                let response = if let Ok(value) =
                    batch_store.get_batch_from_local(&rpc_request.req.digest())
                {
                    let batch: Batch<BatchInfoExt> = value.try_into().unwrap();
                    let batch: Batch<BatchInfo> = batch
                        .try_into()
                        .expect("Batch retieval requests must be for V1 batch");
                    BatchResponse::Batch(batch)
```

**File:** consensus/src/quorum_store/types.rs (L336-352)
```rust
impl TryFrom<Batch<BatchInfoExt>> for Batch<BatchInfo> {
    type Error = anyhow::Error;

    fn try_from(batch: Batch<BatchInfoExt>) -> Result<Self, Self::Error> {
        ensure!(
            matches!(batch.batch_info(), &BatchInfoExt::V1 { .. }),
            "Batch must be V1 type"
        );
        let Batch {
            batch_info,
            payload,
        } = batch;
        Ok(Self {
            batch_info: batch_info.unpack_info(),
            payload,
        })
    }
```

**File:** consensus/src/quorum_store/batch_requester.rs (L153-155)
```rust
                            Ok(BatchResponse::BatchV2(_)) => {
                                error!("Batch V2 response is not supported");
                            }
```
