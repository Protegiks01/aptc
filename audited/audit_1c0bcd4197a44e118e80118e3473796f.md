# Audit Report

## Title
DKG Schnorr Proof-of-Knowledge Replay Attack Enabling Secret Reuse Across Epochs

## Summary
The Schnorr proof-of-knowledge (PoK) verification in the DKG protocol lacks epoch-specific binding, allowing malicious validators to reuse the same `(R, s)` proof values across multiple DKG epochs. This enables validators to avoid generating fresh secrets for each epoch by deliberately reusing the same polynomial constant term, violating the fundamental DKG security requirement of independent randomness per epoch.

## Finding Description

The vulnerability exists in the Schnorr PoK implementation used to prove knowledge of dealt secrets in the DKG protocol. The Fiat-Shamir challenge computation only includes the commitment `R`, public key `pk`, and generator `g`, without any epoch-specific context: [1](#0-0) 

This challenge structure is used during proof generation and verification: [2](#0-1) [3](#0-2) 

**Attack Scenario:**

A malicious validator can exploit this by:

1. **Epoch N**: Generate a DKG transcript with secret `f_coeff[0] = secret_value`, producing commitment `V[W] = g‚ÇÅ^secret_value` and Schnorr PoK `(R, s)`: [4](#0-3) 

2. **Epoch N+1**: Deliberately reuse the same secret `f_coeff[0] = secret_value`, resulting in the same `V[W]` commitment. The validator then:
   - Reuses the same `(R, s)` proof from Epoch N
   - Generates fresh ElGamal encryptions (required for pairing checks)
   - Creates a new BLS signature with the updated epoch in the `aux` parameter

3. **Verification passes** because:
   
   - The Schnorr PoK verification at batch_verify_soks only checks the proof against `(R, pk, g)` without epoch binding: [5](#0-4) 

   - The BLS signature verification passes with the new epoch-specific signature: [6](#0-5) 

   - The epoch check at the VM level only validates that the transcript claims to be from the current epoch: [7](#0-6) 

The `aux` parameter containing epoch information is passed during verification but **only used for BLS signature verification**, not for binding the Schnorr PoK to the epoch: [8](#0-7) [9](#0-8) 

The documentation explicitly states that aux is intended to prevent replay attacks: [10](#0-9) 

## Impact Explanation

This is a **protocol violation** affecting validator behavior and DKG security:

1. **Forward Secrecy Violation**: If a validator's secret from one epoch is compromised (e.g., through side-channel attacks, key leakage, or cryptanalysis), all epochs where that validator reused the secret are retroactively compromised.

2. **Reduced Entropy**: The aggregated DKG output's security relies on the assumption that each validator contributes independent fresh randomness. Validators reusing secrets reduce the effective entropy of the shared secret, potentially bringing it below the security threshold if multiple colluding validators employ this technique.

3. **Predictable Contributions**: An adversary observing a validator's transcript can predict that validator's contribution to future DKG rounds, enabling targeted attacks or manipulation strategies against the randomness beacon.

4. **Collusion Amplification**: Multiple malicious validators could coordinate to all reuse their secrets, significantly weakening the DKG output and potentially enabling practical attacks on the randomness beacon or threshold cryptography operations.

5. **Protocol Invariant Violation**: Violates the DKG security requirement that each epoch must use independent randomness, which is fundamental to the security proof of the protocol.

## Likelihood Explanation

**Likelihood: HIGH**

- **Ease of Exploitation**: Any validator can execute this attack independently without requiring additional privileges, coordination with other validators, or technical sophistication beyond understanding the protocol.

- **Detection Difficulty**: The attack is not easily detectable through normal monitoring since the transcript appears valid and passes all verification checks. Only forensic analysis comparing transcripts across epochs would reveal the reuse.

- **Attacker Motivation**: Validators might be motivated to perform this attack to reduce computational overhead, enable strategic manipulation of DKG outputs, or maintain backdoors into the cryptographic parameters.

- **No Cost to Attack**: The attack requires no additional resources and actually reduces the validator's computational burden.

## Recommendation

Include the epoch information in the Schnorr PoK Fiat-Shamir challenge computation. Modify the `Challenge` struct to include the `aux` parameter:

```rust
#[derive(Serialize, Deserialize, BCSCryptoHash, CryptoHasher)]
#[allow(non_snake_case)]
struct Challenge<Gr, A: Serialize> {
    R: Gr,
    pk: Gr,
    g: Gr,
    aux: A,  // Add epoch binding
}
```

Update the `pok_prove` and `pok_batch_verify` functions to accept and use the `aux` parameter in challenge computation, ensuring the Schnorr PoK is cryptographically bound to the specific epoch.

## Proof of Concept

The vulnerability can be demonstrated by:
1. Running a validator in epoch N and capturing its DKG transcript with PoK (R, s)
2. In epoch N+1, providing the same input secret to generate_transcript
3. Observing that the same (R, s) can be reused with only a fresh BLS signature
4. Verifying that the transcript passes all verification checks

The attack succeeds because the Schnorr challenge computation at line 96 of schnorr.rs omits the aux parameter that contains epoch information, while the BLS signature at lines 79-102 of contribution.rs properly includes it.

## Notes

This vulnerability represents an inconsistency in the DKG protocol's security design: while the BLS signature layer properly binds transcripts to epochs via the `aux` parameter, the Schnorr PoK layer does not. This allows the cryptographic proof-of-knowledge to be reused across epochs despite the protocol's explicit intention to prevent such replay attacks as documented in the PVSS traits interface.

### Citations

**File:** crates/aptos-dkg/src/pvss/schnorr.rs (L21-29)
```rust
/// This is the Schnorr prover transcript that is hashed to obtain a Fiat-Shamir challenge.
/// TODO(TechDebt): Cannot have references here because CryptoHasher doesn't work with lifetimes.
#[derive(Serialize, Deserialize, BCSCryptoHash, CryptoHasher)]
#[allow(non_snake_case)]
struct Challenge<Gr> {
    R: Gr,  // g^r
    pk: Gr, // g^a
    g: Gr,
}
```

**File:** crates/aptos-dkg/src/pvss/schnorr.rs (L32-45)
```rust
pub fn pok_prove<Gr, R>(a: &Scalar, g: &Gr, pk: &Gr, rng: &mut R) -> PoK<Gr>
where
    Gr: Serialize + Group + for<'a> Mul<&'a Scalar, Output = Gr>,
    R: rand_core::RngCore + rand_core::CryptoRng,
{
    debug_assert!(g.mul(a).eq(pk));

    let r = random_scalar(rng);
    let R = g.mul(&r);
    let e = schnorr_hash(Challenge::<Gr> { R, pk: *pk, g: *g });
    let s = r + e * a;

    (R, s)
}
```

**File:** crates/aptos-dkg/src/pvss/schnorr.rs (L69-109)
```rust
pub fn pok_batch_verify<'a, Gr>(
    poks: &Vec<(Gr, PoK<Gr>)>,
    g: &Gr,
    gamma: &Scalar,
) -> anyhow::Result<()>
where
    Gr: Serialize + Group + Mul<&'a Scalar> + HasMultiExp,
{
    let n = poks.len();
    let mut exps = Vec::with_capacity(2 * n + 1);
    let mut bases = Vec::with_capacity(2 * n + 1);

    // Compute \gamma_i = \gamma^i, for all i \in [0, n]
    let mut gammas = Vec::with_capacity(n);
    gammas.push(Scalar::ONE);
    for _ in 0..(n - 1) {
        gammas.push(gammas.last().unwrap().mul(gamma));
    }

    let mut last_exp = Scalar::ZERO;
    for i in 0..n {
        let (pk, (R, s)) = poks[i];

        bases.push(R);
        exps.push(gammas[i]);

        bases.push(pk);
        exps.push(schnorr_hash(Challenge::<Gr> { R, pk, g: *g }) * gammas[i]);

        last_exp += s * gammas[i];
    }

    bases.push(*g);
    exps.push(last_exp.neg());

    if Gr::multi_exp_iter(bases.iter(), exps.iter()) != Gr::identity() {
        bail!("Schnorr PoK batch verification failed");
    }

    Ok(())
}
```

**File:** crates/aptos-dkg/src/pvss/das/weighted_protocol.rs (L128-177)
```rust
        // f_evals[k] = f(\omega^k), \forall k \in [0, W-1]
        let W = sc.get_total_weight();
        let (f_coeff, f_evals) = shamir_secret_share(sc.get_threshold_config(), s, rng);
        assert_eq!(f_coeff.len(), sc.get_threshold_weight());
        assert_eq!(f_evals.len(), W);

        // Pick ElGamal randomness r_j, \forall j \in [W]
        // r[j] = r_{j+1}, \forall j \in [0, W-1]
        let r = random_scalars(W, &mut rng);
        let g_1 = pp.get_encryption_public_params().pubkey_base();
        let g_2 = pp.get_commitment_base();
        let h = *pp.get_encryption_public_params().message_base();

        // NOTE: Recall s_i is the starting index of player i in the vector of shares
        //  - V[s_i + j - 1] = g_2^{f(s_i + j - 1)}
        //  - V[W] = g_2^{f(0)}
        let V = (0..W)
            .map(|k| g_1.mul(f_evals[k]))
            .chain([g_1.mul(f_coeff[0])])
            .collect::<Vec<G1Projective>>();
        let V_hat = (0..W)
            .map(|k| g_2.mul(f_evals[k]))
            .chain([g_2.mul(f_coeff[0])])
            .collect::<Vec<G2Projective>>();

        // R[j] = g_1^{r_{j + 1}},  \forall j \in [0, W-1]
        let R = (0..W).map(|j| g_1.mul(r[j])).collect::<Vec<G1Projective>>();
        let R_hat = (0..W).map(|j| g_2.mul(r[j])).collect::<Vec<G2Projective>>();

        let mut C = Vec::with_capacity(W);
        for i in 0..n {
            let w_i = sc.get_player_weight(&sc.get_player(i));

            let bases = vec![h, Into::<G1Projective>::into(&eks[i])];
            for j in 0..w_i {
                let k = sc.get_share_index(i, j).unwrap();

                C.push(g1_multi_exp(
                    bases.as_slice(),
                    [f_evals[k], r[k]].as_slice(),
                ))
            }
        }

        // Compute PoK of input secret committed in V[n]
        let pok = schnorr::pok_prove(&f_coeff[0], g_1, &V[W], rng);

        // Sign the secret commitment, player ID and `aux`
        let sig = Self::sign_contribution(ssk, dealer, aux, &V[W]);

```

**File:** crates/aptos-dkg/src/pvss/contribution.rs (L70-76)
```rust
    let poks = soks
        .iter()
        .map(|(_, c, _, pok)| (*c, *pok))
        .collect::<Vec<(Gr, schnorr::PoK<Gr>)>>();

    // TODO(Performance): 128-bit exponents instead of powers of tau
    schnorr::pok_batch_verify::<Gr>(&poks, pk_base, &tau)?;
```

**File:** crates/aptos-dkg/src/pvss/contribution.rs (L78-103)
```rust
    // Second, the signatures
    let msgs = soks
        .iter()
        .zip(aux)
        .map(|((player, comm, _, _), aux)| Contribution::<Gr, A> {
            comm: *comm,
            player: *player,
            aux: aux.clone(),
        })
        .collect::<Vec<Contribution<Gr, A>>>();
    let msgs_refs = msgs
        .iter()
        .map(|c| c)
        .collect::<Vec<&Contribution<Gr, A>>>();
    let pks = spks
        .iter()
        .map(|pk| pk)
        .collect::<Vec<&bls12381::PublicKey>>();
    let sig = bls12381::Signature::aggregate(
        soks.iter()
            .map(|(_, _, sig, _)| sig.clone())
            .collect::<Vec<bls12381::Signature>>(),
    )?;

    sig.verify_aggregate(&msgs_refs[..], &pks[..])?;
    Ok(())
```

**File:** dkg/src/transcript_aggregation/mod.rs (L74-77)
```rust
        ensure!(
            metadata.epoch == self.epoch_state.epoch,
            "[DKG] adding peer transcript failed with invalid node epoch",
        );
```

**File:** types/src/dkg/real_dkg/mod.rs (L241-286)
```rust
    fn generate_transcript<R: CryptoRng + RngCore>(
        rng: &mut R,
        pub_params: &Self::PublicParams,
        input_secret: &Self::InputSecret,
        my_index: u64,
        sk: &Self::DealerPrivateKey,
        pk: &Self::DealerPublicKey,
    ) -> Self::Transcript {
        let my_index = my_index as usize;
        let my_addr = pub_params.session_metadata.dealer_validator_set[my_index].addr;
        let aux = (pub_params.session_metadata.dealer_epoch, my_addr);

        let wtrx = WTrx::deal(
            &pub_params.pvss_config.wconfig,
            &pub_params.pvss_config.pp,
            sk,
            pk,
            &pub_params.pvss_config.eks,
            input_secret,
            &aux,
            &Player { id: my_index },
            rng,
        );
        // transcript for fast path
        let fast_wtrx = pub_params
            .pvss_config
            .fast_wconfig
            .as_ref()
            .map(|fast_wconfig| {
                WTrx::deal(
                    fast_wconfig,
                    &pub_params.pvss_config.pp,
                    sk,
                    pk,
                    &pub_params.pvss_config.eks,
                    input_secret,
                    &aux,
                    &Player { id: my_index },
                    rng,
                )
            });
        Transcripts {
            main: wtrx,
            fast: fast_wtrx,
        }
    }
```

**File:** types/src/dkg/real_dkg/mod.rs (L363-374)
```rust
        let aux = dealers_addresses
            .iter()
            .map(|address| (params.pvss_config.epoch, address))
            .collect::<Vec<_>>();

        trx.main.verify(
            &params.pvss_config.wconfig,
            &params.pvss_config.pp,
            &spks,
            &all_eks,
            &aux,
        )?;
```

**File:** crates/aptos-dkg/src/pvss/traits/transcript.rs (L40-41)
```rust
//! To prevent replay of signed PVSS transcripts inside higher-level protocols, the PVSS dealer can
//! include some auxiliary data to compute the signature over too.
```
