# Audit Report

## Title
Malicious Proposers Can Selectively Withhold Votes to Manipulate Leader Reputation and Election

## Summary
A Byzantine proposer can selectively exclude votes from specific validators when forming Quorum Certificates (QCs), causing those validators to appear non-participatory in committed block metadata. This manipulates the LeaderReputation scoring system, gradually reducing targeted validators' probability of being elected as future leaders.

## Finding Description

This vulnerability exists in the consensus vote aggregation and leader reputation system. The attack exploits the fact that proposers have discretion over which votes to process when forming QCs, and this selective processing directly impacts reputation tracking.

**Technical Flow:**

When a validator votes, the vote is sent to the next round's proposer. [1](#0-0)  The proposer processes votes through `process_vote_msg`, which calls `insert_vote` to add votes to the `PendingVotes` aggregator. [2](#0-1) 

A Byzantine proposer can simply choose not to call `process_vote_msg` for certain validators' votes. When votes are aggregated into a QC, the `aggregate_signatures` function creates a BitVec that only includes validators whose votes were actually added to the aggregator. [3](#0-2) 

This BitVec becomes part of the block metadata through the `previous_bitvec()` function, which extracts it from the parent block's QC. [4](#0-3)  The block metadata is then created with this BitVec included. [5](#0-4) 

The LeaderReputation system reads block metadata events and counts votes per validator using the BitVec through the `count_votes` function, which calls `bitvec_to_voters` to determine which validators participated. [6](#0-5)  These vote counts directly influence reputation weights used in leader election. [7](#0-6) 

**Why This Works:**

QC verification only checks that voting power meets the quorum threshold (2f+1), not whether all available votes were included. Even with `broadcast_vote=true` (the default configuration), other validators cannot enforce inclusion of all votes because they cannot prove which votes the proposer received in an asynchronous network. [8](#0-7) 

## Impact Explanation

This represents a **Medium Severity** protocol violation affecting the fairness properties of leader election:

**Impact on Leader Election:**
- Malicious proposers can systematically exclude specific validators' votes across multiple rounds
- Targeted validators' reputation scores decrease artificially
- Lower reputation reduces probability in leader election through weighted selection
- Enables gradual centralization of leadership

**Important Limitations:**
- Does NOT break consensus safety (BFT properties remain intact)
- Does NOT enable fund theft or double-spending
- Does NOT cause network halts or liveness failures
- Requires Byzantine validator to be elected as proposer

This qualifies as a "Limited Protocol Violation" under Medium severity rather than High severity, as it affects fairness guarantees without compromising consensus safety or fund security.

## Likelihood Explanation

**Likelihood: Medium**

**Requirements:**
- Attacker must be an active validator (within f < n/3 Byzantine tolerance)
- Must be elected as proposer for rounds (inevitable over time)
- No collusion with other validators required

**Execution Complexity:**
- Trivially simple: merely not process certain `VoteMsg` events
- No special timing, cryptography, or coordination needed
- Executed passively by selective message handling

**Detection Difficulty:**
- With `broadcast_vote=true`: Other validators observe votes but cannot prove proposer received them
- No accountability mechanism for vote selection
- Indistinguishable from legitimate network delays

## Recommendation

Implement vote accountability mechanisms:

1. **Require vote inclusion justification**: When forming QCs with exactly 2f+1 votes, proposers should demonstrate why additional votes were not included (e.g., timeout witnesses)

2. **Reputation adjustments**: Track proposer behavior patterns - consistently excluding the same validators should raise flags

3. **Vote inclusion verification**: When `broadcast_vote=true`, validators could challenge QCs that exclude votes they observed being broadcast within reasonable timeframes

4. **Alternative reputation metrics**: Supplement vote-based reputation with other metrics less vulnerable to proposer manipulation (e.g., block execution performance, network latency measurements)

## Proof of Concept

The vulnerability can be demonstrated through the following scenario:

1. Deploy a modified validator node that implements selective vote dropping in `process_vote_msg`
2. When elected as proposer, filter votes based on target validator addresses
3. Form valid QCs using remaining votes (â‰¥2f+1)
4. Observe the excluded validators' reputation scores decrease in LeaderReputation metrics over successive epochs
5. Track the reduced leader election probability for targeted validators

The core issue is architectural: the code path from vote reception through QC formation to reputation tracking allows proposer discretion without accountability, as evidenced by the aggregation logic that creates BitVecs only from processed votes [9](#0-8)  and the reputation system's direct reliance on these BitVecs for vote counting. [10](#0-9) 

## Notes

While this is a valid logic vulnerability that enables manipulation of leader election fairness, it operates within the expected Byzantine fault tolerance bounds (f < n/3) and does not compromise the core safety or liveness properties of the consensus protocol. The severity assessment reflects that this is a fairness issue rather than a critical security breach affecting fund security or consensus integrity.

### Citations

**File:** consensus/src/round_manager.rs (L1697-1772)
```rust
    pub async fn process_vote_msg(&mut self, vote_msg: VoteMsg) -> anyhow::Result<()> {
        fail_point!("consensus::process_vote_msg", |_| {
            Err(anyhow::anyhow!("Injected error in process_vote_msg"))
        });
        // Check whether this validator is a valid recipient of the vote.
        if self
            .ensure_round_and_sync_up(
                vote_msg.vote().vote_data().proposed().round(),
                vote_msg.sync_info(),
                vote_msg.vote().author(),
            )
            .await
            .context("[RoundManager] Stop processing vote")?
        {
            self.process_vote(vote_msg.vote())
                .await
                .context("[RoundManager] Add a new vote")?;
        }
        Ok(())
    }

    /// Add a vote to the pending votes.
    /// If a new QC / TC is formed then
    /// 1) fetch missing dependencies if required, and then
    /// 2) call process_certificates(), which will start a new round in return.
    async fn process_vote(&mut self, vote: &Vote) -> anyhow::Result<()> {
        let round = vote.vote_data().proposed().round();

        if vote.is_timeout() {
            info!(
                self.new_log(LogEvent::ReceiveVote)
                    .remote_peer(vote.author()),
                vote = %vote,
                epoch = vote.vote_data().proposed().epoch(),
                round = vote.vote_data().proposed().round(),
                id = vote.vote_data().proposed().id(),
                state = vote.vote_data().proposed().executed_state_id(),
                is_timeout = vote.is_timeout(),
            );
        } else {
            trace!(
                self.new_log(LogEvent::ReceiveVote)
                    .remote_peer(vote.author()),
                epoch = vote.vote_data().proposed().epoch(),
                round = vote.vote_data().proposed().round(),
                id = vote.vote_data().proposed().id(),
            );
        }

        if !self.local_config.broadcast_vote && !vote.is_timeout() {
            // Unlike timeout votes regular votes are sent to the leaders of the next round only.
            let next_round = round + 1;
            ensure!(
                self.proposer_election
                    .is_valid_proposer(self.proposal_generator.author(), next_round),
                "[RoundManager] Received {}, but I am not a valid proposer for round {}, ignore.",
                vote,
                next_round
            );
        }

        let block_id = vote.vote_data().proposed().id();
        // Check if the block already had a QC
        if self
            .block_store
            .get_quorum_cert_for_block(block_id)
            .is_some()
        {
            return Ok(());
        }
        let vote_reception_result = self
            .round_state
            .insert_vote(vote, &self.epoch_state.verifier);
        self.process_vote_reception_result(vote, vote_reception_result)
            .await
    }
```

**File:** types/src/validator_verifier.rs (L316-335)
```rust
    pub fn aggregate_signatures<'a>(
        &self,
        signatures: impl Iterator<Item = (&'a AccountAddress, &'a bls12381::Signature)>,
    ) -> Result<AggregateSignature, VerifyError> {
        let mut sigs = vec![];
        let mut masks = BitVec::with_num_bits(self.len() as u16);
        for (addr, sig) in signatures {
            let index = *self
                .address_to_validator_index
                .get(addr)
                .ok_or(VerifyError::UnknownAuthor)?;
            masks.set(index as u16);
            sigs.push(sig.clone());
        }
        // Perform an optimistic aggregation of the signatures without verification.
        let aggregated_sig = bls12381::Signature::aggregate(sigs)
            .map_err(|_| VerifyError::FailedToAggregateSignature)?;

        Ok(AggregateSignature::new(masks, Some(aggregated_sig)))
    }
```

**File:** consensus/consensus-types/src/block.rs (L570-578)
```rust
    fn previous_bitvec(&self) -> BitVec {
        match self.block_data.block_type() {
            BlockType::DAGBlock { parents_bitvec, .. } => parents_bitvec.clone(),
            BlockType::OptimisticProposal(p) => {
                p.grandparent_qc().ledger_info().get_voters_bitvec().clone()
            },
            _ => self.quorum_cert().ledger_info().get_voters_bitvec().clone(),
        }
    }
```

**File:** consensus/consensus-types/src/block.rs (L580-595)
```rust
    pub fn new_block_metadata(&self, validators: &[AccountAddress]) -> BlockMetadata {
        BlockMetadata::new(
            self.id(),
            self.epoch(),
            self.round(),
            self.author().unwrap_or(AccountAddress::ZERO),
            self.previous_bitvec().into(),
            // For nil block, we use 0x0 which is convention for nil address in move.
            self.block_data()
                .failed_authors()
                .map_or(vec![], |failed_authors| {
                    Self::failed_authors_to_indices(validators, failed_authors)
                }),
            self.timestamp_usecs(),
        )
    }
```

**File:** consensus/src/liveness/leader_reputation.rs (L366-397)
```rust
    pub fn count_votes_custom(
        epoch_to_candidates: &HashMap<u64, Vec<Author>>,
        history: &[NewBlockEvent],
        window_size: usize,
        from_stale_end: bool,
    ) -> HashMap<Author, u32> {
        Self::history_iter(history, epoch_to_candidates, window_size, from_stale_end).fold(
            HashMap::new(),
            |mut map, meta| {
                match Self::bitvec_to_voters(
                    &epoch_to_candidates[&meta.epoch()],
                    &meta.previous_block_votes_bitvec().clone().into(),
                ) {
                    Ok(voters) => {
                        for &voter in voters {
                            let count = map.entry(voter).or_insert(0);
                            *count += 1;
                        }
                    },
                    Err(msg) => {
                        error!(
                            "Voter conversion from bitmap failed at epoch {}, round {}: {}",
                            meta.epoch(),
                            meta.round(),
                            msg
                        )
                    },
                }
                map
            },
        )
    }
```

**File:** consensus/src/liveness/leader_reputation.rs (L521-552)
```rust
impl ReputationHeuristic for ProposerAndVoterHeuristic {
    fn get_weights(
        &self,
        epoch: u64,
        epoch_to_candidates: &HashMap<u64, Vec<Author>>,
        history: &[NewBlockEvent],
    ) -> Vec<u64> {
        assert!(epoch_to_candidates.contains_key(&epoch));

        let (votes, proposals, failed_proposals) =
            self.aggregation
                .get_aggregated_metrics(epoch_to_candidates, history, &self.author);

        epoch_to_candidates[&epoch]
            .iter()
            .map(|author| {
                let cur_votes = *votes.get(author).unwrap_or(&0);
                let cur_proposals = *proposals.get(author).unwrap_or(&0);
                let cur_failed_proposals = *failed_proposals.get(author).unwrap_or(&0);

                if cur_failed_proposals * 100
                    > (cur_proposals + cur_failed_proposals) * self.failure_threshold_percent
                {
                    self.failed_weight
                } else if cur_proposals > 0 || cur_votes > 0 {
                    self.active_weight
                } else {
                    self.inactive_weight
                }
            })
            .collect()
    }
```

**File:** config/src/config/consensus_config.rs (L371-371)
```rust
            broadcast_vote: true,
```
