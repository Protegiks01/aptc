# Audit Report

## Title
State Snapshot Restore Corruption via Empty Chunks Vector Bypassing Root Hash Validation

## Summary
A malicious backup manifest with an empty `chunks` vector but valid metadata can corrupt the state restore process. The `JellyfishMerkleRestore::finish_impl()` method creates a Null root node without validating it matches the expected root hash, resulting in state tree corruption that violates consensus guarantees.

## Finding Description

The `StateSnapshotBackup` structure allows an empty `chunks` vector while maintaining valid metadata including a non-null `root_hash`. [1](#0-0) 

During restoration, the controller loads and validates the manifest's proof, confirming the `root_hash` matches the transaction info's state checkpoint hash. [2](#0-1) 

However, no validation prevents `chunks` from being empty. [3](#0-2) 

When the chunks vector is empty, the restore loop never executes, no state data is added, and `finish()` is called directly. [4](#0-3) 

In `JellyfishMerkleRestore::finish_impl()`, when no chunks were added (`num_children == 0`), the code creates a `Node::Null` and writes it to storage without validating this matches `expected_root_hash`. [5](#0-4) 

The `Node::Null` has hash value `SPARSE_MERKLE_PLACEHOLDER_HASH`, creating a mismatch between:
- The database's actual root: `SPARSE_MERKLE_PLACEHOLDER_HASH`
- The ledger's expected root: The non-null `root_hash` from the manifest

This violates the **State Consistency** invariant requiring verifiable state transitions via Merkle proofs.

**Attack Path:**
1. Attacker crafts malicious `state.manifest` JSON:
   - `root_hash`: Valid non-null hash (e.g., from legitimate backup)
   - `chunks`: `[]` (empty array)
   - `proof`: Valid proof file matching the root_hash
   - `version`, `epoch`: Valid values

2. Victim node performs `aptos-db restore bootstrap-db` with this manifest

3. Restore process:
   - Validates proof successfully
   - Skips chunk processing (empty vector)
   - Creates Null root node
   - No validation of final root hash occurs

4. Result: Database state corrupted with mismatched root hash

## Impact Explanation

This meets **Medium Severity** criteria: "State inconsistencies requiring intervention."

**Immediate Impact:**
- Restored node has incorrect state tree (Null root vs. expected root)
- Transaction execution produces wrong state roots
- Node cannot participate in consensus (state root mismatches)
- Requires manual intervention or re-restore to fix

**Broader Impact:**
- If multiple nodes restore from same malicious backup, network partition occurs
- Validators with corrupted state compute different execution results
- Breaks deterministic execution guarantee across validator set
- Could cause chain halt if sufficient validators affected

Not Critical because it doesn't directly steal funds or permanently break consensus (requires manual backup manipulation), but clearly causes state corruption requiring intervention.

## Likelihood Explanation

**Likelihood: Medium-High**

**Attacker Requirements:**
- Ability to provide backup manifest to victim (social engineering, compromised backup storage, malicious operator)
- Knowledge of valid proof structure
- No privileged access required

**Feasibility:**
- Backup manifests are JSON files, easily craftable
- Legitimate backups provide template for valid proofs
- Restore process is operator-initiated, creating opportunity for attack
- No cryptographic barriers prevent empty chunks vector

**Real-World Scenarios:**
1. Compromised backup storage serving malicious manifests
2. Supply chain attack on backup distribution
3. Malicious node operator intentionally corrupting state
4. Accidental corruption from buggy backup tooling

## Recommendation

Add validation in `JellyfishMerkleRestore::finish_impl()` to verify the final root hash matches `expected_root_hash`:

```rust
pub fn finish_impl(mut self) -> Result<()> {
    self.wait_for_async_commit()?;
    
    // Deal with the special case when the entire tree has a single leaf or null node.
    if self.partial_nodes.len() == 1 {
        let mut num_children = 0;
        let mut leaf = None;
        for i in 0..16 {
            if let Some(ref child_info) = self.partial_nodes[0].children[i] {
                num_children += 1;
                if let ChildInfo::Leaf(node) = child_info {
                    leaf = Some(node.clone());
                }
            }
        }

        match num_children {
            0 => {
                let node_key = NodeKey::new_empty_path(self.version);
                assert!(self.frozen_nodes.is_empty());
                let null_node = Node::Null;
                
                // ADDED: Validate null root matches expected hash
                ensure!(
                    null_node.hash() == self.expected_root_hash,
                    "Final root hash mismatch: got {}, expected {}",
                    null_node.hash(),
                    self.expected_root_hash
                );
                
                self.frozen_nodes.insert(node_key, null_node);
                self.store.write_node_batch(&self.frozen_nodes)?;
                return Ok(());
            },
            1 => {
                if let Some(node) = leaf {
                    let node_key = NodeKey::new_empty_path(self.version);
                    assert!(self.frozen_nodes.is_empty());
                    
                    // ADDED: Validate single leaf root matches expected hash
                    ensure!(
                        node.hash() == self.expected_root_hash,
                        "Final root hash mismatch: got {}, expected {}",
                        node.hash(),
                        self.expected_root_hash
                    );
                    
                    self.frozen_nodes.insert(node_key, node.into());
                    self.store.write_node_batch(&self.frozen_nodes)?;
                    return Ok(());
                }
            },
            _ => (),
        }
    }

    self.freeze(0);
    
    // ADDED: Final validation for multi-node case
    let root_node = self.frozen_nodes.get(&NodeKey::new_empty_path(self.version))
        .ok_or_else(|| anyhow!("Root node not found in frozen nodes"))?;
    ensure!(
        root_node.hash() == self.expected_root_hash,
        "Final root hash mismatch: got {}, expected {}",
        root_node.hash(),
        self.expected_root_hash
    );
    
    self.store.write_node_batch(&self.frozen_nodes)?;
    Ok(())
}
```

Additionally, add validation in `StateSnapshotRestoreController` to reject empty chunks: [6](#0-5) 

Insert after line 163:
```rust
ensure!(
    !manifest.chunks.is_empty(),
    "State snapshot backup contains no chunks. Cannot restore from empty backup."
);
```

## Proof of Concept

```rust
// Test demonstrating the vulnerability
#[test]
fn test_empty_chunks_corruption() {
    use tempfile::TempDir;
    use std::sync::Arc;
    
    // Setup: Create a legitimate state tree
    let tmp_dir = TempDir::new().unwrap();
    let db = Arc::new(MockTreeStore::new(&tmp_dir));
    let version = 100;
    
    // Insert some state to get a non-null root hash
    let mut tree = JellyfishMerkleTree::new(&db);
    let key = b"test_key".to_vec();
    let value = b"test_value".to_vec();
    let batch = vec![(key.clone(), Some(value.clone()))];
    let (expected_root_hash, _) = tree.put_value_set(batch, version).unwrap();
    
    // Attack: Create malicious backup manifest with empty chunks
    let malicious_manifest = StateSnapshotBackup {
        version,
        epoch: 1,
        root_hash: expected_root_hash, // Non-null hash from real state
        chunks: vec![], // EMPTY - no actual state data!
        proof: create_valid_proof_handle(version, expected_root_hash),
    };
    
    // Victim restores from malicious backup
    let restore_db = Arc::new(MockTreeStore::new(&tmp_dir));
    let mut restore = StateSnapshotRestore::new(
        &restore_db,
        &restore_db,
        version,
        expected_root_hash,
        false, // sync commit
        StateSnapshotRestoreMode::Default,
    ).unwrap();
    
    // No chunks are added because chunks vector is empty
    // restore.add_chunk() is never called
    
    // Finish the restore - THIS SHOULD FAIL but doesn't!
    let result = restore.finish();
    assert!(result.is_ok()); // BUG: This succeeds!
    
    // Verification: Check what was actually written
    let restored_tree = JellyfishMerkleTree::new(&restore_db);
    let actual_root_hash = restored_tree.get_root_hash(version).unwrap();
    
    // BUG DEMONSTRATED: Actual root is Null, but expected was non-null!
    assert_eq!(actual_root_hash, *SPARSE_MERKLE_PLACEHOLDER_HASH);
    assert_ne!(actual_root_hash, expected_root_hash);
    
    println!("VULNERABILITY CONFIRMED:");
    println!("Expected root hash: {}", expected_root_hash);
    println!("Actual root hash: {}", actual_root_hash);
    println!("State corruption successful via empty chunks vector!");
}
```

## Notes

This vulnerability exists because the incremental validation in `verify()` is only called during `add_chunk_impl()`, but never validates the final result in `finish_impl()`. The test suite manually performs this validation externally, but production code does not. [7](#0-6)

### Citations

**File:** storage/backup/backup-cli/src/backup_types/state_snapshot/manifest.rs (L29-51)
```rust
/// State snapshot backup manifest, representing a complete state view at specified version.
#[derive(Deserialize, Serialize)]
pub struct StateSnapshotBackup {
    /// Version at which this state snapshot is taken.
    pub version: Version,
    /// Epoch in which this state snapshot is taken.
    pub epoch: u64,
    /// Hash of the state tree root.
    pub root_hash: HashValue,
    /// All account blobs in chunks.
    pub chunks: Vec<StateSnapshotChunk>,
    /// BCS serialized
    /// `Tuple(TransactionInfoWithProof, LedgerInfoWithSignatures)`.
    ///   - The `TransactionInfoWithProof` is at `Version` above, and carries the same `root_hash`
    /// above; It proves that at specified version the root hash is as specified in a chain
    /// represented by the LedgerInfo below.
    ///   - The signatures on the `LedgerInfoWithSignatures` has a version greater than or equal to
    /// the version of this backup but is within the same epoch, so the signatures on it can be
    /// verified by the validator set in the same epoch, which can be provided by an
    /// `EpochStateBackup` recovered prior to this to the DB; Requiring it to be in the same epoch
    /// limits the requirement on such `EpochStateBackup` to no older than the same epoch.
    pub proof: FileHandle,
}
```

**File:** storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs (L125-136)
```rust
        let (txn_info_with_proof, li): (TransactionInfoWithProof, LedgerInfoWithSignatures) =
            self.storage.load_bcs_file(&manifest.proof).await?;
        txn_info_with_proof.verify(li.ledger_info(), manifest.version)?;
        let state_root_hash = txn_info_with_proof
            .transaction_info()
            .ensure_state_checkpoint_hash()?;
        ensure!(
            state_root_hash == manifest.root_hash,
            "Root hash mismatch with that in proof. root hash: {}, expected: {}",
            manifest.root_hash,
            state_root_hash,
        );
```

**File:** storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs (L160-184)
```rust

        ver_gauge.set(self.version as i64);
        tgt_leaf_idx.set(manifest.chunks.last().map_or(0, |c| c.last_idx as i64));
        let total_chunks = manifest.chunks.len();

        let resume_point_opt = receiver.lock().as_mut().unwrap().previous_key_hash()?;
        let chunks = if let Some(resume_point) = resume_point_opt {
            manifest
                .chunks
                .into_iter()
                .skip_while(|chunk| chunk.last_key <= resume_point)
                .collect()
        } else {
            manifest.chunks
        };
        if chunks.len() < total_chunks {
            info!(
                chunks_to_add = chunks.len(),
                total_chunks = total_chunks,
                "Resumed state snapshot restore."
            )
        };
        let chunks_to_add = chunks.len();

        let start_idx = chunks.first().map_or(0, |chunk| chunk.first_idx);
```

**File:** storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs (L201-228)
```rust
        while let Some((chunk_idx, chunk, mut blobs, proof)) = futs_stream.try_next().await? {
            start = start.or_else(|| Some(Instant::now()));
            let _timer = OTHER_TIMERS_SECONDS.timer_with(&["add_state_chunk"]);
            let receiver = receiver.clone();
            if self.validate_modules {
                blobs = tokio::task::spawn_blocking(move || {
                    Self::validate_modules(&blobs);
                    blobs
                })
                .await?;
            }
            tokio::task::spawn_blocking(move || {
                receiver.lock().as_mut().unwrap().add_chunk(blobs, proof)
            })
            .await??;
            leaf_idx.set(chunk.last_idx as i64);
            info!(
                chunk = chunk_idx,
                chunks_to_add = chunks_to_add,
                last_idx = chunk.last_idx,
                values_per_second = ((chunk.last_idx + 1 - start_idx) as f64
                    / start.as_ref().unwrap().elapsed().as_secs_f64())
                    as u64,
                "State chunk added.",
            );
        }

        tokio::task::spawn_blocking(move || receiver.lock().take().unwrap().finish()).await??;
```

**File:** storage/jellyfish-merkle/src/restore/mod.rs (L750-772)
```rust
    pub fn finish_impl(mut self) -> Result<()> {
        self.wait_for_async_commit()?;
        // Deal with the special case when the entire tree has a single leaf or null node.
        if self.partial_nodes.len() == 1 {
            let mut num_children = 0;
            let mut leaf = None;
            for i in 0..16 {
                if let Some(ref child_info) = self.partial_nodes[0].children[i] {
                    num_children += 1;
                    if let ChildInfo::Leaf(node) = child_info {
                        leaf = Some(node.clone());
                    }
                }
            }

            match num_children {
                0 => {
                    let node_key = NodeKey::new_empty_path(self.version);
                    assert!(self.frozen_nodes.is_empty());
                    self.frozen_nodes.insert(node_key, Node::Null);
                    self.store.write_node_batch(&self.frozen_nodes)?;
                    return Ok(());
                },
```

**File:** storage/aptosdb/src/state_restore/restore_test.rs (L240-257)
```rust
    for (key, value) in btree.values() {
        let (value_hash, value_index) = tree
            .get_with_proof(CryptoHash::hash(key), version)
            .unwrap()
            .0
            .unwrap();
        let value_in_db = db.get_value_at_version(&value_index).unwrap();
        assert_eq!(CryptoHash::hash(value), value_hash);
        assert_eq!(&value_in_db, value);
    }

    let actual_root_hash = tree.get_root_hash(version).unwrap();
    assert_eq!(actual_root_hash, expected_root_hash);
    let usage_calculated = db.calculate_usage(version);
    let usage_stored = db.get_stored_usage(version);
    assert_eq!(usage_calculated, usage_stored);
    assert_eq!(usage_stored.items(), tree.get_leaf_count(version).unwrap());
}
```
