# Audit Report

## Title
Asset Type Confusion in `get_account_balance()` API Causes Incorrect Balance Queries During Coin-to-Fungible-Asset Migration

## Summary
The REST API endpoint `/accounts/{address}/balance/{asset_type}` suffers from a type confusion vulnerability where the same asset returns different balances depending on whether it's queried by coin type string or fungible asset metadata address. During the coin-to-fungible-asset migration period, querying by FA metadata address will return zero or incorrectly low balances, missing unmigrated coins still in the CoinStore.

## Finding Description
The vulnerability exists in the balance query logic and asset type parsing. The `AssetType::from_str()` parser attempts to parse the `asset_type` parameter first as an `Address` (resulting in `FungibleAsset`), then falls back to `MoveStructTag` (resulting in `Coin`). [1](#0-0) 

When the balance is calculated, the two code paths behave differently:

**For `AssetType::Coin`**: The function queries both the CoinStore resource for legacy coin balance AND the paired fungible asset primary store, then returns their sum.

**For `AssetType::FungibleAsset`**: The function initializes balance to 0 (skipping CoinStore entirely) and only queries the fungible asset primary store. [2](#0-1) 

This creates a critical inconsistency: For AptosCoin, both `"0x1::aptos_coin::AptosCoin"` (coin type) and `"0xa"` (FA metadata address) are valid according to API documentation, but they return different results when coins haven't been migrated:

**Pre-migration state (user has 1000 APT in CoinStore, 0 in FA store):**
- Query with `"0x1::aptos_coin::AptosCoin"` → Returns 1000 (correct: CoinStore balance + FA balance)
- Query with `"0xa"` → Returns 0 (incorrect: only FA balance, missing CoinStore)

**Post-migration state (0 in CoinStore, 1000 in FA store):**
- Query with `"0x1::aptos_coin::AptosCoin"` → Returns 1000 (correct)
- Query with `"0xa"` → Returns 1000 (correct)

The vulnerability affects all coins with paired fungible assets, not just AptosCoin. The paired FA metadata address is computed deterministically: [3](#0-2) 

The test suite only validates post-migration behavior and never tests querying by FA metadata address before migration, indicating this case was not considered: [4](#0-3) 

## Impact Explanation
This qualifies as **Medium severity** under the Aptos bug bounty program's "State inconsistencies requiring intervention" category. The vulnerability causes:

1. **Incorrect Balance Display**: Users/DApps querying by FA metadata address will see zero or incorrectly low balances during migration, potentially causing panic or belief that funds are lost.

2. **Failed Transaction Construction**: Applications may fail to construct valid transactions believing the account has insufficient funds when it actually has adequate balance.

3. **DApp Logic Failures**: Smart contract interactions or business logic depending on accurate balance queries will malfunction, potentially leading to incorrect financial decisions.

4. **Data Integrity Violation**: The API returns provably different values for the same underlying asset depending solely on query format, violating the fundamental expectation that balance queries are deterministic.

While not causing direct fund loss, this breaks the invariant that **balance queries for the same asset must return consistent values regardless of query format**, which falls under "State inconsistencies requiring intervention."

## Likelihood Explanation
**Medium likelihood** for several reasons:

1. **Documentation Ambiguity**: The API documentation states both coin types and FA metadata addresses are valid inputs, but doesn't warn about different behavior during migration. [5](#0-4) 

2. **Migration Period**: During the ongoing coin-to-fungible-asset migration in the Aptos ecosystem, many accounts exist in partial migration states where this vulnerability is exploitable.

3. **Natural Usage Pattern**: Developers might naturally use the FA metadata address format when working with the fungible asset framework, unaware they're missing CoinStore balances.

4. **No Validation**: There are no warnings, errors, or validation to indicate when a query might be returning incomplete data.

## Recommendation
The balance query logic should be fixed to ensure both query formats return identical results. Specifically, when querying by `AssetType::FungibleAsset`, the function should check if there's a paired coin type and include its balance:

```rust
pub fn balance(
    &self,
    asset_type: AssetType,
    accept_type: &AcceptType,
) -> BasicResultWith404<u64> {
    let (fa_metadata_address, mut balance) = match asset_type {
        AssetType::Coin(move_struct_tag) => {
            // Query coin balance
            let coin_balance = self.query_coin_store_balance(&move_struct_tag)?;
            (get_paired_fa_metadata_address(&move_struct_tag), coin_balance)
        },
        AssetType::FungibleAsset(fa_metadata_address) => {
            // NEW: Also check if this FA has a paired coin type
            let coin_balance = self.query_paired_coin_balance(fa_metadata_address)?;
            (fa_metadata_address.into(), coin_balance)
        },
    };
    
    // Query FA balance and add to total
    balance += self.query_fa_primary_store_balance(fa_metadata_address)?;
    
    // ... rest of implementation
}
```

Alternatively, deprecate the FA metadata address format for balance queries and require users to always use the coin type format, with clear documentation and validation errors.

## Proof of Concept

```rust
#[tokio::test]
async fn test_asset_type_confusion_vulnerability() {
    let mut context = new_test_context("test_asset_type_confusion");
    let root_account = context.root_account().await;
    
    // Initial APT balance in CoinStore (pre-migration)
    let coin_balance = context
        .get(&account_balance(
            &root_account.address().to_hex_literal(),
            "0x1::aptos_coin::AptosCoin", // Query by coin type
        ))
        .await;
    
    // Query same asset by FA metadata address
    let fa_balance = context
        .get(&account_balance(
            &root_account.address().to_hex_literal(),
            "0xa", // Query by FA metadata address (AccountAddress::TEN)
        ))
        .await;
    
    // VULNERABILITY: These should be equal but are not!
    // coin_balance > 0 (has CoinStore balance)
    // fa_balance == 0 (FA store doesn't exist yet, CoinStore ignored)
    assert_ne!(coin_balance, fa_balance); // Demonstrates the bug
    assert_eq!(fa_balance, json!(0)); // FA query returns 0
    assert!(coin_balance.as_u64().unwrap() > 0); // Coin query returns actual balance
    
    // After migration, both formats should work
    let txn = root_account.sign_with_transaction_builder(
        context.transaction_factory()
            .payload(aptos_stdlib::coin_migrate_to_fungible_store(
                AptosCoinType::type_tag(),
            ))
    );
    context.commit_block(&vec![txn]).await;
    
    let coin_balance_after = context
        .get(&account_balance(&root_account.address().to_hex_literal(), "0x1::aptos_coin::AptosCoin"))
        .await;
    let fa_balance_after = context
        .get(&account_balance(&root_account.address().to_hex_literal(), "0xa"))
        .await;
    
    // Post-migration, both formats return same value
    assert_eq!(coin_balance_after, fa_balance_after);
}
```

This test demonstrates that querying the same asset by different formats returns different values during migration, violating data consistency expectations and confirming the type confusion vulnerability.

### Citations

**File:** api/types/src/account.rs (L36-48)
```rust
impl FromStr for AssetType {
    type Err = anyhow::Error;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match Address::from_str(s) {
            Ok(address) => Ok(AssetType::FungibleAsset(address)),
            Err(_) => match MoveStructTag::from_str(s) {
                Ok(tag) => Ok(AssetType::Coin(tag)),
                Err(e) => Err(e),
            },
        }
    }
}
```

**File:** api/src/accounts.rs (L324-367)
```rust
        let (fa_metadata_address, mut balance) = match asset_type {
            AssetType::Coin(move_struct_tag) => {
                let coin_store_type_tag =
                    StructTag::from_str(&format!("0x1::coin::CoinStore<{}>", move_struct_tag))
                        .map_err(|err| {
                            BasicErrorWith404::internal_with_code(
                                err,
                                AptosErrorCode::InternalError,
                                &self.latest_ledger_info,
                            )
                        })?;
                // query coin balance
                let state_value = self.context.get_state_value_poem(
                    &StateKey::resource(&self.address.into(), &coin_store_type_tag).map_err(
                        |err| {
                            BasicErrorWith404::internal_with_code(
                                err,
                                AptosErrorCode::InternalError,
                                &self.latest_ledger_info,
                            )
                        },
                    )?,
                    self.ledger_version,
                    &self.latest_ledger_info,
                )?;
                let coin_balance = match state_value {
                    None => 0,
                    Some(bytes) => bcs::from_bytes::<CoinStoreResourceUntyped>(&bytes)
                        .map_err(|err| {
                            BasicErrorWith404::internal_with_code(
                                err,
                                AptosErrorCode::InternalError,
                                &self.latest_ledger_info,
                            )
                        })?
                        .coin(),
                };
                (
                    get_paired_fa_metadata_address(&move_struct_tag),
                    coin_balance,
                )
            },
            AssetType::FungibleAsset(fa_metadata_adddress) => (fa_metadata_adddress.into(), 0),
        };
```

**File:** sdk/src/types.rs (L149-159)
```rust
pub fn get_paired_fa_metadata_address(coin_type_name: &MoveStructTag) -> AccountAddress {
    let coin_type_name = coin_type_name.to_string();
    if coin_type_name == APTOS_COIN_TYPE_STR {
        *APT_METADATA_ADDRESS
    } else {
        let mut preimage = APT_METADATA_ADDRESS.to_vec();
        preimage.extend(coin_type_name.as_bytes());
        preimage.push(0xFE);
        AccountAddress::from_bytes(HashValue::sha3_256_of(&preimage).to_vec()).unwrap()
    }
}
```

**File:** api/src/tests/accounts_test.rs (L307-345)
```rust
    // First check coin balance
    let coin_balance_before = context
        .get(&account_balance(
            &root_account.address().to_hex_literal(),
            APTOS_COIN_TYPE_STR,
        ))
        .await;
    let txn = root_account.sign_with_transaction_builder(
        context
            .transaction_factory()
            .payload(aptos_stdlib::coin_migrate_to_fungible_store(
                AptosCoinType::type_tag(),
            ))
            .expiration_timestamp_secs(context.get_expiration_time())
            .upgrade_payload_with_rng(
                &mut context.rng,
                context.use_txn_payload_v2_format,
                context.use_orderless_transactions,
            ),
    );
    context.commit_block(&vec![txn.clone()]).await;

    // Check coin balance after migration
    let coin_balance_after = context
        .get(&account_balance(
            &root_account.address().to_hex_literal(),
            APTOS_COIN_TYPE_STR,
        ))
        .await;
    assert_eq!(coin_balance_before, coin_balance_after);

    // Check fungible asset balance
    let fa_balance = context
        .get(&account_balance(
            &root_account.address().to_hex_literal(),
            &AccountAddress::TEN.to_hex_literal(),
        ))
        .await;
    assert_eq!(coin_balance_after, fa_balance);
```

**File:** crates/aptos-rest-client/src/lib.rs (L318-322)
```rust
    /// Gets the balance of a specific asset type for an account.
    /// The `asset_type` parameter can be either:
    /// * A coin type (e.g. "0x1::aptos_coin::AptosCoin")
    /// * A fungible asset metadata address (e.g. "0xa")
    /// For more details, see: https://aptos.dev/en/build/apis/fullnode-rest-api-reference#tag/accounts/GET/accounts/{address}/balance/{asset_type}
```
