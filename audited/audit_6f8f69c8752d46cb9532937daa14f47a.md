# Audit Report

## Title
Incomplete Consistency Check in State Snapshot Restore Progress Validation Allows Undetected Storage Usage Divergence

## Summary
The `get_progress()` function in the state store module performs a consistency check between the main database and internal indexer database during state snapshot restoration. However, this check only validates the `key_hash` field of `StateSnapshotProgress` and completely ignores the `usage` field, allowing databases to remain in an inconsistent state when they have matching key hashes but divergent storage usage metrics.

## Finding Description

The `StateSnapshotProgress` structure contains two critical fields that track restoration progress: [1](#0-0) 

During state snapshot restoration, both the main database and internal indexer database record their progress. The `get_progress()` function is responsible for verifying consistency between these two databases: [2](#0-1) 

The critical flaw is at the consistency check where only `key_hash` is compared: [3](#0-2) 

When `main_progress.key_hash == indexer_progress.key_hash`, the function returns successfully even if `main_progress.usage != indexer_progress.usage`. This means the databases could have processed identical keys but calculated different storage usage (items count and bytes), and this inconsistency would go undetected.

The `StateStorageUsage` tracks critical metrics: [4](#0-3) 

This usage data is later used to set the final storage state: [5](#0-4) 

## Impact Explanation

This issue represents a **Medium Severity** vulnerability under the Aptos bug bounty program criteria for the following reasons:

1. **State Consistency Violation**: The incomplete check violates the "State Consistency" invariant which requires state transitions to be atomic and verifiable. If databases have divergent usage values, the system state is inconsistent.

2. **Storage Usage Integrity**: Storage usage metrics directly affect:
   - Gas fee calculations for storage operations
   - Storage quota enforcement
   - State pruning decisions
   - Consensus on storage costs

3. **Potential for Cross-Node Divergence**: If different validator nodes experience different corruption patterns or hit different code paths in usage calculation bugs, they could end up with different storage usage values for the same state, potentially causing consensus disagreements.

4. **Masked Corruption**: The check is meant to detect database inconsistencies. By only checking `key_hash`, it can mask serious corruption in the `usage` field, allowing corrupted state to persist undetected.

However, the impact is limited because exploitation requires either:
- Pre-existing database corruption
- A bug in usage calculation (non-deterministic behavior)
- Memory corruption during the serialization/deserialization process

## Likelihood Explanation

**Likelihood: Low to Medium**

This issue is likely to occur in the following scenarios:

1. **Database Corruption Events**: Hardware failures, filesystem corruption, or memory errors could corrupt the `usage` field while leaving `key_hash` intact. Since databases use separate storage, corruption could affect them differently.

2. **Concurrent Modification Race**: While the code uses the same `StateSnapshotProgress` object for both writes, the writes occur separately: [6](#0-5) 
   
   The indexer write completes before the main DB commit, creating a window where inconsistency could occur.

3. **Bug in Usage Calculation**: If there's a subtle bug in the `add_item()` logic or usage accumulation that causes non-deterministic behavior: [7](#0-6) 

4. **Restoration Resumption After Crash**: When restoration resumes after an interruption, if the progress records were partially written or corrupted during the crash, the incomplete check would not detect usage field corruption.

The likelihood is elevated because the check is meant to be a safety mechanism but fails to provide complete protection.

## Recommendation

**Fix: Add comprehensive consistency check for both `key_hash` and `usage` fields**

The consistency check should verify complete equality of both progress fields when both databases have progress recorded:

```rust
(Some(main_progress), Some(indexer_progress)) => {
    if main_progress.key_hash > indexer_progress.key_hash {
        bail!(
            "Inconsistent restore progress between main db and internal indexer db. main db: {:?}, internal indexer db: {:?}",
            main_progress,
            indexer_progress,
        );
    }
    // Add check for equal key_hash but different usage
    if main_progress.key_hash == indexer_progress.key_hash 
        && main_progress.usage != indexer_progress.usage {
        bail!(
            "Inconsistent storage usage in restore progress. Main DB and indexer DB have same key_hash {:?} but different usage - main: {:?}, indexer: {:?}",
            main_progress.key_hash,
            main_progress.usage,
            indexer_progress.usage,
        );
    }
},
```

Additionally, the `(None, Some(_))` case should be reconsidered - allowing the indexer to have progress when the main DB doesn't seems logically inconsistent and should likely be an error condition.

## Proof of Concept

```rust
#[cfg(test)]
mod consistency_check_tests {
    use super::*;
    use aptos_db_indexer_schemas::metadata::StateSnapshotProgress;
    use aptos_crypto::HashValue;
    use aptos_types::state_store::state_storage_usage::StateStorageUsage;

    #[test]
    fn test_missing_usage_consistency_check() {
        // Create two progress records with same key_hash but different usage
        let key_hash = HashValue::random();
        let main_progress = StateSnapshotProgress::new(
            key_hash,
            StateStorageUsage::new(100, 10000), // 100 items, 10000 bytes
        );
        let indexer_progress = StateSnapshotProgress::new(
            key_hash,
            StateStorageUsage::new(95, 9500), // Different usage!
        );

        // The current implementation would NOT catch this inconsistency
        // because it only checks: main_progress.key_hash > indexer_progress.key_hash
        // When they're equal, no error is thrown regardless of usage difference
        
        assert_eq!(main_progress.key_hash, indexer_progress.key_hash);
        assert_ne!(main_progress.usage, indexer_progress.usage);
        
        // This demonstrates the gap: same key_hash, different usage goes undetected
        // In production, this would pass the consistency check at line 1342
        // but represent an inconsistent database state
    }
}
```

**Notes:**

This vulnerability specifically affects the state snapshot restoration consistency validation mechanism. While it requires unusual conditions (corruption or bugs) to manifest, it represents a critical gap in defensive programming that could allow serious state inconsistencies to go undetected. The check is explicitly designed to verify consistency but fails to check half of the progress data, potentially masking corruption or bugs that could lead to consensus issues if different nodes end up with different storage usage values for identical state.

### Citations

**File:** storage/indexer_schemas/src/metadata.rs (L46-49)
```rust
pub struct StateSnapshotProgress {
    pub key_hash: HashValue,
    pub usage: StateStorageUsage,
}
```

**File:** storage/aptosdb/src/state_store/mod.rs (L1259-1279)
```rust
        if self.internal_indexer_db.is_some()
            && self
                .internal_indexer_db
                .as_ref()
                .unwrap()
                .statekeys_enabled()
        {
            let keys = node_batch.keys().map(|key| key.0.clone()).collect();
            self.internal_indexer_db
                .as_ref()
                .unwrap()
                .write_keys_to_indexer_db(&keys, version, progress)?;
        }
        self.shard_state_value_batch(
            &mut sharded_schema_batch,
            node_batch,
            self.state_kv_db.enabled_sharding(),
        )?;
        self.state_kv_db
            .commit(version, Some(batch), sharded_schema_batch)
    }
```

**File:** storage/aptosdb/src/state_store/mod.rs (L1317-1361)
```rust
    fn get_progress(&self, version: Version) -> Result<Option<StateSnapshotProgress>> {
        let main_db_progress = self
            .state_kv_db
            .metadata_db()
            .get::<DbMetadataSchema>(&DbMetadataKey::StateSnapshotKvRestoreProgress(version))?
            .map(|v| v.expect_state_snapshot_progress());

        // verify if internal indexer db and main db are consistent before starting the restore
        if self.internal_indexer_db.is_some()
            && self
                .internal_indexer_db
                .as_ref()
                .unwrap()
                .statekeys_enabled()
        {
            let progress_opt = self
                .internal_indexer_db
                .as_ref()
                .unwrap()
                .get_restore_progress(version)?;

            match (main_db_progress, progress_opt) {
                (None, None) => (),
                (None, Some(_)) => (),
                (Some(main_progress), Some(indexer_progress)) => {
                    if main_progress.key_hash > indexer_progress.key_hash {
                        bail!(
                            "Inconsistent restore progress between main db and internal indexer db. main db: {:?}, internal indexer db: {:?}",
                            main_progress,
                            indexer_progress,
                        );
                    }
                },
                _ => {
                    bail!(
                        "Inconsistent restore progress between main db and internal indexer db. main db: {:?}, internal indexer db: {:?}",
                        main_db_progress,
                        progress_opt,
                    );
                },
            }
        }

        Ok(main_db_progress)
    }
```

**File:** types/src/state_store/state_storage_usage.rs (L6-11)
```rust
#[derive(Copy, Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
#[cfg_attr(any(test, feature = "fuzzing"), derive(proptest_derive::Arbitrary))]
pub enum StateStorageUsage {
    Tracked { items: usize, bytes: usize },
    Untracked,
}
```

**File:** types/src/state_store/state_storage_usage.rs (L44-52)
```rust
    pub fn add_item(&mut self, bytes_delta: usize) {
        match self {
            Self::Tracked { items, bytes } => {
                *items += 1;
                *bytes += bytes_delta;
            },
            Self::Untracked => (),
        }
    }
```

**File:** storage/aptosdb/src/state_restore/mod.rs (L129-135)
```rust
    pub fn finish(self) -> Result<()> {
        let progress = self.db.get_progress(self.version)?;
        self.db.kv_finish(
            self.version,
            progress.map_or(StateStorageUsage::zero(), |p| p.usage),
        )
    }
```
