# Audit Report

## Title
Consensus Observer Subscription Health Check Ordering Allows Malicious Peers to Occupy Subscription Slots with Invalid Messages

## Summary
The `check_subscription_health()` function in the consensus observer validates subscriptions in an order that allows malicious peers to pass health checks while sending only invalid messages. The timeout check is satisfied before message validation, and the sync progress check doesn't verify that the subscription itself contributes to database progress. This enables attackers to occupy subscription slots indefinitely without providing valid consensus data.

## Finding Description

The health check ordering vulnerability exists in the subscription validation flow across multiple files:

**1. Message Reception and Time Update Before Validation**

When a message arrives from a subscription peer, the system updates the last message receive time **before** validating the message content: [1](#0-0) 

The message verification only checks if the sender is an active subscription peer, not whether the message is valid: [2](#0-1) 

**2. Health Check Ordering**

The subscription health checks are performed in this specific order: [3](#0-2) 

**3. Critical Flaw: Timeout Check Uses Pre-Validation Time Updates**

The timeout check uses `last_message_receive_time` which was already updated before validation: [4](#0-3) 

**4. Critical Flaw: Sync Check Doesn't Verify Subscription Contribution**

The sync progress check only verifies that the global database version is increasing, not that THIS subscription is the source: [5](#0-4) 

**Attack Path:**

1. Malicious peer establishes a subscription to a consensus observer node
2. Peer sends periodic invalid messages (wrong epoch, invalid proofs, malformed blocks)
3. Each message passes `verify_message_for_subscription` (only checks active subscription status)
4. `update_last_message_receive_time()` is called immediately, satisfying the timeout check
5. Messages are then validated and rejected (e.g., at proof verification): [6](#0-5) 

6. Despite rejecting invalid messages, the subscription passes all health checks:
   - **Connected**: ✓ Attacker remains connected
   - **Timeout**: ✓ Time updated by invalid messages before validation
   - **Sync Progress**: ✓ DB syncs from OTHER sources (state sync, other valid subscriptions)
   - **Optimality**: ✓ May pass if no better peers available

7. Attacker occupies a subscription slot indefinitely without providing valid data

**Broken Invariants:**
- Subscriptions should provide valid, useful consensus data to the observer node
- Resource limits should prevent malicious peers from consuming system resources without benefit
- Network protocol should detect and remove non-contributing peers

## Impact Explanation

**Severity: Medium** (per Aptos Bug Bounty criteria - up to $10,000)

**Impact:**
1. **Subscription Slot Exhaustion**: Attackers can occupy limited subscription slots (typically `max_concurrent_subscriptions` = 1-3) without contributing valid data
2. **Legitimate Peer Exclusion**: Valid consensus peers cannot establish subscriptions if slots are occupied by malicious peers
3. **Node Degradation**: Observer nodes believe they have active subscriptions but receive no useful consensus information
4. **Coordinated Attack Amplification**: Multiple colluding attackers can occupy ALL subscription slots on a target node
5. **Consensus Observer Ineffectiveness**: Nodes may fall behind consensus or fail to properly observe the network state

This qualifies as **Medium severity** under "State inconsistencies requiring intervention" - the node's subscription state is inconsistent with its actual ability to receive valid consensus data, potentially requiring manual intervention to terminate malicious subscriptions and establish new ones.

## Likelihood Explanation

**Likelihood: High**

**Attacker Requirements:**
- Ability to establish network connection with consensus observer nodes (standard P2P capability)
- Knowledge of consensus message formats to craft invalid but properly structured messages
- No privileged validator access required
- No stake or economic cost required

**Ease of Exploitation:**
- Attack is straightforward - simply send periodic invalid messages
- No complex timing or race conditions required
- Difficult to detect - metrics track invalid messages but don't trigger subscription termination
- No existing defense mechanism tracks consecutive invalid messages per subscription

**Realistic Scenario:**
- Adversarial peers can easily execute this attack against public consensus observer nodes
- Multiple attackers can coordinate to occupy all subscription slots on target nodes
- Attack can persist indefinitely until manual intervention

## Recommendation

**Fix Option 1: Update Time Only After Validation (Recommended)**

Modify the message processing flow to update `last_message_receive_time` only after successful message validation:

```rust
// In consensus_observer.rs, process_network_message()
async fn process_network_message(&mut self, network_message: ConsensusObserverNetworkMessage) {
    let message_received_time = Instant::now();
    let (peer_network_id, message) = network_message.into_parts();

    // Verify message is from active subscription but DON'T update time yet
    if !self.subscription_manager.is_active_subscription(peer_network_id) {
        self.subscription_manager.unsubscribe_from_peer(peer_network_id);
        warn!("Received message from inactive subscription");
        return;
    }

    // Process and validate the message
    let validation_result = match message {
        ConsensusObserverDirectSend::OrderedBlock(block) => {
            self.validate_and_process_ordered_block(peer_network_id, message_received_time, block).await
        },
        // ... other message types
    };

    // Only update time if message was valid
    if validation_result.is_ok() {
        self.subscription_manager.update_subscription_time(peer_network_id);
    } else {
        // Track consecutive failures and terminate if threshold exceeded
        self.subscription_manager.record_invalid_message(peer_network_id);
    }
}
```

**Fix Option 2: Add Consecutive Invalid Message Tracking**

Add a counter to `ConsensusObserverSubscription` to track consecutive invalid messages:

```rust
pub struct ConsensusObserverSubscription {
    // ... existing fields
    consecutive_invalid_messages: u64,
}

impl ConsensusObserverSubscription {
    pub fn record_invalid_message(&mut self) {
        self.consecutive_invalid_messages += 1;
    }

    pub fn reset_invalid_counter(&mut self) {
        self.consecutive_invalid_messages = 0;
    }

    fn check_invalid_message_threshold(&self) -> Result<(), Error> {
        const MAX_CONSECUTIVE_INVALID: u64 = 10;
        if self.consecutive_invalid_messages >= MAX_CONSECUTIVE_INVALID {
            return Err(Error::SubscriptionInvalidMessages(format!(
                "Subscription has {} consecutive invalid messages",
                self.consecutive_invalid_messages
            )));
        }
        Ok(())
    }
}
```

Then add this check to `check_subscription_health()` before the optimality check.

**Fix Option 3: Verify Subscription Contribution to Sync Progress**

Modify `check_syncing_progress()` to track whether received messages from this subscription correlate with DB version increases, rather than just checking global DB progress.

## Proof of Concept

```rust
#[tokio::test]
async fn test_malicious_peer_invalid_messages_bypass() {
    use consensus::consensus_observer::observer::subscription::ConsensusObserverSubscription;
    use consensus::consensus_observer::observer::subscription_manager::SubscriptionManager;
    use aptos_config::config::ConsensusObserverConfig;
    use std::sync::Arc;
    use std::time::Duration;

    // Setup: Create observer with one subscription slot
    let config = ConsensusObserverConfig {
        max_concurrent_subscriptions: 1,
        max_subscription_timeout_ms: 5000,
        max_subscription_sync_timeout_ms: 10000,
        ..Default::default()
    };

    let (peers_and_metadata, observer_client) = create_consensus_observer_client(&[NetworkId::Public]);
    let mut subscription_manager = SubscriptionManager::new(
        observer_client,
        config,
        None,
        create_mock_db_reader(), // Returns incrementing versions to simulate sync from OTHER sources
        TimeService::mock(),
    );

    // Step 1: Malicious peer establishes subscription
    let malicious_peer = create_peer_and_connection(
        NetworkId::Public,
        peers_and_metadata.clone(),
        0,
        Some(0.1),
        true,
    );
    
    // Create subscription to malicious peer
    create_observer_subscription(
        &mut subscription_manager,
        config,
        malicious_peer,
    );

    // Step 2: Simulate malicious peer sending 100 invalid messages over time
    for i in 0..100 {
        // Create an invalid ordered block (wrong epoch, invalid proof, etc.)
        let invalid_block = create_invalid_ordered_block();
        let message = ConsensusObserverDirectSend::OrderedBlock(invalid_block);
        
        // Send the message - this will:
        // 1. Pass verify_message_for_subscription (peer is active)
        // 2. Update last_message_receive_time
        // 3. Fail validation (invalid proof)
        // 4. But subscription remains healthy!
        subscription_manager.process_message(malicious_peer, message).await;
        
        // Advance time slightly
        time_service.advance(Duration::from_millis(10));
    }

    // Step 3: Check subscription health - should FAIL but will PASS
    let health_check_result = subscription_manager.check_subscription_health(
        &peers_and_metadata.get_connected_peers_and_metadata().unwrap(),
        malicious_peer,
        false,
    );

    // VULNERABILITY: Despite sending 100 invalid messages, subscription passes health check!
    assert!(health_check_result.is_ok(), "Malicious subscription should have been terminated but passed health check");

    // Step 4: Try to add a legitimate peer - it will be REJECTED because slot is occupied
    let legitimate_peer = create_peer_and_connection(
        NetworkId::Public,
        peers_and_metadata.clone(),
        0,
        Some(0.05), // Better latency
        true,
    );

    // Legitimate peer cannot subscribe because malicious peer occupies the slot
    let active_peers = subscription_manager.get_active_subscription_peers();
    assert_eq!(active_peers.len(), 1);
    assert_eq!(active_peers[0], malicious_peer);
    
    // This demonstrates the vulnerability: malicious peer occupies subscription slot
    // indefinitely while sending invalid data, preventing legitimate peers from subscribing
}

fn create_invalid_ordered_block() -> OrderedBlock {
    // Create block with wrong epoch, invalid proof, or malformed data
    // that will fail verification in verify_ordered_blocks() or verify_ordered_proof()
    OrderedBlock::new_with_invalid_epoch(999999) // Wrong epoch
}
```

**Expected Behavior**: Subscription should be terminated after consecutive invalid messages

**Actual Behavior**: Subscription passes health checks and remains active indefinitely

---

**Notes:**
The vulnerability arises from a fundamental design flaw in the health check ordering. The system updates the timeout timestamp before validating message content, and checks global DB progress rather than subscription-specific contribution. This allows malicious peers to maintain "healthy" subscriptions while providing zero value and blocking legitimate peers. The fix requires either moving the time update after validation, tracking invalid messages per subscription, or verifying that the subscription actively contributes to sync progress.

### Citations

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L573-594)
```rust
    async fn process_network_message(&mut self, network_message: ConsensusObserverNetworkMessage) {
        // Unpack the network message and note the received time
        let message_received_time = Instant::now();
        let (peer_network_id, message) = network_message.into_parts();

        // Verify the message is from the peers we've subscribed to
        if let Err(error) = self
            .subscription_manager
            .verify_message_for_subscription(peer_network_id)
        {
            // Update the rejected message counter
            increment_rejected_message_counter(&peer_network_id, &message);

            // Log the error and return
            warn!(
                LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                    "Received message that was not from an active subscription! Error: {:?}",
                    error,
                ))
            );
            return;
        }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L658-671)
```rust
        // Verify the ordered blocks before processing
        if let Err(error) = ordered_block.verify_ordered_blocks() {
            // Log the error and update the invalid message counter
            error!(
                LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                    "Failed to verify ordered blocks! Ignoring: {:?}, from peer: {:?}. Error: {:?}",
                    ordered_block.proof_block_info(),
                    peer_network_id,
                    error
                ))
            );
            increment_invalid_message_counter(&peer_network_id, metrics::ORDERED_BLOCK_LABEL);
            return;
        };
```

**File:** consensus/src/consensus_observer/observer/subscription_manager.rs (L363-385)
```rust
    pub fn verify_message_for_subscription(
        &mut self,
        message_sender: PeerNetworkId,
    ) -> Result<(), Error> {
        // Check if the message is from an active subscription
        if let Some(active_subscription) = self
            .active_observer_subscriptions
            .lock()
            .get_mut(&message_sender)
        {
            // Update the last message receive time and return early
            active_subscription.update_last_message_receive_time();
            return Ok(());
        }

        // Otherwise, the message is not from an active subscription.
        // Send another unsubscribe request, and return an error.
        self.unsubscribe_from_peer(message_sender);
        Err(Error::InvalidMessageError(format!(
            "Received message from unexpected peer, and not an active subscription: {}!",
            message_sender
        )))
    }
```

**File:** consensus/src/consensus_observer/observer/subscription.rs (L63-91)
```rust
    pub fn check_subscription_health(
        &mut self,
        connected_peers_and_metadata: &HashMap<PeerNetworkId, PeerMetadata>,
        skip_peer_optimality_check: bool,
    ) -> Result<(), Error> {
        // Verify the subscription peer is still connected
        let peer_network_id = self.get_peer_network_id();
        if !connected_peers_and_metadata.contains_key(&peer_network_id) {
            return Err(Error::SubscriptionDisconnected(format!(
                "The peer: {:?} is no longer connected!",
                peer_network_id
            )));
        }

        // Verify the subscription has not timed out
        self.check_subscription_timeout()?;

        // Verify that the DB is continuing to sync and commit new data
        self.check_syncing_progress()?;

        // Verify that the subscription peer is still optimal
        self.check_subscription_peer_optimality(
            connected_peers_and_metadata,
            skip_peer_optimality_check,
        )?;

        // The subscription seems healthy
        Ok(())
    }
```

**File:** consensus/src/consensus_observer/observer/subscription.rs (L166-182)
```rust
    fn check_subscription_timeout(&self) -> Result<(), Error> {
        // Calculate the duration since the last message
        let time_now = self.time_service.now();
        let duration_since_last_message = time_now.duration_since(self.last_message_receive_time);

        // Check if the subscription has timed out
        if duration_since_last_message
            > Duration::from_millis(self.consensus_observer_config.max_subscription_timeout_ms)
        {
            return Err(Error::SubscriptionTimeout(format!(
                "Subscription to peer: {} has timed out! No message received for: {:?}",
                self.peer_network_id, duration_since_last_message
            )));
        }

        Ok(())
    }
```

**File:** consensus/src/consensus_observer/observer/subscription.rs (L184-222)
```rust
    /// Verifies that the DB is continuing to sync and commit new data
    fn check_syncing_progress(&mut self) -> Result<(), Error> {
        // Get the current time and synced version from storage
        let time_now = self.time_service.now();
        let current_synced_version =
            self.db_reader
                .get_latest_ledger_info_version()
                .map_err(|error| {
                    Error::UnexpectedError(format!(
                        "Failed to read highest synced version: {:?}",
                        error
                    ))
                })?;

        // Verify that the synced version is increasing appropriately
        let (highest_synced_version, highest_version_timestamp) =
            self.highest_synced_version_and_time;
        if current_synced_version <= highest_synced_version {
            // The synced version hasn't increased. Check if we should terminate
            // the subscription based on the last time the highest synced version was seen.
            let duration_since_highest_seen = time_now.duration_since(highest_version_timestamp);
            let timeout_duration = Duration::from_millis(
                self.consensus_observer_config
                    .max_subscription_sync_timeout_ms,
            );
            if duration_since_highest_seen > timeout_duration {
                return Err(Error::SubscriptionProgressStopped(format!(
                    "The DB is not making sync progress! Highest synced version: {}, elapsed: {:?}",
                    highest_synced_version, duration_since_highest_seen
                )));
            }
            return Ok(()); // We haven't timed out yet
        }

        // Update the highest synced version and time
        self.highest_synced_version_and_time = (current_synced_version, time_now);

        Ok(())
    }
```
