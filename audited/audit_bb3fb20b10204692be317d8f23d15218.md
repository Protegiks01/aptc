# Audit Report

## Title
Panic in Move IR Compiler Due to Invalid Module Name Validation

## Summary
The Move IR compiler panics when compiling modules with single-character underscore (`_`) or dollar sign (`$`) names due to a validation mismatch between the lexer and the `Identifier::new()` function. The lexer accepts these as valid identifiers, but `Identifier::new()` rejects them, causing an unwrap panic during source map creation.

## Finding Description

The vulnerability exists in the identifier validation logic during Move IR compilation. The attack path is:

1. The IR lexer accepts single-character `_` or `$` as valid module names [1](#0-0) 

2. The parser creates a `ModuleName` from this identifier without validation [2](#0-1) 

3. The module compilation proceeds with no validation of the module name [3](#0-2) 

4. During `Context::new()`, the source map is created with the invalid module name [4](#0-3) 

5. `SourceMap::new()` calls `Identifier::new().unwrap()` which panics on single `_` or `$` [5](#0-4) 

The root cause is that `Identifier::new()` requires `_` and `$` to have at least one additional character: [6](#0-5) 

An attacker can submit malicious IR code:
```
module 0x1._ {
    public fun test() {}
}
```

## Impact Explanation

**Severity: Low to Medium**

This does NOT qualify as a critical or high severity vulnerability because:
- It only affects the IR compiler, not the blockchain runtime
- No consensus violation, funds loss, or network availability impact
- Move IR is legacy tooling primarily used in testing, not production
- Does not affect validator nodes or on-chain operations

However, it represents improper error handling that violates defensive programming principles. If IR compilation were exposed via any API endpoint, it could cause service disruption through repeated crashes.

According to Aptos bounty criteria, this falls into "Non-critical implementation bugs" (Low severity) or potentially "API crashes" if an API endpoint exists (High severity).

## Likelihood Explanation

**Likelihood: Low**

The Move IR format is legacy and not the primary compilation target. Modern Move code uses the Move source language compiler, not IR. The IR compiler is maintained mainly for:
- Testing infrastructure
- Backwards compatibility
- Internal tooling (e.g., gas calibration)

An attacker would need access to an IR compilation endpoint, which is unlikely to exist in production environments.

## Recommendation

**Option 1** (Recommended): Add validation in the parser to reject invalid identifiers early:

```rust
fn parse_module_name(tokens: &mut Lexer) -> Result<ModuleName, ParseError<Loc, anyhow::Error>> {
    let name = parse_name(tokens)?;
    // Validate that the name is a valid Move identifier
    if !Identifier::is_valid(name.as_str()) {
        return Err(ParseError::InvalidToken {
            location: current_token_loc(tokens),
            message: format!("Invalid module name: '{}'", name),
        });
    }
    Ok(ModuleName(name))
}
```

**Option 2**: Handle the error gracefully instead of panicking:

```rust
let module_name_opt = module_name_opt.and_then(|module_name| {
    Identifier::new(module_name.name.0.as_str())
        .ok()
        .map(|ident| (module_name.address, ident))
});
```

**Option 3**: Update the IR lexer to use the same validation rules as `Identifier::is_valid()`.

## Proof of Concept

```rust
// Save as test_invalid_module_name.rs
use move_ir_compiler::Compiler;

#[test]
#[should_panic(expected = "Invalid identifier")]
fn test_invalid_module_name_underscore() {
    let code = r#"
        module 0x1._ {
            public fun test() {}
        }
    "#;
    
    let _result = Compiler { deps: vec![] }
        .into_compiled_module(code);
    // This will panic during source map creation
}

#[test]
#[should_panic(expected = "Invalid identifier")]
fn test_invalid_module_name_dollar() {
    let code = r#"
        module 0x1.$ {
            public fun test() {}
        }
    "#;
    
    let _result = Compiler { deps: vec![] }
        .into_compiled_module(code);
    // This will panic during source map creation
}
```

**Notes:**

This is a defensive programming issue rather than a critical security vulnerability. While the IR compiler does improperly handle invalid identifiers (causing panic instead of returning an error), this does not affect blockchain consensus, execution, state management, or any on-chain operations. The IR compiler is legacy tooling with limited production usage, making exploitation unlikely and impact minimal.

### Citations

**File:** third_party/move/move-ir-compiler/move-ir-to-bytecode/syntax/src/lexer.rs (L404-413)
```rust
fn get_name_len(text: &str) -> usize {
    // If the first character is 0..=9 or EOF, then return a length of 0.
    let first_char = text.chars().next().unwrap_or('0');
    if first_char.is_ascii_digit() {
        return 0;
    }
    text.chars()
        .position(|c| !matches!(c, 'a'..='z' | 'A'..='Z' | '$' | '_' | '0'..='9'))
        .unwrap_or(text.len())
}
```

**File:** third_party/move/move-ir-compiler/move-ir-to-bytecode/syntax/src/syntax.rs (L136-146)
```rust
fn parse_name(tokens: &mut Lexer) -> Result<Symbol, ParseError<Loc, anyhow::Error>> {
    if tokens.peek() != Tok::NameValue {
        return Err(ParseError::InvalidToken {
            location: current_token_loc(tokens),
            message: "expected Tok::NameValue".to_string(),
        });
    }
    let name = tokens.content();
    tokens.advance()?;
    Ok(Symbol::from(name))
}
```

**File:** third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs (L308-313)
```rust
fn verify_module(module: &ModuleDefinition) -> Result<()> {
    for function in &module.functions {
        verify_function(&function.1)?;
    }
    Ok(())
}
```

**File:** third_party/move/move-ir-compiler/move-ir-to-bytecode/src/context.rs (L281-312)
```rust
    pub fn new(
        decl_location: Loc,
        dependencies: CompiledDependencies<'a>,
        current_module_opt: Option<ModuleIdent>,
    ) -> Result<Self> {
        let context = Self {
            dependencies,
            aliases: HashMap::new(),
            modules: HashMap::new(),
            structs: HashMap::new(),
            struct_defs: HashMap::new(),
            named_constants: HashMap::new(),
            labels: HashMap::new(),
            fields: HashMap::new(),
            function_handles: HashMap::new(),
            function_signatures: HashMap::new(),
            module_handles: HashMap::new(),
            struct_handles: HashMap::new(),
            field_handles: HashMap::new(),
            struct_instantiations: HashMap::new(),
            function_instantiations: HashMap::new(),
            field_instantiations: HashMap::new(),
            signatures: HashMap::new(),
            identifiers: HashMap::new(),
            address_identifiers: HashMap::new(),
            constant_pool: HashMap::new(),
            current_function_index: FunctionDefinitionIndex::new(0),
            source_map: SourceMap::new(decl_location, current_module_opt),
        };

        Ok(context)
    }
```

**File:** third_party/move/move-ir-compiler/move-bytecode-source-map/src/source_map.rs (L323-327)
```rust
    pub fn new(definition_location: Loc, module_name_opt: Option<ModuleIdent>) -> Self {
        let module_name_opt = module_name_opt.map(|module_name| {
            let ident = Identifier::new(module_name.name.0.as_str()).unwrap();
            (module_name.address, ident)
        });
```

**File:** third_party/move/move-core/types/src/identifier.rs (L82-94)
```rust
pub const fn is_valid(s: &str) -> bool {
    // Rust const fn's don't currently support slicing or indexing &str's, so we
    // have to operate on the underlying byte slice. This is not a problem as
    // valid identifiers are (currently) ASCII-only.
    let b = s.as_bytes();
    match b {
        b"<SELF>" => true,
        [b'<', b'S', b'E', b'L', b'F', b'>', b'_', ..] if b.len() > 7 => all_bytes_numeric(b, 7),
        [b'a'..=b'z', ..] | [b'A'..=b'Z', ..] => all_bytes_valid(b, 1),
        [b'_', ..] | [b'$', ..] if b.len() > 1 => all_bytes_valid(b, 1),
        _ => false,
    }
}
```
