# Audit Report

## Title
Order Vote Processing Violates `preferred_round <= last_voted_round` Invariant Causing Validator Liveness Failure

## Summary
The `guarded_construct_and_sign_order_vote` function updates `preferred_round` via `observe_qc()` without updating `last_voted_round`, allowing `preferred_round` to exceed `last_voted_round`. This violates a critical consensus invariant and prevents affected validators from functioning as leaders until the network progresses beyond the inflated `preferred_round` value.

## Finding Description
The vulnerability exists in the order vote processing logic where two critical operations are mismatched: [1](#0-0) 

In this function, `observe_qc()` is called at line 108 to update the safety data, but `verify_and_update_last_vote_round()` is never called. This contrasts sharply with the regular voting path: [2](#0-1) 

Where both `verify_and_update_last_vote_round()` (line 77-80) and `observe_qc()` (line 84) are called, maintaining the invariant.

The `observe_qc()` function updates `preferred_round` based on the QC's parent block round: [3](#0-2) 

**Attack Scenario:**
1. Validator has state: `last_voted_round = 5`, `preferred_round = 4`
2. Validator votes normally on round 6: `last_voted_round = 6`
3. Network progresses to round 15 while validator is temporarily slow/disconnected
4. Validator receives OrderVoteProposal for round 15 with QC certifying round 14 (parent at round 13)
5. `observe_qc()` sets `preferred_round = 13` (the two-chain round)
6. `last_voted_round` remains 6 (not updated in order vote path)
7. **Result: `preferred_round (13) > last_voted_round (6)` - INVARIANT VIOLATED**

The corrupted state persists via `set_safety_data()` which has no validation: [4](#0-3) 

When this validator later becomes leader and attempts to sign a proposal, `verify_and_update_preferred_round()` is called: [5](#0-4) 

This function requires `one_chain_round >= preferred_round`. If the validator tries to propose at round 7 with a QC for round 6, it fails because `6 < 13`, returning `IncorrectPreferredRound` error. The validator cannot serve as leader until the network reaches round 13+.

## Impact Explanation
**High Severity** per Aptos bug bounty criteria:

1. **Validator Node Slowdowns**: Affected validators cannot function as leaders, reducing network throughput and increasing block proposal latency. If multiple validators are affected during network asynchrony periods, consensus performance degrades significantly.

2. **Significant Protocol Violations**: Violates the fundamental invariant that `preferred_round <= last_voted_round`. The comment at line 58-59 in `consensus_state.rs` states: *"A 'preferred block' is the two-chain head with the highest block round. The expectation is that a new proposal's parent is higher or equal to the preferred_round."* [6](#0-5) 

This invariant is violated when order votes update `preferred_round` without updating `last_voted_round`.

3. **Persistent State Corruption**: The corrupted state survives node restarts and can only be recovered by waiting for network progression or epoch changes.

4. **No Direct Safety Violation**: While this breaks liveness, consensus safety is maintained because `verify_and_update_preferred_round` causes affected validators to be overly conservative (rejecting valid proposals rather than accepting invalid ones).

## Likelihood Explanation
**High Likelihood**:

1. **Natural Occurrence**: Validators commonly lag behind the network due to network delays, temporary downtime, or catching up after restarts.

2. **Normal Protocol Operation**: Order votes are broadcast as part of the standard consensus protocol after blocks receive QCs. No malicious behavior required.

3. **Order Vote Validation**: The `verify_order_vote_proposal()` function only checks epoch, QC validity, and block consistency - it does NOT validate round relationships with `last_voted_round`: [7](#0-6) 

4. **Frequent in Production**: Any validator experiencing temporary network issues or restarts will process order votes for blocks it hasn't voted on yet, triggering this condition.

## Recommendation
Add validation in `guarded_construct_and_sign_order_vote` to prevent `preferred_round` from exceeding `last_voted_round`:

```rust
pub(crate) fn guarded_construct_and_sign_order_vote(
    &mut self,
    order_vote_proposal: &OrderVoteProposal,
) -> Result<OrderVote, Error> {
    self.signer()?;
    self.verify_order_vote_proposal(order_vote_proposal)?;
    let proposed_block = order_vote_proposal.block();
    let mut safety_data = self.persistent_storage.safety_data()?;

    // Record 1-chain data BUT prevent preferred_round from exceeding last_voted_round
    let old_preferred_round = safety_data.preferred_round;
    self.observe_qc(order_vote_proposal.quorum_cert(), &mut safety_data);
    
    // FIX: Cap preferred_round at last_voted_round to maintain invariant
    if safety_data.preferred_round > safety_data.last_voted_round {
        safety_data.preferred_round = safety_data.last_voted_round;
        trace!(
            SafetyLogSchema::new(LogEntry::PreferredRound, LogEvent::Update)
                .preferred_round(safety_data.preferred_round)
        );
    }

    self.safe_for_order_vote(proposed_block, &safety_data)?;
    // ... rest of function
}
```

Alternatively, add validation in `set_safety_data()`:

```rust
pub fn set_safety_data(&mut self, data: SafetyData) -> Result<(), Error> {
    // Validate invariant
    if data.preferred_round > data.last_voted_round {
        return Err(Error::InternalError(format!(
            "Invariant violation: preferred_round ({}) > last_voted_round ({})",
            data.preferred_round, data.last_voted_round
        )));
    }
    
    let _timer = counters::start_timer("set", SAFETY_DATA);
    // ... rest of function
}
```

## Proof of Concept
```rust
#[test]
fn test_order_vote_preferred_round_violation() {
    let (mut safety_rules, signer) = make_safety_rules();
    let (proof, genesis_qc) = test_utils::make_genesis(&signer);
    safety_rules.initialize(&proof).unwrap();
    
    // Setup: Vote on round 6
    let p6 = test_utils::make_proposal_with_qc(6, genesis_qc.clone(), &signer);
    safety_rules.construct_and_sign_vote_two_chain(&p6, None).unwrap();
    
    let state = safety_rules.consensus_state().unwrap();
    assert_eq!(state.last_voted_round(), 6);
    let initial_preferred = state.preferred_round();
    
    // Simulate network progression: create block at round 15 with QC
    let p14 = test_utils::make_proposal_with_qc(14, p6.block().quorum_cert().clone(), &signer);
    let p15 = test_utils::make_proposal_with_parent(
        random_payload(100), 15, &p14, None, &signer
    );
    
    // Create order vote proposal for round 15
    let ov15 = OrderVoteProposal::new(
        p14.block().clone(),
        p15.block().quorum_cert().certified_block().clone(),
        Arc::new(p15.block().quorum_cert().clone()),
    );
    
    // Process order vote - this should violate the invariant
    safety_rules.construct_and_sign_order_vote(&ov15).unwrap();
    
    let state_after = safety_rules.consensus_state().unwrap();
    
    // BUG: preferred_round is now > last_voted_round
    assert!(state_after.preferred_round() > state_after.last_voted_round(),
        "Invariant violated: preferred_round ({}) > last_voted_round ({})",
        state_after.preferred_round(), state_after.last_voted_round()
    );
    
    // Demonstrate impact: validator cannot sign proposals
    let p7 = test_utils::make_proposal_with_qc(7, p6.block().quorum_cert().clone(), &signer);
    let result = safety_rules.sign_proposal(p7.block().block_data());
    
    // This should fail with IncorrectPreferredRound error
    assert!(matches!(result, Err(Error::IncorrectPreferredRound(_, _))));
}
```

**Notes**

The vulnerability arises from an architectural mismatch: order votes are designed to allow signing blocks without updating `last_voted_round` (to enable ordering of older blocks), but they still call `observe_qc()` which updates `preferred_round`. This creates a state where the validator "knows" about higher rounds in its preferred_round without having voted on them, violating the semantic meaning that preferred_round should track rounds the validator has participated in. The fix should either prevent preferred_round from being updated beyond last_voted_round during order vote processing, or add validation to reject such states entirely.

### Citations

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L53-95)
```rust
    pub(crate) fn guarded_construct_and_sign_vote_two_chain(
        &mut self,
        vote_proposal: &VoteProposal,
        timeout_cert: Option<&TwoChainTimeoutCertificate>,
    ) -> Result<Vote, Error> {
        // Exit early if we cannot sign
        self.signer()?;

        let vote_data = self.verify_proposal(vote_proposal)?;
        if let Some(tc) = timeout_cert {
            self.verify_tc(tc)?;
        }
        let proposed_block = vote_proposal.block();
        let mut safety_data = self.persistent_storage.safety_data()?;

        // if already voted on this round, send back the previous vote
        // note: this needs to happen after verifying the epoch as we just check the round here
        if let Some(vote) = safety_data.last_vote.clone() {
            if vote.vote_data().proposed().round() == proposed_block.round() {
                return Ok(vote);
            }
        }

        // Two voting rules
        self.verify_and_update_last_vote_round(
            proposed_block.block_data().round(),
            &mut safety_data,
        )?;
        self.safe_to_vote(proposed_block, timeout_cert)?;

        // Record 1-chain data
        self.observe_qc(proposed_block.quorum_cert(), &mut safety_data);
        // Construct and sign vote
        let author = self.signer()?.author();
        let ledger_info = self.construct_ledger_info_2chain(proposed_block, vote_data.hash())?;
        let signature = self.sign(&ledger_info)?;
        let vote = Vote::new_with_signature(vote_data, author, ledger_info, signature);

        safety_data.last_vote = Some(vote.clone());
        self.persistent_storage.set_safety_data(safety_data)?;

        Ok(vote)
    }
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L97-119)
```rust
    pub(crate) fn guarded_construct_and_sign_order_vote(
        &mut self,
        order_vote_proposal: &OrderVoteProposal,
    ) -> Result<OrderVote, Error> {
        // Exit early if we cannot sign
        self.signer()?;
        self.verify_order_vote_proposal(order_vote_proposal)?;
        let proposed_block = order_vote_proposal.block();
        let mut safety_data = self.persistent_storage.safety_data()?;

        // Record 1-chain data
        self.observe_qc(order_vote_proposal.quorum_cert(), &mut safety_data);

        self.safe_for_order_vote(proposed_block, &safety_data)?;
        // Construct and sign order vote
        let author = self.signer()?.author();
        let ledger_info =
            LedgerInfo::new(order_vote_proposal.block_info().clone(), HashValue::zero());
        let signature = self.sign(&ledger_info)?;
        let order_vote = OrderVote::new_with_signature(author, ledger_info.clone(), signature);
        self.persistent_storage.set_safety_data(safety_data)?;
        Ok(order_vote)
    }
```

**File:** consensus/safety-rules/src/safety_rules.rs (L87-111)
```rust
    pub(crate) fn verify_order_vote_proposal(
        &mut self,
        order_vote_proposal: &OrderVoteProposal,
    ) -> Result<(), Error> {
        let proposed_block = order_vote_proposal.block();
        let safety_data = self.persistent_storage.safety_data()?;

        self.verify_epoch(proposed_block.epoch(), &safety_data)?;

        let qc = order_vote_proposal.quorum_cert();
        if qc.certified_block() != order_vote_proposal.block_info() {
            return Err(Error::InvalidOneChainQuorumCertificate(
                qc.certified_block().id(),
                order_vote_proposal.block_info().id(),
            ));
        }
        if qc.certified_block().id() != proposed_block.id() {
            return Err(Error::InvalidOneChainQuorumCertificate(
                qc.certified_block().id(),
                proposed_block.id(),
            ));
        }
        self.verify_qc(qc)?;
        Ok(())
    }
```

**File:** consensus/safety-rules/src/safety_rules.rs (L135-156)
```rust
    pub(crate) fn observe_qc(&self, qc: &QuorumCert, safety_data: &mut SafetyData) -> bool {
        let mut updated = false;
        let one_chain = qc.certified_block().round();
        let two_chain = qc.parent_block().round();
        if one_chain > safety_data.one_chain_round {
            safety_data.one_chain_round = one_chain;
            trace!(
                SafetyLogSchema::new(LogEntry::OneChainRound, LogEvent::Update)
                    .preferred_round(safety_data.one_chain_round)
            );
            updated = true;
        }
        if two_chain > safety_data.preferred_round {
            safety_data.preferred_round = two_chain;
            trace!(
                SafetyLogSchema::new(LogEntry::PreferredRound, LogEvent::Update)
                    .preferred_round(safety_data.preferred_round)
            );
            updated = true;
        }
        updated
    }
```

**File:** consensus/safety-rules/src/safety_rules.rs (L173-188)
```rust
    fn verify_and_update_preferred_round(
        &mut self,
        quorum_cert: &QuorumCert,
        safety_data: &mut SafetyData,
    ) -> Result<bool, Error> {
        let preferred_round = safety_data.preferred_round;
        let one_chain_round = quorum_cert.certified_block().round();

        if one_chain_round < preferred_round {
            return Err(Error::IncorrectPreferredRound(
                one_chain_round,
                preferred_round,
            ));
        }
        Ok(self.observe_qc(quorum_cert, safety_data))
    }
```

**File:** consensus/safety-rules/src/persistent_safety_storage.rs (L150-170)
```rust
    pub fn set_safety_data(&mut self, data: SafetyData) -> Result<(), Error> {
        let _timer = counters::start_timer("set", SAFETY_DATA);
        counters::set_state(counters::EPOCH, data.epoch as i64);
        counters::set_state(counters::LAST_VOTED_ROUND, data.last_voted_round as i64);
        counters::set_state(
            counters::HIGHEST_TIMEOUT_ROUND,
            data.highest_timeout_round as i64,
        );
        counters::set_state(counters::PREFERRED_ROUND, data.preferred_round as i64);

        match self.internal_store.set(SAFETY_DATA, data.clone()) {
            Ok(_) => {
                self.cached_safety_data = Some(data);
                Ok(())
            },
            Err(error) => {
                self.cached_safety_data = None;
                Err(Error::SecureStorageUnexpectedError(error.to_string()))
            },
        }
    }
```

**File:** consensus/safety-rules/src/consensus_state.rs (L58-62)
```rust
    /// A "preferred block" is the two-chain head with the highest block round. The expectation is
    /// that a new proposal's parent is higher or equal to the preferred_round.
    pub fn preferred_round(&self) -> Round {
        self.safety_data.preferred_round
    }
```
