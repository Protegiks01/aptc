# Audit Report

## Title
Genesis Transaction Skip Vulnerability via Race Condition in Indexer Startup

## Summary
A race condition in the Aptos indexer's startup sequence can cause version 0 (genesis transaction) to be permanently skipped. When the indexer starts with a fresh database and the first processing loop iteration executes before the transaction fetcher produces any batches, the database is incorrectly marked as having processed version 0, causing subsequent runs to start from version 1.

## Finding Description

The vulnerability exists in the interaction between the indexer runtime loop and the version tracking logic. The issue occurs through the following code path:

In the main processing loop, `batch_end_version` is initialized to 0: [1](#0-0) 

When processing batches, if all batches are empty (return `None`), the loop continues without updating this value: [2](#0-1) 

After the loop completes, `update_last_processed_version` is called **unconditionally** with `batch_end_version`, regardless of whether any transactions were actually processed: [3](#0-2) 

The database update uses an upsert with a WHERE clause that only applies to the UPDATE portion, not the INSERT: [4](#0-3) 

The race condition occurs because the fetcher is started asynchronously without waiting for it to produce batches: [5](#0-4) 

The main loop starts immediately after, and if the first iteration executes before the fetcher has produced any batches, `fetch_next_batch` returns an empty vector: [6](#0-5) 

This causes `process_next_batch` to return `(0, None)`: [7](#0-6) 

On a subsequent restart, `get_start_version` reads the incorrectly stored value and returns version 1: [8](#0-7) 

The default starting version logic then uses this value: [9](#0-8) 

This breaks the **State Consistency** invariant, as the indexer will have incomplete blockchain data, missing the foundational genesis transaction that establishes initial state.

## Impact Explanation

This qualifies as **Medium Severity** under the Aptos bug bounty criteria: "State inconsistencies requiring intervention."

The impact includes:
- **Incomplete blockchain history**: Genesis transaction (version 0) contains critical initialization data including initial account states, framework modules, and system resources
- **Data integrity violation**: Indexer consumers (explorers, APIs, analytics tools) will have gaps in historical data
- **Manual intervention required**: Database must be wiped and reindexed to recover genesis data
- **Cascading failures**: Downstream services relying on complete transaction history will malfunction

While this doesn't directly affect consensus or validator operations, indexers are critical infrastructure for blockchain observability and application development.

## Likelihood Explanation

**Likelihood: Medium to High**

This vulnerability can trigger in production under normal circumstances:
- Occurs during initial indexer deployment (fresh database)
- Timing window exists between fetcher spawn and first loop iteration
- No attacker action required - pure race condition
- More likely on systems with slower startup (I/O constraints, network delays)
- Can manifest during testing/development where indexers are frequently reset

The condition is transient but the impact is permanent once the database is corrupted.

## Recommendation

Add a guard to prevent updating the database when no transactions were actually processed:

```rust
// In runtime.rs, after line 249
if num_res > 0 {
    tailer
        .update_last_processed_version(&processor_name, batch_end_version)
        .unwrap_or_else(|e| {
            error!(
                processor_name = processor_name,
                end_version = batch_end_version,
                error = format!("{:?}", e),
                "Failed to update last processed version!"
            );
            panic!("Failed to update last processed version: {:?}", e);
        });
}
```

Alternatively, ensure the fetcher has produced at least one batch before starting the processing loop:

```rust
// After line 188 in runtime.rs
// Wait for fetcher to be ready
tokio::time::sleep(Duration::from_millis(100)).await;
```

The first approach is more robust as it prevents the issue regardless of timing.

## Proof of Concept

```rust
#[tokio::test]
async fn test_genesis_skip_vulnerability() {
    use crate::indexer::tailer::Tailer;
    use crate::runtime::run_forever;
    
    // Setup fresh database
    let database_url = std::env::var("INDEXER_DATABASE_URL").unwrap();
    let conn_pool = new_db_pool(database_url.as_str()).unwrap();
    
    // Wipe database to simulate fresh start
    wipe_database(&mut conn_pool.get().unwrap());
    
    // Create indexer with fake fetcher that delays first batch
    let tailer = create_test_tailer_with_delayed_fetcher(conn_pool.clone());
    tailer.run_migrations();
    
    // Simulate first loop iteration before fetcher produces batches
    // All process_next_batch calls return (0, None)
    let (num_txns, result) = tailer.process_next_batch().await;
    assert_eq!(num_txns, 0);
    assert!(result.is_none());
    
    // This incorrectly updates database with version 0
    tailer.update_last_processed_version("test_processor", 0).unwrap();
    
    // Verify database state
    let start_version = tailer.get_start_version(&"test_processor".to_string()).unwrap();
    assert_eq!(start_version, Some(1)); // Should be 0 or None, but returns 1
    
    // Genesis (version 0) will now be skipped on next run
}
```

## Notes

This vulnerability specifically affects the indexer component, not the core consensus or execution layers. However, indexers are critical infrastructure for blockchain usability. The issue demonstrates a subtle initialization race condition where defensive programming could prevent incorrect state persistence.

### Citations

**File:** crates/indexer/src/runtime.rs (L163-172)
```rust
    let starting_version_from_db_short = tailer
        .get_start_version(&processor_name)
        .unwrap_or_else(|e| panic!("Failed to get starting version: {:?}", e))
        .unwrap_or_else(|| {
            info!(
                processor_name = processor_name,
                "No starting version from db so starting from version 0"
            );
            0
        }) as u64;
```

**File:** crates/indexer/src/runtime.rs (L187-188)
```rust
    info!(processor_name = processor_name, "Starting fetcher...");
    tailer.transaction_fetcher.lock().await.start().await;
```

**File:** crates/indexer/src/runtime.rs (L221-222)
```rust
        let mut batch_start_version = u64::MAX;
        let mut batch_end_version = 0;
```

**File:** crates/indexer/src/runtime.rs (L225-228)
```rust
        for (num_txn, res) in batches {
            let processed_result: ProcessingResult = match res {
                // When the batch is empty b/c we're caught up, continue to next batch
                None => continue,
```

**File:** crates/indexer/src/runtime.rs (L251-261)
```rust
        tailer
            .update_last_processed_version(&processor_name, batch_end_version)
            .unwrap_or_else(|e| {
                error!(
                    processor_name = processor_name,
                    end_version = batch_end_version,
                    error = format!("{:?}", e),
                    "Failed to update last processed version!"
                );
                panic!("Failed to update last processed version: {:?}", e);
            });
```

**File:** crates/indexer/src/indexer/tailer.rs (L133-137)
```rust
        let num_txns = transactions.len() as u64;
        // When the batch is empty b/c we're caught up
        if num_txns == 0 {
            return (0, None);
        }
```

**File:** crates/indexer/src/indexer/tailer.rs (L177-189)
```rust
        execute_with_better_error(
            &mut conn,
            diesel::insert_into(processor_status::table)
                .values(&status)
                .on_conflict(processor_status::processor)
                .do_update()
                .set((
                    processor_status::last_success_version
                        .eq(excluded(processor_status::last_success_version)),
                    processor_status::last_updated.eq(excluded(processor_status::last_updated)),
                )),
            Some(" WHERE processor_status.last_success_version <= EXCLUDED.last_success_version "),
        )?;
```

**File:** crates/indexer/src/indexer/tailer.rs (L194-201)
```rust
    pub fn get_start_version(&self, processor_name: &String) -> Result<Option<i64>> {
        let mut conn = self.connection_pool.get()?;

        match ProcessorStatusV2Query::get_by_processor(processor_name, &mut conn)? {
            Some(status) => Ok(Some(status.last_success_version + 1)),
            None => Ok(None),
        }
    }
```

**File:** crates/indexer/src/indexer/fetcher.rs (L438-448)
```rust
    async fn fetch_next_batch(&mut self) -> Vec<Transaction> {
        // try_next is nonblocking unlike next. It'll try to fetch the next one and return immediately.
        match self.transaction_receiver.try_next() {
            Ok(Some(transactions)) => transactions,
            Ok(None) => {
                // We never close the channel, so this should never happen
                panic!("Transaction fetcher channel closed");
            },
            // The error here is when the channel is empty which we definitely expect.
            Err(_) => vec![],
        }
```
