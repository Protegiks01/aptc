# Audit Report

## Title
Consensus DoS via Unchecked Author Validation in Secret Share Processing Leading to Total Network Liveness Failure

## Summary
The `SecretShareConfig::get_id()` function uses `.expect()` which panics when a SecretShare contains an author address not in the validator index. A single malicious validator can exploit this to crash all other validators by continuously broadcasting SecretShare messages with invalid author addresses, causing total loss of network liveness.

## Finding Description
The vulnerability exists in the secret sharing component of the Aptos consensus protocol. When validators process incoming SecretShare messages during consensus rounds, the verification flow calls `get_id()` to look up the author's validator index. [1](#0-0) 

This function uses `.expect()` which panics if the author is not found in the validator index. The panic is not caught and instead triggers the global panic handler. [2](#0-1) 

The panic handler terminates the entire validator process. [3](#0-2) 

This panic handler is explicitly set up during validator initialization. [4](#0-3) 

**Attack Flow:**
1. A malicious validator crafts a SecretShareMessage containing a SecretShare with an invalid author address (not in the current validator set)
2. The network layer accepts the message since the sender is an authenticated validator
3. The receiving validator's verification task processes the message [5](#0-4) 
4. The task calls `msg.verify()` [6](#0-5) 
5. Which calls `share.verify()` [7](#0-6) 
6. Which calls `get_id()` and panics
7. The validator process exits immediately with code 12

The code even contains a TODO comment acknowledging the missing bounds check. [8](#0-7) 

This breaks the **Consensus Safety** invariant that "AptosBFT must prevent double-spending and chain splits under < 1/3 Byzantine" by allowing a single malicious validator (< 1/3) to cause complete network unavailability.

## Impact Explanation
This is **Critical Severity** under the Aptos Bug Bounty program category "Total loss of liveness/network availability" (up to $1,000,000).

A single malicious validator can:
- Crash all other validators simultaneously by broadcasting malformed shares
- Repeatedly crash validators as they restart, preventing any consensus progress
- Cause indefinite network downtime until manual intervention patches all nodes
- Require emergency network upgrade/hardfork to resolve

The entire validator set becomes unavailable, halting all transaction processing, block production, and state transitions. This is worse than a 51% attack as it requires only one malicious validator.

## Likelihood Explanation
**Likelihood: HIGH**

The attack requires:
- A single malicious validator (which BFT assumes possible)
- Ability to send consensus messages (validators can always do this)
- Knowledge of any account address not in the current validator set (trivial)

The attack is:
- Simple to execute (single malformed message)
- Deterministic (always crashes target)
- Repeatable (can be sent continuously)
- Undetectable until validators crash (no pre-validation)

The vulnerability is actively exploitable in production networks today.

## Recommendation
Replace the `.expect()` with proper error handling that returns a `Result`:

```rust
pub fn get_id(&self, peer: &Author) -> anyhow::Result<usize> {
    self.validator
        .address_to_validator_index()
        .get(peer)
        .copied()
        .ok_or_else(|| anyhow::anyhow!("Author {} not in validator set", peer))
}
```

Then propagate the error through the call chain instead of panicking. Additionally, add early validation in `SecretShareMessage::verify()` to check that the author is in the validator set before calling cryptographic verification:

```rust
pub fn verify(&self, epoch_state: &EpochState, config: &SecretShareConfig) -> anyhow::Result<()> {
    ensure!(self.epoch() == epoch_state.epoch);
    match self {
        SecretShareMessage::RequestShare(_) => Ok(()),
        SecretShareMessage::Share(share) => {
            // Validate author is in validator set BEFORE expensive crypto
            ensure!(
                epoch_state.verifier.address_to_validator_index().contains_key(share.author()),
                "Share author {} not in current validator set",
                share.author()
            );
            share.verify(config)
        },
    }
}
```

## Proof of Concept

```rust
#[cfg(test)]
mod test {
    use super::*;
    use aptos_types::{
        account_address::AccountAddress,
        validator_verifier::ValidatorVerifier,
    };
    use std::sync::Arc;

    #[test]
    #[should_panic(expected = "Peer should be in the index")]
    fn test_invalid_author_causes_panic() {
        // Create a minimal validator set with one validator
        let validator_address = AccountAddress::random();
        let verifier = ValidatorVerifier::new(vec![(validator_address, 1)]);
        
        // Create SecretShareConfig
        let config = SecretShareConfig {
            _author: validator_address,
            _epoch: 1,
            validator: Arc::new(verifier),
            // ... other fields initialized with defaults
        };
        
        // Try to get ID for an address NOT in the validator set
        let invalid_address = AccountAddress::random();
        let _ = config.get_id(&invalid_address); // This will panic!
    }
    
    #[test]
    fn test_malicious_share_verification_crashes() {
        // Setup validator set
        let validator_address = AccountAddress::random();
        let verifier = ValidatorVerifier::new(vec![(validator_address, 1)]);
        let config = SecretShareConfig::new(/* ... */);
        
        // Create malicious share with invalid author
        let malicious_author = AccountAddress::random(); // Not in validator set!
        let malicious_share = SecretShare::new(
            malicious_author,
            SecretShareMetadata::default(),
            SecretKeyShare::default(),
        );
        
        // This will panic and crash the validator
        let result = malicious_share.verify(&config);
        // Never reaches here - process exits via panic handler
    }
}
```

**Notes:**
- This vulnerability requires a malicious validator to exploit, but BFT consensus explicitly assumes up to 1/3 Byzantine validators
- The system should gracefully reject invalid shares with error returns, not crash
- The panic occurs before cryptographic verification, so it bypasses signature checks
- The TODO comment at line 78 of `secret_sharing.rs` indicates developers were aware of the missing validation but it was never implemented

### Citations

**File:** types/src/secret_sharing.rs (L76-76)
```rust
        let index = config.get_id(self.author());
```

**File:** types/src/secret_sharing.rs (L78-78)
```rust
        // TODO(ibalajiarun): Check index out of bounds
```

**File:** types/src/secret_sharing.rs (L172-178)
```rust
    pub fn get_id(&self, peer: &Author) -> usize {
        *self
            .validator
            .address_to_validator_index()
            .get(peer)
            .expect("Peer should be in the index!")
    }
```

**File:** crates/crash-handler/src/lib.rs (L26-30)
```rust
pub fn setup_panic_handler() {
    panic::set_hook(Box::new(move |pi: &PanicHookInfo<'_>| {
        handle_panic(pi);
    }));
}
```

**File:** crates/crash-handler/src/lib.rs (L56-57)
```rust
    // Kill the process
    process::exit(12);
```

**File:** aptos-node/src/lib.rs (L233-234)
```rust
    // Setup panic handler
    aptos_crash_handler::setup_panic_handler();
```

**File:** consensus/src/rand/secret_sharing/secret_share_manager.rs (L216-233)
```rust
            bounded_executor
                .spawn(async move {
                    match bcs::from_bytes::<SecretShareMessage>(dec_msg.req.data()) {
                        Ok(msg) => {
                            if msg.verify(&epoch_state_clone, &config_clone).is_ok() {
                                let _ = tx.unbounded_send(SecretShareRpc {
                                    msg,
                                    protocol: dec_msg.protocol,
                                    response_sender: dec_msg.response_sender,
                                });
                            }
                        },
                        Err(e) => {
                            warn!("Invalid dec message: {}", e);
                        },
                    }
                })
                .await;
```

**File:** consensus/src/rand/secret_sharing/network_messages.rs (L36-36)
```rust
            SecretShareMessage::Share(share) => share.verify(config),
```
