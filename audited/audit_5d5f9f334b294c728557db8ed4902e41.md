# Audit Report

## Title
Unbounded Memory Growth in VM Validator Module Cache Leading to Resource Exhaustion

## Summary
The `CachedModuleView` used in `vm-validator` for transaction validation has no memory bounds on its module cache. An attacker can cause unbounded memory growth by deploying many large Move modules and sending transactions that reference them, leading to memory exhaustion across all validator nodes.

## Finding Description
The vm-validator component uses a `PooledVMValidator` that maintains a pool of `VMValidator` instances for concurrent transaction validation. Each `VMValidator` contains a `CachedModuleView` that caches loaded Move modules to avoid repeated deserialization. [1](#0-0) 

The `CachedModuleView` uses an `UnsyncModuleCache` internally, which is implemented as a simple `RefCell<HashMap>` with no size limits: [2](#0-1) [3](#0-2) 

**Critical Issue**: The cache persists across block commits in the normal case. When `notify_commit()` is called after a block commit, if the state versions are compatible (linear progression), it only calls `reset_state_view()` which does NOT flush the module cache: [4](#0-3) [5](#0-4) 

**Contrast with Block Executor**: The block executor uses `GlobalModuleCache` which tracks `size_in_bytes` and enforces a configurable memory limit (default 1GB): [6](#0-5) [7](#0-6) [8](#0-7) [9](#0-8) 

The vm-validator has NO such bounds checking.

**Attack Path**:
1. Attacker deploys many large Move modules (production config has unlimited struct/function definitions): [10](#0-9) 

2. Attacker sends transactions to mempool that call functions in these modules
3. Each VMValidator loads modules into its unbounded cache during validation
4. Pool size multiplies impact (set to `num_cpus::get()`): [11](#0-10) 

5. Modules accumulate across commits (cache not flushed in normal case)
6. Memory exhaustion occurs, degrading validator performance or causing crashes

The cache is only cleared during reconfig events, not during normal block processing: [12](#0-11) 

## Impact Explanation
**High Severity** per Aptos bug bounty criteria:

This vulnerability directly matches the HIGH severity category: "Validator Node Slowdowns (High): Significant performance degradation affecting consensus, DoS through resource exhaustion."

- **Validator node slowdowns**: Memory exhaustion causes performance degradation as nodes approach OOM conditions, impacting transaction validation throughput
- **Potential node crashes**: Severe memory exhaustion can trigger OOM killer, causing validator unavailability
- **Network-wide impact**: All validators are affected simultaneously as they process the same transactions

This is resource exhaustion DoS (in scope), not network DoS (out of scope). The attack uses valid transactions to cause memory exhaustion, not network packet flooding.

## Likelihood Explanation
**High Likelihood**:
- Attack requires only standard user capabilities (module deployment + transaction submission)
- No rate limiting on module cache growth
- Exploit is deterministic and reproducible
- Cost is bounded by gas fees for module deployment (one-time cost per module)
- Impact persists across blocks until reconfig event or manual restart
- Affects all validators simultaneously, maximizing damage
- Module size limits in production are lenient (unlimited struct/function definitions)

## Recommendation
Implement memory bounds for `CachedModuleView` similar to the block executor's approach:

1. Add size tracking to `UnsyncModuleCache` or `CachedModuleView`
2. Define a configurable `max_module_cache_size_in_bytes` limit for vm-validator
3. Implement cache eviction policy (e.g., LRU) when limit is exceeded
4. Alternatively, periodically flush the cache even during linear progression

Example approach: Add a size field to `CachedModuleView` and check it in `notify_commit()`, flushing the cache when it exceeds a threshold.

## Proof of Concept
While no executable PoC is provided, the vulnerability can be triggered through:

1. Deploy multiple Move modules with maximum allowed size (utilizing unlimited struct/function definitions)
2. Submit transactions to mempool that reference these modules
3. Monitor validator memory usage over multiple blocks
4. Observe unbounded cache growth leading to memory exhaustion

The attack is deterministic given the verified code paths showing unbounded cache accumulation across block commits.

### Citations

**File:** vm-validator/src/vm_validator.rs (L42-45)
```rust
struct VMValidator {
    db_reader: Arc<dyn DbReader>,
    state: CachedModuleView<CachedDbStateView>,
}
```

**File:** vm-validator/src/vm_validator.rs (L76-99)
```rust
    fn notify_commit(&mut self) {
        let db_state_view = self.db_state_view();

        // On commit, we need to update the state view so that we can see the latest resources.
        let base_view_id = self.state.state_view_id();
        let new_view_id = db_state_view.id();
        match (base_view_id, new_view_id) {
            (
                StateViewId::TransactionValidation {
                    base_version: old_version,
                },
                StateViewId::TransactionValidation {
                    base_version: new_version,
                },
            ) => {
                // if the state view forms a linear history, just update the state view
                if old_version <= new_version {
                    self.state.reset_state_view(db_state_view.into());
                }
            },
            // if the version is incompatible, we flush the cache
            _ => self.state.reset_all(db_state_view.into()),
        }
    }
```

**File:** aptos-move/aptos-resource-viewer/src/module_view.rs (L101-103)
```rust
    pub module_cache:
        UnsyncModuleCache<ModuleId, CompiledModule, Module, AptosModuleExtension, usize>,
}
```

**File:** aptos-move/aptos-resource-viewer/src/module_view.rs (L121-125)
```rust
    /// Resets the state view snapshot to the new one. Does not invalidate the module cache, nor
    /// the VM.
    pub fn reset_state_view(&mut self, state_view: S) {
        self.state_view = state_view;
    }
```

**File:** third_party/move/move-vm/types/src/code/cache/module_cache.rs (L211-213)
```rust
pub struct UnsyncModuleCache<K, DC, VC, E, V> {
    module_cache: RefCell<HashMap<K, VersionedModuleCode<DC, VC, E, V>>>,
}
```

**File:** aptos-move/block-executor/src/code_cache_global.rs (L89-97)
```rust
pub struct GlobalModuleCache<K, D, V, E> {
    /// Module cache containing the verified code.
    module_cache: HashMap<K, Entry<D, V, E>>,
    /// Sum of serialized sizes (in bytes) of all cached modules.
    size: usize,
    /// Cached layouts of structs or enums. This cache stores roots only and is invalidated when
    /// modules are published.
    struct_layouts: DashMap<StructKey, LayoutCacheEntry>,
}
```

**File:** aptos-move/block-executor/src/code_cache_global.rs (L150-153)
```rust
    /// Returns the sum of serialized sizes of modules stored in cache.
    pub fn size_in_bytes(&self) -> usize {
        self.size
    }
```

**File:** aptos-move/block-executor/src/code_cache_global_manager.rs (L168-175)
```rust
        let module_cache_size_in_bytes = self.module_cache.size_in_bytes();
        GLOBAL_MODULE_CACHE_SIZE_IN_BYTES.set(module_cache_size_in_bytes as i64);
        GLOBAL_MODULE_CACHE_NUM_MODULES.set(self.module_cache.num_modules() as i64);

        // If module cache stores too many modules, flush it as well.
        if module_cache_size_in_bytes > config.max_module_cache_size_in_bytes {
            self.module_cache.flush();
        }
```

**File:** types/src/block_executor/config.rs (L31-37)
```rust
impl Default for BlockExecutorModuleCacheLocalConfig {
    fn default() -> Self {
        Self {
            prefetch_framework_code: true,
            // Use 1Gb for now, should be large enough to cache all mainnet modules (at the time
            // of writing this comment, 13.11.24).
            max_module_cache_size_in_bytes: 1024 * 1024 * 1024,
```

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L168-171)
```rust
        max_struct_definitions: None,
        max_struct_variants: None,
        max_fields_in_struct: None,
        max_function_definitions: None,
```

**File:** mempool/src/shared_mempool/runtime.rs (L104-107)
```rust
    let vm_validator = Arc::new(RwLock::new(PooledVMValidator::new(
        Arc::clone(&db),
        num_cpus::get(),
    )));
```

**File:** mempool/src/shared_mempool/tasks.rs (L775-778)
```rust
    if let Err(e) = validator.write().restart() {
        counters::VM_RECONFIG_UPDATE_FAIL_COUNT.inc();
        error!(LogSchema::event_log(LogEntry::ReconfigUpdate, LogEvent::VMUpdateFail).error(&e));
    }
```
