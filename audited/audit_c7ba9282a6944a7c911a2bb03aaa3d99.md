# Audit Report

## Title
Indexer Denial of Service via Unhandled Deserialization Error in Coin Processor

## Summary
The `CoinTransactionProcessor` contains an unsafe `.unwrap()` call that will panic and crash the indexer service when processing transactions with WriteResources that fail deserialization, causing API unavailability.

## Finding Description
The vulnerability exists in the `process_transactions()` function where `AccountTransaction::from_transaction()` is called with an unsafe `.unwrap()`: [1](#0-0) 

This creates a panic-based error propagation path:

1. `AccountTransaction::from_transaction()` returns `anyhow::Result<HashMap<...>>` and can fail when processing WriteResources [2](#0-1) 

2. The function calls `from_write_resource()` which attempts to deserialize ObjectCore and other V2 token resources: [3](#0-2) 

3. `ObjectWithMetadata::from_write_resource()` calls `V2TokenResource::from_resource()` which performs JSON deserialization: [4](#0-3) 

4. The deserialization can fail if the on-chain data structure doesn't match the expected schema: [5](#0-4) 

5. When deserialization fails, the error propagates through the `?` operators, and the `.unwrap()` causes a panic

6. The panic causes the tokio task to fail, which is caught by `try_join_all()` in the runtime, triggering another panic that crashes the entire indexer: [6](#0-5) 

**Trigger Conditions:**
- Transactions containing WriteResources with type matching V2 token resources (e.g., `0x1::object::ObjectCore`)
- Data that cannot be deserialized into the expected Rust struct due to schema mismatch, missing fields, or type mismatches
- This can occur during Move framework upgrades where on-chain struct definitions evolve but the indexer is not updated

## Impact Explanation
This qualifies as **High Severity** under the Aptos bug bounty criteria for "API crashes". When triggered:

- The indexer process terminates immediately via panic
- All indexer API endpoints become unavailable
- Users cannot query transaction history, balances, or account information
- The indexer must be manually restarted
- Upon restart, it will repeatedly crash on the same problematic transaction, creating a persistent DoS condition
- While the blockchain itself continues operating, all applications dependent on the indexer API (wallets, explorers, dApps) lose access to historical data

The indexer is critical infrastructure for the Aptos ecosystem, powering the REST API that most applications rely on for querying blockchain state.

## Likelihood Explanation
**Medium-Low Likelihood** in current deployment, but risk increases with:

1. **Move Framework Evolution**: When the Aptos framework is upgraded and struct definitions change (e.g., adding/removing fields from ObjectCore), a schema mismatch occurs if the indexer isn't updated simultaneously [7](#0-6) 

2. **Version Skew**: The indexer's `ObjectCore` definition has only 3 fields while the on-chain version has 4 (including `transfer_events`), though serde typically ignores extra fields: [8](#0-7) 

3. **Custom Deserializers**: Fields using `deserialize_from_string` can fail if the data format doesn't match expectations (e.g., numeric values not in string format) [9](#0-8) 

While the Move VM typically produces well-formed data, the lack of defensive error handling creates unnecessary fragility.

## Recommendation
Replace the unsafe `.unwrap()` with proper error handling that logs the error and either skips the problematic transaction or returns a recoverable error:

```rust
// Option 1: Skip and log
match AccountTransaction::from_transaction(txn) {
    Ok(txns) => account_transactions.extend(txns),
    Err(e) => {
        aptos_logger::error!(
            transaction_version = txn.version(),
            error = ?e,
            "Failed to parse AccountTransaction, skipping"
        );
        // Continue processing other transactions
    }
}

// Option 2: Return error for batch retry
account_transactions.extend(
    AccountTransaction::from_transaction(txn)
        .map_err(|e| TransactionProcessingError::TransactionCommitError((
            e,
            start_version,
            end_version,
            self.name(),
        )))?
);
```

Additionally, ensure indexer struct definitions stay synchronized with on-chain Move structs, and add integration tests for schema evolution scenarios.

## Proof of Concept

```rust
// Rust test demonstrating the panic
#[test]
#[should_panic(expected = "called `Result::unwrap()` on an `Err` value")]
fn test_indexer_panic_on_malformed_resource() {
    use aptos_api_types::{Transaction, WriteResource, WriteSetChange};
    use serde_json::json;
    
    // Create a transaction with a malformed ObjectCore resource
    // Missing required fields to trigger deserialization error
    let malformed_txn: Transaction = serde_json::from_value(json!({
        "type": "user_transaction",
        "version": "1000",
        "hash": "0x123...",
        "state_change_hash": "0x456...",
        // ... other required fields ...
        "changes": [{
            "type": "write_resource",
            "address": "0x1",
            "state_key_hash": "0xabc...",
            "data": {
                "type": "0x1::object::ObjectCore",
                "data": {
                    // Malformed: missing 'owner' field
                    "allow_ungated_transfer": true,
                    "guid_creation_num": "123"
                    // 'owner' field is missing - will cause deserialization to fail
                }
            }
        }],
        "events": []
    })).unwrap();
    
    // This will panic due to the .unwrap() on line 314
    let result = AccountTransaction::from_transaction(&malformed_txn);
    result.unwrap(); // PANIC!
}
```

**Notes**
- This vulnerability represents a defensive programming failure rather than a direct exploit vector
- The actual exploitability depends on conditions outside typical attacker control (committed transactions contain malformed data)
- Primary risk is during framework upgrades or in the presence of VM bugs
- Impact is limited to indexer API availability; core blockchain operation is unaffected
- Should be classified as a robustness/reliability issue requiring improved error handling

### Citations

**File:** crates/indexer/src/processors/coin_processor.rs (L314-314)
```rust
            account_transactions.extend(AccountTransaction::from_transaction(txn).unwrap());
```

**File:** crates/indexer/src/models/coin_models/account_transactions.rs (L38-86)
```rust
    pub fn from_transaction(
        transaction: &Transaction,
    ) -> anyhow::Result<HashMap<AccountTransactionPK, Self>> {
        let (events, wscs, signatures, txn_version) = match transaction {
            Transaction::UserTransaction(inner) => (
                &inner.events,
                &inner.info.changes,
                UserTransaction::get_signatures(inner, inner.info.version.0 as i64, 0),
                inner.info.version.0 as i64,
            ),
            Transaction::GenesisTransaction(inner) => (
                &inner.events,
                &inner.info.changes,
                vec![],
                inner.info.version.0 as i64,
            ),
            Transaction::BlockMetadataTransaction(inner) => (
                &inner.events,
                &inner.info.changes,
                vec![],
                inner.info.version.0 as i64,
            ),
            _ => {
                return Ok(HashMap::new());
            },
        };
        let mut account_transactions = HashMap::new();
        for sig in &signatures {
            account_transactions.insert((sig.signer.clone(), txn_version), Self {
                transaction_version: txn_version,
                account_address: sig.signer.clone(),
            });
        }
        for event in events {
            account_transactions.extend(Self::from_event(event, txn_version));
        }
        for wsc in wscs {
            match wsc {
                WriteSetChange::DeleteResource(res) => {
                    account_transactions.extend(Self::from_delete_resource(res, txn_version)?);
                },
                WriteSetChange::WriteResource(res) => {
                    account_transactions.extend(Self::from_write_resource(res, txn_version)?);
                },
                _ => {},
            }
        }
        Ok(account_transactions)
    }
```

**File:** crates/indexer/src/models/coin_models/account_transactions.rs (L100-118)
```rust
    fn from_write_resource(
        write_resource: &WriteResource,
        txn_version: i64,
    ) -> anyhow::Result<HashMap<AccountTransactionPK, Self>> {
        let mut result = HashMap::new();
        let account_address = standardize_address(&write_resource.address.to_string());
        result.insert((account_address.clone(), txn_version), Self {
            transaction_version: txn_version,
            account_address,
        });
        if let Some(inner) = &ObjectWithMetadata::from_write_resource(write_resource, txn_version)?
        {
            result.insert((inner.object_core.get_owner_address(), txn_version), Self {
                transaction_version: txn_version,
                account_address: inner.object_core.get_owner_address(),
            });
        }
        Ok(result)
    }
```

**File:** crates/indexer/src/models/token_models/v2_token_utils.rs (L68-74)
```rust
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct ObjectCore {
    pub allow_ungated_transfer: bool,
    #[serde(deserialize_with = "deserialize_from_string")]
    pub guid_creation_num: BigDecimal,
    owner: String,
}
```

**File:** crates/indexer/src/models/token_models/v2_token_utils.rs (L89-114)
```rust
    pub fn from_write_resource(
        write_resource: &WriteResource,
        txn_version: i64,
    ) -> anyhow::Result<Option<Self>> {
        let type_str = format!(
            "{}::{}::{}",
            write_resource.data.typ.address,
            write_resource.data.typ.module,
            write_resource.data.typ.name
        );
        if !V2TokenResource::is_resource_supported(type_str.as_str()) {
            return Ok(None);
        }
        if let V2TokenResource::ObjectCore(inner) = V2TokenResource::from_resource(
            &type_str,
            &serde_json::to_value(&write_resource.data.data).unwrap(),
            txn_version,
        )? {
            Ok(Some(Self {
                object_core: inner,
                state_key_hash: standardize_address(write_resource.state_key_hash.as_str()),
            }))
        } else {
            Ok(None)
        }
    }
```

**File:** crates/indexer/src/models/token_models/v2_token_utils.rs (L466-503)
```rust
    pub fn from_resource(
        data_type: &str,
        data: &serde_json::Value,
        txn_version: i64,
    ) -> Result<Self> {
        match data_type {
            "0x1::object::ObjectCore" => {
                serde_json::from_value(data.clone()).map(|inner| Some(Self::ObjectCore(inner)))
            },
            "0x4::collection::Collection" => {
                serde_json::from_value(data.clone()).map(|inner| Some(Self::Collection(inner)))
            },
            "0x4::collection::FixedSupply" => {
                serde_json::from_value(data.clone()).map(|inner| Some(Self::FixedSupply(inner)))
            },
            "0x4::collection::UnlimitedSupply" => {
                serde_json::from_value(data.clone()).map(|inner| Some(Self::UnlimitedSupply(inner)))
            },
            "0x4::aptos_token::AptosCollection" => {
                serde_json::from_value(data.clone()).map(|inner| Some(Self::AptosCollection(inner)))
            },
            "0x4::token::Token" => {
                serde_json::from_value(data.clone()).map(|inner| Some(Self::TokenV2(inner)))
            },
            "0x4::property_map::PropertyMap" => {
                serde_json::from_value(data.clone()).map(|inner| Some(Self::PropertyMap(inner)))
            },
            _ => Ok(None),
        }
        .context(format!(
            "version {} failed! failed to parse type {}, data {:?}",
            txn_version, data_type, data
        ))?
        .context(format!(
            "Resource unsupported! Call is_resource_supported first. version {} type {}",
            txn_version, data_type
        ))
    }
```

**File:** crates/indexer/src/runtime.rs (L216-219)
```rust
        let batches = match futures::future::try_join_all(tasks).await {
            Ok(res) => res,
            Err(err) => panic!("Error processing transaction batches: {:?}", err),
        };
```

**File:** aptos-move/framework/aptos-framework/sources/object.move (L98-108)
```text
    struct ObjectCore has key {
        /// Used by guid to guarantee globally unique objects and create event streams
        guid_creation_num: u64,
        /// The address (object or account) that owns this object
        owner: address,
        /// Object transferring is a common operation, this allows for disabling and enabling
        /// transfers bypassing the use of a TransferRef.
        allow_ungated_transfer: bool,
        /// Emitted events upon transferring of ownership.
        transfer_events: event::EventHandle<TransferEvent>,
    }
```

**File:** api/types/src/lib.rs (L63-73)
```rust
pub fn deserialize_from_string<'de, D, T>(deserializer: D) -> Result<T, D::Error>
where
    D: Deserializer<'de>,
    T: FromStr,
    <T as FromStr>::Err: std::fmt::Display,
{
    use serde::de::Error;

    let s = <String>::deserialize(deserializer)?;
    s.parse::<T>().map_err(D::Error::custom)
}
```
