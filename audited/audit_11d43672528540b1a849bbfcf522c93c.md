# Audit Report

## Title
Incorrect Peer Penalty for Cryptographic Proof Verification Failures in State Sync

## Summary
The `handle_error_notification()` function in the state sync driver hardcodes `NotificationFeedback::InvalidPayloadData` for all storage synchronizer errors, including cryptographic proof verification failures. This causes malicious peers sending invalid proofs to be under-penalized (0.95x score multiplier) instead of being marked as malicious (0.8x multiplier), allowing them to continue attacks longer and waste node resources. [1](#0-0) 

## Finding Description

The state sync driver receives error notifications from the storage synchronizer when data processing fails. The critical issue is that **all error types** are treated identically with `InvalidPayloadData` feedback, despite different error causes requiring different peer reputation penalties.

**The Vulnerability Chain:**

1. **Proof Verification in Chunk Executor**: When the storage synchronizer processes transactions or outputs, the `StateSyncChunkVerifier` performs cryptographic verification of proofs by checking that the chunk extends the parent accumulator and that transaction infos match. [2](#0-1) 

2. **Error Propagation**: When chunk execution or application fails (including proof verification failures), errors propagate through the storage synchronizer pipeline and are caught by the executor. [3](#0-2) 

3. **Error Notification Sent to Driver**: The storage synchronizer sends an error notification to the driver with the notification ID. [4](#0-3) 

4. **Incorrect Feedback Hardcoding**: The driver's `handle_error_notification()` function hardcodes `NotificationFeedback::InvalidPayloadData` for ALL storage synchronizer errors, regardless of the underlying cause. [5](#0-4) 

5. **Feedback Transformation**: The `InvalidPayloadData` feedback is transformed into `ResponseError::InvalidData`. [6](#0-5) 

6. **Incorrect Peer Scoring**: `ResponseError::InvalidData` is mapped to `ErrorType::NotUseful` (0.95x multiplier) instead of `ErrorType::Malicious` (0.8x multiplier) that should be used for proof verification errors. [7](#0-6) [8](#0-7) 

**The Broken Invariant**: The codebase already correctly uses `NotificationFeedback::PayloadProofFailed` for proof verification failures that occur in the bootstrapper and continuous syncer (before data reaches the storage synchronizer). [9](#0-8) [10](#0-9) 

However, proof verification failures that occur **inside** the storage synchronizer (in the chunk executor) are incorrectly treated as `InvalidPayloadData`. This inconsistency violates the peer reputation system's design.

**Attack Path:**
1. Malicious peer sends `TransactionListWithProofV2` with invalid cryptographic proof
2. Continuous syncer/bootstrapper passes it to storage synchronizer 
3. Chunk executor detects invalid proof during `verify_chunk_result()` and returns error
4. Error propagates as `ErrorNotification` to driver
5. Driver incorrectly uses `InvalidPayloadData` feedback (line 502)
6. Peer score multiplied by 0.95 instead of 0.8
7. Attacker can send approximately **3.5-4x more** invalid responses before being ignored

## Impact Explanation

**Medium Severity** - This meets the "State inconsistencies requiring manual intervention" criterion:

- **Peer Reputation State Corruption**: The peer scoring system's state becomes inconsistent with actual peer behavior - malicious peers (sending invalid proofs) are categorized as "not useful" rather than "malicious"

- **Resource Exhaustion**: Malicious peers can waste significantly more node resources before being ignored:
  - Starting score: 50 [11](#0-10) 
  - Ignore threshold: 25 [12](#0-11) 
  - With 0.95 multiplier: ~14 bad responses needed (50 * 0.95^14 ≈ 24.4)
  - With 0.8 multiplier: ~4 bad responses needed (50 * 0.8^4 ≈ 20.5)
  - **~3.5x more attack opportunities**

- **State Sync Performance Degradation**: Each invalid proof wastes CPU cycles on verification and network bandwidth on retries, delaying blockchain synchronization

- **Protocol Violation**: The peer reputation mechanism is a critical security component that protects against resource exhaustion attacks

This does not qualify as High/Critical severity because:
- No direct fund loss or consensus break
- Network remains operational
- No validator node compromise
- Can be mitigated by node operators monitoring peer behavior

## Likelihood Explanation

**High Likelihood** - This vulnerability will trigger in any realistic attack scenario:

1. **No Special Access Required**: Any network peer can connect and send data
2. **Guaranteed Code Path**: Invalid proofs will definitely trigger chunk executor verification failure
3. **No Rate Limiting Bypass Needed**: The incorrect feedback is applied on every error
4. **Realistic Attack Vector**: Sending invalid cryptographic data is trivial for attackers
5. **Design Inconsistency**: The code already has `PayloadProofFailed` feedback for other proof failures, indicating this is an oversight

The vulnerability is not theoretical - it affects every node performing state synchronization with external peers.

## Recommendation

Modify the `handle_error_notification()` function to differentiate between error types and use appropriate feedback. When storage synchronizer errors indicate proof verification failures, use `NotificationFeedback::PayloadProofFailed` instead of `InvalidPayloadData`.

The storage synchronizer should categorize errors and include error type information in the `ErrorNotification`, allowing the driver to select the appropriate feedback based on the error cause:
- Proof verification failures → `PayloadProofFailed`
- Data format/structure issues → `InvalidPayloadData`
- Other errors → appropriate feedback

## Proof of Concept

The vulnerability is demonstrated by code inspection:

1. A malicious peer sends `TransactionListWithProofV2` with `txn_infos_with_proof` that fails `verify_extends_ledger()` in `StateSyncChunkVerifier::verify_chunk_result()`
2. The error propagates through `execute_transaction_chunk()` → executor spawn (line 572-586) → `handle_storage_synchronizer_error()` → `send_storage_synchronizer_error()`
3. The driver receives the error and hardcodes `InvalidPayloadData` (line 502)
4. This maps to `ErrorType::NotUseful` (0.95x) instead of `ErrorType::Malicious` (0.8x)
5. The peer's score decreases slower, allowing ~3.5x more malicious attempts

## Notes

This vulnerability represents a design inconsistency where the same type of error (proof verification failure) is handled differently depending on where it occurs in the pipeline. The codebase already correctly uses `PayloadProofFailed` for proof failures in the bootstrapper and continuous syncer, but fails to use it for proof failures in the storage synchronizer's chunk executor.

The mathematical calculations for exact number of bad responses may vary slightly based on whether peers send mixed good/bad responses, but the core issue remains: malicious behavior is under-penalized by approximately 3.5-4x, allowing resource exhaustion attacks to persist significantly longer than intended.

### Citations

**File:** state-sync/state-sync-driver/src/driver.rs (L494-533)
```rust
    /// Handles an error notification sent by the storage synchronizer
    async fn handle_error_notification(&mut self, error_notification: ErrorNotification) {
        warn!(LogSchema::new(LogEntry::SynchronizerNotification)
            .error_notification(error_notification.clone())
            .message("Received an error notification from the storage synchronizer!"));

        // Terminate the currently active streams
        let notification_id = error_notification.notification_id;
        let notification_feedback = NotificationFeedback::InvalidPayloadData;
        if self.bootstrapper.is_bootstrapped() {
            if let Err(error) = self
                .continuous_syncer
                .handle_storage_synchronizer_error(NotificationAndFeedback::new(
                    notification_id,
                    notification_feedback,
                ))
                .await
            {
                error!(LogSchema::new(LogEntry::SynchronizerNotification)
                    .message(&format!(
                        "Failed to terminate the active stream for the continuous syncer! Error: {:?}",
                        error
                    )));
            }
        } else if let Err(error) = self
            .bootstrapper
            .handle_storage_synchronizer_error(NotificationAndFeedback::new(
                notification_id,
                notification_feedback,
            ))
            .await
        {
            error!(
                LogSchema::new(LogEntry::SynchronizerNotification).message(&format!(
                    "Failed to terminate the active stream for the bootstrapper! Error: {:?}",
                    error
                ))
            );
        };
    }
```

**File:** execution/executor/src/chunk_executor/chunk_result_verifier.rs (L37-66)
```rust
    fn verify_chunk_result(
        &self,
        parent_accumulator: &InMemoryTransactionAccumulator,
        ledger_update_output: &LedgerUpdateOutput,
    ) -> Result<()> {
        // In consensus-only mode, we cannot verify the proof against the executed output,
        // because the proof returned by the remote peer is an empty one.
        if cfg!(feature = "consensus-only-perf-test") {
            return Ok(());
        }

        THREAD_MANAGER.get_exe_cpu_pool().install(|| {
            let first_version = parent_accumulator.num_leaves();

            // Verify the chunk extends the parent accumulator.
            let parent_root_hash = parent_accumulator.root_hash();
            let num_overlap = self.txn_infos_with_proof.verify_extends_ledger(
                first_version,
                parent_root_hash,
                Some(first_version),
            )?;
            assert_eq!(num_overlap, 0, "overlapped chunks");

            // Verify transaction infos match
            ledger_update_output
                .ensure_transaction_infos_match(&self.txn_infos_with_proof.transaction_infos)?;

            Ok(())
        })
    }
```

**File:** state-sync/state-sync-driver/src/storage_synchronizer.rs (L572-586)
```rust
                Err(error) => {
                    // Send an error notification to the driver (we failed to execute/apply the chunk)
                    let error = if executed_chunk {
                        format!("Failed to execute the data chunk! Error: {:?}", error)
                    } else {
                        format!("Failed to apply the data chunk! Error: {:?}", error)
                    };
                    handle_storage_synchronizer_error(
                        notification_metadata,
                        error,
                        &error_notification_sender,
                        &pending_data_chunks,
                    )
                    .await;
                },
```

**File:** state-sync/state-sync-driver/src/storage_synchronizer.rs (L1321-1347)
```rust
async fn send_storage_synchronizer_error(
    mut error_notification_sender: mpsc::UnboundedSender<ErrorNotification>,
    notification_id: NotificationId,
    error_message: String,
) {
    // Log the storage synchronizer error
    let error_message = format!("Storage synchronizer error: {:?}", error_message);
    error!(LogSchema::new(LogEntry::StorageSynchronizer).message(&error_message));

    // Update the storage synchronizer error metrics
    let error = Error::UnexpectedError(error_message);
    metrics::increment_counter(&metrics::STORAGE_SYNCHRONIZER_ERRORS, error.get_label());

    // Send an error notification to the driver
    let error_notification = ErrorNotification {
        error: error.clone(),
        notification_id,
    };
    if let Err(error) = error_notification_sender.send(error_notification).await {
        error!(
            LogSchema::new(LogEntry::StorageSynchronizer).message(&format!(
                "Failed to send error notification! Error: {:?}",
                error
            ))
        );
    }
}
```

**File:** state-sync/data-streaming-service/src/data_stream.rs (L1383-1394)
```rust
fn extract_response_error(
    notification_feedback: &NotificationFeedback,
) -> Result<ResponseError, Error> {
    match notification_feedback {
        NotificationFeedback::InvalidPayloadData => Ok(ResponseError::InvalidData),
        NotificationFeedback::PayloadTypeIsIncorrect => Ok(ResponseError::InvalidPayloadDataType),
        NotificationFeedback::PayloadProofFailed => Ok(ResponseError::ProofVerificationError),
        _ => Err(Error::UnexpectedErrorEncountered(format!(
            "Invalid notification feedback given: {:?}",
            notification_feedback
        ))),
    }
```

**File:** state-sync/aptos-data-client/src/peer_states.rs (L35-35)
```rust
const STARTING_SCORE: f64 = 50.0;
```

**File:** state-sync/aptos-data-client/src/peer_states.rs (L39-41)
```rust
const NOT_USEFUL_MULTIPLIER: f64 = 0.95;
/// Likely to be a malicious response.
const MALICIOUS_MULTIPLIER: f64 = 0.8;
```

**File:** state-sync/aptos-data-client/src/peer_states.rs (L43-43)
```rust
const IGNORE_PEER_THRESHOLD: f64 = 25.0;
```

**File:** state-sync/aptos-data-client/src/peer_states.rs (L54-62)
```rust
impl From<ResponseError> for ErrorType {
    fn from(error: ResponseError) -> Self {
        match error {
            ResponseError::InvalidData | ResponseError::InvalidPayloadDataType => {
                ErrorType::NotUseful
            },
            ResponseError::ProofVerificationError => ErrorType::Malicious,
        }
    }
```

**File:** state-sync/state-sync-driver/src/bootstrapper.rs (L1099-1105)
```rust
                self.reset_active_stream(Some(NotificationAndFeedback::new(
                    notification_id,
                    NotificationFeedback::PayloadProofFailed,
                )))
                .await?;
                return Err(error);
            }
```

**File:** state-sync/state-sync-driver/src/bootstrapper.rs (L1303-1312)
```rust
                        self.reset_active_stream(Some(NotificationAndFeedback::new(
                            notification_id,
                            NotificationFeedback::PayloadProofFailed,
                        )))
                        .await?;
                        return Err(Error::VerificationError(format!(
                            "Transaction outputs with proof is invalid! Error: {:?}",
                            error
                        )));
                    },
```
