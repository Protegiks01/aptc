# Audit Report

## Title
Peer Isolation Failure: Malicious Peers Can Repeatedly Send Invalid Optimistic Fetches Without Being Banned

## Summary
The `remove_invalid_optimistic_fetches()` function removes invalid optimistic fetch requests without reporting malicious peers to the `RequestModerator`. This allows attackers to repeatedly submit invalid optimistic fetches without triggering the peer banning mechanism, enabling resource exhaustion attacks on storage service servers.

## Finding Description

The Aptos state synchronization system includes a `RequestModerator` component that tracks and temporarily bans peers sending too many invalid requests. However, optimistic fetch requests bypass this protection mechanism entirely.

**Vulnerable Code Flow:**

1. **Entry Point - Validation Bypass**: When an optimistic fetch request arrives, it bypasses normal validation [1](#0-0) 

2. **Direct Insertion Without Validation**: The optimistic fetch is inserted directly into the active map without calling `request_moderator.validate_request()` [2](#0-1) 

3. **Invalid Fetch Detection**: The system periodically checks optimistic fetches and identifies invalid ones (e.g., mismatched epoch and version boundaries) [3](#0-2) 

4. **Removal Without Penalty**: When invalid fetches are identified, they are simply removed from the map with only a warning log. The function does NOT call the `RequestModerator` or increment the invalid request count [4](#0-3) 

**Contrast with Normal Request Handling:**

Normal storage service requests call `validate_request()` which properly tracks invalid requests and bans peers after exceeding `max_invalid_requests_per_peer` [5](#0-4) 

The `RequestModerator` maintains an `UnhealthyPeerState` tracking system that increments counters and applies exponential backoff banning [6](#0-5) 

**Attack Scenario:**

A malicious peer can:
1. Send an optimistic fetch with deliberately mismatched `known_version` and `known_epoch` (e.g., claiming to be at version 100 epoch 5, but the epoch 5 ending ledger info is at version 150)
2. The server detects this as invalid and removes it at line 591
3. Since only one optimistic fetch per peer is allowed and the invalid one was removed, the peer immediately sends another invalid fetch
4. Repeat indefinitely without ever being banned

This bypasses the intended peer protection mechanism that would normally ban a peer after 500 invalid requests for 5 minutes with exponential backoff [7](#0-6) 

## Impact Explanation

This vulnerability falls under **Medium Severity** per Aptos bug bounty criteria due to:

1. **Resource Exhaustion**: Each invalid optimistic fetch requires:
   - Storage reads to fetch epoch ending ledger info
   - CPU cycles for validation logic
   - Map operations to insert and remove entries
   - Logging operations

2. **Service Disruption**: Legitimate peers using optimistic fetch for efficient state synchronization may experience degraded performance as server resources are consumed processing malicious requests

3. **No Direct Consensus Impact**: This does not directly affect consensus safety, fund security, or create state inconsistencies. However, it degrades the availability and performance of state synchronization services.

The impact aligns with Medium severity: "State inconsistencies requiring intervention" in the sense that operators may need to manually intervene to block malicious peers, and service quality degradation affecting node synchronization.

## Likelihood Explanation

**Likelihood: High**

1. **Low Attack Complexity**: The attack requires only sending malformed optimistic fetch requests with mismatched epoch/version pairs - no special privileges, cryptographic operations, or timing requirements

2. **No Authentication Required**: Any network peer can connect and send optimistic fetch requests

3. **Easy to Automate**: The attack can be fully automated with a simple script

4. **No Detection**: Without proper monitoring, operators may not notice the attack until performance degrades significantly

5. **Public Network Exposure**: While the banning mechanism only applies to public network peers, the vulnerability affects ALL networks since optimistic fetches bypass validation entirely

## Recommendation

Integrate invalid optimistic fetch detection with the `RequestModerator` to ensure malicious peers are properly tracked and banned.

**Recommended Fix:**

Modify `remove_invalid_optimistic_fetches()` to report invalid requests to the `RequestModerator`:

```rust
fn remove_invalid_optimistic_fetches(
    optimistic_fetches: Arc<DashMap<PeerNetworkId, OptimisticFetchRequest>>,
    peers_with_invalid_optimistic_fetches: Vec<PeerNetworkId>,
    request_moderator: Arc<RequestModerator>,  // Add this parameter
) {
    for peer_network_id in peers_with_invalid_optimistic_fetches {
        if let Some((peer_network_id, optimistic_fetch)) =
            optimistic_fetches.remove(&peer_network_id)
        {
            // Report the invalid request to the moderator
            if let Some(mut unhealthy_peer_state) = request_moderator
                .get_unhealthy_peer_states()
                .get_mut(&peer_network_id)
            {
                unhealthy_peer_state.increment_invalid_request_count(&peer_network_id);
            } else {
                // Create new unhealthy peer state and increment
                let max_invalid_requests = /* from config */;
                let min_time_to_ignore_secs = /* from config */;
                let time_service = /* from context */;
                let mut new_state = UnhealthyPeerState::new(
                    max_invalid_requests,
                    min_time_to_ignore_secs,
                    time_service,
                );
                new_state.increment_invalid_request_count(&peer_network_id);
                request_moderator.get_unhealthy_peer_states()
                    .insert(peer_network_id, new_state);
            }
            
            warn!(LogSchema::new(LogEntry::OptimisticFetchRefresh)
                .error(&Error::InvalidRequest(
                    "Mismatch between known version and epoch!".into()
                ))
                .request(&optimistic_fetch.request)
                .message(&format!(
                    "Dropping invalid optimistic fetch request for peer: {:?}!",
                    peer_network_id
                )));
        }
    }
}
```

Alternatively, add validation at the entry point in `handle_optimistic_fetch_request()` to check if the peer is currently banned before accepting the optimistic fetch.

## Proof of Concept

```rust
#[tokio::test]
async fn test_malicious_peer_invalid_optimistic_fetch_spam() {
    use aptos_config::config::StorageServiceConfig;
    use aptos_config::network_id::{NetworkId, PeerNetworkId};
    use aptos_types::PeerId;
    use std::sync::Arc;
    
    // Setup test environment
    let config = StorageServiceConfig::default();
    let peer_network_id = PeerNetworkId::new(NetworkId::Public, PeerId::random());
    let time_service = TimeService::mock();
    
    // Create storage service components
    let optimistic_fetches = Arc::new(DashMap::new());
    let request_moderator = Arc::new(RequestModerator::new(
        /* ... config ... */
    ));
    
    // Simulate 1000 invalid optimistic fetch requests
    for i in 0..1000 {
        // Create invalid optimistic fetch with mismatched epoch/version
        let request = StorageServiceRequest::new(
            DataRequest::GetNewTransactionsWithProof(
                NewTransactionsWithProofRequest {
                    known_version: 100,
                    known_epoch: 5,
                    include_events: false,
                }
            ),
            false,
        );
        
        // Insert optimistic fetch (simulating handler.rs:259)
        let (response_sender, _) = oneshot::channel();
        let optimistic_fetch = OptimisticFetchRequest::new(
            request.clone(),
            response_sender,
            time_service.clone(),
        );
        optimistic_fetches.insert(peer_network_id, optimistic_fetch);
        
        // Simulate invalid fetch detection and removal (simulating optimistic_fetch.rs:591)
        let peers_with_invalid = vec![peer_network_id];
        remove_invalid_optimistic_fetches(
            optimistic_fetches.clone(),
            peers_with_invalid,
        );
        
        // Verify peer can immediately submit another request
        assert!(optimistic_fetches.get(&peer_network_id).is_none());
        
        // Check if peer was banned (should be banned after ~500, but won't be due to bug)
        let unhealthy_states = request_moderator.get_unhealthy_peer_states();
        if i > 500 {
            // After 500 invalid requests, peer SHOULD be banned
            // But due to the bug, unhealthy_states will be empty
            assert!(
                unhealthy_states.get(&peer_network_id).is_none(),
                "BUG: Peer was never tracked in unhealthy states despite {} invalid requests",
                i
            );
        }
    }
    
    // Verify the peer was NEVER banned despite 1000 invalid requests
    let unhealthy_states = request_moderator.get_unhealthy_peer_states();
    assert!(
        unhealthy_states.get(&peer_network_id).is_none(),
        "Critical vulnerability: Peer sent 1000 invalid optimistic fetches but was never banned"
    );
}
```

This PoC demonstrates that a peer can send unlimited invalid optimistic fetch requests without triggering the peer banning mechanism that would normally activate after 500 invalid requests.

### Citations

**File:** state-sync/storage-service/server/src/handler.rs (L119-123)
```rust
        // Handle any optimistic fetch requests
        if request.data_request.is_optimistic_fetch() {
            self.handle_optimistic_fetch_request(peer_network_id, request, response_sender);
            return;
        }
```

**File:** state-sync/storage-service/server/src/handler.rs (L211-213)
```rust
        // Validate the request with the moderator
        self.request_moderator
            .validate_request(peer_network_id, request)?;
```

**File:** state-sync/storage-service/server/src/handler.rs (L256-259)
```rust
        // Store the optimistic fetch and check if any existing fetches were found
        if self
            .optimistic_fetches
            .insert(peer_network_id, optimistic_fetch)
```

**File:** state-sync/storage-service/server/src/optimistic_fetch.rs (L531-541)
```rust
                    // Check that we haven't been sent an invalid optimistic fetch request
                    // (i.e., a request that does not respect an epoch boundary).
                    if epoch_ending_ledger_info.ledger_info().version() <= highest_known_version {
                        peers_with_invalid_optimistic_fetches
                            .lock()
                            .push(peer_network_id);
                    } else {
                        peers_with_ready_optimistic_fetches
                            .lock()
                            .push((peer_network_id, epoch_ending_ledger_info));
                    }
```

**File:** state-sync/storage-service/server/src/optimistic_fetch.rs (L586-605)
```rust
fn remove_invalid_optimistic_fetches(
    optimistic_fetches: Arc<DashMap<PeerNetworkId, OptimisticFetchRequest>>,
    peers_with_invalid_optimistic_fetches: Vec<PeerNetworkId>,
) {
    for peer_network_id in peers_with_invalid_optimistic_fetches {
        if let Some((peer_network_id, optimistic_fetch)) =
            optimistic_fetches.remove(&peer_network_id)
        {
            warn!(LogSchema::new(LogEntry::OptimisticFetchRefresh)
                .error(&Error::InvalidRequest(
                    "Mismatch between known version and epoch!".into()
                ))
                .request(&optimistic_fetch.request)
                .message(&format!(
                    "Dropping invalid optimistic fetch request for peer: {:?}!",
                    peer_network_id
                )));
        }
    }
}
```

**File:** state-sync/storage-service/server/src/moderator.rs (L50-69)
```rust
    pub fn increment_invalid_request_count(&mut self, peer_network_id: &PeerNetworkId) {
        // Increment the invalid request count
        self.invalid_request_count += 1;

        // If the peer is a PFN and has sent too many invalid requests, start ignoring it
        if self.ignore_start_time.is_none()
            && peer_network_id.network_id().is_public_network()
            && self.invalid_request_count >= self.max_invalid_requests
        {
            // TODO: at some point we'll want to terminate the connection entirely

            // Start ignoring the peer
            self.ignore_start_time = Some(self.time_service.now());

            // Log the fact that we're now ignoring the peer
            warn!(LogSchema::new(LogEntry::RequestModeratorIgnoredPeer)
                .peer_network_id(peer_network_id)
                .message("Ignoring peer due to too many invalid requests!"));
        }
    }
```

**File:** config/src/config/state_sync_config.rs (L201-213)
```rust
            max_invalid_requests_per_peer: 500,
            max_lru_cache_size: 500, // At ~0.6MiB per chunk, this should take no more than 0.5GiB
            max_network_channel_size: 4000,
            max_network_chunk_bytes: SERVER_MAX_MESSAGE_SIZE as u64,
            max_network_chunk_bytes_v2: SERVER_MAX_MESSAGE_SIZE_V2 as u64,
            max_num_active_subscriptions: 30,
            max_optimistic_fetch_period_ms: 5000, // 5 seconds
            max_state_chunk_size: MAX_STATE_CHUNK_SIZE,
            max_storage_read_wait_time_ms: 10_000, // 10 seconds
            max_subscription_period_ms: 30_000,    // 30 seconds
            max_transaction_chunk_size: MAX_TRANSACTION_CHUNK_SIZE,
            max_transaction_output_chunk_size: MAX_TRANSACTION_OUTPUT_CHUNK_SIZE,
            min_time_to_ignore_peers_secs: 300, // 5 minutes
```
