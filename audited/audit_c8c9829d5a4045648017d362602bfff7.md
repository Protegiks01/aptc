# Audit Report

## Title
Race Condition in Order Vote Creation Due to Interior Mutability in PipelinedBlock Causes Consensus Liveness Failures

## Summary
The `PipelinedBlock` struct uses interior mutability (`Mutex<StateComputeResult>`) which allows the execution state to be modified after the block is shared. This creates a race condition where order votes can be rejected based on execution timing, as the safety rules validation uses strict equality instead of the appropriate `match_ordered_only()` method when comparing `BlockInfo` in decoupled execution contexts.

## Finding Description

The vulnerability stems from an inconsistency in how `BlockInfo` comparison is performed during order vote validation.

**Interior Mutability Architecture:**

The `PipelinedBlock` struct contains `state_compute_result: Mutex<StateComputeResult>` [1](#0-0) , which is initialized with dummy execution state using `ACCUMULATOR_PLACEHOLDER_HASH` [2](#0-1) . After asynchronous execution completes, `set_compute_result()` updates this mutable state [3](#0-2) .

**Decoupled Execution Flow:**

In decoupled execution mode, validators create votes with dummy execution state. The `VoteProposal::gen_vote_data()` method returns `vote_data_ordering_only()` which uses `ACCUMULATOR_PLACEHOLDER_HASH` and version 0 [4](#0-3) . These votes are aggregated into a QuorumCert, whose `certified_block()` method returns this dummy `BlockInfo` [5](#0-4) .

**The Race Condition:**

When `broadcast_order_vote()` is triggered after QC formation [6](#0-5) , it calls `block.order_vote_proposal(qc)` [7](#0-6) . This method calls `self.block_info()` which reads the **current** state from the mutex by calling `compute_result()` [8](#0-7)  and [9](#0-8) .

Meanwhile, execution completes asynchronously and calls `set_compute_result()` to update the mutex [10](#0-9) .

**The Validation Bug:**

The safety rules perform validation using strict equality: `if qc.certified_block() != order_vote_proposal.block_info()` [11](#0-10) . This uses the derived `PartialEq` on `BlockInfo` which compares ALL fields including `executed_state_id` and `version` [12](#0-11) .

**The Inconsistency:**

The codebase provides `match_ordered_only()` specifically for comparing `BlockInfo` in decoupled execution contexts, which ignores execution-related fields [13](#0-12) . This method is correctly used elsewhere in the codebase:
- In commit vote validation [14](#0-13) 
- When merging QCs with executed state [15](#0-14) 
- In buffer item comparisons [16](#0-15) 

**Attack Scenario:**

1. Block B proposed with dummy state
2. Validators vote with dummy `BlockInfo` (ACCUMULATOR_PLACEHOLDER_HASH, version 0)
3. QC formed containing this dummy `BlockInfo`
4. Execution completes asynchronously at varying times across validators
5. Fast validators: execution updates mutex before order vote creation → `block_info()` returns real values → safety check fails (dummy ≠ real) → order vote rejected
6. Slow validators: execution incomplete during order vote creation → `block_info()` returns dummy values → safety check succeeds (dummy == dummy) → order vote succeeds

This causes non-deterministic validator behavior where faster hardware/execution leads to order vote rejection, while slower validators succeed. If >1/3 of validators experience fast execution timing, order vote quorum cannot be achieved [17](#0-16) .

## Impact Explanation

This vulnerability falls under **High Severity** ($50,000 tier) as "Validator Node Slowdowns" or "Limited Protocol Violations" in the Aptos bug bounty program:

1. **Non-Deterministic Validator Behavior**: Validators with identical inputs produce different outcomes based on execution timing, violating the deterministic execution invariant

2. **Consensus Liveness Degradation**: When >1/3 of validators fail to create order votes due to this race, the protocol cannot achieve ordering quorum, causing liveness issues

3. **Performance Impact**: Even below the 1/3 threshold, failed order votes reduce the effectiveness of the optimistic responsiveness feature

While not a total network halt (Critical severity), this represents a significant protocol violation that affects consensus liveness under normal operating conditions.

## Likelihood Explanation

**Likelihood: Medium-High**

This occurs naturally in production:
- **No attacker required**: Race condition triggers during normal operation with order votes enabled
- **Environmental factors**: Network latency, CPU performance, disk I/O, and hardware differences naturally cause execution timing variations across validators
- **Counterintuitive failure mode**: Faster, better-provisioned validators fail while slower validators succeed

The likelihood of >1/3 validators experiencing this simultaneously depends on network composition, but the bug manifests as sporadic failures even below this threshold.

## Recommendation

Replace the strict equality check with `match_ordered_only()` in the order vote validation:

```rust
// In consensus/safety-rules/src/safety_rules.rs line 97
// Change from:
if qc.certified_block() != order_vote_proposal.block_info() {

// To:
if !qc.certified_block().match_ordered_only(order_vote_proposal.block_info()) {
```

This makes the order vote validation consistent with other decoupled execution comparisons in the codebase (safety_rules.rs:397, quorum_cert.rs:157, buffer_item.rs:277), correctly ignoring execution-related fields (`executed_state_id`, `version`) that change asynchronously.

## Proof of Concept

The existing test suite demonstrates this inconsistency. Tests in `consensus/safety-rules/src/tests/suite.rs` manually construct `OrderVoteProposal` using `qc.certified_block()` directly rather than calling `block.order_vote_proposal()`, which bypasses the race condition. A proper test would need to:

1. Create a block with decoupled execution enabled
2. Allow execution to complete and update the mutex via `set_compute_result()`
3. Form a QC from votes created before execution completion
4. Call `block.order_vote_proposal(qc)` 
5. Observe that safety rules reject it due to the `BlockInfo` mismatch

The vulnerability is confirmed through code analysis showing the logical inconsistency in comparison methods across the codebase.

### Citations

**File:** consensus/consensus-types/src/pipelined_block.rs (L208-208)
```rust
    state_compute_result: Mutex<StateComputeResult>,
```

**File:** consensus/consensus-types/src/pipelined_block.rs (L277-330)
```rust
    pub fn set_compute_result(
        &self,
        state_compute_result: StateComputeResult,
        execution_time: Duration,
    ) {
        let mut to_commit = 0;
        let mut to_retry = 0;
        for txn in state_compute_result.compute_status_for_input_txns() {
            match txn {
                TransactionStatus::Keep(_) => to_commit += 1,
                TransactionStatus::Retry => to_retry += 1,
                _ => {},
            }
        }

        let execution_summary = ExecutionSummary {
            payload_len: self
                .block
                .payload()
                .map_or(0, |payload| payload.len_for_execution()),
            to_commit,
            to_retry,
            execution_time,
            root_hash: state_compute_result.root_hash(),
            gas_used: state_compute_result
                .execution_output
                .block_end_info
                .as_ref()
                .map(|info| info.block_effective_gas_units()),
        };
        *self.state_compute_result.lock() = state_compute_result;

        // We might be retrying execution, so it might have already been set.
        // Because we use this for statistics, it's ok that we drop the newer value.
        if let Some(previous) = self.execution_summary.get() {
            if previous.root_hash == execution_summary.root_hash
                || previous.root_hash == *ACCUMULATOR_PLACEHOLDER_HASH
            {
                warn!(
                    "Skipping re-inserting execution result, from {:?} to {:?}",
                    previous, execution_summary
                );
            } else {
                error!(
                    "Re-inserting execution result with different root hash: from {:?} to {:?}",
                    previous, execution_summary
                );
            }
        } else {
            self.execution_summary
                .set(execution_summary)
                .expect("inserting into empty execution summary");
        }
    }
```

**File:** consensus/consensus-types/src/pipelined_block.rs (L396-396)
```rust
        let state_compute_result = StateComputeResult::new_dummy();
```

**File:** consensus/consensus-types/src/pipelined_block.rs (L440-442)
```rust
    pub fn compute_result(&self) -> StateComputeResult {
        self.state_compute_result.lock().clone()
    }
```

**File:** consensus/consensus-types/src/pipelined_block.rs (L452-459)
```rust
    pub fn block_info(&self) -> BlockInfo {
        let compute_result = self.compute_result();
        self.block().gen_block_info(
            compute_result.root_hash(),
            compute_result.last_version_or_0(),
            compute_result.epoch_state().clone(),
        )
    }
```

**File:** consensus/consensus-types/src/pipelined_block.rs (L471-473)
```rust
    pub fn order_vote_proposal(&self, quorum_cert: Arc<QuorumCert>) -> OrderVoteProposal {
        OrderVoteProposal::new(self.block.clone(), self.block_info(), quorum_cert)
    }
```

**File:** consensus/consensus-types/src/vote_proposal.rs (L59-69)
```rust
    /// This function returns the vote data with a dummy executed_state_id and version
    fn vote_data_ordering_only(&self) -> VoteData {
        VoteData::new(
            self.block().gen_block_info(
                *ACCUMULATOR_PLACEHOLDER_HASH,
                0,
                self.next_epoch_state().cloned(),
            ),
            self.block().quorum_cert().certified_block().clone(),
        )
    }
```

**File:** consensus/consensus-types/src/quorum_cert.rs (L58-60)
```rust
    pub fn certified_block(&self) -> &BlockInfo {
        self.vote_data().proposed()
    }
```

**File:** consensus/consensus-types/src/quorum_cert.rs (L156-158)
```rust
        ensure!(
            self_commit_info.match_ordered_only(executed_commit_info),
            "Block info from QC and executed LI need to match, {:?} and {:?}",
```

**File:** consensus/src/round_manager.rs (L1653-1662)
```rust
    async fn broadcast_order_vote(
        &mut self,
        vote: &Vote,
        qc: Arc<QuorumCert>,
    ) -> anyhow::Result<()> {
        if let Some(proposed_block) = self.block_store.get_block(vote.vote_data().proposed().id()) {
            // Generate an order vote with ledger_info = proposed_block
            let order_vote = self
                .create_order_vote(proposed_block.clone(), qc.clone())
                .await?;
```

**File:** consensus/src/pipeline/execution_schedule_phase.rs (L70-76)
```rust
        let fut = async move {
            for b in ordered_blocks.iter_mut() {
                let (compute_result, execution_time) = b.wait_for_compute_result().await?;
                b.set_compute_result(compute_result, execution_time);
            }
            Ok(ordered_blocks)
        }
```

**File:** consensus/safety-rules/src/safety_rules.rs (L97-97)
```rust
        if qc.certified_block() != order_vote_proposal.block_info() {
```

**File:** consensus/safety-rules/src/safety_rules.rs (L395-398)
```rust
        if !old_ledger_info
            .commit_info()
            .match_ordered_only(new_ledger_info.commit_info())
        {
```

**File:** types/src/block_info.rs (L27-27)
```rust
#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
```

**File:** types/src/block_info.rs (L196-204)
```rust
    pub fn match_ordered_only(&self, executed_block_info: &BlockInfo) -> bool {
        self.epoch == executed_block_info.epoch
            && self.round == executed_block_info.round
            && self.id == executed_block_info.id
            && (self.timestamp_usecs == executed_block_info.timestamp_usecs
            // executed block info has changed its timestamp because it's a reconfiguration suffix
                || (self.timestamp_usecs > executed_block_info.timestamp_usecs
                    && executed_block_info.has_reconfiguration()))
    }
```

**File:** consensus/src/pipeline/buffer_item.rs (L274-277)
```rust
                assert!(ordered
                    .ordered_proof
                    .commit_info()
                    .match_ordered_only(commit_proof.commit_info()));
```

**File:** consensus/src/pending_order_votes.rs (L113-118)
```rust
                match sig_aggregator.check_voting_power(validator_verifier, true) {
                    Ok(aggregated_voting_power) => {
                        assert!(
                            aggregated_voting_power >= validator_verifier.quorum_voting_power(),
                            "QC aggregation should not be triggered if we don't have enough votes to form a QC"
                        );
```
