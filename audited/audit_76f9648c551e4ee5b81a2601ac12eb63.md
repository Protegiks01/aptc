# Audit Report

## Title
StateKey Tag Validation Missing in Database Decode Path Allows Corrupted Data Propagation

## Summary
The `StateKey::decode()` function in the storage layer does not validate that the decoded StateKeyInner variant matches the tag byte read from the database. When database corruption occurs, mismatched tags cause the system to silently create incorrect StateKey objects with wrong variants (e.g., interpreting AccessPath data as TableItem), breaking the fundamental invariant that StateKey uniquely identifies StateValue.

## Finding Description

The vulnerability exists in the StateKey decoding mechanism used when reading from AptosDB. The system stores StateKeys in the database with a tag byte indicating the variant type (AccessPath=0x00, TableItem=0x01, Raw=0xFF), followed by the serialized data. [1](#0-0) 

When decoding, the `StateKey::decode()` function reads the tag byte and blindly trusts it to determine how to interpret the remaining bytes: [2](#0-1) 

**The Critical Flaw:** The function performs NO validation that the decoded data structure actually matches the tag. For example:
- If tag byte is `0x01` (TableItem) but data is actually AccessPath structure
- The function extracts HANDLE_SIZE bytes and interprets them as TableHandle
- Since TableHandle is just a wrapper around AccountAddress, AccessPath address bytes successfully deserialize
- Remaining path bytes are interpreted as table item key
- Result: A completely wrong TableItem StateKey is created without any error [3](#0-2) 

**Propagation Path:**

The corrupted StateKey is then used throughout the system:

1. **Database Iteration:** `PrefixedStateValueIterator` decodes StateKeys during iteration: [4](#0-3) 

2. **API Exposure:** The API server returns wrong StateKey-StateValue associations to clients: [5](#0-4) 

3. **State Integrity Validation:** Validation tools use the decoded StateKey's hash, which is computed from the wrong StateKeyInner: [6](#0-5) 

**Broken Invariant:** The system violates **"State Consistency: State transitions must be atomic and verifiable via Merkle proofs"** because StateKey-StateValue associations become corrupted, making state unverifiable.

## Impact Explanation

**Severity: HIGH** (State inconsistencies requiring intervention)

When database corruption causes tag byte mismatches:
- API queries return wrong StateKey-StateValue mappings to clients
- State sync mechanisms may propagate incorrect associations between nodes
- Database validation tools compute wrong hashes and fail to detect actual corruption
- Different nodes with different corruption patterns could diverge in state interpretation

This does not directly cause consensus breaks during normal execution (VM constructs StateKeys directly), but creates **data integrity violations** that could lead to:
- Inconsistent API responses across nodes
- State sync failures requiring manual intervention
- Silent data corruption propagation during database recovery operations

## Likelihood Explanation

**Likelihood: Medium**

Database corruption can occur through:
- Hardware failures (disk bit flips, memory errors)
- Software bugs in the write path (e.g., race conditions, buffer overruns)
- Database migration/upgrade bugs
- Interrupted write operations during crashes

However, this is NOT directly exploitable by unprivileged attackers as it requires existing database corruption. The vulnerability represents a **failure to detect and handle corrupted data safely** rather than a directly exploitable attack vector.

## Recommendation

Add post-decode validation to ensure the decoded StateKeyInner variant matches the tag byte:

```rust
pub fn decode(val: &[u8]) -> Result<StateKey, StateKeyDecodeErr> {
    // ... existing decode logic ...
    
    // VALIDATION: Re-encode and verify tag byte matches
    let decoded_encoded = myself.encoded();
    if !decoded_encoded.is_empty() && decoded_encoded[0] != tag {
        return Err(StateKeyDecodeErr::TagMismatch {
            expected_tag: tag,
            actual_tag: decoded_encoded[0],
        });
    }
    
    Ok(myself)
}
```

Add new error variant:
```rust
#[derive(Debug, Error)]
pub enum StateKeyDecodeErr {
    // ... existing variants ...
    
    #[error("Tag mismatch after decode: expected {expected_tag}, got {actual_tag}")]
    TagMismatch { expected_tag: u8, actual_tag: u8 },
}
```

This ensures database corruption is detected immediately rather than silently propagating wrong data.

## Proof of Concept

```rust
#[test]
fn test_corrupted_tag_detection() {
    use aptos_types::state_store::state_key::{StateKey, inner::StateKeyTag};
    use move_core_types::account_address::AccountAddress;
    
    // Create a valid AccessPath StateKey
    let address = AccountAddress::from_hex_literal("0x1").unwrap();
    let state_key = StateKey::resource_typed::<AccountResource>(&address).unwrap();
    let encoded = state_key.encoded().to_vec();
    
    // Corrupt: Change tag from AccessPath (0x00) to TableItem (0x01)
    let mut corrupted = encoded.clone();
    corrupted[0] = StateKeyTag::TableItem as u8;
    
    // Attempt to decode corrupted data
    let decoded_result = StateKey::decode(&corrupted);
    
    // Currently: This may succeed and create wrong StateKey
    // After fix: Should return TagMismatch error
    match decoded_result {
        Ok(decoded_key) => {
            // Verify that decoded key is different from original
            assert_ne!(decoded_key.encoded().as_ref(), encoded.as_slice(),
                      "Corrupted tag created different StateKey - vulnerability confirmed");
        },
        Err(e) => {
            // After fix: Should get TagMismatch error here
            println!("Correctly detected corruption: {:?}", e);
        }
    }
}
```

## Notes

This vulnerability requires **pre-existing database corruption** and is therefore not directly exploitable by unprivileged attackers. It represents a **defensive programming weakness** where the system fails to detect and handle corrupted data safely, potentially propagating corruption through API responses, state validation, and sync operations. While it meets HIGH severity for state inconsistencies, it does NOT meet the bug bounty criterion of being "exploitable by unprivileged attacker" since database corruption itself cannot be triggered without privileged access or hardware/software faults.

### Citations

**File:** types/src/state_store/state_key/inner.rs (L16-22)
```rust
#[repr(u8)]
#[derive(Clone, Debug, FromPrimitive, ToPrimitive)]
pub enum StateKeyTag {
    AccessPath,
    TableItem,
    Raw = 255,
}
```

**File:** types/src/state_store/state_key/mod.rs (L62-95)
```rust
    pub fn decode(val: &[u8]) -> Result<StateKey, StateKeyDecodeErr> {
        use access_path::Path;

        if val.is_empty() {
            return Err(StateKeyDecodeErr::EmptyInput);
        }
        let tag = val[0];
        let state_key_tag =
            StateKeyTag::from_u8(tag).ok_or(StateKeyDecodeErr::UnknownTag { unknown_tag: tag })?;
        let myself = match state_key_tag {
            StateKeyTag::AccessPath => {
                let AccessPath { address, path } = bcs::from_bytes(&val[1..])?;
                let path: Path = bcs::from_bytes(&path)?;
                match path {
                    Path::Code(ModuleId { address, name }) => Self::module(&address, &name),
                    Path::Resource(struct_tag) => Self::resource(&address, &struct_tag)?,
                    Path::ResourceGroup(struct_tag) => Self::resource_group(&address, &struct_tag),
                }
            },
            StateKeyTag::TableItem => {
                const HANDLE_SIZE: usize = std::mem::size_of::<TableHandle>();
                if val.len() < 1 + HANDLE_SIZE {
                    return Err(StateKeyDecodeErr::NotEnoughBytes {
                        tag,
                        num_bytes: val.len(),
                    });
                }
                let handle = bcs::from_bytes(&val[1..1 + HANDLE_SIZE])?;
                Self::table_item(&handle, &val[1 + HANDLE_SIZE..])
            },
            StateKeyTag::Raw => Self::raw(&val[1..]),
        };
        Ok(myself)
    }
```

**File:** types/src/state_store/table.rs (L11-13)
```rust
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
#[cfg_attr(any(test, feature = "fuzzing"), derive(proptest_derive::Arbitrary))]
pub struct TableHandle(pub AccountAddress);
```

**File:** storage/aptosdb/src/utils/iterators.rs (L148-179)
```rust
    fn next_by_kv(&mut self) -> Result<Option<(StateKey, StateValue)>> {
        let iter = self.kv_iter.as_mut().unwrap();
        if !self.is_finished {
            while let Some(((state_key, version), state_value_opt)) = iter.next().transpose()? {
                // In case the previous seek() ends on the same key with version 0.
                if Some(&state_key) == self.prev_key.as_ref() {
                    continue;
                }
                // Cursor is currently at the first available version of the state key.
                // Check if the key_prefix is a valid prefix of the state_key we got from DB.
                if !self.key_prefix.is_prefix(&state_key)? {
                    // No more keys matching the key_prefix, we can return the result.
                    self.is_finished = true;
                    break;
                }

                if version > self.desired_version {
                    iter.seek(&(state_key.clone(), self.desired_version))?;
                    continue;
                }

                self.prev_key = Some(state_key.clone());
                // Seek to the next key - this can be done by seeking to the current key with version 0
                iter.seek(&(state_key.clone(), 0))?;

                if let Some(state_value) = state_value_opt {
                    return Ok(Some((state_key, state_value)));
                }
            }
        }
        Ok(None)
    }
```

**File:** api/src/context.rs (L440-467)
```rust
        address: AccountAddress,
        version: u64,
    ) -> Result<HashMap<StateKey, StateValue>> {
        let mut iter = if !db_sharding_enabled(&self.node_config) {
            Box::new(
                self.db
                    .get_prefixed_state_value_iterator(
                        &StateKeyPrefix::from(address),
                        None,
                        version,
                    )?
                    .map(|item| item.map_err(|err| anyhow!(err.to_string()))),
            )
        } else {
            self.indexer_reader
                .as_ref()
                .ok_or_else(|| format_err!("Indexer reader doesn't exist"))?
                .get_prefixed_state_value_iterator(&StateKeyPrefix::from(address), None, version)?
        };

        let kvs = iter
            .by_ref()
            .take(MAX_REQUEST_LIMIT as usize)
            .collect::<Result<_>>()?;
        if iter.next().transpose()?.is_some() {
            bail!("Too many state items under account ({:?}).", address);
        }
        Ok(kvs)
```

**File:** storage/aptosdb/src/db_debugger/validation.rs (L128-131)
```rust
    for (key_ind, state_key_res) in iter.enumerate() {
        let state_key = state_key_res?.0;
        let state_key_hash = state_key.hash();
        all_internal_keys.insert(state_key_hash);
```
