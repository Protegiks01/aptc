# Audit Report

## Title
Database Sharding Mode Mismatch Causes Consensus Divergence and State Loss

## Summary
The LedgerDb lacks validation to ensure the database sharding configuration matches the persisted database format. When a node's `enable_storage_sharding` configuration changes between restarts, it opens different database paths without migration, causing validators to operate on inconsistent ledger states and leading to consensus safety violations.

## Finding Description

The `LedgerDb::new()` function opens databases at different filesystem paths depending on the `enable_storage_sharding` configuration flag, but provides no validation that the existing database format matches the current configuration. [1](#0-0) 

When sharding is **disabled**, all ledger data is stored in a single RocksDB instance at `{db_root}/ledger_db`. When sharding is **enabled**, the system splits data across multiple databases: metadata at `{db_root}/ledger_db/metadata`, and separate databases for events, transactions, etc. in `{db_root}/ledger_db/{event_db, transaction_db, ...}`. [2](#0-1) 

RocksDB is configured to automatically create missing databases and column families: [3](#0-2) 

There is no `DbMetadataKey` variant to store or validate the sharding mode: [4](#0-3) 

A TODO comment acknowledges this data inconsistency risk but no validation is implemented: [5](#0-4) 

**Attack Scenario:**

1. Validator runs with `enable_storage_sharding: false`, accumulating ledger data at `{db_root}/ledger_db`
2. Configuration changes to `enable_storage_sharding: true` (accidental during migration or malicious)
3. Node restarts and opens databases at NEW paths: `{db_root}/ledger_db/metadata`, `{db_root}/ledger_db/event_db`, etc.
4. RocksDB creates empty databases at these new locations
5. Validator operates with an empty/inconsistent ledger state, producing different state roots
6. If multiple validators have mismatched configurations, consensus divergence occurs

**Invariant Violations:**
- **Deterministic Execution**: Different validators produce different state roots for identical blocks
- **State Consistency**: Ledger state becomes inconsistent across the network
- **Consensus Safety**: Network can experience safety violations with validators on different database formats

## Impact Explanation

This vulnerability qualifies as **Critical Severity** under the Aptos bug bounty program criteria:

- **Consensus/Safety violations**: Validators with different sharding configurations will produce different state roots, violating the fundamental consensus invariant that all honest validators must agree on state
- **Non-recoverable network partition**: If a significant portion of validators accidentally or maliciously switch sharding modes, the network splits into incompatible states requiring manual intervention or hardfork
- **State inconsistency**: Existing ledger data becomes inaccessible but not actually lost, creating a phantom data loss scenario

While the mainnet/testnet configuration enforces sharding via panic: [6](#0-5) 

This only prevents *disabling* sharding on mainnet/testnet if the config file doesn't explicitly set it. It does NOT:
- Validate existing database format matches configuration
- Prevent initial setup with wrong mode
- Protect devnet or custom networks
- Prevent malicious configuration changes

## Likelihood Explanation

**Likelihood: Medium-High**

This vulnerability can manifest through:

1. **Accidental misconfiguration**: During database migration following AIP-97, operators may restart nodes with incorrect configuration before proper migration
2. **Configuration management errors**: Automated configuration deployment systems may apply wrong settings
3. **Malicious insider**: An attacker with access to validator configuration files can force state divergence
4. **Development/testing spillover**: Nodes initially configured for testing with sharding disabled may be reconfigured for production

The presence of TODOs and the explicit panic message for mainnet/testnet indicates this is an active migration concern, increasing likelihood of misconfiguration during the transition period.

## Recommendation

Implement database format validation on startup:

1. **Add sharding mode marker to database metadata**:
   - Store `enable_storage_sharding` flag in `DbMetadataSchema` when database is created
   - Check this marker on every startup and fail if mismatch detected

2. **Implement validation in `LedgerDb::new()`**:
   - Before opening databases, check if expected paths exist
   - If sharding enabled but non-sharded DB exists (or vice versa), return error with migration instructions
   - Require explicit migration tool instead of automatic path switching

3. **Provide migration utility**:
   - Create explicit migration tool to safely convert between sharding modes
   - Require operators to use this tool rather than just changing configuration

Example fix structure:

```rust
pub(crate) fn new<P: AsRef<Path>>(
    db_root_path: P,
    rocksdb_configs: RocksdbConfigs,
    env: Option<&Env>,
    block_cache: Option<&Cache>,
    readonly: bool,
) -> Result<Self> {
    let sharding = rocksdb_configs.enable_storage_sharding;
    
    // NEW: Validate database format matches configuration
    Self::validate_sharding_mode(&db_root_path, sharding)?;
    
    // ... rest of existing code
}

fn validate_sharding_mode<P: AsRef<Path>>(
    db_root_path: P, 
    expected_sharding: bool
) -> Result<()> {
    // Check for persisted sharding mode marker
    // If exists and doesn't match expected_sharding, return error
    // If doesn't exist, this is a new database, store marker
}
```

## Proof of Concept

**Reproduction Steps:**

1. Start Aptos node with configuration:
```yaml
storage:
  rocksdb_configs:
    enable_storage_sharding: false
```

2. Let node sync some blocks (or start from genesis)

3. Verify ledger data exists at `{db_path}/ledger_db/`

4. Stop node and change configuration to:
```yaml
storage:
  rocksdb_configs:
    enable_storage_sharding: true
```

5. Restart node

6. Observe:
   - Node starts successfully (no error)
   - New empty databases created at `{db_path}/ledger_db/metadata`, `{db_path}/ledger_db/event_db/`, etc.
   - Node reports version 0 or genesis state
   - Original data at `{db_path}/ledger_db/` is inaccessible but still exists
   - Node produces different state roots than validators with correct configuration

**Expected Behavior:** Node should fail to start with error message: "Database sharding mode mismatch detected. Current config: sharding=true, Database format: sharding=false. Use migration tool to convert database format."

**Notes**

The TODOs at lines 394 and 436 indicate these helper functions (`metadata_db_arc()` and `transaction_db_raw()`) are planned for removal after sharding migration completes. However, the core vulnerability is not in these functions themselves, but in the lack of validation when the sharding mode changes between restarts. The incomplete migration infrastructure creates a window for database format mismatches that can compromise consensus integrity.

### Citations

**File:** storage/aptosdb/src/ledger_db/mod.rs (L122-172)
```rust
    pub(crate) fn new<P: AsRef<Path>>(
        db_root_path: P,
        rocksdb_configs: RocksdbConfigs,
        env: Option<&Env>,
        block_cache: Option<&Cache>,
        readonly: bool,
    ) -> Result<Self> {
        let sharding = rocksdb_configs.enable_storage_sharding;
        let ledger_metadata_db_path = Self::metadata_db_path(db_root_path.as_ref(), sharding);
        let ledger_metadata_db = Arc::new(Self::open_rocksdb(
            ledger_metadata_db_path.clone(),
            if sharding {
                LEDGER_METADATA_DB_NAME
            } else {
                LEDGER_DB_NAME
            },
            &rocksdb_configs.ledger_db_config,
            env,
            block_cache,
            readonly,
        )?);

        info!(
            ledger_metadata_db_path = ledger_metadata_db_path,
            sharding = sharding,
            "Opened ledger metadata db!"
        );

        if !sharding {
            info!("Individual ledger dbs are not enabled!");
            return Ok(Self {
                ledger_metadata_db: LedgerMetadataDb::new(Arc::clone(&ledger_metadata_db)),
                event_db: EventDb::new(
                    Arc::clone(&ledger_metadata_db),
                    EventStore::new(Arc::clone(&ledger_metadata_db)),
                ),
                persisted_auxiliary_info_db: PersistedAuxiliaryInfoDb::new(Arc::clone(
                    &ledger_metadata_db,
                )),
                transaction_accumulator_db: TransactionAccumulatorDb::new(Arc::clone(
                    &ledger_metadata_db,
                )),
                transaction_auxiliary_data_db: TransactionAuxiliaryDataDb::new(Arc::clone(
                    &ledger_metadata_db,
                )),
                transaction_db: TransactionDb::new(Arc::clone(&ledger_metadata_db)),
                transaction_info_db: TransactionInfoDb::new(Arc::clone(&ledger_metadata_db)),
                write_set_db: WriteSetDb::new(Arc::clone(&ledger_metadata_db)),
                enable_storage_sharding: false,
            });
        }
```

**File:** storage/aptosdb/src/ledger_db/mod.rs (L281-281)
```rust
        // TODO(grao): Handle data inconsistency.
```

**File:** storage/aptosdb/src/ledger_db/mod.rs (L522-529)
```rust
    fn metadata_db_path<P: AsRef<Path>>(db_root_path: P, sharding: bool) -> PathBuf {
        let ledger_db_folder = db_root_path.as_ref().join(LEDGER_DB_FOLDER_NAME);
        if sharding {
            ledger_db_folder.join("metadata")
        } else {
            ledger_db_folder
        }
    }
```

**File:** storage/rocksdb-options/src/lib.rs (L38-41)
```rust
    if !readonly {
        db_opts.create_if_missing(true);
        db_opts.create_missing_column_families(true);
    }
```

**File:** storage/aptosdb/src/schema/db_metadata/mod.rs (L49-72)
```rust
pub enum DbMetadataKey {
    LedgerPrunerProgress,
    StateMerklePrunerProgress,
    EpochEndingStateMerklePrunerProgress,
    StateKvPrunerProgress,
    StateSnapshotKvRestoreProgress(Version),
    LedgerCommitProgress,
    StateKvCommitProgress,
    OverallCommitProgress,
    StateKvShardCommitProgress(ShardId),
    StateMerkleCommitProgress,
    StateMerkleShardCommitProgress(ShardId),
    EventPrunerProgress,
    TransactionAccumulatorPrunerProgress,
    TransactionInfoPrunerProgress,
    TransactionPrunerProgress,
    WriteSetPrunerProgress,
    StateMerkleShardPrunerProgress(ShardId),
    EpochEndingStateMerkleShardPrunerProgress(ShardId),
    StateKvShardPrunerProgress(ShardId),
    StateMerkleShardRestoreProgress(ShardId, Version),
    TransactionAuxiliaryDataPrunerProgress,
    PersistedAuxiliaryInfoPrunerProgress,
}
```

**File:** config/src/config/storage_config.rs (L664-668)
```rust
            if (chain_id.is_testnet() || chain_id.is_mainnet())
                && config_yaml["rocksdb_configs"]["enable_storage_sharding"].as_bool() != Some(true)
            {
                panic!("Storage sharding (AIP-97) is not enabled in node config. Please follow the guide to migration your node, and set storage.rocksdb_configs.enable_storage_sharding to true explicitly in your node config. https://aptoslabs.notion.site/DB-Sharding-Migration-Public-Full-Nodes-1978b846eb7280b29f17ceee7d480730");
            }
```
