# Audit Report

## Title
Lack of Validator Identity Validation in SafetyRules Storage Allows Wrong Validator Identity Adoption Upon Storage Corruption

## Summary
The `author()` function in `PersistentSafetyStorage` retrieves the validator's identity from persistent storage without validation, allowing storage corruption or misconfiguration to cause a validator node to either fail initialization (denial of service) or adopt a different validator's identity (potential consensus safety violation).

## Finding Description

The `author()` function performs no validation that the retrieved `Author` matches the expected validator identity for the node: [1](#0-0) 

When SafetyRules initializes or reinitializes, the code in `SafetyRulesManager` blindly trusts existing storage if it can successfully retrieve an author: [2](#0-1) 

During initialization, the unchecked author is used to create the `ValidatorSigner`: [3](#0-2) 

This author is subsequently used when constructing votes: [4](#0-3) 

**Attack Scenario:**

1. **Storage Corruption**: The `OWNER_ACCOUNT` value in persistent storage becomes corrupted (hardware failure, memory errors, or malicious modification) to contain a different validator's `Author` address.

2. **Node Restart/Reinitialization**: The validator node restarts or SafetyRules is reinitialized.

3. **Two Possible Outcomes**:

   **Outcome A** (Most Common - Node has only its own key):
   - Wrong author retrieved from corrupted storage
   - Code attempts to find matching private key for the wrong validator
   - Cryptographic validation fails at consensus key retrieval
   - Node fails to initialize
   - **Impact**: Denial of Service - validator cannot participate in consensus

   **Outcome B** (Less Common - Node has multiple validators' keys):
   - This can occur with key rotation configurations or misconfigurations
   - Wrong author retrieved from corrupted storage  
   - Code successfully finds matching private key in storage
   - `ValidatorSigner` created with incorrect validator identity
   - Node signs consensus messages as the wrong validator
   - **Impact**: Consensus safety violation through validator identity confusion

## Impact Explanation

**High Severity** (per Aptos bug bounty criteria):

**Primary Impact - Denial of Service**: Storage corruption causing the `OWNER_ACCOUNT` to contain an incorrect validator address will prevent the affected validator node from initializing. This constitutes "Validator node slowdowns" or unavailability, meeting the High severity criteria for up to $50,000.

**Secondary Impact - Potential Consensus Safety Violation**: In configurations where a node has access to multiple validators' private keys (e.g., during key rotation or misconfiguration), storage corruption could cause the node to adopt a different validator's identity. This would result in:
- Votes attributed to the wrong validator
- Potential for multiple nodes claiming the same validator identity
- Consensus confusion and potential safety violations

This secondary impact could potentially meet Critical severity criteria ("Consensus/Safety violations"), though it requires specific preconditions.

## Likelihood Explanation

**Moderate to High Likelihood for DoS Impact**:
- Storage corruption can occur through hardware failures, software bugs, or cosmic ray-induced bit flips in memory
- No attacker action required - natural failure modes can trigger this
- Any validator node experiencing storage corruption of the `OWNER_ACCOUNT` field will be affected

**Low Likelihood for Consensus Safety Impact**:
- Requires the node to have multiple validators' private keys in storage
- This is not a standard configuration, though possible during key rotation
- More likely to occur due to misconfiguration than malicious action

**Defensive Programming Concern**:
Even with low likelihood for the worst-case scenario, the complete lack of validation violates defense-in-depth principles. Critical identity data should be validated even when retrieved from trusted storage.

## Recommendation

Implement validation in the `author()` function or during SafetyRules initialization to verify that the retrieved author matches the expected validator identity for this node.

**Recommended Fix**:

1. **Option A - Add validation parameter**: Store and verify the expected author during initialization:

```rust
pub struct PersistentSafetyStorage {
    enable_cached_safety_data: bool,
    cached_safety_data: Option<SafetyData>,
    internal_store: Storage,
    expected_author: Option<Author>, // Add this field
}

pub fn author(&self) -> Result<Author, Error> {
    let _timer = counters::start_timer("get", OWNER_ACCOUNT);
    let retrieved_author: Author = self.internal_store.get(OWNER_ACCOUNT).map(|v| v.value)?;
    
    // Validate against expected author if set
    if let Some(expected) = &self.expected_author {
        if &retrieved_author != expected {
            return Err(Error::SecureStorageMissingDataError(format!(
                "Storage corruption detected: retrieved author {:?} does not match expected author {:?}",
                retrieved_author, expected
            )));
        }
    }
    
    Ok(retrieved_author)
}
```

2. **Option B - Cross-validation**: In `guarded_initialize()`, after retrieving the author and finding the corresponding key, verify that the derived public key matches what's expected:

```rust
// After line 329 in safety_rules.rs
let derived_author = AccountAddress::from_bytes(&consensus_key.public_key().to_bytes()[0..32])?;
if derived_author != author {
    return Err(Error::SecureStorageMissingDataError(format!(
        "Author mismatch: storage contains {:?} but consensus key corresponds to {:?}",
        author, derived_author
    )));
}
```

3. **Option C - Checksum/integrity validation**: Store a checksum or HMAC of the author value and verify it on retrieval to detect corruption.

## Proof of Concept

```rust
#[test]
fn test_storage_corruption_causes_initialization_failure() {
    use aptos_crypto::bls12381;
    use aptos_secure_storage::{InMemoryStorage, KVStorage, Storage};
    use aptos_types::validator_signer::ValidatorSigner;
    use aptos_types::waypoint::Waypoint;
    use aptos_consensus_types::common::Author;
    
    // Create two different validators
    let validator_a_signer = ValidatorSigner::from_int(1);
    let validator_b_signer = ValidatorSigner::from_int(2);
    
    let validator_a_author = validator_a_signer.author();
    let validator_b_author = validator_b_signer.author();
    let validator_a_key = validator_a_signer.private_key().clone();
    
    // Initialize storage for validator A
    let internal_storage = Storage::from(InMemoryStorage::new());
    let mut safety_storage = PersistentSafetyStorage::initialize(
        internal_storage,
        validator_a_author,
        validator_a_key,
        Waypoint::default(),
        true,
    );
    
    // Verify initial state is correct
    assert_eq!(safety_storage.author().unwrap(), validator_a_author);
    
    // SIMULATE STORAGE CORRUPTION: Modify OWNER_ACCOUNT to validator B's author
    // In real scenario, this would happen due to hardware failure or malicious modification
    safety_storage.internal_store().set(OWNER_ACCOUNT, validator_b_author).unwrap();
    
    // Now author() returns the WRONG validator's identity
    assert_eq!(safety_storage.author().unwrap(), validator_b_author);
    assert_ne!(safety_storage.author().unwrap(), validator_a_author);
    
    // When SafetyRules tries to initialize with this corrupted storage:
    let mut safety_rules = SafetyRules::new(safety_storage, false);
    
    // Initialize will try to find validator B's key, fail, and return an error
    let epoch_change_proof = EpochChangeProof::new(vec![], false);
    let result = safety_rules.initialize(&epoch_change_proof);
    
    // Expected: Initialization fails because validator A's key doesn't match validator B's identity
    assert!(result.is_err());
    // This demonstrates the DoS impact - the validator cannot participate in consensus
}

#[test]
fn test_storage_corruption_with_multiple_keys_causes_wrong_identity() {
    // This test demonstrates the more serious case where the node has multiple keys
    // and adopts the wrong identity
    
    let validator_a_signer = ValidatorSigner::from_int(1);
    let validator_b_signer = ValidatorSigner::from_int(2);
    
    let validator_a_author = validator_a_signer.author();
    let validator_b_author = validator_b_signer.author();
    let validator_a_key = validator_a_signer.private_key().clone();
    let validator_b_key = validator_b_signer.private_key().clone();
    
    // Initialize storage for validator A
    let internal_storage = Storage::from(InMemoryStorage::new());
    let mut safety_storage = PersistentSafetyStorage::initialize(
        internal_storage,
        validator_a_author,
        validator_a_key.clone(),
        Waypoint::default(),
        true,
    );
    
    // Add validator B's key as an "overriding consensus key" (simulating key rotation scenario)
    let validator_b_pk = validator_b_key.public_key();
    let pk_hex = hex::encode(validator_b_pk.to_bytes());
    let storage_key = format!("{}_{}", CONSENSUS_KEY, pk_hex);
    safety_storage.internal_store().set(storage_key.as_str(), validator_b_key).unwrap();
    
    // SIMULATE STORAGE CORRUPTION: Change OWNER_ACCOUNT to validator B
    safety_storage.internal_store().set(OWNER_ACCOUNT, validator_b_author).unwrap();
    
    // Now when the node reinitializes, it will successfully adopt validator B's identity
    // even though it's supposed to be validator A
    // This demonstrates the consensus safety impact
    assert_eq!(safety_storage.author().unwrap(), validator_b_author);
    
    // The node will now sign votes as validator B instead of validator A
    // This could cause consensus confusion if the real validator B is also active
}
```

## Notes

This vulnerability demonstrates a critical failure in defense-in-depth. While the secure storage backend is designed to be trusted, storage corruption can occur through non-malicious means (hardware failures, cosmic rays affecting memory, software bugs). The complete absence of validation means that such corruption immediately translates into either node unavailability or incorrect validator identity adoption, with no runtime detection mechanism.

The impact severity depends on the node's key configuration:
- Standard single-validator nodes: High severity (DoS)
- Nodes with multiple validators' keys: Potentially Critical severity (consensus safety)

The fix is straightforward: add validation to ensure the retrieved author matches expectations, with clear error reporting to aid diagnosis of storage corruption issues.

### Citations

**File:** consensus/safety-rules/src/persistent_safety_storage.rs (L93-96)
```rust
    pub fn author(&self) -> Result<Author, Error> {
        let _timer = counters::start_timer("get", OWNER_ACCOUNT);
        Ok(self.internal_store.get(OWNER_ACCOUNT).map(|v| v.value)?)
    }
```

**File:** consensus/safety-rules/src/safety_rules_manager.rs (L48-49)
```rust
        let mut storage = if storage.author().is_ok() {
            storage
```

**File:** consensus/safety-rules/src/safety_rules.rs (L312-329)
```rust
        let author = self.persistent_storage.author()?;
        let expected_key = epoch_state.verifier.get_public_key(&author);
        let initialize_result = match expected_key {
            None => Err(Error::ValidatorNotInSet(author.to_string())),
            Some(expected_key) => {
                let current_key = self.signer().ok().map(|s| s.public_key());
                if current_key == Some(expected_key.clone()) {
                    info!(
                        SafetyLogSchema::new(LogEntry::KeyReconciliation, LogEvent::Success),
                        "in set",
                    );
                    Ok(())
                } else {
                    // Try to export the consensus key directly from storage.
                    match self.persistent_storage.consensus_sk_by_pk(expected_key) {
                        Ok(consensus_key) => {
                            self.validator_signer =
                                Some(ValidatorSigner::new(author, Arc::new(consensus_key)));
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L86-89)
```rust
        let author = self.signer()?.author();
        let ledger_info = self.construct_ledger_info_2chain(proposed_block, vote_data.hash())?;
        let signature = self.sign(&ledger_info)?;
        let vote = Vote::new_with_signature(vote_data, author, ledger_info, signature);
```
