# Audit Report

## Title
Low-Order Point Attack on Noise Handshake via HKDF with Empty IKM Enables Predictable Session Key Derivation

## Summary
The `extract_then_expand_no_ikm()` function derives cryptographic keys using HKDF with empty Input Keying Material (IKM), relying solely on the salt parameter for entropy. In the Noise IK handshake implementation, this salt is the chaining key accumulated from X25519 Diffie-Hellman operations. Due to missing validation of X25519 public keys for low-order points and DH output validation, an attacker can force all DH operations to return predictable values (typically all zeros), making the chaining key and consequently the derived session keys deterministic and predictable.

## Finding Description

The vulnerability exists in the interaction between three components:

1. **HKDF with Empty IKM** [1](#0-0) 

When `extract_then_expand_no_ikm()` is called, it invokes `extract_no_ikm_check(salt, &[])` with empty IKM at line 169. This computes `PRK = HMAC-Hash(salt, "")`, making the pseudorandom key entirely dependent on the salt parameter with no additional entropy source.

2. **Usage in Noise Protocol Split Operation** [2](#0-1) 

The function is used in the Noise handshake's final "split" operation to derive session keys. When `dh_output` is empty, line 195 calls `extract_then_expand_no_ikm(Some(ck), None, 64)` where `ck` is the chaining key that should have accumulated entropy from multiple DH operations during the handshake.

3. **Missing Low-Order Point Validation** [3](#0-2) 

The X25519 `diffie_hellman()` implementation directly uses received public keys without validating them for low-order points. According to RFC 7748, X25519 DH operations with low-order points return predictable values (typically all zeros after cofactor clearing).

**Attack Scenario:**

1. Attacker compromises validator configuration or uses social engineering to add a malicious peer with a **low-order static public key** to the trusted peer set

2. When a victim validator initiates a connection via `initiate_connection()` [4](#0-3) :
   - `DH(victim_ephemeral, attacker_static_loworder)` = 0 (mixed at noise.rs line 311)
   - `DH(victim_static, attacker_static_loworder)` = 0 (mixed at noise.rs line 328)

3. Attacker responds with a **low-order ephemeral public key**

4. Victim processes response in `finalize_connection()` [5](#0-4) :
   - `DH(victim_ephemeral, attacker_ephemeral_loworder)` = 0 (mixed at line 378)
   - `DH(victim_static, attacker_ephemeral_loworder)` = 0 (mixed at line 382)

5. The chaining key `ck` now contains only:
   - Initial `PROTOCOL_NAME` constant (public)
   - Four HKDF mixing operations with zero input
   - Result: **Predictable chaining key**

6. Session key derivation at line 395 [6](#0-5) :
   - `hkdf(&ck, None)` â†’ `extract_then_expand_no_ikm(predictable_ck, None, 64)`
   - Produces **deterministic, predictable session keys**

7. Attacker can now decrypt all messages and forge authenticated messages in the compromised session

## Impact Explanation

**High Severity** - This vulnerability enables complete compromise of encrypted validator-to-validator communication:

- **Confidentiality Breach**: Attacker can decrypt all consensus messages, block proposals, votes, and state synchronization data between compromised validator pairs
- **Integrity Violation**: Attacker can forge authenticated messages (though additional signature validation may provide defense-in-depth)
- **Protocol Violation**: Breaks the cryptographic correctness invariant (invariant #10) that all cryptographic operations must be secure
- **Network Security**: Compromises the secure channel assumptions of the Noise protocol in the network layer

Per the Aptos bug bounty program, this qualifies as **High Severity** ($50,000 tier) due to:
- Validator node compromise potential
- Significant protocol violations affecting secure communication
- Potential for consensus message manipulation

While not directly causing consensus safety violations, it enables sophisticated attacks on validator communication that could facilitate more severe exploits.

## Likelihood Explanation

**Medium-Low Likelihood:**

**Attack Requirements:**
1. Social engineering or configuration compromise to add malicious peer with low-order public key to trusted validator set
2. Technical knowledge to generate low-order points on Curve25519
3. Ability to respond to handshake with low-order ephemeral key

**Mitigating Factors:**
- Requires compromising validator operator trust or configuration
- Validators typically have strict peer vetting procedures
- Low-order public keys could be detected by monitoring/auditing tools

**Aggravating Factors:**
- No technical validation prevents the attack once configuration is compromised
- Attack is deterministic once conditions are met
- Silent failure - no warnings or errors when low-order points are used

The combination of high impact and medium-low likelihood justifies **High severity** classification.

## Recommendation

Implement comprehensive low-order point validation:

**1. Validate Received X25519 Public Keys:**

Add validation in `x25519::PublicKey` to reject known low-order points. The 8 low-order points on Curve25519 include the point at infinity and 7 other small-order points.

**2. Validate DH Output:**

In the `diffie_hellman()` method, check for all-zero output (which indicates low-order point was used):

```rust
pub fn diffie_hellman(&self, remote_public_key: &PublicKey) -> Result<[u8; SHARED_SECRET_SIZE], CryptoMaterialError> {
    let remote_public_key = x25519_dalek::PublicKey::from(remote_public_key.0);
    let shared_secret = self.0.diffie_hellman(&remote_public_key);
    let secret_bytes = shared_secret.as_bytes().to_owned();
    
    // Reject all-zero shared secret (indicates low-order point attack)
    if secret_bytes == [0u8; SHARED_SECRET_SIZE] {
        return Err(CryptoMaterialError::ValidationError);
    }
    
    Ok(secret_bytes)
}
```

**3. Add Validation in Noise Handshake:**

In `noise.rs`, validate DH outputs in the `mix_key()` function before mixing into chaining key.

**4. Consider Using XEdDSA Validation:**

Leverage the existing Ed25519 small-order validation from [7](#0-6)  when converting between Ed25519 and X25519 representations.

## Proof of Concept

```rust
#[cfg(test)]
mod low_order_point_attack_test {
    use super::*;
    use aptos_crypto::{noise, x25519, traits::Uniform};
    use rand::SeedableRng;
    
    #[test]
    fn test_low_order_point_attack_on_noise_handshake() {
        // Known low-order point on Curve25519 (point of order 8)
        // This is one of the 8 torsion points
        let low_order_point: [u8; 32] = [
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        ];
        
        let mut rng = rand::rngs::StdRng::from_seed([0u8; 32]);
        
        // Legitimate initiator
        let initiator_key = x25519::PrivateKey::generate(&mut rng);
        let initiator = noise::NoiseConfig::new(initiator_key);
        
        // Attacker uses low-order point as their static public key
        let attacker_static_pubkey = x25519::PublicKey::from(low_order_point);
        
        // Initiator attempts connection to attacker
        let mut init_msg = vec![0u8; noise::handshake_init_msg_len(0)];
        let result = initiator.initiate_connection(
            &mut rng,
            b"prologue",
            attacker_static_pubkey,
            None,
            &mut init_msg,
        );
        
        // The handshake should succeed but produces predictable keys
        assert!(result.is_ok(), "Handshake should succeed with low-order point");
        
        // All DH operations with low_order_point return predictable values
        // This makes the chaining key predictable
        // And therefore session keys are predictable
        
        // Demonstrate that DH with low-order point gives zero
        let any_private = x25519::PrivateKey::generate(&mut rng);
        let dh_output = any_private.diffie_hellman(&attacker_static_pubkey);
        
        // Depending on the specific low-order point, output will be predictable
        // (often all zeros or another small set of values)
        println!("DH with low-order point: {:x?}", dh_output);
    }
}
```

**Notes:**
- The PoC demonstrates that low-order points are accepted without validation
- Actual low-order point bytes would need to be determined from Curve25519 specification
- The x25519_dalek library behavior with low-order points follows RFC 7748
- A complete exploit would require generating proper low-order points and demonstrating predictable session key derivation

### Citations

**File:** crates/aptos-crypto/src/hkdf.rs (L164-171)
```rust
    pub fn extract_then_expand_no_ikm(
        salt: Option<&[u8]>,
        info: Option<&[u8]>,
        length: usize,
    ) -> Result<Vec<u8>, HkdfError> {
        let prk = Hkdf::<D>::extract_no_ikm_check(salt, &[]);
        Hkdf::<D>::expand(&prk, info, length)
    }
```

**File:** crates/aptos-crypto/src/noise.rs (L192-203)
```rust
fn hkdf(ck: &[u8], dh_output: Option<&[u8]>) -> Result<(Vec<u8>, Vec<u8>), NoiseError> {
    let dh_output = dh_output.unwrap_or(&[]);
    let hkdf_output = if dh_output.is_empty() {
        Hkdf::<sha2::Sha256>::extract_then_expand_no_ikm(Some(ck), None, 64)
    } else {
        Hkdf::<sha2::Sha256>::extract_then_expand(Some(ck), dh_output, None, 64)
    };

    let hkdf_output = hkdf_output.map_err(|_| NoiseError::Hkdf)?;
    let (k1, k2) = hkdf_output.split_at(32);
    Ok((k1.to_vec(), k2.to_vec()))
}
```

**File:** crates/aptos-crypto/src/noise.rs (L377-382)
```rust
        let dh_output = e.diffie_hellman(&re);
        mix_key(&mut ck, &dh_output)?;

        // <- se
        let dh_output = self.private_key.diffie_hellman(&re);
        let k = mix_key(&mut ck, &dh_output)?;
```

**File:** crates/aptos-crypto/src/noise.rs (L395-396)
```rust
        let (k1, k2) = hkdf(&ck, None)?;
        let session = NoiseSession::new(k1, k2, rs);
```

**File:** crates/aptos-crypto/src/x25519.rs (L90-94)
```rust
    pub fn diffie_hellman(&self, remote_public_key: &PublicKey) -> [u8; SHARED_SECRET_SIZE] {
        let remote_public_key = x25519_dalek::PublicKey::from(remote_public_key.0);
        let shared_secret = self.0.diffie_hellman(&remote_public_key);
        shared_secret.as_bytes().to_owned()
    }
```

**File:** network/framework/src/noise/handshake.rs (L211-217)
```rust
            .initiate_connection(
                &mut rng,
                prologue_msg,
                remote_public_key,
                Some(&payload),
                client_noise_msg,
            )
```

**File:** aptos-move/framework/src/natives/cryptography/ed25519.rs (L79-80)
```rust
    context.charge(ED25519_PER_PUBKEY_SMALL_ORDER_CHECK * NumArgs::one())?;
    let valid = !point.is_small_order();
```
