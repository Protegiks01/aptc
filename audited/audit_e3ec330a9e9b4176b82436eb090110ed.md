# Audit Report

## Title
Consensus Split During ExecutionConfig V3→V4 Migration Due to Incompatible Fallback Behavior

## Summary
A critical consensus safety vulnerability exists in the ExecutionConfig upgrade path from V3 to V4. When validators with outdated binaries fail to deserialize the V4 config, they silently fall back to using `OnChainExecutionConfig::Missing` which returns `BlockGasLimitType::NoLimit`, while upgraded validators use the actual configured gas limits. This causes validators to execute different numbers of transactions per block, producing divergent state roots and splitting the network.

## Finding Description

The vulnerability stems from a type incompatibility between `ExecutionConfigV3` and `ExecutionConfigV4` combined with incorrect error handling during deserialization.

**Type Change:** [1](#0-0) 

ExecutionConfigV3 uses `block_gas_limit: Option<u64>` while ExecutionConfigV4 uses `block_gas_limit_type: BlockGasLimitType`. The `OnChainExecutionConfig` enum places V4 after the `Missing` variant, giving it BCS serialization tag 4.

**Enum Variant Ordering:** [2](#0-1) 

**Deserialization Failure and Silent Fallback:**
When a validator running old code (compiled with only V1-V3 support) attempts to deserialize on-chain V4 config, the BCS deserialization fails because tag 4 doesn't exist in their enum definition. The epoch manager catches this error and silently falls back to `Missing`: [3](#0-2) 

**Divergent Block Gas Limit Behavior:**
The fallback to `Missing` returns `BlockGasLimitType::NoLimit`: [4](#0-3) 

Meanwhile, validators with V4 support use the actual configured limits. This causes different execution behavior in the block gas limit processor: [5](#0-4) 

**Consensus Split Mechanism:**
- Validators with `NoLimit` execute ALL transactions in a block without early halting
- Validators with configured limits halt early when gas limits are exceeded  
- Different transaction sets included in blocks → different state transitions → different state roots → **consensus safety violation**

**Attack Scenario:**
1. Governance proposal updates on-chain ExecutionConfig from V3 to V4
2. Not all validators have upgraded their binaries to understand V4
3. During epoch transition, old validators fail to deserialize V4 config
4. Old validators silently use `Missing` (NoLimit), new validators use V4 limits
5. Any user submitting transactions during this window triggers divergent block execution
6. Network splits as validators commit different state roots

## Impact Explanation

This qualifies as **Critical Severity** under Aptos bug bounty criteria:

- **Consensus/Safety Violation**: Breaks the fundamental "Deterministic Execution" invariant - validators no longer produce identical state roots for identical blocks
- **Non-recoverable Network Partition**: A chain split between validators using different gas limits would require manual intervention or hardfork to resolve
- **Realistic Attack Surface**: Can occur during normal upgrade processes without requiring attacker privileges

The vulnerability directly violates Critical Invariant #1 (Deterministic Execution) and Critical Invariant #2 (Consensus Safety) from the Aptos specification.

## Likelihood Explanation

**Medium-High Likelihood** during upgrade windows:

- **Trigger Conditions**: Governance proposal updates config to V4 before all validators upgrade binaries
- **No Enforcement**: No code-level mechanism prevents applying V4 config when some validators lack V4 support
- **Silent Failure**: The fallback happens silently with only a warning log that operators might miss
- **Realistic Scenario**: Common in distributed systems for validator upgrades to be staggered

The governance upgrade mechanism has no version compatibility checks: [6](#0-5) 

The Move code only validates that config bytes are non-empty, not whether all validators can deserialize the version.

## Recommendation

**Immediate Fix**: Validators should HALT with a fatal error when ExecutionConfig deserialization fails, rather than silently falling back to `Missing`:

```rust
let execution_config = onchain_execution_config
    .expect("Failed to deserialize ExecutionConfig - validator binary may be outdated. Halting to prevent consensus split.");
```

**Proper Migration Path**:

1. Add version compatibility metadata to ExecutionConfig Move module
2. Implement pre-deployment validation in governance proposals that checks if enough validators support the new version
3. Add explicit migration logic that converts V3 configs to V4 format during deserialization, rather than treating them as incompatible versions
4. Document upgrade procedures requiring validators to upgrade binaries before governance proposals execute

**Code Changes Required**:
- `consensus/src/epoch_manager.rs`: Replace `unwrap_or_else` with `expect` at line 1202-1203
- `consensus/src/consensus_observer/observer/epoch_state.rs`: Same fix at line 178-179  
- `types/src/on_chain_config/execution_config.rs`: Add explicit V3→V4 conversion method

## Proof of Concept

```rust
// Reproduction test demonstrating the vulnerability
// Place in consensus/src/epoch_manager_test.rs

#[tokio::test]
async fn test_execution_config_v3_v4_consensus_split() {
    // Setup: Create V4 config with gas limit
    let v4_config = OnChainExecutionConfig::V4(ExecutionConfigV4 {
        transaction_shuffler_type: TransactionShufflerType::NoShuffling,
        block_gas_limit_type: BlockGasLimitType::Limit(10000),
        transaction_deduper_type: TransactionDeduperType::NoDedup,
    });
    
    // Serialize V4 config as it would appear on-chain
    let v4_bytes = bcs::to_bytes(&v4_config).unwrap();
    
    // Simulate old validator attempting to deserialize
    // (In reality, old code wouldn't have V4 variant, so this simulates
    // deserialization failure by manually triggering the error path)
    let old_validator_result: Result<OnChainExecutionConfig> = 
        Err(anyhow!("Unknown variant tag 4"));
    
    // Old validator falls back to Missing
    let old_validator_config = old_validator_result
        .unwrap_or_else(|_| OnChainExecutionConfig::default_if_missing());
    
    // New validator successfully deserializes V4
    let new_validator_config = bcs::from_bytes::<OnChainExecutionConfig>(&v4_bytes).unwrap();
    
    // Compare gas limit behavior
    let old_limit = old_validator_config.block_gas_limit_type();
    let new_limit = new_validator_config.block_gas_limit_type();
    
    assert_eq!(old_limit, BlockGasLimitType::NoLimit);
    assert_eq!(new_limit, BlockGasLimitType::Limit(10000));
    
    // This difference causes consensus split:
    // - Old validators execute unlimited transactions
    // - New validators halt at 10000 gas
    // Result: Different state roots = consensus split
    println!("CONSENSUS SPLIT: Old validators use {:?}, new validators use {:?}", 
             old_limit, new_limit);
}
```

**Notes**

The vulnerability is particularly dangerous because:
1. The fallback behavior appears designed for "missing config" scenarios (fresh genesis), not for "incompatible version" scenarios
2. The comment at line 136 states "This value should not be changed, for replay purposes" - using `Missing` as a deserialization fallback violates this principle
3. No validation exists in the governance proposal generation to prevent this scenario
4. The multi-step proposal system doesn't include version compatibility checks [7](#0-6)

### Citations

**File:** types/src/on_chain_config/execution_config.rs (L11-24)
```rust
#[derive(Clone, Debug, Deserialize, PartialEq, Eq, Serialize)]
pub enum OnChainExecutionConfig {
    V1(ExecutionConfigV1),
    V2(ExecutionConfigV2),
    V3(ExecutionConfigV3),
    /// To maintain backwards compatibility on replay, we must ensure that any new features resolve
    /// to previous behavior (before OnChainExecutionConfig was registered) in case of Missing.
    Missing,
    // Reminder: Add V4 and future versions here, after Missing (order matters for enums).
    V4(ExecutionConfigV4),
    V5(ExecutionConfigV5),
    V6(ExecutionConfigV6),
    V7(ExecutionConfigV7),
}
```

**File:** types/src/on_chain_config/execution_config.rs (L43-58)
```rust
    pub fn block_gas_limit_type(&self) -> BlockGasLimitType {
        match &self {
            OnChainExecutionConfig::Missing => BlockGasLimitType::NoLimit,
            OnChainExecutionConfig::V1(_config) => BlockGasLimitType::NoLimit,
            OnChainExecutionConfig::V2(config) => config
                .block_gas_limit
                .map_or(BlockGasLimitType::NoLimit, BlockGasLimitType::Limit),
            OnChainExecutionConfig::V3(config) => config
                .block_gas_limit
                .map_or(BlockGasLimitType::NoLimit, BlockGasLimitType::Limit),
            OnChainExecutionConfig::V4(config) => config.block_gas_limit_type.clone(),
            OnChainExecutionConfig::V5(config) => config.block_gas_limit_type.clone(),
            OnChainExecutionConfig::V6(config) => config.block_gas_limit_type.clone(),
            OnChainExecutionConfig::V7(config) => config.block_gas_limit_type.clone(),
        }
    }
```

**File:** types/src/on_chain_config/execution_config.rs (L135-139)
```rust
    /// The default values to use when on-chain config is not initialized.
    /// This value should not be changed, for replay purposes.
    pub fn default_if_missing() -> Self {
        OnChainExecutionConfig::Missing
    }
```

**File:** types/src/on_chain_config/execution_config.rs (L188-199)
```rust
pub struct ExecutionConfigV3 {
    pub transaction_shuffler_type: TransactionShufflerType,
    pub block_gas_limit: Option<u64>,
    pub transaction_deduper_type: TransactionDeduperType,
}

#[derive(Clone, Debug, Deserialize, PartialEq, Eq, Serialize)]
pub struct ExecutionConfigV4 {
    pub transaction_shuffler_type: TransactionShufflerType,
    pub block_gas_limit_type: BlockGasLimitType,
    pub transaction_deduper_type: TransactionDeduperType,
}
```

**File:** consensus/src/epoch_manager.rs (L1179-1203)
```rust
        let onchain_execution_config: anyhow::Result<OnChainExecutionConfig> = payload.get();
        let onchain_randomness_config_seq_num: anyhow::Result<RandomnessConfigSeqNum> =
            payload.get();
        let randomness_config_move_struct: anyhow::Result<RandomnessConfigMoveStruct> =
            payload.get();
        let onchain_jwk_consensus_config: anyhow::Result<OnChainJWKConsensusConfig> = payload.get();
        let dkg_state = payload.get::<DKGState>();

        if let Err(error) = &onchain_consensus_config {
            warn!("Failed to read on-chain consensus config {}", error);
        }

        if let Err(error) = &onchain_execution_config {
            warn!("Failed to read on-chain execution config {}", error);
        }

        if let Err(error) = &randomness_config_move_struct {
            warn!("Failed to read on-chain randomness config {}", error);
        }

        self.epoch_state = Some(epoch_state.clone());

        let consensus_config = onchain_consensus_config.unwrap_or_default();
        let execution_config = onchain_execution_config
            .unwrap_or_else(|_| OnChainExecutionConfig::default_if_missing());
```

**File:** aptos-move/block-executor/src/limit_processor.rs (L127-141)
```rust
    fn should_end_block(&mut self, mode: &str) -> bool {
        if let Some(per_block_gas_limit) = self.block_gas_limit() {
            // When the accumulated block gas of the committed txns exceeds
            // PER_BLOCK_GAS_LIMIT, early halt BlockSTM.
            let accumulated_block_gas = self.get_effective_accumulated_block_gas();
            if accumulated_block_gas >= per_block_gas_limit {
                counters::EXCEED_PER_BLOCK_GAS_LIMIT_COUNT.inc_with(&[mode]);
                info!(
                    "[BlockSTM]: execution ({}) early halted due to \
                    accumulated_block_gas {} >= PER_BLOCK_GAS_LIMIT {}",
                    mode, accumulated_block_gas, per_block_gas_limit,
                );
                return true;
            }
        }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/execution_config.move (L48-52)
```text
    public fun set_for_next_epoch(account: &signer, config: vector<u8>) {
        system_addresses::assert_aptos_framework(account);
        assert!(vector::length(&config) > 0, error::invalid_argument(EINVALID_CONFIG));
        config_buffer::upsert(ExecutionConfig { config });
    }
```
