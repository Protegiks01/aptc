# Audit Report

## Title
Transaction Count Mismatch Vulnerability in Indexer Fullnode Service with Transaction Filtering

## Summary
The `IndexerStreamCoordinator` calculates the batch `end_version` from storage-fetched transactions before applying transaction filters, but the `StreamStatus::BatchEnd` message reports this pre-filter version range. This causes a mismatch between the expected transaction count (`end_version - start_version + 1`) and the actual filtered transaction count sent to consumers, breaking cache worker validation and causing indexer infrastructure failure.

## Finding Description

The vulnerability exists in the transaction streaming pipeline where version accounting occurs before transaction filtering is applied.

**The problematic flow:**

1. **Version calculation happens before filtering**: In `stream_coordinator.rs`, the `end_version` is calculated from the last transaction fetched from storage, before any filtering occurs. [1](#0-0) 

2. **Transaction filtering removes transactions**: Later in the same function, if a filter is present, transactions are removed from the set that will be sent to consumers. [2](#0-1) 

3. **Filtered transactions are sent in chunks**: The remaining (filtered) transactions are chunked and sent as `TransactionsOutput` messages. [3](#0-2) 

4. **Pre-filter end_version is returned**: The function returns the `end_version` calculated in step 1, which represents the last transaction from storage, not the last transaction actually sent. [4](#0-3) 

5. **BatchEnd status uses mismatched version**: The fullnode data service sends a `BatchEnd` status with this pre-filter `end_version`. [5](#0-4) 

6. **Consumer validation fails**: The cache worker calculates expected transaction count as `end_version - start_version + 1` from the `BatchEnd` status. [6](#0-5) 

7. **Mismatch detection causes failure**: The cache worker validates that accumulated transaction count matches expected count, and breaks the stream on mismatch. [7](#0-6) 

**Current Status:**
While transaction filtering is currently disabled in the fullnode data service (set to `None`), the code explicitly documents plans to enable it. [8](#0-7) 

**Concrete Example:**
- Fetch transactions with versions 100-199 (100 transactions)
- Apply filter that removes transaction at version 150
- Send 99 transactions in `TransactionsOutput` chunks  
- Send `BatchEnd` with `start_version=100`, `end_version=199`
- Consumer expects: 199 - 100 + 1 = 100 transactions
- Consumer received: 99 transactions
- **Validation fails, cache worker stops**

## Impact Explanation

This is a **HIGH severity** vulnerability per Aptos bug bounty criteria:

**Impact Category: Validator node slowdowns / Significant protocol violations**

1. **Critical Infrastructure Failure**: The cache worker is essential for the indexer infrastructure. When validation fails, the worker stops processing, causing:
   - Stale indexer data across dependent services
   - API data becoming outdated
   - Applications relying on indexer seeing incorrect state

2. **Service Degradation**: While not causing fund loss or consensus violations, this breaks a critical data availability component that many ecosystem participants depend on for querying blockchain state.

3. **Inevitable Activation**: This is not a theoretical vulnerability - the code comments explicitly state this feature will be enabled, making this a latent bug that will activate when the planned feature is deployed.

4. **No Current Mitigation**: The code contains no validation or correction mechanism to handle this mismatch. The consumer has no way to know filtering occurred or adjust expectations.

This does not reach Critical severity because:
- No fund loss occurs
- Consensus is not affected
- Validator nodes continue operating normally
- The impact is limited to indexer data availability

## Likelihood Explanation

**Likelihood: HIGH (when feature is enabled)**

**Current State:**
- Filtering is disabled (`None`) in production fullnode service
- Code explicitly plans to enable this feature (documented in comments)
- LocalNet service already supports filtering but doesn't send `StreamStatus` messages

**Activation Triggers:**
1. **Planned Feature Deployment**: When transaction filtering is enabled in fullnode service (as planned)
2. **Bad Transaction Handling**: If transaction conversion error handling is changed from panic to skip (commented code exists for this) [9](#0-8) 

**Exploitation Requirements:**
- No attacker action required - normal operation will trigger when filtering is enabled
- Any filter configuration that removes transactions will cause immediate failure
- 100% reproducible with any non-empty filter

**Complexity: LOW**
- Automatically triggered by legitimate filter configurations
- No special attacker capabilities required
- Affects all cache worker instances simultaneously

## Recommendation

**Fix the version accounting to occur AFTER filtering:**

The `end_version` should represent the last transaction actually sent to consumers, not the last transaction fetched from storage. Modify `stream_coordinator.rs`:

```rust
pub async fn process_next_batch(&mut self) -> Vec<Result<EndVersion, Status>> {
    // ... existing code for fetching and conversion ...
    
    // Apply filter if present
    let pb_txns = if let Some(ref filter) = filter {
        pb_txns
            .into_iter()
            .filter(|txn| filter.matches(txn))
            .collect::<Vec<_>>()
    } else {
        pb_txns
    };
    
    // CRITICAL FIX: Calculate end_version AFTER filtering
    let actual_end_version = if pb_txns.is_empty() {
        return vec![];
    } else {
        pb_txns.last().unwrap().version
    };
    
    // ... rest of chunking and sending logic ...
    
    // Return the actual last version sent, not pre-filter version
    vec![Ok(actual_end_version)]
}
```

**Additional Validation:**
Add explicit validation in the fullnode service to ensure version continuity:

```rust
if let Some(filter) = &filter {
    // Verify that returned end_version matches last sent transaction
    assert_eq!(
        max_version,
        last_sent_transaction_version,
        "Version accounting mismatch after filtering"
    );
}
```

## Proof of Concept

**Scenario: Enable transaction filtering in fullnode service**

1. Modify `fullnode_data_service.rs` to enable filtering:
```rust
// Change from None to Some(filter)
let filter = Some(parse_transaction_filter(
    filter_config,
    max_filter_size,
)?);
```

2. Configure a filter that removes specific transaction types (e.g., filter out all state checkpoint transactions)

3. Start the fullnode service and cache worker

4. **Expected Result**: Cache worker will fail validation at line 433 with error:
```
"[Indexer Cache] End signal received with wrong version."
current_version = X (accumulated from actual transactions)
actual_current_version = Y (calculated from BatchEnd versions)
where X < Y (due to filtered transactions)
```

5. Cache worker exits the processing loop (line 442), stopping all indexer updates

**Test Case Structure:**
```rust
#[tokio::test]
async fn test_transaction_filter_version_mismatch() {
    // 1. Fetch 100 transactions (versions 0-99)
    // 2. Apply filter removing 10 transactions
    // 3. Process batch and verify:
    //    - TransactionsOutput contains 90 transactions
    //    - BatchEnd reports end_version = 99
    //    - Expected count = 100, actual = 90
    //    - Validation fails
}
```

## Notes

This vulnerability highlights a critical design flaw where accounting occurs at different stages of the processing pipeline. The `end_version` is a promise to consumers about what data they will receive, but filtering breaks that promise without updating the accounting.

The vulnerability is particularly concerning because:
1. It's explicitly planned to be enabled (not speculative)
2. It affects critical infrastructure relied upon by the ecosystem
3. No detection or mitigation mechanism exists
4. The failure mode is silent breakage rather than explicit errors

The fix requires ensuring version accounting reflects the actual data sent, not the data initially fetched from storage.

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/stream_coordinator.rs (L113-116)
```rust
        let end_version = sorted_transactions_from_storage_with_size
            .last()
            .map(|(txn, _)| txn.version)
            .unwrap() as i64;
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/stream_coordinator.rs (L175-182)
```rust
                let pb_txns = if let Some(ref filter) = filter {
                    pb_txns
                        .into_iter()
                        .filter(|txn| filter.matches(txn))
                        .collect::<Vec<_>>()
                } else {
                    pb_txns
                };
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/stream_coordinator.rs (L185-196)
```rust
                for chunk in pb_txns.chunks(output_batch_size as usize) {
                    for chunk in chunk_transactions(chunk.to_vec(), MESSAGE_SIZE_LIMIT) {
                        let item = TransactionsFromNodeResponse {
                            response: Some(transactions_from_node_response::Response::Data(
                                TransactionsOutput {
                                    transactions: chunk,
                                },
                            )),
                            chain_id: ledger_chain_id as u32,
                        };
                        responses.push(item);
                    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/stream_coordinator.rs (L237-237)
```rust
        vec![Ok(end_version as u64)]
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/stream_coordinator.rs (L458-463)
```rust
                    // IN CASE WE NEED TO SKIP BAD TXNS
                    // continue;
                    panic!(
                        "[Indexer Fullnode] Could not convert txn {} from OnChainTransactions: {:?}",
                        txn_version, err
                    );
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/fullnode_data_service.rs (L111-116)
```rust
                // For now the request for this interface doesn't include a txn filter
                // because it is only used for the txn stream filestore worker, which
                // needs every transaction. Later we may add support for txn filtering
                // to this interface too.
                None,
                Some(abort_handle.clone()),
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/fullnode_data_service.rs (L163-167)
```rust
                let batch_end_status = get_status(
                    StatusType::BatchEnd,
                    coordinator.current_version,
                    Some(max_version),
                    ledger_chain_id,
```

**File:** ecosystem/indexer-grpc/indexer-grpc-cache-worker/src/worker.rs (L194-204)
```rust
                StatusType::BatchEnd => {
                    let start_version = status.start_version;
                    let num_of_transactions = status
                        .end_version
                        .expect("TransactionsFromNodeResponse status end_version is None")
                        - start_version
                        + 1;
                    Ok(GrpcDataStatus::BatchEnd {
                        start_version,
                        num_of_transactions,
                    })
```

**File:** ecosystem/indexer-grpc/indexer-grpc-cache-worker/src/worker.rs (L433-443)
```rust
                    if current_version != start_version + num_of_transactions {
                        error!(
                            current_version = current_version,
                            actual_current_version = start_version + num_of_transactions,
                            "[Indexer Cache] End signal received with wrong version."
                        );
                        ERROR_COUNT
                            .with_label_values(&["data_end_wrong_version"])
                            .inc();
                        break;
                    }
```
