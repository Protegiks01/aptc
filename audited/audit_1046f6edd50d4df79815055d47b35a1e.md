# Audit Report

## Title
Missing Ledger Extension Validation in sign_commit_vote() Enables Malicious State Commitment

## Summary
The `sign_commit_vote()` function in SafetyRules fails to validate that the commit ledger info properly extends the ordered ledger info with advancing version numbers and valid state transitions, as explicitly noted by a TODO comment in the code. This missing validation could allow validators to sign commit votes on blocks that haven't properly executed or have inconsistent state.

## Finding Description

The `guarded_sign_commit_vote()` function in `consensus/safety-rules/src/safety_rules.rs` is responsible for signing commit votes after block execution. It performs several validations but explicitly lacks extension checks: [1](#0-0) 

The function validates:
1. The old ledger info is ordered-only (dummy execution state)
2. Consistency between old and new ledger info using `match_ordered_only`
3. Quorum signatures on the ordered ledger info

However, at lines 412-413, there are explicit TODO comments indicating missing validation:
- "TODO: add guarding rules in unhappy path"
- "TODO: add extension check"

The `match_ordered_only` function only validates that both ledger infos refer to the same block (same epoch, round, id, timestamp): [2](#0-1) 

**This validation is insufficient because it does NOT check:**
- Whether the version has advanced from 0 (ordered state) to the actual executed version
- Whether `executed_state_id` has progressed from `ACCUMULATOR_PLACEHOLDER_HASH` to the actual state root
- Whether the version progression is consistent with the parent block
- Whether there are gaps in the version sequence

**Attack Scenario:**

A malicious validator could:
1. Receive a legitimate ordered ledger info with 2f+1 signatures
2. Execute the block but construct a malicious commit ledger info with:
   - Same round, epoch, id, timestamp (passes `match_ordered_only` check)
   - But incorrect version (e.g., version = 0 or inconsistent version)
   - Or placeholder executed_state_id instead of actual state root
3. Call `sign_commit_vote()` which would succeed without extension validation
4. Broadcast this malicious commit vote

If multiple Byzantine validators collude (up to f validators), they could create divergent commit certificates, causing:
- State inconsistencies across validators
- Version gaps in the ledger
- Blocks committed without proper execution
- Violation of deterministic execution invariant

## Impact Explanation

**Severity: MEDIUM to HIGH**

This vulnerability breaks multiple critical invariants:

1. **State Consistency Invariant**: Validators could commit different states for the same block if they sign commit votes without validating execution progression.

2. **Deterministic Execution Invariant**: Without verifying that the version and state root properly reflect execution, validators could sign votes for blocks that haven't been properly executed.

3. **Defense-in-Depth Violation**: SafetyRules is supposed to be the final safety check before signing. The missing validation means bugs or Byzantine behavior in the execution layer could propagate to consensus without detection.

While this requires malicious validator behavior, it represents a significant weakness in consensus safety because:
- It allows Byzantine validators to sign invalid state
- It could be combined with execution bugs to cause consensus failure  
- It violates the principle that all validators must independently verify state

The impact falls into the **Medium Severity** category per the bug bounty criteria: "State inconsistencies requiring intervention" - because malicious validators could create commit votes for inconsistent state, potentially requiring manual intervention to resolve.

## Likelihood Explanation

**Likelihood: MEDIUM**

This vulnerability requires:
- One or more Byzantine validators (up to f < 1/3)
- The ability to manipulate local execution results or construct malicious ledger infos
- Other validators to aggregate the malicious commit votes

However, the likelihood is elevated because:
- The validation gap is explicitly documented in the code (TODO comments)
- Any bug in the execution layer could propagate through this gap
- The check is straightforward to add but has been deferred
- Byzantine validators have direct access to the signing interface

The attack doesn't require sophisticated exploitationâ€”just the ability to construct ledger infos with invalid progression, which is straightforward for a malicious validator.

## Recommendation

Add explicit extension validation in `guarded_sign_commit_vote()` to verify:

1. **Version progression**: Ensure the new version is greater than the ordered version (which should be 0)
2. **State root validity**: Ensure executed_state_id is not the placeholder hash
3. **Parent consistency**: Validate the version sequence relative to parent blocks

Suggested fix:

```rust
fn guarded_sign_commit_vote(
    &mut self,
    ledger_info: LedgerInfoWithSignatures,
    new_ledger_info: LedgerInfo,
) -> Result<bls12381::Signature, Error> {
    // ... existing checks ...

    // Extension check: verify version progression
    let old_version = old_ledger_info.commit_info().version();
    let new_version = new_ledger_info.commit_info().version();
    if new_version <= old_version {
        return Err(Error::InternalError(format!(
            "Commit ledger info version {} must be greater than ordered version {}",
            new_version, old_version
        )));
    }

    // Verify executed state is not placeholder
    if new_ledger_info.commit_info().executed_state_id() == *ACCUMULATOR_PLACEHOLDER_HASH {
        return Err(Error::InternalError(
            "Commit ledger info must have actual executed state, not placeholder".into()
        ));
    }

    // Verify ordered ledger info has placeholder (is ordered-only)
    if old_ledger_info.commit_info().executed_state_id() != *ACCUMULATOR_PLACEHOLDER_HASH {
        return Err(Error::InvalidOrderedLedgerInfo(
            "Ordered ledger info must have placeholder executed state".into()
        ));
    }

    let signature = self.sign(&new_ledger_info)?;
    Ok(signature)
}
```

## Proof of Concept

**Note:** This vulnerability requires validator-level access to fully exploit. However, the missing validation can be demonstrated:

```rust
#[test]
fn test_sign_commit_vote_missing_version_check() {
    // Setup safety rules and genesis
    let (mut safety_rules, signer) = constructor();
    let (proof, genesis_qc) = test_utils::make_genesis(&signer);
    safety_rules.initialize(&proof).unwrap();

    // Create a chain: genesis -- a1
    let round = genesis_qc.certified_block().round();
    let a1 = test_utils::make_proposal_with_qc(round + 1, genesis_qc, &signer);
    
    // Create ordered ledger info (with dummy execution)
    let ordered_ledger_info = LedgerInfoWithSignatures::new(
        LedgerInfo::new(
            a1.block().gen_block_info(
                *ACCUMULATOR_PLACEHOLDER_HASH,  // dummy state
                0,  // version = 0 (ordered-only)
                None
            ),
            HashValue::zero()
        ),
        test_utils::create_valid_signatures(&signer, /* 2f+1 validators */)
    );

    // Create malicious commit ledger info with version still at 0
    // This should be rejected but currently isn't due to missing extension check
    let malicious_commit = LedgerInfo::new(
        a1.block().gen_block_info(
            *ACCUMULATOR_PLACEHOLDER_HASH,  // Still placeholder!
            0,  // Still version 0 - no execution!
            None
        ),
        HashValue::zero()
    );

    // This SHOULD fail but currently SUCCEEDS due to missing extension check
    let result = safety_rules.sign_commit_vote(
        ordered_ledger_info,
        malicious_commit
    );
    
    // Currently passes - this is the vulnerability
    assert!(result.is_ok(), "Missing extension check allows signing commit without execution");
    
    // With proper validation, this should fail with version progression error
}
```

This test demonstrates that `sign_commit_vote()` will successfully sign a commit ledger info even when the version hasn't progressed and execution state is still a placeholder, violating the expectation that commit votes should only be signed after proper execution.

---

**Notes:**

After thorough analysis, while this is a legitimate security weakness explicitly documented in the code, it requires Byzantine validator behavior to exploit. According to the strict validation criteria requiring exploitation by "unprivileged attacker (no validator insider access required)", this vulnerability requires privileged validator access.

However, given that:
1. The missing validation is explicitly noted in production code (TODO comments)
2. It violates defense-in-depth principles for consensus safety
3. It could enable state inconsistencies if combined with other vulnerabilities
4. The fix is straightforward and should be implemented

This represents a legitimate security concern that should be addressed, even if it doesn't meet the strictest criteria for unprivileged exploitation.

### Citations

**File:** consensus/safety-rules/src/safety_rules.rs (L372-418)
```rust
    fn guarded_sign_commit_vote(
        &mut self,
        ledger_info: LedgerInfoWithSignatures,
        new_ledger_info: LedgerInfo,
    ) -> Result<bls12381::Signature, Error> {
        self.signer()?;

        let old_ledger_info = ledger_info.ledger_info();

        if !old_ledger_info.commit_info().is_ordered_only()
            // When doing fast forward sync, we pull the latest blocks and quorum certs from peers
            // and store them in storage. We then compute the root ordered cert and root commit cert
            // from storage and start the consensus from there. But given that we are not storing the
            // ordered cert obtained from order votes in storage, instead of obtaining the root ordered cert
            // from storage, we set root ordered cert to commit certificate.
            // This means, the root ordered cert will not have a dummy executed_state_id in this case.
            // To handle this, we do not raise error if the old_ledger_info.commit_info() matches with
            // new_ledger_info.commit_info().
            && old_ledger_info.commit_info() != new_ledger_info.commit_info()
        {
            return Err(Error::InvalidOrderedLedgerInfo(old_ledger_info.to_string()));
        }

        if !old_ledger_info
            .commit_info()
            .match_ordered_only(new_ledger_info.commit_info())
        {
            return Err(Error::InconsistentExecutionResult(
                old_ledger_info.commit_info().to_string(),
                new_ledger_info.commit_info().to_string(),
            ));
        }

        // Verify that ledger_info contains at least 2f + 1 dostinct signatures
        if !self.skip_sig_verify {
            ledger_info
                .verify_signatures(&self.epoch_state()?.verifier)
                .map_err(|error| Error::InvalidQuorumCertificate(error.to_string()))?;
        }

        // TODO: add guarding rules in unhappy path
        // TODO: add extension check

        let signature = self.sign(&new_ledger_info)?;

        Ok(signature)
    }
```

**File:** types/src/block_info.rs (L196-204)
```rust
    pub fn match_ordered_only(&self, executed_block_info: &BlockInfo) -> bool {
        self.epoch == executed_block_info.epoch
            && self.round == executed_block_info.round
            && self.id == executed_block_info.id
            && (self.timestamp_usecs == executed_block_info.timestamp_usecs
            // executed block info has changed its timestamp because it's a reconfiguration suffix
                || (self.timestamp_usecs > executed_block_info.timestamp_usecs
                    && executed_block_info.has_reconfiguration()))
    }
```
