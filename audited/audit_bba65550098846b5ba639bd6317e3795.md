# Audit Report

## Title
Inspection Service Lacks Access Logging Enabling Undetected Intelligence Gathering Against Validators

## Summary
The Aptos inspection service exposes sensitive validator operational data through multiple HTTP endpoints without implementing any access logging mechanism. This allows attackers to conduct prolonged reconnaissance campaigns against validators without detection, gathering intelligence about network topology, consensus health, and operational status to facilitate targeted attacks.

## Finding Description

The `serve_requests()` function in the inspection service handles all HTTP endpoint requests but implements no access logging for successful requests. [1](#0-0) 

The function only logs errors when response generation fails, providing no visibility into successful requests. This contrasts sharply with other Aptos services that implement comprehensive access logging with IP addresses, request paths, timestamps, and response statuses. [2](#0-1) 

The inspection service exposes highly sensitive validator information through multiple endpoints:

**1. Peer Information Endpoint** - Exposes complete validator network topology: [3](#0-2) 

This endpoint reveals validator set membership, peer connection states, trust relationships, state sync metadata, and internal client states.

**2. Identity Information Endpoint** - Exposes validator peer IDs: [4](#0-3) 

**3. Consensus Health Check Endpoint** - Exposes real-time consensus participation: [5](#0-4) 

**4. Metrics Endpoints** - Expose all internal operational metrics including consensus state, transaction processing rates, and network statistics.

**Attack Scenario:**

1. Attacker discovers a validator's inspection service endpoint (port 9101 directly or port 9102 via HAProxy)
2. Attacker writes a script to continuously poll sensitive endpoints every few seconds
3. Over hours/days, attacker builds comprehensive intelligence:
   - Complete map of validator network topology and trust relationships
   - Real-time consensus health status identifying degraded validators
   - Transaction processing patterns and performance metrics
   - Optimal timing windows for attacks (when validators are stressed)
4. Attacker uses this intelligence to orchestrate targeted attacks during vulnerable periods
5. **Critical Gap**: Without access logging at the service level, validator operators cannot detect the reconnaissance activity

While HAProxy may provide some logging, this creates a single point of failure: [6](#0-5) 

The network policy also allows direct access from monitoring and health-checker pods, potentially bypassing HAProxy: [7](#0-6) 

This violates the defense-in-depth security principle - the service itself should log access regardless of external infrastructure.

## Impact Explanation

This qualifies as **Medium severity** under the Aptos bug bounty criteria for the following reasons:

1. **Enables Attack Planning**: Intelligence gathering is a precursor to sophisticated attacks on validators, enabling attackers to maximize impact by timing attacks during vulnerable periods

2. **Operational Security Violation**: Prevents validator operators from detecting reconnaissance, making incident response and threat hunting impossible at the service level

3. **Facilitates Targeted Attacks**: Detailed network topology and consensus state information allows attackers to identify critical validators and orchestrate coordinated attacks

4. **Defense-in-Depth Violation**: Reliance on external logging infrastructure (HAProxy, Kubernetes) without service-level logging creates a single point of failure

While not directly causing loss of funds or consensus violations, this vulnerability significantly aids attackers in planning and executing higher-severity attacks against validators.

## Likelihood Explanation

This vulnerability has **HIGH likelihood** of exploitation:

1. **Easy to Exploit**: Requires only HTTP GET requests with no authentication
2. **Common Target**: Validators are high-value targets for reconnaissance
3. **Low Detection Risk**: Without logging, attackers face minimal risk of detection
4. **Standard Attack Pattern**: Intelligence gathering is a standard phase in sophisticated attacks
5. **Production Exposure**: The service defaults to binding on `0.0.0.0:9101`, making it accessible from any network interface unless protected by external firewalls [8](#0-7) 

The configuration shows most sensitive endpoints are enabled by default, particularly on non-mainnet deployments.

## Recommendation

Implement comprehensive access logging in the inspection service following the pattern used in the REST API service. The fix should:

1. **Log All Successful Requests** including:
   - Source IP address (from `remote_addr` and `Forwarded` header)
   - Requested endpoint path
   - HTTP method
   - Response status code
   - Timestamp and elapsed time
   - User-Agent header

2. **Log at Appropriate Severity Levels**:
   - INFO level for access to sensitive endpoints (`/peer_information`, `/identity_information`, `/consensus_health_check`)
   - DEBUG level for metrics endpoints
   - WARN level for repeated access from same IP within short timeframe

3. **Update Metrics** to track access patterns per endpoint

**Implementation Approach:**

Add a logging wrapper similar to the REST API's `middleware_log` function:

```rust
async fn serve_requests(
    req: Request<Body>,
    node_config: NodeConfig,
    aptos_data_client: AptosDataClient,
    peers_and_metadata: Arc<PeersAndMetadata>,
) -> Result<Response<Body>, hyper::Error> {
    let start = std::time::Instant::now();
    
    // Log request information
    let remote_addr = /* extract from connection */;
    let path = req.uri().path().to_string();
    let method = req.method().clone();
    let forwarded = req.headers()
        .get("Forwarded")
        .and_then(|v| v.to_str().ok().map(|v| v.to_string()));
    
    // Process request (existing logic)
    let (status_code, body, content_type) = match req.uri().path() {
        // ... existing endpoint routing ...
    };
    
    // Build response (existing logic)
    let response = /* ... */;
    
    // Log completed request
    let elapsed = start.elapsed();
    info!(
        remote_addr = ?remote_addr,
        forwarded = ?forwarded,
        method = %method,
        path = %path,
        status = status_code.as_u16(),
        elapsed_ms = elapsed.as_millis(),
        "Inspection service request"
    );
    
    Ok(response)
}
```

Additionally, consider:
- Adding rate limiting per source IP
- Implementing optional authentication for sensitive endpoints
- Adding alerting for unusual access patterns

## Proof of Concept

**Reconnaissance Script (Python):**

```python
#!/usr/bin/env python3
import requests
import time
import json
from datetime import datetime

# Target validator inspection service
VALIDATOR_IP = "validator.example.com"
INSPECTION_PORT = 9102  # or 9101 for direct access

BASE_URL = f"http://{VALIDATOR_IP}:{INSPECTION_PORT}"

def gather_intelligence():
    """Continuously gather intelligence from validator"""
    
    intelligence = {
        "start_time": datetime.now().isoformat(),
        "peer_snapshots": [],
        "consensus_health": [],
        "metrics": []
    }
    
    print(f"[*] Starting intelligence gathering against {BASE_URL}")
    print("[*] Press Ctrl+C to stop and save results")
    
    try:
        while True:
            timestamp = datetime.now().isoformat()
            
            # Gather peer information (network topology)
            try:
                resp = requests.get(f"{BASE_URL}/peer_information", timeout=5)
                if resp.status_code == 200:
                    intelligence["peer_snapshots"].append({
                        "timestamp": timestamp,
                        "data": resp.text
                    })
                    print(f"[+] {timestamp}: Captured peer topology")
            except Exception as e:
                print(f"[-] Peer info failed: {e}")
            
            # Check consensus health
            try:
                resp = requests.get(f"{BASE_URL}/consensus_health_check", timeout=5)
                intelligence["consensus_health"].append({
                    "timestamp": timestamp,
                    "status": resp.status_code,
                    "healthy": resp.status_code == 200
                })
                status = "HEALTHY" if resp.status_code == 200 else "DEGRADED"
                print(f"[+] {timestamp}: Consensus status: {status}")
            except Exception as e:
                print(f"[-] Health check failed: {e}")
            
            # Gather detailed metrics
            try:
                resp = requests.get(f"{BASE_URL}/json_metrics", timeout=5)
                if resp.status_code == 200:
                    intelligence["metrics"].append({
                        "timestamp": timestamp,
                        "metrics": resp.json()
                    })
                    print(f"[+] {timestamp}: Captured metrics snapshot")
            except Exception as e:
                print(f"[-] Metrics failed: {e}")
            
            # Wait before next poll (every 10 seconds)
            time.sleep(10)
            
    except KeyboardInterrupt:
        print("\n[*] Stopping intelligence gathering...")
        
        # Save gathered intelligence
        output_file = f"validator_intel_{int(time.time())}.json"
        with open(output_file, 'w') as f:
            json.dump(intelligence, f, indent=2)
        
        print(f"[+] Intelligence saved to {output_file}")
        
        # Analyze for attack opportunities
        analyze_intelligence(intelligence)

def analyze_intelligence(intel):
    """Analyze gathered intelligence for attack opportunities"""
    
    print("\n[*] INTELLIGENCE ANALYSIS:")
    print(f"[*] Collection duration: {len(intel['consensus_health']) * 10} seconds")
    
    # Find periods of consensus degradation
    degraded_periods = [
        h for h in intel['consensus_health'] 
        if not h.get('healthy', True)
    ]
    
    if degraded_periods:
        print(f"[!] Found {len(degraded_periods)} periods of consensus degradation")
        print("[!] OPTIMAL ATTACK WINDOW IDENTIFIED")
        for period in degraded_periods[:3]:  # Show first 3
            print(f"    - {period['timestamp']}")
    
    # Count peer topology snapshots
    print(f"[+] Captured {len(intel['peer_snapshots'])} network topology snapshots")
    print(f"[+] Captured {len(intel['metrics'])} detailed metrics snapshots")
    
    print("\n[!] This reconnaissance was UNDETECTED due to lack of access logging")
    print("[!] Validator operator has NO VISIBILITY into this intelligence gathering")

if __name__ == "__main__":
    gather_intelligence()
```

**Demonstration:**

Run the script against a validator's inspection service:
```bash
python3 reconnaissance.py
```

Expected output:
```
[*] Starting intelligence gathering against http://validator.example.com:9102
[*] Press Ctrl+C to stop and save results
[+] 2024-01-15T10:00:00: Captured peer topology
[+] 2024-01-15T10:00:00: Consensus status: HEALTHY
[+] 2024-01-15T10:00:00: Captured metrics snapshot
[+] 2024-01-15T10:00:10: Captured peer topology
[+] 2024-01-15T10:00:10: Consensus status: DEGRADED
...
```

**Critical Point**: Check validator logs after running this script. The inspection service will have NO LOG ENTRIES for these reconnaissance requests, demonstrating the complete lack of visibility into access patterns. Only HAProxy (if configured) would have generic HTTP logs, which are often not actively monitored for access patterns to specific endpoints.

## Notes

The comparison with the admin service is particularly revealing - the admin service implements authentication and would be more likely to be protected: [9](#0-8) 

The inspection service, despite exposing similarly sensitive operational data, has no such protections and no access logging, creating a significant security gap in validator operational security monitoring.

### Citations

**File:** crates/aptos-inspection-service/src/server/mod.rs (L104-198)
```rust
async fn serve_requests(
    req: Request<Body>,
    node_config: NodeConfig,
    aptos_data_client: AptosDataClient,
    peers_and_metadata: Arc<PeersAndMetadata>,
) -> Result<Response<Body>, hyper::Error> {
    // Process the request and get the response components
    let (status_code, body, content_type) = match req.uri().path() {
        CONFIGURATION_PATH => {
            // /configuration
            // Exposes the node configuration
            configuration::handle_configuration_request(&node_config)
        },
        CONSENSUS_HEALTH_CHECK_PATH => {
            // /consensus_health_check
            // Exposes the consensus health check
            metrics::handle_consensus_health_check(&node_config).await
        },
        FORGE_METRICS_PATH => {
            // /forge_metrics
            // Exposes forge encoded metrics
            metrics::handle_forge_metrics()
        },
        IDENTITY_INFORMATION_PATH => {
            // /identity_information
            // Exposes the identity information of the node
            identity_information::handle_identity_information_request(&node_config)
        },
        INDEX_PATH => {
            // /
            // Exposes the index and list of available endpoints
            index::handle_index_request()
        },
        JSON_METRICS_PATH => {
            // /json_metrics
            // Exposes JSON encoded metrics
            metrics::handle_json_metrics_request()
        },
        METRICS_PATH => {
            // /metrics
            // Exposes text encoded metrics
            metrics::handle_metrics_request()
        },
        PEER_INFORMATION_PATH => {
            // /peer_information
            // Exposes the peer information
            peer_information::handle_peer_information_request(
                &node_config,
                aptos_data_client,
                peers_and_metadata,
            )
        },
        SYSTEM_INFORMATION_PATH => {
            // /system_information
            // Exposes the system and build information
            system_information::handle_system_information_request(node_config)
        },
        _ => {
            // Handle the invalid path
            (
                StatusCode::NOT_FOUND,
                Body::from(INVALID_ENDPOINT_MESSAGE),
                CONTENT_TYPE_TEXT.into(),
            )
        },
    };

    // Create a response builder
    let response_builder = Response::builder()
        .header(HEADER_CONTENT_TYPE, content_type)
        .status(status_code);

    // Build the response based on the request methods
    let response = match *req.method() {
        Method::HEAD => response_builder.body(Body::empty()), // Return only the headers
        Method::GET => response_builder.body(body),           // Include the response body
        _ => {
            // Invalid method found
            Response::builder()
                .status(StatusCode::METHOD_NOT_ALLOWED)
                .body(Body::empty())
        },
    };

    // Return the processed response
    Ok(response.unwrap_or_else(|error| {
        // Log the internal error
        debug!("Error encountered when generating response: {:?}", error);

        // Return a failure response
        let mut response = Response::new(Body::from(UNEXPECTED_ERROR_MESSAGE));
        *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
        response
    }))
}
```

**File:** api/src/log.rs (L54-102)
```rust
pub async fn middleware_log<E: Endpoint>(next: E, request: Request) -> Result<Response> {
    let start = std::time::Instant::now();

    let (trace_id, span_id) = extract_trace_context(&request);

    let mut log = HttpRequestLog {
        remote_addr: request.remote_addr().as_socket_addr().cloned(),
        method: request.method().clone(),
        path: request.uri().path().to_string(),
        status: 0,
        referer: request
            .headers()
            .get(header::REFERER)
            .and_then(|v| v.to_str().ok().map(|v| v.to_string())),
        user_agent: request
            .headers()
            .get(header::USER_AGENT)
            .and_then(|v| v.to_str().ok().map(|v| v.to_string())),
        aptos_client: request
            .headers()
            .get(X_APTOS_CLIENT)
            .and_then(|v| v.to_str().ok().map(|v| v.to_string())),
        elapsed: Duration::from_secs(0),
        forwarded: request
            .headers()
            .get(header::FORWARDED)
            .and_then(|v| v.to_str().ok().map(|v| v.to_string())),
        content_length: request
            .headers()
            .get(header::CONTENT_LENGTH)
            .and_then(|v| v.to_str().ok().map(|v| v.to_string())),
        trace_id,
        span_id,
    };

    let response = next.get_response(request).await;

    let elapsed = start.elapsed();

    log.status = response.status().as_u16();
    log.elapsed = elapsed;

    if log.status >= 500 {
        sample!(SampleRate::Duration(Duration::from_secs(1)), warn!(log));
    } else if log.status >= 400 {
        sample!(SampleRate::Duration(Duration::from_secs(60)), info!(log));
    } else {
        sample!(SampleRate::Duration(Duration::from_secs(1)), debug!(log));
    }
```

**File:** crates/aptos-inspection-service/src/server/peer_information.rs (L21-106)
```rust
pub fn handle_peer_information_request(
    node_config: &NodeConfig,
    aptos_data_client: AptosDataClient,
    peers_and_metadata: Arc<PeersAndMetadata>,
) -> (StatusCode, Body, String) {
    // Only return peer information if the endpoint is enabled
    let (status_code, body) = if node_config.inspection_service.expose_peer_information {
        let peer_information = get_peer_information(aptos_data_client, peers_and_metadata);
        (StatusCode::OK, Body::from(peer_information))
    } else {
        (
            StatusCode::FORBIDDEN,
            Body::from(PEER_INFO_DISABLED_MESSAGE),
        )
    };

    (status_code, body, CONTENT_TYPE_TEXT.into())
}

/// Returns a simple text formatted string with peer and network information
fn get_peer_information(
    aptos_data_client: AptosDataClient,
    peers_and_metadata: Arc<PeersAndMetadata>,
) -> String {
    // Get all registered networks
    let registered_networks: Vec<NetworkId> =
        peers_and_metadata.get_registered_networks().collect();

    // Get all peers (sorted by peer ID)
    let mut all_peers = peers_and_metadata.get_all_peers();
    all_peers.sort();

    // Display a summary of all peers and networks
    let mut peer_information_output = Vec::<String>::new();
    display_peer_information_summary(
        &mut peer_information_output,
        &all_peers,
        &registered_networks,
    );
    peer_information_output.push("\n".into());

    // Display connection metadata for each peer
    display_peer_connection_metadata(
        &mut peer_information_output,
        &all_peers,
        peers_and_metadata.deref(),
    );
    peer_information_output.push("\n".into());

    // Display the entire set of trusted peers
    display_trusted_peers(
        &mut peer_information_output,
        registered_networks,
        peers_and_metadata.deref(),
    );
    peer_information_output.push("\n".into());

    // Display basic peer metadata for each peer
    display_peer_monitoring_metadata(
        &mut peer_information_output,
        &all_peers,
        peers_and_metadata.deref(),
    );
    peer_information_output.push("\n".into());

    // Display state sync metadata for each peer
    display_state_sync_metadata(&mut peer_information_output, &all_peers, aptos_data_client);
    peer_information_output.push("\n".into());

    // Display detailed peer metadata for each peer
    display_detailed_monitoring_metadata(
        &mut peer_information_output,
        &all_peers,
        peers_and_metadata.deref(),
    );
    peer_information_output.push("\n".into());

    // Display the internal client state for each peer
    display_internal_client_state(
        &mut peer_information_output,
        &all_peers,
        peers_and_metadata.deref(),
    );

    peer_information_output.join("\n") // Separate each entry with a newline to construct the output
}
```

**File:** crates/aptos-inspection-service/src/server/identity_information.rs (L13-52)
```rust
pub fn handle_identity_information_request(node_config: &NodeConfig) -> (StatusCode, Body, String) {
    // Only return identity information if the endpoint is enabled
    let (status_code, body) = if node_config.inspection_service.expose_identity_information {
        let identity_information = get_identity_information(node_config);
        (StatusCode::OK, Body::from(identity_information))
    } else {
        (
            StatusCode::FORBIDDEN,
            Body::from(IDENTITY_INFO_DISABLED_MESSAGE),
        )
    };

    (status_code, body, CONTENT_TYPE_TEXT.into())
}

/// Returns a simple text formatted string with identity information
fn get_identity_information(node_config: &NodeConfig) -> String {
    let mut identity_information = Vec::<String>::new();
    identity_information.push("Identity Information:".into());

    // If the validator network is configured, fetch the identity information
    if let Some(validator_network) = &node_config.validator_network {
        identity_information.push(format!(
            "\t- Validator network ({}), peer ID: {}",
            validator_network.network_id,
            validator_network.peer_id()
        ));
    }

    // For each fullnode network, fetch the identity information
    for fullnode_network in &node_config.full_node_networks {
        identity_information.push(format!(
            "\t- Fullnode network ({}), peer ID: {}",
            fullnode_network.network_id,
            fullnode_network.peer_id()
        ));
    }

    identity_information.join("\n") // Separate each entry with a newline to construct the output
}
```

**File:** crates/aptos-inspection-service/src/server/metrics.rs (L16-48)
```rust
/// Handles a consensus health check request. This method returns
/// 200 if the node is currently participating in consensus.
///
/// Note: we assume that this endpoint will only be used every few seconds.
pub async fn handle_consensus_health_check(node_config: &NodeConfig) -> (StatusCode, Body, String) {
    // Verify the node is a validator. If not, return an error.
    if !node_config.base.role.is_validator() {
        return (
            StatusCode::BAD_REQUEST,
            Body::from("This node is not a validator!"),
            CONTENT_TYPE_TEXT.into(),
        );
    }

    // Check the value of the consensus execution gauge
    let metrics = utils::get_all_metrics();
    if let Some(gauge_value) = metrics.get(CONSENSUS_EXECUTION_GAUGE) {
        if gauge_value == "1" {
            return (
                StatusCode::OK,
                Body::from("Consensus health check passed!"),
                CONTENT_TYPE_TEXT.into(),
            );
        }
    }

    // Otherwise, consensus is not executing
    (
        StatusCode::INTERNAL_SERVER_ERROR,
        Body::from("Consensus health check failed! Consensus is not executing!"),
        CONTENT_TYPE_TEXT.into(),
    )
}
```

**File:** terraform/helm/aptos-node/files/haproxy.cfg (L4-26)
```text
## Global settings
global
    # Specify the stdout log format and size
    log stdout len 10240 format raw local0

    # Limit the maximum number of connections to 500 (this is ~5x the validator set size)
    maxconn 500

    # Limit the maximum number of connections per second to 300 (this is ~3x the validator set size)
    maxconnrate 300

    # Limit user privileges
    user {{ $.Values.haproxy.config.user }}

## Default settings
defaults
    # Enable logging of events and traffic
    log global

    # Set the default mode to TCP
    mode tcp
    log-format "%ci:%cp [%t] %ft %b/%s %Tw/%Tc/%Tt %B %ts %ac/%fc/%bc/%sc/%rc %sq/%bq"

```

**File:** terraform/helm/aptos-node/templates/networkpolicy.yaml (L38-56)
```yaml
  # Monitoring metrics port
  - from:
    - namespaceSelector: {}
    - podSelector:
        matchLabels:
          app.kubernetes.io/name: monitoring
    ports:
    - protocol: TCP
      port: 9101
  # Node Health Checker accesses these ports
  - from:
    - namespaceSelector: {}
    - podSelector:
        matchLabels:
          app.kubernetes.io/name: node-health-checker
    ports:
    - protocol: TCP
      port: 9101
    - protocol: TCP
```

**File:** config/src/config/inspection_service_config.rs (L26-37)
```rust
impl Default for InspectionServiceConfig {
    fn default() -> InspectionServiceConfig {
        InspectionServiceConfig {
            address: "0.0.0.0".to_string(),
            port: 9101,
            expose_configuration: false,
            expose_identity_information: true,
            expose_peer_information: true,
            expose_system_information: true,
        }
    }
}
```

**File:** crates/aptos-admin-service/src/server/mod.rs (L154-181)
```rust
        let mut authenticated = false;
        if context.config.authentication_configs.is_empty() {
            authenticated = true;
        } else {
            for authentication_config in &context.config.authentication_configs {
                match authentication_config {
                    AuthenticationConfig::PasscodeSha256(passcode_sha256) => {
                        let query = req.uri().query().unwrap_or("");
                        let query_pairs: HashMap<_, _> =
                            url::form_urlencoded::parse(query.as_bytes()).collect();
                        let passcode: Option<String> =
                            query_pairs.get("passcode").map(|p| p.to_string());
                        if let Some(passcode) = passcode {
                            if sha256::digest(passcode) == *passcode_sha256 {
                                authenticated = true;
                            }
                        }
                    },
                }
            }
        };

        if !authenticated {
            return Ok(reply_with_status(
                StatusCode::NETWORK_AUTHENTICATION_REQUIRED,
                format!("{} endpoint requires authentication.", req.uri().path()),
            ));
        }
```
