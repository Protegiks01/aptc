# Audit Report

## Title
Chain ID Spoofing in Telemetry Service Validator Cache Allows Cross-Chain Validator Set Confusion

## Summary
The `update_for_chain()` function in the telemetry service's validator cache updater does not validate that the chain_id returned from a REST API endpoint matches the expected chain_id for the configured chain name. This allows a malicious or compromised REST API endpoint to cause validator sets from one chain to overwrite another chain's cache entry, leading to authentication failures.

## Finding Description

The vulnerability exists in the validator cache update mechanism: [1](#0-0) 

The function accepts a `chain_name` parameter (e.g., "mainnet", "testnet") and queries the configured REST API URL to fetch the validator set. However, it extracts the `chain_id` directly from the API response headers without validating it matches the expected chain_id for that chain name: [2](#0-1) 

The extracted `chain_id` is then used as the key when storing validator sets in the cache: [3](#0-2) 

**Attack Scenario:**
1. Telemetry service is configured with trusted REST endpoints mapping chain names to URLs: [4](#0-3) 

2. An attacker controls or compromises one REST endpoint (e.g., via misconfiguration, DNS poisoning, or endpoint compromise)

3. The malicious endpoint returns a ValidatorSet with chain_id=1 (mainnet) in response headers, but when queried for "testnet" configuration

4. The validator cache stores this data under chain_id=1, overwriting the legitimate mainnet validator set

5. When validators attempt to authenticate, they query by chain_id: [5](#0-4) 

6. Mainnet validators now fail authentication because the cache contains testnet validators under chain_id=1, causing `ValidatorSetUnavailable` or public key mismatch errors: [6](#0-5) 

## Impact Explanation

This vulnerability does **NOT** meet **Critical** severity criteria. After thorough analysis:

- **No consensus impact**: The telemetry service is separate from the consensus layer and does not participate in block production or validation
- **No funds at risk**: This is a metrics/logging service with no access to funds or state transitions
- **No network availability impact**: Validators can operate normally without telemetry service authentication
- **Limited scope**: Only affects telemetry data collection, not blockchain operations

**Actual Severity: High** - This qualifies as "API crashes" and "significant protocol violations" within the telemetry service itself. It causes:
- Denial of service for legitimate validator telemetry reporting
- Cross-chain authentication confusion
- Operational monitoring blind spots

The claim of "Critical" severity in the question is **incorrect** based on Aptos bug bounty criteria.

## Likelihood Explanation

**Medium likelihood** - Requires one of:
- Operator misconfiguration (pointing to malicious/wrong endpoint)
- DNS poisoning or man-in-the-middle attack on REST API calls
- Compromise of a trusted full node REST endpoint

While feasible, these scenarios require either operational errors or active network-level attacks, making it less likely than pure logic bugs.

## Recommendation

Add chain_id validation in the `update_for_chain()` function:

```rust
async fn update_for_chain(
    &self,
    chain_name: &ChainCommonName,
    url: &str,
    expected_chain_id: ChainId, // Add this parameter
) -> Result<(), ValidatorCacheUpdateError> {
    // ... existing code ...
    
    let chain_id = ChainId::new(state.chain_id);
    
    // Validate chain_id matches expected
    if chain_id != expected_chain_id {
        error!(
            "Chain ID mismatch for {}: expected {}, got {}",
            chain_name, expected_chain_id, chain_id
        );
        return Err(ValidatorCacheUpdateError::ChainIdMismatch);
    }
    
    // ... rest of function ...
}
```

Update configuration to include expected chain_id mappings alongside URLs, and pass the expected_chain_id to the update function.

## Proof of Concept

```rust
#[tokio::test]
async fn test_chain_id_spoofing_attack() {
    let mut rng = OsRng;
    let keypair = KeyPair::<PrivateKey, PublicKey>::generate(&mut rng);
    let validator_info = ValidatorInfo::new(
        PeerId::random(),
        10,
        ValidatorConfig::new(/* ... valid addresses ... */),
    );
    let validator_set = ValidatorSet::new(vec![validator_info]);

    // Malicious server configured for "testnet" but returns mainnet chain_id
    let server = MockServer::start();
    server.mock(|when, then| {
        when.method("GET").path("/v1/accounts/0x1/resource/0x1::stake::ValidatorSet");
        then.status(200)
            .body(bcs::to_bytes(&validator_set).unwrap())
            .header(X_APTOS_CHAIN_ID, "1") // Spoofed mainnet chain_id!
            .header(X_APTOS_EPOCH, "10")
            .header(X_APTOS_LEDGER_VERSION, "10");
    });

    let mut fullnodes = HashMap::new();
    fullnodes.insert("testnet".into(), server.base_url());

    let updater = PeerSetCacheUpdater::new(
        Arc::new(RwLock::new(HashMap::new())),
        Arc::new(RwLock::new(HashMap::new())),
        fullnodes,
        Duration::from_secs(10),
    );

    updater.update().await;

    // Validator set is now stored under chain_id 1 (mainnet) instead of 2 (testnet)
    assert!(updater.validators.read().contains_key(&ChainId::new(1)));
    assert!(!updater.validators.read().contains_key(&ChainId::new(2)));
}
```

## Notes

While this vulnerability is **valid and exploitable**, it does **NOT** meet the claimed "Critical" severity. The telemetry service is an auxiliary monitoring component, not part of the core consensus, execution, or state management layers. Validators continue operating normally without telemetry authentication. This should be classified as **High severity** at most, addressing operational security and service availability concerns rather than critical blockchain invariant violations.

### Citations

**File:** crates/aptos-telemetry-service/src/validator_cache.rs (L86-102)
```rust
    async fn update_for_chain(
        &self,
        chain_name: &ChainCommonName,
        url: &str,
    ) -> Result<(), ValidatorCacheUpdateError> {
        let client = aptos_rest_client::Client::new(Url::parse(url).map_err(|e| {
            error!("invalid url for chain_id {}: {}", chain_name, e);
            ValidatorCacheUpdateError::InvalidUrl
        })?);
        let response: Response<ValidatorSet> = client
            .get_account_resource_bcs(CORE_CODE_ADDRESS, "0x1::stake::ValidatorSet")
            .await
            .map_err(ValidatorCacheUpdateError::RestError)?;

        let (peer_addrs, state) = response.into_parts();

        let chain_id = ChainId::new(state.chain_id);
```

**File:** crates/aptos-telemetry-service/src/validator_cache.rs (L176-176)
```rust
            validator_cache.insert(chain_id, (state.epoch, validator_peers));
```

**File:** crates/aptos-telemetry-service/e2e-test/telemetry-config.yaml (L10-13)
```yaml
trusted_full_node_addresses:
  mainnet: "https://api.mainnet.aptoslabs.com"
  testnet: "https://api.testnet.aptoslabs.com"
  devnet: "https://api.devnet.aptoslabs.com"
```

**File:** crates/aptos-telemetry-service/src/auth.rs (L72-72)
```rust
    let (epoch, peer_role) = match cache.read().get(&body.chain_id) {
```

**File:** crates/aptos-telemetry-service/src/errors.rs (L26-27)
```rust
    #[error("validator set unavailable for chain")]
    ValidatorSetUnavailable,
```
