# Audit Report

## Title
Missing Block Epilogue Execution in Sharded Block Executor Causes Fee Distribution Failure

## Summary
The sharded block execution path discards the block epilogue transaction by calling `into_transaction_outputs_forced()`, resulting in validator fee distributions never being processed. This breaks the validator reward mechanism and creates potential for consensus divergence if nodes use different execution modes.

## Finding Description

The vulnerability exists in how sharded execution handles block epilogue transactions. In normal (unsharded) execution, blocks generate and execute a block epilogue transaction that distributes transaction fees to validators. However, the sharded execution path systematically drops this epilogue transaction. [1](#0-0) 

The sharded executor passes `TransactionSliceMetadata::unknown()` which prevents epilogue generation: [2](#0-1) 

Even if an epilogue were generated, `into_transaction_outputs_forced()` discards it: [3](#0-2) 

In contrast, the unsharded path properly handles the epilogue: [4](#0-3) 

The block epilogue calculates and distributes fees to validators based on which validator proposed each transaction: [5](#0-4) 

The acknowledgment of this issue exists in a TODO comment: [6](#0-5) 

## Impact Explanation

This issue violates **Critical Invariant #6** (Validator rewards must be calculated correctly) and **Invariant #1** (Deterministic Execution).

**However**, the current severity is limited because:

1. Comments in the codebase indicate sharded execution is "only for benchmark purpose right now": [7](#0-6) 

2. No evidence exists of consensus using sharded execution in production
3. The TODO comment indicates developers are aware of the missing implementation

**IF sharded execution were enabled in production consensus**, this would be **CRITICAL severity** because:
- Validators would not receive transaction fee rewards
- Mixed execution modes would cause consensus divergence and chain splits
- State roots would differ between nodes using different execution modes

## Likelihood Explanation

**Current Likelihood: Very Low** - Sharded execution appears to be disabled in production consensus and used only for benchmarking.

**Future Risk: High** - If sharded execution is enabled without addressing this issue, the impact would be immediate and severe.

## Recommendation

Before enabling sharded execution in production, the block epilogue must be properly generated and executed. The fix requires:

1. Pass proper `TransactionSliceMetadata::Block` to sharded executor instead of `Unknown`
2. Modify sharded execution to return `BlockOutput` instead of `Vec<TransactionOutput>`
3. Ensure epilogue transaction is executed after all sharded transactions complete
4. Aggregate fee information across all shards before generating the epilogue

The TODO comment at line 203 of `do_get_execution_output.rs` must be addressed before production deployment.

## Proof of Concept

```rust
// This would demonstrate the issue if sharded execution were enabled:
// 1. Configure node with --num-executor-shards > 1
// 2. Submit block with user transactions that pay fees
// 3. Execute block using sharded path
// 4. Observe that block epilogue transaction is missing from final output
// 5. Verify validator fee distribution did not occur
// 6. Compare state root with unsharded execution - they will differ
```

## Notes

**This is NOT currently an exploitable vulnerability** because:
- Sharded execution is not used in production consensus
- No attack vector exists for unprivileged actors to force sharded execution
- Developers are aware (TODO comment exists)

This represents an **incomplete feature implementation** that must be completed before sharded execution can be safely enabled in production. The question asks about "shard synchronization issues or missing cross-shard fee distributions" - the actual issue is more fundamental: the **entire fee distribution mechanism is bypassed**, not just cross-shard coordination.

### Citations

**File:** aptos-move/aptos-vm/src/sharded_block_executor/sharded_executor_service.rs (L153-156)
```rust
                    TransactionSliceMetadata::unknown(),
                    cross_shard_commit_sender,
                )
                .map(BlockOutput::into_transaction_outputs_forced);
```

**File:** types/src/block_executor/transaction_slice_metadata.rs (L49-57)
```rust
    pub fn append_state_checkpoint_to_block(&self) -> Option<HashValue> {
        use TransactionSliceMetadata::*;

        match self {
            Unknown => None,
            Block { child, .. } => Some(*child),
            Chunk { .. } => None,
        }
    }
```

**File:** types/src/transaction/block_output.rs (L31-33)
```rust
    pub fn into_transaction_outputs_forced(self) -> Vec<Output> {
        self.transaction_outputs
    }
```

**File:** execution/executor/src/workflow/do_get_execution_output.rs (L123-146)
```rust
        let (mut transaction_outputs, block_epilogue_txn) = block_output.into_inner();
        let (transactions, mut auxiliary_infos) = txn_provider.into_inner();
        let mut transactions = transactions
            .into_iter()
            .map(|t| t.into_inner())
            .collect_vec();
        if let Some(block_epilogue_txn) = block_epilogue_txn {
            transactions.push(block_epilogue_txn.into_inner());

            // Check if all existing auxiliary infos are None to maintain consistency
            let all_auxiliary_infos_are_none = auxiliary_infos
                .iter()
                .all(|info| matches!(info.persisted_info(), PersistedAuxiliaryInfo::None));

            let block_epilogue_aux_info = if all_auxiliary_infos_are_none {
                // If all other auxiliary infos are None, use None for consistency (version 0 behavior)
                AuxiliaryInfo::new(PersistedAuxiliaryInfo::None, None)
            } else {
                // Otherwise, use the standard function (version 1 behavior)
                AuxiliaryInfo::auxiliary_info_at_txn_index(transactions.len() as u32 - 1)
            };

            auxiliary_infos.push(block_epilogue_aux_info);
        }
```

**File:** execution/executor/src/workflow/do_get_execution_output.rs (L203-203)
```rust
        // TODO(Manu): Handle state checkpoint here.
```

**File:** aptos-move/block-executor/src/executor.rs (L2042-2084)
```rust
        for (i, output) in outputs.enumerate().take(epilogue_txn_idx as usize) {
            // TODO(grao): Also include other transactions that is "Keep" if we are confident
            // that we successfully charge enough gas amount as it appears in the FeeStatement
            // for every corner cases.
            if !output.is_materialized_and_success() {
                continue;
            }
            let output_after_guard = output.after_materialization()?;
            let fee_statement = output_after_guard.fee_statement();

            let txn = signature_verified_block.get_txn(i as TxnIndex);
            if let Some(user_txn) = txn.try_as_signed_user_txn() {
                let auxiliary_info = signature_verified_block.get_auxiliary_info(i as TxnIndex);
                if let Some(proposer_index) = auxiliary_info.proposer_index() {
                    let gas_price = user_txn.gas_unit_price();
                    let total_gas_unit = fee_statement.gas_used();
                    // Total gas unit here includes the storage fee (deposit), which is not
                    // available for distribution. Only the execution gas and IO gas are available
                    // to distribute. Note here we deliberately NOT use the execution gas and IO
                    // gas value from the fee statement, because they might round up during the
                    // calculation and the sum of them could be larger than the actual value we
                    // burn. Instead we use the total amount (which is the total we've burnt)
                    // minus the storage deposit (round up), to avoid over distribution.
                    // We burn a fix amount of gas per gas unit.
                    let gas_price_to_burn = self.config.onchain.gas_price_to_burn();
                    if gas_price > gas_price_to_burn {
                        let gas_unit_available_to_distribute = total_gas_unit
                            .saturating_sub(fee_statement.storage_fee_used().div_ceil(gas_price));
                        if gas_unit_available_to_distribute > 0 {
                            let fee_to_distribute =
                                gas_unit_available_to_distribute * (gas_price - gas_price_to_burn);
                            *amount.entry(proposer_index).or_insert(0) += fee_to_distribute;
                        }
                    }
                }
            }
        }
        Ok(T::block_epilogue_v1(
            block_id,
            block_end_info,
            FeeDistribution::new(amount),
        ))
    }
```

**File:** types/src/block_executor/partitioner.rs (L449-454)
```rust
            ExecutableTransactions::Sharded(_) => {
                // Not supporting auxiliary info here because the sharded executor is only for
                // benchmark purpose right now.
                // TODO: Revisit when we need it.
                assert!(auxiliary_info.is_empty());
            },
```
