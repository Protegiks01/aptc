# Audit Report

## Title
Reverse Proxy Misconfiguration Enables Complete Bypass of IP-Based Security Controls in Aptos Faucet

## Summary
When the Aptos faucet is deployed behind a misconfigured reverse proxy that fails to forward client IP headers, Poem's `RealIp` extractor falls back to the proxy's IP address, causing all client requests to appear as originating from the same IP. This systematically breaks all IP-based security controls including rate limiting, IP blocklists, and IP allowlists, enabling denial of service and potential fund drainage attacks.

## Finding Description

The Aptos faucet implements IP-based security controls for rate limiting and access control. These controls depend on accurately extracting the client's real IP address from HTTP requests. [1](#0-0) 

The `RealIp` extractor from the Poem framework checks HTTP headers like `X-Forwarded-For`, `X-Real-IP`, and `Forwarded` to determine the client's real IP address. When these headers are absent (due to proxy misconfiguration), the extractor falls back to the direct TCP connection's peer address—which is the reverse proxy's IP, not the client's IP. [2](#0-1) 

While the code checks if `RealIp` returns `None` and rejects such requests, this check is insufficient. In the misconfiguration scenario, `RealIp` returns `Some(proxy_ip)` rather than `None`, because there IS a valid IP address (the proxy's). The validation passes, but all requests now share the same `source_ip` value. [3](#0-2) 

This shared IP address breaks multiple security controls:

**1. Rate Limiting Bypass:** [4](#0-3) 

All clients share the same rate limit counter. Once ANY user exhausts the daily limit, ALL users are blocked globally. Conversely, attackers can coordinate to rapidly exhaust the limit, causing denial of service for all legitimate users.

**2. Redis Rate Limiting Bypass:** [5](#0-4) 

The Redis-based rate limiter uses IP as the key. With all requests sharing the proxy's IP, the rate limit becomes global across all clients instead of per-client.

**3. IP Blocklist Failure:** [6](#0-5) 

IP blocklists cannot block specific malicious clients since all clients appear as the same IP. Either everyone is blocked or no one is blocked.

**4. IP Allowlist Bypass:** [7](#0-6) 

If the proxy's IP is in the allowlist, all clients bypass security checks. If it's not, all legitimate clients are blocked.

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos bug bounty program criteria:

1. **API Service Disruption**: The faucet API becomes effectively unusable once the shared rate limit is exhausted. This is a significant protocol violation affecting service availability.

2. **Security Control Bypass**: All IP-based security mechanisms are rendered ineffective, allowing malicious actors to operate without proper rate limiting or access control.

3. **Fund Drainage Risk**: If rate limits are bypassed or ineffective, attackers can more rapidly drain faucet funds intended for legitimate users.

4. **Production Deployment Risk**: Reverse proxy misconfigurations are common in production environments, making this a realistic attack vector that could occur without malicious intent.

While this doesn't directly affect blockchain consensus or validator operations, it represents a significant failure of the faucet service's security model, which is a critical auxiliary service for the Aptos ecosystem.

## Likelihood Explanation

**Likelihood: HIGH**

This vulnerability is highly likely to occur because:

1. **Common Misconfiguration**: Reverse proxies (Nginx, HAProxy, AWS ALB, CloudFlare) must be explicitly configured to forward client IP headers. Default configurations often don't include these headers or use non-standard header names.

2. **No Detection Mechanism**: The faucet code has no validation to detect when IP extraction has failed to get the real client IP. It silently accepts the proxy IP as legitimate.

3. **Multiple Deployment Scenarios**: Any deployment behind a load balancer, CDN, or reverse proxy is susceptible if the forwarding configuration is incomplete.

4. **No Warning or Logging**: The system doesn't log warnings when all requests appear to originate from the same IP, making the misconfiguration difficult to detect until service degradation occurs.

## Recommendation

Implement multi-layered defense against proxy misconfiguration:

**1. Add Trusted Proxy Configuration:**
Add a configuration option to specify trusted proxy IP addresses and require specific headers when requests come from those IPs. Reject requests from trusted proxies that lack proper forwarding headers.

**2. Implement IP Extraction Validation:**
```rust
// In fund.rs preprocess_request function, add after line 225:
fn validate_source_ip(source_ip: IpAddr, header_map: &HeaderMap) -> Result<(), AptosTapError> {
    // Check if IP is a known proxy/private IP
    if is_private_or_proxy_ip(&source_ip) {
        // Require that proper forwarding headers were present
        if !header_map.contains_key("x-forwarded-for") 
            && !header_map.contains_key("x-real-ip")
            && !header_map.contains_key("forwarded") {
            return Err(AptosTapError::new(
                "Request from proxy without forwarding headers".to_string(),
                AptosTapErrorCode::InvalidRequest,
            ));
        }
    }
    Ok(())
}
```

**3. Add Monitoring and Alerting:**
Implement metrics to track unique source IPs per time window. Alert when 99%+ of requests share the same IP, indicating potential misconfiguration.

**4. Add Fallback Identification:**
When proper IP extraction fails, use alternative identification methods such as:
- Require authentication tokens for all requests
- Use browser fingerprinting
- Implement challenge-response mechanisms

**5. Document Deployment Requirements:**
Create explicit documentation for operators specifying required reverse proxy configurations and how to validate proper IP forwarding.

## Proof of Concept

```rust
// Integration test demonstrating the vulnerability
#[tokio::test]
async fn test_proxy_misconfiguration_breaks_ratelimit() {
    // Setup faucet with rate limit of 3 requests per day per IP
    let config = include_str!("../configs/testing_redis.yaml");
    let (port, _handle) = start_server(config).await.unwrap();
    
    // Simulate requests coming through misconfigured proxy
    // All requests will have the same source IP (127.0.0.1)
    // because no X-Forwarded-For headers are sent
    
    let client = reqwest::Client::new();
    
    // First 3 requests from "different clients" should succeed
    // but will all count against the same IP's rate limit
    for i in 0..3 {
        let resp = client
            .post(format!("http://127.0.0.1:{}/fund", port))
            .json(&FundRequest {
                amount: Some(100),
                address: Some(AccountAddress::random().to_string()),
                ..Default::default()
            })
            .send()
            .await
            .unwrap();
        assert_eq!(resp.status(), 200, "Request {} should succeed", i);
    }
    
    // Fourth request from a "different client" fails
    // because they all share the same rate limit counter
    let resp = client
        .post(format!("http://127.0.0.1:{}/fund", port))
        .json(&FundRequest {
            amount: Some(100),
            address: Some(AccountAddress::random().to_string()),
            ..Default::default()
        })
        .send()
        .await
        .unwrap();
    
    // This demonstrates ALL users are now blocked globally
    assert_eq!(resp.status(), 429); // Too Many Requests
    
    // Verify the error indicates rate limit exhaustion
    let error: AptosTapError = resp.json().await.unwrap();
    assert!(error.rejection_reasons
        .iter()
        .any(|r| r.get_code() == RejectionReasonCode::UsageLimitExhausted));
}
```

## Notes

This vulnerability is particularly insidious because:

1. It can occur through operator error rather than malicious action
2. The system provides no indication that IP extraction is failing
3. The impact scales with the number of users—more users means faster rate limit exhaustion
4. Testing in non-production environments (without proxies) won't reveal the issue
5. The vulnerability persists even if other security controls (captcha, auth tokens) are enabled, since IP-based controls are evaluated first

Operators must explicitly verify their reverse proxy configuration includes proper IP forwarding headers and that the application is correctly configured to trust those headers.

### Citations

**File:** crates/aptos-faucet/core/src/middleware/log.rs (L25-28)
```rust
    let source_ip = RealIp::from_request(&request, &mut RequestBody::default())
        .await
        .map(|ip| ip.0)
        .unwrap_or(None);
```

**File:** crates/aptos-faucet/core/src/endpoints/fund.rs (L217-225)
```rust
        let source_ip = match source_ip.0 {
            Some(ip) => ip,
            None => {
                return Err(AptosTapError::new(
                    "No source IP found in the request".to_string(),
                    AptosTapErrorCode::SourceIpMissing,
                ))
            },
        };
```

**File:** crates/aptos-faucet/core/src/checkers/mod.rs (L148-153)
```rust
pub struct CheckerData {
    pub time_request_received_secs: u64,
    pub receiver: AccountAddress,
    pub source_ip: IpAddr,
    pub headers: Arc<HeaderMap>,
}
```

**File:** crates/aptos-faucet/core/src/checkers/memory_ratelimit.rs (L77-88)
```rust
        let requests_today = ip_to_requests_today.get_or_insert_mut(data.source_ip, || 1);
        if *requests_today >= self.max_requests_per_day {
            return Ok(vec![RejectionReason::new(
                format!(
                    "IP {} has exceeded the daily limit of {} requests",
                    data.source_ip, self.max_requests_per_day
                ),
                RejectionReasonCode::UsageLimitExhausted,
            )]);
        } else if !dry_run {
            *requests_today += 1;
        }
```

**File:** crates/aptos-faucet/core/src/checkers/redis_ratelimit.rs (L44-50)
```rust
    pub async fn ratelimit_key_value(&self, data: &CheckerData) -> Result<String, AptosTapError> {
        match self {
            RatelimitKeyProvider::Ip => Ok(data.source_ip.to_string()),
            RatelimitKeyProvider::Jwt(jwt_verifier) => {
                jwt_verifier.validate_jwt(data.headers.clone()).await
            },
        }
```

**File:** crates/aptos-faucet/core/src/checkers/ip_blocklist.rs (L32-49)
```rust
        match &data.source_ip {
            IpAddr::V4(source_ip) => {
                if self.manager.ipv4_list.contains(source_ip) {
                    return Ok(vec![RejectionReason::new(
                        format!("IP {} is in blocklist", source_ip),
                        RejectionReasonCode::IpInBlocklist,
                    )]);
                }
            },
            IpAddr::V6(source_ip) => {
                if self.manager.ipv6_list.contains(source_ip) {
                    return Ok(vec![RejectionReason::new(
                        format!("IP {} is in blocklist", source_ip),
                        RejectionReasonCode::IpInBlocklist,
                    )]);
                }
            },
        }
```

**File:** crates/aptos-faucet/core/src/bypasser/ip_allowlist.rs (L26-28)
```rust
    async fn request_can_bypass(&self, data: CheckerData) -> Result<bool> {
        Ok(self.manager.contains_ip(&data.source_ip))
    }
```
