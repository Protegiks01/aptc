# Audit Report

## Title
MITM Attack Enables Malicious Service Registration in Indexer-GRPC Metadata Manager

## Summary
The `ping_live_data_service()` function in the indexer-grpc-manager component lacks authentication and cryptographic validation when processing service discovery responses. A Man-in-the-Middle (MITM) attacker can inject malicious `PingDataServiceResponse` messages to register fake data services, causing clients to be redirected to attacker-controlled endpoints that serve fabricated transaction data.

## Finding Description

The indexer-grpc metadata manager discovers and tracks data services by periodically pinging them and storing their responses. The `ping_live_data_service()` function creates unauthenticated gRPC channels and blindly trusts responses without verification. [1](#0-0) 

The channel is created with no TLS certificate validation, mutual authentication, or application-level verification: [2](#0-1) 

When a response is received, the information is extracted and directly registered without any validation: [3](#0-2) 

**Attack Propagation:**

1. Attacker positions themselves to intercept network traffic between the grpc-manager and legitimate data services (e.g., compromised network infrastructure, ARP spoofing, DNS hijacking)
2. When grpc-manager sends a `PingDataServiceRequest`, the attacker intercepts it
3. Attacker responds with a crafted `PingDataServiceResponse` containing their malicious service address and fake metadata (e.g., claiming to serve versions 0 to 999,999,999)
4. The metadata manager registers this fake service in the `live_data_services` DashMap
5. When clients request data, `pick_live_data_service()` may select the attacker's service: [4](#0-3) 

6. The fake service address is returned to clients: [5](#0-4) 

7. Clients connect to the attacker's endpoint and receive fabricated transaction data, events, and state changes

## Impact Explanation

This vulnerability falls under **Medium Severity** per the Aptos bug bounty program, as it affects indexer data integrity rather than core blockchain consensus. The impact includes:

1. **Data Integrity Compromise**: Applications relying on the indexer receive incorrect transaction history, event logs, and account states
2. **Application-Level Exploits**: DeFi protocols, wallets, and analytics tools may make incorrect decisions based on fake data, potentially leading to:
   - Incorrect balance displays
   - Failed transaction validations
   - Erroneous risk assessments
   - Wrong pricing information
3. **Trust Degradation**: Users may lose confidence in Aptos infrastructure if they observe inconsistent data

**Important Limitations**: This vulnerability does NOT affect:
- Blockchain consensus or validator operations
- On-chain transaction execution or state
- Validator rewards or staking mechanisms
- Core blockchain security guarantees

The blockchain itself remains secure; only the indexer infrastructure that provides read-only data access is compromised.

## Likelihood Explanation

**Likelihood: Medium**

**Required Conditions:**
1. MITM network position between grpc-manager and data services
2. Knowledge of the gRPC protocol and message formats
3. Ability to maintain persistent interception

**Feasibility Factors:**

**In Production Deployments:**
- Services typically run within cloud provider private networks (e.g., GCP VPCs)
- MITM requires compromised network infrastructure or cloud account
- If non-TLS endpoints are used (`http://` addresses), attack is straightforward
- If TLS is used but with self-signed certificates and `-insecure` flag (as shown in tests), validation is bypassed: [6](#0-5) 

**Attack Complexity:**
- Low if services use non-TLS connections
- Medium if TLS is used but certificate validation is weak
- High if proper TLS with certificate pinning is implemented (but code shows no such implementation)

## Recommendation

Implement multiple layers of defense:

### 1. Enforce Mutual TLS (mTLS) Authentication
Configure channels with proper TLS certificate validation and client certificates:

```rust
// In LiveDataService::new() and similar constructors
fn new(address: GrpcAddress, tls_config: Option<TlsConfig>) -> Result<Self> {
    let mut channel = Channel::from_shared(address)?;
    
    if let Some(config) = tls_config {
        let tls = ClientTlsConfig::new()
            .ca_certificate(Certificate::from_pem(config.ca_cert))
            .identity(Identity::from_pem(config.client_cert, config.client_key));
        channel = channel.tls_config(tls)?;
    }
    
    let channel = channel.connect_lazy();
    // ... rest of implementation
}
```

### 2. Add Service Authentication Tokens
Include signed authentication tokens in requests and validate responses:

```rust
async fn ping_live_data_service(
    &self,
    address: GrpcAddress,
    mut client: DataServiceClient<Channel>,
) -> Result<()> {
    let nonce = generate_nonce();
    let request = PingDataServiceRequest {
        known_latest_version: Some(self.get_known_latest_version()),
        ping_live_data_service: true,
        auth_token: Some(self.generate_auth_token(&address, nonce)),
        nonce: Some(nonce),
    };
    
    let response = client.ping(request).await?;
    
    // Validate response signature
    if !self.verify_response_signature(&response, &address) {
        bail!("Invalid response signature from {}", address);
    }
    
    if let Some(info) = response.into_inner().info {
        // ... process info
    }
}
```

### 3. Implement Service Registration Allowlist
Only accept services explicitly configured in the startup configuration:

```rust
pub(crate) fn handle_live_data_service_info(
    &self,
    address: GrpcAddress,
    mut info: LiveDataServiceInfo,
) -> Result<()> {
    // Verify service is in allowlist
    if !self.allowed_service_addresses.contains(&address) {
        bail!("Service {} not in allowlist", address);
    }
    
    // ... rest of implementation
}
```

## Proof of Concept

```rust
// PoC demonstrating MITM service registration
// File: ecosystem/indexer-grpc/indexer-grpc-manager/src/test_mitm.rs

#[cfg(test)]
mod mitm_attack_test {
    use super::*;
    use aptos_protos::indexer::v1::{
        data_service_server::{DataService, DataServiceServer},
        LiveDataServiceInfo, PingDataServiceRequest, PingDataServiceResponse,
        ping_data_service_response::Info as ResponseInfo,
    };
    use tonic::{transport::Server, Request, Response, Status};
    
    // Malicious service that responds to pings
    struct MaliciousDataService;
    
    #[tonic::async_trait]
    impl DataService for MaliciousDataService {
        async fn ping(
            &self,
            _request: Request<PingDataServiceRequest>,
        ) -> Result<Response<PingDataServiceResponse>, Status> {
            // Inject fake service info claiming to serve all versions
            let fake_info = LiveDataServiceInfo {
                chain_id: 1,
                min_servable_version: Some(0),
                timestamp: Some(timestamp_now_proto()),
                stream_info: Some(StreamInfo { active_streams: vec![] }),
            };
            
            Ok(Response::new(PingDataServiceResponse {
                info: Some(ResponseInfo::LiveDataServiceInfo(fake_info)),
            }))
        }
        
        // Implement other required methods...
    }
    
    #[tokio::test]
    async fn test_mitm_service_registration() {
        // Start malicious service
        let addr = "127.0.0.1:50099".parse().unwrap();
        tokio::spawn(async move {
            Server::builder()
                .add_service(DataServiceServer::new(MaliciousDataService))
                .serve(addr)
                .await
                .unwrap();
        });
        
        tokio::time::sleep(Duration::from_millis(100)).await;
        
        // Create metadata manager
        let manager = MetadataManager::new(
            1,
            "http://localhost:50051".to_string(),
            vec![],
            vec![],
            None,
        );
        
        // Attacker's malicious address gets registered
        let malicious_address = "http://127.0.0.1:50099".to_string();
        let client = DataServiceClient::new(
            Channel::from_shared(malicious_address.clone())
                .unwrap()
                .connect_lazy()
        );
        
        // This succeeds and registers the fake service
        manager.ping_live_data_service(malicious_address.clone(), client)
            .await
            .expect("Fake service registration succeeded");
        
        // Verify fake service is now registered
        let services = manager.get_live_data_services_info();
        assert!(services.contains_key(&malicious_address));
        
        println!("âœ“ MITM attack successful: Fake service registered at {}", malicious_address);
    }
}
```

## Notes

**Scope Clarification**: This vulnerability affects the **indexer-grpc infrastructure**, which provides read-only access to blockchain data for external applications. It does NOT affect:
- Consensus protocol or validator operations
- Transaction execution or blockchain state
- On-chain governance or staking mechanisms

The core blockchain remains secure and Byzantine fault tolerant. Only the indexer's data delivery mechanism is vulnerable to this attack. Applications should implement their own validation of critical data and not rely solely on a single indexer source for security-critical decisions.

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L89-102)
```rust
    fn new(address: GrpcAddress) -> Self {
        let channel = Channel::from_shared(address)
            .expect("Bad address.")
            .connect_lazy();
        let client = DataServiceClient::new(channel)
            .send_compressed(CompressionEncoding::Zstd)
            .accept_compressed(CompressionEncoding::Zstd)
            .max_encoding_message_size(MAX_MESSAGE_SIZE)
            .max_decoding_message_size(MAX_MESSAGE_SIZE);
        Self {
            client,
            recent_states: VecDeque::new(),
        }
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L445-465)
```rust
    async fn ping_live_data_service(
        &self,
        address: GrpcAddress,
        mut client: DataServiceClient<Channel>,
    ) -> Result<()> {
        let request = PingDataServiceRequest {
            known_latest_version: Some(self.get_known_latest_version()),
            ping_live_data_service: true,
        };
        let response = client.ping(request).await?;
        if let Some(info) = response.into_inner().info {
            match info {
                aptos_protos::indexer::v1::ping_data_service_response::Info::LiveDataServiceInfo(info) => {
                    self.handle_live_data_service_info(address, info)
                },
                _ => bail!("Bad response."),
            }
        } else {
            bail!("Bad response.")
        }
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L489-509)
```rust
    fn handle_live_data_service_info(
        &self,
        address: GrpcAddress,
        mut info: LiveDataServiceInfo,
    ) -> Result<()> {
        let mut entry = self
            .live_data_services
            .entry(address.clone())
            .or_insert(LiveDataService::new(address));
        if info.stream_info.is_none() {
            info.stream_info = Some(StreamInfo {
                active_streams: vec![],
            });
        }
        entry.value_mut().recent_states.push_back(info);
        if entry.value().recent_states.len() > MAX_NUM_OF_STATES_TO_KEEP {
            entry.value_mut().recent_states.pop_front();
        }

        Ok(())
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/service.rs (L71-88)
```rust
    fn pick_live_data_service(&self, starting_version: u64) -> Option<String> {
        let mut candidates = vec![];
        for candidate in self.metadata_manager.get_live_data_services_info() {
            if let Some(info) = candidate.1.back().as_ref() {
                // TODO(grao): Handle the case when the requested starting version is beyond the
                // latest version.
                if info.min_servable_version.is_none()
                    || starting_version < info.min_servable_version.unwrap()
                {
                    continue;
                }
                let num_active_streams = info.stream_info.as_ref().unwrap().active_streams.len();
                candidates.push((candidate.0, num_active_streams));
            }
        }

        Self::pick_data_service_from_candidate(candidates)
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/service.rs (L148-196)
```rust
    async fn get_data_service_for_request(
        &self,
        request: Request<GetDataServiceForRequestRequest>,
    ) -> Result<Response<GetDataServiceForRequestResponse>, Status> {
        let request = request.into_inner();

        if request.user_request.is_none()
            || request
                .user_request
                .as_ref()
                .unwrap()
                .starting_version
                .is_none()
        {
            let candidates = self.metadata_manager.get_live_data_services_info();
            if let Some(candidate) = candidates.iter().next() {
                let data_service_address = candidate.0.clone();
                return Ok(Response::new(GetDataServiceForRequestResponse {
                    data_service_address,
                }));
            } else {
                return Err(Status::internal(
                    "Cannot find a data service instance to serve the provided request.",
                ));
            }
        }

        let starting_version = request.user_request.unwrap().starting_version();

        let data_service_address =
            // TODO(grao): Use a simple strategy for now. Consider to make it smarter in the
            // future.
            if let Some(address) = self.pick_live_data_service(starting_version) {
                COUNTER.with_label_values(&["live_data_service_picked"]).inc();
                address
            } else if let Some(address) = self.pick_historical_data_service(starting_version).await {
                COUNTER.with_label_values(&["historical_data_service_picked"]).inc();
                address
            } else {
                COUNTER.with_label_values(&["failed_to_pick_data_service"]).inc();
                return Err(Status::internal(
                    "Cannot find a data service instance to serve the provided request.",
                ));
            };

        Ok(Response::new(GetDataServiceForRequestResponse {
            data_service_address,
        }))
    }
```

**File:** testsuite/indexer_grpc_local.py (L32-36)
```python
INDEXER_FULLNODE_REST_API_URL = "http://localhost:8080"
INDEXER_DATA_SERVICE_READINESS_URL = "http://localhost:18084/readiness"
GRPC_INDEXER_FULLNODE_URL = "localhost:50051"
GRPC_DATA_SERVICE_NON_TLS_URL = "localhost:50052"
GRPC_DATA_SERVICE_TLS_URL = "localhost:50053"
```
