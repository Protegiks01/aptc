# Audit Report

## Title
Race Condition in Concurrent Restore Operations Leading to Database State Corruption

## Summary
The restore handler's `save_transactions` and `get_next_expected_transaction_version` functions lack synchronization, allowing concurrent restore operations to create version gaps, overlaps, or state corruption when multiple threads access them simultaneously without proper coordination.

## Finding Description

The restore path bypasses the commit locks used by normal transaction processing, creating a critical race condition:

**Normal Transaction Path (Protected):** [1](#0-0) [2](#0-1) 

**Restore Path (Unprotected):** [3](#0-2) [4](#0-3) 

The vulnerability manifests in three ways:

1. **Read-Write Race**: `get_next_expected_transaction_version` reads `OverallCommitProgress` [5](#0-4)  while `save_transactions` writes it [6](#0-5)  without atomic synchronization.

2. **Non-atomic Multi-Database Commit**: State KV DB and Ledger DB commits occur sequentially without atomicity [7](#0-6) , allowing partial writes from concurrent operations to interleave.

3. **Missing Lock Acquisition**: Unlike normal commits that use `pre_commit_lock` and `commit_lock`, restore operations directly call database writes [8](#0-7)  without acquiring these locks.

**Attack Scenario:**
If an operator script or buggy automation creates multiple concurrent restore threads (bypassing the single-threaded coordinator), both threads could:
- Read `next_version = 0` simultaneously  
- Write transactions [0-99] concurrently
- Cause last-writer-wins corruption if transaction data differs
- Create `OverallCommitProgress` inconsistencies

## Impact Explanation

**Severity: Medium**

This breaks the **State Consistency** invariant. While the impact could theoretically be critical (state corruption requiring re-sync), the realistic exploitation requires:
- Operator/administrator access to the node
- Deliberate misuse bypassing the RestoreCoordinator's built-in serialization
- Custom code that creates concurrent RestoreHandler instances

The normal restore flow uses `try_buffered_x` with `max_in_progress=1` [9](#0-8) , which serializes operations. RocksDB file locks prevent multiple processes from concurrent write access.

This is primarily an **operational safety issue** rather than a directly exploitable external attack vector.

## Likelihood Explanation

**Likelihood: Low**

Exploitation requires:
1. Administrative access to validator infrastructure
2. Bypassing the RestoreCoordinator's orchestration
3. Writing custom concurrent code that misuses APIs
4. Having different transaction data for the same versions

The normal usage pattern through RestoreCoordinator is safe. This would only occur through deliberate API misuse or buggy operator tooling.

## Recommendation

Add explicit locking to the restore path to match the safety guarantees of normal commits:

```rust
// In AptosDB struct
restore_lock: std::sync::Mutex<()>,

// In restore_utils::save_transactions
pub(crate) fn save_transactions(
    state_store: Arc<StateStore>,
    ledger_db: Arc<LedgerDb>,
    aptosdb: Arc<AptosDB>, // Add parameter
    // ... other params
) -> Result<()> {
    let _lock = aptosdb.restore_lock.lock()
        .expect("Failed to acquire restore lock");
    
    // Existing implementation
    // ...
}
```

Alternative: Document that RestoreHandler is not thread-safe and must only be used through RestoreCoordinator.

## Proof of Concept

```rust
#[test]
fn test_concurrent_restore_race() {
    use std::sync::Arc;
    use std::thread;
    
    let tmp_dir = TempPath::new();
    let db = Arc::new(AptosDB::new_for_test(&tmp_dir));
    
    let handler1 = db.get_restore_handler();
    let handler2 = db.get_restore_handler();
    
    let h1 = thread::spawn(move || {
        let v = handler1.get_next_expected_transaction_version().unwrap();
        // v == 0
        handler1.save_transactions(
            0, &txns_a, &aux_a, &infos_a, &events_a, wsets_a
        )
    });
    
    let h2 = thread::spawn(move || {
        let v = handler2.get_next_expected_transaction_version().unwrap();
        // v == 0 (race!)
        handler2.save_transactions(
            0, &txns_b, &aux_b, &infos_b, &events_b, wsets_b
        )
    });
    
    h1.join().unwrap().unwrap();
    h2.join().unwrap().unwrap();
    
    // State corruption: txns_a and txns_b mixed or one overwrote the other
}
```

## Notes

This vulnerability exists in the implementation but has limited practical exploitability due to:
- RocksDB's process-level file locking
- RestoreCoordinator's serialization of operations
- Requirement for operator access

However, it violates defensive programming principles and could lead to operational errors during restore procedures if multiple automation scripts run concurrently.

### Citations

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L50-53)
```rust
            let _lock = self
                .pre_commit_lock
                .try_lock()
                .expect("Concurrent committing detected.");
```

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L89-92)
```rust
            let _lock = self
                .commit_lock
                .try_lock()
                .expect("Concurrent committing detected.");
```

**File:** storage/aptosdb/src/backup/restore_handler.rs (L78-99)
```rust
    pub fn save_transactions(
        &self,
        first_version: Version,
        txns: &[Transaction],
        persisted_aux_info: &[PersistedAuxiliaryInfo],
        txn_infos: &[TransactionInfo],
        events: &[Vec<ContractEvent>],
        write_sets: Vec<WriteSet>,
    ) -> Result<()> {
        restore_utils::save_transactions(
            self.state_store.clone(),
            self.ledger_db.clone(),
            first_version,
            txns,
            persisted_aux_info,
            txn_infos,
            events,
            write_sets,
            None,
            false,
        )
    }
```

**File:** storage/aptosdb/src/backup/restore_handler.rs (L128-130)
```rust
    pub fn get_next_expected_transaction_version(&self) -> Result<Version> {
        Ok(self.aptosdb.get_synced_version()?.map_or(0, |ver| ver + 1))
    }
```

**File:** storage/aptosdb/src/backup/restore_utils.rs (L115-176)
```rust
pub(crate) fn save_transactions(
    state_store: Arc<StateStore>,
    ledger_db: Arc<LedgerDb>,
    first_version: Version,
    txns: &[Transaction],
    persisted_aux_info: &[PersistedAuxiliaryInfo],
    txn_infos: &[TransactionInfo],
    events: &[Vec<ContractEvent>],
    write_sets: Vec<WriteSet>,
    existing_batch: Option<(
        &mut LedgerDbSchemaBatches,
        &mut ShardedStateKvSchemaBatch,
        &mut SchemaBatch,
    )>,
    kv_replay: bool,
) -> Result<()> {
    if let Some((ledger_db_batch, state_kv_batches, _state_kv_metadata_batch)) = existing_batch {
        save_transactions_impl(
            state_store,
            ledger_db,
            first_version,
            txns,
            persisted_aux_info,
            txn_infos,
            events,
            write_sets.as_ref(),
            ledger_db_batch,
            state_kv_batches,
            kv_replay,
        )?;
    } else {
        let mut ledger_db_batch = LedgerDbSchemaBatches::new();
        let mut sharded_kv_schema_batch = state_store
            .state_db
            .state_kv_db
            .new_sharded_native_batches();
        save_transactions_impl(
            Arc::clone(&state_store),
            Arc::clone(&ledger_db),
            first_version,
            txns,
            persisted_aux_info,
            txn_infos,
            events,
            write_sets.as_ref(),
            &mut ledger_db_batch,
            &mut sharded_kv_schema_batch,
            kv_replay,
        )?;
        // get the last version and commit to the state kv db
        // commit the state kv before ledger in case of failure happens
        let last_version = first_version + txns.len() as u64 - 1;
        state_store
            .state_db
            .state_kv_db
            .commit(last_version, None, sharded_kv_schema_batch)?;

        ledger_db.write_schemas(ledger_db_batch)?;
    }

    Ok(())
}
```

**File:** storage/aptosdb/src/backup/restore_utils.rs (L282-291)
```rust
        .put::<DbMetadataSchema>(
            &DbMetadataKey::LedgerCommitProgress,
            &DbMetadataValue::Version(last_version),
        )?;
    ledger_db_batch
        .ledger_metadata_db_batches
        .put::<DbMetadataSchema>(
            &DbMetadataKey::OverallCommitProgress,
            &DbMetadataValue::Version(last_version),
        )?;
```

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L536-536)
```rust
            .try_buffered_x(self.global_opt.concurrent_downloads, 1)
```
