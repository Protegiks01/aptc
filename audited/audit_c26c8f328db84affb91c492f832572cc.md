# Audit Report

## Title
Cross-Chain Transaction Data Contamination in Indexer Infrastructure via Shared Redis Cache

## Summary
The indexer-grpc-file-store component lacks proper namespace isolation for Redis cache keys and file storage paths by chain_id, allowing transaction data from different blockchain networks to potentially contaminate each other when instances are misconfigured to share infrastructure. However, this is an **operational configuration issue** rather than a core blockchain security vulnerability.

## Finding Description

The indexer-grpc system stores transaction data in Redis cache and file storage without incorporating chain_id into the key/path structure:

**Redis Keys (NOT namespaced by chain_id):** [1](#0-0) 

**Transaction Cache Keys:** [2](#0-1) 

**File Storage Paths:** [3](#0-2) 

**Existing Safeguards:**

The system implements chain_id validation at startup: [4](#0-3) 

However, validation occurs only at initialization and start of processing: [5](#0-4) 

**Problematic Scenarios:**

1. **Misconfiguration**: Two indexer instances with different chain_ids pointing to the same Redis instance will fail startup validation
2. **Redis Failure Recovery**: If Redis is cleared during operation, running instances don't re-validate chain_id continuously
3. **Race Condition**: Simultaneous startup of multiple instances with empty Redis could lead to inconsistent state

## Impact Explanation

**CRITICAL ASSESSMENT: This is NOT a Critical blockchain vulnerability** for the following reasons:

1. **Indexer ≠ Consensus**: The indexer-grpc components are **external data querying infrastructure**, not part of the core Aptos blockchain consensus, execution, or state management layers. Transaction data corruption in the indexer does not affect:
   - On-chain consensus (validators don't use indexer data)
   - Chain state integrity (AptosDB is separate)
   - Transaction execution (Move VM is independent)
   - Validator operations (staking, governance use on-chain data)

2. **Requires Operator Misconfiguration**: This issue cannot be triggered by an external attacker. It requires:
   - Administrative misconfiguration of multiple indexer instances
   - Intentional sharing of Redis/storage infrastructure across chains
   - Failure to follow operational best practices

3. **Protected by Validation**: The existing chain_id checks prevent most misconfiguration scenarios during normal operation.

**Actual Impact**: Medium severity operational issue - causes API data inconsistency requiring intervention, but does not compromise blockchain security.

## Likelihood Explanation

**Low likelihood** in production:
- Requires explicit operator error (configuring different chain_ids with same infrastructure)
- Startup validation catches most scenarios
- Standard deployment practices use isolated infrastructure per chain
- Protected by multiple configuration layers (Redis URL, bucket_sub_dir, database selection)

## Recommendation

This is an **infrastructure hardening** recommendation rather than a security patch:

1. **Add chain_id namespacing to Redis keys:**
```rust
// Change from:
const CACHE_KEY_CHAIN_ID: &str = "chain_id";
const CACHE_KEY_LATEST_VERSION: &str = "latest_version";

// To:
pub fn cache_key_chain_id(chain_id: u64) -> String {
    format!("chain:{}:metadata", chain_id)
}
pub fn cache_key_latest_version(chain_id: u64) -> String {
    format!("chain:{}:latest_version", chain_id)
}
```

2. **Use Redis database numbers for isolation:**
   - Configure different Redis database numbers (0-15) per chain
   - Similar to the faucet's approach with `database_number` field

3. **Enforce bucket_sub_dir requirement:**
   - Make bucket_sub_dir mandatory for multi-chain deployments
   - Add configuration validation at startup

4. **Add continuous chain_id validation:**
   - Periodically verify Redis chain_id matches instance configuration during operation
   - Fail fast if mismatch detected

5. **Document operational requirements:**
   - Clearly document that each chain requires isolated Redis instance or database number
   - Add deployment examples showing proper configuration

## Proof of Concept

**Note**: This demonstrates operational misconfiguration, not an exploitable attack:

```bash
# Terminal 1: Start mainnet indexer
CHAIN_ID=1 REDIS_URL=redis://localhost:6379 ./indexer-grpc-file-store

# Terminal 2: Clear Redis (simulating failure)
redis-cli FLUSHDB

# Terminal 3: Start testnet indexer with same Redis
CHAIN_ID=2 REDIS_URL=redis://localhost:6379 ./indexer-grpc-file-store

# Result: Testnet instance may set chain_id=2 in Redis
# Mainnet instance continues writing without re-validation
# Redis contains mixed chain data at overlapping version numbers
```

## Notes

**This does NOT qualify as a Critical blockchain security vulnerability** because:

✗ Not exploitable by unprivileged attacker (requires operator access)  
✗ Does not affect consensus, execution, or chain state (indexer is separate layer)  
✗ Protected by existing validation mechanisms  
✗ Requires explicit misconfiguration to manifest  

**This IS a valid operational hardening recommendation** for:  
✓ Multi-chain deployment best practices  
✓ Infrastructure resilience improvements  
✓ Defense-in-depth for operational errors  

The indexer infrastructure should implement namespace isolation as a best practice, but the lack of it is not a blockchain security vulnerability per the Aptos bug bounty criteria. It's an infrastructure configuration issue that should be addressed through documentation and deployment guidance.

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/cache_operator.rs (L26-27)
```rust
const CACHE_KEY_LATEST_VERSION: &str = "latest_version";
const CACHE_KEY_CHAIN_ID: &str = "chain_id";
```

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/compression_util.rs (L127-140)
```rust
    pub fn build_key(version: u64, storage_format: StorageFormat) -> String {
        match storage_format {
            StorageFormat::Lz4CompressedProto => {
                format!("l4:{}", version)
            },
            StorageFormat::Base64UncompressedProto => {
                format!("{}", version)
            },
            StorageFormat::JsonBase64UncompressedProto => {
                // This is fatal to see that we are using legacy file format in cache side.
                panic!("JsonBase64UncompressedProto is not supported in cache.")
            },
        }
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/compression_util.rs (L240-260)
```rust
    pub fn build_key(version: u64, storage_format: StorageFormat) -> String {
        let starting_version =
            version / FILE_ENTRY_TRANSACTION_COUNT * FILE_ENTRY_TRANSACTION_COUNT;
        let mut hasher = Ripemd128::new();
        hasher.update(starting_version.to_string());
        let file_prefix = format!("{:x}", hasher.finalize());
        match storage_format {
            StorageFormat::Lz4CompressedProto => {
                format!(
                    "compressed_files/lz4/{}_{}.bin",
                    file_prefix, starting_version
                )
            },
            StorageFormat::JsonBase64UncompressedProto => {
                format!("files/{}.json", starting_version)
            },
            StorageFormat::Base64UncompressedProto => {
                panic!("Base64UncompressedProto is not supported.")
            },
        }
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-file-store/src/processor.rs (L84-94)
```rust
        ensure!(metadata.chain_id == chain_id, "Chain ID mismatch.");
        let batch_start_version = metadata.version;
        // Cache config in the cache
        cache_operator.cache_setup_if_needed().await?;
        match cache_operator.get_chain_id().await? {
            Some(id) => {
                ensure!(id == chain_id, "Chain ID mismatch.");
            },
            None => {
                cache_operator.set_chain_id(chain_id).await?;
            },
```

**File:** ecosystem/indexer-grpc/indexer-grpc-file-store/src/processor.rs (L113-121)
```rust
    pub async fn run(&mut self) -> Result<()> {
        let chain_id = self.chain_id;

        let metadata = self
            .file_store_operator
            .get_file_store_metadata()
            .await
            .unwrap();
        ensure!(metadata.chain_id == chain_id, "Chain ID mismatch.");
```
