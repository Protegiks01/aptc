# Audit Report

## Title
Delete Operation Can Overwrite Legitimate State Updates in Aggregator Change Set

## Summary
The `into_change_set` function in the aggregator context processes destroyed aggregators after processing active aggregators, using the same `BTreeMap::insert` operation for both. If the same aggregator ID exists in both the `aggregators` map and `destroyed_aggregators` set, the Delete operation will overwrite any legitimate Write or Merge operations, causing loss of state updates. [1](#0-0) 

## Finding Description
The vulnerability exists in the sequential processing logic of `into_change_set()`. The function processes aggregator changes in two phases:

**Phase 1 (Lines 114-134):** Iterates through the `aggregators` map and inserts Write/Merge operations into `aggregator_v1_changes`.

**Phase 2 (Lines 136-139):** Iterates through `destroyed_aggregators` set and inserts Delete operations into the same `aggregator_v1_changes` map.

Both phases use `BTreeMap::insert()`, which **overwrites** any existing value for a given key. If the same aggregator ID appears in both collections, the Delete from Phase 2 will overwrite the legitimate state update from Phase 1. [2](#0-1) [3](#0-2) 

The root cause is that the Rust native API allows an aggregator ID to exist in both collections simultaneously:

1. `get_aggregator()` uses `or_insert` to add/retrieve aggregators from the `aggregators` map
2. `remove_aggregator()` removes from `aggregators` and adds to `destroyed_aggregators`
3. **Critically:** There is no check preventing `get_aggregator()` from being called again after `remove_aggregator()` for the same ID [4](#0-3) [5](#0-4) 

**Attack Scenario:**
1. Aggregator X exists in storage with value 100
2. Transaction performs `add(X, 50)` → X added to `aggregators` with delta +50
3. Due to complex control flow or framework bug, `destroy(X)` is called → X removed from `aggregators`, added to `destroyed_aggregators`
4. Later in the same transaction, X is accessed again → `get_aggregator()` re-inserts X into `aggregators` with new operations
5. Transaction commits → `into_change_set()` processes both:
   - Phase 1: Inserts `{X: Merge(+delta)}`
   - Phase 2: Inserts `{X: Delete}` ← **OVERWRITES the Merge**
6. Result: Legitimate state update lost; storage incorrectly deletes X instead of applying delta

This breaks the **State Consistency** invariant (#4) because state transitions are not correctly preserved, leading to data loss.

## Impact Explanation
This is a **High Severity** vulnerability under the Aptos Bug Bounty program because it causes:

1. **State Inconsistency Requiring Intervention:** Legitimate state updates are silently discarded, causing the blockchain state to diverge from what transactions intended. This could affect:
   - Token balances tracked via aggregators
   - Governance voting power calculations
   - Staking reward accumulations
   - Any protocol mechanism using aggregators v1

2. **Deterministic Execution Violation:** If this occurs on some validators but not others due to timing or implementation differences, it could cause validators to compute different state roots for the same block, potentially breaking consensus.

3. **Silent Data Loss:** The bug causes no immediate errors or transaction failures - the state update is simply lost, making it difficult to detect and potentially affecting many transactions before discovery.

While the vulnerability requires specific conditions to trigger (complex control flow or framework bugs), the impact severity warrants High classification due to potential state corruption and consensus implications.

## Likelihood Explanation
The likelihood depends on whether the vulnerable code path can be triggered in production:

**Mitigating Factors:**
- Move's type system prevents using an aggregator after `destroy()` consumes it by value
- Only `@aptos_framework` can create aggregators, limiting attack surface
- The Aggregator struct lacks `copy` ability, preventing duplication

**Risk Factors:**
- The Rust API has no defensive checks against the vulnerable sequence
- Complex smart contract control flows could potentially trigger the scenario
- Future framework changes might introduce exploitability
- The code relies entirely on Move's type safety without defense-in-depth

The vulnerability is **possible but requires specific conditions** - either a bug in the Move framework allowing post-destruction access, or complex interleaving of operations that bypasses type safety.

## Recommendation
Implement defensive checks at the Rust native API level to prevent the vulnerable state:

**Option 1: Check for conflicts in `into_change_set`**
```rust
pub fn into_change_set(self) -> PartialVMResult<AggregatorChangeSet> {
    // ... existing code ...
    
    for (id, aggregator) in aggregators {
        let change = match state { /* ... */ };
        aggregator_v1_changes.insert(id.0, change);
    }
    
    // NEW: Check for conflicts before processing destroyed aggregators
    for id in &destroyed_aggregators {
        if aggregator_v1_changes.contains_key(&id.0) {
            return Err(extension_error(
                "Aggregator appears in both aggregators and destroyed_aggregators"
            ));
        }
    }
    
    for id in destroyed_aggregators {
        aggregator_v1_changes.insert(id.0, AggregatorChangeV1::Delete);
    }
    // ...
}
```

**Option 2: Prevent re-accessing destroyed aggregators**
Track destroyed IDs and check in `get_aggregator`:
```rust
pub fn get_aggregator(&mut self, id: AggregatorID, max_value: u128) -> PartialVMResult<&mut Aggregator> {
    if self.destroyed_aggregators.contains(&id) {
        return Err(extension_error(
            "Cannot access aggregator after destruction"
        ));
    }
    let aggregator = self.aggregators.entry(id).or_insert(/* ... */);
    Ok(aggregator)
}
```

**Option 3: Process destroyed aggregators first**
Reverse the order so Writes/Merges overwrite Deletes (though this changes semantics):
```rust
// Process destroys first
for id in destroyed_aggregators {
    aggregator_v1_changes.insert(id.0, AggregatorChangeV1::Delete);
}
// Then process active aggregators (will overwrite deletes if present)
for (id, aggregator) in aggregators {
    // ...
}
```

**Recommendation:** Implement Option 1 or Option 2 for defense-in-depth. Option 1 catches the invariant violation explicitly. Option 2 prevents the vulnerable state from occurring.

## Proof of Concept
```rust
#[test]
fn test_delete_overwrites_merge_vulnerability() {
    use aptos_aggregator::{FakeAggregatorView, aggregator_v1_id_for_test, aggregator_v1_state_key_for_test};
    
    // Setup: Aggregator in storage with value 100
    let mut resolver = FakeAggregatorView::default();
    resolver.set_from_state_key(aggregator_v1_state_key_for_test(500), 100);
    
    let context = NativeAggregatorContext::new([0; 32], &resolver, false, &resolver);
    let mut aggregator_data = context.aggregator_v1_data.borrow_mut();
    
    // Step 1: Access aggregator and perform operations
    let id = aggregator_v1_id_for_test(500);
    aggregator_data.get_aggregator(id.clone(), 500).unwrap().add(50).unwrap();
    // Now aggregators map has: {500: Aggregator(delta=+50)}
    
    // Step 2: Destroy the aggregator
    aggregator_data.remove_aggregator(id.clone());
    // Now: aggregators is empty, destroyed_aggregators has {500}
    
    // Step 3: Access aggregator again (simulating complex control flow)
    aggregator_data.get_aggregator(id.clone(), 500).unwrap().add(25).unwrap();
    // Now: aggregators has {500: Aggregator(delta=+25)}, destroyed_aggregators still has {500}
    
    drop(aggregator_data);
    
    // Step 4: Convert to change set
    let change_set = context.into_change_set().unwrap();
    
    // VULNERABILITY: The Delete overwrote the Merge(+25)
    let state_key = aggregator_v1_state_key_for_test(500);
    match change_set.aggregator_v1_changes.get(&state_key).unwrap() {
        AggregatorChangeV1::Delete => {
            // This is the bug - we expected Merge(+25) but got Delete
            println!("BUG CONFIRMED: Delete overwrote legitimate Merge operation");
        },
        AggregatorChangeV1::Merge(_) => {
            println!("Expected behavior: Merge preserved");
        },
        _ => {}
    }
}
```

**Note:** This PoC demonstrates the vulnerability at the Rust API level. In production, this would require either a Move framework bug or complex control flow that bypasses Move's type safety to trigger the vulnerable sequence of operations.

### Citations

**File:** aptos-move/framework/src/natives/aggregator_natives/context.rs (L104-139)
```rust
    pub fn into_change_set(self) -> PartialVMResult<AggregatorChangeSet> {
        let NativeAggregatorContext {
            aggregator_v1_data,
            delayed_field_data,
            ..
        } = self;
        let (_, destroyed_aggregators, aggregators) = aggregator_v1_data.into_inner().into();

        let mut aggregator_v1_changes = BTreeMap::new();

        // First, process all writes and deltas.
        for (id, aggregator) in aggregators {
            let (value, state, limit, history) = aggregator.into();

            let change = match state {
                AggregatorState::Data => AggregatorChangeV1::Write(value),
                AggregatorState::PositiveDelta => {
                    let history = history.unwrap();
                    let plus = SignedU128::Positive(value);
                    let delta_op = DeltaOp::new(plus, limit, history);
                    AggregatorChangeV1::Merge(delta_op)
                },
                AggregatorState::NegativeDelta => {
                    let history = history.unwrap();
                    let minus = SignedU128::Negative(value);
                    let delta_op = DeltaOp::new(minus, limit, history);
                    AggregatorChangeV1::Merge(delta_op)
                },
            };
            aggregator_v1_changes.insert(id.0, change);
        }

        // Additionally, do not forget to delete destroyed values from storage.
        for id in destroyed_aggregators {
            aggregator_v1_changes.insert(id.0, AggregatorChangeV1::Delete);
        }
```

**File:** aptos-move/aptos-aggregator/src/aggregator_v1_extension.rs (L298-310)
```rust
    pub fn get_aggregator(
        &mut self,
        id: AggregatorID,
        max_value: u128,
    ) -> PartialVMResult<&mut Aggregator> {
        let aggregator = self.aggregators.entry(id).or_insert(Aggregator {
            value: 0,
            state: AggregatorState::PositiveDelta,
            max_value,
            history: Some(DeltaHistory::new()),
        });
        Ok(aggregator)
    }
```

**File:** aptos-move/aptos-aggregator/src/aggregator_v1_extension.rs (L333-345)
```rust
    pub fn remove_aggregator(&mut self, id: AggregatorID) {
        // Aggregator no longer in use during this transaction: remove it.
        self.aggregators.remove(&id);

        if self.new_aggregators.contains(&id) {
            // Aggregator has been created in the same transaction. Therefore, no
            // side-effects.
            self.new_aggregators.remove(&id);
        } else {
            // Otherwise, aggregator has been created somewhere else.
            self.destroyed_aggregators.insert(id);
        }
    }
```
