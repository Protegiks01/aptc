# Audit Report

## Title
Server-Side Request Forgery (SSRF) via Percent-Encoded IP Address Bypass in NFT Metadata Crawler

## Summary
The NFT metadata crawler's URI blacklist validation can be bypassed using percent-encoded IP addresses, allowing attackers to exploit Server-Side Request Forgery (SSRF) vulnerabilities to access internal services, private networks, and cloud metadata endpoints.

## Finding Description

The NFT metadata crawler performs URI blacklist validation using a simple string containment check before making HTTP requests to fetch NFT metadata. However, this validation does not normalize or decode percent-encoded characters in URIs. [1](#0-0) 

The blacklist check uses a simple `contains()` operation on the raw URI string. When an attacker provides a percent-encoded URI such as `http://%31%32%37.%30.%30.%31` (encoding of `127.0.0.1`), the blacklist check fails to detect it because the string "%31%32%37.%30.%30.%31" does not contain "127.0.0.1". [2](#0-1) 

The URI validation only checks if it's a valid URL syntax, not whether it resolves to internal addresses: [3](#0-2) 

The percent-encoded URI then flows through to the JSON parser: [4](#0-3) 

Where it's eventually passed to `reqwest::Client` which automatically decodes percent-encoded characters according to RFC 3986: [5](#0-4) 

The same vulnerability exists in the image optimizer path: [6](#0-5) 

**Attack Scenario:**
1. Attacker creates an NFT with metadata URI: `http://%31%32%37.%30.%30.%31:8080/admin` (encodes to `127.0.0.1`)
2. The crawler receives this URI from on-chain NFT data
3. Blacklist check passes because "%31%32%37.%30.%30.%31" doesn't contain "127.0.0.1"
4. URL syntax validation passes (it's a valid URL)
5. `reqwest` decodes the percent-encoding and makes request to `127.0.0.1:8080`
6. Attacker gains access to internal services

Other exploitable targets:
- Private networks: `http://%31%39%32.%31%36%38.1.1` → `192.168.1.1`
- Cloud metadata: `http://%31%36%39.%32%35%34.%31%36%39.%32%35%34` → `169.254.169.254` (AWS/GCP metadata)
- Localhost variations: `http://%6c%6f%63%61%6c%68%6f%73%74` → `localhost`

## Impact Explanation

This vulnerability is classified as **High Severity** according to Aptos bug bounty criteria:

1. **Validator Node Slowdowns**: If the NFT metadata crawler runs on validator infrastructure (which is likely for indexing nodes), an attacker can force it to make numerous requests to internal services, causing resource exhaustion and service degradation.

2. **API Crashes**: Malicious URIs targeting non-existent internal services can cause the crawler to timeout repeatedly, potentially leading to service instability or crashes.

3. **Information Disclosure**: Accessing cloud metadata endpoints (169.254.169.254) could expose:
   - AWS/GCP instance credentials
   - Service account tokens
   - Infrastructure configuration
   - Database connection strings from environment variables

4. **Internal Network Reconnaissance**: Attackers can systematically scan internal networks by creating multiple NFTs with different percent-encoded private IP addresses, mapping the internal infrastructure.

5. **Potential Privilege Escalation**: Access to internal admin panels or APIs could lead to further compromise of the indexing infrastructure.

While this does not directly affect blockchain consensus, it compromises critical infrastructure components that validators and indexers depend on, meeting the "Validator node slowdowns" and "API crashes" criteria for High severity.

## Likelihood Explanation

This vulnerability has **HIGH likelihood** of exploitation:

1. **Low Attack Complexity**: Creating an NFT with malicious metadata is straightforward and requires no special privileges beyond gas fees.

2. **No Authentication Required**: Any user can mint NFTs on Aptos with arbitrary metadata URIs.

3. **Well-Known Attack Pattern**: Percent-encoding bypass is a classic SSRF technique that is actively exploited in web applications.

4. **Wide Attack Surface**: Every NFT minted with a crafted URI becomes a potential attack vector.

5. **Difficult to Detect**: The percent-encoded URIs appear as legitimate external URLs until decoded, making them hard to spot without proper normalization.

6. **Persistent**: Once an NFT is created on-chain, the malicious URI persists and will be processed whenever the crawler encounters it.

## Recommendation

Implement proper URL normalization and validation before blacklist checks:

```rust
fn is_blacklisted_uri(&mut self, uri: &str) -> bool {
    // Parse and normalize the URL first
    let normalized_uri = match Url::parse(uri) {
        Ok(parsed_url) => {
            // Get the normalized host (handles percent-decoding)
            let host = parsed_url.host_str().unwrap_or("");
            let scheme = parsed_url.scheme();
            let port = parsed_url.port().map(|p| format!(":{}", p)).unwrap_or_default();
            format!("{}://{}{}", scheme, host, port)
        },
        Err(_) => uri.to_string(),
    };
    
    // Check both original and normalized URIs against blacklist
    self.parser_config
        .uri_blacklist
        .iter()
        .any(|blacklist_uri| uri.contains(blacklist_uri) || normalized_uri.contains(blacklist_uri))
}
```

Additionally, implement explicit IP address range validation:

```rust
use std::net::IpAddr;

fn is_internal_address(uri: &str) -> bool {
    if let Ok(parsed) = Url::parse(uri) {
        if let Some(host) = parsed.host_str() {
            // Check for localhost variants
            if host == "localhost" || host == "127.0.0.1" || host == "::1" {
                return true;
            }
            
            // Parse as IP address
            if let Ok(ip) = host.parse::<IpAddr>() {
                match ip {
                    IpAddr::V4(ipv4) => {
                        // Private ranges: 10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16
                        // Loopback: 127.0.0.0/8
                        // Link-local: 169.254.0.0/16
                        let octets = ipv4.octets();
                        return octets[0] == 10
                            || octets[0] == 127
                            || (octets[0] == 172 && octets[1] >= 16 && octets[1] <= 31)
                            || (octets[0] == 192 && octets[1] == 168)
                            || (octets[0] == 169 && octets[1] == 254);
                    },
                    IpAddr::V6(ipv6) => {
                        // Block loopback and private IPv6 ranges
                        return ipv6.is_loopback() || ipv6.segments()[0] >= 0xfc00;
                    },
                }
            }
        }
    }
    false
}
```

## Proof of Concept

```rust
#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_percent_encoded_ip_bypass() {
        // Setup mock blacklist containing localhost and private IPs
        let blacklist = vec![
            "127.0.0.1".to_string(),
            "localhost".to_string(),
            "192.168.".to_string(),
            "10.".to_string(),
        ];
        
        // Test cases that SHOULD be blocked but currently pass
        let malicious_uris = vec![
            "http://%31%32%37.%30.%30.%31/admin",           // 127.0.0.1
            "http://%6c%6f%63%61%6c%68%6f%73%74/admin",    // localhost
            "http://%31%39%32.%31%36%38.1.1/admin",        // 192.168.1.1
            "http://%31%30.0.0.1/admin",                   // 10.0.0.1
        ];
        
        for uri in malicious_uris {
            // Current implementation (vulnerable)
            let is_blocked = blacklist.iter().any(|b| uri.contains(b));
            assert!(!is_blocked, "Current implementation fails to block: {}", uri);
            
            // Parse URL to show it decodes to internal address
            if let Ok(parsed) = Url::parse(uri) {
                let host = parsed.host_str().unwrap_or("");
                println!("Decoded host: {} from URI: {}", host, uri);
                
                // Verify the decoded host matches a blacklist entry
                let should_be_blocked = blacklist.iter().any(|b| host.contains(b));
                assert!(should_be_blocked, "After decoding, {} should be blocked", host);
            }
        }
    }
    
    #[tokio::test]
    async fn test_ssrf_exploitation() {
        // Simulate the attack path
        let malicious_uri = "http://%31%32%37.%30.%30.%31:8080/admin";
        
        // This would pass blacklist check (vulnerable)
        let blacklist = vec!["127.0.0.1".to_string()];
        let passes_check = !blacklist.iter().any(|b| malicious_uri.contains(b));
        assert!(passes_check, "Blacklist check incorrectly passes");
        
        // URL parsing succeeds
        assert!(Url::parse(malicious_uri).is_ok(), "URL parsing succeeds");
        
        // Reqwest would decode this to 127.0.0.1:8080
        // (Cannot demonstrate actual network request in unit test,
        //  but the url crate's behavior is documented in RFC 3986)
    }
}
```

**Notes:**
- This vulnerability specifically affects the NFT metadata crawler service infrastructure
- While not a consensus-breaking bug, it represents a significant security risk to validator and indexer infrastructure
- The percent-encoding bypass is a well-documented attack technique (CWE-918: Server-Side Request Forgery)
- Proper URL normalization must be performed BEFORE any security checks to prevent encoding-based bypasses

### Citations

**File:** ecosystem/nft-metadata-crawler/src/parser/worker.rs (L93-100)
```rust
        // Check asset_uri against the URI blacklist
        if self.is_blacklisted_uri(&self.asset_uri.clone()) {
            self.log_info("Found match in URI blacklist, marking as do_not_parse");
            self.model.set_do_not_parse(true);
            self.upsert();
            SKIP_URI_COUNT.with_label_values(&["blacklist"]).inc();
            return Ok(());
        }
```

**File:** ecosystem/nft-metadata-crawler/src/parser/worker.rs (L102-108)
```rust
        // Skip if asset_uri is not a valid URI, do not write invalid URI to Postgres
        if Url::parse(&self.asset_uri).is_err() {
            self.log_info("URI is invalid, skipping parse, marking as do_not_parse");
            self.model.set_do_not_parse(true);
            SKIP_URI_COUNT.with_label_values(&["invalid"]).inc();
            return Ok(());
        }
```

**File:** ecosystem/nft-metadata-crawler/src/parser/worker.rs (L386-391)
```rust
    fn is_blacklisted_uri(&mut self, uri: &str) -> bool {
        self.parser_config
            .uri_blacklist
            .iter()
            .any(|blacklist_uri| uri.contains(blacklist_uri))
    }
```

**File:** ecosystem/nft-metadata-crawler/src/utils/json_parser.rs (L27-32)
```rust
    pub async fn parse(
        uri: String,
        max_file_size_bytes: u32,
    ) -> anyhow::Result<(Option<String>, Option<String>, Value)> {
        PARSE_JSON_INVOCATION_COUNT.inc();
        let (mime, size) = get_uri_metadata(&uri).await?;
```

**File:** ecosystem/nft-metadata-crawler/src/utils/json_parser.rs (L60-64)
```rust
                let response = client
                    .get(uri.trim())
                    .send()
                    .await
                    .context("Failed to get JSON")?;
```

**File:** ecosystem/nft-metadata-crawler/src/utils/image_optimizer.rs (L61-65)
```rust
                let response = client
                    .get(uri.trim())
                    .send()
                    .await
                    .context("Failed to get image")?;
```
