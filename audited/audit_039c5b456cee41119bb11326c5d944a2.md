# Audit Report

## Title
TypeTag Depth Limit Mismatch Causes Event Emission Failures for Valid Types

## Summary
Move smart contracts can construct types with nesting depth up to 20 levels (enforced by verifier and runtime), but TypeTag serialization enforces a stricter limit of 8 levels. When native functions convert these valid runtime types to TypeTags for event emission, the TypeTags are successfully created in memory but fail during BCS serialization, causing transactions to abort unexpectedly.

## Finding Description

The Aptos Move VM has a critical inconsistency between type depth validation and TypeTag serialization limits:

**Type Creation Path (allows depth ≤ 20):**
1. The bytecode verifier enforces `max_type_depth: 20` for function values [1](#0-0) 

2. The production gas schedule sets `max_ty_depth: 20` [2](#0-1) 

3. Runtime type construction enforces this 20-depth limit via `TypeBuilder` [3](#0-2) 

**TypeTag Conversion Path (bypasses 8-depth limit):**
4. Native functions like `type_of` and event emission call `context.type_to_type_tag()` which uses `TypeTagConverter` [4](#0-3) 

5. `TypeTagConverter::ty_to_ty_tag_impl` recursively constructs TypeTags WITHOUT checking against `MAX_TYPE_TAG_NESTING`—it only performs pseudo-gas metering [5](#0-4) 

**Serialization Failure Point (enforces depth ≤ 8):**
6. When creating events, `ContractEvent::new_v1/v2` calls `bcs::serialized_size(&self.type_tag)` to compute event size [6](#0-5) 

7. BCS serialization triggers `type_tag_recursive_serialize` which enforces `MAX_TYPE_TAG_NESTING = 8` [7](#0-6) 

8. If TypeTag depth > 8, serialization fails with "type tag nesting exceeded during serialization", causing `ContractEvent::new` to return an error and the transaction to abort with `ECANNOT_CREATE_EVENT` [8](#0-7) 

**Attack Scenario:**
A contract using a type like `vector<vector<vector<vector<vector<vector<vector<vector<vector<u8>>>>>>>>>` (9 levels) passes all verification and type instantiation checks but fails when emitting events, causing unexpected transaction aborts.

## Impact Explanation

**Severity: Medium**

This vulnerability creates a state where legitimate code that passes bytecode verification fails at runtime in an unexpected and unrecoverable way. The impacts include:

1. **Unexpected Transaction Failures**: Contracts using types with depth 9-20 will pass verification but fail when emitting events, violating the expectation that verified code executes correctly.

2. **Potential System Contract Failures**: If Aptos framework contracts or governance mechanisms use deeply nested types and attempt to emit events, critical operations could fail.

3. **DoS Attack Vector**: Malicious actors can deploy contracts designed to always fail when emitting events, wasting gas and potentially griefing users.

4. **State Inconsistencies**: The inconsistency between what the type system allows and what serialization supports creates an unexpected runtime failure mode that may require protocol intervention to fix.

This qualifies as **Medium Severity** under "State inconsistencies requiring intervention" - the gap between verified types (depth ≤ 20) and serializable TypeTags (depth ≤ 8) creates an operational inconsistency in the protocol.

## Likelihood Explanation

**Likelihood: Medium**

While deeply nested types are uncommon in practice, this vulnerability is:

1. **Easy to Trigger**: Any contract using types with depth > 8 will hit this issue when emitting events
2. **Not Immediately Obvious**: Developers won't discover this limitation until runtime, as verification passes
3. **Affects Valid Code**: This isn't an exploit of malformed bytecode—it affects legitimate contracts that follow all verification rules
4. **No Warning at Deploy Time**: Module deployment succeeds; the error only surfaces during event emission

The likelihood is medium because while most contracts use shallow types, generic frameworks or recursive data structures might legitimately exceed depth 8.

## Recommendation

**Fix: Enforce consistent depth limits across type creation and TypeTag serialization**

Option 1 (Immediate): Add depth checking to `TypeTagConverter::ty_to_ty_tag_impl` to fail early with a clear error when converting types with depth > `MAX_TYPE_TAG_NESTING`:

```rust
fn ty_to_ty_tag_impl(
    &self,
    ty: &Type,
    gas_context: &mut PseudoGasContext,
    depth: u8,  // Add depth parameter
) -> PartialVMResult<TypeTag> {
    // Check depth limit
    if depth > move_core_types::language_storage::MAX_TYPE_TAG_NESTING {
        return Err(PartialVMError::new(StatusCode::TYPE_TAG_LIMIT_EXCEEDED)
            .with_message("Type tag nesting exceeded maximum allowed depth"));
    }
    
    gas_context.charge_base()?;
    
    Ok(match ty {
        // ... existing cases, incrementing depth for nested types
        Type::Vector(elem_ty) => {
            let elem_ty_tag = self.ty_to_ty_tag_impl(elem_ty, gas_context, depth + 1)?;
            TypeTag::Vector(Box::new(elem_ty_tag))
        },
        // ... similar for Struct and Function variants
    })
}
```

Option 2 (Long-term): Increase `MAX_TYPE_TAG_NESTING` to match `max_type_depth` (20) and ensure all serialization paths can handle the increased depth without stack overflow.

## Proof of Concept

```move
module 0x1::deep_type_test {
    use std::event;
    
    struct DeepEvent<T> has drop, store {
        data: T
    }
    
    // Type with 9 levels of nesting (exceeds MAX_TYPE_TAG_NESTING = 8)
    public entry fun emit_deep_event() {
        event::emit(DeepEvent<vector<vector<vector<vector<vector<vector<vector<vector<u8>>>>>>>>>{
            data: vector[]
        });
        // Transaction will abort with ECANNOT_CREATE_EVENT
        // because bcs::serialized_size(&type_tag) fails during event creation
    }
}
```

When this module is called:
1. Bytecode verification succeeds (depth 9 < max_type_depth 20)
2. Type instantiation succeeds
3. Event emission calls `context.type_to_type_tag()` which succeeds
4. `ContractEvent::new_v2()` calls `bcs::serialized_size(&type_tag)`
5. Serialization fails: "type tag nesting exceeded during serialization"
6. Transaction aborts with error code 1 (`ECANNOT_CREATE_EVENT`)

This demonstrates that TypeTagConverter bypasses the serialization depth limit, creating TypeTags that cannot be serialized despite being constructed from valid types.

## Notes

The root cause is an architectural mismatch: runtime types support depth 20 for computational flexibility, while TypeTag serialization enforces depth 8 for safety. The TypeTagConverter acts as a bridge but doesn't validate this constraint, allowing creation of unserializable TypeTags. This affects the **Move VM Safety** and **Resource Limits** invariants by allowing verified code to fail unexpectedly at runtime.

### Citations

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L188-192)
```rust
        max_type_depth: if enable_function_values {
            Some(20)
        } else {
            None
        },
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L270-274)
```rust
        [
            max_ty_depth: NumTypeNodes,
            { RELEASE_V1_15.. => "max_ty_depth" },
            20,
        ],
```

**File:** third_party/move/move-vm/types/src/loaded_data/runtime_types.rs (L1195-1223)
```rust
    fn check(&self, count: &mut u64, depth: u64) -> PartialVMResult<()> {
        if *count >= self.max_ty_size {
            return self.too_many_nodes_error();
        }
        if depth > self.max_ty_depth {
            return self.too_large_depth_error();
        }
        Ok(())
    }

    #[cold]
    fn too_many_nodes_error(&self) -> PartialVMResult<()> {
        Err(
            PartialVMError::new(StatusCode::TOO_MANY_TYPE_NODES).with_message(format!(
                "Type size is larger than maximum {}",
                self.max_ty_size
            )),
        )
    }

    #[cold]
    fn too_large_depth_error(&self) -> PartialVMResult<()> {
        Err(
            PartialVMError::new(StatusCode::VM_MAX_TYPE_DEPTH_REACHED).with_message(format!(
                "Type depth is larger than maximum {}",
                self.max_ty_depth
            )),
        )
    }
```

**File:** aptos-move/framework/src/natives/event.rs (L102-120)
```rust
fn native_write_to_event_store(
    context: &mut SafeNativeContext,
    ty_args: &[Type],
    mut arguments: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    debug_assert!(ty_args.len() == 1);
    debug_assert!(arguments.len() == 3);

    let ty = &ty_args[0];
    let msg = arguments.pop_back().unwrap();
    let seq_num = safely_pop_arg!(arguments, u64);
    let guid = safely_pop_arg!(arguments, Vec<u8>);

    // TODO(Gas): Get rid of abstract memory size
    context.charge(
        EVENT_WRITE_TO_EVENT_STORE_BASE
            + EVENT_WRITE_TO_EVENT_STORE_PER_ABSTRACT_VALUE_UNIT * context.abs_val_size(&msg)?,
    )?;
    let ty_tag = context.type_to_type_tag(ty)?;
```

**File:** aptos-move/framework/src/natives/event.rs (L140-144)
```rust
    let ctx = context.extensions_mut().get_mut::<NativeEventContext>();
    let event =
        ContractEvent::new_v1(key, seq_num, ty_tag, blob).map_err(|_| SafeNativeError::Abort {
            abort_code: ECANNOT_CREATE_EVENT,
        })?;
```

**File:** third_party/move/move-vm/runtime/src/storage/ty_tag_converter.rs (L248-278)
```rust
    fn ty_to_ty_tag_impl(
        &self,
        ty: &Type,
        gas_context: &mut PseudoGasContext,
    ) -> PartialVMResult<TypeTag> {
        // Charge base cost at the start.
        gas_context.charge_base()?;

        Ok(match ty {
            // Primitive types.
            Type::Bool => TypeTag::Bool,
            Type::U8 => TypeTag::U8,
            Type::U16 => TypeTag::U16,
            Type::U32 => TypeTag::U32,
            Type::U64 => TypeTag::U64,
            Type::U128 => TypeTag::U128,
            Type::U256 => TypeTag::U256,
            Type::I8 => TypeTag::I8,
            Type::I16 => TypeTag::I16,
            Type::I32 => TypeTag::I32,
            Type::I64 => TypeTag::I64,
            Type::I128 => TypeTag::I128,
            Type::I256 => TypeTag::I256,
            Type::Address => TypeTag::Address,
            Type::Signer => TypeTag::Signer,

            // Vector types: recurse.
            Type::Vector(elem_ty) => {
                let elem_ty_tag = self.ty_to_ty_tag_impl(elem_ty, gas_context)?;
                TypeTag::Vector(Box::new(elem_ty_tag))
            },
```

**File:** types/src/contract_event.rs (L227-230)
```rust
    pub fn size(&self) -> anyhow::Result<usize> {
        let size = self.key.size() + 8 /* u64 */ + bcs::serialized_size(&self.type_tag)? + self.event_data.len();
        Ok(size)
    }
```

**File:** third_party/move/move-core/types/src/safe_serialize.rs (L11-44)
```rust
pub(crate) const MAX_TYPE_TAG_NESTING: u8 = 8;

thread_local! {
    static TYPE_TAG_DEPTH: RefCell<u8> = const { RefCell::new(0) };
}

pub(crate) fn type_tag_recursive_serialize<S, T>(t: &T, s: S) -> Result<S::Ok, S::Error>
where
    S: Serializer,
    T: Serialize,
{
    use serde::ser::Error;

    // For testability, we allow to serialize one more level than deserialize.
    const MAX_TYPE_TAG_NESTING_WHEN_SERIALIZING: u8 =
        MAX_TYPE_TAG_NESTING + if cfg!(test) { 1 } else { 0 };

    TYPE_TAG_DEPTH.with(|depth| {
        let mut r = depth.borrow_mut();
        if *r >= MAX_TYPE_TAG_NESTING_WHEN_SERIALIZING {
            return Err(S::Error::custom(
                "type tag nesting exceeded during serialization",
            ));
        }
        *r += 1;
        Ok(())
    })?;
    let res = t.serialize(s);
    TYPE_TAG_DEPTH.with(|depth| {
        let mut r = depth.borrow_mut();
        *r -= 1;
    });
    res
}
```
