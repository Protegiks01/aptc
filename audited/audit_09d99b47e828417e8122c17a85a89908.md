# Audit Report

## Title
Gas Metering Bypass via UTF-8 Validation Before Charge in native_format_list

## Summary
The `native_format_list` function in `string_utils.rs` performs UTF-8 validation on the format string before charging gas. When validation fails, the function aborts without charging for the O(n) validation work performed, allowing attackers to execute computation without paying gas costs.

## Finding Description

The vulnerability exists in the native function implementation that handles format string operations. The core issue violates the fundamental gas charging principle documented in SafeNativeContext: [1](#0-0) 

In `native_format_list`, the execution flow is: [2](#0-1) 

The UTF-8 validation at line 609 performs O(n) work where n is the format string length. If validation fails, a `SafeNativeError::Abort` is returned: [3](#0-2) 

At this point, no gas has been charged yet (`context.legacy_gas_used` is 0). When the abort is converted to a `NativeResult`: [4](#0-3) 

The gas cost returned is 0. The VM then charges only this amount: [5](#0-4) 

Furthermore, the pre-execution gas charging is a no-op: [6](#0-5) 

**Attack Path:**
1. Attacker constructs a large byte vector (up to Move's vector size limit) containing mostly valid UTF-8 but with an invalid byte near the end
2. Calls `format1()` or similar functions that invoke `native_format_list`
3. The native function pops arguments and retrieves the format string bytes
4. UTF-8 validation scans through all bytes until it encounters the invalid byte
5. Validation fails, returning abort with 0 gas cost
6. Attacker repeats this in multiple transactions to perform free computation

This breaks **Critical Invariant #9** (Resource Limits: All operations must respect gas, storage, and computational limits) and **Critical Invariant #3** (Move VM Safety: Bytecode execution must respect gas limits).

## Impact Explanation

This is a **High Severity** vulnerability per Aptos bug bounty criteria because it enables:

1. **Validator Node Slowdowns**: Attackers can spam transactions with large invalid UTF-8 format strings, causing validators to perform O(n) validation work without charging proportional gas. This computational burden accumulates across multiple transactions.

2. **Gas Metering Bypass**: The fundamental security property that "all computation must be paid for" is violated. UTF-8 validation is expensive for large strings but goes unmetered.

3. **Protocol Violation**: The explicit contract documented in SafeNativeContext that "gas must be charged before execution" is broken, potentially affecting consensus determinism if different implementations optimize UTF-8 validation differently.

The impact aligns with "Validator node slowdowns" and "Significant protocol violations" from the High Severity category ($50,000 bounty).

## Likelihood Explanation

**Likelihood: HIGH**

- **Attacker Requirements**: Any unprivileged transaction sender can exploit this
- **Complexity**: Trivial - simply call `format1(&b"<large_invalid_utf8>", dummy_value)`
- **Cost**: Minimal gas (only base transaction cost + small native function overhead)
- **Detection**: Difficult to distinguish from legitimate failed format operations
- **Scalability**: Can be repeated across many transactions to amplify impact

The exploitation requires no special permissions, no validator collusion, and no complex setup. The attacker can submit transactions at the rate limited only by their APT balance for base transaction fees.

## Recommendation

**Fix**: Charge gas for UTF-8 validation BEFORE performing the validation work.

```rust
fn native_format_list(
    context: &mut SafeNativeContext,
    ty_args: &[Type],
    mut arguments: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    debug_assert!(ty_args.len() == 1);
    let mut list_ty = &ty_args[0];

    let val = safely_pop_arg!(arguments, Reference);
    let mut val = val
        .read_ref()
        .map_err(SafeNativeError::InvariantViolation)?;

    let fmt_ref = safely_pop_arg!(arguments, VectorRef);
    let fmt_ref2 = fmt_ref.as_bytes_ref();
    
    // FIXED: Charge gas BEFORE UTF-8 validation
    context.charge(STRING_UTILS_PER_BYTE * NumBytes::new(fmt_ref2.as_slice().len() as u64))?;
    
    // Now perform UTF-8 validation
    let fmt = std::str::from_utf8(fmt_ref2.as_slice()).map_err(|_| SafeNativeError::Abort {
        abort_code: EINVALID_FORMAT,
    })?;

    // Continue with rest of function...
```

This ensures that even if validation fails, the attacker has paid for the O(n) work performed.

## Proof of Concept

**Move Test** (add to `aptos-move/framework/aptos-stdlib/sources/string_utils.move`):

```move
#[test]
#[expected_failure(abort_code = EINVALID_FORMAT)]
fun test_gas_abuse_invalid_utf8() {
    // Create a large vector with invalid UTF-8
    let mut invalid_utf8 = vector::empty<u8>();
    let mut i = 0;
    
    // Fill with 100,000 valid ASCII bytes
    while (i < 100000) {
        vector::push_back(&mut invalid_utf8, 0x41); // 'A'
        i = i + 1;
    };
    
    // Add invalid UTF-8 continuation byte at the end
    vector::push_back(&mut invalid_utf8, 0xFF);
    
    // This should fail UTF-8 validation after scanning 100,000 bytes
    // but without proper gas charging, this work is free
    format1(&invalid_utf8, 1u64);
}
```

**Exploitation Script** (pseudo-code):
```python
# Attacker submits many transactions like this:
for i in range(1000):
    invalid_utf8 = b'A' * 100000 + b'\xFF'
    tx = create_transaction(
        function="0x1::string_utils::format1",
        args=[invalid_utf8, 1]
    )
    submit_transaction(tx)
    # Each transaction performs 100KB UTF-8 validation for minimal gas
    # Total: 100MB validation work for ~1000x base transaction cost
```

The validator must perform UTF-8 validation on 100,000 bytes per transaction, but the gas charged is only the base transaction overhead (essentially zero for the validation work itself).

## Notes

The same pattern is correctly implemented in other string functions: [7](#0-6) 

Where gas is charged at lines 46-49 BEFORE the UTF-8 validation at line 51. The `native_format_list` function should follow this same pattern.

### Citations

**File:** aptos-move/aptos-native-interface/src/context.rs (L69-73)
```rust
    /// Always remember: first charge gas, then execute!
    ///
    /// In other words, this function **MUST** always be called **BEFORE** executing **any**
    /// gas-metered operation or library call within a native function.
    #[must_use = "must always propagate the error returned by this function to the native function that called it using the ? operator"]
```

**File:** aptos-move/framework/src/natives/string_utils.rs (L606-613)
```rust
    let fmt_ref = safely_pop_arg!(arguments, VectorRef);
    let fmt_ref2 = fmt_ref.as_bytes_ref();
    // Could use unsafe here, but it's forbidden in this crate.
    let fmt = std::str::from_utf8(fmt_ref2.as_slice()).map_err(|_| SafeNativeError::Abort {
        abort_code: EINVALID_FORMAT,
    })?;

    context.charge(STRING_UTILS_PER_BYTE * NumBytes::new(fmt.len() as u64))?;
```

**File:** aptos-move/aptos-native-interface/src/builder.rs (L134-136)
```rust
                    Abort { abort_code } => {
                        Ok(NativeResult::err(context.legacy_gas_used, abort_code))
                    },
```

**File:** third_party/move/move-vm/runtime/src/interpreter.rs (L1150-1152)
```rust
            NativeResult::Abort { cost, abort_code } => {
                gas_meter.charge_native_function(cost, Option::<std::iter::Empty<&Value>>::None)?;
                Err(PartialVMError::new(StatusCode::ABORTED).with_sub_status(abort_code))
```

**File:** aptos-move/aptos-gas-meter/src/meter.rs (L208-214)
```rust
    fn charge_native_function_before_execution(
        &mut self,
        _ty_args: impl ExactSizeIterator<Item = impl TypeView>,
        _args: impl ExactSizeIterator<Item = impl ValueView>,
    ) -> PartialVMResult<()> {
        Ok(())
    }
```

**File:** aptos-move/framework/move-stdlib/src/natives/string.rs (L46-51)
```rust
    context.charge(
        STRING_CHECK_UTF8_BASE
            + STRING_CHECK_UTF8_PER_BYTE * NumBytes::new(s_ref.as_slice().len() as u64),
    )?;

    let ok = std::str::from_utf8(s_ref.as_slice()).is_ok();
```
