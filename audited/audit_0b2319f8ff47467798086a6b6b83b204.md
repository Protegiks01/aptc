# Audit Report

## Title
Missing Validation and Fuzzing Coverage for Groth16 Verification Key Deserialization Enables Potential Validator Node Crashes

## Summary
The `Groth16VerificationKey` deserialization path lacks both runtime validation and fuzz testing coverage. A validation function exists in the Move code but is never called when setting verification keys on-chain via governance proposals. This allows malformed elliptic curve point data to be stored on-chain, which could cause validator node crashes or non-deterministic behavior when loaded during epoch transitions.

## Finding Description
The security issue spans three critical gaps:

**Gap 1: Unused Validation Function**

A validation function `validate_groth16_vk` exists in the Move framework that validates all elliptic curve points using Move's native deserialization functions (which include proper length checks and error handling): [1](#0-0) 

However, this validation function is **never called** by any of the functions that set or update the verification key: [2](#0-1) [3](#0-2) 

**Gap 2: Missing Length Validation in Rust Deserialization**

When validators load the verification key from on-chain state, the Rust deserialization code does NOT validate byte lengths before calling arkworks' `deserialize_compressed`: [4](#0-3) 

Compare this to Move's native deserialization functions which properly validate byte lengths before deserializing: [5](#0-4) [6](#0-5) 

**Gap 3: No Fuzzing Coverage**

No fuzz tests exist for `Groth16VerificationKey` deserialization with malformed inputs. The existing fuzz tests focus on authenticators but do not specifically target verification key deserialization paths.

**Attack Path:**
1. Attacker submits a governance proposal to set a malformed `Groth16VerificationKey` with invalid byte lengths or malformed elliptic curve point encodings
2. Proposal passes (validation is not enforced)
3. At epoch transition, `on_new_epoch` applies the malformed VK
4. Each validator node attempts to deserialize the VK when loading the environment: [7](#0-6) 

5. If arkworks' `deserialize_compressed` has edge cases that panic (not just return errors) with specific malformed inputs, validators crash
6. If the behavior is non-deterministic across different systems/configurations, consensus breaks

## Impact Explanation
This is a **High Severity** issue per Aptos bug bounty criteria:

- **Validator node crashes**: Malformed verification keys could cause validator nodes to crash when loading keyless configuration during epoch transitions
- **Consensus disruption**: If different validators handle malformed data differently (some crash, some return errors gracefully), this could cause consensus liveness failures
- **Missing security validation**: The existence of an unused validation function indicates awareness of the risk, but the protection is not enforced

While I cannot definitively prove that arkworks will panic (the code uses error handling), the **lack of fuzzing coverage** means edge cases are untested. Without fuzz testing, we cannot guarantee that all malformed inputs are handled safely.

## Likelihood Explanation
**Medium-to-High Likelihood:**

- Requires governance proposal approval (trusted action), but governance compromise or mistakes are possible
- The attack surface is clearly exposed: anyone can propose a governance action
- The validation code exists but is unused, suggesting this was a known risk that wasn't properly mitigated
- Without fuzzing, unknown edge cases in arkworks deserialization remain possible

The comment in the Rust code acknowledges the validation performed in Move but expresses "paranoia" about skipping validation checks, indicating developers were aware of potential issues: [8](#0-7) 

## Recommendation
**Immediate Fix:**

1. **Call validation in Move code** - Modify `set_groth16_verification_key_for_next_epoch` to call `validate_groth16_vk`:

```move
public fun set_groth16_verification_key_for_next_epoch(fx: &signer, vk: Groth16VerificationKey) {
    system_addresses::assert_aptos_framework(fx);
    validate_groth16_vk(&vk);  // ADD THIS LINE
    config_buffer::upsert<Groth16VerificationKey>(vk);
}
```

2. **Add length validation in Rust** - Before calling `deserialize_compressed`, validate byte lengths:

```rust
impl TryFrom<&Groth16VerificationKey> for PreparedVerifyingKey<Bn254> {
    type Error = CryptoMaterialError;

    fn try_from(vk: &Groth16VerificationKey) -> Result<Self, Self::Error> {
        if vk.gamma_abc_g1.len() != 2 {
            return Err(CryptoMaterialError::DeserializationError);
        }
        
        // ADD THESE LENGTH CHECKS:
        if vk.alpha_g1.len() != 32 {
            return Err(CryptoMaterialError::DeserializationError);
        }
        if vk.beta_g2.len() != 64 || vk.gamma_g2.len() != 64 || vk.delta_g2.len() != 64 {
            return Err(CryptoMaterialError::DeserializationError);
        }
        for gamma_abc in &vk.gamma_abc_g1 {
            if gamma_abc.len() != 32 {
                return Err(CryptoMaterialError::DeserializationError);
            }
        }
        
        // ... rest of deserialization
    }
}
```

3. **Add fuzz testing** - Create a fuzz target specifically for `Groth16VerificationKey` deserialization:

```rust
// In testsuite/fuzzer/fuzz/fuzz_targets/groth16_vk_deserialize.rs
#![no_main]
use libfuzzer_sys::fuzz_target;
use aptos_types::keyless::Groth16VerificationKey;

fuzz_target!(|data: &[u8]| {
    let _ = bcs::from_bytes::<Groth16VerificationKey>(data);
});
```

## Proof of Concept

**Reproduction Steps:**

1. Create a malformed `Groth16VerificationKey` with incorrect byte lengths:

```move
#[test]
fun test_malformed_vk_not_validated() {
    let fx = create_signer_for_test(@aptos_framework);
    
    // Create VK with wrong byte lengths
    let malformed_vk = new_groth16_verification_key(
        vector[0u8], // alpha_g1: 1 byte instead of 32
        vector[0u8], // beta_g2: 1 byte instead of 64
        vector[0u8], // gamma_g2: 1 byte instead of 64
        vector[0u8], // delta_g2: 1 byte instead of 64
        vector[vector[0u8]], // gamma_abc_g1: 1 byte instead of 32
    );
    
    // This should fail but doesn't because validate_groth16_vk is not called
    set_groth16_verification_key_for_next_epoch(&fx, malformed_vk);
}
```

2. The malformed VK is accepted and queued for next epoch
3. During epoch transition, validators attempt to deserialize the malformed data
4. Depending on arkworks' internal behavior with wrong-sized inputs, this could cause crashes or undefined behavior

**Notes**
- The exact byte sizes expected are: G1 compressed = 32 bytes, G2 compressed = 64 bytes
- The Move validation function already implements the correct checks but is unused
- Without fuzzing, we cannot guarantee all arkworks edge cases are handled safely

### Citations

**File:** aptos-move/framework/aptos-framework/sources/keyless_account.move (L183-192)
```text
    fun validate_groth16_vk(vk: &Groth16VerificationKey) {
        // Could be leveraged to speed up the VM deserialization of the VK by 2x, since it can assume the points are valid.
        assert!(option::is_some(&crypto_algebra::deserialize<bn254_algebra::G1, bn254_algebra::FormatG1Compr>(&vk.alpha_g1)), E_INVALID_BN254_G1_SERIALIZATION);
        assert!(option::is_some(&crypto_algebra::deserialize<bn254_algebra::G2, bn254_algebra::FormatG2Compr>(&vk.beta_g2)), E_INVALID_BN254_G2_SERIALIZATION);
        assert!(option::is_some(&crypto_algebra::deserialize<bn254_algebra::G2, bn254_algebra::FormatG2Compr>(&vk.gamma_g2)), E_INVALID_BN254_G2_SERIALIZATION);
        assert!(option::is_some(&crypto_algebra::deserialize<bn254_algebra::G2, bn254_algebra::FormatG2Compr>(&vk.delta_g2)), E_INVALID_BN254_G2_SERIALIZATION);
        for (i in 0..vector::length(&vk.gamma_abc_g1)) {
            assert!(option::is_some(&crypto_algebra::deserialize<bn254_algebra::G1, bn254_algebra::FormatG1Compr>(vector::borrow(&vk.gamma_abc_g1, i))), E_INVALID_BN254_G1_SERIALIZATION);
        };
    }
```

**File:** aptos-move/framework/aptos-framework/sources/keyless_account.move (L263-266)
```text
    public fun set_groth16_verification_key_for_next_epoch(fx: &signer, vk: Groth16VerificationKey) {
        system_addresses::assert_aptos_framework(fx);
        config_buffer::upsert<Groth16VerificationKey>(vk);
    }
```

**File:** aptos-move/framework/aptos-framework/sources/keyless_account.move (L358-368)
```text
    public(friend) fun on_new_epoch(fx: &signer) acquires Groth16VerificationKey, Configuration {
        system_addresses::assert_aptos_framework(fx);

        if (config_buffer::does_exist<Groth16VerificationKey>()) {
            let vk = config_buffer::extract_v2();
            if (exists<Groth16VerificationKey>(@aptos_framework)) {
                *borrow_global_mut<Groth16VerificationKey>(@aptos_framework) = vk;
            } else {
                move_to(fx, vk);
            }
        };
```

**File:** types/src/keyless/groth16_vk.rs (L62-91)
```rust
impl TryFrom<&Groth16VerificationKey> for PreparedVerifyingKey<Bn254> {
    type Error = CryptoMaterialError;

    fn try_from(vk: &Groth16VerificationKey) -> Result<Self, Self::Error> {
        if vk.gamma_abc_g1.len() != 2 {
            return Err(CryptoMaterialError::DeserializationError);
        }

        // NOTE: Technically, we already validate the points when we set the VK in Move, so we could
        // make this 2x faster by avoiding the point validation checks  via
        // `deserialize_with_mode(..., Compress::Yes, Validate::No)`. Due to paranoia, will not
        // optimize this for now.
        Ok(Self::from(VerifyingKey {
            alpha_g1: G1Affine::deserialize_compressed(vk.alpha_g1.as_slice())
                .map_err(|_| CryptoMaterialError::DeserializationError)?,
            beta_g2: G2Affine::deserialize_compressed(vk.beta_g2.as_slice())
                .map_err(|_| CryptoMaterialError::DeserializationError)?,
            gamma_g2: G2Affine::deserialize_compressed(vk.gamma_g2.as_slice())
                .map_err(|_| CryptoMaterialError::DeserializationError)?,
            delta_g2: G2Affine::deserialize_compressed(vk.delta_g2.as_slice())
                .map_err(|_| CryptoMaterialError::DeserializationError)?,
            gamma_abc_g1: vec![
                G1Affine::deserialize_compressed(vk.gamma_abc_g1[0].as_slice())
                    .map_err(|_| CryptoMaterialError::DeserializationError)?,
                G1Affine::deserialize_compressed(vk.gamma_abc_g1[1].as_slice())
                    .map_err(|_| CryptoMaterialError::DeserializationError)?,
            ],
        }))
    }
}
```

**File:** aptos-move/framework/src/natives/cryptography/algebra/serialization.rs (L546-557)
```rust
        (Some(Structure::BN254G1), Some(SerializationFormat::BN254G1Compressed)) => {
            // Valid BN254G1AffineCompressed serialization should be 32-byte.
            if bytes.len() != 32 {
                return Ok(smallvec![Value::bool(false), Value::u64(0)]);
            }
            ark_ec_point_deserialize_internal!(
                context,
                bytes,
                ark_bn254::G1Affine,
                deserialize_compressed,
                ALGEBRA_ARK_BN254_G1_AFFINE_DESER_COMP
            )
```

**File:** aptos-move/framework/src/natives/cryptography/algebra/serialization.rs (L572-581)
```rust
        (Some(Structure::BN254G2), Some(SerializationFormat::BN254G2Compressed)) => {
            // Valid BN254G2AffineCompressed serialization should be 64-byte.
            if bytes.len() != 64 {
                return Ok(smallvec![Value::bool(false), Value::u64(0)]);
            }
            ark_ec_point_deserialize_internal!(
                context,
                bytes,
                ark_bn254::G2Affine,
                deserialize_compressed,
```

**File:** aptos-move/aptos-vm-environment/src/environment.rs (L289-293)
```rust
        let keyless_pvk =
            Groth16VerificationKey::fetch_keyless_config(state_view).and_then(|(vk, vk_bytes)| {
                sha3_256.update(&vk_bytes);
                vk.try_into().ok()
            });
```
