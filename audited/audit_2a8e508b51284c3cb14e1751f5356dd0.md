# Audit Report

## Title
Storage Service Rate Limiting Bypass for Validator Network Peers Enables Unlimited Reconnaissance and Resource Exhaustion

## Summary
The `TooManyInvalidRequests` rate limiting mechanism in the storage service completely fails to apply to validator network (NetworkId::Validator) and VFN network (NetworkId::Vfn) peers. While public network peers are ignored after 500 invalid requests (default), validator and VFN peers can send unlimited invalid requests without any rate limiting, allowing malicious validators to probe storage capabilities, perform reconnaissance, and potentially cause resource exhaustion.

## Finding Description
The storage service implements a request moderator that tracks invalid requests per peer and ignores peers that exceed a threshold. However, the rate limiting logic contains a critical network-type check that exempts validator and VFN peers from being ignored. [1](#0-0) 

The `increment_invalid_request_count` function only marks a peer for ignoring if the condition `peer_network_id.network_id().is_public_network()` is true. This means:

- **NetworkId::Public peers**: Rate-limited (ignored after 500 invalid requests by default)
- **NetworkId::Validator peers**: Never rate-limited (unlimited invalid requests allowed)
- **NetworkId::Vfn peers**: Never rate-limited (unlimited invalid requests allowed) [2](#0-1) 

The network type check ensures only public network peers face consequences. The validation logic in the handler correctly converts the error to `TooManyInvalidRequests`: [3](#0-2) 

But this error is never triggered for validator/VFN networks due to the conditional check. The configuration defines the thresholds: [4](#0-3) [5](#0-4) [6](#0-5) 

The differential treatment is explicitly tested and confirmed as intended behavior: [7](#0-6) 

**Attack Path:**
1. Malicious validator or compromised VFN operator connects to storage service nodes
2. Attacker sends unlimited invalid `StorageServiceRequest` messages (e.g., requesting data beyond highest synced version)
3. Each invalid request increments the unhealthy peer counter but never triggers ignore logic
4. Attacker can probe for data availability, system state, epoch boundaries, and storage capabilities
5. Sustained attack can cause CPU/memory exhaustion on storage nodes processing validation checks
6. No rate limiting or backoff mechanism protects storage nodes from this abuse

## Impact Explanation
This is a **HIGH severity** vulnerability per Aptos bug bounty criteria:

- **Validator node slowdowns**: Continuous invalid requests from malicious validators force storage nodes to repeatedly validate unsatisfiable requests, consuming CPU and memory. Each request traverses the full validation pipeline including storage summary checks and moderator validation.

- **Significant protocol violation**: The asymmetric trust model violates defense-in-depth principles. While validators are assumed to be mostly honest due to stake requirements, a single compromised or malicious validator can abuse this unlimited access without consequence.

- **Resource exhaustion vector**: Processing request validation, checking storage summaries, and tracking unhealthy peer states consumes resources. Without rate limiting, a malicious validator can sustain high-frequency invalid requests indefinitely.

- **Reconnaissance enablement**: Unlimited probing allows attackers to map storage node capabilities, discover synchronization state, identify data availability windows, and fingerprint node configurations without detection or throttling.

The impact does not reach Critical severity because it does not directly cause loss of funds, consensus safety violations, or permanent network partition. However, it represents a significant operational security weakness.

## Likelihood Explanation
**Likelihood: MEDIUM-HIGH**

The vulnerability is **highly likely to be exploited** for the following reasons:

1. **Low barrier to entry**: Any validator operator or VFN operator can exploit this. The Aptos network has hundreds of validators, and compromising or operating a malicious VFN is achievable.

2. **Zero detection**: Invalid requests are logged but not permanently tracked for validator networks. No alerting or punishment mechanism exists.

3. **Immediate exploitability**: No complex setup required - simply send invalid storage requests using the existing network protocols.

4. **Operational incentive**: During network stress or state sync operations, storage nodes are critical infrastructure. Reconnaissance to identify weakest nodes or slowdown attacks on competitor validators could provide strategic advantages.

5. **Testing confirms design**: The explicit test coverage shows this is working as designed, meaning it's unlikely to be accidentally fixed and represents a persistent attack surface.

The only mitigating factor is that validator operators have economic incentives (staked tokens) not to harm the network, but this doesn't protect against compromised nodes, malicious VFN operators (who may not have stake), or validators acting under perverse incentives.

## Recommendation
Apply rate limiting uniformly across all network types while allowing for different threshold configurations. The security principle of defense-in-depth requires protection even against potentially trusted peers.

**Recommended Fix:**

```rust
// In moderator.rs, modify increment_invalid_request_count:
pub fn increment_invalid_request_count(&mut self, peer_network_id: &PeerNetworkId) {
    // Increment the invalid request count
    self.invalid_request_count += 1;

    // Apply rate limiting to all network types, but with different thresholds
    // Public networks: strict limits (existing behavior)
    // Validator/VFN networks: higher limits but still bounded
    let should_ignore = match peer_network_id.network_id() {
        NetworkId::Public => {
            self.invalid_request_count >= self.max_invalid_requests
        },
        NetworkId::Validator | NetworkId::Vfn => {
            // Allow 10x more invalid requests for trusted networks
            // but still apply rate limiting
            self.invalid_request_count >= self.max_invalid_requests * 10
        },
    };

    if self.ignore_start_time.is_none() && should_ignore {
        // Start ignoring the peer
        self.ignore_start_time = Some(self.time_service.now());
        
        // Log with appropriate severity based on network type
        let log_level = if peer_network_id.network_id().is_public_network() {
            "WARN"
        } else {
            "ERROR" // Validator/VFN abuse is more serious
        };
        
        warn!(LogSchema::new(LogEntry::RequestModeratorIgnoredPeer)
            .peer_network_id(peer_network_id)
            .message(&format!(
                "[{}] Ignoring peer due to too many invalid requests!", 
                log_level
            )));
    }
}
```

**Configuration Changes:**

Add separate configuration parameters:
```rust
pub struct StorageServiceConfig {
    // ... existing fields ...
    pub max_invalid_requests_per_peer: u64,
    pub max_invalid_requests_per_validator: u64, // New: Higher limit for validators
    pub max_invalid_requests_per_vfn: u64,       // New: Higher limit for VFNs
    // ...
}
```

This preserves the trust model (validators get higher limits) while maintaining defense-in-depth (all peers eventually get rate-limited).

## Proof of Concept

The vulnerability is already demonstrated in the existing test suite: [8](#0-7) 

**Exploitation Steps:**

1. Deploy a validator or VFN node on the Aptos network
2. Connect to storage service nodes via the validator/VFN network
3. Send invalid `StorageServiceRequest` messages continuously:
   ```rust
   let request = StorageServiceRequest::new(
       DataRequest::GetTransactionsWithProof(TransactionsWithProofRequest {
           proof_version: u64::MAX,  // Request impossible version
           start_version: u64::MAX,
           end_version: u64::MAX,
           include_events: false,
       }),
       true,
   );
   ```
4. Observe that requests continue to be processed without rate limiting
5. Monitor storage node CPU/memory usage increases
6. Scale up request rate to cause node slowdown

The test at line 91-116 explicitly validates that VFN peers sending `max_invalid_requests_per_peer * 2` invalid requests are never ignored, confirming the vulnerability.

## Notes

This vulnerability represents a **design flaw** rather than an implementation bug - the behavior is explicitly tested and intentional. However, intentional behavior can still constitute a security vulnerability when it violates defense-in-depth principles and creates exploitable attack vectors.

The assumption that validator/VFN networks are "trusted" is insufficient because:
- Individual validators may be compromised
- VFN operators may not have sufficient stake at risk
- Economic incentives may not always align with network health
- Defense-in-depth requires protection layers even against partially trusted actors

### Citations

**File:** state-sync/storage-service/server/src/moderator.rs (L50-69)
```rust
    pub fn increment_invalid_request_count(&mut self, peer_network_id: &PeerNetworkId) {
        // Increment the invalid request count
        self.invalid_request_count += 1;

        // If the peer is a PFN and has sent too many invalid requests, start ignoring it
        if self.ignore_start_time.is_none()
            && peer_network_id.network_id().is_public_network()
            && self.invalid_request_count >= self.max_invalid_requests
        {
            // TODO: at some point we'll want to terminate the connection entirely

            // Start ignoring the peer
            self.ignore_start_time = Some(self.time_service.now());

            // Log the fact that we're now ignoring the peer
            warn!(LogSchema::new(LogEntry::RequestModeratorIgnoredPeer)
                .peer_network_id(peer_network_id)
                .message("Ignoring peer due to too many invalid requests!"));
        }
    }
```

**File:** config/src/network_id.rs (L159-170)
```rust
impl NetworkId {
    pub fn is_public_network(&self) -> bool {
        self == &NetworkId::Public
    }

    pub fn is_vfn_network(&self) -> bool {
        self == &NetworkId::Vfn
    }

    pub fn is_validator_network(&self) -> bool {
        self == &NetworkId::Validator
    }
```

**File:** state-sync/storage-service/server/src/handler.rs (L196-202)
```rust
        process_result.map_err(|error| match error {
            Error::InvalidRequest(error) => StorageServiceError::InvalidRequest(error),
            Error::TooManyInvalidRequests(error) => {
                StorageServiceError::TooManyInvalidRequests(error)
            },
            error => StorageServiceError::InternalError(error.to_string()),
        })
```

**File:** config/src/config/state_sync_config.rs (L163-164)
```rust
    /// Maximum number of invalid requests per peer
    pub max_invalid_requests_per_peer: u64,
```

**File:** config/src/config/state_sync_config.rs (L201-201)
```rust
            max_invalid_requests_per_peer: 500,
```

**File:** config/src/config/state_sync_config.rs (L213-213)
```rust
            min_time_to_ignore_peers_secs: 300, // 5 minutes
```

**File:** state-sync/storage-service/server/src/tests/request_moderator.rs (L30-117)
```rust
async fn test_request_moderator_ignore_pfn() {
    // Create test data
    let highest_synced_version = 100;
    let highest_synced_epoch = 10;

    // Create a storage service config for testing
    let max_invalid_requests_per_peer = 5;
    let storage_service_config = StorageServiceConfig {
        max_invalid_requests_per_peer,
        ..Default::default()
    };

    // Create the storage client and server
    let (mut mock_client, mut service, _, _, _) =
        MockClient::new(None, Some(storage_service_config));
    utils::update_storage_server_summary(
        &mut service,
        highest_synced_version,
        highest_synced_epoch,
    );

    // Get the request moderator and verify the initial state
    let request_moderator = service.get_request_moderator();
    let unhealthy_peer_states = request_moderator.get_unhealthy_peer_states();
    assert!(unhealthy_peer_states.is_empty());

    // Spawn the server
    tokio::spawn(service.start());

    // Process several invalid PFN requests
    let pfn_peer_network_id = PeerNetworkId::new(NetworkId::Public, PeerId::random());
    for _ in 0..max_invalid_requests_per_peer {
        // Send the invalid request
        let response = send_invalid_transaction_request(
            highest_synced_version,
            &mut mock_client,
            pfn_peer_network_id,
        )
        .await;

        // Verify we get an invalid request error
        assert_matches!(
            response.unwrap_err(),
            StorageServiceError::InvalidRequest(_)
        );
    }

    // Send another request and verify the PFN is now ignored
    let response = send_invalid_transaction_request(
        highest_synced_version,
        &mut mock_client,
        pfn_peer_network_id,
    )
    .await;
    assert_matches!(
        response.unwrap_err(),
        StorageServiceError::TooManyInvalidRequests(_)
    );

    // Process many invalid requests from a VFN and verify it is never ignored
    let vfn_peer_network_id = PeerNetworkId::new(NetworkId::Vfn, PeerId::random());
    for _ in 0..max_invalid_requests_per_peer * 2 {
        // Send the invalid request
        let response = send_invalid_transaction_request(
            highest_synced_version,
            &mut mock_client,
            vfn_peer_network_id,
        )
        .await;

        // Verify we get an invalid request error
        assert_matches!(
            response.unwrap_err(),
            StorageServiceError::InvalidRequest(_)
        );
    }

    // Verify the unhealthy peer states
    assert_eq!(unhealthy_peer_states.len(), 2);

    // Verify the unhealthy peer state for the PFN
    let unhealthy_pfn_state = unhealthy_peer_states.get(&pfn_peer_network_id).unwrap();
    assert!(unhealthy_pfn_state.is_ignored());

    // Verify the unhealthy peer state for the VFN
    let unhealthy_vfn_state = unhealthy_peer_states.get(&vfn_peer_network_id).unwrap();
    assert!(!unhealthy_vfn_state.is_ignored());
}
```
