# Audit Report

## Title
Inspection Service Peer Information Endpoint Lacks Rate Limiting Leading to Resource Exhaustion DoS

## Summary
The `/peer_information` endpoint in the inspection service performs expensive O(N) operations over all connected peers without any rate limiting or authentication, allowing unauthenticated attackers to cause resource exhaustion and node performance degradation through repeated requests.

## Finding Description

The `display_state_sync_metadata()` function performs multiple expensive operations that scale linearly with the number of connected peers (typically 100-500, potentially more): [1](#0-0) 

This function calls `get_priority_and_regular_peers()` which iterates through all connected peers twice: [2](#0-1) 

The first iteration calls `get_all_connected_peers()` which queries the network layer for all connected peers: [3](#0-2) 

This in turn calls `get_connected_supported_peers()` which performs an O(N) iteration: [4](#0-3) 

The second iteration classifies each peer's priority by calling `is_high_priority_peer()` for every peer, which involves additional metadata lookups: [5](#0-4) 

The endpoint is publicly accessible without authentication and enabled by default for testnet nodes: [6](#0-5) 

The inspection service has NO rate limiting implemented: [7](#0-6) 

**Attack Path:**
1. Attacker discovers inspection service on default port 9101
2. Attacker sends thousands of requests per second to `/peer_information`
3. Each request triggers 3+ O(N) iterations over all peers (N=100-500 typical)
4. CPU cycles are consumed for peer iteration, metadata lookups, and string formatting
5. Node performance degrades due to CPU contention

With 500 peers and 100 requests/second, this results in ~150,000 peer iterations per second plus overhead, causing measurable CPU consumption on the validator node.

## Impact Explanation

This qualifies as **High Severity** under the Aptos bug bounty criteria: "Validator node slowdowns."

While the inspection service runs in a separate runtime thread, it shares the same physical CPU resources as the validator process. Sustained high-frequency requests can:
- Consume significant CPU cycles through repeated peer iterations
- Cause CPU cache contention on shared data structures
- Degrade overall node performance including validation operations
- Impact node responsiveness and potentially affect consensus participation

The code documentation itself acknowledges peer counts can be substantial: [8](#0-7) 

## Likelihood Explanation

**High Likelihood:**
- The endpoint is enabled by default for testnet configurations
- Listens on all network interfaces (0.0.0.0)
- No authentication required
- Publicly documented endpoint path (`/peer_information`)
- Simple HTTP GET requests can trigger the vulnerability
- Attacker needs no special privileges or insider access

## Recommendation

Implement rate limiting on the inspection service endpoints:

```rust
// Add to InspectionServiceConfig
pub struct InspectionServiceConfig {
    pub address: String,
    pub port: u16,
    pub expose_peer_information: bool,
    // Add rate limiting configuration
    pub max_requests_per_second: Option<u32>,
    pub max_requests_per_ip_per_minute: Option<u32>,
}

// In serve_requests(), add rate limiting check before processing
async fn serve_requests(
    req: Request<Body>,
    node_config: NodeConfig,
    aptos_data_client: AptosDataClient,
    peers_and_metadata: Arc<PeersAndMetadata>,
    rate_limiter: Arc<RateLimiter>, // Add rate limiter
) -> Result<Response<Body>, hyper::Error> {
    // Check rate limit before processing request
    if let Err(e) = rate_limiter.check_rate_limit(&req) {
        return Ok(Response::builder()
            .status(StatusCode::TOO_MANY_REQUESTS)
            .body(Body::from("Rate limit exceeded"))
            .unwrap());
    }
    
    // ... rest of request handling
}
```

Additional recommendations:
1. Add authentication for sensitive endpoints
2. Consider caching peer information responses with short TTL
3. Add metrics to track endpoint request rates
4. Document the security considerations in the config

## Proof of Concept

```bash
#!/bin/bash
# PoC: DoS attack on inspection service peer information endpoint

TARGET_HOST="testnet-validator.example.com"
TARGET_PORT="9101"
CONCURRENT_REQUESTS=100

echo "Starting DoS attack on $TARGET_HOST:$TARGET_PORT/peer_information"
echo "Sending $CONCURRENT_REQUESTS concurrent requests repeatedly..."

# Install Apache Bench if not present
# apt-get install apache2-utils

# Send continuous requests with 100 concurrent connections
ab -n 100000 -c $CONCURRENT_REQUESTS \
   "http://$TARGET_HOST:$TARGET_PORT/peer_information"

# Alternative using GNU parallel for sustained attack:
# seq 1 10000 | parallel -j 100 'curl -s http://$TARGET_HOST:$TARGET_PORT/peer_information > /dev/null'
```

**Expected Result:**
- Monitoring will show increased CPU usage on the target validator node
- Response times for the endpoint will increase
- Other node operations may experience performance degradation
- No authentication or rate limiting prevents the attack

**Notes**

The vulnerability is particularly concerning because:
1. The inspection service shares CPU resources with critical validator operations despite running in a separate runtime
2. Default configuration exposes the endpoint without protection
3. Testnet validators (which process real value in some cases) are affected by default
4. No operator warning exists about the performance implications of exposing this endpoint
5. The attack requires minimal resources from the attacker but can consume significant validator resources

### Citations

**File:** crates/aptos-inspection-service/src/server/peer_information.rs (L206-271)
```rust
fn display_state_sync_metadata(
    peer_information_output: &mut Vec<String>,
    all_peers: &Vec<PeerNetworkId>,
    aptos_data_client: AptosDataClient,
) {
    peer_information_output.push("State sync metadata for each peer:".into());

    // Fetch and display the priority and regular peers
    if let Ok((priority_peers, regular_peers)) = aptos_data_client.get_priority_and_regular_peers()
    {
        // Sort the peer lists before displaying them
        let mut priority_peers: Vec<_> = priority_peers.into_iter().collect();
        priority_peers.sort();
        let mut regular_peers: Vec<_> = regular_peers.into_iter().collect();
        regular_peers.sort();

        // Display the priority and regular peers
        peer_information_output.push(format!(
            "\t- Priority peers: {:?}, regular peers: {:?}",
            priority_peers, regular_peers
        ));
    }

    // Fetch and display the global advertised data summary
    let global_data_summary = aptos_data_client.get_global_data_summary();
    peer_information_output.push(format!(
        "\t- Global advertised data summary: {:?}",
        global_data_summary
    ));

    // Fetch and display the state sync metadata for each peer
    let peer_to_state = aptos_data_client.get_peer_states().get_peer_to_states();
    for peer in all_peers {
        if let Some(peer_state_entry) = peer_to_state.get(peer) {
            // Get the peer states
            let peer = *peer_state_entry.key();
            let peer_bucket_id = peer_states::get_bucket_id_for_peer(peer);
            let peer_score = peer_state_entry.get_score();
            let peer_storage_summary = peer_state_entry.get_storage_summary();

            // Display the peer states
            peer_information_output.push(format!(
                "\t- Peer: {}, score: {}, bucket ID: {}",
                peer, peer_score, peer_bucket_id
            ));
            peer_information_output.push(format!(
                "\t\t- Advertised storage summary: {:?}",
                peer_storage_summary
            ));

            // Get the peer's request/response counts
            let sent_requests_by_type = peer_state_entry.get_sent_requests_by_type();
            let received_responses_by_type = peer_state_entry.get_received_responses_by_type();

            // Display the peer's request/response counts
            peer_information_output.push(format!(
                "\t\t- Sent requests by type: {:?}",
                sent_requests_by_type
            ));
            peer_information_output.push(format!(
                "\t\t- Received responses by type: {:?}",
                received_responses_by_type
            ));
        }
    }
}
```

**File:** state-sync/aptos-data-client/src/client.rs (L563-572)
```rust
    fn get_all_connected_peers(&self) -> crate::error::Result<HashSet<PeerNetworkId>, Error> {
        let connected_peers = self.storage_service_client.get_available_peers()?;
        if connected_peers.is_empty() {
            return Err(Error::NoConnectedPeers(
                "No available peers found!".to_owned(),
            ));
        }

        Ok(connected_peers)
    }
```

**File:** state-sync/aptos-data-client/src/client.rs (L603-625)
```rust
    pub fn get_priority_and_regular_peers(
        &self,
    ) -> crate::error::Result<(HashSet<PeerNetworkId>, HashSet<PeerNetworkId>), Error> {
        // Get all connected peers
        let all_connected_peers = self.get_all_connected_peers()?;

        // Gather the priority and regular peers
        let mut priority_peers = hashset![];
        let mut regular_peers = hashset![];
        for peer in all_connected_peers {
            if priority::is_high_priority_peer(
                self.base_config.clone(),
                self.get_peers_and_metadata(),
                &peer,
            ) {
                priority_peers.insert(peer);
            } else {
                regular_peers.insert(peer);
            }
        }

        Ok((priority_peers, regular_peers))
    }
```

**File:** network/framework/src/application/storage.rs (L31-35)
```rust
// notification_backlog is how many ConnectionNotification items can be queued waiting for an app to receive them.
// Beyond this, new messages will be dropped if the app is not handling them fast enough.
// We make this big enough to fit an initial burst of _all_ the connected peers getting notified.
// Having 100 connected peers is common, 500 not unexpected
const NOTIFICATION_BACKLOG: usize = 1000;
```

**File:** network/framework/src/application/storage.rs (L129-148)
```rust
    pub fn get_connected_supported_peers(
        &self,
        protocol_ids: &[ProtocolId],
    ) -> Result<Vec<PeerNetworkId>, Error> {
        // Get the cached peers and metadata
        let cached_peers_and_metadata = self.cached_peers_and_metadata.load();

        // Collect all connected peers that support at least one of the given protocols
        let mut connected_supported_peers = Vec::new();
        for (network_id, peers_and_metadata) in cached_peers_and_metadata.iter() {
            for (peer_id, peer_metadata) in peers_and_metadata.iter() {
                if peer_metadata.is_connected() && peer_metadata.supports_any_protocol(protocol_ids)
                {
                    let peer_network_id = PeerNetworkId::new(*network_id, *peer_id);
                    connected_supported_peers.push(peer_network_id);
                }
            }
        }
        Ok(connected_supported_peers)
    }
```

**File:** state-sync/aptos-data-client/src/priority.rs (L132-139)
```rust
pub fn is_high_priority_peer(
    base_config: Arc<BaseConfig>,
    peers_and_metadata: Arc<PeersAndMetadata>,
    peer: &PeerNetworkId,
) -> bool {
    let peer_priority = get_peer_priority(base_config, peers_and_metadata, peer);
    peer_priority.is_high_priority()
}
```

**File:** config/src/config/inspection_service_config.rs (L26-36)
```rust
impl Default for InspectionServiceConfig {
    fn default() -> InspectionServiceConfig {
        InspectionServiceConfig {
            address: "0.0.0.0".to_string(),
            port: 9101,
            expose_configuration: false,
            expose_identity_information: true,
            expose_peer_information: true,
            expose_system_information: true,
        }
    }
```

**File:** crates/aptos-inspection-service/src/server/mod.rs (L104-154)
```rust
async fn serve_requests(
    req: Request<Body>,
    node_config: NodeConfig,
    aptos_data_client: AptosDataClient,
    peers_and_metadata: Arc<PeersAndMetadata>,
) -> Result<Response<Body>, hyper::Error> {
    // Process the request and get the response components
    let (status_code, body, content_type) = match req.uri().path() {
        CONFIGURATION_PATH => {
            // /configuration
            // Exposes the node configuration
            configuration::handle_configuration_request(&node_config)
        },
        CONSENSUS_HEALTH_CHECK_PATH => {
            // /consensus_health_check
            // Exposes the consensus health check
            metrics::handle_consensus_health_check(&node_config).await
        },
        FORGE_METRICS_PATH => {
            // /forge_metrics
            // Exposes forge encoded metrics
            metrics::handle_forge_metrics()
        },
        IDENTITY_INFORMATION_PATH => {
            // /identity_information
            // Exposes the identity information of the node
            identity_information::handle_identity_information_request(&node_config)
        },
        INDEX_PATH => {
            // /
            // Exposes the index and list of available endpoints
            index::handle_index_request()
        },
        JSON_METRICS_PATH => {
            // /json_metrics
            // Exposes JSON encoded metrics
            metrics::handle_json_metrics_request()
        },
        METRICS_PATH => {
            // /metrics
            // Exposes text encoded metrics
            metrics::handle_metrics_request()
        },
        PEER_INFORMATION_PATH => {
            // /peer_information
            // Exposes the peer information
            peer_information::handle_peer_information_request(
                &node_config,
                aptos_data_client,
                peers_and_metadata,
            )
```
