# Audit Report

## Title
Event Attribute Validation Bypass Allows Module Upgrade Denial of Service

## Summary
The `verify_module_metadata_for_module_publishing` function fails to validate that event attributes in `struct_attributes` reference existing structs in the module. This allows an attacker to publish a module with event attributes for non-existent structs, which passes initial validation but causes all future upgrade attempts to fail with validation errors.

## Finding Description

The validation logic in `verify_module_metadata_for_module_publishing` properly checks that resource group and function attributes reference valid structs/functions, but the event attribute validation is incomplete. [1](#0-0) 

For event attributes, the code simply continues without verifying that the struct name (the key in `struct_attributes`) corresponds to an actual struct definition in the module. In contrast, resource group attributes are properly validated: [2](#0-1) 

The `is_valid_resource_group` function checks if the struct exists in the module's struct definitions: [3](#0-2) 

**Attack Flow:**

1. Attacker crafts a `RuntimeModuleMetadataV1` with `struct_attributes` containing entries like `{"NonExistentStruct": [KnownAttribute::event()]}` where "NonExistentStruct" does not exist in the module
2. Module is published and passes validation because event attributes skip struct existence checks
3. Module gets cached in the system
4. When extracting event metadata during upgrade validation, the malformed attributes are extracted without validation: [4](#0-3) 

5. During module upgrade, the validation enforces that all event attributes from the old module must exist in the new module: [5](#0-4) 

6. Since the new (correctly formed) module doesn't have event attributes for non-existent structs, the upgrade fails with `EVENT_METADATA_VALIDATION_ERROR` [6](#0-5) 

## Impact Explanation

**Medium Severity** - This meets the "State inconsistencies requiring intervention" criterion:

- **Denial of Service**: Legitimate module upgrades become impossible once malformed metadata is cached
- **Module Bricking**: Deployed modules with malformed event attributes cannot be fixed through normal upgrade mechanisms
- **Operational Impact**: Requires manual intervention or governance actions to resolve
- **No Direct Fund Loss**: Does not lead to theft or minting of funds
- **No Consensus Impact**: Does not affect consensus safety or block production

The vulnerability allows an attacker to permanently brick their own modules or, if they control deployment of critical infrastructure modules, prevent legitimate maintenance and security patches.

## Likelihood Explanation

**Medium Likelihood**:

- **Low Attacker Complexity**: Crafting malformed metadata is straightforward using BCS serialization
- **High Discovery Likelihood**: Any developer attempting module upgrades would encounter this
- **Prerequisite**: Attacker must control initial module deployment
- **Feature Flag Dependency**: Requires `is_module_event_enabled()` to be true
- **Limited Scope**: Only affects modules with maliciously crafted metadata

The attack is feasible but requires the attacker to intentionally deploy malformed metadata, limiting its occurrence to malicious scenarios or sophisticated testing bypasses.

## Recommendation

Add struct existence validation for event attributes, matching the pattern used for resource group attributes:

```rust
// In verify_module_metadata_for_module_publishing, replace lines 507-509 with:

if features.is_module_event_enabled() && attr.is_event() {
    // Validate that the struct actually exists in the module
    if let Ok(ident_struct) = Identifier::new(struct_) {
        if structs.get(ident_struct.as_ident_str()).is_some() {
            continue;
        }
    }
    // Struct doesn't exist - return error
    return Err(AttributeValidationError {
        key: struct_.clone(),
        attribute: attr.kind,
    }
    .into());
}
```

Alternatively, create a dedicated `is_valid_event` function following the same pattern as `is_valid_resource_group`:

```rust
pub fn is_valid_event(
    structs: &BTreeMap<&IdentStr, (&StructHandle, &StructDefinition)>,
    struct_: &str,
) -> Result<(), AttributeValidationError> {
    if let Ok(ident_struct) = Identifier::new(struct_) {
        if structs.get(ident_struct.as_ident_str()).is_some() {
            return Ok(());
        }
    }
    Err(AttributeValidationError {
        key: struct_.to_string(),
        attribute: KnownAttributeKind::Event as u8,
    })
}
```

## Proof of Concept

```rust
// Create malformed module metadata with event attribute for non-existent struct
use aptos_types::vm::module_metadata::{RuntimeModuleMetadataV1, KnownAttribute};
use std::collections::BTreeMap;

let mut struct_attributes = BTreeMap::new();
// Add event attribute for a struct that doesn't exist in the module
struct_attributes.insert(
    "NonExistentStruct".to_string(), 
    vec![KnownAttribute::event()]
);

let malformed_metadata = RuntimeModuleMetadataV1 {
    error_map: BTreeMap::new(),
    struct_attributes,
    fun_attributes: BTreeMap::new(),
};

// Serialize this into the module's metadata section with APTOS_METADATA_KEY_V1
// The module will pass initial validation at line 507-509
// But future upgrades will fail at event_validation.rs line 74
```

**Move Test Case:**
```move
module 0xCAFE::Malicious {
    // Module has only one struct
    struct RealStruct has drop { value: u64 }
    
    // But metadata claims "FakeStruct" is an event (injected via custom metadata)
    // This will pass publishing but block all future upgrades
}
```

The attacker would need to manually craft the bytecode with malformed `RuntimeModuleMetadataV1` to inject event attributes for "FakeStruct" which doesn't exist in the module definition.

### Citations

**File:** types/src/vm/module_metadata.rs (L398-421)
```rust
pub fn is_valid_resource_group(
    structs: &BTreeMap<&IdentStr, (&StructHandle, &StructDefinition)>,
    struct_: &str,
) -> Result<(), AttributeValidationError> {
    if let Ok(ident_struct) = Identifier::new(struct_) {
        if let Some((struct_handle, struct_def)) = structs.get(ident_struct.as_ident_str()) {
            let num_fields = match &struct_def.field_information {
                StructFieldInformation::Native | StructFieldInformation::DeclaredVariants(_) => 0,
                StructFieldInformation::Declared(fields) => fields.len(),
            };
            if struct_handle.abilities == AbilitySet::EMPTY
                && struct_handle.type_parameters.is_empty()
                && num_fields == 1
            {
                return Ok(());
            }
        }
    }

    Err(AttributeValidationError {
        key: struct_.to_string(),
        attribute: KnownAttributeKind::ViewFunction as u8,
    })
}
```

**File:** types/src/vm/module_metadata.rs (L497-505)
```rust
                if attr.is_resource_group() && attr.get_resource_group().is_some() {
                    is_valid_resource_group(&structs, struct_)?;
                    continue;
                } else if attr.is_resource_group_member()
                    && attr.get_resource_group_member().is_some()
                {
                    is_valid_resource_group_member(&structs, struct_)?;
                    continue;
                }
```

**File:** types/src/vm/module_metadata.rs (L507-509)
```rust
            if features.is_module_event_enabled() && attr.is_event() {
                continue;
            }
```

**File:** aptos-move/aptos-vm/src/verifier/event_validation.rs (L69-77)
```rust
        if let Some(metadata) = old_module_metadata_if_exists {
            let original_event_structs = extract_event_metadata(&metadata)?;
            for member in original_event_structs {
                // Fail if we see a removal of an event attribute.
                if !new_event_structs.remove(&member) {
                    metadata_validation_err("Invalid change in event attributes")?;
                }
            }
        }
```

**File:** aptos-move/aptos-vm/src/verifier/event_validation.rs (L258-270)
```rust
pub(crate) fn extract_event_metadata(
    metadata: &RuntimeModuleMetadataV1,
) -> VMResult<HashSet<String>> {
    let mut event_structs = HashSet::new();
    for (struct_, attrs) in &metadata.struct_attributes {
        for attr in attrs {
            if attr.is_event() && !event_structs.insert(struct_.clone()) {
                metadata_validation_err("Found duplicate event attribute")?;
            }
        }
    }
    Ok(event_structs)
}
```

**File:** aptos-move/e2e-move-tests/src/tests/module_event.rs (L109-123)
```rust
    // Incompatible upgrades -- remove existing event attribute
    let source = r#"
        module 0xf00d::M {
            struct Event1 { }

            #[event]
            struct Event2 { }
        }
        "#;
    let mut builder = PackageBuilder::new("Package");
    builder.add_source("m.move", source);
    let path = builder.write_to_temp().unwrap();
    let result = h.publish_package(&account, path.path());
    assert_vm_status!(result, StatusCode::EVENT_METADATA_VALIDATION_ERROR);
}
```
