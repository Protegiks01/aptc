# Audit Report

## Title
Ciphertext Size Correlation Enables Transaction Type Inference in Encrypted Payloads

## Summary
The encrypted payload implementation in `types/src/transaction/encrypted_payload.rs` lacks padding mechanisms, causing ciphertext sizes to directly correlate with plaintext sizes. This allows passive network observers to infer transaction types (Script vs EntryFunction vs Empty) through traffic analysis, degrading the privacy guarantees of the encrypted transaction system.

## Finding Description

The encrypted payload system encrypts `DecryptedPayload` structures containing `TransactionExecutable` variants without applying constant-size padding. The encryption flow proceeds as follows: [1](#0-0) 

The `TransactionExecutable` enum has three variants with vastly different sizes: [2](#0-1) 

Script transactions contain full Move bytecode: [3](#0-2) 

EntryFunction transactions only reference existing on-chain code: [4](#0-3) 

The encryption uses AES-128-GCM through the batch encryption system: [5](#0-4) 

AES-GCM is a stream cipher that produces ciphertext of size `plaintext_size + 16` bytes (authentication tag), with no padding applied. BCS serialization is compact and does not pad to constant sizes: [6](#0-5) 

**Size Signatures:**
- Empty transactions: ~26 bytes (2 bytes enum + 8 bytes nonce + 16 bytes auth tag)
- EntryFunction: ~74-524 bytes (module ID + function name + arguments + overhead)
- Script: 1KB-100KB+ (full bytecode + arguments + overhead)

A passive network observer can trivially distinguish transaction types by size alone, defeating the confidentiality purpose of encryption.

## Impact Explanation

This constitutes a **Low Severity** information leak per the Aptos Bug Bounty criteria. While it enables traffic analysis attacks that can:
- Identify transaction types without decryption
- Build user behavior profiles based on transaction patterns
- Correlate encrypted transactions across the network
- Potentially identify specific smart contract interactions

It does **not** lead to:
- Loss of funds or unauthorized minting
- Consensus safety violations
- Network availability issues
- Execution of unauthorized transactions
- State corruption

The encrypted transaction system appears designed primarily for MEV (Miner Extractable Value) protection during transaction propagation, where hiding transaction content matters more than hiding transaction type. However, for use cases requiring full traffic analysis resistance, this size correlation represents a privacy degradation.

## Likelihood Explanation

**Likelihood: Very High (Certainty)**

This is not a probabilistic vulnerability but an inherent property of the current implementation. Every encrypted transaction transmitted over the network reveals its type through size:
- No attacker sophistication required
- Passive observation only (no active attacks needed)
- 100% success rate in transaction type inference
- Observable by any network peer

The issue occurs automatically for all encrypted transactions without any special conditions or attacker actions.

## Recommendation

Implement constant-size padding for encrypted payloads, similar to how `BatchPayload` uses padding: [7](#0-6) 

**Recommended Fix:**

1. Define a maximum encrypted payload size constant (e.g., `MAX_ENCRYPTED_PAYLOAD_BYTES = 100KB`)
2. Pad `DecryptedPayload` to this constant size before BCS serialization
3. Add a padding field to `DecryptedPayload`:

```rust
#[derive(Clone, Debug, Hash, Eq, PartialEq, Serialize, Deserialize)]
pub struct DecryptedPayload {
    executable: TransactionExecutable,
    decryption_nonce: u64,
    #[serde(with = "serde_bytes")]
    padding: Vec<u8>,
}
```

4. Before encryption, calculate required padding:
```rust
let serialized_size = bcs::serialized_size(&payload)?;
let padding_size = MAX_ENCRYPTED_PAYLOAD_BYTES.saturating_sub(serialized_size);
payload.padding = vec![0u8; padding_size];
```

5. After decryption, strip padding before processing.

**Trade-offs:** This increases bandwidth usage and storage requirements but provides traffic analysis resistance.

## Proof of Concept

```rust
#[test]
fn test_encrypted_payload_size_correlation() {
    use aptos_types::transaction::{
        Script, EntryFunction, TransactionExecutable, 
        encrypted_payload::DecryptedPayload
    };
    use move_core_types::language_storage::ModuleId;
    use move_core_types::identifier::Identifier;
    
    // Create three transaction types
    let empty = DecryptedPayload {
        executable: TransactionExecutable::Empty,
        decryption_nonce: 1,
    };
    
    let entry_fn = DecryptedPayload {
        executable: TransactionExecutable::EntryFunction(
            EntryFunction::new(
                ModuleId::new(AccountAddress::ZERO, Identifier::new("test").unwrap()),
                Identifier::new("function").unwrap(),
                vec![],
                vec![vec![1, 2, 3]],
            )
        ),
        decryption_nonce: 1,
    };
    
    let script = DecryptedPayload {
        executable: TransactionExecutable::Script(
            Script::new(vec![0u8; 10000], vec![], vec![])
        ),
        decryption_nonce: 1,
    };
    
    // Measure serialized sizes
    let empty_size = bcs::serialized_size(&empty).unwrap();
    let entry_size = bcs::serialized_size(&entry_fn).unwrap();
    let script_size = bcs::serialized_size(&script).unwrap();
    
    // After AES-GCM encryption, add 16 bytes for auth tag
    println!("Empty ciphertext size: {} bytes", empty_size + 16);
    println!("EntryFunction ciphertext size: {} bytes", entry_size + 16);
    println!("Script ciphertext size: {} bytes", script_size + 16);
    
    // Sizes are dramatically different, enabling type inference
    assert!(script_size > entry_size * 10);
    assert!(entry_size > empty_size * 5);
}
```

## Notes

While this is a valid information leak, it represents a **design limitation** rather than an implementation bug. The encrypted transaction feature may prioritize performance and bandwidth efficiency over complete traffic analysis resistance. The Low severity rating acknowledges that this leak does not compromise core blockchain security properties (consensus, fund safety, liveness) but does reduce privacy guarantees for users requiring full transaction confidentiality.

### Citations

**File:** types/src/transaction/encrypted_payload.rs (L14-24)
```rust
#[derive(Clone, Debug, Hash, Eq, PartialEq, Serialize, Deserialize)]
pub struct DecryptedPayload {
    executable: TransactionExecutable,
    decryption_nonce: u64,
}

impl DecryptedPayload {
    pub fn unwrap(self) -> (TransactionExecutable, u64) {
        (self.executable, self.decryption_nonce)
    }
}
```

**File:** types/src/transaction/mod.rs (L716-721)
```rust
#[derive(Clone, Debug, Hash, Eq, PartialEq, Serialize, Deserialize)]
pub enum TransactionExecutable {
    Script(Script),
    EntryFunction(EntryFunction),
    Empty,
}
```

**File:** types/src/transaction/script.rs (L63-69)
```rust
#[derive(Clone, Hash, Eq, PartialEq, Serialize, Deserialize)]
pub struct Script {
    #[serde(with = "serde_bytes")]
    code: Vec<u8>,
    ty_args: Vec<TypeTag>,
    args: Vec<TransactionArgument>,
}
```

**File:** types/src/transaction/script.rs (L108-115)
```rust
#[derive(Clone, Debug, Hash, Eq, PartialEq, Serialize, Deserialize)]
pub struct EntryFunction {
    module: ModuleId,
    function: Identifier,
    ty_args: Vec<TypeTag>,
    #[serde(with = "vec_bytes")]
    args: Vec<Vec<u8>>,
}
```

**File:** crates/aptos-batch-encryption/src/shared/symmetric.rs (L86-109)
```rust
    pub fn encrypt<R: RngCore + CryptoRng>(
        &self,
        rng: &mut R,
        plaintext: &impl Plaintext,
    ) -> Result<SymmetricCiphertext> {
        use aes_gcm::KeyInit as _; // putting this in the global scope causes Hmac<Sha256> to be
                                   // ambiguous for some reason

        let key: &Key<SymmetricCipher> = &self.0;

        let cipher = SymmetricCipher::new(key);
        let nonce = SymmetricCipher::generate_nonce(rng); // 96-bits; unique per message
                                                          //
        let mut plaintext_bytes = Vec::new();
        bcs::serialize_into(&mut plaintext_bytes, &plaintext)
            .map_err(|_| BatchEncryptionError::SerializationError)?;

        Ok(SymmetricCiphertext {
            nonce,
            ct_body: cipher
                .encrypt(&nonce, plaintext_bytes.as_ref())
                .map_err(|_| BatchEncryptionError::SymmetricEncryptionError)?,
        })
    }
```

**File:** config/src/config/quorum_store_config.rs (L12-12)
```rust
pub const BATCH_PADDING_BYTES: usize = 160;
```
