# Audit Report

## Title
Race Condition in Validator Key File Generation Allows Key Corruption During Concurrent Writes

## Summary
The key generation CLI commands (`aptos genesis generate-keys`, `aptos key generate`) do not implement file locking during write operations to private and public key files. This allows concurrent executions to race, potentially corrupting critical validator identity files through interleaved writes or partial truncation.

## Finding Description

The key file write operations in the Aptos CLI lack any file locking mechanism, creating a race condition vulnerability when multiple processes attempt to generate or write keys to the same output directory concurrently.

**Vulnerable Code Flow:**

1. Key generation starts in `GenerateKey::execute()` or `GenerateKeys::execute()`: [1](#0-0) 

2. Keys are saved via `save_key()` which calls through to file write operations: [2](#0-1) 

3. The underlying `write_to_file_with_opts()` uses standard `OpenOptions` without any locking: [3](#0-2) 

4. The `save_to_file_confidential()` method for private keys also lacks locking: [4](#0-3) 

**Attack/Failure Scenario:**

When two processes execute key generation commands concurrently with the same output directory:

- **Process A**: Opens `private-keys.yaml` with `create(true).truncate(true)`, begins writing key K1
- **Process B**: Opens `private-keys.yaml` with `create(true).truncate(true)`, truncates file, begins writing key K2  
- **Process A**: Writes `public-keys.yaml` with K1's public key
- **Process B**: Writes `public-keys.yaml` with K2's public key (overwrites A's write)
- **Result**: The files may contain:
  - Partial/corrupted data from interleaved writes
  - Mismatched key pairs (private key from one generation, public key from another)
  - Truncated content making keys unreadable

**Concurrent Execution Contexts:**

The codebase shows parallel key generation is used in practice: [5](#0-4) 

While each validator gets a separate directory in the automated scripts, the vulnerability can be triggered by:
- User accidentally running the same command twice (appears hung, retries in new terminal)
- Automation scripts with race conditions
- Parallel test/development scripts targeting the same output directory

**File Locking Exists Elsewhere in Codebase:**

The codebase already implements proper file locking in other critical areas using the `fs2` crate: [6](#0-5) 

This demonstrates the codebase recognizes the need for file locking in concurrent scenarios, but this protection was not applied to key file writes.

## Impact Explanation

**Severity: Medium**

This qualifies as Medium severity under the Aptos bug bounty criteria for the following reasons:

1. **State inconsistencies requiring intervention**: Corrupted validator keys would require manual intervention to detect and regenerate, potentially blocking critical genesis procedures or validator onboarding.

2. **Operational security impact**: While not directly causing consensus violations, corrupted validator identity files could:
   - Prevent validators from joining the network during time-sensitive genesis events
   - Cause authentication failures that are difficult to debug (mismatched keys)
   - Force re-runs of genesis ceremonies if detected late

3. **Scope limitation**: The vulnerability affects operator tooling rather than the core protocol, preventing it from reaching High/Critical severity. However, validator identity management is security-critical infrastructure that directly enables network participation.

## Likelihood Explanation

**Likelihood: Medium**

This vulnerability has medium likelihood of occurrence because:

1. **Realistic trigger conditions**:
   - Users commonly retry commands that appear unresponsive
   - Genesis setup involves multiple rapid CLI operations
   - CI/CD pipelines may trigger parallel executions

2. **Practical scenarios**:
   - Testnet creation uses parallel key generation (shown in Python scripts)
   - Operators setting up multiple validators may use parallel execution
   - Network issues can cause users to retry commands

3. **Detection difficulty**: File corruption from race conditions may not be immediately apparent - keys might appear syntactically valid but contain mismatched or partial data, leading to failures only during actual validator operation.

## Recommendation

Implement advisory file locking for all key file write operations using the `fs2` crate (already present in the dependency tree):

```rust
use fs2::FileExt;
use std::fs::File;

pub fn write_to_file_with_opts(
    path: &Path,
    name: &str,
    bytes: &[u8],
    opts: &mut OpenOptions,
) -> CliTypedResult<()> {
    // Acquire exclusive lock before writing
    let lock_path = path.with_extension("lock");
    let lock_file = File::create(&lock_path)
        .map_err(|e| CliError::IO(name.to_string(), e))?;
    lock_file.lock_exclusive()
        .map_err(|e| CliError::IO(format!("{} (lock)", name), e))?;
    
    let mut file = opts
        .write(true)
        .create(true)
        .truncate(true)
        .open(path)
        .map_err(|e| CliError::IO(name.to_string(), e))?;
    
    let result = file.write_all(bytes)
        .map_err(|e| CliError::IO(name.to_string(), e));
    
    // Lock is automatically released when lock_file is dropped
    drop(lock_file);
    let _ = std::fs::remove_file(&lock_path); // Best effort cleanup
    
    result
}
```

Alternatively, use the existing `FileLock` pattern from the Move package cache, adapting it for synchronous operations.

## Proof of Concept

**Bash script to reproduce the race condition:**

```bash
#!/bin/bash

# Create test directory
TEST_DIR=$(mktemp -d)
OUTPUT_DIR="$TEST_DIR/keys"

echo "Testing concurrent key generation in $OUTPUT_DIR"

# Function to generate keys
generate_keys() {
    aptos genesis generate-keys \
        --output-dir "$OUTPUT_DIR" \
        --assume-yes 2>&1 | grep -E "(Error|Success|failed)"
}

# Run two key generations concurrently
generate_keys & 
PID1=$!
generate_keys &
PID2=$!

# Wait for both to complete
wait $PID1
wait $PID2

# Check for file corruption
echo -e "\nChecking for corruption in $OUTPUT_DIR:"

if [ -f "$OUTPUT_DIR/private-keys.yaml" ]; then
    echo "Validating private-keys.yaml..."
    if ! aptos genesis set-validator-configuration \
        --owner-public-identity-file "$OUTPUT_DIR/public-keys.yaml" \
        --local-repository-dir "$TEST_DIR" \
        --username test-validator \
        --validator-host 127.0.0.1:6180 \
        --full-node-host 127.0.0.1:6182 \
        --stake-amount 1 2>&1 | grep -q "Success"; then
        echo "ERROR: Keys appear corrupted or mismatched!"
        exit 1
    fi
else
    echo "ERROR: Key files not created!"
    exit 1
fi

# Cleanup
rm -rf "$TEST_DIR"
echo "Test completed"
```

**Expected behavior**: When run multiple times, this script will occasionally produce corrupted or mismatched key files that fail validation.

## Notes

This vulnerability affects the CLI tooling layer rather than the core blockchain protocol. While it doesn't directly impact consensus safety or on-chain state, it represents a significant operational security risk during validator setup and genesis procedures. The fix should be straightforward given that file locking infrastructure already exists in the codebase for similar use cases.

### Citations

**File:** crates/aptos/src/op/key.rs (L203-265)
```rust
    async fn execute(self) -> CliTypedResult<HashMap<&'static str, PathBuf>> {
        if self.vanity_prefix.is_some() && !matches!(self.key_type, KeyType::Ed25519) {
            return Err(CliError::CommandArgumentError(format!(
                "Vanity prefixes are only accepted for {} keys",
                KeyType::Ed25519
            )));
        }
        if self.vanity_multisig && self.vanity_prefix.is_none() {
            return Err(CliError::CommandArgumentError(
                "No vanity prefix provided".to_string(),
            ));
        }
        self.save_params.check_key_file()?;
        let mut keygen = self.rng_args.key_generator()?;
        match self.key_type {
            KeyType::X25519 => {
                let private_key = keygen.generate_x25519_private_key().map_err(|err| {
                    CliError::UnexpectedError(format!(
                        "Failed to convert ed25519 to x25519 {:?}",
                        err
                    ))
                })?;
                self.save_params.save_key(&private_key, "x25519")
            },
            KeyType::Ed25519 => {
                // If no vanity prefix specified, generate a standard Ed25519 private key.
                let private_key = if self.vanity_prefix.is_none() {
                    keygen.generate_ed25519_private_key()
                } else {
                    // If a vanity prefix is specified, generate vanity Ed25519 account from it.
                    generate_vanity_account_ed25519(
                        self.vanity_prefix.clone().unwrap().as_str(),
                        self.vanity_multisig,
                    )?
                };
                // Store CLI result from key save operation, to append vanity address(es) if needed.
                let mut result_map = self.save_params.save_key(&private_key, "ed25519").unwrap();
                if self.vanity_prefix.is_some() {
                    let account_address = account_address_from_public_key(
                        &ed25519::Ed25519PublicKey::from(&private_key),
                    );
                    // Store account address in a PathBuf so it can be displayed in CLI result.
                    result_map.insert(
                        "Account Address:",
                        PathBuf::from(account_address.to_hex_literal()),
                    );
                    if self.vanity_multisig {
                        let multisig_account_address =
                            create_multisig_account_address(account_address, 0);
                        result_map.insert(
                            "Multisig Account Address:",
                            PathBuf::from(multisig_account_address.to_hex_literal()),
                        );
                    }
                }
                return Ok(result_map);
            },
            KeyType::Bls12381 => {
                let private_key = keygen.generate_bls12381_private_key();
                self.save_params.save_bls_key(&private_key, "bls12381")
            },
        }
    }
```

**File:** crates/aptos/src/op/key.rs (L426-447)
```rust
    pub fn save_key<Key: PrivateKey + ValidCryptoMaterial>(
        self,
        key: &Key,
        key_name: &'static str,
    ) -> CliTypedResult<HashMap<&'static str, PathBuf>> {
        let encoded_private_key = self.encoding_options.encoding.encode_key(key_name, key)?;
        let encoded_public_key = self
            .encoding_options
            .encoding
            .encode_key(key_name, &key.public_key())?;

        // Write private and public keys to files
        let public_key_file = self.public_key_file()?;
        self.file_options
            .save_to_file_confidential(key_name, &encoded_private_key)?;
        write_to_file(&public_key_file, key_name, &encoded_public_key)?;

        let mut map = HashMap::new();
        map.insert("PrivateKey Path", self.file_options.output_file);
        map.insert("PublicKey Path", public_key_file);
        Ok(map)
    }
```

**File:** crates/aptos/src/common/utils.rs (L232-246)
```rust
pub fn write_to_file_with_opts(
    path: &Path,
    name: &str,
    bytes: &[u8],
    opts: &mut OpenOptions,
) -> CliTypedResult<()> {
    let mut file = opts
        .write(true)
        .create(true)
        .truncate(true)
        .open(path)
        .map_err(|e| CliError::IO(name.to_string(), e))?;
    file.write_all(bytes)
        .map_err(|e| CliError::IO(name.to_string(), e))
}
```

**File:** crates/aptos/src/common/types.rs (L1083-1089)
```rust
    /// Save to the `output_file` with restricted permissions (mode 0600)
    pub fn save_to_file_confidential(&self, name: &str, bytes: &[u8]) -> CliTypedResult<()> {
        let mut opts = OpenOptions::new();
        #[cfg(unix)]
        opts.mode(0o600);
        write_to_file_with_opts(self.output_file.as_path(), name, bytes, &mut opts)
    }
```

**File:** testsuite/pangu_lib/testnet_commands/create_testnet.py (L444-468)
```python
            coroutines.append(
                generate_keys_and_configuration(
                    GenesisNodeInformation(
                        vfn_image,
                        validator_image,
                        validator_storage_class_name,
                        vfn_storage_class_name,
                        vfn_validator_node_pair_name,
                        user_dir,
                        validator_host,
                        fullnode_host,
                        cur_stake_amount,
                        validator_config_path,
                        vfn_config_path,
                        persistent_volume_claim_size,
                        create_vfns,
                        cpu,
                        memory,
                    ),
                    args,
                    system_context,
                )
            )

    await asyncio.gather(*coroutines)
```

**File:** third_party/move/tools/move-package-cache/src/file_lock.rs (L15-66)
```rust
/// A file-based lock to ensure exclusive access to certain resources.
///
/// This is used by the package cache to ensure only one process can mutate a cached repo, checkout,
/// or on-chain package at a time.
pub struct FileLock {
    file: Option<File>,
    path: PathBuf,
}

impl FileLock {
    /// Attempts to acquire an exclusive `FileLock`, with an optional alert callback.
    ///
    /// If the lock cannot be acquired within `alert_timeout`, the `alert_on_wait` callback
    /// is executed to notify the caller.
    pub async fn lock_with_alert_on_wait<P, F>(
        lock_path: P,
        alert_timeout: Duration,
        alert_on_wait: F,
    ) -> Result<Self>
    where
        P: AsRef<Path>,
        F: FnOnce(),
    {
        let lock_path = lock_path.as_ref().to_owned();

        let lock_fut = {
            let lock_path = lock_path.clone();

            task::spawn_blocking(move || -> Result<File> {
                let lock_file = File::create(&lock_path)?;
                lock_file.lock_exclusive()?;
                Ok(lock_file)
            })
        };

        let timeout = tokio::time::sleep(alert_timeout).fuse();

        pin!(lock_fut, timeout);

        let lock_file = select! {
            _ = &mut timeout => {
                alert_on_wait();
                lock_fut.await??
            },
            res = &mut lock_fut => res??,
        };

        Ok(Self {
            file: Some(lock_file),
            path: lock_path,
        })
    }
```
