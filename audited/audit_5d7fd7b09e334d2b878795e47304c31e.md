# Audit Report

## Title
Insufficient Gas Metering for Transaction Argument Parsing Enables Validator CPU Exhaustion Attack

## Summary

Transaction argument validation in `transaction_arg_validation.rs` does not charge gas for recursive BCS parsing operations performed in `recursively_construct_arg`. An attacker can craft transactions with large vector arguments (e.g., `Vec<u8>` with hundreds of thousands of elements) that trigger millions of parsing iterations, consuming excessive validator CPU time while only paying intrinsic gas based on transaction byte size. When lazy loading is disabled, the parsing uses an `UnmeteredGasMeter`, charging zero gas for this work.

## Finding Description

The transaction argument validation system breaks the **Resource Limits** invariant (#9: "All operations must respect gas, storage, and computational limits") and the **Move VM Safety** invariant (#3: "Bytecode execution must respect gas limits and memory constraints").

**Vulnerable Code Path:**

1. The `construct_args` function explicitly acknowledges the issue with a TODO comment: [1](#0-0) 

2. The `recursively_construct_arg` function performs recursive parsing of vector arguments without charging gas for iterations: [2](#0-1) 

3. Primitive type parsing calls `read_n_bytes` without gas charges: [3](#0-2) 

4. The `dispatch_transaction_arg_validation` macro uses `UnmeteredGasMeter` when lazy loading is disabled, bypassing all gas charges: [4](#0-3) 

**Attack Scenario:**

An attacker creates an entry function that accepts `Vec<u8>` and submits a transaction with a vector containing 500,000 elements:
- Transaction size: ~500KB (under the 1MB `MAX_NUM_BYTES` limit)
- Parsing iterations: 500,000 (one per element)
- Each iteration: function call overhead + pattern matching + `read_n_bytes` (bounds checking, memory operations, cursor management)

**Gas Charging Analysis:**

Only intrinsic gas is charged based on transaction size: [5](#0-4) 

With parameters: [6](#0-5) 

For 500KB transaction:
- Intrinsic gas = 2,760,000 + 1,158 × (500,000 - 600) ≈ 580 million internal gas units
- This is a ONE-TIME charge based on size

However, the parsing work involves:
- 500,000 recursive function calls
- 500,000 pattern matches
- 500,000 `read_n_bytes` operations with bounds checking and memory allocation
- No per-iteration gas charges for this computational work

The vulnerability is further confirmed by the `max_invocations` limit which only applies to struct constructors, not vector elements: [7](#0-6) 

And string constructors bypass even this limit: [8](#0-7) 

## Impact Explanation

**Severity: High** - Validator Node Slowdowns

Per the Aptos bug bounty criteria, this qualifies as High severity because it enables "Validator node slowdowns."

**Impact:**
- Attackers can submit transactions that consume disproportionate validator CPU time relative to gas paid
- Network-wide throughput degradation as validators spend excessive time parsing arguments
- Potential for sustained DoS if attackers continuously submit such transactions
- All validators process the same blocks, so the attack affects the entire network simultaneously

The attack is particularly severe when lazy loading is disabled, as the `UnmeteredGasMeter` charges zero gas for argument validation, allowing completely free CPU consumption.

## Likelihood Explanation

**Likelihood: High**

- **Ease of exploitation:** Trivial - attacker only needs to submit a transaction with a large vector argument
- **Cost to attacker:** Low - only pays intrinsic gas based on transaction size, not computational work
- **Detection difficulty:** Hard to distinguish from legitimate large transactions
- **Frequency:** Can be repeated continuously by multiple attackers
- **No special privileges required:** Any account can submit transactions

The explicit TODO comment in the code indicates developers are aware that "proper gas metering" is needed but not yet implemented, confirming this is a known gap rather than a design feature.

## Recommendation

Implement per-iteration gas charging in the argument parsing loop:

1. **Charge gas for vector iteration:**
   - In `recursively_construct_arg`, charge gas proportional to vector length before entering the while loop
   - Use existing vector operation gas parameters (e.g., `VEC_UNPACK_PER_EXPECTED_ELEM`)

2. **Charge gas for primitive parsing:**
   - Add gas charges in `read_n_bytes` for bytes read, proportional to `n`
   - Use IO gas charges similar to storage operations

3. **Remove UnmeteredGasMeter usage:**
   - Always pass the real gas meter to argument validation, regardless of lazy loading status
   - The current optimization that bypasses metering when lazy loading is disabled creates a critical vulnerability

4. **Implement depth/complexity limits:**
   - Add a configurable limit on vector nesting depth
   - Track total parsing iterations and fail if exceeded

**Code Fix Example (pseudo-code):**

```rust
Vector(inner) => {
    let mut len = get_len(cursor)?;
    // CHARGE GAS for vector processing
    gas_meter.charge_execution(VEC_UNPACK_BASE + VEC_UNPACK_PER_EXPECTED_ELEM * NumArgs::new(len as u64))?;
    
    serialize_uleb128(len, arg);
    while len > 0 {
        recursively_construct_arg(...)?;
        len -= 1;
    }
}
```

## Proof of Concept

**Step 1: Create entry function**
```move
module attacker::exploit {
    entry fun consume_cpu(data: vector<u8>) {
        // Function body doesn't matter - the attack happens during argument parsing
    }
}
```

**Step 2: Submit malicious transaction**
```rust
// Create a Vec<u8> with 500,000 elements
let mut large_vec = Vec::with_capacity(500_000);
for _ in 0..500_000 {
    large_vec.push(0u8);
}

// Serialize as BCS
let bcs_arg = bcs::to_bytes(&large_vec).unwrap();

// Submit transaction calling consume_cpu with this argument
// The validator will perform 500,000+ parsing iterations
// Only intrinsic gas (~580M internal units) is charged
// Actual CPU cost is much higher due to parsing overhead
```

**Reproduction Steps:**
1. Deploy the Move module with the entry function accepting `vector<u8>`
2. Submit a transaction with a 500KB vector argument
3. Measure validator CPU time spent in `recursively_construct_arg`
4. Compare to gas charged (only intrinsic gas based on size)
5. Observe CPU time >> expected time for the gas charged

**Observable Impact:**
- Validator nodes show increased CPU usage in argument validation
- Transaction processing latency increases
- Network TPS decreases when multiple such transactions are submitted

### Citations

**File:** aptos-move/aptos-vm/src/verifier/transaction_arg_validation.rs (L242-242)
```rust
    // Perhaps in a future we should do proper gas metering here
```

**File:** aptos-move/aptos-vm/src/verifier/transaction_arg_validation.rs (L289-289)
```rust
            let mut max_invocations = 10; // Read from config in the future
```

**File:** aptos-move/aptos-vm/src/verifier/transaction_arg_validation.rs (L345-363)
```rust
        Vector(inner) => {
            // get the vector length and iterate over each element
            let mut len = get_len(cursor)?;
            serialize_uleb128(len, arg);
            while len > 0 {
                recursively_construct_arg(
                    session,
                    loader,
                    gas_meter,
                    traversal_context,
                    inner,
                    allowed_structs,
                    cursor,
                    initial_cursor_len,
                    max_invocations,
                    arg,
                )?;
                len -= 1;
            }
```

**File:** aptos-move/aptos-vm/src/verifier/transaction_arg_validation.rs (L394-399)
```rust
        Bool | U8 | I8 => read_n_bytes(1, cursor, arg)?,
        U16 | I16 => read_n_bytes(2, cursor, arg)?,
        U32 | I32 => read_n_bytes(4, cursor, arg)?,
        U64 | I64 => read_n_bytes(8, cursor, arg)?,
        U128 | I128 => read_n_bytes(16, cursor, arg)?,
        U256 | I256 | Address => read_n_bytes(32, cursor, arg)?,
```

**File:** aptos-move/aptos-vm/src/verifier/transaction_arg_validation.rs (L433-470)
```rust
    if constructor.func_name.as_str() == "utf8" {
        let constructor_error = || {
            // A slight hack, to prevent additional piping of the feature flag through all
            // function calls. We know the feature is active when more structs then just strings are
            // allowed.
            let are_struct_constructors_enabled = allowed_structs.len() > 1;
            if are_struct_constructors_enabled {
                PartialVMError::new(StatusCode::ABORTED)
                    .with_sub_status(1)
                    .at_code_offset(FunctionDefinitionIndex::new(0), 0)
                    .finish(Location::Module(constructor.module_id.clone()))
                    .into_vm_status()
            } else {
                VMStatus::error(StatusCode::FAILED_TO_DESERIALIZE_ARGUMENT, None)
            }
        };
        // Short cut for the utf8 constructor, which is a special case.
        let len = get_len(cursor)?;
        if cursor
            .position()
            .checked_add(len as u64)
            .is_none_or(|l| l > initial_cursor_len as u64)
        {
            // We need to make sure we do not allocate more bytes than
            // needed.
            return Err(VMStatus::error(
                StatusCode::FAILED_TO_DESERIALIZE_ARGUMENT,
                Some("String argument is too long".to_string()),
            ));
        }

        let mut arg = vec![];
        read_n_bytes(len, cursor, &mut arg)?;
        std::str::from_utf8(&arg).map_err(|_| constructor_error())?;
        return bcs::to_bytes(&arg)
            .map_err(|_| VMStatus::error(StatusCode::FAILED_TO_DESERIALIZE_ARGUMENT, None));
    } else {
        *max_invocations -= 1;
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L213-225)
```rust
        } else {
            let traversal_storage = TraversalStorage::new();
            transaction_arg_validation::validate_combine_signer_and_txn_args(
                $session,
                $loader,
                &mut UnmeteredGasMeter,
                &mut TraversalContext::new(&traversal_storage),
                $serialized_signers,
                $args,
                $function,
                $struct_constructors_enabled,
            )
        }
```

**File:** aptos-move/aptos-gas-meter/src/meter.rs (L607-615)
```rust
    fn charge_intrinsic_gas_for_transaction(&mut self, txn_size: NumBytes) -> VMResult<()> {
        let excess = txn_size
            .checked_sub(self.vm_gas_params().txn.large_transaction_cutoff)
            .unwrap_or_else(|| 0.into());

        self.algebra
            .charge_execution(MIN_TRANSACTION_GAS_UNITS + INTRINSIC_GAS_PER_BYTE * excess)
            .map_err(|e| e.finish(Location::Undefined))
    }
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L33-48)
```rust
            min_transaction_gas_units: InternalGas,
            "min_transaction_gas_units",
            2_760_000
        ],
        // Any transaction over this size will be charged an additional amount per byte.
        [
            large_transaction_cutoff: NumBytes,
            "large_transaction_cutoff",
            600
        ],
        // The units of gas that to be charged per byte over the `large_transaction_cutoff` in addition to
        // `min_transaction_gas_units` for transactions whose size exceeds `large_transaction_cutoff`.
        [
            intrinsic_gas_per_byte: InternalGasPerByte,
            "intrinsic_gas_per_byte",
            1_158
```
