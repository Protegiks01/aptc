# Audit Report

## Title
Module Publishing Bypasses Block Conflict Detection Due to Unimplemented Feature Flag

## Summary
The `use_module_publishing_block_conflict` flag in `BlockGasLimitType::ComplexLimitV1` is completely ignored in production code, allowing module publishing transactions to bypass conflict detection and the associated gas penalty multiplier. Despite being set to `true` in genesis configuration and explicitly documented with "NOTE: Currently not supported," the feature is not implemented, creating a false sense of security.

## Finding Description
The Aptos block executor uses a conflict penalty system to inflate effective block gas consumption when transactions have read/write conflicts. This mechanism is designed to prevent resource contention and ensure fair gas accounting. [1](#0-0) 

The flag `use_module_publishing_block_conflict` claims to enable accounting for module publishing conflicts. However, investigation reveals three critical implementation gaps:

**Gap 1: Flag Accessor Never Called**
The accessor method `use_module_publishing_block_conflict()` defined in the configuration is never invoked anywhere in the production codebase. [2](#0-1) 

**Gap 2: Module Writes Excluded from Conflict Detection**
The `get_write_summary()` method, which generates the write set used for conflict detection, only includes resource writes and delayed field writesâ€”it completely omits module writes. [3](#0-2) 

Note that `module_write_set()` exists but is never added to the conflict detection summary: [4](#0-3) 

**Gap 3: Conflict Multiplier Computation Ignores Modules**
The conflict penalty multiplier is computed using `ReadWriteSummary` which only contains resource and delayed field keys, never module keys. [5](#0-4) [6](#0-5) 

This breaks the invariant that "All operations must respect gas, storage, and computational limits" because module publishing can evade the conflict-based gas penalty system entirely, even when the flag is explicitly enabled in configuration. [7](#0-6) 

## Impact Explanation
This is a **Medium Severity** issue per Aptos bug bounty criteria due to "State inconsistencies requiring intervention" and improper resource limit enforcement.

**Specific Impacts:**
1. **Gas Accounting Inaccuracy**: Module publishing transactions can have read/write conflicts with other transactions without triggering the conflict penalty multiplier, leading to undercharging of effective block gas
2. **Block Limit Bypass**: An attacker could publish multiple conflicting modules in a single block without proper gas penalties, potentially exceeding intended resource consumption limits
3. **False Security Configuration**: Validators and node operators believe the flag provides protection when it provides none, violating the principle of least surprise

While this doesn't directly lead to fund theft or consensus failure, it undermines the block gas limit mechanism's effectiveness and could be exploited to congest the network or manipulate block execution economics.

## Likelihood Explanation
**Likelihood: High**

This issue occurs deterministically whenever:
1. Module publishing transactions are included in a block
2. The `use_module_publishing_block_conflict` flag is set to `true` (which it is by default in genesis)
3. Conflict penalty window is configured (standard configuration)

No special permissions or complex setup is required. Any user with sufficient gas to publish a module can trigger this bypass. The configuration mismatch exists in all networks using the default genesis configuration.

## Recommendation
Implement the feature properly or remove the flag entirely. Two approaches:

**Option 1: Implement the Feature**
Modify `get_write_summary()` to include module writes when the flag is enabled:

```rust
fn get_write_summary(&self) -> HashSet<InputOutputKey<StateKey, StructTag>> {
    let mut writes = HashSet::new();

    // Existing resource write logic...
    for (state_key, write) in self.guard.resource_write_set() {
        // ... existing code ...
    }

    // Existing delayed field logic...
    for identifier in self.guard.delayed_field_change_set().keys() {
        writes.insert(InputOutputKey::DelayedField(*identifier));
    }

    // NEW: Add module writes if feature is enabled
    // (Requires passing block_gas_limit_type configuration here)
    if block_gas_limit_type.use_module_publishing_block_conflict() {
        for (state_key, _) in self.guard.module_write_set() {
            writes.insert(InputOutputKey::Resource(state_key.clone()));
        }
    }

    writes
}
```

**Option 2: Remove Unimplemented Flag**
Delete the `use_module_publishing_block_conflict` field and update the comment to reflect that module publishing always falls back to sequential execution (which is the current actual behavior).

## Proof of Concept

The following demonstrates that module writes are never included in conflict detection:

```rust
// Test case to verify module writes are excluded from conflict detection
#[test]
fn test_module_publishing_bypasses_conflict_detection() {
    use aptos_types::on_chain_config::BlockGasLimitType;
    
    // Create configuration with flag enabled
    let config = BlockGasLimitType::ComplexLimitV1 {
        effective_block_gas_limit: 100000,
        execution_gas_effective_multiplier: 1,
        io_gas_effective_multiplier: 1,
        conflict_penalty_window: 8,
        use_module_publishing_block_conflict: true,  // Flag is TRUE
        block_output_limit: None,
        include_user_txn_size_in_block_output: true,
        add_block_limit_outcome_onchain: false,
        use_granular_resource_group_conflicts: false,
    };
    
    // Verify the flag returns true
    assert!(config.use_module_publishing_block_conflict());
    
    // But grep search shows use_module_publishing_block_conflict() is never
    // called in production code - only in test configs!
    
    // And get_write_summary() at aptos-move/aptos-vm/src/block_executor/mod.rs:140-168
    // never includes module_write_set() in the returned HashSet,
    // regardless of the flag value.
    
    // This means module publishing always bypasses conflict detection.
}
```

**Notes:**
- The vulnerability is confirmed by the explicit "Currently not supported" comment in the source code
- The flag is accessible via a public method but that method is never invoked in any execution path
- Module writes exist in `module_write_set()` but are architecturally separated from the conflict detection system
- This represents a significant configuration/implementation mismatch that could mislead operators about system behavior

### Citations

**File:** types/src/on_chain_config/execution_config.rs (L142-155)
```rust
impl BlockGasLimitType {
    pub fn default_for_genesis() -> Self {
        BlockGasLimitType::ComplexLimitV1 {
            effective_block_gas_limit: 20000,
            execution_gas_effective_multiplier: 1,
            io_gas_effective_multiplier: 1,
            conflict_penalty_window: 9,
            use_granular_resource_group_conflicts: false,
            use_module_publishing_block_conflict: true,
            block_output_limit: Some(4 * 1024 * 1024),
            include_user_txn_size_in_block_output: true,
            add_block_limit_outcome_onchain: true,
        }
    }
```

**File:** types/src/on_chain_config/execution_config.rs (L296-300)
```rust
        /// Module publishing today fallbacks to sequential execution,
        /// even though there is no read-write conflict.
        /// When enabled, this flag allows us to account for that conflict.
        /// NOTE: Currently not supported.
        use_module_publishing_block_conflict: bool,
```

**File:** types/src/on_chain_config/execution_config.rs (L376-385)
```rust
    pub fn use_module_publishing_block_conflict(&self) -> bool {
        match self {
            BlockGasLimitType::NoLimit => false,
            BlockGasLimitType::Limit(_) => false,
            BlockGasLimitType::ComplexLimitV1 {
                use_module_publishing_block_conflict,
                ..
            } => *use_module_publishing_block_conflict,
        }
    }
```

**File:** aptos-move/aptos-vm/src/block_executor/mod.rs (L140-168)
```rust
    fn get_write_summary(&self) -> HashSet<InputOutputKey<StateKey, StructTag>> {
        let mut writes = HashSet::new();

        for (state_key, write) in self.guard.resource_write_set() {
            match write {
                AbstractResourceWriteOp::Write(_)
                | AbstractResourceWriteOp::WriteWithDelayedFields(_) => {
                    writes.insert(InputOutputKey::Resource(state_key.clone()));
                },
                AbstractResourceWriteOp::WriteResourceGroup(write) => {
                    for tag in write.inner_ops().keys() {
                        writes.insert(InputOutputKey::Group(state_key.clone(), tag.clone()));
                    }
                },
                AbstractResourceWriteOp::InPlaceDelayedFieldChange(_)
                | AbstractResourceWriteOp::ResourceGroupInPlaceDelayedFieldChange(_) => {
                    // No conflicts on resources from in-place delayed field changes.
                    // Delayed fields conflicts themselves are handled via
                    // delayed_field_change_set below.
                },
            }
        }

        for identifier in self.guard.delayed_field_change_set().keys() {
            writes.insert(InputOutputKey::DelayedField(*identifier));
        }

        writes
    }
```

**File:** aptos-move/aptos-vm/src/block_executor/mod.rs (L287-290)
```rust
    /// Should never be called after incorporating materialized output, as that consumes vm_output.
    fn module_write_set(&self) -> &BTreeMap<StateKey, ModuleWrite<WriteOp>> {
        self.guard.module_write_set()
    }
```

**File:** aptos-move/block-executor/src/txn_last_input_output.rs (L155-161)
```rust
                let maybe_read_write_summary =
                    block_gas_limit_type.conflict_penalty_window().map(|_| {
                        ReadWriteSummary::new(
                            read_set.get_read_summary(),
                            output_before_guard.get_write_summary(),
                        )
                    });
```

**File:** aptos-move/block-executor/src/limit_processor.rs (L175-203)
```rust
    fn compute_conflict_multiplier(&self, conflict_overlap_length: usize) -> u64 {
        let start = self
            .txn_read_write_summaries
            .len()
            .saturating_sub(conflict_overlap_length);
        let end = self.txn_read_write_summaries.len() - 1;

        let mut conflict_count = 0;
        let current = &self.txn_read_write_summaries[end];
        for prev in &self.txn_read_write_summaries[start..end] {
            if current.conflicts_with_previous(prev) {
                if self.print_conflicts_info {
                    println!(
                        "Conflicts with previous: {:?}",
                        current.find_conflicts(prev)
                    );
                }
                conflict_count += 1;
            }
        }
        if self.print_conflicts_info {
            println!(
                "Number of conflicts: {} out of {}",
                conflict_count, conflict_overlap_length
            );
        }
        assert_le!(conflict_count + 1, conflict_overlap_length);
        (conflict_count + 1) as u64
    }
```
