# Audit Report

## Title
Unauthenticated Validator Network Topology Disclosure via Inspection Service

## Summary
The `/peer_information` endpoint in the inspection service exposes detailed validator network topology information including IP addresses, ports, connection states, and peer relationships without any authentication. This information disclosure enables attackers to map the validator network topology for planning targeted attacks.

## Finding Description

The `display_peer_connection_metadata()` function in the inspection service reveals sensitive network information: [1](#0-0) 

This function exposes:
1. **IP addresses and TCP ports** - extracted from `NetworkAddress` containing `Protocol::Ip4`, `Protocol::Ip6`, and `Protocol::Tcp` entries
2. **Connection states** - whether peers are connected or disconnected
3. **Connection origin** - whether connections are inbound or outbound
4. **Peer roles** - including `PeerRole::Validator` for validator-to-validator consensus network peers
5. **Network types** - distinguishing between `NetworkId::Validator` (private consensus network), `NetworkId::Vfn`, and `NetworkId::Public`
6. **Cryptographic public keys** - NoiseIK keys used for authentication

The endpoint is accessible without any authentication: [2](#0-1) 

The configuration defaults to **enabled** and binds to all network interfaces: [3](#0-2) 

Critically, while there is a configuration sanitizer that prevents `expose_configuration` on mainnet validators, **there is no sanitizer for `expose_peer_information`**: [4](#0-3) 

**Attack Scenario:**
1. Attacker queries `http://validator-ip:9101/peer_information` on multiple validators
2. Builds complete network topology map including all validator IPs, ports, and connection patterns
3. Uses this information to plan targeted network-level attacks such as:
   - Targeted DDoS against specific validators
   - Network partitioning attempts by attacking key connection points
   - Connection slot exhaustion attacks
   - Timing analysis based on connection patterns

While Aptos uses on-chain validator set discovery with mutual authentication (preventing traditional eclipse attacks), the topology information still enables network-level reconnaissance: [5](#0-4) 

## Impact Explanation

According to the Aptos bug bounty criteria, this vulnerability falls under **Low Severity: "Minor information leaks"** rather than High severity. 

While the disclosed information could theoretically enable targeted network attacks, the bug bounty rules explicitly state: **"Network-level DoS attacks are out of scope per bug bounty rules"**. 

The vulnerability does NOT:
- Enable consensus safety violations (Aptos uses cryptographic trusted peer sets)
- Cause loss of funds or allow minting
- Directly cause validator slowdowns or liveness issues
- Break any of the 10 documented critical invariants

The primary impact is information disclosure that **enables out-of-scope attack vectors**.

## Likelihood Explanation

**Likelihood: High** for information disclosure itself.

Any attacker with network access to port 9101 can immediately exploit this. However, the reference Kubernetes deployment includes infrastructure protections: [6](#0-5) 

These protections are **optional** and only apply to Helm/Kubernetes deployments. Validators using other deployment methods without proper firewall rules remain vulnerable.

## Recommendation

Add a configuration sanitizer to prevent exposing peer information on mainnet validators:

```rust
// In config/src/config/inspection_service_config.rs
impl ConfigSanitizer for InspectionServiceConfig {
    fn sanitize(
        node_config: &NodeConfig,
        node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();
        let inspection_service_config = &node_config.inspection_service;

        // Verify that mainnet validators do not expose the configuration
        if let Some(chain_id) = chain_id {
            if node_type.is_validator() && chain_id.is_mainnet() {
                if inspection_service_config.expose_configuration {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name,
                        "Mainnet validators should not expose the node configuration!".to_string(),
                    ));
                }
                // ADD THIS CHECK:
                if inspection_service_config.expose_peer_information {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name,
                        "Mainnet validators should not expose peer information!".to_string(),
                    ));
                }
            }
        }

        Ok(())
    }
}
```

Additionally, change the default to `false` for security-by-default, or add authentication to the inspection service endpoints.

## Proof of Concept

```bash
# Query a validator's peer information endpoint
curl http://<validator-ip>:9101/peer_information

# Output will contain:
# - IP addresses and ports of all connected validators
# - Connection states and origin (inbound/outbound)
# - Peer roles (Validator, ValidatorFullNode, etc.)
# - Network types (Validator, Vfn, Public)
# - Cryptographic public keys
# - Trust relationships
```

The test suite confirms this endpoint exposes detailed peer information when enabled: [7](#0-6) 

## Notes

**Critical Caveat:** While this is a legitimate security concern that violates security best practices (no authentication, default-enabled, binding to all interfaces), it does **NOT qualify as a High severity vulnerability** per the Aptos bug bounty criteria because:

1. Its primary impact is information disclosure, categorized as **Low severity**
2. The attack vectors it enables (network-level DoS, targeted attacks) are **explicitly out of scope**
3. It does not break any of the 10 documented critical invariants
4. Infrastructure-level protections exist in the reference deployment

This should be addressed as a **security hardening improvement** rather than a critical vulnerability. Operators should disable this endpoint on production validators or implement proper authentication and network segmentation.

### Citations

**File:** crates/aptos-inspection-service/src/server/peer_information.rs (L149-168)
```rust
fn display_peer_connection_metadata(
    peer_information_output: &mut Vec<String>,
    all_peers: &Vec<PeerNetworkId>,
    peers_and_metadata: &PeersAndMetadata,
) {
    peer_information_output.push("Connection metadata for each peer:".into());

    // Fetch and display the connection metadata for each peer
    for peer in all_peers {
        if let Ok(peer_metadata) = peers_and_metadata.get_metadata_for_peer(*peer) {
            let connection_metadata = peer_metadata.get_connection_metadata();
            peer_information_output.push(format!(
                "\t- Peer: {}, connection state: {:?}, connection metadata: {}",
                peer,
                peer_metadata.get_connection_state(),
                serde_json::to_string(&connection_metadata).unwrap_or_default()
            ));
        }
    }
}
```

**File:** crates/aptos-inspection-service/src/server/mod.rs (L147-155)
```rust
        PEER_INFORMATION_PATH => {
            // /peer_information
            // Exposes the peer information
            peer_information::handle_peer_information_request(
                &node_config,
                aptos_data_client,
                peers_and_metadata,
            )
        },
```

**File:** config/src/config/inspection_service_config.rs (L26-36)
```rust
impl Default for InspectionServiceConfig {
    fn default() -> InspectionServiceConfig {
        InspectionServiceConfig {
            address: "0.0.0.0".to_string(),
            port: 9101,
            expose_configuration: false,
            expose_identity_information: true,
            expose_peer_information: true,
            expose_system_information: true,
        }
    }
```

**File:** config/src/config/inspection_service_config.rs (L45-68)
```rust
impl ConfigSanitizer for InspectionServiceConfig {
    fn sanitize(
        node_config: &NodeConfig,
        node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();
        let inspection_service_config = &node_config.inspection_service;

        // Verify that mainnet validators do not expose the configuration
        if let Some(chain_id) = chain_id {
            if node_type.is_validator()
                && chain_id.is_mainnet()
                && inspection_service_config.expose_configuration
            {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "Mainnet validators should not expose the node configuration!".to_string(),
                ));
            }
        }

        Ok(())
    }
```

**File:** network/discovery/src/validator_set.rs (L1-1)
```rust
// Copyright (c) Aptos Foundation
```

**File:** terraform/helm/aptos-node/templates/networkpolicy.yaml (L19-46)
```yaml
  ingress:
  # HAproxy
  - from:
    - podSelector:
        matchLabels:
          {{- include "aptos-validator.selectorLabels" $ | nindent 10 }}
          app.kubernetes.io/name: haproxy
          app.kubernetes.io/instance: haproxy-{{$i}}
    ports:
      # AptosNet from HAproxy
    - protocol: TCP
      port: 6180
    - protocol: TCP
      port: 9101
  {{- if $.Values.service.validator.enableRestApi }}
      # REST API from HAproxy
    - protocol: TCP
      port: 8080
  {{- end }}
  # Monitoring metrics port
  - from:
    - namespaceSelector: {}
    - podSelector:
        matchLabels:
          app.kubernetes.io/name: monitoring
    ports:
    - protocol: TCP
      port: 9101
```

**File:** crates/aptos-inspection-service/src/server/tests.rs (L203-215)
```rust
    // Enable the peer information endpoint and ping it
    config.inspection_service.expose_peer_information = true;
    let mut response = send_get_request_to_path(&config, PEER_INFORMATION_PATH).await;
    let response_body = block_on(body::to_bytes(response.body_mut())).unwrap();
    let response_body_string = read_to_string(response_body.as_ref()).unwrap();

    // Verify that the response contains the expected information
    assert_eq!(response.status(), StatusCode::OK);
    assert!(response_body_string.contains("Number of peers"));
    assert!(response_body_string.contains("Registered networks"));
    assert!(response_body_string.contains("Peers and network IDs"));
    assert!(response_body_string.contains("State sync metadata"));
}
```
