# Audit Report

## Title
Epoch Mismatch Vulnerability in BlockPayload Processing Allows Consensus Confusion

## Summary
The consensus observer's `BlockPayload` message processing lacks validation that the epoch in the `BlockInfo` matches the epochs of `BatchInfo` objects within the `transaction_payload`. This allows an attacker to send malicious `BlockPayload` messages containing transaction batches from different epochs, potentially causing consensus confusion, state inconsistencies, and validator node failures.

## Finding Description
The consensus observer processes `BlockPayload` messages containing a `BlockInfo` and a `BlockTransactionPayload`. The `BlockInfo` has an epoch field, and the `BlockTransactionPayload` contains `ProofOfStore<BatchInfo>` items where each `BatchInfo` also has an epoch field. [1](#0-0) [2](#0-1) 

When a `BlockPayload` message arrives, the system extracts the block epoch and only validates that it matches the current epoch state: [3](#0-2) 

The critical vulnerability is that **no validation occurs** to ensure the `BatchInfo` epochs within `transaction_payload` match the `block.epoch()`. The verification only checks:
1. Payload digests (line 386) - verifies batch hashes, not epochs
2. Payload signatures (line 403) - verifies cryptographic signatures using current epoch's validator verifier, but doesn't check if `BatchInfo.epoch()` matches `block.epoch()` [4](#0-3) 

In contrast, the normal consensus flow explicitly validates epoch consistency in `Block::verify_well_formed()`: [5](#0-4) [6](#0-5) 

The consensus observer bypasses this check entirely. Even when ordered blocks are later verified, the epoch validation is still missing: [7](#0-6) 

The `verify_ordered_blocks()` function only checks block structure and chaining, not payload epochs. Similarly, `verify_against_ordered_payload()` only verifies structural matching: [8](#0-7) 

**Attack Scenario:**
1. Attacker crafts `BlockPayload` with `block.epoch() = N` (current epoch) but `BatchInfo.epoch = M` (where M â‰  N, e.g., previous epoch)
2. Message passes initial validation because `block_epoch == epoch_state.epoch`
3. Signature verification may pass if validator set unchanged between epochs, or payload stored as "unverified"
4. System processes block believing all data is from epoch N, but actually contains epoch M batches
5. Execution may fail inconsistently across nodes or produce different results

## Impact Explanation
This vulnerability qualifies as **High Severity** under the Aptos bug bounty program due to:

1. **Validator node slowdowns**: Processing mismatched epoch data causes validation failures, retries, and degraded performance
2. **Significant protocol violations**: Breaks the fundamental invariant that block epoch must match payload batch epochs
3. **Consensus confusion**: Different nodes might process the same block differently depending on their epoch state and validator set history
4. **State inconsistencies**: Could lead to divergent state if some nodes accept the payload while others reject it

The vulnerability violates critical invariants:
- **Deterministic Execution**: Nodes may produce different results for identical blocks
- **Consensus Safety**: Could cause consensus splits if nodes disagree on block validity

## Likelihood Explanation
**Likelihood: Medium to High**

The vulnerability is easily exploitable because:
- Any network peer can send `BlockPayload` messages to consensus observers
- No authentication required beyond network-level peer validation
- Attack requires no validator insider access
- Simple to construct malicious payloads with mismatched epochs

The impact varies based on:
- Whether validator set changed between epochs (affects signature verification)
- Timing of attack relative to epoch transitions
- Number of affected consensus observer nodes

The attack is particularly effective during or shortly after epoch transitions when legitimately signed batches from previous epochs can be replayed in new blocks.

## Recommendation
Add explicit epoch validation in the `BlockPayload` verification flow. The fix should verify that all `BatchInfo` epochs within the `transaction_payload` match the `block.epoch()`:

```rust
// In BlockPayload::verify_payload_epochs()
pub fn verify_payload_epochs(&self) -> Result<(), Error> {
    let block_epoch = self.block.epoch();
    
    // Get all proofs and verify their epochs
    let payload_proofs = self.transaction_payload.payload_proofs();
    for proof in &payload_proofs {
        if proof.epoch() != block_epoch {
            return Err(Error::InvalidMessageError(format!(
                "Payload proof epoch {} doesn't match block epoch {}",
                proof.epoch(), block_epoch
            )));
        }
    }
    
    // Verify inline batch epochs
    let inline_batches = self.transaction_payload.optqs_and_inline_batches();
    for batch in inline_batches {
        if batch.epoch() != block_epoch {
            return Err(Error::InvalidMessageError(format!(
                "Inline batch epoch {} doesn't match block epoch {}",
                batch.epoch(), block_epoch
            )));
        }
    }
    
    Ok(())
}
```

Then call this in `process_block_payload_message()`:

```rust
// After verify_payload_digests() at line 386
if let Err(error) = block_payload.verify_payload_epochs() {
    error!(LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
        "Epoch mismatch in block payload! Block: {:?}, Error: {:?}",
        block_payload.block(), error
    )));
    increment_invalid_message_counter(&peer_network_id, metrics::BLOCK_PAYLOAD_LABEL);
    return;
}
```

## Proof of Concept
```rust
#[test]
fn test_block_payload_epoch_mismatch() {
    use aptos_consensus_types::proof_of_store::{BatchInfo, ProofOfStore};
    use aptos_types::{aggregate_signature::AggregateSignature, block_info::BlockInfo};
    use consensus::consensus_observer::network::observer_message::BlockPayload;
    
    // Create a block info for epoch 10
    let current_epoch = 10;
    let block_info = BlockInfo::new(
        current_epoch,
        0,  // round
        HashValue::random(),
        HashValue::random(),
        0,
        0,
        None,
    );
    
    // Create a batch info from a previous epoch (epoch 9)
    let previous_epoch = 9;
    let batch_info = BatchInfo::new(
        PeerId::ZERO,
        BatchId::new(0),
        previous_epoch,  // Different epoch!
        1000,
        HashValue::random(),
        1,
        100,
        0,
    );
    
    // Create proof of store with the mismatched epoch batch
    let proof = ProofOfStore::new(batch_info, AggregateSignature::empty());
    
    // Create transaction payload with the mismatched proof
    let transaction_payload = BlockTransactionPayload::new_in_quorum_store(
        vec![],
        vec![proof],
    );
    
    // Create block payload with epoch mismatch
    let block_payload = BlockPayload::new(block_info, transaction_payload);
    
    // Current code does NOT detect this mismatch!
    // block_payload.epoch() returns 10 (from block_info)
    // But transaction_payload contains BatchInfo with epoch 9
    assert_eq!(block_payload.epoch(), current_epoch);
    
    // The vulnerability: verify_payload_digests() and verify_payload_signatures()
    // do not check this epoch mismatch
}
```

## Notes
This vulnerability is specific to the consensus observer code path and does not affect the main consensus validation logic, which properly validates epoch consistency through `Block::verify_well_formed()`. However, consensus observers are critical infrastructure components that feed blocks to execution, so compromising them can still impact network operation and node availability.

### Citations

**File:** consensus/consensus-types/src/proof_of_store.rs (L46-58)
```rust
#[derive(
    Clone, Debug, Deserialize, Serialize, CryptoHasher, BCSCryptoHash, PartialEq, Eq, Hash,
)]
pub struct BatchInfo {
    author: PeerId,
    batch_id: BatchId,
    epoch: u64,
    expiration: u64,
    digest: HashValue,
    num_txns: u64,
    num_bytes: u64,
    gas_bucket_start: u64,
}
```

**File:** consensus/src/consensus_observer/network/observer_message.rs (L225-266)
```rust
    /// Verifies the ordered blocks and returns an error if the data is invalid.
    /// Note: this does not check the ordered proof.
    pub fn verify_ordered_blocks(&self) -> Result<(), Error> {
        // Verify that we have at least one ordered block
        if self.blocks.is_empty() {
            return Err(Error::InvalidMessageError(
                "Received empty ordered block!".to_string(),
            ));
        }

        // Verify the last block ID matches the ordered proof block ID
        if self.last_block().id() != self.proof_block_info().id() {
            return Err(Error::InvalidMessageError(
                format!(
                    "Last ordered block ID does not match the ordered proof ID! Number of blocks: {:?}, Last ordered block ID: {:?}, Ordered proof ID: {:?}",
                    self.blocks.len(),
                    self.last_block().id(),
                    self.proof_block_info().id()
                )
            ));
        }

        // Verify the blocks are correctly chained together (from the last block to the first)
        let mut expected_parent_id = None;
        for block in self.blocks.iter().rev() {
            if let Some(expected_parent_id) = expected_parent_id {
                if block.id() != expected_parent_id {
                    return Err(Error::InvalidMessageError(
                        format!(
                            "Block parent ID does not match the expected parent ID! Block ID: {:?}, Expected parent ID: {:?}",
                            block.id(),
                            expected_parent_id
                        )
                    ));
                }
            }

            expected_parent_id = Some(block.parent_id());
        }

        Ok(())
    }
```

**File:** consensus/src/consensus_observer/network/observer_message.rs (L647-717)
```rust
    /// Verifies the transaction payload against the given ordered block payload
    pub fn verify_against_ordered_payload(
        &self,
        ordered_block_payload: &Payload,
    ) -> Result<(), Error> {
        match ordered_block_payload {
            Payload::DirectMempool(_) => {
                return Err(Error::InvalidMessageError(
                    "Direct mempool payloads are not supported for consensus observer!".into(),
                ));
            },
            Payload::InQuorumStore(proof_with_data) => {
                // Verify the batches in the requested block
                self.verify_batches(&proof_with_data.proofs)?;
            },
            Payload::InQuorumStoreWithLimit(proof_with_data) => {
                // Verify the batches in the requested block
                self.verify_batches(&proof_with_data.proof_with_data.proofs)?;

                // Verify the transaction limit
                self.verify_transaction_limit(proof_with_data.max_txns_to_execute)?;
            },
            Payload::QuorumStoreInlineHybrid(
                inline_batches,
                proof_with_data,
                max_txns_to_execute,
            ) => {
                // Verify the batches in the requested block
                self.verify_batches(&proof_with_data.proofs)?;

                // Verify the inline batches
                self.verify_inline_batches(inline_batches)?;

                // Verify the transaction limit
                self.verify_transaction_limit(*max_txns_to_execute)?;
            },
            Payload::QuorumStoreInlineHybridV2(
                inline_batches,
                proof_with_data,
                execution_limits,
            ) => {
                // Verify the batches in the requested block
                self.verify_batches(&proof_with_data.proofs)?;

                // Verify the inline batches
                self.verify_inline_batches(inline_batches)?;

                // Verify the transaction limit
                self.verify_transaction_limit(execution_limits.max_txns_to_execute())?;

                // TODO: verify the block gas limit?
            },
            Payload::OptQuorumStore(OptQuorumStorePayload::V1(p)) => {
                // Verify the batches in the requested block
                self.verify_batches(p.proof_with_data())?;

                // Verify optQS and inline batches
                self.verify_optqs_and_inline_batches(p.opt_batches(), p.inline_batches())?;

                // Verify the transaction limit
                self.verify_transaction_limit(p.max_txns_to_execute())?;
            },
            Payload::OptQuorumStore(OptQuorumStorePayload::V2(_p)) => {
                return Err(Error::InvalidMessageError(
                    "OptQuorumStorePayload V2 is not supproted".into(),
                ));
            },
        }

        Ok(())
    }
```

**File:** consensus/src/consensus_observer/network/observer_message.rs (L839-863)
```rust
/// Payload message contains the block and transaction payload
#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
pub struct BlockPayload {
    block: BlockInfo,
    transaction_payload: BlockTransactionPayload,
}

impl BlockPayload {
    pub fn new(block: BlockInfo, transaction_payload: BlockTransactionPayload) -> Self {
        Self {
            block,
            transaction_payload,
        }
    }

    /// Returns a reference to the block info
    pub fn block(&self) -> &BlockInfo {
        &self.block
    }

    /// Returns the epoch of the block info
    pub fn epoch(&self) -> u64 {
        self.block.epoch()
    }

```

**File:** consensus/src/consensus_observer/network/observer_message.rs (L959-982)
```rust

    /// Verifies that the block payload proofs are correctly signed according
    /// to the current epoch state. Returns an error if the data is invalid.
    pub fn verify_payload_signatures(&self, epoch_state: &EpochState) -> Result<(), Error> {
        // Create a dummy proof cache to verify the proofs
        let proof_cache = ProofCache::new(1);

        // Verify each of the proof signatures (in parallel)
        let payload_proofs = self.transaction_payload.payload_proofs();
        let validator_verifier = &epoch_state.verifier;
        payload_proofs
            .par_iter()
            .with_min_len(2)
            .try_for_each(|proof| proof.verify(validator_verifier, &proof_cache))
            .map_err(|error| {
                Error::InvalidMessageError(format!(
                    "Failed to verify the payload proof signatures! Error: {:?}",
                    error
                ))
            })?;

        Ok(()) // All proofs are correctly signed
    }
}
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L356-418)
```rust
    async fn process_block_payload_message(
        &mut self,
        peer_network_id: PeerNetworkId,
        message_received_time: Instant,
        block_payload: BlockPayload,
    ) {
        // Get the epoch and round for the block
        let block_epoch = block_payload.epoch();
        let block_round = block_payload.round();

        // Determine if the payload is behind the last ordered block, or if it already exists
        let last_ordered_block = self.observer_block_data.lock().get_last_ordered_block();
        let payload_out_of_date =
            (block_epoch, block_round) <= (last_ordered_block.epoch(), last_ordered_block.round());
        let payload_exists = self
            .observer_block_data
            .lock()
            .existing_payload_entry(&block_payload);

        // If the payload is out of date or already exists, ignore it
        if payload_out_of_date || payload_exists {
            // Update the metrics for the dropped block payload
            update_metrics_for_dropped_block_payload_message(peer_network_id, &block_payload);
            return;
        }

        // Update the metrics for the received block payload
        update_metrics_for_block_payload_message(peer_network_id, &block_payload);

        // Verify the block payload digests
        if let Err(error) = block_payload.verify_payload_digests() {
            // Log the error and update the invalid message counter
            error!(
                LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                    "Failed to verify block payload digests! Ignoring block: {:?}, from peer: {:?}. Error: {:?}",
                    block_payload.block(), peer_network_id,
                    error
                ))
            );
            increment_invalid_message_counter(&peer_network_id, metrics::BLOCK_PAYLOAD_LABEL);
            return;
        }

        // If the payload is for the current epoch, verify the proof signatures
        let epoch_state = self.get_epoch_state();
        let verified_payload = if block_epoch == epoch_state.epoch {
            // Verify the block proof signatures
            if let Err(error) = block_payload.verify_payload_signatures(&epoch_state) {
                // Log the error and update the invalid message counter
                error!(
                    LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                        "Failed to verify block payload signatures! Ignoring block: {:?}, from peer: {:?}. Error: {:?}",
                        block_payload.block(), peer_network_id, error
                    ))
                );
                increment_invalid_message_counter(&peer_network_id, metrics::BLOCK_PAYLOAD_LABEL);
                return;
            }

            true // We have successfully verified the signatures
        } else {
            false // We can't verify the signatures yet
        };
```

**File:** consensus/consensus-types/src/block.rs (L485-492)
```rust
                self.payload().is_none_or(|p| p.is_empty()),
                "Reconfiguration suffix should not carry payload"
            );
        }

        if let Some(payload) = self.payload() {
            payload.verify_epoch(self.epoch())?;
        }
```

**File:** consensus/consensus-types/src/common.rs (L634-669)
```rust
    pub(crate) fn verify_epoch(&self, epoch: u64) -> anyhow::Result<()> {
        match self {
            Payload::DirectMempool(_) => return Ok(()),
            Payload::InQuorumStore(proof_with_data) => {
                ensure!(
                    proof_with_data.proofs.iter().all(|p| p.epoch() == epoch),
                    "Payload epoch doesn't match given epoch"
                );
            },
            Payload::InQuorumStoreWithLimit(proof_with_data_with_txn_limit) => {
                ensure!(
                    proof_with_data_with_txn_limit
                        .proof_with_data
                        .proofs
                        .iter()
                        .all(|p| p.epoch() == epoch),
                    "Payload epoch doesn't match given epoch"
                );
            },
            Payload::QuorumStoreInlineHybrid(inline_batches, proof_with_data, _)
            | Payload::QuorumStoreInlineHybridV2(inline_batches, proof_with_data, _) => {
                ensure!(
                    proof_with_data.proofs.iter().all(|p| p.epoch() == epoch),
                    "Payload proof epoch doesn't match given epoch"
                );
                ensure!(
                    inline_batches.iter().all(|b| b.0.epoch() == epoch),
                    "Payload inline batch epoch doesn't match given epoch"
                )
            },
            Payload::OptQuorumStore(opt_quorum_store_payload) => {
                opt_quorum_store_payload.check_epoch(epoch)?;
            },
        };
        Ok(())
    }
```
