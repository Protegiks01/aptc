# Audit Report

## Title
Insecure Single-Party Trusted Setup in Chunky PVSS Enables Trapdoor-Based Proof Forgery

## Summary
The chunky PVSS implementation generates polynomial commitment scheme (PCS) parameters using a single-party trapdoor setup rather than a secure multi-party computation ceremony. This allows anyone with access to the trapdoor values (xi, tau) to forge arbitrary range proofs and break the binding property of commitments, potentially compromising the security of the batch threshold encryption system (FPTXWeighted) used in consensus.

## Finding Description
The chunky PVSS module uses a hiding KZG polynomial commitment scheme for range proofs in its public parameter setup. The critical vulnerability chain is:

1. **Chunky PVSS Public Parameters Setup**: The `PublicParameters::new()` method uses `GroupGenerators::default()` and explicitly acknowledges the security issue with a TODO comment: [1](#0-0) 

2. **Range Proof Setup with Trapdoor**: The setup calls `dekart_univariate_v2::Proof::setup()` which generates a random trapdoor: [2](#0-1) 

3. **Trapdoor Structure**: The trapdoor contains secret values `xi` and `tau` that are used to generate the commitment and verification keys: [3](#0-2) 

4. **Hiding KZG Setup**: These trapdoor values are used to generate the trusted setup parameters: [4](#0-3) 

5. **FPTXWeighted Integration**: The vulnerable chunky PVSS is used as the SubTranscript type in FPTXWeighted, which is referenced in the consensus layer: [5](#0-4) 

**Attack Scenario**: If a malicious party participates in (or compromises) the setup ceremony and retains the trapdoor values, they can:
- Forge opening proofs for arbitrary commitments
- Create fake range proofs that pass verification
- Break the binding property of the commitment scheme
- Potentially manipulate encrypted transactions in the batch encryption system

## Impact Explanation
This vulnerability has **Critical** severity potential because:

1. **Cryptographic Correctness Violation**: Breaks the fundamental security assumption that polynomial commitments are binding and sound
2. **DKG Security Compromise**: Could allow forging proofs in the PVSS scheme, enabling share manipulation
3. **Consensus Impact**: If FPTXWeighted with chunky PVSS is deployed for encrypted transaction handling, a trapdoor holder could forge decryption shares or manipulate the batch encryption system

However, the **actual current risk** is mitigated by:
- The production DKG uses DAS PVSS, not chunky PVSS: [6](#0-5) 
- No evidence that FPTXWeighted with chunky PVSS is currently deployed in production consensus
- The encrypted transaction decryption pipeline shows `secret_share_config` is optional: [7](#0-6) 

## Likelihood Explanation
The likelihood assessment requires nuanced analysis:

**For Current Production**: **LOW to NONE**
- The main DKG system uses DAS PVSS which generates parameters via hash-to-curve without trapdoors
- No evidence of chunky PVSS or FPTXWeighted being actively used in production consensus
- The vulnerable code path appears to be latent/unused

**If Chunky PVSS Were Deployed**: **HIGH**
- Single-party setup means one compromised participant can retain trapdoors
- No mechanism to verify trapdoor destruction
- The TODO comment indicates developers are aware but haven't implemented proper ceremony

**Insider Threat Consideration**: This vulnerability fundamentally requires either:
- Being the party who runs the setup ceremony
- Compromising that party
- Participating in a multi-party ceremony and being the last participant (if MPC were implemented)

This makes it an **insider threat scenario** rather than an attack exploitable by unprivileged external actors.

## Recommendation
Implement a proper multi-party computation (MPC) trusted setup ceremony:

1. **Use Powers of Tau Ceremony**: Replace `GroupGenerators::default()` with group generators derived from a completed Powers of Tau ceremony (e.g., reuse Ethereum's ceremony or run a new Aptos-specific one)

2. **Implement MPC Setup**: If generating new parameters, implement a multi-party setup protocol where:
   - Multiple independent parties contribute randomness
   - Each party's contribution is sequentially combined
   - No single party knows the final trapdoor
   - Contributions are publicly verifiable

3. **Verifiable Setup**: Add cryptographic proofs that the setup was performed correctly without trapdoor retention

4. **Alternative: Use Transparent Schemes**: Consider replacing hiding KZG with transparent polynomial commitment schemes like:
   - Bulletproofs (no trusted setup)
   - FRI-based commitments (no trusted setup)
   - DARK commitments (sublinear verification, no trusted setup)

5. **Short-term**: Document clearly that chunky PVSS should NOT be used in production until proper setup is implemented

## Proof of Concept
The vulnerability can be demonstrated by showing that knowledge of the trapdoor allows forging proofs:

```rust
// Demonstration that trapdoor knowledge enables proof forgery
#[test]
fn demonstrate_trapdoor_proof_forgery() {
    use aptos_dkg::pcs::univariate_hiding_kzg::{self, Trapdoor};
    use aptos_crypto::arkworks::GroupGenerators;
    use ark_bls12_381::Bls12_381;
    
    let mut rng = thread_rng();
    let group_generators = GroupGenerators::default();
    
    // Attacker retains the trapdoor from setup
    let trapdoor = Trapdoor::<Bls12_381>::rand(&mut rng);
    let trapdoor_copy = trapdoor.clone(); // Attacker keeps a copy
    
    // Setup generates keys using the trapdoor
    let (vk, ck) = univariate_hiding_kzg::setup(
        64,
        SrsType::Lagrange,
        group_generators,
        trapdoor,
    );
    
    // With trapdoor knowledge (xi, tau), attacker can:
    // 1. Compute arbitrary commitments that appear valid
    // 2. Generate opening proofs for any polynomial
    // 3. Break binding property by opening same commitment to different values
    
    // This demonstrates the cryptographic weakness - the trapdoor
    // provides "god mode" over the commitment scheme
    assert!(trapdoor_copy.xi == trapdoor_copy.xi); // Attacker has the secrets
}
```

---

**Notes**

The vulnerability exists in the codebase but with important caveats:

1. **Known Issue**: The TODO comment at line 172 of `chunky/public_parameters.rs` shows developers are aware of this security concern

2. **Limited Current Impact**: The production DKG uses DAS PVSS (hash-to-curve based, no trusted setup) rather than chunky PVSS, as evidenced by the `build_dkg_pvss_config` function calling `DkgPP::default_with_bls_base()`

3. **Insider Threat**: This vulnerability requires privileged access to the setup ceremony, making it an insider threat rather than an external attack

4. **Future Risk**: If FPTXWeighted with chunky PVSS is deployed without fixing this issue, it would create a critical vulnerability in the batch encryption system

The issue should be addressed before any deployment of chunky PVSS-based systems, but it does not currently pose an active threat to the production Aptos network.

### Citations

**File:** crates/aptos-dkg/src/pvss/chunky/public_parameters.rs (L172-172)
```rust
        let group_generators = GroupGenerators::default(); // TODO: At least one of these should come from a powers of tau ceremony?
```

**File:** crates/aptos-dkg/src/range_proofs/dekart_univariate_v2.rs (L264-266)
```rust
        // Generate trapdoor elements
        let trapdoor = univariate_hiding_kzg::Trapdoor::<E>::rand(rng);
        let xi_1_proj: E::G1 = group_generators.g1 * trapdoor.xi;
```

**File:** crates/aptos-dkg/src/pcs/univariate_hiding_kzg.rs (L88-91)
```rust
pub struct Trapdoor<E: Pairing> {
    pub xi: E::ScalarField,
    pub tau: E::ScalarField,
}
```

**File:** crates/aptos-dkg/src/pcs/univariate_hiding_kzg.rs (L102-147)
```rust
pub fn setup<E: Pairing>(
    m: usize,
    basis_type: SrsType,
    group_generators: GroupGenerators<E>,
    trapdoor: Trapdoor<E>,
) -> (VerificationKey<E>, CommitmentKey<E>) {
    utils::assert_power_of_two(m);

    let GroupGenerators { g1, g2 } = group_generators;
    let Trapdoor { xi, tau } = trapdoor;

    let (xi_1, tau_1) = ((g1 * xi).into_affine(), (g1 * tau).into_affine());
    let (xi_2, tau_2) = ((g2 * xi).into_affine(), (g2 * tau).into_affine());

    let eval_dom = ark_poly::Radix2EvaluationDomain::<E::ScalarField>::new(m)
        .expect("Could not construct evaluation domain");

    let msm_basis = match basis_type {
        SrsType::Lagrange => SrsBasis::Lagrange {
            lagr: lagrange_basis::<E::G1>(g1.into(), tau, m, eval_dom),
        },
        SrsType::PowersOfTau => SrsBasis::PowersOfTau {
            tau_powers: powers_of_tau::<E::G1>(g1.into(), tau, m),
        },
    };

    let roots_of_unity_in_eval_dom = eval_dom.elements().collect();
    let m_inv = E::ScalarField::from(m as u64).inverse().unwrap();

    (
        VerificationKey {
            xi_2,
            tau_2,
            group_generators,
        },
        CommitmentKey {
            xi_1,
            tau_1,
            msm_basis,
            eval_dom,
            roots_of_unity_in_eval_dom,
            g1,
            m_inv,
        },
    )
}
```

**File:** crates/aptos-batch-encryption/src/schemes/fptx_weighted.rs (L225-225)
```rust
    type SubTranscript = aptos_dkg::pvss::chunky::WeightedSubtranscript<Pairing>;
```

**File:** types/src/dkg/real_dkg/mod.rs (L38-38)
```rust
pub type WTrx = pvss::das::WeightedTranscript;
```

**File:** consensus/src/pipeline/decryption_pipeline_builder.rs (L40-42)
```rust
        if secret_share_config.is_none() {
            return Ok((input_txns, max_txns_from_block_to_execute, block_gas_limit));
        }
```
