# Audit Report

## Title
Trusted Waypoint Validation Bypass via Early Exit in Epoch Ending Restore

## Summary
The `preheat_impl()` function in the epoch ending restore process performs a version check before cryptographic validation, allowing an attacker with write access to backup storage to trigger premature loop termination that bypasses trusted waypoint validation for subsequent epochs. [1](#0-0) 

## Finding Description
The vulnerability exists in the validation order within `EpochEndingRestoreController::preheat_impl()`. When processing ledger infos from backup chunks, the code checks if `li.ledger_info().version() > self.target_version` and immediately breaks from the loop if true. [2](#0-1) 

This version check occurs BEFORE all cryptographic validations:
1. Epoch sequence validation
2. Manifest waypoint validation 
3. **Trusted waypoint validation** (lines 129-136)
4. Signature chain verification (lines 136-147) [3](#0-2) 

An attacker who can modify backup data can exploit this by:
1. Modifying a ledger info's version field in the serialized BCS data to artificially exceed `target_version`
2. The modified ledger info triggers early exit before any validation occurs
3. All subsequent ledger infos (including those with trusted waypoints) are never processed or validated
4. The restore returns an incomplete epoch history

The attack bypasses the trusted waypoint mechanism, which is specifically designed to provide cryptographic validation of backup data from untrusted sources. Trusted waypoints represent out-of-band trust anchors that should catch any manipulation, but they are never reached. [4](#0-3) 

The incomplete epoch history is then used by subsequent restore operations. When `EpochHistory::verify_ledger_info()` is called for epochs beyond the incomplete history, it returns `Ok()` with only a warning, allowing unverified data to pass: [5](#0-4) 

## Impact Explanation
This is a **Medium severity** vulnerability per the Aptos bug bounty criteria ("State inconsistencies requiring intervention").

**Specific Impacts:**
1. **Trusted Waypoint Bypass**: The primary security mechanism for validating backup integrity is circumvented, defeating the purpose of out-of-band trust anchors
2. **Incomplete Epoch History**: Nodes restore with missing epoch-ending information, potentially having incorrect views of validator sets for later epochs
3. **State Inconsistency**: Different nodes restoring from differently manipulated backups could have divergent epoch histories, leading to consensus issues
4. **Unverified Data Acceptance**: The permissive behavior in `verify_ledger_info()` allows transaction and state snapshot data for missing epochs to be accepted without cryptographic verification

While this doesn't directly allow fund theft or immediate consensus safety violations, it creates state inconsistencies that could require manual intervention and potentially lead to validator set disagreements during epoch transitions.

## Likelihood Explanation
**Likelihood: Medium**

**Attacker Requirements:**
- Write access to backup storage (compromised backup server, MITM during download, or malicious backup provider)
- Knowledge of BCS serialization format to modify version field
- No validator privileges required

**Complexity:**
- Moderate - requires compromising backup storage but no cryptographic breaks
- The attack is straightforward once storage access is obtained

**Realistic Scenarios:**
1. Compromised cloud storage containing backups
2. Man-in-the-middle attack during backup download from untrusted sources
3. Intentionally malicious backup provider

Trusted waypoints exist specifically to protect against these scenarios, making the bypass particularly concerning.

## Recommendation

**Fix: Perform validation before version check, or validate the version field itself**

Option 1 - Defer version check until after validations:
```rust
for li in lis {
    // Validate epoch sequence first
    ensure!(
        li.ledger_info().epoch() == next_epoch,
        "LedgerInfo epoch not expected. Expected: {}, actual: {}.",
        li.ledger_info().epoch(),
        next_epoch,
    );
    
    // Validate waypoints (including trusted waypoints)
    let wp_manifest = waypoint_iter.next().ok_or_else(|| {
        anyhow!("More LedgerInfo's found than waypoints in manifest.")
    })?;
    let wp_li = Waypoint::new_epoch_boundary(li.ledger_info())?;
    ensure!(
        *wp_manifest == wp_li,
        "Waypoints don't match. In manifest: {}, In chunk: {}",
        wp_manifest,
        wp_li,
    );
    if let Some(wp_trusted) = self.trusted_waypoints.get(&wp_li.version()) {
        ensure!(
            *wp_trusted == wp_li,
            "Waypoints don't match. In backup: {}, trusted: {}",
            wp_li,
            wp_trusted,
        );
    }
    
    // NOW check version and decide whether to include this ledger info
    if li.ledger_info().version() > self.target_version {
        past_target = true;
        break;
    }
    
    // Continue with remaining validations and storage
    // ...
}
```

Option 2 - Validate version consistency with epoch before the version check:
```rust
for li in lis {
    // First validate that version is consistent with epoch progression
    if let Some(previous) = previous_li {
        ensure!(
            li.ledger_info().version() > previous.ledger_info().version(),
            "Version must be monotonically increasing"
        );
    }
    
    // Then perform the target_version check
    if li.ledger_info().version() > self.target_version {
        past_target = true;
        break;
    }
    
    // Continue with validations...
}
```

## Proof of Concept

```rust
#[cfg(test)]
mod exploit_test {
    use super::*;
    use aptos_types::ledger_info::LedgerInfoWithSignatures;
    
    #[tokio::test]
    async fn test_version_manipulation_bypasses_waypoint_validation() {
        // Setup: Create a backup with epochs 0-99, target version 10000
        // Epoch 80 ends at version 8000 and has a trusted waypoint
        // Epoch 50 ends at version 5000
        
        // Attack: Modify epoch 50's serialized ledger info to claim version 15000
        // This is done by manipulating the BCS bytes after serialization
        
        let mut manipulated_bytes = bcs::to_bytes(&legitimate_li_epoch_50).unwrap();
        // Locate and modify version field in BCS bytes to 15000
        // (exact byte manipulation depends on BCS format)
        
        // Store manipulated backup
        // ...
        
        // Attempt restore
        let controller = EpochEndingRestoreController::new(
            opt,
            GlobalRestoreOpt {
                target_version: Some(10000),
                trusted_waypoints: Arc::new(hashmap! {
                    8000 => trusted_waypoint_epoch_80,
                }),
                // ...
            },
            storage,
        );
        
        let result = controller.preheat().await;
        
        // Expected: Should fail because trusted waypoint at version 8000 
        //           should be validated
        // Actual: Succeeds and returns incomplete epoch history (epochs 0-49)
        //         Trusted waypoint at version 8000 is never checked!
        
        assert!(result.is_ok());
        let preheat_data = result.unwrap().preheat_result.unwrap();
        
        // Verify the vulnerability: epoch history stops at epoch 49
        assert_eq!(preheat_data.ledger_infos.len(), 50); // epochs 0-49
        
        // The trusted waypoint for epoch 80 was never validated
        // Malicious data for epochs 50-99 can be injected in later restore steps
    }
}
```

## Notes

The vulnerability is particularly concerning because:

1. **Trusted waypoints are the defense**: They exist specifically to protect against compromised backup data, but this bypass defeats their purpose

2. **Silent failure**: The code doesn't detect that epochs with trusted waypoints were skipped - it just returns a shorter epoch history

3. **Acknowledged weakness**: The comment in `verify_ledger_info()` states "node won't be able to start if this data is malicious", but this assumes previous chunks were verified, which this vulnerability prevents

4. **Cascading impact**: The incomplete epoch history causes later verification steps to be skipped via the permissive `verify_ledger_info()` behavior

The fix should ensure all cryptographic validations (especially trusted waypoints) are performed before making control flow decisions based on potentially manipulated fields.

### Citations

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L93-95)
```rust
            if past_target {
                break;
            }
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L107-111)
```rust
            for li in lis {
                if li.ledger_info().version() > self.target_version {
                    past_target = true;
                    break;
                }
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L129-136)
```rust
                if let Some(wp_trusted) = self.trusted_waypoints.get(&wp_li.version()) {
                    ensure!(
                        *wp_trusted == wp_li,
                        "Waypoints don't match. In backup: {}, trusted: {}",
                        wp_li,
                        wp_trusted,
                    );
                } else if let Some(pre_li) = previous_li {
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L279-288)
```rust
        if epoch > self.epoch_endings.len() as u64 {
            // TODO(aldenhu): fix this from upper level
            warn!(
                epoch = epoch,
                epoch_history_until = self.epoch_endings.len(),
                "Epoch is too new and can't be verified. Previous chunks are verified and node \
                won't be able to start if this data is malicious."
            );
            return Ok(());
        }
```

**File:** types/src/waypoint.rs (L62-79)
```rust
    pub fn verify(&self, ledger_info: &LedgerInfo) -> Result<()> {
        ensure!(
            ledger_info.version() == self.version(),
            "Waypoint version mismatch: waypoint version = {}, given version = {}",
            self.version(),
            ledger_info.version()
        );
        let converter = Ledger2WaypointConverter::new(ledger_info);
        ensure!(
            converter.hash() == self.value(),
            format!(
                "Waypoint value mismatch: waypoint value = {}, given value = {}",
                self.value().to_hex(),
                converter.hash().to_hex()
            )
        );
        Ok(())
    }
```
