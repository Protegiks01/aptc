# Audit Report

## Title
State Tombstone Premature Pruning Vulnerability Due to Version Equality in Stale Index

## Summary
When state values are deleted, the stale index entry is created with `stale_since_version == version`, causing tombstones to be pruned while still within the queryable version range. This results in queries at the deletion version incorrectly returning old values instead of `None`, breaking state consistency guarantees.

## Finding Description

The vulnerability exists in how deletion operations (tombstones) create stale state value index entries. [1](#0-0) 

When a state key is deleted at version V, the code creates a stale index with both `stale_since_version` and `version` set to V. This indicates the tombstone is "stale since the version it was created," which is semantically incorrect.

The pruning logic deletes all stale entries where `stale_since_version <= target_version`. [2](#0-1) 

The pruner target is calculated as `min_readable_version = latest_version - prune_window`. [3](#0-2) 

However, queries are allowed for any version >= min_readable_version. [4](#0-3) 

**The Critical Issue**: When `min_readable_version = V`, both conditions are true:
1. Version V is queryable (V >= min_readable_version)
2. The tombstone at version V is pruned (stale_since_version V <= target V)

After pruning, queries at version V use the iterator seek mechanism which returns the next available entry in descending version order. [5](#0-4) 

Since versions are stored with bitwise-inverted encoding for descending order, the iterator returns an older version's value instead of None. [6](#0-5) 

**Exploitation Path**:
1. At version 800: Key K has value V1
2. At version 900: Key K is deleted (tombstone created with stale_since_version=900, version=900)
3. At version 1000: Pruning runs with target=900, deleting the tombstone
4. Query at version 900 returns V1 instead of None
5. Different nodes with different pruning states return inconsistent results

This violates the **State Consistency** invariant: queries at version V must return the state as it existed at version V.

## Impact Explanation

**Severity: Medium** (State inconsistencies requiring intervention)

This vulnerability breaks two critical invariants:

1. **State Consistency**: Queries no longer return accurate historical state after pruning, violating the guarantee that "state transitions must be atomic and verifiable."

2. **Deterministic Execution**: Nodes with different pruning states return different results for the same query, potentially breaking the requirement that "all validators must produce identical state roots for identical blocks" if these queries are used during block execution.

While this doesn't directly cause fund loss, it creates state inconsistencies that could:
- Cause consensus divergence if validators query pruned versions during execution
- Break state synchronization for nodes catching up
- Violate historical state query guarantees for applications and indexers
- Require manual intervention to identify and resolve inconsistencies

The impact aligns with Medium severity per Aptos bug bounty: "State inconsistencies requiring intervention."

## Likelihood Explanation

**Likelihood: High**

This issue occurs automatically and predictably:

1. **Trigger Frequency**: Every state deletion (common in smart contract operations like resource cleanup, NFT burning, account deletions) creates the vulnerable condition.

2. **Automatic Occurrence**: Pruning runs automatically based on configuration, requiring no attacker action beyond triggering deletions.

3. **Observable Impact**: Any application querying historical state at pruning boundaries will observe incorrect results.

4. **No Special Privileges**: Any user can submit transactions that delete state values, triggering this vulnerability.

The only requirement is that queries occur at exactly the pruning boundary version, but given continuous operation, this is inevitable over time.

## Recommendation

**Fix**: Change the stale index creation for deletions to set `stale_since_version = version + 1` instead of `version`.

In `storage/aptosdb/src/state_store/mod.rs`, modify the deletion handling:

```rust
if update_to_cold.state_op.expect_as_write_op().is_delete() {
    // Tombstone should be stale from NEXT version, not current version
    // This ensures it remains queryable at the deletion version
    Self::put_state_kv_index(batch, enable_sharding, version + 1, version, key);
}
```

This ensures tombstones are only pruned when `target_version >= version + 1`, meaning version V is no longer in the queryable range when the tombstone at V is pruned.

**Alternative**: Modify the pruning boundary check to use strict inequality:
```rust
if index.stale_since_version >= target_version {  // Changed from >
    break;
}
```

However, the first solution is preferred as it maintains clearer semantics: a value is "stale since V" only when it's been replaced at version V.

## Proof of Concept

```rust
// Test case demonstrating the vulnerability
#[test]
fn test_tombstone_pruning_boundary_bug() {
    let executor = TestExecutor::new();
    let db = &executor.db;
    let test_key = StateKey::raw(b"vulnerable_key");
    let test_value = vec![1u8, 2, 3, 4];
    
    // Version 800: Create state value
    let txn1 = create_test_transaction(0);
    let write_set1 = WriteSetMut::new(vec![(
        test_key.clone(),
        WriteOp::legacy_modification(test_value.clone()),
    )]).freeze().unwrap();
    apply_transaction_by_writeset(db, vec![(txn1, write_set1)]);
    
    // Version 900: Delete the key (tombstone created)
    let txn2 = create_test_transaction(1);
    let write_set2 = WriteSetMut::new(vec![(
        test_key.clone(),
        WriteOp::legacy_deletion(),
    )]).freeze().unwrap();
    apply_transaction_by_writeset(db, vec![(txn2, write_set2)]);
    
    // Verify deletion worked
    let result_before_prune = db.reader
        .get_state_value_by_version(&test_key, 900)
        .unwrap();
    assert!(result_before_prune.is_none(), "Should be deleted at v900");
    
    // Simulate pruning to version 900 (min_readable_version = 900)
    // This would prune the tombstone at version 900
    db.state_store.state_kv_pruner.prune_to_version(900).unwrap();
    
    // BUG: Query at version 900 now returns the old value!
    let result_after_prune = db.reader
        .get_state_value_by_version(&test_key, 900)
        .unwrap();
    
    // This assertion FAILS - we get Some(old_value) instead of None
    assert!(result_after_prune.is_none(), 
        "VULNERABILITY: Deleted state reappears after pruning! Got: {:?}", 
        result_after_prune);
}
```

This test would fail, demonstrating that the tombstone at version 900 is incorrectly pruned while version 900 remains queryable, causing deleted state to reappear.

## Notes

The root cause is the semantic confusion between "stale since" and "created at" for tombstones. A tombstone at version V represents the current state from V onwards (the state is "deleted"), so it should only become stale when replaced or when V+1 is the new minimum queryable version, not at V itself.

This affects all deletion operations in the system, including Move resource deletions, table entry removals, and any other state cleanup operations.

### Citations

**File:** storage/aptosdb/src/state_store/mod.rs (L947-951)
```rust
                if update_to_cold.state_op.expect_as_write_op().is_delete() {
                    // This is a tombstone, can be pruned once this `version` goes out of
                    // the pruning window.
                    Self::put_state_kv_index(batch, enable_sharding, version, version, key);
                }
```

**File:** storage/aptosdb/src/pruner/state_kv_pruner/state_kv_shard_pruner.rs (L58-65)
```rust
        for item in iter {
            let (index, _) = item?;
            if index.stale_since_version > target_version {
                break;
            }
            batch.delete::<StaleStateValueIndexByKeyHashSchema>(&index)?;
            batch.delete::<StateValueByKeyHashSchema>(&(index.state_key_hash, index.version))?;
        }
```

**File:** storage/aptosdb/src/pruner/state_kv_pruner/state_kv_pruner_manager.rs (L130-141)
```rust
        let min_readable_version = latest_version.saturating_sub(self.prune_window);
        self.min_readable_version
            .store(min_readable_version, Ordering::SeqCst);

        PRUNER_VERSIONS
            .with_label_values(&["state_kv_pruner", "min_readable"])
            .set(min_readable_version as i64);

        self.pruner_worker
            .as_ref()
            .unwrap()
            .set_target_db_version(min_readable_version);
```

**File:** storage/aptosdb/src/db/aptosdb_internal.rs (L305-315)
```rust
    pub(super) fn error_if_state_kv_pruned(&self, data_type: &str, version: Version) -> Result<()> {
        let min_readable_version = self.state_store.state_kv_pruner.get_min_readable_version();
        ensure!(
            version >= min_readable_version,
            "{} at version {} is pruned, min available version is {}.",
            data_type,
            version,
            min_readable_version
        );
        Ok(())
    }
```

**File:** storage/aptosdb/src/schema/state_value/mod.rs (L42-48)
```rust
impl KeyCodec<StateValueSchema> for Key {
    fn encode_key(&self) -> Result<Vec<u8>> {
        let mut encoded = vec![];
        encoded.write_all(self.0.encoded())?;
        encoded.write_u64::<BigEndian>(!self.1)?;
        Ok(encoded)
    }
```

**File:** storage/aptosdb/src/state_kv_db.rs (L387-401)
```rust
            iter.seek(&(state_key.clone(), version))?;
            Ok(iter
                .next()
                .transpose()?
                .and_then(|((_, version), value_opt)| value_opt.map(|value| (version, value))))
        } else {
            let mut iter = self
                .db_shard(state_key.get_shard_id())
                .iter_with_opts::<StateValueByKeyHashSchema>(read_opts)?;
            iter.seek(&(state_key.hash(), version))?;
            Ok(iter
                .next()
                .transpose()?
                .and_then(|((_, version), value_opt)| value_opt.map(|value| (version, value))))
        }
```
