# Audit Report

## Title
Cloudflare API Key Exposed in Application Logs at Startup

## Summary
The `cloudflare_auth_key` credential is logged in plaintext when the NFT Metadata Crawler service starts up, exposing the Cloudflare Images API authentication token to anyone with access to application logs.

## Finding Description
The NFT Metadata Crawler's configuration logging mechanism exposes sensitive credentials through Debug formatting. The vulnerability chain is as follows:

1. The `AssetUploaderWorkerConfig` struct derives the `Debug` trait and contains `cloudflare_auth_key` as a public `String` field [1](#0-0) 

2. This configuration is nested within `ServerConfig` enum (also deriving Debug), which is nested in `NFTMetadataCrawlerConfig` (also deriving Debug) [2](#0-1) 

3. At service startup, the entire configuration structure is logged with Debug formatting [3](#0-2) 

When Rust's derived `Debug` trait formats a struct, it recursively prints all fields including nested structures. This means the log output includes the complete `cloudflare_auth_key` in plaintext.

**Attack Path:**
- Service starts with AssetUploaderWorker configuration
- Line 88 executes, logging full config tree including the authentication key
- Attacker with log access (developer, operations staff, compromised log aggregation system, or anyone with access to log files) extracts the plaintext credential
- Attacker uses stolen Cloudflare API key to access the Images API with full account permissions

**Additional Context on Error Paths:**
While the primary vulnerability is at startup logging, the error handling in `upload_asset()` also logs errors with Debug formatting [4](#0-3) . However, reqwest errors typically do not include request headers in their error messages, so this is less likely to leak credentials. The HTTP response error messages use Display formatting [5](#0-4) , which also typically doesn't expose headers from reqwest errors.

## Impact Explanation
This vulnerability qualifies as **Low Severity** per the Aptos bug bounty program criteria. While it represents a credential exposure issue, it affects an ecosystem tool (NFT metadata crawler) rather than core blockchain consensus, execution, or governance components. The impact is limited to:

- Unauthorized access to the Cloudflare Images API for the affected account
- Potential for malicious content uploads, image deletions, or API quota exhaustion
- No direct impact on blockchain consensus, validator operations, or on-chain funds

This does not meet Critical, High, or Medium severity thresholds which require blockchain-level impacts such as consensus violations, fund theft, or state corruption.

## Likelihood Explanation
**High likelihood** - This vulnerability is guaranteed to occur on every service startup when the AssetUploaderWorker configuration is used. The exposure happens automatically without requiring any specific conditions or attacker actions beyond gaining log access.

## Recommendation
Implement credential redaction for sensitive configuration fields:

1. **Create a custom Debug implementation** for `AssetUploaderWorkerConfig` that redacts the auth key:
```rust
impl std::fmt::Debug for AssetUploaderWorkerConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("AssetUploaderWorkerConfig")
            .field("cloudflare_auth_key", &"[REDACTED]")
            .field("cloudflare_account_id", &self.cloudflare_account_id)
            .finish()
    }
}
```

2. **Remove the derived Debug trait** from the config struct and use the custom implementation above.

3. **Alternatively**, wrap sensitive fields in a newtype that implements redacted Debug formatting:
```rust
pub struct SensitiveString(String);
impl std::fmt::Debug for SensitiveString {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "[REDACTED]")
    }
}
```

4. **Consider using a secrets management pattern** where credentials are never included in config structs that derive Debug.

## Proof of Concept

**Step 1**: Create a test configuration file with AssetUploaderWorker settings:
```yaml
database_url: "postgresql://localhost/test"
server_port: 8080
server_config:
  type: AssetUploaderWorker
  cloudflare_auth_key: "test_secret_key_12345"
  cloudflare_account_id: "test_account_id"
```

**Step 2**: Start the NFT Metadata Crawler service with this configuration.

**Step 3**: Observe the application logs. You will see output similar to:
```
INFO [NFT Metadata Crawler] Starting with config: NFTMetadataCrawlerConfig { 
    database_url: "postgresql://localhost/test", 
    server_port: 8080, 
    server_config: AssetUploaderWorker(
        AssetUploaderWorkerConfig { 
            cloudflare_auth_key: "test_secret_key_12345", 
            cloudflare_account_id: "test_account_id" 
        }
    ) 
}
```

The `cloudflare_auth_key` value is clearly visible in plaintext.

**Step 4**: Anyone with access to these logs can extract the credential and use it to authenticate to the Cloudflare Images API.

---

## Notes
This vulnerability is a real credential exposure issue in the codebase, but it affects an ecosystem tool rather than core blockchain infrastructure. While it represents poor security practice and should be fixed, it does not constitute a blockchain consensus, execution, or governance vulnerability under the strict Aptos bug bounty criteria. The impact is limited to the NFT metadata crawler service's Cloudflare account access and does not affect blockchain operations, validator security, or on-chain asset safety.

### Citations

**File:** ecosystem/nft-metadata-crawler/src/asset_uploader/worker/config.rs (L7-11)
```rust
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct AssetUploaderWorkerConfig {
    /// Cloudflare API key
    pub cloudflare_auth_key: String,
```

**File:** ecosystem/nft-metadata-crawler/src/config.rs (L30-46)
```rust
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(tag = "type")]
pub enum ServerConfig {
    Parser(ParserConfig),
    AssetUploaderWorker(AssetUploaderWorkerConfig),
    AssetUploaderApi,
    AssetUploaderThrottler(AssetUploaderThrottlerConfig),
}

/// Structs to hold config from YAML
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct NFTMetadataCrawlerConfig {
    pub database_url: String,
    pub server_port: u16,
    pub server_config: ServerConfig,
}
```

**File:** ecosystem/nft-metadata-crawler/src/config.rs (L88-88)
```rust
        info!("[NFT Metadata Crawler] Starting with config: {:?}", self);
```

**File:** ecosystem/nft-metadata-crawler/src/asset_uploader/worker/mod.rs (L117-117)
```rust
                error!(asset_uri = ?request.url, error = ?e, "[Asset Uploader] Error uploading asset");
```

**File:** ecosystem/nft-metadata-crawler/src/asset_uploader/worker/mod.rs (L120-120)
```rust
                    format!("Error uploading asset: {}", e),
```
