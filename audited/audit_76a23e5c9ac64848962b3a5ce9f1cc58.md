# Audit Report

## Title
API Race Condition Causes State Version Mismatch Between Response Headers and Transaction Data

## Summary
The `get_transaction_by_hash_inner()` function contains a race condition where `ledger_info` is captured at version N but the transaction is decoded using state from a later version N+k. This results in API responses with inconsistent metadata (headers claim version N) and data (decoded using state from version N+k), breaking client-side verification and API response integrity.

## Finding Description

The vulnerability exists in the two-stage async blocking architecture of transaction retrieval: [1](#0-0) 

**Stage 1 (Line 950-952):** The function calls `api_spawn_blocking()` to retrieve `ledger_info` at version N (time T1).

**Stage 2 (Line 973-977):** After asynchronous transaction lookup, it calls another `api_spawn_blocking()` to convert the transaction using `get_transaction_inner()`.

The critical flaw occurs in `get_transaction_inner()`: [2](#0-1) 

At line 1017, `latest_state_view_poem(ledger_info)` is called. Despite receiving `ledger_info` as a parameter (which contains version N), this function **ignores the version** and retrieves the absolute latest state: [3](#0-2) 

The `latest_state_checkpoint_view()` implementation confirms it gets the current latest version: [4](#0-3) 

This state view is then used to decode transaction data, including:
- Write set changes with resource type information
- Events with type annotations
- Table items with type metadata [5](#0-4) 

The transaction conversion accesses state for type information: [6](#0-5) 

Finally, the API response includes ledger_info from version N in HTTP headers: [7](#0-6) 

**Result:** The API returns:
- **Headers:** `X-Aptos-Ledger-Version: N`, state from version N
- **Body:** Transaction data decoded using state from version N+k (where k > 0)

## Impact Explanation

This qualifies as **Medium Severity** under Aptos bug bounty criteria for "State inconsistencies requiring intervention":

1. **API Integrity Violation**: The response is internally inconsistent - metadata claims version N but data reflects version N+k. This violates the fundamental API contract that responses are self-consistent.

2. **Client Verification Impossible**: Light clients attempting to verify API responses against the state root hash in the ledger info headers will fail, as the decoded transaction data was generated using a different state version.

3. **Module Upgrade Confusion**: If a Move module is upgraded between version N and N+k, the transaction payload will be decoded using the new module ABI, potentially showing incorrect or corrupted data for transactions that executed with the old ABI.

4. **Epoch Boundary Corruption**: When epoch changes occur between T1 and T2, governance/staking transactions may be decoded using wrong validator set configurations, misleading clients about actual on-chain state.

5. **Audit Trail Corruption**: Systems recording API responses for compliance cannot determine the true state at version N, as the data was decoded with future state information.

## Likelihood Explanation

**Likelihood: HIGH**

This race condition occurs naturally during normal blockchain operation:

- Aptos produces blocks every few hundred milliseconds
- API calls involve two separate blocking thread pool operations with await points between them
- During high transaction throughput, the blockchain frequently advances between the two `api_spawn_blocking()` calls
- No synchronization mechanism prevents the state from advancing between stages
- Any client calling `/transactions/by_hash/{hash}` during active block production will encounter this issue

The vulnerability requires no special attacker capabilities - it happens organically as part of normal API operations under load.

## Recommendation

**Fix:** Pin the state view to the ledger version captured in stage 1.

Replace `latest_state_view_poem()` with a version-specific state view:

```rust
// In get_transaction_inner(), change line 1017 from:
let state_view = self.context.latest_state_view_poem(ledger_info)?;

// To:
let state_view = self.context.state_view_at_version_poem(
    Some(ledger_info.ledger_version.into()),
    ledger_info
)?;
```

Add the helper method to Context:

```rust
pub fn state_view_at_version_poem<E: InternalError>(
    &self,
    version: Option<u64>,
    ledger_info: &LedgerInfo,
) -> Result<DbStateView, E> {
    self.db
        .state_view_at_version(version)
        .context("Failed to read state view at specified version from DB")
        .map_err(|e| E::internal_with_code(e, AptosErrorCode::InternalError, ledger_info))
}
```

This ensures transaction decoding uses the exact state version specified in the response metadata, maintaining internal consistency.

## Proof of Concept

**Reproduction Steps:**

1. Start a local Aptos testnet with continuous transaction submission:
```bash
aptos node run-local-testnet --with-faucet
```

2. Submit transactions continuously in background:
```bash
while true; do
  aptos account transfer --account alice --amount 100 --recipient bob
  sleep 0.1
done
```

3. Query transactions while monitoring version headers:
```bash
# Get a recent transaction hash
HASH=$(aptos account list --query account | jq -r '.Result[0].transaction_hash')

# Query repeatedly and compare versions
for i in {1..100}; do
  RESPONSE=$(curl -v "http://localhost:8080/v1/transactions/by_hash/$HASH" 2>&1)
  HEADER_VERSION=$(echo "$RESPONSE" | grep "X-Aptos-Ledger-Version:" | cut -d' ' -f3)
  
  # Extract state-dependent decoded data
  # If write sets decode differently between calls, version mismatch occurred
  echo "Header Version: $HEADER_VERSION"
  sleep 0.05
done
```

4. **Expected Result:** Under load, responses will show the same transaction hash but with varying ledger version headers, while the decoded transaction data (especially resource types and table decoding) reflects the state at the time of conversion, not the header version.

5. **Verification:** Compare the `state_change_hash` in transaction info against the state root at the header version - they will be inconsistent when the race occurs.

**Notes**

This vulnerability is an API-layer consistency issue, not a consensus or state corruption bug. The blockchain state itself remains correct and consistent. However, it breaks the API contract that responses are internally consistent, preventing clients from correctly verifying API data against claimed ledger versions. This is particularly problematic for light clients, audit systems, and applications requiring cryptographic verification of API responses.

### Citations

**File:** api/src/transactions.rs (L942-978)
```rust
    async fn get_transaction_by_hash_inner(
        &self,
        accept_type: &AcceptType,
        hash: HashValue,
    ) -> BasicResultWith404<Transaction> {
        let context = self.context.clone();
        let accept_type = accept_type.clone();

        let (internal_ledger_info_opt, storage_ledger_info) =
            api_spawn_blocking(move || context.get_latest_internal_and_storage_ledger_info())
                .await?;
        let storage_version = storage_ledger_info.ledger_version.into();
        let internal_indexer_version = internal_ledger_info_opt
            .as_ref()
            .map(|info| info.ledger_version.into());
        let latest_ledger_info = internal_ledger_info_opt.unwrap_or(storage_ledger_info);

        let txn_data = self
            .get_by_hash(hash.into(), storage_version, internal_indexer_version)
            .await
            .context(format!("Failed to get transaction by hash {}", hash))
            .map_err(|err| {
                BasicErrorWith404::internal_with_code(
                    err,
                    AptosErrorCode::InternalError,
                    &latest_ledger_info,
                )
            })?
            .context(format!("Failed to find transaction with hash: {}", hash))
            .map_err(|_| transaction_not_found_by_hash(hash, &latest_ledger_info))?;

        let api = self.clone();
        api_spawn_blocking(move || {
            api.get_transaction_inner(&accept_type, txn_data, &latest_ledger_info)
        })
        .await
    }
```

**File:** api/src/transactions.rs (L1009-1058)
```rust
    fn get_transaction_inner(
        &self,
        accept_type: &AcceptType,
        transaction_data: TransactionData,
        ledger_info: &LedgerInfo,
    ) -> BasicResultWith404<Transaction> {
        match accept_type {
            AcceptType::Json => {
                let state_view = self.context.latest_state_view_poem(ledger_info)?;
                let transaction = match transaction_data {
                    TransactionData::OnChain(txn) => {
                        let timestamp =
                            self.context.get_block_timestamp(ledger_info, txn.version)?;
                        state_view
                            .as_converter(
                                self.context.db.clone(),
                                self.context.indexer_reader.clone(),
                            )
                            .try_into_onchain_transaction(timestamp, txn)
                            .context("Failed to convert on chain transaction to Transaction")
                            .map_err(|err| {
                                BasicErrorWith404::internal_with_code(
                                    err,
                                    AptosErrorCode::InternalError,
                                    ledger_info,
                                )
                            })?
                    },
                    TransactionData::Pending(txn) => state_view
                        .as_converter(self.context.db.clone(), self.context.indexer_reader.clone())
                        .try_into_pending_transaction(*txn)
                        .context("Failed to convert on pending transaction to Transaction")
                        .map_err(|err| {
                            BasicErrorWith404::internal_with_code(
                                err,
                                AptosErrorCode::InternalError,
                                ledger_info,
                            )
                        })?,
                };

                BasicResponse::try_from_json((transaction, ledger_info, BasicResponseStatus::Ok))
            },
            AcceptType::Bcs => BasicResponse::try_from_bcs((
                transaction_data,
                ledger_info,
                BasicResponseStatus::Ok,
            )),
        }
    }
```

**File:** api/src/context.rs (L160-168)
```rust
    pub fn latest_state_view_poem<E: InternalError>(
        &self,
        ledger_info: &LedgerInfo,
    ) -> Result<DbStateView, E> {
        self.db
            .latest_state_checkpoint_view()
            .context("Failed to read latest state checkpoint from DB")
            .map_err(|e| E::internal_with_code(e, AptosErrorCode::InternalError, ledger_info))
    }
```

**File:** storage/storage-interface/src/state_store/state_view/db_state_view.rs (L82-90)
```rust
    fn latest_state_checkpoint_view(&self) -> StateViewResult<DbStateView> {
        Ok(DbStateView {
            db: self.clone(),
            version: self
                .get_latest_state_checkpoint_version()
                .map_err(Into::<StateViewError>::into)?,
            maybe_verify_against_state_root_hash: None,
        })
    }
```

**File:** api/types/src/convert.rs (L173-242)
```rust
    pub fn try_into_onchain_transaction(
        &self,
        timestamp: u64,
        data: TransactionOnChainData,
    ) -> Result<Transaction> {
        use aptos_types::transaction::Transaction::{
            BlockEpilogue, BlockMetadata, BlockMetadataExt, GenesisTransaction, StateCheckpoint,
            UserTransaction,
        };
        let aux_data = self
            .db
            .get_transaction_auxiliary_data_by_version(data.version)?;
        let info = self.into_transaction_info(
            data.version,
            &data.info,
            data.accumulator_root_hash,
            data.changes,
            aux_data,
        );
        let events = self.try_into_events(&data.events)?;
        Ok(match data.transaction {
            UserTransaction(txn) => {
                let payload = self.try_into_transaction_payload(txn.payload().clone())?;
                (&txn, info, payload, events, timestamp).into()
            },
            GenesisTransaction(write_set) => {
                let payload = self.try_into_write_set_payload(write_set)?;
                (info, payload, events).into()
            },
            BlockMetadata(txn) => Transaction::BlockMetadataTransaction(
                BlockMetadataTransaction::from_internal(txn, info, events),
            ),
            BlockMetadataExt(txn) => Transaction::BlockMetadataTransaction(
                BlockMetadataTransaction::from_internal_ext(txn, info, events),
            ),
            StateCheckpoint(_) => {
                Transaction::StateCheckpointTransaction(StateCheckpointTransaction {
                    info,
                    timestamp: timestamp.into(),
                })
            },
            BlockEpilogue(block_epilogue_payload) => {
                let block_end_info = block_epilogue_payload
                    .try_as_block_end_info()
                    .unwrap()
                    .clone();
                let block_end_info = match block_end_info {
                    BlockEndInfo::V0 {
                        block_gas_limit_reached,
                        block_output_limit_reached,
                        block_effective_block_gas_units,
                        block_approx_output_size,
                    } => Some(crate::transaction::BlockEndInfo {
                        block_gas_limit_reached,
                        block_output_limit_reached,
                        block_effective_block_gas_units,
                        block_approx_output_size,
                    }),
                };
                Transaction::BlockEpilogueTransaction(BlockEpilogueTransaction {
                    info,
                    timestamp: timestamp.into(),
                    block_end_info,
                })
            },
            aptos_types::transaction::Transaction::ValidatorTransaction(txn) => {
                Transaction::ValidatorTransaction((txn, info, events, timestamp).into())
            },
        })
    }
```

**File:** api/types/src/convert.rs (L601-610)
```rust
    pub fn try_into_events(&self, events: &[ContractEvent]) -> Result<Vec<Event>> {
        let mut ret = vec![];
        for event in events {
            let data = self
                .inner
                .view_value(event.type_tag(), event.event_data())?;
            ret.push((event, MoveValue::try_from(data)?.json()?).into());
        }
        Ok(ret)
    }
```

**File:** api/src/response.rs (L366-395)
```rust
        impl <T: poem_openapi::types::ToJSON + Send + Sync> From<($crate::response::AptosResponseContent<T>, &aptos_api_types::LedgerInfo, [<$enum_name Status>])>
            for $enum_name<T>
        {
            fn from(
                (value, ledger_info, status): (
                    $crate::response::AptosResponseContent<T>,
                    &aptos_api_types::LedgerInfo,
                    [<$enum_name Status>]
                ),
            ) -> Self {
                match status {
                    $(
                    [<$enum_name Status>]::$name => {
                        $enum_name::$name(
                            value,
                            ledger_info.chain_id,
                            ledger_info.ledger_version.into(),
                            ledger_info.oldest_ledger_version.into(),
                            ledger_info.ledger_timestamp.into(),
                            ledger_info.epoch.into(),
                            ledger_info.block_height.into(),
                            ledger_info.oldest_block_height.into(),
                            None,
                            None,
                        )
                    },
                    )*
                }
            }
        }
```
