# Audit Report

## Title
Pre-Deserialization Size Check Bypass Enables CPU Exhaustion via Large NetworkInformationResponse

## Summary
A malicious peer can cause CPU exhaustion on victim nodes by sending `NetworkInformationResponse` messages with tens of thousands of `connected_peers` entries. The vulnerability exists because BCS deserialization and BTreeMap population occur at the network layer before application-level size validation, allowing attackers to force expensive O(n log n) operations on victim nodes regardless of configured size limits.

## Finding Description

The peer monitoring service performs size validation on responses **after** deserialization rather than before, creating a CPU exhaustion attack vector. [1](#0-0) 

The `NetworkInformationResponse` struct contains an unbounded `BTreeMap<PeerNetworkId, ConnectionMetadata>` for `connected_peers`.

When a peer monitoring client requests network information, the attack flow is:

1. **Network Layer Deserialization** (occurs first): [2](#0-1) 

The response bytes are deserialized at the network layer using `protocol.from_bytes(&res_data)` in a blocking task. This creates the full `BTreeMap` structure with all entries via BCS deserialization, performing O(n log n) BTreeMap insertions.

2. **Application Layer Size Check** (occurs after deserialization): [3](#0-2) 

Only after deserialization does `sanity_check_response_size` validate the message size: [4](#0-3) 

This function re-serializes the already-deserialized response to compute its size, adding additional CPU overhead.

3. **Server Creates Unlimited Responses**: [5](#0-4) 

The server includes ALL connected peers with no filtering or limits, collecting them into the BTreeMap.

**Attack Scenario:**
- Attacker runs a modified peer monitoring server that reports tens of thousands of fake `connected_peers` entries
- Network layer accepts messages up to `MAX_MESSAGE_SIZE` (64 MiB): [6](#0-5) 
- A 10 MiB response can contain ~66,000 entries, a 64 MiB response can contain ~426,000 entries
- Victim node deserializes the entire BTreeMap (expensive CPU work) before checking the `max_num_response_bytes` limit (default 100 KB): [7](#0-6) 
- Even though the response is ultimately rejected, the CPU damage is already done
- Attack repeats every 60 seconds per the default request interval: [8](#0-7) 

## Impact Explanation

This qualifies as **High Severity** ("Validator node slowdowns") per the Aptos bug bounty program.

**Quantified Impact:**
- BTreeMap insertion complexity is O(n log n)
- For 50,000 entries: ~50,000 × log₂(50,000) ≈ 815,000 operations per response
- Additional CPU cost from re-serialization in `get_num_bytes()` for size checking
- Attack affects all nodes that query malicious peers
- Repeated every 60 seconds per peer, multiplied across multiple malicious peers
- CPU exhaustion degrades consensus participation, state sync, and transaction processing

The vulnerability breaks the **Resource Limits** invariant: "All operations must respect gas, storage, and computational limits." No computational limit is enforced before deserialization.

## Likelihood Explanation

**High Likelihood:**
- Attack requires no privileged access—any network peer can execute it
- No cryptographic breaking or complex exploitation required
- Attacker simply needs to run a modified peer monitoring server
- Victims automatically query connected peers at regular intervals
- Default configuration is vulnerable (100 KB limit checked after deserialization of potentially 64 MB messages)
- Multiple malicious peers compound the effect

## Recommendation

**Implement size validation before deserialization at the network layer:**

1. Add a protocol-specific size limit check in the network layer before calling `from_bytes()`
2. Store the raw response size and validate against `max_num_response_bytes` before deserialization
3. Consider implementing streaming deserialization with early termination for collection types
4. Add a hard limit on the number of entries in `NetworkInformationResponse.connected_peers` at the protocol level

**Suggested Fix Approach:**

```rust
// In network/framework/src/protocols/network/mod.rs, modify send_rpc_raw:
pub async fn send_rpc_raw(
    &self,
    recipient: PeerId,
    protocol: ProtocolId,
    req_msg: Bytes,
    timeout: Duration,
    max_response_bytes: Option<usize>, // Add parameter
) -> Result<TMessage, RpcError> {
    let res_data = self
        .peer_mgr_reqs_tx
        .send_rpc(recipient, protocol, req_msg, timeout)
        .await?;
    
    // Check size BEFORE deserialization
    if let Some(max_size) = max_response_bytes {
        if res_data.len() > max_size {
            return Err(RpcError::ResponseTooLarge(res_data.len(), max_size));
        }
    }
    
    // Only deserialize if size check passed
    let res_msg = tokio::task::spawn_blocking(move || protocol.from_bytes(&res_data)).await??;
    Ok(res_msg)
}
```

Additionally, enforce a maximum entry count on `NetworkInformationResponse`:

```rust
// In peer-monitoring-service/types/src/response.rs:
pub const MAX_CONNECTED_PEERS_IN_RESPONSE: usize = 1000;

impl NetworkInformationResponse {
    pub fn new(
        connected_peers: BTreeMap<PeerNetworkId, ConnectionMetadata>,
        distance_from_validators: u64,
    ) -> Result<Self, ResponseError> {
        if connected_peers.len() > MAX_CONNECTED_PEERS_IN_RESPONSE {
            return Err(ResponseError::TooManyPeers);
        }
        Ok(Self {
            connected_peers,
            distance_from_validators,
        })
    }
}
```

## Proof of Concept

```rust
// Integration test demonstrating CPU exhaustion
#[tokio::test]
async fn test_large_network_info_response_cpu_exhaustion() {
    use peer_monitoring_service_types::response::*;
    use aptos_config::network_id::{NetworkId, PeerNetworkId};
    use aptos_types::PeerId;
    use std::time::Instant;
    
    // Create a NetworkInformationResponse with 50,000 entries
    let mut connected_peers = BTreeMap::new();
    for i in 0..50_000 {
        let peer_id = PeerId::random();
        let peer_network_id = PeerNetworkId::new(NetworkId::Validator, peer_id);
        let metadata = ConnectionMetadata::new(
            "/ip4/127.0.0.1/tcp/8080".parse().unwrap(),
            peer_id,
            PeerRole::Validator,
        );
        connected_peers.insert(peer_network_id, metadata);
    }
    
    let response = NetworkInformationResponse {
        connected_peers,
        distance_from_validators: 0,
    };
    
    // Serialize the response (simulates network transmission)
    let serialized = bcs::to_bytes(&response).unwrap();
    println!("Serialized size: {} bytes", serialized.len());
    
    // Measure deserialization time (this is where CPU exhaustion occurs)
    let start = Instant::now();
    let _deserialized: NetworkInformationResponse = bcs::from_bytes(&serialized).unwrap();
    let duration = start.elapsed();
    
    println!("Deserialization took: {:?}", duration);
    println!("This expensive operation happens BEFORE size validation!");
    
    // Size check happens AFTER deserialization
    let check_start = Instant::now();
    let response_bytes = PeerMonitoringServiceResponse::NetworkInformation(_deserialized)
        .get_num_bytes()
        .unwrap();
    let check_duration = check_start.elapsed();
    
    println!("Size check (with re-serialization) took: {:?}", check_duration);
    println!("Response size: {} bytes (exceeds 100KB limit)", response_bytes);
    
    // Demonstrate the attack can be repeated
    assert!(duration.as_millis() > 10, "Deserialization should take measurable time");
}
```

**Notes:**
- The vulnerability exists in the architectural decision to deserialize before size validation
- Affects all peer monitoring service clients across the network
- Can be exploited by any malicious peer without special privileges
- Default configuration provides insufficient protection (100 KB limit applied post-deserialization)

### Citations

**File:** peer-monitoring-service/types/src/response.rs (L52-55)
```rust
pub struct NetworkInformationResponse {
    pub connected_peers: BTreeMap<PeerNetworkId, ConnectionMetadata>, // Connected peers
    pub distance_from_validators: u64, // The distance of the peer from the validator set
}
```

**File:** network/framework/src/protocols/network/mod.rs (L468-470)
```rust
        // Deserialize the response using a blocking task
        let res_msg = tokio::task::spawn_blocking(move || protocol.from_bytes(&res_data)).await??;
        Ok(res_msg)
```

**File:** peer-monitoring-service/client/src/peer_states/peer_state.rs (L135-142)
```rust
            if let Err(error) =
                sanity_check_response_size(max_num_response_bytes, &monitoring_service_response)
            {
                peer_state_value
                    .write()
                    .handle_monitoring_service_response_error(&peer_network_id, error);
                return;
            }
```

**File:** peer-monitoring-service/client/src/peer_states/peer_state.rs (L313-331)
```rust
fn sanity_check_response_size(
    max_num_response_bytes: u64,
    monitoring_service_response: &PeerMonitoringServiceResponse,
) -> Result<(), Error> {
    // Calculate the number of bytes in the response
    let num_response_bytes = monitoring_service_response.get_num_bytes()?;

    // Verify the response respects the max message sizes
    if num_response_bytes > max_num_response_bytes {
        return Err(Error::UnexpectedError(format!(
            "The monitoring service response ({:?}) is too large: {:?}. Maximum allowed: {:?}",
            monitoring_service_response.get_label(),
            num_response_bytes,
            max_num_response_bytes
        )));
    }

    Ok(())
}
```

**File:** peer-monitoring-service/server/src/lib.rs (L217-247)
```rust
    fn get_network_information(&self) -> Result<PeerMonitoringServiceResponse, Error> {
        // Get the connected peers
        let connected_peers_and_metadata =
            self.peers_and_metadata.get_connected_peers_and_metadata()?;
        let connected_peers = connected_peers_and_metadata
            .into_iter()
            .map(|(peer, metadata)| {
                let connection_metadata = metadata.get_connection_metadata();
                (
                    peer,
                    ConnectionMetadata::new(
                        connection_metadata.addr,
                        connection_metadata.remote_peer_id,
                        connection_metadata.role,
                    ),
                )
            })
            .collect();

        // Get the distance from the validators
        let distance_from_validators =
            get_distance_from_validators(&self.base_config, self.peers_and_metadata.clone());

        // Create and return the response
        let network_information_response = NetworkInformationResponse {
            connected_peers,
            distance_from_validators,
        };
        Ok(PeerMonitoringServiceResponse::NetworkInformation(
            network_information_response,
        ))
```

**File:** config/src/config/network_config.rs (L50-50)
```rust
pub const MAX_MESSAGE_SIZE: usize = 64 * 1024 * 1024; /* 64 MiB */
```

**File:** config/src/config/peer_monitoring_config.rs (L28-28)
```rust
            max_num_response_bytes: 100 * 1024, // 100 KB
```

**File:** config/src/config/peer_monitoring_config.rs (L68-68)
```rust
            network_info_request_interval_ms: 60_000, // 1 minute
```
