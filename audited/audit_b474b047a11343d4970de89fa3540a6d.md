# Audit Report

## Title
Captcha Key Sharing Enables Coordinated Mass Faucet Draining Attacks

## Summary
The `/request_captcha` endpoint lacks rate limiting and captchas never expire, allowing attackers to generate unlimited captcha challenges, solve them offline, and distribute the key-solution pairs to coordinate mass faucet draining attacks that completely bypass the anti-bot protection.

## Finding Description

The Aptos faucet implements a captcha system to prevent automated bot attacks. However, this system has a critical design flaw that enables attackers to share captcha solutions and coordinate large-scale draining attacks.

**Vulnerability Flow:**

1. The `/request_captcha` endpoint generates captcha challenges without any rate limiting [1](#0-0) 

2. Each captcha is stored indefinitely in an in-memory HashMap with no expiration mechanism [2](#0-1) 

3. The file itself acknowledges the OOM attack vector but not the key sharing vulnerability [3](#0-2) 

4. Captchas are only removed upon successful validation, making each captcha valid for exactly one funding request [4](#0-3) 

**Attack Scenario:**

1. Attacker calls `/request_captcha` 10,000 times (no rate limit exists)
2. Attacker receives 10,000 unique (key, image) pairs stored indefinitely
3. Attacker uses OCR software or captcha-solving services to solve all 10,000 captchas offline
4. Attacker distributes these 10,000 valid (key, solution) pairs to accomplices or uses them with different IPs/VPN endpoints
5. All 10,000 attackers submit `/fund` requests simultaneously, each with a unique valid captcha
6. Each funding request passes the TapCaptchaChecker since each uses a distinct, valid captcha [5](#0-4) 
7. Even with IP/JWT rate limiting on `/fund`, attackers can multiply their attack capacity by using VPNs, proxies, or multiple accounts

**Broken Invariant:**

This violates the **Resource Limits** invariant: "All operations must respect gas, storage, and computational limits." The `/request_captcha` endpoint has no limits, enabling unlimited captcha generation that facilitates coordinated attacks.

The captcha system's fundamental security assumption—"one human solves one captcha per request"—is completely bypassed because captchas can be bulk-generated, solved offline, and distributed for coordinated use.

## Impact Explanation

This is a **Medium Severity** vulnerability per the Aptos bug bounty criteria: "Limited funds loss or manipulation."

**Specific Impact:**
- Enables coordinated mass draining of faucet funds on testnets
- Completely defeats the anti-bot protection mechanism
- Attackers can stockpile unlimited valid captchas for future attacks
- Multiplies the effectiveness of rate limiting bypasses (VPNs, multiple accounts)
- Causes memory exhaustion on faucet servers through captcha accumulation

While limited to testnet faucet tokens (not mainnet funds), this represents a significant operational security failure that could disrupt testnet availability and exhaust faucet resources needed for legitimate developers.

## Likelihood Explanation

**Likelihood: High**

The attack requires only moderate effort:
- **Technical Complexity:** Low - simple HTTP requests and OCR/captcha-solving services
- **Cost:** Minimal - captcha-solving services cost $1-3 per 1000 captchas
- **Coordination:** Medium - requires distributing keys to accomplices or using proxy infrastructure
- **Detection:** Low - appears as normal traffic since each request uses a valid captcha

The attack is highly feasible because:
1. No rate limiting exists on captcha generation
2. Captcha-solving services and OCR tools are readily available
3. VPN/proxy services enable IP rotation for rate limit bypass
4. The attack leaves no unusual traces since all captchas are validly solved

## Recommendation

**Immediate Fixes:**

1. **Add Rate Limiting to `/request_captcha`:**
   - Apply the existing `RedisRatelimitChecker` or `MemoryRatelimitChecker` to the captcha endpoint
   - Limit captcha generation to 10-20 per IP/hour
   - Track captcha requests separately from funding requests

2. **Implement Captcha Expiration:**
   - Add a timestamp field to the `CaptchaManager` HashMap
   - Expire captchas after 5-10 minutes
   - Add periodic cleanup task to remove expired captchas

3. **One-to-One Captcha-to-Fund Binding:**
   - Bind each captcha to the requesting IP address or session
   - Reject captcha solutions submitted from different IPs than the requesting IP
   - Implement session tokens to tie captcha generation to fund requests

**Code Fix Example:**

```rust
// In CaptchaManager
pub struct CaptchaChallenge {
    solution: String,
    created_at: u64,
    source_ip: IpAddr,  // Bind to requesting IP
}

pub struct CaptchaManager {
    challenges: HashMap<u32, CaptchaChallenge>,
}

impl CaptchaManager {
    pub fn create_challenge(&mut self, source_ip: IpAddr) -> Result<(u32, Vec<u8>)> {
        // Cleanup expired captchas (older than 10 minutes)
        let now = get_current_time_secs();
        self.challenges.retain(|_, v| now - v.created_at < 600);
        
        let key = rand::thread_rng().gen_range(0, u32::MAX - 1);
        let (solution, image) = Captcha::new()
            .add_chars(5)
            .apply_filter(Noise::new(0.4))
            // ... filters ...
            .as_tuple()?;
        
        self.challenges.insert(key, CaptchaChallenge {
            solution,
            created_at: now,
            source_ip,
        });
        
        Ok((key, image))
    }
    
    pub fn check_challenge(&mut self, key: u32, value: &str, source_ip: IpAddr) -> Result<bool> {
        match self.challenges.get(&key) {
            Some(challenge) => {
                // Verify IP match
                if challenge.source_ip != source_ip {
                    bail!("Captcha IP mismatch");
                }
                // Verify not expired
                if get_current_time_secs() - challenge.created_at > 600 {
                    self.challenges.remove(&key);
                    bail!("Captcha expired");
                }
                // Verify solution
                if &challenge.solution == value {
                    self.challenges.remove(&key);
                    Ok(true)
                } else {
                    Ok(false)
                }
            },
            None => bail!("Captcha key unknown"),
        }
    }
}
```

## Proof of Concept

**Step 1: Generate Multiple Captchas (No Rate Limit)**
```bash
# Generate 1000 captchas
for i in {1..1000}; do
  curl -s http://faucet.testnet.aptoslabs.com/v1/request_captcha \
    -D headers_$i.txt -o captcha_$i.png
  # Extract CAPTCHA_KEY from headers
  KEY=$(grep -i "captcha-key:" headers_$i.txt | cut -d: -f2 | tr -d ' \r')
  echo "$KEY,captcha_$i.png" >> captcha_keys.csv
done
```

**Step 2: Solve Captchas Offline**
```python
# Using pytesseract OCR or a captcha-solving service
import pytesseract
from PIL import Image

solutions = {}
with open('captcha_keys.csv') as f:
    for line in f:
        key, image_path = line.strip().split(',')
        image = Image.open(image_path)
        solution = pytesseract.image_to_string(image).strip()
        solutions[key] = solution

# Save for distribution
with open('captcha_solutions.json', 'w') as f:
    json.dump(solutions, f)
```

**Step 3: Distribute and Execute Coordinated Attack**
```bash
# Each attacker uses a different captcha key/solution
curl -X POST http://faucet.testnet.aptoslabs.com/v1/fund \
  -H "CAPTCHA_KEY: 1234567890" \
  -H "CAPTCHA_VALUE: ABC12" \
  -H "Content-Type: application/json" \
  -d '{"address":"0x1234...","amount":100000000}'

# Repeat with different keys across 1000 different IPs/VPNs
# Result: 1000 successful funding requests bypassing captcha protection
```

**Expected Result:** All 1000 funding requests succeed because each uses a unique, valid captcha, completely bypassing the anti-bot protection system.

## Notes

The vulnerability is compounded by the fact that the captcha endpoint is mentioned in the server API documentation and is accessible without authentication. The existing warning comment in the code acknowledges potential OOM attacks but does not address the key sharing attack vector, which is the more serious security issue.

### Citations

**File:** crates/aptos-faucet/core/src/endpoints/captcha.rs (L40-58)
```rust
    async fn request_captcha(&self) -> Result<Response<Binary<Vec<u8>>>, AptosTapErrorResponse> {
        if !self.enabled {
            return Err(AptosTapError::new(
                "The CaptchaChecker is not enabled".to_string(),
                AptosTapErrorCode::EndpointNotEnabled,
            )
            .into());
        }
        let mut captcha_manager = self.captcha_manager.lock().await;
        let (key, image) = match captcha_manager.create_challenge() {
            Ok((key, image)) => (key, image),
            Err(e) => {
                return Err(
                    AptosTapError::new_with_error_code(e, AptosTapErrorCode::CheckerError).into(),
                );
            },
        };
        Ok(Response::new(Binary(image)).header(CAPTCHA_KEY, key))
    }
```

**File:** crates/aptos-faucet/core/src/checkers/tap_captcha.rs (L4-6)
```rust
//! Warning: This could be attacked and cause the server to OOM because we
//! don't throw out captchas info if it has been sitting there for too long /
//! the map grows too large.
```

**File:** crates/aptos-faucet/core/src/checkers/tap_captcha.rs (L50-114)
```rust
    async fn check(
        &self,
        data: CheckerData,
        _dry_run: bool,
    ) -> Result<Vec<RejectionReason>, AptosTapError> {
        let captcha_key = match data.headers.get(CAPTCHA_KEY) {
            Some(header_value) => match header_value
                .to_str()
                .map_err(|e| {
                    AptosTapError::new_with_error_code(e, AptosTapErrorCode::InvalidRequest)
                })?
                .parse::<u32>()
            {
                Ok(value) => value,
                Err(e) => {
                    return Ok(vec![RejectionReason::new(
                        format!("Captcha value not a number: {:#}", e),
                        RejectionReasonCode::CaptchaInvalid,
                    )])
                },
            },
            None => {
                return Ok(vec![RejectionReason::new(
                    format!("Captcha header {} not found", CAPTCHA_KEY),
                    RejectionReasonCode::CaptchaInvalid,
                )])
            },
        };

        let captcha_value = match data.headers.get(CAPTCHA_VALUE) {
            Some(header_value) => header_value.to_str().map_err(|e| {
                AptosTapError::new_with_error_code(e, AptosTapErrorCode::InvalidRequest)
            })?,
            None => {
                return Ok(vec![RejectionReason::new(
                    format!("Captcha header {} not found", CAPTCHA_VALUE),
                    RejectionReasonCode::CaptchaInvalid,
                )])
            },
        };

        let captcha_correct = match self
            .captcha_manager
            .lock()
            .await
            .check_challenge(captcha_key, captcha_value)
        {
            Ok(correct) => correct,
            Err(e) => {
                return Ok(vec![RejectionReason::new(
                    format!("Captcha key unknown: {}", e),
                    RejectionReasonCode::CaptchaInvalid,
                )])
            },
        };

        if !captcha_correct {
            return Ok(vec![RejectionReason::new(
                format!("Captcha value {} incorrect", captcha_value),
                RejectionReasonCode::CaptchaInvalid,
            )]);
        }

        Ok(vec![])
    }
```

**File:** crates/aptos-faucet/core/src/checkers/tap_captcha.rs (L125-131)
```rust
#[derive(Debug, Default)]
pub struct CaptchaManager {
    /// When a challenge is created, we return to the client the captcha itself
    /// and a random key they must make the second request with. This is a map
    /// from that random key to the value of the captcha.
    challenges: HashMap<u32, String>,
}
```

**File:** crates/aptos-faucet/core/src/checkers/tap_captcha.rs (L165-177)
```rust
    pub fn check_challenge(&mut self, key: u32, value: &str) -> Result<bool> {
        match self.challenges.get(&key) {
            Some(captcha) => {
                if captcha == value {
                    self.challenges.remove(&key);
                    Ok(true)
                } else {
                    Ok(false)
                }
            },
            None => bail!("Captcha key unknown: {}", key),
        }
    }
```
