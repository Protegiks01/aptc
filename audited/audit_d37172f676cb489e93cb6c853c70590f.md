# Audit Report

## Title
Event Data Loss Due to State Timing Mismatch in V2-to-V1 Event Translation

## Summary
Token mutation events are permanently dropped when the V2-to-V1 event translation system queries the latest state instead of historical state. When a token is mutated and subsequently burned within the same transaction (or before indexing completes), the translation fails because it cannot locate the deleted Token resource, causing the mutation event to be silently discarded without any error propagation.

## Finding Description

The Aptos event system supports two event versions: V1 (legacy event handles) and V2 (module events). When the `module_event_migration_enabled()` feature flag is enabled, token mutation operations emit V2 `Mutation` events instead of V1 `MutationEvent` events. [1](#0-0) 

For backward compatibility, the indexer translates V2 events to V1 format using the `EventV2TranslationEngine`. However, this translation has a critical flaw: it queries state using `latest_state_checkpoint_view()` rather than the state at the transaction version being indexed. [2](#0-1) 

The `TokenMutationTranslator` specifically requires the Token resource to exist to extract the event handle key and sequence number. If the resource is not found, it returns an error with the comment "The token may have been burned." [3](#0-2) 

When translation fails, the error is caught in the indexing code, logged as a warning, and `Ok(None)` is returned, causing the event to be silently dropped from the indexed event system. [4](#0-3) 

The dropped event is never added to the `EventByKeySchema` or `EventByVersionSchema`, making it permanently unqueryable via API endpoints. [5](#0-4) 

**Attack Scenario:**
1. Attacker calls `set_description()`, `set_name()`, or `set_uri()` on a token object
2. In the same transaction, the token is burned via `token::burn()`
3. Transaction commits successfully, emitting both the V2 Mutation event and destroying the Token resource
4. Indexer processes the transaction and attempts to translate the Mutation event
5. Translation queries `latest_state_checkpoint_view()` which reflects state AFTER the transaction
6. Token resource no longer exists, translation returns error
7. Error is caught and event is dropped with only a warning log
8. Mutation event is permanently lost from the indexed event system

## Impact Explanation

**Severity: Medium** (up to $10,000 per Aptos Bug Bounty)

This vulnerability causes **state inconsistencies requiring intervention** through permanent loss of event data. While it does not directly cause loss of funds or consensus failures, it breaks critical system invariants:

- **Data Integrity**: Events are an immutable part of blockchain history and should never be lost
- **Auditability**: Applications tracking token mutations rely on complete event histories for compliance and transparency
- **State Consistency**: The invariant that "all events emitted by committed transactions are queryable" is violated

The impact extends to:
- NFT marketplaces unable to track complete token history
- Auditing tools with gaps in mutation records
- Analytics platforms producing incorrect statistics
- Legal compliance systems missing critical provenance data

## Likelihood Explanation

**Likelihood: Medium-High**

This issue occurs whenever:
1. The `module_event_migration_enabled()` feature flag is enabled (currently enabled by default per the features configuration)
2. A token is mutated and burned within a short timeframe

The specific conditions are easily triggerable:
- Any user can call mutation functions (set_description, set_name, set_uri) with a `MutatorRef`
- Token burning is a standard operation in many NFT workflows
- The timing window exists whenever the indexer processes transactions with both mutations and burns

Real-world scenarios include:
- NFT games that update token metadata then burn obsolete tokens
- Dynamic NFTs that evolve based on events, with old versions being burned
- Token migration contracts that copy metadata before destroying originals

## Recommendation

**Primary Fix:** Modify the event translation system to use versioned state lookups instead of the latest state checkpoint.

The `EventV2TranslationEngine` should accept the transaction version as a parameter and query state at that specific version. This requires:

1. Modify `translate_event_v2_to_v1` signature to accept a version parameter
2. Replace `latest_state_checkpoint_view()` with `state_view_at_version(version)` 
3. Update all translator implementations to use the versioned state view

**Alternative Fix:** Store untranslated V2 events alongside translations, allowing fallback queries when translation fails. This preserves data even when translation is incomplete.

**Immediate Mitigation:** Add explicit error handling that propagates translation failures as critical errors rather than silently dropping events, alerting operators to data loss.

## Proof of Concept

```move
#[test(creator = @0x123, framework = @0x1)]
fun test_mutation_event_loss_on_burn(creator: &signer, framework: &signer) {
    // Setup: Enable module event migration feature
    use std::features;
    features::change_feature_flags_for_testing(
        framework, 
        vector[features::get_module_event_migration_feature()], 
        vector[]
    );
    
    // Create and mutate a token
    use aptos_token_objects::token::{Self, MutatorRef};
    use aptos_token_objects::collection;
    
    // Create collection and token
    let constructor_ref = collection::create_unlimited_collection(
        creator,
        string::utf8(b"Test Collection"),
        string::utf8(b""),
        option::none(),
        string::utf8(b""),
    );
    
    let token_ref = token::create(
        creator,
        string::utf8(b"Test Collection"),
        string::utf8(b"Test Token"),
        string::utf8(b"Initial Description"),
        option::none(),
        string::utf8(b""),
    );
    
    let mutator_ref = token::generate_mutator_ref(&token_ref);
    
    // This emits a V2 Mutation event when feature flag is enabled
    token::set_description(&mutator_ref, string::utf8(b"Updated Description"));
    
    // Burn the token in the same transaction
    let burn_ref = token::generate_burn_ref(&token_ref);
    token::burn(burn_ref);
    
    // At this point:
    // - Transaction succeeds and commits
    // - Mutation event was emitted (V2 format)
    // - Token resource is destroyed
    // - When indexer processes this transaction:
    //   - It tries to translate V2 Mutation â†’ V1 MutationEvent
    //   - Translation queries latest state for Token resource
    //   - Resource doesn't exist (burned)
    //   - Translation returns error
    //   - Event is dropped with Ok(None)
    // - Result: Mutation event is permanently lost from indexed events
}
```

**Notes**

The vulnerability stems from a fundamental architectural issue where the event translation layer operates on current state rather than historical state. This violates the principle that blockchain data should be immutable and fully queryable. The `MoveEventV1Type` implementation itself is not the root cause, but the migration to V2 events exposes this design flaw in the translation infrastructure.

While the `module_event_migration_enabled()` feature flag controls when this occurs, disabling the flag would prevent the ecosystem from adopting modern event patterns. The proper solution is fixing the translation layer to use versioned state queries, ensuring events remain accessible regardless of subsequent state changes.

### Citations

**File:** aptos-move/framework/aptos-token-objects/sources/token.move (L777-793)
```text
        if (std::features::module_event_migration_enabled()) {
            event::emit(Mutation {
                token_address: mutator_ref.self,
                mutated_field_name: string::utf8(b"description"),
                old_value: token.description,
                new_value: description
            })
        } else {
            event::emit_event(
                &mut token.mutation_events,
                MutationEvent {
                    mutated_field_name: string::utf8(b"description"),
                    old_value: token.description,
                    new_value: description
                },
            );
        };
```

**File:** storage/indexer/src/event_v2_translator.rs (L216-235)
```rust
    pub fn get_state_value_bytes_for_object_group_resource(
        &self,
        address: &AccountAddress,
        struct_tag: &StructTag,
    ) -> Result<Option<Bytes>> {
        let state_view = self
            .main_db_reader
            .latest_state_checkpoint_view()
            .expect("Failed to get state view");
        static OBJECT_GROUP_TAG: Lazy<StructTag> = Lazy::new(ObjectGroupResource::struct_tag);
        let state_key = StateKey::resource_group(address, &OBJECT_GROUP_TAG);
        let maybe_state_value = state_view.get_state_value(&state_key)?;
        let state_value = maybe_state_value
            .ok_or_else(|| anyhow::format_err!("ObjectGroup resource not found"))?;
        let object_group_resource: ObjectGroupResource = bcs::from_bytes(state_value.bytes())?;
        Ok(object_group_resource
            .group
            .get(struct_tag)
            .map(|bytes| Bytes::copy_from_slice(bytes)))
    }
```

**File:** storage/indexer/src/event_v2_translator.rs (L440-456)
```rust
        let (key, sequence_number) = if let Some(state_value_bytes) = engine
            .get_state_value_bytes_for_object_group_resource(
                token_mutation.token_address(),
                &struct_tag,
            )? {
            let token_resource: TokenResource = bcs::from_bytes(&state_value_bytes)?;
            let key = *token_resource.mutation_events().key();
            let sequence_number =
                engine.get_next_sequence_number(&key, token_resource.mutation_events().count())?;
            (key, sequence_number)
        } else {
            // If the token resource is not found, we skip the event translation to avoid panic
            // because the creation number cannot be decided. The token may have been burned.
            return Err(AptosDbError::from(anyhow::format_err!(
                "Token resource not found"
            )));
        };
```

**File:** storage/indexer/src/db_indexer.rs (L448-483)
```rust
                    if self.indexer_db.event_v2_translation_enabled() {
                        if let ContractEvent::V2(v2) = event {
                            if let Some(translated_v1_event) =
                                self.translate_event_v2_to_v1(v2).map_err(|e| {
                                    anyhow::anyhow!(
                                        "Failed to translate event: {:?}. Error: {}",
                                        v2,
                                        e
                                    )
                                })?
                            {
                                let key = *translated_v1_event.key();
                                let sequence_number = translated_v1_event.sequence_number();
                                self.event_v2_translation_engine
                                    .cache_sequence_number(&key, sequence_number);
                                event_keys.insert(key);
                                batch
                                    .put::<EventByKeySchema>(
                                        &(key, sequence_number),
                                        &(version, idx as u64),
                                    )
                                    .expect("Failed to put events by key to a batch");
                                batch
                                    .put::<EventByVersionSchema>(
                                        &(key, version, sequence_number),
                                        &(idx as u64),
                                    )
                                    .expect("Failed to put events by version to a batch");
                                batch
                                    .put::<TranslatedV1EventSchema>(
                                        &(version, idx as u64),
                                        &translated_v1_event,
                                    )
                                    .expect("Failed to put translated v1 events to a batch");
                            }
                        }
```

**File:** storage/indexer/src/db_indexer.rs (L562-580)
```rust
            let result = translator.translate_event_v2_to_v1(v2, &self.event_v2_translation_engine);
            match result {
                Ok(v1) => Ok(Some(v1)),
                Err(e) => {
                    // If the token object collection uses ConcurrentSupply, skip the translation and ignore the error.
                    // This is expected, as the event handle won't be found in either FixedSupply or UnlimitedSupply.
                    let is_ignored_error = (v2.type_tag() == &*MINT_TYPE
                        || v2.type_tag() == &*BURN_TYPE)
                        && e.to_string().contains("resource not found");
                    if !is_ignored_error {
                        warn!(
                            "Failed to translate event: {:?}. Error: {}",
                            v2,
                            e.to_string()
                        );
                    }
                    Ok(None)
                },
            }
```
