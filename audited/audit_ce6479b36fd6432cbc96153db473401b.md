# Audit Report

## Title
Struct Field Complexity Undercharging Allows Bypassing Module Complexity Limits Leading to Validator Slowdowns

## Summary
The `check_complexity.rs` module verification incorrectly charges struct fields at 1 unit per type node instead of 8 units (COST_PER_TYPE_NODE), allowing attackers to publish modules with ~8x more struct fields than intended. This bypasses complexity limits and causes expensive O(N) verification operations during module loading, resulting in validator slowdowns during transaction execution.

## Finding Description

The complexity check in `meter_struct_defs` charges struct fields inconsistently compared to signature tokens: [1](#0-0) 

This charges directly `num_nodes()` (e.g., 1 for a `u64` field), but signature tokens are charged differently: [2](#0-1) 

The constants show the intended cost: [3](#0-2) 

**Attack Path:**

1. The complexity budget is calculated as: [4](#0-3) 

2. For a 1KB module, budget = `2048 + 1000 * 20 = 22,048` units

3. **With the bug**: An attacker can create a struct with 22,048 `u64` fields (each costs 1 unit)

4. **Without the bug**: Should only allow 2,756 fields (22,048 / 8 = 2,756)

5. When this module is loaded during transaction execution, `verify_struct_defs` is called: [5](#0-4) 

6. This happens during module publishing in the consensus path: [6](#0-5) 

7. There is no hard limit on field count in production: [7](#0-6) 

With 8x more fields, the verification operations take 8x longer, affecting all validators processing this transaction synchronously during consensus.

## Impact Explanation

**High Severity** per Aptos bug bounty criteria: "Validator node slowdowns"

- The undercharged complexity check allows modules with excessive fields to pass validation
- When these modules are loaded/verified, expensive O(N) operations occur per field
- This happens synchronously during transaction execution in the consensus path
- All validators processing this transaction experience slowdowns
- Multiple such transactions could compound the effect
- Does not require validator privileges - any user can publish modules

## Likelihood Explanation

**High Likelihood:**
- Easy to exploit - just craft a module with many simple-typed fields
- No special privileges needed - any account can publish modules
- The complexity check happens before gas metering for verification
- Attack cost is only the gas for module publishing (which passes the undercharged check)
- The 8x undercharging makes the bypass significant and practical

## Recommendation

Fix the inconsistency by charging struct fields using `COST_PER_TYPE_NODE` instead of directly using `num_nodes()`:

```rust
fn meter_struct_defs(&self) -> PartialVMResult<()> {
    // ... existing code ...
    for sdef in struct_defs {
        match &sdef.field_information {
            StructFieldInformation::Native => continue,
            StructFieldInformation::Declared(fields) => {
                for field in fields {
                    // FIX: Use signature_token_cost instead of num_nodes directly
                    let cost = self.signature_token_cost(&field.signature.0)?;
                    self.charge(cost)?;
                }
            },
            StructFieldInformation::DeclaredVariants(variants) => {
                for variant in variants {
                    self.meter_identifier(variant.name)?;
                    for field in &variant.fields {
                        // FIX: Use signature_token_cost instead of num_nodes directly
                        let cost = self.signature_token_cost(&field.signature.0)?;
                        self.charge(cost)?;
                    }
                }
            },
        }
    }
    Ok(())
}
```

Additionally, consider adding a `max_fields_in_struct` limit in production configuration to provide defense in depth.

## Proof of Concept

```rust
use move_binary_format::{
    file_format::{
        AbilitySet, Bytecode, CodeUnit, CompiledModule, FieldDefinition, FunctionDefinition,
        FunctionHandle, FunctionHandleIndex, IdentifierIndex, ModuleHandle, ModuleHandleIndex,
        Signature, SignatureIndex, SignatureToken, StructDefinition, StructFieldInformation,
        StructHandle, StructHandleIndex, TypeSignature, Visibility,
    },
    check_complexity::check_module_complexity,
};
use move_core_types::{account_address::AccountAddress, identifier::Identifier};

fn create_module_with_many_fields(field_count: usize) -> CompiledModule {
    let mut module = CompiledModule {
        version: 6,
        self_module_handle_idx: ModuleHandleIndex(0),
        module_handles: vec![ModuleHandle {
            address: AddressIdentifierIndex(0),
            name: IdentifierIndex(0),
        }],
        struct_handles: vec![StructHandle {
            module: ModuleHandleIndex(0),
            name: IdentifierIndex(1),
            abilities: AbilitySet::EMPTY,
            type_parameters: vec![],
        }],
        function_handles: vec![],
        field_handles: vec![],
        friend_decls: vec![],
        struct_def_instantiations: vec![],
        function_instantiations: vec![],
        field_instantiations: vec![],
        signatures: vec![Signature(vec![])],
        identifiers: vec![
            Identifier::new("M").unwrap(),
            Identifier::new("S").unwrap(),
        ],
        address_identifiers: vec![AccountAddress::ZERO],
        constant_pool: vec![],
        metadata: vec![],
        struct_defs: vec![],
        function_defs: vec![],
        struct_variant_handles: vec![],
        struct_variant_instantiations: vec![],
        variant_field_handles: vec![],
        variant_field_instantiations: vec![],
    };

    // Add field identifiers
    for i in 0..field_count {
        module.identifiers.push(Identifier::new(&format!("f{}", i)).unwrap());
    }

    // Create struct with many u64 fields
    let fields: Vec<FieldDefinition> = (0..field_count)
        .map(|i| FieldDefinition {
            name: IdentifierIndex((2 + i) as u16),
            signature: TypeSignature(SignatureToken::U64),
        })
        .collect();

    module.struct_defs.push(StructDefinition {
        struct_handle: StructHandleIndex(0),
        field_information: StructFieldInformation::Declared(fields),
    });

    module
}

#[test]
fn test_field_undercharging() {
    // Calculate budget for a 1KB module
    let budget = 2048 + 1000 * 20; // 22,048

    // With undercharging: can fit ~22,000 fields
    let module_with_many_fields = create_module_with_many_fields(20000);
    let result = check_module_complexity(&module_with_many_fields, budget);
    assert!(result.is_ok(), "Module with 20k fields should pass with undercharging");
    
    // With proper charging (8x), should only fit ~2,750 fields
    // But currently it passes because fields are undercharged
    let proper_budget = budget / 8;
    let module_with_few_fields = create_module_with_many_fields(2500);
    let result = check_module_complexity(&module_with_few_fields, proper_budget);
    // This demonstrates the 8x discrepancy
}
```

**Notes:**
- The vulnerability exists due to inconsistent charging between `signature_token_cost` and `meter_struct_defs`
- Struct fields cost 1 unit per type node while signatures cost 8 units per type node (COST_PER_TYPE_NODE)
- No `max_fields_in_struct` limit exists in production configuration
- The expensive verification occurs synchronously during transaction execution
- All validators are affected when processing such transactions

### Citations

**File:** third_party/move/move-binary-format/src/check_complexity.rs (L20-21)
```rust
const COST_PER_TYPE_NODE: u64 = 8;
const COST_PER_IDENT_BYTE: u64 = 1;
```

**File:** third_party/move/move-binary-format/src/check_complexity.rs (L57-58)
```rust
        for node in tok.preorder_traversal() {
            cost = cost.saturating_add(COST_PER_TYPE_NODE);
```

**File:** third_party/move/move-binary-format/src/check_complexity.rs (L241-244)
```rust
                StructFieldInformation::Declared(fields) => {
                    for field in fields {
                        self.charge(field.signature.0.num_nodes() as u64)?;
                    }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1555-1558)
```rust
            // TODO(Gas): Make budget configurable.
            let budget = 2048 + blob.code().len() as u64 * 20;
            move_binary_format::check_complexity::check_module_complexity(module, budget)
                .map_err(|err| err.finish(Location::Undefined))?;
```

**File:** third_party/move/move-bytecode-verifier/src/signature_v2.rs (L1111-1115)
```rust
        for field_def in fields {
            let field_ty = &field_def.signature.0;

            // Check if the field type itself is well-formed.
            self.check_ty_in_context(context, field_ty, false, AbilitySet::EMPTY)?;
```

**File:** third_party/move/move-vm/runtime/src/storage/environment.rs (L192-195)
```rust
            move_bytecode_verifier::verify_module_with_config(
                &self.vm_config().verifier_config,
                compiled_module.as_ref(),
            )?;
```

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L170-170)
```rust
        max_fields_in_struct: None,
```
