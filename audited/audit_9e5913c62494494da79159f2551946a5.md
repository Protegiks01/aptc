# Audit Report

## Title
Fast Path Threshold Bypass Through Incomplete Validation in DKG Rounding Allows Threshold > 1.0 Invariant Violation

## Summary
A governance proposal can set fast path secrecy thresholds greater than 1.0, bypassing validation checks and causing the DKG rounding algorithm to create configurations with reconstruction thresholds exceeding 1.0. This violates the fundamental DKG invariant that thresholds must be in the range [0, 1] and breaks the fast path randomness reconstruction mechanism.

## Finding Description

The vulnerability exists in the randomness configuration validation and DKG rounding logic. When a governance proposal sets randomness thresholds, there are two critical validation failures:

**First Issue - Missing Move-Layer Validation:**
The Move framework's `randomness_config::new_v2()` function accepts any `FixedPoint64` value without validating that thresholds are ≤ 1.0. The `fixed_point64::create_from_rational()` function only validates that the result fits in the range [2^-64, 2^64-1], allowing values like `create_from_rational(150, 100)` to create a threshold of 1.5. [1](#0-0) [2](#0-1) 

**Second Issue - Incomplete Clamping in Rust:**
When the DKG system processes these thresholds, the `DKGRounding::new()` method performs validation checks that fail for thresholds > 2/3. The code then falls back to the `infallible()` method, which is intended to handle edge cases by clamping invalid values.

However, `infallible()` only clamps the main `secrecy_threshold` and `reconstruct_threshold` to 1.0, but **fails to clamp the `fast_secrecy_threshold_in_stake_ratio` parameter**: [3](#0-2) 

The unclamped fast threshold is then passed to `compute_profile_fixed_point()`, which calculates `fast_reconstruct_threshold_in_stake_ratio = fast_secrecy + stake_gap`. This results in a DKGRoundingProfile with a fast reconstruction threshold > 1.0: [4](#0-3) 

**Attack Path:**
1. Attacker creates governance proposal with `randomness_config::new_v2(secrecy_threshold, reconstruct_threshold, fast_path_secrecy_threshold)` where fast_path_secrecy_threshold > 1.0
2. Proposal passes governance voting and is applied at epoch change
3. DKG initialization reads the invalid configuration
4. `DKGRounding::new()` validation fails, falls back to `infallible()`
5. `infallible()` fails to clamp fast_secrecy_threshold, producing profile with `fast_reconstruct_threshold_in_stake_ratio > 1.0`
6. Invalid profile is used in randomness system

## Impact Explanation

**Severity: HIGH** - This qualifies as a "Significant protocol violation" per the Aptos bug bounty criteria.

**Invariant Violation:** A reconstruction threshold > 1.0 means validators would need more than 100% of the total voting power to reconstruct randomness via the fast path, which is mathematically impossible. This violates the fundamental DKG security property that a qualified subset of validators should be able to reconstruct the shared secret.

**Fast Path Liveness Failure:** When the fast path reconstruction threshold exceeds 1.0, no validator subset (even 100% participation) can meet the threshold. This effectively disables the fast path randomness mechanism, degrading system performance and potentially causing timeouts or failures in randomness-dependent operations.

**Semantic Corruption:** The system operates with nonsensical security parameters, breaking monitoring, debugging, and any code that assumes thresholds are valid ratios in [0, 1].

**Potential Undefined Behavior:** Code downstream that assumes threshold ≤ 1.0 could exhibit undefined behavior, including arithmetic errors, incorrect calculations, or crashes.

## Likelihood Explanation

**Likelihood: MEDIUM-HIGH**

While this requires governance access (stake/voting power), the vulnerability is exploitable through any governance proposal that sets invalid thresholds. The likelihood increases because:

1. **No validation prevents it**: Neither the Move nor Rust layer properly validates all threshold parameters
2. **Silent failure mode**: The `infallible()` fallback creates a false sense of safety while actually allowing invalid configurations
3. **Configuration mistakes**: Even non-malicious governance proposals could accidentally set invalid values due to the lack of validation
4. **No warning/error**: The system accepts and processes the invalid configuration without raising alerts

The issue is particularly concerning because the validation code path (`DKGRounding::new()`) appears to catch invalid thresholds, but the fallback path (`infallible()`) has incomplete protection.

## Recommendation

**Fix 1 - Add Move-Layer Validation:**
Add explicit validation in `randomness_config::new_v2()` to ensure all thresholds are ≤ 1.0:

```move
public fun new_v2(
    secrecy_threshold: FixedPoint64,
    reconstruction_threshold: FixedPoint64,
    fast_path_secrecy_threshold: FixedPoint64,
): RandomnessConfig {
    let one = fixed_point64::create_from_u128(1);
    assert!(fixed_point64::less_or_equal(secrecy_threshold, one), EINVALID_THRESHOLD);
    assert!(fixed_point64::less_or_equal(reconstruction_threshold, one), EINVALID_THRESHOLD);
    assert!(fixed_point64::less_or_equal(fast_path_secrecy_threshold, one), EINVALID_THRESHOLD);
    // ... rest of function
}
```

**Fix 2 - Complete the Clamping in infallible():**
Update the `infallible()` method to clamp the fast threshold parameter: [3](#0-2) 

Add after line 262:
```rust
let fast_secrecy_threshold_in_stake_ratio = 
    fast_secrecy_threshold_in_stake_ratio.map(|t| min(one, t));
```

Then pass the clamped value to `compute_profile_fixed_point()`.

## Proof of Concept

**Malicious Governance Proposal Script:**

```move
script {
    use aptos_framework::aptos_governance;
    use aptos_framework::randomness_config;
    use aptos_std::fixed_point64;

    fun main(core_resources: &signer) {
        let framework_signer = aptos_governance::get_signer_testnet_only(
            core_resources, 
            @0x1
        );
        
        // Create invalid config with fast_path_secrecy_threshold = 1.5 (150%)
        let malicious_config = randomness_config::new_v2(
            fixed_point64::create_from_rational(50, 100),   // 0.5 - valid
            fixed_point64::create_from_rational(67, 100),   // 0.67 - valid
            fixed_point64::create_from_rational(150, 100)   // 1.5 - INVALID!
        );
        
        randomness_config::set_for_next_epoch(&framework_signer, malicious_config);
        aptos_governance::reconfigure(&framework_signer);
    }
}
```

**Expected Result:** 
- The proposal is accepted without validation errors
- At epoch change, the DKG system processes this configuration
- `DKGRounding::new()` fails validation, falls back to `infallible()`
- The resulting `DKGRoundingProfile` contains `fast_reconstruct_threshold_in_stake_ratio > 1.0`
- Fast path randomness reconstruction becomes impossible, violating the DKG invariant

**Verification:**
After the epoch change, query the DKG configuration and observe that the fast path reconstruction threshold exceeds 1.0, confirming the invariant violation.

### Citations

**File:** aptos-move/framework/aptos-stdlib/sources/fixed_point64.move (L119-141)
```text
    /// Create a fixed-point value from a rational number specified by its
    /// numerator and denominator. Calling this function should be preferred
    /// for using `Self::create_from_raw_value` which is also available.
    /// This will abort if the denominator is zero. It will also
    /// abort if the numerator is nonzero and the ratio is not in the range
    /// 2^-64 .. 2^64-1. When specifying decimal fractions, be careful about
    /// rounding errors: if you round to display N digits after the decimal
    /// point, you can use a denominator of 10^N to avoid numbers where the
    /// very small imprecision in the binary representation could change the
    /// rounding, e.g., 0.0125 will round down to 0.012 instead of up to 0.013.
    public fun create_from_rational(numerator: u128, denominator: u128): FixedPoint64 {
        // If the denominator is zero, this will abort.
        // Scale the numerator to have 64 fractional bits, so that the quotient will have 64
        // fractional bits.
        let scaled_numerator = (numerator as u256) << 64;
        assert!(denominator != 0, EDENOMINATOR);
        let quotient = scaled_numerator / (denominator as u256);
        assert!(quotient != 0 || numerator == 0, ERATIO_OUT_OF_RANGE);
        // Return the quotient as a fixed-point number. We first need to check whether the cast
        // can succeed.
        assert!(quotient <= MAX_U128, ERATIO_OUT_OF_RANGE);
        FixedPoint64 { value: (quotient as u128) }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/randomness_config.move (L103-115)
```text
    public fun new_v2(
        secrecy_threshold: FixedPoint64,
        reconstruction_threshold: FixedPoint64,
        fast_path_secrecy_threshold: FixedPoint64,
    ): RandomnessConfig {
        RandomnessConfig {
            variant: copyable_any::pack( ConfigV2 {
                secrecy_threshold,
                reconstruction_threshold,
                fast_path_secrecy_threshold,
            } )
        }
    }
```

**File:** types/src/dkg/real_dkg/rounding/mod.rs (L254-282)
```rust
    pub fn infallible(
        validator_stakes: &Vec<u64>,
        mut secrecy_threshold_in_stake_ratio: U64F64,
        mut reconstruct_threshold_in_stake_ratio: U64F64,
        fast_secrecy_threshold_in_stake_ratio: Option<U64F64>,
    ) -> Self {
        let one = U64F64::from_num(1);
        secrecy_threshold_in_stake_ratio = min(one, secrecy_threshold_in_stake_ratio);
        reconstruct_threshold_in_stake_ratio = min(one, reconstruct_threshold_in_stake_ratio);
        reconstruct_threshold_in_stake_ratio = max(
            secrecy_threshold_in_stake_ratio,
            reconstruct_threshold_in_stake_ratio,
        );

        let stake_total = U64F64::from_num(validator_stakes.clone().into_iter().sum::<u64>());

        let estimated_weight_total = total_weight_upper_bound(
            validator_stakes,
            reconstruct_threshold_in_stake_ratio,
            secrecy_threshold_in_stake_ratio,
        );
        let stake_per_weight = stake_total / U64F64::from_num(estimated_weight_total);
        compute_profile_fixed_point(
            validator_stakes,
            stake_per_weight,
            secrecy_threshold_in_stake_ratio,
            fast_secrecy_threshold_in_stake_ratio,
        )
    }
```

**File:** types/src/dkg/real_dkg/rounding/mod.rs (L335-351)
```rust
    let (fast_reconstruct_threshold_in_stake_ratio, fast_reconstruct_threshold_in_weights) =
        if let Some(fast_secrecy_threshold_in_stake_ratio) =
            maybe_fast_secrecy_threshold_in_stake_ratio
        {
            let recon_threshold = fast_secrecy_threshold_in_stake_ratio + stake_gap_fixed;
            let recon_weight = min(
                weight_total,
                ((fast_secrecy_threshold_in_stake_ratio * stake_sum_fixed / stake_per_weight
                    + delta_up_fixed)
                    .ceil()
                    + one)
                    .to_num::<u64>(),
            );
            (Some(recon_threshold), Some(recon_weight))
        } else {
            (None, None)
        };
```
