# Audit Report

## Title
Timeout Mechanism Protocol Violation Enables Diagnostic Evasion and Network Performance Degradation

## Summary
The `Vote::verify()` function contains an unimplemented TODO check that should enforce votes to have `two_chain_timeout = None` when the `RoundTimeoutMsg` protocol is enabled. This missing validation allows malicious validators to bypass the intended timeout signaling mechanism, dilute diagnostic information, and prevent the network from identifying and excluding problematic validators, leading to performance degradation and liveness issues.

## Finding Description

The vulnerability exists in the vote verification logic where a critical protocol invariant check is not implemented. [1](#0-0) 

The Aptos consensus protocol supports two mechanisms for signaling round timeouts:
1. **Legacy mechanism**: Votes with `two_chain_timeout` field set (used when `enable_round_timeout_msg = false`)
2. **Modern mechanism**: Separate `RoundTimeoutMsg` messages (used when `enable_round_timeout_msg = true`)

The default production configuration enables the modern mechanism. [2](#0-1) 

When `enable_round_timeout_msg` is enabled, honest validators send `RoundTimeoutMsg` for timeouts, which includes diagnostic information via `RoundTimeoutReason` enum that can identify why timeouts occur (e.g., `ProposalNotReceived`, `PayloadUnavailable`, `NoQC`). [3](#0-2) 

However, malicious validators can exploit the missing verification check to send votes with `two_chain_timeout` set instead. These votes are processed and their timeout signatures are aggregated into the timeout certificate. [4](#0-3) 

**Critical Impact**: Votes with `two_chain_timeout` always contribute an "Unknown" timeout reason, regardless of the actual cause. [5](#0-4) 

The system uses aggregated timeout reasons to identify problematic validators and exclude them from Optimistic Quorum Store (OptQS) pulls. [6](#0-5) 

During timeout reason aggregation, the system requires f+1 voting power for a reason to be accepted. [7](#0-6)  

If malicious validators with ≥ f+1 voting power send votes with `two_chain_timeout` (contributing "Unknown" reasons), they can:
1. Prevent `PayloadUnavailable` reasons from reaching the acceptance threshold
2. Block identification of validators with missing payloads
3. Prevent the system from excluding problematic validators from OptQS
4. Cause exponential growth of the failure window [8](#0-7) 

## Impact Explanation

This vulnerability qualifies as **High Severity** per the Aptos bug bounty program:

1. **Validator node slowdowns**: The attack causes repeated timeouts and prevents OptQS optimization, leading to measurable performance degradation across the network.

2. **Significant protocol violations**: Malicious validators bypass the intended `RoundTimeoutMsg` protocol when it's explicitly enabled, violating the protocol specification.

3. **Network-wide liveness degradation**: As the failure window grows exponentially, OptQS effectiveness decreases, eventually potentially disabling it entirely, significantly impacting network throughput and latency.

While this does not directly cause fund loss or consensus safety violations (which would be Critical severity), it creates a persistent attack vector for degrading network performance without detection.

## Likelihood Explanation

The likelihood is **Medium to High**:

**Attacker Requirements:**
- Control of validators with ≥ f+1 voting power (~34% of network)
- Ability to send crafted votes with `two_chain_timeout` field set
- Network must have `enable_round_timeout_msg = true` (the default production setting)

**Feasibility:**
- No validator insider access required beyond running malicious validator software
- Attack is undetectable since votes pass all verification checks
- Can be executed continuously to sustain performance degradation
- Becomes more effective during periods of legitimate network issues (providing cover)

**Barriers:**
- Requires significant stake/validator set participation
- Other validators may notice discrepancy between expected and actual timeout reasons through manual investigation

## Recommendation

Implement the TODO check with proper context. However, since `Vote::verify()` doesn't have access to the `enable_round_timeout_msg` configuration, the fix requires architectural changes:

**Option 1: Add configuration parameter to verify()**
```rust
pub fn verify(&self, validator: &ValidatorVerifier, expect_new_timeout_protocol: bool) -> anyhow::Result<()> {
    if expect_new_timeout_protocol {
        ensure!(
            self.two_chain_timeout.is_none(),
            "Vote should not contain two_chain_timeout when RoundTimeoutMsg protocol is enabled"
        );
    }
    
    ensure!(
        self.ledger_info.consensus_data_hash() == self.vote_data.hash(),
        "Vote's hash mismatch with LedgerInfo"
    );
    // ... rest of verification
}
```

**Option 2: Separate verification path based on protocol version**

Track protocol version in `VoteMsg` and enforce different validation rules based on the version, rejecting votes with `two_chain_timeout` when the modern protocol is active.

**Option 3: Network-wide migration completion**

After confirming all validators have upgraded to `enable_round_timeout_msg = true`, deploy a hard fork that unconditionally rejects votes with `two_chain_timeout` in all verification paths.

## Proof of Concept

```rust
// Proof of Concept: Malicious validator sending vote with two_chain_timeout
// when RoundTimeoutMsg is enabled

use aptos_consensus_types::{
    vote::Vote,
    vote_data::VoteData,
    timeout_2chain::TwoChainTimeout,
};
use aptos_types::{
    ledger_info::LedgerInfo,
    block_info::BlockInfo,
};
use aptos_crypto::hash::HashValue;

// Setup: Network has enable_round_timeout_msg = true
// Honest validators send RoundTimeoutMsg for timeouts

// Malicious validator creates a vote
let vote_data = VoteData::new(
    BlockInfo::new(1, 5, HashValue::random(), HashValue::random(), 0, 0, None),
    BlockInfo::new(1, 4, HashValue::random(), HashValue::random(), 0, 0, None),
);

let mut ledger_info = LedgerInfo::new(
    BlockInfo::new(1, 5, HashValue::random(), HashValue::random(), 0, 0, None),
    HashValue::random(),
);
ledger_info.set_consensus_data_hash(vote_data.hash());

// Create vote with signature
let mut malicious_vote = Vote::new(
    vote_data,
    malicious_validator.author(),
    ledger_info,
    &malicious_validator_signer,
).unwrap();

// Malicious action: Add two_chain_timeout when it shouldn't be present
let timeout = TwoChainTimeout::new(1, 5, highest_qc.clone());
let timeout_signature = safety_rules.sign_timeout_with_qc(&timeout, None).unwrap();
malicious_vote.add_2chain_timeout(timeout, timeout_signature);

// Verification passes - the TODO check is not implemented!
assert!(malicious_vote.verify(&validator_verifier).is_ok());

// When processed, this vote contributes "Unknown" timeout reason
// instead of the proper reason from RoundTimeoutMsg,
// preventing identification of problematic validators
```

**Notes**

This vulnerability stems from the incomplete migration from the legacy timeout mechanism to the modern `RoundTimeoutMsg` protocol. The TODO comment acknowledges this check should exist, but the verification function lacks the necessary context (configuration state) to enforce it. The attack exploits the gap between protocol intention (use `RoundTimeoutMsg` exclusively when enabled) and actual enforcement (accepts both mechanisms regardless of configuration), allowing sophisticated attackers to systematically degrade network diagnostic capabilities and performance.

### Citations

**File:** consensus/consensus-types/src/vote.rs (L151-153)
```rust
    pub fn verify(&self, validator: &ValidatorVerifier) -> anyhow::Result<()> {
        // TODO(ibalajiarun): Ensure timeout is None if RoundTimeoutMsg is enabled.

```

**File:** config/src/config/consensus_config.rs (L383-383)
```rust
            enable_round_timeout_msg: true,
```

**File:** consensus/src/round_manager.rs (L1005-1043)
```rust
        if self.local_config.enable_round_timeout_msg {
            let timeout = if let Some(timeout) = self.round_state.timeout_sent() {
                timeout
            } else {
                let timeout = TwoChainTimeout::new(
                    self.epoch_state.epoch,
                    round,
                    self.block_store.highest_quorum_cert().as_ref().clone(),
                );
                let signature = self
                    .safety_rules
                    .lock()
                    .sign_timeout_with_qc(
                        &timeout,
                        self.block_store.highest_2chain_timeout_cert().as_deref(),
                    )
                    .context("[RoundManager] SafetyRules signs 2-chain timeout")?;

                let timeout_reason = self.compute_timeout_reason(round);

                RoundTimeout::new(
                    timeout,
                    self.proposal_generator.author(),
                    timeout_reason,
                    signature,
                )
            };

            self.round_state.record_round_timeout(timeout.clone());
            let round_timeout_msg = RoundTimeoutMsg::new(timeout, self.block_store.sync_info());
            self.network
                .broadcast_round_timeout(round_timeout_msg)
                .await;
            warn!(
                round = round,
                remote_peer = self.proposer_election.get_valid_proposer(round),
                event = LogEvent::Timeout,
            );
            bail!("Round {} timeout, broadcast to all peers", round);
```

**File:** consensus/src/pending_votes.rs (L123-153)
```rust
        reason_voting_power
            .into_iter()
            .max_by_key(|(_, voting_power)| *voting_power)
            .filter(|(_, voting_power)| {
                verifier
                    .check_aggregated_voting_power(*voting_power, false)
                    .is_ok()
            })
            .map(|(reason, _)| {
                // If the aggregated reason is due to unavailable payload, we will compute the
                // aggregated missing authors bitvec counting batch authors that have been reported
                // missing by minority peers.
                if matches!(reason, RoundTimeoutReason::PayloadUnavailable { .. }) {
                    let mut aggregated_bitvec = BitVec::with_num_bits(verifier.len() as u16);
                    for (author_idx, voting_power) in missing_batch_authors {
                        if verifier
                            .check_aggregated_voting_power(voting_power, false)
                            .is_ok()
                        {
                            aggregated_bitvec.set(author_idx as u16);
                        }
                    }
                    RoundTimeoutReason::PayloadUnavailable {
                        missing_authors: aggregated_bitvec,
                    }
                } else {
                    reason
                }
            })
            .unwrap_or(RoundTimeoutReason::Unknown)
    }
```

**File:** consensus/src/pending_votes.rs (L422-441)
```rust
        if let Some((timeout, signature)) = vote.two_chain_timeout() {
            counters::CONSENSUS_CURRENT_ROUND_TIMEOUT_VOTED_POWER
                .with_label_values(&[&vote.author().to_string()])
                .set(validator_voting_power as f64);
            counters::CONSENSUS_LAST_TIMEOUT_VOTE_EPOCH
                .with_label_values(&[&vote.author().to_string()])
                .set(cur_epoch);
            counters::CONSENSUS_LAST_TIMEOUT_VOTE_ROUND
                .with_label_values(&[&vote.author().to_string()])
                .set(cur_round);

            let two_chain_votes = self
                .maybe_2chain_timeout_votes
                .get_or_insert_with(|| TwoChainTimeoutVotes::new(timeout.clone()));
            two_chain_votes.add(
                vote.author(),
                timeout.clone(),
                signature.clone(),
                RoundTimeoutReason::Unknown,
            );
```

**File:** consensus/src/liveness/proposal_status_tracker.rs (L65-78)
```rust
    fn compute_failure_window(&mut self) {
        self.last_consecutive_success_count = self.last_consecutive_statuses_matching(|reason| {
            !matches!(
                reason,
                NewRoundReason::Timeout(RoundTimeoutReason::PayloadUnavailable { .. })
            )
        });
        if self.last_consecutive_success_count == 0 {
            self.window *= 2;
            self.window = self.window.min(self.max_window);
        } else if self.last_consecutive_success_count == self.past_round_statuses.len() {
            self.window = 2;
        }
    }
```

**File:** consensus/src/liveness/proposal_status_tracker.rs (L80-98)
```rust
    fn get_exclude_authors(&self) -> HashSet<Author> {
        let mut exclude_authors = HashSet::new();

        let limit = self.window;
        for round_reason in self.past_round_statuses.iter().rev().take(limit) {
            if let NewRoundReason::Timeout(RoundTimeoutReason::PayloadUnavailable {
                missing_authors,
            }) = round_reason
            {
                for author_idx in missing_authors.iter_ones() {
                    if let Some(author) = self.ordered_authors.get(author_idx) {
                        exclude_authors.insert(*author);
                    }
                }
            }
        }

        exclude_authors
    }
```
