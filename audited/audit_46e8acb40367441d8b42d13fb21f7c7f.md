# Audit Report

## Title
Poisoned Mutex in State Snapshot Restore Causes Unrecoverable Failure Without Corruption Marking

## Summary
During state snapshot restore operations, if a panic occurs while processing a chunk (e.g., due to JellyfishMerkleRestore internal invariant violations), the `aptos-infallible::Mutex` protecting the restore receiver becomes poisoned. This prevents any retry or recovery attempts, as subsequent lock operations panic immediately, rendering the node unable to complete restoration without manual intervention.

## Finding Description

The vulnerability exists in the state snapshot restore flow, specifically in how mutex-protected state is handled during chunk processing: [1](#0-0) 

The `aptos-infallible::Mutex::lock()` function panics when encountering a poisoned lock, rather than returning a `Result` that could be handled. [2](#0-1) 

During state snapshot restoration, the receiver is wrapped in this infallible mutex. [3](#0-2) 

When `add_chunk()` is called through `tokio::spawn_blocking`, if a panic occurs during chunk processing, the mutex becomes poisoned. [4](#0-3) 

The `StateSnapshotRestore` contains two mutex-protected components that are accessed during `add_chunk()`. [5](#0-4) 

The `JellyfishMerkleRestore` can panic if internal invariants are violated during restore. [6](#0-5) 

Another panic point exists when rightmost child validation fails.

**Attack Scenario**:
1. A state snapshot backup is created but contains data that violates JellyfishMerkleRestore invariants (due to storage corruption, incomplete writes, or software bugs)
2. During restoration, a chunk is processed via `add_chunk()`
3. `JellyfishMerkleRestore` detects the invariant violation and panics while holding the mutex
4. The mutex becomes poisoned
5. The restore coordinator catches the error but any retry attempt to access the receiver panics on the poisoned mutex
6. The node cannot complete restoration without manual DB cleanup and restart

## Impact Explanation

This meets **Medium Severity** criteria ("State inconsistencies requiring intervention") because:

- **No funds loss**: This is a recovery mechanism failure, not a consensus or execution vulnerability
- **Requires intervention**: Operators must manually delete corrupted data or reset the DB to recover
- **Affects availability**: A node cannot restore from backups if corruption exists
- **Not easily exploitable**: Requires pre-existing backup corruption or internal bugs, not external attack

The issue breaks the **State Consistency** invariant expectation that backup/restore operations should be resilient to corruption and provide clear error reporting rather than entering unrecoverable states.

However, this does NOT meet Critical/High severity because:
- It doesn't affect consensus safety or liveness of the network
- It doesn't enable theft or creation of funds
- It only affects individual nodes attempting restoration
- The network continues operating normally

## Likelihood Explanation

**Likelihood: Low to Medium**

This can occur when:
- Storage hardware failures corrupt backup data partially
- Software bugs in backup code create invalid snapshots
- Incomplete backup writes due to crashes or network failures
- Concurrent modifications during backup (race conditions)

However, it requires specific conditions:
- Backup data must appear structurally valid enough to pass initial validation
- But must violate JellyfishMerkleRestore internal invariants
- The panic must occur during chunk processing, not during initialization

The coding standard explicitly treats poisoned locks as unrecoverable: [7](#0-6) 

This is a deliberate design choice documented in the codebase, suggesting the developers are aware of this behavior.

## Recommendation

**Option 1: Graceful Recovery from Poisoned Locks**

Replace `aptos-infallible::Mutex` with recoverable error handling in restoration paths:

```rust
// In restore.rs, use std::sync::Mutex and handle poison errors
let receiver = Arc::new(std::sync::Mutex::new(Some(...)));

// When locking:
match receiver.lock() {
    Ok(guard) => { /* process */ },
    Err(poisoned) => {
        warn!("Mutex poisoned during restore, attempting recovery");
        // Clear the poisoned state and extract the data
        let guard = poisoned.into_inner();
        // Mark restore as failed, cleanup state
        return Err(anyhow!("Restore failed due to panic, manual cleanup required"));
    }
}
```

**Option 2: Isolation via Process Boundaries**

Run restoration in a separate process that can crash without poisoning shared state:
- Use inter-process communication instead of shared mutexes
- Child process crashes are detected and handled by parent
- Parent can retry with a fresh process

**Option 3: Explicit Corruption Detection**

Add validation layer before `add_chunk()` to detect corrupted data early:
```rust
fn validate_chunk_integrity(chunk: &[StateKey, StateValue]) -> Result<()> {
    // Validate keys are in order
    // Validate hash consistency
    // Check for structural violations
}
```

## Proof of Concept

```rust
// Test demonstrating poisoned mutex during restore
#[tokio::test]
async fn test_poisoned_mutex_on_corrupt_restore() {
    use std::sync::Arc;
    use aptos_infallible::Mutex;
    
    // Simulate StateSnapshotRestore with mutex-protected state
    let receiver = Arc::new(Mutex::new(Some(MockReceiver::new())));
    
    // First operation succeeds
    {
        let mut guard = receiver.lock();
        guard.as_mut().unwrap().add_chunk(valid_chunk()).unwrap();
    }
    
    // Second operation causes panic while holding lock
    let receiver_clone = receiver.clone();
    let handle = tokio::spawn(async move {
        let mut guard = receiver_clone.lock();
        // Simulate panic from JellyfishMerkleRestore
        panic!("Internal invariant violated: Must have at least one child");
    });
    
    // Wait for panic
    let _ = handle.await;
    
    // Now the mutex is poisoned - any subsequent lock will panic
    // This demonstrates the unrecoverable state
    let result = std::panic::catch_unwind(|| {
        receiver.lock(); // This will panic with "Cannot currently handle a poisoned lock"
    });
    
    assert!(result.is_err(), "Expected panic on poisoned mutex");
}
```

---

**Notes**

The vulnerability is real but limited in scope. The backup operations themselves do not have this issue - backups fail cleanly with errors. The problem is specific to the restore path where the codebase's design philosophy of treating poisoned locks as fatal errors creates an unrecoverable state.

The fundamental tension is between the Rust best practice of propagating errors versus the Aptos design decision to panic on poisoned locks. For critical recovery operations like state restoration, the latter approach reduces reliability without providing compensating security benefits.

### Citations

**File:** crates/aptos-infallible/src/mutex.rs (L19-23)
```rust
    pub fn lock(&self) -> MutexGuard<'_, T> {
        self.0
            .lock()
            .expect("Cannot currently handle a poisoned lock")
    }
```

**File:** storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs (L141-145)
```rust
        let receiver = Arc::new(Mutex::new(Some(self.run_mode.get_state_restore_receiver(
            self.version,
            manifest.root_hash,
            self.restore_mode,
        )?)));
```

**File:** storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs (L212-215)
```rust
            tokio::task::spawn_blocking(move || {
                receiver.lock().as_mut().unwrap().add_chunk(blobs, proof)
            })
            .await??;
```

**File:** storage/aptosdb/src/state_restore/mod.rs (L146-149)
```rust
    tree_restore: Arc<Mutex<Option<JellyfishMerkleRestore<K>>>>,
    kv_restore: Arc<Mutex<Option<StateValueRestore<K, V>>>>,
    restore_mode: StateSnapshotRestoreMode,
}
```

**File:** storage/jellyfish-merkle/src/restore/mod.rs (L582-583)
```rust
            _ => panic!("Must have at least one child and must not have further internal nodes."),
        }
```

**File:** storage/jellyfish-merkle/src/restore/mod.rs (L616-618)
```rust
                    _ => panic!(
                        "Must have at least one child and the rightmost child must not be a leaf."
                    ),
```

**File:** RUST_CODING_STYLE.md (L177-178)
```markdown
- `duration_since_epoch()` - to obtain the Unix time, call the function provided by `aptos-infallible`.
- `RwLock` and `Mutex` - Instead of calling `unwrap()` on the standard library implementations of these functions, use the infallible equivalent types that we provide in `aptos-infallible`.
```
