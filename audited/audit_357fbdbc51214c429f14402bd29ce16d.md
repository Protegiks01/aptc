# Audit Report

## Title
KvOnly State Restoration Mode Prevents Merkle Proof Generation, Causing State Sync Failures

## Summary
When a node performs state restoration using `StateSnapshotRestoreMode::KvOnly`, only the key-value state data is written to the database while the Jellyfish Merkle Tree structure is intentionally skipped. If the subsequent tree restoration phase fails or is interrupted, the node retains state values but cannot generate Merkle proofs. This causes the node to fail when serving state synchronization requests from peers, returning `MissingRootError` and degrading network-wide state sync availability.

## Finding Description

The vulnerability occurs in the state restoration mechanism when using the two-phase restore process. [1](#0-0) 

In `KvOnly` mode, the restoration logic explicitly skips tree structure restoration: [2](#0-1) 

When peers later request state chunks with proofs via `get_state_value_chunk_with_proof`, the call chain proceeds through: [3](#0-2) 

Which calls `get_value_range_proof`: [4](#0-3) 

This delegates to the Jellyfish Merkle Tree's `get_range_proof`: [5](#0-4) 

Which requires reading tree nodes from the database: [6](#0-5) 

When the root node doesn't exist (because tree restoration was skipped), this returns `MissingRootError`: [7](#0-6) 

**Critical Issue**: The storage service's `get_data_summary` method advertises state availability without validating that the tree structure exists: [8](#0-7) 

The `fetch_state_values_range` method only checks pruning windows, not tree existence: [9](#0-8) 

This breaks the **State Consistency** invariant: "State transitions must be atomic and verifiable via Merkle proofs." The node has state values but cannot prove their integrity.

## Impact Explanation

This is a **HIGH severity** vulnerability per Aptos bug bounty criteria:

1. **Validator node slowdowns**: Nodes attempting to sync from affected peers experience repeated failures and must retry with different peers
2. **Significant protocol violations**: Nodes advertise state availability they cannot actually serve with proofs
3. **Network availability degradation**: If multiple nodes experience interrupted two-phase restores, the state sync network's capacity is reduced

The issue affects any node that:
- Completes Phase 1 (KvOnly restore) of the two-phase restore process
- Fails to complete Phase 2 (tree restoration) due to errors, interruptions, or operational issues
- Continues operating and responds to state sync requests [10](#0-9) 

## Likelihood Explanation

**Medium-to-High Likelihood**:

1. **Two-phase restore is documented and used**: The backup-cli explicitly uses KvOnly mode for Phase 1 restoration
2. **No validation prevents incomplete restores**: No check verifies tree existence before the node starts serving requests
3. **Operational scenarios enable this**: Network interruptions, OOM errors, or manual intervention during restore can leave nodes in this inconsistent state
4. **Silent failure mode**: The node appears functional (can read state values locally) but fails only when serving proofs to peers

The storage service handler will propagate the error to requesting peers: [11](#0-10) 

## Recommendation

**Immediate Fix**: Add validation before advertising state availability and serving proof requests:

```rust
// In storage/state-sync/storage-service/server/src/storage.rs
fn fetch_state_values_range(
    &self,
    latest_version: Version,
    transactions_range: &Option<CompleteDataRange<Version>>,
) -> aptos_storage_service_types::Result<Option<CompleteDataRange<Version>>, Error> {
    let pruner_enabled = self.storage.is_state_merkle_pruner_enabled()?;
    if !pruner_enabled {
        // NEW: Verify tree exists before advertising state availability
        if let Some(range) = transactions_range {
            // Check if root hash exists for latest version
            if self.storage.get_state_merkle_db().get_root_hash(range.highest()).is_err() {
                return Ok(None); // Don't advertise state if tree is missing
            }
        }
        return Ok(*transactions_range);
    }
    // ... rest of existing logic
}
```

**Additional Safeguards**:

1. Add completion marker in metadata DB tracking whether two-phase restore finished
2. Prevent node startup if KvOnly restore completed but tree restoration didn't
3. Add explicit documentation warning about KvOnly mode limitations
4. Implement health check endpoint that verifies tree structure availability [12](#0-11) 

## Proof of Concept

**Reproduction Steps**:

```rust
// Test case in storage/aptosdb/src/state_restore/restore_test.rs

#[test]
fn test_kv_only_restore_blocks_proof_generation() {
    let tmpdir = TempPath::new();
    let db = AptosDB::new_for_test(&tmpdir);
    
    // Step 1: Perform KvOnly restoration
    let version = 100;
    let expected_root_hash = HashValue::random();
    let mut receiver = StateSnapshotRestore::new(
        &db.state_merkle_db,
        &db.state_store.state_kv_db,
        version,
        expected_root_hash,
        false, /* async_commit */
        StateSnapshotRestoreMode::KvOnly, // ← Only restore KV
    ).unwrap();
    
    // Add state chunks
    let chunk = vec![(StateKey::random(), StateValue::random())];
    let proof = SparseMerkleRangeProof::new(vec![]);
    receiver.add_chunk(chunk.clone(), proof).unwrap();
    receiver.finish().unwrap();
    
    // Step 2: Verify KV data exists
    let (key, value) = &chunk[0];
    let retrieved = db.state_store.get_state_value_by_version(key, version).unwrap();
    assert_eq!(retrieved, Some(value.clone()));
    
    // Step 3: Attempt to generate proof (THIS FAILS)
    let key_hash = key.hash();
    let result = db.state_store.state_merkle_db.get_with_proof_ext(
        &key_hash, 
        version, 
        0 /* root_depth */
    );
    
    // Assertion: Proof generation fails with MissingRootError
    match result {
        Err(AptosDbError::MissingRootError(v)) => {
            assert_eq!(v, version);
            println!("✓ Confirmed: Cannot generate proofs after KvOnly restore");
        }
        _ => panic!("Expected MissingRootError but got: {:?}", result),
    }
    
    // Step 4: Verify state sync would fail
    let result = db.get_state_value_chunk_with_proof(version, 0, 10);
    assert!(result.is_err(), "State chunk with proof should fail");
}
```

**Expected Result**: The test confirms that after KvOnly restoration, the node can read state values but cannot generate Merkle proofs, causing `MissingRootError(version)` when `get_state_value_chunk_with_proof` is called.

---

**Notes**

This vulnerability demonstrates a subtle interaction between the restore mechanism and the state sync protocol. While KvOnly mode is designed for specific use cases (two-phase restore), the lack of safeguards allows nodes to enter an inconsistent state where they advertise state availability but cannot serve cryptographic proofs. This violates the fundamental assumption that any advertised state is verifiable via Merkle proofs.

### Citations

**File:** storage/aptosdb/src/state_restore/mod.rs (L49-57)
```rust
#[derive(Clone, Copy, Deserialize, Serialize, PartialEq, Eq)]
pub enum StateSnapshotRestoreMode {
    /// Restore both KV and Tree by default
    Default,
    /// Only restore the state KV
    KvOnly,
    /// Only restore the state tree
    TreeOnly,
}
```

**File:** storage/aptosdb/src/state_restore/mod.rs (L228-258)
```rust
    fn add_chunk(&mut self, chunk: Vec<(K, V)>, proof: SparseMerkleRangeProof) -> Result<()> {
        let kv_fn = || {
            let _timer = OTHER_TIMERS_SECONDS.timer_with(&["state_value_add_chunk"]);
            self.kv_restore
                .lock()
                .as_mut()
                .unwrap()
                .add_chunk(chunk.clone())
        };

        let tree_fn = || {
            let _timer = OTHER_TIMERS_SECONDS.timer_with(&["jmt_add_chunk"]);
            self.tree_restore
                .lock()
                .as_mut()
                .unwrap()
                .add_chunk_impl(chunk.iter().map(|(k, v)| (k, v.hash())).collect(), proof)
        };
        match self.restore_mode {
            StateSnapshotRestoreMode::KvOnly => kv_fn()?,
            StateSnapshotRestoreMode::TreeOnly => tree_fn()?,
            StateSnapshotRestoreMode::Default => {
                // We run kv_fn with TreeOnly to restore the usage of DB
                let (r1, r2) = IO_POOL.join(kv_fn, tree_fn);
                r1?;
                r2?;
            },
        }

        Ok(())
    }
```

**File:** storage/aptosdb/src/state_restore/mod.rs (L261-273)
```rust
        match self.restore_mode {
            StateSnapshotRestoreMode::KvOnly => self.kv_restore.lock().take().unwrap().finish()?,
            StateSnapshotRestoreMode::TreeOnly => {
                self.tree_restore.lock().take().unwrap().finish_impl()?
            },
            StateSnapshotRestoreMode::Default => {
                // for tree only mode, we also need to write the usage to DB
                self.kv_restore.lock().take().unwrap().finish()?;
                self.tree_restore.lock().take().unwrap().finish_impl()?
            },
        }
        Ok(())
    }
```

**File:** storage/aptosdb/src/state_store/mod.rs (L749-755)
```rust
    pub fn get_value_range_proof(
        &self,
        rightmost_key: HashValue,
        version: Version,
    ) -> Result<SparseMerkleRangeProof> {
        self.state_merkle_db.get_range_proof(rightmost_key, version)
    }
```

**File:** storage/aptosdb/src/state_store/mod.rs (L1117-1143)
```rust
    pub fn get_value_chunk_proof(
        self: &Arc<Self>,
        version: Version,
        first_index: usize,
        state_key_values: Vec<(StateKey, StateValue)>,
    ) -> Result<StateValueChunkWithProof> {
        ensure!(
            !state_key_values.is_empty(),
            "State chunk starting at {}",
            first_index,
        );
        let last_index = (state_key_values.len() - 1 + first_index) as u64;
        let first_key = state_key_values.first().expect("checked to exist").0.hash();
        let last_key = state_key_values.last().expect("checked to exist").0.hash();
        let proof = self.get_value_range_proof(last_key, version)?;
        let root_hash = self.get_root_hash(version)?;

        Ok(StateValueChunkWithProof {
            first_index: first_index as u64,
            last_index,
            first_key,
            last_key,
            raw_values: state_key_values,
            proof,
            root_hash,
        })
    }
```

**File:** storage/aptosdb/src/state_merkle_db.rs (L290-296)
```rust
    pub fn get_range_proof(
        &self,
        rightmost_key: HashValue,
        version: Version,
    ) -> Result<SparseMerkleRangeProof> {
        JellyfishMerkleTree::new(self).get_range_proof(rightmost_key, version)
    }
```

**File:** storage/jellyfish-merkle/src/lib.rs (L730-741)
```rust
        // in the tree structure.
        for nibble_depth in 0..=ROOT_NIBBLE_HEIGHT {
            let next_node = self
                .reader
                .get_node_with_tag(&next_node_key, "get_proof")
                .map_err(|err| {
                    if nibble_depth == 0 {
                        AptosDbError::MissingRootError(version)
                    } else {
                        err
                    }
                })?;
```

**File:** storage/storage-interface/src/errors.rs (L18-19)
```rust
    #[error("Missing state root node at version {0}, probably pruned.")]
    MissingRootError(u64),
```

**File:** state-sync/storage-service/server/src/storage.rs (L146-176)
```rust
    fn fetch_state_values_range(
        &self,
        latest_version: Version,
        transactions_range: &Option<CompleteDataRange<Version>>,
    ) -> aptos_storage_service_types::Result<Option<CompleteDataRange<Version>>, Error> {
        let pruner_enabled = self.storage.is_state_merkle_pruner_enabled()?;
        if !pruner_enabled {
            return Ok(*transactions_range);
        }
        let pruning_window = self.storage.get_epoch_snapshot_prune_window()?;

        if latest_version > pruning_window as Version {
            // lowest_state_version = latest_version - pruning_window + 1;
            let mut lowest_state_version = latest_version
                .checked_sub(pruning_window as Version)
                .ok_or_else(|| {
                    Error::UnexpectedErrorEncountered("Lowest state version has overflown!".into())
                })?;
            lowest_state_version = lowest_state_version.checked_add(1).ok_or_else(|| {
                Error::UnexpectedErrorEncountered("Lowest state version has overflown!".into())
            })?;

            // Create the state range
            let state_range = CompleteDataRange::new(lowest_state_version, latest_version)
                .map_err(|error| Error::UnexpectedErrorEncountered(error.to_string()))?;
            return Ok(Some(state_range));
        }

        // No pruning has occurred. Return the transactions range.
        Ok(*transactions_range)
    }
```

**File:** state-sync/storage-service/server/src/storage.rs (L1036-1073)
```rust
    fn get_data_summary(&self) -> aptos_storage_service_types::Result<DataSummary, Error> {
        // Fetch the latest ledger info
        let latest_ledger_info_with_sigs = self.storage.get_latest_ledger_info()?;

        // Fetch the epoch ending ledger info range
        let latest_ledger_info = latest_ledger_info_with_sigs.ledger_info();
        let epoch_ending_ledger_infos = if latest_ledger_info.ends_epoch() {
            let highest_ending_epoch = latest_ledger_info.epoch();
            Some(CompleteDataRange::from_genesis(highest_ending_epoch))
        } else if latest_ledger_info.epoch() > 0 {
            let highest_ending_epoch =
                latest_ledger_info.epoch().checked_sub(1).ok_or_else(|| {
                    Error::UnexpectedErrorEncountered("Highest ending epoch overflowed!".into())
                })?;
            Some(CompleteDataRange::from_genesis(highest_ending_epoch))
        } else {
            None // We haven't seen an epoch change yet
        };

        // Fetch the transaction and transaction output ranges
        let latest_version = latest_ledger_info.version();
        let transactions = self.fetch_transaction_range(latest_version)?;
        let transaction_outputs = self.fetch_transaction_output_range(latest_version)?;

        // Fetch the state values range
        let states = self.fetch_state_values_range(latest_version, &transactions)?;

        // Return the relevant data summary
        let data_summary = DataSummary {
            synced_ledger_info: Some(latest_ledger_info_with_sigs),
            epoch_ending_ledger_infos,
            transactions,
            transaction_outputs,
            states,
        };

        Ok(data_summary)
    }
```

**File:** storage/backup/backup-cli/src/coordinators/restore.rs (L242-260)
```rust
            // phase 1.a: restore the kv snapshot
            if kv_snapshot.is_some() {
                let kv_snapshot = kv_snapshot.clone().unwrap();
                info!("Start restoring KV snapshot at {}", kv_snapshot.version);

                StateSnapshotRestoreController::new(
                    StateSnapshotRestoreOpt {
                        manifest_handle: kv_snapshot.manifest,
                        version: kv_snapshot.version,
                        validate_modules: false,
                        restore_mode: StateSnapshotRestoreMode::KvOnly,
                    },
                    self.global_opt.clone(),
                    Arc::clone(&self.storage),
                    epoch_history.clone(),
                )
                .run()
                .await?;
            }
```

**File:** state-sync/storage-service/server/src/handler.rs (L463-476)
```rust
    fn get_state_value_chunk_with_proof(
        &self,
        request: &StateValuesWithProofRequest,
    ) -> aptos_storage_service_types::Result<DataResponse, Error> {
        let state_value_chunk_with_proof = self.storage.get_state_value_chunk_with_proof(
            request.version,
            request.start_index,
            request.end_index,
        )?;

        Ok(DataResponse::StateValueChunkWithProof(
            state_value_chunk_with_proof,
        ))
    }
```
