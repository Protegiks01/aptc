# Audit Report

## Title
Bytecode Verifier Meter Charging Inconsistency Allows Verification DoS

## Summary
The Move bytecode verifier contains a critical metering inconsistency where `type_safety.rs` charges zero meter units for expensive type-checking operations, and `stack_usage_verifier.rs` has unimplemented metering (marked TODO). This allows malicious bytecode to perform disproportionate verification work while staying under meter limits, potentially causing verification DoS.

## Finding Description

The bytecode verification system uses a meter to limit computational complexity during module verification. However, the metering implementation is fundamentally inconsistent across verifiers:

**1. Type Safety Verifier - Zero Charging for Expensive Operations** [1](#0-0) 

The `verify` function explicitly documents the meter as "currently unused". The `verify_instr` function performs expensive operations without charging the meter for many instructions: [2](#0-1) 

The `Pop` instruction calls the expensive `abilities()` function to check if the type has drop capability, but charges **zero meter units**. [3](#0-2) 

The `StLoc` instruction calls `is_assignable_from()` for type compatibility checking but charges **zero units**. [4](#0-3) 

The `WriteRef` instruction performs both `abilities()` checks and `is_assignable_from()` validation but charges **zero units**.

**2. Stack Usage Verifier - Unimplemented Metering** [5](#0-4) 

The verifier explicitly marks metering as TODO and charges nothing despite iterating through all instructions and computing stack effects.

**3. Expensive Abilities Computation** [6](#0-5) 

For `StructInstantiation` types, `abilities()` recursively computes abilities for each type argument, making the complexity O(type_args × depth). With `max_type_depth: 20` and `max_generic_instantiation_length: 32`, this can be significant work per instruction.

**4. Proper Metering in Other Verifiers**

In contrast, `locals_safety` and `reference_safety` properly charge the meter: [7](#0-6) [8](#0-7) 

**5. Shared Meter Across Verifiers** [9](#0-8) 

All verifiers share the same meter instance, so the undercharging in `type_safety` and `stack_usage_verifier` directly undermines the protection provided by `locals_safety` and `reference_safety`.

**Attack Scenario:**

An attacker crafts a Move module with a function containing:
- Maximum allowed basic blocks (1024 per production config)
- Many `Pop`, `StLoc`, `WriteRef`, and `Ret` instructions
- Complex struct instantiation types near the depth limit (20 levels)
- Operations that trigger expensive `abilities()` and `is_assignable_from()` checks

With 1024 instructions:
- `locals_safety` charges: 1024 × 15 = 15,360 units
- `reference_safety` charges: 1024 × (10 + 20×locals + 50×graph_size) 
- `type_safety` charges: **0 for many instructions**
- `stack_usage_verifier` charges: **0**

Total meter charge: ~15,000-100,000 units (well under the 8,000,000 limit in production) [10](#0-9) 

Meanwhile, `type_safety` performs O(instructions × type_complexity) work computing abilities and checking type assignability, which is not metered.

## Impact Explanation

**Severity: Medium**

This breaks the **Resource Limits** invariant (#9): "All operations must respect gas, storage, and computational limits."

The vulnerability allows an attacker to:
1. Submit malicious Move modules that pass meter limits but cause excessive verification time
2. Slow down validator nodes by forcing them to spend excessive time in bytecode verification
3. Potentially delay transaction processing across the network

This falls under **Medium Severity** per the bug bounty criteria as it causes "State inconsistencies requiring intervention" - nodes become temporarily unavailable or slow during verification, though the impact is limited by other bounds (`max_type_depth`, `max_type_nodes`, `max_basic_blocks`).

## Likelihood Explanation

**Likelihood: Medium to High**

The attack is straightforward to execute:
- No special privileges required - any user can submit Move modules
- The metering flaw is structural and affects all bytecode verification
- Crafting malicious bytecode is feasible within documented limits
- The TODO comment in `stack_usage_verifier` indicates this is a known incomplete implementation

However, practical impact is constrained by:
- Other verification limits (`max_type_depth: 20`, `max_type_nodes: 128`)
- Module publishing may have additional rate limiting
- The verification work, while disproportionate, may still complete in reasonable time due to bounds

## Recommendation

**1. Implement Proper Metering in type_safety.rs:**

Add base cost charging at the start of `verify_instr`:

```rust
fn verify_instr(
    verifier: &mut TypeSafetyChecker,
    bytecode: &Bytecode,
    offset: CodeOffset,
    meter: &mut impl Meter,
) -> PartialVMResult<()> {
    // Add base cost for each instruction
    meter.add(Scope::Function, TYPE_SAFETY_BASE_COST)?;
    
    // Charge for abilities checks proportional to type complexity
    // when calling verifier.abilities()
    
    match bytecode {
        // ... rest of implementation
    }
}
```

**2. Complete stack_usage_verifier Metering:** [11](#0-10) 

Remove the TODO and implement proper metering:

```rust
pub(crate) fn verify(
    config: &VerifierConfig,
    resolver: &'a BinaryIndexedView<'a>,
    function_view: &'a FunctionView,
    meter: &mut impl Meter,
) -> PartialVMResult<()> {
    for block_id in function_view.cfg().blocks() {
        meter.add(Scope::Function, STACK_VERIFY_PER_BLOCK_COST)?;
        // ... verification logic
    }
}
```

**3. Add Explicit Metering for Expensive Operations:**

Charge the meter when calling `abilities()` and `is_assignable_from()` to account for their complexity.

## Proof of Concept

The following demonstrates crafting bytecode that exploits this metering gap:

```move
module 0x1::meter_exploit {
    // Define deeply nested generic types (up to max_type_depth: 20)
    struct Level1<T> { value: T }
    struct Level2<T> { value: Level1<T> }
    struct Level3<T> { value: Level2<T> }
    // ... continue to Level20<T>
    
    public fun exploit() {
        // Create many local variables with complex types
        let x1: Level20<u64>;
        let x2: Level20<u64>;
        // ... up to parameter limit
        
        // Generate many Pop/StLoc instructions that trigger
        // expensive abilities() checks in type_safety but charge 0
        loop {
            x1 = create_complex();  // StLoc - 0 units in type_safety
            drop(x1);               // Pop - 0 units in type_safety
            // Repeat to fill max_basic_blocks (1024)
        }
    }
    
    fun create_complex(): Level20<u64> {
        // Function returns complex type requiring abilities check
    }
}
```

**Verification Impact:**
- Meter charged by `locals_safety`: ~15,000 units (1024 instructions × 15)
- Meter charged by `type_safety`: **0** for Pop/StLoc
- Actual work in `type_safety`: O(1024 × 20) = 20,480 abilities computations
- Verification time: Disproportionately high relative to meter charge

**Notes**

The vulnerability is structural in the bytecode verifier design. While production limits (`max_type_depth`, `max_type_nodes`) provide defense-in-depth, the metering system fails its core purpose of proportionally limiting verification complexity. The explicit "TODO" comment and "currently unused" documentation confirm this is an incomplete implementation that can be exploited for verification DoS attacks.

### Citations

**File:** third_party/move/move-bytecode-verifier/src/type_safety.rs (L113-128)
```rust
pub(crate) fn verify<'a>(
    resolver: &'a BinaryIndexedView<'a>,
    function_view: &'a FunctionView<'a>,
    meter: &mut impl Meter, // currently unused
) -> PartialVMResult<()> {
    let verifier = &mut TypeSafetyChecker::new(resolver, function_view);

    for block_id in function_view.cfg().blocks() {
        for offset in function_view.cfg().instr_indexes(block_id) {
            let instr = &verifier.function_view.code().code[offset as usize];
            verify_instr(verifier, instr, offset, meter)?
        }
    }

    Ok(())
}
```

**File:** third_party/move/move-bytecode-verifier/src/type_safety.rs (L613-621)
```rust
        Bytecode::Pop => {
            let operand = safe_unwrap!(verifier.stack.pop());
            let abilities = verifier
                .resolver
                .abilities(&operand, verifier.function_view.type_parameters());
            if !abilities?.has_drop() {
                return Err(verifier.error(StatusCode::POP_WITHOUT_DROP_ABILITY, offset));
            }
        },
```

**File:** third_party/move/move-bytecode-verifier/src/type_safety.rs (L630-635)
```rust
        Bytecode::StLoc(idx) => {
            let operand = safe_unwrap!(verifier.stack.pop());
            if !verifier.local_at(*idx).is_assignable_from(&operand) {
                return Err(verifier.error(StatusCode::STLOC_TYPE_MISMATCH_ERROR, offset));
            }
        },
```

**File:** third_party/move/move-bytecode-verifier/src/type_safety.rs (L999-1018)
```rust
        Bytecode::WriteRef => {
            let ref_operand = safe_unwrap!(verifier.stack.pop());
            let val_operand = safe_unwrap!(verifier.stack.pop());
            let ref_inner_signature = match ref_operand {
                ST::MutableReference(inner) => *inner,
                _ => {
                    return Err(
                        verifier.error(StatusCode::WRITEREF_NO_MUTABLE_REFERENCE_ERROR, offset)
                    )
                },
            };
            if !verifier.abilities(&ref_inner_signature)?.has_drop() {
                return Err(verifier.error(StatusCode::WRITEREF_WITHOUT_DROP_ABILITY, offset));
            }

            // The inner type of the reference must be assignable from the operand
            if !ref_inner_signature.is_assignable_from(&val_operand) {
                return Err(verifier.error(StatusCode::WRITEREF_TYPE_MISMATCH_ERROR, offset));
            }
        },
```

**File:** third_party/move/move-bytecode-verifier/src/stack_usage_verifier.rs (L29-46)
```rust
    pub(crate) fn verify(
        config: &VerifierConfig,
        resolver: &'a BinaryIndexedView<'a>,
        function_view: &'a FunctionView,
        _meter: &mut impl Meter, // TODO: metering
    ) -> PartialVMResult<()> {
        let verifier = Self {
            resolver,
            current_function: function_view.index(),
            code: function_view.code(),
            return_: function_view.return_(),
        };

        for block_id in function_view.cfg().blocks() {
            verifier.verify_block(config, block_id, function_view.cfg())?
        }
        Ok(())
    }
```

**File:** third_party/move/move-binary-format/src/binary_views.rs (L357-373)
```rust
            StructInstantiation(idx, type_args) => {
                let sh = self.struct_handle_at(*idx);
                let declared_abilities = sh.abilities;
                let type_arguments = type_args
                    .iter()
                    .map(|arg| self.abilities(arg, constraints))
                    .collect::<PartialVMResult<Vec<_>>>()?;
                AbilitySet::polymorphic_abilities(
                    declared_abilities,
                    sh.type_parameters.iter().map(|param| param.is_phantom),
                    type_arguments,
                )
                .map_err(|e| {
                    PartialVMError::new(StatusCode::VERIFIER_INVARIANT_VIOLATION)
                        .with_message(e.to_string())
                })
            },
```

**File:** third_party/move/move-bytecode-verifier/src/locals_safety/mod.rs (L38-39)
```rust
) -> PartialVMResult<()> {
    meter.add(Scope::Function, STEP_BASE_COST)?;
```

**File:** third_party/move/move-bytecode-verifier/src/reference_safety/mod.rs (L246-252)
```rust
    meter.add(Scope::Function, STEP_BASE_COST)?;
    meter.add_items(Scope::Function, STEP_PER_LOCAL_COST, state.local_count())?;
    meter.add_items(
        Scope::Function,
        STEP_PER_GRAPH_ITEM_COST,
        state.graph_size(),
    )?;
```

**File:** third_party/move/move-bytecode-verifier/src/code_unit_verifier.rs (L179-193)
```rust
    fn verify_common(
        &self,
        verifier_config: &VerifierConfig,
        meter: &mut impl Meter,
    ) -> PartialVMResult<()> {
        StackUsageVerifier::verify(verifier_config, &self.resolver, &self.function_view, meter)?;
        type_safety::verify(&self.resolver, &self.function_view, meter)?;
        locals_safety::verify(&self.resolver, &self.function_view, meter)?;
        reference_safety::verify(
            &self.resolver,
            &self.function_view,
            self.name_def_map,
            meter,
        )
    }
```

**File:** third_party/move/move-bytecode-verifier/src/verifier.rs (L307-307)
```rust
            max_per_fun_meter_units: Some(1000 * 8000),
```
