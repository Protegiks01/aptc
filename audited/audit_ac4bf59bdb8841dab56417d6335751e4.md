# Audit Report

## Title
Gas Schedule Governance Manipulation Enables Computational DoS via Underpriced Function Reflection

## Summary
The `REFLECT_RESOLVE_BASE` gas parameter can be arbitrarily manipulated through governance proposals with no validation or bounds checking, enabling cheap computational attacks. Setting this parameter below its intended value (4096 internal gas units) allows attackers to perform expensive type-checking operations at drastically reduced gas cost, potentially causing validator node slowdowns.

## Finding Description

The reflection feature introduced in RELEASE_V1_39 allows Move code to dynamically resolve functions by address, module name, and function name. The native implementation charges a base cost `REFLECT_RESOLVE_BASE` before performing type checking and inference work. [1](#0-0) [2](#0-1) 

The gas parameter is defined with a value of 4096 internal gas units: [3](#0-2) 

However, governance can update gas schedules through `set_for_next_epoch()` with NO validation on parameter values: [4](#0-3) 

The code explicitly acknowledges missing validation with TODO comments: [5](#0-4) 

**Attack Vector:**

1. Malicious or compromised governance passes a proposal setting `REFLECT_RESOLVE_BASE` to 1 (or any value much lower than 4096)
2. After epoch change, the new gas schedule becomes active
3. Attackers craft transactions that repeatedly call `std::reflect::resolve()` to resolve multiple functions from the same module
4. Module loading gas is charged only once per module per traversal context, but each subsequent resolve pays only the base cost
5. Each resolve performs expensive type checking and type inference operations: [6](#0-5) 

The type matching involves recursive traversal of complex type structures: [7](#0-6) 

With `REFLECT_RESOLVE_BASE = 1` instead of 4096, attackers achieve a **4096x discount** on computational work. Given the maximum transaction gas of 2,000,000 units: [8](#0-7) 

An attacker could perform ~2,000,000 resolve operations (after first module load) instead of ~488, causing significant CPU consumption on validator nodes.

## Impact Explanation

This qualifies as **High Severity** per Aptos bug bounty criteria: "Validator node slowdowns". 

While not causing permanent damage, this enables resource exhaustion attacks that could:
- Slow down block execution across all validators
- Increase transaction latency network-wide
- Potentially cause temporary liveness issues under sustained attack
- Violate the documented invariant: "Resource Limits: All operations must respect gas, storage, and computational limits"

The impact is NOT Critical because it requires governance compromise and doesn't cause permanent state corruption or fund loss.

## Likelihood Explanation

**Likelihood: Medium-Low**

Prerequisites:
1. Governance proposal must pass setting malicious gas values (requires governance compromise or critical error)
2. Attacker must wait for epoch change
3. Attacker must submit transactions exploiting the underpriced operation

While governance compromise is unlikely under normal circumstances, the complete absence of validation creates risk from:
- Malicious governance participants
- Bugs in gas parameter generation scripts
- Unintentional errors in governance proposals

The question explicitly asks whether governance manipulation could enable cheap attacks, indicating this threat model is within scope.

## Recommendation

Implement validation in `set_for_next_epoch()` and `set_for_next_epoch_check_hash()` to enforce minimum gas parameter values:

```move
public fun set_for_next_epoch(aptos_framework: &signer, gas_schedule_blob: vector<u8>) acquires GasScheduleV2 {
    system_addresses::assert_aptos_framework(aptos_framework);
    assert!(!vector::is_empty(&gas_schedule_blob), error::invalid_argument(EINVALID_GAS_SCHEDULE));
    let new_gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
    if (exists<GasScheduleV2>(@aptos_framework)) {
        let cur_gas_schedule = borrow_global<GasScheduleV2>(@aptos_framework);
        assert!(
            new_gas_schedule.feature_version >= cur_gas_schedule.feature_version,
            error::invalid_argument(EINVALID_GAS_FEATURE_VERSION)
        );
    };
    
    // ADD VALIDATION HERE
    validate_gas_schedule_bounds(&new_gas_schedule);
    
    config_buffer::upsert(new_gas_schedule);
}

// Implement bounds checking for critical gas parameters
fun validate_gas_schedule_bounds(schedule: &GasScheduleV2) {
    // Define minimum values for critical parameters
    // reflect_resolve_base should be >= 1024 (example threshold)
    // Validate each critical parameter has reasonable bounds
    // abort with EINVALID_GAS_SCHEDULE if any parameter is out of bounds
}
```

Additionally, consider implementing:
1. Separate gas metering for type checking operations within `verify_function()`
2. Rate limiting or additional checks on reflection API usage
3. Governance proposal review process that validates gas parameter changes

## Proof of Concept

```move
// PoC demonstrating cheap attack after governance sets REFLECT_RESOLVE_BASE=1
module 0x1::reflection_dos_poc {
    use std::reflect;
    use std::string::utf8;
    use std::vector;
    
    // Target module with multiple public functions to resolve
    public fun dummy_func_1() {}
    public fun dummy_func_2() {}
    public fun dummy_func_3() {}
    // ... add more functions
    
    public fun exploit() {
        // After governance sets REFLECT_RESOLVE_BASE to 1,
        // this loop performs 1000 expensive type-checking operations
        // for only ~1000 gas units (plus one module load)
        let i = 0;
        while (i < 1000) {
            // First iteration pays module load + 1 gas
            // Subsequent iterations pay only 1 gas each
            let _fn1 = reflect::resolve<||>(@0x1, &utf8(b"reflection_dos_poc"), &utf8(b"dummy_func_1"));
            let _fn2 = reflect::resolve<||>(@0x1, &utf8(b"reflection_dos_poc"), &utf8(b"dummy_func_2"));
            let _fn3 = reflect::resolve<||>(@0x1, &utf8(b"reflection_dos_poc"), &utf8(b"dummy_func_3"));
            i = i + 1;
        };
        // With REFLECT_RESOLVE_BASE=4096, this would cost ~12M gas (exceeds max)
        // With REFLECT_RESOLVE_BASE=1, this costs only ~3000 gas (easily fits)
        // Each resolve does expensive recursive type matching
    }
}
```

**Notes**

The vulnerability exists because gas schedule updates have no validation despite TODO comments acknowledging this gap. The question explicitly explores governance manipulation scenarios, making this threat model in scope. While requiring governance compromise, the complete absence of bounds checking represents a significant security risk that could enable resource exhaustion attacks affecting network-wide validator performance. This is compounded by the fact that expensive type-checking computation is not separately metered from the base cost.

### Citations

**File:** aptos-move/framework/move-stdlib/src/natives/reflect.rs (L7-7)
```rust
use aptos_gas_schedule::gas_params::natives::aptos_framework::REFLECT_RESOLVE_BASE;
```

**File:** aptos-move/framework/move-stdlib/src/natives/reflect.rs (L26-67)
```rust
fn native_resolve(
    context: &mut SafeNativeContext,
    ty_args: &[Type],
    mut args: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    // Charge base cost before anything else.
    context.charge(REFLECT_RESOLVE_BASE)?;

    // Process arguments
    debug_assert!(ty_args.len() == 1);
    let Some(fun_ty) = ty_args.first() else {
        return Err(SafeNativeError::InvariantViolation(
            PartialVMError::new_invariant_violation("wrong number of type arguments"),
        ));
    };

    debug_assert!(args.len() == 3);
    let Some(fun_name) = identifier_from_string(safely_pop_arg!(args))? else {
        return Ok(smallvec![result::err_result(pack_err(INVALID_IDENTIFIER))]);
    };
    let Some(mod_name) = identifier_from_string(safely_pop_arg!(args))? else {
        return Ok(smallvec![result::err_result(pack_err(INVALID_IDENTIFIER))]);
    };
    let addr = safely_pop_arg!(args, AccountAddress);
    let mod_id = ModuleId::new(addr, mod_name);

    // Resolve function and return closure. Notice the loader context function
    // takes care of gas metering and type checking.
    match context
        .loader_context()
        .resolve_function(&mod_id, &fun_name, fun_ty)?
    {
        Ok(fun) => {
            // Return as a closure with no captured arguments
            Ok(smallvec![result::ok_result(Value::closure(
                fun,
                iter::empty()
            ))])
        },
        Err(e) => Ok(smallvec![result::err_result(pack_err(e as u16))]),
    }
}
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/aptos_framework.rs (L363-363)
```rust
        [reflect_resolve_base: InternalGas, { RELEASE_V1_39.. => "reflect.resolve_base" }, 4096],
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L47-47)
```text
        // TODO(Gas): check if gas schedule is consistent
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L91-103)
```text
    public fun set_for_next_epoch(aptos_framework: &signer, gas_schedule_blob: vector<u8>) acquires GasScheduleV2 {
        system_addresses::assert_aptos_framework(aptos_framework);
        assert!(!vector::is_empty(&gas_schedule_blob), error::invalid_argument(EINVALID_GAS_SCHEDULE));
        let new_gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
        if (exists<GasScheduleV2>(@aptos_framework)) {
            let cur_gas_schedule = borrow_global<GasScheduleV2>(@aptos_framework);
            assert!(
                new_gas_schedule.feature_version >= cur_gas_schedule.feature_version,
                error::invalid_argument(EINVALID_GAS_FEATURE_VERSION)
            );
        };
        config_buffer::upsert(new_gas_schedule);
    }
```

**File:** third_party/move/move-vm/runtime/src/native_functions.rs (L393-450)
```rust
    fn verify_function(
        &mut self,
        module: Arc<Module>,
        func: Arc<Function>,
        expected_ty: &Type,
    ) -> PartialVMResult<Result<Box<dyn AbstractFunction>, FunctionResolutionError>> {
        use FunctionResolutionError::*;
        if !func.is_public() {
            return Ok(Err(FunctionNotAccessible));
        }
        let Type::Function {
            args,
            results,
            // Since resolved functions must be public, they always have all possible
            // abilities (store, copy, and drop), and we don't need to check with
            // expected abilities.
            abilities: _,
        } = expected_ty
        else {
            return Ok(Err(FunctionIncompatibleType));
        };
        let func_ref = func.as_ref();

        // Match types, inferring instantiation of function in `subst`.
        let mut subst = TypeParamMap::default();
        if !subst.match_tys(func_ref.param_tys.iter(), args.iter())
            || !subst.match_tys(func_ref.return_tys.iter(), results.iter())
        {
            return Ok(Err(FunctionIncompatibleType));
        }

        // Construct the type arguments from the match.
        let ty_args = match subst.verify_and_extract_type_args(func_ref.ty_param_abilities()) {
            Ok(ty_args) => ty_args,
            Err(err) => match err.major_status() {
                StatusCode::NUMBER_OF_TYPE_ARGUMENTS_MISMATCH => {
                    return Ok(Err(FunctionNotInstantiated));
                },
                StatusCode::CONSTRAINT_NOT_SATISFIED => {
                    return Ok(Err(FunctionIncompatibleType));
                },
                _ => return Err(err),
            },
        };

        // Construct result.
        let env = self.module_storage.runtime_environment();
        let ty_args_id = env.ty_pool().intern_ty_args(&ty_args);
        let loaded_fun = Rc::new(LoadedFunction {
            owner: LoadedFunctionOwner::Module(module),
            ty_args,
            ty_args_id,
            function: func,
        });
        Ok(Ok(Box::new(
            LazyLoadedFunction::new_resolved_not_capturing(env, loaded_fun)?,
        )))
    }
```

**File:** third_party/move/move-vm/types/src/loaded_data/runtime_types.rs (L1560-1686)
```rust
    pub fn match_ty(&mut self, ty: &Type, expected_ty: &'a Type) -> bool {
        match (ty, expected_ty) {
            // The important case, deduce the type params.
            (Type::TyParam(idx), _) => {
                use btree_map::Entry::*;
                match self.map.entry(*idx) {
                    Occupied(occupied_entry) => *occupied_entry.get() == expected_ty,
                    Vacant(vacant_entry) => {
                        vacant_entry.insert(expected_ty);
                        true
                    },
                }
            },
            // Recursive types we need to recurse the matching types.
            (Type::Reference(inner), Type::Reference(expected_inner))
            | (Type::MutableReference(inner), Type::MutableReference(expected_inner)) => {
                self.match_ty(inner, expected_inner)
            },
            (Type::Vector(inner), Type::Vector(expected_inner)) => {
                self.match_ty(inner, expected_inner)
            },
            // Function types, the expected abilities need to be equal to the provided ones,
            // and recursively argument and result types need to match.
            (
                Type::Function {
                    args,
                    results,
                    abilities,
                },
                Type::Function {
                    args: exp_args,
                    results: exp_results,
                    abilities: exp_abilities,
                },
            ) if abilities == exp_abilities
                && args.len() == exp_args.len()
                && results.len() == exp_results.len() =>
            {
                args.iter().zip(exp_args).all(|(t, e)| self.match_ty(t, e))
                    && results
                        .iter()
                        .zip(exp_results)
                        .all(|(t, e)| self.match_ty(t, e))
            },
            // Abilities should not contribute to the equality check as they just serve for caching
            // computations. For structs the both need to be the same struct.
            (
                Type::Struct { idx, .. },
                Type::Struct {
                    idx: expected_idx, ..
                },
            ) => *idx == *expected_idx,
            // For struct instantiations we need to additionally match all type arguments.
            (
                Type::StructInstantiation { idx, ty_args, .. },
                Type::StructInstantiation {
                    idx: expected_idx,
                    ty_args: expected_ty_args,
                    ..
                },
            ) => {
                *idx == *expected_idx
                    && ty_args.len() == expected_ty_args.len()
                    && ty_args
                        .iter()
                        .zip(expected_ty_args.iter())
                        .all(|types| self.match_ty(types.0, types.1))
            },
            // For primitive types we need to assure the types match.
            (Type::U8, Type::U8)
            | (Type::U16, Type::U16)
            | (Type::U32, Type::U32)
            | (Type::U64, Type::U64)
            | (Type::U128, Type::U128)
            | (Type::U256, Type::U256)
            | (Type::I8, Type::I8)
            | (Type::I16, Type::I16)
            | (Type::I32, Type::I32)
            | (Type::I64, Type::I64)
            | (Type::I128, Type::I128)
            | (Type::I256, Type::I256)
            | (Type::Bool, Type::Bool)
            | (Type::Address, Type::Address)
            | (Type::Signer, Type::Signer) => true,
            // Otherwise the types do not match, and we can't match return type to the expected type.
            // Note we don't use the _ pattern but spell out all cases, so that the compiler will
            // bark when a case is missed upon future updates to the types.
            (Type::U8, _)
            | (Type::U16, _)
            | (Type::U32, _)
            | (Type::U64, _)
            | (Type::U128, _)
            | (Type::U256, _)
            | (Type::I8, _)
            | (Type::I16, _)
            | (Type::I32, _)
            | (Type::I64, _)
            | (Type::I128, _)
            | (Type::I256, _)
            | (Type::Bool, _)
            | (Type::Address, _)
            | (Type::Signer, _)
            | (Type::Struct { .. }, _)
            | (Type::StructInstantiation { .. }, _)
            | (Type::Function { .. }, _)
            | (Type::Vector(_), _)
            | (Type::MutableReference(_), _)
            | (Type::Reference(_), _) => false,
        }
    }

    /// Matches sequences of types using `match_ty`.
    pub fn match_tys(
        &mut self,
        actuals: impl ExactSizeIterator<Item = &'a Type>,
        expected: impl ExactSizeIterator<Item = &'a Type>,
    ) -> bool {
        if actuals.len() != expected.len() {
            return false;
        }
        for (actual, formal) in actuals.zip(expected) {
            if !self.match_ty(actual, formal) {
                return false;
            }
        }
        true
    }
```

**File:** config/global-constants/src/lib.rs (L28-31)
```rust
#[cfg(any(test, feature = "testing"))]
pub const MAX_GAS_AMOUNT: u64 = 100_000_000;
#[cfg(not(any(test, feature = "testing")))]
pub const MAX_GAS_AMOUNT: u64 = 2_000_000;
```
