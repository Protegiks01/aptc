# Audit Report

## Title
Namespace Isolation Bypass in Vault Transit Backend via Separator Injection

## Summary
The `crypto_name()` function in `secure/storage/src/vault.rs` performs a naive string replacement of "/" with "__" to convert namespaced key names into Vault transit key names. This creates a collision vulnerability where carefully crafted namespace or key names containing "__" can bypass namespace isolation, allowing unauthorized access to cryptographic keys across namespace boundaries. [1](#0-0) 

## Finding Description

The Aptos secure storage system supports multi-tenant deployments where multiple validators share a single Vault instance using the `Namespaced` wrapper. [2](#0-1) 

The namespace separator "/" is used in the KV storage layer, but Vault's transit backend requires a different separator "__". [3](#0-2) [4](#0-3) 

When a cryptographic operation is performed, the flow is:
1. `Namespaced` wrapper prepends namespace: `"namespace/keyname"`
2. `crypto_name()` replaces "/" with "__": `"namespace__keyname"`

**The vulnerability:** If either the namespace or key name contains "__", collisions occur in Vault's transit backend:

- **Victim**: namespace=`"validator"`, key=`"consensus__backup"` → transit key: `"validator__consensus__backup"`
- **Attacker**: namespace=`"validator__consensus"`, key=`"backup"` → transit key: `"validator__consensus__backup"`

Both map to the **same key** in Vault's transit engine, allowing the attacker to:
- Sign messages with the victim's private key
- Export the victim's private key (if permissions allow)
- Rotate or access the victim's consensus key

The vulnerability violates the namespace isolation security boundary that is explicitly designed to allow multiple entities to safely share a Vault instance. [5](#0-4) 

## Impact Explanation

**Severity: High**

This vulnerability breaks the namespace isolation security guarantee in multi-tenant Vault deployments. The impact includes:

1. **Unauthorized Access to Cryptographic Keys**: An attacker with one namespace can access consensus signing keys from another namespace, violating the "Cryptographic Correctness" invariant.

2. **Potential Consensus Attacks**: Access to another validator's consensus key enables the attacker to sign messages on behalf of the victim validator, potentially causing equivocation or other consensus-level attacks that could violate consensus safety.

3. **Validator Identity Compromise**: Compromise of validator consensus keys undermines the security of the validator's identity and operations. [6](#0-5) 

While this requires the attacker to be a validator operator in a multi-tenant deployment (not a completely unprivileged attacker), it still qualifies as **High Severity** because:
- Namespace isolation is an explicit security feature
- Multi-tenant deployments are documented and supported
- The attack allows one validator operator to compromise another's keys
- No validation prevents "__" in namespace or key names

## Likelihood Explanation

**Likelihood: Medium**

The attack requires:
1. A multi-tenant Vault deployment where multiple validators share the same Vault instance
2. Attacker control over their own namespace name (standard validator operator capability)
3. Either victim using key names with "__" OR attacker using namespace containing "__"

While multi-tenant Vault deployments are explicitly supported and tested [7](#0-6) , the likelihood is reduced because:
- Current codebase uses standard key names without "__" [8](#0-7) 
- Namespaces are typically controlled through configuration files
- No evidence of "__" being used in practice

However, the vulnerability exists because there is no validation preventing "__" in namespace or key names, making exploitation possible if an attacker deliberately chooses such names.

## Recommendation

Implement validation to prevent "__" in namespace and key names when using VaultStorage, or use a more robust separator encoding scheme:

**Option 1: Validation (Simpler)**
```rust
fn crypto_name(&self, name: &str) -> String {
    if name.contains(TRANSIT_NAMESPACE_SEPARATOR) {
        panic!("Key name cannot contain '{}' separator", TRANSIT_NAMESPACE_SEPARATOR);
    }
    name.replace(NAMESPACE_SEPARATOR, TRANSIT_NAMESPACE_SEPARATOR)
}
```

**Option 2: Proper Encoding (More Robust)**
```rust
fn crypto_name(&self, name: &str) -> String {
    // URL-encode or use a safe delimiter that gets escaped
    name.replace(NAMESPACE_SEPARATOR, "__")
        .replace("__", "___") // Escape existing double underscores
}
```

Add validation in `Namespaced::new()` to reject namespaces containing the transit separator:
```rust
pub fn new<N: Into<String>>(namespace: N, inner: S) -> Self {
    let namespace = namespace.into();
    assert!(!namespace.contains("__"), 
            "Namespace cannot contain '__' separator");
    Self { namespace, inner }
}
```

## Proof of Concept

```rust
#[cfg(test)]
mod test_namespace_collision {
    use super::*;
    use aptos_crypto::ed25519::Ed25519PrivateKey;
    use aptos_secure_storage::{CryptoStorage, Namespaced, Storage};

    #[test]
    fn test_transit_key_collision() {
        let vault = create_vault(); // Assumes vault test setup
        
        // Victim creates a key in namespace "validator" with name "consensus__backup"
        let victim_namespace = "validator";
        let victim_key = "consensus__backup";
        let mut victim_storage = Namespaced::new(
            victim_namespace,
            Box::new(Storage::from(vault.clone()))
        );
        let victim_pubkey = victim_storage.create_key(victim_key).unwrap();
        
        // Attacker creates a key in namespace "validator__consensus" with name "backup"
        let attacker_namespace = "validator__consensus";
        let attacker_key = "backup";
        let mut attacker_storage = Namespaced::new(
            attacker_namespace,
            Box::new(Storage::from(vault.clone()))
        );
        
        // Due to collision, attacker gets the SAME key as victim
        let attacker_pubkey = attacker_storage.get_public_key(attacker_key).unwrap();
        
        // This assertion would pass, proving the collision
        assert_eq!(victim_pubkey, attacker_pubkey.public_key);
        
        // Attacker can now sign with victim's key
        let message = "malicious message";
        let signature = attacker_storage.sign(attacker_key, &message).unwrap();
        
        // Signature verifies with victim's public key
        signature.verify(&message, &victim_pubkey).unwrap();
    }
}
```

## Notes

The vulnerability exists in the design of the separator replacement mechanism. While no current usage in the codebase explicitly uses "__" in names, the lack of validation means this remains exploitable. The namespace isolation feature is documented as a security boundary for multi-tenant deployments, making this a genuine security issue rather than a theoretical concern.

### Citations

**File:** secure/storage/src/vault.rs (L24-24)
```rust
const TRANSIT_NAMESPACE_SEPARATOR: &str = "__";
```

**File:** secure/storage/src/vault.rs (L135-137)
```rust
    fn crypto_name(&self, name: &str) -> String {
        name.replace(NAMESPACE_SEPARATOR, TRANSIT_NAMESPACE_SEPARATOR)
    }
```

**File:** secure/storage/README.md (L44-47)
```markdown
In addition, this crate also offers a `Namespaced` wrapper around secure storage
implementations. Using the Namespaced wrapper, different entities can share the
same secure storage instance, under different namespaces, providing an abstraction that
each entity has its own secure storage backend.
```

**File:** secure/storage/src/namespaced.rs (L11-11)
```rust
pub const NAMESPACE_SEPARATOR: &str = "/";
```

**File:** config/src/config/secure_backend_config.rs (L56-59)
```rust
    /// A namespace is an optional portion of the path to a key stored within Vault. For example,
    /// a secret, S, without a namespace would be available in secret/data/S, with a namespace, N, it
    /// would be in secret/data/N/S.
    pub namespace: Option<String>,
```

**File:** consensus/safety-rules/src/persistent_safety_storage.rs (L63-81)
```rust
    fn initialize_keys_and_accounts(
        internal_store: &mut Storage,
        author: Author,
        consensus_private_key: bls12381::PrivateKey,
    ) -> Result<(), Error> {
        let result = internal_store.set(CONSENSUS_KEY, consensus_private_key);
        // Attempting to re-initialize existing storage. This can happen in environments like
        // forge. Rather than be rigid here, leave it up to the developer to detect
        // inconsistencies or why they did not reset storage between rounds. Do not repeat the
        // checks again below, because it is just too strange to have a partially configured
        // storage.
        if let Err(aptos_secure_storage::Error::KeyAlreadyExists(_)) = result {
            warn!("Attempted to re-initialize existing storage");
            return Ok(());
        }

        internal_store.set(OWNER_ACCOUNT, author)?;
        Ok(())
    }
```

**File:** secure/storage/src/tests/vault.rs (L76-84)
```rust
fn test_suite_multiple_namespaces() {
    let mut storage_1 = Storage::from(create_vault_with_namespace(VAULT_NAMESPACE_1));
    let mut storage_2 = Storage::from(create_vault_with_namespace(VAULT_NAMESPACE_2));
    let mut storage_3 = Storage::from(create_vault_with_namespace(VAULT_NAMESPACE_3));

    suite::execute_all_storage_tests(&mut storage_1);
    suite::execute_all_storage_tests(&mut storage_2);
    suite::execute_all_storage_tests(&mut storage_3);
}
```

**File:** config/global-constants/src/lib.rs (L12-12)
```rust
pub const CONSENSUS_KEY: &str = "consensus";
```
