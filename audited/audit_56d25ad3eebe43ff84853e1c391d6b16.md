# Audit Report

## Title
OnDiskStorage Silently Overwrites Consensus Keys Due to Missing Collision Detection in create_key()

## Summary
The `CryptoKVStorage` implementation (used by `OnDiskStorage` and `InMemoryStorage`) lacks collision detection in `create_key()`, allowing consensus keys to be silently overwritten. Unlike `VaultStorage` which properly rejects duplicate key creation, `OnDiskStorage` unconditionally overwrites existing keys, creating a risk of permanent consensus key loss for validators using this storage backend in production.

## Finding Description

The security question asks whether `create_key()` can be called multiple times with the same name and if collisions are properly handled. Investigation reveals a critical inconsistency between storage backend implementations:

**VaultStorage** properly handles collisions: [1](#0-0) 

**CryptoKVStorage** (OnDiskStorage/InMemoryStorage) does NOT: [2](#0-1) 

The `create_key()` method calls `import_private_key()`: [3](#0-2) 

Which then calls `set()` that unconditionally overwrites: [4](#0-3) 

**Production Impact**: Despite code comments suggesting OnDiskStorage is for testing only, production validator configurations explicitly use it: [5](#0-4) 

The configuration sanitizer only forbids `InMemoryStorage` for mainnet, explicitly allowing `OnDiskStorage`: [6](#0-5) 

**Attack Scenario**: When `PersistentSafetyStorage::initialize()` stores consensus keys, it expects `KeyAlreadyExists` errors to prevent overwrites: [7](#0-6) 

However, OnDiskStorage never returns this error - it silently overwrites, and the warning at line 75 never triggers.

## Impact Explanation

While this vulnerability exists in production code and affects actual validator deployments, it does NOT meet the **Critical** severity threshold per the Aptos bug bounty criteria because:

1. **Not remotely exploitable**: Triggering the vulnerability requires:
   - Local filesystem access to corrupt storage or delete the `author` key
   - Write access to configuration files
   - Ability to restart the validator process

2. **Limited scope**: Only affects a single validator, not network-wide consensus safety

3. **Requires unusual conditions**: Storage corruption or multiple initialization attempts

This is better classified as a **High** severity operational reliability issue (validator incapacitation) rather than a Critical security vulnerability. An attacker with sufficient access to trigger this would already have compromised the validator node and could directly steal keys.

## Likelihood Explanation

The likelihood of exploitation is **LOW** because:

- Requires local validator node access (not a remote attack)
- Storage corruption must occur naturally or be induced by an attacker who already controls the node
- The `storage.author().is_ok()` check prevents most re-initialization scenarios
- If an attacker has this level of access, simpler attacks (direct key theft) are available

However, the likelihood of **accidental** key loss is MODERATE due to:
- Code bugs causing double initialization
- Storage corruption from disk failures
- Migration/upgrade issues
- Race conditions in multi-process scenarios

## Recommendation

Add collision detection to `CryptoKVStorage::create_key()` to match `VaultStorage` behavior:

```rust
fn create_key(&mut self, name: &str) -> Result<Ed25519PublicKey, Error> {
    // Check if key already exists
    if self.get::<Ed25519PrivateKey>(name).is_ok() {
        return Err(Error::KeyAlreadyExists(name.to_string()));
    }
    
    // Generate and store the new named key pair
    let (private_key, public_key) = new_ed25519_key_pair();
    self.import_private_key(name, private_key)?;
    Ok(public_key)
}
```

Additionally, production deployments should migrate to VaultStorage for proper secure key management.

## Proof of Concept

```rust
#[cfg(test)]
mod test_key_collision {
    use aptos_secure_storage::{CryptoStorage, InMemoryStorage, Storage};
    
    #[test]
    #[should_panic(expected = "KeyAlreadyExists")]
    fn test_create_key_collision_detection() {
        let mut storage = Storage::from(InMemoryStorage::new());
        
        // Create a key
        let key1 = storage.create_key("test_consensus_key").unwrap();
        
        // Attempt to create the same key again - should fail but doesn't
        let key2 = storage.create_key("test_consensus_key").unwrap();
        
        // Keys are different - the first key was silently overwritten!
        assert_ne!(key1, key2, "Second create_key() overwrote the first key");
    }
}
```

**Note**: This test will demonstrate the vulnerability - it will NOT panic as expected because `InMemoryStorage` silently overwrites keys instead of returning `KeyAlreadyExists`.

---

**Final Assessment**: While the vulnerability exists as described, it does not meet the strict criteria for an **unprivileged remote exploit** required by the bug bounty program validation checklist. The vulnerability requires local node access and unusual conditions to trigger, making it more of a reliability concern than a critical security threat.

### Citations

**File:** secure/storage/src/vault.rs (L194-204)
```rust
    fn create_key(&mut self, name: &str) -> Result<Ed25519PublicKey, Error> {
        let ns_name = self.crypto_name(name);
        match self.get_public_key(name) {
            Ok(_) => return Err(Error::KeyAlreadyExists(ns_name)),
            Err(Error::KeyNotSet(_)) => (/* Expected this for new keys! */),
            Err(e) => return Err(e),
        }

        self.client().create_ed25519_key(&ns_name, true)?;
        self.get_public_key(name).map(|v| v.public_key)
    }
```

**File:** secure/storage/src/crypto_kv_storage.rs (L19-24)
```rust
    fn create_key(&mut self, name: &str) -> Result<Ed25519PublicKey, Error> {
        // Generate and store the new named key pair
        let (private_key, public_key) = new_ed25519_key_pair();
        self.import_private_key(name, private_key)?;
        Ok(public_key)
    }
```

**File:** secure/storage/src/crypto_kv_storage.rs (L55-57)
```rust
    fn import_private_key(&mut self, name: &str, key: Ed25519PrivateKey) -> Result<(), Error> {
        self.set(name, key)
    }
```

**File:** secure/storage/src/on_disk.rs (L85-93)
```rust
    fn set<V: Serialize>(&mut self, key: &str, value: V) -> Result<(), Error> {
        let now = self.time_service.now_secs();
        let mut data = self.read()?;
        data.insert(
            key.to_string(),
            serde_json::to_value(GetResponse::new(value, now))?,
        );
        self.write(&data)
    }
```

**File:** terraform/helm/aptos-node/files/configs/validator-base.yaml (L14-16)
```yaml
    backend:
      type: "on_disk_storage"
      path: secure-data.json
```

**File:** config/src/config/safety_rules_config.rs (L85-96)
```rust
        if let Some(chain_id) = chain_id {
            // Verify that the secure backend is appropriate for mainnet validators
            if chain_id.is_mainnet()
                && node_type.is_validator()
                && safety_rules_config.backend.is_in_memory()
            {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "The secure backend should not be set to in memory storage in mainnet!"
                        .to_string(),
                ));
            }
```

**File:** consensus/safety-rules/src/persistent_safety_storage.rs (L68-77)
```rust
        let result = internal_store.set(CONSENSUS_KEY, consensus_private_key);
        // Attempting to re-initialize existing storage. This can happen in environments like
        // forge. Rather than be rigid here, leave it up to the developer to detect
        // inconsistencies or why they did not reset storage between rounds. Do not repeat the
        // checks again below, because it is just too strange to have a partially configured
        // storage.
        if let Err(aptos_secure_storage::Error::KeyAlreadyExists(_)) = result {
            warn!("Attempted to re-initialize existing storage");
            return Ok(());
        }
```
