# Audit Report

After thorough investigation of the 404 vs 410 status code handling in the Aptos Core API, I have identified a race condition that causes pruned blocks to incorrectly return 404 (Not Found) instead of 410 (Gone), leading to client retry confusion.

## Title
TOCTOU Race Condition in Block Retrieval API Causes Incorrect 404 Status for Pruned Blocks

## Summary
The `get_block_by_height` function contains a Time-of-Check-Time-of-Use (TOCTOU) race condition between validating block availability and querying the database. When the pruner runs during this window, pruned blocks return 404 instead of 410, causing clients to incorrectly retry requests that will never succeed.

## Finding Description

The vulnerability exists in the block retrieval flow across multiple layers: [1](#0-0) 

The `get_block_by_height` function performs these steps:
1. Retrieves `latest_ledger_info` containing `oldest_block_height` (first non-pruned block)
2. Checks if `height < oldest_block_height` → returns 410 (pruned)
3. Checks if `height > current_block_height` → returns 404 (not found)
4. Calls `db.get_block_info_by_height(height)` and maps **any** error to 404

The issue occurs when `skip_index_and_usage == false` (event-based retrieval): [2](#0-1) 

In this mode, block info is retrieved from NewBlockEvents in the event store. The event store **is** pruned: [3](#0-2) 

**Race Condition Window:**
1. API retrieves `latest_ledger_info` at time T1 with `oldest_block_height = H1`
2. Pruner runs between T1 and T2, deletes NewBlockEvents for blocks < H2 (where H2 > H1)
3. API calls `db.get_block_info_by_height(H1)` at time T2
4. Database returns `NotFound` because event was pruned
5. API maps this to 404 instead of checking if the block is now pruned [4](#0-3) 

The error helper functions show that 404 and 410 are distinct status codes with different semantic meanings, but the catch-all error mapping loses this distinction.

## Impact Explanation

This falls under **Low Severity** ($1,000 category) per Aptos bug bounty rules:
- **Minor implementation bug**: HTTP status code confusion
- **Client impact**: Incorrect retry behavior wastes network bandwidth and client resources
- **No consensus impact**: Does not affect validator operations or chain state
- **No fund loss**: No financial implications
- **No availability impact**: API remains functional, just returns incorrect status

The bug causes operational inefficiency rather than security compromise.

## Likelihood Explanation

**Likelihood: Medium-High** during active pruning:
- Occurs naturally when nodes are pruning historical data
- Race window is narrow (milliseconds) but exists on every API call
- More likely on nodes with aggressive pruning policies
- Can be triggered by any client querying blocks near the pruning boundary
- No special privileges required

## Recommendation

**Fix 1: Re-check pruning status on database error**

Modify `get_block_by_height` to re-validate against current pruning state when the database call fails:

```rust
let (first_version, last_version, new_block_event) = match self
    .db
    .get_block_info_by_height(height) {
    Ok(result) => result,
    Err(_) => {
        // Re-check if block was pruned since initial check
        let current_ledger_info = self.get_latest_ledger_info()?;
        if height < current_ledger_info.oldest_block_height.0 {
            return Err(block_pruned_by_height(height, &current_ledger_info));
        }
        return Err(block_not_found_by_height(height, latest_ledger_info));
    }
};
```

**Fix 2: Add explicit pruning check in storage layer**

Modify `get_raw_block_info_by_height` to distinguish pruned vs not-found:

```rust
pub(super) fn get_raw_block_info_by_height(&self, block_height: u64) -> Result<BlockInfo> {
    if !self.skip_index_and_usage {
        let min_viable_version = self.ledger_pruner.get_min_viable_version();
        let result = self.event_store.get_event_by_key(
            &new_block_event_key(),
            block_height,
            self.ensure_synced_version()?,
        );
        
        match result {
            Err(_) => {
                // Check if this is because data was pruned
                let (first_viable_version, first_viable_height) = self.get_first_viable_block()?;
                if block_height < first_viable_height {
                    return Err(AptosDbError::Pruned(format!("Block {} has been pruned", block_height)));
                }
                return Err(AptosDbError::NotFound(format!("BlockInfo not found at height {}", block_height)));
            }
            Ok((first_version, new_block_event)) => {
                let new_block_event = bcs::from_bytes(new_block_event.event_data())?;
                Ok(BlockInfo::from_new_block_event(first_version, &new_block_event))
            }
        }
    } else {
        // ... existing code
    }
}
```

## Proof of Concept

```rust
// Test demonstrating the race condition
#[tokio::test]
async fn test_block_pruning_status_code_race() {
    let (mock_db, context) = setup_test_context();
    
    // Setup: Block height 100 exists
    mock_db.set_block_info(100, create_test_block_info());
    mock_db.set_oldest_block_height(50);
    
    // Simulate concurrent API call and pruning
    let api_handle = tokio::spawn({
        let context = context.clone();
        async move {
            // API reads ledger info (oldest_block = 50)
            let ledger_info = context.get_latest_ledger_info().unwrap();
            assert_eq!(ledger_info.oldest_block_height.0, 50);
            
            // Small delay to allow pruner to run
            tokio::time::sleep(tokio::time::Duration::from_millis(10)).await;
            
            // Try to get block 60 (was valid, now pruned)
            context.get_block_by_height(60, &ledger_info, false)
        }
    });
    
    // Pruner runs and advances oldest_block to 100
    tokio::time::sleep(tokio::time::Duration::from_millis(5)).await;
    mock_db.prune_blocks_before(100);
    mock_db.set_oldest_block_height(100);
    
    // API call completes - should return 410 but returns 404
    let result = api_handle.await.unwrap();
    match result {
        Err(e) => {
            // BUG: This will be NotFound (404) instead of Gone (410)
            assert!(matches!(e, BasicErrorWith404::NotFound(_)));
            // Should be: assert!(matches!(e, BasicErrorWith404::Gone(_)));
        }
        Ok(_) => panic!("Expected error"),
    }
}
```

## Notes

This is a legitimate implementation bug that causes HTTP status code confusion, but the security impact is minimal. The issue is confined to the REST API layer and does not affect:
- Consensus or validator operations
- On-chain state or transaction execution
- Fund security or balance integrity
- Network liveness or availability

The bug should be fixed to improve API correctness and prevent unnecessary client retries, but it does not represent a critical security vulnerability.

### Citations

**File:** api/src/context.rs (L628-652)
```rust
    pub fn get_block_by_height<E: StdApiError>(
        &self,
        height: u64,
        latest_ledger_info: &LedgerInfo,
        with_transactions: bool,
    ) -> Result<BcsBlock, E> {
        if height < latest_ledger_info.oldest_block_height.0 {
            return Err(block_pruned_by_height(height, latest_ledger_info));
        } else if height > latest_ledger_info.block_height.0 {
            return Err(block_not_found_by_height(height, latest_ledger_info));
        }

        let (first_version, last_version, new_block_event) = self
            .db
            .get_block_info_by_height(height)
            .map_err(|_| block_not_found_by_height(height, latest_ledger_info))?;

        self.get_block(
            latest_ledger_info,
            with_transactions,
            first_version,
            last_version,
            new_block_event,
        )
    }
```

**File:** storage/aptosdb/src/db/aptosdb_internal.rs (L317-338)
```rust
    pub(super) fn get_raw_block_info_by_height(&self, block_height: u64) -> Result<BlockInfo> {
        if !self.skip_index_and_usage {
            let (first_version, new_block_event) = self.event_store.get_event_by_key(
                &new_block_event_key(),
                block_height,
                self.ensure_synced_version()?,
            )?;
            let new_block_event = bcs::from_bytes(new_block_event.event_data())?;
            Ok(BlockInfo::from_new_block_event(
                first_version,
                &new_block_event,
            ))
        } else {
            Ok(self
                .ledger_db
                .metadata_db()
                .get_block_info(block_height)?
                .ok_or_else(|| {
                    AptosDbError::NotFound(format!("BlockInfo not found at height {block_height}"))
                })?)
        }
    }
```

**File:** storage/aptosdb/src/pruner/ledger_pruner/event_store_pruner.rs (L43-81)
```rust
    fn prune(&self, current_progress: Version, target_version: Version) -> Result<()> {
        let mut batch = SchemaBatch::new();
        let mut indexer_batch = None;

        let indices_batch = if let Some(indexer_db) = self.indexer_db() {
            if indexer_db.event_enabled() {
                indexer_batch = Some(SchemaBatch::new());
            }
            indexer_batch.as_mut()
        } else {
            Some(&mut batch)
        };
        let num_events_per_version = self.ledger_db.event_db().prune_event_indices(
            current_progress,
            target_version,
            indices_batch,
        )?;
        self.ledger_db.event_db().prune_events(
            num_events_per_version,
            current_progress,
            target_version,
            &mut batch,
        )?;
        batch.put::<DbMetadataSchema>(
            &DbMetadataKey::EventPrunerProgress,
            &DbMetadataValue::Version(target_version),
        )?;

        if let Some(mut indexer_batch) = indexer_batch {
            indexer_batch.put::<InternalIndexerMetadataSchema>(
                &IndexerMetadataKey::EventPrunerProgress,
                &IndexerMetadataValue::Version(target_version),
            )?;
            self.expect_indexer_db()
                .get_inner_db_ref()
                .write_schemas(indexer_batch)?;
        }
        self.ledger_db.event_db().write_schemas(batch)
    }
```

**File:** api/src/response.rs (L762-792)
```rust
pub fn block_not_found_by_height<E: NotFoundError>(
    block_height: u64,
    ledger_info: &LedgerInfo,
) -> E {
    build_not_found(
        "Block",
        format!("Block height({})", block_height,),
        AptosErrorCode::BlockNotFound,
        ledger_info,
    )
}

pub fn block_not_found_by_version<E: NotFoundError>(
    ledger_version: u64,
    ledger_info: &LedgerInfo,
) -> E {
    build_not_found(
        "Block",
        format!("Ledger version({})", ledger_version,),
        AptosErrorCode::BlockNotFound,
        ledger_info,
    )
}

pub fn block_pruned_by_height<E: GoneError>(block_height: u64, ledger_info: &LedgerInfo) -> E {
    E::gone_with_code(
        format!("Block({}) has been pruned", block_height),
        AptosErrorCode::BlockPruned,
        ledger_info,
    )
}
```
