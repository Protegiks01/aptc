# Audit Report

## Title
Sensitive Credentials Exposed in Faucet Configuration Logs

## Summary
The Aptos Faucet's configuration validation and startup functions log the entire configuration structure at INFO level using Debug formatting (`{:#?}`), which exposes sensitive credentials including private keys, API keys, database passwords, and filesystem paths. This violates the principle of least information disclosure and creates a significant security risk.

## Finding Description

The faucet configuration is logged in two critical locations: [1](#0-0) [2](#0-1) 

Both locations use `info!("{:#?}", config)` which recursively prints all configuration fields. The problem is that multiple configuration structures derive the default `Debug` trait without implementing custom sanitization for sensitive fields.

**Sensitive Data Exposed:**

1. **Private Keys**: The `AssetConfig` struct contains private keys: [3](#0-2) 

The `ConfigKey<Ed25519PrivateKey>` wrapper also derives Debug without masking: [4](#0-3) 

2. **API Keys**: The `ApiConnectionConfig` exposes the `api_key` field: [5](#0-4) 

3. **Database Passwords**: The `RedisRatelimitCheckerConfig` exposes database credentials: [6](#0-5) 

4. **Filesystem Paths**: Full paths to key files and token lists are exposed, revealing system structure.

**Attack Vector:**

An attacker who gains access to faucet logs (through compromised log aggregation systems, leaked log files, insider access, or compromised operator accounts) can extract:
- The faucet's private key → enables draining the faucet or minting unlimited tokens
- Node API keys → enables abuse of node API access
- Redis credentials → enables access to rate-limiting data and request history

## Impact Explanation

This vulnerability qualifies as **MEDIUM to HIGH severity** under the Aptos bug bounty program:

- **Medium Severity** ($10,000): Limited funds loss through stolen faucet private keys
- **High Severity** ($50,000): If the faucet uses the same credentials as validator infrastructure, this could lead to validator node compromise

The faucet private key exposure allows attackers to:
1. Mint unlimited test tokens on testnets
2. Drain the faucet account balance
3. Impersonate the faucet for phishing attacks
4. Disrupt testnet operations

While this is "only" a testnet faucet, credential exposure represents a serious security failure that could be replicated in production systems.

## Likelihood Explanation

**Likelihood: HIGH**

This vulnerability is already present and actively logging credentials:
- INFO level logs are typically enabled in production environments
- Logs are commonly aggregated to centralized logging systems (Splunk, ELK, CloudWatch)
- Log files are often accessible to support staff, SREs, and incident responders
- Logs may be inadvertently leaked in bug reports, GitHub issues, or support tickets
- Compromised monitoring infrastructure is a common attack vector

The vulnerability requires no special trigger—it activates automatically on faucet startup and configuration validation.

## Recommendation

Implement custom `Debug` trait implementations for all configuration structures containing sensitive data. The codebase already demonstrates the correct pattern: [7](#0-6) 

**Specific Fixes Required:**

1. **AssetConfig**: Implement custom Debug to redact the `key` field
2. **ConfigKey<T>**: Implement custom Debug to always print `"<key hidden>"`
3. **ApiConnectionConfig**: Redact `api_key` and `additional_headers`
4. **RedisRatelimitCheckerConfig**: Redact `database_password` and optionally `database_user`
5. **ListManagerConfig**: Optionally redact file paths or replace with basename only

Additionally, consider using WARN or ERROR level for configuration issues instead of INFO for successful validation.

## Proof of Concept

Create a minimal test configuration with sensitive data:

```yaml
# test_config.yaml
server_config:
  listen_address: "0.0.0.0"
  listen_port: 8081
  api_path_base: ""

metrics_server_config:
  disable: true
  listen_address: "0.0.0.0"
  listen_port: 9102

bypasser_configs: []
checker_configs:
  - type: RedisRatelimit
    database_address: "redis.example.com"
    database_port: 6379
    database_number: 0
    database_user: "faucet_user"
    database_password: "SuperSecretPassword123!"
    max_requests_per_day: 100

funder_config:
  type: MintFunder
  api_connection_config:
    node_url: "https://api.example.com"
    api_key: "SecretAPIKey123456"
    chain_id: 2
  assets:
    apt:
      mint_account_address: "0x1"
      do_not_delegate: false
      key: "0x1234567890abcdef..." # Hex-encoded private key
  default_asset: "apt"
  amount_to_fund: 100000000

handler_config:
  use_helpful_errors: true
  return_rejections_early: false
  max_concurrent_requests: 10
```

**Steps to reproduce:**

1. Run: `aptos-faucet validate-config --config-path test_config.yaml`
2. Observe in logs: The entire private key, API key, and database password are printed in plaintext at INFO level
3. Alternatively, run the faucet normally and check startup logs

**Expected Output (vulnerable):**
```
INFO Running with config: RunConfig { 
  ...
  funder_config: MintFunder { 
    api_connection_config: ApiConnectionConfig { 
      api_key: Some("SecretAPIKey123456"),
      ...
    },
    assets: { "apt": AssetConfig { 
      key: Some(ConfigKey { key: Ed25519PrivateKey([1, 2, 3, ...]) }),
      ...
    }}
  },
  checker_configs: [RedisRatelimitCheckerConfig { 
    database_password: Some("SuperSecretPassword123!"),
    ...
  }]
}
```

**Expected Output (after fix):**
```
INFO Running with config: RunConfig { 
  ...
  funder_config: MintFunder { 
    api_connection_config: ApiConnectionConfig { 
      api_key: Some("<redacted>"),
      ...
    },
    assets: { "apt": AssetConfig { 
      key: Some("<key hidden>"),
      ...
    }}
  },
  checker_configs: [RedisRatelimitCheckerConfig { 
    database_password: Some("<redacted>"),
    ...
  }]
}
```

## Notes

The Google Captcha API key is properly protected with a custom `KeyString` wrapper that implements Debug to hide the key: [8](#0-7) 

This demonstrates that the team is aware of the need to protect secrets in logs, but this pattern was not consistently applied across all configuration structures. The same approach should be extended to all sensitive fields.

### Citations

**File:** crates/aptos-faucet/core/src/server/validate_config.rs (L32-32)
```rust
        info!("Config is valid: {:#?}", run_config);
```

**File:** crates/aptos-faucet/core/src/server/run.rs (L86-86)
```rust
        info!("Running with config: {:#?}", self);
```

**File:** crates/aptos-faucet/core/src/funder/common.rs (L54-75)
```rust
#[derive(Clone, Debug, Deserialize, Parser, Serialize)]
pub struct ApiConnectionConfig {
    /// Aptos node (any node type with an open API) server URL.
    /// Include the port in this if not using the default for the scheme.
    #[clap(long, default_value = "https://fullnode.testnet.aptoslabs.com/")]
    pub node_url: Url,

    /// API key for talking to the node API.
    #[clap(long)]
    pub api_key: Option<String>,

    /// Any additional headers to send with the request. We don't accept this on the
    /// CLI.
    #[clap(skip)]
    pub additional_headers: Option<HashMap<String, String>>,

    /// Chain ID of the network this client is connecting to. For example, for mainnet:
    /// "MAINNET" or 1, testnet: "TESTNET" or 2. If there is no predefined string
    /// alias (e.g. "MAINNET"), just use the number. Note: Chain ID of 0 is not allowed.
    #[clap(long, default_value_t = ChainId::testnet())]
    pub chain_id: ChainId,
}
```

**File:** crates/aptos-faucet/core/src/funder/common.rs (L450-465)
```rust
#[derive(Clone, Debug, Deserialize, Serialize, Parser)]
pub struct AssetConfig {
    /// Path to the private key for creating test account and minting coins in
    /// the MintFunder case, or for transferring coins in the TransferFunder case.
    /// To keep Testnet simple, we used one private key for aptos root account
    /// To manually generate a keypair, use generate-key:
    /// `cargo run -p generate-keypair -- -o <output_file_path>`
    #[serde(default = "AssetConfig::default_key_file_path")]
    #[clap(long, default_value = DEFAULT_KEY_FILE_PATH, value_parser)]
    pub key_file_path: PathBuf,

    /// Hex string of an Ed25519PrivateKey for minting / transferring coins.
    #[serde(skip_serializing_if = "Option::is_none")]
    #[clap(long, value_parser = ConfigKey::<Ed25519PrivateKey>::from_encoded_string)]
    pub key: Option<ConfigKey<Ed25519PrivateKey>>,
}
```

**File:** config/src/keys.rs (L25-29)
```rust
#[derive(Debug, Deserialize, Serialize)]
pub struct ConfigKey<T: PrivateKey + Serialize> {
    #[serde(bound(deserialize = "T: Deserialize<'de>"))]
    key: T,
}
```

**File:** crates/aptos-faucet/core/src/checkers/redis_ratelimit.rs (L54-81)
```rust
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct RedisRatelimitCheckerConfig {
    /// The database address to connect to, not including port,
    /// e.g. db.example.com or 234.121.222.42.
    pub database_address: String,

    /// The port to connect to.
    #[serde(default = "RedisRatelimitCheckerConfig::default_database_port")]
    pub database_port: u16,

    /// The number of the database to use. If it doesn't exist, it will be created (todo verify this)
    #[serde(default = "RedisRatelimitCheckerConfig::default_database_number")]
    pub database_number: i64,

    /// The name of the user to use, if necessary.
    pub database_user: Option<String>,

    /// The password of the given user, if necessary.
    pub database_password: Option<String>,

    /// Max number of requests per key per day. 500s are not counted, because they are
    /// not the user's fault, but everything else is.
    pub max_requests_per_day: u32,

    /// This defines how we ratelimit, e.g. either by IP or by JWT (Firebase UID).
    #[serde(default)]
    pub ratelimit_key_provider_config: RatelimitKeyProviderConfig,
}
```

**File:** config/src/config/indexer_config.rs (L92-117)
```rust
impl Debug for IndexerConfig {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        let postgres_uri = self.postgres_uri.as_ref().map(|u| {
            let mut parsed_url = url::Url::parse(u).expect("Invalid postgres uri");
            if parsed_url.password().is_some() {
                parsed_url.set_password(Some("*")).unwrap();
            }
            parsed_url.to_string()
        });
        f.debug_struct("IndexerConfig")
            .field("enabled", &self.enabled)
            .field("postgres_uri", &postgres_uri)
            .field("processor", &self.processor)
            .field("starting_version", &self.starting_version)
            .field("skip_migrations", &self.skip_migrations)
            .field("check_chain_id", &self.check_chain_id)
            .field("batch_size", &self.batch_size)
            .field("fetch_tasks", &self.fetch_tasks)
            .field("processor_tasks", &self.processor_tasks)
            .field("emit_every", &self.emit_every)
            .field("gap_lookback_versions", &self.gap_lookback_versions)
            .field("ans_contract_address", &self.ans_contract_address)
            .field("nft_points_contract", &self.nft_points_contract)
            .finish()
    }
}
```

**File:** crates/aptos-faucet/core/src/checkers/google_captcha.rs (L15-22)
```rust
#[derive(Clone, Default, Deserialize, Eq, PartialEq, Serialize)]
pub struct KeyString(pub String);

impl std::fmt::Debug for KeyString {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "<key hidden>")
    }
}
```
