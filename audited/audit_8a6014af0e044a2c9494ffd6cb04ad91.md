# Audit Report

## Title
Insecure File Permissions in SafetyRulesConfig Persistence Allow Exposure of Validator Consensus Keys

## Summary
The `write_file()` function in `config/src/config/persistable_config.rs` creates configuration files using `File::create()` without explicitly setting secure file permissions, relying instead on the process umask. This can result in SafetyRulesConfig and NodeConfig files being created with world-readable permissions (mode 0644) when umask is misconfigured to common defaults like 0022, exposing sensitive cryptographic material including validator consensus private keys and network identity keys to any local user on the system. [1](#0-0) 

## Finding Description

The vulnerability exists in the file permission handling during configuration serialization. The affected code path is:

1. **Configuration structures contain sensitive private keys:**
   - `SafetyRulesTestConfig` contains `consensus_key: Option<ConfigKey<bls12381::PrivateKey>>` - the validator's BLS12-381 consensus signing key [2](#0-1) 

   - `IdentityFromConfig` contains `key: ConfigKey<x25519::PrivateKey>` - the network identity private key [3](#0-2) 

   - `ConfigKey<T>` directly serializes the private key material [4](#0-3) 

2. **Both NodeConfig and SafetyRulesConfig implement PersistableConfig** and can be saved to disk: [5](#0-4) 

3. **The `save_config()` method serializes to YAML and calls `write_file()`:** [6](#0-5) 

4. **`write_file()` uses `File::create()` without explicit permission setting:**
   On Unix systems, `File::create()` creates files with permissions `0o666 & !umask`. With the common default umask of `0o022`, files are created with mode `0o644` (owner: rw, group: r, others: r), making them world-readable.

**Attack Scenario:**

1. Validator operator runs node setup with default umask `0o022`
2. During genesis or configuration generation, `NodeConfig` with embedded test consensus keys is saved using `save_config()` [7](#0-6) [8](#0-7) 

3. Configuration file is created as world-readable (mode 0644)
4. Local attacker with unprivileged access to the validator host reads the configuration file
5. Attacker extracts the BLS12-381 consensus private key from the YAML
6. Attacker can now sign consensus votes and blocks as that validator, enabling:
   - **Equivocation attacks:** Sign conflicting blocks/votes to violate AptosBFT safety rules
   - **Consensus disruption:** Cause safety violations leading to validator slashing
   - **Double-signing penalties:** Trigger slashing conditions for the legitimate validator

**Affected Invariants:**
- **Cryptographic Correctness:** Private keys must be protected with appropriate file system permissions
- **Consensus Safety:** Validator consensus keys must remain confidential to prevent equivocation attacks

## Impact Explanation

**Severity: HIGH**

This vulnerability qualifies as HIGH severity under the Aptos bug bounty criteria for the following reasons:

1. **Significant Protocol Violations:** Compromised consensus keys enable equivocation attacks that violate AptosBFT safety guarantees, potentially causing consensus failures or chain splits in affected networks.

2. **Validator Security Compromise:** Stolen consensus keys allow attackers to impersonate validators, sign malicious blocks, and trigger slashing conditions that result in financial penalties for legitimate validators.

3. **Defense-in-Depth Failure:** While mainnet validators are protected by the config sanitizer rejecting test configs with embedded keys, this vulnerability affects: [9](#0-8) 
   - TestNet and DevNet deployments where test configs are commonly used
   - Network identity keys (x25519) which may be embedded in production configs via `IdentityFromConfig`
   - Any environment where the sanitizer is bypassed or not enforced

The codebase already demonstrates awareness of this security requirement through the `write_to_user_only_file()` utility that explicitly sets mode 0o600: [10](#0-9) 

## Likelihood Explanation

**Likelihood: MEDIUM to HIGH**

This vulnerability is likely to occur because:

1. **Common Misconfiguration:** The umask value `0o022` is the default on most Linux distributions, making this not a "misconfiguration" but rather the standard behavior.

2. **Real Usage Scenarios:**
   - Test networks and development environments commonly use `SafetyRulesTestConfig` with embedded consensus keys
   - Genesis configuration tools save `NodeConfig` to disk during validator setup
   - Network identity keys in `IdentityFromConfig` may be present in production configurations

3. **Attack Surface:**
   - Shared hosting environments where multiple services run on the same machine
   - Container escape scenarios where attackers gain host file system access
   - Lateral movement from compromised neighboring services
   - Cloud instance metadata access vulnerabilities

4. **Easy Exploitation:** Once local file system access is achieved, exploitation is trivial - simply read the YAML file and extract the base64-encoded private keys.

## Recommendation

Modify `write_file()` to explicitly set restrictive file permissions (mode 0o600) on Unix systems, ensuring configuration files containing sensitive data are readable only by the owner:

```rust
use std::fs::OpenOptions;

fn write_file<P: AsRef<Path>>(serialized_config: Vec<u8>, output_file: P) -> Result<(), Error> {
    let mut opts = OpenOptions::new();
    opts.write(true).create(true).truncate(true);
    
    #[cfg(unix)]
    {
        use std::os::unix::fs::OpenOptionsExt;
        opts.mode(0o600);
    }
    
    let mut file = opts
        .open(output_file.as_ref())
        .map_err(|e| Error::IO(output_file.as_ref().to_str().unwrap().to_string(), e))?;
    
    file.write_all(&serialized_config)
        .map_err(|e| Error::IO(output_file.as_ref().to_str().unwrap().to_string(), e))?;
    
    Ok(())
}
```

This matches the security pattern already established in `write_to_user_only_file()` used elsewhere in the codebase.

## Proof of Concept

```rust
use aptos_config::config::{NodeConfig, PersistableConfig, SafetyRulesConfig, SafetyRulesTestConfig};
use aptos_types::PeerId;
use std::fs;
use std::os::unix::fs::PermissionsExt;
use tempfile::TempDir;

#[test]
fn test_config_file_permissions_vulnerability() {
    // Create a temporary directory for testing
    let temp_dir = TempDir::new().unwrap();
    let config_path = temp_dir.path().join("validator.yaml");
    
    // Create a NodeConfig with embedded consensus key in test config
    let mut node_config = NodeConfig::default();
    let mut test_config = SafetyRulesTestConfig::new(PeerId::random());
    let mut rng = rand::rngs::StdRng::from_entropy();
    test_config.random_consensus_key(&mut rng);
    node_config.consensus.safety_rules.test = Some(test_config);
    
    // Set umask to 0o022 (common default)
    unsafe { libc::umask(0o022); }
    
    // Save the config using the vulnerable write_file()
    node_config.save_config(&config_path).unwrap();
    
    // Check the file permissions
    let metadata = fs::metadata(&config_path).unwrap();
    let permissions = metadata.permissions();
    let mode = permissions.mode();
    
    // Extract permission bits (last 9 bits)
    let perm_bits = mode & 0o777;
    
    println!("File created with permissions: {:o}", perm_bits);
    
    // VULNERABILITY: File is created with permissions 0o644 (world-readable)
    // instead of 0o600 (user-only)
    assert_eq!(perm_bits, 0o644, 
        "Config file with private keys is world-readable!");
    
    // Any local user can now read the consensus private key
    let contents = fs::read_to_string(&config_path).unwrap();
    assert!(contents.contains("consensus_key"), 
        "Consensus private key is exposed in world-readable file");
}
```

**Notes:**

This vulnerability represents a defense-in-depth failure where the code does not follow security best practices for handling sensitive cryptographic material. While mainnet production validators have additional protections (sanitizer enforcement, recommended use of Vault backend), the principle of secure defaults requires that configuration persistence set restrictive permissions regardless of deployment environment. The existence of `write_to_user_only_file()` elsewhere in the codebase demonstrates that developers are aware of this requirement, making the lack of permission setting in `write_file()` an oversight that should be corrected.

### Citations

**File:** config/src/config/persistable_config.rs (L23-29)
```rust
    fn save_config<P: AsRef<Path>>(&self, output_file: P) -> Result<(), Error> {
        // Serialize the config to a string
        let serialized_config = serde_yaml::to_vec(&self)
            .map_err(|e| Error::Yaml(output_file.as_ref().to_str().unwrap().to_string(), e))?;

        Self::write_file(serialized_config, output_file)
    }
```

**File:** config/src/config/persistable_config.rs (L43-50)
```rust
    fn write_file<P: AsRef<Path>>(serialized_config: Vec<u8>, output_file: P) -> Result<(), Error> {
        let mut file = File::create(output_file.as_ref())
            .map_err(|e| Error::IO(output_file.as_ref().to_str().unwrap().to_string(), e))?;
        file.write_all(&serialized_config)
            .map_err(|e| Error::IO(output_file.as_ref().to_str().unwrap().to_string(), e))?;

        Ok(())
    }
```

**File:** config/src/config/persistable_config.rs (L59-60)
```rust
impl PersistableConfig for NodeConfig {}
impl PersistableConfig for SafetyRulesConfig {}
```

**File:** config/src/config/safety_rules_config.rs (L107-112)
```rust
            if chain_id.is_mainnet() && safety_rules_config.test.is_some() {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "The safety rules test config should not be used in mainnet!".to_string(),
                ));
            }
```

**File:** config/src/config/safety_rules_config.rs (L242-245)
```rust
pub struct SafetyRulesTestConfig {
    pub author: PeerId,
    pub consensus_key: Option<ConfigKey<bls12381::PrivateKey>>,
    pub waypoint: Option<Waypoint>,
```

**File:** config/src/config/identity_config.rs (L132-135)
```rust
pub struct IdentityFromConfig {
    #[serde(flatten)]
    pub key: ConfigKey<x25519::PrivateKey>,
    pub peer_id: PeerId,
```

**File:** config/src/keys.rs (L25-29)
```rust
#[derive(Debug, Deserialize, Serialize)]
pub struct ConfigKey<T: PrivateKey + Serialize> {
    #[serde(bound(deserialize = "T: Deserialize<'de>"))]
    key: T,
}
```

**File:** config/src/config/node_config.rs (L224-226)
```rust
            let mut safety_rules_test_config = SafetyRulesTestConfig::new(peer_id);
            safety_rules_test_config.random_consensus_key(rng);
            node_config.consensus.safety_rules.test = Some(safety_rules_test_config);
```

**File:** crates/aptos-genesis/src/builder.rs (L179-189)
```rust
    fn save_config(&mut self) -> anyhow::Result<()> {
        // Save the execution config to disk along with the full config.
        self.config
            .override_config_mut()
            .save_to_path(self.dir.join(CONFIG_FILE))?;

        // Overwrite the full config with the override config
        self.config
            .save_config(self.dir.join(CONFIG_FILE))
            .map_err(Into::into)
    }
```

**File:** crates/aptos/src/common/utils.rs (L223-229)
```rust
/// Write a User only read / write file
pub fn write_to_user_only_file(path: &Path, name: &str, bytes: &[u8]) -> CliTypedResult<()> {
    let mut opts = OpenOptions::new();
    #[cfg(unix)]
    opts.mode(0o600);
    write_to_file_with_opts(path, name, bytes, &mut opts)
}
```
