# Audit Report

## Title
CCA Vulnerability in BIBE Decryption Allows Adaptive Chosen-Ciphertext Attacks and Key Extraction

## Summary
The BIBE (Batch Identity-Based Encryption) implementation in `aptos-batch-encryption` is not CCA-secure. An attacker can modify `ct_g2` ciphertext components and observe decryption success/failure to mount adaptive chosen-ciphertext attacks, potentially extracting bits of the decryption key. The vulnerability exists because the scheme lacks ciphertext validity proofs and relies on AES-GCM authentication tag verification as the only integrity check, creating a decryption oracle.

## Finding Description

The BIBE decryption function lacks any validation of the `ct_g2` ciphertext components before using them in pairing operations. [1](#0-0) 

When an encrypted transaction is submitted to consensus, the decryption pipeline processes it without verifying ciphertext integrity: [2](#0-1) 

The attack flow is:

1. **Attacker submits malicious ciphertext**: A transaction sender creates an encrypted transaction with modified `ct_g2` components (specifically `ct_g2[2]`).

2. **No validation during preparation**: The `prepare_individual` function directly uses the malicious `ct_g2` components in pairing operations without any integrity check: [3](#0-2) 

3. **Decryption oracle created**: During decryption, the modified `ct_g2[2]` causes incorrect `otp_source_gt` computation, leading to a wrong symmetric key derivation. The subsequent AES-GCM decryption fails with an observable error: [4](#0-3) 

4. **Observable failure**: The transaction is marked as `FailedDecryption`, which is observable to the network, creating a decryption oracle that leaks information about whether specific ciphertext modifications are valid.

5. **Adaptive attack**: By systematically modifying `ct_g2` components and observing which modifications cause decryption failures, an attacker can extract information about the decryption key through adaptive queries.

The vulnerability exists because the ciphertext signature verification is optional and not enforced before decryption: [5](#0-4) 

## Impact Explanation

**Critical Severity** - This vulnerability breaks the fundamental security guarantee of the encryption scheme:

1. **Cryptographic Correctness Violation**: The BIBE scheme violates the "Cryptographic Correctness" invariant by not being CCA-secure, which is a standard requirement for secure encryption schemes in adversarial environments.

2. **Key Extraction Risk**: Through adaptive chosen-ciphertext attacks, an attacker can potentially extract bits of the decryption key used by validators to decrypt transaction batches.

3. **Confidentiality Breach**: Once key information is extracted, attackers could potentially decrypt other users' encrypted transactions, breaking the confidentiality guarantees of the system.

4. **Consensus Impact**: The encrypted transaction processing is used in the consensus pipeline: [6](#0-5) 

This impacts the security of the threshold encryption system used for transaction privacy in Aptos consensus.

## Likelihood Explanation

**High Likelihood**:

1. **No Special Privileges Required**: Any transaction sender can submit encrypted transactions with malicious ciphertexts - no validator access needed.

2. **Observable Oracle**: The decryption success/failure is observable through transaction status (Decrypted vs FailedDecryption state).

3. **Active Feature**: The encrypted payload functionality is actively used in consensus: [7](#0-6) 

4. **Standard Attack**: CCA attacks on encryption schemes without proper validation are well-documented in cryptographic literature.

## Recommendation

Implement proper ciphertext validation before decryption:

1. **Enforce Signature Verification**: Make the `verify()` call mandatory before `prepare()` and decryption. Modify the API to return `PreparedCiphertext` only after successful verification.

2. **Add Ciphertext Validity Proof**: Implement a zero-knowledge proof of knowledge for the randomness used in encryption, ensuring that `ct_g2` components are well-formed.

3. **Use Fujisaki-Okamoto Transform**: Properly implement the FO transform by:
   - Including plaintext hash in the ciphertext
   - Re-encrypting after decryption to verify ciphertext validity
   - Rejecting any ciphertext that doesn't re-encrypt to itself

4. **Constant-Time Failure Handling**: Ensure decryption failures don't leak timing information about which component validation failed.

Fixed code structure:
```rust
// In prepare_individual, add validation:
fn prepare_individual(&self, digest: &Digest, eval_proof: &EvalProof) -> Result<PreparedBIBECiphertext> {
    // Add proof verification here
    self.verify_ciphertext_validity()?;
    
    // Existing pairing operations...
}
```

## Proof of Concept

```rust
#[test]
fn test_cca_attack_on_bibe() {
    use ark_std::rand::thread_rng;
    use aptos_batch_encryption::{
        schemes::fptx::FPTX,
        shared::{
            ciphertext::bibe::{BIBECTEncrypt, BIBECTDecrypt},
            ids::Id,
        },
        traits::BatchThresholdEncryption,
    };
    use aptos_crypto::arkworks::shamir::ShamirThresholdConfig;
    
    let mut rng = thread_rng();
    let tc = ShamirThresholdConfig::new(1, 1);
    let (ek, dk, _, msk_shares) = FPTX::setup_for_testing(rng.gen(), 8, 1, &tc).unwrap();
    
    // Create legitimate ciphertext
    let plaintext = String::from("secret message");
    let id = Id::new(Fr::zero());
    let mut ct = ek.bibe_encrypt(&mut rng, &plaintext, id).unwrap();
    
    // ATTACK: Modify ct_g2[2] component
    ct.ct_g2[2] = (ct.ct_g2[2].into_group() * Fr::from(2u64)).into();
    
    // Prepare digest and proofs
    let mut ids = IdSet::with_capacity(dk.capacity()).unwrap();
    ids.add(&id);
    ids.compute_poly_coeffs();
    let (digest, pfs) = dk.digest(&mut ids, 0).unwrap();
    let pfs = pfs.compute_all(&dk);
    
    // Derive decryption key
    let dk_key = BIBEDecryptionKey::reconstruct(
        &tc,
        &[msk_shares[0].derive_decryption_key_share(&digest).unwrap()]
    ).unwrap();
    
    // Prepare malicious ciphertext - NO VALIDATION OCCURS
    let prepared_ct = ct.prepare(&digest, &pfs).unwrap();
    
    // Attempt decryption - this will fail with observable error
    let result: Result<String> = dk_key.bibe_decrypt(&prepared_ct);
    
    // ORACLE: Attacker observes failure
    assert!(result.is_err()); // SymmetricDecryptionError - observable oracle!
    
    // By trying many modifications and observing failures,
    // attacker can extract key information through adaptive queries
}
```

**Notes**

This vulnerability is particularly critical because:

1. The batch encryption library is used in production consensus code for encrypted transaction processing
2. The `verify()` method exists but is not enforced in the decryption pipeline
3. The reliance on AES-GCM authentication as the sole integrity check creates an exploitable oracle
4. Standard CCA security definitions require that an adversary cannot distinguish between real and random messages even with access to a decryption oracle

The fix requires both API changes (enforcing verification) and cryptographic changes (adding proper validity proofs to achieve CCA security).

### Citations

**File:** crates/aptos-batch-encryption/src/shared/ciphertext/bibe.rs (L92-106)
```rust
    fn prepare_individual(
        &self,
        digest: &Digest,
        eval_proof: &EvalProof,
    ) -> Result<PreparedBIBECiphertext> {
        let pairing_output = PairingSetting::pairing(digest.as_g1(), self.ct_g2[0])
            + PairingSetting::pairing(**eval_proof, self.ct_g2[1]);

        Ok(PreparedBIBECiphertext {
            pairing_output,
            ct_g2: self.ct_g2[2].into(),
            padded_key: self.padded_key.clone(),
            symmetric_ciphertext: self.symmetric_ciphertext.clone(),
        })
    }
```

**File:** crates/aptos-batch-encryption/src/shared/ciphertext/bibe.rs (L156-168)
```rust
    fn bibe_decrypt(&self, ct: &PreparedBIBECiphertext) -> Result<P> {
        let otp_source_1 = PairingSetting::pairing(self.signature_g1, ct.ct_g2.clone());
        let otp_source_gt = otp_source_1 + ct.pairing_output;

        let mut otp_source_bytes = Vec::new();
        otp_source_gt.serialize_compressed(&mut otp_source_bytes)?;
        let otp = OneTimePad::from_source_bytes(otp_source_bytes);

        let symmetric_key = otp.unpad_key(&ct.padded_key);

        symmetric_key.decrypt(&ct.symmetric_ciphertext)
    }
}
```

**File:** consensus/src/pipeline/decryption_pipeline_builder.rs (L126-145)
```rust
                if let Ok(payload) = FPTXWeighted::decrypt_individual::<DecryptedPayload>(
                    &decryption_key.key,
                    &ciphertext,
                    &digest,
                    &eval_proof,
                ) {
                    let (executable, nonce) = payload.unwrap();
                    txn.payload_mut()
                        .as_encrypted_payload_mut()
                        .map(|p| {
                            p.into_decrypted(eval_proof, executable, nonce)
                                .expect("must happen")
                        })
                        .expect("must exist");
                } else {
                    txn.payload_mut()
                        .as_encrypted_payload_mut()
                        .map(|p| p.into_failed_decryption(eval_proof).expect("must happen"))
                        .expect("must exist");
                }
```

**File:** crates/aptos-batch-encryption/src/shared/symmetric.rs (L118-120)
```rust
        let plaintext_bytes = cipher
            .decrypt(&ciphertext.nonce, ciphertext.ct_body.as_ref())
            .map_err(|_| BatchEncryptionError::SymmetricDecryptionError)?;
```

**File:** crates/aptos-batch-encryption/src/shared/ciphertext/mod.rs (L138-144)
```rust
    pub fn prepare(&self, digest: &Digest, eval_proofs: &EvalProofs) -> Result<PreparedCiphertext> {
        Ok(PreparedCiphertext {
            vk: self.vk,
            bibe_ct: self.bibe_ct.prepare(digest, eval_proofs)?,
            signature: self.signature,
        })
    }
```

**File:** types/src/secret_sharing.rs (L16-28)
```rust
pub type EncryptionKey = <FPTXWeighted as BatchThresholdEncryption>::EncryptionKey;
pub type DigestKey = <FPTXWeighted as BatchThresholdEncryption>::DigestKey;
pub type Ciphertext = <FPTXWeighted as BatchThresholdEncryption>::Ciphertext;
pub type Id = <FPTXWeighted as BatchThresholdEncryption>::Id;
pub type Round = <FPTXWeighted as BatchThresholdEncryption>::Round;
pub type Digest = <FPTXWeighted as BatchThresholdEncryption>::Digest;
pub type EvalProofsPromise = <FPTXWeighted as BatchThresholdEncryption>::EvalProofsPromise;
pub type EvalProof = <FPTXWeighted as BatchThresholdEncryption>::EvalProof;
pub type EvalProofs = <FPTXWeighted as BatchThresholdEncryption>::EvalProofs;
pub type MasterSecretKeyShare = <FPTXWeighted as BatchThresholdEncryption>::MasterSecretKeyShare;
pub type VerificationKey = <FPTXWeighted as BatchThresholdEncryption>::VerificationKey;
pub type SecretKeyShare = <FPTXWeighted as BatchThresholdEncryption>::DecryptionKeyShare;
pub type DecryptionKey = <FPTXWeighted as BatchThresholdEncryption>::DecryptionKey;
```

**File:** types/src/transaction/encrypted_payload.rs (L42-64)
```rust
pub enum EncryptedPayload {
    Encrypted {
        ciphertext: Ciphertext,
        extra_config: TransactionExtraConfig,
        payload_hash: HashValue,
    },
    FailedDecryption {
        ciphertext: Ciphertext,
        extra_config: TransactionExtraConfig,
        payload_hash: HashValue,
        eval_proof: EvalProof,
    },
    Decrypted {
        ciphertext: Ciphertext,
        extra_config: TransactionExtraConfig,
        payload_hash: HashValue,
        eval_proof: EvalProof,

        // decrypted things
        executable: TransactionExecutable,
        decryption_nonce: u64,
    },
}
```
