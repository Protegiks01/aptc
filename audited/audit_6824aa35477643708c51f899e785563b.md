# Audit Report

## Title
Feature Flag Bypass in Delegation Pool Governance Voting Allows Unauthorized Operations When Features Are Disabled

## Summary
The Aptos CLI enforces both `PARTIAL_GOVERNANCE_VOTING` and `DELEGATION_POOL_PARTIAL_GOVERNANCE_VOTING` feature flags for delegation pool governance operations, but these global feature flags are not validated on-chain. Attackers can bypass CLI restrictions by submitting transactions directly via SDK/API, allowing governance voting and proposal creation even when the network has disabled these features.

## Finding Description

The delegation pool governance system has a critical mismatch between client-side and on-chain enforcement of feature flags.

**CLI Enforcement (Client-Side Only):** [1](#0-0) 

The `delegation_pool_governance_precheck()` function requires BOTH feature flags to be enabled before allowing governance operations through the CLI.

**On-Chain Enforcement (Missing):** [2](#0-1) 

The on-chain `vote()` function only checks pool-specific state via `assert_partial_governance_voting_enabled(pool_address)`, which verifies that GovernanceRecords exists and the delegated voter is set correctly. [3](#0-2) 

This assertion function only validates pool-level state, not global feature flags. [4](#0-3) 

The `partial_governance_voting_enabled()` check only verifies local pool state, completely ignoring the global feature flags defined in the features module. [5](#0-4) 

**Attack Vector:**

1. Attacker identifies that global feature flags are disabled (either flag #17 or #21)
2. Attacker crafts a raw transaction calling `0x1::delegation_pool::vote()` or `0x1::delegation_pool::create_proposal()` directly
3. Attacker submits via REST API or SDK (bypassing CLI checks)
4. On-chain execution succeeds because Move code never checks global feature flags
5. Governance operations execute when they should be disabled network-wide

**Broken Invariant:**

This violates the **Governance Integrity** invariant: "Feature flags must enforce governance controls consistently across all transaction submission paths." It also breaks the **Access Control** principle that system-wide feature flags should be enforced uniformly.

## Impact Explanation

**Severity: High** - This constitutes a "Significant protocol violation" per the Aptos bug bounty criteria.

**Specific Impacts:**

1. **Governance Circuit Breaker Bypass**: Feature flags serve as emergency circuit breakers. If governance discovers a vulnerability in partial voting and disables the flags, attackers can continue exploiting via direct API calls.

2. **Inconsistent Security Posture**: The network believes a feature is disabled when it remains fully operational, creating false security assumptions.

3. **Policy Enforcement Failure**: Governance decisions to disable features are rendered ineffective for any user bypassing the CLI.

4. **Deterministic Execution Violation**: Different transaction submission paths (CLI vs SDK) have different validation rules, potentially causing consensus nodes to have different views of valid governance operations.

This does not reach Critical severity as it doesn't directly cause loss of funds or consensus failure, but it significantly undermines governance security controls.

## Likelihood Explanation

**Likelihood: High**

1. **Easy to Exploit**: Any user with basic blockchain knowledge can submit transactions via SDK/API
2. **No Special Privileges Required**: Regular delegators can exploit this
3. **Clear Attack Path**: Direct transaction submission is standard practice
4. **Discoverable**: Feature flag states are public, attackers can easily detect when flags are disabled
5. **Incentive Exists**: Governance proposals can have significant economic impact, creating strong motivation to vote when voting should be disabled

The only requirement is that a delegation pool has previously enabled partial governance voting (via `enable_partial_governance_voting()`), which is increasingly common.

## Recommendation

Add on-chain validation of the global feature flags in the delegation pool governance functions:

```move
public entry fun vote(
    voter: &signer,
    pool_address: address,
    proposal_id: u64,
    voting_power: u64,
    should_pass: bool
) acquires DelegationPool, GovernanceRecords, BeneficiaryForOperator, NextCommissionPercentage {
    // ADD: Check global feature flags
    assert!(
        features::delegation_pool_partial_governance_voting_enabled(),
        error::invalid_state(EDISABLED_FUNCTION)
    );
    
    check_stake_management_permission(voter);
    assert_partial_governance_voting_enabled(pool_address);
    // ... rest of function
}

public entry fun create_proposal(
    voter: &signer,
    pool_address: address,
    execution_hash: vector<u8>,
    metadata_location: vector<u8>,
    metadata_hash: vector<u8>,
    is_multi_step_proposal: bool,
) acquires DelegationPool, GovernanceRecords, BeneficiaryForOperator, NextCommissionPercentage {
    // ADD: Check global feature flags
    assert!(
        features::delegation_pool_partial_governance_voting_enabled(),
        error::invalid_state(EDISABLED_FUNCTION)
    );
    
    check_stake_management_permission(voter);
    assert_partial_governance_voting_enabled(pool_address);
    // ... rest of function
}
```

Additionally, consider whether `PARTIAL_GOVERNANCE_VOTING` flag should also be checked, depending on the relationship between regular stake pool and delegation pool governance features.

## Proof of Concept

```move
#[test_only]
module aptos_framework::delegation_pool_feature_flag_bypass_test {
    use std::features;
    use aptos_framework::delegation_pool;
    use aptos_framework::aptos_governance;
    
    #[test(aptos_framework = @aptos_framework, voter = @0x123, pool_owner = @0x456)]
    fun test_vote_bypasses_disabled_feature_flag(
        aptos_framework: &signer,
        voter: &signer,
        pool_owner: &signer,
    ) {
        // Setup: Create delegation pool with partial voting enabled
        delegation_pool::initialize_for_test(pool_owner);
        delegation_pool::enable_partial_governance_voting(signer::address_of(pool_owner));
        
        // Setup: Create a governance proposal
        let proposal_id = aptos_governance::create_test_proposal();
        
        // Disable the feature flag (simulating emergency circuit breaker)
        features::change_feature_flags_for_testing(
            aptos_framework,
            vector[],
            vector[features::get_delegation_pool_partial_governance_voting()]
        );
        
        // Verify flag is disabled
        assert!(!features::delegation_pool_partial_governance_voting_enabled(), 0);
        
        // EXPLOIT: Vote still succeeds via direct function call (bypassing CLI checks)
        delegation_pool::vote(
            voter,
            signer::address_of(pool_owner),
            proposal_id,
            100,
            true
        );
        
        // Vote was processed even though feature flag is disabled
        // This should have failed but didn't
    }
}
```

**Notes:**

The security question asks "which takes precedence?" when the two feature flags return conflicting states. The answer is: **neither takes precedence on-chain because both flags are completely ignored**. The CLI requires both flags to be enabled, but this enforcement can be trivially bypassed by any user submitting transactions through alternative paths (SDK, API, or direct transaction crafting). This represents a fundamental security architecture flaw where critical governance controls exist only at the client layer rather than being enforced at the protocol level where they cannot be circumvented.

### Citations

**File:** crates/aptos/src/governance/delegation_pool.rs (L175-205)
```rust
async fn delegation_pool_governance_precheck(
    txn_options: &TransactionOptions,
    pool_address: AccountAddress,
) -> CliTypedResult<Option<TransactionSummary>> {
    let client = &txn_options
        .rest_options
        .client(&txn_options.profile_options)?;
    if !is_partial_governance_voting_enabled(client).await? {
        return Err(CliError::CommandArgumentError(
            "Partial governance voting feature flag is not enabled".to_string(),
        ));
    };
    if !is_delegation_pool_partial_governance_voting_enabled(client).await? {
        return Err(CliError::CommandArgumentError(
            "Delegation pool partial governance voting feature flag is not enabled".to_string(),
        ));
    };
    if is_partial_governance_voting_enabled_for_delegation_pool(client, pool_address).await? {
        Ok(None)
    } else {
        println!("Partial governance voting for delegation pool {} hasn't been enabled yet. Enabling it now...",
                 pool_address);
        let txn_summary = txn_options
            .submit_transaction(
                aptos_stdlib::delegation_pool_enable_partial_governance_voting(pool_address),
            )
            .await
            .map(TransactionSummary::from)?;
        Ok(Some(txn_summary))
    }
}
```

**File:** aptos-move/framework/aptos-framework/sources/delegation_pool.move (L538-540)
```text
    public fun partial_governance_voting_enabled(pool_address: address): bool {
        exists<GovernanceRecords>(pool_address) && stake::get_delegated_voter(pool_address) == pool_address
    }
```

**File:** aptos-move/framework/aptos-framework/sources/delegation_pool.move (L964-995)
```text
    public entry fun vote(
        voter: &signer,
        pool_address: address,
        proposal_id: u64,
        voting_power: u64,
        should_pass: bool
    ) acquires DelegationPool, GovernanceRecords, BeneficiaryForOperator, NextCommissionPercentage {
        check_stake_management_permission(voter);
        assert_partial_governance_voting_enabled(pool_address);
        // synchronize delegation and stake pools before any user operation.
        synchronize_delegation_pool(pool_address);

        let voter_address = signer::address_of(voter);
        let remaining_voting_power = calculate_and_update_remaining_voting_power(
            pool_address,
            voter_address,
            proposal_id
        );
        if (voting_power > remaining_voting_power) {
            voting_power = remaining_voting_power;
        };
        aptos_governance::assert_proposal_expiration(pool_address, proposal_id);
        assert!(voting_power > 0, error::invalid_argument(ENO_VOTING_POWER));

        let governance_records = borrow_global_mut<GovernanceRecords>(pool_address);
        // Check a edge case during the transient period of enabling partial governance voting.
        assert_and_update_proposal_used_voting_power(governance_records, pool_address, proposal_id, voting_power);
        let used_voting_power = borrow_mut_used_voting_power(governance_records, voter_address, proposal_id);
        *used_voting_power = *used_voting_power + voting_power;

        let pool_signer = retrieve_stake_pool_owner(borrow_global<DelegationPool>(pool_address));
        aptos_governance::partial_vote(&pool_signer, pool_address, proposal_id, voting_power, should_pass);
```

**File:** aptos-move/framework/aptos-framework/sources/delegation_pool.move (L1098-1104)
```text
    fun assert_partial_governance_voting_enabled(pool_address: address) {
        assert_delegation_pool_exists(pool_address);
        assert!(
            partial_governance_voting_enabled(pool_address),
            error::invalid_state(EPARTIAL_GOVERNANCE_VOTING_NOT_ENABLED)
        );
    }
```

**File:** aptos-move/framework/move-stdlib/sources/configs/features.move (L197-217)
```text
    const PARTIAL_GOVERNANCE_VOTING: u64 = 17;

    public fun get_partial_governance_voting(): u64 { PARTIAL_GOVERNANCE_VOTING }

    public fun partial_governance_voting_enabled(): bool acquires Features {
        is_enabled(PARTIAL_GOVERNANCE_VOTING)
    }

    /// Charge invariant violation error.
    /// Lifetime: transient
    const CHARGE_INVARIANT_VIOLATION: u64 = 20;

    /// Whether enable paritial governance voting on delegation_pool.
    /// Lifetime: transient
    const DELEGATION_POOL_PARTIAL_GOVERNANCE_VOTING: u64 = 21;

    public fun get_delegation_pool_partial_governance_voting(): u64 { DELEGATION_POOL_PARTIAL_GOVERNANCE_VOTING }

    public fun delegation_pool_partial_governance_voting_enabled(): bool acquires Features {
        is_enabled(DELEGATION_POOL_PARTIAL_GOVERNANCE_VOTING)
    }
```
