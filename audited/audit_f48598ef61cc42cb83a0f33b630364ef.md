# Audit Report

## Title
Missing Configuration Sanitizer for Peer Information Disclosure on Mainnet Validators Enables Network Reconnaissance Attacks

## Summary
The inspection service's peer information endpoint lacks a configuration sanitizer to prevent mainnet validators from exposing sensitive network topology data. While a sanitizer explicitly forbids exposing node configuration on mainnet validators, no equivalent protection exists for peer information disclosure, creating an inconsistent security policy that enables network reconnaissance and targeted attacks.

## Finding Description

The inspection service exposes detailed peer information via the `/peer_information` endpoint, which displays all connected peer IDs, network addresses, connection metadata, and network topology at line 182. [1](#0-0) 

The `expose_peer_information` configuration flag defaults to `true` [2](#0-1)  and the service binds to all network interfaces by default. [3](#0-2) 

**Critical Security Gap:** The configuration sanitizer explicitly prevents mainnet validators from exposing their node configuration [4](#0-3)  but contains NO equivalent check for `expose_peer_information`. This creates an inconsistent security policy where arguably more sensitive information (real-time network topology, peer IPs, connection states) lacks the same protection as static configuration data.

The endpoint exposes:
- All connected peer IDs with network classifications (Validator/VFN/Public) [1](#0-0) 
- Connection metadata including network addresses (IP:port) [5](#0-4) 
- Trusted peer lists (validator set and seeds) [6](#0-5) 
- State sync metadata with peer scores and priorities [7](#0-6) 

While validator network addresses are public on-chain in the ValidatorConfig [8](#0-7)  the inspection service reveals significantly more: real-time connections, dynamic topology, actual peer IPs (not just configured addresses), connection states, and peer selection/scoring mechanisms.

**Attack Scenario:** An attacker queries `/peer_information` on multiple mainnet validators that failed to disable this endpoint (due to lack of enforced sanitization), maps the entire P2P network topology, identifies validator IP addresses, correlates peer identities across networks, and uses this intelligence to plan targeted eclipse attacks, DDoS campaigns, or validator deanonymization.

## Impact Explanation

**High Severity** under Aptos bug bounty criteria: This vulnerability enables attacks that could cause "Validator node slowdowns" and "Significant protocol violations."

The exposed information facilitates:
1. **Targeted DDoS Attacks:** Real IP addresses enable focused denial-of-service attacks on specific validators
2. **Eclipse Attacks:** Network topology knowledge enables isolation of validators from the honest network
3. **Validator Deanonymization:** Cross-network correlation compromises operational security
4. **Network Reconnaissance:** Complete P2P topology mapping aids sophisticated attacks
5. **Peer Selection Manipulation:** Understanding peer scoring enables Sybil attack planning

While not directly causing consensus violations, the information disclosure enables attacks that degrade network performance, compromise validator availability, and violate protocol security assumptions about network topology confidentiality.

## Likelihood Explanation

**Medium-High Likelihood:**

- **Easy Exploitation:** Simple HTTP GET request with no authentication required [9](#0-8) 
- **Default Configuration Risk:** Endpoint enabled by default, requires manual disabling [2](#0-1) 
- **No Enforcement:** Missing sanitizer means no automatic protection for mainnet validators
- **Mitigating Factors:** Production deployments (Docker, Kubernetes) typically implement external access controls through port binding restrictions [10](#0-9)  and network policies [11](#0-10) 

However, the vulnerability manifests when validators deploy without proper external controls (bare metal deployments, misconfigured firewalls, custom infrastructure) or when operators are unaware of the security implications.

## Recommendation

Add a configuration sanitizer for `expose_peer_information` that mirrors the existing protection for `expose_configuration`: [12](#0-11) 

The fix should add an additional check within the `ConfigSanitizer::sanitize()` implementation:

```rust
// Verify that mainnet validators do not expose peer information
if let Some(chain_id) = chain_id {
    if node_type.is_validator()
        && chain_id.is_mainnet()
        && inspection_service_config.expose_peer_information
    {
        return Err(Error::ConfigSanitizerFailed(
            sanitizer_name,
            "Mainnet validators should not expose peer information!".to_string(),
        ));
    }
}
```

Additionally, consider:
1. Changing the default to `expose_peer_information: false` for production builds
2. Adding security documentation warning about this endpoint
3. Implementing authentication for the inspection service (similar to the admin service pattern)

## Proof of Concept

**Step 1:** Deploy a mainnet validator with default inspection service configuration:

```yaml
# validator.yaml
inspection_service:
  address: "0.0.0.0"
  port: 9101
  expose_peer_information: true  # Default, no sanitizer prevents this
```

**Step 2:** Query the peer information endpoint from an external attacker:

```bash
curl http://<validator-ip>:9101/peer_information
```

**Expected Output:** Detailed peer information including:
- All connected peer IDs with network types
- IP addresses and ports of connected peers
- Network topology and connection metadata
- Trusted peer lists (validator set)
- State sync metadata with peer scores

**Observed Behavior:** The endpoint returns this sensitive information without authentication, enabling network reconnaissance despite being a mainnet validator.

**Demonstration that sanitizer is missing:**

The `ConfigSanitizer` implementation only checks `expose_configuration` [4](#0-3)  but performs no validation on `expose_peer_information`, allowing mainnet validators to expose this endpoint contrary to security best practices.

## Notes

This vulnerability represents a **defense-in-depth failure** where security relies solely on external infrastructure controls (Docker port binding, Kubernetes NetworkPolicy) rather than code-level enforcement. The inconsistency between protecting configuration exposure while leaving peer information unprotected suggests an incomplete security policy implementation. While validator network addresses are public on-chain, the inspection service reveals significantly more sensitive real-time operational data including dynamic topology, actual connections, and peer selection metadata that could enable sophisticated attacks against the network.

### Citations

**File:** crates/aptos-inspection-service/src/server/peer_information.rs (L21-37)
```rust
pub fn handle_peer_information_request(
    node_config: &NodeConfig,
    aptos_data_client: AptosDataClient,
    peers_and_metadata: Arc<PeersAndMetadata>,
) -> (StatusCode, Body, String) {
    // Only return peer information if the endpoint is enabled
    let (status_code, body) = if node_config.inspection_service.expose_peer_information {
        let peer_information = get_peer_information(aptos_data_client, peers_and_metadata);
        (StatusCode::OK, Body::from(peer_information))
    } else {
        (
            StatusCode::FORBIDDEN,
            Body::from(PEER_INFO_DISABLED_MESSAGE),
        )
    };

    (status_code, body, CONTENT_TYPE_TEXT.into())
```

**File:** crates/aptos-inspection-service/src/server/peer_information.rs (L148-167)
```rust
/// Displays connection metadata for each peer
fn display_peer_connection_metadata(
    peer_information_output: &mut Vec<String>,
    all_peers: &Vec<PeerNetworkId>,
    peers_and_metadata: &PeersAndMetadata,
) {
    peer_information_output.push("Connection metadata for each peer:".into());

    // Fetch and display the connection metadata for each peer
    for peer in all_peers {
        if let Ok(peer_metadata) = peers_and_metadata.get_metadata_for_peer(*peer) {
            let connection_metadata = peer_metadata.get_connection_metadata();
            peer_information_output.push(format!(
                "\t- Peer: {}, connection state: {:?}, connection metadata: {}",
                peer,
                peer_metadata.get_connection_state(),
                serde_json::to_string(&connection_metadata).unwrap_or_default()
            ));
        }
    }
```

**File:** crates/aptos-inspection-service/src/server/peer_information.rs (L182-182)
```rust
    peer_information_output.push(format!("\t- Peers and network IDs: {:?}", all_peers));
```

**File:** crates/aptos-inspection-service/src/server/peer_information.rs (L205-271)
```rust
/// Displays state sync metadata for each peer
fn display_state_sync_metadata(
    peer_information_output: &mut Vec<String>,
    all_peers: &Vec<PeerNetworkId>,
    aptos_data_client: AptosDataClient,
) {
    peer_information_output.push("State sync metadata for each peer:".into());

    // Fetch and display the priority and regular peers
    if let Ok((priority_peers, regular_peers)) = aptos_data_client.get_priority_and_regular_peers()
    {
        // Sort the peer lists before displaying them
        let mut priority_peers: Vec<_> = priority_peers.into_iter().collect();
        priority_peers.sort();
        let mut regular_peers: Vec<_> = regular_peers.into_iter().collect();
        regular_peers.sort();

        // Display the priority and regular peers
        peer_information_output.push(format!(
            "\t- Priority peers: {:?}, regular peers: {:?}",
            priority_peers, regular_peers
        ));
    }

    // Fetch and display the global advertised data summary
    let global_data_summary = aptos_data_client.get_global_data_summary();
    peer_information_output.push(format!(
        "\t- Global advertised data summary: {:?}",
        global_data_summary
    ));

    // Fetch and display the state sync metadata for each peer
    let peer_to_state = aptos_data_client.get_peer_states().get_peer_to_states();
    for peer in all_peers {
        if let Some(peer_state_entry) = peer_to_state.get(peer) {
            // Get the peer states
            let peer = *peer_state_entry.key();
            let peer_bucket_id = peer_states::get_bucket_id_for_peer(peer);
            let peer_score = peer_state_entry.get_score();
            let peer_storage_summary = peer_state_entry.get_storage_summary();

            // Display the peer states
            peer_information_output.push(format!(
                "\t- Peer: {}, score: {}, bucket ID: {}",
                peer, peer_score, peer_bucket_id
            ));
            peer_information_output.push(format!(
                "\t\t- Advertised storage summary: {:?}",
                peer_storage_summary
            ));

            // Get the peer's request/response counts
            let sent_requests_by_type = peer_state_entry.get_sent_requests_by_type();
            let received_responses_by_type = peer_state_entry.get_received_responses_by_type();

            // Display the peer's request/response counts
            peer_information_output.push(format!(
                "\t\t- Sent requests by type: {:?}",
                sent_requests_by_type
            ));
            peer_information_output.push(format!(
                "\t\t- Received responses by type: {:?}",
                received_responses_by_type
            ));
        }
    }
}
```

**File:** crates/aptos-inspection-service/src/server/peer_information.rs (L273-299)
```rust
/// Displays the entire set of trusted peers
fn display_trusted_peers(
    peer_information_output: &mut Vec<String>,
    registered_networks: Vec<NetworkId>,
    peers_and_metadata: &PeersAndMetadata,
) {
    peer_information_output.push("Trusted peers (validator set & seeds):".into());

    // Fetch and display the trusted peers for each network
    for network in registered_networks {
        peer_information_output.push(format!("\t- Network: {}", network));
        if let Ok(trusted_peers) = peers_and_metadata.get_trusted_peers(&network) {
            // Sort the peers before displaying them
            let mut sorted_trusted_peers = BTreeMap::new();
            for (peer_id, peer_info) in trusted_peers {
                sorted_trusted_peers.insert(peer_id, peer_info);
            }

            // Display the trusted peers
            for (peer_id, peer_info) in sorted_trusted_peers {
                peer_information_output.push(format!(
                    "\t\t- Peer: {:?}, peer information: {:?}",
                    peer_id, peer_info
                ));
            }
        }
    }
```

**File:** config/src/config/inspection_service_config.rs (L29-29)
```rust
            address: "0.0.0.0".to_string(),
```

**File:** config/src/config/inspection_service_config.rs (L33-33)
```rust
            expose_peer_information: true,
```

**File:** config/src/config/inspection_service_config.rs (L45-68)
```rust
impl ConfigSanitizer for InspectionServiceConfig {
    fn sanitize(
        node_config: &NodeConfig,
        node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();
        let inspection_service_config = &node_config.inspection_service;

        // Verify that mainnet validators do not expose the configuration
        if let Some(chain_id) = chain_id {
            if node_type.is_validator()
                && chain_id.is_mainnet()
                && inspection_service_config.expose_configuration
            {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "Mainnet validators should not expose the node configuration!".to_string(),
                ));
            }
        }

        Ok(())
    }
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L161-168)
```text
    struct ValidatorConfig has key, copy, store, drop {
        consensus_pubkey: vector<u8>,
        network_addresses: vector<u8>,
        // to make it compatible with previous definition, remove later
        fullnode_addresses: vector<u8>,
        // Index in the active set if the validator corresponding to this stake pool is active.
        validator_index: u64,
    }
```

**File:** docker/compose/aptos-node/docker-compose.yaml (L32-32)
```yaml
      - "127.0.0.1:9101:9101"
```

**File:** terraform/helm/aptos-node/templates/networkpolicy.yaml (L38-56)
```yaml
  # Monitoring metrics port
  - from:
    - namespaceSelector: {}
    - podSelector:
        matchLabels:
          app.kubernetes.io/name: monitoring
    ports:
    - protocol: TCP
      port: 9101
  # Node Health Checker accesses these ports
  - from:
    - namespaceSelector: {}
    - podSelector:
        matchLabels:
          app.kubernetes.io/name: node-health-checker
    ports:
    - protocol: TCP
      port: 9101
    - protocol: TCP
```
