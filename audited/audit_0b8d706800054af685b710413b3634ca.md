# Audit Report

## Title
Missing Groth16 Verification Key Validation Allows Potential Validator Crash via Malicious Governance Proposal

## Summary
The `validate_groth16_vk()` function exists in the Move code to validate Groth16 verification key points before they are set on-chain, but this validation is never called in the governance flow. If arkworks' `deserialize_compressed()` function can panic on certain malformed inputs (rather than returning an error), a malicious governance proposal could crash all validators simultaneously during block execution, causing complete network halt.

## Finding Description

The keyless authentication system uses a Groth16 verification key stored on-chain. When a governance proposal updates this key via `set_groth16_verification_key_for_next_epoch()`, no validation is performed. [1](#0-0) 

A validation function `validate_groth16_vk()` exists that checks if all BN254 curve points deserialize correctly: [2](#0-1) 

However, this validation is **never invoked** in the actual code paths. The `on_new_epoch()` function that activates the new key does not call validation: [3](#0-2) 

During block execution, the environment is created by calling `AptosEnvironment::new_with_delayed_field_optimization_enabled()`: [4](#0-3) 

Inside environment creation, the verification key is fetched and converted to `PreparedVerifyingKey`: [5](#0-4) 

The conversion calls arkworks' `deserialize_compressed()` on potentially malicious data: [6](#0-5) 

The comment at line 70-73 claims "we already validate the points when we set the VK in Move", but this is **false** - the validation function is never called. [7](#0-6) 

**Attack Path:**
1. Attacker crafts malformed byte sequences for G1/G2 points that trigger panics in arkworks deserialization
2. Submits governance proposal with malicious `Groth16VerificationKey`
3. Proposal passes governance vote
4. During epoch transition, `on_new_epoch()` activates the malicious key
5. At start of next block, all validators create `AptosEnvironment`
6. Arkworks `deserialize_compressed()` panics on malformed data
7. All validators crash simultaneously, causing complete network halt

## Impact Explanation

**Severity: Critical** if arkworks can panic; **Medium** if it only returns errors.

- **If arkworks panics:** This breaks the **Deterministic Execution** and **Consensus Safety** invariants. All validators would crash simultaneously during block execution, causing **Total loss of liveness/network availability** requiring manual intervention. This meets Critical severity criteria (up to $1,000,000).

- **If arkworks returns errors:** The error is caught by `.map_err()` and `.ok()`, resulting in `keyless_pvk = None`. Keyless transactions would fail but validators wouldn't crash. This would be a **significant protocol violation** meeting High severity criteria.

The missing validation clearly violates defense-in-depth principles and the misleading comment suggests a security assumption that is not enforced.

## Likelihood Explanation

**Likelihood: Medium to Low**

Requirements for exploitation:
- Requires successful governance proposal (high bar for untrusted attackers)
- Requires knowledge of specific byte sequences that trigger arkworks panics
- Depends on whether arkworks actually can panic vs. returning errors

However, the vulnerability is **guaranteed to exist** in the code structure (missing validation), even if exploitability depends on arkworks implementation details.

## Recommendation

**Immediate fix:** Call `validate_groth16_vk()` before setting the key:

```move
public fun set_groth16_verification_key_for_next_epoch(fx: &signer, vk: Groth16VerificationKey) {
    system_addresses::assert_aptos_framework(fx);
    // ADD THIS LINE:
    validate_groth16_vk(&vk);
    config_buffer::upsert<Groth16VerificationKey>(vk);
}
```

**Additional hardening:**
1. Add panic catching around arkworks deserialization in Rust:
```rust
use std::panic::catch_unwind;

let result = catch_unwind(|| {
    vk.try_into()
});
match result {
    Ok(Ok(pvk)) => Some(pvk),
    _ => None
}
```

2. Add explicit byte length checks before deserialization
3. Add fuzzing tests for malformed verification key inputs

## Proof of Concept

The following Move test demonstrates that the validation function exists but is not called:

```move
#[test(fx = @aptos_framework)]
fun test_malicious_vk_not_validated(fx: &signer) {
    // Create a VK with invalid (all-zero) G1 point
    let malicious_vk = new_groth16_verification_key(
        vector[0u8; 32],  // Invalid alpha_g1
        vector[0u8; 64],  // Invalid beta_g2
        vector[0u8; 64],  // Invalid gamma_g2
        vector[0u8; 64],  // Invalid delta_g2
        vector[vector[0u8; 32], vector[0u8; 32]]  // Invalid gamma_abc_g1
    );
    
    // This should fail if validation were called, but it succeeds
    set_groth16_verification_key_for_next_epoch(fx, malicious_vk);
    
    // The malicious VK is now queued and will be activated on next epoch
    // When validators try to deserialize it, behavior depends on arkworks implementation
}
```

The crash would occur in Rust during the next block's environment creation when arkworks attempts to deserialize the malformed points.

## Notes

The exploitability of this vulnerability depends critically on whether arkworks' `deserialize_compressed()` can panic on malformed inputs. The arkworks library is designed to return `Result<Self, SerializationError>`, but implementation bugs or edge cases could still cause panics. Without access to arkworks source code or concrete panic-triggering inputs, the actual exploitability cannot be definitively confirmed.

However, the **design flaw is unquestionable**: a validation function exists, a comment claims it's being used, but it's never actually called. This violates security best practices and creates unnecessary risk.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/keyless_account.move (L183-192)
```text
    fun validate_groth16_vk(vk: &Groth16VerificationKey) {
        // Could be leveraged to speed up the VM deserialization of the VK by 2x, since it can assume the points are valid.
        assert!(option::is_some(&crypto_algebra::deserialize<bn254_algebra::G1, bn254_algebra::FormatG1Compr>(&vk.alpha_g1)), E_INVALID_BN254_G1_SERIALIZATION);
        assert!(option::is_some(&crypto_algebra::deserialize<bn254_algebra::G2, bn254_algebra::FormatG2Compr>(&vk.beta_g2)), E_INVALID_BN254_G2_SERIALIZATION);
        assert!(option::is_some(&crypto_algebra::deserialize<bn254_algebra::G2, bn254_algebra::FormatG2Compr>(&vk.gamma_g2)), E_INVALID_BN254_G2_SERIALIZATION);
        assert!(option::is_some(&crypto_algebra::deserialize<bn254_algebra::G2, bn254_algebra::FormatG2Compr>(&vk.delta_g2)), E_INVALID_BN254_G2_SERIALIZATION);
        for (i in 0..vector::length(&vk.gamma_abc_g1)) {
            assert!(option::is_some(&crypto_algebra::deserialize<bn254_algebra::G1, bn254_algebra::FormatG1Compr>(vector::borrow(&vk.gamma_abc_g1, i))), E_INVALID_BN254_G1_SERIALIZATION);
        };
    }
```

**File:** aptos-move/framework/aptos-framework/sources/keyless_account.move (L263-266)
```text
    public fun set_groth16_verification_key_for_next_epoch(fx: &signer, vk: Groth16VerificationKey) {
        system_addresses::assert_aptos_framework(fx);
        config_buffer::upsert<Groth16VerificationKey>(vk);
    }
```

**File:** aptos-move/framework/aptos-framework/sources/keyless_account.move (L358-378)
```text
    public(friend) fun on_new_epoch(fx: &signer) acquires Groth16VerificationKey, Configuration {
        system_addresses::assert_aptos_framework(fx);

        if (config_buffer::does_exist<Groth16VerificationKey>()) {
            let vk = config_buffer::extract_v2();
            if (exists<Groth16VerificationKey>(@aptos_framework)) {
                *borrow_global_mut<Groth16VerificationKey>(@aptos_framework) = vk;
            } else {
                move_to(fx, vk);
            }
        };

        if (config_buffer::does_exist<Configuration>()) {
            let config = config_buffer::extract_v2();
            if (exists<Configuration>(@aptos_framework)) {
                *borrow_global_mut<Configuration>(@aptos_framework) = config;
            } else {
                move_to(fx, config);
            }
        };
    }
```

**File:** aptos-move/block-executor/src/code_cache_global_manager.rs (L211-213)
```rust
        // Get the current environment from storage.
        let storage_environment =
            AptosEnvironment::new_with_delayed_field_optimization_enabled(&state_view);
```

**File:** aptos-move/aptos-vm-environment/src/environment.rs (L289-293)
```rust
        let keyless_pvk =
            Groth16VerificationKey::fetch_keyless_config(state_view).and_then(|(vk, vk_bytes)| {
                sha3_256.update(&vk_bytes);
                vk.try_into().ok()
            });
```

**File:** types/src/keyless/groth16_vk.rs (L62-91)
```rust
impl TryFrom<&Groth16VerificationKey> for PreparedVerifyingKey<Bn254> {
    type Error = CryptoMaterialError;

    fn try_from(vk: &Groth16VerificationKey) -> Result<Self, Self::Error> {
        if vk.gamma_abc_g1.len() != 2 {
            return Err(CryptoMaterialError::DeserializationError);
        }

        // NOTE: Technically, we already validate the points when we set the VK in Move, so we could
        // make this 2x faster by avoiding the point validation checks  via
        // `deserialize_with_mode(..., Compress::Yes, Validate::No)`. Due to paranoia, will not
        // optimize this for now.
        Ok(Self::from(VerifyingKey {
            alpha_g1: G1Affine::deserialize_compressed(vk.alpha_g1.as_slice())
                .map_err(|_| CryptoMaterialError::DeserializationError)?,
            beta_g2: G2Affine::deserialize_compressed(vk.beta_g2.as_slice())
                .map_err(|_| CryptoMaterialError::DeserializationError)?,
            gamma_g2: G2Affine::deserialize_compressed(vk.gamma_g2.as_slice())
                .map_err(|_| CryptoMaterialError::DeserializationError)?,
            delta_g2: G2Affine::deserialize_compressed(vk.delta_g2.as_slice())
                .map_err(|_| CryptoMaterialError::DeserializationError)?,
            gamma_abc_g1: vec![
                G1Affine::deserialize_compressed(vk.gamma_abc_g1[0].as_slice())
                    .map_err(|_| CryptoMaterialError::DeserializationError)?,
                G1Affine::deserialize_compressed(vk.gamma_abc_g1[1].as_slice())
                    .map_err(|_| CryptoMaterialError::DeserializationError)?,
            ],
        }))
    }
}
```
