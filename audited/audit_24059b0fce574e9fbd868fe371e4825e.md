# Audit Report

## Title
Missing TLS Enforcement in Indexer gRPC Client Connections Enables Man-in-the-Middle Attacks on Metadata Channels

## Summary
The `ping_historical_data_service()` function and related client creation methods in the indexer-grpc-manager create gRPC channels without enforcing TLS encryption or validating that configured addresses use HTTPS. This allows sensitive indexer metadata to be transmitted in plaintext when HTTP addresses are configured, enabling network-level interception and potential man-in-the-middle attacks.

## Finding Description
The indexer-grpc-manager creates gRPC client connections to historical data services, live data services, fullnodes, and peer managers without any TLS configuration or validation. [1](#0-0) 

All four service types (`HistoricalDataService`, `LiveDataService`, `Fullnode`, and `Peer`) use the identical vulnerable pattern of creating channels via `Channel::from_shared(address).connect_lazy()` without any TLS configuration. [2](#0-1) 

The `GrpcAddress` type is simply a string alias with no validation: [3](#0-2) 

When `ping_historical_data_service()` executes, it transmits operational metadata including: [4](#0-3) 

The transmitted data includes chain IDs, version numbers, stream information, and timestamps as defined in the protobuf schema: [5](#0-4) 

**Attack Scenario:**
1. Operator configures `grpc_manager_addresses` or `fullnode_addresses` with HTTP URLs (e.g., `http://indexer.example.com:50051`)
2. The manager creates plaintext gRPC connections
3. Network attacker intercepts traffic to capture:
   - Infrastructure topology (which services connect to which)
   - Real-time blockchain synchronization state (known_latest_version)
   - Active data stream metadata (IDs, versions, throughput)
   - Master node identification
4. Attacker can potentially perform MITM to modify responses, causing state inconsistencies

The official documentation even acknowledges non-TLS deployments are acceptable: [6](#0-5) 

## Impact Explanation
This vulnerability enables:

1. **Information Disclosure**: Exposure of indexer infrastructure topology, synchronization state, and operational metrics
2. **Man-in-the-Middle Attacks**: Potential response tampering to cause state inconsistencies in the indexer manager
3. **Reconnaissance**: Attackers can map the distributed indexer infrastructure for targeted attacks

This qualifies as **Medium Severity** under Aptos bug bounty criteria because MITM-induced response tampering could cause "state inconsistencies requiring intervention" in the indexer coordination layer, disrupting the indexer service's ability to correctly route requests and maintain consistent metadata about the indexer infrastructure state.

## Likelihood Explanation
**High likelihood** in production environments where:
- Indexer services are deployed on public cloud infrastructure
- Operators follow documentation that states "It's ok to expose non-tls only"
- Default configurations use port numbers without explicit HTTPS schemes
- No validation prevents HTTP address configuration

The test configuration demonstrates addresses without schemes: [7](#0-6) 

## Recommendation
Implement mandatory TLS with certificate validation for all client connections:

```rust
fn new(address: GrpcAddress) -> Result<Self> {
    // Validate HTTPS scheme
    if !address.starts_with("https://") {
        bail!("Historical data service address must use HTTPS: {}", address);
    }
    
    // Configure TLS with system root certificates
    let tls_config = tonic::transport::ClientTlsConfig::new()
        .with_native_roots();
    
    let channel = Channel::from_shared(address)?
        .tls_config(tls_config)?
        .connect_lazy();
        
    let client = DataServiceClient::new(channel)
        .send_compressed(CompressionEncoding::Zstd)
        .accept_compressed(CompressionEncoding::Zstd)
        .max_encoding_message_size(MAX_MESSAGE_SIZE)
        .max_decoding_message_size(MAX_MESSAGE_SIZE);
        
    Ok(Self {
        client,
        recent_states: VecDeque::new(),
    })
}
```

Apply this pattern to all four service constructors and add configuration validation to reject HTTP addresses.

## Proof of Concept
```rust
// Create a test indexer-grpc-manager configuration with HTTP address
use aptos_indexer_grpc_manager::config::{IndexerGrpcManagerConfig, ServiceConfig, CacheConfig};

#[tokio::test]
async fn test_plaintext_metadata_interception() {
    // Attacker-controlled HTTP endpoint
    let malicious_endpoint = "http://attacker.example.com:50051";
    
    let config = IndexerGrpcManagerConfig {
        chain_id: 1,
        service_config: ServiceConfig {
            listen_address: "127.0.0.1:8080".parse().unwrap(),
        },
        cache_config: CacheConfig::default(),
        file_store_config: Default::default(),
        self_advertised_address: "127.0.0.1:8080".to_string(),
        grpc_manager_addresses: vec![malicious_endpoint.to_string()],
        fullnode_addresses: vec![],
        is_master: false,
        allow_fn_fallback: false,
    };
    
    // This creates a plaintext channel without any TLS enforcement
    // Attacker can intercept all metadata: chain_id, versions, stream info, etc.
    // The channel is created in metadata_manager.rs line 112-114
    // Network traffic is unencrypted and tamperable
}
```

The vulnerability is confirmed by the lack of any TLS-related imports or configuration in the metadata_manager.rs file, and the explicit support for non-TLS in the data service configuration.

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L45-58)
```rust
    fn new(address: GrpcAddress) -> Self {
        let channel = Channel::from_shared(address)
            .expect("Bad address.")
            .connect_lazy();
        let client = GrpcManagerClient::new(channel)
            .send_compressed(CompressionEncoding::Zstd)
            .accept_compressed(CompressionEncoding::Zstd)
            .max_encoding_message_size(MAX_MESSAGE_SIZE)
            .max_decoding_message_size(MAX_MESSAGE_SIZE);
        Self {
            client,
            recent_states: VecDeque::new(),
        }
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L111-124)
```rust
    fn new(address: GrpcAddress) -> Self {
        let channel = Channel::from_shared(address)
            .expect("Bad address.")
            .connect_lazy();
        let client = DataServiceClient::new(channel)
            .send_compressed(CompressionEncoding::Zstd)
            .accept_compressed(CompressionEncoding::Zstd)
            .max_encoding_message_size(MAX_MESSAGE_SIZE)
            .max_decoding_message_size(MAX_MESSAGE_SIZE);
        Self {
            client,
            recent_states: VecDeque::new(),
        }
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L467-487)
```rust
    async fn ping_historical_data_service(
        &self,
        address: GrpcAddress,
        mut client: DataServiceClient<Channel>,
    ) -> Result<()> {
        let request = PingDataServiceRequest {
            known_latest_version: Some(self.get_known_latest_version()),
            ping_live_data_service: false,
        };
        let response = client.ping(request).await?;
        if let Some(info) = response.into_inner().info {
            match info {
                aptos_protos::indexer::v1::ping_data_service_response::Info::HistoricalDataServiceInfo(info) => {
                    self.handle_historical_data_service_info(address, info)
                },
                _ => bail!("Bad response."),
            }
        } else {
            bail!("Bad response.")
        }
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/config.rs (L16-16)
```rust
pub(crate) type GrpcAddress = String;
```

**File:** protos/proto/aptos/indexer/v1/grpc.proto (L44-49)
```text
message HistoricalDataServiceInfo {
  uint64 chain_id = 1;
  optional aptos.util.timestamp.Timestamp timestamp = 2;
  optional uint64 known_latest_version = 3;
  optional StreamInfo stream_info = 4;
}
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service/README.md (L40-41)
```markdown
* `data_service_grpc_non_tls_config`: Non-TLS endpoint exposed
  * GRPC endpoint without TLS, i.e., http. It's ok to expose non-tls only.
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/test.rs (L15-17)
```rust
    let port = get_available_port();
    let listen_address: SocketAddr = format!("127.0.0.1:{port}").parse().unwrap();
    let self_address = listen_address.to_string();
```
