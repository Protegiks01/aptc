# Audit Report

## Title
Indexer Split-Brain Status Tracking Vulnerability Due to Missing Migration Between ProcessorStatus and ProcessorStatusV2

## Summary
The Aptos indexer simultaneously writes to two separate database tables for tracking processor status (`processor_statuses` and `processor_status`), but only reads from the newer table during startup. This creates a version compatibility issue where older indexer versions writing only to `processor_statuses` can cause newer versions to restart indexing from version 0, resulting in duplicate processing and state inconsistencies.

## Finding Description

The indexer codebase maintains two separate processor status tracking systems:

1. **Old system (`processor_statuses`)**: Tracks every individual version processed with composite primary key `(name, version)` [1](#0-0) 

2. **New system (`processor_status`)**: Tracks only the last successful version per processor with primary key `processor` [2](#0-1) 

The current codebase writes to BOTH tables simultaneously:
- Old table updates occur in `TransactionProcessor::apply_processor_status()` [3](#0-2) 
- New table updates occur in `Tailer::update_last_processed_version()` [4](#0-3) 

However, at startup, the runtime **only** reads from the new table using `get_start_version()` [5](#0-4) 

The vulnerability occurs when:
1. An older indexer version runs that only writes to `processor_statuses` (before ProcessorStatusV2 was introduced)
2. The indexer processes transactions up to version N
3. A newer indexer version starts that reads from `processor_status` table
4. The new table is empty, so `get_start_version()` returns `None` [6](#0-5) 
5. Runtime defaults to version 0 and re-indexes all transactions [5](#0-4) 

The old model is explicitly marked as deprecated [7](#0-6)  but no migration exists to transfer data between tables, and no fallback logic checks the old table if the new one is empty.

## Impact Explanation

This qualifies as **Medium Severity** under the Aptos bug bounty criteria as "State inconsistencies requiring intervention." While the indexer is an off-chain component and doesn't affect blockchain consensus, the impact includes:

1. **Data Integrity Issues**: Re-indexing from version 0 can cause duplicate entries, conflicting data, or primary key violations in dependent tables
2. **API Service Disruption**: Applications relying on indexed data will receive incorrect or inconsistent results
3. **Operational Downtime**: Manual database intervention required to resolve conflicts and restore correct state
4. **Resource Exhaustion**: Re-processing millions of transactions wastes computational resources and database capacity

While this doesn't affect validator operations or consensus, it impacts data availability guarantees for ecosystem applications depending on the indexer API.

## Likelihood Explanation

**Likelihood: High** in version upgrade scenarios:

- Occurs during standard operational procedures (version upgrades)
- No malicious intent required - happens automatically
- Affects any deployment that:
  - Upgrades from pre-ProcessorStatusV2 versions
  - Has existing data in `processor_statuses` table
  - Doesn't manually create/populate `processor_status` table
- The deprecated comment indicates active migration is planned, increasing probability of version skew

## Recommendation

Implement a fallback mechanism that checks the old table when the new table is empty:

```rust
pub fn get_start_version(&self, processor_name: &String) -> Result<Option<i64>> {
    let mut conn = self.connection_pool.get()?;
    
    // Try to get from new table first
    match ProcessorStatusV2Query::get_by_processor(processor_name, &mut conn)? {
        Some(status) => Ok(Some(status.last_success_version + 1)),
        None => {
            // Fallback: check old table for backward compatibility
            let max_version = dsl::processor_statuses
                .filter(dsl::name.eq(processor_name))
                .filter(dsl::success.eq(true))
                .select(diesel::dsl::max(dsl::version))
                .first::<Option<i64>>(&mut conn)?;
            
            match max_version {
                Some(Some(v)) => {
                    // Migrate the max version to new table
                    let status = ProcessorStatusV2 {
                        processor: processor_name.clone(),
                        last_success_version: v,
                    };
                    diesel::insert_into(processor_status::table)
                        .values(&status)
                        .execute(&mut conn)?;
                    Ok(Some(v + 1))
                },
                _ => Ok(None)
            }
        }
    }
}
```

Additionally, create a formal database migration to populate `processor_status` from `processor_statuses` for existing deployments.

## Proof of Concept

```rust
// Simulate version compatibility issue
#[test]
fn test_split_brain_processor_status() {
    let conn_pool = setup_test_db();
    let processor_name = "test_processor";
    
    // Simulate older version: write only to processor_statuses
    {
        let mut conn = conn_pool.get().unwrap();
        let old_status = ProcessorStatus::new(processor_name, 1000, true, None);
        diesel::insert_into(processor_statuses::table)
            .values(&old_status)
            .execute(&mut conn)
            .unwrap();
    }
    
    // Simulate newer version: read from processor_status (empty)
    let tailer = create_tailer(conn_pool.clone(), processor_name);
    let start_version = tailer.get_start_version(&processor_name.to_string()).unwrap();
    
    // BUG: Returns None instead of 1001, causing restart from 0
    assert_eq!(start_version, None); // Should be Some(1001)
    
    // This causes re-indexing from version 0
    let runtime_start = start_version.unwrap_or(0);
    assert_eq!(runtime_start, 0); // VULNERABILITY: Lost 1000 versions of progress
}
```

## Notes

While this vulnerability doesn't directly impact blockchain consensus or validator operations, it represents a significant data integrity issue in the indexer infrastructure. The indexer is critical for ecosystem applications that query blockchain data via APIs. The split-brain scenario can occur naturally during version upgrades without any malicious intent, making it a high-probability operational risk.

The deprecated comment in the codebase [7](#0-6)  indicates awareness of the migration, but the implementation is incomplete without proper backward compatibility handling or data migration scripts.

### Citations

**File:** crates/indexer/src/schema.rs (L606-613)
```rust
diesel::table! {
    processor_status (processor) {
        #[max_length = 50]
        processor -> Varchar,
        last_success_version -> Int8,
        last_updated -> Timestamp,
    }
}
```

**File:** crates/indexer/src/schema.rs (L615-624)
```rust
diesel::table! {
    processor_statuses (name, version) {
        #[max_length = 50]
        name -> Varchar,
        version -> Int8,
        success -> Bool,
        details -> Nullable<Text>,
        last_updated -> Timestamp,
    }
}
```

**File:** crates/indexer/src/indexer/transaction_processor.rs (L146-165)
```rust
    fn apply_processor_status(&self, psms: &[ProcessorStatusModel]) {
        let mut conn = self.get_conn();
        let chunks = get_chunks(psms.len(), ProcessorStatusModel::field_count());
        for (start_ind, end_ind) in chunks {
            execute_with_better_error(
                &mut conn,
                diesel::insert_into(processor_statuses::table)
                    .values(&psms[start_ind..end_ind])
                    .on_conflict((dsl::name, dsl::version))
                    .do_update()
                    .set((
                        dsl::success.eq(excluded(dsl::success)),
                        dsl::details.eq(excluded(dsl::details)),
                        dsl::last_updated.eq(excluded(dsl::last_updated)),
                    )),
                None,
            )
            .expect("Error updating Processor Status!");
        }
    }
```

**File:** crates/indexer/src/indexer/tailer.rs (L170-191)
```rust
    pub fn update_last_processed_version(&self, processor_name: &str, version: u64) -> Result<()> {
        let mut conn = self.connection_pool.get()?;

        let status = ProcessorStatusV2 {
            processor: processor_name.to_owned(),
            last_success_version: version as i64,
        };
        execute_with_better_error(
            &mut conn,
            diesel::insert_into(processor_status::table)
                .values(&status)
                .on_conflict(processor_status::processor)
                .do_update()
                .set((
                    processor_status::last_success_version
                        .eq(excluded(processor_status::last_success_version)),
                    processor_status::last_updated.eq(excluded(processor_status::last_updated)),
                )),
            Some(" WHERE processor_status.last_success_version <= EXCLUDED.last_success_version "),
        )?;
        Ok(())
    }
```

**File:** crates/indexer/src/indexer/tailer.rs (L193-201)
```rust
    /// Get last version processed successfully from databse
    pub fn get_start_version(&self, processor_name: &String) -> Result<Option<i64>> {
        let mut conn = self.connection_pool.get()?;

        match ProcessorStatusV2Query::get_by_processor(processor_name, &mut conn)? {
            Some(status) => Ok(Some(status.last_success_version + 1)),
            None => Ok(None),
        }
    }
```

**File:** crates/indexer/src/runtime.rs (L163-172)
```rust
    let starting_version_from_db_short = tailer
        .get_start_version(&processor_name)
        .unwrap_or_else(|e| panic!("Failed to get starting version: {:?}", e))
        .unwrap_or_else(|| {
            info!(
                processor_name = processor_name,
                "No starting version from db so starting from version 0"
            );
            0
        }) as u64;
```

**File:** crates/indexer/src/models/processor_statuses.rs (L10-10)
```rust
/// We are deprecating this in favor of ProcessorStatusV2
```
