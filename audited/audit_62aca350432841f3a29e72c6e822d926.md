# Audit Report

## Title
Unbounded Batch Accumulation via Far-Future Expiration Time Manipulation in Quorum Store

## Summary
A malicious validator can send `BatchMsg` messages containing batches with expiration times set to extremely far future values (e.g., `u64::MAX`). Honest validators lack upper-bound validation on batch expiration times during `BatchMsg` processing, allowing these malicious batches to bypass all expiration cleanup mechanisms in `ProofManager` and `BatchProofQueue`, resulting in unbounded memory accumulation and potential validator node resource exhaustion.

## Finding Description

The vulnerability exists in the quorum store's batch processing pipeline. When a validator receives a `BatchMsg` from a peer, the system performs several validation checks but **fails to validate upper bounds on the expiration time**.

**Attack Flow:**

1. **Malicious Batch Creation**: A Byzantine validator creates batches with `expiration = u64::MAX` and sends them via `BatchMsg` to honest validators. [1](#0-0) 

The `Batch::verify()` method validates payload hash, transaction counts, and gas prices but does **not** check expiration bounds.

2. **Network Message Verification Bypass**: When `BatchMsg::verify()` is called during message verification, it also lacks expiration validation: [2](#0-1) 

The verification only checks batch count limits, author validity, and payload integrity—**no expiration upper bound check**. [3](#0-2) 

3. **Storage Without Upper Bound Validation**: The batch is then stored in `BatchStore`: [4](#0-3) 

The `save()` method only verifies `expiration > last_certified_time`, which `u64::MAX` easily satisfies. There is **no check for excessively far-future values**.

4. **Propagation to ProofManager**: The batch info (with `u64::MAX` expiration) is forwarded to `ProofManager`: [5](#0-4) 

5. **Insertion into BatchProofQueue**: The batch is inserted into `BatchProofQueue` with the malicious expiration: [6](#0-5) 

Line 282-283 adds the batch to the expiration index with `u64::MAX` expiration.

6. **Expiration Cleanup Bypass**: When block commits trigger cleanup via `handle_updated_block_timestamp()`: [7](#0-6) 

Line 729 calls `self.expirations.expire(block_timestamp)`. Since `u64::MAX >> block_timestamp`, these batches are **never** expired and removed.

7. **Garbage Collection Bypass**: The periodic GC for batches without proofs also fails: [8](#0-7) 

Line 327 checks `item.info.expiration() > timestamp`. For `u64::MAX`, this is always true, preventing garbage collection.

**Contrast with SignedBatchInfo Protection**: 

`SignedBatchInfo` messages DO have upper-bound validation: [9](#0-8) 

However, this validation only occurs when validators receive **signatures back** for their own batches, not when receiving `BatchMsg` from remote peers.

**Note on expiration=0**: Setting expiration to 0 is **not** a vulnerability, as `BatchStore::save()` line 421 would reject it (`0 > last_certified_time` is false), causing the bail at line 433.

## Impact Explanation

**Severity: HIGH**

This vulnerability enables resource exhaustion attacks against honest validators:

1. **Unbounded Memory Growth**: Each malicious batch with `u64::MAX` expiration permanently consumes memory in:
   - `BatchStore::db_cache` (DashMap)
   - `BatchProofQueue::items` (HashMap)
   - `BatchProofQueue::author_to_batches` (HashMap of BTrees)
   - `BatchProofQueue::expirations` (TimeExpirations index)

2. **Validator Node Slowdowns**: Growing data structures degrade lookup performance and increase processing latency, directly impacting consensus participation.

3. **Potential Node Crashes**: Continued accumulation can exhaust system memory, causing validator nodes to crash and reducing network decentralization.

4. **Economic Attack Vector**: An attacker controlling even a single validator can continuously spam all other validators, imposing costs without corresponding stake penalties.

Per the Aptos Bug Bounty program, this qualifies as **High Severity** ($50,000 tier) due to "Validator node slowdowns" and "Significant protocol violations."

## Likelihood Explanation

**Likelihood: HIGH**

This attack is highly likely to occur because:

1. **Low Attack Complexity**: Sending `BatchMsg` with modified expiration requires minimal effort—just constructing a batch with `expiration = u64::MAX`.

2. **No Validator Collusion Required**: Any single malicious or compromised validator can execute this attack against the entire network.

3. **No Economic Deterrent**: The attacker incurs no stake slashing or penalties, as batches with invalid expiration are not explicitly detected as Byzantine behavior.

4. **Immediate Impact**: Effects are cumulative and persistent—each malicious batch permanently increases memory usage until manual intervention.

5. **Detection Difficulty**: Operators may not immediately notice slow memory growth until performance degradation becomes severe.

## Recommendation

Implement upper-bound validation on batch expiration times at the earliest point in the processing pipeline—during `BatchMsg::verify()` or `Batch::verify()`.

**Recommended Fix:**

Add expiration upper-bound validation in `consensus/src/quorum_store/types.rs`:

```rust
pub fn verify(
    &self,
    peer_id: PeerId,
    max_num_batches: usize,
    max_batch_expiry_gap_usecs: u64,  // Add this parameter
    verifier: &ValidatorVerifier,
) -> anyhow::Result<()> {
    ensure!(!self.batches.is_empty(), "Empty message");
    ensure!(
        self.batches.len() <= max_num_batches,
        "Too many batches: {} > {}",
        self.batches.len(),
        max_num_batches
    );
    let epoch_authors = verifier.address_to_validator_index();
    let current_time = aptos_infallible::duration_since_epoch().as_micros() as u64;
    
    for batch in self.batches.iter() {
        ensure!(
            epoch_authors.contains_key(&batch.author()),
            "Invalid author {} for batch {} in current epoch",
            batch.author(),
            batch.digest()
        );
        ensure!(
            batch.author() == peer_id,
            "Batch author doesn't match sender"
        );
        
        // NEW: Validate expiration upper bound
        ensure!(
            batch.expiration() <= current_time + max_batch_expiry_gap_usecs,
            "Batch expiration too far in future: {} > {}",
            batch.expiration(),
            current_time + max_batch_expiry_gap_usecs
        );
        
        batch.verify()?
    }
    Ok(())
}
```

Update the call site in `round_manager.rs` to pass `max_batch_expiry_gap_usecs`: [3](#0-2) 

Change line 168 to include the expiration parameter (similar to how `SignedBatchInfo` is verified on lines 186-191).

## Proof of Concept

**Reproduction Steps:**

1. **Setup malicious validator** that creates batches with `u64::MAX` expiration:

```rust
// In consensus/src/quorum_store/batch_generator.rs (modified for PoC)
let malicious_expiration = u64::MAX;
let batch = Batch::new_v1(
    batch_id,
    txns,
    self.epoch,
    malicious_expiration,  // Set to u64::MAX
    self.my_peer_id,
    bucket_start,
);
```

2. **Send BatchMsg** to target validators via network layer.

3. **Observe victim validator** memory growth:
   - Monitor `BatchProofQueue::items.len()` increasing without bound
   - Check `BatchStore::db_cache.len()` growth
   - Verify batches are never removed by `handle_updated_block_timestamp()`

4. **Expected Result**: Victim validators accumulate batches indefinitely, consuming increasing memory until:
   - Performance degradation (slower block processing)
   - OOM crashes
   - Manual intervention required

**Verification Command:**

```bash
# Monitor BatchProofQueue metrics showing unbounded growth
curl -s http://localhost:9101/metrics | grep "aptos_consensus_quorum_store.*batch.*remaining"
```

The `NUM_TOTAL_PROOFS_LEFT_ON_UPDATE` and `NUM_TOTAL_TXNS_LEFT_ON_UPDATE` metrics will continuously increase without the expected periodic decreases from expiration cleanup.

### Citations

**File:** consensus/src/quorum_store/types.rs (L262-290)
```rust
    pub fn verify(&self) -> anyhow::Result<()> {
        ensure!(
            self.payload.author() == self.author(),
            "Payload author doesn't match the info"
        );
        ensure!(
            self.payload.hash() == *self.digest(),
            "Payload hash doesn't match the digest"
        );
        ensure!(
            self.payload.num_txns() as u64 == self.num_txns(),
            "Payload num txns doesn't match batch info"
        );
        ensure!(
            self.payload.num_bytes() as u64 == self.num_bytes(),
            "Payload num bytes doesn't match batch info"
        );
        for txn in self.payload.txns() {
            ensure!(
                txn.gas_unit_price() >= self.gas_bucket_start(),
                "Payload gas unit price doesn't match batch info"
            );
            ensure!(
                !txn.payload().is_encrypted_variant(),
                "Encrypted transaction is not supported yet"
            );
        }
        Ok(())
    }
```

**File:** consensus/src/quorum_store/types.rs (L433-461)
```rust
    pub fn verify(
        &self,
        peer_id: PeerId,
        max_num_batches: usize,
        verifier: &ValidatorVerifier,
    ) -> anyhow::Result<()> {
        ensure!(!self.batches.is_empty(), "Empty message");
        ensure!(
            self.batches.len() <= max_num_batches,
            "Too many batches: {} > {}",
            self.batches.len(),
            max_num_batches
        );
        let epoch_authors = verifier.address_to_validator_index();
        for batch in self.batches.iter() {
            ensure!(
                epoch_authors.contains_key(&batch.author()),
                "Invalid author {} for batch {} in current epoch",
                batch.author(),
                batch.digest()
            );
            ensure!(
                batch.author() == peer_id,
                "Batch author doesn't match sender"
            );
            batch.verify()?
        }
        Ok(())
    }
```

**File:** consensus/src/round_manager.rs (L166-173)
```rust
            UnverifiedEvent::BatchMsg(b) => {
                if !self_message {
                    b.verify(peer_id, max_num_batches, validator)?;
                    counters::VERIFY_MSG
                        .with_label_values(&["batch"])
                        .observe(start_time.elapsed().as_secs_f64());
                }
                VerifiedEvent::BatchMsg(Box::new((*b).into()))
```

**File:** consensus/src/quorum_store/batch_store.rs (L419-439)
```rust
    pub(crate) fn save(&self, value: &PersistedValue<BatchInfoExt>) -> anyhow::Result<bool> {
        let last_certified_time = self.last_certified_time();
        if value.expiration() > last_certified_time {
            fail_point!("quorum_store::save", |_| {
                // Skip caching and storing value to the db
                Ok(false)
            });
            counters::GAP_BETWEEN_BATCH_EXPIRATION_AND_CURRENT_TIME_WHEN_SAVE.observe(
                Duration::from_micros(value.expiration() - last_certified_time).as_secs_f64(),
            );

            return self.insert_to_cache(value);
        }
        counters::NUM_BATCH_EXPIRED_WHEN_SAVE.inc();
        bail!(
            "Incorrect expiration {} in epoch {}, last committed timestamp {}",
            value.expiration(),
            self.epoch(),
            last_certified_time,
        );
    }
```

**File:** consensus/src/quorum_store/batch_coordinator.rs (L92-134)
```rust
            let batches = persist_requests
                .iter()
                .map(|persisted_value| {
                    (
                        persisted_value.batch_info().clone(),
                        persisted_value.summary(),
                    )
                })
                .collect();

            if persist_requests[0].batch_info().is_v2() {
                let signed_batch_infos = batch_store.persist(persist_requests);
                if !signed_batch_infos.is_empty() {
                    if approx_created_ts_usecs > 0 {
                        observe_batch(approx_created_ts_usecs, peer_id, BatchStage::SIGNED);
                    }
                    network_sender
                        .send_signed_batch_info_msg_v2(signed_batch_infos, vec![peer_id])
                        .await;
                }
            } else {
                let signed_batch_infos = batch_store.persist(persist_requests);
                if !signed_batch_infos.is_empty() {
                    assert!(!signed_batch_infos
                        .first()
                        .expect("must not be empty")
                        .is_v2());
                    if approx_created_ts_usecs > 0 {
                        observe_batch(approx_created_ts_usecs, peer_id, BatchStage::SIGNED);
                    }
                    let signed_batch_infos = signed_batch_infos
                        .into_iter()
                        .map(|sbi| sbi.try_into().expect("Batch must be V1 batch"))
                        .collect();
                    network_sender
                        .send_signed_batch_info_msg(signed_batch_infos, vec![peer_id])
                        .await;
                }
            }
            let _ = sender_to_proof_manager
                .send(ProofManagerCommand::ReceiveBatches(batches))
                .await;
        });
```

**File:** consensus/src/quorum_store/batch_proof_queue.rs (L258-283)
```rust
    pub fn insert_batches(
        &mut self,
        batches_with_txn_summaries: Vec<(BatchInfoExt, Vec<TxnSummaryWithExpiration>)>,
    ) {
        let start = Instant::now();

        for (batch_info, txn_summaries) in batches_with_txn_summaries.into_iter() {
            let batch_sort_key = BatchSortKey::from_info(&batch_info);
            let batch_key = BatchKey::from_info(&batch_info);

            // If the batch is either committed or the txn summary already exists, skip
            // inserting this batch.
            if self
                .items
                .get(&batch_key)
                .is_some_and(|item| item.is_committed() || item.txn_summaries.is_some())
            {
                continue;
            }

            self.author_to_batches
                .entry(batch_info.author())
                .or_default()
                .insert(batch_sort_key.clone(), batch_info.clone());
            self.expirations
                .add_item(batch_sort_key, batch_info.expiration());
```

**File:** consensus/src/quorum_store/batch_proof_queue.rs (L324-339)
```rust
    fn gc_expired_batch_summaries_without_proofs(&mut self) {
        let timestamp = aptos_infallible::duration_since_epoch().as_micros() as u64;
        self.items.retain(|_, item| {
            if item.is_committed() || item.proof.is_some() || item.info.expiration() > timestamp {
                true
            } else {
                self.author_to_batches
                    .get_mut(&item.info.author())
                    .map(|queue| queue.remove(&BatchSortKey::from_info(&item.info)));
                counters::GARBAGE_COLLECTED_IN_PROOF_QUEUE_COUNTER
                    .with_label_values(&["expired_batch_without_proof"])
                    .inc();
                false
            }
        });
    }
```

**File:** consensus/src/quorum_store/batch_proof_queue.rs (L716-769)
```rust
    pub(crate) fn handle_updated_block_timestamp(&mut self, block_timestamp: u64) {
        // tolerate asynchronous notification
        if self.latest_block_timestamp > block_timestamp {
            return;
        }
        let start = Instant::now();
        self.latest_block_timestamp = block_timestamp;
        if let Some(time_lag) = aptos_infallible::duration_since_epoch()
            .checked_sub(Duration::from_micros(block_timestamp))
        {
            counters::TIME_LAG_IN_BATCH_PROOF_QUEUE.observe_duration(time_lag);
        }

        let expired = self.expirations.expire(block_timestamp);
        let mut num_expired_but_not_committed = 0;
        for key in &expired {
            if let Some(mut queue) = self.author_to_batches.remove(&key.author()) {
                if let Some(batch) = queue.remove(key) {
                    let item = self
                        .items
                        .get(&key.batch_key)
                        .expect("Entry for unexpired batch must exist");
                    if item.proof.is_some() {
                        // not committed proof that is expired
                        num_expired_but_not_committed += 1;
                        counters::GAP_BETWEEN_BATCH_EXPIRATION_AND_CURRENT_TIME_WHEN_COMMIT
                            .observe((block_timestamp - batch.expiration()) as f64);
                        if let Some(ref txn_summaries) = item.txn_summaries {
                            for txn_summary in txn_summaries {
                                if let Some(count) =
                                    self.txn_summary_num_occurrences.get_mut(txn_summary)
                                {
                                    *count -= 1;
                                    if *count == 0 {
                                        self.txn_summary_num_occurrences.remove(txn_summary);
                                    }
                                };
                            }
                        }
                        self.dec_remaining_proofs(&batch.author(), batch.num_txns());
                        counters::GARBAGE_COLLECTED_IN_PROOF_QUEUE_COUNTER
                            .with_label_values(&["expired_proof"])
                            .inc();
                    }
                    claims::assert_some!(self.items.remove(&key.batch_key));
                }
                if !queue.is_empty() {
                    self.author_to_batches.insert(key.author(), queue);
                }
            }
        }
        counters::PROOF_QUEUE_UPDATE_TIMESTAMP_DURATION.observe_duration(start.elapsed());
        counters::NUM_PROOFS_EXPIRED_WHEN_COMMIT.inc_by(num_expired_but_not_committed);
    }
```

**File:** consensus/consensus-types/src/proof_of_store.rs (L469-479)
```rust
        if self.expiration()
            > aptos_infallible::duration_since_epoch().as_micros() as u64
                + max_batch_expiry_gap_usecs
        {
            bail!(
                "Batch expiration too far in future: {} > {}",
                self.expiration(),
                aptos_infallible::duration_since_epoch().as_micros() as u64
                    + max_batch_expiry_gap_usecs
            );
        }
```
