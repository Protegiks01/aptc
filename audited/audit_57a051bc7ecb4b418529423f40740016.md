# Audit Report

## Title
Test Native Validation Bypass in `assert_no_test_natives()` - Incorrect Function Name Check for Event Module

## Summary
The `assert_no_test_natives()` function contains a critical validation error where it checks for a non-existent native function name `"emitted_events_internal"` in the event module, while the actual test-only natives are registered as `"emitted_events"` and `"emitted_events_by_handle"`. This allows two test-only introspection natives to bypass production validation and potentially be included in mainnet deployments if the "testing" feature flag is accidentally enabled. [1](#0-0) 

## Finding Description
The security validation function `assert_no_test_natives()` is designed to prevent test-only native functions from being included in production builds of the Aptos node. This check is executed at node startup to catch accidental inclusion of test features due to Cargo's feature unification. [2](#0-1) 

The validation checks for specific test native function names, including checking if the "event" module contains `"emitted_events_internal"`: [3](#0-2) 

However, the actual test-only natives registered in the event module have different names. The event module registers TWO test-only natives when the "testing" feature is enabled: [4](#0-3) 

These natives are named:
1. `"emitted_events_by_handle"`
2. `"emitted_events"`

Neither of these matches the checked name `"emitted_events_internal"`. This name appears nowhere else in the Rust codebase, making this a dead check that will never detect the actual test natives.

The validation uses the standard Rust iterator `all()` method, which properly iterates through all native functions. However, the boolean logic checks for the wrong function name, causing a validation bypass. The `all()` iterator itself works correctly - the issue is purely the incorrect name in the predicate.

## Impact Explanation
**Severity: High** 

This vulnerability breaks the critical security invariant that test-only features must never be present in production deployments. The two bypassed test natives provide powerful introspection capabilities:

1. **`emitted_events<T>()`**: Allows Move code to query ALL events of type T emitted in the current transaction context [5](#0-4) 

2. **`emitted_events_by_handle<T>()`**: Allows Move code to query events by event handle [6](#0-5) 

If these natives are present in production, malicious Move modules could:
- Access event data from other modules that should be private
- Potentially break **Deterministic Execution** if different validators have different feature flag configurations
- Leak sensitive information through event introspection
- Violate module isolation assumptions

The validation bypass also undermines the security purpose stated in the error message: [7](#0-6) 

## Likelihood Explanation
**Likelihood: Medium**

The vulnerability requires the "testing" feature flag to be accidentally enabled in a production build. While this should not happen in normal circumstances, Cargo's feature unification makes it possible when:

1. Multiple crates with shared dependencies are compiled together
2. One crate enables the "testing" feature for a shared dependency
3. The feature propagates to aptos-node through the dependency tree

The error message specifically warns about this scenario, indicating it's a known risk. Once the feature is enabled, the validation will definitely fail to detect the event test natives due to the name mismatch.

The Move framework also explicitly declares these as test-only functions: [8](#0-7) 

## Recommendation
Fix the validation check to use the correct native function names. Replace the incorrect check with checks for both actual test natives:

```rust
// In assert_no_test_natives(), replace line 185-186:
|| module_name.as_str() == "event" 
    && func_name.as_str() == "emitted_events_internal"

// With:
|| module_name.as_str() == "event" 
    && (func_name.as_str() == "emitted_events" 
        || func_name.as_str() == "emitted_events_by_handle")
```

Additionally, consider adding a comprehensive test that verifies all conditionally-compiled test natives are properly checked in the validation function.

## Proof of Concept

To demonstrate this vulnerability:

1. **Verify the name mismatch**: Search the codebase for "emitted_events_internal" - it only appears in the validation check, never in actual native registration.

2. **Confirm actual names**: Check `aptos-move/framework/src/natives/event.rs` lines 334-341 showing the actual registered names are "emitted_events" and "emitted_events_by_handle".

3. **Test the bypass**: 
```rust
#[test]
fn test_validation_bypass() {
    // Enable testing feature and build natives table
    #[cfg(feature = "testing")]
    {
        let natives = aptos_natives(
            LATEST_GAS_FEATURE_VERSION,
            NativeGasParameters::zeros(),
            MiscGasParameters::zeros(),
            TimedFeaturesBuilder::enable_all().build(),
            Features::default()
        );
        
        // Check if event test natives are present
        let has_emitted_events = natives.iter().any(|(_, m, f, _)| 
            m.as_str() == "event" && f.as_str() == "emitted_events"
        );
        
        let has_emitted_events_by_handle = natives.iter().any(|(_, m, f, _)| 
            m.as_str() == "event" && f.as_str() == "emitted_events_by_handle"
        );
        
        // Both should be present
        assert!(has_emitted_events);
        assert!(has_emitted_events_by_handle);
        
        // But the validation check would NOT fail because it looks for wrong name
        let validation_would_fail = natives.iter().any(|(_, m, f, _)| 
            m.as_str() == "event" && f.as_str() == "emitted_events_internal"
        );
        
        assert!(!validation_would_fail); // Proves the bypass
    }
}
```

This demonstrates that when the "testing" feature is enabled, the two event test natives are present but would not be detected by `assert_no_test_natives()` due to the incorrect function name in the validation predicate.

## Notes
The root cause is a simple typo or naming inconsistency between the validation check and the actual native registration. The iterator logic (`all()` method) functions correctly - this is not an issue with short-circuit evaluation or early termination. The vulnerability is specifically the incorrect string literal used in the validation predicate.

### Citations

**File:** aptos-move/aptos-vm/src/natives.rs (L161-191)
```rust
pub fn assert_no_test_natives(err_msg: &str) {
    assert!(
        aptos_natives(
            LATEST_GAS_FEATURE_VERSION,
            NativeGasParameters::zeros(),
            MiscGasParameters::zeros(),
            TimedFeaturesBuilder::enable_all().build(),
            Features::default()
        )
        .into_iter()
        .all(|(_, module_name, func_name, _)| {
            !(module_name.as_str() == "unit_test"
                && func_name.as_str() == "create_signers_for_testing"
                || module_name.as_str() == "ed25519"
                    && func_name.as_str() == "generate_keys_internal"
                || module_name.as_str() == "ed25519" && func_name.as_str() == "sign_internal"
                || module_name.as_str() == "multi_ed25519"
                    && func_name.as_str() == "generate_keys_internal"
                || module_name.as_str() == "multi_ed25519" && func_name.as_str() == "sign_internal"
                || module_name.as_str() == "bls12381"
                    && func_name.as_str() == "generate_keys_internal"
                || module_name.as_str() == "bls12381" && func_name.as_str() == "sign_internal"
                || module_name.as_str() == "bls12381"
                    && func_name.as_str() == "generate_proof_of_possession_internal"
                || module_name.as_str() == "event"
                    && func_name.as_str() == "emitted_events_internal")
        }),
        "{}",
        err_msg
    )
}
```

**File:** aptos-move/framework/src/natives/event.rs (L154-209)
```rust
fn native_emitted_events_by_handle(
    context: &mut SafeNativeContext,
    ty_args: &[Type],
    mut arguments: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    debug_assert!(ty_args.len() == 1);
    debug_assert!(arguments.len() == 1);

    let ty = &ty_args[0];
    let mut guid = safely_pop_arg!(arguments, StructRef)
        .borrow_field(1)?
        .value_as::<StructRef>()?
        .borrow_field(0)?
        .value_as::<Reference>()?
        .read_ref()?
        .value_as::<Struct>()?
        .unpack()?;

    let creation_num = guid
        .next()
        .ok_or_else(|| {
            SafeNativeError::InvariantViolation(PartialVMError::new(
                StatusCode::INTERNAL_TYPE_ERROR,
            ))
        })?
        .value_as::<u64>()?;
    let addr = guid
        .next()
        .ok_or_else(|| {
            SafeNativeError::InvariantViolation(PartialVMError::new(
                StatusCode::INTERNAL_TYPE_ERROR,
            ))
        })?
        .value_as::<AccountAddress>()?;
    let key = EventKey::new(creation_num, addr);
    let ty_tag = context.type_to_type_tag(ty)?;
    let ty_layout = context.type_to_type_layout_check_no_delayed_fields(ty)?;
    let ctx = context.extensions().get::<NativeEventContext>();
    let events = ctx
        .emitted_v1_events(&key, &ty_tag)
        .into_iter()
        .map(|blob| {
            let function_value_extension = context.function_value_extension();
            let max_value_nest_depth = context.max_value_nest_depth();
            ValueSerDeContext::new(max_value_nest_depth)
                .with_func_args_deserialization(&function_value_extension)
                .deserialize(blob, &ty_layout)
                .ok_or_else(|| {
                    SafeNativeError::InvariantViolation(PartialVMError::new(
                        StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR,
                    ))
                })
        })
        .collect::<SafeNativeResult<Vec<Value>>>()?;
    Ok(smallvec![Value::vector_unchecked(events)?])
}
```

**File:** aptos-move/framework/src/natives/event.rs (L212-244)
```rust
fn native_emitted_events(
    context: &mut SafeNativeContext,
    ty_args: &[Type],
    arguments: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    debug_assert!(ty_args.len() == 1);
    debug_assert!(arguments.is_empty());

    let ty = &ty_args[0];

    let ty_tag = context.type_to_type_tag(ty)?;
    let ty_layout = context.type_to_type_layout_check_no_delayed_fields(ty)?;
    let ctx = context.extensions().get::<NativeEventContext>();

    let events = ctx
        .emitted_v2_events(&ty_tag)
        .into_iter()
        .map(|blob| {
            let function_value_extension = context.function_value_extension();
            let max_value_nest_depth = context.max_value_nest_depth();
            ValueSerDeContext::new(max_value_nest_depth)
                .with_func_args_deserialization(&function_value_extension)
                .with_delayed_fields_serde()
                .deserialize(blob, &ty_layout)
                .ok_or_else(|| {
                    SafeNativeError::InvariantViolation(PartialVMError::new(
                        StatusCode::VALUE_DESERIALIZATION_ERROR,
                    ))
                })
        })
        .collect::<SafeNativeResult<Vec<Value>>>()?;
    Ok(smallvec![Value::vector_unchecked(events)?])
}
```

**File:** aptos-move/framework/src/natives/event.rs (L334-341)
```rust
    #[cfg(feature = "testing")]
    natives.extend([(
        "emitted_events_by_handle",
        native_emitted_events_by_handle as RawSafeNative,
    )]);

    #[cfg(feature = "testing")]
    natives.extend([("emitted_events", native_emitted_events as RawSafeNative)]);
```

**File:** aptos-move/framework/aptos-framework/sources/event.move (L24-25)
```text
    #[test_only]
    public native fun emitted_events<T: drop + store>(): vector<T>;
```
