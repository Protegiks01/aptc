# Audit Report

## Title
Configuration Validation Bypass: Dangerous Skip Flags Allow Complete Bypass of Mainnet Security Checks

## Summary
The `NodeStartupConfig` allows `skip_config_optimizer` and `skip_config_sanitizer` flags to be set in configuration files without any validation or warnings, enabling complete bypass of critical mainnet security checks including mutual authentication, paranoid VM verification, and failpoint prevention. While the attack surface varies by deployment model, the lack of validation represents a significant security gap that could be exploited if an attacker gains configuration modification capabilities.

## Finding Description

The `NodeStartupConfig` struct defines two boolean flags that control whether security validation runs at node startup: [1](#0-0) 

When `skip_config_sanitizer` is set to true, the sanitizer returns immediately without performing any validation: [2](#0-1) 

Similarly, when `skip_config_optimizer` is set to true, the optimizer skips all configuration adjustments: [3](#0-2) 

**Critical Security Checks Bypassed:**

When `skip_config_sanitizer: true` is set, ALL of the following mainnet-critical validations are bypassed:

1. **Paranoid Hot Potato Verification (MANDATORY for mainnet):** [4](#0-3) 

2. **Paranoid Type Verification (MANDATORY for mainnet):** [5](#0-4) 

3. **Validator Mutual Authentication (MANDATORY):** [6](#0-5) 

4. **Failpoints Prevention on Mainnet:** [7](#0-6) 

5. **Safety Rules Backend Validation:** [8](#0-7) 

**Deployment-Specific Attack Surface:**

**Kubernetes Deployments:** Configuration is mounted from read-only ConfigMaps, limiting this attack vector: [9](#0-8) 

The pod security context runs as non-root with read-only root filesystem: [10](#0-9) 

**Docker Compose/Bare Metal Deployments:** Configuration files are bind-mounted from the host filesystem where an attacker with write access to the config file can modify them: [11](#0-10) 

**The Core Vulnerability:** The code performs NO validation to prevent these flags from being set or warn operators about their use on mainnet. Configuration files are loaded and deserialized via standard YAML parsing: [12](#0-11) 

## Impact Explanation

**High Severity** - This vulnerability allows bypassing ALL critical security validations on mainnet nodes, leading to:

1. **Consensus Safety Violations**: Validators can run without mutual authentication, potentially enabling unauthorized participation in consensus or man-in-the-middle attacks on the validator network.

2. **Move VM Execution Safety Degradation**: Disabling paranoid hot potato and type verification removes critical runtime checks that ensure bytecode execution safety and determinism across all validators.

3. **Unauthorized Debug Features**: Failpoints and test configurations can be enabled on mainnet, potentially exposing dangerous debugging interfaces or causing non-deterministic behavior.

4. **Weak Safety Rules**: Validators can use in-memory storage backends for safety rules (losing critical consensus state on restart) or other insecure configurations.

While the attack requires configuration modification capabilities (which varies by deployment), the complete absence of validation or warnings makes this a significant defense-in-depth failure. If an attacker gains config modification through ANY means (compromised operator account, configuration management vulnerability, insider threat, or permission misconfiguration), they can disable all security checks without any barriers.

## Likelihood Explanation

**Medium Likelihood** - The exploitability depends on deployment model:

- **Kubernetes (Most Common)**: Requires Kubernetes API access with ConfigMap edit permissions, not simple filesystem access. However, misconfigurations in RBAC or compromised service accounts could enable this.

- **Docker Compose/Bare Metal**: Requires write access to the configuration file, typically meaning:
  - Compromised user account owning the config file
  - Misconfigured file permissions
  - Vulnerable configuration management systems

The lack of any validation means there's no "last line of defense" if configuration modification is achieved through any vector. This is especially concerning for:
- Automated deployment systems that might accidentally set these flags
- Operators who might enable these flags for debugging and forget to remove them
- Supply chain attacks on configuration management tools

## Recommendation

**Implement strict validation to prevent dangerous configuration flags on mainnet:**

```rust
impl ConfigSanitizer for NodeConfig {
    fn sanitize(
        node_config: &NodeConfig,
        node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        // NEW: Validate skip flags before checking if sanitization should be skipped
        if let Some(chain_id) = chain_id {
            if chain_id.is_mainnet() {
                if node_config.node_startup.skip_config_sanitizer {
                    return Err(Error::ConfigSanitizerFailed(
                        "NodeStartupConfig".to_string(),
                        "skip_config_sanitizer cannot be enabled on mainnet nodes! This bypasses critical security checks.".to_string(),
                    ));
                }
                if node_config.node_startup.skip_config_optimizer {
                    return Err(Error::ConfigSanitizerFailed(
                        "NodeStartupConfig".to_string(),
                        "skip_config_optimizer should not be enabled on mainnet nodes as it may result in suboptimal or insecure configurations.".to_string(),
                    ));
                }
            }
        }
        
        // If config sanitization is disabled, don't do anything!
        if node_config.node_startup.skip_config_sanitizer {
            return Ok(());
        }
        
        // ... rest of sanitization ...
    }
}
```

**Additional Recommendations:**
1. Add file permission enforcement: Use restrictive permissions (0600) when writing config files
2. Add audit logging: Log when these dangerous flags are used
3. Add warnings: Even for non-mainnet, log warnings when these flags are enabled
4. Add documentation: Clearly document that these flags should NEVER be used in production

## Proof of Concept

Create a malicious validator configuration file `malicious-validator.yaml`:

```yaml
base:
  role: "validator"
  data_dir: "/opt/aptos/data"
  waypoint:
    from_file: "/opt/aptos/genesis/waypoint.txt"

# MALICIOUS: Skip all security checks
node_startup:
  skip_config_optimizer: true
  skip_config_sanitizer: true

# DANGEROUS: Disable critical mainnet protections
execution:
  genesis_file_location: "/opt/aptos/genesis/genesis.blob"
  paranoid_hot_potato_verification: false  # Violates mainnet requirement
  paranoid_type_verification: false        # Violates mainnet requirement

validator_network:
  discovery_method: "onchain"
  mutual_authentication: false  # Violates validator requirement
  identity:
    type: "from_file"
    path: /opt/aptos/genesis/validator-identity.yaml

full_node_networks:
- network_id:
    private: "vfn"
  listen_address: "/ip4/0.0.0.0/tcp/6181"
```

**Exploitation Steps:**
1. Attacker gains write access to validator config file through any means
2. Attacker modifies config to add `skip_config_sanitizer: true` and disable security features
3. Node restarts (crash, system restart, or manual restart)
4. Node loads config via `NodeConfig::load_config()` 
5. Sanitizer checks `skip_config_sanitizer` flag and returns early, bypassing all validations
6. Node starts with weakened security on mainnet - no mutual auth, no paranoid checks, potential failpoints enabled

The node will start successfully despite violating multiple critical mainnet security requirements, with no errors or warnings.

## Notes

This vulnerability is particularly concerning because it provides a "master bypass" for all security validations. While properly deployed Kubernetes environments have defense through read-only ConfigMaps, the complete lack of validation creates risk across multiple threat vectors including insider threats, compromised automation systems, and permission misconfigurations. The fix should be implemented as a defense-in-depth measure to ensure that even if configuration modification is achieved through any means, critical mainnet security checks cannot be disabled.

### Citations

**File:** config/src/config/node_startup_config.rs (L8-11)
```rust
pub struct NodeStartupConfig {
    pub skip_config_optimizer: bool, // Whether or not to skip the config optimizer at startup
    pub skip_config_sanitizer: bool, // Whether or not to skip the config sanitizer at startup
}
```

**File:** config/src/config/config_sanitizer.rs (L45-48)
```rust
        // If config sanitization is disabled, don't do anything!
        if node_config.node_startup.skip_config_sanitizer {
            return Ok(());
        }
```

**File:** config/src/config/config_sanitizer.rs (L82-90)
```rust
    // Verify that failpoints are not enabled in mainnet
    let failpoints_enabled = are_failpoints_enabled();
    if let Some(chain_id) = chain_id {
        if chain_id.is_mainnet() && failpoints_enabled {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "Failpoints are not supported on mainnet nodes!".into(),
            ));
        }
```

**File:** config/src/config/config_sanitizer.rs (L192-197)
```rust
        if !validator_network_config.mutual_authentication {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "Mutual authentication must be enabled for the validator network!".into(),
            ));
        }
```

**File:** config/src/config/config_optimizer.rs (L104-107)
```rust
        // If config optimization is disabled, don't do anything!
        if node_config.node_startup.skip_config_optimizer {
            return Ok(false);
        }
```

**File:** config/src/config/execution_config.rs (L169-175)
```rust
                if !execution_config.paranoid_hot_potato_verification {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name,
                        "paranoid_hot_potato_verification must be enabled for mainnet nodes!"
                            .into(),
                    ));
                }
```

**File:** config/src/config/execution_config.rs (L176-181)
```rust
                if !execution_config.paranoid_type_verification {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name,
                        "paranoid_type_verification must be enabled for mainnet nodes!".into(),
                    ));
                }
```

**File:** config/src/config/safety_rules_config.rs (L87-95)
```rust
            if chain_id.is_mainnet()
                && node_type.is_validator()
                && safety_rules_config.backend.is_in_memory()
            {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "The secure backend should not be set to in memory storage in mainnet!"
                        .to_string(),
                ));
```

**File:** terraform/helm/aptos-node/templates/validator.yaml (L193-203)
```yaml
        securityContext:
          {{- if $.Values.enablePrivilegedMode }}
          runAsUser: 0
          privileged: true
          {{- else }}
          readOnlyRootFilesystem: true
          allowPrivilegeEscalation: false
          capabilities:
            drop:
            - ALL
          {{- end }}
```

**File:** terraform/helm/aptos-node/templates/validator.yaml (L232-234)
```yaml
      - name: aptos-config
        configMap:
          name: {{ include "aptos-validator.fullname" $ }}-{{$i}}
```

**File:** docker/compose/aptos-node/docker-compose-src.yaml (L49-51)
```yaml
      - type: bind
        source: ./validator.yaml
        target: /opt/aptos/etc/validator.yaml
```

**File:** config/src/config/persistable_config.rs (L32-39)
```rust
    fn read_config_file<P: AsRef<Path>>(path: P) -> Result<String, Error> {
        let config_path_string = path.as_ref().to_str().unwrap().to_string();
        read_to_string(config_path_string.clone()).map_err(|error| {
            Error::Unexpected(format!(
                "Failed to read the config file into a string: {:?}. Error: {:?}",
                config_path_string, error
            ))
        })
```
