# Audit Report

## Title
API Error Responses Leak Internal File Paths and Database Implementation Details

## Summary
The Aptos Node API error handling system exposes sensitive internal information through error responses when database or storage operations fail. The use of `format!("{:#}", error)` on `anyhow::Error` chains results in full error traces being returned to API clients, including internal file paths, RocksDB error details, and system-level error messages.

## Finding Description
The vulnerability exists in how API errors are constructed and exposed to clients. When internal database operations fail, the error flow is:

1. RocksDB or storage layer generates an error (e.g., `AptosDbError::OtherRocksDbError`) containing file paths and system details [1](#0-0) 

2. These errors are converted to `anyhow::Error` and wrapped with context messages using `.context()` [2](#0-1) 

3. The contextual error chain is passed to `AptosError::new_with_error_code()` which formats it using `{:#}` [3](#0-2) 

4. The `{:#}` format specifier on `anyhow::Error` displays the **full error chain**, exposing both the high-level context message and the underlying system error with all its details

5. This `AptosError` is then serialized to JSON and returned to the API client [4](#0-3) 

**Example vulnerable code paths:**

- `latest_state_view_poem` function exposes database checkpoint errors [5](#0-4) 
- `get_state_value_poem` function exposes state retrieval errors [6](#0-5) 
- `get_resource_poem` function exposes resource deserialization errors [7](#0-6) 
- State API resource lookup exposes database query errors [8](#0-7) 

**Information Leaked:**
- Internal file system paths (e.g., `/var/lib/aptos/db/state.db`, `/opt/aptos/data/rocksdb/`)
- Database directory structure and organization
- RocksDB-specific error messages revealing implementation details
- System-level errors (permissions, disk space, file not found)
- Storage layer architecture details

**Note on panic_handler:** While the panic handler correctly sanitizes panic messages by only returning "internal error" to clients, this doesn't apply to regular error flows [9](#0-8) 

## Impact Explanation
**Severity: Medium** (per Aptos Bug Bounty criteria for "Minor information leaks")

This vulnerability provides attackers with reconnaissance information that aids in planning more sophisticated attacks:

1. **File System Reconnaissance:** Knowledge of internal paths helps attackers understand the deployment architecture and identify potential attack vectors
2. **Implementation Details:** Revealing RocksDB usage and error patterns helps attackers craft targeted attacks against the storage layer
3. **Error Condition Mapping:** Understanding what causes specific errors helps attackers probe for edge cases and race conditions
4. **Deployment Fingerprinting:** File paths and error messages can reveal operating system, deployment method, and configuration details

While this doesn't directly compromise funds or consensus, it violates security best practices and provides actionable intelligence to adversaries. The information disclosure could enable or accelerate exploitation of other vulnerabilities.

## Likelihood Explanation
**Likelihood: High**

This vulnerability is highly likely to be exploited because:

1. **No Authentication Required:** Any API user can trigger these errors
2. **Common Occurrence:** Database errors naturally occur during normal operations (pruned data, version lookups, resource queries)
3. **Easy to Trigger:** Simple API requests to non-existent resources, pruned versions, or during node stress can trigger informative errors
4. **No Special Conditions:** No race conditions, timing, or complex setup required
5. **Publicly Documented API:** Error responses are observable by any user of the public API endpoints

An attacker can systematically probe the API with various requests to collect comprehensive information about the node's internal structure.

## Recommendation
Implement proper error sanitization before exposing errors to API clients. The fix should:

1. **Sanitize error messages** by replacing the `{:#}` format (which shows full error chains) with a simple top-level message or error code
2. **Log full errors internally** for debugging while returning sanitized versions to clients
3. **Use allowlisting** for what information can be included in error responses

**Proposed fix for `api/types/src/error.rs`:**

```rust
pub fn new_with_error_code<ErrorType: std::fmt::Display>(
    error: ErrorType,
    error_code: AptosErrorCode,
) -> AptosError {
    // Log the full error chain internally for debugging
    aptos_logger::error!("API error: {:#}", error);
    
    // Only expose a sanitized message to clients
    // Extract just the outermost context message, not the full chain
    let sanitized_message = error.to_string()
        .lines()
        .next()
        .unwrap_or("Internal error")
        .to_string();
    
    Self {
        message: sanitized_message,
        error_code,
        vm_error_code: None,
    }
}
```

Alternatively, for specific error types, provide predefined safe error messages based on the error code rather than exposing any part of the underlying error.

## Proof of Concept

**Test scenario to trigger information disclosure:**

```bash
# Query a pruned ledger version to trigger database error
curl -X GET "http://localhost:8080/v1/accounts/0x1/resource/0x1::account::Account?ledger_version=1" \
  -H "Accept: application/json"

# Expected vulnerable response (example):
{
  "message": "Failed to retrieve state value\nCaused by:\n    AptosDB RocksDB Error: IO error: /var/lib/aptos/db/state_merkle_db/: No such file or directory",
  "error_code": "internal_error",
  "vm_error_code": null
}

# Query with filesystem stress to potentially trigger IO errors
curl -X GET "http://localhost:8080/v1/" -H "Accept: application/json"
# During disk I/O issues, this could return:
{
  "message": "Failed to read latest state checkpoint from DB\nCaused by:\n    AptosDB IO Error: /opt/aptos/data/db: Permission denied",
  "error_code": "internal_error",
  "vm_error_code": null
}
```

**Rust unit test to demonstrate the issue:**

```rust
#[test]
fn test_error_information_disclosure() {
    use aptos_api_types::{AptosError, AptosErrorCode};
    use anyhow::{anyhow, Context};
    
    // Simulate a database error with internal path
    let db_error = anyhow!("RocksDB error: /var/lib/aptos/db/state.db: Permission denied");
    let contextual_error = db_error.context("Failed to read from database");
    
    // Create API error the same way production code does
    let api_error = AptosError::new_with_error_code(
        contextual_error,
        AptosErrorCode::InternalError,
    );
    
    // Serialize to JSON as would be sent to client
    let json = serde_json::to_string(&api_error).unwrap();
    
    // Verify that internal path is exposed
    assert!(json.contains("/var/lib/aptos/db/state.db"), 
            "Internal file path should be exposed in current implementation");
    assert!(json.contains("Permission denied"),
            "System error details should be exposed in current implementation");
            
    println!("Leaked information in API response:\n{}", json);
}
```

## Notes
The error_converter module at [10](#0-9)  handles **Poem framework errors** separately and does expose their `to_string()` output, but the primary vulnerability is in how **application-level errors** from the database and storage layers are formatted using `{:#}` before being exposed through `BasicError` and other API error types.

The panic handler is correctly implemented and does not leak information [9](#0-8) , but regular error paths throughout the API expose sensitive details through the `AptosError` message field.

### Citations

**File:** storage/schemadb/src/lib.rs (L389-407)
```rust
fn to_db_err(rocksdb_err: rocksdb::Error) -> AptosDbError {
    match rocksdb_err.kind() {
        ErrorKind::Incomplete => AptosDbError::RocksDbIncompleteResult(rocksdb_err.to_string()),
        ErrorKind::NotFound
        | ErrorKind::Corruption
        | ErrorKind::NotSupported
        | ErrorKind::InvalidArgument
        | ErrorKind::IOError
        | ErrorKind::MergeInProgress
        | ErrorKind::ShutdownInProgress
        | ErrorKind::TimedOut
        | ErrorKind::Aborted
        | ErrorKind::Busy
        | ErrorKind::Expired
        | ErrorKind::TryAgain
        | ErrorKind::CompactionTooLarge
        | ErrorKind::ColumnFamilyDropped
        | ErrorKind::Unknown => AptosDbError::OtherRocksDbError(rocksdb_err.to_string()),
    }
```

**File:** api/src/context.rs (L160-168)
```rust
    pub fn latest_state_view_poem<E: InternalError>(
        &self,
        ledger_info: &LedgerInfo,
    ) -> Result<DbStateView, E> {
        self.db
            .latest_state_checkpoint_view()
            .context("Failed to read latest state checkpoint from DB")
            .map_err(|e| E::internal_with_code(e, AptosErrorCode::InternalError, ledger_info))
    }
```

**File:** api/src/context.rs (L382-391)
```rust
    pub fn get_state_value_poem<E: InternalError>(
        &self,
        state_key: &StateKey,
        version: u64,
        ledger_info: &LedgerInfo,
    ) -> Result<Option<Vec<u8>>, E> {
        self.get_state_value(state_key, version)
            .context("Failed to retrieve state value")
            .map_err(|e| E::internal_with_code(e, AptosErrorCode::InternalError, ledger_info))
    }
```

**File:** api/src/context.rs (L405-416)
```rust
    pub fn get_resource_poem<T: MoveResource, E: InternalError>(
        &self,
        address: AccountAddress,
        version: Version,
        latest_ledger_info: &LedgerInfo,
    ) -> Result<Option<T>, E> {
        self.get_resource(address, version)
            .context("Failed to read account resource.")
            .map_err(|err| {
                E::internal_with_code(err, AptosErrorCode::InternalError, latest_ledger_info)
            })
    }
```

**File:** api/types/src/error.rs (L29-37)
```rust
    pub fn new_with_error_code<ErrorType: std::fmt::Display>(
        error: ErrorType,
        error_code: AptosErrorCode,
    ) -> AptosError {
        Self {
            message: format!("{:#}", error),
            error_code,
            vm_error_code: None,
        }
```

**File:** api/src/response.rs (L137-161)
```rust
        #[derive(Debug, poem_openapi::ApiResponse)]
        pub enum $enum_name {
            $(
            #[oai(status = $status)]
            $name(poem_openapi::payload::Json<Box<aptos_api_types::AptosError>>,
                // We use just regular u64 here instead of U64 since all header
                // values are implicitly strings anyway.
                /// Chain ID of the current chain
                #[oai(header = "X-Aptos-Chain-Id")] Option<u8>,
                /// Current ledger version of the chain
                #[oai(header = "X-Aptos-Ledger-Version")] Option<u64>,
                /// Oldest non-pruned ledger version of the chain
                #[oai(header = "X-Aptos-Ledger-Oldest-Version")] Option<u64>,
                /// Current timestamp of the chain
                #[oai(header = "X-Aptos-Ledger-TimestampUsec")] Option<u64>,
                /// Current epoch of the chain
                #[oai(header = "X-Aptos-Epoch")] Option<u64>,
                /// Current block height of the chain
                #[oai(header = "X-Aptos-Block-Height")] Option<u64>,
                /// Oldest non-pruned block height of the chain
                #[oai(header = "X-Aptos-Oldest-Block-Height")] Option<u64>,
                /// The cost of the call in terms of gas
                #[oai(header = "X-Aptos-Gas-Used")] Option<u64>,
            ),
            )*
```

**File:** api/src/state.rs (L289-303)
```rust
        let bytes = state_view
            .as_converter(self.context.db.clone(), self.context.indexer_reader.clone())
            .find_resource(&state_view, address, &tag)
            .context(format!(
                "Failed to query DB to check for {} at {}",
                tag.to_canonical_string(),
                address
            ))
            .map_err(|err| {
                BasicErrorWith404::internal_with_code(
                    err,
                    AptosErrorCode::InternalError,
                    &ledger_info,
                )
            })?
```

**File:** api/src/error_converter.rs (L21-39)
```rust
pub async fn convert_error(error: poem::Error) -> impl poem::IntoResponse {
    // This is a bit of a hack but errors we return have no source, whereas
    // those returned by the framework do. As such, if we cannot downcast the
    // error we know it's one of ours and we just return it directly.
    let error_string = error.to_string();
    let is_framework_error = error.has_source();
    if is_framework_error {
        // Build the response.
        let mut response = error.into_response();
        // Replace the body with the response.
        response.set_body(build_error_response(error_string).take_body());
        response
            .headers_mut()
            .insert(CONTENT_TYPE, HeaderValue::from_static(JSON));
        response
    } else {
        error.into_response()
    }
}
```

**File:** api/src/error_converter.rs (L49-52)
```rust
pub fn panic_handler(err: Box<dyn Any + Send>) -> Response {
    error!("Panic captured: {:?}", err);
    build_panic_response("internal error".into())
}
```
