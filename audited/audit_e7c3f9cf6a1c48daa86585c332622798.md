# Audit Report

## Title
Indexer gRPC Data Service v2 Crashes on Client Requests When Both Services Disabled

## Summary
The indexer-grpc-data-service-v2 lacks startup validation to ensure at least one data service is enabled. When both `live_data_service_config.enabled` and `historical_data_service_config.enabled` are set to false, the service starts successfully and accepts gRPC connections, but crashes the entire process with `unreachable!()` panic when clients make `get_transactions()` requests.

## Finding Description

The vulnerability exists in the service initialization and request handling logic. The configuration allows both data services to be disabled without validation: [1](#0-0) [2](#0-1) 

When both services are disabled, the `create_live_data_service()` and `create_historical_data_service()` methods return `None`: [3](#0-2) [4](#0-3) 

The server starts successfully and creates a `DataServiceWrapperWrapper` with both services as `None`: [5](#0-4) [6](#0-5) 

When a client makes a `get_transactions()` request, the code path leads to an `unreachable!()` macro: [7](#0-6) 

The `unreachable!()` macro causes a panic, which is caught by the framework's panic handler that terminates the process: [8](#0-7) 

Crucially, there is no `validate()` method implementation in `IndexerGrpcDataServiceConfig`, so it uses the default trait implementation that always returns `Ok(())`: [9](#0-8) 

## Impact Explanation

This qualifies as **High Severity** under the Aptos Bug Bounty program's "API crashes" category. The impact includes:

1. **Service Unavailability**: The indexer service crashes completely on any client request, requiring manual restart
2. **Retry Storm Risk**: Clients will reconnect and retry, triggering repeated crashes
3. **Operational Confusion**: Service passes health checks and appears ready, but crashes on actual use
4. **Infrastructure Instability**: Repeated crash-restart cycles can destabilize the deployment environment

While this doesn't affect blockchain consensus or validator operations directly, it causes significant disruption to indexer infrastructure that applications rely on for querying blockchain data.

## Likelihood Explanation

**Likelihood: Medium to High**

This issue can occur through:
1. **Misconfiguration**: Operators accidentally setting both services to disabled
2. **Gradual Deployment**: Disabling services one at a time during maintenance
3. **Testing/Staging Environments**: Incomplete configuration files

The misconfiguration is easy to make and not caught until runtime when clients connect. The lack of startup validation means the service appears healthy in monitoring systems, making the issue difficult to diagnose.

## Recommendation

Add startup validation to ensure at least one data service is enabled. Implement the `validate()` method in `IndexerGrpcDataServiceConfig`:

```rust
impl RunnableConfig for IndexerGrpcDataServiceConfig {
    fn validate(&self) -> Result<()> {
        if !self.live_data_service_config.enabled 
            && !self.historical_data_service_config.enabled {
            anyhow::bail!(
                "At least one of live_data_service_config or historical_data_service_config must be enabled"
            );
        }
        Ok(())
    }

    async fn run(&self) -> Result<()> {
        // existing implementation
    }

    // ... other methods
}
```

Additionally, replace the `unreachable!()` with proper error handling as a defense-in-depth measure:

```rust
} else {
    Err(Status::failed_precondition(
        "No data services are enabled. Please enable at least one service."
    ))
}
```

## Proof of Concept

Create a test configuration file `test_config.yaml`:

```yaml
health_check_port: 8081
server_config:
  chain_id: 1
  service_config:
    listen_address: "0.0.0.0:50051"
  live_data_service_config:
    enabled: false
  historical_data_service_config:
    enabled: false
    file_store_config:
      file_store_type: "Local"
  grpc_manager_addresses: []
  self_advertised_address: "localhost:50051"
```

Steps to reproduce:
1. Start the service with the above configuration: `cargo run --bin indexer-grpc-data-service-v2 -- -c test_config.yaml`
2. Service starts successfully (no validation error)
3. Connect a gRPC client and call `GetTransactions`
4. Observe: Service crashes with panic at `unreachable!()` and exits with code 12
5. Check logs: Panic message shows the unreachable macro was reached

Expected behavior: Service should either refuse to start (with validation error) or return a proper gRPC error to the client.

## Notes

This vulnerability only affects the indexer-grpc-data-service-v2 component, not core blockchain consensus or validator operations. However, it represents a significant availability issue for applications depending on indexer services for querying historical blockchain data.

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/config.rs (L58-64)
```rust
pub struct LiveDataServiceConfig {
    pub enabled: bool,
    #[serde(default = "LiveDataServiceConfig::default_num_slots")]
    pub num_slots: usize,
    #[serde(default = "LiveDataServiceConfig::default_size_limit_bytes")]
    pub size_limit_bytes: usize,
}
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/config.rs (L78-81)
```rust
pub struct HistoricalDataServiceConfig {
    pub enabled: bool,
    pub file_store_config: IndexerGrpcFileStoreConfig,
}
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/config.rs (L111-113)
```rust
        if !self.live_data_service_config.enabled {
            return None;
        }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/config.rs (L161-163)
```rust
        if !self.historical_data_service_config.enabled {
            return None;
        }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/config.rs (L228-234)
```rust
        let live_data_service = self.create_live_data_service(&mut tasks).await;
        let historical_data_service = self.create_historical_data_service(&mut tasks).await;

        let wrapper = Arc::new(DataServiceWrapperWrapper::new(
            live_data_service,
            historical_data_service,
        ));
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/config.rs (L271-279)
```rust
        tasks.push(tokio::spawn(async move {
            server_builder
                .add_service(wrapper_service)
                .add_service(wrapper_service_raw)
                .add_service(reflection_service)
                .serve(listen_address)
                .await
                .map_err(|e| anyhow::anyhow!(e))
        }));
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/service.rs (L43-72)
```rust
    async fn get_transactions(
        &self,
        req: Request<GetTransactionsRequest>,
    ) -> Result<Response<Self::GetTransactionsStream>, Status> {
        if let Some(live_data_service) = self.live_data_service.as_ref() {
            if let Some(historical_data_service) = self.historical_data_service.as_ref() {
                let request = req.into_inner();
                let mut stream = live_data_service
                    .get_transactions(Request::new(request.clone()))
                    .await?
                    .into_inner();
                let peekable = std::pin::pin!(stream.as_mut().peekable());
                if let Some(Ok(_)) = peekable.peek().await {
                    return live_data_service
                        .get_transactions(Request::new(request.clone()))
                        .await;
                }

                historical_data_service
                    .get_transactions(Request::new(request))
                    .await
            } else {
                live_data_service.get_transactions(req).await
            }
        } else if let Some(historical_data_service) = self.historical_data_service.as_ref() {
            historical_data_service.get_transactions(req).await
        } else {
            unreachable!("Must have at least one of the data services enabled.");
        }
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-server-framework/src/lib.rs (L114-116)
```rust
    fn validate(&self) -> Result<()> {
        Ok(())
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-server-framework/src/lib.rs (L149-168)
```rust
pub fn setup_panic_handler() {
    std::panic::set_hook(Box::new(move |pi: &PanicHookInfo<'_>| {
        handle_panic(pi);
    }));
}

// Formats and logs panic information
fn handle_panic(panic_info: &PanicHookInfo<'_>) {
    // The Display formatter for a PanicHookInfo contains the message, payload and location.
    let details = format!("{}", panic_info);
    let backtrace = format!("{:#?}", Backtrace::new());
    let info = CrashInfo { details, backtrace };
    let crash_info = toml::to_string_pretty(&info).unwrap();
    error!("{}", crash_info);
    // TODO / HACK ALARM: Write crash info synchronously via eprintln! to ensure it is written before the process exits which error! doesn't guarantee.
    // This is a workaround until https://github.com/aptos-labs/aptos-core/issues/2038 is resolved.
    eprintln!("{}", crash_info);
    // Kill the process
    process::exit(12);
}
```
