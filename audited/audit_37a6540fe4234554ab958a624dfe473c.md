# Audit Report

## Title
Empty String Validation Bypass in Keyless Override Audience Configuration Allows Universal Account Recovery

## Summary
The `override_aud_vals` configuration field in the keyless authentication system does not validate against empty strings, potentially allowing a recovery service with `aud=""` to bypass intended audience restrictions and recover arbitrary keyless accounts.

## Finding Description

The keyless account system uses the `override_aud_vals` configuration to maintain an allow-list of trusted recovery service audience values. When a user wants to recover their account through a recovery service, the JWT from that service must have an `aud` value in this allow-list. [1](#0-0) 

The `add_override_aud_for_next_epoch` function accepts any `String` value without validation, including empty strings. There is no check to ensure the string is non-empty or meets minimum security requirements. [2](#0-1) 

The validation logic in `is_allowed_override_aud` performs simple string equality matching. If "" is in the list, it will match JWT claims with `aud=""`.

During OpenIdSig validation for account recovery: [3](#0-2) 

When `idc_aud_val` is provided (recovery mode), the code checks that the JWT's `aud` is in the allow-list, then uses `idc_aud_val` for IDC verification. If "" is allowed, a JWT with `aud=""` passes validation regardless of the original account's audience.

The pepper service has logic to handle recovery managers: [4](#0-3) 

If a recovery manager with `aud=""` is registered in the pepper service's `account_recovery_managers` list, it can request peppers for arbitrary `aud_override` values.

**Attack Path:**
1. Governance adds "" to `override_aud_vals` via proposal
2. A recovery service (malicious or compromised) is configured with `aud=""`
3. If the pepper service registers this as an account recovery manager, it gains universal recovery capability
4. When users sign into this service, it obtains JWTs with `aud=""`
5. The service can request peppers with any `aud_override` value
6. The service can then authenticate as the user for ANY keyless account by setting `idc_aud_val` to the target account's original `aud`

## Impact Explanation

**Severity: Medium to High**

If exploitable, this would allow:
- **Unauthorized Account Access**: A recovery service with `aud=""` could access any user's keyless accounts
- **Violation of Security Boundaries**: The intended restriction that recovery services only help with specific applications is bypassed
- **Trust Model Violation**: Users expect recovery services to be scoped to specific applications

However, the impact is limited by:
- Requires governance vote to add "" (detectable and reversible)
- Requires OIDC providers to issue `aud=""` tokens (violates OAuth/OIDC spec)
- Requires pepper service to register recovery manager with `aud=""` (may have additional validation)
- Users must actively sign in to the malicious service

This falls under **Medium Severity** (limited funds loss or manipulation) with potential for High depending on the number of affected users and whether the conditions can be met.

## Likelihood Explanation

**Likelihood: Low to Medium**

**Factors reducing likelihood:**
- OAuth/OIDC specification requires `aud` to be non-empty and identify specific recipients
- Legitimate OIDC providers (Google, Facebook, etc.) should not issue tokens with empty audience
- Governance would need to approve adding "" (suspicious and likely to be rejected)
- Pepper service may have additional validation preventing `aud=""` registration

**Factors increasing likelihood:**
- No technical validation prevents adding ""
- If one non-compliant OIDC provider exists, the attack becomes feasible
- Configuration mistakes happen

## Recommendation

Add validation to reject empty or semantically invalid audience values:

**In Move code** (`keyless_account.move`):
```move
public fun add_override_aud_for_next_epoch(fx: &signer, aud: String) acquires Configuration {
    system_addresses::assert_aptos_framework(fx);
    
    // Validate aud is non-empty
    assert!(!string::is_empty(&aud), E_INVALID_OVERRIDE_AUD);
    
    let config = if (config_buffer::does_exist<Configuration>()) {
        config_buffer::extract_v2<Configuration>()
    } else {
        *borrow_global<Configuration>(signer::address_of(fx))
    };
    
    vector::push_back(&mut config.override_aud_vals, aud);
    set_configuration_for_next_epoch(fx, config);
}
```

**In Rust code** (`configuration.rs`):
```rust
pub fn is_allowed_override_aud(&self, override_aud_val: &String) -> Result<(), VMStatus> {
    // Reject empty strings
    if override_aud_val.is_empty() {
        return Err(invalid_signature!(
            "override aud cannot be empty"
        ));
    }
    
    let matches = self
        .override_aud_vals
        .iter()
        .filter(|&e| e.eq(override_aud_val))
        .count();

    if matches == 0 {
        Err(invalid_signature!(format!(
            "override aud is not allow-listed in 0x1::{}",
            KEYLESS_ACCOUNT_MODULE_NAME
        )))
    } else {
        Ok(())
    }
}
```

Additional recommendations:
- Add minimum length requirement (e.g., 3 characters)
- Consider format validation (e.g., must be valid URL or domain)
- Document the security implications clearly
- Add monitoring/alerting for suspicious override_aud additions

## Proof of Concept

```move
#[test(framework = @aptos_framework)]
#[expected_failure(abort_code = E_INVALID_OVERRIDE_AUD)]
fun test_empty_override_aud_rejected(framework: &signer) {
    use aptos_framework::keyless_account;
    use std::string;
    
    // Attempt to add empty string as override aud
    keyless_account::add_override_aud_for_next_epoch(
        framework,
        string::utf8(b"")  // Empty string
    );
    // Should fail with E_INVALID_OVERRIDE_AUD
}
```

## Notes

This vulnerability requires multiple conditions to align for successful exploitation. The primary defense is that compliant OIDC providers should not issue tokens with empty `aud` values. However, defense-in-depth principles dictate that input validation should prevent semantically invalid values even if they're unlikely to occur in practice.

The issue is exacerbated if any OIDC provider (including custom/federated providers) can be configured to issue `aud=""` tokens, or if there are edge cases in JWT parsing that treat missing/null `aud` as empty string.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/keyless_account.move (L343-355)
```text
    public fun add_override_aud_for_next_epoch(fx: &signer, aud: String) acquires Configuration {
        system_addresses::assert_aptos_framework(fx);

        let config = if (config_buffer::does_exist<Configuration>()) {
            config_buffer::extract_v2<Configuration>()
        } else {
            *borrow_global<Configuration>(signer::address_of(fx))
        };

        vector::push_back(&mut config.override_aud_vals, aud);

        set_configuration_for_next_epoch(fx, config);
    }
```

**File:** types/src/keyless/configuration.rs (L81-96)
```rust
    pub fn is_allowed_override_aud(&self, override_aud_val: &String) -> Result<(), VMStatus> {
        let matches = self
            .override_aud_vals
            .iter()
            .filter(|&e| e.eq(override_aud_val))
            .count();

        if matches == 0 {
            Err(invalid_signature!(format!(
                "override aud is not allow-listed in 0x1::{}",
                KEYLESS_ACCOUNT_MODULE_NAME
            )))
        } else {
            Ok(())
        }
    }
```

**File:** types/src/keyless/openid_sig.rs (L88-101)
```rust
        let idc_aud_val = match self.idc_aud_val.as_ref() {
            None => &claims.oidc_claims.aud,
            Some(idc_aud_val) => {
                // If there's an override, check that the override `aud` from the JWT, is allow-listed
                ensure!(
                    config
                        .is_allowed_override_aud(&claims.oidc_claims.aud)
                        .is_ok(),
                    "{} is not an allow-listed override aud",
                    &claims.oidc_claims.aud
                );
                idc_aud_val
            },
        };
```

**File:** keyless/pepper/service/src/dedicated_handlers/pepper_request.rs (L205-225)
```rust
    // Get the aud for the pepper input. Note: if the request is from an account
    // recovery manager, we will override the aud and generate the pepper input
    // with the overridden aud. This is useful for pepper recovery.
    let aud = if account_recovery_managers.contains(&iss, &claims_aud) {
        match aud_override {
            Some(aud_override) => aud_override, // Use the overridden aud
            None => {
                return Err(PepperServiceError::UnexpectedError(format!(
                    "The issuer {} and aud {} correspond to an account recovery manager, but no aud override was provided!",
                    &iss, &claims_aud
                )));
            },
        }
    } else if let Some(aud_override) = aud_override {
        return Err(PepperServiceError::UnexpectedError(format!(
            "The issuer {} and aud {} do not correspond to an account recovery manager, but an aud override was provided: {}!",
            &iss, &claims_aud, &aud_override
        )));
    } else {
        claims_aud // Use the aud directly from the claims
    };
```
