# Audit Report

## Title
Missing Validator Signature Verification in Cross-Epoch Range Proof Verification

## Summary
The `check_range_proof` database debugger tool fails to verify validator signatures on LedgerInfo objects when checking range proofs across epoch boundaries. This allows the tool to accept forged or corrupted LedgerInfo entries without detection, undermining its purpose as a database integrity verification utility.

## Finding Description

The `Cmd::run()` function in the range proof checker retrieves LedgerInfo objects for multiple epochs but never verifies their validator signatures. [1](#0-0) 

When a version range spans epoch boundaries, the function loops through each epoch and retrieves the corresponding LedgerInfo. [2](#0-1) 

However, it only uses these LedgerInfo objects to verify the transaction accumulator hash against range proofs, without verifying that the LedgerInfo signatures are valid for that epoch's validator set. [3](#0-2) 

The correct verification pattern used throughout the codebase requires:
1. Retrieving the epoch state containing the validator verifier for each epoch [4](#0-3) 
2. Verifying that the LedgerInfo's epoch matches the expected epoch
3. Verifying signatures using that epoch's validator set [5](#0-4) 

Examples of proper verification are found in trusted state verification [6](#0-5)  and consensus observer verification [7](#0-6) .

The signature verification method is available but unused: [8](#0-7) 

## Impact Explanation

This issue represents a **High Severity** vulnerability under the category of "Significant protocol violations" because it undermines database integrity verification, which is critical for operational security.

If a validator's database becomes corrupted (through disk errors, malware, or insider threats), this verification tool will report success even when LedgerInfo entries contain:
- Invalid signatures from wrong validator sets
- Forged signatures that don't represent actual validator consensus
- LedgerInfo objects from different epochs with mismatched validator sets

This creates a false sense of security during incident response and database recovery procedures, potentially allowing corrupted data to persist or propagate through state synchronization mechanisms.

## Likelihood Explanation

The likelihood is **MEDIUM** because:

**Required conditions:**
1. Database corruption or malicious modification (through disk errors, filesystem attacks, or insider access)
2. Operator relies on this tool to verify database integrity
3. Cross-epoch range verification is performed

**Realistic scenarios:**
- Disk corruption affecting LedgerInfo storage
- Malware targeting validator node databases
- Insider threats with filesystem access
- Hardware failures during epoch transitions
- Database migration or recovery procedures

While the tool requires database access to exploit, database integrity verification is a critical operational function, and failures in verification tools can have cascading security effects.

## Recommendation

Add validator signature verification for each epoch's LedgerInfo using the correct epoch state:

```rust
pub fn run(self) -> Result<()> {
    let ledger_db = Arc::new(self.db_dir.open_ledger_db()?);
    let ledger_metadata_db = ledger_db.metadata_db();
    let ledger_info = ledger_metadata_db.get_latest_ledger_info()?;
    println!("Latest LedgerInfo: {:?}", ledger_info);

    println!("Checking Range proof...");

    let txn_infos: Vec<_> = ledger_db
        .transaction_info_db()
        .get_transaction_info_iter(self.start_version, self.num_versions)?
        .collect::<Result<_>>()?;
    ensure!(
        txn_infos.len() == self.num_versions,
        "expecting {} txns, got {}",
        self.num_versions,
        txn_infos.len(),
    );
    let txn_info_hashes: Vec<_> = txn_infos.iter().map(CryptoHash::hash).collect();

    let last_version = self.start_version + self.num_versions as u64 - 1;
    let last_version_epoch = ledger_metadata_db.get_epoch(last_version)?;
    for epoch in last_version_epoch..=ledger_info.ledger_info().epoch() {
        println!("Check against epoch {} LedgerInfo.", epoch);
        let li = ledger_metadata_db.get_latest_ledger_info_in_epoch(epoch)?;
        
        // ADD SIGNATURE VERIFICATION HERE
        let epoch_state = ledger_metadata_db.get_epoch_state(epoch)?;
        epoch_state.verify(&li)?;
        println!("    Signatures verified for epoch {}", epoch);
        
        println!(
            "    Root hash: {:?}",
            li.ledger_info().transaction_accumulator_hash()
        );
        let range_proof = ledger_db
            .transaction_accumulator_db()
            .get_transaction_range_proof(
                Some(self.start_version),
                self.num_versions as u64,
                li.ledger_info().version(),
            )?;
        range_proof.verify(
            li.ledger_info().transaction_accumulator_hash(),
            Some(self.start_version),
            &txn_info_hashes,
        )?;
    }

    println!("Done.");
    Ok(())
}
```

## Proof of Concept

```rust
// Test demonstrating the vulnerability
// Place in storage/aptosdb/src/db_debugger/ledger/check_range_proof.rs tests module

#[cfg(test)]
mod tests {
    use super::*;
    use aptos_crypto::bls12381;
    use aptos_types::{
        aggregate_signature::AggregateSignature,
        ledger_info::{LedgerInfo, LedgerInfoWithSignatures},
        block_info::BlockInfo,
    };

    #[test]
    fn test_missing_signature_verification() {
        // Create a LedgerInfo with an empty (invalid) signature
        let block_info = BlockInfo::empty();
        let ledger_info = LedgerInfo::new(block_info, HashValue::zero());
        
        // Create LedgerInfoWithSignatures with EMPTY signatures (invalid)
        let li_with_invalid_sigs = LedgerInfoWithSignatures::new(
            ledger_info,
            AggregateSignature::empty(), // Invalid signature!
        );
        
        // The current implementation would accept this LedgerInfo
        // without verifying signatures, allowing corrupted data to pass
        // verification.
        
        // To properly verify, we need:
        // let epoch_state = get_epoch_state(epoch)?;
        // epoch_state.verify(&li_with_invalid_sigs)?; // This would FAIL
        
        // But current code never calls verify, so invalid signatures
        // are accepted during range proof checking.
    }
}
```

**Steps to reproduce:**
1. Set up an AptosDB with transactions spanning multiple epochs
2. Manually corrupt a LedgerInfo entry in the database by replacing its signatures with invalid data
3. Run the check_range_proof tool on a range spanning the corrupted epoch
4. Observe that the tool reports "Done" successfully despite the invalid signatures
5. Compare with proper verification that would fail on the corrupted LedgerInfo

### Citations

**File:** storage/aptosdb/src/db_debugger/ledger/check_range_proof.rs (L45-66)
```rust
        let last_version = self.start_version + self.num_versions as u64 - 1;
        let last_version_epoch = ledger_metadata_db.get_epoch(last_version)?;
        for epoch in last_version_epoch..=ledger_info.ledger_info().epoch() {
            println!("Check against epoch {} LedgerInfo.", epoch);
            let li = ledger_metadata_db.get_latest_ledger_info_in_epoch(epoch)?;
            println!(
                "    Root hash: {:?}",
                li.ledger_info().transaction_accumulator_hash()
            );
            let range_proof = ledger_db
                .transaction_accumulator_db()
                .get_transaction_range_proof(
                    Some(self.start_version),
                    self.num_versions as u64,
                    li.ledger_info().version(),
                )?;
            range_proof.verify(
                li.ledger_info().transaction_accumulator_hash(),
                Some(self.start_version),
                &txn_info_hashes,
            )?;
        }
```

**File:** storage/aptosdb/src/ledger_db/ledger_metadata_db.rs (L135-154)
```rust
    pub(crate) fn get_epoch_state(&self, epoch: u64) -> Result<EpochState> {
        ensure!(epoch > 0, "EpochState only queryable for epoch >= 1.",);

        let ledger_info_with_sigs =
            self.db
                .get::<LedgerInfoSchema>(&(epoch - 1))?
                .ok_or_else(|| {
                    AptosDbError::NotFound(format!("Last LedgerInfo of epoch {}", epoch - 1))
                })?;
        let latest_epoch_state = ledger_info_with_sigs
            .ledger_info()
            .next_epoch_state()
            .ok_or_else(|| {
                AptosDbError::Other(
                    "Last LedgerInfo in epoch must carry next_epoch_state.".to_string(),
                )
            })?;

        Ok(latest_epoch_state.clone())
    }
```

**File:** types/src/epoch_state.rs (L41-50)
```rust
    fn verify(&self, ledger_info: &LedgerInfoWithSignatures) -> anyhow::Result<()> {
        ensure!(
            self.epoch == ledger_info.ledger_info().epoch(),
            "LedgerInfo has unexpected epoch {}, expected {}",
            ledger_info.ledger_info().epoch(),
            self.epoch
        );
        ledger_info.verify_signatures(&self.verifier)?;
        Ok(())
    }
```

**File:** types/src/trusted_state.rs (L180-182)
```rust
            } else if latest_li.ledger_info().epoch() == new_epoch {
                new_epoch_state.verify(latest_li)?;
                latest_li
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L728-730)
```rust
        let epoch_state = self.get_epoch_state();
        if ordered_block.proof_block_info().epoch() == epoch_state.epoch {
            if let Err(error) = ordered_block.verify_ordered_proof(&epoch_state) {
```

**File:** types/src/ledger_info.rs (L303-308)
```rust
    pub fn verify_signatures(
        &self,
        validator: &ValidatorVerifier,
    ) -> ::std::result::Result<(), VerifyError> {
        validator.verify_multi_signatures(self.ledger_info(), &self.signatures)
    }
```
