# Audit Report

## Title
JWK Version Rollback Attack via Issuer Removal and Replay

## Summary
A critical vulnerability exists in the JWK (JSON Web Key) consensus mechanism that allows an attacker to roll back JWK versions to previous states containing potentially revoked or outdated keys. When an issuer is removed from `ObservedJWKs` via governance and subsequently re-added through validator consensus, the version counter resets to 0, allowing old `QuorumCertifiedUpdate` transactions with version 1 to be replayed, reintroducing previously superseded or revoked cryptographic keys.

## Finding Description

The vulnerability exists in the interaction between three components:

1. **Version Reset on Issuer Removal**: When governance removes an issuer from `ObservedJWKs`, the issuer's version history is lost. [1](#0-0) 

2. **Rust VM Version Validation**: The VM validates that the observed version equals the on-chain version + 1. However, when an issuer doesn't exist on-chain, it creates a new `ProviderJWKs` with version 0, allowing version 1 updates to pass validation. [2](#0-1) 

3. **No Epoch-Based Replay Protection**: The `QuorumCertifiedUpdate` structure contains only the `ProviderJWKs` and aggregate signature, with no epoch number or nonce to prevent cross-epoch replay. [3](#0-2) 

**Attack Scenario:**

1. Issuer "alice" progresses from version 1 (with key K1) to version 5 (with key K5, after K1 was compromised/revoked)
2. Governance removes issuer "alice" via `remove_issuer_from_observed_jwks()` for legitimate reasons (e.g., policy change)
3. JWK consensus manager detects the removal and updates its internal state, where `on_chain_version()` now returns 0 for "alice" [4](#0-3) 
4. Attacker obtains historical blockchain data containing the original `QuorumCertifiedUpdate` for version 1 (publicly available)
5. Attacker submits this old validator transaction to the network
6. Rust validation creates a new `ProviderJWKs` with version 0, checks `0 + 1 != 1` (passes), verifies the multi-sig against the current validator set (passes if sufficient validator overlap exists)
7. In per-issuer mode, Move contract performs NO additional version validation, directly upserting the old keys [5](#0-4) 

The revoked key K1 is now active again, potentially enabling authentication bypass for keyless accounts.

**Broken Invariants:**
- **Cryptographic Correctness**: Revoked cryptographic keys can be re-enabled
- **State Consistency**: Version monotonicity is violated through issuer removal
- **Authentication Security**: Users relying on keyless authentication are vulnerable to compromised keys

## Impact Explanation

**Critical Severity (up to $1,000,000)**

This vulnerability enables:

1. **Authentication Bypass**: Revoked JWKs that were rotated due to compromise can be reintroduced, allowing attackers who possess the compromised private keys to forge valid JWT signatures
2. **Security Update Rollback**: Cryptographic improvements (e.g., stronger key lengths, algorithm updates) in newer versions can be undone
3. **Compliance Violations**: Organizations that removed providers for compliance reasons could have them reintroduced without authorization
4. **Consensus Safety Risk**: Different validators could have inconsistent views of valid JWKs if replay occurs during epoch transitions

This meets the Critical severity criteria for "Consensus/Safety violations" and could lead to "Loss of Funds" through unauthorized account access in keyless authentication systems.

## Likelihood Explanation

**Likelihood: MEDIUM to HIGH**

Required conditions:
1. **Governance Removal**: An issuer must be legitimately removed (MEDIUM - happens for security/policy reasons)
2. **Validator Set Overlap**: Sufficient validators from the original signing set must remain in the current validator set (HIGH - validator sets are relatively stable)
3. **Historical Data Access**: Attacker needs old `QuorumCertifiedUpdate` transactions (HIGH - blockchain data is public)
4. **No Epoch Binding**: No replay protection exists beyond version numbers (CONFIRMED)

The attack doesn't require validator collusion or privileged access - any network participant can submit validator transactions. Governance-initiated issuer removals occur naturally during provider rotations, security incidents, or policy changes.

## Recommendation

Implement multi-layered replay protection:

1. **Add Epoch Binding to QuorumCertifiedUpdate**:
```rust
// In types/src/jwks/mod.rs
#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize, CryptoHasher, BCSCryptoHash)]
pub struct QuorumCertifiedUpdate {
    pub epoch: u64,  // Add epoch field
    pub update: ProviderJWKs,
    pub multi_sig: AggregateSignature,
}
```

2. **Validate Epoch in VM Processing**:
```rust
// In aptos-move/aptos-vm/src/validator_txns/jwk.rs
fn process_jwk_update_inner(..., update: jwks::QuorumCertifiedUpdate) -> Result<...> {
    // Add epoch check
    let current_epoch = reconfiguration::current_epoch();
    if update.epoch != current_epoch {
        return Err(Expected(InvalidEpoch));
    }
    // ... existing validation
}
```

3. **Preserve Version History on Removal**:
Store removed issuer versions in a separate resource to prevent version reuse:
```move
// In jwks.move
struct RemovedIssuers has key {
    // Track highest version ever used by each issuer
    max_versions: SimpleMap<vector<u8>, u64>,
}

// Validate minimum version on re-addition
if (simple_map::contains_key(&removed.max_versions, &issuer)) {
    let min_version = *simple_map::borrow(&removed.max_versions, &issuer) + 1;
    assert!(proposed_provider_jwks.version >= min_version, EVERSION_TOO_LOW);
}
```

4. **Add Move-Side Version Validation for Per-Issuer Mode**:
```move
// In upsert_into_observed_jwks, per-issuer mode branch
let maybe_existing = get_provider_jwks(&observed_jwks.jwks, &provider_jwks.issuer);
if (option::is_some(&maybe_existing)) {
    let existing = option::borrow(&maybe_existing);
    assert!(existing.version + 1 == provider_jwks.version, EUNEXPECTED_VERSION);
}
```

## Proof of Concept

**Rust Test Scenario** (pseudo-code for `aptos-move/aptos-vm/src/validator_txns/jwk.rs`):

```rust
#[test]
fn test_jwk_version_rollback_via_removal() {
    // 1. Initialize issuer with version 1
    let issuer = b"alice".to_vec();
    let jwks_v1 = ProviderJWKs { issuer: issuer.clone(), version: 1, jwks: vec![old_jwk] };
    let qc_update_v1 = create_quorum_certified_update(jwks_v1, &validators);
    
    // 2. Process update to version 1 (succeeds)
    process_jwk_update(&vm, &resolver, qc_update_v1.clone()).unwrap();
    
    // 3. Update to version 5
    for v in 2..=5 {
        let jwks = ProviderJWKs { issuer: issuer.clone(), version: v, jwks: vec![new_jwk] };
        let qc_update = create_quorum_certified_update(jwks, &validators);
        process_jwk_update(&vm, &resolver, qc_update).unwrap();
    }
    
    // 4. Governance removes issuer
    call_move_function("jwks::remove_issuer_from_observed_jwks", vec![issuer.clone()]);
    
    // 5. Replay old version 1 update (should fail but currently succeeds)
    let result = process_jwk_update(&vm, &resolver, qc_update_v1);
    
    // Expected: Err(IncorrectVersion) or Err(ReplayDetected)
    // Actual: Ok(_) - VULNERABILITY CONFIRMED
    assert!(result.is_ok(), "Version rollback attack succeeded");
    
    // 6. Verify old revoked keys are now active
    let on_chain = get_observed_jwks();
    assert_eq!(on_chain.get_provider_jwks(&issuer).unwrap().version, 1);
    // Revoked keys from version 1 are now active!
}
```

**Move Test Scenario** (for `aptos-move/framework/aptos-framework/sources/jwks.move`):

```move
#[test(fx = @aptos_framework)]
fun test_version_rollback_after_removal(fx: &signer) {
    initialize_for_test(fx);
    
    // Setup: Create issuer with version 5
    let alice_v5 = ProviderJWKs { 
        issuer: b"alice", 
        version: 5, 
        jwks: vector[secure_jwk] 
    };
    upsert_into_observed_jwks(fx, vector[alice_v5]);
    
    // Governance removes issuer
    remove_issuer_from_observed_jwks(fx, b"alice");
    
    // Attacker replays old version 1 (with revoked keys)
    let alice_v1_replay = ProviderJWKs { 
        issuer: b"alice", 
        version: 1, 
        jwks: vector[revoked_jwk] 
    };
    
    // This should fail but succeeds - VULNERABILITY
    upsert_into_observed_jwks(fx, vector[alice_v1_replay]);
    
    // Revoked keys are now active!
    let observed = borrow_global<ObservedJWKs>(@aptos_framework);
    assert!(observed.jwks.entries[0].version == 1, 0);
}
```

This vulnerability represents a critical flaw in the JWK consensus replay protection mechanism, enabling version rollback attacks that can reintroduce revoked cryptographic keys and compromise keyless authentication security.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/jwks.move (L496-500)
```text
        } else {
            vector::for_each(provider_jwks_vec, |provider_jwks| {
                upsert_provider_jwks(&mut observed_jwks.jwks, provider_jwks);
            });
        };
```

**File:** aptos-move/framework/aptos-framework/sources/jwks.move (L510-520)
```text
    public fun remove_issuer_from_observed_jwks(fx: &signer, issuer: vector<u8>): Option<ProviderJWKs> acquires ObservedJWKs, PatchedJWKs, Patches {
        system_addresses::assert_aptos_framework(fx);
        let observed_jwks = borrow_global_mut<ObservedJWKs>(@aptos_framework);
        let old_value = remove_issuer(&mut observed_jwks.jwks, issuer);

        let epoch = reconfiguration::current_epoch();
        emit(ObservedJWKsUpdated { epoch, jwks: observed_jwks.jwks });
        regenerate_patched_jwks();

        old_value
    }
```

**File:** aptos-move/aptos-vm/src/validator_txns/jwk.rs (L114-130)
```rust
        let mut jwks_by_issuer: HashMap<Issuer, ProviderJWKs> =
            observed_jwks.into_providers_jwks().into();
        let issuer = update.update.issuer.clone();
        let on_chain = jwks_by_issuer
            .entry(issuer.clone())
            .or_insert_with(|| ProviderJWKs::new(issuer));
        let verifier = ValidatorVerifier::from(&validator_set);

        let QuorumCertifiedUpdate {
            update: observed,
            multi_sig,
        } = update;

        // Check version.
        if on_chain.version + 1 != observed.version {
            return Err(Expected(IncorrectVersion));
        }
```

**File:** types/src/jwks/mod.rs (L303-307)
```rust
#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize, CryptoHasher, BCSCryptoHash)]
pub struct QuorumCertifiedUpdate {
    pub update: ProviderJWKs,
    pub multi_sig: AggregateSignature,
}
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager/mod.rs (L377-381)
```rust
    pub fn on_chain_version(&self) -> u64 {
        self.on_chain
            .as_ref()
            .map_or(0, |provider_jwks| provider_jwks.version)
    }
```
