# Audit Report

## Title
Private Key Exposure Through CLI Error Messages in Account Address Parser

## Summary
The `load_account_arg` function used as a clap `value_parser` for the `--account` parameter does not sanitize input values in error messages. When parsing fails, clap's default error formatter includes the invalid input value in the error output, which can leak private key material if a user accidentally passes a private key instead of an account address.

## Finding Description

The `CreateAccount` command (and many other CLI commands) uses `load_account_arg` as the value parser for account address arguments. [1](#0-0) 

The `load_account_arg` function attempts to parse the input string in three ways, and if all fail, returns a generic error message. [2](#0-1) 

However, when clap 4.3.9 (the version used in this codebase) receives an error from a value_parser, it formats the error message to include the invalid value that failed to parse. [3](#0-2) 

The styling configuration confirms that invalid values are displayed during parsing. [4](#0-3) 

When a user accidentally provides a private key hex string (e.g., a 64-character hex string meant for a different parameter), clap will display an error message in the format:
```
error: invalid value '<private_key_hex>' for '--account <ACCOUNT>': Invalid arguments: '--account' or '--profile' after using aptos init must be provided
```

This exposes the private key material in:
- Terminal output visible on screen
- Shell history in some configurations  
- Log files if terminal output is redirected
- Screenshots or screen recordings shared for debugging

The codebase demonstrates awareness of private key sensitivity through the use of `SilentDebug` and `SilentDisplay` derives for private key types. [5](#0-4) 

However, this protection only applies when PrivateKey objects are formatted, not when the private key exists as a raw string in user input.

## Impact Explanation

This vulnerability represents a **High Severity** information disclosure issue. While it doesn't directly cause loss of funds through the blockchain protocol, private key exposure enables complete account compromise:

1. **Complete Account Takeover**: An exposed private key allows an attacker to sign arbitrary transactions, transfer all funds, and fully control the account
2. **Persistent Exposure**: Once leaked, the private key cannot be "unleaked" - the account must be abandoned
3. **Secondary Exposure Vectors**: Error messages may be captured in logs, terminal recordings, screenshots shared in support channels, or visible to observers

The likelihood of occurrence is **Medium to High** because:
- New users frequently confuse private keys with account addresses
- The `--account` parameter appears in many commonly-used commands
- No warning is given that the input will be echoed in error messages
- Private key hex strings may have similar format to address strings (both hex-encoded)

This does not fit cleanly into the traditional blockchain security categories (consensus, state management, etc.) as it's a CLI security issue. However, it breaks the **Cryptographic Correctness** invariant that sensitive cryptographic material must be protected from exposure.

## Likelihood Explanation

The likelihood is **Medium** due to several factors:

**Factors Increasing Likelihood:**
- New users commonly confuse private keys with addresses, especially when following tutorials or documentation
- The format similarity between 64-character hex private keys and account addresses (also hex)
- Multiple commands use `--account` parameter, increasing exposure surface
- Error scenarios (wrong parameters, typos) are common during initial CLI use

**Factors Decreasing Likelihood:**
- Requires user error (accidentally providing private key instead of address)
- Experienced users understand the distinction between keys and addresses
- The error only occurs when parsing fails (not during successful operations)

## Recommendation

Implement input sanitization in the error path to prevent sensitive data from being exposed in error messages. The fix should:

1. **Detect potentially sensitive input**: Check if the input string resembles a private key (e.g., 64-character hex string, starts with 0x and has 64+ hex chars)
2. **Redact sensitive values**: Replace detected sensitive values with a placeholder like `<redacted-potential-private-key>` in error messages
3. **Apply sanitization before returning error**: Sanitize the input before it reaches clap's error formatter

Recommended implementation in `load_account_arg`:

```rust
pub fn load_account_arg(str: &str) -> Result<AccountAddress, CliError> {
    // Try parsing as before...
    if let Ok(account_address) = AccountAddress::from_str(str) {
        Ok(account_address)
    } else if let Some(Some(account_address)) =
        CliConfig::load_profile(Some(str), ConfigSearchMode::CurrentDirAndParents)?
            .map(|p| p.account)
    {
        Ok(account_address)
    } else if let Some(Some(private_key)) =
        CliConfig::load_profile(Some(str), ConfigSearchMode::CurrentDirAndParents)?
            .map(|p| p.private_key)
    {
        let public_key = private_key.public_key();
        Ok(account_address_from_public_key(&public_key))
    } else {
        // Sanitize error message - check if input looks like a private key
        let sanitized_input = if is_potentially_sensitive(str) {
            "<redacted-potential-private-key>".to_string()
        } else {
            str.to_string()
        };
        
        Err(CliError::CommandArgumentError(
            format!("Invalid account address '{}': '--account' or '--profile' after using aptos init must be provided", sanitized_input)
        ))
    }
}

fn is_potentially_sensitive(s: &str) -> bool {
    // Check if string looks like a private key (64+ hex chars)
    let hex_part = s.strip_prefix("0x").unwrap_or(s);
    hex_part.len() >= 64 && hex_part.chars().all(|c| c.is_ascii_hexdigit())
}
```

Alternatively, use a wrapper type that implements custom Display to redact sensitive values before they reach clap.

## Proof of Concept

**Reproduction Steps:**

1. Run the Aptos CLI with a private key passed to `--account`:
```bash
aptos account create --account 0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef
```

2. Expected vulnerable output (current behavior):
```
error: invalid value '0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef' for '--account <ACCOUNT>': Invalid arguments: '--account' or '--profile' after using aptos init must be provided
```

The 64-character hex string (representing a private key) is displayed in plaintext in the error message.

3. Expected secure output (after fix):
```
error: invalid value '<redacted-potential-private-key>' for '--account <ACCOUNT>': Invalid arguments: '--account' or '--profile' after using aptos init must be provided
```

**Verification:**
This can be tested by examining terminal output, log files, or shell history after running the command with a private-key-like input to any command that uses `load_account_arg` as a value_parser.

## Notes

While this vulnerability requires user error to trigger, the security implications are severe. Private key exposure results in complete account compromise, and the error output may persist in logs, screenshots, or terminal history. The codebase demonstrates clear intent to protect private keys through `SilentDebug` and `SilentDisplay` derives, indicating this exposure is inconsistent with the security design. The fix is straightforward and should be applied to all CLI argument parsers that might receive sensitive input.

### Citations

**File:** crates/aptos/src/account/create.rs (L21-22)
```rust
    #[clap(long, value_parser = crate::common::types::load_account_arg)]
    pub(crate) account: AccountAddress,
```

**File:** crates/aptos/src/common/types.rs (L1369-1388)
```rust
pub fn load_account_arg(str: &str) -> Result<AccountAddress, CliError> {
    if let Ok(account_address) = AccountAddress::from_str(str) {
        Ok(account_address)
    } else if let Some(Some(account_address)) =
        CliConfig::load_profile(Some(str), ConfigSearchMode::CurrentDirAndParents)?
            .map(|p| p.account)
    {
        Ok(account_address)
    } else if let Some(Some(private_key)) =
        CliConfig::load_profile(Some(str), ConfigSearchMode::CurrentDirAndParents)?
            .map(|p| p.private_key)
    {
        let public_key = private_key.public_key();
        Ok(account_address_from_public_key(&public_key))
    } else {
        Err(CliError::CommandArgumentError(
            "'--account' or '--profile' after using aptos init must be provided".to_string(),
        ))
    }
}
```

**File:** Cargo.toml (L554-559)
```text
clap = { version = "4.3.9", features = [
    "derive",
    "env",
    "unstable-styles",
    "wrap_help",
] }
```

**File:** crates/aptos-cli-common/src/lib.rs (L29-31)
```rust
        // Invalid value during parsing
        // To test: `aptos account create --account not-a-number`
        .invalid(Style::new().fg_color(Some(Ansi(AnsiColor::Yellow))))
```

**File:** crates/aptos-crypto/src/ed25519/ed25519_keys.rs (L1-50)
```rust
// Copyright (c) Aptos Foundation
// Licensed pursuant to the Innovation-Enabling Source Code License, available at https://github.com/aptos-labs/aptos-core/blob/main/LICENSE

//! This file implements traits for Ed25519 private keys and public keys.

#[cfg(any(test, feature = "fuzzing"))]
use crate::test_utils::{self, KeyPair};
use crate::{
    ed25519::{Ed25519Signature, ED25519_PRIVATE_KEY_LENGTH, ED25519_PUBLIC_KEY_LENGTH},
    hash::CryptoHash,
    traits::*,
};
use aptos_crypto_derive::{DeserializeKey, SerializeKey, SilentDebug, SilentDisplay};
use core::convert::TryFrom;
use curve25519_dalek::{edwards::CompressedEdwardsY, scalar::Scalar};
use ed25519_dalek::ExpandedSecretKey;
#[cfg(any(test, feature = "fuzzing"))]
use proptest::prelude::*;
use serde::Serialize;
use std::fmt;

/// An Ed25519 private key
#[derive(DeserializeKey, SerializeKey, SilentDebug, SilentDisplay)]
pub struct Ed25519PrivateKey(pub(crate) ed25519_dalek::SecretKey);

#[cfg(feature = "assert-private-keys-not-cloneable")]
static_assertions::assert_not_impl_any!(Ed25519PrivateKey: Clone);

#[cfg(any(test, feature = "cloneable-private-keys"))]
impl Clone for Ed25519PrivateKey {
    fn clone(&self) -> Self {
        let serialized: &[u8] = &(self.to_bytes());
        Ed25519PrivateKey::try_from(serialized).unwrap()
    }
}

/// An Ed25519 public key
#[derive(DeserializeKey, Clone, SerializeKey)]
pub struct Ed25519PublicKey(pub(crate) ed25519_dalek::PublicKey);

#[cfg(any(test, feature = "fuzzing"))]
impl<'a> arbitrary::Arbitrary<'a> for Ed25519PublicKey {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let bytes: [u8; ED25519_PUBLIC_KEY_LENGTH] = u.arbitrary()?;
        Ed25519PublicKey::from_bytes_unchecked(&bytes)
            .map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

impl Ed25519PrivateKey {
```
