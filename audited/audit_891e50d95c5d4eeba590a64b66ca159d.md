# Audit Report

## Title
Waypoint Verification Allows Permanent Node DoS via Non-Epoch-Ending Version

## Summary
The waypoint verification system does not validate that a waypoint is positioned at an epoch-ending version when loaded from configuration. An attacker with file system access can set a waypoint at a non-epoch-ending version, causing the node to panic during state synchronization and permanently preventing it from syncing to current state or participating in consensus.

## Finding Description

The Aptos blockchain uses waypoints as trusted checkpoints to verify state synchronization after node restarts. Waypoints should always be positioned at epoch-ending versions where the network commits epoch change transactions. However, the waypoint loading mechanism fails to enforce this critical invariant.

**The vulnerability exists in two stages:**

**Stage 1: Insufficient Validation at Load Time**

When a waypoint is loaded from a file, the `Waypoint::from_str()` method only validates the format (version:hash) but does not verify that the version corresponds to an epoch-ending ledger info: [1](#0-0) 

The `WaypointConfig::waypoint()` method loads waypoints from files without any semantic validation: [2](#0-1) 

**Stage 2: Panic During Synchronization**

During state synchronization, the bootstrapper fetches epoch-ending ledger infos sequentially and attempts to verify the waypoint. When a waypoint is at a non-epoch-ending version (e.g., version 1250 between epochs ending at 1000 and 2000), the node will never receive a ledger info at exactly that version. When it processes the next epoch-ending ledger info (version 2000 > 1250), the verification logic panics: [3](#0-2) 

**Attack Scenario:**

1. Attacker gains file system access to the waypoint file (commonly at `/opt/aptos/genesis/waypoint.txt`)
2. Attacker modifies the waypoint to a version between epoch boundaries: `1250:0123456789abcdef...`
3. Node restarts and loads the invalid waypoint via `WaypointConfig::waypoint()`
4. Node begins state sync and fetches epoch-ending ledger infos (versions 1000, 2000, 3000...)
5. When processing epoch-ending ledger info at version 2000, the panic condition triggers at line 144-149
6. Node terminates and cannot proceed with synchronization
7. Node cannot sync to current state or participate in consensus

The vulnerability breaks the **availability invariant** - nodes must be able to sync to current state to participate in the network.

## Impact Explanation

This vulnerability qualifies as **HIGH severity** under the Aptos bug bounty program criteria:

**"Validator node slowdowns"** - The vulnerability causes complete denial of service for affected nodes. Specifically:

- **Validator nodes** cannot participate in consensus, reducing the effective validator set size
- **Full nodes** cannot serve current blockchain state to clients
- Requires manual intervention (waypoint correction and node restart) to recover
- No automatic recovery mechanism exists

The impact is amplified because:
- Multiple nodes can be affected if they share waypoint configuration sources
- Validators experiencing this issue miss participation rewards and may face performance penalties
- Network liveness could be impacted if multiple validators are affected simultaneously
- The attack is persistent - the node will panic on every restart attempt until the waypoint file is corrected

## Likelihood Explanation

**Likelihood: Medium to High**

The attack requires:
- File system access to the waypoint configuration file
- Knowledge of the attack vector (non-epoch-ending version)

**Factors increasing likelihood:**
- Waypoint files are often stored in predictable, accessible locations (e.g., `/opt/aptos/genesis/waypoint.txt`)
- In cloud deployments, configuration management systems may have broad access
- Automated deployment tools may inadvertently introduce malformed waypoints
- No warning or validation during node startup - the issue only manifests during sync
- The attack is simple - modifying a single line in a text file
- No cryptographic knowledge required

**Factors decreasing likelihood:**
- Requires some level of system access
- Operators typically have restricted file system permissions
- Most waypoints are set during genesis and rarely modified

## Recommendation

Implement validation that waypoints must be at epoch-ending versions when loaded from configuration:

**Recommended Fix:**

1. Add a validation method to `Waypoint` that checks if a version is at an epoch boundary by verifying against storage
2. Validate waypoints during node startup before beginning synchronization
3. Provide clear error messages when validation fails

```rust
// In types/src/waypoint.rs
impl Waypoint {
    /// Validates that this waypoint is at an epoch-ending version
    pub fn validate_epoch_boundary(&self, storage: &dyn DbReader) -> Result<()> {
        // If waypoint is at genesis, it's always valid
        if self.version == 0 {
            return Ok(());
        }
        
        // Fetch the ledger info at the waypoint version
        let ledger_info = storage
            .get_ledger_info_by_version(self.version)
            .map_err(|e| format_err!(
                "Waypoint validation failed: cannot fetch ledger info at version {}. Error: {:?}",
                self.version, e
            ))?;
        
        // Verify it ends an epoch
        ensure!(
            ledger_info.ledger_info().ends_epoch(),
            "Waypoint validation failed: version {} is not at an epoch boundary",
            self.version
        );
        
        // Verify the hash matches
        self.verify(ledger_info.ledger_info())?;
        
        Ok(())
    }
}

// In state-sync/state-sync-driver/src/bootstrapper.rs
// At the start of verify_waypoint_is_satisfiable(), add:
fn verify_waypoint_is_satisfiable(
    &mut self,
    global_data_summary: &GlobalDataSummary,
) -> Result<(), Error> {
    // Validate waypoint is at epoch boundary
    if !self.verified_epoch_states.verified_waypoint() {
        if let Err(e) = self.driver_configuration.waypoint.validate_epoch_boundary(self.storage.as_ref()) {
            warn!("Waypoint validation failed: {:?}", e);
            // If storage doesn't have the waypoint version yet, we'll verify it during sync
            // But we should at least check if we've already passed it
        }
    }
    
    // ... existing code
}
```

Alternatively, for a more defensive approach during waypoint loading:

```rust
// In config/src/config/base_config.rs
impl WaypointConfig {
    pub fn waypoint(&self) -> Waypoint {
        let waypoint = match &self {
            // ... existing match arms
        };
        let waypoint = waypoint.expect("waypoint should be present");
        
        // Log a warning if waypoint version suggests it might not be at epoch boundary
        // (This is a heuristic check - exact validation requires storage access)
        if waypoint.version() % 1000 != 0 && waypoint.version() != 0 {
            warn!(
                "Waypoint at version {} may not be at an epoch boundary. \
                 Ensure this version corresponds to an epoch-ending transaction.",
                waypoint.version()
            );
        }
        
        waypoint
    }
}
```

## Proof of Concept

```rust
#[test]
#[should_panic(expected = "Failed to verify the waypoint: ledger info version is too high")]
fn test_waypoint_at_non_epoch_ending_version_causes_panic() {
    use aptos_types::waypoint::Waypoint;
    use std::str::FromStr;
    
    // Create a waypoint at a non-epoch-ending version (e.g., version 1250)
    let non_epoch_waypoint = Waypoint::from_str(
        "1250:0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef"
    ).unwrap();
    
    // Create a driver configuration with this waypoint
    let mut driver_configuration = create_full_node_driver_configuration();
    driver_configuration.waypoint = non_epoch_waypoint;
    
    // Create mock streaming client that returns epoch ending ledger infos
    let mut mock_streaming_client = create_mock_streaming_client();
    let (mut notification_sender, data_stream_listener) = create_data_stream_listener();
    mock_streaming_client
        .expect_get_all_epoch_ending_ledger_infos()
        .with(eq(1))
        .return_once(move |_| Ok(data_stream_listener));
    
    // Create bootstrapper
    let (mut bootstrapper, _) = create_bootstrapper(
        driver_configuration, 
        mock_streaming_client, 
        None, 
        true
    );
    
    // Create global data summary with epoch endings beyond the waypoint
    let global_data_summary = create_global_summary_with_version(2, 2000);
    
    // Drive progress to initialize epoch ending data stream
    drive_progress(&mut bootstrapper, &global_data_summary, false)
        .await
        .unwrap();
    
    // Send epoch ending ledger infos that skip over the waypoint version
    // Epochs end at versions: 1000, 2000, 3000...
    // Waypoint is at version 1250 (not an epoch ending)
    let mut epoch_ending_ledger_infos = vec![];
    epoch_ending_ledger_infos.push(create_random_epoch_ending_ledger_info(1000, 1));
    epoch_ending_ledger_infos.push(create_random_epoch_ending_ledger_info(2000, 2));
    
    let data_notification = DataNotification::new(
        0,
        DataPayload::EpochEndingLedgerInfos(epoch_ending_ledger_infos),
    );
    notification_sender.send(data_notification).await.unwrap();
    
    // Drive progress to process epoch ending ledger infos
    // This will panic when processing version 2000 (> 1250) because waypoint hasn't been verified
    drive_progress(&mut bootstrapper, &global_data_summary, false)
        .await
        .unwrap();
}
```

**Notes**

The vulnerability demonstrates a critical gap in waypoint validation - the system assumes waypoints are always positioned at epoch-ending versions but does not enforce this assumption. The panic mechanism in `verify_waypoint()` that is intended to catch waypoint mismatches instead becomes a denial-of-service vector when combined with insufficient input validation. While the attack requires file system access, this is a realistic threat model for cloud deployments, configuration management systems, or compromised operator machines.

### Citations

**File:** types/src/waypoint.rs (L108-124)
```rust
impl FromStr for Waypoint {
    type Err = Error;

    fn from_str(s: &str) -> Result<Self> {
        let mut split = s.split(WAYPOINT_DELIMITER);
        let version = split
            .next()
            .ok_or_else(|| format_err!("Failed to parse waypoint string {}", s))?
            .parse::<Version>()?;
        let value = HashValue::from_hex(
            split
                .next()
                .ok_or_else(|| format_err!("Failed to parse waypoint string {}", s))?,
        )?;
        Ok(Self { version, value })
    }
}
```

**File:** config/src/config/base_config.rs (L74-110)
```rust
    pub fn waypoint(&self) -> Waypoint {
        let waypoint = match &self {
            WaypointConfig::FromConfig(waypoint) => Some(*waypoint),
            WaypointConfig::FromFile(waypoint_path) => {
                if !waypoint_path.exists() {
                    panic!(
                        "Waypoint file not found! Ensure the given path is correct: {:?}",
                        waypoint_path.display()
                    );
                }
                let content = fs::read_to_string(waypoint_path).unwrap_or_else(|error| {
                    panic!(
                        "Failed to read waypoint file {:?}. Error: {:?}",
                        waypoint_path.display(),
                        error
                    )
                });
                Some(Waypoint::from_str(content.trim()).unwrap_or_else(|error| {
                    panic!(
                        "Failed to parse waypoint: {:?}. Error: {:?}",
                        content.trim(),
                        error
                    )
                }))
            },
            WaypointConfig::FromStorage(backend) => {
                let storage: Storage = backend.into();
                let waypoint = storage
                    .get::<Waypoint>(aptos_global_constants::WAYPOINT)
                    .expect("Unable to read waypoint")
                    .value;
                Some(waypoint)
            },
            WaypointConfig::None => None,
        };
        waypoint.expect("waypoint should be present")
    }
```

**File:** state-sync/state-sync-driver/src/bootstrapper.rs (L132-166)
```rust
    fn verify_waypoint(
        &mut self,
        epoch_ending_ledger_info: &LedgerInfoWithSignatures,
        waypoint: &Waypoint,
    ) -> Result<(), Error> {
        if !self.verified_waypoint {
            // Fetch the waypoint and ledger info versions
            let waypoint_version = waypoint.version();
            let ledger_info = epoch_ending_ledger_info.ledger_info();
            let ledger_info_version = ledger_info.version();

            // Verify we haven't missed the waypoint
            if ledger_info_version > waypoint_version {
                panic!(
                    "Failed to verify the waypoint: ledger info version is too high! Waypoint version: {:?}, ledger info version: {:?}",
                    waypoint_version, ledger_info_version
                );
            }

            // Check if we've found the ledger info corresponding to the waypoint version
            if ledger_info_version == waypoint_version {
                match waypoint.verify(ledger_info) {
                    Ok(()) => self.set_verified_waypoint(waypoint_version),
                    Err(error) => {
                        panic!(
                            "Failed to verify the waypoint: {:?}! Waypoint: {:?}, given ledger info: {:?}",
                            error, waypoint, ledger_info
                        );
                    },
                }
            }
        }

        Ok(())
    }
```
