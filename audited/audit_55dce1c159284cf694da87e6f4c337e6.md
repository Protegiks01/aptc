# Audit Report

## Title
Insufficient StateKey Validation and Panic-Based Error Handling in Cross-Shard Message Processing Enables Denial of Service

## Summary
The `RemoteTxnWrite` struct in the sharded block executor lacks proper validation of `StateKey` variants and internal structure. When cross-shard messages are received, the code fails to validate that the StateKey is in the expected dependency set before processing, and uses panic-inducing `.unwrap()` calls instead of graceful error handling. This allows malformed or unexpected StateKeys to crash shard execution threads, causing denial of service.

## Finding Description

The `RemoteTxnWrite` struct contains a `StateKey` that is deserialized from network messages in remote execution mode without sufficient validation: [1](#0-0) 

When messages are received, the deserialization uses `.unwrap()` which panics on any BCS deserialization error: [2](#0-1) 

More critically, after successful deserialization, the receiver processes the StateKey without validating it belongs to the expected cross-shard dependency set: [3](#0-2) 

This calls `set_value` which uses `.unwrap()` assuming the StateKey exists in the HashMap: [4](#0-3) 

Additionally, `StateKey` deserialization has incomplete validation. While `AccessPath` variants validate the internal path bytes, `TableItem` and `Raw` variants accept arbitrary data without validation: [5](#0-4) 

The `Raw` variant is marked as test-only but has no runtime enforcement: [6](#0-5) 

Finally, remote cross-shard messages have no cryptographic authentication, relying solely on network-level security: [7](#0-6) 

**Attack Scenario:**
1. In remote execution mode, shards communicate via `NetworkController` which lacks message authentication
2. An attacker with network access (or a compromised shard, or a software bug producing invalid StateKeys) sends a `RemoteTxnWrite` with either:
   - A StateKey not in the receiving shard's expected dependency set
   - A malformed StateKey that fails deserialization
   - A `Raw` variant StateKey (test-only in production)
3. The receiving thread panics due to `.unwrap()` failures
4. The rayon scope propagates the panic, causing `execute_transactions_with_dependencies` to fail
5. Block execution fails on the affected shard

## Impact Explanation

This vulnerability meets **High Severity** criteria per the Aptos bug bounty program:
- **Validator node slowdowns/crashes**: Panics in execution threads cause shard execution failures
- **Significant protocol violations**: Breaks the liveness and deterministic execution invariants

While not a consensus safety violation, this is a liveness attack that can halt block production on affected shards. Multiple targeted shards could halt the entire sharded execution system.

The impact is limited by:
- Remote execution mode may not be used in standard validator deployments
- Requires network access to inter-shard communication channels
- Does not affect consensus safety directly, only availability

## Likelihood Explanation

**Likelihood: Medium to High** depending on deployment:

In remote execution environments:
- Network message injection requires either compromised infrastructure or network vulnerabilities
- No authentication makes injection trivial once network access is obtained
- Software bugs in partitioner or VM could also produce invalid StateKeys

The lack of defensive programming (validation + error handling) makes this more likely to be triggered accidentally by bugs even without malicious intent.

## Recommendation

Implement defense-in-depth with multiple layers of protection:

**1. Add StateKey validation before processing:**
```rust
// In CrossShardCommitReceiver::start
RemoteTxnWriteMsg(txn_commit_msg) => {
    let (state_key, write_op) = txn_commit_msg.take();
    // Validate the StateKey is expected
    if !cross_shard_state_view.contains_key(&state_key) {
        warn!("Received unexpected StateKey in cross-shard message: {:?}", state_key);
        continue; // Skip instead of panic
    }
    cross_shard_state_view.set_value(&state_key, write_op.and_then(|w| w.as_state_value()));
}
```

**2. Replace `.unwrap()` with proper error handling:**
```rust
// In RemoteCrossShardClient::receive_cross_shard_msg
fn receive_cross_shard_msg(&self, current_round: RoundId) -> CrossShardMsg {
    let rx = self.message_rxs[current_round].lock().unwrap();
    let message = rx.recv().unwrap();
    match bcs::from_bytes(&message.to_bytes()) {
        Ok(msg) => msg,
        Err(e) => {
            error!("Failed to deserialize cross-shard message: {}", e);
            CrossShardMsg::StopMsg // Or return error type
        }
    }
}
```

**3. Add runtime enforcement for Raw variant:**
```rust
// In StateKey::from_deserialized
StateKeyInner::Raw(bytes) => {
    if !cfg!(any(test, feature = "fuzzing")) {
        return Err(anyhow::anyhow!("Raw StateKey variant not allowed in production"));
    }
    Self::raw(&bytes)
}
```

**4. Add message authentication:**
```rust
// Add HMAC or signature verification to NetworkController messages
// Use validator keys to authenticate cross-shard messages
```

**5. Validate TableItem structure:**
```rust
// Add validation that TableHandle corresponds to an actual table
// Validate key bytes are properly formatted
```

## Proof of Concept

```rust
#[cfg(test)]
mod exploit_poc {
    use super::*;
    use aptos_types::state_store::state_key::StateKey;
    use aptos_vm::sharded_block_executor::messages::{CrossShardMsg, RemoteTxnWrite};
    
    #[test]
    #[should_panic(expected = "called `Option::unwrap()` on a `None` value")]
    fn test_unexpected_statekey_causes_panic() {
        // Setup: Create a CrossShardStateView with specific expected keys
        let expected_key = StateKey::raw(b"expected_key");
        let mut expected_keys = HashSet::new();
        expected_keys.insert(expected_key.clone());
        
        let base_view = EmptyView;
        let cross_shard_view = Arc::new(CrossShardStateView::new(expected_keys, &base_view));
        
        // Attack: Send a RemoteTxnWrite with unexpected StateKey
        let malicious_key = StateKey::raw(b"malicious_unexpected_key");
        
        // This will panic with unwrap() on None
        cross_shard_view.set_value(&malicious_key, None);
        // PANIC: thread panics, execution fails
    }
    
    #[test]
    #[should_panic]
    fn test_malformed_statekey_deserialization_panic() {
        // Attack: Craft malformed BCS bytes that fail StateKey deserialization
        let malformed_msg = vec![
            0x00, // RemoteTxnWriteMsg variant
            0xFF, // Invalid StateKeyInner variant index
            0x00, 0x00, 0x00, 0x00, // Garbage data
        ];
        
        // This will panic on unwrap() in RemoteCrossShardClient::receive_cross_shard_msg
        let _: CrossShardMsg = bcs::from_bytes(&malformed_msg).unwrap();
        // PANIC: deserialization fails
    }
}
```

## Notes

This vulnerability specifically affects **remote sharded execution mode** using `RemoteCrossShardClient`. Standard validator deployments using `LocalCrossShardClient` (in-memory channels) are less vulnerable but still have the validation gaps. The core issue is insufficient defensive programmingâ€”even in trusted network environments, proper input validation and error handling are essential security practices.

### Citations

**File:** aptos-move/aptos-vm/src/sharded_block_executor/messages.rs (L13-18)
```rust
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct RemoteTxnWrite {
    state_key: StateKey,
    // The write op is None if the transaction is aborted.
    write_op: Option<WriteOp>,
}
```

**File:** execution/executor-service/src/remote_cross_shard_client.rs (L61-66)
```rust
    fn receive_cross_shard_msg(&self, current_round: RoundId) -> CrossShardMsg {
        let rx = self.message_rxs[current_round].lock().unwrap();
        let message = rx.recv().unwrap();
        let msg: CrossShardMsg = bcs::from_bytes(&message.to_bytes()).unwrap();
        msg
    }
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/cross_shard_client.rs (L31-38)
```rust
        loop {
            let msg = cross_shard_client.receive_cross_shard_msg(round);
            match msg {
                RemoteTxnWriteMsg(txn_commit_msg) => {
                    let (state_key, write_op) = txn_commit_msg.take();
                    cross_shard_state_view
                        .set_value(&state_key, write_op.and_then(|w| w.as_state_value()));
                },
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/cross_shard_state_view.rs (L49-56)
```rust
    pub fn set_value(&self, state_key: &StateKey, state_value: Option<StateValue>) {
        self.cross_shard_data
            .get(state_key)
            .unwrap()
            .set_value(state_value);
        // uncomment the following line to debug waiting count
        // trace!("waiting count for shard id {} is {}", self.shard_id, self.waiting_count());
    }
```

**File:** types/src/state_store/state_key/mod.rs (L110-137)
```rust
    pub fn from_deserialized(deserialized: StateKeyInner) -> Result<Self> {
        use access_path::Path;

        let myself = match deserialized {
            StateKeyInner::AccessPath(AccessPath { address, path }) => {
                match bcs::from_bytes::<Path>(&path) {
                    Err(err) => {
                        if cfg!(feature = "fuzzing") {
                            // note: to make analyze-serde-formats test happy, do not error out
                            //       alternative is to wrap `AccessPath::path: Vec<u8>` in an enum
                            Self::raw(&bcs::to_bytes(&(address, path)).unwrap())
                        } else {
                            return Err(err.into());
                        }
                    },
                    Ok(Path::Code(module_id)) => Self::module_id(&module_id),
                    Ok(Path::Resource(struct_tag)) => Self::resource(&address, &struct_tag)?,
                    Ok(Path::ResourceGroup(struct_tag)) => {
                        Self::resource_group(&address, &struct_tag)
                    },
                }
            },
            StateKeyInner::TableItem { handle, key } => Self::table_item(&handle, &key),
            StateKeyInner::Raw(bytes) => Self::raw(&bytes),
        };

        Ok(myself)
    }
```

**File:** types/src/state_store/state_key/inner.rs (L46-59)
```rust
#[derive(Clone, CryptoHasher, Eq, PartialEq, Serialize, Deserialize, Ord, PartialOrd, Hash)]
#[cfg_attr(any(test, feature = "fuzzing"), derive(proptest_derive::Arbitrary))]
#[serde(rename = "StateKey")]
pub enum StateKeyInner {
    AccessPath(AccessPath),
    TableItem {
        handle: TableHandle,
        #[serde(with = "serde_bytes")]
        key: Vec<u8>,
    },
    // Only used for testing
    #[serde(with = "serde_bytes")]
    Raw(Vec<u8>),
}
```

**File:** secure/net/src/network_controller/mod.rs (L56-70)
```rust
#[derive(Clone, Debug, Deserialize, Serialize)]
#[allow(dead_code)]
pub struct Message {
    pub data: Vec<u8>,
}

impl Message {
    pub fn new(data: Vec<u8>) -> Self {
        Self { data }
    }

    pub fn to_bytes(self) -> Vec<u8> {
        self.data
    }
}
```
