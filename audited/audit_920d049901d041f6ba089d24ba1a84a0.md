# Audit Report

## Title
Critical Consensus Safety Violation: Missing Validation in Sharded Block Executor Aggregation Allows Transaction Ordering Corruption

## Summary
The sharded block executor's aggregation logic assumes all shards return the same number of rounds without validation, creating a critical vulnerability where malicious remote executors can cause consensus safety violations, validator crashes, or transaction ordering corruption by returning inconsistent round counts.

## Finding Description

The sharded block executor aggregates execution results from multiple shards using a formula that assumes all shards return identical numbers of rounds. However, this invariant is never validated in production code. [1](#0-0) 

The critical flaw is on line 98, where `num_rounds` is determined **only** from the first shard (`sharded_output[0].len()`), then used to allocate an array and aggregate results from **all** shards using the formula `round * num_executor_shards + shard_id`.

**Attack Scenario 1 - Validator Crash:**
If a malicious remote executor returns more rounds than shard 0:
- Array allocated: `vec![vec![]; 3 * 2]` (assuming shard 0 has 3 rounds, 2 shards total)
- Malicious shard 1 returns 4 rounds
- When processing shard 1's round 3: index = `3 * 2 + 1 = 7` → **OUT OF BOUNDS PANIC**

**Attack Scenario 2 - Transaction Ordering Corruption:**
If a malicious remote executor returns fewer rounds than shard 0:
- Array allocated: `vec![vec![]; 4 * 2]` (assuming shard 0 has 4 rounds)
- Malicious shard 1 returns 3 rounds
- Slots at indices 7 remain empty (`vec![]`)
- These empty vectors are extended into `aggregated_results`, causing **missing transactions** and **wrong ordering**

The same vulnerability exists in the total supply aggregation logic: [2](#0-1) 

**Exploitation Path:**
1. Validator runs with remote executor shards configured
2. Malicious remote shard receives execution request with N sub-blocks
3. Malicious shard returns M rounds where M ≠ N (crafted `RemoteExecutionResult`)
4. Coordinator's deserialization succeeds (valid BCS structure) [3](#0-2) 
5. No validation checks round count consistency
6. Aggregation logic either panics or produces corrupted output

**Why the Invariant Can Be Violated:**

The partitioner guarantees all shards receive the same number of sub-blocks: [4](#0-3) 

However, this guarantee only applies to the **input**. The remote executor can arbitrarily modify the **output** structure, and there's no validation that the output matches the input.

Validation exists only in test code: [5](#0-4) 

## Impact Explanation

**Critical Severity** - This vulnerability qualifies for the highest bounty tier ($1,000,000) as it enables:

1. **Consensus Safety Violations**: If different validators have different remote executors (one malicious, one honest), they will produce different transaction orderings and state roots for the same block, breaking the fundamental "Deterministic Execution" invariant. This causes non-recoverable chain splits requiring a hard fork.

2. **Validator Crashes**: The out-of-bounds panic causes complete validator unavailability, contributing to network liveness loss. If multiple validators are affected, this could approach the 1/3 threshold for total network failure.

3. **Transaction Ordering Corruption**: Missing or misplaced transactions violate state consistency guarantees, potentially causing fund loss scenarios where transactions are executed in unintended orders.

## Likelihood Explanation

**Likelihood: Medium-High**

While the vulnerability requires a compromised remote executor shard, the attack complexity is low:
- No cryptographic primitives need to be broken
- Simply requires sending back a valid BCS-serialized response with wrong structure
- No authentication beyond network-level controls
- Single compromised remote executor affects the entire validator node

In distributed deployments where validators use remote execution services, a compromised service provider or supply chain attack could exploit this. The lack of defense-in-depth (no validation whatsoever) makes this particularly concerning.

## Recommendation

Add explicit validation that all shards return the expected number of rounds before aggregation:

```rust
pub fn execute_block(
    &self,
    state_view: Arc<S>,
    transactions: PartitionedTransactions,
    concurrency_level_per_shard: usize,
    onchain_config: BlockExecutorConfigFromOnchain,
) -> Result<Vec<TransactionOutput>, VMStatus> {
    let _timer = SHARDED_BLOCK_EXECUTION_SECONDS.start_timer();
    let num_executor_shards = self.executor_client.num_shards();
    NUM_EXECUTOR_SHARDS.set(num_executor_shards as i64);
    
    // Get expected number of rounds from input
    let expected_num_rounds = transactions.sharded_txns()[0].num_sub_blocks();
    
    let (sharded_output, global_output) = self
        .executor_client
        .execute_block(
            state_view,
            transactions,
            concurrency_level_per_shard,
            onchain_config,
        )?
        .into_inner();
    
    // VALIDATE: All shards must return the same number of rounds
    let num_rounds = sharded_output[0].len();
    if num_rounds != expected_num_rounds {
        return Err(VMStatus::error(
            StatusCode::INTERNAL_ERROR,
            Some("Shard 0 returned unexpected number of rounds".to_string())
        ));
    }
    
    for (shard_id, results_from_shard) in sharded_output.iter().enumerate().skip(1) {
        if results_from_shard.len() != num_rounds {
            return Err(VMStatus::error(
                StatusCode::INTERNAL_ERROR,
                Some(format!(
                    "Shard {} returned {} rounds, expected {}",
                    shard_id,
                    results_from_shard.len(),
                    num_rounds
                ))
            ));
        }
    }
    
    // ... rest of aggregation logic
}
```

Apply similar validation in `sharded_aggregator_service.rs`.

## Proof of Concept

```rust
#[cfg(test)]
mod test_aggregation_vulnerability {
    use super::*;
    use aptos_types::transaction::TransactionOutput;
    
    #[test]
    #[should_panic(expected = "index out of bounds")]
    fn test_inconsistent_rounds_causes_panic() {
        // Simulate scenario where shard 0 has 3 rounds, shard 1 has 4 rounds
        let num_executor_shards = 2;
        
        // Shard 0: 3 rounds
        let shard_0_output = vec![
            vec![TransactionOutput::default()], // Round 0
            vec![TransactionOutput::default()], // Round 1
            vec![TransactionOutput::default()], // Round 2
        ];
        
        // Shard 1: 4 rounds (malicious)
        let shard_1_output = vec![
            vec![TransactionOutput::default()], // Round 0
            vec![TransactionOutput::default()], // Round 1
            vec![TransactionOutput::default()], // Round 2
            vec![TransactionOutput::default()], // Round 3 - EXTRA ROUND
        ];
        
        let sharded_output = vec![shard_0_output, shard_1_output];
        
        // This is the vulnerable aggregation logic from mod.rs:98-110
        let num_rounds = sharded_output[0].len(); // Gets 3 from shard 0
        let mut ordered_results = vec![vec![]; num_executor_shards * num_rounds]; // Size: 6
        
        // This will panic when processing shard 1's round 3
        for (shard_id, results_from_shard) in sharded_output.into_iter().enumerate() {
            for (round, result) in results_from_shard.into_iter().enumerate() {
                // When shard_id=1, round=3: index = 3*2+1 = 7, but array size is 6
                ordered_results[round * num_executor_shards + shard_id] = result;
            }
        }
    }
    
    #[test]
    fn test_inconsistent_rounds_causes_missing_transactions() {
        // Simulate scenario where shard 0 has 4 rounds, shard 1 has 3 rounds
        let num_executor_shards = 2;
        
        // Shard 0: 4 rounds
        let shard_0_output = vec![
            vec![TransactionOutput::default()],
            vec![TransactionOutput::default()],
            vec![TransactionOutput::default()],
            vec![TransactionOutput::default()],
        ];
        
        // Shard 1: 3 rounds (malicious - missing last round)
        let shard_1_output = vec![
            vec![TransactionOutput::default()],
            vec![TransactionOutput::default()],
            vec![TransactionOutput::default()],
        ];
        
        let sharded_output = vec![shard_0_output, shard_1_output];
        
        let num_rounds = sharded_output[0].len(); // Gets 4
        let mut ordered_results = vec![vec![]; num_executor_shards * num_rounds]; // Size: 8
        let mut aggregated_results = vec![];
        
        for (shard_id, results_from_shard) in sharded_output.into_iter().enumerate() {
            for (round, result) in results_from_shard.into_iter().enumerate() {
                ordered_results[round * num_executor_shards + shard_id] = result;
            }
        }
        
        // Index 7 (round=3, shard=1) remains as empty vec![]
        assert!(ordered_results[7].is_empty(), "Missing transaction slot");
        
        for result in ordered_results.into_iter() {
            aggregated_results.extend(result);
        }
        
        // aggregated_results now has wrong structure with missing transactions
        assert_eq!(aggregated_results.len(), 7, "Should have 8 but has 7 due to empty slot");
    }
}
```

## Notes

This vulnerability demonstrates a critical failure in defensive programming where an implicit invariant (all shards return same number of rounds) is assumed but never validated. While the partitioner guarantees uniform input distribution, the remote execution model allows untrusted actors to violate output structure assumptions. The lack of validation creates a consensus-critical attack surface exploitable by compromised remote executors or network-level attackers capable of message manipulation.

### Citations

**File:** aptos-move/aptos-vm/src/sharded_block_executor/mod.rs (L98-110)
```rust
        let num_rounds = sharded_output[0].len();
        let mut aggregated_results = vec![];
        let mut ordered_results = vec![vec![]; num_executor_shards * num_rounds];
        // Append the output from individual shards in the round order
        for (shard_id, results_from_shard) in sharded_output.into_iter().enumerate() {
            for (round, result) in results_from_shard.into_iter().enumerate() {
                ordered_results[round * num_executor_shards + shard_id] = result;
            }
        }

        for result in ordered_results.into_iter() {
            aggregated_results.extend(result);
        }
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/sharded_aggregator_service.rs (L174-175)
```rust
    let num_shards = sharded_output.len();
    let num_rounds = sharded_output[0].len();
```

**File:** execution/executor-service/src/remote_executor_client.rs (L163-172)
```rust
    fn get_output_from_shards(&self) -> Result<Vec<Vec<Vec<TransactionOutput>>>, VMStatus> {
        trace!("RemoteExecutorClient Waiting for results");
        let mut results = vec![];
        for rx in self.result_rxs.iter() {
            let received_bytes = rx.recv().unwrap().to_bytes();
            let result: RemoteExecutionResult = bcs::from_bytes(&received_bytes).unwrap();
            results.push(result.inner?);
        }
        Ok(results)
    }
```

**File:** execution/block-partitioner/src/v2/build_edge.rs (L72-86)
```rust
        let final_num_rounds = state.sub_block_matrix.len();
        let sharded_txns = (0..state.num_executor_shards)
            .map(|shard_id| {
                let sub_blocks: Vec<SubBlock<AnalyzedTransaction>> = (0..final_num_rounds)
                    .map(|round_id| {
                        state.sub_block_matrix[round_id][shard_id]
                            .lock()
                            .unwrap()
                            .take()
                            .unwrap()
                    })
                    .collect();
                SubBlocksForShard::new(shard_id, sub_blocks)
            })
            .collect();
```

**File:** execution/block-partitioner/src/test_utils.rs (L170-172)
```rust
    for sub_block_list in output.sharded_txns().iter().take(num_shards).skip(1) {
        assert_eq!(num_rounds, sub_block_list.sub_blocks.len());
    }
```
