# Audit Report

## Title
Indexer gRPC Data Service Crashes on Misconfiguration Due to Reachable `unreachable!()` Panic

## Summary
The indexer-grpc-data-service-v2 contains a reachable `unreachable!()` panic in `DataServiceWrapperWrapper::get_transactions()` that can be triggered when both live and historical data services are disabled in the configuration. This causes the service to crash immediately upon receiving any transaction request, leading to a denial of service.

## Finding Description
The vulnerability exists in the interaction between configuration loading and service initialization. The `IndexerGrpcDataServiceConfig` does not validate that at least one data service (live or historical) is enabled before starting the server. [1](#0-0) [2](#0-1) 

Both `create_live_data_service()` and `create_historical_data_service()` return `None` when their respective `enabled` flags are set to `false`. These None values are then passed to the `DataServiceWrapperWrapper` constructor: [3](#0-2) 

The constructor accepts both services as `Option<DataServiceWrapper>` without any validation: [4](#0-3) 

The critical issue occurs in the `get_transactions()` method. When both services are `None`, the code reaches an `unreachable!()` macro that was intended as a programming assertion but is actually reachable through misconfiguration: [5](#0-4) 

When this panic occurs, the panic handler terminates the entire service process: [6](#0-5) 

The configuration validation is handled by the `RunnableConfig` trait, but `IndexerGrpcDataServiceConfig` does not override the default `validate()` method: [7](#0-6) 

This allows an invalid configuration (both services disabled) to pass validation and start the service, which then crashes on the first client request.

## Impact Explanation
This vulnerability qualifies as **High Severity** per Aptos bug bounty criteria because it causes API crashes. The indexer gRPC data service is a critical API component that provides transaction data to clients, explorers, and other ecosystem services. When this service crashes:

1. All connected clients lose their data streams
2. The service must be manually restarted
3. Transaction indexing is disrupted
4. Dependent applications experience downtime

While this does not directly affect consensus or validator operations, it severely impacts the availability and reliability of the indexer infrastructure, which is essential for the Aptos ecosystem.

## Likelihood Explanation
The likelihood is **Medium to High** because:

1. **Configuration errors are common**: Operators may accidentally disable both services during testing, migration, or misconfiguration
2. **No validation prevents it**: The service accepts invalid configurations and starts successfully
3. **Silent failure mode**: The error only manifests when a client makes a request, not during startup
4. **Clear attack vector**: An operator following incomplete or outdated documentation might deploy with both services disabled
5. **Cascading failure**: Once deployed with this configuration, every client request triggers a crash, requiring manual intervention

The vulnerability does not require attacker access to configuration files - a simple operational mistake is sufficient to trigger it.

## Recommendation
Implement configuration validation in the `IndexerGrpcDataServiceConfig::validate()` method to ensure at least one data service is enabled:

```rust
impl RunnableConfig for IndexerGrpcDataServiceConfig {
    fn validate(&self) -> Result<()> {
        if !self.live_data_service_config.enabled 
            && !self.historical_data_service_config.enabled {
            anyhow::bail!(
                "At least one data service must be enabled. \
                 Set live_data_service_config.enabled = true \
                 or historical_data_service_config.enabled = true"
            );
        }
        Ok(())
    }

    async fn run(&self) -> Result<()> {
        // ... existing implementation
    }

    // ... other methods
}
```

Additionally, replace the `unreachable!()` with a proper error return to make the invariant explicit:

```rust
} else {
    return Err(Status::internal(
        "Service misconfigured: no data service available"
    ));
}
```

## Proof of Concept

**Step 1**: Create a configuration file `crash-config.yaml` with both services disabled:

```yaml
health_check_port: 8084
server_config:
  chain_id: 1
  service_config:
    listen_address: "0.0.0.0:50051"
  live_data_service_config:
    enabled: false  # Disabled
    num_slots: 5000000
    size_limit_bytes: 10000000000
  historical_data_service_config:
    enabled: false  # Disabled
    file_store_config:
      file_store_type: "LocalFileStore"
      local_file_store_path: "/tmp/indexer"
  grpc_manager_addresses: []
  self_advertised_address: "127.0.0.1:50051"
  data_service_response_channel_size: 5
```

**Step 2**: Start the service (it will start successfully despite invalid config):

```bash
cargo run --bin aptos-indexer-grpc-data-service-v2 -- --config-path crash-config.yaml
```

**Step 3**: Send a gRPC request using any client (e.g., grpcurl):

```bash
grpcurl -plaintext -d '{"starting_version": 0}' \
    localhost:50051 \
    aptos.indexer.v1.DataService/GetTransactions
```

**Expected Result**: The service immediately panics with the message "Must have at least one of the data services enabled." and exits with code 12, causing complete service unavailability.

## Notes
While the original security question asked about "configuration race conditions or runtime state changes," the actual vulnerability is simpler but equally serious: missing startup validation allows an invalid configuration to cause service crashes. The fields are immutable after construction, so no race conditions exist, but the lack of validation makes the supposedly "unreachable" panic fully reachable through operator error.

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/config.rs (L107-113)
```rust
    async fn create_live_data_service(
        &self,
        tasks: &mut Vec<JoinHandle<Result<()>>>,
    ) -> Option<DataServiceWrapper> {
        if !self.live_data_service_config.enabled {
            return None;
        }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/config.rs (L157-163)
```rust
    async fn create_historical_data_service(
        &self,
        tasks: &mut Vec<JoinHandle<Result<()>>>,
    ) -> Option<DataServiceWrapper> {
        if !self.historical_data_service_config.enabled {
            return None;
        }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/config.rs (L228-234)
```rust
        let live_data_service = self.create_live_data_service(&mut tasks).await;
        let historical_data_service = self.create_historical_data_service(&mut tasks).await;

        let wrapper = Arc::new(DataServiceWrapperWrapper::new(
            live_data_service,
            historical_data_service,
        ));
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/service.rs (L27-36)
```rust
impl DataServiceWrapperWrapper {
    pub fn new(
        live_data_service: Option<DataServiceWrapper>,
        historical_data_service: Option<DataServiceWrapper>,
    ) -> Self {
        Self {
            live_data_service,
            historical_data_service,
        }
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/service.rs (L43-72)
```rust
    async fn get_transactions(
        &self,
        req: Request<GetTransactionsRequest>,
    ) -> Result<Response<Self::GetTransactionsStream>, Status> {
        if let Some(live_data_service) = self.live_data_service.as_ref() {
            if let Some(historical_data_service) = self.historical_data_service.as_ref() {
                let request = req.into_inner();
                let mut stream = live_data_service
                    .get_transactions(Request::new(request.clone()))
                    .await?
                    .into_inner();
                let peekable = std::pin::pin!(stream.as_mut().peekable());
                if let Some(Ok(_)) = peekable.peek().await {
                    return live_data_service
                        .get_transactions(Request::new(request.clone()))
                        .await;
                }

                historical_data_service
                    .get_transactions(Request::new(request))
                    .await
            } else {
                live_data_service.get_transactions(req).await
            }
        } else if let Some(historical_data_service) = self.historical_data_service.as_ref() {
            historical_data_service.get_transactions(req).await
        } else {
            unreachable!("Must have at least one of the data services enabled.");
        }
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-server-framework/src/lib.rs (L112-117)
```rust
pub trait RunnableConfig: Clone + DeserializeOwned + Send + Sync + 'static {
    // Validate the config.
    fn validate(&self) -> Result<()> {
        Ok(())
    }

```

**File:** ecosystem/indexer-grpc/indexer-grpc-server-framework/src/lib.rs (L149-168)
```rust
pub fn setup_panic_handler() {
    std::panic::set_hook(Box::new(move |pi: &PanicHookInfo<'_>| {
        handle_panic(pi);
    }));
}

// Formats and logs panic information
fn handle_panic(panic_info: &PanicHookInfo<'_>) {
    // The Display formatter for a PanicHookInfo contains the message, payload and location.
    let details = format!("{}", panic_info);
    let backtrace = format!("{:#?}", Backtrace::new());
    let info = CrashInfo { details, backtrace };
    let crash_info = toml::to_string_pretty(&info).unwrap();
    error!("{}", crash_info);
    // TODO / HACK ALARM: Write crash info synchronously via eprintln! to ensure it is written before the process exits which error! doesn't guarantee.
    // This is a workaround until https://github.com/aptos-labs/aptos-core/issues/2038 is resolved.
    eprintln!("{}", crash_info);
    // Kill the process
    process::exit(12);
}
```
