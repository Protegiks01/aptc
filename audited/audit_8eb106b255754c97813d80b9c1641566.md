# Audit Report

## Title
InternalNode Deserialization Allows Invalid leaf_count Leading to Assertion Panic

## Summary
The `InternalNode::deserialize()` function accepts serialized data with `leaf_count = 0` for Internal children without validation, allowing creation of InternalNodes with total `leaf_count = 0`. This violates the fundamental invariant that internal nodes must contain at least one leaf, and triggers an assertion panic when proof generation is attempted on such nodes.

## Finding Description

The Jellyfish Merkle tree implementation has a critical missing validation in its deserialization path that breaks a core structural invariant.

**Violated Invariant:** An `InternalNode` must always have `leaf_count >= 1` because it represents a subtree containing at least one key-value pair (leaf node).

**Missing Validations:**

1. During deserialization of an Internal child's `NodeType`, the `leaf_count` value is read directly without validation: [1](#0-0) 

2. When creating the parent `InternalNode`, the total `leaf_count` is computed as a sum with no validation that the result is positive: [2](#0-1) 

3. The `new()` wrapper uses `.expect()`, which panics on error, but `new_impl()` only checks for empty children: [3](#0-2) 

**Attack Path:**

If malicious serialized data containing Internal children with `leaf_count = 0` enters storage (through storage corruption, backup restoration from untrusted source, or another vulnerability), the following panic occurs:

1. Malicious node with all children having `NodeType::Internal { leaf_count: 0 }` deserializes successfully
2. Parent's total `leaf_count` becomes 0 (sum of zeros)
3. Node is stored and later retrieved for proof generation
4. In `get_with_proof_ext()`, the special case check `if internal_node.leaf_count() == 1` evaluates to false (0 â‰  1): [4](#0-3) 

5. Code proceeds to call `get_child_with_siblings()`: [5](#0-4) 

6. Assertion `assert!(self.leaf_count > 1)` fails immediately: [6](#0-5) 

7. **Validator node panics** - any subsequent query accessing this corrupted node path crashes the process

## Impact Explanation

**Severity Assessment: LOW to MEDIUM** (conditional on attack feasibility)

While the technical impact is significant (validator node crash), the exploitability is severely limited:

**If Exploitable (Medium Severity - up to $10,000):**
- Causes validator node crashes when querying affected state
- Violates state consistency guarantees
- Requires operator intervention to restore service
- Could affect multiple nodes if corrupted data propagates

**Realistic Assessment: LOW Severity or Out of Scope**

The vulnerability requires an attacker to inject malicious serialized data into a node's local RocksDB storage. This is **NOT achievable** by unprivileged attackers through normal protocol operations because:

1. Serialized merkle nodes are not directly received from network peers
2. State sync transfers transactions/state values, not raw merkle tree nodes  
3. All normal node creation paths in the codebase construct valid nodes with proper leaf counts
4. Attack requires either:
   - Physical/filesystem access to corrupt storage files (insider threat)
   - Exploitation of a separate vulnerability allowing storage writes
   - Restoration from maliciously crafted backup

## Likelihood Explanation

**Likelihood: Very Low**

This vulnerability cannot be exploited through normal protocol interactions. Required conditions:

1. **Storage Corruption**: Attacker needs direct access to RocksDB files or ability to manipulate database restoration
2. **No Network Vector**: No identified path for remote exploitation
3. **Requires Additional Compromise**: Would need to chain with another vulnerability

The attack surface is limited to scenarios involving:
- Malicious node operators (excluded from trust model)
- Compromised backup/restore procedures
- Physical security breaches
- Unrelated storage corruption vulnerabilities

## Recommendation

Add validation to enforce the `leaf_count > 0` invariant for Internal nodes:

```rust
pub fn new_impl(children: Children) -> Result<Self> {
    ensure!(!children.is_empty(), "Children must not be empty");
    
    let leaf_count = children.iter().map(|(_, child)| child.leaf_count()).sum();
    
    // NEW: Validate that internal nodes always contain at least one leaf
    ensure!(
        leaf_count > 0,
        "InternalNode must have leaf_count > 0, got {}. This indicates corrupted data.",
        leaf_count
    );
    
    Ok(Self {
        children,
        leaf_count,
    })
}
```

Additionally, validate during deserialization:

```rust
// In deserialize(), after reading leaf_count for Internal children:
let node_type = if (leaf_bitmap & child_bit) != 0 {
    NodeType::Leaf
} else {
    let leaf_count = deserialize_u64_varint(&mut reader)? as usize;
    ensure!(
        leaf_count > 0,
        "Internal node child must have leaf_count > 0, got {}",
        leaf_count
    );
    NodeType::Internal { leaf_count }
};
```

## Proof of Concept

```rust
#[test]
fn test_internal_node_zero_leaf_count_panic() {
    use crate::node_type::{Child, Children, InternalNode, NodeType};
    use aptos_crypto::HashValue;
    
    // Create a malicious child with leaf_count = 0
    let malicious_child = Child::new(
        HashValue::random(),
        0, // version
        NodeType::Internal { leaf_count: 0 }, // INVALID: leaf_count should be > 0
    );
    
    // This creates a node with total leaf_count = 0
    let children = Children::from_sorted(vec![(Nibble::from(0), malicious_child)]);
    let internal_node = InternalNode::new(children);
    
    // Verify the node has invalid leaf_count = 0
    assert_eq!(internal_node.leaf_count(), 0);
    
    // Attempting to call get_child_with_siblings would panic
    // assert!(self.leaf_count > 1) fails when leaf_count == 0
}
```

---

**Notes:**

Despite identifying the technical vulnerability, this finding **does not meet the bug bounty criteria** for an unprivileged attacker exploit. The vulnerability requires storage-level corruption or insider access, which falls outside the realistic threat model. The issue represents defensive programming gap rather than an actively exploitable remote vulnerability.

The proper classification would be a **code quality/hardening issue** rather than a security-critical bug, as it only manifests under already-compromised conditions.

### Citations

**File:** storage/jellyfish-merkle/src/node_type/mod.rs (L331-333)
```rust
    pub fn new(children: Children) -> Self {
        Self::new_impl(children).expect("Input children are logical.")
    }
```

**File:** storage/jellyfish-merkle/src/node_type/mod.rs (L335-345)
```rust
    pub fn new_impl(children: Children) -> Result<Self> {
        // Assert the internal node must have >= 1 children. If it only has one child, it cannot be
        // a leaf node. Otherwise, the leaf node should be a child of this internal node's parent.
        ensure!(!children.is_empty(), "Children must not be empty");

        let leaf_count = children.iter().map(|(_, child)| child.leaf_count()).sum();
        Ok(Self {
            children,
            leaf_count,
        })
    }
```

**File:** storage/jellyfish-merkle/src/node_type/mod.rs (L428-429)
```rust
                let leaf_count = deserialize_u64_varint(&mut reader)? as usize;
                NodeType::Internal { leaf_count }
```

**File:** storage/jellyfish-merkle/src/node_type/mod.rs (L603-603)
```rust
        assert!(self.leaf_count > 1);
```

**File:** storage/jellyfish-merkle/src/lib.rs (L744-751)
```rust
                    if internal_node.leaf_count() == 1 {
                        // Logically this node should be a leaf node, it got pushed down for
                        // sharding, skip the siblings.
                        let (only_child_nibble, Child { version, .. }) =
                            internal_node.children_sorted().next().unwrap();
                        next_node_key =
                            next_node_key.gen_child_node_key(*version, *only_child_nibble);
                        continue;
```

**File:** storage/jellyfish-merkle/src/lib.rs (L756-763)
```rust
                    let child_node_key = internal_node.get_child_with_siblings(
                        &next_node_key,
                        queried_child_index,
                        Some(self.reader),
                        &mut out_siblings,
                        nibble_depth * 4,
                        target_root_depth,
                    )?;
```
