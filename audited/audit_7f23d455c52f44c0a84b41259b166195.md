# Audit Report

## Title
Consensus Observer Same-Epoch State Sync Race Condition Denial of Service

## Summary
The consensus observer's `process_commit_decision_message` function lacks synchronization protection for same-epoch commit decisions, allowing a malicious subscribed peer to trigger concurrent state sync operations that continuously abort each other, preventing the observer from processing blocks and making progress.

## Finding Description

The consensus observer handles commit decisions from subscribed peers and initiates state sync when it needs to catch up to a commit. While there is protection against concurrent epoch-changing syncs, there is **no equivalent protection for same-epoch syncs**. [1](#0-0) 

This check only prevents multiple syncs when `epoch_changed` is true. For same-epoch commits, the code proceeds directly to: [2](#0-1) 

Each call to `sync_to_commit` overwrites the previous sync handle: [3](#0-2) 

When the handle is overwritten, the `DropGuard` for the previous sync is dropped, aborting that sync task. If a notification from an aborted sync arrives after the root has been updated to a newer commit, it is marked as stale and ignored: [4](#0-3) 

**Attack Scenario:**
1. Malicious peer (subscribed to by the observer) obtains legitimate commit decisions from the network
2. Sends commit decision A for round 200 → observer updates root to 200, starts sync A
3. Before sync A completes, sends commit decision B for round 300 → root updates to 300, sync A aborted, sync B starts
4. Repeats with increasing rounds faster than state sync can complete
5. Notifications from aborted syncs arrive and are marked as stale
6. Observer never successfully processes blocks, becoming stuck

## Impact Explanation

This vulnerability constitutes a **Medium Severity** denial-of-service attack according to Aptos bug bounty criteria:

- **State inconsistencies requiring intervention**: The observer's internal state (block_data root) becomes inconsistent with its ability to process blocks. While state sync may complete successfully in storage, the observer never processes the buffered ordered blocks.

- **Limited scope**: Affects consensus observer nodes only, not core validator consensus. Observer nodes are important for serving read requests and providing consensus monitoring.

- **Temporary but exploitable**: An attacker with a steady stream of legitimate commit decisions can sustain the attack, preventing the observer from processing any blocks during the attack period.

- **Resource exhaustion**: Continuous state sync operations consume CPU, network bandwidth, and I/O resources.

The vulnerability does NOT cause:
- Consensus safety violations (observers don't participate in consensus)
- Permanent damage (recoverable by restarting or changing subscriptions)
- Fund loss or theft

## Likelihood Explanation

**Attack Requirements:**
- Attacker must be a peer that the observer has subscribed to (passes `verify_message_for_subscription`)
- Access to legitimate commit decisions with valid quorum signatures (publicly available on the network)
- Ability to forward commits faster than state sync completes

**Likelihood: MEDIUM**

The attack is more likely when:
- Observer is significantly behind (state sync is slower)
- Network latency is high (slowing state sync)
- Attacker has good network connectivity to rapidly forward commits

The attack is less effective when:
- Observer is nearly caught up (state sync is fast)
- Consensus block rate is slow relative to state sync speed
- Observer has multiple subscriptions (can switch peers)

**Mitigation factors:**
- Observers can unsubscribe from malicious peers
- Attack requires sustained effort (must keep forwarding commits)
- Natural rate limiting from consensus block production

## Recommendation

Add a check for active same-epoch syncs before starting a new sync, consistent with the existing epoch-change protection:

```rust
// In process_commit_decision_message, around line 507:
if epoch_changed || commit_round > last_block.round() {
    // If we're waiting for state sync to transition into a new epoch,
    // we should just wait and not issue a new state sync request.
    if self.state_sync_manager.is_syncing_through_epoch() {
        info!(...);
        return;
    }
    
    // ADD THIS CHECK:
    // If we're already syncing to a commit (same epoch), wait for it to complete
    if self.state_sync_manager.is_syncing_to_commit() {
        info!(
            LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                "Already syncing to commit: {:?}. Dropping commit decision: {:?}!",
                self.observer_block_data.lock().root().commit_info(),
                commit_decision.proof_block_info()
            ))
        );
        return;
    }
    
    // Otherwise, proceed with state sync
    self.observer_block_data
        .lock()
        .update_blocks_for_state_sync_commit(&commit_decision);
    self.state_sync_manager
        .sync_to_commit(commit_decision, epoch_changed);
}
```

Alternatively, implement a queue for pending commit decisions and process them sequentially after each sync completes.

## Proof of Concept

```rust
// This demonstrates the race condition in a test environment
// Place in consensus/src/consensus_observer/observer/consensus_observer.rs tests

#[tokio::test]
async fn test_rapid_commit_decisions_cause_stale_notifications() {
    // Setup observer with initial state at round 100
    let mut observer = setup_test_observer(epoch = 10, round = 100);
    
    // Simulate rapid commit decisions from a malicious peer
    let peer = PeerNetworkId::random();
    
    // Send commit decision A for round 200
    let commit_a = create_valid_commit_decision(epoch = 10, round = 200);
    observer.process_commit_decision_message(peer, Instant::now(), commit_a);
    
    // Immediately send commit decision B for round 300 (before sync A completes)
    let commit_b = create_valid_commit_decision(epoch = 10, round = 300);
    observer.process_commit_decision_message(peer, Instant::now(), commit_b);
    
    // Verify that:
    // 1. block_data root is now at round 300
    assert_eq!(observer.observer_block_data.lock().root().round(), 300);
    
    // 2. Only one sync is active (sync B)
    assert!(observer.state_sync_manager.is_syncing_to_commit());
    
    // 3. When notification for sync A arrives, it will be marked as stale
    let notification_a = StateSyncNotification::CommitSyncCompleted(
        create_ledger_info(epoch = 10, round = 200)
    );
    observer.process_state_sync_notification(notification_a).await;
    
    // 4. Verify blocks were not processed (notification was ignored)
    // This demonstrates the DoS: legitimate syncs complete but their notifications are ignored
}
```

## Notes

The code comment at lines 999-1001 acknowledges this race condition exists, but the lack of protection for same-epoch syncs (unlike epoch-changing syncs at line 507) suggests this may be an unintended gap rather than deliberate design. The inconsistency in handling epoch-changing vs same-epoch syncs indicates this is a bug that should be fixed. [5](#0-4)

### Citations

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L507-516)
```rust
            if self.state_sync_manager.is_syncing_through_epoch() {
                info!(
                    LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                        "Already waiting for state sync to reach new epoch: {:?}. Dropping commit decision: {:?}!",
                        self.observer_block_data.lock().root().commit_info(),
                        commit_decision.proof_block_info()
                    ))
                );
                return;
            }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L520-526)
```rust
            self.observer_block_data
                .lock()
                .update_blocks_for_state_sync_commit(&commit_decision);

            // Start state syncing to the commit decision
            self.state_sync_manager
                .sync_to_commit(commit_decision, epoch_changed);
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L999-1001)
```rust
        // If the commit sync notification is behind the block data root, ignore it. This
        // is possible due to a race condition where we started syncing to a newer commit
        // at the same time that state sync sent the notification for a previous commit.
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L1002-1009)
```rust
        if (synced_epoch, synced_round) < (block_data_epoch, block_data_round) {
            info!(
                LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                    "Ignoring old commit sync notification for epoch: {}, round: {}! Current root: {:?}",
                    synced_epoch, synced_round, block_data_root
                ))
            );
            return;
```

**File:** consensus/src/consensus_observer/observer/state_sync_manager.rs (L256-257)
```rust
        // Save the sync task handle
        self.sync_to_commit_handle = Some((DropGuard::new(abort_handle), epoch_changed));
```
