# Audit Report

## Title
Verified Module Cache Bypasses Stricter Verifier Config on Networks with gas_feature_version < 38

## Summary
The verified module cache (`VERIFIED_MODULES_CACHE`) is not properly invalidated when the verifier configuration changes on networks running gas_feature_version < 38. This allows modules verified under permissive settings to continue executing under stricter settings, bypassing critical safety limits and potentially causing consensus violations.

## Finding Description

The Move VM maintains a global cache of verified module hashes to avoid re-verification across blocks. When a module is verified in `build_locally_verified_module()`, only its hash is stored as the cache key—the verifier configuration is not included. [1](#0-0) 

The cache uses only the module hash for lookups, not a composite key of (hash, config). When verification is skipped due to a cache hit, the current `verifier_config` settings are never checked against the config used during the original verification.

The verifier configuration can change when on-chain governance enables/disables feature flags or updates gas parameters. For example, enabling `ENABLE_FUNCTION_VALUES` changes several critical limits: [2](#0-1) 

When the environment changes, the code attempts to flush the verified module cache—but only for networks with `gas_feature_version >= RELEASE_V1_34` (version 38): [3](#0-2) 

**Attack Scenario:**

1. Network operates at `gas_feature_version = 37` (or any version < 38)
2. Initial verifier config has `max_type_nodes: Some(256)` and `max_type_depth: None` (when `ENABLE_FUNCTION_VALUES` is disabled)
3. Attacker publishes module M with 200 type nodes, which passes verification
4. Module hash is cached in `VERIFIED_MODULES_CACHE`
5. Governance enables `ENABLE_FUNCTION_VALUES` feature flag
6. New verifier config has `max_type_nodes: Some(128)` and `max_type_depth: Some(20)`
7. Environment hash changes, module cache is flushed, but `VERIFIED_MODULES_CACHE` is NOT flushed (line 117-126 skipped)
8. When module M is loaded again, `VERIFIED_MODULES_CACHE.contains(hash)` returns true
9. Verification is skipped entirely
10. Module M executes with 200 type nodes under a config limiting to 128 nodes

This breaks the **Deterministic Execution** invariant—different validators could have different cache states, leading to disagreement on which modules are valid.

## Impact Explanation

**Critical Severity** - This vulnerability causes:

1. **Consensus Safety Violation**: Validators with different cache states may disagree on transaction execution results, potentially causing chain splits or consensus failures. If some validators flush their cache while others don't (due to timing, restarts, or version differences), they will have different views of module validity.

2. **Verifier Bypass**: Security-critical limits enforced by the bytecode verifier (max loop depth, type complexity, function parameters) can be circumvented. These limits exist to prevent DoS attacks and ensure safe execution.

3. **Non-Deterministic State Transitions**: The same block could produce different state roots on different nodes, violating the core blockchain invariant that identical inputs must produce identical outputs.

This qualifies as Critical per the Aptos bug bounty criteria: "Consensus/Safety violations" and "Non-recoverable network partition (requires hardfork)".

## Likelihood Explanation

**Likelihood: Medium to High**

The vulnerability is exploitable if:
- Any network (mainnet, testnet, or devnet) runs `gas_feature_version < 38`
- Verifier configuration changes occur (via feature flags or governance)
- Affected modules exist in the cache

While the latest gas feature version is 45, networks may still be on older versions:
- Testnets or devnets for backward compatibility testing
- Networks during the upgrade window from version 37 to 38
- Forked chains or custom deployments

The version gate at line 117 indicates this was a recognized vulnerability that required a fix, confirming the issue's validity.

## Recommendation

**Immediate Fix**: Include the verifier configuration in the cache key or flush the cache unconditionally when the environment changes.

**Option 1 - Composite Cache Key:**
Modify `VERIFIED_MODULES_CACHE` to use `(module_hash, verifier_config_hash)` as the key instead of just `module_hash`.

**Option 2 - Unconditional Flush (Simpler):**
Remove the version gate and always flush the verified module cache when verifier config changes:

```rust
let environment_requires_update = self.environment.as_ref() != Some(&storage_environment);
if environment_requires_update {
    // Always check if verifier config changed and flush cache if needed
    let flush_verifier_cache = self.environment.as_ref().is_none_or(|e| {
        e.verifier_config_bytes() != storage_environment.verifier_config_bytes()
    });
    if flush_verifier_cache {
        RuntimeEnvironment::flush_verified_module_cache();
    }
    
    self.environment = Some(storage_environment);
    self.module_cache.flush();
}
```

**Option 3 - Hash in Cache Key:**
Store `verifier_config` hash alongside module hash in the cache structure to ensure config compatibility on retrieval.

## Proof of Concept

The following demonstrates the vulnerability path (pseudocode outline):

```rust
// Setup: Network at gas_feature_version 37
// Initial config: max_type_nodes = Some(256)

// Step 1: Publish module with 200 type nodes
let module_bytes = compile_module_with_type_nodes(200);
let module_hash = hash(&module_bytes);

// Verification passes with permissive config
verify_module_with_config(&config_v1, &module); // max_type_nodes: 256
VERIFIED_MODULES_CACHE.put(module_hash);

// Step 2: Governance enables ENABLE_FUNCTION_VALUES
// New config: max_type_nodes = Some(128)
let new_config = aptos_prod_verifier_config(37, &features_with_function_values);
assert_eq!(new_config.max_type_nodes, Some(128));

// Step 3: Environment changes but cache NOT flushed (gas_feature_version < 38)
// check_ready() executes but skips lines 117-126

// Step 4: Load module again
if VERIFIED_MODULES_CACHE.contains(&module_hash) {
    // Verification skipped! Module with 200 type nodes runs under 128 limit
    return Ok(LocallyVerifiedModule(module));
}

// Result: Module violating new limits executes successfully
// Different validators may enforce different limits → consensus failure
```

To reproduce in a test environment:
1. Set gas_feature_version to 37
2. Disable `ENABLE_FUNCTION_VALUES` feature flag
3. Publish a module with type complexity between 128-256 nodes
4. Enable `ENABLE_FUNCTION_VALUES` feature flag
5. Verify the module loads without re-verification
6. Observe that execution succeeds despite violating new limits

## Notes

The fix was introduced with the version gate at `RELEASE_V1_34` (version 38), confirming this was a known vulnerability. The gate prevents breaking networks already on older versions but leaves those networks exposed. Any deployment still running gas_feature_version < 38 remains vulnerable to this cache invalidation bypass, which can lead to consensus disagreement and network partition.

### Citations

**File:** third_party/move/move-vm/runtime/src/storage/environment.rs (L178-201)
```rust
    pub fn build_locally_verified_module(
        &self,
        compiled_module: Arc<CompiledModule>,
        module_size: usize,
        module_hash: &[u8; 32],
    ) -> VMResult<LocallyVerifiedModule> {
        if !VERIFIED_MODULES_CACHE.contains(module_hash) {
            let _timer =
                VM_TIMER.timer_with_label("move_bytecode_verifier::verify_module_with_config");

            // For regular execution, we cache already verified modules. Note that this even caches
            // verification for the published modules. This should be ok because as long as the
            // hash is the same, the deployed bytecode and any dependencies are the same, and so
            // the cached verification result can be used.
            move_bytecode_verifier::verify_module_with_config(
                &self.vm_config().verifier_config,
                compiled_module.as_ref(),
            )?;
            check_natives(compiled_module.as_ref())?;
            VERIFIED_MODULES_CACHE.put(*module_hash);
        }

        Ok(LocallyVerifiedModule(compiled_module, module_size))
    }
```

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L145-194)
```rust
pub fn aptos_prod_verifier_config(gas_feature_version: u64, features: &Features) -> VerifierConfig {
    let sig_checker_v2_fix_script_ty_param_count =
        features.is_enabled(FeatureFlag::SIGNATURE_CHECKER_V2_SCRIPT_FIX);
    let sig_checker_v2_fix_function_signatures = gas_feature_version >= RELEASE_V1_34;
    let enable_enum_types = features.is_enabled(FeatureFlag::ENABLE_ENUM_TYPES);
    let enable_resource_access_control =
        features.is_enabled(FeatureFlag::ENABLE_RESOURCE_ACCESS_CONTROL);
    let enable_function_values = features.is_enabled(FeatureFlag::ENABLE_FUNCTION_VALUES);
    // Note: we reuse the `enable_function_values` flag to set various stricter limits on types.

    VerifierConfig {
        scope: VerificationScope::Everything,
        max_loop_depth: Some(5),
        max_generic_instantiation_length: Some(32),
        max_function_parameters: Some(128),
        max_basic_blocks: Some(1024),
        max_value_stack_size: 1024,
        max_type_nodes: if enable_function_values {
            Some(128)
        } else {
            Some(256)
        },
        max_push_size: Some(10000),
        max_struct_definitions: None,
        max_struct_variants: None,
        max_fields_in_struct: None,
        max_function_definitions: None,
        max_back_edges_per_function: None,
        max_back_edges_per_module: None,
        max_basic_blocks_in_script: None,
        max_per_fun_meter_units: Some(1000 * 80000),
        max_per_mod_meter_units: Some(1000 * 80000),
        _use_signature_checker_v2: true,
        sig_checker_v2_fix_script_ty_param_count,
        sig_checker_v2_fix_function_signatures,
        enable_enum_types,
        enable_resource_access_control,
        enable_function_values,
        max_function_return_values: if enable_function_values {
            Some(128)
        } else {
            None
        },
        max_type_depth: if enable_function_values {
            Some(20)
        } else {
            None
        },
    }
}
```

**File:** aptos-move/block-executor/src/code_cache_global_manager.rs (L115-130)
```rust
        let environment_requires_update = self.environment.as_ref() != Some(&storage_environment);
        if environment_requires_update {
            if storage_environment.gas_feature_version() >= RELEASE_V1_34 {
                let flush_verifier_cache = self.environment.as_ref().is_none_or(|e| {
                    e.verifier_config_bytes() != storage_environment.verifier_config_bytes()
                });
                if flush_verifier_cache {
                    // Additionally, if the verifier config changes, we flush static verifier cache
                    // as well.
                    RuntimeEnvironment::flush_verified_module_cache();
                }
            }

            self.environment = Some(storage_environment);
            self.module_cache.flush();
        }
```
