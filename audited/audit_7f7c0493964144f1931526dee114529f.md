# Audit Report

## Title
Sequence Number Desynchronization in HardwareWalletAccount After Failed Transaction Signing

## Summary
The `HardwareWalletAccount::sign_with_transaction_builder()` function increments the local sequence number before attempting hardware wallet signature, creating a permanent desynchronization between client state and on-chain state when signing fails. This affects SDK users who maintain `HardwareWalletAccount` instances across multiple transaction attempts.

## Finding Description

The vulnerability exists in the transaction signing flow for hardware wallet accounts. [1](#0-0) 

The problematic sequence of operations is:

1. **Line 631**: Read the current local sequence number
2. **Lines 633-637**: Build the raw transaction with that sequence number
3. **Line 640**: Increment the local sequence number (`*self.sequence_number_mut() += 1`)
4. **Line 642**: Attempt to sign the transaction via hardware wallet (`self.sign_transaction(raw_txn)`)

The critical flaw is that the sequence number increment occurs **before** the hardware wallet signing operation, which can fail for multiple reasons: [2](#0-1) 

The signing operation delegates to the hardware wallet device: [3](#0-2) 

Hardware wallet operations can fail due to:
- **User rejection**: User declines transaction approval on device (AptosLedgerStatusCode::Deny)
- **Device disconnection**: Ledger device unplugged during signing
- **Timeout**: User takes too long to approve
- **Communication errors**: USB/Bluetooth connection issues

When any of these failures occur:
1. The local `sequence_number` field has already been incremented (line 640 executed)
2. The function returns an error via `?` operator (line 642 fails)
3. The signed transaction is never created or submitted
4. The on-chain sequence number remains unchanged
5. **Desynchronization**: Local sequence number is N+1, on-chain is N

For SDK users who maintain a `HardwareWalletAccount` instance across multiple transaction attempts (a common pattern in wallet applications and automated systems), subsequent signing attempts will use sequence number N+1, which the blockchain will reject because it expects N.

**Note**: The CLI usage is not affected because it creates a fresh `HardwareWalletAccount` instance for each transaction, fetching the current sequence number from the blockchain: [4](#0-3) [5](#0-4) 

## Impact Explanation

This issue meets **Medium Severity** criteria per Aptos bug bounty program:

**Category**: "State inconsistencies requiring intervention"

**Impact Details**:
- SDK users experience transaction submission failures with confusing error messages
- Requires manual intervention: users must call `set_sequence_number()` or recreate the account instance
- Affects automated systems and wallets that maintain persistent `HardwareWalletAccount` instances
- No loss of funds (transactions simply fail validation)
- No blockchain consensus impact (on-chain state remains correct)
- Isolated to client-side SDK usage, not blockchain infrastructure

This is classified as Medium rather than High/Critical because:
- Only affects SDK client applications, not the blockchain itself
- Does not result in fund loss, theft, or permanent freezing
- Can be resolved by syncing sequence number from blockchain
- Does not impact consensus, validators, or network availability

## Likelihood Explanation

**Likelihood: High** for affected SDK users

Hardware wallet transaction rejection is a common occurrence:
- Users frequently reject transactions for various reasons (wrong amount, change of mind, double-checking)
- Hardware wallet connectivity issues are common (USB disconnections, Bluetooth dropouts)
- User interaction timeouts occur regularly

The pattern of maintaining a `HardwareWalletAccount` instance across transactions is natural for:
- Wallet applications with persistent sessions
- Automated trading/staking bots
- Multi-transaction workflows (batch operations)
- Long-running daemons interacting with the blockchain

Developers using the SDK API directly (not via CLI) would reasonably expect the sequence number to remain consistent with on-chain state, especially since the similar `LocalAccount` class maintains atomic sequence number semantics through its use of `AtomicU64` and infallible signing.

## Recommendation

**Fix**: Move the sequence number increment to occur **after** successful signing, or implement rollback on signing failure.

### Option 1: Increment After Signing (Preferred)

```rust
fn sign_with_transaction_builder(
    &mut self,
    builder: TransactionBuilder,
) -> Result<SignedTransaction> {
    let two_minutes = Duration::from_secs(2 * 60);
    let current_time = SystemTime::now().duration_since(UNIX_EPOCH)? + two_minutes;
    let seconds = current_time.as_secs();
    let orderless = builder.has_nonce();
    let sequence_number = if orderless {
        u64::MAX
    } else {
        self.sequence_number()
    };
    let raw_txn = builder
        .sender(self.address())
        .sequence_number(sequence_number)
        .expiration_timestamp_secs(seconds)
        .build();

    // Sign BEFORE incrementing
    let signed_txn = self.sign_transaction(raw_txn)?;
    
    // Only increment if signing succeeded
    if !orderless {
        *self.sequence_number_mut() += 1;
    }
    
    Ok(signed_txn)
}
```

### Option 2: Rollback on Failure

```rust
fn sign_with_transaction_builder(
    &mut self,
    builder: TransactionBuilder,
) -> Result<SignedTransaction> {
    let two_minutes = Duration::from_secs(2 * 60);
    let current_time = SystemTime::now().duration_since(UNIX_EPOCH)? + two_minutes;
    let seconds = current_time.as_secs();
    let orderless = builder.has_nonce();
    let sequence_number = if orderless {
        u64::MAX
    } else {
        self.sequence_number()
    };
    let raw_txn = builder
        .sender(self.address())
        .sequence_number(sequence_number)
        .expiration_timestamp_secs(seconds)
        .build();

    if !orderless {
        *self.sequence_number_mut() += 1;
    }
    
    // Rollback sequence number if signing fails
    match self.sign_transaction(raw_txn) {
        Ok(signed_txn) => Ok(signed_txn),
        Err(e) => {
            if !orderless {
                *self.sequence_number_mut() -= 1;
            }
            Err(e)
        }
    }
}
```

**Option 1 is preferred** as it's simpler and matches the semantic expectation that state changes only occur after operations succeed.

## Proof of Concept

```rust
#[cfg(test)]
mod sequence_number_desync_test {
    use super::*;
    use aptos_crypto::ed25519::Ed25519PrivateKey;
    use aptos_types::transaction::TransactionPayload;
    
    #[test]
    fn test_hardware_wallet_sequence_desync_on_signing_failure() {
        // This test demonstrates the sequence number desynchronization bug
        // Note: This is a conceptual PoC as we cannot easily mock hardware wallet failures
        
        // 1. Create a HardwareWalletAccount with sequence number 5
        let address = AccountAddress::random();
        let public_key = Ed25519PublicKey::from(&Ed25519PrivateKey::generate_for_testing());
        let mut hw_account = HardwareWalletAccount::new(
            address,
            public_key,
            "m/44'/637'/0'/0'/0'".to_string(),
            HardwareWalletType::Ledger,
            5, // Initial sequence number from blockchain
        );
        
        assert_eq!(hw_account.sequence_number(), 5);
        
        // 2. Attempt to sign a transaction
        let transaction_factory = TransactionFactory::new(ChainId::test())
            .with_gas_unit_price(100)
            .with_max_gas_amount(1000);
        
        let payload = TransactionPayload::Script(Script::new(vec![], vec![], vec![]));
        let txn_builder = transaction_factory.payload(payload);
        
        // 3. When sign_with_transaction_builder is called:
        //    - It reads sequence_number = 5
        //    - Builds transaction with sequence_number = 5
        //    - INCREMENTS local sequence_number to 6
        //    - Attempts hardware wallet signing (FAILS in real scenario)
        
        // In a real scenario with actual hardware wallet that fails:
        // let result = hw_account.sign_with_transaction_builder(txn_builder);
        // assert!(result.is_err()); // Signing failed
        // assert_eq!(hw_account.sequence_number(), 6); // BUT sequence number was incremented!
        
        // 4. The on-chain sequence number is still 5 (transaction never submitted)
        //    but local sequence number is now 6
        
        // 5. Next attempt will use sequence_number = 6, which blockchain rejects
        //    because it expects sequence_number = 5
        
        // Expected behavior: sequence_number should remain 5 after signing failure
        // Actual behavior: sequence_number becomes 6, causing permanent desync
        
        println!("Sequence number desynchronization demonstrated:");
        println!("- Initial local sequence: 5");
        println!("- After failed signing: 6 (BUG)");
        println!("- On-chain sequence: 5 (unchanged)");
        println!("- Expected local sequence: 5 (should match on-chain)");
    }
}
```

## Notes

This vulnerability specifically affects the **Aptos SDK** (`sdk/src/types.rs`), not the core blockchain consensus or execution layers. It is a client-side state management bug that impacts developers building applications with hardware wallet support.

The issue does NOT affect:
- Blockchain consensus or validator operations
- On-chain account state (which remains correct)
- CLI tool users (which create fresh instances per transaction)
- `LocalAccount` users (which use infallible in-memory signing)

The fix should be implemented in the SDK to maintain the expected invariant: **local sequence number should always match on-chain sequence number when no transaction is in flight**.

### Citations

**File:** sdk/src/types.rs (L607-618)
```rust
    fn sign_transaction(&self, txn: RawTransaction) -> Result<SignedTransaction> {
        let signature = self.sign_arbitrary_message(
            signing_message(&txn)
                .expect("Unable to convert txn to signing message.")
                .as_ref(),
        )?;
        Ok(SignedTransaction::new(
            txn,
            self.public_key().clone(),
            signature,
        ))
    }
```

**File:** sdk/src/types.rs (L620-643)
```rust
    fn sign_with_transaction_builder(
        &mut self,
        builder: TransactionBuilder,
    ) -> Result<SignedTransaction> {
        let two_minutes = Duration::from_secs(2 * 60);
        let current_time = SystemTime::now().duration_since(UNIX_EPOCH)? + two_minutes;
        let seconds = current_time.as_secs();
        let orderless = builder.has_nonce();
        let sequence_number = if orderless {
            u64::MAX
        } else {
            self.sequence_number()
        };
        let raw_txn = builder
            .sender(self.address())
            .sequence_number(sequence_number)
            .expiration_timestamp_secs(seconds)
            .build();

        if !orderless {
            *self.sequence_number_mut() += 1;
        }
        self.sign_transaction(raw_txn)
    }
```

**File:** sdk/src/types.rs (L706-711)
```rust
    pub fn sign_arbitrary_message(
        &self,
        message: &[u8],
    ) -> Result<Ed25519Signature, AptosLedgerError> {
        aptos_ledger::sign_message(&self.derivation_path, message)
    }
```

**File:** crates/aptos/src/common/types.rs (L1959-1960)
```rust
        let (account, state) = get_account_with_state(&client, sender_address).await?;
        let sequence_number = account.sequence_number;
```

**File:** crates/aptos/src/common/types.rs (L2064-2079)
```rust
                let sender_account = &mut HardwareWalletAccount::new(
                    sender_address,
                    sender_public_key,
                    self.profile_options
                        .derivation_path()
                        .expect("derivative path is missing from profile")
                        .unwrap(),
                    HardwareWalletType::Ledger,
                    sequence_number,
                );
                let mut txn_builder = transaction_factory.payload(payload);
                if self.replay_protection_type == ReplayProtectionType::Nonce {
                    let mut rng = rand::thread_rng();
                    txn_builder = txn_builder.upgrade_payload_with_rng(&mut rng, true, true);
                };
                sender_account.sign_with_transaction_builder(txn_builder)?
```
