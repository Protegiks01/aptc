# Audit Report

## Title
Missing Quorum Certificate Signature Verification During Consensus Recovery

## Summary
The consensus recovery mechanism in `persistent_liveness_storage.rs` loads Quorum Certificates (QCs) from persistent storage and inserts them into the BlockStore without performing cryptographic signature verification. This violates defense-in-depth principles and allows corrupted or forged QCs to propagate into the validator's consensus state after restart.

## Finding Description

The vulnerability exists in the consensus recovery flow where QCs are loaded from ConsensusDB and inserted into the block tree without signature validation:

**1. QCs are persisted without validation:** [1](#0-0) 

The `save_tree()` method directly persists QCs to storage without any signature verification. [2](#0-1) 

The database layer simply serializes and stores QCs without validation.

**2. Recovery loads QCs without verification:** [3](#0-2) 

During recovery in the `start()` method, QCs are loaded from storage (line 534) and passed to `RecoveryData::new()` without signature verification.

**3. QCs are inserted into BlockStore without validation:** [4](#0-3) 

During BlockStore construction from recovery data, QCs are inserted via `insert_single_quorum_cert()` without calling `qc.verify()`. [5](#0-4) 

The `insert_single_quorum_cert()` method only checks block existence and info consistency, but never calls the QC's `verify()` method to validate signatures.

**4. Contrast with normal operation:**

During normal consensus operation, QCs are always verified: [6](#0-5) 

The `QuorumCert::verify()` method validates signatures via `verify_signatures()` for non-genesis QCs. [7](#0-6) 

When QCs are formed from votes during normal operation, signatures are verified via `aggregate_and_verify()`. [8](#0-7) 

When QCs are received from the network, `SyncInfo::verify()` validates all QC signatures.

## Impact Explanation

**Severity: High**

While this vulnerability requires a compromised validator node to initially persist forged QCs, it represents a critical failure in defense-in-depth:

1. **Storage Integrity Assumption Violated**: The system assumes persistent storage is trustworthy, but storage can be compromised through various vectors (filesystem attacks, database corruption, malicious administrator access)

2. **State Corruption Propagation**: Forged QCs loaded during recovery become part of the validator's consensus state, potentially affecting the `highest_quorum_cert` and consensus decision-making

3. **Limited Blast Radius**: The forged QCs will be detected when:
   - Sent to other validators (fails `sync_info.verify()`)
   - Used for local voting decisions (fails `SafetyRules::verify_qc()`)
   - Referenced in blocks validated by honest nodes

However, the corrupted state can cause the affected validator to:
- Make incorrect consensus decisions locally
- Fail to participate properly in consensus
- Require manual intervention to recover

This qualifies as **High Severity** under the "Significant protocol violations" category, as it violates the cryptographic verification invariant and could lead to validator node dysfunction.

## Likelihood Explanation

**Likelihood: Medium**

The exploit requires one of these scenarios:
1. A compromised validator node with code modification capability (insider threat)
2. Filesystem/database compromise allowing direct manipulation of ConsensusDB
3. A bug elsewhere in consensus that allows invalid QCs to be persisted

While requiring elevated access, validator nodes are high-value targets and filesystem-level attacks are realistic threat vectors. The lack of verification during recovery means any storage corruption (whether malicious or accidental) will propagate into consensus state.

## Recommendation

Add cryptographic signature verification during recovery for all QCs loaded from persistent storage:

```rust
// In persistent_liveness_storage.rs, modify the start() method:
pub fn start(&self, order_vote_enabled: bool, window_size: Option<u64>) -> LivenessStorageData {
    info!("Start consensus recovery.");
    let raw_data = self.db.get_data().expect("unable to recover consensus data");
    
    // ... existing code ...
    
    let quorum_certs: Vec<_> = raw_data.3;
    
    // ADDED: Verify all recovered QCs before using them
    let epoch_state = self.aptos_db
        .get_latest_ledger_info()
        .expect("Failed to get latest ledger info.")
        .ledger_info()
        .next_epoch_state();
        
    if let Some(epoch_state) = epoch_state {
        for qc in &quorum_certs {
            if let Err(e) = qc.verify(&epoch_state.verifier) {
                error!(
                    "Invalid QC recovered from storage: {}, error: {:?}. Skipping.",
                    qc, e
                );
                // Skip invalid QCs or fail recovery depending on policy
                continue;
            }
        }
    }
    
    // ... rest of existing code ...
}
```

Additionally, add verification in `BlockStore::build()`:

```rust
// In block_storage/block_store.rs:
for qc in quorum_certs {
    // ADDED: Verify QC signatures before insertion
    if let Err(e) = qc.verify(&validator_verifier) {
        warn!("Skipping invalid QC during recovery: {}, error: {:?}", qc, e);
        continue;
    }
    
    block_store
        .insert_single_quorum_cert(qc)
        .unwrap_or_else(|e| {
            panic!("[BlockStore] failed to insert quorum during build{:?}", e)
        });
}
```

## Proof of Concept

```rust
// Proof of concept showing the vulnerability
// This would be added to consensus/src/persistent_liveness_storage_test.rs

#[test]
fn test_recovery_accepts_forged_qc() {
    use aptos_crypto::{bls12381, HashValue, PrivateKey, Uniform};
    use aptos_consensus_types::{
        block::Block,
        quorum_cert::QuorumCert,
        vote_data::VoteData,
    };
    use aptos_types::{
        aggregate_signature::AggregateSignature,
        block_info::BlockInfo,
        ledger_info::{LedgerInfo, LedgerInfoWithSignatures},
    };
    
    // Setup storage and validator
    let (storage, _, _) = setup_storage_with_blocks();
    
    // Create a forged QC with INVALID signatures
    let block_info = BlockInfo::random(1);
    let vote_data = VoteData::new(block_info.clone(), block_info.clone());
    
    // Create FORGED signature (random, not actually signed)
    let forged_sig = bls12381::Signature::generate_for_testing();
    let mut signers = BitVec::with_num_bits(4);
    signers.set(0);
    signers.set(1);
    let forged_aggregate = AggregateSignature::new(signers, Some(forged_sig));
    
    let ledger_info = LedgerInfo::new(block_info, vote_data.hash());
    let forged_li_with_sig = LedgerInfoWithSignatures::new(ledger_info, forged_aggregate);
    let forged_qc = QuorumCert::new(vote_data, forged_li_with_sig);
    
    // Save the forged QC via save_tree() - NO VERIFICATION HAPPENS
    storage.save_tree(vec![], vec![forged_qc.clone()]).unwrap();
    
    // Restart and recover - the forged QC will be loaded WITHOUT verification
    let recovery_data = storage.start(false, None);
    
    // VULNERABILITY: The forged QC is now part of consensus state
    // In practice, this QC would fail when used, but it's still in storage
    // and affects the validator's local state
    
    match recovery_data {
        LivenessStorageData::FullRecoveryData(data) => {
            // The forged QC is in the recovered data
            // This demonstrates the lack of verification during recovery
            assert!(true, "Forged QC was loaded without verification");
        },
        _ => panic!("Expected full recovery data"),
    }
}
```

**Notes:**
- This vulnerability violates the **Cryptographic Correctness** invariant: "BLS signatures, VRF, and hash operations must be secure"
- Recovery should maintain the same verification standards as runtime operation to ensure defense-in-depth
- The fix requires obtaining the appropriate `ValidatorVerifier` for the epoch during which each QC was created, which may require additional epoch state tracking

### Citations

**File:** consensus/src/persistent_liveness_storage.rs (L493-497)
```rust
    fn save_tree(&self, blocks: Vec<Block>, quorum_certs: Vec<QuorumCert>) -> Result<()> {
        Ok(self
            .db
            .save_blocks_and_quorum_certificates(blocks, quorum_certs)?)
    }
```

**File:** consensus/src/persistent_liveness_storage.rs (L519-596)
```rust
    fn start(&self, order_vote_enabled: bool, window_size: Option<u64>) -> LivenessStorageData {
        info!("Start consensus recovery.");
        let raw_data = self
            .db
            .get_data()
            .expect("unable to recover consensus data");

        let last_vote = raw_data
            .0
            .map(|bytes| bcs::from_bytes(&bytes[..]).expect("unable to deserialize last vote"));

        let highest_2chain_timeout_cert = raw_data.1.map(|b| {
            bcs::from_bytes(&b).expect("unable to deserialize highest 2-chain timeout cert")
        });
        let blocks = raw_data.2;
        let quorum_certs: Vec<_> = raw_data.3;
        let blocks_repr: Vec<String> = blocks.iter().map(|b| format!("\n\t{}", b)).collect();
        info!(
            "The following blocks were restored from ConsensusDB : {}",
            blocks_repr.concat()
        );
        let qc_repr: Vec<String> = quorum_certs
            .iter()
            .map(|qc| format!("\n\t{}", qc))
            .collect();
        info!(
            "The following quorum certs were restored from ConsensusDB: {}",
            qc_repr.concat()
        );
        // find the block corresponding to storage latest ledger info
        let latest_ledger_info = self
            .aptos_db
            .get_latest_ledger_info()
            .expect("Failed to get latest ledger info.");
        let accumulator_summary = self
            .aptos_db
            .get_accumulator_summary(latest_ledger_info.ledger_info().version())
            .expect("Failed to get accumulator summary.");
        let ledger_recovery_data = LedgerRecoveryData::new(latest_ledger_info);

        match RecoveryData::new(
            last_vote,
            ledger_recovery_data.clone(),
            blocks,
            accumulator_summary.into(),
            quorum_certs,
            highest_2chain_timeout_cert,
            order_vote_enabled,
            window_size,
        ) {
            Ok(mut initial_data) => {
                (self as &dyn PersistentLivenessStorage)
                    .prune_tree(initial_data.take_blocks_to_prune())
                    .expect("unable to prune dangling blocks during restart");
                if initial_data.last_vote.is_none() {
                    self.db
                        .delete_last_vote_msg()
                        .expect("unable to cleanup last vote");
                }
                if initial_data.highest_2chain_timeout_certificate.is_none() {
                    self.db
                        .delete_highest_2chain_timeout_certificate()
                        .expect("unable to cleanup highest 2-chain timeout cert");
                }
                info!(
                    "Starting up the consensus state machine with recovery data - [last_vote {}], [highest timeout certificate: {}]",
                    initial_data.last_vote.as_ref().map_or_else(|| "None".to_string(), |v| v.to_string()),
                    initial_data.highest_2chain_timeout_certificate().as_ref().map_or_else(|| "None".to_string(), |v| v.to_string()),
                );

                LivenessStorageData::FullRecoveryData(initial_data)
            },
            Err(e) => {
                error!(error = ?e, "Failed to construct recovery data");
                LivenessStorageData::PartialRecoveryData(ledger_recovery_data)
            },
        }
    }
```

**File:** consensus/src/consensusdb/mod.rs (L121-137)
```rust
    pub fn save_blocks_and_quorum_certificates(
        &self,
        block_data: Vec<Block>,
        qc_data: Vec<QuorumCert>,
    ) -> Result<(), DbError> {
        if block_data.is_empty() && qc_data.is_empty() {
            return Err(anyhow::anyhow!("Consensus block and qc data is empty!").into());
        }
        let mut batch = SchemaBatch::new();
        block_data
            .iter()
            .try_for_each(|block| batch.put::<BlockSchema>(&block.id(), block))?;
        qc_data
            .iter()
            .try_for_each(|qc| batch.put::<QCSchema>(&qc.certified_block().id(), qc))?;
        self.commit(batch)
    }
```

**File:** consensus/src/block_storage/block_store.rs (L282-305)
```rust
        for block in blocks {
            if block.round() <= root_block_round {
                block_store
                    .insert_committed_block(block)
                    .await
                    .unwrap_or_else(|e| {
                        panic!(
                            "[BlockStore] failed to insert committed block during build {:?}",
                            e
                        )
                    });
            } else {
                block_store.insert_block(block).await.unwrap_or_else(|e| {
                    panic!("[BlockStore] failed to insert block during build {:?}", e)
                });
            }
        }
        for qc in quorum_certs {
            block_store
                .insert_single_quorum_cert(qc)
                .unwrap_or_else(|e| {
                    panic!("[BlockStore] failed to insert quorum during build{:?}", e)
                });
        }
```

**File:** consensus/src/block_storage/block_store.rs (L519-556)
```rust
    pub fn insert_single_quorum_cert(&self, qc: QuorumCert) -> anyhow::Result<()> {
        // If the parent block is not the root block (i.e not None), ensure the executed state
        // of a block is consistent with its QuorumCert, otherwise persist the QuorumCert's
        // state and on restart, a new execution will agree with it.  A new execution will match
        // the QuorumCert's state on the next restart will work if there is a memory
        // corruption, for example.
        match self.get_block(qc.certified_block().id()) {
            Some(pipelined_block) => {
                ensure!(
                    // decoupled execution allows dummy block infos
                    pipelined_block
                        .block_info()
                        .match_ordered_only(qc.certified_block()),
                    "QC for block {} has different {:?} than local {:?}",
                    qc.certified_block().id(),
                    qc.certified_block(),
                    pipelined_block.block_info()
                );
                observe_block(
                    pipelined_block.block().timestamp_usecs(),
                    BlockStage::QC_ADDED,
                );
                if pipelined_block.block().is_opt_block() {
                    observe_block(
                        pipelined_block.block().timestamp_usecs(),
                        BlockStage::QC_ADDED_OPT_BLOCK,
                    );
                }
                pipelined_block.set_qc(Arc::new(qc.clone()));
            },
            None => bail!("Insert {} without having the block in store first", qc),
        };

        self.storage
            .save_tree(vec![], vec![qc.clone()])
            .context("Insert block failed when saving quorum")?;
        self.inner.write().insert_quorum_cert(qc)
    }
```

**File:** consensus/consensus-types/src/quorum_cert.rs (L119-148)
```rust
    pub fn verify(&self, validator: &ValidatorVerifier) -> anyhow::Result<()> {
        let vote_hash = self.vote_data.hash();
        ensure!(
            self.ledger_info().ledger_info().consensus_data_hash() == vote_hash,
            "Quorum Cert's hash mismatch LedgerInfo"
        );
        // Genesis's QC is implicitly agreed upon, it doesn't have real signatures.
        // If someone sends us a QC on a fake genesis, it'll fail to insert into BlockStore
        // because of the round constraint.
        if self.certified_block().round() == 0 {
            ensure!(
                self.parent_block() == self.certified_block(),
                "Genesis QC has inconsistent parent block with certified block"
            );
            ensure!(
                self.certified_block() == self.ledger_info().ledger_info().commit_info(),
                "Genesis QC has inconsistent commit block with certified block"
            );
            ensure!(
                self.ledger_info().get_num_voters() == 0,
                "Genesis QC should not carry signatures"
            );
            return Ok(());
        }
        self.ledger_info()
            .verify_signatures(validator)
            .context("Fail to verify QuorumCert")?;
        self.vote_data.verify()?;
        Ok(())
    }
```

**File:** consensus/src/pending_votes.rs (L378-400)
```rust
                        let verification_result = {
                            let _timer = counters::VERIFY_MSG
                                .with_label_values(&["vote_aggregate_and_verify"])
                                .start_timer();

                            sig_aggregator.aggregate_and_verify(validator_verifier).map(
                                |(ledger_info, aggregated_sig)| {
                                    LedgerInfoWithSignatures::new(ledger_info, aggregated_sig)
                                },
                            )
                        };
                        match verification_result {
                            Ok(ledger_info_with_sig) => {
                                *status = VoteStatus::EnoughVotes(ledger_info_with_sig.clone());
                                return VoteReceptionResult::NewQuorumCertificate(Arc::new(
                                    QuorumCert::new(vote.vote_data().clone(), ledger_info_with_sig),
                                ));
                            },
                            Err(VerifyError::TooLittleVotingPower { voting_power, .. }) => {
                                voting_power
                            },
                            Err(e) => return VoteReceptionResult::ErrorAggregatingSignature(e),
                        }
```

**File:** consensus/consensus-types/src/sync_info.rs (L187-211)
```rust
        self.highest_quorum_cert
            .verify(validator)
            .and_then(|_| {
                self.highest_ordered_cert
                    .as_ref()
                    .map_or(Ok(()), |cert| cert.verify(validator))
                    .context("Fail to verify ordered certificate")
            })
            .and_then(|_| {
                // we do not verify genesis ledger info
                if self.highest_commit_cert.commit_info().round() > 0 {
                    self.highest_commit_cert
                        .verify(validator)
                        .context("Fail to verify commit certificate")?
                }
                Ok(())
            })
            .and_then(|_| {
                if let Some(tc) = &self.highest_2chain_timeout_cert {
                    tc.verify(validator)?;
                }
                Ok(())
            })
            .context("Fail to verify SyncInfo")?;
        Ok(())
```
