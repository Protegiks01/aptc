# Audit Report

## Title
PreparedCiphertext Signature Integrity Loss - Unverifiable Cryptographic Attestation Post-Preparation

## Summary
The `PreparedCiphertext` structure maintains the Ed25519 signature from the original `Ciphertext`, but this signature becomes cryptographically unverifiable after the preparation transformation due to missing verification data and structural changes to the signed content.

## Finding Description

The batch encryption system uses a two-stage ciphertext design where `Ciphertext<PCT>` is transformed into `PreparedCiphertext` for efficient decryption. During encryption, the original ciphertext includes an Ed25519 signature computed over both the inner BIBE ciphertext and associated data: [1](#0-0) 

The original `Ciphertext` structure contains the necessary fields for signature verification: [2](#0-1) 

When `prepare()` is called to convert a `Ciphertext` into `PreparedCiphertext`, the signature is copied unchanged, but critical verification data is lost: [3](#0-2) 

The resulting `PreparedCiphertext` structure lacks the `associated_data_bytes` field: [4](#0-3) 

Additionally, the inner `bibe_ct` field undergoes a structural transformation from `BIBECiphertext` to `PreparedBIBECiphertext`, changing the data that was originally signed: [5](#0-4) 

The original `Ciphertext` has a verification method that requires both the `bibe_ct` and `associated_data_bytes`: [6](#0-5) 

However, no corresponding `verify()` method exists for `PreparedCiphertext`, and implementing one would be impossible because:
1. The `associated_data_bytes` field is not present
2. The `bibe_ct` structure has changed from the original signed format
3. The signature was computed over the pre-preparation data

This design flaw violates the cryptographic integrity principle where signatures should remain verifiable throughout an object's lifecycle, especially when the object is serializable: [7](#0-6) 

## Impact Explanation

While this is classified as **Medium severity** in the security question scope, the current implementation in consensus shows PreparedCiphertexts are only used ephemerally within local decryption operations: [8](#0-7) 

The ciphertexts are used in `FPTXWeighted`, which is the encryption scheme used throughout Aptos for encrypted transactions: [9](#0-8) 

However, because `PreparedCiphertext` is `Serialize + Deserialize`, it could potentially be transmitted or stored in future protocol modifications, at which point the lack of signature verifiability would become a critical integrity vulnerability enabling substitution attacks.

## Likelihood Explanation

Currently **LOW** - PreparedCiphertexts are created and immediately consumed locally without network transmission or persistent storage. However, this represents a latent vulnerability that could manifest if:
- Future protocol versions transmit PreparedCiphertexts between nodes
- PreparedCiphertexts are cached or stored for batch processing
- Multi-party protocols incorporate PreparedCiphertext exchange

The design flaw exists now but lacks an immediate exploitation path.

## Recommendation

Implement one of the following solutions:

**Option 1**: Preserve verification capability by including associated data in PreparedCiphertext:
```rust
#[derive(Clone, Serialize, Deserialize, Debug, Eq, PartialEq)]
pub struct PreparedCiphertext {
    vk: VerifyingKey,
    bibe_ct: PreparedBIBECiphertext,
    #[serde(with = "serde_bytes")]
    associated_data_bytes: Vec<u8>,
    signature: Signature,
    // Store original bibe_ct hash for signature verification
    original_bibe_ct_hash: [u8; 32],
}
```

**Option 2**: Remove the signature from PreparedCiphertext since it cannot be verified:
```rust
#[derive(Clone, Serialize, Deserialize, Debug, Eq, PartialEq)]
pub struct PreparedCiphertext {
    vk: VerifyingKey,
    bibe_ct: PreparedBIBECiphertext,
    // Signature removed - verification must happen pre-preparation
}
```

**Option 3**: Make PreparedCiphertext non-serializable to prevent future misuse:
```rust
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct PreparedCiphertext {
    // Remove Serialize/Deserialize derives
    vk: VerifyingKey,
    bibe_ct: PreparedBIBECiphertext,
    signature: Signature,
}
```

## Proof of Concept

```rust
#[test]
fn test_prepared_ciphertext_signature_unverifiable() {
    use ark_std::rand::thread_rng;
    use crate::{
        schemes::fptx::FPTX,
        shared::{
            ciphertext::{CTEncrypt, StandardCiphertext},
            ids::IdSet,
        },
        traits::BatchThresholdEncryption,
    };
    use aptos_crypto::arkworks::shamir::ShamirThresholdConfig;

    let mut rng = thread_rng();
    let tc = ShamirThresholdConfig::new(1, 1);
    let (ek, dk, _, _) = FPTX::setup_for_testing(rng.gen(), 8, 1, &tc).unwrap();

    let plaintext = String::from("sensitive data");
    let associated_data = String::from("critical metadata");
    
    // Create and verify original ciphertext
    let ct: StandardCiphertext = ek.encrypt(&mut rng, &plaintext, &associated_data).unwrap();
    assert!(ct.verify(&associated_data).is_ok());

    // Prepare ciphertext for decryption
    let mut ids = IdSet::with_capacity(dk.capacity()).unwrap();
    ids.add(&ct.id());
    ids.compute_poly_coeffs();
    let (digest, pfs) = dk.digest(&mut ids, 0).unwrap();
    let pfs = pfs.compute_all(&dk);
    
    let prepared_ct = ct.prepare(&digest, &pfs).unwrap();
    
    // VULNERABILITY: PreparedCiphertext contains signature but cannot verify it
    // No verify() method exists, and implementing one would be impossible
    // because associated_data_bytes is missing and bibe_ct structure changed
    
    // The signature is present but useless:
    assert!(prepared_ct.signature == ct.signature); // Signature copied
    // But cannot call: prepared_ct.verify(&associated_data) - method doesn't exist!
    
    // This means if prepared_ct is serialized and transmitted,
    // an attacker could substitute it with no detection mechanism
}
```

**Notes**:
The vulnerability answers the security question directly: PreparedCiphertext **does** maintain the signature from the original Ciphertext (by copying it), but this signature **cannot** be verified post-preparation due to missing verification data (`associated_data_bytes`) and structural transformation of the signed content (`BIBECiphertext` â†’ `PreparedBIBECiphertext`). This creates a cryptographic integrity gap where signatures exist but serve no verification purpose.

### Citations

**File:** crates/aptos-batch-encryption/src/shared/ciphertext/mod.rs (L23-31)
```rust
#[derive(Clone, Serialize, Deserialize, Debug, Eq, PartialEq)]
#[serde(bound(deserialize = "PCT: DeserializeOwned"))]
pub struct Ciphertext<PCT: InnerCiphertext> {
    vk: VerifyingKey,
    bibe_ct: PCT,
    #[serde(with = "serde_bytes")]
    associated_data_bytes: Vec<u8>,
    signature: Signature,
}
```

**File:** crates/aptos-batch-encryption/src/shared/ciphertext/mod.rs (L36-41)
```rust
#[derive(Clone, Serialize, Deserialize, Debug, Eq, PartialEq)]
pub struct PreparedCiphertext {
    vk: VerifyingKey,
    bibe_ct: PreparedBIBECiphertext,
    signature: Signature,
}
```

**File:** crates/aptos-batch-encryption/src/shared/ciphertext/mod.rs (L87-88)
```rust
        let to_sign = (&bibe_ct, &associated_data_bytes);
        let signature = signing_key.sign(&bcs::to_bytes(&to_sign)?);
```

**File:** crates/aptos-batch-encryption/src/shared/ciphertext/mod.rs (L111-132)
```rust
    pub fn verify(&self, associated_data: &impl AssociatedData) -> Result<()> {
        let hashed_id = Id::from_verifying_key(&self.vk);

        (self.bibe_ct.id() == hashed_id).then_some(()).ok_or(
            BatchEncryptionError::CTVerifyError(CTVerifyError::IdDoesNotMatchHashedVK),
        )?;
        (self.associated_data_bytes == bcs::to_bytes(associated_data)?)
            .then_some(())
            .ok_or(BatchEncryptionError::CTVerifyError(
                CTVerifyError::AssociatedDataDoesNotMatch,
            ))?;

        let to_verify = (&self.bibe_ct, &self.associated_data_bytes);

        self.vk
            .verify(&bcs::to_bytes(&to_verify)?, &self.signature)
            .map_err(|e| {
                BatchEncryptionError::CTVerifyError(CTVerifyError::SigVerificationFailed(e))
            })?;

        Ok(())
    }
```

**File:** crates/aptos-batch-encryption/src/shared/ciphertext/mod.rs (L138-144)
```rust
    pub fn prepare(&self, digest: &Digest, eval_proofs: &EvalProofs) -> Result<PreparedCiphertext> {
        Ok(PreparedCiphertext {
            vk: self.vk,
            bibe_ct: self.bibe_ct.prepare(digest, eval_proofs)?,
            signature: self.signature,
        })
    }
```

**File:** crates/aptos-batch-encryption/src/shared/ciphertext/bibe.rs (L92-106)
```rust
    fn prepare_individual(
        &self,
        digest: &Digest,
        eval_proof: &EvalProof,
    ) -> Result<PreparedBIBECiphertext> {
        let pairing_output = PairingSetting::pairing(digest.as_g1(), self.ct_g2[0])
            + PairingSetting::pairing(**eval_proof, self.ct_g2[1]);

        Ok(PreparedBIBECiphertext {
            pairing_output,
            ct_g2: self.ct_g2[2].into(),
            padded_key: self.padded_key.clone(),
            symmetric_ciphertext: self.symmetric_ciphertext.clone(),
        })
    }
```

**File:** consensus/src/pipeline/decryption_pipeline_builder.rs (L126-131)
```rust
                if let Ok(payload) = FPTXWeighted::decrypt_individual::<DecryptedPayload>(
                    &decryption_key.key,
                    &ciphertext,
                    &digest,
                    &eval_proof,
                ) {
```

**File:** types/src/secret_sharing.rs (L18-18)
```rust
pub type Ciphertext = <FPTXWeighted as BatchThresholdEncryption>::Ciphertext;
```
