# Audit Report

## Title
Signature Verification Bypass in Backup Restore for Future Epochs

## Summary
The backup restore mechanism contains a critical signature verification bypass that allows an attacker to restore malicious transaction data from a backup claiming to be from a future epoch. When restoring from an epoch beyond the known epoch history, signature validation is completely skipped, enabling state corruption and consensus violations.

## Finding Description

The vulnerability exists in the `EpochHistory::verify_ledger_info()` method, which is responsible for verifying ledger info signatures during backup restoration. When a ledger info's epoch exceeds the length of the known epoch history, the method logs a warning but returns `Ok()` without performing any signature verification. [1](#0-0) 

This bypass occurs during the `LoadedChunk::load()` process when restoring transaction chunks: [2](#0-1) 

The subsequent verification at line 167 only validates merkle proofs against the ledger info, not the signatures on the ledger info itself: [3](#0-2) 

The `TransactionListWithProofV2::verify()` method only checks transaction hashes and merkle accumulator proofs, never validating signatures: [4](#0-3) 

**Attack Scenario:**

1. Attacker obtains epoch history for epochs 0-10 (epoch_endings.len() = 11)
2. Attacker creates malicious backup with ledger_info claiming epoch = 15
3. Attacker crafts valid merkle proofs for fake transactions
4. During restore:
   - `verify_ledger_info()` sees epoch (15) > epoch_endings.len() (11)
   - Verification returns `Ok()` without checking signatures
   - Fake transactions with valid proofs are accepted
5. Malicious state is written to database via `save_transactions()` and `save_ledger_infos()` without signature validation [5](#0-4) 

The restore utilities save ledger infos directly to the database without invoking the signature checks that would normally be enforced during consensus commits: [6](#0-5) 

## Impact Explanation

**Critical Severity** - This vulnerability enables:

1. **Consensus Safety Violations**: An attacker can restore fake transaction history that was never committed by legitimate validators, causing nodes to operate on divergent state
2. **State Corruption**: Malicious state can be injected into the database, compromising the integrity of the Jellyfish Merkle tree and state store
3. **Validator Set Manipulation**: By restoring fake epoch-ending ledger infos, an attacker could inject fraudulent validator sets for future epochs
4. **Loss of Funds**: Fake transactions can mint tokens, transfer assets, or manipulate account balances

The TODO comment at line 280 acknowledges this is a known issue requiring a fix "from upper level," but no such fix exists. The warning message claims "node won't be able to start if this data is malicious," but this is incorrect—the malicious data is persisted to the database during restore and can corrupt consensus.

## Likelihood Explanation

**High Likelihood** for the following reasons:

1. **Attacker Requirements**: Only requires ability to create/modify backup files and initiate restore operations
2. **No Special Privileges**: Does not require validator access or consensus participation
3. **Known Issue**: The TODO comment indicates developers are aware but haven't fixed it
4. **Operational Scenario**: Backup restoration is a common operational procedure, especially during node recovery or disaster scenarios
5. **Bypass Condition**: Easy to trigger—simply create backup claiming epoch beyond current history

## Recommendation

The signature verification must be enforced for all epochs, not bypassed for future epochs. The fix should:

1. **Remove the bypass**: Delete the early return at lines 279-287
2. **Require trusted waypoints**: For epochs beyond the known history, mandate trusted waypoint verification
3. **Fail securely**: Return an error instead of accepting unverified data

**Proposed Fix:**

```rust
pub fn verify_ledger_info(&self, li_with_sigs: &LedgerInfoWithSignatures) -> Result<()> {
    let epoch = li_with_sigs.ledger_info().epoch();
    ensure!(!self.epoch_endings.is_empty(), "Empty epoch history.");
    
    // For epochs beyond known history, require trusted waypoint
    if epoch >= self.epoch_endings.len() as u64 {
        let wp_trusted = self
            .trusted_waypoints
            .get(&li_with_sigs.ledger_info().version())
            .ok_or_else(|| anyhow!(
                "Cannot verify epoch {} beyond known history (up to epoch {}). \
                 Trusted waypoint required but not found for version {}.",
                epoch,
                self.epoch_endings.len() - 1,
                li_with_sigs.ledger_info().version()
            ))?;
        let wp_li = Waypoint::new_any(li_with_sigs.ledger_info());
        ensure!(
            *wp_trusted == wp_li,
            "Waypoint mismatch for epoch beyond history. Expected: {}, got: {}",
            wp_trusted,
            wp_li
        );
        return Ok(());
    }
    
    // Continue with existing verification logic for known epochs...
}
```

Additionally, consider enforcing that backups must include complete epoch history or be validated against a minimum required waypoint.

## Proof of Concept

```rust
// Proof of Concept demonstrating the bypass
// File: storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs

#[cfg(test)]
mod vulnerability_test {
    use super::*;
    use aptos_crypto::HashValue;
    use aptos_types::{
        block_info::BlockInfo,
        ledger_info::{LedgerInfo, LedgerInfoWithSignatures},
        aggregate_signature::AggregateSignature,
    };
    use std::collections::HashMap;

    #[test]
    fn test_signature_bypass_for_future_epoch() {
        // Setup: Create epoch history for epochs 0-2
        let mut epoch_endings = vec![];
        for epoch in 0..=2 {
            let li = LedgerInfo::new(
                BlockInfo::new(
                    epoch,
                    0,
                    HashValue::zero(),
                    HashValue::zero(),
                    epoch * 100, // version
                    0,
                    None,
                ),
                HashValue::zero(),
            );
            epoch_endings.push(li);
        }
        
        let epoch_history = EpochHistory {
            epoch_endings,
            trusted_waypoints: Arc::new(HashMap::new()),
        };
        
        // Attack: Create malicious ledger info for epoch 10 (beyond history)
        // with INVALID/EMPTY signatures
        let malicious_li = LedgerInfo::new(
            BlockInfo::new(
                10, // epoch beyond history
                0,
                HashValue::zero(),
                HashValue::zero(),
                1000,
                0,
                None,
            ),
            HashValue::zero(),
        );
        
        let malicious_li_with_sigs = LedgerInfoWithSignatures::new(
            malicious_li,
            AggregateSignature::empty(), // Invalid/empty signature!
        );
        
        // Vulnerability: This verification PASSES even with invalid signatures
        // because epoch 10 > epoch_endings.len() (3)
        let result = epoch_history.verify_ledger_info(&malicious_li_with_sigs);
        
        // The verification should FAIL but it SUCCEEDS
        assert!(result.is_ok(), "Signature bypass vulnerability confirmed!");
        // This demonstrates the critical flaw: unsigned/malicious ledger infos
        // from future epochs are accepted without signature verification
    }
}
```

This proof of concept demonstrates that ledger infos claiming to be from epochs beyond the known history are accepted with empty signatures, confirming the critical signature verification bypass vulnerability.

### Citations

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L279-287)
```rust
        if epoch > self.epoch_endings.len() as u64 {
            // TODO(aldenhu): fix this from upper level
            warn!(
                epoch = epoch,
                epoch_history_until = self.epoch_endings.len(),
                "Epoch is too new and can't be verified. Previous chunks are verified and node \
                won't be able to start if this data is malicious."
            );
            return Ok(());
```

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L152-154)
```rust
        if let Some(epoch_history) = epoch_history {
            epoch_history.verify_ledger_info(&ledger_info)?;
        }
```

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L167-167)
```rust
        txn_list_with_proof.verify(ledger_info.ledger_info(), Some(manifest.first_version))?;
```

**File:** types/src/transaction/mod.rs (L2295-2354)
```rust
    pub fn verify(
        &self,
        ledger_info: &LedgerInfo,
        first_transaction_version: Option<Version>,
    ) -> Result<()> {
        // Verify the first transaction versions match
        ensure!(
            self.get_first_transaction_version() == first_transaction_version,
            "First transaction version ({:?}) doesn't match given version ({:?}).",
            self.get_first_transaction_version(),
            first_transaction_version,
        );

        // Verify the lengths of the transactions and transaction infos match
        ensure!(
            self.proof.transaction_infos.len() == self.get_num_transactions(),
            "The number of TransactionInfo objects ({}) does not match the number of \
             transactions ({}).",
            self.proof.transaction_infos.len(),
            self.get_num_transactions(),
        );

        // Verify the transaction hashes match those of the transaction infos
        self.transactions
            .par_iter()
            .zip_eq(self.proof.transaction_infos.par_iter())
            .map(|(txn, txn_info)| {
                let txn_hash = CryptoHash::hash(txn);
                ensure!(
                    txn_hash == txn_info.transaction_hash(),
                    "The hash of transaction does not match the transaction info in proof. \
                     Transaction hash: {:x}. Transaction hash in txn_info: {:x}.",
                    txn_hash,
                    txn_info.transaction_hash(),
                );
                Ok(())
            })
            .collect::<Result<Vec<_>>>()?;

        // Verify the transaction infos are proven by the ledger info.
        self.proof
            .verify(ledger_info, self.get_first_transaction_version())?;

        // Verify the events if they exist.
        if let Some(event_lists) = &self.events {
            ensure!(
                event_lists.len() == self.get_num_transactions(),
                "The length of event_lists ({}) does not match the number of transactions ({}).",
                event_lists.len(),
                self.get_num_transactions(),
            );
            event_lists
                .into_par_iter()
                .zip_eq(self.proof.transaction_infos.par_iter())
                .map(|(events, txn_info)| verify_events_against_root_hash(events, txn_info))
                .collect::<Result<Vec<_>>>()?;
        }

        Ok(())
    }
```

**File:** storage/aptosdb/src/backup/restore_utils.rs (L41-58)
```rust
pub(crate) fn save_ledger_infos(
    ledger_metadata_db: &LedgerMetadataDb,
    ledger_infos: &[LedgerInfoWithSignatures],
    existing_batch: Option<&mut SchemaBatch>,
) -> Result<()> {
    ensure!(!ledger_infos.is_empty(), "No LedgerInfos to save.");

    if let Some(existing_batch) = existing_batch {
        save_ledger_infos_impl(ledger_metadata_db, ledger_infos, existing_batch)?;
    } else {
        let mut batch = SchemaBatch::new();
        save_ledger_infos_impl(ledger_metadata_db, ledger_infos, &mut batch)?;
        ledger_metadata_db.write_schemas(batch)?;
        update_latest_ledger_info(ledger_metadata_db, ledger_infos)?;
    }

    Ok(())
}
```

**File:** storage/aptosdb/src/backup/restore_utils.rs (L179-190)
```rust
fn save_ledger_infos_impl(
    ledger_metadata_db: &LedgerMetadataDb,
    ledger_infos: &[LedgerInfoWithSignatures],
    batch: &mut SchemaBatch,
) -> Result<()> {
    ledger_infos
        .iter()
        .map(|li| ledger_metadata_db.put_ledger_info(li, batch))
        .collect::<Result<Vec<_>>>()?;

    Ok(())
}
```
