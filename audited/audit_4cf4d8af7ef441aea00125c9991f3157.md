# Audit Report

## Title
Race Condition in Per-Key JWK Consensus Causes Silent Discarding of Legitimate Updates

## Summary
When the `JWK_CONSENSUS_PER_KEY_MODE` feature flag is enabled, multiple JWK updates for the same issuer but different keys can be included in a single block. Due to sequential execution and issuer-level version checking, only the first update succeeds while subsequent updates fail the version check and are silently discarded via the Expected failure path, resulting in permanent loss of legitimate security updates.

## Finding Description

The vulnerability exists in the interaction between per-key consensus mode and the version validation logic in `process_jwk_update_inner()`. [1](#0-0) 

When per-key mode is enabled, validators can create independent quorum-certified updates for different keys of the same issuer. These updates use different topics in the validator transaction pool: [2](#0-1) [3](#0-2) 

The pool allows multiple updates for the same issuer (with different key IDs) to coexist and be included in the same block: [4](#0-3) 

During block execution, these transactions are processed sequentially. Each update for the same issuer starts with the same `base_version` and targets the same new version. The first update succeeds and increments the on-chain version. When the second update executes, it loads the already-modified state and fails the version check: [5](#0-4) 

This triggers the Expected failure path: [6](#0-5) 

The transaction is **discarded** with `TransactionStatus::Discard(StatusCode::ABORTED)`, meaning the legitimate JWK update for the second key is permanently lost.

**Attack Scenario:**
1. Current on-chain `ProviderJWKs` for issuer "google.com" has version 10
2. Validator node A observes and certifies: `KeyLevelUpdate { issuer: "google.com", base_version: 10, kid: "key1", ... }` → becomes `ProviderJWKs { version: 11, jwks: [key1_jwk] }`
3. Validator node B independently observes and certifies: `KeyLevelUpdate { issuer: "google.com", base_version: 10, kid: "key2", ... }` → becomes `ProviderJWKs { version: 11, jwks: [key2_jwk] }`
4. Both enter the pool with different topics and are included in the same block
5. During execution:
   - Update for key1 succeeds, version becomes 11
   - Update for key2 fails version check (11 + 1 ≠ 11), gets **discarded**
   - key2 update is permanently lost

This breaks the **Deterministic Execution** invariant because validators cannot predict which updates will succeed based purely on transaction content. It also breaks **State Consistency** because legitimate, quorum-certified security updates are silently lost.

## Impact Explanation

This is a **High Severity** vulnerability per Aptos bug bounty criteria ("Significant protocol violations"):

1. **Authentication/Authorization Impact**: If malicious JWKs are applied while legitimate ones are discarded, this compromises OIDC-based authentication mechanisms that rely on these keys
2. **Silent Data Loss**: Legitimate, quorum-certified JWK updates are permanently discarded with no error visible to validators or operators
3. **Non-Deterministic Behavior**: The outcome depends on transaction ordering within a block, which may vary based on network timing
4. **Protocol Integrity**: The per-key consensus mechanism fails to achieve its design goal of allowing independent key updates

While not Critical severity (no direct fund loss), this significantly impacts protocol security and correctness.

## Likelihood Explanation

**Likelihood: Medium to High** when per-key mode is enabled.

Factors increasing likelihood:
- No malicious intent required - this is a race condition between legitimate validators
- Occurs whenever multiple validators independently observe different key updates for the same issuer within the same epoch
- More likely during JWK rotation events when multiple keys need updating
- The per-key mode is designed to enable this exact scenario (multiple key updates), making the bug highly likely to manifest [7](#0-6) 

## Recommendation

**Fix the version checking logic to support per-key mode correctly:**

Option 1: **Skip version check for per-key updates** in the Rust validation layer, relying on the Move-level validation which already handles per-key semantics correctly: [8](#0-7) 

Option 2: **Batch same-issuer updates** at the proposal generation level to ensure only one update per issuer per block.

Option 3: **Modify version semantics** for per-key mode to use (issuer, kid) pair versioning instead of issuer-only versioning.

**Recommended Fix (Option 1):**

In `process_jwk_update_inner()`, check if per-key mode is enabled and skip the Rust-level version check, allowing the Move function to handle versioning correctly:

```rust
// Check version only in non-per-key mode
if !is_per_key_mode_enabled() {
    if on_chain.version + 1 != observed.version {
        return Err(Expected(IncorrectVersion));
    }
}
```

This allows the Move-level validation to handle per-key updates correctly while maintaining safety for issuer-level mode.

## Proof of Concept

**Integration Test Scenario:**

1. Enable `JWK_CONSENSUS_PER_KEY_MODE` feature flag
2. Create two key-level updates for the same issuer with the same `base_version`:
   - Update A: `KeyLevelUpdate { issuer: "issuer1", base_version: 0, kid: "key1", to_upsert: Some(jwk1) }`
   - Update B: `KeyLevelUpdate { issuer: "issuer1", base_version: 0, kid: "key2", to_upsert: Some(jwk2) }`
3. Get both quorum-certified independently
4. Add both to the validator transaction pool
5. Generate a block containing both updates
6. Execute the block
7. **Observe:** Only the first update succeeds, second returns `VMStatus::MoveAbort` with `IncorrectVersion` code and `TransactionStatus::Discard`
8. **Verify:** On-chain `ProviderJWKs` contains only key1, key2 is missing despite being quorum-certified

This can be implemented by extending existing tests in: [9](#0-8) 

The test should verify that when two key-level updates for the same issuer are processed in the same block, both keys end up in the final on-chain state (which currently fails).

### Citations

**File:** aptos-move/aptos-vm/src/validator_txns/jwk.rs (L78-88)
```rust
            Err(Expected(failure)) => {
                // Pretend we are inside Move, and expected failures are like Move aborts.
                debug!("Processing dkg transaction expected failure: {:?}", failure);
                Ok((
                    VMStatus::MoveAbort {
                        location: AbortLocation::Script,
                        code: failure as u64,
                        message: None,
                    },
                    VMOutput::empty_with_status(TransactionStatus::Discard(StatusCode::ABORTED)),
                ))
```

**File:** aptos-move/aptos-vm/src/validator_txns/jwk.rs (L100-130)
```rust
    fn process_jwk_update_inner(
        &self,
        resolver: &impl AptosMoveResolver,
        module_storage: &impl AptosModuleStorage,
        log_context: &AdapterLogSchema,
        session_id: SessionId,
        update: jwks::QuorumCertifiedUpdate,
    ) -> Result<(VMStatus, VMOutput), ExecutionFailure> {
        // Load resources.
        let validator_set =
            ValidatorSet::fetch_config(resolver).ok_or(Expected(MissingResourceValidatorSet))?;
        let observed_jwks =
            ObservedJWKs::fetch_config(resolver).ok_or(Expected(MissingResourceObservedJWKs))?;

        let mut jwks_by_issuer: HashMap<Issuer, ProviderJWKs> =
            observed_jwks.into_providers_jwks().into();
        let issuer = update.update.issuer.clone();
        let on_chain = jwks_by_issuer
            .entry(issuer.clone())
            .or_insert_with(|| ProviderJWKs::new(issuer));
        let verifier = ValidatorVerifier::from(&validator_set);

        let QuorumCertifiedUpdate {
            update: observed,
            multi_sig,
        } = update;

        // Check version.
        if on_chain.version + 1 != observed.version {
            return Err(Expected(IncorrectVersion));
        }
```

**File:** types/src/validator_txn.rs (L55-64)
```rust
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
#[allow(non_camel_case_types)]
pub enum Topic {
    DKG,
    JWK_CONSENSUS(jwks::Issuer),
    JWK_CONSENSUS_PER_KEY_MODE {
        issuer: jwks::Issuer,
        kid: jwks::KID,
    },
}
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager_per_key.rs (L336-341)
```rust
                let topic = Topic::JWK_CONSENSUS_PER_KEY_MODE {
                    issuer: issuer.clone(),
                    kid: kid.clone(),
                };
                let txn = ValidatorTransaction::ObservedJWKUpdate(issuer_level_repr.clone());
                let vtxn_guard = self.vtxn_pool.put(topic, Arc::new(txn), None);
```

**File:** crates/validator-transaction-pool/src/lib.rs (L58-82)
```rust
    pub fn put(
        &self,
        topic: Topic,
        txn: Arc<ValidatorTransaction>,
        pull_notification_tx: Option<aptos_channel::Sender<(), Arc<ValidatorTransaction>>>,
    ) -> TxnGuard {
        let mut pool = self.inner.lock();
        let seq_num = pool.next_seq_num;
        pool.next_seq_num += 1;

        pool.txn_queue.insert(seq_num, PoolItem {
            topic: topic.clone(),
            txn,
            pull_notification_tx,
        });

        if let Some(old_seq_num) = pool.seq_nums_by_topic.insert(topic.clone(), seq_num) {
            pool.txn_queue.remove(&old_seq_num);
        }

        TxnGuard {
            pool: self.inner.clone(),
            seq_num,
        }
    }
```

**File:** crates/aptos-jwk-consensus/src/epoch_manager.rs (L228-235)
```rust
                if features.is_enabled(FeatureFlag::JWK_CONSENSUS_PER_KEY_MODE) {
                    Box::new(KeyLevelConsensusManager::new(
                        Arc::new(my_sk),
                        self.my_addr,
                        epoch_state.clone(),
                        rb,
                        self.vtxn_pool.clone(),
                    ))
```

**File:** aptos-move/framework/aptos-framework/sources/jwks.move (L466-495)
```text
        if (features::is_jwk_consensus_per_key_mode_enabled()) {
            vector::for_each(provider_jwks_vec, |proposed_provider_jwks|{
                let maybe_cur_issuer_jwks = remove_issuer(&mut observed_jwks.jwks, proposed_provider_jwks.issuer);
                let cur_issuer_jwks = if (option::is_some(&maybe_cur_issuer_jwks)) {
                    option::extract(&mut maybe_cur_issuer_jwks)
                } else {
                    ProviderJWKs {
                        issuer: proposed_provider_jwks.issuer,
                        version: 0,
                        jwks: vector[],
                    }
                };
                assert!(cur_issuer_jwks.version + 1 == proposed_provider_jwks.version, error::invalid_argument(EUNEXPECTED_VERSION));
                vector::for_each(proposed_provider_jwks.jwks, |jwk|{
                    let variant_type_name = *string::bytes(copyable_any::type_name(&jwk.variant));
                    let is_delete = if (variant_type_name == b"0x1::jwks::UnsupportedJWK") {
                        let repr = copyable_any::unpack<UnsupportedJWK>(jwk.variant);
                        &repr.payload == &DELETE_COMMAND_INDICATOR
                    } else {
                        false
                    };
                    if (is_delete) {
                        remove_jwk(&mut cur_issuer_jwks, get_jwk_id(&jwk));
                    } else {
                        upsert_jwk(&mut cur_issuer_jwks, jwk);
                    }
                });
                cur_issuer_jwks.version = cur_issuer_jwks.version + 1;
                upsert_provider_jwks(&mut observed_jwks.jwks, cur_issuer_jwks);
            });
```

**File:** testsuite/smoke-test/src/jwks/jwk_consensus_per_key.rs (L1-1)
```rust
// Copyright (c) Aptos Foundation
```
