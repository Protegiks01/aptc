# Audit Report

## Title
Memory Accounting Bypass via Vector Capacity Exploitation - Abstract Value Size Calculation Ignores Rust Vec Capacity

## Summary
The abstract value size calculation for Move vectors only considers the vector's **length** but actual memory consumption is determined by the vector's **capacity**. An attacker can create vectors with large capacity but minimal length, bypassing memory quota enforcement and consuming significantly more memory than charged for, leading to validator node resource exhaustion.

## Finding Description

The Move VM uses abstract value size to track heap memory usage and enforce memory quotas. [1](#0-0) 

Abstract value size for vectors is calculated based only on the vector's **length**, not its **capacity**. [2](#0-1) 

However, Rust's `Vec<T>` maintains both `len` and `capacity`, where capacity is the allocated memory. When elements are pushed to a vector, Rust grows the capacity exponentially (typically doubling). When elements are popped, the standard `Vec::pop()` method **does not shrink capacity**. [3](#0-2) 

**Attack Scenario:**

1. Attacker creates a `vector<u8>` and pushes 1,000,000 elements
2. Vector capacity grows to ~1,000,000 bytes  
3. Attacker pops 999,999 elements
4. Vector now has: **length = 1**, **capacity = ~1,000,000**
5. Abstract value size calculated: `40 + 1 * 1 = 41` units
6. Actual memory consumption: `48 + 1,000,000 â‰ˆ 1 MB`
7. **Amplification factor: ~24,000x**

The memory quota enforcement uses abstract value size to track heap usage: [4](#0-3) 

Since the abstract size is based on length (1 element) rather than capacity (1M bytes), the memory tracker believes only 41 abstract units are consumed when actually ~1MB of memory is held.

This breaks the **Resource Limits** invariant (#9): "All operations must respect gas, storage, and computational limits" and the **Move VM Safety** invariant (#3): "Bytecode execution must respect gas limits and memory constraints."

## Impact Explanation

**High Severity** - Validator Node Slowdowns and Resource Exhaustion:

1. **Memory Exhaustion**: An attacker can submit multiple transactions that each create vectors with high capacity but low length, bypassing the memory quota (`10_000_000` abstract units). With a 24,000x amplification factor, an attacker could consume gigabytes of memory while only being charged for kilobytes in abstract units.

2. **Validator Node Slowdowns**: Excessive memory consumption leads to:
   - Increased garbage collection pressure
   - Memory thrashing
   - Slower transaction processing
   - Potential node crashes under memory pressure

3. **Transaction Cost Bypass**: Operations that depend on abstract value size (like event writing) significantly undercharge: [5](#0-4) 

This fits the **High Severity** criteria per Aptos bug bounty: "Validator node slowdowns" and "Significant protocol violations."

## Likelihood Explanation

**High Likelihood**:

1. **Easy to Exploit**: Requires only standard Move vector operations (`vector::push_back`, `vector::pop_back`) available to any transaction sender
2. **No Special Privileges**: Any user can submit transactions with malicious vector manipulation
3. **Amplification Available**: Each transaction can create multiple vectors with capacity amplification
4. **No Detection**: Current gas metering and memory tracking cannot detect this attack
5. **Deterministic**: The attack works reliably due to Rust's standard vector growth strategy

## Recommendation

Implement one of the following fixes:

**Option 1: Call `shrink_to_fit()` after vector pop operations**

Modify the `VectorRef::pop()` implementation to shrink capacity when appropriate: [3](#0-2) 

After the `pop()` calls (lines 3780-3839), add:
```rust
// Shrink capacity if length drops significantly below capacity
// For example, shrink if len < capacity/4
if let Container::VecU8(r) = c {
    let mut vec = r.borrow_mut();
    if vec.len() < vec.capacity() / 4 {
        vec.shrink_to_fit();
    }
}
// Repeat for all vector types...
```

**Option 2: Track actual memory capacity in abstract value size**

Modify abstract value size calculation to estimate capacity, not just length. For vectors that have grown and shrunk, estimate capacity as `max(len, prev_capacity)` or use a heuristic like `len * growth_factor`.

**Option 3: Add explicit `shrink_to_fit` native function**

Expose a native Move function to allow explicit capacity management, and call it automatically during memory-sensitive operations.

**Recommended**: Implement Option 1 with a threshold-based shrinking strategy to balance memory usage with performance (frequent shrinking has overhead).

## Proof of Concept

```move
module attacker::memory_bypass {
    use std::vector;
    
    /// Demonstrates memory accounting bypass
    /// This function consumes ~1MB of actual memory but only ~41 abstract value units
    public entry fun exploit_memory_accounting() {
        // Create vector and reserve large capacity
        let vec = vector::empty<u8>();
        
        // Push 1 million elements - capacity grows to ~1M
        let i = 0;
        while (i < 1_000_000) {
            vector::push_back(&mut vec, 1u8);
            i = i + 1;
        };
        
        // Pop 999,999 elements - capacity remains ~1M, length becomes 1
        i = 0;
        while (i < 999_999) {
            vector::pop_back(&mut vec);
            i = i + 1;
        };
        
        // Vector now has:
        // - Length: 1 (only 1 element)
        // - Capacity: ~1,000,000 (1MB of allocated memory)
        // - Abstract value size: 40 + 1*1 = 41 units
        // - Actual memory: ~1MB
        // 
        // Amplification: ~24,000x
        
        // Keep vector alive to hold memory
        let _holder = vec;
    }
}
```

**Test Scenario:**
1. Deploy this module
2. Call `exploit_memory_accounting()` from multiple transactions
3. Observe validator memory usage increases significantly
4. Gas charged and memory quota tracking show minimal consumption
5. Abstract value size reports ~41 units while actual memory is ~1MB per call

## Notes

The vulnerability affects all vector types (`vector<u8>`, `vector<u64>`, generic vectors, etc.) because the root cause is in how Rust's `Vec::pop()` behaves - it never shrinks capacity without explicit `shrink_to_fit()` calls.

The memory quota of 10,000,000 abstract units is meant to limit transactions to reasonable memory usage, but with 24,000x amplification, an attacker could theoretically consume 240GB of memory while staying within quota (though OS limits would intervene first).

This is particularly dangerous because:
1. The attack is **deterministic** - works on all validators identically
2. Creates **persistent memory pressure** - vectors hold memory until dropped
3. Can be **amplified across transactions** - submit many transactions with this pattern
4. **Bypasses existing defenses** - memory quota enforcement is ineffective

### Citations

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L142-142)
```rust
        [memory_quota: AbstractValueSize, { 1.. => "memory_quota" }, 10_000_000],
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/misc.rs (L335-343)
```rust
    fn visit_vec_u8(&mut self, depth: u64, vals: &[u8]) -> PartialVMResult<()> {
        self.check_depth(depth)?;
        let mut size = self.params.per_u8_packed * NumArgs::new(vals.len() as u64);
        if self.feature_version >= 3 {
            size += self.params.vector;
        }
        self.size += size;
        Ok(())
    }
```

**File:** third_party/move/move-vm/types/src/values/values_impl.rs (L3769-3845)
```rust
    pub fn pop(&self) -> PartialVMResult<Value> {
        let c = self.0.container();

        macro_rules! err_pop_empty_vec {
            () => {
                return Err(PartialVMError::new(StatusCode::VECTOR_OPERATION_ERROR)
                    .with_sub_status(POP_EMPTY_VEC))
            };
        }

        let res = match c {
            Container::VecU8(r) => match r.borrow_mut().pop() {
                Some(x) => Value::u8(x),
                None => err_pop_empty_vec!(),
            },
            Container::VecU16(r) => match r.borrow_mut().pop() {
                Some(x) => Value::u16(x),
                None => err_pop_empty_vec!(),
            },
            Container::VecU32(r) => match r.borrow_mut().pop() {
                Some(x) => Value::u32(x),
                None => err_pop_empty_vec!(),
            },
            Container::VecU64(r) => match r.borrow_mut().pop() {
                Some(x) => Value::u64(x),
                None => err_pop_empty_vec!(),
            },
            Container::VecU128(r) => match r.borrow_mut().pop() {
                Some(x) => Value::u128(x),
                None => err_pop_empty_vec!(),
            },
            Container::VecU256(r) => match r.borrow_mut().pop() {
                Some(x) => Value::u256(x),
                None => err_pop_empty_vec!(),
            },
            Container::VecI8(r) => match r.borrow_mut().pop() {
                Some(x) => Value::i8(x),
                None => err_pop_empty_vec!(),
            },
            Container::VecI16(r) => match r.borrow_mut().pop() {
                Some(x) => Value::i16(x),
                None => err_pop_empty_vec!(),
            },
            Container::VecI32(r) => match r.borrow_mut().pop() {
                Some(x) => Value::i32(x),
                None => err_pop_empty_vec!(),
            },
            Container::VecI64(r) => match r.borrow_mut().pop() {
                Some(x) => Value::i64(x),
                None => err_pop_empty_vec!(),
            },
            Container::VecI128(r) => match r.borrow_mut().pop() {
                Some(x) => Value::i128(x),
                None => err_pop_empty_vec!(),
            },
            Container::VecI256(r) => match r.borrow_mut().pop() {
                Some(x) => Value::i256(x),
                None => err_pop_empty_vec!(),
            },
            Container::VecBool(r) => match r.borrow_mut().pop() {
                Some(x) => Value::bool(x),
                None => err_pop_empty_vec!(),
            },
            Container::VecAddress(r) => match r.borrow_mut().pop() {
                Some(x) => Value::address(x),
                None => err_pop_empty_vec!(),
            },
            Container::Vec(r) => match r.borrow_mut().pop() {
                Some(x) => x,
                None => err_pop_empty_vec!(),
            },
            Container::Locals(_) | Container::Struct(_) => unreachable!(),
        };

        self.0.mark_dirty();
        Ok(res)
    }
```

**File:** aptos-move/aptos-memory-usage-tracker/src/lib.rs (L48-63)
```rust
    fn use_heap_memory(&mut self, amount: AbstractValueSize) -> PartialVMResult<()> {
        if self.feature_version >= 3 {
            match self.remaining_memory_quota.checked_sub(amount) {
                Some(remaining_quota) => {
                    self.remaining_memory_quota = remaining_quota;
                    Ok(())
                },
                None => {
                    self.remaining_memory_quota = 0.into();
                    Err(PartialVMError::new(StatusCode::MEMORY_LIMIT_EXCEEDED))
                },
            }
        } else {
            Ok(())
        }
    }
```

**File:** aptos-move/framework/src/natives/event.rs (L116-119)
```rust
    context.charge(
        EVENT_WRITE_TO_EVENT_STORE_BASE
            + EVENT_WRITE_TO_EVENT_STORE_PER_ABSTRACT_VALUE_UNIT * context.abs_val_size(&msg)?,
    )?;
```
