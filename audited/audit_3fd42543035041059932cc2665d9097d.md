# Audit Report

## Title
Pre-Gas-Charge Value Traversal in `native_compare()` Enables Validator Resource Exhaustion

## Summary
The `native_compare()` function in `aptos-move/framework/move-stdlib/src/natives/cmp.rs` performs expensive value tree traversal to calculate gas costs **before** charging any gas, violating the "charge first, execute later" principle. This allows attackers to exhaust validator CPU resources by passing large nested structures to comparison operations, performing O(n) computation for free where n is the total number of nodes in the value tree.

## Finding Description

The vulnerability exists in the gas charging sequence of the `native_compare()` function: [1](#0-0) 

The function calculates the gas cost by calling `abs_val_size_dereferenced()` on both arguments (lines 50-51), which triggers a complete traversal of both value trees. Only after this expensive computation completes does line 52 charge gas.

The traversal mechanism in `abs_val_size_dereferenced()` recursively visits every node for non-optimized containers: [2](#0-1) 

For vectors containing structs or nested structures, this results in O(n) traversal where n is the total number of elements across all nesting levels (limited only by depth 128): [3](#0-2) 

**The Critical Flaw:** The `SafeNativeContext` explicitly documents the required pattern: [4](#0-3) 

However, `native_compare()` violates this by performing expensive traversal operations in the gas calculation phase itself, before `context.charge()` is called.

**Correct Pattern:** The `native_serialized_size()` function demonstrates the proper implementation: [5](#0-4) 

This function charges a base cost **first** (line 133), then performs the calculation, then charges additional gas based on the result (line 149).

**Attack Scenario:**

1. Attacker creates a transaction with large nested structures (e.g., vector of 50,000 structs, each containing multiple fields)
2. Calls Move functions that invoke `std::cmp::compare()` on these structures multiple times within the transaction
3. Each `compare()` call triggers traversal of both value trees (potentially 100,000+ node visits total) **before** any gas is charged for the comparison
4. If the transaction contains a loop calling `compare()` N times, total free traversal work becomes N × (node_count_1 + node_count_2)
5. Validator nodes process this work synchronously, blocking transaction execution
6. Attacker pays gas only for the vector creation and loop execution, but gets free traversal computation that is proportionally more expensive

## Impact Explanation

This is **HIGH severity** per Aptos Bug Bounty criteria:
- **Validator node slowdowns**: Attackers can force validators to perform expensive O(n) traversal operations before paying gas, causing processing delays across all validators
- **Significant protocol violation**: Violates the fundamental gas metering invariant that "all operations must respect gas limits" (Invariant #9) and "bytecode execution must respect gas limits and memory constraints" (Invariant #3)
- **Unprivileged exploitation**: Any transaction sender can exploit this without special access

The gas parameters show the vulnerability: [6](#0-5) 

While gas is eventually charged proportionally (14 per abstract value unit), the calculation of that abstract value size itself requires expensive traversal that happens **before** the base cost of 367 is deducted.

## Likelihood Explanation

**HIGH likelihood** of exploitation:
- Transaction size limit of 64KB allows construction of moderately large nested structures within a single transaction: [7](#0-6) 

- Attacker can create vectors of structs programmatically within Move code using loops
- The `std::cmp::compare()` function is part of the standard library and commonly used in Move contracts
- No special privileges or validator access required
- Attack can be repeated across multiple transactions to sustain validator slowdown
- All validators processing transactions with large `compare()` operations are affected simultaneously

## Recommendation

Restructure `native_compare()` to follow the proven pattern from `native_serialized_size()` by charging a base cost before performing any value traversal:

```rust
fn native_compare(
    context: &mut SafeNativeContext,
    _ty_args: &[Type],
    args: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    debug_assert!(args.len() == 2);
    if args.len() != 2 {
        return Err(SafeNativeError::InvariantViolation(PartialVMError::new(
            StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR,
        )));
    }

    // CHARGE BASE COST FIRST - before any expensive operations
    context.charge(CMP_COMPARE_BASE)?;
    
    // THEN calculate abstract sizes (expensive traversal)
    let size1 = context.abs_val_size_dereferenced(&args[0])?;
    let size2 = context.abs_val_size_dereferenced(&args[1])?;
    
    // THEN charge for size-dependent work
    context.charge(CMP_COMPARE_PER_ABS_VAL_UNIT * (size1 + size2))?;

    // Finally perform the comparison
    let ordering = args[0].compare(&args[1])?;
    let ordering_move_variant = match ordering {
        std::cmp::Ordering::Less => ORDERING_LESS_THAN_VARIANT,
        std::cmp::Ordering::Equal => ORDERING_EQUAL_VARIANT,
        std::cmp::Ordering::Greater => ORDERING_GREATER_THAN_VARIANT,
    };

    Ok(smallvec![Value::struct_(Struct::pack(vec![Value::u16(
        ordering_move_variant
    )]))])
}
```

This ensures:
1. Base gas cost (367 units) is charged **before** any value traversal
2. If size calculation fails or exhausts gas, the base cost has already been paid
3. Additional size-dependent gas is charged before the actual comparison
4. Follows the documented "charge first, execute later" principle

## Proof of Concept

```move
module attacker::resource_exhaust {
    use std::cmp;
    use std::vector;

    struct NestedData has copy, drop {
        field1: u64,
        field2: u64,
        field3: u64,
        field4: u64,
        field5: u64,
    }

    public entry fun exhaust_validator_resources() {
        // Create large vector of structs (within transaction size limits)
        let vec1 = vector::empty<NestedData>();
        let vec2 = vector::empty<NestedData>();
        
        let i = 0;
        // Create 10,000 struct elements in each vector
        while (i < 10000) {
            vector::push_back(&mut vec1, NestedData {
                field1: i,
                field2: i + 1,
                field3: i + 2,
                field4: i + 3,
                field5: i + 4,
            });
            vector::push_back(&mut vec2, NestedData {
                field1: i,
                field2: i + 1,
                field3: i + 2,
                field4: i + 3,
                field5: i + 4,
            });
            i = i + 1;
        };
        
        // Call compare() multiple times - each triggers full traversal BEFORE charging gas
        let j = 0;
        while (j < 100) {
            // Each call: 20,000 structs × 6 nodes/struct = 120,000 node visits
            // BEFORE gas is charged for the comparison
            let _result = cmp::compare(&vec1, &vec2);
            j = j + 1;
        };
        
        // Total free traversal work: 100 calls × 120,000 nodes = 12,000,000 node visits
        // before any comparison gas is charged
    }
}
```

**Expected Behavior:** Validators experience CPU slowdown processing this transaction due to 12 million node visits in `abs_val_size_dereferenced()` calls happening before gas charges, while attacker only pays gas for vector creation and loop execution.

## Notes

This vulnerability specifically affects **non-optimized containers** (vectors of structs, nested structures) where the traversal iterates through all elements. Optimized vectors (`VecU8`, `VecU64`, etc.) only access the length in O(1) time: [8](#0-7) 

However, any use of `std::cmp::compare()` with complex nested structures allows exploitation of this gas accounting flaw, making it a systemic issue affecting validator resource management across the network.

### Citations

**File:** aptos-move/framework/move-stdlib/src/natives/cmp.rs (L48-54)
```rust
    let cost = CMP_COMPARE_BASE
        + CMP_COMPARE_PER_ABS_VAL_UNIT
            * (context.abs_val_size_dereferenced(&args[0])?
                + context.abs_val_size_dereferenced(&args[1])?);
    context.charge(cost)?;

    let ordering = args[0].compare(&args[1])?;
```

**File:** third_party/move/move-vm/types/src/values/values_impl.rs (L57-57)
```rust
pub const DEFAULT_MAX_VM_VALUE_NESTED_DEPTH: u64 = 128;
```

**File:** third_party/move/move-vm/types/src/values/values_impl.rs (L5485-5492)
```rust
            Vec(r) => {
                let r = r.borrow();
                if visitor.visit_vec(depth, r.len())? {
                    for val in r.iter() {
                        val.visit_impl(visitor, depth + 1)?;
                    }
                }
                Ok(())
```

**File:** aptos-move/aptos-native-interface/src/context.rs (L69-72)
```rust
    /// Always remember: first charge gas, then execute!
    ///
    /// In other words, this function **MUST** always be called **BEFORE** executing **any**
    /// gas-metered operation or library call within a native function.
```

**File:** aptos-move/framework/move-stdlib/src/natives/bcs.rs (L133-149)
```rust
    context.charge(BCS_SERIALIZED_SIZE_BASE)?;

    let reference = safely_pop_arg!(args, Reference);
    let ty = &ty_args[0];

    let serialized_size = match serialized_size_impl(context, reference, ty) {
        Ok(serialized_size) => serialized_size as u64,
        Err(_) => {
            context.charge(BCS_SERIALIZED_SIZE_FAILURE)?;

            // Re-use the same abort code as bcs::to_bytes.
            return Err(SafeNativeError::Abort {
                abort_code: NFE_BCS_SERIALIZATION_FAILURE,
            });
        },
    };
    context.charge(BCS_SERIALIZED_SIZE_PER_BYTE_SERIALIZED * NumBytes::new(serialized_size))?;
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/move_stdlib.rs (L48-49)
```rust
        [cmp_compare_base: InternalGas, { RELEASE_V1_24.. => "cmp.compare.base" }, 367],
        [cmp_compare_per_abs_val_unit: InternalGasPerAbstractValueUnit, { RELEASE_V1_24.. => "cmp.compare.per_abs_val_unit"}, 14],
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L73-76)
```rust
            max_transaction_size_in_bytes: NumBytes,
            "max_transaction_size_in_bytes",
            64 * 1024
        ],
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/misc.rs (L335-343)
```rust
    fn visit_vec_u8(&mut self, depth: u64, vals: &[u8]) -> PartialVMResult<()> {
        self.check_depth(depth)?;
        let mut size = self.params.per_u8_packed * NumArgs::new(vals.len() as u64);
        if self.feature_version >= 3 {
            size += self.params.vector;
        }
        self.size += size;
        Ok(())
    }
```
