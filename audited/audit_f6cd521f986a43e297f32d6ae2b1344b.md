# Audit Report

## Title
Block Gas Limit Miscalculation Due to Component-wise Rounding Causes Premature Block Termination and Reduced Validator Rewards

## Summary
The `BlockGasLimitProcessor` uses individually-rounded gas components (`execution_gas_units` + `io_gas_units`) from `FeeStatement` to track block gas consumption, while these components can sum to more than the actual total gas due to independent ceiling rounding. This causes blocks to terminate prematurely, excluding valid transactions and reducing validator fee rewards.

## Finding Description

The vulnerability stems from a discrepancy in how gas is measured for block limits versus how it's actually consumed. [1](#0-0) 

The FeeStatement documentation acknowledges "potential precision loss when the conversion between internal and external gas units," noting the total is "the final charge, while the break down is merely informational."

However, the `BlockGasLimitProcessor` uses these "informational" components for critical block termination decisions: [2](#0-1) 

The root cause is in the gas unit conversion with scaling factor = 1,000,000: [3](#0-2) 

**The Rounding Issue:**

Individual components are rounded up independently: [4](#0-3) 

Due to the ceiling rounding function: [5](#0-4) 

This creates the mathematical inequality: `ceil(a/scale) + ceil(b/scale) ≥ ceil((a+b)/scale)`, with equality only when both `a` and `b` are exact multiples of `scale`.

**Exploitation Path:**

1. Attacker crafts transactions where internal gas units for execution and IO are not exact multiples of 1,000,000
2. Each component rounds up independently (e.g., 0.5 → 1, 0.5 → 1, sum = 2 instead of actual 1)
3. Block gas limit accumulator inflates faster than actual consumption
4. Block terminates early when inflated sum reaches limit
5. Valid transactions excluded, reducing total fees collected
6. Validators receive fewer rewards than they should

**Example Calculation:**
- Transaction with exec_internal = 500,000, io_internal = 500,000
- exec_external = ceil(0.5) = 1
- io_external = ceil(0.5) = 1  
- Reported to block limit: 2 gas units
- Actual consumption: ceil(1.0) = 1 gas unit
- Per-transaction overcharge: 100%

Notably, the executor correctly avoids this issue for reward distribution: [6](#0-5) 

The comment explicitly states they "deliberately NOT use the execution gas and IO gas value from the fee statement, because they might round up during the calculation and the sum of them could be larger than the actual value we burn."

## Impact Explanation

This qualifies as **High Severity** under "Significant protocol violations":

1. **Validator Economic Impact**: Blocks terminate at ~50-99% of actual capacity in worst-case scenarios, directly reducing fee rewards
2. **Resource Limit Violation**: Breaks invariant #9 (Resource Limits) - blocks enforce incorrect gas limits based on inflated accounting
3. **Protocol Integrity**: The block gas limit mechanism, intended to prevent resource exhaustion, instead causes resource under-utilization
4. **Compounding Effect**: Over thousands of transactions per block, even sub-gas-unit discrepancies accumulate to significant capacity loss

While not a consensus violation (all nodes calculate identically), this represents a systematic protocol-level miscalculation affecting validator economics.

## Likelihood Explanation

**Likelihood: Medium-High**

The vulnerability occurs automatically for any transaction where internal gas values aren't exact multiples of 1,000,000. Given:
- Most transactions have fractional internal gas consumption
- No attacker action required beyond normal transaction submission
- Effect compounds across all transactions in a block
- No special privileges needed to exploit

However, maximizing exploitation requires sophisticated transaction engineering to consistently produce maximum rounding discrepancies.

## Recommendation

Use the actual consumed gas (total_charge_gas_units minus storage) for block limit tracking instead of component sums:

```rust
// In limit_processor.rs, replace lines 103-107:
let raw_gas_used = fee_statement.gas_used()
    .saturating_sub(fee_statement.storage_fee_used().div_ceil(
        /* need access to gas_unit_price here */
    ))
    * self.block_gas_limit_type.execution_gas_effective_multiplier();
```

Alternatively, calculate execution + IO gas accurately at the internal level before conversion, then convert once with a single rounding operation.

## Proof of Concept

```rust
// Demonstration of rounding discrepancy
use aptos_gas_algebra::GasScalingFactor;

fn demonstrate_rounding_issue() {
    const SCALING_FACTOR: u64 = 1_000_000;
    
    // Transaction with fractional gas consumption
    let exec_internal: u64 = 500_000;
    let io_internal: u64 = 500_000;
    let total_internal = exec_internal + io_internal;
    
    // Component-wise conversion (what BlockGasLimitProcessor uses)
    let exec_external = (exec_internal + SCALING_FACTOR - 1) / SCALING_FACTOR; // ceil
    let io_external = (io_internal + SCALING_FACTOR - 1) / SCALING_FACTOR; // ceil
    let component_sum = exec_external + io_external;
    
    // Actual total (what was really consumed)
    let actual_total = (total_internal + SCALING_FACTOR - 1) / SCALING_FACTOR; // ceil
    
    assert_eq!(component_sum, 2);
    assert_eq!(actual_total, 1);
    assert_eq!(component_sum - actual_total, 1); // 100% discrepancy!
    
    // Over 10,000 such transactions in a block:
    let block_discrepancy = (component_sum - actual_total) * 10_000;
    println!("Block capacity lost: {} gas units", block_discrepancy);
    // Output: Block capacity lost: 10000 gas units
}
```

To test in practice, submit transactions with Move code designed to consume gas in fractional patterns and observe block termination occurring before the actual block gas limit is reached.

**Notes**

The developers were aware of this rounding issue as evidenced by the explicit comment in `executor.rs` avoiding component use for reward calculations. However, they did not apply the same fix to block gas limit tracking in `limit_processor.rs`, creating this vulnerability. The fix should ensure consistent gas accounting across all subsystems.

### Citations

**File:** types/src/fee_statement.rs (L8-28)
```rust
/// Breakdown of fee charge and refund for a transaction.
/// The structure is:
///
/// - Net charge or refund (not in the statement)
///    - total charge: total_charge_gas_units, matches `gas_used` in the on-chain `TransactionInfo`.
///      This is the sum of the sub-items below. Notice that there's potential precision loss when
///      the conversion between internal and external gas units and between native token and gas
///      units, so it's possible that the numbers don't add up exactly. -- This number is the final
///      charge, while the break down is merely informational.
///        - gas charge for execution (CPU time): `execution_gas_units`
///        - gas charge for IO (storage random access): `io_gas_units`
///        - storage fee charge (storage space): `storage_fee_octas`, to be included in
///          `total_charge_gas_unit`, this number is converted to gas units according to the user
///          specified `gas_unit_price` on the transaction.
///    - storage deletion refund: `storage_fee_refund_octas`, this is not included in `gas_used` or
///      `total_charge_gas_units`, the net charge / refund is calculated by
///      `total_charge_gas_units` * `gas_unit_price` - `storage_fee_refund_octas`.
///
/// This is meant to emitted as a module event.
///
/// (keep this doc in sync with the `struct FeeStatement` in Move.)
```

**File:** aptos-move/block-executor/src/limit_processor.rs (L100-109)
```rust
        // When the accumulated execution and io gas of the committed txns exceeds
        // PER_BLOCK_GAS_LIMIT, early halt BlockSTM. Storage fee does not count towards
        // the per block gas limit, as we measure execution related cost here.
        let raw_gas_used = fee_statement.execution_gas_used()
            * self
                .block_gas_limit_type
                .execution_gas_effective_multiplier()
            + fee_statement.io_gas_used() * self.block_gas_limit_type.io_gas_effective_multiplier();
        self.accumulated_raw_block_gas += raw_gas_used;
        self.accumulated_effective_block_gas += conflict_multiplier * raw_gas_used;
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L22-22)
```rust
const GAS_SCALING_FACTOR: u64 = 1_000_000;
```

**File:** aptos-move/aptos-gas-meter/src/traits.rs (L251-263)
```rust
    /// Return the total gas used for execution.
    fn execution_gas_used(&self) -> Gas {
        self.algebra()
            .execution_gas_used()
            .to_unit_round_up_with_params(&self.vm_gas_params().txn)
    }

    /// Return the total gas used for io.
    fn io_gas_used(&self) -> Gas {
        self.algebra()
            .io_gas_used()
            .to_unit_round_up_with_params(&self.vm_gas_params().txn)
    }
```

**File:** third_party/move/move-core/types/src/gas_algebra.rs (L266-279)
```rust
fn apply_ratio_round_up(val: u64, nominator: u64, denominator: u64) -> u64 {
    assert_ne!(nominator, 0);
    assert_ne!(denominator, 0);

    let n = val as u128 * nominator as u128;
    let d = denominator as u128;

    let res = n / d + if n.is_multiple_of(d) { 0 } else { 1 };
    if res > u64::MAX as u128 {
        u64::MAX
    } else {
        res as u64
    }
}
```

**File:** aptos-move/block-executor/src/executor.rs (L2058-2073)
```rust
                    // Total gas unit here includes the storage fee (deposit), which is not
                    // available for distribution. Only the execution gas and IO gas are available
                    // to distribute. Note here we deliberately NOT use the execution gas and IO
                    // gas value from the fee statement, because they might round up during the
                    // calculation and the sum of them could be larger than the actual value we
                    // burn. Instead we use the total amount (which is the total we've burnt)
                    // minus the storage deposit (round up), to avoid over distribution.
                    // We burn a fix amount of gas per gas unit.
                    let gas_price_to_burn = self.config.onchain.gas_price_to_burn();
                    if gas_price > gas_price_to_burn {
                        let gas_unit_available_to_distribute = total_gas_unit
                            .saturating_sub(fee_statement.storage_fee_used().div_ceil(gas_price));
                        if gas_unit_available_to_distribute > 0 {
                            let fee_to_distribute =
                                gas_unit_available_to_distribute * (gas_price - gas_price_to_burn);
                            *amount.entry(proposer_index).or_insert(0) += fee_to_distribute;
```
