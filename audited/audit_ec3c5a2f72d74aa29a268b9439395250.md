# Audit Report

## Title
Integer Overflow in Gas Calculation Leads to Potential Consensus Divergence

## Summary
The gas cost calculation in the Rust transaction validation layer performs unchecked multiplication that can overflow when `gas_unit_price × max_gas_amount` exceeds `u64::MAX`. While current default gas parameters are safe, on-chain governance can update these parameters without overflow validation, potentially causing consensus divergence between debug and release builds or between Rust and Move validation layers.

## Finding Description

The vulnerability exists in multiple critical locations where gas costs are calculated through multiplication:

**Location 1: Rust VM Layer** [1](#0-0) 

The code performs unchecked multiplication on line 233: `let actual = gas_unit_price * max_gas_amount`. In Rust release mode, integer overflow causes silent wraparound rather than panicking. This calculation validates whether accounts have sufficient gas for account creation.

**Location 2: Move Prologue Layer** [2](#0-1) 

The Move prologue performs the same multiplication on line 188: `let max_transaction_fee = txn_gas_price * txn_max_gas_units`. However, Move aborts on integer overflow by default, creating a behavioral discrepancy with the Rust layer.

**Location 3: Move Epilogue Layer** [3](#0-2) 

The epilogue correctly guards against overflow by checking `(txn_gas_price as u128) * (gas_used as u128) <= MAX_U64` before multiplication, demonstrating awareness of the risk.

**Developer Acknowledgment** [4](#0-3) 

Line 53 explicitly documents: "MAXIMUM_NUMBER_OF_GAS_UNITS * MAX_PRICE_PER_GAS_UNIT < min(u64::MAX, GasUnits<GasCarrier>::MAX)" as a required invariant.

**Missing Validation in Governance** [5](#0-4) 

The gas schedule update functions (lines 48, 68, 75) contain `TODO(Gas): check if gas schedule is consistent` comments, confirming that overflow validation is missing when governance updates gas parameters.

**Attack Vector:**

1. Governance proposal updates gas schedule with parameters where `maximum_number_of_gas_units * max_price_per_gas_unit > u64::MAX`
2. Example: `maximum_number_of_gas_units = 2_000_000`, `max_price_per_gas_unit = 100_000_000_000` (10x current)
   - Product: 200,000,000,000,000,000 > 18,446,744,073,709,551,615 ❌ OVERFLOWS
3. Transactions submitted with maximum allowed gas parameters
4. **Rust layer (release build):** Multiplication wraps, producing incorrect small value, validation passes/fails incorrectly  
5. **Move prologue:** Multiplication aborts transaction
6. **Consensus divergence:** Validators disagree on transaction validity, violating deterministic execution

## Impact Explanation

**Severity: HIGH (up to $50,000)**

This qualifies as HIGH severity under "Significant protocol violations" because:

1. **Consensus Safety Violation:** Different execution paths (Rust vs Move, debug vs release) produce inconsistent results, breaking the "Deterministic Execution" invariant that all validators must produce identical state roots
2. **Chain Halt Risk:** If validators run different build configurations, they may disagree on block validity, preventing consensus
3. **State Inconsistency:** Incorrect gas validation could allow transactions that should fail or reject valid transactions

While not reaching CRITICAL severity (which requires proven fund loss or network partition), this represents a serious threat to protocol integrity that could escalate to CRITICAL if exploited during an epoch transition or coordinated with other attacks.

## Likelihood Explanation

**Likelihood: MEDIUM**

The vulnerability requires governance action but represents a realistic threat:

**Factors Increasing Likelihood:**
- Explicit TODO comments indicate developers are aware validation is missing
- Governance proposals undergo review, but mathematical overflow checks may not be obvious
- No automated validation prevents malicious or buggy proposals
- Historical precedent: governance mistakes have occurred on other blockchains (e.g., Compound COMP distribution bug)

**Factors Decreasing Likelihood:**
- Requires governance approval (multi-step process with voting)
- Current default values are safe (2M × 10B = 20 quadrillion < u64::MAX)
- Governance participants are generally trustworthy

**Realistic Scenario:** A well-intentioned governance proposal aims to increase gas price limits for high-priority transactions during network congestion, inadvertently setting `max_price_per_gas_unit` too high without validating the overflow constraint.

## Recommendation

**Immediate Fix:** Add overflow validation in gas schedule update functions:

```move
// In aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move

/// Validate gas schedule consistency (prevents overflow)
fun validate_gas_schedule_consistency(entries: &vector<GasEntry>) {
    // Extract critical parameters
    let max_gas_units_opt = find_gas_entry(entries, b"txn.maximum_number_of_gas_units");
    let max_price_opt = find_gas_entry(entries, b"txn.max_price_per_gas_unit");
    
    if (option::is_some(&max_gas_units_opt) && option::is_some(&max_price_opt)) {
        let max_gas_units = *option::borrow(&max_gas_units_opt);
        let max_price = *option::borrow(&max_price_opt);
        
        // Check: max_gas_units * max_price < u64::MAX
        // Use u128 to prevent overflow in check itself
        let product = (max_gas_units as u128) * (max_price as u128);
        let max_u64 = 18446744073709551615u128;
        
        assert!(product < max_u64, error::invalid_argument(EINVALID_GAS_SCHEDULE));
    }
}

// Call in set_gas_schedule, set_for_next_epoch, etc.:
validate_gas_schedule_consistency(&new_gas_schedule.entries);
```

**Secondary Fix:** Use checked multiplication in Rust code:

```rust
// In aptos-move/aptos-vm/src/gas.rs line 233
let actual = gas_unit_price.checked_mul(max_gas_amount)
    .ok_or_else(|| VMStatus::error(
        StatusCode::ARITHMETIC_ERROR,
        None,
    ))?;
```

**Tertiary Fix:** Add overflow check in Move prologue (line 188):

```move
// In transaction_validation.move
assert!(
    (txn_gas_price as u128) * (txn_max_gas_units as u128) <= MAX_U64,
    error::out_of_range(PROLOGUE_ECANT_PAY_GAS_DEPOSIT)
);
let max_transaction_fee = txn_gas_price * txn_max_gas_units;
```

## Proof of Concept

```move
#[test_only]
module aptos_framework::gas_overflow_test {
    use aptos_framework::gas_schedule;
    use std::vector;
    
    #[test(framework = @aptos_framework)]
    #[expected_failure] // Should fail but currently doesn't validate
    fun test_governance_gas_overflow(framework: &signer) {
        // Simulate governance proposal with overflow-causing values
        let entries = vector::empty();
        
        // Set maximum_number_of_gas_units = 2,000,000
        vector::push_back(&mut entries, gas_schedule::GasEntry {
            key: string::utf8(b"txn.maximum_number_of_gas_units"),
            val: 2000000,
        });
        
        // Set max_price_per_gas_unit = 100,000,000,000 (10x too high)
        // Product: 2M * 100B = 200 quadrillion > u64::MAX ❌
        vector::push_back(&mut entries, gas_schedule::GasEntry {
            key: string::utf8(b"txn.max_price_per_gas_unit"),
            val: 100000000000,
        });
        
        let schedule = gas_schedule::GasScheduleV2 {
            feature_version: 1,
            entries,
        };
        
        let schedule_bytes = bcs::to_bytes(&schedule);
        
        // This should FAIL with overflow validation, but currently SUCCEEDS
        gas_schedule::set_for_next_epoch(framework, schedule_bytes);
        
        // Now submit a transaction with max values:
        // gas.rs line 233 will overflow: 2M * 100B wraps around
        // Move line 188 will abort
        // Consensus divergence!
    }
}
```

## Notes

The current default values (2M gas units × 10B price = 20 quadrillion) are within u64::MAX (~18.4 quintillion), so this is not immediately exploitable. However, the missing validation represents a critical gap in protocol safety that could be triggered by governance error or malicious proposal. The explicit developer comment acknowledging this invariant, combined with multiple TODO comments about missing validation, confirms this is a recognized but unaddressed security concern.

### Citations

**File:** aptos-move/aptos-vm/src/gas.rs (L213-247)
```rust
    let gas_unit_price: u64 = txn_metadata.gas_unit_price().into();
    if crate::aptos_vm::should_create_account_resource(
        txn_metadata,
        features,
        resolver,
        module_storage,
    )? && (gas_unit_price != 0 || !features.is_default_account_resource_enabled())
    {
        let max_gas_amount: u64 = txn_metadata.max_gas_amount().into();
        let pricing = DiskSpacePricing::new(gas_feature_version, features);
        let storage_fee_per_account_create: u64 = pricing
            .hack_estimated_fee_for_account_creation(txn_gas_params)
            .into();

        let expected = gas_unit_price * 10
            + if features.is_new_account_default_to_fa_store() {
                1
            } else {
                2
            } * storage_fee_per_account_create;
        let actual = gas_unit_price * max_gas_amount;
        if actual < expected {
            speculative_warn!(
                log_context,
                format!(
                    "[VM] Insufficient gas for account creation; min {}, submitted {}",
                    expected, actual,
                ),
            );
            return Err(VMStatus::error(
                StatusCode::MAX_GAS_UNITS_BELOW_MIN_TRANSACTION_GAS_UNITS,
                None,
            ));
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/transaction_validation.move (L187-213)
```text
        // Check if the gas payer has enough balance to pay for the transaction
        let max_transaction_fee = txn_gas_price * txn_max_gas_units;
        if (!skip_gas_payment(
            is_simulation,
            gas_payer_address
        )) {
            assert!(
                permissioned_signer::check_permission_capacity_above(
                    gas_payer,
                    (max_transaction_fee as u256),
                    GasPermission {}
                ),
                error::permission_denied(PROLOGUE_PERMISSIONED_GAS_LIMIT_INSUFFICIENT)
            );
            if (features::operations_default_to_fa_apt_store_enabled()) {
                assert!(
                    aptos_account::is_fungible_balance_at_least(gas_payer_address, max_transaction_fee),
                    error::invalid_argument(PROLOGUE_ECANT_PAY_GAS_DEPOSIT)
                );
            } else {
                assert!(
                    coin::is_balance_at_least<AptosCoin>(gas_payer_address, max_transaction_fee),
                    error::invalid_argument(PROLOGUE_ECANT_PAY_GAS_DEPOSIT)
                );
            }
        };
    }
```

**File:** aptos-move/framework/aptos-framework/sources/transaction_validation.move (L596-604)
```text
        assert!(txn_max_gas_units >= gas_units_remaining, error::invalid_argument(EOUT_OF_GAS));
        let gas_used = txn_max_gas_units - gas_units_remaining;

        assert!(
            (txn_gas_price as u128) * (gas_used as u128) <= MAX_U64,
            error::out_of_range(EOUT_OF_GAS)
        );
        let transaction_fee_amount = txn_gas_price * gas_used;

```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L50-71)
```rust
        // ~5 microseconds should equal one unit of computational gas. We bound the maximum
        // computational time of any given transaction at roughly 20 seconds. We want this number and
        // `MAX_PRICE_PER_GAS_UNIT` to always satisfy the inequality that
        // MAXIMUM_NUMBER_OF_GAS_UNITS * MAX_PRICE_PER_GAS_UNIT < min(u64::MAX, GasUnits<GasCarrier>::MAX)
        [
            maximum_number_of_gas_units: Gas,
            "maximum_number_of_gas_units",
            aptos_global_constants::MAX_GAS_AMOUNT
        ],
        // The minimum gas price that a transaction can be submitted with.
        // TODO(Gas): should probably change this to something > 0
        [
            min_price_per_gas_unit: FeePerGasUnit,
            "min_price_per_gas_unit",
            aptos_global_constants::GAS_UNIT_PRICE
        ],
        // The maximum gas unit price that a transaction can be submitted with.
        [
            max_price_per_gas_unit: FeePerGasUnit,
            "max_price_per_gas_unit",
            10_000_000_000
        ],
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L43-81)
```text
    public(friend) fun initialize(aptos_framework: &signer, gas_schedule_blob: vector<u8>) {
        system_addresses::assert_aptos_framework(aptos_framework);
        assert!(!vector::is_empty(&gas_schedule_blob), error::invalid_argument(EINVALID_GAS_SCHEDULE));

        // TODO(Gas): check if gas schedule is consistent
        let gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
        move_to<GasScheduleV2>(aptos_framework, gas_schedule);
    }

    /// Deprecated by `set_for_next_epoch()`.
    ///
    /// WARNING: calling this while randomness is enabled will trigger a new epoch without randomness!
    ///
    /// TODO: update all the tests that reference this function, then disable this function.
    public fun set_gas_schedule(aptos_framework: &signer, gas_schedule_blob: vector<u8>) acquires GasSchedule, GasScheduleV2 {
        system_addresses::assert_aptos_framework(aptos_framework);
        assert!(!vector::is_empty(&gas_schedule_blob), error::invalid_argument(EINVALID_GAS_SCHEDULE));
        chain_status::assert_genesis();

        if (exists<GasScheduleV2>(@aptos_framework)) {
            let gas_schedule = borrow_global_mut<GasScheduleV2>(@aptos_framework);
            let new_gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
            assert!(new_gas_schedule.feature_version >= gas_schedule.feature_version,
                error::invalid_argument(EINVALID_GAS_FEATURE_VERSION));
            // TODO(Gas): check if gas schedule is consistent
            *gas_schedule = new_gas_schedule;
        }
        else {
            if (exists<GasSchedule>(@aptos_framework)) {
                _ = move_from<GasSchedule>(@aptos_framework);
            };
            let new_gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
            // TODO(Gas): check if gas schedule is consistent
            move_to<GasScheduleV2>(aptos_framework, new_gas_schedule);
        };

        // Need to trigger reconfiguration so validator nodes can sync on the updated gas schedule.
        reconfiguration::reconfigure();
    }
```
