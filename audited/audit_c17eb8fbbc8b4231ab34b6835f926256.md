# Audit Report

## Title
Circular Package Dependencies Can Be Published On-Chain When Lazy Loading Is Enabled, Violating DAG Invariant and Causing State Inconsistency

## Summary
When the lazy loading feature is enabled, the Move package publishing mechanism fails to detect circular dependencies, allowing packages with cyclic dependency graphs to be published on-chain. This violates the documented invariant that module dependencies must form a Directed Acyclic Graph (DAG) and creates a state inconsistency where modules are valid under lazy loading but would fail verification under eager loading. [1](#0-0) 

## Finding Description

The `check_dependencies` function in the Move framework only performs single-level dependency validation, checking that each direct dependency exists and has an appropriate upgrade policy, but does not recursively traverse the dependency graph to detect cycles. [2](#0-1) 

During module publishing with lazy loading enabled, cycle detection is explicitly skipped. The code comment states: "Linking checks to immediate dependencies. Note that we do not check cyclic dependencies here." [3](#0-2) 

The lazy verification path calls `build_verified_module_skip_linking_checks`, which bypasses the dependency cycle checks that would normally be performed.

In contrast, when lazy loading is disabled, the eager verification explicitly detects and rejects circular dependencies: [4](#0-3) 

This creates a critical inconsistency: modules with circular dependencies can be published when lazy loading is enabled, but would fail verification if lazy loading is disabled.

**Attack Path:**
1. Attacker waits for lazy loading feature to be enabled via governance (Feature Flag #95)
2. Attacker publishes Package A at address 0xA that depends on Package B at address 0xB  
3. Attacker publishes Package B at address 0xB that depends on Package A at address 0xA (creating a cycle)
4. Both packages are accepted on-chain because cycle detection is skipped
5. If lazy loading is later disabled, these modules become invalid but remain on-chain
6. Any validator attempting eager verification of these modules will encounter errors [5](#0-4) 

The code documentation explicitly states: "If dependencies form a cycle (which should not be the case as we check this when modules are added to the module cache), an error is returned." This assumption is violated when lazy loading is enabled.

## Impact Explanation

This vulnerability constitutes a **High Severity** issue under the Aptos bug bounty criteria as a "Significant protocol violation." Specifically:

1. **Invariant Violation**: The system assumes dependency graphs form DAGs, as documented in the eager verification code. Circular dependencies violate this fundamental assumption.

2. **State Inconsistency**: Modules become valid or invalid depending on the lazy loading feature flag state, creating non-deterministic behavior across the network.

3. **Consensus Risk**: During feature flag transitions (enabling/disabling lazy loading), validators could disagree on module validity, potentially causing consensus issues.

4. **Upgrade Disruption**: Future protocol upgrades that require eager verification would fail when encountering these circular dependencies, requiring manual intervention or a hard fork to resolve.

## Likelihood Explanation

**Likelihood: Medium-High**

- The lazy loading feature (Feature Flag #95) can be enabled via on-chain governance
- Any user can publish packages without special privileges  
- The attack requires only two package publication transactions
- The circular dependencies are permanent once on-chain
- Feature flags can be toggled by governance, triggering the inconsistency

The attack is straightforward and does not require validator cooperation or complex timing.

## Recommendation

Add cycle detection to the lazy loading verification path. Modify the `StagingModuleStorage::create_with_compat_config` function to detect cycles even when lazy loading is enabled:

**Option 1:** Add explicit cycle detection during lazy verification by tracking visited modules across the bundle.

**Option 2:** Enhance `check_dependencies` in code.move to recursively validate the dependency graph:

```move
// In code.move, modify check_dependencies to detect cycles
fun check_dependencies(publish_address: address, pack: &PackageMetadata): vector<AllowedDep>
acquires PackageRegistry {
    let allowed_module_deps = vector::empty();
    let deps = &pack.deps;
    let visited = vector::empty<PackageDep>(); // Track visited packages
    
    // Recursively check dependencies for cycles
    check_dependencies_recursive(publish_address, pack, &mut visited, &mut allowed_module_deps);
    
    allowed_module_deps
}

fun check_dependencies_recursive(
    publish_address: address,
    pack: &PackageMetadata, 
    visited: &mut vector<PackageDep>,
    allowed_module_deps: &mut vector<AllowedDep>
) acquires PackageRegistry {
    vector::for_each_ref(&pack.deps, |dep| {
        let dep: &PackageDep = dep;
        
        // Check for cycle
        assert!(
            !vector::contains(visited, dep),
            error::invalid_argument(EDEP_CYCLE_DETECTED)
        );
        
        vector::push_back(visited, *dep);
        
        // ... existing dependency validation ...
        
        // Recursively check dependencies of this dependency
        if (exists<PackageRegistry>(dep.account)) {
            let registry = borrow_global<PackageRegistry>(dep.account);
            // Find and recursively check the dependency package
        }
        
        vector::pop_back(visited);
    });
}
```

## Proof of Concept

```move
#[test_only]
module 0xA::PackageA {
    use 0xB::PackageB; // Depends on B
    
    public fun use_b() {
        PackageB::some_function();
    }
}

#[test_only]  
module 0xB::PackageB {
    use 0xA::PackageA; // Depends on A - creates cycle!
    
    public fun use_a() {
        PackageA::use_b();
    }
}

#[test]
fun test_circular_dependency_with_lazy_loading() {
    // 1. Enable lazy loading feature flag
    features::change_feature_flags(
        &aptos_framework_account,
        vector[features::get_lazy_loading_feature()],
        vector[]
    );
    
    // 2. Publish PackageA (depends on PackageB, but B doesn't exist yet)
    // This would normally fail, so publish a version without the dependency first
    publish_package(&account_a, package_a_metadata_v1, package_a_code_v1);
    
    // 3. Publish PackageB (depends on PackageA v1, which doesn't depend on B yet)  
    publish_package(&account_b, package_b_metadata, package_b_code);
    
    // 4. Upgrade PackageA to depend on PackageB (creates the cycle)
    publish_package(&account_a, package_a_metadata_v2, package_a_code_v2);
    
    // Both packages are now on-chain with circular dependencies!
    
    // 5. Disable lazy loading
    features::change_feature_flags(
        &aptos_framework_account,
        vector[],
        vector[features::get_lazy_loading_feature()]
    );
    
    // 6. Attempt to eagerly verify PackageA - this will FAIL
    // because eager verification detects the cycle
    // This creates state inconsistency!
}
```

**Notes:**

The vulnerability allows violation of a critical system invariant (DAG dependency structure). While runtime execution is protected by `TraversalContext` from infinite loops, the ability to publish invalid dependency structures creates state inconsistency and could cause validator disagreements during feature flag transitions or protocol upgrades. This represents a significant protocol violation requiring governance intervention to remediate.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/code.move (L298-344)
```text
    fun check_dependencies(publish_address: address, pack: &PackageMetadata): vector<AllowedDep>
    acquires PackageRegistry {
        let allowed_module_deps = vector::empty();
        let deps = &pack.deps;
        vector::for_each_ref(deps, |dep| {
            let dep: &PackageDep = dep;
            assert!(exists<PackageRegistry>(dep.account), error::not_found(EPACKAGE_DEP_MISSING));
            if (is_policy_exempted_address(dep.account)) {
                // Allow all modules from this address, by using "" as a wildcard in the AllowedDep
                let account: address = dep.account;
                let module_name = string::utf8(b"");
                vector::push_back(&mut allowed_module_deps, AllowedDep { account, module_name });
            } else {
                let registry = borrow_global<PackageRegistry>(dep.account);
                let found = vector::any(&registry.packages, |dep_pack| {
                    let dep_pack: &PackageMetadata = dep_pack;
                    if (dep_pack.name == dep.package_name) {
                        // Check policy
                        assert!(
                            dep_pack.upgrade_policy.policy >= pack.upgrade_policy.policy,
                            error::invalid_argument(EDEP_WEAKER_POLICY)
                        );
                        if (dep_pack.upgrade_policy == upgrade_policy_arbitrary()) {
                            assert!(
                                dep.account == publish_address,
                                error::invalid_argument(EDEP_ARBITRARY_NOT_SAME_ADDRESS)
                            )
                        };
                        // Add allowed deps
                        let account = dep.account;
                        let k = 0;
                        let r = vector::length(&dep_pack.modules);
                        while (k < r) {
                            let module_name = vector::borrow(&dep_pack.modules, k).name;
                            vector::push_back(&mut allowed_module_deps, AllowedDep { account, module_name });
                            k = k + 1;
                        };
                        true
                    } else {
                        false
                    }
                });
                assert!(found, error::not_found(EPACKAGE_DEP_MISSING));
            };
        });
        allowed_module_deps
    }
```

**File:** third_party/move/move-vm/runtime/src/storage/publishing.rs (L259-260)
```rust
                // Linking checks to immediate dependencies. Note that we do not check cyclic
                // dependencies here.
```

**File:** third_party/move/move-vm/runtime/src/storage/module_storage.rs (L295-329)
```rust
    fn unmetered_get_lazily_verified_module(
        &self,
        module_id: &ModuleId,
    ) -> VMResult<Option<Arc<Module>>> {
        let (module, version) = match self.get_module_or_build_with(module_id, self)? {
            Some(module_and_version) => module_and_version,
            None => return Ok(None),
        };

        if module.code().is_verified() {
            return Ok(Some(module.code().verified().clone()));
        }

        let _timer = VM_TIMER.timer_with_label("unmetered_get_lazily_verified_module [cache miss]");
        let runtime_environment = self.runtime_environment();
        runtime_environment.paranoid_check_module_address_and_name(
            module.code().deserialized(),
            module_id.address(),
            module_id.name(),
        )?;
        let locally_verified_code = runtime_environment.build_locally_verified_module(
            module.code().deserialized().clone(),
            module.extension().size_in_bytes(),
            module.extension().hash(),
        )?;
        let verified_code =
            runtime_environment.build_verified_module_skip_linking_checks(locally_verified_code)?;
        let verified_module = self.insert_verified_module(
            module_id.clone(),
            verified_code,
            module.extension().clone(),
            version,
        )?;
        Ok(Some(verified_module.code().verified().clone()))
    }
```

**File:** third_party/move/move-vm/runtime/src/storage/module_storage.rs (L332-344)
```rust
/// Visits the dependencies of the given module. If dependencies form a cycle (which should not be
/// the case as we check this when modules are added to the module cache), an error is returned.
///
/// Note:
///   This implementation **does not** load transitive friends. While it is possible to view
///   friends as `used-by` relation, it cannot be checked fully. For example, consider the case
///   when we have four modules A, B, C, D and let `X --> Y` be a dependency relation (Y is a
///   dependency of X) and `X ==> Y ` a friend relation (X declares Y a friend). Then consider the
///   case `A --> B <== C --> D <== A`. Here, if we opt for `used-by` semantics, there is a cycle.
///   But it cannot be checked, since, A only sees B and D, and C sees B and D, but both B and D do
///   not see any dependencies or friends. Hence, A cannot discover C and vice-versa, making
///   detection of such corner cases only possible if **all existing modules are checked**, which
///   is clearly infeasible.
```

**File:** third_party/move/move-vm/runtime/src/storage/module_storage.rs (L399-415)
```rust
        if visited.insert(dependency_id.clone()) {
            // Dependency is not verified, and we have not visited it yet.
            let verified_dependency = visit_dependencies_and_verify(
                dependency_id.clone(),
                dependency,
                dependency_version,
                visited,
                module_cache_with_context,
            )?;
            verified_dependencies.push(verified_dependency);
        } else {
            // We must have found a cycle otherwise.
            return Err(module_cyclic_dependency_error!(
                dependency_id.address(),
                dependency_id.name()
            ));
        }
```
