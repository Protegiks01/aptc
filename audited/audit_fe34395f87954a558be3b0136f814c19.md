# Audit Report

## Title
Secp256k1 ECDSA Signature Malleability Bypasses Transaction Deduplication in Consensus

## Summary
The secp256k1 ECDSA signature implementation allows non-canonical (high-s) signatures to be deserialized without normalization, enabling attackers to create multiple distinct representations of the same transaction that bypass the consensus transaction deduplication mechanism. This allows resource exhaustion attacks on validator nodes.

## Finding Description

The transaction deduplication mechanism in consensus uses the tuple `(transaction_hash, authenticator)` to filter duplicate transactions before signature verification. However, secp256k1 ECDSA signatures do not enforce canonical encoding during deserialization, allowing signature malleability attacks. [1](#0-0) 

The deduplication occurs before signature verification: [2](#0-1) 

The vulnerability exists because secp256k1 signatures accept both canonical (low-s) and non-canonical (high-s) encodings during deserialization without normalization: [3](#0-2) 

The malleability check only occurs during verification, not deserialization: [4](#0-3) 

Since the `Hash` and `PartialEq` implementations use the raw bytes from `to_bytes()`, which preserves the non-canonical encoding: [5](#0-4) 

An attacker can:
1. Create a legitimate transaction with canonical signature (low-s)
2. Create a malleable version by negating s to produce high-s
3. Both transactions have the same hash but different authenticator hashes
4. Both bypass deduplication and enter consensus processing
5. The high-s version fails verification, but consensus resources are already consumed

This is confirmed by the malleability test showing high-s signatures can be deserialized but fail verification: [6](#0-5) 

**Contrast with secp256r1**: The secp256r1 implementation correctly rejects non-canonical signatures during deserialization, preventing this attack: [7](#0-6) 

## Impact Explanation

This vulnerability allows a **Medium Severity** DoS attack on consensus validators:

- **Resource Exhaustion**: Attackers can submit malleable transaction variants that bypass deduplication, forcing validators to process duplicate transactions through expensive cryptographic operations (hashing, signature verification)
- **Consensus Performance Degradation**: Each malleable variant consumes CPU cycles in the consensus pipeline before failing verification
- **Network Bandwidth Waste**: Duplicate transactions propagate through the P2P network and mempool

The impact is Medium rather than Critical/High because:
- No funds are lost or stolen
- No consensus safety violations occur (both versions fail for the same sender/sequence number during execution)
- Attack requires active participation (sending transactions)
- Mitigations exist (rate limiting, gas fees)

However, coordinated attacks submitting many malleable variants could significantly degrade validator performance.

## Likelihood Explanation

**High Likelihood**:
- Exploitation requires only the ability to submit transactions (available to any user)
- The attack is straightforward: flip the s component of a secp256k1 signature
- No special permissions or validator access needed
- Secp256k1 is a supported signature scheme in `AnySignature`: [8](#0-7) 

## Recommendation

**Fix**: Enforce canonical signature encoding during deserialization by rejecting high-s signatures in the `TryFrom<&[u8]>` implementation, matching the secp256r1 approach.

**Recommended Code Change** in `crates/aptos-crypto/src/secp256k1_ecdsa.rs`:

```rust
impl TryFrom<&[u8]> for Signature {
    type Error = CryptoMaterialError;

    fn try_from(bytes: &[u8]) -> std::result::Result<Signature, CryptoMaterialError> {
        let signature = match libsecp256k1::Signature::parse_standard_slice(bytes) {
            Ok(signature) => Signature(signature),
            Err(_) => return Err(CryptoMaterialError::DeserializationError),
        };
        
        // Reject non-canonical (high-s) signatures to prevent malleability
        if signature.0.s.is_high() {
            return Err(CryptoMaterialError::CanonicalRepresentationError);
        }
        
        Ok(signature)
    }
}
```

This ensures that only canonical signatures are accepted, preventing multiple encodings of the same signature from bypassing deduplication.

## Proof of Concept

```rust
#[test]
fn test_secp256k1_malleability_bypasses_deduplication() {
    use aptos_crypto::{secp256k1_ecdsa, SigningKey, Uniform};
    use std::collections::HashSet;
    
    let mut rng = rand::rngs::OsRng;
    let message = b"Test transaction";
    let key_pair = aptos_crypto::test_utils::KeyPair::<
        secp256k1_ecdsa::PrivateKey,
        secp256k1_ecdsa::PublicKey,
    >::generate(&mut rng);
    
    // Create canonical signature
    let canonical_sig = key_pair.private_key.sign_arbitrary_message(message);
    let canonical_bytes = canonical_sig.to_bytes();
    
    // Create malleable high-s signature
    let mut malleable_sig = canonical_sig.clone();
    malleable_sig.0.s = -malleable_sig.0.s;
    let malleable_bytes = malleable_sig.to_bytes();
    
    // Both deserialize successfully (VULNERABILITY)
    let canonical_deserialized = secp256k1_ecdsa::Signature::try_from(&canonical_bytes[..]).unwrap();
    let malleable_deserialized = secp256k1_ecdsa::Signature::try_from(&malleable_bytes[..]).unwrap();
    
    // Signatures hash to different values (bypassing deduplication)
    let mut canonical_hash = std::collections::hash_map::DefaultHasher::new();
    let mut malleable_hash = std::collections::hash_map::DefaultHasher::new();
    
    use std::hash::{Hash, Hasher};
    canonical_deserialized.hash(&mut canonical_hash);
    malleable_deserialized.hash(&mut malleable_hash);
    
    assert_ne!(canonical_hash.finish(), malleable_hash.finish(), 
               "Malleable signatures produce different hashes - deduplication bypassed!");
    
    // Only canonical signature verifies
    assert!(canonical_deserialized.verify_arbitrary_msg(message, &key_pair.public_key).is_ok());
    assert!(malleable_deserialized.verify_arbitrary_msg(message, &key_pair.public_key).is_err());
    
    println!("VULNERABILITY CONFIRMED:");
    println!("- Both signatures deserialize successfully");
    println!("- They hash to different values (bypass deduplication)");
    println!("- Only canonical signature verifies (malleable wastes resources)");
}
```

**Notes**
- The original security question referenced `bench_utils.rs` and compressed deserialization for BLS/arkworks, but the actual vulnerability exists in secp256k1 transaction authentication signatures
- Ed25519 and secp256r1 are NOT vulnerable as they enforce canonical encoding during deserialization
- BLS signatures used in validator consensus (not transaction authentication) rely on subgroup checking rather than canonical form validation

### Citations

**File:** consensus/src/txn_hash_and_authenticator_deduper.rs (L14-17)
```rust
/// (raw_txn.hash(), authenticator). Both the hash and signature are required because dedup
/// happens before signatures are verified and transaction prologue is checked. (So, e.g., a bad
/// transaction could contain a txn and signature that are unrelated.) If the checks are done
/// beforehand only one of the txn hash or signature would be required.
```

**File:** consensus/src/txn_hash_and_authenticator_deduper.rs (L63-72)
```rust
        let hash_and_authenticators: Vec<_> = possible_duplicates
            .into_par_iter()
            .zip(&transactions)
            .with_min_len(optimal_min_len(num_txns, 48))
            .map(|(need_hash, txn)| match need_hash {
                true => Some((txn.committed_hash(), txn.authenticator())),
                false => None,
            })
            .collect();

```

**File:** crates/aptos-crypto/src/secp256k1_ecdsa.rs (L209-223)
```rust
    fn verify(
        &self,
        message: &libsecp256k1::Message,
        public_key: &libsecp256k1::PublicKey,
    ) -> Result<()> {
        // Prevent malleability attacks, low order only. The library only signs in low
        // order, so this was done intentionally.
        if self.0.s.is_high() {
            Err(anyhow!(CryptoMaterialError::CanonicalRepresentationError))
        } else if libsecp256k1::verify(message, &self.0, public_key) {
            Ok(())
        } else {
            Err(anyhow!("Unable to verify signature."))
        }
    }
```

**File:** crates/aptos-crypto/src/secp256k1_ecdsa.rs (L234-243)
```rust
impl TryFrom<&[u8]> for Signature {
    type Error = CryptoMaterialError;

    fn try_from(bytes: &[u8]) -> std::result::Result<Signature, CryptoMaterialError> {
        match libsecp256k1::Signature::parse_standard_slice(bytes) {
            Ok(signature) => Ok(Signature(signature)),
            Err(_) => Err(CryptoMaterialError::DeserializationError),
        }
    }
}
```

**File:** crates/aptos-crypto/src/secp256k1_ecdsa.rs (L257-261)
```rust
impl std::hash::Hash for Signature {
    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
        state.write(&self.to_bytes());
    }
}
```

**File:** crates/aptos-crypto/src/unit_tests/secp256k1_ecdsa_test.rs (L98-112)
```rust
    let mut high_signature = signature.clone();
    high_signature.0.s = -high_signature.0.s;
    let high_signature_bytes = high_signature.to_bytes();

    // We can load
    secp256k1_ecdsa::Signature::try_from(&high_signature_bytes[..]).unwrap();

    // Ensure this is now high.
    assert!(!signature.0.s.is_high());
    assert!(high_signature.0.s.is_high());
    assert!(high_signature.0.s != signature.0.s);
    high_signature
        .verify_arbitrary_msg(message, &key_pair.public_key)
        .unwrap_err();
}
```

**File:** crates/aptos-crypto/src/secp256r1_ecdsa/secp256r1_ecdsa_sigs.rs (L169-176)
```rust
impl TryFrom<&[u8]> for Signature {
    type Error = CryptoMaterialError;

    fn try_from(bytes: &[u8]) -> std::result::Result<Signature, CryptoMaterialError> {
        Signature::check_s_malleability(bytes)?;
        Signature::from_bytes_unchecked(bytes)
    }
}
```

**File:** types/src/transaction/authenticator.rs (L1235-1253)
```rust
#[derive(Clone, Debug, Eq, PartialEq, Hash, Serialize, Deserialize)]
#[allow(non_camel_case_types)]
pub enum AnySignature {
    Ed25519 {
        signature: Ed25519Signature,
    },
    Secp256k1Ecdsa {
        signature: secp256k1_ecdsa::Signature,
    },
    WebAuthn {
        signature: PartialAuthenticatorAssertionResponse,
    },
    Keyless {
        signature: KeylessSignature,
    },
    SlhDsa_Sha2_128s {
        signature: Box<slh_dsa_sha2_128s::Signature>,
    },
}
```
