# Audit Report

## Title
Insecure File Permissions on Validator Private Keys in Genesis Builder - World-Readable Cryptographic Material

## Summary
The `write_yaml()` function in the genesis builder creates validator identity files containing highly sensitive private keys (Ed25519, BLS12-381, x25519) with default file permissions, making them world-readable on Unix systems. This exposes validator private keys to any local user with shell access, enabling account takeover and consensus participation impersonation.

## Finding Description

The genesis builder writes four critical identity files when initializing a validator node: [1](#0-0) 

These files contain highly sensitive cryptographic material defined in the `PrivateIdentity` structure: [2](#0-1) 

The vulnerability exists in the `write_yaml()` function which uses `File::create()` without setting restrictive file permissions: [3](#0-2) 

On Unix systems, `File::create()` creates files with default permissions based on the process umask (typically resulting in 0644 or 0666 permissions), making the files world-readable or group-readable. This violates the principle of least privilege for cryptographic key material.

The Aptos codebase already implements secure file writing utilities that set 0600 permissions: [4](#0-3) 

The CLI genesis key generation correctly uses this secure function: [5](#0-4) 

However, the genesis builder in `aptos-genesis/src/builder.rs` does not use these secure utilities, creating a security gap.

**Attack Scenario:**
1. Developer runs `aptos node run-localnet` or uses the genesis builder on a shared development server, cloud instance, or CI/CD environment
2. The builder creates validator identity files with world-readable permissions (0644)
3. Attacker with local shell access (different user account) executes: `cat /path/to/testnet/0/private-identity.yaml`
4. Attacker extracts:
   - **Ed25519 private key**: Full control over validator account, can submit transactions, drain funds
   - **BLS12-381 private key**: Can participate in consensus as that validator, sign blocks, potentially double-sign to violate consensus safety
   - **x25519 network keys**: Can impersonate validator in P2P network communications, intercept/modify messages

**Which Invariant Is Broken:**
This breaks **Invariant #10: Cryptographic Correctness** - the security of BLS signatures, network encryption, and account control depends on private key confidentiality. Once keys are exposed, all cryptographic guarantees are void.

## Impact Explanation

**Severity: High** (per Aptos Bug Bounty criteria - up to $50,000)

This vulnerability enables:

1. **Validator Account Compromise**: The Ed25519 private key grants full control over the validator account, allowing the attacker to:
   - Submit arbitrary transactions as the validator
   - Transfer funds out of the validator's account
   - Modify staking configurations

2. **Consensus Participation**: The BLS12-381 consensus private key allows the attacker to:
   - Sign blocks and votes as the compromised validator
   - Participate in consensus under the validator's identity
   - Potentially cause consensus safety violations through equivocation

3. **Network Impersonation**: The x25519 network private keys enable:
   - Man-in-the-middle attacks on validator communications
   - Network partitioning attacks
   - Information disclosure of consensus messages

While primarily affecting development/testnet environments, the impact extends to:
- **Shared Development Servers**: University labs, company development machines
- **Cloud Development Environments**: AWS WorkSpaces, Google Cloud Shell, Azure DevBox
- **CI/CD Pipelines**: Where multiple build jobs run under different users
- **Container Environments**: Where filesystem access may cross container boundaries
- **Testnets**: Compromise disrupts development and testing workflows

The vulnerability qualifies as **High Severity** under "Significant protocol violations" as it compromises the fundamental security of validator operations.

## Likelihood Explanation

**Likelihood: Medium to High**

This vulnerability is highly likely to occur in practice:

1. **Common Deployment Scenarios**: The genesis builder is used for:
   - Local development via `aptos node run-localnet`
   - Test mode via `aptos-node --test`
   - Forge testing framework
   - Custom testnet deployments

2. **Shared Environment Usage**: Developers frequently work on:
   - Shared development servers with multiple user accounts
   - Cloud-based development environments
   - CI/CD systems with multiple concurrent jobs
   - Academic/research environments with shared access

3. **Default Umask Settings**: Most Unix systems use umask 0022, resulting in files created with 0644 (world-readable) permissions by default.

4. **No User Awareness**: The genesis builder provides no warnings about file permissions, and developers may not realize the security implications of the generated files.

5. **Pattern Reuse**: Developers may copy the insecure `write_yaml()` pattern for production key generation, propagating the vulnerability.

## Recommendation

**Immediate Fix**: Replace `File::create()` with `write_to_user_only_file()` to ensure 0600 permissions on Unix systems.

**Modified `write_yaml()` function:**

```rust
fn write_yaml<T: Serialize>(path: &Path, object: &T) -> anyhow::Result<()> {
    // Use the secure file writing utility that sets 0600 permissions on Unix
    let bytes = serde_yaml::to_string(object)?.as_bytes().to_vec();
    
    #[cfg(unix)]
    {
        use std::fs::OpenOptions;
        use std::os::unix::fs::OpenOptionsExt;
        use std::io::Write;
        
        let mut opts = OpenOptions::new();
        opts.mode(0o600);
        let mut file = opts
            .write(true)
            .create(true)
            .truncate(true)
            .open(path)?;
        file.write_all(&bytes)?;
    }
    
    #[cfg(not(unix))]
    {
        use std::io::Write;
        let mut file = File::create(path)?;
        file.write_all(&bytes)?;
    }
    
    Ok(())
}
```

**Additional Fixes Required:**

1. Genesis blob file creation also needs fixing: [6](#0-5) 

2. Root key file creation in aptos-node: [7](#0-6) 

**Long-term Recommendations:**
- Add linting rules to detect `File::create()` usage for sensitive data
- Implement file permission verification tests
- Add warnings to documentation about file permissions in multi-user environments
- Consider encrypting private key files at rest

## Proof of Concept

**Step 1**: Create a test demonstrating the vulnerability (save as `test_file_permissions.rs`):

```rust
use std::fs::{self, File};
use std::io::Write;
use std::os::unix::fs::PermissionsExt;
use tempfile::TempDir;

#[test]
fn test_genesis_builder_file_permissions_vulnerability() {
    let temp_dir = TempDir::new().unwrap();
    let identity_file = temp_dir.path().join("validator-identity.yaml");
    
    // Simulate the vulnerable write_yaml() behavior
    let sensitive_data = "account_private_key: 0xDEADBEEF...";
    File::create(&identity_file)
        .unwrap()
        .write_all(sensitive_data.as_bytes())
        .unwrap();
    
    // Check permissions
    let metadata = fs::metadata(&identity_file).unwrap();
    let permissions = metadata.permissions();
    let mode = permissions.mode();
    
    println!("File permissions: {:o}", mode & 0o777);
    
    // On most Unix systems with default umask 0022, this will be 0644
    // which means world-readable!
    assert_eq!(
        mode & 0o777,
        0o644,
        "File is world-readable - VULNERABILITY CONFIRMED"
    );
}

#[test]
fn test_secure_file_writing() {
    use std::os::unix::fs::OpenOptionsExt;
    let temp_dir = TempDir::new().unwrap();
    let identity_file = temp_dir.path().join("secure-identity.yaml");
    
    // Secure implementation
    let sensitive_data = "account_private_key: 0xDEADBEEF...";
    let mut opts = fs::OpenOptions::new();
    opts.mode(0o600);
    opts.write(true)
        .create(true)
        .truncate(true)
        .open(&identity_file)
        .unwrap()
        .write_all(sensitive_data.as_bytes())
        .unwrap();
    
    // Verify permissions
    let metadata = fs::metadata(&identity_file).unwrap();
    let mode = metadata.permissions().mode();
    
    println!("Secure file permissions: {:o}", mode & 0o777);
    assert_eq!(mode & 0o777, 0o600, "File is properly restricted");
}
```

**Step 2**: Shell-based PoC demonstrating exploitation:

```bash
#!/bin/bash
# PoC: Demonstrate private key exposure in genesis builder

# Setup: Run as user 'developer'
sudo -u developer aptos node run-localnet --test-dir /tmp/testnet

# Wait for keys to be generated
sleep 5

# Attack: Run as different user 'attacker'
sudo -u attacker cat /tmp/testnet/0/private-identity.yaml
sudo -u attacker cat /tmp/testnet/0/validator-identity.yaml

# Output shows all private keys are readable!
# An attacker can now steal:
# - account_private_key (Ed25519)
# - consensus_private_key (BLS12-381)  
# - validator_network_private_key (x25519)
# - full_node_network_private_key (x25519)
```

**Expected Output**: The attacker successfully reads all private key material, confirming the vulnerability.

## Notes

This vulnerability affects the genesis builder module which, while primarily used for local development and testing, can have serious security implications:

1. **Scope of Impact**: Any deployment using the genesis builder on shared systems is vulnerable
2. **Similar Issues**: The `OnDiskStorage` in secure/storage also has this issue but explicitly warns against production use [8](#0-7) 
3. **Correct Implementation Available**: The codebase already has the proper pattern in the CLI tools, but it wasn't consistently applied to the genesis builder
4. **Defense in Depth**: Even for "test-only" code, proper file permissions are a fundamental security control that should not be omitted

### Citations

**File:** crates/aptos-genesis/src/builder.rs (L145-148)
```rust
            write_yaml(val_identity_file.as_path(), &validator_identity)?;
            write_yaml(vfn_identity_file.as_path(), &vfn_identity)?;
            write_yaml(private_identity_file.as_path(), &private_identity)?;
            write_yaml(public_identity_file.as_path(), &public_identity)?;
```

**File:** crates/aptos-genesis/src/builder.rs (L316-316)
```rust
        File::create(&genesis_file_location)?.write_all(&bcs::to_bytes(&genesis)?)?;
```

**File:** crates/aptos-genesis/src/builder.rs (L418-421)
```rust
fn write_yaml<T: Serialize>(path: &Path, object: &T) -> anyhow::Result<()> {
    File::create(path)?.write_all(serde_yaml::to_string(object)?.as_bytes())?;
    Ok(())
}
```

**File:** crates/aptos-genesis/src/keys.rs (L14-22)
```rust
/// Type for serializing private keys file
#[derive(Deserialize, Serialize)]
pub struct PrivateIdentity {
    pub account_address: AccountAddress,
    pub account_private_key: Ed25519PrivateKey,
    pub consensus_private_key: bls12381::PrivateKey,
    pub full_node_network_private_key: x25519::PrivateKey,
    pub validator_network_private_key: x25519::PrivateKey,
}
```

**File:** crates/aptos/src/common/utils.rs (L224-229)
```rust
pub fn write_to_user_only_file(path: &Path, name: &str, bytes: &[u8]) -> CliTypedResult<()> {
    let mut opts = OpenOptions::new();
    #[cfg(unix)]
    opts.mode(0o600);
    write_to_file_with_opts(path, name, bytes, &mut opts)
}
```

**File:** crates/aptos/src/genesis/keys.rs (L82-97)
```rust
        write_to_user_only_file(
            private_keys_file.as_path(),
            PRIVATE_KEYS_FILE,
            to_yaml(&private_identity)?.as_bytes(),
        )?;
        write_to_user_only_file(
            public_keys_file.as_path(),
            PUBLIC_KEYS_FILE,
            to_yaml(&public_identity)?.as_bytes(),
        )?;
        write_to_user_only_file(
            validator_file.as_path(),
            VALIDATOR_FILE,
            to_yaml(&validator_blob)?.as_bytes(),
        )?;
        write_to_user_only_file(vfn_file.as_path(), VFN_FILE, to_yaml(&vfn_blob)?.as_bytes())?;
```

**File:** aptos-node/src/lib.rs (L620-621)
```rust
    let mut key_file = fs::File::create(aptos_root_key_path)?;
    key_file.write_all(&serialized_keys)?;
```

**File:** secure/storage/src/on_disk.rs (L16-22)
```rust
/// OnDiskStorage represents a key value store that is persisted to the local filesystem and is
/// intended for single threads (or must be wrapped by a Arc<RwLock<>>). This provides no permission
/// checks and simply offers a proof of concept to unblock building of applications without more
/// complex data stores. Internally, it reads and writes all data to a file, which means that it
/// must make copies of all key material which violates the code base. It violates it because
/// the anticipation is that data stores would securely handle key material. This should not be used
/// in production.
```
