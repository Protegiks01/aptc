# Audit Report

## Title
Type Parameter Substitution Failure in Access Specifiers Causes Legitimate Access Denial for Generic Functions

## Summary
The Move VM fails to substitute type parameters in `ResourceInstantiation` access specifiers when generic functions are instantiated with concrete types. This causes all resource access attempts from generic functions to be incorrectly denied, breaking the intended semantics of Move's access control system and causing denial-of-service for any contract using generic functions with access specifiers.

## Finding Description

When a generic function is defined with access specifiers that reference type parameters (e.g., `fun foo<T>() reads Resource<T>`), the Move VM loader converts the type parameter `T` into `Type::TyParam(0)` and stores it in the access specifier's `ResourceInstantiation` variant. [1](#0-0) 

This `Type::TyParam` is stored directly in the access specifier without substitution: [2](#0-1) 

When the generic function is instantiated (e.g., `foo<u64>()`), a `LoadedFunction` is created with concrete type arguments, but the underlying `Function` structure containing the access specifier is shared via `Arc` and remains unmodified: [3](#0-2) 

When entering the function, the access specifier is specialized, but this only handles `AddressSpecifier::Eval` - it does NOT substitute type parameters in `ResourceSpecifier`: [4](#0-3) 

During access checking, when the VM attempts to access `Resource<u64>`, it creates an `AccessInstance` with concrete types: [5](#0-4) 

The access check then compares the unsubstituted `Type::TyParam(0)` in the access specifier against the concrete `Type::U64` in the access instance: [6](#0-5) 

Since `Type::TyParam(0) != Type::U64`, the match fails and access is denied, even though it should be allowed.

## Impact Explanation

This vulnerability qualifies as **High Severity** under the "Significant protocol violations" category. The Move VM's access control system is a core security feature, and its failure to correctly handle generic functions represents a fundamental protocol violation.

While this bug denies legitimate access rather than granting unintended access, it effectively causes denial-of-service for any smart contract that uses generic functions with access specifiers. Any transaction calling such functions will fail with `ACCESS_DENIED` errors, making these contracts unusable.

This violates the **Deterministic Execution** and **Move VM Safety** invariants, as correct code fails unexpectedly at runtime rather than at compile-time or verification.

## Likelihood Explanation

The likelihood is **Medium to High**. While there is currently no evidence of production Move code using generic functions with access specifiers (searches reveal no test cases for this pattern), the feature is syntactically valid and could be deployed by developers unaware of this bug.

The bug triggers automatically whenever:
1. A generic function with access specifiers is defined
2. The function is called with any concrete type arguments
3. The function attempts to access a resource matching its access specifier

No special attacker capabilities are required - any normal function call triggers the bug.

## Recommendation

Implement type parameter substitution for `ResourceSpecifier` during access specifier specialization. The `AccessSpecifierClause::specialize()` method should substitute type parameters in resource specifiers using the function's type arguments.

Add a new method to substitute types in `ResourceSpecifier`:

```rust
impl ResourceSpecifier {
    fn substitute(&mut self, ty_args: &[Type], ty_builder: &TyBuilder) -> PartialVMResult<()> {
        if let ResourceSpecifier::ResourceInstantiation(_, type_inst) = self {
            let mut substituted = Vec::with_capacity(type_inst.len());
            for ty in type_inst.iter() {
                substituted.push(ty_builder.create_ty_with_subst(ty, ty_args)?);
            }
            *type_inst = substituted;
        }
        Ok(())
    }
}
```

Then call this during function entry in `AccessControlState::enter_function()`, passing the function's type arguments from the `LoadedFunction`.

## Proof of Concept

```move
module 0x42::test {
    struct Resource<T> has key { value: T }
    
    // Generic function with access specifier
    public fun read_resource<T>() reads Resource<T>@0x42 acquires Resource {
        // This should be allowed but will fail with ACCESS_DENIED
        let _ = borrow_global<Resource<T>>(@0x42);
    }
    
    // Test calling the generic function
    public entry fun test() acquires Resource {
        // This call will fail with ACCESS_DENIED when it tries to
        // access Resource<u64>, because the access specifier contains
        // Type::TyParam(0) but the access check sees Type::U64
        read_resource<u64>();
    }
}
```

When `test()` is executed, the transaction will abort with `ACCESS_DENIED` error, even though the access specifier `reads Resource<T>@0x42` should permit reading `Resource<u64>@0x42` when `T=u64`.

**Notes**

This vulnerability exists at the intersection of two Move VM features: generic functions and access specifiers. The root cause is that access specifier loading happens during module loading (where type parameters are represented as `Type::TyParam`), but type substitution only occurs for function signatures, not for access specifiers. The `specialize()` method was designed to handle dynamic address evaluation but not type substitution, creating this gap in functionality.

### Citations

**File:** third_party/move/move-vm/runtime/src/loader/type_loader.rs (L69-69)
```rust
        SignatureToken::TypeParameter(idx) => (Type::TyParam(*idx), false),
```

**File:** third_party/move/move-vm/runtime/src/loader/access_specifier_loader.rs (L71-74)
```rust
        ResourceInstantiation(str_idx, ty_idx) => Ok(ResourceSpecifier::ResourceInstantiation(
            access_table(struct_names, str_idx.0)?.clone(),
            access_table(signature_table, ty_idx.0)?.clone(),
        )),
```

**File:** third_party/move/move-vm/runtime/src/frame.rs (L104-110)
```rust
                        FunctionHandle::Local(function) => {
                            (Ok(LoadedFunction {
                                owner: LoadedFunctionOwner::Module(module.clone()),
                                ty_args: verified_ty_args,
                                ty_args_id,
                                function: function.clone(),
                            }))
```

**File:** third_party/move/move-vm/types/src/loaded_data/runtime_access_specifier.rs (L198-201)
```rust
    fn specialize(&mut self, env: &impl AccessSpecifierEnv) -> PartialVMResult<()> {
        // Only addresses can be specialized right now.
        self.address.specialize(env)
    }
```

**File:** third_party/move/move-vm/types/src/loaded_data/runtime_access_specifier.rs (L213-215)
```rust
            ResourceInstantiation(enabled_struct_id, enabled_type_inst) => {
                enabled_struct_id == struct_id && enabled_type_inst == type_inst
            },
```

**File:** third_party/move/move-vm/runtime/src/interpreter.rs (L1412-1414)
```rust
        let (struct_idx, instance) = match ty {
            Type::Struct { idx, .. } => (*idx, [].as_slice()),
            Type::StructInstantiation { idx, ty_args, .. } => (*idx, ty_args.as_slice()),
```
