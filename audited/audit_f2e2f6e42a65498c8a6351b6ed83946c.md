# Audit Report

## Title
LedgerPrunerProgress Manipulation Causing Unintended Data Deletion During Pruner Initialization

## Summary
An attacker with direct database write access can manipulate the `LedgerPrunerProgress` metadata value to trigger unintended deletion of historical ledger data during node restart, causing permanent data loss and state inconsistencies.

## Finding Description
The `LedgerPrunerProgress` value stored in the database metadata tracks the version up to which ledger data has been pruned. During node initialization, this value is read from the database and used to initialize sub-pruners without validation. [1](#0-0) 

When a node restarts, the `LedgerPrunerManager` reads this progress value: [2](#0-1) 

The `LedgerPruner` then initializes each sub-pruner (TransactionPruner, EventStorePruner, etc.) with this `metadata_progress`: [3](#0-2) 

Each sub-pruner retrieves its own progress and attempts to "catch up" to the metadata progress: [4](#0-3) 

**Attack Scenario:**
1. Actual pruned version: 1000, Committed version: 10000
2. Attacker manipulates `DbMetadataKey::LedgerPrunerProgress` to 8000
3. On restart, each sub-pruner calls `prune(1000, 8000)`
4. The prune methods delete data without validation: [5](#0-4) 

This causes permanent deletion of transactions, events, and other ledger data from versions 1000-8000.

## Impact Explanation
This represents **Medium Severity** impact based on the bug bounty criteria:
- **State inconsistencies requiring intervention**: Historical data loss affects state sync, rollback capabilities, and historical queries
- However, this requires **database write access**, which is an insider threat scenario requiring:
  - Physical access to validator node
  - Root/admin filesystem permissions
  - Or complete node operator compromise

The impact is contained because:
- Network consensus is not broken (validators with correct data continue)
- Current state remains consistent
- Only historical data on the compromised node is affected

## Likelihood Explanation
**Likelihood: Low** - This attack requires privileged access beyond typical remote exploitation:
- Attacker needs direct filesystem access to RocksDB files
- This represents a compromised node operator or insider threat
- No remote exploitation vector exists
- Falls outside the typical "unprivileged attacker" threat model

## Recommendation
Implement validation during pruner initialization to detect metadata inconsistencies:

1. **Add metadata validation on startup**: Check that `LedgerPrunerProgress` is not higher than the first available data version
2. **Add integrity checks**: Before executing catch-up pruning, verify that data exists in the range to be pruned
3. **Add bounds checking**: Ensure metadata progress never exceeds committed version
4. **Add audit logging**: Log any metadata inconsistencies detected during initialization

Example validation in `LedgerMetadataPruner::new()`:
```rust
// After reading progress, validate against actual data
let mut iter = ledger_metadata_db.iter::<VersionDataSchema>()?;
iter.seek_to_first();
if let Some((first_version, _)) = iter.next().transpose()? {
    ensure!(
        progress <= first_version || progress == 0,
        "LedgerPrunerProgress ({}) is ahead of first available data ({}). Database may be corrupted.",
        progress, first_version
    );
}
```

## Proof of Concept
```rust
// This PoC demonstrates the vulnerability path (requires test environment)
use aptos_schemadb::DB;
use storage::schema::db_metadata::{DbMetadataKey, DbMetadataSchema, DbMetadataValue};

fn exploit_ledger_pruner_progress(db: &DB) -> Result<()> {
    // Attacker with DB write access manipulates progress
    let malicious_progress = 8000;
    db.put::<DbMetadataSchema>(
        &DbMetadataKey::LedgerPrunerProgress,
        &DbMetadataValue::Version(malicious_progress),
    )?;
    
    // On node restart, LedgerPruner::new() will read this value
    // Sub-pruners will call prune(actual_progress, malicious_progress)
    // Result: Unintended deletion of data from actual_progress to malicious_progress
    
    Ok(())
}
```

**Note:** This vulnerability requires **database write access** (privileged insider access), which falls outside the standard threat model for remote exploitation. This is a **defense-in-depth** issue rather than a remotely exploitable vulnerability.

### Citations

**File:** storage/aptosdb/src/schema/db_metadata/mod.rs (L50-50)
```rust
    LedgerPrunerProgress,
```

**File:** storage/aptosdb/src/pruner/ledger_pruner/ledger_pruner_manager.rs (L123-124)
```rust
        let min_readable_version =
            pruner_utils::get_ledger_pruner_progress(&ledger_db).expect("Must succeed.");
```

**File:** storage/aptosdb/src/pruner/ledger_pruner/mod.rs (L129-170)
```rust
        let metadata_progress = ledger_metadata_pruner.progress()?;

        info!(
            metadata_progress = metadata_progress,
            "Created ledger metadata pruner, start catching up all sub pruners."
        );

        let transaction_store = Arc::new(TransactionStore::new(Arc::clone(&ledger_db)));

        let event_store_pruner = Box::new(EventStorePruner::new(
            Arc::clone(&ledger_db),
            metadata_progress,
            internal_indexer_db.clone(),
        )?);
        let persisted_auxiliary_info_pruner = Box::new(PersistedAuxiliaryInfoPruner::new(
            Arc::clone(&ledger_db),
            metadata_progress,
        )?);
        let transaction_accumulator_pruner = Box::new(TransactionAccumulatorPruner::new(
            Arc::clone(&ledger_db),
            metadata_progress,
        )?);

        let transaction_auxiliary_data_pruner = Box::new(TransactionAuxiliaryDataPruner::new(
            Arc::clone(&ledger_db),
            metadata_progress,
        )?);

        let transaction_info_pruner = Box::new(TransactionInfoPruner::new(
            Arc::clone(&ledger_db),
            metadata_progress,
        )?);
        let transaction_pruner = Box::new(TransactionPruner::new(
            Arc::clone(&transaction_store),
            Arc::clone(&ledger_db),
            metadata_progress,
            internal_indexer_db,
        )?);
        let write_set_pruner = Box::new(WriteSetPruner::new(
            Arc::clone(&ledger_db),
            metadata_progress,
        )?);
```

**File:** storage/aptosdb/src/pruner/ledger_pruner/transaction_pruner.rs (L84-101)
```rust
        let progress = get_or_initialize_subpruner_progress(
            ledger_db.transaction_db_raw(),
            &DbMetadataKey::TransactionPrunerProgress,
            metadata_progress,
        )?;

        let myself = TransactionPruner {
            transaction_store,
            ledger_db,
            internal_indexer_db,
        };

        info!(
            progress = progress,
            metadata_progress = metadata_progress,
            "Catching up TransactionPruner."
        );
        myself.prune(progress, metadata_progress)?;
```

**File:** storage/aptosdb/src/ledger_db/transaction_db.rs (L169-179)
```rust
    pub(crate) fn prune_transactions(
        &self,
        begin: Version,
        end: Version,
        db_batch: &mut SchemaBatch,
    ) -> Result<()> {
        for version in begin..end {
            db_batch.delete::<TransactionSchema>(&version)?;
        }
        Ok(())
    }
```
