# Audit Report

## Title
BlockSTM V1 Module Read Validation Bypass Enables Non-Deterministic Execution Across Validators

## Summary
BlockSTM V1 completely bypasses module read validation by setting `skip_module_reads_validation = true`, allowing transactions to commit with stale module code captured from GlobalCache before module overrides take effect. This creates a race condition window where different validators can execute the same transaction with different module versions depending on parallel execution timing, violating the critical **Deterministic Execution** invariant.

## Finding Description

The vulnerability exists in BlockSTM V1's validation logic where module reads are unconditionally skipped during transaction validation. [1](#0-0) 

The validation function explicitly checks this flag and skips module validation when set: [2](#0-1) 

**Attack Scenario:**

1. Transaction T0 (index 0) publishes a new version of module M
2. Transaction T1 (index 1) needs to execute code that uses module M
3. In parallel execution, T1 may execute **before** T0's sequential commit completes
4. T1 reads module M from GlobalCache via `get_module_or_build_with`: [3](#0-2) 

5. T1 captures `ModuleRead::GlobalCache(M_old)` in its read set: [4](#0-3) 

6. T0 commits sequentially and calls `publish_module_write_set`, which marks M as overridden: [5](#0-4) 

7. The `mark_overridden` call invalidates the GlobalCache entry: [6](#0-5) 

8. T1 is triggered for re-validation via `decrease_validation_idx`: [7](#0-6) 

9. T1's validation runs but **skips module read validation entirely**, passing with stale module code
10. T1 commits with output computed using M_old instead of M_new

**Race Condition Window:** Different validators executing the same block in parallel may have T1 read the module at different times relative to T0's commit. Validator A might have T1 execute before T0's `mark_overridden`, while Validator B might have T1 execute after. This produces different state roots from identical input blocks.

The validation logic in `validate_module_reads` would catch this, but it's bypassed: [8](#0-7) 

## Impact Explanation

**Critical Severity** - This violates the fundamental **Deterministic Execution** invariant (#1 in the specification):

- **Consensus Safety Violation**: Different validators produce different state roots for identical blocks, causing consensus failures
- **Network Partition**: Validators will disagree on state, potentially requiring emergency intervention or hardfork
- **State Divergence**: The blockchain state becomes inconsistent across the network

This meets the Critical severity criteria: "Consensus/Safety violations" and "Non-recoverable network partition (requires hardfork)".

## Likelihood Explanation

**High likelihood** in networks using BlockSTM V1:

- The race condition triggers whenever module publishing occurs in a block with subsequent transactions using those modules
- No attacker control needed - the non-determinism is inherent to parallel execution timing
- Module publishing is a standard operation (framework upgrades, user module deployments)
- The larger the validator set and higher the network latency variance, the more likely timing differences occur

**Attacker amplification**: A malicious actor could deliberately publish modules in blocks to maximize the probability of validator disagreement by:
- Publishing frequently-used modules
- Ensuring subsequent transactions in the same block use the published modules
- Exploiting network topology to maximize timing variance

## Recommendation

**Immediate Fix**: Disable BlockSTM V1 or set `skip_module_reads_validation = false` for V1 execution.

**Long-term Fix**: BlockSTM V2 already implements the correct solution through cold validation requirements. Migrate all execution to V2, which properly validates module reads: [9](#0-8) 

V2 ensures module validation occurs before commit via the cold validation mechanism: [10](#0-9) 

## Proof of Concept

```rust
// Reproduction scenario (conceptual - would require full test harness):

// Block with 2 transactions:
// T0: Publishes module M with new function behavior
// T1: Calls function in module M

// On Validator A (T1 executes early):
// 1. T1 starts execution in parallel
// 2. T1 reads M from GlobalCache -> gets M_old
// 3. T0 commits, marks M as overridden
// 4. T1 validates (module validation SKIPPED)
// 5. T1 commits with output based on M_old
// Result: state_root_A based on M_old behavior

// On Validator B (T1 executes late):
// 1. T0 commits first, marks M as overridden
// 2. T1 starts execution
// 3. T1 reads M from GlobalCache -> returns None (overridden)
// 4. T1 reads M from per-block cache -> gets M_new
// 5. T1 executes with M_new
// 6. T1 validates and commits with output based on M_new
// Result: state_root_B based on M_new behavior

// Assertion: state_root_A â‰  state_root_B (consensus failure)
```

To reproduce in a test environment:
1. Deploy BlockSTM V1 with multiple validator nodes
2. Submit a block with module publishing followed by module usage
3. Introduce artificial network delays to vary execution timing
4. Observe validators computing different state roots
5. Verify the divergence is caused by skipped module validation

---

**Notes:**

This vulnerability only affects BlockSTM V1. BlockSTM V2 correctly implements module validation through the cold validation requirements mechanism. The existence of V2 with explicit module validation strongly suggests this was a known limitation of V1 that required architectural changes to fix properly.

### Citations

**File:** aptos-move/block-executor/src/executor.rs (L763-773)
```rust
        if !read_set.validate_module_reads(
            global_module_cache,
            versioned_cache.module_cache(),
            Some(updated_module_keys),
        ) {
            scheduler.direct_abort(idx_to_validate, incarnation_to_validate, false)?;
            return Ok(false);
        }

        Ok(true)
    }
```

**File:** aptos-move/block-executor/src/executor.rs (L808-815)
```rust
        read_set.validate_data_reads(versioned_cache.data(), idx_to_validate)
            && read_set.validate_group_reads(versioned_cache.group_data(), idx_to_validate)
            && (skip_module_reads_validation
                || read_set.validate_module_reads(
                    global_module_cache,
                    versioned_cache.module_cache(),
                    None,
                ))
```

**File:** aptos-move/block-executor/src/executor.rs (L1056-1056)
```rust
            scheduler.wake_dependencies_and_decrease_validation_idx(txn_idx)?;
```

**File:** aptos-move/block-executor/src/executor.rs (L1895-1895)
```rust
        let skip_module_reads_validation = AtomicBool::new(true);
```

**File:** aptos-move/block-executor/src/code_cache.rs (L148-174)
```rust
        match &self.latest_view {
            ViewState::Sync(state) => {
                // Check the transaction-level cache with already read modules first.
                if let CacheRead::Hit(read) = state.captured_reads.borrow().get_module_read(key) {
                    return Ok(read);
                }

                // Otherwise, it is a miss. Check global cache.
                if let Some(module) = self.global_module_cache.get(key) {
                    state
                        .captured_reads
                        .borrow_mut()
                        .capture_global_cache_read(key.clone(), module.clone());
                    return Ok(Some((module, Self::Version::default())));
                }

                // If not global cache, check per-block cache.
                let _timer = GLOBAL_MODULE_CACHE_MISS_SECONDS.start_timer();
                let read = state
                    .versioned_map
                    .module_cache()
                    .get_module_or_build_with(key, builder)?;
                state
                    .captured_reads
                    .borrow_mut()
                    .capture_per_block_cache_read(key.clone(), read.clone());
                Ok(read)
```

**File:** aptos-move/block-executor/src/captured_reads.rs (L522-529)
```rust
enum ModuleRead<DC, VC, S> {
    /// Read from the global module cache. Modules in this cache have storage version, but require
    /// different validation - a check that they have not been overridden.
    GlobalCache(Arc<ModuleCode<DC, VC, S>>),
    /// Read from per-block cache that contains committed (by specified transaction) and newly
    /// loaded from storage (i.e., not yet moved to global module cache) modules.
    PerBlockCache(Option<(Arc<ModuleCode<DC, VC, S>>, Option<TxnIndex>)>),
}
```

**File:** aptos-move/block-executor/src/captured_reads.rs (L1060-1067)
```rust
        let validate = |key: &K, read: &ModuleRead<DC, VC, S>| match read {
            ModuleRead::GlobalCache(_) => global_module_cache.contains_not_overridden(key),
            ModuleRead::PerBlockCache(previous) => {
                let current_version = per_block_module_cache.get_module_version(key);
                let previous_version = previous.as_ref().map(|(_, version)| *version);
                current_version == previous_version
            },
        };
```

**File:** aptos-move/block-executor/src/txn_last_input_output.rs (L559-571)
```rust
        for write in output_before_guard.module_write_set().values() {
            published = true;
            if scheduler.is_v2() {
                module_ids_for_v2.insert(write.module_id().clone());
            }
            add_module_write_to_module_cache::<T>(
                write,
                txn_idx,
                runtime_environment,
                global_module_cache,
                versioned_cache.module_cache(),
            )?;
        }
```

**File:** aptos-move/block-executor/src/code_cache_global.rs (L124-128)
```rust
    pub fn mark_overridden(&self, key: &K) {
        if let Some(entry) = self.module_cache.get(key) {
            entry.mark_overridden();
        }
    }
```

**File:** aptos-move/block-executor/src/cold_validation.rs (L208-266)
```rust
    pub(crate) fn record_requirements(
        &self,
        worker_id: u32,
        calling_txn_idx: TxnIndex,
        min_never_scheduled_idx: TxnIndex,
        requirements: BTreeSet<R>,
    ) -> Result<(), PanicError> {
        if min_never_scheduled_idx > self.num_txns || min_never_scheduled_idx <= calling_txn_idx {
            return Err(code_invariant_error(format!(
                "Invalid min_never_scheduled_idx = {} for calling_txn_idx = {} and num_txns = {}",
                min_never_scheduled_idx, calling_txn_idx, self.num_txns
            )));
        }

        if calling_txn_idx + 1 == std::cmp::min(self.num_txns, min_never_scheduled_idx) {
            // Requirements are void, since it applies to txns before min_never_scheduled_idx.
            return Ok(());
        }

        if requirements.is_empty() {
            return Err(code_invariant_error(format!(
                "Empty requirements to record for calling_txn_idx = {}",
                calling_txn_idx
            )));
        }

        let mut pending_reqs = self.pending_requirements.lock();
        pending_reqs.push(PendingRequirement {
            requirements,
            from_idx: calling_txn_idx + 1,
            to_idx: min_never_scheduled_idx,
        });

        // Updates to atomic variables while recording pending requirements occur under the
        // pending_requirements lock to ensure atomicity versus draining to activate.
        // However, for simplicity and simpler invariants, all updates (including in
        // validation_requirement_processed) are under the same lock.
        let _ = self.dedicated_worker_id.compare_exchange(
            u32::MAX,
            worker_id,
            Ordering::Relaxed,
            Ordering::Relaxed,
        );
        let prev_min_idx = self
            .min_idx_with_unprocessed_validation_requirement
            .swap(calling_txn_idx + 1, Ordering::Relaxed);
        if prev_min_idx <= calling_txn_idx {
            // Record may not be called with a calling_txn_idx higher or equal to the
            // min_from_idx, as committing calling_txn_idx is impossible before the pending
            // requirements with lower min index are processed and any (lower or equal)
            // required validations are performed.
            return Err(code_invariant_error(format!(
                "Recording validation requirements, min idx = {} <= calling_txn_idx = {}",
                prev_min_idx, calling_txn_idx
            )));
        }

        Ok(())
    }
```
