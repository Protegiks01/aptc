# Audit Report

## Title
Bytecode Verifier Missing Type Validation for AddressSpecifier Identity Function

## Summary
The Move bytecode verifier fails to validate that when `AddressSpecifier::Parameter(idx, None)` is used (defaulting to `AddressSpecifierFunction::Identity`), the parameter at index `idx` has type `address`. This allows invalid bytecode to pass verification and only fail at runtime, violating a documented specification invariant and creating a verification bypass.

## Finding Description

The issue exists in the access specifier loading and verification flow: [1](#0-0) 

When `fun` is `None` at line 107, the code defaults to `AddressSpecifierFunction::Identity` without verifying that the parameter type is `address`. [2](#0-1) 

The specification explicitly states (line 910): "If `modifier` is not given, the parameter must have address type." However, the bytecode verifier does not enforce this constraint.

The runtime evaluation attempts type conversion: [3](#0-2) 

When a non-address type is passed, this fails: [4](#0-3) 

The error is caught at function entry: [5](#0-4) 

**Attack Path:**
1. Attacker crafts malicious bytecode with `AddressSpecifier::Parameter(0, None)` where parameter 0 is `u64` instead of `address`
2. Bytecode passes all verification checks (BoundsChecker, FeatureVerifier, signature_v2, etc.): [6](#0-5) 
3. Invalid module is deployed on-chain
4. When function is called, `enter_function()` fails with `INTERNAL_TYPE_ERROR` during specialization
5. Transaction aborts but gas is consumed

The compiler correctly validates this during type checking: [7](#0-6) 

But malicious bytecode can bypass the compiler entirely.

## Impact Explanation

**High Severity - Significant Protocol Violations:**

This constitutes a significant protocol violation because:
1. **Verification Bypass**: The bytecode verifier's purpose is to reject invalid bytecode before execution. This gap allows specification-violating bytecode to be deployed
2. **Documented Invariant Violation**: The file format specification explicitly requires this check, making this a violation of a documented security invariant
3. **Defense-in-Depth Failure**: While runtime checking catches the error, verification-time checking is a critical security layer that should not be bypassable
4. **Resource Waste**: Attackers can deploy modules that pass verification but fail at runtime, consuming on-chain storage and wasting gas for callers

While execution fails deterministically (preventing consensus issues), the verification bypass itself represents a significant protocol violation that undermines the security guarantees of the bytecode verifier.

## Likelihood Explanation

**High Likelihood:**
- Exploitation requires only crafting malicious bytecode or using a modified compiler
- No special privileges needed - any user can deploy modules
- The attack surface is easily accessible to any attacker
- The verification gap is consistent and reproducible

## Recommendation

Add validation in the bytecode verifier to check access specifier parameter types. Specifically, add a new verification pass or extend `signature_v2::verify_module()`:

```rust
// In signature_v2.rs or a new access_specifier_verifier.rs
fn verify_access_specifiers(&self) -> PartialVMResult<()> {
    for func_handle in self.resolver.function_handles() {
        if let Some(access_specs) = &func_handle.access_specifiers {
            let param_types = self.resolver.signature_at(func_handle.parameters);
            for spec in access_specs {
                if let AddressSpecifier::Parameter(idx, None) = &spec.address {
                    // When None (Identity function), parameter must be address type
                    if *idx as usize >= param_types.0.len() {
                        return Err(PartialVMError::new(StatusCode::INVALID_SIGNATURE_TOKEN)
                            .with_message("access specifier references invalid parameter"));
                    }
                    if param_types.0[*idx as usize] != SignatureToken::Address {
                        return Err(PartialVMError::new(StatusCode::TYPE_MISMATCH)
                            .with_message("AddressSpecifier::Identity requires address parameter"));
                    }
                }
            }
        }
    }
    Ok(())
}
```

Call this from `verify_module_with_config()` after signature verification.

## Proof of Concept

```rust
// Rust test demonstrating the vulnerability
#[test]
fn test_invalid_access_specifier_passes_verification() {
    use move_binary_format::file_format::*;
    
    // Craft a module with AddressSpecifier::Parameter(0, None) 
    // where parameter 0 is U64 instead of Address
    let mut module = CompiledModule {
        version: 7,
        // ... basic module structure ...
        function_handles: vec![FunctionHandle {
            module: ModuleHandleIndex(0),
            name: IdentifierIndex(0),
            parameters: SignatureIndex(0), // Points to signature with U64
            return_: SignatureIndex(1),
            type_parameters: vec![],
            access_specifiers: Some(vec![AccessSpecifier {
                kind: AccessKind::Acquires,
                negated: false,
                resource: ResourceSpecifier::Any,
                address: AddressSpecifier::Parameter(0, None), // INVALID: param 0 is U64
            }]),
            attributes: vec![],
        }],
        signatures: vec![
            Signature(vec![SignatureToken::U64]), // Parameter signature
            Signature(vec![]),                     // Return signature
        ],
        // ... rest of module ...
    };
    
    // This SHOULD fail verification but currently PASSES
    let result = move_bytecode_verifier::verify_module(&module);
    
    // Currently this assertion fails - the module incorrectly passes verification
    assert!(result.is_err(), "Expected verification to fail for type mismatch");
}
```

## Notes

While the runtime correctly handles this error by aborting execution deterministically, the verification bypass represents a significant protocol violation. The bytecode verifier is designed to be the first line of defense against invalid bytecode, and this gap undermines that security layer. The fix should be implemented in the verifier to prevent invalid modules from being deployed on-chain in the first place.

### Citations

**File:** third_party/move/move-vm/runtime/src/loader/access_specifier_loader.rs (L89-109)
```rust
        Parameter(param, fun) => {
            let fun = if let Some(idx) = fun {
                let fun_inst = access_table(module.function_instantiations(), idx.0)?;
                let fun_handle = access_table(module.function_handles(), fun_inst.handle.0)?;
                let mod_handle = access_table(module.module_handles(), fun_handle.module.0)?;
                let mod_id = module
                    .safe_module_id_for_handle(mod_handle)
                    .ok_or_else(index_out_of_range)?;
                let mod_name = mod_id.short_str_lossless();
                let fun_name = access_table(module.identifiers(), fun_handle.name.0)?;
                AddressSpecifierFunction::parse(&mod_name, fun_name.as_str()).ok_or_else(|| {
                    PartialVMError::new(StatusCode::ACCESS_CONTROL_INVARIANT_VIOLATION)
                        .with_message(format!(
                            "function `{}::{}` not supported for address specifier",
                            mod_name, fun_name
                        ))
                })?
            } else {
                AddressSpecifierFunction::Identity
            };
            Ok(AddressSpecifier::Eval(fun, *param))
```

**File:** third_party/move/move-binary-format/src/file_format.rs (L908-917)
```rust
    Parameter(
        /// The index of a parameter of the current function. If `modifier` is not given, the
        /// parameter must have address type. Otherwise `modifier` must be a function which takes
        /// a value (or reference) of the parameter type and delivers an address.
        #[cfg_attr(any(test, feature = "fuzzing"), proptest(strategy = "0u8..63"))]
        LocalIndex,
        /// If given, a function applied to the parameter. This is a well-known function which
        /// extracts an address from a value, e.g. `object::address_of`.
        Option<FunctionInstantiationIndex>,
    ),
```

**File:** third_party/move/move-vm/types/src/loaded_data/runtime_access_specifier.rs (L249-252)
```rust
    pub fn eval(&self, arg: Value) -> PartialVMResult<AccountAddress> {
        use AddressSpecifierFunction::*;
        match self {
            Identity => arg.value_as::<AccountAddress>(),
```

**File:** third_party/move/move-vm/types/src/values/values_impl.rs (L2689-2710)
```rust
macro_rules! impl_vm_value_cast_boxed {
    ($ty:ty, $tc:ident) => {
        impl VMValueCast<$ty> for Value {
            #[cfg_attr(feature = "inline-vm-casts", inline)]
            fn cast(self) -> PartialVMResult<$ty> {
                return match self {
                    Value::$tc(x) => Ok(*x),
                    v => __cannot_cast(v),
                };
                #[cold]
                fn __cannot_cast(v: Value) -> PartialVMResult<$ty> {
                    Err(
                        PartialVMError::new(StatusCode::INTERNAL_TYPE_ERROR).with_message(format!(
                            "cannot cast {:?} to {}",
                            v,
                            stringify!($ty)
                        )),
                    )
                }
            }
        }
    };
```

**File:** third_party/move/move-vm/runtime/src/interpreter.rs (L382-384)
```rust
        self.access_control
            .enter_function(&current_frame, &current_frame.function)
            .map_err(|e| self.set_location(e))?;
```

**File:** third_party/move/move-bytecode-verifier/src/verifier.rs (L134-163)
```rust
pub fn verify_module_with_config(config: &VerifierConfig, module: &CompiledModule) -> VMResult<()> {
    if config.verify_nothing() {
        return Ok(());
    }
    let prev_state = move_core_types::state::set_state(VMState::VERIFIER);
    let result = std::panic::catch_unwind(|| {
        // Always needs to run bound checker first as subsequent passes depend on it
        BoundsChecker::verify_module(module).map_err(|e| {
            // We can't point the error at the module, because if bounds-checking
            // failed, we cannot safely index into module's handle to itself.
            e.finish(Location::Undefined)
        })?;
        FeatureVerifier::verify_module(config, module)?;
        LimitsVerifier::verify_module(config, module)?;
        DuplicationChecker::verify_module(module)?;

        signature_v2::verify_module(config, module)?;

        InstructionConsistency::verify_module(module)?;
        constants::verify_module(module)?;
        friends::verify_module(module)?;

        RecursiveStructDefChecker::verify_module(module)?;
        InstantiationLoopChecker::verify_module(module)?;
        CodeUnitVerifier::verify_module(config, module)?;

        // Add the failpoint injection to test the catch_unwind behavior.
        fail::fail_point!("verifier-failpoint-panic");

        script_signature::verify_module(module, no_additional_script_signature_checks)
```

**File:** third_party/move/move-model/src/builder/exp_builder.rs (L1394-1406)
```rust
                // Construct an expansion name exp for regular type check
                let maccess = sp(name.loc, EA::ModuleAccess_::Name(*name));
                self.translate_name(
                    &self.to_loc(&maccess.loc),
                    &maccess,
                    &None,
                    &Type::new_prim(PrimitiveType::Address),
                    &ErrorMessageContext::General,
                );
                (
                    loc,
                    AddressSpecifier::Parameter(self.symbol_pool().make(name.value.as_str())),
                )
```
