# Audit Report

## Title
VMState Leak Enables Crash Suppression in Non-Verifier Code Due to Panic in Error Handler

## Summary
A thread-local VMState can become permanently stuck in VERIFIER mode if a panic occurs during error construction in the bytecode verifier's panic handler. This causes the crash handler to incorrectly suppress legitimate panics in subsequent non-verifier operations on the same thread, potentially masking critical failures that should halt validator nodes.

## Finding Description

The Move bytecode verifier uses a thread-local `VMState` variable to track whether code is executing within the verifier context. The crash handler checks this state to determine whether panics should kill the process or be handled gracefully. [1](#0-0) 

The vulnerability exists in the state restoration pattern used by `verify_module_with_config`: [2](#0-1) 

The critical flaw is that when the inner `catch_unwind` catches a verification panic, the `unwrap_or_else` closure creates a `PartialVMError` which can itself panic during error construction. This panic occurs **outside** the `catch_unwind` scope, so it propagates upward without restoring the previous VMState on line 171.

The error construction code contains multiple panic points:
- Backtrace capture and allocation [3](#0-2) 
- Fuzzing-mode intentional panic injection [4](#0-3) 
- String formatting and Box allocation [5](#0-4) 

In production, the VMValidator service wraps transaction validation in an outer `catch_unwind`: [6](#0-5) 

This outer handler catches the escaped panic, logs it, and returns an error. Critically, **the thread survives and continues processing transactions from the thread pool** [7](#0-6)  with VMState still set to VERIFIER.

**Attack Flow:**
1. Transaction validation is invoked on a thread pool worker
2. Module loading triggers `verify_module_with_config` 
3. Verification panics (e.g., malformed bytecode)
4. Error handler panics during `PartialVMError::new()` (OOM or fuzzing mode)
5. Inner `catch_unwind` doesn't catch this panic (it's outside the closure)
6. Outer `catch_unwind` in vm-validator catches it, thread continues
7. VMState remains VERIFIER for this thread's lifetime
8. Subsequent non-verifier operations on this thread have their panics suppressed by crash handler
9. Critical failures that should crash the node are hidden

The same vulnerability exists in `verify_script_with_config` [8](#0-7)  and the deserializer [9](#0-8) 

## Impact Explanation

This is a **High Severity** vulnerability per the Aptos bug bounty criteria:

**Validator Node Reliability:** A validator node with a stuck VMState will continue running despite critical panics that should terminate it. This violates the fail-fast principle essential for distributed consensus systems.

**State Inconsistency Risk:** Different nodes may handle the same edge case differently - some might crash (if their VMState isn't stuck), while others continue with suppressed panics. This could lead to consensus divergence where validators have different views of valid transactions or state.

**Hidden Critical Bugs:** Security-critical panics (memory corruption, invariant violations, cryptographic failures) would be logged but not halt the process, allowing potentially corrupted state to propagate through the system.

**Cascading Failures:** A thread pool worker with stuck VMState could process thousands of transactions before being recycled, potentially propagating incorrect results or hiding systematic issues.

## Likelihood Explanation

**Production Likelihood: Low-to-Medium**
- Requires specific panic scenarios during error construction (OOM, allocation failure)
- More likely under resource pressure or adversarial inputs
- Once triggered, affects all subsequent operations on that thread

**Fuzzing/Testing Likelihood: High**
- The `fuzzing_maybe_panic!` macro deliberately triggers this path
- Demonstrates the vulnerability is architecturally present

**Exploitation Complexity: Medium**
- Attacker needs to trigger verification failure (straightforward with malformed modules)
- Must also trigger panic during error handling (harder, but possible via resource exhaustion)
- No privileged access required

**Persistence:** Once a thread's VMState is stuck, it remains until thread termination, affecting potentially thousands of subsequent operations.

## Recommendation

**Immediate Fix:** Use RAII guard pattern to ensure state is always restored, even on panic:

```rust
pub fn verify_module_with_config(config: &VerifierConfig, module: &CompiledModule) -> VMResult<()> {
    if config.verify_nothing() {
        return Ok(());
    }
    
    // RAII guard ensures state is restored even on panic
    struct StateGuard {
        prev_state: VMState,
    }
    
    impl Drop for StateGuard {
        fn drop(&mut self) {
            move_core_types::state::set_state(self.prev_state);
        }
    }
    
    let _guard = StateGuard {
        prev_state: move_core_types::state::set_state(VMState::VERIFIER),
    };
    
    let result = std::panic::catch_unwind(|| {
        // verification code unchanged
        BoundsChecker::verify_module(module).map_err(|e| {
            e.finish(Location::Undefined)
        })?;
        // ... rest of verification ...
        fail::fail_point!("verifier-failpoint-panic");
        script_signature::verify_module(module, no_additional_script_signature_checks)
    })
    .unwrap_or_else(|_| {
        Err(
            PartialVMError::new(StatusCode::VERIFIER_INVARIANT_VIOLATION)
                .finish(Location::Undefined),
        )
    });
    
    // Guard drops here, restoring state even if unwrap_or_else panics
    result
}
```

Apply the same pattern to `verify_script_with_config` and deserializer functions.

**Alternative Fix:** Move error construction outside `unwrap_or_else` to eliminate panic path:

```rust
let result = std::panic::catch_unwind(|| { /* ... */ });
move_core_types::state::set_state(prev_state); // Restore BEFORE error handling

result.unwrap_or_else(|_| {
    Err(PartialVMError::new(StatusCode::VERIFIER_INVARIANT_VIOLATION)
        .finish(Location::Undefined))
})
```

## Proof of Concept

```rust
#[cfg(test)]
mod test_state_leak {
    use move_binary_format::file_format::empty_module;
    use move_bytecode_verifier::VerifierConfig;
    use move_core_types::state::{self, VMState};
    use std::panic;

    #[test]
    #[cfg(feature = "fuzzing")]
    fn test_vmstate_leak_on_error_panic() {
        // Set up fuzzing mode to panic during error construction
        std::env::set_var("DEBUG_VM_STATUS", "VERIFIER_INVARIANT_VIOLATION");
        
        // Verify initial state is not VERIFIER
        assert_ne!(state::get_state(), VMState::VERIFIER);
        
        // Outer catch_unwind simulates vm-validator behavior
        let result = panic::catch_unwind(|| {
            let m = empty_module();
            // Inject verification failure
            fail::cfg("verifier-failpoint-panic", "panic").unwrap();
            
            move_bytecode_verifier::verify_module_with_config(
                &VerifierConfig::unbounded(),
                &m
            )
        });
        
        // Outer catch_unwind caught the panic from error handler
        assert!(result.is_err());
        
        // BUG: State is now stuck as VERIFIER
        assert_eq!(state::get_state(), VMState::VERIFIER);
        
        // Simulate subsequent non-verifier operation
        let non_verifier_panic_result = panic::catch_unwind(|| {
            // This panic should crash the node, but will be suppressed
            // because crash handler sees VMState::VERIFIER
            panic!("Critical non-verifier failure!");
        });
        
        // The panic was suppressed by crash handler due to stuck VMState
        assert!(non_verifier_panic_result.is_err());
        
        // State remains VERIFIER indefinitely
        assert_eq!(state::get_state(), VMState::VERIFIER);
        
        std::env::remove_var("DEBUG_VM_STATUS");
    }
}
```

**Notes**

The vulnerability stems from an unsafe assumption that `PartialVMError` construction cannot panic. While rare in production, the fuzzing infrastructure explicitly includes panic injection in this code path, demonstrating the architectural flaw. The RAII guard pattern provides a robust solution that handles panics at any point in the function, including during error handling, ensuring crash handler behavior remains correct.

### Citations

**File:** crates/crash-handler/src/lib.rs (L48-54)
```rust
    // Do not kill the process if the panics happened at move-bytecode-verifier.
    // This is safe because the `state::get_state()` uses a thread_local for storing states. Thus the state can only be mutated to VERIFIER by the thread that's running the bytecode verifier.
    //
    // TODO: once `can_unwind` is stable, we should assert it. See https://github.com/rust-lang/rust/issues/92988.
    if state::get_state() == VMState::VERIFIER || state::get_state() == VMState::DESERIALIZER {
        return;
    }
```

**File:** third_party/move/move-bytecode-verifier/src/verifier.rs (L138-172)
```rust
    let prev_state = move_core_types::state::set_state(VMState::VERIFIER);
    let result = std::panic::catch_unwind(|| {
        // Always needs to run bound checker first as subsequent passes depend on it
        BoundsChecker::verify_module(module).map_err(|e| {
            // We can't point the error at the module, because if bounds-checking
            // failed, we cannot safely index into module's handle to itself.
            e.finish(Location::Undefined)
        })?;
        FeatureVerifier::verify_module(config, module)?;
        LimitsVerifier::verify_module(config, module)?;
        DuplicationChecker::verify_module(module)?;

        signature_v2::verify_module(config, module)?;

        InstructionConsistency::verify_module(module)?;
        constants::verify_module(module)?;
        friends::verify_module(module)?;

        RecursiveStructDefChecker::verify_module(module)?;
        InstantiationLoopChecker::verify_module(module)?;
        CodeUnitVerifier::verify_module(config, module)?;

        // Add the failpoint injection to test the catch_unwind behavior.
        fail::fail_point!("verifier-failpoint-panic");

        script_signature::verify_module(module, no_additional_script_signature_checks)
    })
    .unwrap_or_else(|_| {
        Err(
            PartialVMError::new(StatusCode::VERIFIER_INVARIANT_VIOLATION)
                .finish(Location::Undefined),
        )
    });
    move_core_types::state::set_state(prev_state);
    result
```

**File:** third_party/move/move-bytecode-verifier/src/verifier.rs (L193-219)
```rust
    let prev_state = move_core_types::state::set_state(VMState::VERIFIER);
    let result = std::panic::catch_unwind(|| {
        // Always needs to run bound checker first as subsequent passes depend on it
        BoundsChecker::verify_script(script).map_err(|e| {
            // We can't point the error at the script, because if bounds-checking
            // failed, we cannot safely index into script
            e.finish(Location::Undefined)
        })?;
        FeatureVerifier::verify_script(config, script)?;
        LimitsVerifier::verify_script(config, script)?;
        DuplicationChecker::verify_script(script)?;

        signature_v2::verify_script(config, script)?;

        InstructionConsistency::verify_script(script)?;
        constants::verify_script(script)?;
        CodeUnitVerifier::verify_script(config, script)?;
        script_signature::verify_script(script, no_additional_script_signature_checks)
    })
    .unwrap_or_else(|_| {
        Err(
            PartialVMError::new(StatusCode::VERIFIER_INVARIANT_VIOLATION)
                .with_message("[VM] bytecode verifier panicked for script".to_string())
                .finish(Location::Undefined),
        )
    });
    move_core_types::state::set_state(prev_state);
```

**File:** third_party/move/move-binary-format/src/errors.rs (L39-50)
```rust
macro_rules! fuzzing_maybe_panic {
    ($major_status:expr, $message:expr) => {{
        if let Ok(debug_statuses) = std::env::var("DEBUG_VM_STATUS") {
            if debug_statuses
                .split(',')
                .any(|s| s.trim() == format!("{:?}", $major_status))
            {
                panic!("PartialVMError: {:?} {:?}", $major_status, $message);
            }
        }
    }};
}
```

**File:** third_party/move/move-binary-format/src/errors.rs (L448-469)
```rust
            backtrace::trace(|frame| {
                backtrace::resolve_frame(frame, |symbol| {
                    let mut function_name = backtrace::SymbolName::new("<unknown>".as_bytes());
                    if let Some(name) = symbol.name() {
                        function_name = name;
                    }
                    let mut file_name = "<unknown>";
                    if let Some(filename) = symbol.filename() {
                        if let Some(filename) = filename.to_str() {
                            file_name = filename;
                        }
                    }
                    let lineno = symbol.lineno().unwrap_or(0);
                    trace.push_str(&format!(
                        "In function {} at {}:{}\n",
                        function_name, file_name, lineno
                    ));
                });
                len -= 1;
                len > 0
            });
            Some(trace)
```

**File:** third_party/move/move-binary-format/src/errors.rs (L477-484)
```rust
        Self(Box::new(PartialVMError_ {
            major_status,
            sub_status: None,
            message,
            exec_state: None,
            indices: vec![],
            offsets: vec![],
        }))
```

**File:** vm-validator/src/vm_validator.rs (L155-169)
```rust
        let result = std::panic::catch_unwind(move || {
            let vm_validator_locked = vm_validator.lock().unwrap();

            use aptos_vm::VMValidator;
            let vm = AptosVM::new(&vm_validator_locked.state.environment);
            vm.validate_transaction(
                txn,
                &vm_validator_locked.state.state_view,
                &vm_validator_locked.state,
            )
        });
        if let Err(err) = &result {
            error!("VMValidator panicked: {:?}", err);
        }
        result.map_err(|_| anyhow::anyhow!("panic validating transaction"))
```

**File:** mempool/src/shared_mempool/tasks.rs (L490-503)
```rust
    let validation_results = VALIDATION_POOL.install(|| {
        transactions
            .par_iter()
            .map(|t| {
                let result = smp.validator.read().validate_transaction(t.0.clone());
                // Pre-compute the hash and length if the transaction is valid, before locking mempool
                if result.is_ok() {
                    t.0.committed_hash();
                    t.0.txn_bytes_len();
                }
                result
            })
            .collect::<Vec<_>>()
    });
```

**File:** third_party/move/move-binary-format/src/deserializer.rs (L56-68)
```rust
        let prev_state = move_core_types::state::set_state(VMState::DESERIALIZER);
        let result = std::panic::catch_unwind(|| {
            let module = deserialize_compiled_module(binary, config)?;
            BoundsChecker::verify_module(&module)?;

            Ok(module)
        })
        .unwrap_or_else(|_| {
            Err(PartialVMError::new(
                StatusCode::VERIFIER_INVARIANT_VIOLATION,
            ))
        });
        move_core_types::state::set_state(prev_state);
```
