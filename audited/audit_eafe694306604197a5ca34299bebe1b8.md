# Audit Report

## Title
Genesis Transaction Replay via Unvalidated Restore Process Enables Critical System State Corruption

## Summary
The transaction restore process accessible via `aptos-db-tool restore oneoff transaction` fails to validate against already-committed transactions when restoring backups that start at version 0. This allows an attacker to replay the genesis transaction, overwriting critical system state including the validator set, framework modules, and epoch configuration, leading to consensus failure and potential network takeover.

## Finding Description

The vulnerability exists in the transaction restore implementation when using `TransactionRestoreController` directly through the CLI tool. The root cause is an improper boundary check that fails to filter out already-committed transactions.

**Vulnerable Code Path:**

1. The `aptos-db-tool restore oneoff transaction` command instantiates `TransactionRestoreController` with `first_version=None` hardcoded: [1](#0-0) 

2. This causes `TransactionRestoreBatchController::run_impl` to use the backup's first version instead of the database's current state: [2](#0-1) 

3. The transaction filtering logic only removes transactions before `global_first_version`, which is set from the backup (0) rather than the database state: [3](#0-2) 

4. This allows the genesis transaction to pass through to `save_transactions`, which blindly overwrites existing data: [4](#0-3) 

5. The `save_transactions_impl` function unconditionally overwrites all transaction data without checking if versions already exist: [5](#0-4) 

6. The underlying `put_transaction` method uses `batch.put` which overwrites existing entries: [6](#0-5) 

**Attack Scenario:**

An attacker with access to a node's `aptos-db-tool` CLI can:
1. Obtain or create a backup file containing transactions starting from version 0 (including genesis)
2. Run: `aptos-db-tool restore oneoff transaction --transaction-manifest <backup-path>`
3. The restore process overwrites the existing genesis transaction at version 0
4. Critical system state is corrupted: validator set, framework modules, epoch configuration

**Invariant Violations:**

- **State Consistency**: The genesis transaction and all subsequent transactions can be replayed, violating the immutability of committed state
- **Deterministic Execution**: Different nodes could have different genesis states if selectively attacked, breaking consensus
- **Consensus Safety**: Validator set manipulation through genesis replay enables consensus takeover

## Impact Explanation

This vulnerability meets **Critical Severity** criteria per the Aptos bug bounty program:

1. **Consensus/Safety Violations**: Replaying genesis with a modified validator set breaks AptosBFT consensus. The genesis transaction defines the initial validator set as shown in: [7](#0-6) 

2. **Network Partition**: If different nodes have different genesis states, they will produce different state roots, causing non-recoverable network partition requiring a hardfork.

3. **Validator Set Manipulation**: Genesis contains the initial validator configuration. Replacing it allows an attacker to:
   - Remove legitimate validators
   - Add malicious validators
   - Manipulate voting power distribution
   - Control consensus from version 0 forward

4. **System State Corruption**: Genesis initializes critical Move framework modules, system resources, and on-chain configuration. Overwriting these causes:
   - Move VM execution inconsistencies
   - Broken system invariants
   - Potential for arbitrary code execution through corrupted framework modules

## Likelihood Explanation

**Likelihood: High**

1. **Low Complexity**: Exploitation requires only CLI access to `aptos-db-tool`, which is commonly available on validator and fullnode infrastructure for operational tasks.

2. **No Special Privileges Required**: The attack doesn't require validator keys, consensus participation, or any cryptographic capabilitiesâ€”just local CLI access.

3. **Common Operational Scenario**: Restore operations are frequently performed during:
   - Node recovery after failures
   - State synchronization
   - Database maintenance
   - Migration between infrastructure

4. **No Rate Limiting or Validation**: The restore process has no safeguards against replaying already-committed transactions. The CLI tool is directly accessible from: [8](#0-7) 

## Recommendation

**Immediate Fix**: Add validation in `TransactionRestoreBatchController::run_impl` to reject transactions that would overwrite already-committed versions.

**Recommended Code Changes:**

In `storage/backup/backup-cli/src/backup_types/transaction/restore.rs`, modify the `run_impl` method to:

1. Always retrieve `next_expected_version` from the database
2. Use `max(global_first_version, next_expected_version)` as the filtering boundary
3. Add explicit checks to prevent overwriting committed transactions

```rust
async fn run_impl(self) -> Result<()> {
    // ... existing code ...
    
    let mut loaded_chunk_stream = self.loaded_chunk_stream();
    let next_expected_version = self
        .global_opt
        .run_mode
        .get_next_expected_transaction_version()?;
    
    // Use the greater of backup's first version or DB's next version
    let first_version = self.first_version.unwrap_or_else(|| {
        let backup_first = self.confirm_or_save_frozen_subtrees(&mut loaded_chunk_stream).await?;
        max(backup_first, next_expected_version)
    });
    
    // Add validation to prevent overwriting committed transactions
    ensure!(
        first_version >= next_expected_version,
        "Cannot restore transactions before version {}. Database already contains versions up to {}.",
        next_expected_version,
        next_expected_version.saturating_sub(1)
    );
    
    // ... rest of implementation ...
}
```

**Additional Safeguards:**

1. Add a CLI flag `--allow-overwrite` that requires explicit confirmation before allowing any restore operation that would affect existing versions
2. Log warnings when restore operations interact with already-committed transaction ranges
3. Implement database-level checks in `put_transaction` to reject overwrites unless explicitly allowed for recovery scenarios

## Proof of Concept

**Setup:**
```bash
# Initialize a test database with genesis
aptos-db-tool bootstrap-db --genesis-txn-file genesis.blob --target-db-dir /tmp/test-db

# Verify genesis exists at version 0
aptos-db-tool query transaction-info --version 0 --db-dir /tmp/test-db
```

**Exploit:**
```bash
# Create a backup containing transactions from version 0
# (This would normally be done through the backup process, but for PoC,
# assume we have a backup file: transaction_backup.manifest)

# Run the vulnerable restore command
aptos-db-tool restore oneoff transaction \
  --transaction-manifest gs://backup-bucket/transaction_backup.manifest \
  --target-db-dir /tmp/test-db

# The genesis transaction at version 0 is now overwritten
# Query to verify corruption:
aptos-db-tool query transaction-info --version 0 --db-dir /tmp/test-db

# Compare with original genesis - the transaction hash will differ if replaced
```

**Expected Result**: The restore command should successfully overwrite version 0, demonstrating the vulnerability.

**Rust Integration Test** (to be added to `storage/backup/backup-cli/src/backup_types/transaction/tests.rs`):

```rust
#[tokio::test]
async fn test_genesis_replay_protection() {
    // Setup: Create DB with genesis at version 0
    let tmpdir = TempDir::new().unwrap();
    let db = setup_db_with_genesis(&tmpdir);
    
    // Create a backup containing version 0
    let backup_dir = TempDir::new().unwrap();
    let backup = create_backup_from_version_0(&db, &backup_dir);
    
    // Attempt to restore over existing version 0
    let result = TransactionRestoreController::new(
        TransactionRestoreOpt {
            manifest_handle: backup.manifest_handle,
            replay_from_version: None,
            kv_only_replay: None,
        },
        GlobalRestoreOptions::default(),
        Arc::new(LocalStorage::new(backup_dir.path())),
        None,
        VerifyExecutionMode::NoVerify,
    )
    .run()
    .await;
    
    // Should fail with error about overwriting existing transactions
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("already contains"));
}
```

**Notes**

This vulnerability represents a fundamental breach of blockchain immutability guarantees. While the normal commit path through `pre_commit_validation` correctly prevents transaction replay, the restore path bypasses all such checks. The issue is particularly severe because genesis transactions are the foundation of the entire blockchain state, and their corruption invalidates all subsequent state transitions.

The vulnerability is exploitable in practice because:
1. The `aptos-db-tool` is deployed on production infrastructure for operational purposes
2. Backup/restore operations are common during disaster recovery
3. No authentication or authorization checks prevent misuse of the restore functionality
4. The corruption is immediate and affects critical consensus-related state

This finding highlights the importance of maintaining consistent validation across all code paths that modify persistent state, not just the primary transaction execution pipeline.

### Citations

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L230-239)
```rust
        let inner = TransactionRestoreBatchController::new(
            global_opt,
            storage,
            vec![opt.manifest_handle],
            None,
            replay_from_version,
            epoch_history,
            verify_execution_mode,
            None,
        );
```

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L309-312)
```rust
        let first_version = self.first_version.unwrap_or(
            self.confirm_or_save_frozen_subtrees(&mut loaded_chunk_stream)
                .await?,
        );
```

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L485-495)
```rust
                    // remove the txns that are before the global_first_version
                    if global_first_version > first_version {
                        let num_to_remove = (global_first_version - first_version) as usize;

                        txns.drain(..num_to_remove);
                        persisted_aux_info.drain(..num_to_remove);
                        txn_infos.drain(..num_to_remove);
                        event_vecs.drain(..num_to_remove);
                        write_sets.drain(..num_to_remove);
                        first_version = global_first_version;
                    }
```

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L507-517)
```rust
                        tokio::task::spawn_blocking(move || {
                            restore_handler.save_transactions(
                                first_version,
                                &txns_to_save,
                                &persisted_aux_info_to_save,
                                &txn_infos_to_save,
                                &event_vecs_to_save,
                                write_sets_to_save,
                            )
                        })
                        .await??;
```

**File:** storage/aptosdb/src/backup/restore_utils.rs (L206-213)
```rust
    for (idx, txn) in txns.iter().enumerate() {
        ledger_db.transaction_db().put_transaction(
            first_version + idx as Version,
            txn,
            /*skip_index=*/ false,
            &mut ledger_db_batch.transaction_db_batches,
        )?;
    }
```

**File:** storage/aptosdb/src/ledger_db/transaction_db.rs (L163-163)
```rust
        batch.put::<TransactionSchema>(&version, transaction)?;
```

**File:** execution/executor/src/db_bootstrapper/mod.rs (L115-205)
```rust
pub fn calculate_genesis<V: VMBlockExecutor>(
    db: &DbReaderWriter,
    ledger_summary: LedgerSummary,
    genesis_txn: &Transaction,
) -> Result<GenesisCommitter> {
    // DB bootstrapper works on either an empty transaction accumulator or an existing block chain.
    // In the very extreme and sad situation of losing quorum among validators, we refer to the
    // second use case said above.
    let genesis_version = ledger_summary.version().map_or(0, |v| v + 1);
    let base_state_view = CachedStateView::new(
        StateViewId::Miscellaneous,
        Arc::clone(&db.reader),
        ledger_summary.state.latest().clone(),
    )?;

    let epoch = if genesis_version == 0 {
        GENESIS_EPOCH
    } else {
        get_state_epoch(&base_state_view)?
    };

    let execution_output = DoGetExecutionOutput::by_transaction_execution::<V>(
        &V::new(),
        vec![genesis_txn.clone().into()].into(),
        // TODO(grao): Do we need any auxiliary info for hard fork? Not now, but maybe one day we
        // will need it.
        vec![AuxiliaryInfo::new_empty()],
        &ledger_summary.state,
        base_state_view,
        BlockExecutorConfigFromOnchain::new_no_block_limit(),
        TransactionSliceMetadata::unknown(),
    )?;
    ensure!(
        execution_output.num_transactions_to_commit() != 0,
        "Genesis txn execution failed."
    );
    ensure!(
        execution_output.next_epoch_state.is_some(),
        "Genesis txn didn't output reconfig event."
    );

    let output = ApplyExecutionOutput::run(execution_output, ledger_summary, db.reader.as_ref())?;
    let timestamp_usecs = if genesis_version == 0 {
        // TODO(aldenhu): fix existing tests before using real timestamp and check on-chain epoch.
        GENESIS_TIMESTAMP_USECS
    } else {
        let state_view = CachedStateView::new(
            StateViewId::Miscellaneous,
            Arc::clone(&db.reader),
            output.result_state().latest().clone(),
        )?;
        let next_epoch = epoch
            .checked_add(1)
            .ok_or_else(|| format_err!("integer overflow occurred"))?;
        ensure!(
            next_epoch == get_state_epoch(&state_view)?,
            "Genesis txn didn't bump epoch."
        );
        get_state_timestamp(&state_view)?
    };

    let ledger_info_with_sigs = LedgerInfoWithSignatures::new(
        LedgerInfo::new(
            BlockInfo::new(
                epoch,
                GENESIS_ROUND,
                genesis_block_id(),
                output
                    .ensure_ledger_update_output()?
                    .transaction_accumulator
                    .root_hash(),
                genesis_version,
                timestamp_usecs,
                output.execution_output.next_epoch_state.clone(),
            ),
            genesis_block_id(), /* consensus_data_hash */
        ),
        AggregateSignature::empty(), /* signatures */
    );
    let executed_chunk = ExecutedChunk {
        output,
        ledger_info_opt: Some(ledger_info_with_sigs),
    };

    let committer = GenesisCommitter::new(db.writer.clone(), executed_chunk)?;
    info!(
        "Genesis calculated: ledger_info_with_sigs {:?}, waypoint {:?}",
        &committer.output.ledger_info_opt, committer.waypoint,
    );
    Ok(committer)
}
```

**File:** storage/db-tool/src/restore.rs (L97-111)
```rust
                    Oneoff::Transaction {
                        storage,
                        opt,
                        global,
                    } => {
                        TransactionRestoreController::new(
                            opt,
                            global.try_into()?,
                            storage.init_storage().await?,
                            None, /* epoch_history */
                            VerifyExecutionMode::NoVerify,
                        )
                        .run()
                        .await?;
                    },
```
