# Audit Report

## Title
Protocol Mismatch Between Serialization and Transmission in Consensus Reliable Broadcast

## Summary
A race condition exists between protocol negotiation in `to_bytes_by_protocol()` and protocol selection in `send_to_peer_rpc_raw()`, which can cause messages to be sent with mismatched protocol IDs and serialization formats, leading to deserialization failures and consensus message delivery issues.

## Finding Description

The vulnerability exists in the reliable broadcast mechanism used by consensus. The issue involves two separate protocol lookups that can observe inconsistent peer metadata:

**First lookup** - In `to_bytes_by_protocol()`: [1](#0-0) 

The function groups peers by their preferred protocol and serializes the message once per protocol group. Each peer's protocol is determined by reading the cached peer metadata.

**Second lookup** - In `send_to_peer_rpc_raw()`: [2](#0-1) 

The function determines the protocol ID to attach to the RPC message by calling `get_preferred_protocol_for_peer()` again, which reads the cached peer metadata a second time.

**The race condition:**
Between these two reads, the cached peer metadata can be updated when a peer disconnects and reconnects: [3](#0-2) 

The cached metadata is stored using `ArcSwap`, which allows atomic updates but different calls to `load()` can observe different snapshots: [4](#0-3) 

**Exploitation scenario:**
1. Validator A calls `to_bytes_by_protocol([B, C, D], consensus_msg)` in reliable broadcast
2. At this time, peer B's preferred protocol is `ConsensusRpcCompressed` (protocol negotiated during current connection)
3. Message is serialized with compression: `protocol_id.to_bytes(&message)` produces compressed bytes
4. Peer B disconnects and immediately reconnects with different protocol preferences (e.g., due to configuration change or network upgrade)
5. The cached metadata is updated with B's new protocols, now preferring `ConsensusRpcBcs`
6. Validator A calls `send_rpc_raw(B, compressed_bytes, timeout)`
7. This reads peer metadata again and gets `ConsensusRpcBcs` as the preferred protocol
8. Message is sent with `protocol_id = ConsensusRpcBcs` but `bytes = compressed_bytes`
9. Peer B receives the message and attempts to deserialize: [5](#0-4) 
10. Since protocol_id is `ConsensusRpcBcs`, it uses `Encoding::Bcs` which calls `bcs_decode()` directly without decompression
11. Deserialization fails because the bytes are compressed but the protocol expects plain BCS

The reliable broadcast usage confirms this flow: [6](#0-5) 

## Impact Explanation

This vulnerability falls under **High Severity** per the Aptos bug bounty criteria as it causes:

1. **Validator node slowdowns**: Failed message deliveries require retries, causing delays in consensus message processing
2. **Significant protocol violations**: Messages are sent with incorrect protocol-to-encoding mappings, violating the protocol specification

The impact includes:
- **Consensus liveness degradation**: Critical messages (block proposals, votes, commit decisions) may fail to deliver, delaying consensus progress
- **Message delivery failures**: Affects all consensus messages sent via reliable broadcast including ProposalMsg, VoteMsg, CommitVote, and CommitDecision
- **Cascading retries**: Failed deliveries trigger the backoff retry mechanism, increasing network load and latency

While this doesn't directly violate consensus safety (no chain splits or double-spending), it breaks the **message delivery reliability** guarantee that consensus depends on, potentially causing temporary liveness failures.

## Likelihood Explanation

**Likelihood: Medium to Low**

The vulnerability requires specific conditions:
1. **Peer reconnection**: A peer must disconnect and reconnect during the window between `to_bytes_by_protocol()` and the actual message send
2. **Protocol preference change**: The reconnection must result in different protocol preferences (e.g., due to rolling upgrade, configuration change, or feature flag modification)
3. **Timing window**: The events must occur within the reliable broadcast execution timeframe

However, the likelihood increases during:
- **Rolling upgrades** when validators restart with different protocol configurations
- **Network instability** causing frequent peer reconnections
- **Configuration changes** affecting protocol preferences across the validator set

The time window is non-trivial since reliable broadcast processes messages asynchronously with backoff retries, creating multiple opportunities for the race to occur.

## Recommendation

**Solution: Capture protocol ID during serialization and use it consistently**

Modify `to_bytes_by_protocol()` to return both the serialized bytes AND the protocol ID used:

```rust
fn to_bytes_by_protocol(
    &self,
    peers: Vec<PeerNetworkId>,
    message: Message,
) -> anyhow::Result<HashMap<PeerNetworkId, (ProtocolId, Bytes)>> {
    let peers_per_protocol = self.group_peers_by_protocol(peers);
    let mut protocol_and_bytes_per_peer = HashMap::new();
    for (protocol_id, peers) in peers_per_protocol {
        let bytes: Bytes = protocol_id.to_bytes(&message)?.into();
        for peer in peers {
            protocol_and_bytes_per_peer.insert(peer, (protocol_id, bytes.clone()));
        }
    }
    Ok(protocol_and_bytes_per_peer)
}
```

Then modify `send_to_peer_rpc_raw()` to accept the protocol ID as a parameter instead of looking it up:

```rust
async fn send_to_peer_rpc_raw(
    &self,
    message: Bytes,
    protocol: ProtocolId,  // Accept protocol instead of looking up
    rpc_timeout: Duration,
    peer: PeerNetworkId,
) -> Result<Message, Error> {
    let network_sender = self.get_sender_for_network_id(&peer.network_id())?;
    Ok(network_sender
        .send_rpc_raw(peer.peer_id(), protocol, message, rpc_timeout)
        .await?)
}
```

Update reliable broadcast and all callers to use the protocol ID from serialization.

## Proof of Concept

```rust
// Proof of Concept - Demonstrates protocol mismatch scenario
// This would be integrated into consensus tests

#[tokio::test]
async fn test_protocol_mismatch_in_reliable_broadcast() {
    // Setup: Create two validators with network clients
    let (validator_a, validator_b) = setup_validators().await;
    
    // Step 1: Establish connection with B preferring ConsensusRpcCompressed
    let peers_and_metadata = validator_a.get_peers_and_metadata();
    peers_and_metadata.insert_connection_metadata(
        validator_b.peer_network_id(),
        create_connection_metadata_with_protocols(vec![
            ProtocolId::ConsensusRpcCompressed,
            ProtocolId::ConsensusRpcBcs,
        ])
    ).unwrap();
    
    // Step 2: Call to_bytes_by_protocol - serializes with compression
    let message = create_test_consensus_message();
    let peer_bytes = validator_a
        .consensus_network_client
        .to_bytes_by_protocol(vec![validator_b.peer_id()], message.clone())
        .unwrap();
    
    // Step 3: Simulate peer B reconnecting with different protocol preferences
    // (This would happen due to configuration change or network conditions)
    peers_and_metadata.insert_connection_metadata(
        validator_b.peer_network_id(),
        create_connection_metadata_with_protocols(vec![
            ProtocolId::ConsensusRpcBcs,  // Now prefers plain BCS
            ProtocolId::ConsensusRpcCompressed,
        ])
    ).unwrap();
    
    // Step 4: Attempt to send using pre-serialized bytes
    let result = validator_a
        .consensus_network_client
        .send_rpc_raw(
            validator_b.peer_id(),
            peer_bytes.get(&validator_b.peer_id()).unwrap().clone(),
            Duration::from_secs(5)
        )
        .await;
    
    // Expected: Deserialization fails because protocol ID (BCS) doesn't match
    // the serialization format (compressed BCS)
    assert!(result.is_err(), "Expected deserialization failure due to protocol mismatch");
    
    // Verify the error is related to deserialization
    let error_msg = format!("{:?}", result.unwrap_err());
    assert!(
        error_msg.contains("deserialize") || error_msg.contains("decompress"),
        "Error should indicate deserialization failure"
    );
}
```

## Notes

This vulnerability specifically affects the consensus layer's reliable broadcast mechanism, which is used for critical message types including block proposals, votes, and commit decisions. The race condition is most likely to manifest during:

1. **Rolling upgrades** when validators restart with updated protocol preferences
2. **Network partitions and recoveries** causing rapid reconnection cycles  
3. **Dynamic protocol feature enablement** via feature flags

The issue demonstrates a **Time-of-Check to Time-of-Use (TOCTOU)** race condition where peer metadata is checked twice with potential updates in between. The use of `ArcSwap` for the cached metadata provides atomicity for individual reads but does not guarantee consistency across multiple reads in the same logical operation.

While message delivery failures trigger retry mechanisms that may mask this issue under normal conditions, during periods of network instability or coordinated upgrades, the accumulation of failed deliveries could significantly impact consensus liveness and validator performance.

### Citations

**File:** network/framework/src/application/interface.rs (L274-286)
```rust
    async fn send_to_peer_rpc_raw(
        &self,
        message: Bytes,
        rpc_timeout: Duration,
        peer: PeerNetworkId,
    ) -> Result<Message, Error> {
        let network_sender = self.get_sender_for_network_id(&peer.network_id())?;
        let rpc_protocol_id =
            self.get_preferred_protocol_for_peer(&peer, &self.rpc_protocols_and_preferences)?;
        Ok(network_sender
            .send_rpc_raw(peer.peer_id(), rpc_protocol_id, message, rpc_timeout)
            .await?)
    }
```

**File:** network/framework/src/application/interface.rs (L288-304)
```rust
    fn to_bytes_by_protocol(
        &self,
        peers: Vec<PeerNetworkId>,
        message: Message,
    ) -> anyhow::Result<HashMap<PeerNetworkId, Bytes>> {
        let peers_per_protocol = self.group_peers_by_protocol(peers);
        // Convert to bytes per protocol
        let mut bytes_per_peer = HashMap::new();
        for (protocol_id, peers) in peers_per_protocol {
            let bytes: Bytes = protocol_id.to_bytes(&message)?.into();
            for peer in peers {
                bytes_per_peer.insert(peer, bytes.clone());
            }
        }

        Ok(bytes_per_peer)
    }
```

**File:** network/framework/src/application/storage.rs (L150-169)
```rust
    /// Returns the metadata for the specified peer
    pub fn get_metadata_for_peer(
        &self,
        peer_network_id: PeerNetworkId,
    ) -> Result<PeerMetadata, Error> {
        // Get the cached peers and metadata
        let cached_peers_and_metadata = self.cached_peers_and_metadata.load();

        // Fetch the peers and metadata for the given network
        let network_id = peer_network_id.network_id();
        let peer_metadata_for_network = cached_peers_and_metadata
            .get(&network_id)
            .ok_or_else(|| missing_network_metadata_error(&network_id))?;

        // Get the metadata for the peer
        peer_metadata_for_network
            .get(&peer_network_id.peer_id())
            .cloned()
            .ok_or_else(|| missing_peer_metadata_error(&peer_network_id))
    }
```

**File:** network/framework/src/application/storage.rs (L186-214)
```rust
    pub fn insert_connection_metadata(
        &self,
        peer_network_id: PeerNetworkId,
        connection_metadata: ConnectionMetadata,
    ) -> Result<(), Error> {
        // Grab the write lock for the peer metadata
        let mut peers_and_metadata = self.peers_and_metadata.write();

        // Fetch the peer metadata for the given network
        let peer_metadata_for_network =
            get_peer_metadata_for_network(&peer_network_id, &mut peers_and_metadata)?;

        // Update the metadata for the peer or insert a new entry
        peer_metadata_for_network
            .entry(peer_network_id.peer_id())
            .and_modify(|peer_metadata| {
                peer_metadata.connection_metadata = connection_metadata.clone()
            })
            .or_insert_with(|| PeerMetadata::new(connection_metadata.clone()));

        // Update the cached peers and metadata
        self.set_cached_peers_and_metadata(peers_and_metadata.clone());

        let event =
            ConnectionNotification::NewPeer(connection_metadata, peer_network_id.network_id());
        self.broadcast(event);

        Ok(())
    }
```

**File:** network/framework/src/protocols/wire/handshake/v1/mod.rs (L224-252)
```rust
    /// Deserializes the given bytes into a typed message (based on the
    /// protocol ID and encoding to use).
    pub fn from_bytes<T: DeserializeOwned>(&self, bytes: &[u8]) -> anyhow::Result<T> {
        // Start the deserialization timer
        let deserialization_timer = start_serialization_timer(*self, DESERIALIZATION_LABEL);

        // Deserialize the message
        let result = match self.encoding() {
            Encoding::Bcs(limit) => self.bcs_decode(bytes, limit),
            Encoding::CompressedBcs(limit) => {
                let compression_client = self.get_compression_client();
                let raw_bytes = aptos_compression::decompress(
                    &bytes.to_vec(),
                    compression_client,
                    MAX_APPLICATION_MESSAGE_SIZE,
                )
                .map_err(|e| anyhow! {"{:?}", e})?;
                self.bcs_decode(&raw_bytes, limit)
            },
            Encoding::Json => serde_json::from_slice(bytes).map_err(|e| anyhow!("{:?}", e)),
        };

        // Only record the duration if deserialization was successful
        if result.is_ok() {
            deserialization_timer.observe_duration();
        }

        result
    }
```

**File:** crates/reliable-broadcast/src/lib.rs (L127-156)
```rust
            let peers = receivers.clone();
            let sender = network_sender.clone();
            let message_clone = message.clone();
            let protocols = Arc::new(
                tokio::task::spawn_blocking(move || {
                    sender.to_bytes_by_protocol(peers, message_clone)
                })
                .await??,
            );

            let send_message = |receiver, sleep_duration: Option<Duration>| {
                let network_sender = network_sender.clone();
                let time_service = time_service.clone();
                let message = message.clone();
                let protocols = protocols.clone();
                async move {
                    if let Some(duration) = sleep_duration {
                        time_service.sleep(duration).await;
                    }
                    let send_fut = if receiver == self_author {
                        network_sender.send_rb_rpc(receiver, message, rpc_timeout_duration)
                    } else if let Some(raw_message) = protocols.get(&receiver).cloned() {
                        network_sender.send_rb_rpc_raw(receiver, raw_message, rpc_timeout_duration)
                    } else {
                        network_sender.send_rb_rpc(receiver, message, rpc_timeout_duration)
                    };
                    (receiver, send_fut.await)
                }
                .boxed()
            };
```
