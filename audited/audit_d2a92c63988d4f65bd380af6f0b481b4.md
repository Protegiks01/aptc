# Audit Report

## Title
DKG Share Forgery via Empty Chunk Vectors Enabling Zero Share Injection

## Summary
The `le_chunks_to_scalar()` function returns `F::zero()` when called with an empty chunks slice, and the transcript verification lacks explicit validation that chunk vectors are non-empty. This allows a malicious dealer to craft transcripts with empty ciphertext chunk vectors that pass verification but cause validators to decrypt shares as zero, potentially compromising DKG security.

## Finding Description

The vulnerability exists in the DKG (Distributed Key Generation) chunky PVSS implementation across multiple components:

**Root Cause**: The `le_chunks_to_scalar()` function in [1](#0-0)  initializes an accumulator to `F::zero()` and iterates through chunks. When the chunks slice is empty, the loop never executes and the function returns zero.

**Missing Validation**: The transcript verification in [2](#0-1)  only checks that the outer dimensions of `Cs` (ciphertext chunks) match expectations, but never validates that each individual `Cs[player_id][share_index]` vector contains the expected number of chunks.

**Attack Path**:

1. **Malicious Transcript Creation**: A compromised dealer creates a transcript where one or more `Cs[player_id][share_index]` vectors are empty (zero-length vectors).

2. **Verification Bypass**: During verification at [3](#0-2) , the code flattens `Cs` and iterates through chunks. For empty vectors, the inner loop `for j in 0..Cs_flat[i].len()` simply doesn't execute, skipping those positions without error.

3. **Share Decryption**: When a victim validator calls `decrypt_own_share()` at [4](#0-3) , if their `Cs[i]` is empty:
   - Line 351-355: The zip iterator produces an empty vector
   - Line 357-363: `bsgs::dlog_vec` returns an empty vector  
   - Line 365-369: Maps to empty scalar vector
   - Line 371-372: `le_chunks_to_scalar` is called with empty chunks, returning `F::zero()`
   - Line 374: This zero is stored as a "valid" secret key share

4. **Security Compromise**: The validator now possesses a forged zero share instead of their legitimate share. In threshold cryptography:
   - Zero shares don't contribute to secret reconstruction
   - Multiple zero shares can reduce the effective threshold below the security parameter
   - Attackers controlling dealer selection can strategically inject zero shares to enable threshold bypasses

**Invariant Violation**: This breaks the **Cryptographic Correctness** invariant - specifically that DKG must ensure all validators receive valid, unpredictable secret shares computed according to the threshold secret sharing scheme.

## Impact Explanation

**Severity: High**

This vulnerability falls under the **High Severity** category ($50,000) for "Significant protocol violations" because:

1. **DKG Compromise**: The DKG protocol is fundamental to Aptos validator set management and consensus security. Compromised DKG shares directly threaten validator key generation.

2. **Threshold Reduction**: By forcing multiple validators to have zero shares, an attacker can effectively reduce the reconstruction threshold. If the scheme requires `t` shares but `k` validators have zero shares, reconstruction becomes possible with only `t-k` legitimate shares.

3. **Determinism Break**: Different validators would decrypt different share values (some zero, some legitimate), but the inconsistency may not be immediately detected, potentially causing consensus issues during validator set transitions.

4. **Limited But Real Impact**: While this doesn't directly cause consensus safety violations or immediate fund loss, it undermines the security guarantees of the DKG protocol which is critical infrastructure for validator operations.

The impact doesn't reach **Critical** because:
- Requires a compromised dealer position (not completely unprivileged)
- Doesn't directly cause immediate fund theft or permanent network partition
- Detection may be possible through anomalous zero share values

## Likelihood Explanation

**Likelihood: Medium-High**

**Factors Increasing Likelihood**:
- The missing validation is a clear oversight - no explicit check exists for `Cs[i][j].len() == num_chunks_per_scalar`
- A malicious dealer has full control over transcript construction
- The verification code's complexity (PoK, range proofs, pairing checks) may mask the absence of this specific validation
- Empty vectors are valid Rust constructs that won't cause runtime panics

**Factors Decreasing Likelihood**:
- Requires compromising a validator to become a dealer in the DKG protocol
- The range proof and pairing checks may indirectly catch some malformed transcripts (requires further analysis to confirm full bypassing)
- Other validators might detect anomalous behavior if they compare share values or reconstruction fails

**Attacker Requirements**:
- Must be selected as a DKG dealer (requires validator status)
- Must craft transcripts with manipulated `Cs` structures
- Target selection: Can choose which validators receive zero shares

## Recommendation

**Add explicit validation** in the transcript verification to ensure all chunk vectors have the expected length:

```rust
// In weighted_transcript.rs, add after line 152:
let expected_chunks_per_scalar = num_chunks_per_scalar::<E::ScalarField>(pp.ell) as usize;
for (player_idx, player_cs) in self.subtrs.Cs.iter().enumerate() {
    let player_weight = sc.get_player_weight(&sc.get_player(player_idx));
    if player_cs.len() != player_weight {
        bail!(
            "Player {} expected {} share vectors, but got {}",
            player_idx, player_weight, player_cs.len()
        );
    }
    for (share_idx, chunks) in player_cs.iter().enumerate() {
        if chunks.len() != expected_chunks_per_scalar {
            bail!(
                "Player {} share {} expected {} chunks, but got {}",
                player_idx, share_idx, expected_chunks_per_scalar, chunks.len()
            );
        }
    }
}
```

**Additional Hardening**:
- Add a defensive check in `le_chunks_to_scalar()` to return an error instead of zero for empty inputs
- Add assertions during decryption that verify non-empty chunks before calling `le_chunks_to_scalar()`

## Proof of Concept

```rust
#[cfg(test)]
mod test_empty_chunks_vulnerability {
    use super::*;
    use ark_bls12_381::Fr;
    
    #[test]
    fn test_empty_chunks_returns_zero() {
        // Demonstrate that le_chunks_to_scalar returns F::zero() for empty input
        let empty_chunks: Vec<Fr> = vec![];
        let result = le_chunks_to_scalar(16, &empty_chunks);
        
        assert_eq!(result, Fr::zero(), 
            "Empty chunks should return zero, enabling share forgery");
        
        // This zero would be indistinguishable from a legitimate zero share
        // (which should be astronomically rare for random field elements)
        println!("VULNERABILITY CONFIRMED: Empty chunks produce zero share");
    }
    
    #[test] 
    fn test_legitimate_vs_forged_shares() {
        use ark_ff::UniformRand;
        let mut rng = ark_std::test_rng();
        
        // Legitimate share: random non-zero scalar chunked and reconstructed
        let legitimate_share = Fr::rand(&mut rng);
        let chunks = scalar_to_le_chunks(16, &legitimate_share);
        let reconstructed = le_chunks_to_scalar(16, &chunks);
        assert_eq!(legitimate_share, reconstructed);
        
        // Forged share: empty chunks produce zero
        let forged_share = le_chunks_to_scalar(16, &[]);
        assert_eq!(forged_share, Fr::zero());
        
        println!("Legitimate share: {:?}", legitimate_share);
        println!("Forged share (zero): {:?}", forged_share);
        println!("An attacker can force validators to receive zero shares");
    }
}
```

**Exploitation Steps**:
1. Attacker gains dealer position in DKG protocol
2. Constructs transcript with `Cs[target_player][share_idx] = vec![]` (empty vector)
3. Adjusts other transcript components to pass verification checks
4. Broadcasts transcript to validators
5. Target validator decrypts share, receives `F::zero()`  
6. Repeat for multiple validators to reduce effective threshold
7. Compromise reconstructed secret with fewer shares than intended

## Notes

This vulnerability specifically affects the chunky PVSS implementation used in Aptos DKG. Both `weighted_transcript.rs` and `weighted_transcriptv2.rs` variants are affected [5](#0-4) . The missing validation is systematic across the verification pipeline - while complex cryptographic proofs (PoK, range proofs, pairings) are verified, the basic structural constraint that chunk vectors must be non-empty is not explicitly checked.

### Citations

**File:** crates/aptos-dkg/src/pvss/chunky/chunks.rs (L32-48)
```rust
pub fn le_chunks_to_scalar<F: PrimeField>(num_bits: u8, chunks: &[F]) -> F {
    assert!(
        num_bits.is_multiple_of(8) && num_bits > 0 && num_bits <= 64, // TODO: so make num_bits a u8?
        "Invalid chunk size"
    );

    let base = F::from(1u128 << num_bits); // need u128 in the case where `num_bits` is 64, because of `chunk * multiplier`
    let mut acc = F::zero();
    let mut multiplier = F::one();

    for &chunk in chunks {
        acc += chunk * multiplier;
        multiplier *= base;
    }

    acc
}
```

**File:** crates/aptos-dkg/src/pvss/chunky/weighted_transcript.rs (L140-152)
```rust
        if self.subtrs.Cs.len() != sc.get_total_num_players() {
            bail!(
                "Expected {} arrays of chunked ciphertexts, but got {}",
                sc.get_total_num_players(),
                self.subtrs.Cs.len()
            );
        }
        if self.subtrs.Vs.len() != sc.get_total_num_players() {
            bail!(
                "Expected {} arrays of commitment elements, but got {}",
                sc.get_total_num_players(),
                self.subtrs.Vs.len()
            );
```

**File:** crates/aptos-dkg/src/pvss/chunky/weighted_transcript.rs (L247-262)
```rust
        let Cs_flat: Vec<_> = self.subtrs.Cs.iter().flatten().cloned().collect();
        assert_eq!(
            Cs_flat.len(),
            sc.get_total_weight(),
            "Number of ciphertexts does not equal number of weights"
        ); // TODO what if zero weight?
           // could add an assert_eq here with sc.get_total_weight()

        for i in 0..Cs_flat.len() {
            for j in 0..Cs_flat[i].len() {
                let base = Cs_flat[i][j];
                let exp = pp.powers_of_radix[j] * powers_of_beta[i];
                base_vec.push(base);
                exp_vec.push(exp);
            }
        }
```

**File:** crates/aptos-dkg/src/pvss/chunky/weighted_transcript.rs (L318-380)
```rust
    fn decrypt_own_share(
        &self,
        sc: &Self::SecretSharingConfig,
        player: &Player,
        dk: &Self::DecryptPrivKey,
        pp: &Self::PublicParameters,
    ) -> (Self::DealtSecretKeyShare, Self::DealtPubKeyShare) {
        let weight = sc.get_player_weight(player);

        let Cs = &self.Cs[player.id];

        // TODO: put an assert here saying that len(Cs) = weight

        let ephemeral_keys: Vec<_> = self
            .Rs
            .iter()
            .take(weight)
            .map(|R_i_vec| R_i_vec.iter().map(|R_i| R_i.mul(dk.dk)).collect::<Vec<_>>())
            .collect();

        if let Some(first_key) = ephemeral_keys.first() {
            debug_assert_eq!(
                first_key.len(),
                Cs[0].len(),
                "Number of ephemeral keys does not match the number of ciphertext chunks"
            );
        }

        let mut sk_shares: Vec<Scalar<E::ScalarField>> = Vec::with_capacity(weight);
        let pk_shares = self.get_public_key_share(sc, player);

        for i in 0..weight {
            // TODO: should really put this in a separate function
            let dealt_encrypted_secret_key_share_chunks: Vec<_> = Cs[i]
                .iter()
                .zip(ephemeral_keys[i].iter())
                .map(|(C_ij, ephemeral_key)| C_ij.sub(ephemeral_key))
                .collect();

            let dealt_chunked_secret_key_share = bsgs::dlog_vec(
                pp.pp_elgamal.G.into_group(),
                &dealt_encrypted_secret_key_share_chunks,
                &pp.table,
                pp.get_dlog_range_bound(),
            )
            .expect("BSGS dlog failed");

            let dealt_chunked_secret_key_share_fr: Vec<E::ScalarField> =
                dealt_chunked_secret_key_share
                    .iter()
                    .map(|&x| E::ScalarField::from(x))
                    .collect();

            let dealt_secret_key_share =
                chunks::le_chunks_to_scalar(pp.ell, &dealt_chunked_secret_key_share_fr);

            sk_shares.push(Scalar(dealt_secret_key_share));
        }

        (
            sk_shares, pk_shares, // TODO: review this formalism... why do we need this here?
        )
    }
```

**File:** crates/aptos-dkg/src/pvss/chunky/weighted_transcriptv2.rs (L870-893)
```rust
            let dealt_chunked_secret_key_share = bsgs::dlog_vec(
                pp.pp_elgamal.G.into_group(),
                &dealt_encrypted_secret_key_share_chunks,
                &pp.table,
                pp.get_dlog_range_bound(),
            )
            .expect("BSGS dlog failed");

            let dealt_chunked_secret_key_share_fr: Vec<E::ScalarField> =
                dealt_chunked_secret_key_share
                    .iter()
                    .map(|&x| E::ScalarField::from(x))
                    .collect();

            let dealt_secret_key_share =
                chunks::le_chunks_to_scalar(pp.ell, &dealt_chunked_secret_key_share_fr);

            sk_shares.push(Scalar(dealt_secret_key_share));
        }

        (
            sk_shares, pk_shares, // TODO: review this formalism... wh ydo we need this here?
        )
    }
```
