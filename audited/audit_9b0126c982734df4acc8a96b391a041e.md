# Audit Report

## Title
Database Corruption on Signal Interruption Due to Missing Recovery for Fresh Database State

## Summary
The aptos-debugger lacks signal handlers for SIGTERM/SIGINT, and when interrupted during database write operations on a fresh database, it can leave the database in a partially-committed state that cannot be automatically recovered, requiring manual deletion of the database directory.

## Finding Description

The aptos-debugger entry point does not install signal handlers for graceful shutdown: [1](#0-0) 

When database writes occur, the `calculate_and_commit_ledger_and_state_kv` function spawns **seven parallel tasks** that independently write to different database components: [2](#0-1) 

Note the TODO comment on lines 272-273 acknowledging this issue: "Write progress for each of the following databases, and handle the inconsistency at the startup time."

The commit process follows a two-phase pattern through `save_transactions`: [3](#0-2) 

The critical vulnerability occurs when:

1. **Fresh database** (no prior `OverallCommitProgress` marker)
2. User runs a command like `Bootstrap --commit` which writes genesis data
3. During `pre_commit_ledger`, the seven parallel tasks begin writing independently
4. **SIGTERM/SIGINT sent** - process immediately terminates
5. Some parallel RocksDB write operations complete (with `sync=true`, they are durable), others don't
6. `commit_ledger` never executes, so `OverallCommitProgress` is never written
7. Database now has **inconsistent partial data** across different column families

The recovery mechanism `sync_commit_progress` is designed to truncate inconsistent data: [4](#0-3) 

However, it **fails to recover** when no `OverallCommitProgress` exists. Lines 417-420 show that if `get_synced_version()` returns `None`, the function simply logs "No overall commit progress was found!" (line 500) and returns **without performing any truncation**. The partial data remains in the database.

**Invariant Violation:** This breaks the **State Consistency** invariant: "State transitions must be atomic and verifiable via Merkle proofs." Different database components (events, transactions, state KV, etc.) become desynchronized, with some containing data for versions that don't exist in others.

## Impact Explanation

This is a **Medium Severity** issue per Aptos bug bounty criteria: "State inconsistencies requiring intervention."

**Impact:**
- Database becomes unusable - subsequent commands or node startup will fail when encountering inconsistent state
- No automatic recovery mechanism exists for this scenario
- Requires manual intervention: user must delete the entire database directory and restart from scratch
- Data loss of any work performed before the interruption
- Potential for operators to waste significant time debugging the inconsistent state before realizing manual repair is needed

This does not rise to High or Critical severity because:
- No funds are at risk (debugger tool, not production node)
- No consensus safety violation
- No network-wide impact
- Recovery is possible through manual intervention

## Likelihood Explanation

**Likelihood: Medium to High**

This is likely to occur because:

1. **Common operator action:** Sending SIGTERM/SIGINT is a standard way to stop long-running processes
2. **Long execution windows:** Genesis commits and database operations can take significant time, providing a large window for interruption
3. **No protection:** The code has zero signal handling or graceful shutdown logic
4. **Affects multiple commands:** Bootstrap, restore operations, and other database-modifying commands are vulnerable
5. **Fresh database scenarios are common:** Initial setup, testing, development environments frequently start with fresh databases

The TODO comment in the code confirms developers are aware of this inconsistency risk but haven't implemented the handling.

## Recommendation

Implement proper signal handling and two-phase commit recovery:

**1. Add signal handlers to main.rs:**
```rust
#[tokio::main]
async fn main() -> Result<()> {
    Logger::new().level(Level::Info).init();
    let _mp = MetricsPusher::start(vec![]);

    // Install signal handlers
    let ctrl_c = tokio::signal::ctrl_c();
    
    tokio::select! {
        result = Cmd::parse().run() => result,
        _ = ctrl_c => {
            eprintln!("Received interrupt signal, shutting down gracefully...");
            Err(anyhow::anyhow!("Interrupted by signal"))
        }
    }
}
```

**2. Fix sync_commit_progress to handle fresh databases:**

In `storage/aptosdb/src/state_store/mod.rs`, modify `sync_commit_progress` to truncate partial data even when no `OverallCommitProgress` exists: [5](#0-4) 

Add logic to detect and truncate partial writes in fresh databases by checking if any component has data but no overall progress exists.

**3. Implement atomic write coordination:**

As suggested by the TODO comment, write per-component progress markers before each parallel write, allowing recovery to detect which components need truncation.

## Proof of Concept

```bash
# Step 1: Create a fresh database directory
mkdir -p /tmp/test_aptos_db

# Step 2: Start bootstrap in background
aptos-debugger AptosDb Bootstrap \
  --db-dir /tmp/test_aptos_db \
  --genesis-txn-file genesis.blob \
  --waypoint-to-verify <WAYPOINT> \
  --commit &

DEBUGGER_PID=$!

# Step 3: Wait for parallel writes to start (adjust timing as needed)
sleep 2

# Step 4: Kill the process mid-execution
kill -TERM $DEBUGGER_PID

# Step 5: Verify database corruption
# Try to use the database - this will fail with inconsistent state
aptos-debugger AptosDb Bootstrap \
  --db-dir /tmp/test_aptos_db \
  --genesis-txn-file genesis.blob \
  --waypoint-to-verify <WAYPOINT>
# Expected: Fails due to inconsistent DB state

# Step 6: Verify sync_commit_progress doesn't recover
# Check logs - will show "No overall commit progress was found!"
# Database remains corrupted

# Required manual repair:
rm -rf /tmp/test_aptos_db
# Must recreate database from scratch
```

**Expected Results:**
- Database contains partial data in some column families but not others
- No `OverallCommitProgress` marker exists
- `sync_commit_progress` logs "No overall commit progress was found!" and exits without recovery
- Subsequent operations fail due to inconsistent state
- Only manual deletion and recreation resolves the issue

### Citations

**File:** crates/aptos-debugger/src/main.rs (L14-19)
```rust
#[tokio::main]
async fn main() -> Result<()> {
    Logger::new().level(Level::Info).init();
    let _mp = MetricsPusher::start(vec![]);

    Cmd::parse().run().await
```

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L263-322)
```rust
    fn calculate_and_commit_ledger_and_state_kv(
        &self,
        chunk: &ChunkToCommit,
        skip_index_and_usage: bool,
    ) -> Result<HashValue> {
        let _timer = OTHER_TIMERS_SECONDS.timer_with(&["save_transactions__work"]);

        let mut new_root_hash = HashValue::zero();
        THREAD_MANAGER.get_non_exe_cpu_pool().scope(|s| {
            // TODO(grao): Write progress for each of the following databases, and handle the
            // inconsistency at the startup time.
            //
            // TODO(grao): Consider propagating the error instead of panic, if necessary.
            s.spawn(|_| {
                self.commit_events(
                    chunk.first_version,
                    chunk.transaction_outputs,
                    skip_index_and_usage,
                )
                .unwrap()
            });
            s.spawn(|_| {
                self.ledger_db
                    .write_set_db()
                    .commit_write_sets(chunk.first_version, chunk.transaction_outputs)
                    .unwrap()
            });
            s.spawn(|_| {
                self.ledger_db
                    .transaction_db()
                    .commit_transactions(
                        chunk.first_version,
                        chunk.transactions,
                        skip_index_and_usage,
                    )
                    .unwrap()
            });
            s.spawn(|_| {
                self.ledger_db
                    .persisted_auxiliary_info_db()
                    .commit_auxiliary_info(chunk.first_version, chunk.persisted_auxiliary_infos)
                    .unwrap()
            });
            s.spawn(|_| {
                self.commit_state_kv_and_ledger_metadata(chunk, skip_index_and_usage)
                    .unwrap()
            });
            s.spawn(|_| {
                self.commit_transaction_infos(chunk.first_version, chunk.transaction_infos)
                    .unwrap()
            });
            s.spawn(|_| {
                new_root_hash = self
                    .commit_transaction_accumulator(chunk.first_version, chunk.transaction_infos)
                    .unwrap()
            });
        });

        Ok(new_root_hash)
    }
```

**File:** storage/storage-interface/src/lib.rs (L608-628)
```rust
    fn save_transactions(
        &self,
        chunk: ChunkToCommit,
        ledger_info_with_sigs: Option<&LedgerInfoWithSignatures>,
        sync_commit: bool,
    ) -> Result<()> {
        // For reconfig suffix.
        if ledger_info_with_sigs.is_none() && chunk.is_empty() {
            return Ok(());
        }

        if !chunk.is_empty() {
            self.pre_commit_ledger(chunk.clone(), sync_commit)?;
        }
        let version_to_commit = if let Some(ledger_info_with_sigs) = ledger_info_with_sigs {
            ledger_info_with_sigs.ledger_info().version()
        } else {
            chunk.expect_last_version()
        };
        self.commit_ledger(version_to_commit, ledger_info_with_sigs, Some(chunk))
    }
```

**File:** storage/aptosdb/src/state_store/mod.rs (L410-502)
```rust
    pub fn sync_commit_progress(
        ledger_db: Arc<LedgerDb>,
        state_kv_db: Arc<StateKvDb>,
        state_merkle_db: Arc<StateMerkleDb>,
        crash_if_difference_is_too_large: bool,
    ) {
        let ledger_metadata_db = ledger_db.metadata_db();
        if let Some(overall_commit_progress) = ledger_metadata_db
            .get_synced_version()
            .expect("DB read failed.")
        {
            info!(
                overall_commit_progress = overall_commit_progress,
                "Start syncing databases..."
            );
            let ledger_commit_progress = ledger_metadata_db
                .get_ledger_commit_progress()
                .expect("Failed to read ledger commit progress.");
            assert_ge!(ledger_commit_progress, overall_commit_progress);

            let state_kv_commit_progress = state_kv_db
                .metadata_db()
                .get::<DbMetadataSchema>(&DbMetadataKey::StateKvCommitProgress)
                .expect("Failed to read state K/V commit progress.")
                .expect("State K/V commit progress cannot be None.")
                .expect_version();
            assert_ge!(state_kv_commit_progress, overall_commit_progress);

            // LedgerCommitProgress was not guaranteed to commit after all ledger changes finish,
            // have to attempt truncating every column family.
            info!(
                ledger_commit_progress = ledger_commit_progress,
                "Attempt ledger truncation...",
            );
            let difference = ledger_commit_progress - overall_commit_progress;
            if crash_if_difference_is_too_large {
                assert_le!(difference, MAX_COMMIT_PROGRESS_DIFFERENCE);
            }
            truncate_ledger_db(ledger_db.clone(), overall_commit_progress)
                .expect("Failed to truncate ledger db.");

            // State K/V commit progress isn't (can't be) written atomically with the data,
            // because there are shards, so we have to attempt truncation anyway.
            info!(
                state_kv_commit_progress = state_kv_commit_progress,
                "Start state KV truncation..."
            );
            let difference = state_kv_commit_progress - overall_commit_progress;
            if crash_if_difference_is_too_large {
                assert_le!(difference, MAX_COMMIT_PROGRESS_DIFFERENCE);
            }
            truncate_state_kv_db(
                &state_kv_db,
                state_kv_commit_progress,
                overall_commit_progress,
                std::cmp::max(difference as usize, 1), /* batch_size */
            )
            .expect("Failed to truncate state K/V db.");

            let state_merkle_max_version = get_max_version_in_state_merkle_db(&state_merkle_db)
                .expect("Failed to get state merkle max version.")
                .expect("State merkle max version cannot be None.");
            if state_merkle_max_version > overall_commit_progress {
                let difference = state_merkle_max_version - overall_commit_progress;
                if crash_if_difference_is_too_large {
                    assert_le!(difference, MAX_COMMIT_PROGRESS_DIFFERENCE);
                }
            }
            let state_merkle_target_version = find_tree_root_at_or_before(
                ledger_metadata_db,
                &state_merkle_db,
                overall_commit_progress,
            )
            .expect("DB read failed.")
            .unwrap_or_else(|| {
                panic!(
                    "Could not find a valid root before or at version {}, maybe it was pruned?",
                    overall_commit_progress
                )
            });
            if state_merkle_target_version < state_merkle_max_version {
                info!(
                    state_merkle_max_version = state_merkle_max_version,
                    target_version = state_merkle_target_version,
                    "Start state merkle truncation..."
                );
                truncate_state_merkle_db(&state_merkle_db, state_merkle_target_version)
                    .expect("Failed to truncate state merkle db.");
            }
        } else {
            info!("No overall commit progress was found!");
        }
    }
```
