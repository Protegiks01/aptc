# Audit Report

## Title
Missing Version Monotonicity Check in Commit Vote Signing Enables Ledger Rollback Attacks

## Summary
The `sign_commit_vote()` function in SafetyRules lacks validation to ensure that `new_ledger_info.version()` is greater than or equal to `old_ledger_info.version()`, violating the critical invariant of ledger version monotonicity. This allows validators to sign commit votes for states with regressed version numbers, potentially enabling blockchain rollback attacks.

## Finding Description

The `guarded_sign_commit_vote()` implementation contains insufficient validation of ledger version ordering. [1](#0-0) 

The function performs these checks:

1. **Ordered-only validation**: Verifies that `old_ledger_info` is either ordered-only (dummy execution state) or matches `new_ledger_info` exactly [2](#0-1) 

2. **Match ordered-only check**: Verifies epoch, round, and id match between old and new ledger info [3](#0-2) 

3. **Signature verification**: Validates that the old ledger info has sufficient validator signatures [4](#0-3) 

**Critical Gap**: The `match_ordered_only()` method only checks epoch, round, and block id equality, but does NOT verify version ordering. [5](#0-4) 

The ledger version field represents the transaction count and must be monotonically increasing. [6](#0-5) 

A TODO comment explicitly acknowledges this missing validation: [7](#0-6) 

**Attack Scenario**:
1. Attacker constructs `new_ledger_info` with same epoch, round, and id as legitimate `ordered_ledger_info`
2. Sets `new_ledger_info.version()` to value LESS than current committed ledger version
3. Sets `executed_state_id` to correspond to older blockchain state
4. Provides valid `ordered_ledger_info` (with version=0 per ordered-only convention) and malicious `new_ledger_info` to `sign_commit_vote()`
5. All validation passes because version is never checked
6. Validator signs the rollback state
7. With sufficient signatures (2f+1), forms valid commit certificate for regressed state

## Impact Explanation

**Critical Severity** - This vulnerability violates fundamental consensus safety guarantees:

1. **Ledger Monotonicity Violation**: Breaks the core invariant that ledger versions must strictly increase, which is foundational to blockchain integrity

2. **State Rollback Attacks**: Enables committing blockchain states with lower version numbers, effectively rolling back transaction history

3. **Double-Spending Risk**: If state rolls back to before certain transactions executed, those transactions could be re-spent or altered

4. **Consensus Safety Break**: Violates AptosBFT safety guarantees by allowing validators to commit divergent states

5. **Network Partition**: Nodes that accept the rollback diverge from nodes that reject it, potentially causing permanent chain split requiring hard fork

This meets the **Critical Severity** criteria per Aptos Bug Bounty: "Consensus/Safety violations" and "Non-recoverable network partition (requires hardfork)".

## Likelihood Explanation

**Medium-High Likelihood** due to:

1. **Missing Defense-in-Depth**: SafetyRules is the last line of defense for consensus safety. Even if upstream validation exists, safety rules MUST enforce all invariants independently

2. **Acknowledged Gap**: The TODO comment confirms developers know this check is missing, indicating it's a real vulnerability, not theoretical

3. **Complex Attack Path**: While direct exploitation requires malicious validator behavior or bugs in upstream ledger info construction, the missing validation creates systemic risk

4. **Potential Trigger Scenarios**:
   - Bugs in buffer manager or execution pipeline constructing invalid ledger infos
   - Memory corruption affecting ledger info data structures  
   - Race conditions in concurrent consensus operations
   - Other undiscovered vulnerabilities in upstream components

The vulnerability is exploitable if ANY component in the consensus pipeline constructs ledger infos incorrectly, or if a validator is compromised.

## Recommendation

Add explicit version monotonicity validation in `guarded_sign_commit_vote()`:

```rust
fn guarded_sign_commit_vote(
    &mut self,
    ledger_info: LedgerInfoWithSignatures,
    new_ledger_info: LedgerInfo,
) -> Result<bls12381::Signature, Error> {
    self.signer()?;

    let old_ledger_info = ledger_info.ledger_info();

    // Existing checks...
    if !old_ledger_info.commit_info().is_ordered_only()
        && old_ledger_info.commit_info() != new_ledger_info.commit_info()
    {
        return Err(Error::InvalidOrderedLedgerInfo(old_ledger_info.to_string()));
    }

    if !old_ledger_info
        .commit_info()
        .match_ordered_only(new_ledger_info.commit_info())
    {
        return Err(Error::InconsistentExecutionResult(
            old_ledger_info.commit_info().to_string(),
            new_ledger_info.commit_info().to_string(),
        ));
    }

    // **ADD THIS CHECK**
    // Verify version monotonicity: new version must be >= old version
    // Exception: when old is ordered-only (version=0), new should be > 0
    if !old_ledger_info.commit_info().is_ordered_only() {
        if new_ledger_info.version() < old_ledger_info.version() {
            return Err(Error::InvalidLedgerInfo(format!(
                "Version regression: new version {} < old version {}",
                new_ledger_info.version(),
                old_ledger_info.version()
            )));
        }
    }

    // Verify accumulator extension proof to ensure state properly extends
    // TODO: Implement full accumulator extension validation

    // Existing signature verification...
    if !self.skip_sig_verify {
        ledger_info
            .verify_signatures(&self.epoch_state()?.verifier)
            .map_err(|error| Error::InvalidQuorumCertificate(error.to_string()))?;
    }

    let signature = self.sign(&new_ledger_info)?;
    Ok(signature)
}
```

Additionally, implement the TODO'd extension check by verifying the transaction accumulator properly extends from old to new state, similar to how voting validates extensions. [8](#0-7) 

## Proof of Concept

```rust
// Test case demonstrating the vulnerability
#[test]
fn test_sign_commit_vote_version_regression() {
    let (mut safety_rules, signer) = make_safety_rules();
    let (proof, genesis_qc) = test_utils::make_genesis(&signer);
    safety_rules.initialize(&proof).unwrap();

    // Create legitimate block chain
    let round = genesis_qc.certified_block().round();
    let a1 = test_utils::make_proposal_with_qc(round + 1, genesis_qc, &signer);
    let a2 = make_proposal_with_parent(round + 2, &a1, None, &signer);
    let a3 = make_proposal_with_parent(round + 3, &a2, Some(&a1), &signer);

    // Get ordered ledger info for a1 (version=0, dummy state)
    let ordered_ledger_info = a3.block().quorum_cert().ledger_info();
    
    // Create malicious new_ledger_info with REGRESSED version
    // Attacker sets version to 50 instead of proper value (e.g., 100)
    let malicious_ledger_info = LedgerInfo::new(
        BlockInfo::new(
            ordered_ledger_info.ledger_info().epoch(),
            ordered_ledger_info.ledger_info().round(),
            ordered_ledger_info.ledger_info().consensus_block_id(),
            HashValue::random(), // Different executed state (rollback state)
            50, // REGRESSED VERSION (should be 100+)
            ordered_ledger_info.ledger_info().timestamp_usecs(),
            None,
        ),
        ordered_ledger_info.ledger_info().consensus_data_hash(),
    );

    // BUG: This succeeds when it SHOULD fail due to version regression
    let result = safety_rules.sign_commit_vote(
        ordered_ledger_info.clone(),
        malicious_ledger_info,
    );
    
    // Currently passes (VULNERABLE)
    assert!(result.is_ok());
    
    // After fix, should fail with version monotonicity error
    // assert!(matches!(result.unwrap_err(), Error::InvalidLedgerInfo(_)));
}
```

**Notes**

This vulnerability exists in the core consensus safety rules layer, which should enforce ALL safety invariants as the last line of defense. The missing version monotonicity check, combined with the explicit TODO comment about missing extension validation, represents a critical gap in consensus safety guarantees. While exploitation requires specific conditions (malicious validator, upstream bugs, or state corruption), defense-in-depth principles mandate that SafetyRules must independently validate all safety-critical invariants including ledger version monotonicity.

### Citations

**File:** consensus/safety-rules/src/safety_rules.rs (L372-418)
```rust
    fn guarded_sign_commit_vote(
        &mut self,
        ledger_info: LedgerInfoWithSignatures,
        new_ledger_info: LedgerInfo,
    ) -> Result<bls12381::Signature, Error> {
        self.signer()?;

        let old_ledger_info = ledger_info.ledger_info();

        if !old_ledger_info.commit_info().is_ordered_only()
            // When doing fast forward sync, we pull the latest blocks and quorum certs from peers
            // and store them in storage. We then compute the root ordered cert and root commit cert
            // from storage and start the consensus from there. But given that we are not storing the
            // ordered cert obtained from order votes in storage, instead of obtaining the root ordered cert
            // from storage, we set root ordered cert to commit certificate.
            // This means, the root ordered cert will not have a dummy executed_state_id in this case.
            // To handle this, we do not raise error if the old_ledger_info.commit_info() matches with
            // new_ledger_info.commit_info().
            && old_ledger_info.commit_info() != new_ledger_info.commit_info()
        {
            return Err(Error::InvalidOrderedLedgerInfo(old_ledger_info.to_string()));
        }

        if !old_ledger_info
            .commit_info()
            .match_ordered_only(new_ledger_info.commit_info())
        {
            return Err(Error::InconsistentExecutionResult(
                old_ledger_info.commit_info().to_string(),
                new_ledger_info.commit_info().to_string(),
            ));
        }

        // Verify that ledger_info contains at least 2f + 1 dostinct signatures
        if !self.skip_sig_verify {
            ledger_info
                .verify_signatures(&self.epoch_state()?.verifier)
                .map_err(|error| Error::InvalidQuorumCertificate(error.to_string()))?;
        }

        // TODO: add guarding rules in unhappy path
        // TODO: add extension check

        let signature = self.sign(&new_ledger_info)?;

        Ok(signature)
    }
```

**File:** types/src/block_info.rs (L38-39)
```rust
    /// The version of the latest transaction after executing this block.
    version: Version,
```

**File:** types/src/block_info.rs (L196-204)
```rust
    pub fn match_ordered_only(&self, executed_block_info: &BlockInfo) -> bool {
        self.epoch == executed_block_info.epoch
            && self.round == executed_block_info.round
            && self.id == executed_block_info.id
            && (self.timestamp_usecs == executed_block_info.timestamp_usecs
            // executed block info has changed its timestamp because it's a reconfiguration suffix
                || (self.timestamp_usecs > executed_block_info.timestamp_usecs
                    && executed_block_info.has_reconfiguration()))
    }
```

**File:** consensus/consensus-types/src/vote_proposal.rs (L93-98)
```rust
            let new_tree = self.accumulator_extension_proof().verify(
                proposed_block
                    .quorum_cert()
                    .certified_block()
                    .executed_state_id(),
            )?;
```
