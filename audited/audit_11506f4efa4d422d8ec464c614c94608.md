# Audit Report

## Title
Resource Exhaustion via Maximum-Sized Transactions Bypassing Early Validation

## Summary

The `PostSizeLimitEndpoint::call()` middleware performs only header-based size validation (Content-Length ≤ 8MB) without early transaction viability checks. Attackers can exploit this by flooding the API with maximum-sized BCS-encoded transactions that pass size validation but are designed to fail VM validation (e.g., insufficient gas balance, invalid sequence numbers), wasting substantial validator resources on network I/O, memory allocation, deserialization, and expensive VM prologue execution.

## Finding Description

The vulnerability exists in the transaction submission pipeline where resource consumption precedes meaningful validation: [1](#0-0) 

The middleware only validates the Content-Length header value against the configured limit (default 8MB). If this check passes, the request proceeds to the inner endpoint without any transaction-level validation. [2](#0-1) 

The full attack flow:

1. **Header Check (Cheap)**: PostSizeLimit validates Content-Length ≤ 8MB
2. **Payload Read (Expensive)**: Poem framework reads entire payload into memory
3. **Deserialization (Expensive)**: BCS deserialization with depth limit [3](#0-2) 

4. **Mempool Submission**: Transaction forwarded to mempool [4](#0-3) 

5. **State Access (Expensive)**: Mempool fetches account sequence numbers from state [5](#0-4) 

6. **VM Validation (Very Expensive)**: Full prologue execution including gas parameter checks and balance verification [6](#0-5) 

If VM validation fails (e.g., `INSUFFICIENT_BALANCE_FOR_TRANSACTION_FEE`, `SEQUENCE_NUMBER_TOO_OLD`), all resources consumed in steps 2-6 are wasted.

**Attack Scenario:**
An attacker crafts BCS-encoded `SignedTransaction` payloads that:
- Are syntactically valid (pass BCS deserialization)
- Are maximum size (~8MB) to maximize resource waste
- Contain invalid transaction parameters guaranteed to fail VM validation:
  - Gas unit price exceeding account balance
  - Incorrect sequence numbers
  - Invalid entry function signatures

The attacker floods the `/transactions` endpoint with these payloads in parallel.

## Impact Explanation

**Severity: Medium to High**

This breaks the **Resource Limits** invariant: "All operations must respect gas, storage, and computational limits."

Per Aptos bug bounty criteria:
- **High Severity**: "Validator node slowdowns" - Sustained attacks can degrade validator performance
- **Medium Severity**: "State inconsistencies requiring intervention" - Resource exhaustion may require node restarts

**Resource Consumption per Attack Transaction:**
- Network: Up to 8MB bandwidth
- Memory: 8MB raw payload + deserialized structures
- CPU: BCS deserialization + state DB reads + VM prologue execution
- Concurrency: Bounded executor task slots in mempool [7](#0-6) 

**Amplification Factor:**
An attacker sending 100 concurrent 8MB requests consumes:
- 800MB network bandwidth
- 800MB+ memory
- Hundreds of DB state reads
- 100 VM validation sessions

This can significantly degrade validator API responsiveness, delaying legitimate transaction submissions and potentially impacting consensus participation if the validator's resources become severely constrained.

## Likelihood Explanation

**Likelihood: High**

- **Attack Complexity**: Low - requires only HTTP client capable of sending POST requests
- **Attacker Requirements**: None - no authentication, stake, or privileged access needed
- **Detection Difficulty**: Medium - appears as legitimate traffic until VM validation fails
- **Exploitability**: Trivial - can be scripted in any language with HTTP support

The attack is economically viable because:
1. Attacker pays no gas fees (transactions rejected pre-execution)
2. Cost to attacker: Only network bandwidth
3. Cost to validator: CPU, memory, state DB access, bounded executor slots

## Recommendation

Implement **early transaction viability checks** before consuming full payload resources:

```rust
// In PostSizeLimitEndpoint::call()
async fn call(&self, req: Request) -> Result<Self::Output> {
    if req.method() != Method::POST {
        return self.inner.call(req).await;
    }

    let content_length = req
        .headers()
        .typed_get::<headers::ContentLength>()
        .ok_or(SizedLimitError::MissingContentLength)?;

    if content_length.0 > self.max_size {
        return Err(SizedLimitError::PayloadTooLarge.into());
    }

    // NEW: Add rate limiting per IP/sender before reading body
    // NEW: Consider reducing max_size for transaction submissions (e.g., 1MB)
    
    self.inner.call(req).await
}
```

**Additional Mitigations:**

1. **Reduce Maximum Transaction Size**: Lower `DEFAULT_REQUEST_CONTENT_LENGTH_LIMIT` from 8MB to 1-2MB for transaction submissions. Legitimate transactions rarely exceed 100KB. [2](#0-1) 

2. **Implement Sender-Based Rate Limiting**: Track and limit requests per sender address before full payload processing

3. **Early Balance Validation**: Add optional pre-check for sender account balance against max gas before full VM validation

4. **Streaming Validation**: Perform BCS deserialization in streaming fashion with early rejection on invalid structure

## Proof of Concept

```rust
// PoC: Flood API with maximum-sized invalid transactions
use reqwest;
use aptos_types::transaction::{SignedTransaction, RawTransaction, TransactionPayload};
use bcs;

#[tokio::main]
async fn main() {
    let client = reqwest::Client::new();
    let api_url = "http://localhost:8080/v1/transactions";
    
    // Craft transaction with invalid parameters
    let mut invalid_txn = create_invalid_transaction();
    
    // Pad transaction to approach 8MB limit
    let mut txn_bytes = bcs::to_bytes(&invalid_txn).unwrap();
    txn_bytes.resize(8_000_000, 0xFF); // Padding
    
    // Send 100 concurrent requests
    let mut handles = vec![];
    for _ in 0..100 {
        let client = client.clone();
        let url = api_url.to_string();
        let body = txn_bytes.clone();
        
        handles.push(tokio::spawn(async move {
            client.post(&url)
                .header("Content-Type", "application/x.aptos.signed_transaction+bcs")
                .body(body)
                .send()
                .await
        }));
    }
    
    for handle in handles {
        handle.await.unwrap();
    }
    
    println!("Attack complete - validator consumed 800MB+ resources validating invalid txns");
}

fn create_invalid_transaction() -> SignedTransaction {
    // Transaction with insufficient gas balance, wrong sequence number, etc.
    // Details omitted for brevity - would create syntactically valid but VM-invalid txn
    unimplemented!()
}
```

**Expected Behavior**: Validator node API processes all 100 requests, consuming ~800MB memory and significant CPU before rejecting each at VM validation stage.

**Notes**
- This vulnerability is exacerbated by the lack of sender authentication at the API layer
- The bounded executor in mempool provides some protection but can still be overwhelmed
- Real-world exploitation would likely combine this with other denial-of-service vectors for maximum impact

### Citations

**File:** api/src/check_size.rs (L43-58)
```rust
    async fn call(&self, req: Request) -> Result<Self::Output> {
        if req.method() != Method::POST {
            return self.inner.call(req).await;
        }

        let content_length = req
            .headers()
            .typed_get::<headers::ContentLength>()
            .ok_or(SizedLimitError::MissingContentLength)?;

        if content_length.0 > self.max_size {
            return Err(SizedLimitError::PayloadTooLarge.into());
        }

        self.inner.call(req).await
    }
```

**File:** config/src/config/api_config.rs (L97-97)
```rust
const DEFAULT_REQUEST_CONTENT_LENGTH_LIMIT: u64 = 8 * 1024 * 1024; // 8 MB
```

**File:** api/src/transactions.rs (L1224-1224)
```rust
                    bcs::from_bytes_with_limit(&data.0, Self::MAX_SIGNED_TRANSACTION_DEPTH)
```

**File:** api/src/transactions.rs (L1439-1446)
```rust
        let (mempool_status, vm_status_opt) = self
            .context
            .submit_transaction(txn)
            .await
            .context("Mempool failed to initially evaluate submitted transaction")
            .map_err(|err| {
                aptos_api_types::AptosError::new_with_error_code(err, AptosErrorCode::InternalError)
            })?;
```

**File:** mempool/src/shared_mempool/tasks.rs (L335-350)
```rust
    let account_seq_numbers = IO_POOL.install(|| {
        transactions
            .par_iter()
            .map(|(t, _, _)| match t.replay_protector() {
                ReplayProtector::Nonce(_) => Ok(None),
                ReplayProtector::SequenceNumber(_) => {
                    get_account_sequence_number(&state_view, t.sender())
                        .map(Some)
                        .inspect_err(|e| {
                            error!(LogSchema::new(LogEntry::DBError).error(e));
                            counters::DB_ERROR.inc();
                        })
                },
            })
            .collect::<Vec<_>>()
    });
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L3250-3278)
```rust
        let vm_params = match self.gas_params(&log_context) {
            Ok(vm_params) => vm_params.vm.clone(),
            Err(err) => {
                return VMValidatorResult::new(Some(err.status_code()), 0);
            },
        };
        let storage_gas_params = match self.storage_gas_params(&log_context) {
            Ok(storage_params) => storage_params.clone(),
            Err(err) => {
                return VMValidatorResult::new(Some(err.status_code()), 0);
            },
        };

        let initial_balance = if self.features().is_account_abstraction_enabled()
            || self.features().is_derivable_account_abstraction_enabled()
        {
            vm_params.txn.max_aa_gas.min(txn_data.max_gas_amount())
        } else {
            txn_data.max_gas_amount()
        };

        let mut gas_meter = make_prod_gas_meter(
            self.gas_feature_version(),
            vm_params,
            storage_gas_params,
            is_approved_gov_script,
            initial_balance,
            &NoopBlockSynchronizationKillSwitch {},
        );
```

**File:** mempool/src/shared_mempool/coordinator.rs (L189-196)
```rust
            bounded_executor
                .spawn(tasks::process_client_transaction_submission(
                    smp.clone(),
                    txn,
                    callback,
                    task_start_timer,
                ))
                .await;
```
