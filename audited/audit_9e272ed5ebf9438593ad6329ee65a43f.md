# Audit Report

## Title
IPv4/IPv6 Dual-Stack Bypass Vulnerability in Aptos Faucet IP-Based Security Controls

## Summary
The Aptos Faucet's IP range manager maintains separate lists for IPv4 and IPv6 addresses without performing IPv4-mapped IPv6 normalization. This allows attackers to bypass IP blocklists and rate limits by switching between IPv4 and IPv6 protocols in dual-stack network environments, potentially leading to resource exhaustion and unauthorized access to faucet funds.

## Finding Description

The vulnerability exists in the `IpRangeManager` implementation, which maintains two completely separate IP range lists—one for IPv4 and one for IPv6. [1](#0-0) 

The `contains_ip()` function checks IPv4 addresses only against the IPv4 list and IPv6 addresses only against the IPv6 list, with no cross-protocol normalization or IPv4-mapped IPv6 address handling: [2](#0-1) 

This design flaw propagates through multiple critical security components:

**1. IP Blocklist Checker:** The blocklist checker directly accesses the separate IPv4 and IPv6 lists without any cross-protocol validation. [3](#0-2) 

**2. Memory-Based Rate Limiter:** The rate limiter uses the source IP address directly as a key in an LRU cache, treating IPv4 and IPv6 addresses from the same host as completely independent entities. [4](#0-3) 

**3. Redis-Based Rate Limiter:** When using IP-based rate limiting, the Redis implementation converts the source IP to a string key without normalization. [5](#0-4) 

**Attack Scenario:**

1. An attacker's IP address (e.g., `203.0.113.50`) is added to the blocklist or exhausts their daily rate limit
2. The attacker connects to the faucet via IPv6 (e.g., `2001:db8::32`) from the same dual-stack host
3. The faucet extracts the source IP from the request headers [6](#0-5) 
4. Security checks pass because:
   - Blocklist contains only IPv4 ranges; IPv6 list is empty
   - Rate limit counters are separate for IPv4 and IPv6 addresses
5. The attacker successfully bypasses all IP-based security controls

This is particularly exploitable because:
- Modern internet infrastructure increasingly supports dual-stack (IPv4 + IPv6) connectivity
- IPv4-mapped IPv6 addresses (e.g., `::ffff:192.0.2.1`) are not normalized to their IPv4 equivalents
- The codebase has no IPv4-mapped IPv6 conversion logic anywhere in the network address handling

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos Bug Bounty program criteria:

1. **API Crashes:** Bypassing rate limits enables resource exhaustion attacks that can crash or severely degrade the faucet API service, affecting all legitimate users trying to obtain testnet tokens.

2. **Significant Protocol Violations:** The faucet's IP-based security controls (blocklists and rate limits) are fundamental protocol-level protections. Bypassing these controls violates the intended security model and allows:
   - Circumventing abuse prevention mechanisms
   - Draining faucet funds beyond intended limits
   - Denial of service through request flooding
   - Bypassing manual abuse mitigation (IP blocklisting)

3. **Resource Exhaustion:** Attackers can multiply their effective rate limits by the number of IP protocol versions they have access to (typically 2x for dual-stack), leading to faster fund depletion and increased infrastructure costs.

While this does not directly affect blockchain consensus or validator operations, the faucet is critical infrastructure for the Aptos testnet ecosystem, and its compromise impacts developer onboarding and testing capabilities.

## Likelihood Explanation

**Likelihood: HIGH**

- **Exploitability:** Trivial. No special tools or skills required—attackers simply need dual-stack network connectivity, which is increasingly common.
- **Attack Complexity:** Low. Attackers can alternate between IPv4 and IPv6 connections using standard network configuration.
- **Prerequisites:** Only requires dual-stack internet access, which is available from most modern ISPs, cloud providers, and VPN services.
- **Detection Difficulty:** Moderate. Without proper logging correlation, each IP version appears as a separate client.
- **Real-World Prevalence:** Dual-stack deployments are the recommended standard per IETF RFC 6555 and are widely deployed.

The vulnerability is actively exploitable in any environment where:
- The faucet is deployed on a dual-stack server (listens on both IPv4 and IPv6)
- Blocklists contain only IPv4 or only IPv6 ranges (not both)
- Attackers have access to both IPv4 and IPv6 connectivity

## Recommendation

Implement IPv4-mapped IPv6 address normalization and unified IP range checking:

**Fix 1: Normalize IPv4-mapped IPv6 addresses to IPv4**

```rust
impl IpRangeManager {
    // Add normalization helper
    fn normalize_ip(ip: &IpAddr) -> IpAddr {
        match ip {
            IpAddr::V6(ipv6) => {
                // Check if this is an IPv4-mapped IPv6 address (::ffff:0:0/96)
                if let Some(ipv4) = ipv6.to_ipv4_mapped() {
                    IpAddr::V4(ipv4)
                } else {
                    *ip
                }
            },
            _ => *ip,
        }
    }

    pub fn contains_ip(&self, ip: &IpAddr) -> bool {
        let normalized_ip = Self::normalize_ip(ip);
        match normalized_ip {
            IpAddr::V4(ipv4) => self.ipv4_list.contains(&ipv4),
            IpAddr::V6(ipv6) => self.ipv6_list.contains(&ipv6),
        }
    }
}
```

**Fix 2: Add dual-stack support for rate limiting**

For rate limiters, consider hashing the client's IP in a way that treats dual-stack hosts as the same entity:

```rust
// In RatelimitKeyProvider::ratelimit_key_value
RatelimitKeyProvider::Ip => {
    let normalized_ip = normalize_ip(&data.source_ip);
    Ok(normalized_ip.to_string())
}
```

**Fix 3: Documentation and operational guidance**

- Document that blocklist files should contain both IPv4 and IPv6 ranges for the same hosts
- Provide tooling to convert IPv4 ranges to their IPv4-mapped IPv6 equivalents automatically
- Log both the original and normalized IP addresses for forensic analysis

## Proof of Concept

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};
    use std::fs::write;
    use tempfile::NamedTempFile;

    #[test]
    fn test_ipv4_ipv6_bypass_vulnerability() {
        // Create a blocklist with only IPv4 ranges
        let blocklist_file = NamedTempFile::new().unwrap();
        write(blocklist_file.path(), "192.0.2.0/24\n").unwrap();
        
        let config = IpRangeManagerConfig {
            file: blocklist_file.path().to_path_buf(),
        };
        let manager = IpRangeManager::new(config).unwrap();
        
        // IPv4 address is blocked
        let ipv4_blocked = IpAddr::V4(Ipv4Addr::new(192, 0, 2, 50));
        assert!(manager.contains_ip(&ipv4_blocked), "IPv4 should be blocked");
        
        // Same host via IPv6 bypasses the blocklist!
        let ipv6_same_host = IpAddr::V6(Ipv6Addr::new(0x2001, 0xdb8, 0, 0, 0, 0, 0, 0x32));
        assert!(!manager.contains_ip(&ipv6_same_host), 
            "VULNERABILITY: IPv6 from same host bypasses IPv4 blocklist");
        
        // IPv4-mapped IPv6 address also bypasses!
        let ipv4_mapped = IpAddr::V6(
            Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc000, 0x232) // ::ffff:192.0.2.50
        );
        assert!(!manager.contains_ip(&ipv4_mapped),
            "VULNERABILITY: IPv4-mapped IPv6 address bypasses IPv4 blocklist");
    }
    
    #[tokio::test]
    async fn test_rate_limit_bypass() {
        use crate::checkers::{CheckerTrait, CheckerData};
        use std::sync::Arc;
        use poem::http::HeaderMap;
        
        let config = MemoryRatelimitCheckerConfig {
            max_requests_per_day: 1,
            max_entries_in_map: NonZeroUsize::new(1000).unwrap(),
        };
        let checker = MemoryRatelimitChecker::new(config);
        
        let ipv4 = IpAddr::V4(Ipv4Addr::new(203, 0, 113, 50));
        let ipv6 = IpAddr::V6(Ipv6Addr::new(0x2001, 0xdb8, 0, 0, 0, 0, 0, 0x32));
        
        let receiver = AccountAddress::from_hex_literal("0x1").unwrap();
        
        // First request via IPv4 - allowed
        let data_ipv4_1 = CheckerData {
            receiver,
            source_ip: ipv4,
            headers: Arc::new(HeaderMap::new()),
            time_request_received_secs: 1000,
        };
        assert!(checker.check(data_ipv4_1, false).await.unwrap().is_empty());
        
        // Second request via IPv4 - rate limited
        let data_ipv4_2 = CheckerData {
            receiver,
            source_ip: ipv4,
            headers: Arc::new(HeaderMap::new()),
            time_request_received_secs: 1001,
        };
        assert!(!checker.check(data_ipv4_2, false).await.unwrap().is_empty());
        
        // Request via IPv6 from same host - BYPASSES rate limit!
        let data_ipv6 = CheckerData {
            receiver,
            source_ip: ipv6,
            headers: Arc::new(HeaderMap::new()),
            time_request_received_secs: 1002,
        };
        assert!(checker.check(data_ipv6, false).await.unwrap().is_empty(),
            "VULNERABILITY: IPv6 bypasses IPv4 rate limit");
    }
}
```

**Notes:**

- This vulnerability is a classic dual-stack security oversight that affects IP-based security controls across the faucet infrastructure.
- The issue does not affect blockchain consensus, validator operations, or Move VM execution—it is isolated to the faucet service.
- Modern deployment environments increasingly use dual-stack configurations, making this exploit practical and likely to occur in the wild.
- The fix requires both code changes and operational procedures to ensure blocklists cover both protocol versions for each malicious actor.

### Citations

**File:** crates/aptos-faucet/core/src/common/ip_range_manager.rs (L18-21)
```rust
pub struct IpRangeManager {
    pub ipv4_list: IpRange<Ipv4Net>,
    pub ipv6_list: IpRange<Ipv6Net>,
}
```

**File:** crates/aptos-faucet/core/src/common/ip_range_manager.rs (L55-60)
```rust
    pub fn contains_ip(&self, ip: &IpAddr) -> bool {
        match ip {
            IpAddr::V4(ipv4) => self.ipv4_list.contains(ipv4),
            IpAddr::V6(ipv6) => self.ipv6_list.contains(ipv6),
        }
    }
```

**File:** crates/aptos-faucet/core/src/checkers/ip_blocklist.rs (L32-49)
```rust
        match &data.source_ip {
            IpAddr::V4(source_ip) => {
                if self.manager.ipv4_list.contains(source_ip) {
                    return Ok(vec![RejectionReason::new(
                        format!("IP {} is in blocklist", source_ip),
                        RejectionReasonCode::IpInBlocklist,
                    )]);
                }
            },
            IpAddr::V6(source_ip) => {
                if self.manager.ipv6_list.contains(source_ip) {
                    return Ok(vec![RejectionReason::new(
                        format!("IP {} is in blocklist", source_ip),
                        RejectionReasonCode::IpInBlocklist,
                    )]);
                }
            },
        }
```

**File:** crates/aptos-faucet/core/src/checkers/memory_ratelimit.rs (L77-88)
```rust
        let requests_today = ip_to_requests_today.get_or_insert_mut(data.source_ip, || 1);
        if *requests_today >= self.max_requests_per_day {
            return Ok(vec![RejectionReason::new(
                format!(
                    "IP {} has exceeded the daily limit of {} requests",
                    data.source_ip, self.max_requests_per_day
                ),
                RejectionReasonCode::UsageLimitExhausted,
            )]);
        } else if !dry_run {
            *requests_today += 1;
        }
```

**File:** crates/aptos-faucet/core/src/checkers/redis_ratelimit.rs (L44-51)
```rust
    pub async fn ratelimit_key_value(&self, data: &CheckerData) -> Result<String, AptosTapError> {
        match self {
            RatelimitKeyProvider::Ip => Ok(data.source_ip.to_string()),
            RatelimitKeyProvider::Jwt(jwt_verifier) => {
                jwt_verifier.validate_jwt(data.headers.clone()).await
            },
        }
    }
```

**File:** crates/aptos-faucet/core/src/endpoints/fund.rs (L217-225)
```rust
        let source_ip = match source_ip.0 {
            Some(ip) => ip,
            None => {
                return Err(AptosTapError::new(
                    "No source IP found in the request".to_string(),
                    AptosTapErrorCode::SourceIpMissing,
                ))
            },
        };
```
