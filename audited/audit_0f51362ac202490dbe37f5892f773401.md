# Audit Report

## Title
Resource Storage Type Confusion Vulnerability When SAFER_RESOURCE_GROUPS Feature Flag is Disabled

## Summary
When the `SAFER_RESOURCE_GROUPS` feature flag is disabled, module upgraders can add `#[resource_group_member]` attributes to existing resource structs, causing previously stored resource data to become permanently inaccessible due to storage key mismatch between `Path::Resource` and `Path::ResourceGroup` variants.

## Finding Description

The Aptos VM uses module metadata to determine whether a resource should be accessed as a standalone resource or as a member of a resource group. This routing decision happens in the `StorageAdapter::get_any_resource_with_layout` method: [1](#0-0) 

When `get_resource_group_member_from_metadata()` returns a group tag, the VM creates a `StateKey::resource_group()` key. Otherwise, it creates a `StateKey::resource()` key. These produce different storage keys because the `Path` enum variant is included in BCS serialization: [2](#0-1) 

The critical vulnerability exists in the module upgrade validation logic: [3](#0-2) 

When `SAFER_RESOURCE_GROUPS` is disabled (line 167), the validation returns early (line 168), bypassing the checks that prevent adding `resource_group_member` attributes to existing structs (lines 182-186).

**Attack Scenario:**
1. Attacker deploys module with `struct Token has key { balance: u64 }` (no resource_group_member attribute)
2. Users call `move_to()` to store Token instances
   - Storage key: `StateKey::resource(user_addr, Token)` → BCS serialization includes `Path::Resource(Token)`
3. Attacker upgrades module to add `#[resource_group_member(group = 0xATTACKER::M::Group)]` to Token
4. When users try to access their Token:
   - VM reads metadata, finds resource_group_member attribute
   - VM creates `StateKey::resource_group(user_addr, Group)` → BCS serialization includes `Path::ResourceGroup(Group)`
   - This is a **different storage key** than the original
   - VM attempts to read from the group and fails to find the Token
5. Original Token data remains at the old storage key but is **permanently inaccessible**

The test suite explicitly demonstrates this unsafe upgrade is allowed when the flag is disabled: [4](#0-3) 

## Impact Explanation

**Severity: Critical** (up to $1,000,000 per Aptos Bug Bounty)

This vulnerability meets multiple critical impact categories:

1. **Permanent Freezing of Funds**: If resource structs hold tokens or other valuable assets, they become permanently inaccessible without a hardfork to manually migrate data between storage keys.

2. **State Consistency Violation**: Breaks the fundamental invariant that "State transitions must be atomic and verifiable via Merkle proofs." Resources exist in storage but are unreachable through normal execution paths.

3. **Deterministic Execution Failure**: If different nodes have different metadata caching behavior, they could disagree on whether to use `Path::Resource` vs `Path::ResourceGroup`, causing consensus splits.

## Likelihood Explanation

**Current Likelihood: Low** (mitigated by default)

The `SAFER_RESOURCE_GROUPS` feature flag is enabled by default: [5](#0-4) 

**However**, this vulnerability becomes exploitable if:
1. Governance disables the feature flag through an on-chain proposal
2. Private networks or testnets operate without this protection
3. The flag was not enabled in earlier network versions

The attack requires only:
- Ability to publish/upgrade Move modules (standard capability)
- No validator access or collusion needed
- Single malicious actor can affect all users of their module

## Recommendation

The current mitigation (SAFER_RESOURCE_GROUPS flag) is correct but insufficient. The feature flag should be **permanently enforced** and removed as a configurable option.

**Recommended fix:**

```rust
// In aptos-move/aptos-vm/src/verifier/resource_groups.rs
// Remove the conditional check at line 167-169 and ALWAYS enforce the validation:

// Before (vulnerable):
if !features.is_enabled(FeatureFlag::SAFER_RESOURCE_GROUPS) {
    return Ok((new_groups, new_members));
}

// After (secure):
// Remove the above conditional entirely, always validate

for group in new_groups.keys() {
    if structs.remove(group) {
        metadata_validation_err("Invalid addition of resource_group attribute")?;
    }
}

for member in new_members.keys() {
    if structs.remove(member) {
        metadata_validation_err("Invalid addition of resource_group_member attribute")?;
    }
}
```

Additionally, mark `SAFER_RESOURCE_GROUPS` as permanently enabled and non-disableable, similar to other rolled-out features: [6](#0-5) 

## Proof of Concept

```move
// Initial module deployment
module 0xVULN::attack {
    struct UserToken has key {
        balance: u64
    }
    
    public entry fun mint(account: &signer) {
        move_to(account, UserToken { balance: 1000 });
    }
    
    public fun read_balance(addr: address): u64 acquires UserToken {
        borrow_global<UserToken>(addr).balance
    }
}

// Users store tokens:
// Storage key: StateKey::resource(user_addr, 0xVULN::attack::UserToken)

// Malicious upgrade (when SAFER_RESOURCE_GROUPS disabled):
module 0xVULN::attack {
    #[resource_group(scope = global)]
    struct TokenGroup {}
    
    #[resource_group_member(group = 0xVULN::attack::TokenGroup)]
    struct UserToken has key {
        balance: u64
    }
    
    public fun read_balance(addr: address): u64 acquires UserToken {
        // VM now tries to read from:
        // StateKey::resource_group(addr, TokenGroup) 
        // -> Not found! Original data orphaned at old key
        borrow_global<UserToken>(addr).balance  // FAILS
    }
}
```

**Rust test to verify vulnerability:** [4](#0-3) 

## Notes

This is a **known vulnerability** that has been mitigated by the `SAFER_RESOURCE_GROUPS` feature flag, which is enabled by default in current versions. However, the vulnerability remains exploitable if governance disables this protection, representing a latent critical risk. The recommended fix is to make this validation permanent and non-bypassable.

### Citations

**File:** aptos-move/aptos-vm/src/data_cache.rs (L98-129)
```rust
    fn get_any_resource_with_layout(
        &self,
        address: &AccountAddress,
        struct_tag: &StructTag,
        metadata: &[Metadata],
        maybe_layout: Option<&MoveTypeLayout>,
    ) -> PartialVMResult<(Option<Bytes>, usize)> {
        let resource_group = get_resource_group_member_from_metadata(struct_tag, metadata);
        if let Some(resource_group) = resource_group {
            let key = StateKey::resource_group(address, &resource_group);
            let buf =
                self.resource_group_view
                    .get_resource_from_group(&key, struct_tag, maybe_layout)?;

            let first_access = self.accessed_groups.borrow_mut().insert(key.clone());
            let group_size = if first_access {
                self.resource_group_view.resource_group_size(&key)?.get()
            } else {
                0
            };

            let buf_size = resource_size(&buf);
            Ok((buf, buf_size + group_size as usize))
        } else {
            let state_key = resource_state_key(address, struct_tag)?;
            let buf = self
                .executor_view
                .get_resource_bytes(&state_key, maybe_layout)?;
            let buf_size = resource_size(&buf);
            Ok((buf, buf_size))
        }
    }
```

**File:** types/src/access_path.rs (L76-82)
```rust
#[derive(Clone, Debug, Eq, PartialEq, Hash, Serialize, Deserialize, Ord, PartialOrd)]
#[cfg_attr(any(test, feature = "fuzzing"), derive(Arbitrary))]
pub enum Path {
    Code(ModuleId),
    Resource(StructTag),
    ResourceGroup(StructTag),
}
```

**File:** aptos-move/aptos-vm/src/verifier/resource_groups.rs (L167-188)
```rust
    if !features.is_enabled(FeatureFlag::SAFER_RESOURCE_GROUPS) {
        return Ok((new_groups, new_members));
    }

    // At this point, only original structs that do not have resource group affiliation are left.
    // Note, we do not validate for being both a member and a group, because there are other
    // checks earlier on, such as, a resource group must have no abilities, while a resource group
    // member must.

    for group in new_groups.keys() {
        if structs.remove(group) {
            metadata_validation_err("Invalid addition of resource_group attribute")?;
        }
    }

    for member in new_members.keys() {
        if structs.remove(member) {
            metadata_validation_err("Invalid addition of resource_group_member attribute")?;
        }
    }

    Ok((new_groups, new_members))
```

**File:** aptos-move/e2e-move-tests/src/tests/resource_groups.rs (L473-507)
```rust
#[test]
fn verify_unsafe_resource_group_member_upgrades() {
    let mut h = MoveHarness::new_with_features(vec![], vec![FeatureFlag::SAFER_RESOURCE_GROUPS]);
    let account = h.new_account_at(AccountAddress::from_hex_literal("0xf00d").unwrap());

    // Initial code
    let source = r#"
        module 0xf00d::M {
            struct NotResourceGroupMember has key { }

            #[resource_group(scope = address)]
            struct ResourceGroup { }
        }
        "#;
    let mut builder = PackageBuilder::new("Package");
    builder.add_source("m.move", source);
    let path = builder.write_to_temp().unwrap();
    let result = h.publish_package(&account, path.path());
    assert_success!(result);

    // Incompatible addition of ResourceGroupMember
    let source = r#"
        module 0xf00d::M {
            #[resource_group_member(group = 0xf00d::M::ResourceGroup)]
            struct NotResourceGroupMember has key { }

            #[resource_group(scope = address)]
            struct ResourceGroup { }
        }
        "#;
    let mut builder = PackageBuilder::new("Package");
    builder.add_source("m.move", source);
    let path = builder.write_to_temp().unwrap();
    let result = h.publish_package(&account, path.path());
    assert_success!(result);
```

**File:** types/src/on_chain_config/aptos_features.rs (L79-80)
```rust
    /// Enabled on mainnet, can never be disabled.
    _REJECT_UNSTABLE_BYTECODE = 58,
```

**File:** types/src/on_chain_config/aptos_features.rs (L205-205)
```rust
            FeatureFlag::SAFER_RESOURCE_GROUPS,
```
