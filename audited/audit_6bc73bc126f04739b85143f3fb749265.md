# Audit Report

## Title
Panic on Pruned Version Request in Indexer gRPC Fullnode Service

## Summary
The `get_transactions_from_node()` function in the indexer-grpc-fullnode service does not validate whether the requested `starting_version` has been pruned before processing. When a client requests transactions from a pruned version, the service panics after exhausting retries instead of returning a graceful error response, causing connection failures and log flooding.

## Finding Description

When a client sends a `GetTransactionsFromNodeRequest` with a `starting_version` pointing to a pruned ledger version, the request handler accepts it without validation. [1](#0-0) 

The request spawns a tokio task that creates an `IndexerStreamCoordinator` with the unchecked `starting_version`. [2](#0-1) 

When processing the batch, the coordinator calls `fetch_raw_txns_with_retries()` which attempts to fetch transactions from storage. [3](#0-2) 

The database layer correctly detects the pruned version and returns an error via `error_if_ledger_pruned()`. [4](#0-3) 

However, instead of propagating this error gracefully, `fetch_raw_txns_with_retries()` retries 3 times (with 300ms delays) and then **panics** with the error message. [5](#0-4) 

This breaks the client's gRPC stream connection and fills service logs with panic messages. The service has access to methods like `get_first_viable_block()` to check the oldest available version, but never validates the request upfront. [6](#0-5) 

## Impact Explanation

This qualifies as **Medium Severity** per the Aptos bug bounty program:
- **State inconsistencies requiring intervention**: While this doesn't affect blockchain state, it causes operational issues requiring manual intervention to diagnose panic logs and identify client misconfigurations
- **API crashes**: Individual client connections experience unexpected task panics instead of receiving proper error responses

The vulnerability enables:
1. **Denial of Service for individual clients**: Any client requesting pruned versions experiences connection failure
2. **Log pollution**: Repeated panic messages flood service logs, obscuring legitimate errors
3. **Operational overhead**: Operators must manually investigate panic alerts that should be normal error conditions
4. **Poor client experience**: Clients receive no actionable error message indicating the version range is unavailable

The ping endpoint does not expose `oldest_ledger_version`, preventing clients from pre-validating their requests. [7](#0-6) 

## Likelihood Explanation

**High Likelihood** - This issue occurs in common operational scenarios:

1. **Pruning is standard practice**: Nodes typically configure ledger pruning (e.g., 90M version window) to manage storage costs
2. **Client reconnection after downtime**: When indexer clients reconnect after extended downtime, they naturally request versions that have since been pruned
3. **New indexer bootstrap**: Indexers attempting to sync from genesis will always hit pruned versions on established networks
4. **No proactive validation mechanism**: The service provides no endpoint to query available version ranges before requesting

The pruning threshold is determined by `ledger_pruner.get_min_readable_version()`, and any request below this threshold triggers the panic. [8](#0-7) 

## Recommendation

Add validation at the request entry point to check if `starting_version` is within the available range:

```rust
async fn get_transactions_from_node(
    &self,
    req: Request<GetTransactionsFromNodeRequest>,
) -> Result<Response<Self::GetTransactionsFromNodeStream>, Status> {
    let r = req.into_inner();
    let starting_version = match r.starting_version {
        Some(version) => version,
        None => return Err(Status::invalid_argument("Starting version must be set")),
    };
    
    // ADD THIS VALIDATION:
    let (oldest_version, _) = self
        .service_context
        .context
        .db
        .get_first_viable_block()
        .map_err(|e| Status::internal(format!("Failed to get oldest version: {}", e)))?;
    
    if starting_version < oldest_version {
        return Err(Status::out_of_range(
            format!(
                "Starting version {} is pruned. Minimum available version is {}",
                starting_version, oldest_version
            )
        ));
    }
    
    // Continue with existing logic...
}
```

Additionally, enhance the `PingFullnodeResponse` to include `oldest_ledger_version` so clients can discover the valid version range before making requests.

## Proof of Concept

```rust
#[tokio::test]
async fn test_pruned_version_request_panics() {
    // Setup: Create a fullnode service with pruned ledger data
    // Assume ledger has versions 90_000_000 to 100_000_000 (older versions pruned)
    
    let service = setup_fullnode_service_with_pruning(90_000_000);
    
    // Create request for pruned version
    let request = GetTransactionsFromNodeRequest {
        starting_version: Some(0), // Version 0 is pruned
        transactions_count: Some(1000),
    };
    
    // Send request - this will cause the spawned task to panic
    let response = service.get_transactions_from_node(Request::new(request)).await;
    
    // The response stream is created successfully, but the spawned task panics
    // when attempting to fetch transactions from pruned storage
    assert!(response.is_ok());
    
    let mut stream = response.unwrap().into_inner();
    
    // The stream will be broken due to the panic in the spawned task
    // Expected: Should receive Status::out_of_range error instead
    // Actual: Connection breaks after panic in fetch_raw_txns_with_retries()
    
    // Monitor logs for panic message:
    // "Could not fetch 1000 transactions after 3 retries, starting at 0: 
    //  Transaction at version 0 is pruned, min available version is 90000000"
}
```

**Notes**

This vulnerability is isolated to the indexer-grpc-fullnode service and does not affect core consensus, execution, or state management. However, it represents a significant operational issue for production deployments where indexers depend on reliable gRPC access to blockchain data. The panic-on-error pattern violates Rust best practices and standard gRPC error handling conventions, where recoverable errors should return proper `Status` codes rather than crashing execution contexts.

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/fullnode_data_service.rs (L67-78)
```rust
    async fn get_transactions_from_node(
        &self,
        req: Request<GetTransactionsFromNodeRequest>,
    ) -> Result<Response<Self::GetTransactionsFromNodeStream>, Status> {
        // Gets configs for the stream, partly from the request and partly from the node config
        let r = req.into_inner();
        let starting_version = match r.starting_version {
            Some(version) => version,
            // Live mode unavailable for FullnodeDataService
            // Enable use_data_service_interface in config to use LocalnetDataService instead
            None => return Err(Status::invalid_argument("Starting version must be set")),
        };
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/fullnode_data_service.rs (L101-117)
```rust
        tokio::spawn(async move {
            // Initialize the coordinator that tracks starting version and processes transactions
            let mut coordinator = IndexerStreamCoordinator::new(
                context,
                starting_version,
                ending_version,
                processor_task_count,
                processor_batch_size,
                output_batch_size,
                tx.clone(),
                // For now the request for this interface doesn't include a txn filter
                // because it is only used for the txn stream filestore worker, which
                // needs every transaction. Later we may add support for txn filtering
                // to this interface too.
                None,
                Some(abort_handle.clone()),
            );
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/fullnode_data_service.rs (L207-242)
```rust
    async fn ping(
        &self,
        _request: Request<PingFullnodeRequest>,
    ) -> Result<Response<PingFullnodeResponse>, Status> {
        let timestamp = timestamp_now_proto();
        let known_latest_version = self
            .service_context
            .context
            .db
            .get_synced_version()
            .map_err(|e| Status::internal(format!("{e}")))?;

        let table_info_version = self
            .service_context
            .context
            .indexer_reader
            .as_ref()
            .and_then(|r| r.get_latest_table_info_ledger_version().ok().flatten());

        if known_latest_version.is_some() && table_info_version.is_some() {
            let version = std::cmp::min(known_latest_version.unwrap(), table_info_version.unwrap());
            if let Ok(timestamp_us) = self.service_context.context.db.get_block_timestamp(version) {
                let latency = SystemTime::now().duration_since(UNIX_EPOCH).unwrap()
                    - Duration::from_micros(timestamp_us);
                LATENCY_MS.set(latency.as_millis() as i64);
            }
        }

        let info = FullnodeInfo {
            chain_id: self.service_context.context.chain_id().id() as u64,
            timestamp: Some(timestamp),
            known_latest_version,
        };
        let response = PingFullnodeResponse { info: Some(info) };
        Ok(Response::new(response))
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/stream_coordinator.rs (L320-360)
```rust
    pub async fn fetch_raw_txns_with_retries(
        context: Arc<Context>,
        ledger_version: u64,
        batch: TransactionBatchInfo,
    ) -> Vec<TransactionOnChainData> {
        let mut retries = 0;
        loop {
            match context.get_transactions(
                batch.start_version,
                batch.num_transactions_to_fetch,
                ledger_version,
            ) {
                Ok(raw_txns) => return raw_txns,
                Err(err) => {
                    UNABLE_TO_FETCH_TRANSACTION.inc();
                    retries += 1;

                    if retries >= DEFAULT_NUM_RETRIES {
                        error!(
                            starting_version = batch.start_version,
                            num_transactions = batch.num_transactions_to_fetch,
                            error = format!("{:?}", err),
                            "Could not fetch transactions: retries exhausted",
                        );
                        panic!(
                            "Could not fetch {} transactions after {} retries, starting at {}: {:?}",
                            batch.num_transactions_to_fetch, retries, batch.start_version, err
                        );
                    } else {
                        error!(
                            starting_version = batch.start_version,
                            num_transactions = batch.num_transactions_to_fetch,
                            error = format!("{:?}", err),
                            "Could not fetch transactions: will retry",
                        );
                    }
                    tokio::time::sleep(Duration::from_millis(300)).await;
                },
            }
        }
    }
```

**File:** storage/aptosdb/src/db/aptosdb_reader.rs (L374-387)
```rust
    fn get_transaction_outputs(
        &self,
        start_version: Version,
        limit: u64,
        ledger_version: Version,
    ) -> Result<TransactionOutputListWithProofV2> {
        gauged_api("get_transaction_outputs", || {
            error_if_too_many_requested(limit, MAX_REQUEST_LIMIT)?;

            if start_version > ledger_version || limit == 0 {
                return Ok(TransactionOutputListWithProofV2::new_empty());
            }

            self.error_if_ledger_pruned("Transaction", start_version)?;
```

**File:** api/src/context.rs (L234-241)
```rust
    pub fn get_oldest_version_and_block_height<E: ServiceUnavailableError>(
        &self,
    ) -> Result<(Version, u64), E> {
        self.db
            .get_first_viable_block()
            .context("Failed to retrieve oldest block information")
            .map_err(|e| E::service_unavailable_with_code_no_info(e, AptosErrorCode::InternalError))
    }
```

**File:** storage/aptosdb/src/db/aptosdb_internal.rs (L261-271)
```rust
    pub(super) fn error_if_ledger_pruned(&self, data_type: &str, version: Version) -> Result<()> {
        let min_readable_version = self.ledger_pruner.get_min_readable_version();
        ensure!(
            version >= min_readable_version,
            "{} at version {} is pruned, min available version is {}.",
            data_type,
            version,
            min_readable_version
        );
        Ok(())
    }
```
