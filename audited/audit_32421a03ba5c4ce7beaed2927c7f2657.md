# Audit Report

## Title
Memory Exhaustion via Unbounded Manifest Loading in Epoch History Restore

## Summary
The epoch ending backup restore functionality lacks size validation when loading manifest files from backup storage. An attacker who controls or compromises the backup storage can provide manifests containing billions of waypoints, causing immediate memory exhaustion and crash of the restore process.

## Finding Description

The `EpochHistoryRestoreController::run_impl()` function processes epoch ending backups by loading manifest files and accumulating epoch ending ledger infos without any bounds checking on input sizes.

**Vulnerable Code Path:**

1. At line 381, the controller retrieves ledger infos from each manifest: [1](#0-0) 

2. At line 402, these are accumulated unbounded into the `epoch_endings` vector: [2](#0-1) 

3. The ledger infos originate from manifests loaded at line 81-82 in `preheat_impl()`: [3](#0-2) 

4. The `load_json_file` implementation reads entire files into memory without size limits: [4](#0-3) 

5. The manifest structure requires waypoints for all epochs. A malicious manifest can declare billions of epochs with corresponding waypoints: [5](#0-4) 

6. The manifest verification only checks structural consistency, not size bounds: [6](#0-5) 

**Attack Scenario:**

An attacker who compromises backup storage infrastructure (e.g., leaked cloud credentials, compromised shared backup service, MITM attack) can:

1. Create malicious epoch ending backup metadata pointing to crafted manifest files
2. Craft manifest JSON with `first_epoch: 0`, `last_epoch: 10000000000` (10 billion)
3. Include 10 billion waypoint entries in the JSON (each waypoint ~48 bytes + JSON overhead â‰ˆ 1TB JSON file)
4. When an operator runs restore pointing to this storage, the manifest is loaded entirely into memory
5. Immediate memory exhaustion causes OOM crash

**Broken Invariant:**

This violates Invariant #9: "Resource Limits: All operations must respect gas, storage, and computational limits." The restore operation does not respect memory limits when processing backup manifests.

## Impact Explanation

**Severity: High (Validator Node Crash/DoS)**

Per the Aptos bug bounty criteria, this qualifies as **High Severity** because it causes:
- **Validator node crashes**: If backup-cli runs on the validator node during restore (common scenario), the OOM will crash or severely impact the node
- **API crashes**: The backup service becomes unavailable
- **Denial of Service**: Prevents operators from recovering from data loss scenarios

While this requires compromised backup infrastructure, the vulnerability enables complete DoS of the restore operation affecting validator availability. Multiple operators could be affected if they use shared backup infrastructure that becomes compromised.

## Likelihood Explanation

**Likelihood: Medium**

This requires the attacker to compromise or control the backup storage that the operator uses. Realistic scenarios include:

1. **Cloud storage credential leakage**: Backup storage credentials exposed in logs, repositories, or compromised systems
2. **Shared backup service compromise**: Multiple validators using community-run backup services that get compromised
3. **Supply chain attacks**: Backup service providers getting compromised
4. **MITM attacks**: Man-in-the-middle attacks on backup storage connections without proper TLS verification

While not trivial, these scenarios are realistic in production environments, especially for validators using shared backup infrastructure or with inadequate operational security.

## Recommendation

Implement size validation for manifest files before loading them into memory. Add configurable limits on:

1. Maximum manifest file size
2. Maximum number of epochs per manifest
3. Maximum number of waypoints

**Suggested Fix:**

```rust
// In storage_ext.rs, add size limit to read_all:
const MAX_MANIFEST_SIZE: usize = 100 * 1024 * 1024; // 100 MB

async fn read_all(&self, file_handle: &FileHandleRef) -> Result<Vec<u8>> {
    let mut file = self.open_for_read(file_handle).await?;
    let mut bytes = Vec::new();
    
    // Use read_to_end with capacity limit
    file.take(MAX_MANIFEST_SIZE as u64 + 1)
        .read_to_end(&mut bytes)
        .await?;
    
    ensure!(
        bytes.len() <= MAX_MANIFEST_SIZE,
        "Manifest file exceeds maximum size of {} bytes",
        MAX_MANIFEST_SIZE
    );
    
    Ok(bytes)
}

// In manifest.rs, add epoch count validation:
const MAX_EPOCHS_PER_MANIFEST: u64 = 10_000; // Reasonable limit

pub fn verify(&self) -> Result<()> {
    let epoch_count = self.last_epoch.saturating_sub(self.first_epoch).saturating_add(1);
    ensure!(
        epoch_count <= MAX_EPOCHS_PER_MANIFEST,
        "Manifest contains {} epochs, exceeding maximum of {}",
        epoch_count,
        MAX_EPOCHS_PER_MANIFEST
    );
    
    // ... existing validations
}
```

## Proof of Concept

**Rust Test to Demonstrate Vulnerability:**

```rust
// Create malicious manifest JSON
let malicious_manifest = serde_json::json!({
    "first_epoch": 0,
    "last_epoch": 1_000_000_000u64, // 1 billion epochs
    "waypoints": vec![
        "0:0000000000000000000000000000000000000000000000000000000000000000"; 
        1_000_000_001 // 1 billion + 1 waypoints
    ],
    "chunks": [{
        "first_epoch": 0,
        "last_epoch": 1_000_000_000u64,
        "ledger_infos": "mock://ledger_infos"
    }]
});

// Write to file (will be ~several GB of JSON)
let manifest_json = serde_json::to_string(&malicious_manifest).unwrap();

// When restore attempts to load this:
// let manifest: EpochEndingBackup = storage.load_json_file(&handle).await?;
// This will exhaust memory trying to deserialize billions of waypoints
```

**Steps to Reproduce:**

1. Set up local backup storage with malicious metadata
2. Create manifest JSON with `last_epoch` set to 1 billion
3. Generate corresponding waypoint array (this alone will be several GB)
4. Run backup-cli restore command pointing to this storage
5. Observe OOM crash when manifest is loaded

**Notes**

- This vulnerability exists in the backup-cli administrative tool, not the core consensus or execution layer
- Exploitation requires compromising the backup storage infrastructure that operators use
- The issue is the complete lack of input validation and resource limits in the restore code, violating defensive programming principles
- Even accidental bugs in backup generation could trigger this issue
- While state sync has limits like `MAX_EPOCH_CHUNK_SIZE` of 200, backup restore has no equivalent protections [7](#0-6)

### Citations

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L80-83)
```rust
    async fn preheat_impl(&self) -> Result<EpochEndingRestorePreheatData> {
        let manifest: EpochEndingBackup =
            self.storage.load_json_file(&self.manifest_handle).await?;
        manifest.verify()?;
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L381-381)
```rust
            let lis = preheated_restore.run(previous_li).await?;
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L402-403)
```rust
            epoch_endings.extend(lis);
            previous_li = epoch_endings.last();
```

**File:** storage/backup/backup-cli/src/utils/storage_ext.rs (L35-36)
```rust
    async fn load_json_file<T: DeserializeOwned>(&self, file_handle: &FileHandleRef) -> Result<T> {
        Ok(serde_json::from_slice(&self.read_all(file_handle).await?)?)
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/manifest.rs (L21-26)
```rust
pub struct EpochEndingBackup {
    pub first_epoch: u64,
    pub last_epoch: u64,
    pub waypoints: Vec<Waypoint>,
    pub chunks: Vec<EpochEndingChunk>,
}
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/manifest.rs (L29-38)
```rust
    pub fn verify(&self) -> Result<()> {
        // check number of waypoints
        ensure!(
            self.first_epoch <= self.last_epoch
                && self.last_epoch - self.first_epoch + 1 == self.waypoints.len() as u64,
            "Malformed manifest. first epoch: {}, last epoch {}, num waypoints {}",
            self.first_epoch,
            self.last_epoch,
            self.waypoints.len(),
        );
```

**File:** config/src/config/state_sync_config.rs (L24-24)
```rust
const MAX_EPOCH_CHUNK_SIZE: u64 = 200;
```
