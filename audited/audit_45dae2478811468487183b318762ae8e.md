# Audit Report

## Title
Missing Function Handle Table Size Validation During Module Deserialization

## Summary
The Move binary format deserializer does not enforce that the number of entries in the `FUNCTION_HANDLES` table remains within `FUNCTION_HANDLE_INDEX_MAX` (65,535), allowing modules to contain more function handles than can be validly referenced by bytecode instructions.

## Finding Description

The vulnerability exists in the module deserialization process where table sizes are validated only by their byte size, not their entry count. [1](#0-0) 

The constant `FUNCTION_HANDLE_INDEX_MAX` is defined as 65,535, which should limit the maximum number of function handles. However, during deserialization: [2](#0-1) 

The `load_table_size` function validates table size in bytes against `TABLE_SIZE_MAX` (4GB), not the entry count. [3](#0-2) 

The `Table::load` method deserializes entries until all bytes are consumed without checking if the total count exceeds `TABLE_INDEX_MAX`. [4](#0-3) 

When building function handles, the table loads all entries without validation.

The bounds checker only validates that indices used in bytecode are within the loaded table bounds: [5](#0-4) 

But never checks if the table length itself exceeds `TABLE_INDEX_MAX`.

The limits verifier checks individual function handle properties but not table size: [6](#0-5) 

Production configuration sets no limit on function definitions: [7](#0-6) 

**Attack Scenario:**
1. Attacker crafts a Move module with 100,000 function handles (within 1MB governance transaction limit)
2. Module passes deserialization as table byte size < `TABLE_SIZE_MAX`
3. All 100,000 function handles are loaded into memory
4. Only first 65,535 can be referenced (index validation enforces `FUNCTION_HANDLE_INDEX_MAX`)
5. 34,465 unreachable function handles waste memory

## Impact Explanation

This issue falls under **Low Severity** due to practical constraints limiting exploitation: [8](#0-7) 

Transaction size limits (64KB regular, 1MB governance) significantly constrain the attack surface. With ~10 bytes per serialized `FunctionHandle`, a 1MB governance transaction could contain approximately 100,000 function handles, wasting several hundred KB of memory per module.

While this violates the design intent that table entries should be indexable within u16 range, it does not:
- Cause consensus divergence (deterministic across all validators)
- Enable fund theft or manipulation
- Create validator crashes or significant performance degradation
- Break critical system invariants

The impact is limited memory waste that cannot be significantly amplified due to governance proposal requirements and module publication costs.

## Likelihood Explanation

**Likelihood: Low**

Exploitation requires:
1. Submitting a governance proposal (requires significant governance token holdings)
2. Proposal approval from the community
3. Each malicious module provides minimal impact (limited memory waste)
4. No ability to amplify attack due to transaction size constraints

The attack provides minimal benefit to the attacker relative to the cost and difficulty of execution.

## Recommendation

Add explicit validation during table loading to enforce entry count limits:

```rust
// In deserializer.rs, modify Table::load to check entry count
fn load<T>(
    &self,
    binary: &VersionedBinary,
    result: &mut Vec<T>,
    deserializer: impl Fn(&mut VersionedCursor) -> BinaryLoaderResult<T>,
) -> BinaryLoaderResult<()> {
    let start = self.offset as usize;
    let end = start + self.count as usize;
    let mut cursor = binary.new_cursor(start, end);
    
    let mut entry_count = 0u64;
    while cursor.position() < self.count as u64 {
        if entry_count > TABLE_INDEX_MAX {
            return Err(PartialVMError::new(StatusCode::MALFORMED)
                .with_message(format!("Table entry count {} exceeds maximum {}", 
                    entry_count, TABLE_INDEX_MAX)));
        }
        result.push(deserializer(&mut cursor)?);
        entry_count += 1;
    }
    Ok(())
}
```

## Proof of Concept

Due to transaction size limits and governance requirements, a practical PoC would require:
1. Creating a governance proposal with a specially crafted 1MB module
2. Module containing minimal function handles (~10 bytes each) to maximize count
3. Observing that all validators deserialize and allocate memory for 100K+ entries
4. Verifying that entries beyond index 65,535 cannot be referenced in bytecode

The attack is theoretically possible but provides minimal practical benefit given the constraints and limited impact.

---

**Notes:**

While this represents a discrepancy between the intended design (table indices limited by `TABLE_INDEX_MAX`) and implementation (no entry count validation), the practical security impact is constrained by transaction size limits to a level that does not constitute a meaningful security threat. The issue is more accurately characterized as a code quality/correctness concern rather than an exploitable vulnerability requiring immediate security response.

### Citations

**File:** third_party/move/move-binary-format/src/file_format_common.rs (L43-50)
```rust
pub const TABLE_INDEX_MAX: u64 = 65535;
pub const SIGNATURE_INDEX_MAX: u64 = TABLE_INDEX_MAX;
pub const ADDRESS_INDEX_MAX: u64 = TABLE_INDEX_MAX;
pub const IDENTIFIER_INDEX_MAX: u64 = TABLE_INDEX_MAX;
pub const MODULE_HANDLE_INDEX_MAX: u64 = TABLE_INDEX_MAX;
pub const STRUCT_HANDLE_INDEX_MAX: u64 = TABLE_INDEX_MAX;
pub const STRUCT_DEF_INDEX_MAX: u64 = TABLE_INDEX_MAX;
pub const FUNCTION_HANDLE_INDEX_MAX: u64 = TABLE_INDEX_MAX;
```

**File:** third_party/move/move-binary-format/src/deserializer.rs (L418-420)
```rust
fn load_table_size(cursor: &mut VersionedCursor) -> BinaryLoaderResult<u32> {
    read_uleb_internal(cursor, TABLE_SIZE_MAX)
}
```

**File:** third_party/move/move-binary-format/src/deserializer.rs (L573-588)
```rust
impl Table {
    /// Generic function to deserialize a table into a vector of given type.
    fn load<T>(
        &self,
        binary: &VersionedBinary,
        result: &mut Vec<T>,
        deserializer: impl Fn(&mut VersionedCursor) -> BinaryLoaderResult<T>,
    ) -> BinaryLoaderResult<()> {
        let start = self.offset as usize;
        let end = start + self.count as usize;
        let mut cursor = binary.new_cursor(start, end);
        while cursor.position() < self.count as u64 {
            result.push(deserializer(&mut cursor)?)
        }
        Ok(())
    }
```

**File:** third_party/move/move-binary-format/src/deserializer.rs (L718-722)
```rust
            TableType::FUNCTION_HANDLES => {
                table.load(binary, common.get_function_handles(), |cursor| {
                    load_function_handle(binary.version(), cursor)
                })?;
            },
```

**File:** third_party/move/move-binary-format/src/check_bounds.rs (L883-898)
```rust
fn check_bounds_impl<T, I>(pool: &[T], idx: I) -> PartialVMResult<()>
where
    I: ModuleIndex,
{
    let idx = idx.into_index();
    let len = pool.len();
    if idx >= len {
        Err(bounds_error(
            StatusCode::INDEX_OUT_OF_BOUNDS,
            I::KIND,
            idx as TableIndex,
            len,
        ))
    } else {
        Ok(())
    }
```

**File:** third_party/move/move-bytecode-verifier/src/limits.rs (L65-94)
```rust
    fn verify_function_handles(&self, config: &VerifierConfig) -> PartialVMResult<()> {
        for (idx, function_handle) in self.resolver.function_handles().iter().enumerate() {
            if let Some(limit) = config.max_generic_instantiation_length {
                if function_handle.type_parameters.len() > limit {
                    return Err(PartialVMError::new(StatusCode::TOO_MANY_TYPE_PARAMETERS)
                        .at_index(IndexKind::FunctionHandle, idx as u16));
                }
            };
            if let Some(limit) = config.max_function_parameters {
                if self
                    .resolver
                    .signature_at(function_handle.parameters)
                    .0
                    .len()
                    > limit
                {
                    return Err(PartialVMError::new(StatusCode::TOO_MANY_PARAMETERS)
                        .at_index(IndexKind::FunctionHandle, idx as u16));
                }
            }
            if let Some(limit) = config.max_function_return_values {
                if self.resolver.signature_at(function_handle.return_).0.len() > limit {
                    return Err(PartialVMError::new(StatusCode::TOO_MANY_PARAMETERS)
                        .at_index(IndexKind::FunctionHandle, idx as u16));
                }
            };
            // Note: the size of `attributes` is limited by the deserializer.
        }
        Ok(())
    }
```

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L168-171)
```rust
        max_struct_definitions: None,
        max_struct_variants: None,
        max_fields_in_struct: None,
        max_function_definitions: None,
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L1-50)
```rust
// Copyright (c) Aptos Foundation
// Licensed pursuant to the Innovation-Enabling Source Code License, available at https://github.com/aptos-labs/aptos-core/blob/main/LICENSE

//! This module defines all the gas parameters for transactions, along with their initial values
//! in the genesis and a mapping between the Rust representation and the on-chain gas schedule.

use crate::{
    gas_schedule::VMGasParameters,
    ver::gas_feature_versions::{
        RELEASE_V1_10, RELEASE_V1_11, RELEASE_V1_12, RELEASE_V1_13, RELEASE_V1_15, RELEASE_V1_26,
        RELEASE_V1_41,
    },
};
use aptos_gas_algebra::{
    AbstractValueSize, Fee, FeePerByte, FeePerGasUnit, FeePerSlot, Gas, GasExpression,
    GasScalingFactor, GasUnit, NumModules, NumSlots, NumTypeNodes,
};
use move_core_types::gas_algebra::{
    InternalGas, InternalGasPerArg, InternalGasPerByte, InternalGasUnit, NumBytes, ToUnitWithParams,
};

const GAS_SCALING_FACTOR: u64 = 1_000_000;

crate::gas_schedule::macros::define_gas_parameters!(
    TransactionGasParameters,
    "txn",
    VMGasParameters => .txn,
    [
        // The flat minimum amount of gas required for any transaction.
        // Charged at the start of execution.
        // It is variable to charge more for more expensive authenticators, e.g., keyless
        [
            min_transaction_gas_units: InternalGas,
            "min_transaction_gas_units",
            2_760_000
        ],
        // Any transaction over this size will be charged an additional amount per byte.
        [
            large_transaction_cutoff: NumBytes,
            "large_transaction_cutoff",
            600
        ],
        // The units of gas that to be charged per byte over the `large_transaction_cutoff` in addition to
        // `min_transaction_gas_units` for transactions whose size exceeds `large_transaction_cutoff`.
        [
            intrinsic_gas_per_byte: InternalGasPerByte,
            "intrinsic_gas_per_byte",
            1_158
        ],
        // ~5 microseconds should equal one unit of computational gas. We bound the maximum
```
