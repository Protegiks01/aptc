# Audit Report

## Title
Non-Canonical Currency Type Strings Cause Transaction Parsing Failures in Rosetta API

## Summary
The Rosetta API's currency configuration loading does not normalize type tag strings to canonical form, allowing operators to register currencies with non-canonical address representations (e.g., `0x00001::coin::Coin` instead of `0x1::coin::Coin`). This causes legitimate transactions with canonically-represented type tags to fail currency validation checks, resulting in transaction parsing failures and service disruption. [1](#0-0) [2](#0-1) 

## Finding Description
The vulnerability exists in the currency registration and validation flow:

1. **Configuration Loading**: When the Rosetta API loads currencies from a JSON configuration file, it validates that the `move_type` string can be parsed as a valid `StructTag` but does not normalize it to canonical form. [3](#0-2) 

2. **Storage Without Normalization**: If validation passes, the currency is inserted directly with the original (potentially non-canonical) string from the config file.

3. **String Comparison in Validation**: During transaction parsing, the `parse_coin_currency()` function compares the canonical string representation of incoming TypeTags against the stored currency strings using direct string equality. [4](#0-3) 

4. **Mismatch**: Since TypeTags from blockchain transactions are always canonical (addresses are normalized during parsing and serialization), they produce canonical strings via `to_canonical_string()`. These canonical strings won't match non-canonical stored strings, causing validation failures. [5](#0-4) 

The same issue affects `find_coin_currency()` which uses identical string comparison logic: [6](#0-5) 

**Address Normalization Mechanism**: The canonical string format uses `short_str_lossless()` which trims leading zeros from addresses: [7](#0-6) 

## Impact Explanation
This is a **Medium Severity** issue per Aptos bug bounty criteria:
- **Service Disruption**: Legitimate transactions involving misconfigured currencies will be rejected by the Rosetta API
- **Limited Scope**: Only affects the Rosetta API layer, not core blockchain consensus or execution
- **No Fund Loss**: Does not enable theft or unauthorized minting of assets
- **State Inconsistency**: Could cause accounting discrepancies if the same currency is registered multiple times with different representations

The impact is limited because:
- The Rosetta API is an auxiliary interface, not part of core consensus
- Requires operator misconfiguration (trusted role)
- Does not affect on-chain state or validator operations

## Likelihood Explanation
**Likelihood: Low to Medium**

This requires:
- Operator access to currency configuration files (trusted role)
- Either accidental misconfiguration or malicious insider

However, it's reasonably likely to occur because:
- No automated normalization or warning during configuration loading
- Address representations with leading zeros are valid and may appear in documentation or examples
- Operators may copy-paste addresses without realizing normalization requirements

## Recommendation
Normalize all `move_type` strings to canonical form during currency registration:

```rust
// In main.rs supported_currencies() function, replace lines 256-260 with:
if let Some(metadata) = item.metadata.as_ref() {
    if let Some(move_type) = metadata.move_type.as_ref() {
        if let Ok(struct_tag) = StructTag::from_str(move_type) {
            // Create normalized currency with canonical string
            let normalized_currency = Currency {
                symbol: item.symbol.clone(),
                decimals: item.decimals,
                metadata: Some(CurrencyMetadata {
                    move_type: Some(struct_tag.to_canonical_string()),
                    fa_address: metadata.fa_address.clone(),
                }),
            };
            supported_currencies.insert(normalized_currency);
            continue;
        }
    }
    warn!(
        "Currency {:?} has an invalid metadata coin type, and is being skipped",
        item
    );
}
```

This ensures all stored currency type strings are in canonical form before comparison.

## Proof of Concept

**Setup:**
1. Create a currency configuration file `currencies.json`:
```json
[
  {
    "symbol": "TEST",
    "decimals": 8,
    "metadata": {
      "move_type": "0x00001::test_coin::TestCoin"
    }
  }
]
```

2. Start Rosetta API with this configuration file

**Expected Behavior:**
- Currency loads successfully (validation passes)
- Transactions with `0x1::test_coin::TestCoin` type fail to parse
- Error: "Invalid coin for transfer 0x1::test_coin::TestCoin"

**Root Cause:**
- Stored string: `"0x00001::test_coin::TestCoin"`
- Transaction TypeTag canonical: `"0x1::test_coin::TestCoin"`
- String comparison at line 397 fails despite representing the same type

## Notes
- The `to_canonical_string()` method itself functions correctly and consistently produces canonical output for equivalent TypeTags
- The vulnerability is in the configuration loading logic that accepts non-canonical strings without normalization
- This issue is specific to the Rosetta API layer and does not affect core Aptos blockchain functionality, consensus, or Move VM execution

### Citations

**File:** crates/aptos-rosetta/src/main.rs (L245-269)
```rust
        if let Some(ref filepath) = self.currency_config_file {
            let file = File::open(filepath).unwrap();
            let currencies: Vec<Currency> = serde_json::from_reader(file).unwrap();
            for item in currencies.into_iter() {
                // Do a safety check on possible currencies on startup
                if item.symbol.as_str() == "" {
                    warn!(
                        "Currency {:?} has an empty symbol, and is being skipped",
                        item
                    );
                } else if let Some(metadata) = item.metadata.as_ref() {
                    if let Some(move_type) = metadata.move_type.as_ref() {
                        if StructTag::from_str(move_type).is_ok() {
                            supported_currencies.insert(item);
                            continue;
                        }
                    }
                    warn!(
                        "Currency {:?} has an invalid metadata coin type, and is being skipped",
                        item
                    );
                } else {
                    supported_currencies.insert(item);
                }
            }
```

**File:** crates/aptos-rosetta/src/common.rs (L208-223)
```rust
pub fn find_coin_currency(currencies: &HashSet<Currency>, type_tag: &TypeTag) -> Option<Currency> {
    currencies
        .iter()
        .find(|currency| {
            if let Some(CurrencyMetadata {
                move_type: Some(ref move_type),
                fa_address: _,
            }) = currency.metadata
            {
                move_type == &type_tag.to_canonical_string()
            } else {
                false
            }
        })
        .cloned()
}
```

**File:** crates/aptos-rosetta/src/common.rs (L387-408)
```rust
pub fn parse_coin_currency(
    server_context: &RosettaContext,
    struct_tag: &StructTag,
) -> ApiResult<Currency> {
    if let Some(currency) = server_context.currencies.iter().find(|currency| {
        if let Some(move_type) = currency
            .metadata
            .as_ref()
            .and_then(|inner| inner.move_type.as_ref())
        {
            struct_tag.to_canonical_string() == *move_type
        } else {
            false
        }
    }) {
        Ok(currency.clone())
    } else {
        Err(ApiError::TransactionParseError(Some(format!(
            "Invalid coin for transfer {}",
            struct_tag.to_canonical_string()
        ))))
    }
```

**File:** third_party/move/move-core/types/src/language_storage.rs (L267-291)
```rust
    pub fn to_canonical_string(&self) -> String {
        let generics = if self.type_args.is_empty() {
            "".to_string()
        } else {
            format!(
                "<{}>",
                self.type_args
                    .iter()
                    .map(|t| t.to_canonical_string())
                    .collect::<Vec<_>>()
                    .join(", ")
            )
        };
        format!(
            // Note:
            //   For historical reasons, we convert addresses as strings using 0x... and trimming
            //   leading zeroes. This cannot be changed easily because 0x1::any::Any relies on that
            //   and may store bytes of these strings on-chain.
            "0x{}::{}::{}{}",
            self.address.short_str_lossless(),
            self.module,
            self.name,
            generics
        )
    }
```

**File:** third_party/move/move-core/types/src/account_address.rs (L138-145)
```rust
    pub fn short_str_lossless(&self) -> String {
        let hex_str = hex::encode(self.0).trim_start_matches('0').to_string();
        if hex_str.is_empty() {
            "0".to_string()
        } else {
            hex_str
        }
    }
```
