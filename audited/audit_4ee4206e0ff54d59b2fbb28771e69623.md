# Audit Report

## Title
Transaction Filter Configuration Information Disclosure Through Logging and Inspection Service

## Summary
The `TransactionFilterConfig` struct and its dependent types use standard `Serialize` and `Debug` trait implementations without redaction, causing sensitive filter criteria (blocked addresses, public keys, transaction IDs, and entry functions) to be exposed through node startup logs and the inspection service HTTP endpoint. This reveals operational security policies to anyone with access to logs or network access to the inspection service.

## Finding Description

The `TransactionFilterConfig` struct contains sensitive filtering rules through its `transaction_filter` field, which holds a `TransactionFilter` containing rules and matchers that can specify: [1](#0-0) 

The underlying `TransactionMatcher` enum can contain sensitive operational data: [2](#0-1) 

These types use standard `Serialize` and `Debug` derives without any redaction mechanism. This causes information leakage through three vectors:

**Vector 1: Logger initialization** - The node config is logged with debug formatting during logger creation: [3](#0-2) 

**Vector 2: Node startup logging** - The config is serialized to JSON and logged at INFO level during node initialization: [4](#0-3) 

**Vector 3: Inspection service endpoint** - When enabled, the configuration endpoint exposes the full config via HTTP using debug formatting: [5](#0-4) 

The inspection service is automatically enabled on testnet/devnet nodes: [6](#0-5) 

An attacker who gains access to node logs (via compromised log aggregation systems, monitoring dashboards, or log files) or who can reach the inspection service endpoint on testnet/devnet nodes can discover:
- Which account addresses are blocked (via `Sender`, `AccountAddress`, `ModuleAddress` matchers)
- Which public keys are filtered (via `PublicKey` matcher)
- Specific transaction IDs being blocked
- Entry function patterns being restricted

This allows adversaries to:
- Evade detection by creating new addresses to bypass filters
- Understand the operator's security posture and compliance requirements
- Tailor attacks to avoid filtered patterns
- Identify regulatory actions or sanctioned addresses

## Impact Explanation

This issue qualifies as **Low Severity** per the Aptos bug bounty criteria:
- **Minor information leaks**: Reveals operational security policies without directly compromising funds, consensus safety, or network availability

While the information disclosed could help attackers evade detection mechanisms, it does not:
- Enable theft or minting of funds (Critical)
- Cause consensus violations or safety breaks (Critical)
- Result in network partition or liveness failures (Critical)
- Cause validator slowdowns or API crashes (High)
- Lead to state inconsistencies or limited funds manipulation (Medium)

The impact is limited to information disclosure that reveals security policies, which is categorized as a minor information leak under Low severity.

## Likelihood Explanation

**High likelihood of exposure occurring:**
- Logging happens automatically on every node startup for all nodes (mainnet, testnet, devnet)
- Inspection service is enabled by default on testnet/devnet nodes
- No special configuration is needed to trigger the leakage

**Moderate likelihood of exploitation:**
- Attacker needs access to log aggregation systems, monitoring platforms, or log files
- For inspection service: attacker needs network access to port 9101 on testnet/devnet nodes
- Many operators use centralized logging (e.g., Elasticsearch, Splunk) which could be targeted
- Log files may be inadvertently shared or exposed through misconfigurations

## Recommendation

Implement custom serialization and debug formatting for transaction filter types that redacts sensitive criteria:

**Option 1**: Use a custom `Serialize` implementation that omits filter details:

```rust
impl Serialize for TransactionFilterConfig {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut state = serializer.serialize_struct("TransactionFilterConfig", 2)?;
        state.serialize_field("filter_enabled", &self.filter_enabled)?;
        state.serialize_field("transaction_filter", "<redacted>")?;
        state.end()
    }
}
```

**Option 2**: Implement a `SilentDebug`-like trait for these types:

```rust
impl std::fmt::Debug for TransactionFilterConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TransactionFilterConfig")
            .field("filter_enabled", &self.filter_enabled)
            .field("transaction_filter", &"<redacted>")
            .finish()
    }
}
```

**Option 3**: Add a configuration flag to control whether filter details are logged:

```rust
pub struct TransactionFilterConfig {
    filter_enabled: bool,
    transaction_filter: TransactionFilter,
    #[serde(default)]
    log_filter_details: bool, // Default to false
}
```

Apply the same pattern to `TransactionFilter`, `TransactionRule`, and `TransactionMatcher` types.

## Proof of Concept

**Step 1**: Create a node configuration with transaction filters:

```yaml
transaction_filters:
  mempool_filter:
    filter_enabled: true
    transaction_filter:
      transaction_rules:
        - Deny:
          - Sender: "0xBADADD4E55"
          - PublicKey: 
              Ed25519:
                public_key: "0x1234567890abcdef..."
```

**Step 2**: Start an Aptos node with this configuration

**Step 3**: Observe the logs - they will contain:
```
INFO Loaded node config: ... transaction_filters: TransactionFiltersConfig { mempool_filter: TransactionFilterConfig { filter_enabled: true, transaction_filter: TransactionFilter { transaction_rules: [Deny([Sender(0xBADADD4E55), PublicKey(...)])] } } }
```

**Step 4**: For testnet/devnet nodes, access the inspection service:
```bash
curl http://<node-ip>:9101/configuration
```

The response will include the full transaction filter configuration with all blocked addresses and public keys visible.

**Notes**

This is categorized as a **Low severity** information disclosure issue that does not meet the validation criteria requiring Medium+ severity impact. While the vulnerability is real and exploitable, it represents a minor information leak rather than a critical security flaw affecting funds, consensus, or availability. The issue should still be addressed to improve operational security, but it does not constitute a high-priority security vulnerability under the strict validation requirements.

### Citations

**File:** config/src/config/transaction_filters_config.rs (L20-25)
```rust
#[derive(Clone, Debug, Deserialize, PartialEq, Eq, Serialize)]
#[serde(default, deny_unknown_fields)]
pub struct TransactionFilterConfig {
    filter_enabled: bool,                  // Whether the filter is enabled
    transaction_filter: TransactionFilter, // The transaction filter to apply
}
```

**File:** crates/aptos-transaction-filters/src/transaction_filter.rs (L170-180)
```rust
#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
pub enum TransactionMatcher {
    All,                                           // Matches any transaction
    TransactionId(HashValue),                      // Matches a specific transaction by its ID
    Sender(AccountAddress), // Matches any transaction sent by a specific account address
    ModuleAddress(AccountAddress), // Matches any transaction that calls a module at a specific address
    EntryFunction(AccountAddress, String, String), // Matches any transaction that calls a specific entry function in a module
    AccountAddress(AccountAddress), // Matches any transaction that involves a specific account address
    PublicKey(AnyPublicKey),        // Matches any transaction that involves a specific public key
    EncryptedTransaction,           // Matches any encrypted transaction
}
```

**File:** aptos-node/src/logger.rs (L101-101)
```rust
    info!("Loaded node config: {:?}", config);
```

**File:** config/src/config/node_config.rs (L97-111)
```rust
    pub fn log_all_configs(&self) {
        // Parse the node config as serde JSON
        let config_value =
            serde_json::to_value(self).expect("Failed to serialize the node config!");
        let config_map = config_value
            .as_object()
            .expect("Failed to get the config map!");

        // Log each config entry
        for (config_name, config_value) in config_map {
            let config_string =
                serde_json::to_string(config_value).expect("Failed to parse the config value!");
            info!("Using {} config: {}", config_name, config_string);
        }
    }
```

**File:** crates/aptos-inspection-service/src/server/configuration.rs (L13-29)
```rust
pub fn handle_configuration_request(node_config: &NodeConfig) -> (StatusCode, Body, String) {
    // Only return configuration if the endpoint is enabled
    let (status_code, body) = if node_config.inspection_service.expose_configuration {
        // We format the configuration using debug formatting. This is important to
        // prevent secret/private keys from being serialized and leaked (i.e.,
        // all secret keys are marked with SilentDisplay and SilentDebug).
        let encoded_configuration = format!("{:?}", node_config);
        (StatusCode::OK, Body::from(encoded_configuration))
    } else {
        (
            StatusCode::FORBIDDEN,
            Body::from(CONFIGURATION_DISABLED_MESSAGE),
        )
    };

    (status_code, body, CONTENT_TYPE_TEXT.into())
}
```

**File:** config/src/config/inspection_service_config.rs (L82-88)
```rust
        let mut modified_config = false;
        if let Some(chain_id) = chain_id {
            if !chain_id.is_mainnet() {
                if local_inspection_config_yaml["expose_configuration"].is_null() {
                    inspection_service_config.expose_configuration = true;
                    modified_config = true;
                }
```
