# Audit Report

## Title
IPv6 Address Rotation Bypass of IP-Based Rate Limiting in Aptos Faucet

## Summary
The Aptos faucet's IP-based rate limiting mechanisms treat each individual IPv6 address as a unique entity without subnet-based normalization, allowing attackers with IPv6 connectivity to completely bypass rate limits by rotating through the vast IPv6 address space (typically a /64 prefix providing 2^64 addresses per user).

## Finding Description

The vulnerability exists in the faucet's rate limiting implementation where IP addresses are used directly as rate limiting keys without any subnet-based grouping for IPv6 addresses.

**Affected Components:**

1. **MemoryRatelimitChecker** - Uses individual `IpAddr` as LRU cache key [1](#0-0) 

2. **RedisRatelimitChecker** - Converts IP to string without subnet normalization [2](#0-1) 

**Attack Flow:**

The faucet's `preprocess_request()` function extracts the source IP from the request using `RealIp`: [3](#0-2) 

This IP is then passed to rate limiting checkers in `CheckerData`: [4](#0-3) 

Both rate limiters use this IP directly as a unique key:
- **MemoryRatelimitChecker**: Uses `data.source_ip` directly in LRU map lookup [5](#0-4) 

- **RedisRatelimitChecker**: Converts to string without normalization [6](#0-5) 

**Exploitation Scenario:**

1. Attacker obtains IPv6 connectivity with a /64 prefix (standard residential allocation providing 18.4 quintillion addresses)
2. Sends faucet request from `2001:db8:1234:5678::1` - consumes 1/N daily limit
3. Sends faucet request from `2001:db8:1234:5678::2` - treated as completely different user, consumes 1/N limit  
4. Repeats for millions of different IPv6 addresses from the same /64 prefix
5. Each address is tracked separately, effectively providing unlimited requests

**Additional Impact - Memory Exhaustion:**

The MemoryRatelimitChecker has a default max of 1 million entries: [7](#0-6) 

Once this limit is reached, the LRU cache evicts old entries, allowing attackers to cycle back to previously used addresses and continue the attack indefinitely.

## Impact Explanation

This vulnerability qualifies as **HIGH severity** under the Aptos Bug Bounty program criteria:

1. **API crashes / slowdowns** (High severity category): The unlimited requests can overwhelm the faucet API, causing service degradation or crashes due to:
   - Excessive transaction submission to the blockchain
   - Redis/Memory storage exhaustion for rate limiter state
   - Network bandwidth saturation

2. **Significant protocol violations** (High severity category): The rate limiting is a critical security control designed to prevent abuse. Complete bypass represents a fundamental protocol violation.

3. **Resource exhaustion**: Attackers can drain faucet funds completely, impacting legitimate users and testnet operations.

4. **Storage exhaustion**: For Redis-based rate limiting, attackers can create millions of unique keys, exhausting Redis storage capacity.

While this doesn't affect consensus or validator operations (which would be Critical), it significantly compromises a production service that's part of the Aptos ecosystem infrastructure.

## Likelihood Explanation

**Likelihood: HIGH**

1. **Easy exploitation**: Attack requires only IPv6 connectivity, which is widely available:
   - Most residential ISPs provide /64 IPv6 prefixes
   - Cloud providers (AWS, GCP, Azure) offer IPv6 support with large address blocks
   - Mobile networks increasingly support IPv6

2. **Low technical barrier**: Exploitation is trivial - simply change source IPv6 address per request using standard networking tools or programming libraries.

3. **High attacker motivation**: 
   - Free testnet tokens have value for testing and development
   - Attackers could resell testnet accounts
   - Denial of service against legitimate users

4. **No detection mechanisms**: The code has no IPv6-specific protections, subnet grouping, or anomaly detection for rapid IPv6 address rotation.

## Recommendation

Implement IPv6 subnet-based rate limiting by normalizing IPv6 addresses to their subnet prefix (typically /64) before using them as rate limiting keys.

**Recommended Fix:**

```rust
// Add to CheckerData or a helper module
use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};

fn normalize_ip_for_ratelimit(ip: IpAddr) -> String {
    match ip {
        IpAddr::V4(ipv4) => {
            // For IPv4, use the full address or optionally /24 subnet
            ipv4.to_string()
        }
        IpAddr::V6(ipv6) => {
            // Normalize IPv6 to /64 subnet
            let segments = ipv6.segments();
            // Keep first 4 segments (64 bits), zero out the rest
            let normalized = Ipv6Addr::new(
                segments[0], segments[1], segments[2], segments[3],
                0, 0, 0, 0
            );
            format!("{}/64", normalized)
        }
    }
}
```

**Apply in MemoryRatelimitChecker:**
```rust
// In check() method, replace:
// let requests_today = ip_to_requests_today.get_or_insert_mut(data.source_ip, || 1);
// With:
let normalized_ip = normalize_ip_for_ratelimit(data.source_ip);
let requests_today = ip_to_requests_today.get_or_insert_mut(normalized_ip, || 1);
```

**Apply in RedisRatelimitChecker:**  
```rust
// In ratelimit_key_value(), replace:
// RatelimitKeyProvider::Ip => Ok(data.source_ip.to_string()),
// With:
RatelimitKeyProvider::Ip => Ok(normalize_ip_for_ratelimit(data.source_ip)),
```

**Configuration Option:**
Make the IPv6 prefix length configurable (default /64) to allow operators to adjust based on their threat model and user distribution.

## Proof of Concept

```rust
// Integration test demonstrating IPv6 bypass
#[cfg(test)]
mod tests {
    use super::*;
    use std::net::{IpAddr, Ipv6Addr};
    
    #[tokio::test]
    async fn test_ipv6_ratelimit_bypass() {
        // Create rate limiter allowing 1 request per day
        let config = MemoryRatelimitCheckerConfig {
            max_requests_per_day: 1,
            max_entries_in_map: NonZeroUsize::new(1000000).unwrap(),
        };
        let checker = MemoryRatelimitChecker::new(config);
        
        // Simulate requests from different IPv6 addresses in same /64 subnet
        let base_prefix = [0x2001, 0x0db8, 0x1234, 0x5678];
        
        for i in 1..=100 {
            // Each iteration uses a different IPv6 address from same /64
            let ipv6 = Ipv6Addr::new(
                base_prefix[0], base_prefix[1], base_prefix[2], base_prefix[3],
                0, 0, 0, i  // Only last segment changes
            );
            
            let checker_data = CheckerData {
                source_ip: IpAddr::V6(ipv6),
                receiver: AccountAddress::random(),
                headers: Arc::new(HeaderMap::new()),
                time_request_received_secs: get_current_time_secs(),
            };
            
            // All requests should succeed, bypassing rate limit
            let result = checker.check(checker_data, false).await.unwrap();
            assert!(result.is_empty(), 
                "Request {} from {:?} should pass but got rejection: {:?}", 
                i, ipv6, result);
        }
        
        // This demonstrates 100 successful requests despite limit of 1 per day,
        // proving complete bypass of rate limiting via IPv6 rotation
    }
}
```

**Manual Testing Steps:**

1. Configure faucet with `MemoryRatelimit` or `RedisRatelimit` checker with low daily limit (e.g., 1-5 requests)
2. From a machine with IPv6 connectivity and /64 prefix:
   ```bash
   # Request 1
   curl -6 --interface 2001:db8::1 https://faucet.testnet.aptoslabs.com/fund -d '{"address":"0xABC..."}'
   
   # Request 2 (different IPv6, bypasses limit)
   curl -6 --interface 2001:db8::2 https://faucet.testnet.aptoslabs.com/fund -d '{"address":"0xDEF..."}'
   
   # Continue with ::3, ::4, etc.
   ```
3. Observe all requests succeed despite rate limit, confirming vulnerability

## Notes

- This vulnerability affects production faucet deployments for testnet and devnet
- The issue applies to both `MemoryRatelimitChecker` and `RedisRatelimitChecker` when configured in IP mode
- JWT-based rate limiting (available in `RedisRatelimitChecker`) is NOT affected as it uses Firebase UID instead of IP
- The same attack vector could theoretically work with IPv4 if attackers control large IPv4 ranges, but IPv6 makes it trivially easy due to the vastly larger address space
- While the faucet is not consensus-critical, it's an important piece of infrastructure for onboarding new users and developers

### Citations

**File:** crates/aptos-faucet/core/src/checkers/memory_ratelimit.rs (L24-26)
```rust
    fn default_max_entries_in_map() -> NonZeroUsize {
        NonZeroUsize::new(1000000).unwrap()
    }
```

**File:** crates/aptos-faucet/core/src/checkers/memory_ratelimit.rs (L37-37)
```rust
    pub ip_to_requests_today: Mutex<LruCache<IpAddr, u32>>,
```

**File:** crates/aptos-faucet/core/src/checkers/memory_ratelimit.rs (L77-78)
```rust
        let requests_today = ip_to_requests_today.get_or_insert_mut(data.source_ip, || 1);
        if *requests_today >= self.max_requests_per_day {
```

**File:** crates/aptos-faucet/core/src/checkers/redis_ratelimit.rs (L46-46)
```rust
            RatelimitKeyProvider::Ip => Ok(data.source_ip.to_string()),
```

**File:** crates/aptos-faucet/core/src/checkers/redis_ratelimit.rs (L193-198)
```rust
        let key = format!(
            "{}:{}:{}",
            ratelimit_key_prefix,
            ratelimit_key_value,
            days_since_tap_epoch(now_secs)
        );
```

**File:** crates/aptos-faucet/core/src/endpoints/fund.rs (L217-225)
```rust
        let source_ip = match source_ip.0 {
            Some(ip) => ip,
            None => {
                return Err(AptosTapError::new(
                    "No source IP found in the request".to_string(),
                    AptosTapErrorCode::SourceIpMissing,
                ))
            },
        };
```

**File:** crates/aptos-faucet/core/src/checkers/mod.rs (L147-153)
```rust
#[derive(Clone, Debug)]
pub struct CheckerData {
    pub time_request_received_secs: u64,
    pub receiver: AccountAddress,
    pub source_ip: IpAddr,
    pub headers: Arc<HeaderMap>,
}
```
