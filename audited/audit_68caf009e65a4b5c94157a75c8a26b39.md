# Audit Report

## Title
Transaction Filter Bypass via Proof-Based Transactions in QuorumStore Payloads

## Summary
A malicious block proposer can bypass the `BlockTransactionFilter` by including denied transactions in the `proof_with_data` component of `QuorumStoreInlineHybrid` payloads instead of `inline_batches`. The filter only checks `inline_batches` transactions, allowing filtered transactions to be executed when included via Proof-of-Store references.

## Finding Description

The `check_denied_inline_transactions` method in `QuorumStorePayloadManager` only examines transactions present in `inline_batches` of quorum store payloads, completely ignoring transactions referenced by `proof_with_data` (Proof-of-Store objects). This creates a critical bypass vulnerability. [1](#0-0) 

The `get_inline_transactions` helper function only extracts transactions from `inline_batches` for `QuorumStoreInlineHybrid` and related payload types, returning an empty vector for other components: [2](#0-1) 

However, during execution, the `get_transactions_quorum_store_inline_hybrid` method fetches and executes transactions from BOTH `proof_with_data` AND `inline_batches`: [3](#0-2) 

In contrast, `DirectMempoolPayloadManager` correctly filters ALL transactions because they're all considered inline: [4](#0-3) 

**Attack Path:**
1. Transaction filter is configured to deny specific transactions (e.g., from sanctioned addresses)
2. Malicious proposer creates batches containing denied transactions
3. Proposer broadcasts these batches to the network for certification
4. Honest validators sign batches without checking transaction filter (batch signing has no filter validation)
5. Malicious proposer collects signatures and forms valid Proof-of-Store certificates
6. Proposer creates `QuorumStoreInlineHybrid` payload with:
   - `inline_batches`: empty or containing only allowed transactions
   - `proof_with_data`: containing proofs referencing denied transactions
7. `check_denied_inline_transactions` examines only `inline_batches` (empty/clean) and returns `Ok()`
8. Block proposal is accepted by honest validators
9. During execution, transactions from BOTH components are extracted and executed
10. Denied transactions from `proof_with_data` bypass the filter completely

This violates the **Transaction Validation** invariant that all transactions must pass configured filters before execution.

## Impact Explanation

**Critical Severity** - This represents a consensus/safety violation allowing circumvention of transaction filtering mechanisms:

- **Consensus Integrity**: Different filtering implementations for different payload types create an exploitable inconsistency in transaction validation
- **Regulatory Compliance Bypass**: Transaction filters may be used for compliance (sanctioned addresses, restricted operations), and this bypass undermines that security control
- **Deterministic Execution Violation**: If some nodes have different filter configurations or processing logic, this could lead to state divergence
- **Access Control Failure**: Filters intended to block specific transaction types can be completely circumvented

The impact qualifies as Critical under "Consensus/Safety violations" and "Significant protocol violations" categories from the Aptos bug bounty program.

## Likelihood Explanation

**High Likelihood**:
- Exploitable by any malicious block proposer without requiring validator collusion
- No complex timing or race conditions needed
- Attack is deterministic once the proposer has valid Proof-of-Store certificates
- Validators will unknowingly sign batches containing denied transactions (no filter check during batch certification)
- The vulnerability exists whenever transaction filtering is enabled and QuorumStore is active
- No additional privileges beyond being a block proposer are required

## Recommendation

The filter must check ALL transactions that will be executed, not just inline transactions. Modify `check_denied_inline_transactions` to also validate transactions referenced by proofs:

```rust
fn check_denied_inline_transactions(
    &self,
    block: &Block,
    block_txn_filter_config: &BlockTransactionFilterConfig,
) -> anyhow::Result<()> {
    if !block_txn_filter_config.is_enabled() {
        return Ok(());
    }

    let Some(payload) = block.payload() else {
        return Ok(());
    };

    // Collect ALL transactions that will be executed
    let mut all_transactions = Vec::new();
    
    match payload {
        Payload::QuorumStoreInlineHybrid(inline_batches, proof_with_data, _)
        | Payload::QuorumStoreInlineHybridV2(inline_batches, proof_with_data, _) => {
            // Add inline transactions
            for (_, txns) in inline_batches {
                all_transactions.extend(txns.clone());
            }
            
            // Add transactions from proofs (requires batch reader access)
            for proof in &proof_with_data.proofs {
                if let Some(batch) = self.batch_reader.exists(proof.digest()) {
                    all_transactions.extend(batch.transactions().clone());
                }
            }
        },
        Payload::OptQuorumStore(opt_payload) => {
            // Similar logic for OptQuorumStore payloads
            all_transactions.extend(opt_payload.inline_batches().transactions());
            // Also check proof_with_data and opt_batches
        },
        _ => {}
    }

    if all_transactions.is_empty() {
        return Ok(());
    }

    // Apply filter to ALL transactions
    let block_transaction_filter = block_txn_filter_config.block_transaction_filter();
    let denied_transactions = block_transaction_filter.get_denied_block_transactions(
        block.id(),
        block.author(),
        block.epoch(),
        block.timestamp_usecs(),
        all_transactions,
    );
    
    if !denied_transactions.is_empty() {
        return Err(anyhow::anyhow!(
            "Transactions in QuorumStore payload denied by filter: {:?}",
            denied_transactions
        ));
    }

    Ok(())
}
```

**Alternative approach**: Implement filter checking during batch certification, so denied transactions never get signed by validators in the first place.

## Proof of Concept

```rust
#[tokio::test]
async fn test_filter_bypass_via_proof_based_transactions() {
    use aptos_config::config::BlockTransactionFilterConfig;
    use aptos_consensus_types::{
        block::Block,
        common::{Payload, ProofWithData},
        proof_of_store::{BatchInfo, ProofOfStore},
    };
    use aptos_transaction_filters::block_transaction_filter::BlockTransactionFilter;
    
    // Create a filter that denies transactions from a specific sender
    let denied_sender = AccountAddress::random();
    let filter = BlockTransactionFilter::empty()
        .add_sender_filter(false, denied_sender)
        .add_all_filter(true);
    let filter_config = BlockTransactionFilterConfig::new(true, filter);
    
    // Create a denied transaction
    let denied_txn = create_transaction_from_sender(denied_sender);
    
    // Create a batch with the denied transaction and get it certified
    let batch_info = create_batch_info(1);
    let proof = create_valid_proof_of_store(batch_info.clone(), vec![denied_txn.clone()]);
    
    // Create QuorumStoreInlineHybrid payload with:
    // - Empty inline_batches (no denied transactions here)
    // - proof_with_data containing the denied transaction
    let payload = Payload::QuorumStoreInlineHybrid(
        vec![], // Empty inline batches
        ProofWithData::new(vec![proof]),
        None,
    );
    
    // Create block with this payload
    let block = Block::new_proposal(
        payload,
        1,
        1,
        certificate_for_genesis(),
        &validator_signer,
        Vec::new(),
    ).unwrap();
    
    // Check with QuorumStorePayloadManager
    let payload_manager = QuorumStorePayloadManager::new(...);
    
    // This should FAIL but currently PASSES (vulnerability!)
    let result = payload_manager.check_denied_inline_transactions(
        &block,
        &filter_config,
    );
    
    assert!(result.is_err(), "Filter should have caught the denied transaction in proof_with_data");
    
    // Verify that get_transactions would execute the denied transaction
    let (transactions, _, _) = payload_manager.get_transactions(&block, None).await.unwrap();
    assert!(transactions.contains(&denied_txn), "Denied transaction would be executed");
}
```

**Notes:**
- This vulnerability breaks the security guarantee that transaction filters are enforced consistently across all payload types
- The attack is realistic and exploitable by any malicious block proposer in production networks
- The fix requires checking ALL transactions that will be executed, not just those directly embedded in the proposal

### Citations

**File:** consensus/src/payload_manager/quorum_store_payload_manager.rs (L126-163)
```rust
    async fn get_transactions_quorum_store_inline_hybrid(
        &self,
        block: &Block,
        inline_batches: &[(BatchInfo, Vec<SignedTransaction>)],
        proof_with_data: &ProofWithData,
        max_txns_to_execute: &Option<u64>,
        block_gas_limit_override: &Option<u64>,
    ) -> ExecutorResult<BlockTransactionPayload> {
        let all_transactions = {
            let mut all_txns = process_qs_payload(
                proof_with_data,
                self.batch_reader.clone(),
                block,
                &self.ordered_authors,
            )
            .await?;
            all_txns.append(
                &mut inline_batches
                    .iter()
                    // TODO: Can clone be avoided here?
                    .flat_map(|(_batch_info, txns)| txns.clone())
                    .collect(),
            );
            all_txns
        };
        let inline_batches = inline_batches
            .iter()
            .map(|(batch_info, _)| batch_info.clone())
            .collect();
        Ok(BlockTransactionPayload::new_quorum_store_inline_hybrid(
            all_transactions,
            proof_with_data.proofs.clone(),
            *max_txns_to_execute,
            *block_gas_limit_override,
            inline_batches,
            self.enable_payload_v2,
        ))
    }
```

**File:** consensus/src/payload_manager/quorum_store_payload_manager.rs (L308-347)
```rust
    fn check_denied_inline_transactions(
        &self,
        block: &Block,
        block_txn_filter_config: &BlockTransactionFilterConfig,
    ) -> anyhow::Result<()> {
        // If the filter is disabled, return early
        if !block_txn_filter_config.is_enabled() {
            return Ok(());
        }

        // Get the inline transactions for the block proposal
        let inline_transactions = get_inline_transactions(block);
        if inline_transactions.is_empty() {
            return Ok(());
        }

        // Fetch the block metadata
        let block_id = block.id();
        let block_author = block.author();
        let block_epoch = block.epoch();
        let block_timestamp = block.timestamp_usecs();

        // Identify any denied inline transactions
        let block_transaction_filter = block_txn_filter_config.block_transaction_filter();
        let denied_inline_transactions = block_transaction_filter.get_denied_block_transactions(
            block_id,
            block_author,
            block_epoch,
            block_timestamp,
            inline_transactions,
        );
        if !denied_inline_transactions.is_empty() {
            return Err(anyhow::anyhow!(
                "Inline transactions for QuorumStorePayload denied by block transaction filter: {:?}",
                denied_inline_transactions
            ));
        }

        Ok(()) // No transactions were denied
    }
```

**File:** consensus/src/payload_manager/quorum_store_payload_manager.rs (L568-599)
```rust
fn get_inline_transactions(block: &Block) -> Vec<SignedTransaction> {
    // If the block has no payload, return an empty vector
    let Some(payload) = block.payload() else {
        return vec![];
    };

    // Fetch the inline transactions from the payload
    match payload {
        Payload::QuorumStoreInlineHybrid(inline_batches, ..) => {
            // Flatten the inline batches and return the transactions
            inline_batches
                .iter()
                .flat_map(|(_batch_info, txns)| txns.clone())
                .collect()
        },
        Payload::QuorumStoreInlineHybridV2(inline_batches, ..) => {
            // Flatten the inline batches and return the transactions
            inline_batches
                .iter()
                .flat_map(|(_batch_info, txns)| txns.clone())
                .collect()
        },
        Payload::OptQuorumStore(OptQuorumStorePayload::V1(p)) => p.inline_batches().transactions(),
        Payload::OptQuorumStore(OptQuorumStorePayload::V2(_p)) => {
            error!("OptQSPayload V2 is not expected");
            Vec::new()
        },
        _ => {
            vec![] // Other payload types do not have inline transactions
        },
    }
}
```

**File:** consensus/src/payload_manager/direct_mempool_payload_manager.rs (L30-70)
```rust
    fn check_denied_inline_transactions(
        &self,
        block: &Block,
        block_txn_filter_config: &BlockTransactionFilterConfig,
    ) -> anyhow::Result<()> {
        // If the filter is disabled, return early
        if !block_txn_filter_config.is_enabled() {
            return Ok(());
        }

        // Get the inline transactions for the block proposal. Note: all
        // transactions in a direct mempool payload are inline transactions.
        let (inline_transactions, _, _) = get_transactions_from_block(block)?;
        if inline_transactions.is_empty() {
            return Ok(());
        }

        // Fetch the block metadata
        let block_id = block.id();
        let block_author = block.author();
        let block_epoch = block.epoch();
        let block_timestamp = block.timestamp_usecs();

        // Identify any denied inline transactions
        let block_transaction_filter = block_txn_filter_config.block_transaction_filter();
        let denied_inline_transactions = block_transaction_filter.get_denied_block_transactions(
            block_id,
            block_author,
            block_epoch,
            block_timestamp,
            inline_transactions,
        );
        if !denied_inline_transactions.is_empty() {
            return Err(anyhow::anyhow!(
                "Inline transactions for DirectMempoolPayload denied by block transaction filter: {:?}",
                denied_inline_transactions
            ));
        }

        Ok(()) // No transactions were denied
    }
```
