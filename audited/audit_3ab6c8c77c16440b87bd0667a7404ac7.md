# Audit Report

## Title
Consensus Safety Violation: Missing QuorumCert Signature Verification During Recovery from ConsensusDB

## Summary
The Aptos consensus layer does not cryptographically verify QuorumCert signatures when recovering from persistent storage (ConsensusDB). An attacker with filesystem access can inject forged QuorumCerts with invalid signatures that will be accepted during node restart, potentially violating consensus safety guarantees.

## Finding Description

During node recovery, the consensus layer loads blocks and QuorumCerts from ConsensusDB without performing signature verification. This creates a critical trust boundary violation where data from persistent storage is accepted without cryptographic validation.

**The vulnerability exists in the recovery flow:**

1. **Storage Loading**: `StorageWriteProxy::start()` loads QuorumCerts from ConsensusDB via BCS deserialization: [1](#0-0) 

2. **Structural-Only Validation**: `RecoveryData::new()` calls `find_root()` which only validates structural consistency (parent-child relationships, block topology), but **does NOT verify signatures**: [2](#0-1) 

3. **Block Store Insertion**: `BlockStore::build()` inserts QuorumCerts via `insert_single_quorum_cert()` which validates that the QC matches the local block info, but **does NOT call `qc.verify()`**: [3](#0-2) 

4. **Signature Verification Function Exists But Is Not Called**: The `QuorumCert::verify()` method exists and validates signatures using `ValidatorVerifier`, but it is **only called by SafetyRules during normal operation**, not during recovery: [4](#0-3) 

5. **SafetyRules Only Verifies New Proposals**: The `verify_qc()` function in SafetyRules validates signatures for newly received proposals, but is **not invoked during recovery**: [5](#0-4) 

**Attack Vector:**

An attacker who gains filesystem access to a validator node's ConsensusDB can:

1. Craft a malicious QuorumCert with forged BLS signatures for a conflicting block
2. Serialize it using BCS and inject it into the `quorum_certificate` column family in ConsensusDB, keyed by the target block hash: [6](#0-5) 

3. Restart the validator node
4. The forged QC will be loaded, deserialized, and accepted without signature verification
5. The node will use this forged QC in its consensus state, potentially:
   - Accepting conflicting blocks as certified
   - Violating consensus safety by voting on incompatible chains
   - Creating chain splits if multiple validators are compromised

**Comparison with Network Path**: When QuorumCerts are received from network peers during sync, they ARE verified through `SyncInfo::verify()`: [7](#0-6) 

This creates an inconsistent trust model where network data is verified but persistent storage data is trusted blindly.

## Impact Explanation

**Critical Severity** - This vulnerability can lead to **Consensus Safety Violations**, which falls under the Critical category (up to $1,000,000) in the Aptos Bug Bounty program.

**Specific Impacts:**

1. **Consensus Safety Violation**: An attacker can inject forged QCs that certify conflicting blocks, violating the fundamental safety guarantee that < 1/3 Byzantine validators cannot cause chain splits

2. **Defense in Depth Failure**: The system fails to implement defense in depth by trusting persistent storage without verification, making it vulnerable to:
   - Database corruption attacks
   - Compromised backups
   - Container escape scenarios
   - OS-level vulnerabilities that grant filesystem access

3. **State Persistence**: Unlike transient network attacks, forged QCs persist across restarts, creating a permanent compromise until detected and manually remediated

4. **Multi-Validator Attack**: If an attacker compromises multiple validators' ConsensusDB instances, they can coordinate to create widespread consensus violations

## Likelihood Explanation

**Moderate to High Likelihood** in realistic threat scenarios:

**Attack Prerequisites:**
- Filesystem write access to ConsensusDB directory on validator node
- Knowledge of BCS serialization format
- Understanding of consensus internals

**Feasible Attack Scenarios:**

1. **Stolen Database Backups**: Validators often create backups of their state. If backups are stolen or leaked, an attacker can modify the ConsensusDB, inject forged QCs, and convince the validator to restore from the compromised backup.

2. **Container Escape**: In containerized deployments, container escape vulnerabilities could grant filesystem access to the host's ConsensusDB.

3. **OS Kernel Vulnerabilities**: Privilege escalation vulnerabilities in the OS kernel could grant filesystem access to an initially unprivileged attacker.

4. **Supply Chain Attacks**: Compromised monitoring or backup tools with filesystem access could inject forged QCs.

5. **Insider Threats**: While not the primary threat model, malicious operators with node access could perform this attack.

The likelihood is increased by:
- The complete absence of verification (no defense in depth)
- The persistence of the attack across restarts
- The deterministic exploitation path once filesystem access is obtained

## Recommendation

**Implement signature verification during recovery from ConsensusDB:**

Add QuorumCert signature verification in the recovery flow. Modify `BlockStore::build()` or `insert_single_quorum_cert()` to verify QC signatures when inserting during recovery:

```rust
// In consensus/src/block_storage/block_store.rs
// Modify the build() function to accept a ValidatorVerifier

for qc in quorum_certs {
    // Add signature verification before insertion
    if let Err(e) = qc.verify(&epoch_state.verifier) {
        warn!(
            "Recovered QC failed signature verification: {}. Ignoring invalid QC.",
            e
        );
        continue; // Skip invalid QCs
    }
    
    block_store
        .insert_single_quorum_cert(qc)
        .unwrap_or_else(|e| {
            panic!("[BlockStore] failed to insert quorum during build{:?}", e)
        });
}
```

**Alternative Approach:** Add cryptographic integrity protection to ConsensusDB:
- Use authenticated encryption for ConsensusDB entries
- Implement HMAC-based integrity checking
- Sign database entries with validator's private key

**Defense in Depth:** Even with filesystem access restrictions, cryptographic verification should always be performed to ensure system integrity.

## Proof of Concept

```rust
// Proof of Concept demonstrating the vulnerability
// This would be a test in consensus/src/block_storage/block_store_test.rs

#[tokio::test]
async fn test_forged_qc_accepted_during_recovery() {
    use aptos_crypto::bls12381;
    use aptos_consensus_types::{
        block::Block,
        quorum_cert::QuorumCert,
        vote_data::VoteData,
    };
    use aptos_types::{
        aggregate_signature::AggregateSignature,
        ledger_info::{LedgerInfo, LedgerInfoWithSignatures},
    };
    
    // Setup: Create a legitimate block and validator set
    let (mut runtime, mut block_store, validators) = setup_test_environment();
    
    // Create a block
    let block = Block::make_block(/* ... */);
    block_store.insert_block(block.clone()).await.unwrap();
    
    // Forge a QC with INVALID signatures
    let vote_data = VoteData::new(block.block_info(), block.block_info());
    let ledger_info = LedgerInfo::new(block.block_info(), vote_data.hash());
    
    // Create an empty/invalid aggregate signature (forged)
    let forged_signature = AggregateSignature::empty();
    let forged_li = LedgerInfoWithSignatures::new(ledger_info, forged_signature);
    let forged_qc = QuorumCert::new(vote_data, forged_li);
    
    // Inject forged QC into ConsensusDB
    block_store.storage.save_tree(vec![], vec![forged_qc.clone()]).unwrap();
    
    // Restart: Recover from storage
    let recovery_data = block_store.storage.start(false, None);
    
    // VULNERABILITY: The forged QC is accepted without verification
    match recovery_data {
        LivenessStorageData::FullRecoveryData(data) => {
            // The forged QC is in the recovered data
            assert!(data.quorum_certs.contains(&forged_qc));
            println!("VULNERABILITY CONFIRMED: Forged QC accepted without verification!");
        },
        _ => panic!("Recovery should succeed with forged QC"),
    }
    
    // Verify that the forged QC would FAIL signature verification if checked
    let verifier = validators.verifier();
    assert!(forged_qc.verify(&verifier).is_err(), 
            "Forged QC should fail verification");
}
```

**Notes:**

This vulnerability violates the **Cryptographic Correctness** invariant ("BLS signatures, VRF, and hash operations must be secure") and the **Consensus Safety** invariant ("AptosBFT must prevent double-spending and chain splits under < 1/3 Byzantine"). The system should never trust data from persistent storage without cryptographic verification, as this creates a critical trust boundary violation that can be exploited to compromise consensus safety.

### Citations

**File:** consensus/src/persistent_liveness_storage.rs (L358-383)
```rust
        let root = ledger_recovery_data
            .find_root(
                &mut blocks,
                &mut quorum_certs,
                order_vote_enabled,
                window_size,
            )
            .with_context(|| {
                // for better readability
                blocks.sort_by_key(|block| block.round());
                quorum_certs.sort_by_key(|qc| qc.certified_block().round());
                format!(
                    "\nRoot: {}\nBlocks in db: {}\nQuorum Certs in db: {}\n",
                    ledger_recovery_data.storage_ledger.ledger_info(),
                    blocks
                        .iter()
                        .map(|b| format!("\n{}", b))
                        .collect::<Vec<String>>()
                        .concat(),
                    quorum_certs
                        .iter()
                        .map(|qc| format!("\n{}", qc))
                        .collect::<Vec<String>>()
                        .concat(),
                )
            })?;
```

**File:** consensus/src/persistent_liveness_storage.rs (L519-547)
```rust
    fn start(&self, order_vote_enabled: bool, window_size: Option<u64>) -> LivenessStorageData {
        info!("Start consensus recovery.");
        let raw_data = self
            .db
            .get_data()
            .expect("unable to recover consensus data");

        let last_vote = raw_data
            .0
            .map(|bytes| bcs::from_bytes(&bytes[..]).expect("unable to deserialize last vote"));

        let highest_2chain_timeout_cert = raw_data.1.map(|b| {
            bcs::from_bytes(&b).expect("unable to deserialize highest 2-chain timeout cert")
        });
        let blocks = raw_data.2;
        let quorum_certs: Vec<_> = raw_data.3;
        let blocks_repr: Vec<String> = blocks.iter().map(|b| format!("\n\t{}", b)).collect();
        info!(
            "The following blocks were restored from ConsensusDB : {}",
            blocks_repr.concat()
        );
        let qc_repr: Vec<String> = quorum_certs
            .iter()
            .map(|qc| format!("\n\t{}", qc))
            .collect();
        info!(
            "The following quorum certs were restored from ConsensusDB: {}",
            qc_repr.concat()
        );
```

**File:** consensus/src/block_storage/block_store.rs (L519-556)
```rust
    pub fn insert_single_quorum_cert(&self, qc: QuorumCert) -> anyhow::Result<()> {
        // If the parent block is not the root block (i.e not None), ensure the executed state
        // of a block is consistent with its QuorumCert, otherwise persist the QuorumCert's
        // state and on restart, a new execution will agree with it.  A new execution will match
        // the QuorumCert's state on the next restart will work if there is a memory
        // corruption, for example.
        match self.get_block(qc.certified_block().id()) {
            Some(pipelined_block) => {
                ensure!(
                    // decoupled execution allows dummy block infos
                    pipelined_block
                        .block_info()
                        .match_ordered_only(qc.certified_block()),
                    "QC for block {} has different {:?} than local {:?}",
                    qc.certified_block().id(),
                    qc.certified_block(),
                    pipelined_block.block_info()
                );
                observe_block(
                    pipelined_block.block().timestamp_usecs(),
                    BlockStage::QC_ADDED,
                );
                if pipelined_block.block().is_opt_block() {
                    observe_block(
                        pipelined_block.block().timestamp_usecs(),
                        BlockStage::QC_ADDED_OPT_BLOCK,
                    );
                }
                pipelined_block.set_qc(Arc::new(qc.clone()));
            },
            None => bail!("Insert {} without having the block in store first", qc),
        };

        self.storage
            .save_tree(vec![], vec![qc.clone()])
            .context("Insert block failed when saving quorum")?;
        self.inner.write().insert_quorum_cert(qc)
    }
```

**File:** consensus/consensus-types/src/quorum_cert.rs (L119-148)
```rust
    pub fn verify(&self, validator: &ValidatorVerifier) -> anyhow::Result<()> {
        let vote_hash = self.vote_data.hash();
        ensure!(
            self.ledger_info().ledger_info().consensus_data_hash() == vote_hash,
            "Quorum Cert's hash mismatch LedgerInfo"
        );
        // Genesis's QC is implicitly agreed upon, it doesn't have real signatures.
        // If someone sends us a QC on a fake genesis, it'll fail to insert into BlockStore
        // because of the round constraint.
        if self.certified_block().round() == 0 {
            ensure!(
                self.parent_block() == self.certified_block(),
                "Genesis QC has inconsistent parent block with certified block"
            );
            ensure!(
                self.certified_block() == self.ledger_info().ledger_info().commit_info(),
                "Genesis QC has inconsistent commit block with certified block"
            );
            ensure!(
                self.ledger_info().get_num_voters() == 0,
                "Genesis QC should not carry signatures"
            );
            return Ok(());
        }
        self.ledger_info()
            .verify_signatures(validator)
            .context("Fail to verify QuorumCert")?;
        self.vote_data.verify()?;
        Ok(())
    }
```

**File:** consensus/safety-rules/src/safety_rules.rs (L235-243)
```rust
    pub(crate) fn verify_qc(&self, qc: &QuorumCert) -> Result<(), Error> {
        let epoch_state = self.epoch_state()?;

        if !self.skip_sig_verify {
            qc.verify(&epoch_state.verifier)
                .map_err(|e| Error::InvalidQuorumCertificate(e.to_string()))?;
        }
        Ok(())
    }
```

**File:** consensus/src/consensusdb/schema/quorum_certificate/mod.rs (L35-43)
```rust
impl ValueCodec<QCSchema> for QuorumCert {
    fn encode_value(&self) -> Result<Vec<u8>> {
        Ok(bcs::to_bytes(self)?)
    }

    fn decode_value(data: &[u8]) -> Result<Self> {
        Ok(bcs::from_bytes(data)?)
    }
}
```

**File:** consensus/consensus-types/src/sync_info.rs (L187-210)
```rust
        self.highest_quorum_cert
            .verify(validator)
            .and_then(|_| {
                self.highest_ordered_cert
                    .as_ref()
                    .map_or(Ok(()), |cert| cert.verify(validator))
                    .context("Fail to verify ordered certificate")
            })
            .and_then(|_| {
                // we do not verify genesis ledger info
                if self.highest_commit_cert.commit_info().round() > 0 {
                    self.highest_commit_cert
                        .verify(validator)
                        .context("Fail to verify commit certificate")?
                }
                Ok(())
            })
            .and_then(|_| {
                if let Some(tc) = &self.highest_2chain_timeout_cert {
                    tc.verify(validator)?;
                }
                Ok(())
            })
            .context("Fail to verify SyncInfo")?;
```
