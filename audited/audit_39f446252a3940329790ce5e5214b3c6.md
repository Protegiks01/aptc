# Audit Report

## Title
Lock Poisoning in SUBTREE_DROPPER Causes Validator Crash via Memory Exhaustion

## Summary
The `SUBTREE_DROPPER` static uses `NumTasksTracker` with an `aptos_infallible::Mutex` that does not handle lock poisoning. If a panic occurs while holding the mutex (e.g., during metric operations), the lock becomes poisoned and all subsequent drop operations fail, preventing memory from being freed and causing validator crash due to memory exhaustion. [1](#0-0) 

## Finding Description

The vulnerability stems from the interaction between Rust's lock poisoning mechanism and the `aptos_infallible::Mutex` wrapper used in `NumTasksTracker`.

**Architecture:**
The `AsyncConcurrentDropper` uses a `NumTasksTracker` to limit concurrent drop operations. This tracker contains an `aptos_infallible::Mutex<usize>` to coordinate access to the task counter. [2](#0-1) 

The `aptos_infallible::Mutex` wraps `std::sync::Mutex` but panics on poisoned locks rather than returning an error: [3](#0-2) 

**Vulnerability Chain:**

1. During `inc()` or `dec()` operations, the mutex is held while updating metrics: [4](#0-3) [5](#0-4) 

2. If `GAUGE.set_with()` panics while the mutex guard is held, the underlying `std::sync::Mutex` becomes poisoned.

3. All subsequent calls to `lock()` will receive a `PoisonError`, causing `aptos_infallible::Mutex::lock()` to panic.

4. The `SUBTREE_DROPPER` is used in the `Drop` implementation of sparse merkle tree nodes: [6](#0-5) 

5. Once poisoned, all `Inner::drop()` calls panic when attempting to `schedule_drop()`.

6. Additionally, `get_state_summary()` calls `wait_for_backlog_drop()` which also accesses the poisoned lock: [7](#0-6) 

7. Memory from old merkle tree nodes cannot be freed, leading to memory exhaustion.

**Invariant Violation:**
This violates the Aptos secure coding guideline: [8](#0-7) 

## Impact Explanation

**Critical Severity** - This meets the "Total loss of liveness/network availability" category because:

1. **Validator Crash**: Memory exhaustion forces validator restart
2. **Non-Recoverable**: Lock remains poisoned until process restart
3. **Cascading Failure**: Affects all sparse merkle tree operations
4. **State Storage Impact**: Prevents state commitment and synchronization
5. **Network Impact**: If multiple validators experience this simultaneously, network liveness is threatened

The validator's state storage mechanism becomes completely inoperable once the lock is poisoned.

## Likelihood Explanation

**Low Likelihood, Critical Impact**: While the technical vulnerability is real, the likelihood depends on factors outside attacker control:

- Requires a panic during `GAUGE.set_with()` or `cvar.notify_all()` 
- Metric operations rarely panic in normal operation
- Labels are correctly hardcoded
- Would require either: prometheus internal bug, memory exhaustion at exact moment, or dependency panic

However, this is a **defensive programming failure** rather than a directly exploitable attack vector. An unprivileged attacker cannot reliably trigger panics in the prometheus metric code.

The vulnerability is better characterized as a **reliability issue** that could be triggered by environmental factors (memory pressure, bugs in dependencies) rather than a targeted attack.

## Recommendation

Replace `aptos_infallible::Mutex` with proper lock poisoning recovery in `NumTasksTracker`:

```rust
use std::sync::Mutex as StdMutex;

impl NumTasksTracker {
    fn inc(&self) {
        let mut num_tasks = self.lock.lock().unwrap_or_else(|poisoned| {
            // Log the poisoning event
            eprintln!("NumTasksTracker lock poisoned, recovering");
            poisoned.into_inner()
        });
        // ... rest of implementation
    }
    
    fn dec(&self) {
        let mut num_tasks = self.lock.lock().unwrap_or_else(|poisoned| {
            eprintln!("NumTasksTracker lock poisoned, recovering");
            poisoned.into_inner()
        });
        // ... rest of implementation
    }
}
```

Alternatively, wrap panic-prone operations in `catch_unwind` to prevent lock poisoning:

```rust
fn inc(&self) {
    let mut num_tasks = self.lock.lock();
    while *num_tasks >= self.max_tasks {
        num_tasks = self.cvar.wait(num_tasks).unwrap_or_else(|e| e.into_inner());
    }
    *num_tasks += 1;
    
    // Prevent panic from poisoning lock
    let _ = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        GAUGE.set_with(&[self.name, "num_tasks"], *num_tasks as i64);
    }));
}
```

## Proof of Concept

```rust
#[cfg(test)]
mod test_lock_poisoning {
    use super::*;
    use std::sync::Arc;
    
    // Simulate a panic during metric update
    struct PanicOnDrop;
    impl Drop for PanicOnDrop {
        fn drop(&mut self) {
            // This simulates what happens if GAUGE.set_with() panics
            panic!("Simulated metric panic");
        }
    }
    
    #[test]
    #[should_panic(expected = "Cannot currently handle a poisoned lock")]
    fn test_lock_poisoning_prevents_future_drops() {
        let dropper = Arc::new(AsyncConcurrentDropper::new("test", 8, 4));
        
        // First drop that causes panic and poisons lock
        let dropper_clone = dropper.clone();
        let handle = std::thread::spawn(move || {
            dropper_clone.schedule_drop(PanicOnDrop);
        });
        
        // Wait for panic and lock poisoning
        let _ = handle.join();
        std::thread::sleep(std::time::Duration::from_millis(100));
        
        // This will panic with "Cannot currently handle a poisoned lock"
        dropper.schedule_drop(Vec::<u8>::new());
    }
}
```

## Notes

While the technical analysis confirms that lock poisoning **can** prevent all future drops and cause memory exhaustion, this vulnerability has a critical limitation: **there is no realistic attack path for an unprivileged attacker to trigger it**.

The panic must occur in prometheus metric code (`GAUGE.set_with()`) which is:
- Internal to the validator
- Not controllable by transaction senders, network peers, or Move module deployers
- Protected by correct label validation

This makes the issue a **code quality and defensive programming concern** rather than a directly exploitable security vulnerability. It represents a failure mode that could be triggered by environmental factors (memory pressure, dependency bugs) but not by targeted attacks.

**Validation Checklist Result**: FAILS requirement #2 - "Exploitable by unprivileged attacker (no validator insider access required)"

Given the EXTREMELY high validation bar and requirement for realistic exploitation paths, this does not qualify as a valid bounty-eligible vulnerability despite the correct technical analysis.

### Citations

**File:** storage/scratchpad/src/sparse_merkle/dropper.rs (L9-10)
```rust
pub static SUBTREE_DROPPER: Lazy<AsyncConcurrentDropper> =
    Lazy::new(|| AsyncConcurrentDropper::new("smt_subtree", 32, 8));
```

**File:** crates/aptos-drop-helper/src/async_concurrent_dropper.rs (L95-100)
```rust
struct NumTasksTracker {
    name: &'static str,
    lock: Mutex<usize>,
    cvar: Condvar,
    max_tasks: usize,
}
```

**File:** crates/aptos-drop-helper/src/async_concurrent_dropper.rs (L112-119)
```rust
    fn inc(&self) {
        let mut num_tasks = self.lock.lock();
        while *num_tasks >= self.max_tasks {
            num_tasks = self.cvar.wait(num_tasks).expect("lock poisoned.");
        }
        *num_tasks += 1;
        GAUGE.set_with(&[self.name, "num_tasks"], *num_tasks as i64);
    }
```

**File:** crates/aptos-drop-helper/src/async_concurrent_dropper.rs (L121-126)
```rust
    fn dec(&self) {
        let mut num_tasks = self.lock.lock();
        *num_tasks -= 1;
        GAUGE.set_with(&[self.name, "num_tasks"], *num_tasks as i64);
        self.cvar.notify_all();
    }
```

**File:** crates/aptos-infallible/src/mutex.rs (L19-23)
```rust
    pub fn lock(&self) -> MutexGuard<'_, T> {
        self.0
            .lock()
            .expect("Cannot currently handle a poisoned lock")
    }
```

**File:** storage/scratchpad/src/sparse_merkle/mod.rs (L117-120)
```rust
impl Drop for Inner {
    fn drop(&mut self) {
        // Drop the root in a different thread, because that's the slowest part.
        SUBTREE_DROPPER.schedule_drop(self.root.take());
```

**File:** storage/aptosdb/src/state_store/persisted_state.rs (L31-38)
```rust
    pub fn get_state_summary(&self) -> StateSummary {
        let _timer = OTHER_TIMERS_SECONDS.timer_with(&["get_persisted_state_summary"]);

        // The back pressure is on the getting side (which is the execution side) so that it's less
        // likely for a lot of blocks locking the same old base SMT.
        SUBTREE_DROPPER.wait_for_backlog_drop(Self::MAX_PENDING_DROPS);

        self.summary.lock().clone()
```

**File:** RUST_SECURE_CODING.md (L93-94)
```markdown
In a Rust secure development, the implementation of the `std::ops::Drop` trait
must not panic.
```
