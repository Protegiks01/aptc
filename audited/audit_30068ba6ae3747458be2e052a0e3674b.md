# Audit Report

## Title
Resource Access Control Bypass via Missing Access Specifiers

## Summary
When the `enable_resource_access_control` feature is enabled, functions with missing access specifiers (`None`) are treated as having unrestricted access (`AccessSpecifier::Any`) instead of being rejected or defaulting to deny-all. This allows attackers to bypass resource access control by publishing modules with functions that intentionally omit access specifier declarations.

## Finding Description

The vulnerability exists in the semantic interpretation of missing access specifiers and the lack of enforcement when the resource access control feature is enabled.

**The Attack Path:**

1. The `access_specifiers()` function returns `None` when a function handle has no access specifiers declared. [1](#0-0) 

2. During function loading, `None` is explicitly converted to `AccessSpecifier::Any`: [2](#0-1) 

3. The documentation confirms this behavior as intentional: "If this is `None`, all accesses are allowed." [3](#0-2) 

4. At runtime, `AccessSpecifier::Any` always returns `true` from the `enables()` check, granting unrestricted access: [4](#0-3) 

5. When entering a function with `AccessSpecifier::Any`, the runtime takes a shortcut and does not push any restrictions onto the access control stack: [5](#0-4) 

6. When `check_access()` runs with an empty stack (or only `Any` on stack), all resource accesses are permitted: [6](#0-5) 

**The Verification Gap:**

The bytecode verifier only checks that access specifiers are NOT used when the feature is disabled, but does NOT enforce that access specifiers MUST be present when the feature is enabled: [7](#0-6) 

The compiler can generate function handles with `None` for access_specifiers even when the feature is enabled: [8](#0-7) 

**Exploitation Scenario:**

An attacker publishes a malicious Move module with entry functions that have no access specifiers. When `enable_resource_access_control` is enabled:
- The module passes verification (no error for missing specifiers)
- The functions load with `AccessSpecifier::Any`
- Transactions calling these functions can access ANY global resource
- This bypasses the intended access control mechanism

## Impact Explanation

**Severity: Critical**

This vulnerability breaks Critical Invariant #8 (Access Control) and potentially enables:

1. **Unauthorized Resource Access**: Functions can read/write any global resource, including system resources at privileged addresses like `@aptos_framework` and `@core_resources`

2. **Consensus Safety Violation**: Different validators may have different versions with varying access control enforcement, leading to consensus splits if some enforce restrictions while others allow bypass

3. **Potential Loss of Funds**: Malicious modules could manipulate token balances, steal from accounts, or corrupt staking/governance state

4. **State Consistency Violation**: Unauthorized state modifications could corrupt the Jellyfish Merkle tree state or critical system resources

This meets the **Critical Severity** criteria ($1,000,000 impact tier) for:
- Consensus/Safety violations
- Potential loss of funds
- Access control failures allowing system address compromise

## Likelihood Explanation

**Likelihood: Medium-High**

- **Attack Complexity**: Low - attacker only needs to publish a module without access specifiers
- **Prerequisites**: Ability to publish modules (achievable by any user with sufficient gas)
- **Detection**: May be difficult to detect without analyzing bytecode for missing access specifiers
- **Current Deployment**: If `enable_resource_access_control` feature is enabled in production, this is immediately exploitable

The main uncertainty is whether the feature flag is currently enabled on mainnet. If enabled, exploitation is straightforward and highly likely.

## Recommendation

**Immediate Fix:**

When `enable_resource_access_control` is enabled, the bytecode verifier should enforce that all functions accessing global resources MUST have explicit access specifiers. Modify the verifier to reject modules with `None` access specifiers:

```rust
// In features.rs verify_function_handles()
if config.enable_resource_access_control {
    for (idx, function_handle) in self.code.function_handles().iter().enumerate() {
        // For functions that could access global state, require explicit specifiers
        if function_handle.access_specifiers.is_none() {
            // Could add heuristic: check if function has acquires_global_resources
            // or if it's an entry function, then require specifiers
            return Err(PartialVMError::new(StatusCode::MISSING_ACCESS_SPECIFIERS)
                .at_index(IndexKind::FunctionHandle, idx as u16)
                .with_message("access specifiers required when feature is enabled".to_string()));
        }
    }
}
```

**Alternative Fix:**

Change the semantic interpretation in `load_access_specifier()` to default to deny-all instead of allow-all when specifiers are missing:

```rust
// In access_specifier_loader.rs
if let Some(specs) = specifier {
    // ... existing logic ...
    Ok(AccessSpecifier::Constraint(incls, excls))
} else {
    // When feature is enabled, missing specifiers = deny all access
    // Return empty constraint (no inclusions, no exclusions) which denies all
    Ok(AccessSpecifier::Constraint(vec![], vec![]))
}
```

**Long-term Solution:**

1. Deprecate the `None` option entirely once all legacy modules are migrated
2. Require explicit access specifiers for all functions when the feature is enabled
3. Add static analysis to detect functions accessing global resources without proper declarations

## Proof of Concept

```move
// malicious_module.move
module attacker::exploit {
    use std::signer;
    use aptos_framework::coin;
    
    // Entry function with NO access specifiers declared
    // When compiled, this gets access_specifiers: None
    // At runtime, this becomes AccessSpecifier::Any
    entry fun steal_coins<CoinType>(attacker: &signer, victim: address) {
        // Without proper access specifiers, this function can:
        // 1. Access any account's CoinStore
        // 2. Manipulate balances
        // 3. Access system resources
        
        // This should be blocked by access control but isn't
        // because None -> Any -> unrestricted access
        let victim_balance = coin::balance<CoinType>(victim);
        
        // Could perform unauthorized transfers or state modifications
        // bypassing all resource access control checks
    }
}
```

The PoC demonstrates that a function without explicit `reads`/`writes` clauses in its signature will have `access_specifiers: None` in the compiled bytecode, which bypasses access control when the feature is enabled.

## Notes

This vulnerability represents a fundamental flaw in the security model transition: when access control is enabled, the default should be "deny all" (fail secure), not "allow all" (fail open). The current implementation treats missing access specifiers as backward-compatible unrestricted access, which defeats the entire purpose of the access control feature when applied to newly published modules.

### Citations

**File:** third_party/move/move-binary-format/src/views.rs (L344-346)
```rust
    pub fn access_specifiers(&self) -> Option<&Vec<AccessSpecifier>> {
        self.function_handle.access_specifiers.as_ref()
    }
```

**File:** third_party/move/move-vm/runtime/src/loader/access_specifier_loader.rs (L20-48)
```rust
pub fn load_access_specifier(
    module: BinaryIndexedView,
    signature_table: &[Vec<Type>],
    struct_names: &[StructIdentifier],
    specifier: &Option<Vec<FF::AccessSpecifier>>,
) -> PartialVMResult<AccessSpecifier> {
    if let Some(specs) = specifier {
        let mut incls = vec![];
        let mut excls = vec![];
        for spec in specs {
            let resource =
                load_resource_specifier(module, signature_table, struct_names, &spec.resource)?;
            let address = load_address_specifier(module, &spec.address)?;
            let clause = AccessSpecifierClause {
                kind: spec.kind,
                resource,
                address,
            };
            if spec.negated {
                excls.push(clause)
            } else {
                incls.push(clause)
            }
        }
        Ok(AccessSpecifier::Constraint(incls, excls))
    } else {
        Ok(AccessSpecifier::Any)
    }
}
```

**File:** third_party/move/move-model/src/model.rs (L5110-5118)
```rust
    /// Returns the access specifiers of this function.
    /// If this is `None`, all accesses are allowed. If the list is empty,
    /// no accesses are allowed. Otherwise the list is divided into _inclusions_ and _exclusions_,
    /// the later being negated specifiers. Access is allowed if (a) any of the inclusion
    /// specifiers allows it (union of inclusion specifiers) (b) none of the exclusions
    /// specifiers disallows it (intersection of exclusion specifiers).
    pub fn get_access_specifiers(&self) -> Option<&[AccessSpecifier]> {
        self.data.access_specifiers.as_deref()
    }
```

**File:** third_party/move/move-vm/types/src/loaded_data/runtime_access_specifier.rs (L144-153)
```rust
    pub fn enables(&self, access: &AccessInstance) -> bool {
        use AccessSpecifier::*;
        match self {
            Any => true,
            Constraint(incls, excls) => {
                (incls.is_empty() && !excls.is_empty() || incls.iter().any(|c| c.includes(access)))
                    && excls.iter().all(|c| !c.excludes(access))
            },
        }
    }
```

**File:** third_party/move/move-vm/runtime/src/access_control.rs (L26-49)
```rust
    pub(crate) fn enter_function(
        &mut self,
        env: &impl AccessSpecifierEnv,
        fun: &LoadedFunction,
    ) -> PartialVMResult<()> {
        if matches!(fun.access_specifier(), AccessSpecifier::Any) {
            // Shortcut case that no access is specified
            return Ok(());
        }
        if self.specifier_stack.len() >= ACCESS_STACK_SIZE_LIMIT {
            Err(
                PartialVMError::new(StatusCode::ACCESS_STACK_LIMIT_EXCEEDED).with_message(format!(
                    "access specifier stack overflow (limit = {})",
                    ACCESS_STACK_SIZE_LIMIT
                )),
            )
        } else {
            // Specialize the functions access specifier and push it on the stack.
            let mut fun_specifier = fun.access_specifier().clone();
            fun_specifier.specialize(env)?;
            self.specifier_stack.push(fun_specifier);
            Ok(())
        }
    }
```

**File:** third_party/move/move-vm/runtime/src/access_control.rs (L69-77)
```rust
    pub(crate) fn check_access(&self, access: AccessInstance) -> PartialVMResult<()> {
        for specifier in self.specifier_stack.iter().rev() {
            if !specifier.enables(&access) {
                return Err(PartialVMError::new(StatusCode::ACCESS_DENIED)
                    .with_message(format!("not allowed to perform `{}`", access)));
            }
        }
        Ok(())
    }
```

**File:** third_party/move/move-bytecode-verifier/src/features.rs (L108-126)
```rust
    fn verify_function_handles(&self) -> PartialVMResult<()> {
        if !self.config.enable_resource_access_control || !self.config.enable_function_values {
            for (idx, function_handle) in self.code.function_handles().iter().enumerate() {
                if !self.config.enable_resource_access_control
                    && function_handle.access_specifiers.is_some()
                {
                    return Err(PartialVMError::new(StatusCode::FEATURE_NOT_ENABLED)
                        .at_index(IndexKind::FunctionHandle, idx as u16)
                        .with_message("resource access control feature not enabled".to_string()));
                }
                if !self.config.enable_function_values && !function_handle.attributes.is_empty() {
                    return Err(PartialVMError::new(StatusCode::FEATURE_NOT_ENABLED)
                        .at_index(IndexKind::FunctionDefinition, idx as u16)
                        .with_message("function value feature not enabled".to_string()));
                }
            }
        }
        Ok(())
    }
```

**File:** third_party/move/move-compiler-v2/src/file_format_generator/module_generator.rs (L576-600)
```rust
        let access_specifiers = fun_env
            .get_access_specifiers()
            .as_ref()
            .map(|v| {
                v.iter()
                    .filter_map(|s| self.access_specifier(ctx, fun_env, s))
                    .collect_vec()
            })
            .and_then(|specs| if specs.is_empty() { None } else { Some(specs) });
        if !self.gen_access_specifiers && access_specifiers.is_some() {
            ctx.error(loc, "access specifiers not enabled");
        }
        let attributes = if self.gen_function_attributes {
            ctx.function_attributes(fun_env)
        } else {
            vec![]
        };
        let handle = FF::FunctionHandle {
            module,
            name,
            type_parameters,
            parameters,
            return_,
            access_specifiers,
            attributes,
```
