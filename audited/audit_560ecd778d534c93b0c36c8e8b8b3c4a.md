# Audit Report

## Title
Timing Attack Vulnerability in Faucet Auth Token Verification Due to Non-Constant-Time String Comparison

## Summary
The `AuthTokenChecker::check()` function uses non-constant-time string comparison for authentication token validation, enabling potential timing side-channel attacks to extract valid tokens through statistical analysis of response times.

## Finding Description

The authentication token checker in the Aptos faucet performs token validation using standard string comparison operations that are not constant-time. [1](#0-0) 

The vulnerable code path is:
1. `AuthTokenChecker::check()` extracts the auth token from the Authorization header [2](#0-1) 
2. It calls `self.manager.contains(auth_token)` which delegates to `ListManager::contains()` [3](#0-2) 
3. The `ListManager` uses a `HashSet<String>` for storage [4](#0-3) 
4. Rust's `HashSet::contains()` uses standard string equality (`==`) which short-circuits on the first character mismatch, creating timing variations based on the number of matching prefix characters

**Attack Scenario:**
An attacker can iteratively reconstruct a valid auth token by:
1. Sending requests with candidate tokens sharing different prefix lengths with valid tokens
2. Measuring response times statistically over many requests
3. Observing that tokens with longer matching prefixes take slightly longer to reject
4. Building the token character-by-character through this timing oracle

The same vulnerability exists in `AuthTokenBypasser` which uses identical comparison logic. [5](#0-4) 

**Invariant Violated:** Cryptographic Correctness - Authentication secrets must be compared in constant time to prevent information leakage through timing side channels.

## Impact Explanation

This vulnerability is classified as **Medium Severity** per the Aptos bug bounty program criteria ("Limited funds loss or manipulation").

If an attacker successfully extracts a valid auth token:
- They can bypass authentication checks and gain unauthorized access to the faucet
- With `AuthTokenBypasser`, they can bypass all rate limits and security checks
- They can drain the faucet of test tokens through repeated unauthorized requests
- Impact is limited to test network funds (devnet/testnet), not mainnet assets

The vulnerability does not affect:
- Consensus or validator operations
- Mainnet funds or critical protocol functions
- State integrity or blockchain security

## Likelihood Explanation

**Likelihood: Low to Medium**

While the vulnerability is technically present, practical exploitation faces significant challenges:

**Factors Reducing Likelihood:**
- Network latency jitter (1-100ms) typically dominates the timing signal from string comparison (nanoseconds to microseconds)
- Requires thousands of requests per character position for statistical significance
- Rate limiting may prevent the rapid probing needed for effective timing analysis
- Auth tokens are likely long random strings, requiring extensive probing
- Requires sophisticated statistical analysis and controlled measurement environment

**Factors Increasing Likelihood:**
- The vulnerability is exploitable by any unprivileged network user
- Timing attacks over networks have been demonstrated in academic research
- Once a token is extracted, unauthorized access is straightforward
- The same comparison pattern is used in multiple components (checker and bypasser)

The Aptos codebase demonstrates awareness of timing attacks through its `constant_time` module for cryptographic operations, [6](#0-5)  making this omission a deviation from established security practices within the project.

## Recommendation

Implement constant-time comparison for authentication token validation using a cryptographic comparison function. The fix should:

1. Add a dependency on the `subtle` crate for constant-time operations
2. Replace the `HashSet::contains()` check with constant-time comparison logic
3. Apply the fix to both `AuthTokenChecker` and `AuthTokenBypasser`

**Recommended Fix:**

```rust
// In Cargo.toml, add:
// subtle = "2.5"

use subtle::ConstantTimeEq;

impl ListManager {
    pub fn contains(&self, item: &str) -> bool {
        // Constant-time comparison against all stored tokens
        self.items.iter().any(|token| {
            // Ensure equal length check is also constant-time aware
            if token.len() != item.len() {
                return false;
            }
            // Use constant-time byte comparison
            token.as_bytes().ct_eq(item.as_bytes()).into()
        })
    }
}
```

Alternatively, consider using HMAC-based token validation where tokens are HMACs of user identifiers, eliminating the need to store and compare raw token values.

## Proof of Concept

The following Rust benchmark demonstrates measurable timing differences in string comparison based on prefix matching:

```rust
#[cfg(test)]
mod timing_attack_poc {
    use std::collections::HashSet;
    use std::time::Instant;

    #[test]
    fn demonstrate_timing_leak() {
        // Simulated auth token
        let mut valid_tokens = HashSet::new();
        let secret_token = "SecretToken123456789ABCDEF";
        valid_tokens.insert(secret_token.to_string());

        // Measure timing for tokens with different prefix lengths
        let test_cases = vec![
            ("X", 0),  // No match
            ("S", 1),  // 1 char match
            ("SecretT", 7),  // 7 char match
            ("SecretToken123", 13),  // 13 char match
        ];

        println!("Timing measurements (averaged over 100,000 iterations):");
        for (candidate, matching_chars) in test_cases {
            let mut total_duration = 0u128;
            for _ in 0..100_000 {
                let start = Instant::now();
                let _ = valid_tokens.contains(candidate);
                total_duration += start.elapsed().as_nanos();
            }
            let avg_nanos = total_duration / 100_000;
            println!("Prefix '{}' (matches {} chars): {} ns", 
                     candidate, matching_chars, avg_nanos);
        }
        
        // On most systems, you'll observe longer times for longer matching prefixes
        // demonstrating the timing side-channel
    }

    #[test] 
    fn demonstrate_constant_time_comparison() {
        use subtle::ConstantTimeEq;
        
        let secret_token = "SecretToken123456789ABCDEF";
        
        println!("\nConstant-time comparison (averaged over 100,000 iterations):");
        let test_cases = vec![
            "X",
            "S", 
            "SecretT",
            "SecretToken123",
        ];
        
        for candidate in test_cases {
            let mut total_duration = 0u128;
            for _ in 0..100_000 {
                let start = Instant::now();
                // Pad to same length for fair comparison
                let padded = format!("{:width$}", candidate, width = secret_token.len());
                let _ = secret_token.as_bytes().ct_eq(padded.as_bytes());
                total_duration += start.elapsed().as_nanos();
            }
            let avg_nanos = total_duration / 100_000;
            println!("Prefix '{}': {} ns", candidate, avg_nanos);
        }
        // Times should be much more consistent regardless of prefix match
    }
}
```

## Notes

- This vulnerability exists in both `AuthTokenChecker` (authentication enforcement) and `AuthTokenBypasser` (authentication bypass for trusted sources)
- The issue is a violation of cryptographic best practices rather than a critical protocol flaw
- While practical exploitation over HTTP networks is challenging due to jitter, defense-in-depth principles dictate that authentication secrets should always use constant-time comparison
- The same pattern may exist in other authentication mechanisms throughout the faucet service and should be audited
- Consider implementing token rotation and expiration policies as additional defense layers

### Citations

**File:** crates/aptos-faucet/core/src/checkers/auth_token.rs (L42-53)
```rust
        let auth_token = match data
            .headers
            .get(AUTHORIZATION)
            .and_then(|v| v.to_str().ok())
            .and_then(|v| v.split_whitespace().nth(1))
        {
            Some(auth_token) => auth_token,
            None => return Ok(vec![RejectionReason::new(
                "Either the Authorization header is missing or it is not in the form of 'Bearer <token>'".to_string(),
                RejectionReasonCode::AuthTokenInvalid,
            )]),
        };
```

**File:** crates/aptos-faucet/core/src/checkers/auth_token.rs (L54-54)
```rust
        if self.manager.contains(auth_token) {
```

**File:** crates/aptos-faucet/core/src/common/list_manager.rs (L16-18)
```rust
pub struct ListManager {
    items: HashSet<String>,
}
```

**File:** crates/aptos-faucet/core/src/common/list_manager.rs (L35-37)
```rust
    pub fn contains(&self, item: &str) -> bool {
        self.items.contains(item)
    }
```

**File:** crates/aptos-faucet/core/src/bypasser/auth_token.rs (L48-48)
```rust
        Ok(self.manager.contains(auth_token))
```

**File:** crates/aptos-crypto/src/constant_time/mod.rs (L5-9)
```rust
//! is constant-time (e.g., like scalar multiplication).

/// Module for testing that blstrs scalar multiplication is constant-time
pub mod blstrs_scalar_mul;
/// Module for testing that zkcrypto scalar multiplication is constant-time
```
