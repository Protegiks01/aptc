# Audit Report

## Title
Consensus Observer Subscription State Divergence Due to Network Timeout Mismatch

## Summary
The consensus observer configuration contains misaligned timeout values where `network_request_timeout_ms` (5 seconds) is significantly shorter than `max_subscription_timeout_ms` and `max_subscription_sync_timeout_ms` (both 15 seconds). This mismatch can cause state divergence between publishers and observers during network congestion, leading to RPC storms and degraded observer functionality.

## Finding Description
The vulnerability exists in the interaction between three timeout configurations: [1](#0-0) 

When network latency exceeds 5 seconds but is less than 15 seconds (a realistic scenario during network congestion), the following cascading failure occurs:

**Step 1: Subscribe Request Timeout** [2](#0-1) 

An observer sends a Subscribe RPC with a 5-second timeout. If the network is congested and the request takes 6 seconds to reach the publisher:
- Observer side: Times out at 5s, marks subscription creation as failed
- Publisher side: Receives request at 6s, adds observer to `active_subscribers`, sends SubscribeAck (never received)

**Step 2: State Divergence**
The publisher believes the observer is subscribed and begins sending consensus messages (OrderedBlock, CommitDecision, BlockPayload) at the block production rate (potentially multiple per second).

**Step 3: Message Rejection and RPC Storm** [3](#0-2) 

Each consensus message received by the observer triggers: [4](#0-3) 

The observer rejects the message and spawns an asynchronous Unsubscribe request: [5](#0-4) 

If network congestion persists, these Unsubscribe RPCs also timeout at 5 seconds, never reaching the publisher. The publisher continues sending messages, and **every single consensus message triggers another Unsubscribe RPC attempt**.

**Step 4: Cascading Failure**
With high-frequency consensus messages and no rate limiting, this creates:
- Multiple Unsubscribe RPC attempts per second
- Wasted network bandwidth from publisher sending unwanted messages
- Observer unable to establish stable subscriptions
- Resource exhaustion on both publisher and observer nodes

## Impact Explanation
This qualifies as **Medium Severity** under the Aptos bug bounty criteria for "State inconsistencies requiring intervention":

1. **State Inconsistency**: Publisher and observer have divergent views of subscription state
2. **Resource Exhaustion**: RPC storm (multiple unsubscribe attempts per second) wastes network and CPU resources
3. **Service Degradation**: Consensus observers cannot function properly, affecting network participants who rely on them
4. **Validator Impact**: Validators act as publishers [6](#0-5)  and may experience resource pressure from managing many broken subscriptions

The lack of rate limiting or backoff mechanisms exacerbates the issue - there is no circuit breaker to prevent the RPC storm.

## Likelihood Explanation
**High Likelihood** - This issue will occur naturally under common network conditions:
- Network latency >5s is common in distributed systems, especially during congestion
- No attacker action required - normal network variability triggers it
- Aptos blocks are produced frequently in high-throughput scenarios, amplifying the RPC storm
- The 3x difference between network timeout (5s) and subscription timeout (15s) creates a large window for state divergence

## Recommendation
Implement three fixes:

**1. Align Timeout Values**
```rust
pub struct ConsensusObserverConfig {
    // Increase network timeout to match subscription expectations
    pub network_request_timeout_ms: u64, // Change from 5_000 to 20_000 (20 seconds)
    pub max_subscription_timeout_ms: u64, // Keep at 15_000
    pub max_subscription_sync_timeout_ms: u64, // Keep at 15_000
}
```

**2. Add Rate Limiting to Unsubscribe Requests**
In `verify_message_for_subscription`, track unsubscribe attempts and implement exponential backoff:
```rust
// Add to ConsensusObserverSubscription
last_unsubscribe_attempt: Option<Instant>,
unsubscribe_backoff_duration: Duration,

// In verify_message_for_subscription
if let Some(last_attempt) = self.last_unsubscribe_attempt {
    if last_attempt.elapsed() < self.unsubscribe_backoff_duration {
        return Err(Error::InvalidMessageError(...)); // Skip unsubscribe
    }
}
self.last_unsubscribe_attempt = Some(Instant::now());
self.unsubscribe_backoff_duration *= 2; // Exponential backoff
self.unsubscribe_from_peer(message_sender);
```

**3. Add Publisher-Side Timeout Detection**
Publishers should detect when observers are not acknowledging messages and proactively remove stale subscriptions.

## Proof of Concept

```rust
// Test demonstrating the timeout mismatch vulnerability
#[tokio::test]
async fn test_subscription_state_divergence_from_timeout_mismatch() {
    use std::time::Duration;
    use tokio::time::sleep;
    
    // Create consensus observer with default config (5s network timeout)
    let config = ConsensusObserverConfig::default();
    let (publisher, observer) = setup_publisher_and_observer(config);
    
    // Simulate network delay of 6 seconds (exceeds network_request_timeout_ms)
    let delayed_subscribe = async {
        sleep(Duration::from_secs(6)).await;
        // Subscribe request reaches publisher after observer timeout
    };
    
    // Observer sends subscribe with 5s timeout
    let observer_result = tokio::time::timeout(
        Duration::from_millis(config.network_request_timeout_ms),
        send_subscribe_request(&observer)
    ).await;
    
    // Observer times out - subscription creation fails
    assert!(observer_result.is_err(), "Observer should timeout");
    
    // Publisher receives request after 6s and adds to active_subscribers
    delayed_subscribe.await;
    assert!(publisher.has_active_subscriber(&observer.peer_id()));
    
    // Publisher sends consensus message
    publisher.publish_message(create_ordered_block());
    
    // Observer receives message but has no active subscription
    let message = observer.receive_message().await;
    let verify_result = observer.subscription_manager
        .verify_message_for_subscription(message.sender);
    
    // Verification fails, triggers unsubscribe RPC
    assert!(verify_result.is_err());
    
    // Publisher still thinks observer is subscribed
    assert!(publisher.has_active_subscriber(&observer.peer_id()));
    
    // Each subsequent message triggers another unsubscribe attempt
    for i in 0..10 {
        publisher.publish_message(create_ordered_block());
        let msg = observer.receive_message().await;
        observer.subscription_manager.verify_message_for_subscription(msg.sender)
            .expect_err("Should reject message");
        // This triggers 10 unsubscribe RPCs within seconds - RPC storm
    }
}
```

## Notes
The vulnerability is exacerbated by the fact that validators are enabled as publishers by default, meaning core consensus participants may experience resource pressure from managing broken observer subscriptions during network congestion periods.

### Citations

**File:** config/src/config/consensus_observer_config.rs (L70-76)
```rust
            network_request_timeout_ms: 5_000,                 // 5 seconds
            garbage_collection_interval_ms: 60_000,            // 60 seconds
            max_num_pending_blocks: 150, // 150 blocks (sufficient for existing production networks)
            progress_check_interval_ms: 5_000, // 5 seconds
            max_concurrent_subscriptions: 2, // 2 streams should be sufficient
            max_subscription_sync_timeout_ms: 15_000, // 15 seconds
            max_subscription_timeout_ms: 15_000, // 15 seconds
```

**File:** config/src/config/consensus_observer_config.rs (L112-117)
```rust
            NodeType::Validator => {
                if ENABLE_ON_VALIDATORS && !publisher_manually_set {
                    // Only enable the publisher for validators
                    consensus_observer_config.publisher_enabled = true;
                    modified_config = true;
                }
```

**File:** consensus/src/consensus_observer/observer/subscription_utils.rs (L136-140)
```rust
        let subscription_request = ConsensusObserverRequest::Subscribe;
        let request_timeout_ms = consensus_observer_config.network_request_timeout_ms;
        let response = consensus_observer_client
            .send_rpc_request_to_peer(&potential_peer, subscription_request, request_timeout_ms)
            .await;
```

**File:** consensus/src/consensus_observer/observer/subscription_manager.rs (L318-327)
```rust
        tokio::spawn(async move {
            // Send the unsubscribe request to the peer
            let unsubscribe_request = ConsensusObserverRequest::Unsubscribe;
            let response = consensus_observer_client
                .send_rpc_request_to_peer(
                    &peer_network_id,
                    unsubscribe_request,
                    consensus_observer_config.network_request_timeout_ms,
                )
                .await;
```

**File:** consensus/src/consensus_observer/observer/subscription_manager.rs (L361-385)
```rust
    /// Verifies that the message is from an active
    /// subscription. If not, an error is returned.
    pub fn verify_message_for_subscription(
        &mut self,
        message_sender: PeerNetworkId,
    ) -> Result<(), Error> {
        // Check if the message is from an active subscription
        if let Some(active_subscription) = self
            .active_observer_subscriptions
            .lock()
            .get_mut(&message_sender)
        {
            // Update the last message receive time and return early
            active_subscription.update_last_message_receive_time();
            return Ok(());
        }

        // Otherwise, the message is not from an active subscription.
        // Send another unsubscribe request, and return an error.
        self.unsubscribe_from_peer(message_sender);
        Err(Error::InvalidMessageError(format!(
            "Received message from unexpected peer, and not an active subscription: {}!",
            message_sender
        )))
    }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L579-594)
```rust
        if let Err(error) = self
            .subscription_manager
            .verify_message_for_subscription(peer_network_id)
        {
            // Update the rejected message counter
            increment_rejected_message_counter(&peer_network_id, &message);

            // Log the error and return
            warn!(
                LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                    "Received message that was not from an active subscription! Error: {:?}",
                    error,
                ))
            );
            return;
        }
```
