# Audit Report

## Title
Unbounded Transaction Accumulation in Batch Generator Enabling Mempool DoS via Range Search Overhead

## Summary
Byzantine validators can flood the batch generator with remote batch messages, causing transactions to accumulate unbounded in `txns_in_progress_sorted` before quota enforcement occurs. This leads to severe performance degradation when `mempool.get_batch()` performs O(M × log N) range searches on millions of excluded transactions, potentially stalling block production.

## Finding Description

The vulnerability exists in the asynchronous processing flow between batch reception and quota enforcement in the Quorum Store subsystem.

**Attack Flow:**

1. Byzantine validator(s) send `BatchMsg` containing up to `receiver_max_total_txns` (2,000) transactions per message [1](#0-0) 

2. Each message passes per-message validation in `BatchCoordinator::ensure_max_limits()` [2](#0-1) 

3. The batch is **immediately** sent to the batch generator via async channel **before** quota checking occurs [3](#0-2) 

4. The batch generator receives the command and adds all transactions to `txns_in_progress_sorted` without any quota check [4](#0-3) [5](#0-4) 

5. **Asynchronously** and **separately**, quota enforcement happens in a spawned task during `batch_store.persist()` [6](#0-5) [7](#0-6) 

6. If quota is exceeded (300,000 batches per peer), the persist fails, but transactions **remain** in `txns_in_progress_sorted` [8](#0-7) 

7. The only cleanup mechanism is expiration based on **block timestamp**, not wall-clock time [9](#0-8) 

**Critical Race Condition:**

There is no synchronization ensuring quota checks complete before transactions are added to `txns_in_progress_sorted`. The batch generator processes commands from its queue independently of the persist operation, creating a time-of-check-to-time-of-use vulnerability.

**Impact on Mempool:**

When consensus calls `mempool.get_batch()`, it passes `txns_in_progress_sorted` as `exclude_transactions`: [10](#0-9) 

For each of M transactions in the mempool, `txn_was_chosen()` performs a BTreeMap range search on the (potentially millions of) excluded transactions: [11](#0-10) 

The range search at line 411-414 has O(log N) complexity per call, resulting in O(M × log N) total complexity.

**Amplification Factors:**

- **Per-peer quota**: 300,000 batches × 100 txns/batch = 30,000,000 transactions [12](#0-11) 

- **Multiple byzantine validators**: 100 validators × 30M = 3,000,000,000 transactions
- **Sustained attack**: Remote batches expire in 500ms, but attacker can sustain flooding [13](#0-12) 

- **Positive feedback loop**: As block production slows, expiration (based on block timestamp) also slows

## Impact Explanation

**High Severity** per Aptos Bug Bounty criteria: "Validator node slowdowns"

The vulnerability breaks the **Resource Limits** invariant: "All operations must respect gas, storage, and computational limits."

**Quantified Impact:**
- With 1M excluded transactions and 100K mempool transactions: 100,000 × log₂(1,000,000) ≈ 2,000,000 BTreeMap operations per `get_batch()` call
- Consensus calls `get_batch()` multiple times per block
- Affects block production latency, potentially causing consensus timeouts
- Can cascade to network liveness issues if sufficient validators are impacted
- Does not directly cause safety violations, but severely degrades liveness

## Likelihood Explanation

**Medium-High Likelihood:**

**Requirements:**
- Attacker controls one or more validator nodes (within Byzantine threat model of <1/3 stake)
- Ability to send batch messages over the consensus network

**Ease of Exploitation:**
- Attack is straightforward: repeatedly send `BatchMsg` with 2,000 transactions
- No cryptographic breaks or complex state manipulation required
- Can be executed continuously with minimal resources
- Natural network conditions (slow consensus) amplify the attack

**Detection:**
- Metrics exist (`EXCEEDED_BATCH_QUOTA_COUNT`) but only measure persist failures, not accumulated transactions in `txns_in_progress_sorted`
- No alerting on abnormal `get_batch()` latency tied to `exclude_transactions` size

## Recommendation

**Immediate Mitigations:**

1. **Enforce quota synchronously before adding to `txns_in_progress_sorted`:**
```rust
// In BatchCoordinator::handle_batches_msg(), check quota BEFORE sending to batch_generator
for batch in &batches {
    if !self.batch_store.check_quota_available(author, batch.num_bytes()) {
        warn!("Quota exceeded for peer {}, dropping batch", author);
        return;
    }
}
// Only then send to batch_generator
```

2. **Add global limit on total `txns_in_progress_sorted` size:**
```rust
// In BatchGenerator::insert_batch()
const MAX_TOTAL_TXNS_IN_PROGRESS: usize = 1_000_000;
if self.txns_in_progress_sorted.len() + txns.len() > MAX_TOTAL_TXNS_IN_PROGRESS {
    warn!("Global transaction limit exceeded, rejecting batch");
    return;
}
```

3. **Add wall-clock based expiration as backup:**
```rust
// Clean up batches older than 5 seconds regardless of block timestamp
let wall_clock_cutoff = SystemTime::now() - Duration::from_secs(5);
// Remove expired batches based on wall_clock_cutoff
```

4. **Add metrics and alerting:**
```rust
counters::TXNS_IN_PROGRESS_SIZE.set(self.txns_in_progress_sorted.len() as i64);
counters::GET_BATCH_EXCLUDE_SIZE.observe(exclude_transactions.len() as f64);
```

**Long-term Solutions:**

- Redesign to make quota enforcement synchronous with admission control
- Consider Bloom filter or bitmap for faster exclusion checks (O(1) instead of O(log N))
- Implement per-peer rate limiting on batch message acceptance

## Proof of Concept

```rust
// Integration test demonstrating the vulnerability

#[tokio::test]
async fn test_batch_flood_dos() {
    let (mut batch_generator, tx) = setup_batch_generator();
    
    // Byzantine validator floods with batches
    let byzantine_validator = PeerId::random();
    let num_batches = 1000;
    let txns_per_batch = 2000;
    
    for i in 0..num_batches {
        let batch_id = BatchId::new(i);
        let txns = generate_signed_txns(txns_per_batch);
        
        tx.send(BatchGeneratorCommand::RemoteBatch(
            Batch::new(batch_id, txns, /* ... */)
        )).await.unwrap();
    }
    
    // Wait for processing
    tokio::time::sleep(Duration::from_secs(1)).await;
    
    // Verify txns_in_progress_sorted has grown unbounded
    let size = batch_generator.txns_in_progress_sorted_len();
    assert!(size > 1_000_000, "DoS successful: {} transactions accumulated", size);
    
    // Measure get_batch performance degradation
    let start = Instant::now();
    let exclude = batch_generator.txns_in_progress_sorted.clone();
    let _ = mempool.get_batch(100, 1MB, true, exclude);
    let elapsed = start.elapsed();
    
    assert!(elapsed > Duration::from_millis(100), 
        "get_batch severely degraded: {:?}", elapsed);
}
```

**Notes:**

This vulnerability requires byzantine validator access, which is explicitly within the Aptos consensus threat model (Byzantine Fault Tolerance assumes up to 1/3 malicious validators). The attack leverages a race condition between batch admission and quota enforcement, combined with block-timestamp-based expiration that creates a positive feedback loop when consensus slows down.

### Citations

**File:** config/src/config/quorum_store_config.rs (L80-80)
```rust
    pub receiver_max_total_txns: usize,
```

**File:** config/src/config/quorum_store_config.rs (L132-132)
```rust
            remote_batch_expiry_gap_when_init_usecs: Duration::from_millis(500).as_micros() as u64,
```

**File:** config/src/config/quorum_store_config.rs (L135-135)
```rust
            batch_quota: 300_000,
```

**File:** consensus/src/quorum_store/batch_coordinator.rs (L137-171)
```rust
    fn ensure_max_limits(&self, batches: &[Batch<BatchInfoExt>]) -> anyhow::Result<()> {
        let mut total_txns = 0;
        let mut total_bytes = 0;
        for batch in batches.iter() {
            ensure!(
                batch.num_txns() <= self.max_batch_txns,
                "Exceeds batch txn limit {} > {}",
                batch.num_txns(),
                self.max_batch_txns,
            );
            ensure!(
                batch.num_bytes() <= self.max_batch_bytes,
                "Exceeds batch bytes limit {} > {}",
                batch.num_bytes(),
                self.max_batch_bytes,
            );

            total_txns += batch.num_txns();
            total_bytes += batch.num_bytes();
        }
        ensure!(
            total_txns <= self.max_total_txns,
            "Exceeds total txn limit {} > {}",
            total_txns,
            self.max_total_txns,
        );
        ensure!(
            total_bytes <= self.max_total_bytes,
            "Exceeds total bytes limit: {} > {}",
            total_bytes,
            self.max_total_bytes,
        );

        Ok(())
    }
```

**File:** consensus/src/quorum_store/batch_coordinator.rs (L231-237)
```rust
            if let Err(e) = self
                .sender_to_batch_generator
                .send(BatchGeneratorCommand::RemoteBatch(batch.clone()))
                .await
            {
                warn!("Failed to send batch to batch generator: {}", e);
            }
```

**File:** consensus/src/quorum_store/batch_coordinator.rs (L244-244)
```rust
        self.persist_and_send_digests(persist_requests, approx_created_ts_usecs);
```

**File:** consensus/src/quorum_store/batch_generator.rs (L149-158)
```rust
        let mut txns = vec![];
        for (summary, info) in txns_in_progress {
            let txn_info = self
                .txns_in_progress_sorted
                .entry(summary)
                .or_insert_with(|| TransactionInProgress::new(info.gas_unit_price));
            txn_info.increment();
            txn_info.gas_unit_price = info.gas_unit_price.max(txn_info.gas_unit_price);
            txns.push(summary);
        }
```

**File:** consensus/src/quorum_store/batch_generator.rs (L352-358)
```rust
        let mut pulled_txns = self
            .mempool_proxy
            .pull_internal(
                max_count,
                self.config.sender_max_total_bytes as u64,
                self.txns_in_progress_sorted.clone(),
            )
```

**File:** consensus/src/quorum_store/batch_generator.rs (L392-401)
```rust
    pub(crate) fn handle_remote_batch(
        &mut self,
        author: PeerId,
        batch_id: BatchId,
        txns: Vec<SignedTransaction>,
    ) {
        let expiry_time_usecs = aptos_infallible::duration_since_epoch().as_micros() as u64
            + self.config.remote_batch_expiry_gap_when_init_usecs;
        self.insert_batch(author, batch_id, txns, expiry_time_usecs);
    }
```

**File:** consensus/src/quorum_store/batch_generator.rs (L534-552)
```rust
                            // Cleans up all batches that expire in timestamp <= block_timestamp. This is
                            // safe since clean request must occur only after execution result is certified.
                            for (author, batch_id) in self.batch_expirations.expire(block_timestamp) {
                                if let Some(batch_in_progress) = self.batches_in_progress.get(&(author, batch_id)) {
                                    // If there is an identical batch with higher expiry time, re-insert it.
                                    if batch_in_progress.expiry_time_usecs > block_timestamp {
                                        self.batch_expirations.add_item((author, batch_id), batch_in_progress.expiry_time_usecs);
                                        continue;
                                    }
                                }
                                if self.remove_batch_in_progress(author, batch_id) {
                                    counters::BATCH_IN_PROGRESS_EXPIRED.inc();
                                    debug!(
                                        "QS: logical time based expiration batch w. id {} from batches_in_progress, new size {}",
                                        batch_id,
                                        self.batches_in_progress.len(),
                                    );
                                }
                            }
```

**File:** consensus/src/quorum_store/batch_store.rs (L64-68)
```rust
    pub(crate) fn update_quota(&mut self, num_bytes: usize) -> anyhow::Result<StorageMode> {
        if self.batch_balance == 0 {
            counters::EXCEEDED_BATCH_QUOTA_COUNT.inc();
            bail!("Batch quota exceeded ");
        }
```

**File:** consensus/src/quorum_store/batch_store.rs (L383-391)
```rust
            let value_to_be_stored = if self
                .peer_quota
                .entry(author)
                .or_insert(QuotaManager::new(
                    self.db_quota,
                    self.memory_quota,
                    self.batch_quota,
                ))
                .update_quota(value.num_bytes() as usize)?
```

**File:** mempool/src/core_mempool/mempool.rs (L386-415)
```rust
    fn txn_was_chosen(
        account_address: AccountAddress,
        sequence_number: u64,
        inserted: &HashSet<(AccountAddress, ReplayProtector)>,
        exclude_transactions: &BTreeMap<TransactionSummary, TransactionInProgress>,
    ) -> bool {
        if inserted.contains(&(
            account_address,
            ReplayProtector::SequenceNumber(sequence_number),
        )) {
            return true;
        }

        // TODO: Make sure this range search works as expected
        let min_inclusive = TxnPointer::new(
            account_address,
            ReplayProtector::SequenceNumber(sequence_number),
            HashValue::zero(),
        );
        let max_exclusive = TxnPointer::new(
            account_address,
            ReplayProtector::SequenceNumber(sequence_number.saturating_add(1)),
            HashValue::zero(),
        );

        exclude_transactions
            .range(min_inclusive..max_exclusive)
            .next()
            .is_some()
    }
```
