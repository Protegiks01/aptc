# Audit Report

## Title
Silent Fee Statement Deserialization Failure Causing Consensus Divergence During Type Tag Mismatches

## Summary
A type tag mismatch between stored V2 events and runtime `MoveStructType` implementations causes silent deserialization failures that replace `FeeStatement` data with zeros, leading to consensus divergence in fee distributions and block gas limit calculations.

## Finding Description

The `MoveEventV2Type` trait creates V2 events by embedding a type tag derived from `MoveStructType::struct_tag()` along with BCS-serialized data. [1](#0-0) 

When deserializing events, `ContractEvent::try_v2_typed()` performs a type tag comparison and silently returns `Ok(None)` if tags don't match. [2](#0-1) 

For consensus-critical `FeeStatement` events, the extraction logic falls back to `FeeStatement::zero()` when no matching event is found. [3](#0-2) 

This zero fee statement is then used in two consensus-critical paths:

1. **Fee Distribution Calculation**: Block proposer rewards are calculated using `fee_statement.gas_used()` and `fee_statement.storage_fee_used()`, directly affecting on-chain state. [4](#0-3) 

2. **Block Gas Limit Enforcement**: Gas accumulation uses `fee_statement.execution_gas_used()` and `fee_statement.io_gas_used()` to determine when blocks should end. [5](#0-4) 

**Violation of Invariant**: "Deterministic Execution: All validators must produce identical state roots for identical blocks"

If validators run with different `MoveStructType` implementations (different `MODULE_NAME`, `STRUCT_NAME`, or `ADDRESS` constants), they will:
- Produce different fee distributions (different block epilogue transactions)
- Calculate different block gas totals (different transaction inclusion decisions)
- Generate different state roots for the same block

## Impact Explanation

**Critical Severity** - This breaks consensus safety:

1. **Consensus Divergence**: Different validators compute different state roots for identical blocks, violating AptosBFT's deterministic execution guarantee. This can cause chain splits requiring manual intervention or hard fork recovery.

2. **Financial Impact**: Block proposers receive incorrect fee distributions (likely zero), constituting a loss of validator rewards that should have been distributed according to protocol rules.

3. **Resource Limit Bypass**: Zero fee statements allow blocks to bypass gas limits, potentially enabling inclusion of more transactions than intended, affecting network throughput guarantees.

## Likelihood Explanation

**Medium-to-Low Likelihood**: This requires specific conditions:

1. **Validator Version Skew**: During coordinated upgrades, validators temporarily run different code versions. If type constants differ between versions, mismatches occur.

2. **Historical Event Processing**: After an upgrade that changes type definitions, historical events may fail to deserialize correctly when processed.

3. **Code Quality Issues**: Bugs in `MoveStructType` constant definitions could introduce mismatches.

While framework modules use compatibility policies preventing struct changes [6](#0-5) , the Rust-side constants are separately maintained and not automatically validated against on-chain definitions.

## Recommendation

**Add explicit validation** that raises consensus errors rather than silently returning zeros:

```rust
pub fn fee_statement(&self) -> Result<FeeStatement, Error> {
    match self.output.try_extract_fee_statement() {
        Ok(Some(fee_statement)) => Ok(fee_statement),
        Ok(None) => {
            // For consensus-critical code paths, missing fee statements 
            // should be an explicit error, not silent zero fallback
            Err(anyhow::anyhow!(
                "Fee statement event not found or type tag mismatch - potential consensus divergence"
            ))
        },
        Err(e) => Err(e),
    }
}
```

Additionally, implement runtime validation that `FeeStatement::struct_tag()` matches the on-chain definition:

```rust
// At initialization or epoch boundaries
pub fn validate_fee_statement_type_tag(
    view: &impl StateView
) -> Result<()> {
    let runtime_tag = FeeStatement::struct_tag();
    let onchain_tag = get_onchain_struct_tag(
        view, 
        &runtime_tag.address, 
        &runtime_tag.module, 
        &runtime_tag.name
    )?;
    
    ensure!(
        runtime_tag == onchain_tag,
        "FeeStatement type tag mismatch: runtime={:?}, onchain={:?}",
        runtime_tag, onchain_tag
    );
    Ok(())
}
```

## Proof of Concept

```rust
// Reproduction scenario: Simulate validator version skew

#[test]
fn test_fee_statement_type_mismatch_consensus_divergence() {
    // Setup two validators with different FeeStatement definitions
    struct ValidatorA;
    impl MoveStructType for ValidatorA {
        const MODULE_NAME: &'static IdentStr = ident_str!("transaction_fee");
        const STRUCT_NAME: &'static IdentStr = ident_str!("FeeStatement");
        // Old address
        const ADDRESS: AccountAddress = CORE_CODE_ADDRESS;
    }
    
    struct ValidatorB;
    impl MoveStructType for ValidatorB {
        const MODULE_NAME: &'static IdentStr = ident_str!("transaction_fee_v2");  // Changed!
        const STRUCT_NAME: &'static IdentStr = ident_str!("FeeStatement");
        const ADDRESS: AccountAddress = CORE_CODE_ADDRESS;
    }
    
    // Create event with ValidatorA's type tag
    let fee_statement_data = FeeStatement::new(1000, 500, 300, 200, 50);
    let event = ContractEvent::new_v2(
        TypeTag::Struct(Box::new(ValidatorA::struct_tag())),
        bcs::to_bytes(&fee_statement_data).unwrap()
    ).unwrap();
    
    // ValidatorA successfully deserializes
    let result_a = event.try_v2_typed::<FeeStatement>(
        &TypeTag::Struct(Box::new(ValidatorA::struct_tag()))
    ).unwrap();
    assert!(result_a.is_some());
    assert_eq!(result_a.unwrap().gas_used(), 1000);
    
    // ValidatorB gets None due to type tag mismatch
    let result_b = event.try_v2_typed::<FeeStatement>(
        &TypeTag::Struct(Box::new(ValidatorB::struct_tag()))
    ).unwrap();
    assert!(result_b.is_none());  // Silent failure!
    
    // This leads to consensus divergence:
    // - ValidatorA: fee_distribution = calculate_from(1000 gas)
    // - ValidatorB: fee_distribution = calculate_from(0 gas)  // FeeStatement::zero()
    // Result: Different block epilogue transactions, different state roots
}
```

## Notes

While Move module compatibility checks prevent on-chain struct changes, the Rust `MoveStructType` implementations are compile-time constants that could diverge from on-chain definitions during upgrades or due to implementation bugs. The silent fallback to zero values in consensus-critical code paths creates a hidden consensus divergence risk that violates deterministic execution guarantees.

### Citations

**File:** types/src/move_utils/move_event_v2.rs (L8-14)
```rust
pub trait MoveEventV2Type: MoveStructType + Serialize {
    fn create_event_v2(&self) -> anyhow::Result<ContractEvent> {
        ContractEvent::new_v2(
            TypeTag::Struct(Box::new(Self::struct_tag())),
            bcs::to_bytes(self)?,
        )
    }
```

**File:** types/src/contract_event.rs (L145-153)
```rust
    pub fn try_v2_typed<T: DeserializeOwned>(&self, event_type: &TypeTag) -> Result<Option<T>> {
        if let Some(v2) = self.try_v2() {
            if &v2.type_tag == event_type {
                return Ok(Some(bcs::from_bytes(&v2.event_data)?));
            }
        }

        Ok(None)
    }
```

**File:** aptos-move/aptos-vm/src/block_executor/mod.rs (L106-111)
```rust
    fn fee_statement(&self) -> FeeStatement {
        if let Ok(Some(fee_statement)) = self.output.try_extract_fee_statement() {
            return fee_statement;
        }
        FeeStatement::zero()
    }
```

**File:** aptos-move/block-executor/src/executor.rs (L2050-2073)
```rust
            let fee_statement = output_after_guard.fee_statement();

            let txn = signature_verified_block.get_txn(i as TxnIndex);
            if let Some(user_txn) = txn.try_as_signed_user_txn() {
                let auxiliary_info = signature_verified_block.get_auxiliary_info(i as TxnIndex);
                if let Some(proposer_index) = auxiliary_info.proposer_index() {
                    let gas_price = user_txn.gas_unit_price();
                    let total_gas_unit = fee_statement.gas_used();
                    // Total gas unit here includes the storage fee (deposit), which is not
                    // available for distribution. Only the execution gas and IO gas are available
                    // to distribute. Note here we deliberately NOT use the execution gas and IO
                    // gas value from the fee statement, because they might round up during the
                    // calculation and the sum of them could be larger than the actual value we
                    // burn. Instead we use the total amount (which is the total we've burnt)
                    // minus the storage deposit (round up), to avoid over distribution.
                    // We burn a fix amount of gas per gas unit.
                    let gas_price_to_burn = self.config.onchain.gas_price_to_burn();
                    if gas_price > gas_price_to_burn {
                        let gas_unit_available_to_distribute = total_gas_unit
                            .saturating_sub(fee_statement.storage_fee_used().div_ceil(gas_price));
                        if gas_unit_available_to_distribute > 0 {
                            let fee_to_distribute =
                                gas_unit_available_to_distribute * (gas_price - gas_price_to_burn);
                            *amount.entry(proposer_index).or_insert(0) += fee_to_distribute;
```

**File:** aptos-move/block-executor/src/limit_processor.rs (L63-109)
```rust
    pub(crate) fn accumulate_fee_statement(
        &mut self,
        fee_statement: FeeStatement,
        txn_read_write_summary: Option<ReadWriteSummary<T>>,
        approx_output_size: Option<u64>,
    ) {
        self.accumulated_fee_statement
            .add_fee_statement(&fee_statement);
        self.txn_fee_statements.push(fee_statement);

        let conflict_multiplier = if let Some(conflict_overlap_length) =
            self.block_gas_limit_type.conflict_penalty_window()
        {
            let txn_read_write_summary = txn_read_write_summary.expect(
                "txn_read_write_summary needs to be computed if conflict_penalty_window is set",
            );
            if self.print_conflicts_info {
                println!("{:?}", txn_read_write_summary);
            }
            let rw_summary = if self
                .block_gas_limit_type
                .use_granular_resource_group_conflicts()
            {
                txn_read_write_summary
            } else {
                txn_read_write_summary.collapse_resource_group_conflicts()
            };
            if let Some(x) = &mut self.hot_state_op_accumulator {
                x.add_transaction(rw_summary.keys_written(), rw_summary.keys_read());
            }
            self.txn_read_write_summaries.push(rw_summary);
            self.compute_conflict_multiplier(conflict_overlap_length as usize)
        } else {
            assert_none!(txn_read_write_summary);
            1
        };

        // When the accumulated execution and io gas of the committed txns exceeds
        // PER_BLOCK_GAS_LIMIT, early halt BlockSTM. Storage fee does not count towards
        // the per block gas limit, as we measure execution related cost here.
        let raw_gas_used = fee_statement.execution_gas_used()
            * self
                .block_gas_limit_type
                .execution_gas_effective_multiplier()
            + fee_statement.io_gas_used() * self.block_gas_limit_type.io_gas_effective_multiplier();
        self.accumulated_raw_block_gas += raw_gas_used;
        self.accumulated_effective_block_gas += conflict_multiplier * raw_gas_used;
```

**File:** third_party/move/move-binary-format/src/compatibility.rs (L102-110)
```rust
        if old_module.address() != new_module.address() {
            errors.push(format!(
                "module address changed to `{}`",
                new_module.address()
            ));
        }
        if old_module.name() != new_module.name() {
            errors.push(format!("module name changed to `{}`", new_module.name()));
        }
```
