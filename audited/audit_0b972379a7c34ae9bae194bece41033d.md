# Audit Report

## Title
Missing Ciphertext Verification Before Decryption Creates Latent Timing Oracle Vulnerability

## Summary
The consensus decryption pipeline decrypts encrypted transaction ciphertexts without verifying their cryptographic signatures, violating the documented security requirement that validators "MUST verify each ciphertext before approving it to be decrypted." While API-level validation currently provides defense-in-depth, the decryption code path contains distinguishable error patterns and potential timing side-channels that could leak information about validator decryption keys if verification is bypassed.

## Finding Description

The `decrypt()` function implements a two-stage decryption process that can fail with distinguishable error types: [1](#0-0) 

This delegates to symmetric decryption which produces two distinct error patterns: [2](#0-1) 

The security documentation explicitly requires verification before decryption: [3](#0-2) 

However, the consensus decryption pipeline violates this requirement by calling `decrypt_individual` without prior verification: [4](#0-3) 

**Current Mitigation:**

The API layer does enforce verification before accepting encrypted transactions: [5](#0-4) [6](#0-5) 

**The Vulnerability:**

While API validation currently prevents arbitrary malformed ciphertexts, the decryption code path itself lacks verification, creating three security concerns:

1. **Timing Side-Channels**: Even with valid ciphertexts, the pairing computation depends on attacker-controlled input, and the underlying BLS12-381 implementation may not be constant-time
2. **Defense-in-Depth Violation**: The decryption layer trusts that validation occurred elsewhere, violating secure design principles
3. **Latent Oracle**: Future code changes, debug interfaces, or alternative code paths could expose this as a full decryption oracle

## Impact Explanation

**Current Impact: Low to Medium**

The immediate exploitability is limited by API validation, but the violation of documented security requirements and potential timing leakage constitute a **Medium Severity** issue under "State inconsistencies requiring intervention" and "Non-critical implementation bugs."

If verification could be bypassed (through future changes, alternative entry points, or bugs), this would escalate to **High Severity** due to information leakage about validator decryption keys.

## Likelihood Explanation

**Current Likelihood: Low**

Direct exploitation is prevented by API validation. However, the likelihood increases significantly if:
- Debug/test endpoints expose decryption without validation
- Future refactoring removes or bypasses API validation
- Alternative transaction submission paths are added
- A malicious validator gains access to internal decryption functions

The documented requirement suggests the original designers intended verification at decryption time, indicating this is a genuine security gap.

## Recommendation

**Enforce verification in the decryption code path:**

```rust
// In consensus/src/pipeline/decryption_pipeline_builder.rs
let decrypted_txns = encrypted_txns
    .into_par_iter()
    .zip(txn_ciphertexts)
    .map(|(mut txn, ciphertext)| {
        // Add verification before decryption
        let associated_data = PayloadAssociatedData::new(txn.sender());
        if let Err(e) = FPTXWeighted::verify_ct(&ciphertext, &associated_data) {
            // Log verification failure and mark as failed decryption
            txn.payload_mut()
                .as_encrypted_payload_mut()
                .map(|p| p.into_failed_decryption(eval_proof).expect("must happen"))
                .expect("must exist");
            return txn;
        }
        
        let eval_proof = proofs.get(&ciphertext.id()).expect("must exist");
        if let Ok(payload) = FPTXWeighted::decrypt_individual::<DecryptedPayload>(
            &decryption_key.key,
            &ciphertext,
            &digest,
            &eval_proof,
        ) {
            // ... rest of success path
        }
        // ... rest of code
    })
    .collect();
```

**Additional recommendations:**
1. Add cryptographic assertions to ensure pairing operations use constant-time implementations
2. Consider unifying error types to prevent distinguishability even in debug builds
3. Add runtime checks to enforce the verification requirement programmatically

## Proof of Concept

```rust
// Timing analysis PoC (conceptual - would require actual timing measurements)
#[test]
fn test_timing_oracle_potential() {
    use std::time::Instant;
    
    let mut rng = thread_rng();
    let tc = ShamirThresholdConfig::new(1, 1);
    let (ek, dk, _, msk_shares) = FPTX::setup_for_testing(rng.gen(), 8, 1, &tc).unwrap();
    
    // Create two ciphertexts:
    // CT1: Will fail at AES-GCM authentication (wrong key)
    // CT2: Will fail at BCS deserialization (right key, wrong data)
    
    let plaintext = String::from("test");
    let associated_data = String::from("");
    
    // CT1: Valid ciphertext (will pass AES-GCM, fail BCS if we corrupt plaintext)
    let ct1 = ek.encrypt(&mut rng, &plaintext, &associated_data).unwrap();
    
    // Prepare for decryption
    let mut ids = IdSet::with_capacity(dk.capacity()).unwrap();
    ids.add(&ct1.id());
    ids.compute_poly_coeffs();
    let (digest, pfs) = dk.digest(&mut ids, 0).unwrap();
    let pfs = pfs.compute_all(&dk);
    
    let dk_reconstructed = BIBEDecryptionKey::reconstruct(&tc, &[msk_shares[0]
        .derive_decryption_key_share(&digest)
        .unwrap()])
    .unwrap();
    
    // Measure timing for valid ciphertext
    let start1 = Instant::now();
    let result1 = dk_reconstructed.decrypt(&ct1.prepare(&digest, &pfs).unwrap());
    let time1 = start1.elapsed();
    
    // Note: Would need to craft CT2 with wrong pairing output to measure
    // timing difference. This demonstrates the concept but actual exploitation
    // requires more sophisticated timing analysis.
    
    println!("Decryption time: {:?}", time1);
    println!("Result: {:?}", result1.is_ok());
}
```

## Notes

This vulnerability represents a **defense-in-depth failure** rather than an immediately exploitable attack. The API validation layer provides adequate protection in the current implementation, but the decryption code violates its documented security contract. The documented requirement that validators "MUST verify each ciphertext before approving it to be decrypted" exists precisely to prevent decryption oracles and timing attacks.

The security concern is amplified by:
- Use of potentially non-constant-time pairing operations on attacker-controlled inputs
- Distinguishable error patterns in the decryption path
- Lack of cryptographic binding between verification and decryption stages

While not immediately critical, this should be addressed to maintain robust security guarantees as the codebase evolves.

### Citations

**File:** crates/aptos-batch-encryption/src/shared/ciphertext/bibe.rs (L156-167)
```rust
    fn bibe_decrypt(&self, ct: &PreparedBIBECiphertext) -> Result<P> {
        let otp_source_1 = PairingSetting::pairing(self.signature_g1, ct.ct_g2.clone());
        let otp_source_gt = otp_source_1 + ct.pairing_output;

        let mut otp_source_bytes = Vec::new();
        otp_source_gt.serialize_compressed(&mut otp_source_bytes)?;
        let otp = OneTimePad::from_source_bytes(otp_source_bytes);

        let symmetric_key = otp.unpad_key(&ct.padded_key);

        symmetric_key.decrypt(&ct.symmetric_ciphertext)
    }
```

**File:** crates/aptos-batch-encryption/src/shared/symmetric.rs (L112-123)
```rust
    pub fn decrypt<P: Plaintext>(&self, ciphertext: &SymmetricCiphertext) -> Result<P> {
        use aes_gcm::KeyInit as _; // putting this in the global scope causes Hmac<Sha256> to be
                                   // ambiguous for some reason

        let key: &Key<SymmetricCipher> = &self.0;
        let cipher = SymmetricCipher::new(key);
        let plaintext_bytes = cipher
            .decrypt(&ciphertext.nonce, ciphertext.ct_body.as_ref())
            .map_err(|_| BatchEncryptionError::SymmetricDecryptionError)?;
        Ok(bcs::from_bytes(&plaintext_bytes)
            .map_err(|_| BatchEncryptionError::DeserializationError)?)
    }
```

**File:** crates/aptos-batch-encryption/src/traits.rs (L106-109)
```rust
    /// Validators *must* verify each ciphertext before approving it to be decrypted, in order to
    /// prevent malleability attacks. Verification happens w.r.t. some associated data that was
    /// passed into the encrypt fn.
    fn verify_ct(ct: &Self::Ciphertext, associated_data: &impl AssociatedData) -> Result<()>;
```

**File:** consensus/src/pipeline/decryption_pipeline_builder.rs (L126-131)
```rust
                if let Ok(payload) = FPTXWeighted::decrypt_individual::<DecryptedPayload>(
                    &decryption_key.key,
                    &ciphertext,
                    &digest,
                    &eval_proof,
                ) {
```

**File:** api/src/transactions.rs (L1340-1346)
```rust
                if let Err(e) = payload.verify(signed_transaction.sender()) {
                    return Err(SubmitTransactionError::bad_request_with_code(
                        e.context("Encrypted transaction payload could not be verified"),
                        AptosErrorCode::InvalidInput,
                        ledger_info,
                    ));
                }
```

**File:** types/src/transaction/encrypted_payload.rs (L147-150)
```rust
    pub fn verify(&self, sender: AccountAddress) -> anyhow::Result<()> {
        let associated_data = PayloadAssociatedData::new(sender);
        self.ciphertext().verify(&associated_data)
    }
```
