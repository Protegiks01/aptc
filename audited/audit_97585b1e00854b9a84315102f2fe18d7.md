# Audit Report

## Title
Data Loss During Forced V2 to V1 Batch Conversion in Batch Retrieval Path

## Summary
The batch retrieval task in `quorum_store_builder.rs` forcibly converts V2 batches (which may contain encrypted batch metadata) to V1 format, causing either node crashes or silent data loss if the conversion path doesn't properly validate batch versions.

## Finding Description
The vulnerability exists in the batch retrieval response construction path. When a node receives a batch request, it retrieves the batch from local storage and attempts to convert it for network transmission. [1](#0-0) 

The code retrieves a `PersistedValue<BatchInfoExt>` (which can be either V1 or V2), converts it to `Batch<BatchInfoExt>`, then **forcibly converts it to `Batch<BatchInfo>`** with an expect that assumes all batch retrieval requests are for V1 batches.

When `enable_batch_v2` configuration is enabled, V2 batches containing `BatchInfoExt::V2` variants are created with additional metadata (specifically `ExtraBatchInfo` with `batch_kind: BatchKind`). [2](#0-1) 

If such a V2 batch is stored and later requested by a peer:

1. The retrieval path loads it as `PersistedValue<BatchInfoExt>` with V2 variant
2. Line 412-414 attempts conversion to `Batch<BatchInfo>` via `try_into()`
3. The TryFrom implementation checks if it's V1: [3](#0-2) 

4. If it's V2, the conversion fails and the `.expect()` panics, **crashing the validator node**
5. If the check is somehow bypassed or the `unpack_info()` method is called directly: [4](#0-3) 

The `extra: ExtraBatchInfo` field containing `batch_kind` is **silently discarded**, losing critical metadata about whether the batch is encrypted or normal.

This breaks **Deterministic Execution** invariant: Different nodes could process the same batch differently if some lose the encryption metadata while others preserve it, leading to state divergence.

## Impact Explanation
**High Severity** - This impacts consensus safety and node availability:

1. **Node Crashes**: When V2 batches are requested, validator nodes panic and crash, causing **validator node slowdowns** and potential liveness issues
2. **State Inconsistency**: If the conversion succeeds via unprotected `unpack_info()` paths, different nodes process batches with different metadata, breaking consensus determinism
3. **Consensus Safety**: Mixed V1/V2 batch handling across the network can cause validators to have inconsistent views of batch properties, potentially leading to safety violations

This qualifies as High Severity per Aptos bug bounty criteria: "Validator node slowdowns" and "Significant protocol violations".

## Likelihood Explanation
**Moderate to High Likelihood**:

- The `enable_batch_v2` configuration flag exists and can be enabled
- V2 batch creation is implemented and functional
- Batch retrieval is a common operation during consensus
- The vulnerability requires mixed deployment (some nodes with V2 enabled, others requesting those batches)
- Currently mitigated by batch_kind being hardcoded to `Normal`, but infrastructure for `Encrypted` batches exists

## Recommendation
Implement proper version negotiation and handling in the batch retrieval path:

1. **Check batch version before forced conversion**:
```rust
let response = if let Ok(value) = batch_store.get_batch_from_local(&rpc_request.req.digest()) {
    let batch: Batch<BatchInfoExt> = value.try_into().unwrap();
    
    // Check if it's a V2 batch
    if batch.batch_info().is_v2() {
        // Send as V2 response
        BatchResponse::BatchV2(batch)
    } else {
        // Convert to V1 for backward compatibility
        let batch: Batch<BatchInfo> = batch.try_into()
            .expect("V1 batch conversion should succeed");
        BatchResponse::Batch(batch)
    }
} else {
    // ... NotFound handling
};
```

2. **Fix database cleanup to handle V2 batches**: [5](#0-4) 

The cleanup logic only deletes from V1 schema. It should be updated to:
```rust
pub fn update_certified_timestamp(&self, certified_time: u64) {
    self.last_certified_time.fetch_max(certified_time, Ordering::SeqCst);
    
    let expired_keys = self.clear_expired_payload(certified_time);
    // Separate V1 and V2 keys based on cache metadata
    let (v1_keys, v2_keys) = self.separate_expired_keys_by_version(expired_keys);
    
    if let Err(e) = self.db.delete_batches(v1_keys) {
        debug!("Error deleting V1 batches: {:?}", e)
    }
    if let Err(e) = self.db.delete_batches_v2(v2_keys) {
        debug!("Error deleting V2 batches: {:?}", e)
    }
}
```

3. **Make `unpack_info()` private or add safety documentation** to prevent misuse outside checked contexts.

## Proof of Concept
```rust
// Test demonstrating the vulnerability
#[test]
fn test_v2_batch_retrieval_causes_panic() {
    use consensus::quorum_store::batch_store::BatchStore;
    use consensus_types::proof_of_store::{BatchInfoExt, BatchKind};
    
    // Setup batch store with V2 batch
    let batch_store = setup_test_batch_store();
    
    // Create and store a V2 batch with Encrypted kind
    let v2_batch = Batch::new_v2(
        BatchId::new_for_test(1),
        vec![/* transactions */],
        epoch,
        expiration,
        author,
        gas_bucket_start,
        BatchKind::Encrypted, // V2-specific field
    );
    
    let persisted = PersistedValue::from(v2_batch);
    batch_store.save(&persisted).unwrap();
    
    // Simulate batch retrieval (from quorum_store_builder.rs:408-415)
    let value = batch_store.get_batch_from_local(&persisted.digest()).unwrap();
    let batch: Batch<BatchInfoExt> = value.try_into().unwrap();
    
    // This will panic with "Batch retrieval requests must be for V1 batch"
    let _v1_batch: Batch<BatchInfo> = batch.try_into()
        .expect("Batch retrieval requests must be for V1 batch");
    
    // Node crashes here, causing validator downtime
}
```

**Notes:**
The conversion implementations use proper safety checks (TryFrom with version validation), preventing silent data loss in normal paths. However, the batch retrieval task bypasses these safeguards by using `.expect()`, assuming all batches are V1. This creates a critical failure point when V2 batches are enabled, violating both the node availability and consensus determinism guarantees.

### Citations

**File:** consensus/src/quorum_store/quorum_store_builder.rs (L408-415)
```rust
                let response = if let Ok(value) =
                    batch_store.get_batch_from_local(&rpc_request.req.digest())
                {
                    let batch: Batch<BatchInfoExt> = value.try_into().unwrap();
                    let batch: Batch<BatchInfo> = batch
                        .try_into()
                        .expect("Batch retieval requests must be for V1 batch");
                    BatchResponse::Batch(batch)
```

**File:** consensus/src/quorum_store/batch_generator.rs (L190-201)
```rust
        if self.config.enable_batch_v2 {
            // TODO(ibalajiarun): Specify accurate batch kind
            let batch_kind = BatchKind::Normal;
            Batch::new_v2(
                batch_id,
                txns,
                self.epoch,
                expiry_time,
                self.my_peer_id,
                bucket_start,
                batch_kind,
            )
```

**File:** consensus/src/quorum_store/types.rs (L336-353)
```rust
impl TryFrom<Batch<BatchInfoExt>> for Batch<BatchInfo> {
    type Error = anyhow::Error;

    fn try_from(batch: Batch<BatchInfoExt>) -> Result<Self, Self::Error> {
        ensure!(
            matches!(batch.batch_info(), &BatchInfoExt::V1 { .. }),
            "Batch must be V1 type"
        );
        let Batch {
            batch_info,
            payload,
        } = batch;
        Ok(Self {
            batch_info: batch_info.unpack_info(),
            payload,
        })
    }
}
```

**File:** consensus/consensus-types/src/proof_of_store.rs (L267-272)
```rust
    pub fn unpack_info(self) -> BatchInfo {
        match self {
            BatchInfoExt::V1 { info } => info,
            BatchInfoExt::V2 { info, .. } => info,
        }
    }
```

**File:** consensus/src/quorum_store/batch_store.rs (L530-539)
```rust
    pub fn update_certified_timestamp(&self, certified_time: u64) {
        trace!("QS: batch reader updating time {:?}", certified_time);
        self.last_certified_time
            .fetch_max(certified_time, Ordering::SeqCst);

        let expired_keys = self.clear_expired_payload(certified_time);
        if let Err(e) = self.db.delete_batches(expired_keys) {
            debug!("Error deleting batches: {:?}", e)
        }
    }
```
