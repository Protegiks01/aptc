# Audit Report

## Title
Consensus Safety Violation via SafetyData Field Defaulting on Storage Corruption

## Summary
The `SafetyData` struct contains critical consensus safety fields `one_chain_round` and `highest_timeout_round` marked with `#[serde(default)]`. When SafetyData is deserialized from storage with missing fields, these default to 0, severely weakening the 2-chain consensus safety checks and potentially allowing validators to sign conflicting timeouts and order votes. [1](#0-0) 

## Finding Description

The vulnerability exists in how SafetyData is deserialized from persistent storage. The struct defines two critical safety fields with serde default attributes: [2](#0-1) 

When SafetyData is loaded from storage, deserialization occurs via the secure storage backend: [3](#0-2) 

The storage backend uses `serde_json` for deserialization: [4](#0-3) 

If stored data lacks `one_chain_round` or `highest_timeout_round` fields (due to storage corruption, incomplete writes, or backward compatibility), these fields silently default to 0.

**Critical Safety Checks Bypassed:**

1. **Timeout Safety Rule** - The `safe_to_timeout` function checks that `qc_round >= safety_data.one_chain_round`: [5](#0-4) 

With `one_chain_round = 0`, this check becomes `qc_round >= 0`, which passes for any valid QC, allowing validators to sign timeouts with arbitrarily old QCs.

2. **Order Vote Safety Rule** - The `safe_for_order_vote` function checks that `round > safety_data.highest_timeout_round`: [6](#0-5) 

With `highest_timeout_round = 0`, this becomes `round > 0`, allowing order votes on rounds where the validator previously signed timeouts.

**Attack Scenario:**
1. Validator operates normally with `one_chain_round = 100`, `highest_timeout_round = 95`, `last_voted_round = 100`
2. Storage corruption or incomplete write causes these fields to be missing on restart
3. Validator deserializes SafetyData with `one_chain_round = 0`, `highest_timeout_round = 0`
4. Validator can now sign timeout for round 101 with QC from round 50 (should require QC >= 100)
5. Validator can sign order vote for round 60 despite having timed out on round 95
6. This violates 2-chain consensus safety invariants, potentially enabling equivocation

The backward compatibility test confirms this behavior is intentional: [7](#0-6) 

## Impact Explanation

**Severity: High**

This vulnerability breaks the **Consensus Safety** invariant: "AptosBFT must prevent double-spending and chain splits under < 1/3 Byzantine validators."

When safety fields default to 0, a validator can:
- Sign conflicting timeouts for different QCs at the same round
- Sign order votes after timing out, violating protocol invariants
- Potentially cause consensus divergence if multiple validators are affected

However, this does NOT qualify as **Critical** because:
- It requires storage-level access or corruption (not remotely exploitable)
- It affects individual validator safety, not direct fund loss
- Recovery is possible through validator restart with correct storage

This aligns with **High Severity** per Aptos Bug Bounty: "Significant protocol violations" that affect consensus integrity without causing immediate critical system failure.

## Likelihood Explanation

**Likelihood: Medium-Low**

This vulnerability can manifest through:
1. **Storage corruption** - Hardware failure, filesystem corruption, incomplete writes
2. **Backward compatibility** - Upgrading from old version lacking these fields (intentionally handled)
3. **Operational errors** - Manual storage manipulation, backup/restore issues

The backward compatibility scenario is explicitly tested and intentional. The storage corruption scenario is possible but requires system-level failures rather than network-based exploitation.

Mitigating factors:
- `last_voted_round` field (without `#[serde(default)]`) provides partial protection against voting on old rounds
- Secure storage backends have durability guarantees
- Validator operators monitor for anomalies

## Recommendation

**Solution: Add validation when loading SafetyData from storage**

Add a consistency check that validates deserialized SafetyData:

```rust
pub fn safety_data(&mut self) -> Result<SafetyData, Error> {
    // ... existing cache logic ...
    
    let safety_data: SafetyData = self.internal_store.get(SAFETY_DATA).map(|v| v.value)?;
    
    // Validate consistency: one_chain_round and highest_timeout_round 
    // should not be 0 if last_voted_round is non-zero (except for new epochs)
    if safety_data.last_voted_round > 0 {
        if safety_data.one_chain_round == 0 {
            warn!("SafetyData consistency violation: one_chain_round is 0 but last_voted_round is {}. Possible storage corruption.", safety_data.last_voted_round);
            // Consider returning error or fixing it based on last_voted_round
        }
        if safety_data.highest_timeout_round == 0 && safety_data.last_voted_round > 1 {
            warn!("SafetyData consistency violation: highest_timeout_round is 0 but last_voted_round is {}.", safety_data.last_voted_round);
        }
    }
    
    self.cached_safety_data = Some(safety_data.clone());
    Ok(safety_data)
}
```

**Alternative: Remove #[serde(default)] and require explicit migration**

Instead of silently defaulting, fail deserialization if fields are missing and require explicit migration code during upgrades.

## Proof of Concept

```rust
#[cfg(test)]
mod safety_data_defaulting_test {
    use super::*;
    use aptos_consensus_types::safety_data::SafetyData;
    use aptos_secure_storage::{InMemoryStorage, Storage};
    use aptos_global_constants::SAFETY_DATA;

    #[test]
    fn test_safety_data_field_defaulting_vulnerability() {
        // Simulate a validator with advanced consensus state
        let mut storage = Storage::from(InMemoryStorage::new());
        
        // Create SafetyData with high rounds (active validator state)
        let advanced_state = SafetyData::new(5, 100, 99, 99, None, 95);
        storage.set(SAFETY_DATA, advanced_state.clone()).unwrap();
        
        // Verify normal operation
        let loaded: SafetyData = storage.get(SAFETY_DATA).unwrap().value;
        assert_eq!(loaded.one_chain_round, 99);
        assert_eq!(loaded.highest_timeout_round, 95);
        
        // Simulate storage corruption: manually construct JSON without new fields
        let corrupted_json = serde_json::json!({
            "epoch": 5,
            "last_voted_round": 100,
            "preferred_round": 99,
            "last_vote": null
        });
        
        // Deserialize corrupted data
        let corrupted_state: SafetyData = serde_json::from_value(corrupted_json).unwrap();
        
        // VULNERABILITY: Critical safety fields default to 0
        assert_eq!(corrupted_state.one_chain_round, 0);
        assert_eq!(corrupted_state.highest_timeout_round, 0);
        assert_eq!(corrupted_state.last_voted_round, 100); // Preserved
        
        // This allows bypassing safety checks:
        // - safe_to_timeout check: qc_round >= 0 (always passes)
        // - safe_for_order_vote check: round > 0 (trivially passes)
        
        println!("VULNERABILITY CONFIRMED:");
        println!("Expected one_chain_round: 99, Got: {}", corrupted_state.one_chain_round);
        println!("Expected highest_timeout_round: 95, Got: {}", corrupted_state.highest_timeout_round);
        println!("Safety checks are now severely weakened!");
    }
}
```

## Notes

While the vulnerability is real and breaks consensus safety invariants, it has **significant limitations** for practical exploitation:

1. **Requires Validator Access**: An external attacker cannot directly corrupt a validator's secure storage - this requires system-level access to the validator node
2. **Intentional Design**: The `test_safety_data_upgrade` test shows this defaulting behavior is intentional for backward compatibility
3. **Operational Risk**: This is primarily an operational risk during upgrades or storage failures, not a remotely exploitable vulnerability

Per the Aptos Bug Bounty trust model excluding validator insider attacks and the requirement for "bugs exploitable without requiring privileged validator access," this issue may fall outside the standard attack surface. However, it represents a genuine protocol weakness that should be addressed through defensive validation.

### Citations

**File:** consensus/consensus-types/src/safety_data.rs (L9-21)
```rust
#[derive(Debug, Deserialize, Eq, PartialEq, Serialize, Clone, Default)]
pub struct SafetyData {
    pub epoch: u64,
    pub last_voted_round: u64,
    // highest 2-chain round, used for 3-chain
    pub preferred_round: u64,
    // highest 1-chain round, used for 2-chain
    #[serde(default)]
    pub one_chain_round: u64,
    pub last_vote: Option<Vote>,
    #[serde(default)]
    pub highest_timeout_round: u64,
}
```

**File:** consensus/consensus-types/src/safety_data.rs (L53-70)
```rust
#[test]
fn test_safety_data_upgrade() {
    #[derive(Debug, Deserialize, Eq, PartialEq, Serialize, Clone, Default)]
    struct OldSafetyData {
        pub epoch: u64,
        pub last_voted_round: u64,
        pub preferred_round: u64,
        pub last_vote: Option<Vote>,
    }
    let old_data = OldSafetyData {
        epoch: 1,
        last_voted_round: 10,
        preferred_round: 100,
        last_vote: None,
    };
    let value = serde_json::to_value(old_data).unwrap();
    let _: SafetyData = serde_json::from_value(value).unwrap();
}
```

**File:** consensus/safety-rules/src/persistent_safety_storage.rs (L134-148)
```rust
    pub fn safety_data(&mut self) -> Result<SafetyData, Error> {
        if !self.enable_cached_safety_data {
            let _timer = counters::start_timer("get", SAFETY_DATA);
            return self.internal_store.get(SAFETY_DATA).map(|v| v.value)?;
        }

        if let Some(cached_safety_data) = self.cached_safety_data.clone() {
            Ok(cached_safety_data)
        } else {
            let _timer = counters::start_timer("get", SAFETY_DATA);
            let safety_data: SafetyData = self.internal_store.get(SAFETY_DATA).map(|v| v.value)?;
            self.cached_safety_data = Some(safety_data.clone());
            Ok(safety_data)
        }
    }
```

**File:** secure/storage/src/in_memory.rs (L41-48)
```rust
    fn get<V: DeserializeOwned>(&self, key: &str) -> Result<GetResponse<V>, Error> {
        let response = self
            .data
            .get(key)
            .ok_or_else(|| Error::KeyNotSet(key.to_string()))?;

        serde_json::from_slice(response).map_err(|e| e.into())
    }
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L124-145)
```rust
    fn safe_to_timeout(
        &self,
        timeout: &TwoChainTimeout,
        maybe_tc: Option<&TwoChainTimeoutCertificate>,
        safety_data: &SafetyData,
    ) -> Result<(), Error> {
        let round = timeout.round();
        let qc_round = timeout.hqc_round();
        let tc_round = maybe_tc.map_or(0, |tc| tc.round());
        if (round == next_round(qc_round)? || round == next_round(tc_round)?)
            && qc_round >= safety_data.one_chain_round
        {
            Ok(())
        } else {
            Err(Error::NotSafeToTimeout(
                round,
                qc_round,
                tc_round,
                safety_data.one_chain_round,
            ))
        }
    }
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L168-178)
```rust
    fn safe_for_order_vote(&self, block: &Block, safety_data: &SafetyData) -> Result<(), Error> {
        let round = block.round();
        if round > safety_data.highest_timeout_round {
            Ok(())
        } else {
            Err(Error::NotSafeForOrderVote(
                round,
                safety_data.highest_timeout_round,
            ))
        }
    }
```
