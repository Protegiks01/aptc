# Audit Report

## Title
Array Out-of-Bounds Panic in DKG Share Decryption Due to Missing Validator Index Validation

## Summary
The DKG (Distributed Key Generation) share decryption process lacks explicit bounds validation when accessing arrays using validator indices, potentially causing validator node crashes during epoch transitions if validator set mismatches occur.

## Finding Description

The DKG share decryption implementations contain unchecked array accesses that can panic if a validator's index exceeds the configured player count.

**Vulnerability Location 1 - Insecure Field Implementation:** [1](#0-0) 

The `decrypt_own_share` function directly accesses `self.C[player.id]` without validating that `player.id < self.C.len()`.

**Vulnerability Location 2 - Weighted Protocol Implementation:** [2](#0-1) 

This implementation uses `sc.get_share_index(player.id, j).unwrap()` which internally accesses: [3](#0-2) 

The `get_share_index` function accesses `self.weights[i]` without bounds checking on the index `i`.

**Unchecked Player Creation:** [4](#0-3) 

Players are created directly from `player_idx` without validation that the index is within the DKG configuration's bounds.

**Call Site in Consensus:** [5](#0-4) 

The `my_index` comes from the new epoch's validator set, which may not match the DKG session's configured player count.

**Root Cause:**
The Player struct is supposed to enforce type safety through controlled creation: [6](#0-5) 

However, direct Player construction bypasses this safety mechanism, as evidenced by multiple instances in the codebase: [7](#0-6) 

## Impact Explanation

**Severity: High** - Validator node slowdowns/crashes

If a validator's index in the new epoch (`my_index`) is greater than or equal to the DKG configuration's player count (`sc.n`), attempting to decrypt their share will cause a Rust panic and crash the validator node.

This breaks the **Consensus Safety** invariant (#2) by preventing affected validators from participating in randomness generation, potentially impacting the validator set's ability to produce randomness for the epoch.

While Rust's bounds checking prevents memory corruption, the panic still causes:
- Validator node unavailability
- Loss of randomness generation capability
- Potential liveness issues if multiple validators are affected

## Likelihood Explanation

**Likelihood: Low to Medium**

The vulnerability requires a mismatch between the DKG session's target validator set and the actual new epoch validator set. While protections exist: [8](#0-7) 

The `assert_reconfig_not_in_progress()` prevents validator set changes during DKG. However:

1. The DKG session stores a snapshot of the target validator set: [9](#0-8) 

2. There's no explicit validation that `new_epoch_state.verifier` matches the DKG session's validator count/ordering
3. Edge cases during epoch transitions, validator set reordering, or configuration errors could trigger the mismatch
4. The check only validates epoch numbers, not validator set consistency: [10](#0-9) 

## Recommendation

Add explicit bounds validation before creating Players and accessing arrays:

```rust
// In decrypt_secret_share_from_transcript
fn decrypt_secret_share_from_transcript(
    pub_params: &Self::PublicParams,
    trx: &Self::Transcript,
    player_idx: u64,
    dk: &Self::NewValidatorDecryptKey,
) -> anyhow::Result<(Self::DealtSecretShare, Self::DealtPubKeyShare)> {
    // Add validation
    let player_idx_usize = player_idx as usize;
    let total_players = pub_params.pvss_config.wconfig.get_total_num_players();
    
    ensure!(
        player_idx_usize < total_players,
        "Player index {} exceeds DKG configuration player count {}",
        player_idx_usize,
        total_players
    );
    
    let player = Player { id: player_idx_usize };
    
    // Rest of function...
}

// In decrypt_own_share implementations, add debug assertions
fn decrypt_own_share(...) -> (...) {
    debug_assert!(player.id < self.C.len(), 
        "Player ID {} exceeds array bounds {}", player.id, self.C.len());
    // Rest of function...
}
```

Additionally, validate validator set consistency during epoch initialization.

## Proof of Concept

The following demonstrates the panic condition:

```rust
#[test]
#[should_panic(expected = "index out of bounds")]
fn test_player_index_out_of_bounds() {
    use aptos_dkg::pvss::insecure_field::transcript::Transcript;
    use aptos_crypto::blstrs::ThresholdConfigBlstrs;
    
    // Create DKG config for 10 players
    let sc = ThresholdConfigBlstrs::new(7, 10).unwrap();
    
    // Generate transcript
    let mut rng = rand::thread_rng();
    let pp = PublicParameters::default_with_bls_base();
    let trx = Transcript::generate(&sc, &pp, &mut rng);
    
    // Attempt to decrypt with player index >= n
    let invalid_player = Player { id: 15 }; // Out of bounds
    let dk = DecryptPrivKey::default();
    
    // This will panic with array index out of bounds
    let _ = trx.decrypt_own_share(&sc, &invalid_player, &dk, &pp);
}
```

**Notes:**
- The actual production code uses `pvss::das::WeightedTranscript`, but the same vulnerability pattern exists there
- The insecure_field implementation may be test-only, but the pattern indicates a systemic issue
- The vulnerability manifests as a node crash (panic) rather than memory corruption due to Rust's safety guarantees
- Explicit validation would provide better error messages and prevent surprising crashes during epoch transitions

### Citations

**File:** crates/aptos-dkg/src/pvss/insecure_field/transcript.rs (L129-137)
```rust
    fn decrypt_own_share(
        &self,
        sc: &Self::SecretSharingConfig,
        player: &Player,
        _dk: &Self::DecryptPrivKey,
        _pp: &Self::PublicParameters,
    ) -> (Self::DealtSecretKeyShare, Self::DealtPubKeyShare) {
        (self.C[player.id], self.get_public_key_share(sc, player))
    }
```

**File:** crates/aptos-dkg/src/pvss/das/weighted_protocol.rs (L220-244)
```rust
    fn decrypt_own_share(
        &self,
        sc: &Self::SecretSharingConfig,
        player: &Player,
        dk: &Self::DecryptPrivKey,
        _pp: &Self::PublicParameters,
    ) -> (Self::DealtSecretKeyShare, Self::DealtPubKeyShare) {
        let weight = sc.get_player_weight(player);
        let mut sk_shares = Vec::with_capacity(weight);
        let pk_shares = self.get_public_key_share(sc, player);

        for j in 0..weight {
            let k = sc.get_share_index(player.id, j).unwrap();

            let ctxt = self.C[k]; // h_1^{f(s_i + j - 1)} \ek_i^{r_{s_i + j}}
            let ephemeral_key = self.R[k].mul(dk.dk); // (g_1^{r_{s_i + j}})
            let dealt_secret_key_share = ctxt.sub(ephemeral_key);

            sk_shares.push(pvss::dealt_secret_key_share::g1::DealtSecretKeyShare::new(
                Self::DealtSecretKey::new(dealt_secret_key_share),
            ));
        }

        (sk_shares, pk_shares)
    }
```

**File:** crates/aptos-crypto/src/weighted_config.rs (L199-205)
```rust
    pub fn get_share_index(&self, i: usize, j: usize) -> Option<usize> {
        if j < self.weights[i] {
            Some(self.starting_index[i] + j)
        } else {
            None
        }
    }
```

**File:** types/src/dkg/real_dkg/mod.rs (L261-262)
```rust
            &Player { id: my_index },
            rng,
```

**File:** types/src/dkg/real_dkg/mod.rs (L422-435)
```rust
    fn decrypt_secret_share_from_transcript(
        pub_params: &Self::PublicParams,
        trx: &Self::Transcript,
        player_idx: u64,
        dk: &Self::NewValidatorDecryptKey,
    ) -> anyhow::Result<(Self::DealtSecretShare, Self::DealtPubKeyShare)> {
        let (sk, pk) = trx.main.decrypt_own_share(
            &pub_params.pvss_config.wconfig,
            &Player {
                id: player_idx as usize,
            },
            dk,
            &pub_params.pvss_config.pp,
        );
```

**File:** consensus/src/epoch_manager.rs (L1043-1045)
```rust
        if dkg_session.metadata.dealer_epoch + 1 != new_epoch_state.epoch {
            return Err(NoRandomnessReason::CompletedSessionTooOld);
        }
```

**File:** consensus/src/epoch_manager.rs (L1047-1072)
```rust
        let my_index = new_epoch_state
            .verifier
            .address_to_validator_index()
            .get(&self.author)
            .copied()
            .ok_or_else(|| NoRandomnessReason::NotInValidatorSet)?;

        let dkg_decrypt_key = maybe_dk_from_bls_sk(consensus_key.as_ref())
            .map_err(NoRandomnessReason::ErrConvertingConsensusKeyToDecryptionKey)?;
        let transcript = bcs::from_bytes::<<DefaultDKG as DKGTrait>::Transcript>(
            dkg_session.transcript.as_slice(),
        )
        .map_err(NoRandomnessReason::TranscriptDeserializationError)?;

        let vuf_pp = WvufPP::from(&dkg_pub_params.pvss_config.pp);

        // No need to verify the transcript.

        // keys for randomness generation
        let (sk, pk) = DefaultDKG::decrypt_secret_share_from_transcript(
            &dkg_pub_params,
            &transcript,
            my_index as u64,
            &dkg_decrypt_key,
        )
        .map_err(NoRandomnessReason::SecretShareDecryptionFailed)?;
```

**File:** crates/aptos-crypto/src/player.rs (L26-28)
```rust
/// The point of Player is to provide type-safety: ensure nobody creates out-of-range player IDs.
/// So there is no `new()` method; only the SecretSharingConfig trait is allowed to create them.
// TODO: AFAIK the only way to really enforce this is to put both traits inside the same module (or use unsafe Rust)
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1059-1063)
```text
    public(friend) fun join_validator_set_internal(
        operator: &signer,
        pool_address: address
    ) acquires StakePool, ValidatorConfig, ValidatorSet {
        assert_reconfig_not_in_progress();
```

**File:** types/src/dkg/mod.rs (L92-97)
```rust
pub struct DKGSessionMetadata {
    pub dealer_epoch: u64,
    pub randomness_config: RandomnessConfigMoveStruct,
    pub dealer_validator_set: Vec<ValidatorConsensusInfoMoveStruct>,
    pub target_validator_set: Vec<ValidatorConsensusInfoMoveStruct>,
}
```
