# Audit Report

## Title
Idempotency Violation in Ledger Update Causes Node Panic on Partial Failure Retry

## Summary
The `set_ledger_update_output()` and `set_state_checkpoint_output()` functions use `OnceCell` with `.expect()` that panics on duplicate calls. During `ledger_update()`, if a partial failure occurs after `set_state_checkpoint_output()` succeeds but before `set_ledger_update_output()` completes, any retry attempt will panic and crash the validator node instead of gracefully recovering.

## Finding Description

The vulnerability exists in the ledger update workflow where state checkpoint and ledger update operations are performed sequentially but are not atomic. The functions use `OnceCell::set()` with `.expect()` that panics if called multiple times: [1](#0-0) [2](#0-1) 

The `PartialStateComputeResult` struct stores these outputs in `OnceCell` fields that persist across the lifetime of the block in the `BlockTree`: [3](#0-2) [4](#0-3) 

In the `ledger_update()` method, there is a defensive check attempting to handle retries, but it is incomplete: [5](#0-4) 

The TODO comment "assuming no retries" indicates developer uncertainty about whether retries can occur. The check only succeeds if BOTH outputs are set, returning early. However, if only `state_checkpoint_output` is set (partial failure scenario), the check fails and execution continues.

The critical failure sequence occurs here: [6](#0-5) 

**Attack Scenario:**

1. **First `ledger_update()` call:**
   - Lines 315-320: `DoStateCheckpoint::run()` succeeds, `set_state_checkpoint_output()` completes successfully (OnceCell now SET)
   - Lines 321-328: An error occurs during argument evaluation:
     - `parent_out.ensure_ledger_update_output()?` could fail if parent state is inconsistent
     - `ProvableStateSummary::new_persisted()` could fail due to transient database errors
     - Or failpoint injection at line 312-314 triggers after state checkpoint is set
   - Function returns error, `ledger_update_output` remains UNSET
   - Block remains in `BlockTree` with partial state

2. **Retry attempt (via error handling, failpoint testing, or recovery):**
   - Line 291: `get_complete_result()` returns `None` (ledger_update_output not set)
   - Execution proceeds to line 315
   - Attempts `set_state_checkpoint_output()` again
   - **PANIC**: "StateCheckpointOutput already set"
   - Validator node crashes

There's additional evidence this was a known concern: [7](#0-6) 

The comment "no known strategy to recover from this failure" acknowledges that failures in this region are problematic.

## Impact Explanation

This qualifies as **High Severity** per Aptos Bug Bounty criteria:

**Validator Node Crashes:** When the panic occurs, the validator node terminates abnormally instead of gracefully handling the retry. This directly impacts:
- **Liveness:** Affected validator cannot participate in consensus
- **Network Stability:** Multiple validators experiencing transient database issues simultaneously could impact consensus quorum
- **Operational Reliability:** Node operators must manually restart nodes rather than automatic recovery

The impact is amplified because:
1. Database transient errors are unpredictable and can affect multiple nodes
2. Failpoint testing infrastructure relies on being able to inject and recover from errors
3. The defensive check demonstrates developers anticipated this scenario but implemented incomplete protection

While not causing consensus safety violations or fund loss, validator node crashes constitute "significant protocol violations" and "validator node slowdowns" (permanent until manual restart) per High severity criteria.

## Likelihood Explanation

**Medium Likelihood** in specific scenarios:

1. **Failpoint Testing (High):** The failpoint at line 312-314 is specifically designed to test failure recovery. If triggered after state checkpoint completes, it will cause this panic on retry.

2. **Transient Database Errors (Medium):** Operations like `ProvableStateSummary::new_persisted()` perform database reads that can fail due to:
   - Temporary I/O issues
   - Connection timeouts
   - Corruption recovery
   
3. **Parent State Inconsistency (Low):** Though consensus dependencies should prevent this, edge cases in state synchronization or recovery could cause `parent_out.ensure_ledger_update_output()` to fail.

4. **Node Recovery Scenarios (Low):** If a node crashes during ledger update and attempts to replay blocks on restart, it might retry operations on blocks with partial state.

The existence of the defensive check and TODO comments indicates developers saw this as a realistic concern, even if rare in normal operation. The incomplete defensive check transforms what could be a graceful retry into a node crash.

## Recommendation

Implement idempotent setter functions that check if the value is already set and either:

**Option 1: Allow idempotent sets (safest for retries):**
```rust
pub fn set_state_checkpoint_output(&self, state_checkpoint_output: StateCheckpointOutput) {
    // Allow re-setting with same value, panic only on different value
    if let Err(existing) = self.state_checkpoint_output.set(state_checkpoint_output.clone()) {
        // OnceCell already set, verify it matches
        assert_eq!(
            self.state_checkpoint_output.get().unwrap(),
            &existing,
            "StateCheckpointOutput set with different value"
        );
    }
}

pub fn set_ledger_update_output(&self, ledger_update_output: LedgerUpdateOutput) {
    if let Err(existing) = self.ledger_update_output.set(ledger_update_output.clone()) {
        assert_eq!(
            self.ledger_update_output.get().unwrap(),
            &existing,
            "LedgerUpdateOutput set with different value"
        );
    }
}
```

**Option 2: Return Result instead of panicking:**
```rust
pub fn set_state_checkpoint_output(&self, state_checkpoint_output: StateCheckpointOutput) -> Result<()> {
    self.state_checkpoint_output
        .set(state_checkpoint_output)
        .map_err(|_| anyhow!("StateCheckpointOutput already set"))
}

pub fn set_ledger_update_output(&self, ledger_update_output: LedgerUpdateOutput) -> Result<()> {
    self.ledger_update_output
        .set(ledger_update_output)
        .map_err(|_| anyhow!("LedgerUpdateOutput already set"))
}
```

**Option 3: Improve defensive check to detect partial state:**
```rust
// Check if ANY output is already set
if self.state_checkpoint_output.get().is_some() || self.ledger_update_output.get().is_some() {
    // Partial or complete state exists, verify completeness
    if let Some(complete_result) = block.output.get_complete_result() {
        info!(block_id = block_id, "ledger_update already done.");
        return Ok(complete_result);
    } else {
        // Partial state detected - this is an error condition
        return Err(ExecutorError::InternalError {
            error: format!(
                "Block {:x} has partial ledger update state (state_checkpoint: {}, ledger_update: {})",
                block_id,
                block.output.state_checkpoint_output.get().is_some(),
                block.output.ledger_update_output.get().is_some()
            ).into(),
        }.into());
    }
}
```

Option 1 is recommended as it provides true idempotency while maintaining safety guarantees.

## Proof of Concept

```rust
#[cfg(test)]
mod test {
    use super::*;
    use aptos_executor_types::{
        execution_output::ExecutionOutput,
        state_checkpoint_output::StateCheckpointOutput,
        LedgerUpdateOutput,
    };
    use aptos_storage_interface::state_store::state::LedgerState;
    use aptos_types::ledger_info::LedgerInfo;
    
    #[test]
    #[should_panic(expected = "StateCheckpointOutput already set")]
    fn test_idempotency_violation_panic() {
        // Create a PartialStateComputeResult
        let execution_output = ExecutionOutput::new_empty(
            LedgerState::new_empty(Default::default())
        );
        let result = PartialStateComputeResult::new(execution_output);
        
        // Create dummy state checkpoint output
        let state_checkpoint = StateCheckpointOutput::new_empty(Default::default());
        
        // First call succeeds
        result.set_state_checkpoint_output(state_checkpoint.clone());
        
        // Second call panics - simulating retry after partial failure
        result.set_state_checkpoint_output(state_checkpoint);
        // This line is never reached due to panic
    }
    
    #[test]
    fn test_defensive_check_fails_on_partial_state() {
        let execution_output = ExecutionOutput::new_empty(
            LedgerState::new_empty(Default::default())
        );
        let result = PartialStateComputeResult::new(execution_output);
        
        // Set only state_checkpoint_output (simulating partial failure)
        let state_checkpoint = StateCheckpointOutput::new_empty(Default::default());
        result.set_state_checkpoint_output(state_checkpoint);
        
        // get_complete_result returns None because ledger_update_output not set
        assert!(result.get_complete_result().is_none());
        
        // Defensive check would fail to catch this and proceed to retry,
        // leading to panic on second set_state_checkpoint_output call
    }
}
```

This PoC demonstrates the idempotency violation and shows how the defensive check fails to protect against partial state scenarios, confirming the vulnerability.

### Citations

**File:** execution/executor/src/types/partial_state_compute_result.rs (L17-22)
```rust
#[derive(Clone, Debug)]
pub struct PartialStateComputeResult {
    pub execution_output: ExecutionOutput,
    pub state_checkpoint_output: OnceCell<StateCheckpointOutput>,
    pub ledger_update_output: OnceCell<LedgerUpdateOutput>,
}
```

**File:** execution/executor/src/types/partial_state_compute_result.rs (L76-80)
```rust
    pub fn set_state_checkpoint_output(&self, state_checkpoint_output: StateCheckpointOutput) {
        self.state_checkpoint_output
            .set(state_checkpoint_output)
            .expect("StateCheckpointOutput already set");
    }
```

**File:** execution/executor/src/types/partial_state_compute_result.rs (L88-92)
```rust
    pub fn set_ledger_update_output(&self, ledger_update_output: LedgerUpdateOutput) {
        self.ledger_update_output
            .set(ledger_update_output)
            .expect("LedgerUpdateOutput already set");
    }
```

**File:** execution/executor/src/block_executor/block_tree/mod.rs (L27-32)
```rust
pub struct Block {
    pub id: HashValue,
    pub output: PartialStateComputeResult,
    children: Mutex<Vec<Arc<Block>>>,
    block_lookup: Arc<BlockLookup>,
}
```

**File:** execution/executor/src/block_executor/mod.rs (L290-294)
```rust
        // TODO(aldenhu): remove, assuming no retries.
        if let Some(complete_result) = block.output.get_complete_result() {
            info!(block_id = block_id, "ledger_update already done.");
            return Ok(complete_result);
        }
```

**File:** execution/executor/src/block_executor/mod.rs (L310-330)
```rust
            THREAD_MANAGER.get_non_exe_cpu_pool().install(|| {
                // TODO(aldenhu): remove? no known strategy to recover from this failure
                fail_point!("executor::block_state_checkpoint", |_| {
                    Err(anyhow::anyhow!("Injected error in block state checkpoint."))
                });
                output.set_state_checkpoint_output(DoStateCheckpoint::run(
                    &output.execution_output,
                    parent_block.output.ensure_result_state_summary()?,
                    &ProvableStateSummary::new_persisted(self.db.reader.as_ref())?,
                    None,
                )?);
                output.set_ledger_update_output(DoLedgerUpdate::run(
                    &output.execution_output,
                    output.ensure_state_checkpoint_output()?,
                    parent_out
                        .ensure_ledger_update_output()?
                        .transaction_accumulator
                        .clone(),
                )?);
                Result::<_>::Ok(())
            })?;
```
