# Audit Report

## Title
Missing TLS Encryption in Remote Executor Service Communication Enables MITM Attacks

## Summary
The `GRPCNetworkMessageServiceClientWrapper` in the `secure/net` module establishes gRPC connections using plaintext HTTP instead of HTTPS, providing no TLS encryption or certificate validation. This exposes transaction execution data to man-in-the-middle attacks when the remote executor service is deployed with shards on separate machines.

## Finding Description

The `GRPCNetworkMessageServiceClientWrapper::new()` function creates gRPC client connections using unencrypted HTTP: [1](#0-0) 

The critical issue is at line 128 where the connection URL is formatted as `http://` rather than `https://`: [2](#0-1) 

This means:
1. **No TLS encryption** is applied to the communication
2. **No certificate validation** occurs (because no certificates are used)
3. All data is transmitted in **cleartext** over the network
4. The connection provides **no authentication** of the remote endpoint

This wrapper is used by the remote executor service to communicate between a coordinator and remote executor shards: [3](#0-2) 

The communication includes sensitive data such as execution commands containing transaction sub-blocks and execution results: [4](#0-3) 

**Important Context**: This vulnerability does **NOT** affect validator-to-validator consensus communication, which uses the NoiseIK protocol with proper authentication and encryption. The vulnerable code is specific to the optional remote executor service used for distributed transaction execution within a single validator's infrastructure.

A man-in-the-middle attacker positioned on the network between the coordinator and executor shards could:
- **Intercept and read** all transaction execution data, including transaction payloads and execution results
- **Modify execution commands** sent from coordinator to shards
- **Modify execution results** returned from shards to coordinator  
- **Impersonate** executor shards or the coordinator

## Impact Explanation

**Severity: Medium** (up to $10,000 per Aptos Bug Bounty)

While the code objectively lacks TLS security, the actual impact is limited by deployment context:

1. **Scope limitation**: This affects only the remote executor service, not the main consensus protocol or validator-to-validator communication
2. **Deployment context**: Evidence suggests this is primarily used for benchmarking and performance testing rather than production validator deployments
3. **Network assumptions**: The service appears designed for deployment within a single validator's private infrastructure

However, if deployed in production with remote executors on separate machines (especially across network boundaries), the impact could include:
- **Information disclosure**: Exposure of transaction data being executed
- **State inconsistencies**: Modified execution results could lead to incorrect state transitions
- **Execution manipulation**: Altered commands could affect transaction processing

This constitutes a "state inconsistency requiring intervention" which falls under Medium severity.

## Likelihood Explanation

**Likelihood: Low to Medium**

The exploitation requires:
1. The remote executor service being deployed (not standard practice)
2. Executor shards running on separate machines with network communication
3. Attacker having MITM position on the network path
4. No additional network security controls (VPN, network isolation)

The codebase shows this feature is primarily used in benchmarking contexts: [5](#0-4) 

Standard validator deployments don't appear to use this remote executor architecture, reducing real-world exploitability.

## Recommendation

Implement TLS encryption for the gRPC client connections, following the pattern used in other parts of the codebase. The indexer gRPC services provide a reference implementation: [6](#0-5) 

**Recommended fix for `secure/net/src/grpc_network_service/mod.rs`**:

1. Add TLS configuration to the client wrapper
2. Change `http://` to `https://` 
3. Configure certificate validation using `ClientTlsConfig`
4. Add certificate paths to the configuration

Alternatively, if this service is intended only for same-machine or secure private network communication, add documentation clearly stating the security assumptions and recommended deployment model.

## Proof of Concept

A MITM attack can be demonstrated by:

1. Deploy the remote executor service with coordinator and shards on different machines
2. Position an attacker machine to intercept network traffic (e.g., ARP spoofing, network tap)
3. Use tools like `mitmproxy` or `Wireshark` to capture gRPC traffic
4. Observe plaintext transaction execution data in captured packets
5. Demonstrate message modification by intercepting and altering execution commands

**Rust reproduction steps**:

```rust
// Start remote executor service
let coordinator_addr = SocketAddr::from(([192, 168, 1, 10], 52200));
let shard_addr = SocketAddr::from(([192, 168, 1, 11], 52201));

// Network capture shows HTTP (not HTTPS) connection establishment
// gRPC messages transmitted in cleartext
// No TLS handshake occurs
```

## Notes

**Critical Clarification**: Despite the security question's framing about "validator communication," this vulnerability does **NOT** compromise inter-validator consensus communication. The Aptos consensus network uses NoiseIK protocol with proper cryptographic authentication and encryption. This issue is isolated to the optional remote executor service architecture used for distributed execution within a single validator's infrastructure, primarily in benchmarking scenarios.

### Citations

**File:** secure/net/src/grpc_network_service/mod.rs (L124-129)
```rust
    pub fn new(rt: &Runtime, remote_addr: SocketAddr) -> Self {
        Self {
            remote_addr: remote_addr.to_string(),
            remote_channel: rt
                .block_on(async { Self::get_channel(format!("http://{}", remote_addr)).await }),
        }
```

**File:** secure/net/src/grpc_network_service/mod.rs (L132-138)
```rust
    async fn get_channel(remote_addr: String) -> NetworkMessageServiceClient<Channel> {
        info!("Trying to connect to remote server at {:?}", remote_addr);
        let conn = tonic::transport::Endpoint::new(remote_addr)
            .unwrap()
            .connect_lazy();
        NetworkMessageServiceClient::new(conn).max_decoding_message_size(MAX_MESSAGE_SIZE)
    }
```

**File:** execution/executor-service/src/remote_executor_client.rs (L69-76)
```rust
            None,
        ),
    ))
});

#[allow(dead_code)]
pub struct RemoteExecutorClient<S: StateView + Sync + Send + 'static> {
    // The network controller used to create channels to send and receive messages. We want the
```

**File:** execution/executor-service/src/remote_executor_client.rs (L193-206)
```rust
        for (shard_id, sub_blocks) in sub_blocks.into_iter().enumerate() {
            let senders = self.command_txs.clone();
            let execution_request = RemoteExecutionRequest::ExecuteBlock(ExecuteBlockCommand {
                sub_blocks,
                concurrency_level: concurrency_level_per_shard,
                onchain_config: onchain_config.clone(),
            });

            senders[shard_id]
                .lock()
                .unwrap()
                .send(Message::new(bcs::to_bytes(&execution_request).unwrap()))
                .unwrap();
        }
```

**File:** execution/executor-benchmark/src/main.rs (L626-638)
```rust
    if opt
        .pipeline_opt
        .sharding_opt
        .remote_executor_addresses
        .is_some()
    {
        remote_executor_client::set_remote_addresses(
            opt.pipeline_opt
                .sharding_opt
                .remote_executor_addresses
                .clone()
                .unwrap(),
        );
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/config.rs (L254-259)
```rust
        if let Some(config) = &self.service_config.tls_config {
            let cert = tokio::fs::read(config.cert_path.clone()).await?;
            let key = tokio::fs::read(config.key_path.clone()).await?;
            let identity = tonic::transport::Identity::from_pem(cert, key);
            server_builder = server_builder
                .tls_config(tonic::transport::ServerTlsConfig::new().identity(identity))?;
```
