# Audit Report

## Title
Storage Usage Accounting Invariant Broken in TreeOnly State Snapshot Restore

## Summary
In TreeOnly restore mode, `kv_restore.finish()` is not called, preventing accumulated storage usage from being persisted to `VersionDataSchema`. This breaks storage accounting invariants, causing nodes to lose critical state size metadata needed for resource management and on-chain reporting.

## Finding Description

The `StateSnapshotRestore::finish()` method handles three restore modes: Default, KvOnly, and TreeOnly. In TreeOnly mode, only the Merkle tree structure is restored without persisting key-value data. [1](#0-0) 

The critical issue is that in TreeOnly mode (lines 263-265), `kv_restore.finish()` is never called. This method is responsible for persisting the accumulated storage usage: [2](#0-1) 

During chunk processing, storage usage is carefully accumulated for all restore modes, including TreeOnly: [3](#0-2) 

This usage is stored in progress metadata but never finalized to `VersionDataSchema` via `put_usage()` in TreeOnly mode: [4](#0-3) 

When nodes later initialize from this restored state, they call `init_state_ignoring_summary()` which retrieves usage: [5](#0-4) 

The `get_state_storage_usage()` method attempts to read from `VersionDataSchema`. With the default production configuration (`skip_usage=true` from `enable_storage_sharding`), it returns `Untracked` usage (0 items, 0 bytes) instead of the actual accumulated values: [6](#0-5) [7](#0-6) 

The comment in Default mode explicitly acknowledges that usage must be written for tree-only scenarios, but this is not done in TreeOnly mode: [8](#0-7) 

## Impact Explanation

This vulnerability breaks the **Resource Limits** critical invariant: "All operations must respect gas, storage, and computational limits." Storage accounting is permanently corrupted for nodes using TreeOnly restore.

**Direct Impacts:**
1. **Incorrect On-Chain State Size Reporting**: The Move framework's `StateStorageUsage` resource is updated at epoch boundaries using this data, leading to incorrect on-chain state size values. [9](#0-8) [10](#0-9) 

2. **State Management Degradation**: Operators lose visibility into actual storage consumption, hindering capacity planning and state pruning decisions.

3. **Potential Non-Determinism**: If storage-based gas calculations or framework logic depend on usage values, different nodes could have divergent state after TreeOnly restore, though the framework's warning suggests this is already handled carefully.

This qualifies as **Medium Severity** per the bug bounty criteria: "State inconsistencies requiring intervention." The issue requires operator action (performing TreeOnly restore) and causes persistent state corruption that affects resource accounting but does not directly cause fund loss or consensus safety violations.

## Likelihood Explanation

**High Likelihood**: TreeOnly mode is used in production restore scenarios when `db_next_version > 0` and the tree is not completed: [11](#0-10) 

The bug occurs automatically whenever TreeOnly restore is performedâ€”no attacker interaction required. With the default production configuration (`enable_storage_sharding=true`), nodes silently operate with incorrect accounting rather than crashing: [12](#0-11) [13](#0-12) 

## Recommendation

**Fix**: Call `kv_restore.finish()` in TreeOnly mode to persist accumulated usage:

```rust
fn finish(self) -> Result<()> {
    match self.restore_mode {
        StateSnapshotRestoreMode::KvOnly => self.kv_restore.lock().take().unwrap().finish()?,
        StateSnapshotRestoreMode::TreeOnly => {
            // Persist usage even in TreeOnly mode
            self.kv_restore.lock().take().unwrap().finish()?;
            self.tree_restore.lock().take().unwrap().finish_impl()?
        },
        StateSnapshotRestoreMode::Default => {
            self.kv_restore.lock().take().unwrap().finish()?;
            self.tree_restore.lock().take().unwrap().finish_impl()?
        },
    }
    Ok(())
}
```

Alternatively, modify `StateValueRestore::finish()` to handle TreeOnly mode by only persisting usage without finalizing KV-specific operations.

## Proof of Concept

```rust
// Rust reproduction steps:
// 1. Create AptosDB with enable_storage_sharding=true
// 2. Perform state snapshot restore with StateSnapshotRestoreMode::TreeOnly
// 3. Call finish() - kv_restore.finish() is not called
// 4. Query get_state_storage_usage(version) for the restored version
// 5. Observe that usage returns Untracked (0 items, 0 bytes) instead of actual accumulated values
// 6. Call init_state_ignoring_summary() and verify State is initialized with zero usage
// 7. Compare with Default mode restore where usage is correctly persisted

#[test]
fn test_tree_only_restore_missing_usage() {
    let tmpdir = TempPath::new();
    let db = AptosDB::new_for_test(&tmpdir);
    
    // Setup: Create snapshot at version 100 with known usage
    // ... setup code ...
    
    // Perform TreeOnly restore
    let receiver = db.get_state_restore_receiver(
        100,
        expected_root_hash,
        StateSnapshotRestoreMode::TreeOnly
    ).unwrap();
    
    // Add chunks - usage is accumulated in progress
    receiver.add_chunk(chunks, proof).unwrap();
    receiver.finish().unwrap(); // kv_restore.finish() NOT called
    
    // BUG: Usage is missing from VersionDataSchema
    let usage = db.get_state_storage_usage(Some(100)).unwrap();
    assert!(usage.is_untracked()); // Returns Untracked instead of actual usage
    assert_eq!(usage.items(), 0); // Should be > 0
    assert_eq!(usage.bytes(), 0); // Should be > 0
}
```

**Notes:**
- This bug specifically affects TreeOnly restore operations used during backup recovery scenarios
- The Default mode correctly persists usage (line 268), confirming the intent to track usage even when only restoring trees
- Production nodes with sharding enabled silently lose storage accounting rather than crashing, making this bug harder to detect
- The accumulated usage exists in `StateSnapshotProgress` metadata but is never migrated to `VersionDataSchema` where the system expects to find it

### Citations

**File:** storage/aptosdb/src/state_restore/mod.rs (L111-114)
```rust
        // In case of TreeOnly Restore, we only restore the usage of KV without actually writing KV into DB
        for (k, v) in chunk.iter() {
            usage.add_item(k.key_size() + v.value_size());
        }
```

**File:** storage/aptosdb/src/state_restore/mod.rs (L129-135)
```rust
    pub fn finish(self) -> Result<()> {
        let progress = self.db.get_progress(self.version)?;
        self.db.kv_finish(
            self.version,
            progress.map_or(StateStorageUsage::zero(), |p| p.usage),
        )
    }
```

**File:** storage/aptosdb/src/state_restore/mod.rs (L260-273)
```rust
    fn finish(self) -> Result<()> {
        match self.restore_mode {
            StateSnapshotRestoreMode::KvOnly => self.kv_restore.lock().take().unwrap().finish()?,
            StateSnapshotRestoreMode::TreeOnly => {
                self.tree_restore.lock().take().unwrap().finish_impl()?
            },
            StateSnapshotRestoreMode::Default => {
                // for tree only mode, we also need to write the usage to DB
                self.kv_restore.lock().take().unwrap().finish()?;
                self.tree_restore.lock().take().unwrap().finish_impl()?
            },
        }
        Ok(())
    }
```

**File:** storage/aptosdb/src/state_store/mod.rs (L238-248)
```rust
    fn get_state_storage_usage(&self, version: Option<Version>) -> Result<StateStorageUsage> {
        version.map_or(Ok(StateStorageUsage::zero()), |version| {
            Ok(match self.ledger_db.metadata_db().get_usage(version) {
                Ok(data) => data,
                _ => {
                    ensure!(self.skip_usage, "VersionData at {version} is missing.");
                    StateStorageUsage::new_untracked()
                },
            })
        })
    }
```

**File:** storage/aptosdb/src/state_store/mod.rs (L1199-1205)
```rust
    pub fn init_state_ignoring_summary(&self, version: Option<Version>) -> Result<()> {
        let usage = self.get_usage(version)?;
        let state = State::new_at_version(version, usage, HotStateConfig::default());
        let ledger_state = LedgerState::new(state.clone(), state);
        self.set_state_ignoring_summary(ledger_state);

        Ok(())
```

**File:** storage/aptosdb/src/state_store/mod.rs (L1281-1282)
```rust
    fn kv_finish(&self, version: Version, usage: StateStorageUsage) -> Result<()> {
        self.ledger_db.metadata_db().put_usage(version, usage)?;
```

**File:** types/src/state_store/state_storage_usage.rs (L30-42)
```rust
    pub fn items(&self) -> usize {
        match self {
            Self::Tracked { items, .. } => *items,
            Self::Untracked => 0,
        }
    }

    pub fn bytes(&self) -> usize {
        match self {
            Self::Tracked { bytes, .. } => *bytes,
            Self::Untracked => 0,
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/state_storage.move (L39-49)
```text
    public(friend) fun on_new_block(epoch: u64) acquires StateStorageUsage {
        assert!(
            exists<StateStorageUsage>(@aptos_framework),
            error::not_found(ESTATE_STORAGE_USAGE)
        );
        let usage = borrow_global_mut<StateStorageUsage>(@aptos_framework);
        if (epoch != usage.epoch) {
            usage.epoch = epoch;
            usage.usage = get_state_storage_usage_only_at_epoch_beginning();
        }
    }
```

**File:** aptos-move/framework/src/natives/state_storage.rs (L59-79)
```rust
fn native_get_usage(
    context: &mut SafeNativeContext,
    _ty_args: &[Type],
    _args: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    assert!(_ty_args.is_empty());
    assert!(_args.is_empty());

    context.charge(STATE_STORAGE_GET_USAGE_BASE_COST)?;

    let ctx = context.extensions().get::<NativeStateStorageContext>();
    let usage = ctx.resolver.get_usage().map_err(|err| {
        PartialVMError::new(StatusCode::VM_EXTENSION_ERROR)
            .with_message(format!("Failed to get state storage usage: {}", err))
    })?;

    Ok(smallvec![Value::struct_(Struct::pack(vec![
        Value::u64(usage.items() as u64),
        Value::u64(usage.bytes() as u64),
    ]))])
}
```

**File:** storage/backup/backup-cli/src/coordinators/restore.rs (L316-326)
```rust
            if !tree_completed {
                // For boostrap DB to latest version, we want to use default mode
                let restore_mode_opt = if db_next_version > 0 {
                    if replay_all_mode {
                        None // the restore should already been done in the replay_all mode
                    } else {
                        Some(StateSnapshotRestoreMode::TreeOnly)
                    }
                } else {
                    Some(StateSnapshotRestoreMode::Default)
                };
```

**File:** storage/aptosdb/src/db/aptosdb_internal.rs (L148-160)
```rust
        let mut myself = Self::new_with_dbs(
            ledger_db,
            hot_state_merkle_db,
            state_merkle_db,
            state_kv_db,
            pruner_config,
            buffered_state_target_items,
            readonly,
            empty_buffered_state_for_restore,
            rocksdb_configs.enable_storage_sharding,
            internal_indexer_db,
            hot_state_config,
        );
```

**File:** config/src/config/storage_config.rs (L233-233)
```rust
            enable_storage_sharding: true,
```
