# Audit Report

## Title
Database Pruner Infinite Retry Loop on Corruption Leading to Unbounded Storage Growth and Node Failure

## Summary
The database pruner implementations lack corruption recovery mechanisms. When corruption is detected during pruning operations, the pruner enters an infinite retry loop attempting to process the same corrupted data range repeatedly, never advancing its progress. This leads to unbounded database growth, eventual disk exhaustion, and validator node failure.

## Finding Description

The Aptos database pruner system is designed to remove old historical data to prevent unbounded storage growth. However, all `DBSubPruner` implementations lack any mechanism to detect, skip, or recover from database corruption encountered during pruning operations.

**The Critical Flow:**

1. The `PrunerWorkerInner::work()` method runs in a continuous loop, calling `pruner.prune()` repeatedly [1](#0-0) 

2. When pruning errors occur (including corruption), they are caught, logged, and the worker continues to retry after a brief sleep [2](#0-1) 

3. Individual pruner implementations like `TransactionPruner` read data during pruning via `get_pruning_candidate_transactions()`, which iterates over the database [3](#0-2) 

4. RocksDB corruption errors are converted to `AptosDbError::OtherRocksDbError` [4](#0-3) 

5. Progress is ONLY updated after successful pruning completion [5](#0-4) 

**The Vulnerability:**

When corruption exists in a version range that the pruner attempts to process:
- The iterator fails when encountering corrupted data
- Error propagates up through the pruner chain
- Progress metadata is NOT updated (remains at the version before the corrupted range)
- Worker logs the error and retries
- **On retry, the pruner attempts to process THE SAME corrupted range again**
- This creates an infinite loop where no forward progress is ever made

There is no mechanism to:
- Skip corrupted version ranges
- Mark regions as requiring manual intervention  
- Advance progress past unrecoverable errors
- Limit retry attempts
- Gracefully degrade (e.g., prune what's possible, skip the rest)

**Broken Invariants:**

This breaks **Resource Limits (Invariant #9)**: "All operations must respect gas, storage, and computational limits." The pruner's failure to make progress violates storage limits, allowing unbounded database growth.

This also impacts **State Consistency (Invariant #4)** as the pruner is a critical component of state management that maintains database size within operational bounds.

## Impact Explanation

**Severity: HIGH**

This vulnerability qualifies as HIGH severity per Aptos bug bounty criteria under "Validator node slowdowns" and "Significant protocol violations."

**Impact Quantification:**

1. **Immediate Impact**: Pruner becomes stuck, consuming CPU cycles in infinite retry loop
2. **Medium-term Impact**: Database continues growing without pruning, consuming disk space at the normal transaction rate
3. **Long-term Impact**: Disk exhaustion causes validator node failure, requiring manual intervention
4. **Network Impact**: If multiple validators encounter corruption (e.g., from a bug in RocksDB or schema serialization), it could affect network liveness

**Affected Systems:**
- All validator nodes running with pruning enabled (production validators MUST prune to operate long-term)
- All archive nodes that enable pruning
- Any node that experiences database corruption in historical data

**Damage Quantification:**
- **Availability**: Node becomes inoperable when disk fills
- **Operational Cost**: Manual intervention required (corruption repair or database rebuild)
- **Network Health**: Validator downtime affects consensus participation and rewards

## Likelihood Explanation

**Likelihood: MEDIUM-HIGH**

Database corruption is a realistic scenario in production systems due to:

1. **Hardware Failures**: Disk errors, bit flips, controller failures
2. **Filesystem Issues**: Filesystem bugs, unexpected shutdowns, power loss during writes
3. **Software Bugs**: Bugs in RocksDB, schema serialization/deserialization, or concurrent access patterns
4. **Natural Occurrence**: RocksDB explicitly detects and reports corruption, indicating it's an expected scenario [6](#0-5) 

The vulnerability triggers automatically once corruption exists - no attacker interaction required. The infinite retry is deterministic and guaranteed to occur.

**Attacker Requirements:**
- For natural corruption: None (happens automatically)
- For induced corruption: Filesystem access to corrupt database files (requires privileged access, but less sophisticated than attacking consensus)

## Recommendation

Implement corruption recovery mechanisms in the pruner system:

**1. Add retry limits with exponential backoff:**
```rust
// In PrunerWorkerInner
struct PrunerWorkerInner {
    consecutive_errors: AtomicUsize,
    max_consecutive_errors: usize, // e.g., 10
    // ... existing fields
}

fn work(&self) {
    while !self.quit_worker.load(Ordering::SeqCst) {
        let pruner_result = self.pruner.prune(self.batch_size);
        if pruner_result.is_err() {
            let error_count = self.consecutive_errors.fetch_add(1, Ordering::SeqCst);
            if error_count >= self.max_consecutive_errors {
                error!("Pruner failed {} times consecutively. Stopping pruner to prevent infinite loop. Manual intervention required.", error_count);
                self.stop_pruning();
                return;
            }
            // Exponential backoff
            let sleep_ms = self.pruning_time_interval_in_ms * 2_u64.pow(error_count as u32);
            sleep(Duration::from_millis(sleep_ms.min(60000)));
            continue;
        }
        self.consecutive_errors.store(0, Ordering::SeqCst);
        // ... rest of logic
    }
}
```

**2. Add corruption-specific error handling:**
```rust
// Detect corruption errors specifically
if let Err(e) = pruner_result {
    if is_corruption_error(&e) {
        error!("Database corruption detected at version {}. Attempting to skip corrupted range.", 
               self.pruner.progress());
        // Attempt to advance progress past corrupted range
        self.pruner.force_advance_progress(CORRUPTION_SKIP_SIZE);
    }
}
```

**3. Add operator controls:**
- Expose metrics for consecutive pruner errors
- Add admin API to manually advance pruner progress
- Add configuration option to skip corrupted ranges automatically
- Implement corruption detection and repair tools

**4. Improve observability:**
- Alert operators when pruner is stuck
- Track and expose pruner health metrics
- Log detailed corruption information for debugging

## Proof of Concept

**Rust Test Demonstrating the Vulnerability:**

```rust
#[test]
fn test_pruner_infinite_retry_on_corruption() {
    use std::sync::atomic::{AtomicU64, Ordering};
    use std::sync::Arc;
    use std::time::Duration;
    
    // Setup: Create a mock pruner that fails with corruption error
    struct CorruptedPruner {
        call_count: Arc<AtomicU64>,
        progress: AtomicVersion,
    }
    
    impl DBPruner for CorruptedPruner {
        fn name(&self) -> &'static str { "test_pruner" }
        
        fn prune(&self, _batch_size: usize) -> Result<Version> {
            self.call_count.fetch_add(1, Ordering::SeqCst);
            // Simulate corruption error
            Err(AptosDbError::OtherRocksDbError(
                "Corruption: corrupted key in database".into()
            ).into())
        }
        
        fn progress(&self) -> Version {
            self.progress.load(Ordering::SeqCst)
        }
        
        fn set_target_version(&self, _: Version) {}
        fn target_version(&self) -> Version { 1000 }
        fn record_progress(&self, v: Version) {
            self.progress.store(v, Ordering::SeqCst);
        }
    }
    
    let call_count = Arc::new(AtomicU64::new(0));
    let pruner = Arc::new(CorruptedPruner {
        call_count: Arc::clone(&call_count),
        progress: AtomicVersion::new(0),
    });
    
    let worker = PrunerWorker::new(pruner, 100, "test");
    worker.set_target_db_version(1000);
    
    // Wait and verify pruner keeps retrying
    std::thread::sleep(Duration::from_millis(500));
    
    let calls = call_count.load(Ordering::SeqCst);
    assert!(calls > 10, "Pruner should retry many times, but called {} times", calls);
    
    // Verify progress never advanced
    assert_eq!(worker.inner.pruner.progress(), 0, 
               "Progress should remain at 0, stuck on corruption");
    
    // This demonstrates the infinite retry loop on corruption
}
```

**Manual Reproduction Steps:**

1. Run an Aptos validator node with pruning enabled
2. Wait for some transactions to be committed and pruning to begin
3. Stop the node
4. Corrupt the RocksDB database files in the ledger_db directory:
   ```bash
   # Corrupt a random block in the transaction column family
   dd if=/dev/urandom of=storage/aptosdb/ledger_db/transaction.sst \
      bs=4096 count=1 seek=100 conv=notrunc
   ```
5. Restart the node
6. Observe pruner logs showing repeated errors for the same version range
7. Monitor disk usage - it will continue growing unbounded
8. Eventually, disk will fill and node will fail

**Notes:**
- The vulnerability requires database corruption to trigger, which can occur naturally in production
- Once triggered, it's deterministic and guaranteed to cause unbounded growth
- Manual intervention (corruption repair or database rebuild) is required to recover
- No automatic recovery mechanism exists in the current implementation

### Citations

**File:** storage/aptosdb/src/pruner/pruner_worker.rs (L53-69)
```rust
    fn work(&self) {
        while !self.quit_worker.load(Ordering::SeqCst) {
            let pruner_result = self.pruner.prune(self.batch_size);
            if pruner_result.is_err() {
                sample!(
                    SampleRate::Duration(Duration::from_secs(1)),
                    error!(error = ?pruner_result.err().unwrap(),
                        "Pruner has error.")
                );
                sleep(Duration::from_millis(self.pruning_time_interval_in_ms));
                continue;
            }
            if !self.pruner.is_pruning_pending() {
                sleep(Duration::from_millis(self.pruning_time_interval_in_ms));
            }
        }
    }
```

**File:** storage/aptosdb/src/pruner/ledger_pruner/transaction_pruner.rs (L106-131)
```rust
    fn get_pruning_candidate_transactions(
        &self,
        start: Version,
        end: Version,
    ) -> Result<Vec<(Version, Transaction)>> {
        ensure!(end >= start, "{} must be >= {}", end, start);

        let mut iter = self
            .ledger_db
            .transaction_db_raw()
            .iter::<TransactionSchema>()?;
        iter.seek(&start)?;

        // The capacity is capped by the max number of txns we prune in a single batch. It's a
        // relatively small number set in the config, so it won't cause high memory usage here.
        let mut txns = Vec::with_capacity((end - start) as usize);
        for item in iter {
            let (version, txn) = item?;
            if version >= end {
                break;
            }
            txns.push((version, txn));
        }

        Ok(txns)
    }
```

**File:** storage/schemadb/src/lib.rs (L389-407)
```rust
fn to_db_err(rocksdb_err: rocksdb::Error) -> AptosDbError {
    match rocksdb_err.kind() {
        ErrorKind::Incomplete => AptosDbError::RocksDbIncompleteResult(rocksdb_err.to_string()),
        ErrorKind::NotFound
        | ErrorKind::Corruption
        | ErrorKind::NotSupported
        | ErrorKind::InvalidArgument
        | ErrorKind::IOError
        | ErrorKind::MergeInProgress
        | ErrorKind::ShutdownInProgress
        | ErrorKind::TimedOut
        | ErrorKind::Aborted
        | ErrorKind::Busy
        | ErrorKind::Expired
        | ErrorKind::TryAgain
        | ErrorKind::CompactionTooLarge
        | ErrorKind::ColumnFamilyDropped
        | ErrorKind::Unknown => AptosDbError::OtherRocksDbError(rocksdb_err.to_string()),
    }
```

**File:** storage/aptosdb/src/pruner/ledger_pruner/mod.rs (L86-87)
```rust
            progress = current_batch_target_version;
            self.record_progress(progress);
```
