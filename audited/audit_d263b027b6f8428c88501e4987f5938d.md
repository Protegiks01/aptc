# Audit Report

## Title
Missing Gas Parameter Validation in Governance Updates Enables Resource Exhaustion Attacks

## Summary
The Aptos gas schedule update mechanism lacks validation of gas parameter values, allowing governance proposals to set native function gas costs to zero or arbitrarily low values. This breaks gas accounting and enables any user to execute computationally expensive cryptographic operations (like BLS12-381 pairings) for free, leading to validator resource exhaustion and potential network-wide denial of service.

## Finding Description

The vulnerability exists in the gas schedule governance update flow where critical validation is missing:

**1. Missing Validation in Gas Schedule Updates**

The `set_for_next_epoch` function in the gas schedule module only validates that the blob is non-empty and the feature version is non-decreasing, but explicitly lacks consistency checks: [1](#0-0) 

Note the TODO comment at line 47 and similar comments throughout indicating missing validation: [2](#0-1) 

**2. Unconstrained Gas Parameter Parsing**

The gas parameter deserialization performs no bounds checking on values: [3](#0-2) 

The macro simply converts u64 values directly to gas parameters with `.into()` without any validation of minimum/maximum bounds.

**3. Zero Gas Parameters Enable Free Execution**

When gas parameters are zero, the charge function evaluates to zero gas cost: [4](#0-3) 

In the gas meter, charging zero gas leaves the balance unchanged: [5](#0-4) 

**4. Expensive Native Functions Become Free**

Critical cryptographic operations like BLS12-381 aggregate signature verification charge gas based on these parameters: [6](#0-5) 

If `BLS12381_PER_PAIRING` is set to zero via governance, this charges `0 * (N+1) = 0` gas for N+1 expensive pairing operations. Normal values for these parameters are substantial: [7](#0-6) 

**Attack Scenario:**

1. A governance proposal (malicious or erroneous) sets `bls12381_per_pairing` to 0
2. The proposal passes governance voting and is applied at the next epoch
3. Any user can now call `bls12381_verify_aggregate_signature` with hundreds of messages
4. Each call performs hundreds of expensive pairing operations (each ~14.7M gas units normally) but charges 0 gas
5. Validators' CPU resources are exhausted processing these free operations
6. Network experiences degraded performance or complete liveness failure

## Impact Explanation

**Critical Severity** - This vulnerability meets multiple critical impact criteria:

1. **Total Loss of Liveness/Network Availability**: Validators can be overwhelmed with free expensive operations, causing network-wide denial of service

2. **Consensus Safety Violation**: Different validators may process blocks at different rates based on their CPU capacity when flooded with expensive free operations, potentially causing consensus failures

3. **Resource Limits Invariant Broken**: Violates the documented invariant #9: "All operations must respect gas, storage, and computational limits"

4. **Move VM Safety Invariant Broken**: Violates invariant #3: "Bytecode execution must respect gas limits and memory constraints"

The normal cost for a single BLS12-381 pairing is 14,751,788 internal gas units. An attacker could craft transactions calling aggregate signature verification with 100 messages (101 pairings), normally costing ~1.49 billion gas units, but paying effectively zero gas. A single transaction slot could execute operations equivalent to consuming the entire block gas limit multiple times over.

## Likelihood Explanation

**Medium-High Likelihood:**

1. **Accidental Trigger**: A governance proposal with a typo or missing digit could accidentally set critical parameters to zero without malicious intent

2. **No Runtime Protection**: Once malicious parameters are set, there are no runtime checks to prevent exploitation

3. **Simple Exploitation**: After parameters are set to zero, any user can exploit it with straightforward native function calls

4. **Governance Dependency**: The system has a single point of failure - governance must be perfect with no validation safety net

While the initial trigger requires governance action (either malicious or accidental), the subsequent exploitation is trivial and can be performed by any network participant.

## Recommendation

Implement comprehensive gas parameter validation during governance updates:

```rust
// In aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move

public fun set_for_next_epoch(aptos_framework: &signer, gas_schedule_blob: vector<u8>) acquires GasScheduleV2 {
    system_addresses::assert_aptos_framework(aptos_framework);
    assert!(!vector::is_empty(&gas_schedule_blob), error::invalid_argument(EINVALID_GAS_SCHEDULE));
    let new_gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
    
    if (exists<GasScheduleV2>(@aptos_framework)) {
        let cur_gas_schedule = borrow_global<GasScheduleV2>(@aptos_framework);
        assert!(
            new_gas_schedule.feature_version >= cur_gas_schedule.feature_version,
            error::invalid_argument(EINVALID_GAS_FEATURE_VERSION)
        );
    };
    
    // ADD: Validate gas schedule consistency
    validate_gas_schedule_consistency(&new_gas_schedule);
    
    config_buffer::upsert(new_gas_schedule);
}

// ADD: New validation function
fun validate_gas_schedule_consistency(schedule: &GasScheduleV2) {
    // Validate that critical parameters are within acceptable bounds
    let i = 0;
    while (i < vector::length(&schedule.entries)) {
        let entry = vector::borrow(&schedule.entries, i);
        
        // Enforce minimum values for expensive operations
        if (is_critical_parameter(&entry.key)) {
            assert!(entry.val >= get_minimum_value(&entry.key), 
                error::invalid_argument(EINVALID_GAS_SCHEDULE));
        };
        
        // Enforce maximum values to prevent overflow
        assert!(entry.val <= MAX_REASONABLE_GAS_VALUE,
            error::invalid_argument(EINVALID_GAS_SCHEDULE));
        
        i = i + 1;
    };
}
```

Additionally, add runtime checks in the Rust gas parameter loading code to reject zero or suspiciously low values:

```rust
// In aptos-move/aptos-gas-schedule/src/gas_schedule/macros.rs
// Modify the macro to add validation

params.$name = {
    let val = gas_schedule.get(&name).cloned().ok_or_else(|| format!("Gas parameter {} does not exist.", name))?;
    // ADD: Validate critical parameters are not zero
    if val == 0 && is_critical_param(&name) {
        return Err(format!("Critical gas parameter {} cannot be zero", name));
    }
    val.into()
};
```

## Proof of Concept

```move
module test_addr::gas_exploit {
    use std::vector;
    use aptos_std::crypto_algebra::bls12381;
    
    /// Demonstrates resource exhaustion when gas parameters are zero
    public entry fun exploit_zero_gas_params(account: &signer) {
        // Generate test data
        let messages = vector::empty<vector<u8>>();
        let public_keys = vector::empty<bls12381::PublicKey>();
        
        // Create 100 messages and corresponding public keys
        let i = 0;
        while (i < 100) {
            vector::push_back(&mut messages, b"attack_message");
            // Assume public_keys are populated with valid test keys
            i = i + 1;
        };
        
        // If bls12381_per_pairing is set to 0 via governance:
        // - This call should cost ~1.49 billion gas (101 pairings * 14.75M each)
        // - But actually costs 0 gas, allowing unlimited calls
        // - Each call consumes significant validator CPU for pairing operations
        
        let fake_signature = vector::empty<u8>();
        // In real attack, use valid-looking signature bytes
        
        // This expensive verification executes for free
        let _result = bls12381::verify_aggregate_signature(
            &fake_signature,
            public_keys,
            messages
        );
        
        // Attacker can call this repeatedly in a loop or across multiple transactions
        // to exhaust validator resources
    }
}
```

**Notes**

This vulnerability represents a critical defense-in-depth failure. While governance is trusted, the lack of input validation creates a single point of failure where:

1. **Accidental errors** in governance proposals could inadvertently break gas accounting
2. **Malicious governance compromise** (however unlikely) would have catastrophic consequences
3. **No recovery mechanism** exists once bad parameters are committed to chain

The explicit TODO comments in the codebase confirm this validation was intended but never implemented, making this a known gap in the security architecture. The fix requires both on-chain Move validation and off-chain Rust validation to ensure defense in depth.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L43-50)
```text
    public(friend) fun initialize(aptos_framework: &signer, gas_schedule_blob: vector<u8>) {
        system_addresses::assert_aptos_framework(aptos_framework);
        assert!(!vector::is_empty(&gas_schedule_blob), error::invalid_argument(EINVALID_GAS_SCHEDULE));

        // TODO(Gas): check if gas schedule is consistent
        let gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
        move_to<GasScheduleV2>(aptos_framework, gas_schedule);
    }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L91-103)
```text
    public fun set_for_next_epoch(aptos_framework: &signer, gas_schedule_blob: vector<u8>) acquires GasScheduleV2 {
        system_addresses::assert_aptos_framework(aptos_framework);
        assert!(!vector::is_empty(&gas_schedule_blob), error::invalid_argument(EINVALID_GAS_SCHEDULE));
        let new_gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
        if (exists<GasScheduleV2>(@aptos_framework)) {
            let cur_gas_schedule = borrow_global<GasScheduleV2>(@aptos_framework);
            assert!(
                new_gas_schedule.feature_version >= cur_gas_schedule.feature_version,
                error::invalid_argument(EINVALID_GAS_FEATURE_VERSION)
            );
        };
        config_buffer::upsert(new_gas_schedule);
    }
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/macros.rs (L34-45)
```rust
            fn from_on_chain_gas_schedule(gas_schedule: &std::collections::BTreeMap<String, u64>, feature_version: u64) -> Result<Self, String> {
                let mut params = $params_name::zeros();

                $(
                    if let Some(key) = $crate::gas_schedule::macros::define_gas_parameters_extract_key_at_version!($key_bindings, feature_version) {
                        let name = format!("{}.{}", $prefix, key);
                        params.$name = gas_schedule.get(&name).cloned().ok_or_else(|| format!("Gas parameter {} does not exist. Feature version: {}.", name, feature_version))?.into();
                    }
                )*

                Ok(params)
            }
```

**File:** aptos-move/aptos-native-interface/src/context.rs (L75-103)
```rust
    pub fn charge(
        &mut self,
        abstract_amount: impl GasExpression<NativeGasParameters, Unit = InternalGasUnit>,
    ) -> SafeNativeResult<()> {
        let amount = abstract_amount.evaluate(self.gas_feature_version, self.native_gas_params);

        if let Some(hook) = self.gas_hook {
            let node = abstract_amount.to_dynamic();
            hook(node);
        }

        if self.has_direct_gas_meter_access_in_native_context() {
            self.gas_meter()
                .charge_native_execution(amount)
                .map_err(LimitExceededError::from_err)?;
            Ok(())
        } else {
            self.legacy_gas_used += amount;
            if self.legacy_gas_used > self.legacy_gas_budget()
                && self.legacy_enable_incremental_gas_charging
            {
                Err(SafeNativeError::LimitExceeded(
                    LimitExceededError::LegacyOutOfGas,
                ))
            } else {
                Ok(())
            }
        }
    }
```

**File:** aptos-move/aptos-gas-meter/src/algebra.rs (L172-209)
```rust
    #[inline(always)]
    fn charge_execution(
        &mut self,
        abstract_amount: impl GasExpression<VMGasParameters, Unit = InternalGasUnit> + Debug,
    ) -> PartialVMResult<()> {
        self.counter_for_kill_switch += 1;
        if self.counter_for_kill_switch & 3 == 0
            && self.block_synchronization_kill_switch.interrupt_requested()
        {
            return Err(
                PartialVMError::new(StatusCode::SPECULATIVE_EXECUTION_ABORT_ERROR)
                    .with_message("Interrupted from block synchronization view".to_string()),
            );
        }

        let amount = abstract_amount.evaluate(self.feature_version, &self.vm_gas_params);

        match self.balance.checked_sub(amount) {
            Some(new_balance) => {
                self.balance = new_balance;
                self.execution_gas_used += amount;
            },
            None => {
                let old_balance = self.balance;
                self.balance = 0.into();
                if self.feature_version >= 12 {
                    self.execution_gas_used += old_balance;
                }
                return Err(PartialVMError::new(StatusCode::OUT_OF_GAS));
            },
        };

        if self.feature_version >= 7 && self.execution_gas_used > self.max_execution_gas {
            Err(PartialVMError::new(StatusCode::EXECUTION_LIMIT_REACHED))
        } else {
            Ok(())
        }
    }
```

**File:** aptos-move/framework/src/natives/cryptography/bls12381.rs (L488-501)
```rust
    context.charge(
        BLS12381_PER_PAIRING * NumArgs::new((messages.len() + 1) as u64)
            + BLS12381_PER_MSG_HASHING * NumArgs::new(messages.len() as u64)
            + BLS12381_PER_BYTE_HASHING
                * messages.iter().fold(NumBytes::new(0), |sum, msg| {
                    sum + NumBytes::new(msg.len() as u64)
                }),
    )?;

    let verify_result = aggsig
        .verify_aggregate_arbitrary_msg(&msgs_refs, &pks_refs)
        .is_ok();

    Ok(smallvec![Value::bool(verify_result)])
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/aptos_framework.rs (L182-188)
```rust
        [bls12381_per_sig_verify: InternalGasPerArg, "bls12381.per_sig_verify", 31190860],
        [bls12381_per_pop_verify: InternalGasPerArg, "bls12381.per_pop_verify", 37862800],

        [bls12381_per_pairing: InternalGasPerArg, "bls12381.per_pairing", 14751788],

        [bls12381_per_msg_hashing: InternalGasPerArg, "bls12381.per_msg_hashing", 5661040],
        [bls12381_per_byte_hashing: InternalGasPerByte, "bls12381.per_byte_hashing", 183],
```
