# Audit Report

## Title
Retroactive Authorization Bypass via MultisigV2Enhancement Feature Activation

## Summary
The activation order of multisig feature flags creates a critical window where pending transactions created under stricter authorization requirements can be executed with weakened security guarantees. Specifically, when `MultisigV2Enhancement` is enabled after transactions are already pending, the validation logic switches from requiring K explicit approvals to allowing implicit approval during execution, effectively reducing the approval threshold retroactively.

## Finding Description

The multisig account system uses three related feature flags that control authorization and validation behavior: [1](#0-0) [2](#0-1) [3](#0-2) 

The critical vulnerability exists in how transaction validation changes when `MultisigV2Enhancement` is activated:

**Before V2Enhancement is enabled:** [4](#0-3) 

The validation uses `can_be_executed()` which strictly counts existing explicit approvals: [5](#0-4) 

**After V2Enhancement is enabled:** [6](#0-5) 

The validation switches to `can_execute()` which grants implicit approval to the executor: [7](#0-6) 

**Attack Scenario:**

1. A 2-of-3 multisig account has `MULTISIG_ACCOUNTS` enabled
2. Owner A creates a transaction to transfer funds (receives automatic approval via line 1310) [8](#0-7) 

3. The transaction now has 1 explicit approval, needs 2 total to execute
4. Owner B and Owner C haven't voted yet
5. **Governance enables `MULTISIG_V2_ENHANCEMENT` via on-chain proposal**
6. Owner B (who never explicitly approved) can now execute the transaction
   - `can_execute()` checks if Owner B voted (they didn't)
   - Adds implicit approval: 1 + 1 = 2 approvals
   - Check passes: 2 >= 2 (num_signatures_required)
   - Transaction executes despite having only 1 explicit approval

The implicit approval is recorded during cleanup: [9](#0-8) 

This breaks the fundamental security invariant that **K-of-N explicit approvals are required before execution**. Transactions created under the expectation of needing K explicit approvals can suddenly be executed with K-1 explicit approvals + 1 implicit approval from the executor.

## Impact Explanation

**Severity: HIGH** (Significant Protocol Violation)

This vulnerability breaks critical security guarantees:

1. **Authorization Bypass**: Transactions can execute with fewer explicit approvals than the threshold requires, violating the K-of-N multisig security model
2. **Retroactive Security Weakening**: Existing pending transactions created under stricter rules become vulnerable to execution with relaxed rules
3. **No User Consent**: Multisig owners have no control over when the upgrade happens or ability to protect existing transactions
4. **Non-Deterministic Security**: The same transaction has different execution requirements before vs. after the feature flag activation

While this doesn't directly cause loss of funds, it enables **unauthorized operations** that could lead to:
- Unauthorized fund transfers
- Unauthorized owner changes  
- Unauthorized signature threshold modifications
- Unauthorized metadata updates

Any pending multisig transaction becomes executable with one fewer explicit approval once V2Enhancement activates.

## Likelihood Explanation

**Likelihood: HIGH**

This vulnerability is highly likely to occur because:

1. **Guaranteed Trigger**: Feature flag activation is a normal governance operation that WILL happen as the protocol upgrades
2. **Common Scenario**: Multisig accounts often have pending transactions (especially governance proposals with long voting periods)
3. **No Migration Path**: There is no grace period, notification system, or automatic cancellation of pending transactions
4. **Network-Wide Impact**: All multisig accounts are affected simultaneously at the feature activation block
5. **Unpredictable Timing**: Multisig owners cannot predict when governance will enable the feature

The default feature list shows all three flags are meant to be enabled together in production: [10](#0-9) [11](#0-10) [12](#0-11) 

However, during initial rollout or between upgrades, there will be windows where these flags are activated separately, creating the vulnerability window.

## Recommendation

Implement transaction versioning to preserve the security model under which transactions were created:

```move
struct MultisigTransaction has copy, drop, store {
    payload: Option<vector<u8>>,
    payload_hash: Option<vector<u8>>,
    votes: SimpleMap<address, bool>,
    creator: address,
    creation_time_secs: u64,
    // NEW: Record feature flag state at creation
    created_with_v2_enhancement: bool,
}
```

In `validate_multisig_transaction`, use the transaction's recorded feature state:

```move
fun validate_multisig_transaction(
    owner: &signer, multisig_account: address, payload: vector<u8>) acquires MultisigAccount {
    // ... existing checks ...
    
    let transaction = table::borrow(&multisig_account_resource.transactions, sequence_number);
    
    // Use the feature state from when transaction was CREATED, not current state
    if (transaction.created_with_v2_enhancement) {
        assert!(
            can_execute(address_of(owner), multisig_account, sequence_number),
            error::invalid_argument(ENOT_ENOUGH_APPROVALS),
        );
    } else {
        assert!(
            can_be_executed(multisig_account, sequence_number),
            error::invalid_argument(ENOT_ENOUGH_APPROVALS),
        );
    };
    // ... rest of validation ...
}
```

Update `add_transaction` to record the current feature state:

```move
inline fun add_transaction(
    creator: address,
    multisig_account: address,
    mut transaction: MultisigTransaction
) {
    // Record current feature state
    transaction.created_with_v2_enhancement = features::multisig_v2_enhancement_feature_enabled();
    // ... rest of function ...
}
```

This ensures transactions maintain their original security guarantees regardless of future feature flag changes.

## Proof of Concept

```move
#[test(framework = @0x1, owner_a = @0x123, owner_b = @0x124, owner_c = @0x125)]
public entry fun test_retroactive_authorization_bypass(
    framework: &signer,
    owner_a: &signer, 
    owner_b: &signer, 
    owner_c: &signer
) acquires MultisigAccount {
    // Setup with ONLY MultisigAccounts enabled (V2 Enhancement OFF)
    features::change_feature_flags_for_testing(
        framework,
        vector[features::get_multisig_accounts_feature()],
        vector[]
    );
    timestamp::set_time_has_started_for_testing(framework);
    chain_id::initialize_for_test(framework, 1);
    
    let owner_a_addr = address_of(owner_a);
    let owner_b_addr = address_of(owner_b);
    let owner_c_addr = address_of(owner_c);
    
    // Create 2-of-3 multisig
    create_account(owner_a_addr);
    let multisig_addr = get_next_multisig_account_address(owner_a_addr);
    create_with_owners(owner_a, vector[owner_b_addr, owner_c_addr], 2, vector[], vector[]);
    
    // Owner A creates transaction (gets 1 approval automatically)
    create_transaction(owner_a, multisig_addr, PAYLOAD);
    
    // Verify transaction cannot be executed yet (only 1 of 2 approvals)
    assert!(!can_be_executed(multisig_addr, 1), 0);
    assert!(!can_execute(owner_b_addr, multisig_addr, 1), 1);
    
    // EXPLOIT: Enable MultisigV2Enhancement via governance
    features::change_feature_flags_for_testing(
        framework,
        vector[features::get_multisig_v2_enhancement_feature()],
        vector[]
    );
    
    // NOW Owner B can execute with implicit approval despite never explicitly approving!
    assert!(can_execute(owner_b_addr, multisig_addr, 1), 2);
    
    // Execution succeeds with only 1 explicit approval + 1 implicit approval
    // This violates the 2-of-3 security guarantee the transaction was created under
}
```

**Notes:**
- Transaction created when 2 explicit approvals required
- Feature flag changed the rules mid-flight  
- Transaction executable with 1 explicit + 1 implicit approval
- Security guarantee retroactively weakened without owner consent
- Any pending multisig transaction across the network is affected at feature activation

### Citations

**File:** aptos-move/aptos-release-builder/src/components/feature_flags.rs (L64-64)
```rust
    MultisigAccounts,
```

**File:** aptos-move/aptos-release-builder/src/components/feature_flags.rs (L109-109)
```rust
    MultisigV2Enhancement,
```

**File:** aptos-move/aptos-release-builder/src/components/feature_flags.rs (L124-124)
```rust
    AbortIfMultisigPayloadMismatch,
```

**File:** aptos-move/framework/aptos-framework/sources/multisig_account.move (L408-413)
```text
    public fun can_be_executed(multisig_account: address, sequence_number: u64): bool acquires MultisigAccount {
        assert_valid_sequence_number(multisig_account, sequence_number);
        let (num_approvals, _) = num_approvals_and_rejections(multisig_account, sequence_number);
        sequence_number == last_resolved_sequence_number(multisig_account) + 1 &&
            num_approvals >= num_signatures_required(multisig_account)
    }
```

**File:** aptos-move/framework/aptos-framework/sources/multisig_account.move (L417-426)
```text
    public fun can_execute(owner: address, multisig_account: address, sequence_number: u64): bool acquires MultisigAccount {
        assert_valid_sequence_number(multisig_account, sequence_number);
        let (num_approvals, _) = num_approvals_and_rejections(multisig_account, sequence_number);
        if (!has_voted_for_approval(multisig_account, sequence_number, owner)) {
            num_approvals = num_approvals + 1;
        };
        is_owner(owner, multisig_account) &&
            sequence_number == last_resolved_sequence_number(multisig_account) + 1 &&
            num_approvals >= num_signatures_required(multisig_account)
    }
```

**File:** aptos-move/framework/aptos-framework/sources/multisig_account.move (L1146-1150)
```text
        if (features::multisig_v2_enhancement_feature_enabled()) {
            assert!(
                can_execute(address_of(owner), multisig_account, sequence_number),
                error::invalid_argument(ENOT_ENOUGH_APPROVALS),
            );
```

**File:** aptos-move/framework/aptos-framework/sources/multisig_account.move (L1152-1157)
```text
        else {
            assert!(
                can_be_executed(multisig_account, sequence_number),
                error::invalid_argument(ENOT_ENOUGH_APPROVALS),
            );
        };
```

**File:** aptos-move/framework/aptos-framework/sources/multisig_account.move (L1256-1282)
```text
        let implicit_approval = !has_voted_for_approval(multisig_account, sequence_number, executor);

        let multisig_account_resource = borrow_global_mut<MultisigAccount>(multisig_account);
        let (num_approvals, _) = remove_executed_transaction(multisig_account_resource);

        if (features::multisig_v2_enhancement_feature_enabled() && implicit_approval) {
            if (std::features::module_event_migration_enabled()) {
                emit(
                    Vote {
                        multisig_account,
                        owner: executor,
                        sequence_number,
                        approved: true,
                    }
                );
            } else {
                emit_event(
                    &mut multisig_account_resource.vote_events,
                    VoteEvent {
                        owner: executor,
                        sequence_number,
                        approved: true,
                    }
                );
            };
            num_approvals = num_approvals + 1;
        };
```

**File:** aptos-move/framework/aptos-framework/sources/multisig_account.move (L1307-1310)
```text
        let multisig_account_resource = borrow_global_mut<MultisigAccount>(multisig_account);

        // The transaction creator also automatically votes for the transaction.
        simple_map::add(&mut transaction.votes, creator, true);
```

**File:** types/src/on_chain_config/aptos_features.rs (L184-184)
```rust
            FeatureFlag::MULTISIG_ACCOUNTS,
```

**File:** types/src/on_chain_config/aptos_features.rs (L226-226)
```rust
            FeatureFlag::MULTISIG_V2_ENHANCEMENT,
```

**File:** types/src/on_chain_config/aptos_features.rs (L240-240)
```rust
            FeatureFlag::ABORT_IF_MULTISIG_PAYLOAD_MISMATCH,
```
