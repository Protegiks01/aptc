# Audit Report

## Title
Feature Flag State-Dependent Denial of Service in Dispatchable Fungible Assets via Legacy Check Bypass

## Summary
When `is_account_abstraction_enabled()` is false, the `native_dispatch()` function uses `legacy_check_visited()` to verify that dispatch target modules have been properly loaded and charged. However, special addresses (0x0-0xf) are never added to the visited set during module loading, causing a critical inconsistency: fungible assets with dispatch functions pointing to special addresses work correctly when account abstraction is enabled but permanently fail when it's disabled, freezing all funds.

## Finding Description
The vulnerability stems from an inconsistency between two module visitation checking mechanisms: [1](#0-0) 

When account abstraction is enabled, `check_is_special_or_visited()` is used, which explicitly allows special addresses without checking the visited set: [2](#0-1) 

However, when account abstraction is disabled, `legacy_check_visited()` is used, which checks the visited set for ALL addresses including special ones: [3](#0-2) 

The critical issue is that special addresses are **never added to the visited set** during module loading: [4](#0-3) [5](#0-4) 

An attacker can exploit this by:

1. Creating a fungible asset when account abstraction is enabled
2. Registering dispatch functions using `new_function_info_from_address()` pointing to a module at a special address (0x0-0xf): [6](#0-5) 

3. The type compatibility check during registration succeeds because it also uses `check_is_special_or_visited()` when AA is enabled: [7](#0-6) 

4. When account abstraction is later disabled (via governance or feature flag change), all withdraw/deposit operations on this fungible asset abort with error code 4, permanently freezing funds.

## Impact Explanation
This vulnerability has **HIGH severity** impact:

- **Permanent Freezing of Funds**: Once account abstraction is disabled, any fungible asset with dispatch functions at special addresses becomes completely unusable. Users cannot withdraw or deposit, effectively freezing all funds indefinitely.

- **Denial of Service**: The fungible asset becomes permanently bricked, requiring a hard fork to recover.

- **State Inconsistency**: The system's behavior changes based on a feature flag, breaking the invariant that fungible assets should remain operational regardless of configuration changes.

- **Multiple Assets Affected**: All fungible assets using this pattern would fail simultaneously when the feature flag changes.

According to Aptos bug bounty criteria, this qualifies as **High Severity** due to "Significant protocol violations" and potential **Critical Severity** if it leads to "Permanent freezing of funds (requires hardfork)".

## Likelihood Explanation
**Likelihood: Medium**

While this requires specific conditions:
- Attacker must register dispatch functions at special addresses (uncommon but possible)
- Feature flag must toggle from enabled to disabled (rare but legitimate)
- Type signature must be compatible (restricts target functions)

The vulnerability is **exploitable** because:
1. `new_function_info_from_address()` is public and allows pointing to any address
2. No validation prevents dispatch targets at special addresses during registration
3. Feature flag changes are legitimate governance actions that could trigger this at any time
4. An attacker can deliberately create "time bomb" tokens that break when the flag changes

## Recommendation

Add explicit validation to prevent registration of dispatch functions at special addresses:

```move
// In fungible_asset.move, modify register_dispatch_function_sanity_check()
inline fun register_dispatch_function_sanity_check(
    constructor_ref: &ConstructorRef
) {
    // Existing checks...
    
    // Add validation in register_dispatch_functions() to check dispatch targets:
    withdraw_function.for_each_ref(|func| {
        assert!(
            !func.module_address.is_special(),
            error::invalid_argument(ESPECIAL_ADDRESS_NOT_ALLOWED)
        );
    });
    // Similar checks for deposit_function and derived_balance_function
}
```

Alternatively, ensure `legacy_check_visited()` also exempts special addresses:

```rust
// In module_traversal.rs
pub fn legacy_check_visited(
    &self,
    addr: &AccountAddress,
    name: &IdentStr,
) -> PartialVMResult<()> {
    // Add special address check for backwards compatibility
    if addr.is_special() {
        return Ok(());
    }
    self.check_visited_impl(addr, name)
}
```

The first approach (preventing special address dispatch targets) is preferred as it's more explicit and prevents confusion.

## Proof of Concept

```move
#[test_only]
module test_addr::exploit_token {
    use aptos_framework::fungible_asset;
    use aptos_framework::dispatchable_fungible_asset;
    use aptos_framework::function_info;
    use aptos_framework::object;
    use std::option;
    use std::string;
    
    #[test(creator = @test_addr)]
    #[expected_failure(abort_code = 4, location = aptos_framework::dispatchable_fungible_asset)]
    fun test_special_address_dispatch_fails_when_aa_disabled(
        creator: &signer,
    ) {
        // Create a fungible asset
        let constructor_ref = &object::create_named_object(creator, b"EXPLOIT");
        fungible_asset::add_fungibility(
            constructor_ref,
            option::none(),
            string::utf8(b"Exploit Token"),
            string::utf8(b"EXPLOIT"),
            8,
            string::utf8(b""),
            string::utf8(b""),
        );
        
        // Register dispatch function pointing to a special address (0x1)
        // Assume there exists a compatible function at 0x1::some_module::withdraw
        let withdraw = function_info::new_function_info_from_address(
            @0x1,  // Special address
            string::utf8(b"some_module"),
            string::utf8(b"withdraw"),
        );
        
        // This succeeds when account abstraction is enabled
        dispatchable_fungible_asset::register_dispatch_functions(
            constructor_ref,
            option::some(withdraw),
            option::none(),
            option::none(),
        );
        
        let store = fungible_asset::create_store(constructor_ref, metadata);
        
        // When account abstraction is later disabled, this will fail with abort_code 4
        // Users' funds become permanently frozen
        dispatchable_fungible_asset::withdraw(creator, store, 100);
    }
}
```

**Notes**
- The vulnerability creates a state-dependent behavior where the same fungible asset works or fails based on a feature flag
- This breaks the fundamental invariant that fungible asset operations should be deterministic and feature-flag-independent
- The issue affects both the registration path (`check_dispatch_type_compatibility_impl`) and the dispatch path (`native_dispatch`), but registration only fails when AA is already disabled
- The test code shows special addresses (0x1) are marked as visited in tests but NOT in production code during gas charging

### Citations

**File:** aptos-move/framework/src/natives/dispatchable_fungible_asset.rs (L30-45)
```rust
    let check_visited = |a, n| {
        let special_addresses_considered_visited =
            context.get_feature_flags().is_account_abstraction_enabled()
                || context
                    .get_feature_flags()
                    .is_derivable_account_abstraction_enabled();
        if special_addresses_considered_visited {
            context
                .traversal_context()
                .check_is_special_or_visited(a, n)
        } else {
            context.traversal_context().legacy_check_visited(a, n)
        }
    };
    check_visited(module_name.address(), module_name.name())
        .map_err(|_| SafeNativeError::Abort { abort_code: 4 })?;
```

**File:** third_party/move/move-vm/runtime/src/module_traversal.rs (L59-65)
```rust
    pub fn visit_if_not_special_address(
        &mut self,
        addr: &'a AccountAddress,
        name: &'a IdentStr,
    ) -> bool {
        !addr.is_special() && self.visited.insert((addr, name), ()).is_none()
    }
```

**File:** third_party/move/move-vm/runtime/src/module_traversal.rs (L70-85)
```rust
    pub fn visit_if_not_special_module_id(&mut self, module_id: &ModuleId) -> bool {
        let addr = module_id.address();
        if addr.is_special() {
            return false;
        }

        let name = module_id.name();
        if self.visited.contains_key(&(addr, name)) {
            false
        } else {
            let module_id = self.referenced_module_ids.alloc(module_id.clone());
            self.visited
                .insert((module_id.address(), module_id.name()), ());
            true
        }
    }
```

**File:** third_party/move/move-vm/runtime/src/module_traversal.rs (L98-108)
```rust
    pub fn check_is_special_or_visited(
        &self,
        addr: &AccountAddress,
        name: &IdentStr,
    ) -> PartialVMResult<()> {
        if addr.is_special() {
            return Ok(());
        }

        self.check_visited_impl(addr, name)
    }
```

**File:** third_party/move/move-vm/runtime/src/module_traversal.rs (L114-120)
```rust
    pub fn legacy_check_visited(
        &self,
        addr: &AccountAddress,
        name: &IdentStr,
    ) -> PartialVMResult<()> {
        self.check_visited_impl(addr, name)
    }
```

**File:** aptos-move/framework/aptos-framework/sources/function_info.move (L35-53)
```text
    public fun new_function_info_from_address(
        module_address: address,
        module_name: String,
        function_name: String,
    ): FunctionInfo {
        assert!(
            is_identifier(string::bytes(&module_name)),
            EINVALID_IDENTIFIER
        );
        assert!(
            is_identifier(string::bytes(&function_name)),
            EINVALID_IDENTIFIER
        );
        FunctionInfo {
            module_address,
            module_name,
            function_name,
        }
    }
```

**File:** aptos-move/framework/src/natives/function_info.rs (L88-103)
```rust
        let check_visited = |a, n| {
            let special_addresses_considered_visited =
                context.get_feature_flags().is_account_abstraction_enabled()
                    || context
                        .get_feature_flags()
                        .is_derivable_account_abstraction_enabled();
            if special_addresses_considered_visited {
                context
                    .traversal_context()
                    .check_is_special_or_visited(a, n)
            } else {
                context.traversal_context().legacy_check_visited(a, n)
            }
        };
        check_visited(module.address(), module.name())
            .map_err(|_| SafeNativeError::Abort { abort_code: 2 })?;
```
