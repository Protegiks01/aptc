# Audit Report

## Title
Consensus Divergence via Storage Error Swallowing in On-Chain Configuration Reads

## Summary
Storage errors when reading critical on-chain configurations (particularly `Features`) are silently converted to default values, potentially causing different validator nodes to execute transactions with different feature flags if some nodes experience storage errors while others do not, leading to consensus divergence.

## Finding Description

The codebase contains a systematic error swallowing pattern that masks storage failures when reading on-chain configurations. This violates the **Deterministic Execution** invariant.

### Error Swallowing Chain

1. **ConfigStorage Implementation** - Storage errors are converted to `None`: [1](#0-0) [2](#0-1) 

The `.ok()?` pattern converts **any** error from `get_state_value()` (including `StateViewError::Other` representing storage failures) into `None`, making it indistinguishable from legitimate missing configs.

2. **Features Configuration Loading** - Errors become default features: [3](#0-2) 

The `unwrap_or_default()` provides default `Features` whenever any error occurs, including critical storage failures.

3. **Error Type Definitions**: [4](#0-3) [5](#0-4) 

### Exploitation Scenario

**Precondition**: Network has non-default Features enabled (e.g., new VM binary format, modified gas charging, changed transaction validation rules).

**Attack Vector**: While not directly exploitable by external attackers, this creates a consensus vulnerability when:

1. Validator Node A experiences a transient storage error (disk I/O timeout, RocksDB corruption, filesystem issues) when reading `Features` state key
2. `get_state_value()` returns `Err(StateViewError::Other("storage error"))`
3. Error is swallowed by `.ok()?` â†’ returns `None`
4. `unwrap_or_default()` provides default `Features` with all flags disabled
5. Node A executes block with default features

6. Validator Node B successfully reads `Features` from storage
7. Node B executes same block with actual on-chain features

8. If on-chain features differ from defaults:
   - Nodes compute different state roots
   - Consensus divergence occurs
   - Network partition or safety violation

### Features Impact Consensus-Critical Behavior [6](#0-5) 

Features control resource group handling which affects state layout and gas charging, directly impacting transaction execution determinism.

## Impact Explanation

**Severity: Critical** - Consensus Safety Violation

This meets Critical severity criteria because:

1. **Consensus Safety Violation**: Different validators computing different state roots for identical blocks breaks the fundamental AptosBFT safety guarantee that < 1/3 Byzantine nodes cannot cause safety violations.

2. **Non-Recoverable Without Intervention**: Once divergence occurs, affected nodes cannot automatically recover without manual intervention or rollback.

3. **No Byzantine Nodes Required**: This violates consensus safety through implementation bugs alone, not requiring malicious validators.

4. **Deterministic Execution Broken**: Violates Invariant #1 - "All validators must produce identical state roots for identical blocks."

While this requires hardware/storage failures rather than attacker-triggered exploits, consensus vulnerabilities that can occur through natural operational conditions still qualify as Critical severity under protocol safety violations.

## Likelihood Explanation

**Likelihood: Medium to High**

1. **Storage errors occur in production environments**:
   - Disk I/O timeouts during heavy load
   - RocksDB corruption from unclean shutdowns
   - Network filesystem transient failures
   - SSD wear causing read errors

2. **Race condition window**: Error must occur during specific phase (Environment initialization) creating a time-of-check-time-of-use vulnerability.

3. **Features change infrequently**: On-chain Features typically differ from defaults in production networks, creating persistent divergence risk.

4. **No error detection**: Current implementation provides no logging or alerting when storage errors are swallowed, making the issue invisible until consensus fails.

## Recommendation

**Immediate Fix**: Distinguish between legitimate missing configs vs storage errors:

```rust
impl<E: ExecutorView> ConfigStorage for StorageAdapter<'_, E> {
    fn fetch_config_bytes(&self, state_key: &StateKey) -> Option<Bytes> {
        match self.executor_view.get_resource_bytes(state_key, None) {
            Ok(maybe_bytes) => maybe_bytes,
            Err(e) => {
                // Log critical storage errors instead of silently swallowing
                error!("Storage error reading config at {:?}: {:?}", state_key, e);
                // For consensus-critical configs, panic instead of returning None
                panic!("Cannot proceed with storage error on critical config");
            }
        }
    }
}
```

**Better Solution**: Make Environment initialization return `Result` instead of using `unwrap_or_default()`:

```rust
impl Environment {
    fn new(state_view: &impl StateView, ...) -> Result<Self, String> {
        let features = Features::fetch_config(state_view)
            .ok_or_else(|| "Failed to read Features config from storage")?;
        // ... rest of initialization
    }
}
```

This forces callers to handle the error explicitly, preventing silent consensus divergence.

## Proof of Concept

```rust
#[test]
fn test_storage_error_causes_default_features() {
    use aptos_types::state_store::{StateView, MockStateView};
    use aptos_types::on_chain_config::Features;
    
    // Create a mock state view that returns storage error
    struct FailingStateView;
    
    impl StateView for FailingStateView {
        fn get_state_value(&self, _key: &StateKey) 
            -> Result<Option<StateValue>, StateViewError> {
            // Simulate storage error (e.g., RocksDB corruption)
            Err(StateViewError::Other("RocksDB read error".to_string()))
        }
        
        fn get_usage(&self) -> Result<StateStorageUsage, StateViewError> {
            Ok(StateStorageUsage::zero())
        }
    }
    
    let failing_view = FailingStateView;
    
    // This should fail but instead returns default Features
    let features = Features::fetch_config(&failing_view).unwrap_or_default();
    
    // Demonstrates that storage error becomes default features
    assert_eq!(features, Features::default());
    
    // In production, this means:
    // - Node with storage error: executes with default features
    // - Node without error: executes with on-chain features
    // - Result: Consensus divergence if features differ
}
```

## Notes

This vulnerability demonstrates that error handling patterns designed for fault tolerance can inadvertently create consensus safety issues. The `.ok()?` pattern throughout config loading code prioritizes availability over correctness, which is inappropriate for consensus-critical configurations like `Features` that directly affect transaction execution semantics.

### Citations

**File:** aptos-move/aptos-vm/src/data_cache.rs (L84-85)
```rust
            features.is_resource_groups_split_in_vm_change_set_enabled(),
        );
```

**File:** aptos-move/aptos-vm/src/data_cache.rs (L253-259)
```rust
impl<E: ExecutorView> ConfigStorage for StorageAdapter<'_, E> {
    fn fetch_config_bytes(&self, state_key: &StateKey) -> Option<Bytes> {
        self.executor_view
            .get_resource_bytes(state_key, None)
            .ok()?
    }
}
```

**File:** types/src/on_chain_config/mod.rs (L204-210)
```rust
impl<S: StateView> ConfigStorage for S {
    fn fetch_config_bytes(&self, state_key: &StateKey) -> Option<Bytes> {
        self.get_state_value(state_key)
            .ok()?
            .map(|s| s.bytes().clone())
    }
}
```

**File:** aptos-move/aptos-vm-environment/src/environment.rs (L219-221)
```rust
        let features =
            fetch_config_and_update_hash::<Features>(&mut sha3_256, state_view).unwrap_or_default();

```

**File:** types/src/state_store/errors.rs (L6-15)
```rust
#[derive(Debug, Error)]
pub enum StateViewError {
    #[error("{0} not found.")]
    NotFound(String),
    /// Other non-classified error.
    #[error("{0}")]
    Other(String),
    #[error(transparent)]
    BcsError(#[from] bcs::Error),
}
```

**File:** storage/storage-interface/src/errors.rs (L69-87)
```rust
impl From<AptosDbError> for StateViewError {
    fn from(error: AptosDbError) -> Self {
        match error {
            AptosDbError::NotFound(msg) => StateViewError::NotFound(msg),
            AptosDbError::Other(msg) => StateViewError::Other(msg),
            _ => StateViewError::Other(format!("{}", error)),
        }
    }
}

impl From<StateViewError> for AptosDbError {
    fn from(error: StateViewError) -> Self {
        match error {
            StateViewError::NotFound(msg) => AptosDbError::NotFound(msg),
            StateViewError::Other(msg) => AptosDbError::Other(msg),
            StateViewError::BcsError(err) => AptosDbError::BcsError(err.to_string()),
        }
    }
}
```
