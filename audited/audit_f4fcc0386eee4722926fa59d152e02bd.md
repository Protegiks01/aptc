# Audit Report

## Title
Validator Disagreement on Denied Inline Transactions Causes Consensus Failures and Potential Chain Splits

## Summary
The `check_denied_inline_transactions` method is called during block proposal processing with each validator using its own locally-configured `BlockTransactionFilterConfig`. Since these configurations are loaded from local node config files without on-chain consensus, validators can have different filtering rules, causing them to disagree on which block proposals to vote for. This breaks consensus safety guarantees and can lead to liveness failures or chain splits.

## Finding Description

The vulnerability exists in how transaction filtering is applied during the consensus voting phase. When a validator receives a block proposal containing inline transactions, it calls `check_denied_inline_transactions` to determine if any transactions should be denied based on its local filter configuration. [1](#0-0) 

Each validator's filter configuration comes from its local node configuration file: [2](#0-1) [3](#0-2) 

The `BlockTransactionFilterConfig` is NOT part of the on-chain consensus configuration - it's purely local configuration that can differ between validators. The configuration structure shows it's loaded from node config: [4](#0-3) 

The filtering logic uses rules that can match on block metadata (author, epoch, timestamp) and transaction properties: [5](#0-4) 

**Attack Scenario:**

1. Validator A (proposer) has `consensus_filter` disabled or with permissive rules
2. Validator B has `consensus_filter` enabled with strict deny rules (e.g., deny transactions from specific senders)
3. Validator C has `consensus_filter` disabled
4. Validator A proposes a block with inline transactions including one that matches Validator B's deny rule
5. Validator B calls `check_denied_inline_transactions`, finds denied transactions, and rejects the proposal (doesn't vote)
6. Validator C calls `check_denied_inline_transactions`, finds no denied transactions, and votes for the proposal
7. Result: Validators disagree on block validity, potentially causing consensus to stall if enough validators have conflicting configs

**Additional Issue - ConsensusObserver Asymmetry:**

ConsensusObserver nodes don't check denied transactions at all, creating further asymmetry: [6](#0-5) 

**Critical Invariant Violations:**

1. **Deterministic Execution**: Validators must agree on which blocks are valid
2. **Consensus Safety**: AptosBFT must ensure all honest validators agree on the blockchain state

## Impact Explanation

This vulnerability qualifies as **Critical Severity** ($1,000,000) under the Aptos Bug Bounty program because it enables:

1. **Consensus/Safety Violations**: Validators can disagree on which blocks to vote for, breaking the fundamental assumption that honest validators agree on valid blocks.

2. **Liveness Failures**: If enough validators have conflicting filter configurations, blocks may fail to achieve quorum, causing the chain to halt.

3. **Potential Chain Splits**: In edge cases where validators have severely misaligned configurations, this could lead to different groups of validators accepting different blocks, creating a fork scenario.

4. **Non-Recoverable Network State**: If validators have diverged significantly due to inconsistent filtering, recovery may require manual intervention or a hard fork to realign the network.

The impact is systemic because:
- Every block proposal with inline transactions is vulnerable
- The issue affects the core consensus mechanism
- No on-chain governance mechanism exists to ensure filter consistency
- Validators naturally have different configurations in a decentralized network

## Likelihood Explanation

**Likelihood: HIGH**

This vulnerability is highly likely to manifest in production environments because:

1. **No Coordination Mechanism**: There is no on-chain mechanism to coordinate transaction filter configurations across validators. Each operator independently configures their node.

2. **Configuration Drift**: Over time, different validator operators will update their configurations at different times, leading to natural divergence.

3. **Decentralized Operations**: Aptos validators are operated by different entities with different operational practices and security policies.

4. **Feature Design**: The transaction filtering feature is explicitly designed for validators to make local decisions about which transactions to accept, but this design conflicts with consensus requirements for deterministic block validation.

5. **No Documentation**: There's no clear documentation requiring all validators to maintain identical filter configurations.

The test file confirms this is a documented feature (not a bug in implementation), but the design doesn't account for consensus implications: [7](#0-6) 

## Recommendation

**Immediate Fix**: Remove local transaction filtering from the consensus voting phase entirely. Transaction filtering should only occur during execution (which already has safeguards), not during proposal voting.

**Option 1 - Remove Consensus-Time Filtering:**
Remove the `check_denied_inline_transactions` call from proposal processing and rely solely on execution-time filtering. This ensures validators agree on block validity while still allowing execution-time filtering for denial-of-service protection.

**Option 2 - Move Filters On-Chain:**
Move `BlockTransactionFilterConfig` into the on-chain `ConsensusConfig` so all validators must agree on filtering rules through governance. This ensures consistency but reduces validator autonomy.

**Option 3 - Two-Phase Validation:**
- Phase 1: Validators vote on blocks without filtering (consensus agreement)
- Phase 2: Each validator applies local filters during execution only
- Ensure execution results are deterministic by having a canonical filter that's part of block data

**Recommended Implementation (Option 1):**

In `consensus/src/round_manager.rs`, remove the denied transaction check:

```rust
// REMOVE these lines (1204-1214):
// if let Err(error) = self
//     .block_store
//     .check_denied_inline_transactions(&proposal, &self.block_txn_filter_config)
// {
//     counters::REJECTED_PROPOSAL_DENY_TXN_COUNT.inc();
//     bail!(...);
// }
```

Filtering should remain in `BlockPreparer` for execution-time DoS protection, but the execution filter should be deterministic (ideally on-chain or at minimum documented as requiring identical configuration across all validators).

## Proof of Concept

```rust
// Proof of Concept: Two validators with different configs disagree on block validity
// This would be added as a test in consensus/src/round_manager_tests/

#[test]
fn test_consensus_disagreement_on_filter_mismatch() {
    use aptos_config::config::BlockTransactionFilterConfig;
    use aptos_transaction_filters::block_transaction_filter::{
        BlockTransactionFilter, BlockTransactionMatcher
    };
    use aptos_transaction_filters::transaction_filter::TransactionMatcher;
    
    // Create two validators with different filter configs
    let mut playground = NetworkPlayground::new(runtime.handle().clone());
    
    // Validator 1: Has strict deny filter
    let deny_filter = BlockTransactionFilter::empty()
        .add_multiple_matchers_filter(
            false, // deny
            vec![BlockTransactionMatcher::Transaction(
                TransactionMatcher::Sender(test_sender)
            )]
        );
    let filter_config_strict = BlockTransactionFilterConfig::new(true, deny_filter);
    
    // Validator 2: Has no filter (disabled)
    let filter_config_permissive = BlockTransactionFilterConfig::new(false, 
        BlockTransactionFilter::empty());
    
    // Create validators
    let mut validator1 = create_validator_with_filter(&mut playground, filter_config_strict);
    let mut validator2 = create_validator_with_filter(&mut playground, filter_config_permissive);
    
    // Create a block with inline transaction from denied sender
    let denied_txn = create_transaction_from_sender(test_sender);
    let payload = Payload::QuorumStoreInlineHybrid(
        vec![(BatchInfo::new(...), vec![denied_txn])],
        ProofWithData::empty(),
        None
    );
    let block = Block::new_proposal(payload, 1, 1, genesis_qc, &signer, vec![]).unwrap();
    
    // Validator 1 rejects the block
    let result1 = validator1.round_manager.process_proposal(block.clone()).await;
    assert!(result1.is_err()); // Validator 1 REJECTS
    
    // Validator 2 accepts the same block  
    let result2 = validator2.round_manager.process_proposal(block.clone()).await;
    assert!(result2.is_ok()); // Validator 2 ACCEPTS
    
    // This proves validators disagree on the same block!
    // In production, this causes consensus failure.
}
```

**Notes**

The vulnerability stems from a fundamental design flaw: allowing validators to make independent decisions about transaction validity during the consensus voting phase. While transaction filtering may be desirable for DoS protection, it must not affect consensus agreement on block validity. The separation of concerns should be: consensus determines which blocks are valid, and execution determines which transactions to include in state transitions. Currently, these concerns are improperly mixed, creating the potential for consensus failures.

### Citations

**File:** consensus/src/round_manager.rs (L1204-1214)
```rust
        if let Err(error) = self
            .block_store
            .check_denied_inline_transactions(&proposal, &self.block_txn_filter_config)
        {
            counters::REJECTED_PROPOSAL_DENY_TXN_COUNT.inc();
            bail!(
                "[RoundManager] Proposal for block {} contains denied inline transactions: {}. Dropping proposal!",
                proposal.id(),
                error
            );
        }
```

**File:** consensus/src/epoch_manager.rs (L211-211)
```rust
        let consensus_txn_filter_config = node_config.transaction_filters.consensus_filter.clone();
```

**File:** consensus/src/epoch_manager.rs (L982-982)
```rust
            self.consensus_txn_filter_config.clone(),
```

**File:** config/src/config/transaction_filters_config.rs (L92-123)
```rust
pub struct BlockTransactionFilterConfig {
    filter_enabled: bool, // Whether the filter is enabled
    block_transaction_filter: BlockTransactionFilter, // The block transaction filter to apply
}

impl BlockTransactionFilterConfig {
    pub fn new(filter_enabled: bool, block_transaction_filter: BlockTransactionFilter) -> Self {
        Self {
            filter_enabled,
            block_transaction_filter,
        }
    }

    /// Returns true iff the filter is enabled and not empty
    pub fn is_enabled(&self) -> bool {
        self.filter_enabled && !self.block_transaction_filter.is_empty()
    }

    /// Returns a reference to the block transaction filter
    pub fn block_transaction_filter(&self) -> &BlockTransactionFilter {
        &self.block_transaction_filter
    }
}

impl Default for BlockTransactionFilterConfig {
    fn default() -> Self {
        Self {
            filter_enabled: false,                                     // Disable the filter
            block_transaction_filter: BlockTransactionFilter::empty(), // Use an empty filter
        }
    }
}
```

**File:** crates/aptos-transaction-filters/src/block_transaction_filter.rs (L68-90)
```rust
    /// Identifies the transactions in the given block that are denied by the filter.
    /// Note: this returns the inverse of `filter_block_transactions`.
    pub fn get_denied_block_transactions(
        &self,
        block_id: HashValue,
        block_author: Option<AccountAddress>,
        block_epoch: u64,
        block_timestamp_usecs: u64,
        transactions: Vec<SignedTransaction>,
    ) -> Vec<SignedTransaction> {
        transactions
            .into_iter()
            .filter(|txn| {
                !self.allows_transaction(
                    block_id,
                    block_author,
                    block_epoch,
                    block_timestamp_usecs,
                    txn,
                )
            })
            .collect()
    }
```

**File:** consensus/src/payload_manager/co_payload_manager.rs (L101-107)
```rust
    fn check_denied_inline_transactions(
        &self,
        _block: &Block,
        _block_txn_filter_config: &BlockTransactionFilterConfig,
    ) -> anyhow::Result<()> {
        Ok(()) // Consensus observer doesn't filter transactions
    }
```

**File:** consensus/src/round_manager_tests/txn_filter_proposal_test.rs (L31-46)
```rust
// Verify that the round manager will not vote if a block
// proposal contains any denied inline transactions.
#[test]
fn test_no_vote_on_denied_inline_transactions() {
    // Test both direct mempool and quorum store payloads
    for use_quorum_store_payloads in [false, true] {
        // Create test transactions
        let transactions = create_test_transactions();

        // Create a block filter config that denies the first transaction sender
        let block_txn_filter = BlockTransactionFilter::empty()
            .add_multiple_matchers_filter(false, vec![BlockTransactionMatcher::Transaction(
                TransactionMatcher::Sender(transactions[0].sender()),
            )])
            .add_all_filter(true);
        let block_txn_filter_config = BlockTransactionFilterConfig::new(true, block_txn_filter);
```
