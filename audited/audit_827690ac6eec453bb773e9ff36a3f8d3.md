# Audit Report

## Title
Mempool Bootstrap Panic Due to Unvalidated Broadcast Buckets Configuration

## Summary
The `bootstrap()` function in the mempool runtime does not validate the `broadcast_buckets` configuration parameter before creating `CoreMempool`. Malformed configuration values cause an unhandled panic during node initialization, resulting in validator/fullnode unavailability. This represents a critical operational robustness failure that can be exploited through configuration tampering.

## Finding Description

The `bootstrap()` function directly creates a `CoreMempool` without any prior validation of the configuration parameters. [1](#0-0) 

This `CoreMempool::new(config)` call instantiates a `TransactionStore` which creates `MultiBucketTimelineIndex` objects using the `broadcast_buckets` configuration with an `.unwrap()` call: [2](#0-1) 

The `MultiBucketTimelineIndex::new()` function performs several validation checks using `anyhow::ensure!` that will return errors for invalid configurations: [3](#0-2) 

The validation checks require:
1. `broadcast_buckets` must not be empty
2. First element must equal 0
3. Values must be strictly increasing (sorted, no duplicates)

When any of these conditions fail, `MultiBucketTimelineIndex::new()` returns an `Err`, which is then unwrapped, causing a panic.

**Critical Failure**: The `MempoolConfig::sanitize()` function is supposed to validate configuration but is not implemented: [4](#0-3) 

Although `MempoolConfig::sanitize()` is called during node configuration loading: [5](#0-4) 

It provides **no actual validation** and simply returns `Ok(())` with a TODO comment, leaving the panic path completely unguarded.

## Impact Explanation

**Severity: High**

This vulnerability causes immediate node unavailability during initialization. According to the Aptos bug bounty program, this qualifies as **High Severity** due to:

1. **Validator Node Unavailability**: Affected nodes crash on startup and cannot participate in consensus, reducing the validator set's liveness and potentially impacting network availability if multiple nodes are affected.

2. **Operational Denial of Service**: While requiring configuration file access, this can be exploited through:
   - Supply chain attacks on configuration templates
   - Compromised CI/CD pipelines
   - Malicious infrastructure management tools
   - Configuration management system vulnerabilities

3. **Cascading Impact**: Organizations often deploy multiple nodes from shared configuration templates. A single malformed template could crash multiple validators simultaneously, potentially threatening network liveness if >1/3 of stake is affected.

4. **Poor Error Handling**: The panic provides no actionable error message to operators, making troubleshooting difficult and extending downtime.

## Likelihood Explanation

**Likelihood: Medium-High**

While this requires configuration file access rather than direct network exploitation, the likelihood is elevated due to:

1. **Configuration Management Complexity**: Modern infrastructure uses automated configuration management (Terraform, Ansible, Kubernetes ConfigMaps) where a single template error propagates to multiple nodes.

2. **Supply Chain Risks**: Configuration templates distributed through documentation, GitHub repos, or package managers can be tampered with.

3. **Operational Errors**: Legitimate operators may accidentally misconfigure `broadcast_buckets` when customizing node behavior, especially given the lack of validation or documentation about constraints.

4. **No Defense in Depth**: The complete absence of validation at any layer (config loading, sanitization, or runtime) makes this failure inevitable once malformed config is present.

## Recommendation

Implement proper validation in `MempoolConfig::sanitize()` before any initialization occurs:

```rust
impl ConfigSanitizer for MempoolConfig {
    fn sanitize(
        node_config: &NodeConfig,
        _node_type: NodeType,
        _chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let broadcast_buckets = &node_config.mempool.broadcast_buckets;
        
        // Validate broadcast_buckets
        if broadcast_buckets.is_empty() {
            return Err(Error::ConfigSanitizerFailed(
                "MempoolConfig".to_string(),
                "broadcast_buckets must not be empty".to_string(),
            ));
        }
        
        if broadcast_buckets[0] != 0 {
            return Err(Error::ConfigSanitizerFailed(
                "MempoolConfig".to_string(),
                format!("First broadcast_bucket must be 0, got {}", broadcast_buckets[0]),
            ));
        }
        
        let mut prev = None;
        for &bucket in broadcast_buckets.iter() {
            if let Some(prev_val) = prev {
                if prev_val >= bucket {
                    return Err(Error::ConfigSanitizerFailed(
                        "MempoolConfig".to_string(),
                        format!(
                            "broadcast_buckets must be strictly increasing, found {} followed by {}",
                            prev_val, bucket
                        ),
                    ));
                }
            }
            prev = Some(bucket);
        }
        
        Ok(())
    }
}
```

Additionally, convert the `.unwrap()` to proper error propagation: [2](#0-1) 

Change to return `Result<Self, Error>` and propagate errors properly.

## Proof of Concept

```rust
#[cfg(test)]
mod test {
    use super::*;
    use aptos_config::config::{NodeConfig, MempoolConfig};
    
    #[test]
    #[should_panic(expected = "Must not be empty")]
    fn test_empty_broadcast_buckets_panics() {
        let mut config = NodeConfig::default();
        config.mempool.broadcast_buckets = vec![]; // Empty - violates constraint
        
        // This will panic during CoreMempool::new()
        let _mempool = CoreMempool::new(&config);
    }
    
    #[test]
    #[should_panic(expected = "First bucket must start at 0")]
    fn test_nonzero_first_bucket_panics() {
        let mut config = NodeConfig::default();
        config.mempool.broadcast_buckets = vec![100, 200, 300]; // Doesn't start at 0
        
        let _mempool = CoreMempool::new(&config);
    }
    
    #[test]
    #[should_panic(expected = "Values must be sorted and not repeat")]
    fn test_unsorted_buckets_panics() {
        let mut config = NodeConfig::default();
        config.mempool.broadcast_buckets = vec![0, 300, 200]; // Not sorted
        
        let _mempool = CoreMempool::new(&config);
    }
    
    #[test]
    #[should_panic(expected = "Values must be sorted and not repeat")]
    fn test_duplicate_buckets_panics() {
        let mut config = NodeConfig::default();
        config.mempool.broadcast_buckets = vec![0, 100, 100, 200]; // Has duplicates
        
        let _mempool = CoreMempool::new(&config);
    }
}
```

## Notes

This vulnerability represents a critical gap in defensive programming. While the attack requires configuration file access, modern infrastructure complexity (CI/CD pipelines, configuration management systems, container orchestration) creates multiple attack surfaces for configuration tampering. The complete absence of validation combined with panic-on-error behavior creates an unnecessary operational fragility that could be exploited to cause coordinated validator outages.

The TODO comment in the sanitizer indicates this was a known gap that was never addressed, making this a preventable vulnerability that has persisted in production code.

### Citations

**File:** mempool/src/shared_mempool/runtime.rs (L91-103)
```rust
pub fn bootstrap(
    config: &NodeConfig,
    db: Arc<dyn DbReader>,
    network_client: NetworkClient<MempoolSyncMsg>,
    network_service_events: NetworkServiceEvents<MempoolSyncMsg>,
    client_events: MempoolEventsReceiver,
    quorum_store_requests: Receiver<QuorumStoreRequest>,
    mempool_listener: MempoolNotificationListener,
    mempool_reconfig_events: ReconfigNotificationListener<DbBackedOnChainConfig>,
    peers_and_metadata: Arc<PeersAndMetadata>,
) -> Runtime {
    let runtime = aptos_runtimes::spawn_named_runtime("shared-mem".into(), None);
    let mempool = Arc::new(Mutex::new(CoreMempool::new(config)));
```

**File:** mempool/src/core_mempool/transaction_store.rs (L104-111)
```rust
    pub(crate) fn new(config: &MempoolConfig) -> Self {
        let mut timeline_index = HashMap::new();
        for sender_bucket in 0..config.num_sender_buckets {
            timeline_index.insert(
                sender_bucket,
                MultiBucketTimelineIndex::new(config.broadcast_buckets.clone()).unwrap(),
            );
        }
```

**File:** mempool/src/core_mempool/index.rs (L405-429)
```rust
    pub(crate) fn new(bucket_mins: Vec<RankingScore>) -> anyhow::Result<Self> {
        anyhow::ensure!(!bucket_mins.is_empty(), "Must not be empty");
        anyhow::ensure!(bucket_mins[0] == 0, "First bucket must start at 0");

        let mut prev = None;
        let mut timelines = vec![];
        for entry in bucket_mins.clone() {
            if let Some(prev) = prev {
                anyhow::ensure!(prev < entry, "Values must be sorted and not repeat");
            }
            prev = Some(entry);
            timelines.push(TimelineIndex::new());
        }

        let bucket_mins_to_string: Vec<_> = bucket_mins
            .iter()
            .map(|bucket_min| bucket_min.to_string())
            .collect();

        Ok(Self {
            timelines,
            bucket_mins,
            bucket_mins_to_string,
        })
    }
```

**File:** config/src/config/mempool_config.rs (L176-184)
```rust
impl ConfigSanitizer for MempoolConfig {
    fn sanitize(
        _node_config: &NodeConfig,
        _node_type: NodeType,
        _chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        Ok(()) // TODO: add reasonable verifications
    }
}
```

**File:** config/src/config/config_sanitizer.rs (L62-62)
```rust
        MempoolConfig::sanitize(node_config, node_type, chain_id)?;
```
