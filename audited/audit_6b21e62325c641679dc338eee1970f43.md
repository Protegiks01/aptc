# Audit Report

## Title
Silent Token Indexing Failures Due to Missing ObjectCore Metadata in Token V2 Processing

## Summary
The `TokenDataV2::get_v2_from_write_resource()` function silently skips tokens when ObjectCore metadata is unavailable, returning `Ok(None)` without logging. This causes tokens to be excluded from the indexer database, resulting in incomplete data for applications querying the Aptos indexer API.

## Finding Description

The indexer processes blockchain transactions in batches to populate a queryable database. For Token V2, this involves a multi-pass approach: [1](#0-0) 

The first pass collects ObjectCore resources into a metadata helper map. The second pass populates additional resource data (Token, Collection, PropertyMap, etc.) but only for addresses that already exist in the map: [2](#0-1) 

When processing Token resources in subsequent passes, `TokenDataV2::get_v2_from_write_resource()` requires the ObjectCore to be present in the metadata helper: [3](#0-2) 

**The vulnerability occurs when:**
1. A transaction modifies only the Token resource at an address (e.g., updating metadata/URI)
2. The ObjectCore is not modified and thus not included in the transaction's write set
3. The indexer processes this transaction in isolation (new batch, metadata helper is empty)
4. `token_v2_metadata.get(&token_data_id)` returns `None` at line 90
5. The function returns `Ok(None)` at line 108 **without any logging**
6. The token is silently skipped - never added to the database

**Inconsistency with V1 code:** The V1 function logs warnings when unexpected conditions occur: [4](#0-3) 

But the V2 function has only a comment ("ObjectCore should not be missing") and no logging.

## Impact Explanation

**Severity: Medium** per Aptos bug bounty criteria ("State inconsistencies requiring intervention")

**Impact:**
- Tokens missing from indexer database lead to incomplete API query results
- NFT marketplaces cannot display affected tokens
- Wallets fail to show user holdings accurately  
- Analytics platforms report incorrect statistics
- Developers building on the indexer API receive incomplete data

**Scope:** 
- Does NOT affect blockchain consensus or execution (blockchain state remains correct)
- Affects all applications relying on the Aptos indexer API for Token V2 data
- Indexer operator must manually investigate and reindex to recover missing data
- No automated detection due to silent failures

## Likelihood Explanation

**Likelihood: Medium to High**

This occurs whenever:
- Token metadata updates happen without ObjectCore modifications
- Indexer processes transactions where Token and ObjectCore are in separate batches
- Token resources are accessed at addresses where ObjectCore wasn't recently modified

**Realistic scenarios:**
1. Token URI updates (only Token resource changes)
2. Description/name modifications (Token resource only)
3. Property updates via PropertyMap (separate resource)

The silent nature makes detection difficult - operators may not realize tokens are missing until users report discrepancies.

## Recommendation

**Add logging when ObjectCore is missing:**

```rust
} else {
    // ObjectCore should not be missing, returning from entire function early
    aptos_logger::warn!(
        transaction_version = txn_version,
        token_data_id = token_data_id,
        "ObjectCore missing for token - skipping indexing. Token may be from previous batch."
    );
    return Ok(None);
}
```

**Alternative improvements:**
1. Query the database for existing ObjectCore data when not in the current batch
2. Return an error instead of `Ok(None)` to make failures visible
3. Implement a two-phase commit: first verify all required metadata exists, then process

**Consistent with V1 pattern:** This aligns with how `get_v1_from_write_table_item()` logs warnings for unexpected conditions.

## Proof of Concept

**Scenario:** Token metadata update without ObjectCore modification

```rust
// Pseudo-code demonstrating the issue
// This would occur when processing a transaction batch

// Transaction 1: Create token (both ObjectCore and Token written)
// - ObjectCore written at address 0xABC
// - Token written at address 0xABC
// Result: Token indexed successfully

// === New batch processed (metadata_helper reset) ===

// Transaction 2: Update token URI (only Token resource written)
// - Token resource updated at address 0xABC
// - ObjectCore NOT in write set (unchanged)
// Result: 
//   1. First pass: No ObjectCore found, metadata_helper[0xABC] = None
//   2. Second pass: token_v2_metadata_helper.get_mut(0xABC) returns None, Token not added
//   3. Fourth pass: get_v2_from_write_resource() called
//      - TokenV2::from_write_resource() succeeds
//      - token_v2_metadata.get(0xABC) returns None
//      - Returns Ok(None) silently
//   4. Token update LOST - not in database
//   5. NO LOG ENTRY - silent failure
```

**To reproduce:**
1. Deploy a Token V2 contract with mutable metadata
2. Mint a token (transaction T1)
3. Wait for indexer to process T1
4. Update token URI (transaction T2, only modifies Token resource)
5. Observe indexer processing T2 in a new batch
6. Query indexer API - token will have stale URI
7. Check logs - no warning/error logged

## Notes

**Important Context:**
- This is an **indexer data quality issue**, not a consensus or execution layer vulnerability
- The blockchain state remains correct; only the indexer's view is incomplete
- Applications with critical dependencies on indexer data are affected
- The silent nature (no logging) makes debugging extremely difficult

**Comparison with V1:**
The V1 token processing path includes explicit logging for unexpected conditions, establishing a precedent that the V2 path should follow. The comment "ObjectCore should not be missing" indicates developer awareness but lacks implementation of proper error visibility.

### Citations

**File:** crates/indexer/src/processors/token_processor.rs (L1092-1115)
```rust
            // Need to do a first pass to get all the objects
            for wsc in user_txn.info.changes.iter() {
                if let WriteSetChange::WriteResource(wr) = wsc {
                    if let Some(object) =
                        ObjectWithMetadata::from_write_resource(wr, txn_version).unwrap()
                    {
                        token_v2_metadata_helper.insert(
                            standardize_address(&wr.address.to_string()),
                            TokenV2AggregatedData {
                                aptos_collection: None,
                                fixed_supply: None,
                                object,
                                unlimited_supply: None,
                                property_map: None,
                                transfer_event: None,
                                token: None,
                                fungible_asset_metadata: None,
                                fungible_asset_supply: None,
                                fungible_asset_store: None,
                            },
                        );
                    }
                }
            }
```

**File:** crates/indexer/src/processors/token_processor.rs (L1117-1145)
```rust
            // Need to do a second pass to get all the structs related to the object
            for wsc in user_txn.info.changes.iter() {
                if let WriteSetChange::WriteResource(wr) = wsc {
                    let address = standardize_address(&wr.address.to_string());
                    if let Some(aggregated_data) = token_v2_metadata_helper.get_mut(&address) {
                        if let Some(fixed_supply) =
                            FixedSupply::from_write_resource(wr, txn_version).unwrap()
                        {
                            aggregated_data.fixed_supply = Some(fixed_supply);
                        }
                        if let Some(unlimited_supply) =
                            UnlimitedSupply::from_write_resource(wr, txn_version).unwrap()
                        {
                            aggregated_data.unlimited_supply = Some(unlimited_supply);
                        }
                        if let Some(aptos_collection) =
                            AptosCollection::from_write_resource(wr, txn_version).unwrap()
                        {
                            aggregated_data.aptos_collection = Some(aptos_collection);
                        }
                        if let Some(property_map) =
                            PropertyMap::from_write_resource(wr, txn_version).unwrap()
                        {
                            aggregated_data.property_map = Some(property_map);
                        }
                        if let Some(token) = TokenV2::from_write_resource(wr, txn_version).unwrap()
                        {
                            aggregated_data.token = Some(token);
                        }
```

**File:** crates/indexer/src/models/token_models/v2_token_datas.rs (L83-109)
```rust
        if let Some(inner) = &TokenV2::from_write_resource(write_resource, txn_version)? {
            let token_data_id = standardize_address(&write_resource.address.to_string());
            // Get maximum, supply, and is fungible from fungible asset if this is a fungible token
            let (mut maximum, mut supply, mut decimals, mut is_fungible_v2) =
                (None, BigDecimal::zero(), 0, Some(false));
            // Get token properties from 0x4::property_map::PropertyMap
            let mut token_properties = serde_json::Value::Null;
            if let Some(metadata) = token_v2_metadata.get(&token_data_id) {
                let fungible_asset_metadata = metadata.fungible_asset_metadata.as_ref();
                let fungible_asset_supply = metadata.fungible_asset_supply.as_ref();
                if let Some(metadata) = fungible_asset_metadata {
                    if let Some(fa_supply) = fungible_asset_supply {
                        maximum = fa_supply.get_maximum();
                        supply = fa_supply.current.clone();
                        decimals = metadata.decimals as i64;
                        is_fungible_v2 = Some(true);
                    }
                }
                token_properties = metadata
                    .property_map
                    .as_ref()
                    .map(|m| m.inner.clone())
                    .unwrap_or(token_properties);
            } else {
                // ObjectCore should not be missing, returning from entire function early
                return Ok(None);
            }
```

**File:** crates/indexer/src/models/token_models/v2_token_datas.rs (L224-231)
```rust
            } else {
                aptos_logger::warn!(
                    transaction_version = txn_version,
                    key_type = table_item_data.key_type,
                    key = table_item_data.key,
                    "Expecting token_data_id as key for value = token_data"
                );
            }
```
