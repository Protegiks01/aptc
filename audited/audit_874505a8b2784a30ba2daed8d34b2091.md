# Audit Report

## Title
Panic-Induced Denial of Service in Indexer-GRPC Service Due to Zero-Valued output_batch_size Configuration

## Summary
The indexer-grpc fullnode service lacks validation for the `output_batch_size` configuration parameter. When misconfigured to 0, any client request to `GetTransactionsFromNode` triggers a panic via Rust's `.chunks(0)` method, causing the service to crash and become unavailable.

## Finding Description

The vulnerability exists in the transaction streaming logic where configuration values are read without validation: [1](#0-0) 

These values are passed directly to the `IndexerStreamCoordinator`: [2](#0-1) 

In the coordinator's `process_next_batch()` function, the `output_batch_size` is used to chunk processed transactions: [3](#0-2) [4](#0-3) 

When `output_batch_size` is 0, calling `.chunks(0)` on a Rust slice panics with "chunk size must be non-zero". This is standard Rust behavior and crashes the spawned tokio task, terminating the GRPC stream.

The configuration values originate from the node's YAML config without validation: [5](#0-4) [6](#0-5) 

The configuration struct defines these as u16 values with defaults, but provides no validation in the sanitizer: [7](#0-6) [8](#0-7) 

The sanitizer only checks if the storage indexer is enabled, but performs no range validation on batch sizes.

**Attack Path:**
1. Node operator misconfigures `indexer_grpc.output_batch_size: 0` in the YAML config
2. Node starts successfully (no config validation catches the error)
3. Any client sends a `GetTransactionsFromNodeRequest` to the indexer-grpc service
4. Service reads the zero-valued config and spawns processing task
5. When chunking transactions, `.chunks(0)` panics
6. The tokio task crashes, GRPC stream terminates abnormally
7. Service becomes unavailable for indexing requests

The same vulnerability affects the LocalnetDataService which uses identical code paths: [9](#0-8) 

## Impact Explanation

This qualifies as **High Severity** under the Aptos bug bounty program's "API crashes" category. While the indexer-grpc service is not part of core consensus and does not affect validator operations or fund safety, it provides critical data access infrastructure for applications and block explorers.

The impact includes:
- Complete denial of service for the indexer-grpc API
- Any client request triggers the panic
- Service requires restart and config fix to restore functionality
- Applications dependent on indexed data cannot operate
- No recovery mechanism without configuration change

This does NOT affect:
- Core consensus operations
- Validator functionality
- On-chain fund safety
- State commitment or execution

## Likelihood Explanation

**Likelihood: Low-Medium**

The vulnerability requires operator misconfiguration, making it less likely than code-based bugs. However:

**Factors increasing likelihood:**
- No validation catches the error at startup
- Config files may be edited manually or generated by automation
- Default values are non-zero (1000, 100), but overrides have no guards
- Error manifests only when clients make requests, not at startup
- Similar patterns affect multiple services (FullnodeDataService, LocalnetDataService)

**Factors decreasing likelihood:**
- Requires operator to explicitly set value to 0 (unlikely accident)
- Most operators use default values
- Issue is immediately apparent after first request

## Recommendation

Add validation in the `IndexerGrpcConfig::sanitize()` method to reject zero-valued batch sizes:

```rust
impl ConfigSanitizer for IndexerGrpcConfig {
    fn sanitize(
        node_config: &NodeConfig,
        _node_type: NodeType,
        _chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();

        if !node_config.indexer_grpc.enabled {
            return Ok(());
        }

        // Existing validation...
        if !node_config.storage.enable_indexer
            && !node_config
                .indexer_table_info
                .table_info_service_mode
                .is_enabled()
        {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "storage.enable_indexer must be true...".to_string(),
            ));
        }

        // NEW: Validate batch sizes are non-zero
        if node_config.indexer_grpc.processor_batch_size == 0 {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "processor_batch_size must be greater than 0".to_string(),
            ));
        }

        if node_config.indexer_grpc.output_batch_size == 0 {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "output_batch_size must be greater than 0".to_string(),
            ));
        }

        Ok(())
    }
}
```

Additionally, add runtime validation in `IndexerStreamCoordinator::new()` as defense-in-depth:

```rust
pub fn new(
    context: Arc<Context>,
    request_start_version: u64,
    end_version: u64,
    processor_task_count: u16,
    processor_batch_size: u16,
    output_batch_size: u16,
    transactions_sender: mpsc::Sender<Result<TransactionsFromNodeResponse, tonic::Status>>,
    filter: Option<BooleanTransactionFilter>,
    abort_handle: Option<Arc<AtomicBool>>,
) -> Self {
    assert!(processor_batch_size > 0, "processor_batch_size must be non-zero");
    assert!(output_batch_size > 0, "output_batch_size must be non-zero");
    
    Self {
        current_version: request_start_version,
        end_version,
        processor_task_count,
        processor_batch_size,
        output_batch_size,
        highest_known_version: 0,
        context,
        transactions_sender,
        filter,
        abort_handle,
    }
}
```

## Proof of Concept

Create a test file demonstrating the panic:

```rust
#[cfg(test)]
mod test_config_validation {
    use super::*;
    use aptos_config::config::{IndexerGrpcConfig, NodeConfig};
    
    #[test]
    #[should_panic(expected = "chunk size must be non-zero")]
    fn test_zero_output_batch_size_panics() {
        // Create config with zero output_batch_size
        let mut node_config = NodeConfig::default();
        node_config.indexer_grpc.enabled = true;
        node_config.indexer_grpc.output_batch_size = 0;
        
        // This configuration would pass validation (incorrectly)
        // and cause a panic when processing transactions
        let vec = vec![1, 2, 3, 4, 5];
        let zero_batch_size = 0_usize;
        
        // Simulate the code path that panics
        for _chunk in vec.chunks(zero_batch_size) {
            // This never executes - panics on chunks() call
        }
    }
    
    #[test]
    fn test_config_sanitizer_should_reject_zero_batch_sizes() {
        use aptos_config::config::{ConfigSanitizer, NodeType};
        use aptos_types::chain_id::ChainId;
        
        let mut node_config = NodeConfig::default();
        node_config.indexer_grpc.enabled = true;
        node_config.storage.enable_indexer = true;
        node_config.indexer_grpc.output_batch_size = 0;
        
        // After fix, this should return an error
        let result = IndexerGrpcConfig::sanitize(
            &node_config,
            NodeType::Validator,
            Some(ChainId::mainnet()),
        );
        
        // Currently passes (bug), should fail after fix
        assert!(result.is_err(), "Config sanitizer should reject zero output_batch_size");
    }
}
```

To reproduce manually:
1. Edit node config YAML to set `indexer_grpc.output_batch_size: 0`
2. Start the indexer-grpc fullnode
3. Send any `GetTransactionsFromNodeRequest` via GRPC client
4. Observe panic in logs: "chunk size must be non-zero"
5. Service becomes unavailable

## Notes

- The vulnerability also affects `processor_batch_size` set to 0, though this creates inefficient behavior rather than a panic (creates batches requesting 0 transactions)
- Setting `processor_task_count` to 0 causes empty results but no panic
- The default values prevent this issue in standard deployments
- This is specific to the indexer-grpc auxiliary service and does not impact core blockchain consensus or validator operations

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/fullnode_data_service.rs (L79-81)
```rust
        let processor_task_count = self.service_context.processor_task_count;
        let processor_batch_size = self.service_context.processor_batch_size;
        let output_batch_size = self.service_context.output_batch_size;
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/fullnode_data_service.rs (L103-117)
```rust
            let mut coordinator = IndexerStreamCoordinator::new(
                context,
                starting_version,
                ending_version,
                processor_task_count,
                processor_batch_size,
                output_batch_size,
                tx.clone(),
                // For now the request for this interface doesn't include a txn filter
                // because it is only used for the txn stream filestore worker, which
                // needs every transaction. Later we may add support for txn filtering
                // to this interface too.
                None,
                Some(abort_handle.clone()),
            );
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/stream_coordinator.rs (L163-163)
```rust
        let output_batch_size = self.output_batch_size;
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/stream_coordinator.rs (L185-185)
```rust
                for chunk in pb_txns.chunks(output_batch_size as usize) {
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/runtime.rs (L54-59)
```rust
    let processor_task_count = node_config
        .indexer_grpc
        .processor_task_count
        .unwrap_or_else(|| get_default_processor_task_count(use_data_service_interface));
    let processor_batch_size = node_config.indexer_grpc.processor_batch_size;
    let output_batch_size = node_config.indexer_grpc.output_batch_size;
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/runtime.rs (L72-79)
```rust
        let service_context = ServiceContext {
            context: context.clone(),
            processor_task_count,
            processor_batch_size,
            output_batch_size,
            transaction_channel_size,
            max_transaction_filter_size_bytes,
        };
```

**File:** config/src/config/indexer_grpc_config.rs (L48-52)
```rust
    /// Number of transactions each processor will process
    pub processor_batch_size: u16,

    /// Number of transactions returned in a single stream response
    pub output_batch_size: u16,
```

**File:** config/src/config/indexer_grpc_config.rs (L103-127)
```rust
impl ConfigSanitizer for IndexerGrpcConfig {
    fn sanitize(
        node_config: &NodeConfig,
        _node_type: NodeType,
        _chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();

        if !node_config.indexer_grpc.enabled {
            return Ok(());
        }

        if !node_config.storage.enable_indexer
            && !node_config
                .indexer_table_info
                .table_info_service_mode
                .is_enabled()
        {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "storage.enable_indexer must be true or indexer_table_info.table_info_service_mode must be IndexingOnly if indexer_grpc.enabled is true".to_string(),
            ));
        }
        Ok(())
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/localnet_data_service.rs (L56-89)
```rust
        let processor_task_count = self.service_context.processor_task_count;
        let processor_batch_size = self.service_context.processor_batch_size;
        let output_batch_size = self.service_context.output_batch_size;
        let transaction_channel_size = self.service_context.transaction_channel_size;
        let ledger_chain_id = context.chain_id().id();
        let transactions_count = r.transactions_count;

        // Parse transaction filter if present.
        let filter = if let Some(proto_filter) = r.transaction_filter {
            Some(parse_transaction_filter(
                proto_filter,
                self.service_context.max_transaction_filter_size_bytes,
            )?)
        } else {
            None
        };

        // Creates a channel to send the stream to the client.
        let (tx, mut rx) = mpsc::channel(transaction_channel_size);
        let (external_service_tx, external_service_rx) = mpsc::channel(transaction_channel_size);

        tokio::spawn(async move {
            // Initialize the coordinator that tracks starting version and processes transactions.
            let mut coordinator = IndexerStreamCoordinator::new(
                context,
                starting_version,
                ending_version,
                processor_task_count,
                processor_batch_size,
                output_batch_size,
                tx.clone(),
                filter,
                None,
            );
```
