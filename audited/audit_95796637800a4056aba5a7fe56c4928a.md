# Audit Report

## Title
Missing Input Validation in MempoolConfig Allows Mempool DoS via Configuration Injection

## Summary
The `MempoolConfig::sanitize()` function in `config/src/config/mempool_config.rs` contains no validation logic for the `max_broadcasts_per_peer` parameter, allowing dangerous values (0 or excessively large values) to be injected via configuration files. This enables a complete denial-of-service of mempool transaction broadcasting or memory exhaustion attacks. [1](#0-0) 

## Finding Description

The `MempoolConfig` struct defines critical mempool parameters, including `max_broadcasts_per_peer` which controls rate-limiting of transaction broadcasts to peers. [2](#0-1) 

When `MempoolNetworkInterface::new()` is called, it accepts a `MempoolConfig` without performing any validation on the parameters. [3](#0-2) 

The config sanitization framework calls `MempoolConfig::sanitize()` during node startup, but this function is completely empty with only a TODO comment, performing no validation whatsoever. [1](#0-0) 

The `max_broadcasts_per_peer` value is used in critical rate-limiting logic in `determine_broadcast_batch()`: [4](#0-3) 

**Attack Vector 1: Setting max_broadcasts_per_peer = 0**

When `max_broadcasts_per_peer` is set to 0:
1. The first broadcast succeeds (no pending broadcasts yet)
2. On subsequent broadcasts, the check `pending_broadcasts >= 0` immediately triggers after counting the first pending message
3. All broadcasts fail with `TooManyPendingBroadcasts` error
4. Transactions can only propagate at the ACK timeout rate (default 2000ms) instead of tick interval rate (default 10ms)
5. This creates a **200x slowdown** in transaction propagation

**Attack Vector 2: Setting max_broadcasts_per_peer = usize::MAX**

When set to an extremely large value:
1. Rate limiting is effectively disabled
2. If peers stop ACKing (network issues, malicious peers), the `sent_messages` BTreeMap grows unbounded [5](#0-4) 
3. New entries are added every tick interval (10ms by default) [6](#0-5) 
4. Memory grows at ~100 entries/second per non-responding peer
5. Leads to memory exhaustion and node crash

The cleanup mechanism only removes committed transactions, not expired ones from the map. [7](#0-6) 

## Impact Explanation

This qualifies as **High Severity** per Aptos bug bounty criteria:
- **Validator node slowdowns**: Setting `max_broadcasts_per_peer=0` causes a 200x degradation in transaction propagation rate
- **Node crashes**: Setting excessively high values can cause memory exhaustion leading to validator crashes
- **Network-wide impact**: If multiple validators are misconfigured, the entire network's transaction throughput is severely degraded

While the config is typically controlled by node operators, this represents a critical defense-in-depth failure:
1. Configuration injection attacks are a recognized attack vector
2. No validation on security-critical parameters violates secure coding practices
3. The explicit TODO comment indicates this was recognized but not addressed
4. Other config parameters have extensive validation; this omission is inconsistent

## Likelihood Explanation

**Medium-High Likelihood:**
- Configuration files are loaded from YAML with deserialization [8](#0-7) 
- Node operators may make mistakes or be subject to social engineering
- Automated deployment scripts could propagate misconfigurations
- Compromised deployment infrastructure could inject malicious configs
- The parameter is of type `usize`, accepting any value from 0 to MAX without bounds checking

## Recommendation

Implement proper validation in `MempoolConfig::sanitize()`:

```rust
impl ConfigSanitizer for MempoolConfig {
    fn sanitize(
        node_config: &NodeConfig,
        _node_type: NodeType,
        _chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let mempool_config = &node_config.mempool;
        let sanitizer_name = Self::get_sanitizer_name();
        
        // Validate max_broadcasts_per_peer is within reasonable bounds
        if mempool_config.max_broadcasts_per_peer == 0 {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "max_broadcasts_per_peer cannot be 0 - this would prevent all broadcasts".into(),
            ));
        }
        
        if mempool_config.max_broadcasts_per_peer > 1000 {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                format!(
                    "max_broadcasts_per_peer ({}) exceeds safe maximum of 1000",
                    mempool_config.max_broadcasts_per_peer
                ),
            ));
        }
        
        // Add other validations as needed
        Ok(())
    }
}
```

## Proof of Concept

Create a malicious config file `malicious_mempool.yaml`:
```yaml
mempool:
  max_broadcasts_per_peer: 0
```

Load and test:
```rust
#[test]
fn test_mempool_config_zero_broadcasts_dos() {
    use aptos_config::config::{NodeConfig, MempoolConfig};
    use std::path::Path;
    
    // Load config with max_broadcasts_per_peer = 0
    let mut node_config = NodeConfig::default();
    node_config.mempool.max_broadcasts_per_peer = 0;
    
    // Sanitize should fail but currently doesn't
    let result = MempoolConfig::sanitize(&node_config, NodeType::Validator, Some(ChainId::test()));
    assert!(result.is_ok()); // BUG: This passes when it should fail!
    
    // Create mempool network interface
    let (network_client, _) = create_network_client_and_events();
    let network_interface = MempoolNetworkInterface::new(
        network_client,
        NodeType::Validator,
        node_config.mempool.clone(),
    );
    
    // First broadcast succeeds, but subsequent ones will fail immediately
    // Demonstrating the DoS condition
}

#[test]  
fn test_mempool_config_unbounded_memory() {
    let mut node_config = NodeConfig::default();
    node_config.mempool.max_broadcasts_per_peer = usize::MAX;
    
    // No validation prevents this dangerous configuration
    let result = MempoolConfig::sanitize(&node_config, NodeType::Validator, Some(ChainId::test()));
    assert!(result.is_ok()); // BUG: Allows unlimited memory growth
}
```

## Notes

This vulnerability demonstrates a critical gap in the defense-in-depth strategy. While node operators are generally trusted, configuration validation is a fundamental security control that prevents:
- Human error and misconfigurations
- Supply chain attacks on deployment tooling
- Compromised configuration management systems
- Social engineering attacks targeting operators

The fact that other configuration parameters receive extensive validation (as seen throughout the sanitizer implementations) makes this omission particularly concerning. The TODO comment at line 182 indicates this was a known gap that was never addressed.

### Citations

**File:** config/src/config/mempool_config.rs (L13-14)
```rust
#[derive(Clone, Debug, Deserialize, PartialEq, Eq, Serialize)]
#[serde(default, deny_unknown_fields)]
```

**File:** config/src/config/mempool_config.rs (L52-53)
```rust
    /// The maximum number of broadcasts sent to a single peer that are pending a response ACK at any point.
    pub max_broadcasts_per_peer: usize,
```

**File:** config/src/config/mempool_config.rs (L176-184)
```rust
impl ConfigSanitizer for MempoolConfig {
    fn sanitize(
        _node_config: &NodeConfig,
        _node_type: NodeType,
        _chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        Ok(()) // TODO: add reasonable verifications
    }
}
```

**File:** mempool/src/shared_mempool/network.rs (L133-149)
```rust
    pub(crate) fn new(
        network_client: NetworkClient,
        node_type: NodeType,
        mempool_config: MempoolConfig,
    ) -> MempoolNetworkInterface<NetworkClient> {
        let prioritized_peers_state =
            PrioritizedPeersState::new(mempool_config.clone(), node_type, TimeService::real());
        Self {
            network_client,
            sync_states: Arc::new(RwLock::new(HashMap::new())),
            node_type,
            mempool_config,
            prioritized_peers_state,
            num_mempool_txns_received_since_peers_updated: 0,
            num_committed_txns_received_since_peers_updated: Arc::new(AtomicU64::new(0)),
        }
    }
```

**File:** mempool/src/shared_mempool/network.rs (L396-410)
```rust
        // Sync peer's pending broadcasts with latest mempool state.
        // A pending or retry broadcast might become empty if the corresponding txns were committed through
        // another peer, so don't track broadcasts for committed txns.
        let mempool = smp.mempool.lock();
        state.broadcast_info.sent_messages = state
            .broadcast_info
            .sent_messages
            .clone()
            .into_iter()
            .filter(|(message_id, _batch)| {
                !mempool
                    .timeline_range_of_message(message_id.decode())
                    .is_empty()
            })
            .collect::<BTreeMap<MempoolMessageId, SystemTime>>();
```

**File:** mempool/src/shared_mempool/network.rs (L441-448)
```rust
            // The maximum number of broadcasts sent to a single peer that are pending a response ACK at any point.
            // If the number of un-ACK'ed un-expired broadcasts reaches this threshold, we do not broadcast anymore
            // and wait until an ACK is received or a sent broadcast expires.
            // This helps rate-limit egress network bandwidth and not overload a remote peer or this
            // node's network sender.
            if pending_broadcasts >= self.mempool_config.max_broadcasts_per_peer {
                return Err(BroadcastError::TooManyPendingBroadcasts(peer));
            }
```

**File:** mempool/src/shared_mempool/network.rs (L629-633)
```rust
        state
            .broadcast_info
            .sent_messages
            .insert(message_id, send_time);
        Ok(state.broadcast_info.sent_messages.len())
```

**File:** mempool/src/shared_mempool/types.rs (L457-464)
```rust
pub struct BroadcastInfo {
    // Sent broadcasts that have not yet received an ack.
    pub sent_messages: BTreeMap<MempoolMessageId, SystemTime>,
    // Broadcasts that have received a retry ack and are pending a resend.
    pub retry_messages: BTreeSet<MempoolMessageId>,
    // Whether broadcasting to this peer is in backoff mode, e.g. broadcasting at longer intervals.
    pub backoff_mode: bool,
}
```
