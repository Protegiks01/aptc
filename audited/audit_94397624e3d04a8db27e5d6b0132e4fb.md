# Audit Report

## Title
Consensus Divergence via Non-Synchronized Transaction Filter Configuration Across Validators

## Summary
Different validators can have different `BlockTransactionFilterConfig` settings loaded from their local configuration files, causing them to filter different transactions from the same block during execution. This breaks the fundamental consensus invariant that all validators must produce identical state roots for identical blocks, leading to consensus divergence and liveness failures.

## Finding Description

The Aptos consensus system allows validators to apply transaction filters during block execution through two mechanisms:

1. **Consensus-level filtering** - Validates inline transactions during proposal acceptance
2. **Execution-level filtering** - Filters transactions before execution in the block preparation pipeline

Both filters are loaded from each validator's local `node_config.transaction_filters` configuration, which is not synchronized across the validator set. [1](#0-0) 

The execution filter is used in the `ExecutionProxy` initialization: [2](#0-1) 

During block execution, all validators run the `prepare_block` function which applies the filter: [3](#0-2) 

The filtering logic in `filter_block_transactions` checks if filtering is enabled and applies the configured rules: [4](#0-3) 

The `allows_transaction` function iterates through rules and matches transactions against filter criteria: [5](#0-4) 

**Attack Scenario:**

1. Validator A configures `execution_filter` to deny transactions from address `0xABCD`
2. Validator B has no execution filter configured (default empty filter)
3. Block proposer creates Block N containing a transaction from address `0xABCD`
4. All validators receive Block N and begin execution:
   - Validator A's `prepare_block` filters out the transaction from `0xABCD`
   - Validator B's `prepare_block` includes the transaction from `0xABCD`
5. Execution proceeds with different transaction sets:
   - Validator A executes Block N without the filtered transaction
   - Validator B executes Block N with the filtered transaction
6. Result: Different state roots, preventing quorum formation on the ledger info

**Which Invariant is Broken:**

This violates **Critical Invariant #1: Deterministic Execution** - "All validators must produce identical state roots for identical blocks."

The block ID is the same, but validators execute different transaction subsets, producing different state roots and breaking consensus determinism.

## Impact Explanation

**Severity: CRITICAL**

This vulnerability meets the Critical severity criteria for the following reasons:

1. **Consensus/Safety Violation**: Different validators cannot agree on the state root for the same block, preventing quorum certificate formation and breaking the AptosBFT safety guarantee.

2. **Network Partition/Liveness Failure**: The network cannot make progress when validators disagree on execution results. Blocks cannot be certified, and the chain halts until all validators align their filter configurations.

3. **Non-recoverable Without Intervention**: Unlike transient network issues, this requires manual intervention to detect the configuration mismatch and coordinate filter updates across all validators.

4. **Affects All Validators**: Every validator with a divergent filter configuration will produce different results, potentially fragmenting the validator set into multiple incompatible groups.

This directly matches the bug bounty's Critical category: "Consensus/Safety violations" and "Non-recoverable network partition (requires hardfork)".

## Likelihood Explanation

**Likelihood: HIGH**

This vulnerability is highly likely to occur because:

1. **No Enforcement Mechanism**: The codebase has no validation that all validators use identical filter configurations. Each validator independently loads filters from local config files.

2. **Operational Complexity**: In a distributed validator set, maintaining identical configurations across all nodes is challenging. Human error during configuration updates is common.

3. **Silent Failure Mode**: Validators with different filters will silently produce different execution results without explicit warnings that configuration divergence is the cause.

4. **Already Deployed Feature**: Transaction filters are an active feature with configuration options exposed in the node config, making misconfiguration a real operational risk.

5. **No Documentation Warning**: The configuration documentation doesn't warn operators that filters must be identical across all validators to maintain consensus.

The only barrier to exploitation is that it requires validators to have different configurations, which can occur naturally through:
- Gradual rollout of configuration changes
- Different validator operators using different default configs
- Intentional filtering by some validators for compliance reasons
- Configuration management errors in multi-validator deployments

## Recommendation

**Short-term Fix:**

1. **Add Configuration Validation**: Implement a startup check that validates filter configurations match across the validator set, or disable execution filtering entirely for consensus validators.

2. **Move Filters to On-Chain Config**: Make `BlockTransactionFilterConfig` part of the on-chain consensus configuration (`OnChainConsensusConfig`) so all validators automatically use identical filters.

3. **Documentation Update**: Clearly document that transaction filters, if used, MUST be identical across all validators to prevent consensus divergence.

**Long-term Fix:**

Restructure the filtering architecture to separate concerns:
- **Mempool-only filtering**: Apply filters only at transaction submission/mempool level
- **Proposer-only filtering**: Only the block proposer applies filters when creating proposals
- **Execution uses exact payload**: All validators execute exactly the transactions specified in the block payload without re-filtering

**Code Example (Conceptual Fix):**

```rust
// In block_preparer.rs - filter_block_transactions
fn filter_block_transactions(
    txn_filter_config: Arc<BlockTransactionFilterConfig>,
    block_id: HashValue,
    block_author: Option<AccountAddress>,
    block_epoch: u64,
    block_timestamp_usecs: u64,
    txns: Vec<SignedTransaction>,
) -> Vec<SignedTransaction> {
    // CRITICAL FIX: Disable execution-time filtering for consensus
    // Filtering should only occur at mempool/proposal time
    warn!("Execution-time transaction filtering is disabled to ensure consensus determinism");
    return txns; // Return all transactions without filtering
}
```

Or add validation:

```rust
// In epoch_manager.rs - validate filter config matches on-chain config
fn validate_filter_config(&self, local_filter: &BlockTransactionFilterConfig) -> Result<()> {
    let onchain_filter = self.get_onchain_filter_config()?;
    ensure!(
        local_filter == onchain_filter,
        "Local transaction filter config does not match on-chain config. \
         This will cause consensus divergence. Local: {:?}, OnChain: {:?}",
        local_filter,
        onchain_filter
    );
    Ok(())
}
```

## Proof of Concept

**Reproduction Steps:**

1. Set up a testnet with 4 validators (V1, V2, V3, V4)

2. Configure V1 and V2 with a transaction filter that denies transactions from address `0xDEADBEEF`:
```yaml
transaction_filters:
  execution_filter:
    filter_enabled: true
    block_transaction_filter:
      block_transaction_rules:
        - Deny:
          - Transaction:
              Sender: "0xDEADBEEF"
```

3. Configure V3 and V4 with no filter (default empty):
```yaml
transaction_filters:
  execution_filter:
    filter_enabled: false
```

4. Submit a transaction from account `0xDEADBEEF` to the mempool

5. When a proposer creates a block containing this transaction:
   - V1 and V2 will filter it out during `prepare_block` (line 91-98 in block_preparer.rs)
   - V3 and V4 will include it in execution
   - V1/V2 compute state root R1 (without the transaction)
   - V3/V4 compute state root R2 (with the transaction)
   - R1 â‰  R2

6. Result: Cannot form a quorum certificate (requires 3/4 validators to agree on the same ledger info with matching state root)

7. Chain halts, unable to progress until filter configurations are synchronized

**Evidence in Code:**

The vulnerability exists because:
- Filter config is local: [6](#0-5) 
- Filtering happens during execution: [7](#0-6) 
- No validation of filter consistency: No code exists to check that all validators have the same filter configuration

**Notes**

This vulnerability is particularly insidious because:

1. The matching logic itself is deterministic - given the same filter configuration and same inputs, `allows_transaction()` always produces the same result
2. The non-determinism arises from validators having different filter configurations, not from bugs in the matching logic
3. The issue affects both the `consensus_filter` (used for proposal validation) and `execution_filter` (used during block execution), though the execution filter divergence is more severe
4. This is an architectural issue where a local configuration parameter affects consensus-critical execution paths

The fundamental problem is that transaction filtering during execution violates the consensus model where all validators must execute identical operations on identical inputs to produce identical outputs.

### Citations

**File:** config/src/config/node_config.rs (L87-87)
```rust
    pub transaction_filters: TransactionFiltersConfig,
```

**File:** consensus/src/consensus_provider.rs (L65-72)
```rust
    let execution_proxy = ExecutionProxy::new(
        Arc::new(BlockExecutor::<AptosVMBlockExecutor>::new(aptos_db)),
        txn_notifier,
        state_sync_notifier,
        node_config.transaction_filters.execution_filter.clone(),
        node_config.consensus.enable_pre_commit,
        None,
    );
```

**File:** consensus/src/block_preparer.rs (L71-119)
```rust
    pub async fn prepare_block(
        &self,
        block: &Block,
        txns: Vec<SignedTransaction>,
        max_txns_from_block_to_execute: Option<u64>,
        block_gas_limit: Option<u64>,
    ) -> (Vec<SignedTransaction>, Option<u64>) {
        let start_time = Instant::now();

        let txn_filter_config = self.txn_filter_config.clone();
        let txn_deduper = self.txn_deduper.clone();
        let txn_shuffler = self.txn_shuffler.clone();

        let block_id = block.id();
        let block_author = block.author();
        let block_epoch = block.epoch();
        let block_timestamp_usecs = block.timestamp_usecs();

        // Transaction filtering, deduplication and shuffling are CPU intensive tasks, so we run them in a blocking task.
        let result = tokio::task::spawn_blocking(move || {
            let filtered_txns = filter_block_transactions(
                txn_filter_config,
                block_id,
                block_author,
                block_epoch,
                block_timestamp_usecs,
                txns,
            );
            let deduped_txns = txn_deduper.dedup(filtered_txns);
            let mut shuffled_txns = {
                let _timer = TXN_SHUFFLE_SECONDS.start_timer();

                txn_shuffler.shuffle(deduped_txns)
            };

            if let Some(max_txns_from_block_to_execute) = max_txns_from_block_to_execute {
                shuffled_txns.truncate(max_txns_from_block_to_execute as usize);
            }
            TXNS_IN_BLOCK
                .with_label_values(&["after_filter"])
                .observe(shuffled_txns.len() as f64);
            MAX_TXNS_FROM_BLOCK_TO_EXECUTE.observe(shuffled_txns.len() as f64);
            shuffled_txns
        })
        .await
        .expect("Failed to spawn blocking task for transaction generation");
        counters::BLOCK_PREPARER_LATENCY.observe_duration(start_time.elapsed());
        (result, block_gas_limit)
    }
```

**File:** consensus/src/block_preparer.rs (L122-146)
```rust
/// Filters transactions in a block based on the filter configuration
fn filter_block_transactions(
    txn_filter_config: Arc<BlockTransactionFilterConfig>,
    block_id: HashValue,
    block_author: Option<AccountAddress>,
    block_epoch: u64,
    block_timestamp_usecs: u64,
    txns: Vec<SignedTransaction>,
) -> Vec<SignedTransaction> {
    // If the transaction filter is disabled, return early
    if !txn_filter_config.is_enabled() {
        return txns;
    }

    // Otherwise, filter the transactions
    txn_filter_config
        .block_transaction_filter()
        .filter_block_transactions(
            block_id,
            block_author,
            block_epoch,
            block_timestamp_usecs,
            txns,
        )
}
```

**File:** crates/aptos-transaction-filters/src/block_transaction_filter.rs (L28-59)
```rust
    /// Returns true iff the filter allows the transaction in the block
    pub fn allows_transaction(
        &self,
        block_id: HashValue,
        block_author: Option<AccountAddress>,
        block_epoch: u64,
        block_timestamp: u64,
        signed_transaction: &SignedTransaction,
    ) -> bool {
        // If the filter is empty, allow the transaction by default
        if self.is_empty() {
            return true;
        }

        // Check if any rule matches the block transaction
        for block_transaction_rule in &self.block_transaction_rules {
            if block_transaction_rule.matches(
                block_id,
                block_author,
                block_epoch,
                block_timestamp,
                signed_transaction,
            ) {
                return match block_transaction_rule {
                    BlockTransactionRule::Allow(_) => true,
                    BlockTransactionRule::Deny(_) => false,
                };
            }
        }

        true // No rules match (allow the block transaction by default)
    }
```

**File:** config/src/config/transaction_filters_config.rs (L90-123)
```rust
#[derive(Clone, Debug, Deserialize, PartialEq, Eq, Serialize)]
#[serde(default, deny_unknown_fields)]
pub struct BlockTransactionFilterConfig {
    filter_enabled: bool, // Whether the filter is enabled
    block_transaction_filter: BlockTransactionFilter, // The block transaction filter to apply
}

impl BlockTransactionFilterConfig {
    pub fn new(filter_enabled: bool, block_transaction_filter: BlockTransactionFilter) -> Self {
        Self {
            filter_enabled,
            block_transaction_filter,
        }
    }

    /// Returns true iff the filter is enabled and not empty
    pub fn is_enabled(&self) -> bool {
        self.filter_enabled && !self.block_transaction_filter.is_empty()
    }

    /// Returns a reference to the block transaction filter
    pub fn block_transaction_filter(&self) -> &BlockTransactionFilter {
        &self.block_transaction_filter
    }
}

impl Default for BlockTransactionFilterConfig {
    fn default() -> Self {
        Self {
            filter_enabled: false,                                     // Disable the filter
            block_transaction_filter: BlockTransactionFilter::empty(), // Use an empty filter
        }
    }
}
```
