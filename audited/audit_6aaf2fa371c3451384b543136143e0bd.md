# Audit Report

## Title
Missing Validation in Runtime Staking Configuration Updates Enables Premature Stake Unlock via Governance Manipulation

## Summary
The staking configuration update functions in the Aptos framework allow governance to independently modify `recurring_lockup_duration_secs` and `epoch_interval_microsecs` without cross-validation, enabling a scenario where validators can unlock and withdraw their stake significantly faster than intended when `recurring_lockup_duration_secs < epoch_duration_secs`.

## Finding Description

While genesis initialization properly validates that `recurring_lockup_duration_secs >= epoch_duration_secs` [1](#0-0) , this invariant can be violated post-genesis through governance proposals.

The staking system relies on a critical relationship between epoch duration and recurring lockup duration. At each epoch transition, active validators have their lockup automatically renewed [2](#0-1) . However, validators who leave the active set do NOT have their lockup renewed.

**Vulnerability Path:**

1. The `staking_config::update_recurring_lockup_duration_secs()` function only validates that the new value is greater than zero, with no validation against epoch duration [3](#0-2) .

2. The `block::update_epoch_interval_microsecs()` function similarly lacks validation against recurring lockup duration [4](#0-3) .

3. When a validator becomes inactive, the withdrawal check allows moving `pending_inactive` to `inactive` if the current time exceeds `locked_until_secs` [5](#0-4) .

**Exploitation Scenario:**

If governance updates `recurring_lockup_duration_secs` to 3600 seconds (1 hour) while `epoch_duration_secs` remains 7200 seconds (2 hours):

- At epoch N (T=0): Validator lockup renewed to `locked_until_secs = T + 3600`
- At T=3600: Lockup expires while still mid-epoch
- Validator calls `leave_validator_set()` between T=3600 and T=7200
- At epoch N+1 (T=7200): Validator becomes fully inactive, lockup is NOT renewed
- Since T=7200 > locked_until_secs=3600, validator can immediately `withdraw()`

This violates the security invariant that validator stake should remain locked for the recurring lockup period to ensure economic security and prevent rapid validator set destabilization.

## Impact Explanation

**Medium Severity** - This qualifies as "State inconsistencies requiring intervention" per the Aptos bug bounty criteria. While it doesn't directly result in fund theft or consensus violations, it:

- Undermines the economic security model of the staking system
- Allows validators to exit faster than designed, potentially destabilizing the validator set
- Breaks the documented lockup security guarantees that other protocol mechanisms rely upon
- Could be exploited systematically if governance inadvertently creates this condition

The impact is limited to Medium (not High) because:
- Requires governance approval to create the vulnerable state
- Does not affect active validators (only those choosing to exit)
- Network consensus remains functional throughout
- Reversible through subsequent governance action

## Likelihood Explanation

**Medium Likelihood** - While exploitation requires governance action, this could realistically occur through:

1. **Legitimate configuration changes with unintended consequences**: Governance might update epoch duration for performance reasons without realizing it breaks the lockup invariant
2. **Coordinated governance manipulation**: A coalition holding sufficient voting power could deliberately create this condition
3. **Sequential proposals**: Two separate proposals updating each parameter independently, neither appearing suspicious in isolation

The lack of validation means this vulnerability is latent and waiting to be triggered whenever governance modifies these parameters without manually checking the invariant.

## Recommendation

Add cross-validation in both update functions to enforce the invariant that `recurring_lockup_duration_secs` must be greater than or equal to `epoch_duration_secs` (converted to seconds).

**Fix for `staking_config.move`:** [3](#0-2) 

Add validation to read the current epoch interval from `block::BlockResource` and ensure the new lockup duration is not less than the epoch duration in seconds:

```move
public fun update_recurring_lockup_duration_secs(
    aptos_framework: &signer,
    new_recurring_lockup_duration_secs: u64,
) acquires StakingConfig {
    assert!(new_recurring_lockup_duration_secs > 0, error::invalid_argument(EZERO_LOCKUP_DURATION));
    
    // NEW: Validate against epoch duration
    let epoch_interval_microsecs = block::get_epoch_interval_microsecs();
    let epoch_duration_secs = epoch_interval_microsecs / 1000000;
    assert!(
        new_recurring_lockup_duration_secs >= epoch_duration_secs,
        error::invalid_argument(EINVALID_LOCKUP_DURATION)
    );
    
    system_addresses::assert_aptos_framework(aptos_framework);
    let staking_config = borrow_global_mut<StakingConfig>(@aptos_framework);
    staking_config.recurring_lockup_duration_secs = new_recurring_lockup_duration_secs;
}
```

**Fix for `block.move`:** [4](#0-3) 

Add validation to read the current recurring lockup duration and ensure the new epoch interval doesn't exceed it:

```move
public fun update_epoch_interval_microsecs(
    aptos_framework: &signer,
    new_epoch_interval: u64,
) acquires BlockResource {
    system_addresses::assert_aptos_framework(aptos_framework);
    assert!(new_epoch_interval > 0, error::invalid_argument(EZERO_EPOCH_INTERVAL));
    
    // NEW: Validate against recurring lockup duration
    let recurring_lockup_secs = staking_config::get_recurring_lockup_duration(&staking_config::get());
    let new_epoch_duration_secs = new_epoch_interval / 1000000;
    assert!(
        recurring_lockup_secs >= new_epoch_duration_secs,
        error::invalid_argument(EINVALID_EPOCH_INTERVAL)
    );
    
    let block_resource = borrow_global_mut<BlockResource>(@aptos_framework);
    // ... rest of function
}
```

## Proof of Concept

```move
#[test(aptos_framework = @aptos_framework)]
public entry fun test_lockup_epoch_duration_invariant_violation(aptos_framework: signer) {
    // Setup: Initialize with valid configuration
    timestamp::set_time_has_started_for_testing(&aptos_framework);
    block::initialize(&aptos_framework, 7200 * 1000000); // 2 hour epochs
    staking_config::initialize_for_test(&aptos_framework, 0, 1000000, 7200, true, 1, 100, 10);
    
    // Attempt to violate invariant: set lockup < epoch duration
    // This should FAIL but currently SUCCEEDS due to missing validation
    staking_config::update_recurring_lockup_duration_secs(&aptos_framework, 3600); // 1 hour
    
    // Vulnerability: lockup duration (3600s) < epoch duration (7200s)
    // Active validators leaving can now withdraw earlier than intended
    
    let config = staking_config::get();
    let lockup = staking_config::get_recurring_lockup_duration(&config);
    assert!(lockup == 3600, 0); // Vulnerable state achieved
}
```

**Notes:**

This vulnerability demonstrates a critical gap in invariant enforcement between genesis-time validation and runtime updates. The genesis code correctly validates this relationship [1](#0-0) , but the Move framework functions that allow post-genesis updates lack this crucial check. This creates a state where the system can drift into an insecure configuration through seemingly innocuous governance proposals.

### Citations

**File:** aptos-move/vm-genesis/src/lib.rs (L418-421)
```rust
    assert!(
        genesis_config.recurring_lockup_duration_secs >= genesis_config.epoch_duration_secs,
        "Recurring lockup duration must be at least as long as epoch duration"
    );
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1177-1181)
```text
        if (get_validator_state(pool_address) == VALIDATOR_STATUS_INACTIVE &&
            timestamp::now_seconds() >= stake_pool.locked_until_secs) {
            let pending_inactive_stake = coin::extract_all(&mut stake_pool.pending_inactive);
            coin::merge(&mut stake_pool.inactive, pending_inactive_stake);
        };
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1437-1449)
```text
            let stake_pool = borrow_global_mut<StakePool>(validator_info.addr);
            let now_secs = timestamp::now_seconds();
            let reconfig_start_secs = if (chain_status::is_operating()) {
                get_reconfig_start_time_secs()
            } else {
                now_secs
            };
            if (stake_pool.locked_until_secs <= reconfig_start_secs) {
                spec {
                    assume now_secs + recurring_lockup_duration_secs <= MAX_U64;
                };
                stake_pool.locked_until_secs = now_secs + recurring_lockup_duration_secs;
            };
```

**File:** aptos-move/framework/aptos-framework/sources/configs/staking_config.move (L289-298)
```text
    public fun update_recurring_lockup_duration_secs(
        aptos_framework: &signer,
        new_recurring_lockup_duration_secs: u64,
    ) acquires StakingConfig {
        assert!(new_recurring_lockup_duration_secs > 0, error::invalid_argument(EZERO_LOCKUP_DURATION));
        system_addresses::assert_aptos_framework(aptos_framework);

        let staking_config = borrow_global_mut<StakingConfig>(@aptos_framework);
        staking_config.recurring_lockup_duration_secs = new_recurring_lockup_duration_secs;
    }
```

**File:** aptos-move/framework/aptos-framework/sources/block.move (L124-133)
```text
    public fun update_epoch_interval_microsecs(
        aptos_framework: &signer,
        new_epoch_interval: u64,
    ) acquires BlockResource {
        system_addresses::assert_aptos_framework(aptos_framework);
        assert!(new_epoch_interval > 0, error::invalid_argument(EZERO_EPOCH_INTERVAL));

        let block_resource = borrow_global_mut<BlockResource>(@aptos_framework);
        let old_epoch_interval = block_resource.epoch_interval;
        block_resource.epoch_interval = new_epoch_interval;
```
