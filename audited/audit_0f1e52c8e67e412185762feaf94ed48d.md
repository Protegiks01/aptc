# Audit Report

## Title
Upgrade Policy Enforcement Gap: Manifest Declaration vs. On-Chain Enforcement Mismatch

## Summary
The Aptos code publishing system stores both a `manifest` field (gzipped Move.toml text) and an `upgrade_policy` field in `PackageMetadata`, but performs no on-chain validation that these two values are consistent. A malicious publisher can declare `upgrade_policy = "immutable"` in their Move.toml manifest while publishing the package with a weaker policy (e.g., `compatible`) on-chain, allowing them to upgrade the package later despite users believing it's immutable.

## Finding Description

The vulnerability exists in the package metadata validation flow: [1](#0-0) 

The `PackageMetadata` struct stores two separate representations of the upgrade policy:
1. The `upgrade_policy: UpgradePolicy` field (line 34) - the actual enforced policy (numeric: 0=arbitrary, 1=compatible, 2=immutable)
2. The `manifest: vector<u8>` field (line 42) - the gzipped Move.toml text declaring the policy in human-readable form

During package building, both fields are populated from the same Move.toml: [2](#0-1) 

The upgrade policy is extracted from the manifest's custom properties, defaulting to `compat()` if not specified. The manifest is separately compressed and stored.

However, the on-chain enforcement only validates the numeric `upgrade_policy` field, never parsing or validating the `manifest` field contents: [3](#0-2) [4](#0-3) 

The `publish_package` function only checks the `pack.upgrade_policy` field. When upgrading, `check_upgradability` only examines `old_pack.upgrade_policy.policy` and `new_pack.upgrade_policy.policy`, never validating that the manifest text matches these values.

**Attack Path:**
1. Malicious publisher creates a Move.toml with `upgrade_policy = "immutable"`
2. Builds the package normally - metadata has `upgrade_policy = { policy: 2 }` and `manifest = gzipped("...upgrade_policy = 'immutable'...")`
3. Before submitting transaction, manually modifies the BCS-serialized `PackageMetadata` to change `upgrade_policy.policy` from `2` to `1`, while keeping `manifest` unchanged
4. Publishes with the tampered metadata via `code::publish_package_txn`: [5](#0-4) 

5. On-chain validation passes because `pack.upgrade_policy.policy = 1 > 0` (line 172-174 of `publish_package`)
6. Package is stored with mismatched values: `upgrade_policy.policy = 1` but manifest declares "immutable"
7. Users inspecting the manifest believe the package is immutable
8. Publisher later upgrades the package successfully because on-chain policy is `compatible`, not `immutable`

## Impact Explanation

This vulnerability represents a **HIGH severity** issue under the "Significant protocol violations" category for the following reasons:

**Trust and Transparency Violation**: The fundamental contract between package publishers and users is broken. Users inspecting package metadata on-chain expect the manifest to accurately reflect the enforced upgrade policy. This mismatch enables deceptive practices.

**Potential Loss of Funds**: In scenarios where:
- Users deposit funds into a smart contract believing it's immutable and cannot be upgraded to drain their funds
- DeFi protocols integrate with packages declared as immutable for security guarantees
- Multi-signature wallets or DAOs depend on immutability for governance safety

The publisher could upgrade the package to steal funds or manipulate behavior, despite the manifest declaring immutability.

**Protocol Integrity**: This violates the deterministic execution and state consistency invariants - what's declared should match what's enforced. The stored manifest becomes untrustworthy, undermining the entire metadata system.

## Likelihood Explanation

**Likelihood: Medium-High**

**Attacker Requirements:**
- Ability to modify BCS-serialized data (requires understanding of BCS format and Rust/Move tooling)
- Can be accomplished by forking the Aptos CLI or building custom client tools
- No special blockchain privileges required - any package publisher can execute this

**Detectability:**
- The mismatch IS detectable by comparing the manifest text against the `upgrade_policy` field
- However, most tooling and block explorers display only the `upgrade_policy` field, not the parsed manifest content
- Users would need to manually unzip and parse the manifest to detect the discrepancy

**Motivation:**
- High motivation for malicious actors to gain user trust while retaining upgrade capabilities
- Particularly valuable for rug-pull attacks in DeFi contexts
- Could be used to bypass security audits that only check the manifest

## Recommendation

Add on-chain validation that the `upgrade_policy` field matches the policy declared in the `manifest` field. This requires parsing the manifest on-chain or computing a verified hash:

**Option 1: Parse and Validate Manifest On-Chain**
Modify `publish_package` to unzip and parse the manifest, then verify the declared upgrade_policy matches the field value. This adds gas overhead but provides complete validation.

**Option 2: Two-Step Verification**
During package building, compute a cryptographic hash of the canonical representation of the entire `PackageMetadata` struct (including both manifest and upgrade_policy). Store this hash and validate it on-chain. Any tampering would invalidate the hash.

**Option 3: Remove Redundancy**
Store only the `manifest` field and parse it on-chain to derive the `upgrade_policy`. This eliminates the redundancy and potential mismatch.

**Recommended Implementation (Option 1 - Most Robust):**

Add to `code.move` in `publish_package` function after line 182:

```move
// Validate that manifest content matches upgrade_policy field
let manifest_str = util::unzip_metadata_str(&pack.manifest);
let declared_policy = parse_upgrade_policy_from_manifest(&manifest_str);
assert!(
    declared_policy == pack.upgrade_policy,
    error::invalid_argument(EMANIFEST_POLICY_MISMATCH)
);
```

Add new error code:
```move
const EMANIFEST_POLICY_MISMATCH: u64 = 0xC;
```

Add parsing helper function to extract upgrade_policy from manifest text.

## Proof of Concept

```rust
// Rust test demonstrating the vulnerability
#[test]
fn test_upgrade_policy_manifest_mismatch() {
    // 1. Build a package with immutable policy in Move.toml
    let manifest_content = r#"
[package]
name = "TestPackage"
version = "1.0.0"
upgrade_policy = "immutable"
"#;
    
    // 2. Extract metadata normally (would have policy = 2)
    let mut metadata = build_package_metadata(manifest_content);
    assert_eq!(metadata.upgrade_policy.policy, 2); // immutable
    
    // 3. Maliciously modify the upgrade_policy field
    metadata.upgrade_policy.policy = 1; // change to compatible
    
    // 4. Serialize and publish
    let metadata_serialized = bcs::to_bytes(&metadata).unwrap();
    
    // 5. Publish via transaction
    let result = publish_package_txn(&publisher, metadata_serialized, code);
    assert!(result.is_ok()); // Publish succeeds despite mismatch
    
    // 6. Verify the manifest still says "immutable" but policy is compatible
    let on_chain_metadata = get_package_metadata(publisher_addr);
    let manifest = unzip_metadata_str(&on_chain_metadata.manifest).unwrap();
    assert!(manifest.contains("upgrade_policy = \"immutable\"")); // Manifest claims immutable
    assert_eq!(on_chain_metadata.upgrade_policy.policy, 1); // But actual policy is compatible
    
    // 7. Prove upgrade is allowed despite manifest declaring immutable
    let upgrade_result = publish_package_txn(&publisher, new_metadata_serialized, new_code);
    assert!(upgrade_result.is_ok()); // Upgrade succeeds!
}
```

## Notes

This vulnerability is particularly concerning because:
- The manifest is explicitly stored on-chain as a trust anchor
- Users and auditors rely on manifest declarations for security decisions
- The on-chain code performs no consistency validation between manifest and enforced policy
- Block explorers and verification tools may display different fields, causing confusion

The fix should be implemented before mainnet deployments to prevent trust exploitation.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/code.move (L30-49)
```text
    struct PackageMetadata has copy, drop, store {
        /// Name of this package.
        name: String,
        /// The upgrade policy of this package.
        upgrade_policy: UpgradePolicy,
        /// The numbers of times this module has been upgraded. Also serves as the on-chain version.
        /// This field will be automatically assigned on successful upgrade.
        upgrade_number: u64,
        /// The source digest of the sources in the package. This is constructed by first building the
        /// sha256 of each individual source, than sorting them alphabetically, and sha256 them again.
        source_digest: String,
        /// The package manifest, in the Move.toml format. Gzipped text.
        manifest: vector<u8>,
        /// The list of modules installed by this package.
        modules: vector<ModuleMetadata>,
        /// Holds PackageDeps.
        deps: vector<PackageDep>,
        /// For future extension
        extension: Option<Any>
    }
```

**File:** aptos-move/framework/aptos-framework/sources/code.move (L168-174)
```text
    public fun publish_package(owner: &signer, pack: PackageMetadata, code: vector<vector<u8>>) acquires PackageRegistry {
        check_code_publishing_permission(owner);
        // Disallow incompatible upgrade mode. Governance can decide later if this should be reconsidered.
        assert!(
            pack.upgrade_policy.policy > upgrade_policy_arbitrary().policy,
            error::invalid_argument(EINCOMPATIBLE_POLICY_DISABLED),
        );
```

**File:** aptos-move/framework/aptos-framework/sources/code.move (L256-259)
```text
    public entry fun publish_package_txn(owner: &signer, metadata_serialized: vector<u8>, code: vector<vector<u8>>)
    acquires PackageRegistry {
        publish_package(owner, util::from_bytes<PackageMetadata>(metadata_serialized), code)
    }
```

**File:** aptos-move/framework/aptos-framework/sources/code.move (L265-279)
```text
    fun check_upgradability(
        old_pack: &PackageMetadata, new_pack: &PackageMetadata, new_modules: &vector<String>) {
        assert!(old_pack.upgrade_policy.policy < upgrade_policy_immutable().policy,
            error::invalid_argument(EUPGRADE_IMMUTABLE));
        assert!(can_change_upgrade_policy_to(old_pack.upgrade_policy, new_pack.upgrade_policy),
            error::invalid_argument(EUPGRADE_WEAKER_POLICY));
        let old_modules = get_module_names(old_pack);

        vector::for_each_ref(&old_modules, |old_module| {
            assert!(
                vector::contains(new_modules, old_module),
                EMODULE_MISSING
            );
        });
    }
```

**File:** aptos-move/framework/src/built_package.rs (L527-531)
```rust
        let upgrade_policy = if let Some(val) = custom_props.get(UPGRADE_POLICY_CUSTOM_FIELD) {
            str::parse::<UpgradePolicy>(val.as_ref())?
        } else {
            UpgradePolicy::compat()
        };
```
