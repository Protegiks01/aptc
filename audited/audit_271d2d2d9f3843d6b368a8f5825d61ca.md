# Audit Report

## Title
State Sync Notification Failure Causes Persistent Mempool Inconsistency and Permanent Event Loss

## Summary
When `handle_committed_transactions()` fails to notify mempool, event subscriptions, or storage service, the error is only logged with no retry mechanism. This causes mempool to retain stale committed transactions with outdated account sequence numbers, leading to wasteful re-broadcast and re-proposal of already-committed transactions. More critically, event subscribers permanently lose notifications, potentially affecting consensus components like DKG and JWK that rely on on-chain events. [1](#0-0) 

## Finding Description

The vulnerability exists in the notification flow when transactions are committed to storage. The `handle_committed_transactions()` function attempts to notify three critical components, but provides no recovery mechanism when notifications fail: [2](#0-1) 

**Failure Points:**

1. **Mempool Notification Failure**: The notification uses an mpsc channel that can fail if the receiver is closed or the channel is full (default size: 100 pending notifications). [3](#0-2) 

2. **Event Subscription Notification Failure**: Uses aptos_channel with KLAST queue style that drops old messages when full. [4](#0-3) 

3. **Storage Service Notification Failure**: Uses a LIFO channel with size limit of 1. [5](#0-4) 

**Mempool State Corruption Path:**

When mempool doesn't receive commit notifications, it fails to update its internal state: [6](#0-5) 

The critical issue is that `account_sequence_numbers` map is not updated (line 682-683 in the citation above), causing mempool to think older transactions are still valid. When consensus requests transactions via `get_batch()`: [7](#0-6) 

The check at line 471 compares against the stale `account_sequence_number`, causing already-committed transactions to be included in new block proposals. While these transactions fail execution (SEQUENCE_NUMBER_TOO_OLD) and are eventually cleaned up, this wastes network bandwidth and CPU cycles.

**Event Loss Path:**

Event subscribers receive notifications for on-chain events via the subscription service. If the notification fails: [8](#0-7) 

The events are permanently lost. Components like DKG and JWK consensus that subscribe to specific on-chain events will miss critical state updates.

**Storage Service Impact:**

The storage service maintains a cached storage summary that becomes stale if notifications fail. However, this has a periodic refresh mechanism that mitigates the impact: [9](#0-8) 

## Impact Explanation

**Medium Severity** per Aptos bug bounty criteria: "State inconsistencies requiring intervention"

The impact manifests in three ways:

1. **Mempool Resource Waste**: Stale transactions are re-broadcast across the network and re-proposed in blocks, wasting bandwidth and validator CPU cycles. Under heavy transaction load with notification channel saturation, mempool could accumulate many stale transactions, degrading network performance. The state eventually self-corrects when transactions are rejected during execution, but this is inefficient.

2. **Permanent Event Loss**: Event subscribers permanently lose notifications when the channel fails. For consensus components like DKG (Distributed Key Generation) and JWK (JSON Web Key) consensus that subscribe to critical on-chain events, missing these events could cause them to miss epoch transitions or configuration updates. This could affect consensus operation depending on how these components handle missing events.

3. **Storage Service Staleness**: The cached storage summary becomes temporarily stale, but this auto-corrects via the periodic refresh timer, so the impact is minimal.

The issue does NOT constitute Critical or High severity because:
- No fund loss or theft occurs
- No consensus safety violations (transactions fail re-execution)
- No permanent network partition
- Performance degradation is not classified as High severity per bounty rules

## Likelihood Explanation

**Medium to High Likelihood** under certain conditions:

1. **Natural Occurrence**: During periods of high transaction throughput, the notification channels (especially mempool's 100-message buffer) could become saturated, causing notifications to fail. This is more likely during stress conditions or coordinated transaction spam.

2. **Component Restart**: If mempool or other components restart while notifications are pending, the channels would close, causing notification failures for in-flight commits.

3. **No External Attacker Required**: While an external attacker cannot directly trigger notification failures without some form of DOS, the failures can occur naturally under load. This increases likelihood compared to attacks requiring privileged access.

4. **No Detection or Recovery**: The system logs errors but has no monitoring, alerting, or automatic recovery for notification failures, allowing the inconsistent state to persist.

## Recommendation

Implement a robust notification retry mechanism with the following components:

1. **Persistent Notification Queue**: Store pending notifications in a persistent queue (e.g., in storage) rather than relying solely on in-memory channels. When `handle_transaction_notification()` fails, enqueue the notification for retry.

2. **Retry Logic with Exponential Backoff**: Implement automatic retry with exponential backoff for failed notifications:

```rust
pub async fn handle_committed_transactions_with_retry<M, S>(
    committed_transactions: CommittedTransactions,
    storage: Arc<dyn DbReader>,
    mempool_notification_handler: MempoolNotificationHandler<M>,
    event_subscription_service: Arc<Mutex<EventSubscriptionService>>,
    storage_service_notification_handler: StorageServiceNotificationHandler<S>,
    max_retries: usize,
) where
    M: MempoolNotificationSender,
    S: StorageServiceNotificationSender,
{
    // Fetch latest state once
    let (latest_synced_version, latest_synced_ledger_info) = 
        match fetch_state(storage.clone()) {
            Ok(state) => state,
            Err(error) => {
                error!(LogSchema::new(LogEntry::SynchronizerNotification)
                    .error(&error)
                    .message("Failed to fetch state!"));
                return;
            }
        };

    // Retry notification with exponential backoff
    let mut retry_count = 0;
    let mut backoff_ms = 100;
    
    loop {
        match CommitNotification::handle_transaction_notification(
            committed_transactions.events.clone(),
            committed_transactions.transactions.clone(),
            latest_synced_version,
            latest_synced_ledger_info.clone(),
            mempool_notification_handler.clone(),
            event_subscription_service.clone(),
            storage_service_notification_handler.clone(),
        ).await {
            Ok(_) => break,
            Err(error) => {
                retry_count += 1;
                if retry_count >= max_retries {
                    error!(LogSchema::new(LogEntry::SynchronizerNotification)
                        .error(&error)
                        .message("Failed to handle notification after max retries!"));
                    // Persist to recovery queue
                    persist_failed_notification(
                        committed_transactions,
                        latest_synced_version,
                        latest_synced_ledger_info,
                    );
                    break;
                }
                warn!(LogSchema::new(LogEntry::SynchronizerNotification)
                    .error(&error)
                    .message(&format!("Retry attempt {}/{}", retry_count, max_retries)));
                tokio::time::sleep(Duration::from_millis(backoff_ms)).await;
                backoff_ms *= 2; // Exponential backoff
            }
        }
    }
}
```

3. **Background Recovery Task**: Implement a background task that periodically processes the recovery queue and retries failed notifications.

4. **Increase Channel Capacities**: Consider increasing channel buffer sizes, especially for mempool (from 100 to at least 1000) to handle burst traffic.

5. **Monitoring and Alerting**: Add metrics and alerts for notification failures to enable operators to detect and respond to persistent issues.

## Proof of Concept

```rust
// Reproduction test demonstrating the vulnerability
#[tokio::test]
async fn test_commit_notification_failure_causes_mempool_inconsistency() {
    use aptos_mempool_notifications::new_mempool_notifier_listener_pair;
    use aptos_types::transaction::SignedTransaction;
    use aptos_types::account_address::AccountAddress;
    
    // Setup: Create mempool with notification channel
    let (mempool_notifier, mut mempool_listener) = 
        new_mempool_notifier_listener_pair(1); // Small buffer size
    
    // Step 1: Fill the channel to capacity
    let dummy_txn = create_dummy_signed_transaction(AccountAddress::random(), 0);
    mempool_notifier.notify_new_commit(vec![dummy_txn.clone()], 0).await.unwrap();
    
    // Step 2: Attempt to send another notification - this will block/fail
    let result = tokio::time::timeout(
        Duration::from_secs(1),
        mempool_notifier.notify_new_commit(vec![dummy_txn], 0)
    ).await;
    
    // Verify: Notification failed/timed out
    assert!(result.is_err(), "Notification should timeout when channel is full");
    
    // Step 3: Mempool never receives the second notification
    // This means mempool state becomes inconsistent with storage
    // (In real scenario, mempool would still have the committed transaction
    // and stale account sequence number)
}

fn create_dummy_signed_transaction(sender: AccountAddress, seq: u64) -> Transaction {
    // Create a dummy signed transaction for testing
    // Implementation details omitted for brevity
}
```

## Notes

The vulnerability is confirmed through code analysis showing three critical gaps:

1. **No retry mechanism** exists in `handle_committed_transactions()`
2. **No persistent queue** for failed notifications  
3. **No reconciliation mechanism** to detect and correct inconsistencies between storage and component state

The storage service has partial mitigation via periodic refresh, but mempool and event subscriptions have no such fallback. Under sustained load or component failures, this can lead to significant operational issues requiring manual intervention to restore consistency.

### Citations

**File:** state-sync/state-sync-driver/src/utils.rs (L355-370)
```rust
    // Handle the commit notification
    if let Err(error) = CommitNotification::handle_transaction_notification(
        committed_transactions.events,
        committed_transactions.transactions,
        latest_synced_version,
        latest_synced_ledger_info,
        mempool_notification_handler,
        event_subscription_service,
        storage_service_notification_handler,
    )
    .await
    {
        error!(LogSchema::new(LogEntry::SynchronizerNotification)
            .error(&error)
            .message("Failed to handle a transaction commit notification!"));
    }
```

**File:** state-sync/state-sync-driver/src/notification_handlers.rs (L75-112)
```rust
    pub async fn handle_transaction_notification<
        M: MempoolNotificationSender,
        S: StorageServiceNotificationSender,
    >(
        events: Vec<ContractEvent>,
        transactions: Vec<Transaction>,
        latest_synced_version: Version,
        latest_synced_ledger_info: LedgerInfoWithSignatures,
        mut mempool_notification_handler: MempoolNotificationHandler<M>,
        event_subscription_service: Arc<Mutex<EventSubscriptionService>>,
        mut storage_service_notification_handler: StorageServiceNotificationHandler<S>,
    ) -> Result<(), Error> {
        // Log the highest synced version and timestamp
        let blockchain_timestamp_usecs = latest_synced_ledger_info.ledger_info().timestamp_usecs();
        debug!(
            LogSchema::new(LogEntry::NotificationHandler).message(&format!(
                "Notifying the storage service, mempool and the event subscription service of version: {:?} and timestamp: {:?}.",
                latest_synced_version, blockchain_timestamp_usecs
            ))
        );

        // Notify the storage service of the committed transactions
        storage_service_notification_handler
            .notify_storage_service_of_committed_transactions(latest_synced_version)
            .await?;

        // Notify mempool of the committed transactions
        mempool_notification_handler
            .notify_mempool_of_committed_transactions(transactions, blockchain_timestamp_usecs)
            .await?;

        // Notify the event subscription service of the events
        event_subscription_service
            .lock()
            .notify_events(latest_synced_version, events)?;

        Ok(())
    }
```

**File:** state-sync/inter-component/mempool-notifications/src/lib.rs (L77-116)
```rust
    async fn notify_new_commit(
        &self,
        transactions: Vec<Transaction>,
        block_timestamp_usecs: u64,
    ) -> Result<(), Error> {
        // Get only user transactions from committed transactions
        let user_transactions: Vec<CommittedTransaction> = transactions
            .iter()
            .filter_map(|transaction| match transaction {
                Transaction::UserTransaction(signed_txn) => Some(CommittedTransaction {
                    sender: signed_txn.sender(),
                    replay_protector: signed_txn.replay_protector(),
                    use_case: signed_txn.parse_use_case(),
                }),
                _ => None,
            })
            .collect();

        // Mempool needs to be notified about all transactions (user and non-user transactions).
        // See https://github.com/aptos-labs/aptos-core/issues/1882 for more details.
        let commit_notification = MempoolCommitNotification {
            transactions: user_transactions,
            block_timestamp_usecs,
        };

        // Send the notification to mempool
        if let Err(error) = self
            .notification_sender
            .clone()
            .send(commit_notification)
            .await
        {
            return Err(Error::CommitNotificationError(format!(
                "Failed to notify mempool of committed transactions! Error: {:?}",
                error
            )));
        }

        Ok(())
    }
```

**File:** state-sync/inter-component/event-notifications/src/lib.rs (L311-326)
```rust
    fn notify_events(&mut self, version: Version, events: Vec<ContractEvent>) -> Result<(), Error> {
        if events.is_empty() {
            return Ok(()); // No events!
        }

        // Notify event subscribers and check if a reconfiguration event was processed
        let reconfig_event_processed = self.notify_event_subscribers(version, events)?;

        // If a reconfiguration event was found, also notify the reconfig subscribers
        // of the new configuration values.
        if reconfig_event_processed {
            self.notify_reconfiguration_subscribers(version)
        } else {
            Ok(())
        }
    }
```

**File:** state-sync/inter-component/event-notifications/src/lib.rs (L349-358)
```rust
    fn notify_subscriber_of_events(&mut self, version: Version) -> Result<(), Error> {
        let event_notification = EventNotification {
            subscribed_events: self.event_buffer.drain(..).collect(),
            version,
        };

        self.notification_sender
            .push((), event_notification)
            .map_err(|error| Error::UnexpectedErrorEncountered(format!("{:?}", error)))
    }
```

**File:** state-sync/inter-component/storage-service-notifications/src/lib.rs (L76-95)
```rust
    async fn notify_new_commit(&self, highest_synced_version: u64) -> Result<(), Error> {
        // Create a new commit notification
        let commit_notification = StorageServiceCommitNotification {
            highest_synced_version,
        };

        // Send the notification to the storage service
        if let Err(error) = self
            .notification_sender
            .clone()
            .push((), commit_notification)
        {
            return Err(Error::CommitNotificationError(format!(
                "Failed to notify the storage service of committed transactions! Error: {:?}",
                error
            )));
        }

        Ok(())
    }
```

**File:** mempool/src/core_mempool/transaction_store.rs (L671-707)
```rust
    pub fn commit_transaction(
        &mut self,
        account: &AccountAddress,
        replay_protector: ReplayProtector,
    ) {
        match replay_protector {
            ReplayProtector::SequenceNumber(txn_sequence_number) => {
                let current_account_seq_number =
                    self.get_account_sequence_number(account).map_or(0, |v| *v);
                let new_account_seq_number =
                    max(current_account_seq_number, txn_sequence_number + 1);
                self.account_sequence_numbers
                    .insert(*account, new_account_seq_number);
                self.clean_committed_transactions_below_account_seq_num(
                    account,
                    new_account_seq_number,
                );
                self.process_ready_seq_num_based_transactions(account, new_account_seq_number);
            },
            ReplayProtector::Nonce(nonce) => {
                if let Some(txns) = self.transactions.get_mut(account) {
                    if let Some(txn) = txns.remove(&ReplayProtector::Nonce(nonce)) {
                        self.index_remove(&txn);
                        trace!(
                            LogSchema::new(LogEntry::CleanCommittedTxn).txns(TxnsLog::new_txn(
                                txn.get_sender(),
                                txn.get_replay_protector()
                            )),
                            "txns cleaned with committing tx {}:{:?}",
                            txn.get_sender(),
                            txn.get_replay_protector()
                        );
                    }
                }
            },
        }
    }
```

**File:** mempool/src/core_mempool/mempool.rs (L467-471)
```rust
                    let account_sequence_number =
                        self.transactions.get_account_sequence_number(&txn.address);
                    // include transaction if it's "next" for given account or
                    // we've already sent its ancestor to Consensus.
                    if txn_in_sequence || account_sequence_number == Some(&txn_seq) {
```

**File:** state-sync/storage-service/server/src/lib.rs (L188-216)
```rust
            loop {
                futures::select! {
                    _ = ticker.select_next_some() => {
                        // Refresh the cache periodically
                        refresh_cached_storage_summary(
                            cached_storage_server_summary.clone(),
                            storage.clone(),
                            config,
                            cache_update_notifiers.clone(),
                        )
                    },
                    notification = storage_service_listener.select_next_some() => {
                        trace!(LogSchema::new(LogEntry::ReceivedCommitNotification)
                            .message(&format!(
                                "Received commit notification for highest synced version: {:?}.",
                                notification.highest_synced_version
                            ))
                        );

                        // Refresh the cache because of a commit notification
                        refresh_cached_storage_summary(
                            cached_storage_server_summary.clone(),
                            storage.clone(),
                            config,
                            cache_update_notifiers.clone(),
                        )
                    },
                }
            }
```
