# Audit Report

## Title
NativeEventContext Memory Bypass: Unbounded Event Accumulation Outside Memory Quota Enforcement Leading to Validator OOM

## Summary
The `NativeEventContext.events` Vec can accumulate up to 10 MB of event data during transaction execution while completely bypassing the memory quota system. This occurs because event native functions are explicitly configured to "leak memory" from the quota tracking perspective, and the events Vec itself is stored in native context extensions that are not tracked by the Move VM memory quota enforcement. This can cause validator out-of-memory conditions before transaction completion, especially when multiple transactions execute concurrently.

## Finding Description

The vulnerability exists in the interaction between event accumulation and memory quota enforcement: [1](#0-0) 

Events are stored in a plain `Vec` with no memory tracking. During transaction execution: [2](#0-1) 

Gas is charged based on abstract value size, but crucially, the event is then pushed to the Vec which resides outside Move VM memory tracking.

The memory quota system explicitly excludes event functions from tracking: [3](#0-2) 

When `should_leak_memory_for_native` is true (which it is for event functions when feature_version >= 4), the memory quota system does NOT release the heap memory for event arguments: [4](#0-3) 

The size limits are only checked POST-execution: [5](#0-4) 

This creates a bypass where:
1. Event data accumulates in `NativeEventContext.events` Vec during execution
2. This Vec is a native extension, not tracked by Move VM memory quota
3. Up to 10 MB of events can accumulate per transaction
4. With concurrent transaction execution in blocks, this multiplies (e.g., 100 transactions Ã— 10 MB = 1 GB)
5. Memory exhaustion occurs BEFORE the size check in `check_change_set`

The configured limits show the extent of the issue: [6](#0-5) 

## Impact Explanation

This is **High Severity** per the Aptos bug bounty criteria ("Validator node slowdowns / API crashes"):

1. **Validator DoS**: An attacker can craft transactions that emit maximum events (approaching 10 MB), causing validators to run out of memory during block execution
2. **Consensus Disruption**: If enough validators crash/slow down due to OOM, block production is delayed or halted
3. **Resource Exhaustion**: Unlike other operations that respect the 10,000,000 abstract value unit memory quota, events bypass this entirely
4. **Amplification via Concurrency**: During parallel block execution, multiple transactions can simultaneously accumulate events, multiplying memory consumption

The vulnerability breaks the critical invariant: **"Move VM Safety: Bytecode execution must respect gas limits and memory constraints"**.

## Likelihood Explanation

**High Likelihood:**
- Any transaction sender can exploit this without special privileges
- The attack is straightforward: emit many events with maximum allowed size
- The bypass is by design (intentional "memory leak" for event functions) but creates an exploitable gap
- Governance transactions with higher gas limits (4B internal gas units) exacerbate the issue
- Modern Aptos networks run feature_version >= 4, making the bypass active

## Recommendation

Implement memory quota tracking for the `NativeEventContext.events` Vec:

1. **Track event memory in native context**: Call `context.use_heap_memory()` after pushing events to track their memory consumption against the quota
2. **Enforce incremental limits**: Check accumulated event size against a threshold during execution, not just at the end
3. **Add early validation**: In `native_write_to_event_store` and `native_write_module_event_to_store`, track the memory consumed by both the ContractEvent and the optional MoveTypeLayout
4. **Remove memory leak flag for events**: Re-evaluate whether `should_leak_memory_for_native` should be true for event functions in feature_version >= 4

Example fix for `native_write_to_event_store`:

```rust
// After line 149, add memory tracking:
let event_memory = (blob.len() + std::mem::size_of::<ContractEvent>()) as u64;
if contains_delayed_fields {
    // Rough approximation of MoveTypeLayout memory
    event_memory += (std::mem::size_of::<MoveTypeLayout>() * 2) as u64;
}
context.use_heap_memory(event_memory)?;
```

## Proof of Concept

The following Move module demonstrates the vulnerability:

```move
module attacker::event_bomb {
    use std::vector;
    use aptos_framework::event;
    
    struct LargeEvent has drop, store {
        data: vector<u8>
    }
    
    public entry fun emit_event_bomb() {
        let i = 0;
        // Emit many events, each approaching maximum size
        // Will accumulate up to 10 MB in NativeEventContext.events
        // without being tracked by memory quota
        while (i < 50) {
            let large_data = vector::empty<u8>();
            let j = 0;
            // Create 200 KB event data
            while (j < 200000) {
                vector::push_back(&mut large_data, 0xFF);
                j = j + 1;
            };
            
            event::emit(LargeEvent { data: large_data });
            i = i + 1;
        };
        // Total: 50 * 200 KB = 10 MB of events
        // All accumulated in Vec outside memory quota tracking
    }
}
```

When multiple transactions call `emit_event_bomb()` concurrently during block execution, validators will experience memory pressure leading to OOM crashes.

## Notes

The vulnerability is particularly dangerous because:
- The "memory leak" behavior for event functions (feature_version >= 4) was likely intended as an optimization to avoid double-counting memory
- However, it creates a gap where the actual memory consumed by the `NativeEventContext.events` Vec is never tracked
- The 10 MB post-execution limit provides a ceiling but doesn't prevent OOM during execution
- This represents a fundamental disconnect between the memory quota system (tracking Move VM heap) and native context extensions (untracked)

### Citations

**File:** aptos-move/framework/src/natives/event.rs (L34-36)
```rust
pub struct NativeEventContext {
    events: Vec<(ContractEvent, Option<MoveTypeLayout>)>,
}
```

**File:** aptos-move/framework/src/natives/event.rs (L116-149)
```rust
    context.charge(
        EVENT_WRITE_TO_EVENT_STORE_BASE
            + EVENT_WRITE_TO_EVENT_STORE_PER_ABSTRACT_VALUE_UNIT * context.abs_val_size(&msg)?,
    )?;
    let ty_tag = context.type_to_type_tag(ty)?;
    let (layout, contains_delayed_fields) = context
        .type_to_type_layout_with_delayed_fields(ty)?
        .unpack();

    let function_value_extension = context.function_value_extension();
    let max_value_nest_depth = context.max_value_nest_depth();
    let blob = ValueSerDeContext::new(max_value_nest_depth)
        .with_delayed_fields_serde()
        .with_func_args_deserialization(&function_value_extension)
        .serialize(&msg, &layout)?
        .ok_or_else(|| {
            SafeNativeError::InvariantViolation(PartialVMError::new(
                StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR,
            ))
        })?;
    let key = bcs::from_bytes(guid.as_slice()).map_err(|_| {
        SafeNativeError::InvariantViolation(PartialVMError::new(StatusCode::EVENT_KEY_MISMATCH))
    })?;

    let ctx = context.extensions_mut().get_mut::<NativeEventContext>();
    let event =
        ContractEvent::new_v1(key, seq_num, ty_tag, blob).map_err(|_| SafeNativeError::Abort {
            abort_code: ECANNOT_CREATE_EVENT,
        })?;
    // TODO(layouts): avoid cloning layouts for events with delayed fields.
    ctx.events.push((
        event,
        contains_delayed_fields.then(|| layout.as_ref().clone()),
    ));
```

**File:** aptos-move/aptos-memory-usage-tracker/src/lib.rs (L311-315)
```rust
        self.should_leak_memory_for_native = (*module_id.address() == CORE_CODE_ADDRESS
            && module_id.name().as_str() == "table")
            || (self.feature_version() >= 4
                && *module_id.address() == CORE_CODE_ADDRESS
                && module_id.name().as_str() == "event");
```

**File:** aptos-move/aptos-memory-usage-tracker/src/lib.rs (L328-340)
```rust
        if !self.should_leak_memory_for_native {
            self.release_heap_memory(args.clone().try_fold(
                AbstractValueSize::zero(),
                |acc, val| {
                    let heap_size = self
                        .vm_gas_params()
                        .misc
                        .abs_val
                        .abstract_heap_size(val, self.feature_version())?;
                    Ok::<_, PartialVMError>(acc + heap_size)
                },
            )?);
        }
```

**File:** aptos-move/aptos-vm-types/src/storage/change_set_configs.rs (L115-125)
```rust
        let mut total_event_size = 0;
        for event in change_set.events_iter() {
            let size = event.event_data().len() as u64;
            if size > self.max_bytes_per_event {
                return storage_write_limit_reached(None);
            }
            total_event_size += size;
            if total_event_size > self.max_bytes_all_events_per_transaction {
                return storage_write_limit_reached(None);
            }
        }
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L164-171)
```rust
            max_bytes_per_event: NumBytes,
            { 5.. => "max_bytes_per_event" },
            1 << 20, // a single event is 1MB max
        ],
        [
            max_bytes_all_events_per_transaction: NumBytes,
            { 5.. => "max_bytes_all_events_per_transaction"},
            10 << 20, // all events from a single transaction are 10MB max
```
