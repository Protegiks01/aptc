# Audit Report

## Title
Optimistic Proposal DoS: Proposer Validation After Expensive Sync Operations

## Summary
The `process_opt_proposal_msg()` function in `consensus/src/round_manager.rs` performs expensive synchronization operations before validating whether the sender is a valid proposer for the round. An attacker can exploit this ordering to force validators to execute costly block fetching and processing operations by sending crafted optimistic proposals, causing validator node slowdowns across the network.

## Finding Description

The vulnerability exists in the optimistic proposal handling flow where proposer validation occurs AFTER expensive sync operations. [1](#0-0) 

The attack flow works as follows:

1. **No Signature Requirement**: Unlike regular proposals, optimistic proposals are not signed by the proposer. The code explicitly states this: [2](#0-1) 

2. **Early Verification Lacks Proposer Check**: The `OptProposalMsg::verify()` function verifies signatures on embedded certificates and payload validity, but does NOT validate if the sender is a valid proposer: [3](#0-2) 

3. **Expensive Sync Before Validation**: When processing the message, `sync_up()` is called at line 813-814, which can trigger expensive operations: [4](#0-3) 

4. **Expensive Operations in sync_up()**: The `add_certs()` function performs block retrieval from the network: [5](#0-4) 

5. **Network Block Fetching**: The `fetch_quorum_cert()` and `fast_forward_sync()` functions fetch potentially hundreds of blocks: [6](#0-5) 

6. **Late Proposer Validation**: Only AFTER all these expensive operations does proposer validation occur: [7](#0-6) 

**Attack Scenario:**
1. Attacker monitors the network and obtains legitimate `SyncInfo` with certificates for rounds significantly ahead of their target
2. Attacker crafts `OptProposalMsg` for round R, claiming to be the author (but is NOT the valid proposer)
3. Attacker includes the legitimate `SyncInfo` with newer certificates
4. Victim validator receives the message and calls `process_opt_proposal_msg()`
5. `sync_up()` executes, triggering expensive block fetching operations (potentially hundreds of blocks)
6. Only after this expensive work does proposer validation fail
7. Attacker repeats for every round, broadcasting to all validators

This breaks the **Resource Limits** invariant: "All operations must respect gas, storage, and computational limits" by allowing resource exhaustion before proper authorization checks.

## Impact Explanation

**Severity: High** - Validator Node Slowdowns

Per the Aptos Bug Bounty criteria, this qualifies as **High Severity** due to:

1. **Validator Node Slowdowns**: The attack forces validators to perform expensive operations (network I/O, block processing, state updates) before rejecting invalid proposers
2. **Network-Wide Impact**: The attack can target all validators simultaneously by broadcasting malicious messages
3. **Repeated Exploitation**: The attack can be repeated for every consensus round
4. **Consensus Liveness Degradation**: While not causing total liveness failure, the resource exhaustion significantly slows down consensus operations
5. **Amplification Factor**: A single small malicious message can trigger fetching and processing of hundreds of blocks

The vulnerability does not directly cause loss of funds or consensus safety violations, placing it in High Severity rather than Critical.

## Likelihood Explanation

**Likelihood: High**

The attack is highly likely to be exploited because:

1. **Low Barrier to Entry**: Any network peer can send consensus messages
2. **No Special Resources Required**: Attacker only needs to monitor the network to obtain legitimate `SyncInfo` 
3. **Easy to Craft**: Creating the malicious `OptProposalMsg` requires no cryptographic operations (no signature needed)
4. **Difficult to Mitigate**: Standard rate limiting may not be effective since messages appear valid until expensive processing completes
5. **Clear Motivation**: Disrupting consensus can provide economic advantages or enable other attacks
6. **Broad Attack Surface**: All validators in the network are vulnerable

The code comment at lines 822-824 indicates developers were aware of the need to validate after sync, but didn't anticipate the DoS risk from doing expensive operations first.

## Recommendation

Move proposer validation BEFORE the `sync_up()` call. Since optimistic proposals lack proposer signatures, early validation is critical to prevent resource exhaustion:

```rust
pub async fn process_opt_proposal_msg(
    &mut self,
    proposal_msg: OptProposalMsg,
) -> anyhow::Result<()> {
    ensure!(self.local_config.enable_optimistic_proposal_rx,
        "Opt proposal is disabled, but received opt proposal msg of epoch {} round {} from peer {}",
        proposal_msg.block_data().epoch(), proposal_msg.round(), proposal_msg.proposer()
    );

    // ... fail_point and observe_block calls ...

    // VALIDATE PROPOSER EARLY - BEFORE EXPENSIVE SYNC OPERATIONS
    ensure!(
        self.proposer_election
            .is_valid_proposer(proposal_msg.proposer(), proposal_msg.round()),
        "[OptProposal] Not a valid proposer for round {}: {}",
        proposal_msg.round(),
        proposal_msg.proposer()
    );

    // Now perform sync_up - only for messages from valid proposers
    self.sync_up(proposal_msg.sync_info(), proposal_msg.proposer())
        .await?;

    if self.round_state.current_round() == proposal_msg.round() {
        self.opt_proposal_loopback_tx
            .send(proposal_msg.take_block_data())
            .await
            .expect("Sending to a self loopback unbounded channel cannot fail");
    } else {
        // Re-check after sync in case proposer election state changed
        ensure!(
            self.proposer_election
                .is_valid_proposer(proposal_msg.proposer(), proposal_msg.round()),
            "[OptProposal] Not a valid proposer for round {} after sync: {}",
            proposal_msg.round(),
            proposal_msg.proposer()
        );
        self.pending_opt_proposals
            .insert(proposal_msg.round(), proposal_msg.take_block_data());
    }

    Ok(())
}
```

This ensures resource-intensive operations only occur for messages from legitimate proposers.

## Proof of Concept

```rust
// Integration test demonstrating the vulnerability
// Add to consensus/src/round_manager_tests/

#[tokio::test]
async fn test_opt_proposal_dos_attack() {
    // Setup: Create a consensus environment with multiple validators
    let (mut playground, _) = consensus_playground();
    let validator_signers = playground.validator_signers.clone();
    
    // Get a non-proposer validator (attacker)
    let attacker_signer = &validator_signers[1];
    let attacker_author = attacker_signer.author();
    
    // Assume validator 0 is the valid proposer for round 10
    let valid_proposer = validator_signers[0].author();
    let target_round = 10;
    
    // Attacker obtains legitimate sync_info with certificates for rounds ahead
    // (simulating monitoring the network)
    let future_round = 100;
    let sync_info = create_sync_info_with_future_certs(future_round);
    
    // Craft malicious OptProposalMsg claiming to be from attacker (NOT valid proposer)
    let malicious_opt_proposal = OptProposalMsg::new(
        create_opt_block_data(
            attacker_author,  // Attacker claims to be author
            target_round,
            /* ... other params ... */
        ),
        sync_info.clone(),
    );
    
    // Measure resource consumption
    let start_time = Instant::now();
    let initial_block_count = get_block_store_size();
    
    // Send malicious message to victim validator
    let result = victim_round_manager
        .process_opt_proposal_msg(malicious_opt_proposal)
        .await;
    
    let elapsed = start_time.elapsed();
    let blocks_fetched = get_block_store_size() - initial_block_count;
    
    // Verify the attack succeeded in forcing expensive operations
    assert!(elapsed > Duration::from_millis(100)); // Sync took significant time
    assert!(blocks_fetched > 10); // Multiple blocks were fetched
    
    // Verify the message was eventually rejected
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Not a valid proposer"));
    
    // The vulnerability: expensive sync happened BEFORE rejection
    println!("Attack forced {} ms of processing and {} block fetches before rejection",
             elapsed.as_millis(), blocks_fetched);
}
```

**Notes:**
- The vulnerability specifically affects optimistic proposal handling due to the lack of proposer signatures
- Regular proposals are less vulnerable because they require valid proposer signatures that are checked during initial verification
- The attack can cause cascading effects if validators become backlogged processing malicious sync operations
- This represents a fundamental ordering issue in the consensus message processing pipeline

### Citations

**File:** consensus/src/round_manager.rs (L813-831)
```rust
        self.sync_up(proposal_msg.sync_info(), proposal_msg.proposer())
            .await?;

        if self.round_state.current_round() == proposal_msg.round() {
            self.opt_proposal_loopback_tx
                .send(proposal_msg.take_block_data())
                .await
                .expect("Sending to a self loopback unbounded channel cannot fail");
        } else {
            // Pre-check that proposal is from valid proposer before queuing it.
            // This check is done after syncing up to sync info to ensure proposer
            // election provider is up to date.
            ensure!(
                self.proposer_election
                    .is_valid_proposer(proposal_msg.proposer(), proposal_msg.round()),
                "[OptProposal] Not a valid proposer for round {}: {}",
                proposal_msg.round(),
                proposal_msg.proposer()
            );
```

**File:** consensus/src/round_manager.rs (L877-906)
```rust
    /// Sync to the sync info sending from peer if it has newer certificates.
    async fn sync_up(&mut self, sync_info: &SyncInfo, author: Author) -> anyhow::Result<()> {
        let local_sync_info = self.block_store.sync_info();
        if sync_info.has_newer_certificates(&local_sync_info) {
            info!(
                self.new_log(LogEvent::ReceiveNewCertificate)
                    .remote_peer(author),
                "Local state {},\n remote state {}", local_sync_info, sync_info
            );
            // Some information in SyncInfo is ahead of what we have locally.
            // First verify the SyncInfo (didn't verify it in the yet).
            sync_info.verify(&self.epoch_state.verifier).map_err(|e| {
                error!(
                    SecurityEvent::InvalidSyncInfoMsg,
                    sync_info = sync_info,
                    remote_peer = author,
                    error = ?e,
                );
                VerifyError::from(e)
            })?;
            SYNC_INFO_RECEIVED_WITH_NEWER_CERT.inc();
            let result = self
                .block_store
                .add_certs(sync_info, self.create_block_retriever(author))
                .await;
            self.process_certificates().await?;
            result
        } else {
            Ok(())
        }
```

**File:** consensus/consensus-types/src/block.rs (L453-454)
```rust
            BlockType::OptimisticProposal(p) => {
                // Note: Optimistic proposal is not signed by proposer unlike normal proposal
```

**File:** consensus/consensus-types/src/opt_proposal_msg.rs (L96-123)
```rust
    pub fn verify(
        &self,
        sender: Author,
        validator: &ValidatorVerifier,
        proof_cache: &ProofCache,
        quorum_store_enabled: bool,
    ) -> Result<()> {
        ensure!(
            self.proposer() == sender,
            "OptProposal author {:?} doesn't match sender {:?}",
            self.proposer(),
            sender
        );

        let (payload_verify_result, qc_verify_result) = rayon::join(
            || {
                self.block_data()
                    .payload()
                    .verify(validator, proof_cache, quorum_store_enabled)
            },
            || self.block_data().grandparent_qc().verify(validator),
        );
        payload_verify_result?;
        qc_verify_result?;

        // Note that we postpone the verification of SyncInfo until it's being used.
        self.verify_well_formed()
    }
```

**File:** consensus/src/block_storage/sync_manager.rs (L116-173)
```rust
    pub async fn add_certs(
        &self,
        sync_info: &SyncInfo,
        mut retriever: BlockRetriever,
    ) -> anyhow::Result<()> {
        // When the local ordered round is very old than the received sync_info, this function will
        // (1) resets the block store with highest commit cert = sync_info.highest_quorum_cert()
        // (2) insert all the blocks between (inclusive) highest_commit_cert.commit_info().id() to
        // highest_quorum_cert.certified_block().id() into the block store and storage
        // (3) insert the quorum cert for all the above blocks into the block store and storage
        // (4) executes all the blocks that are ordered while inserting the above quorum certs
        self.sync_to_highest_quorum_cert(
            sync_info.highest_quorum_cert().clone(),
            sync_info.highest_commit_cert().clone(),
            &mut retriever,
        )
        .await?;

        self.sync_to_highest_commit_cert(
            sync_info.highest_commit_cert().ledger_info(),
            retriever.network.clone(),
        )
        .await;

        // The insert_ordered_cert(order_cert) function call expects that order_cert.commit_info().id() block
        // is already stored in block_store. So, we first call insert_quorum_cert(highest_quorum_cert).
        // This call will ensure that the highest ceritified block along with all its ancestors are inserted
        // into the block store.
        self.insert_quorum_cert(sync_info.highest_quorum_cert(), &mut retriever)
            .await?;

        // Even though we inserted the highest_quorum_cert (and its ancestors) in the above step,
        // we still need to insert ordered cert explicitly. This will send the highest ordered block
        // to execution.
        if self.order_vote_enabled {
            self.insert_ordered_cert(&sync_info.highest_ordered_cert())
                .await?;
        } else {
            // When order votes are disabled, the highest_ordered_cert().certified_block().id() need not be
            // one of the ancestors of highest_quorum_cert.certified_block().id() due to forks. So, we call
            // insert_quorum_cert instead of insert_ordered_cert as in the above case. This will ensure that
            // highest_ordered_cert().certified_block().id() is inserted the block store.
            self.insert_quorum_cert(
                &self
                    .highest_ordered_cert()
                    .as_ref()
                    .clone()
                    .into_quorum_cert(self.order_vote_enabled)?,
                &mut retriever,
            )
            .await?;
        }

        if let Some(tc) = sync_info.highest_2chain_timeout_cert() {
            self.insert_2chain_timeout_certificate(Arc::new(tc.clone()))?;
        }
        Ok(())
    }
```

**File:** consensus/src/block_storage/sync_manager.rs (L233-262)
```rust
    async fn fetch_quorum_cert(
        &self,
        qc: QuorumCert,
        retriever: &mut BlockRetriever,
    ) -> anyhow::Result<()> {
        let mut pending = vec![];
        let mut retrieve_qc = qc.clone();
        loop {
            if self.block_exists(retrieve_qc.certified_block().id()) {
                break;
            }
            BLOCKS_FETCHED_FROM_NETWORK_WHILE_INSERTING_QUORUM_CERT.inc_by(1);
            let target_block_retrieval_payload = match &self.window_size {
                None => TargetBlockRetrieval::TargetBlockId(retrieve_qc.certified_block().id()),
                Some(_) => TargetBlockRetrieval::TargetRound(retrieve_qc.certified_block().round()),
            };
            let mut blocks = retriever
                .retrieve_blocks_in_range(
                    retrieve_qc.certified_block().id(),
                    1,
                    target_block_retrieval_payload,
                    qc.ledger_info()
                        .get_voters(&retriever.validator_addresses()),
                )
                .await?;
            // retrieve_blocks_in_range guarantees that blocks has exactly 1 element
            let block = blocks.remove(0);
            retrieve_qc = block.quorum_cert().clone();
            pending.push(block);
        }
```
