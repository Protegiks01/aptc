# Audit Report

## Title
Unverified CommitDecision with Future Epoch Causes Root Corruption and Consensus Observer DoS

## Summary
An attacker can send a `CommitDecision` message with a future epoch and arbitrary round value to corrupt the consensus observer's root state and cause a complete denial of service. The vulnerability exists because future-epoch commit decisions bypass signature verification but are still used to update critical internal state.

## Finding Description

The consensus observer processes `CommitDecision` messages containing commit proofs with epoch and round information. The vulnerability arises from a critical flaw in the message processing flow where unverified future-epoch commits corrupt internal state.

**Vulnerability Flow:**

1. The `round()` and `epoch()` functions extract values directly from the unverified commit proof without any validation: [1](#0-0) 

2. In `process_commit_decision_message()`, epoch and round are extracted BEFORE any signature verification occurs: [2](#0-1) 

3. These unverified values are immediately used to filter messages by comparing against the highest committed epoch/round, allowing the attacker's fake values to pass the staleness check: [3](#0-2) 

4. Signature verification is ONLY performed when the commit epoch matches the current epoch: [4](#0-3) 

5. For future-epoch commits (where `commit_epoch > epoch_state.epoch`), the code skips verification entirely and proceeds to state sync handling: [5](#0-4) 

6. Most critically, the unverified commit decision is used to update the observer's root BEFORE any state sync validation occurs: [6](#0-5) 

7. The root update in `update_blocks_for_state_sync_commit()` directly assigns the unverified commit proof to the root: [7](#0-6) [8](#0-7) 

8. After the root is corrupted with fake epoch/round values, `get_highest_committed_epoch_round()` returns these manipulated values for all subsequent message filtering: [9](#0-8) 

9. The observer then starts state syncing to the non-existent target. When state sync fails to reach the fake target, it only logs an error and exits without clearing the sync handle or sending a notification: [10](#0-9) 

10. The observer becomes permanently stuck because `check_progress()` continuously waits for the failed state sync to complete: [11](#0-10) 

11. All normal block processing is blocked while waiting for the failed state sync: [12](#0-11) [13](#0-12) 

**Attack Scenario:**
1. Attacker sends `CommitDecision` with `epoch = current_epoch + 1` and `round = u64::MAX`
2. Observer extracts these values without validation (lines 449-450)
3. Values pass staleness check since they're "higher" than current committed epoch/round (lines 453-457)
4. Signature verification is skipped because `commit_epoch != epoch_state.epoch` (line 468 check fails)
5. Root is updated to the fake commit at line 520-522 (calls update_root at line 282 of block_data.rs)
6. State sync to non-existent target is initiated and fails (lines 218-230 of state_sync_manager.rs)
7. Observer is permanently stuck waiting for failed state sync (lines 180-187)
8. All legitimate messages with "lower" epochs/rounds are now rejected as stale by the corrupted filtering logic

This breaks the **Consensus Safety** invariant by allowing an attacker to corrupt the observer's view of consensus state without any cryptographic validation.

## Impact Explanation

This is a **Critical Severity** vulnerability based on Aptos bug bounty criteria because it causes:

**Total Loss of Liveness/Network Availability** (Critical Impact Category):
- The affected consensus observer node becomes completely non-functional
- All block processing is halted while waiting for the failed state sync
- The observer cannot participate in consensus observation or execution
- Recovery requires manual intervention (node restart and state cleanup)

**Significant Protocol Violations**:
- Corrupts the consensus observer's internal state tracking
- Bypasses all cryptographic signature verification requirements
- Violates the fundamental security assumption that all state updates must be verified

**Wide Attack Surface**:
- Affects all consensus observer nodes in the network
- Can be exploited by any network peer without requiring:
  - Validator credentials or stake
  - Governance power or voting rights
  - Cryptographic key compromise
  - Network majority control or coordination

The vulnerability violates core consensus safety guarantees by allowing unverified data to corrupt critical consensus state, resulting in a non-recoverable denial of service.

## Likelihood Explanation

**Likelihood: Very High**

- **Attack Complexity: Trivial** - A single malformed network message triggers the vulnerability with no complex setup or timing requirements
- **Attacker Requirements: Minimal** - Only requires network access to send messages to consensus observer nodes (any network peer)
- **No Authentication Required** - The attack succeeds before any signature verification occurs, bypassing all cryptographic protections
- **Easily Reproducible** - The vulnerable code path is deterministic and always accessible during normal operations
- **High Impact per Attack** - Each malicious message causes complete and permanent DoS until manual recovery
- **No Rate Limiting** - The vulnerability can be triggered repeatedly against multiple observer nodes simultaneously

## Recommendation

Implement signature verification for ALL commit decisions regardless of epoch, before using them to update any internal state:

```rust
fn process_commit_decision_message(
    &mut self,
    peer_network_id: PeerNetworkId,
    message_received_time: Instant,
    commit_decision: CommitDecision,
) {
    let commit_epoch = commit_decision.epoch();
    let commit_round = commit_decision.round();
    
    // Verify commit decision BEFORE any state updates
    let epoch_state = self.get_epoch_state();
    
    // For future epochs, we need the future epoch state to verify
    // If unavailable, reject the message rather than accepting unverified data
    if commit_epoch != epoch_state.epoch {
        warn!("Received commit decision for different epoch without ability to verify. Rejecting.");
        increment_invalid_message_counter(&peer_network_id, metrics::COMMIT_DECISION_LABEL);
        return;
    }
    
    // Verify the commit decision
    if let Err(error) = commit_decision.verify_commit_proof(&epoch_state) {
        error!("Failed to verify commit decision: {:?}", error);
        increment_invalid_message_counter(&peer_network_id, metrics::COMMIT_DECISION_LABEL);
        return;
    }
    
    // Only after verification, proceed with state updates
    // ... rest of processing logic
}
```

Additionally, add proper cleanup in `state_sync_manager.rs` when state sync fails:

```rust
// In sync_to_commit task
if let Err(error) = execution_client.clone().sync_to_target(commit_decision.commit_proof().clone()).await {
    error!("Failed to sync to commit decision: {:?}", error);
    
    // Send notification about failure so observer can clean up
    let state_sync_notification = StateSyncNotification::commit_sync_failed(commit_decision.commit_proof().clone());
    let _ = sync_notification_sender.send(state_sync_notification);
    return;
}
```

## Proof of Concept

```rust
#[tokio::test]
async fn test_unverified_future_epoch_commit_corruption() {
    // Setup consensus observer with current epoch = 10
    let current_epoch = 10;
    let current_round = 100;
    
    // Create malicious commit decision with future epoch
    let fake_epoch = current_epoch + 1;
    let fake_round = u64::MAX;
    let fake_commit = create_fake_commit_decision(fake_epoch, fake_round);
    
    // Send to observer (no signature verification will occur)
    observer.process_commit_decision_message(peer_id, Instant::now(), fake_commit);
    
    // Verify root is corrupted
    let (corrupted_epoch, corrupted_round) = observer.observer_block_data.lock().get_highest_committed_epoch_round();
    assert_eq!(corrupted_epoch, fake_epoch);
    assert_eq!(corrupted_round, fake_round);
    
    // Verify observer is stuck in state sync
    assert!(observer.state_sync_manager.is_syncing_to_commit());
    
    // Verify legitimate messages are now rejected as "stale"
    let legitimate_commit = create_legitimate_commit(current_epoch, current_round + 1);
    observer.process_commit_decision_message(peer_id, Instant::now(), legitimate_commit);
    // Message will be dropped at lines 453-457 because (current_epoch, current_round+1) < (fake_epoch, fake_round)
    
    // Observer remains permanently stuck
    assert!(observer.state_sync_manager.is_syncing_to_commit());
}
```

### Citations

**File:** consensus/src/consensus_observer/network/observer_message.rs (L352-364)
```rust
    pub fn epoch(&self) -> u64 {
        self.commit_proof.ledger_info().epoch()
    }

    /// Returns a reference to the commit proof block info
    pub fn proof_block_info(&self) -> &BlockInfo {
        self.commit_proof.commit_info()
    }

    /// Returns the round of the commit proof
    pub fn round(&self) -> Round {
        self.commit_proof.ledger_info().round()
    }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L179-188)
```rust
        // If state sync is syncing to a commit decision, we should wait for it to complete
        if self.state_sync_manager.is_syncing_to_commit() {
            info!(
                LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                    "Waiting for state sync to reach commit decision: {:?}!",
                    self.observer_block_data.lock().root().commit_info()
                ))
            );
            return;
        }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L448-450)
```rust
        // Get the commit decision epoch and round
        let commit_epoch = commit_decision.epoch();
        let commit_round = commit_decision.round();
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L452-461)
```rust
        // If the commit message is behind our highest committed block, ignore it
        let get_highest_committed_epoch_round = self
            .observer_block_data
            .lock()
            .get_highest_committed_epoch_round();
        if (commit_epoch, commit_round) <= get_highest_committed_epoch_round {
            // Update the metrics for the dropped commit decision
            update_metrics_for_dropped_commit_decision_message(peer_network_id, &commit_decision);
            return;
        }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L467-482)
```rust
        let epoch_state = self.get_epoch_state();
        if commit_epoch == epoch_state.epoch {
            // Verify the commit decision
            if let Err(error) = commit_decision.verify_commit_proof(&epoch_state) {
                // Log the error and update the invalid message counter
                error!(
                    LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                        "Failed to verify commit decision! Ignoring: {:?}, from peer: {:?}. Error: {:?}",
                        commit_decision.proof_block_info(),
                        peer_network_id,
                        error
                    ))
                );
                increment_invalid_message_counter(&peer_network_id, metrics::COMMIT_DECISION_LABEL);
                return;
            }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L500-527)
```rust
        // Otherwise, we failed to process the commit decision. If the commit
        // is for a future epoch or round, we need to state sync.
        let last_block = self.observer_block_data.lock().get_last_ordered_block();
        let epoch_changed = commit_epoch > last_block.epoch();
        if epoch_changed || commit_round > last_block.round() {
            // If we're waiting for state sync to transition into a new epoch,
            // we should just wait and not issue a new state sync request.
            if self.state_sync_manager.is_syncing_through_epoch() {
                info!(
                    LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                        "Already waiting for state sync to reach new epoch: {:?}. Dropping commit decision: {:?}!",
                        self.observer_block_data.lock().root().commit_info(),
                        commit_decision.proof_block_info()
                    ))
                );
                return;
            }

            // Otherwise, we should start the state sync process for the commit.
            // Update the block data (to the commit decision).
            self.observer_block_data
                .lock()
                .update_blocks_for_state_sync_commit(&commit_decision);

            // Start state syncing to the commit decision
            self.state_sync_manager
                .sync_to_commit(commit_decision, epoch_changed);
        }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L554-563)
```rust
                // If state sync is not syncing to a commit, forward the commit decision to the execution pipeline
                if !self.state_sync_manager.is_syncing_to_commit() {
                    info!(
                        LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                            "Forwarding commit decision to the execution pipeline: {}",
                            commit_decision.proof_block_info()
                        ))
                    );
                    self.forward_commit_decision(commit_decision.clone());
                }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L789-791)
```rust
            // If state sync is not syncing to a commit, finalize the ordered blocks
            if !self.state_sync_manager.is_syncing_to_commit() {
                self.finalize_ordered_block(ordered_block).await;
```

**File:** consensus/src/consensus_observer/observer/block_data.rs (L131-141)
```rust
    /// Returns the highest committed block epoch and round
    pub fn get_highest_committed_epoch_round(&self) -> (u64, Round) {
        if let Some(epoch_round) = self.ordered_block_store.get_highest_committed_epoch_round() {
            // Return the highest committed epoch and round
            epoch_round
        } else {
            // Return the root epoch and round
            let root_block_info = self.root.commit_info().clone();
            (root_block_info.epoch(), root_block_info.round())
        }
    }
```

**File:** consensus/src/consensus_observer/observer/block_data.rs (L275-282)
```rust
    pub fn update_blocks_for_state_sync_commit(&mut self, commit_decision: &CommitDecision) {
        // Get the commit proof, epoch and round
        let commit_proof = commit_decision.commit_proof();
        let commit_epoch = commit_decision.epoch();
        let commit_round = commit_decision.round();

        // Update the root
        self.update_root(commit_proof.clone());
```

**File:** consensus/src/consensus_observer/observer/block_data.rs (L299-302)
```rust
    /// Updates the root ledger info
    pub fn update_root(&mut self, new_root: LedgerInfoWithSignatures) {
        self.root = new_root;
    }
```

**File:** consensus/src/consensus_observer/observer/state_sync_manager.rs (L218-230)
```rust
                // Sync to the commit decision
                if let Err(error) = execution_client
                    .clone()
                    .sync_to_target(commit_decision.commit_proof().clone())
                    .await
                {
                    error!(
                        LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                            "Failed to sync to commit decision: {:?}! Error: {:?}",
                            commit_decision, error
                        ))
                    );
                    return;
```
