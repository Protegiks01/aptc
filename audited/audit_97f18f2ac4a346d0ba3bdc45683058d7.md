# Audit Report

## Title
Insufficient Module Name Validation Allows Non-ASCII Identifiers in BCS-Deserialized Transactions

## Summary
The post-deserialization validation for `EntryFunction` module names only checks for the presence of "::" but fails to validate that identifiers conform to Move's strict ASCII-only requirements, creating a validation gap that could enable Unicode homograph attacks and violate the documented identifier invariant.

## Finding Description

The Aptos codebase enforces that all Move identifiers must be ASCII-only (matching `[a-zA-Z0-9_$]`) to prevent Unicode normalization issues. [1](#0-0) 

However, when transactions are submitted via BCS encoding, a validation gap exists:

1. **BCS Deserialization bypasses validation**: The `Identifier` struct derives `Deserialize`, which deserializes the inner `Box<str>` directly without calling `Identifier::new()` or `Identifier::is_valid()`. [2](#0-1) 

2. **Incomplete post-deserialization validation**: After deserializing a `SignedTransaction`, the API calls `verify_module_identifier()` which only checks if the identifier contains "::" but does NOT validate ASCII-only requirements. [3](#0-2) 

3. **Invalid identifiers reach execution context**: The unvalidated module name flows through to `EntryFunctionPayload` and is exposed to Move code via `transaction_context::module_name()`. [4](#0-3) [5](#0-4) 

4. **Exposure in authentication flows**: Module names are used in constructing authentication messages for account abstraction. [6](#0-5) 

**Attack scenario**: An attacker crafts a BCS-encoded `SignedTransaction` with an `EntryFunction` payload where the module `Identifier` contains Unicode characters (e.g., Cyrillic "с" instead of Latin "c" in "сoin" vs "coin"). This bypasses validation and could be used for homograph attacks in user-facing contexts.

## Impact Explanation

**Severity: Medium to Low**

While this violates the documented invariant that identifiers must be ASCII-only, the practical exploitability is limited:

- **No direct fund loss**: Byte-level string comparisons in Move mean Unicode spoofs won't match legitimate module names
- **No consensus divergence**: All validators deserialize identical bytes deterministically  
- **Limited ACL bypass potential**: Move's standard string comparison is byte-level, preventing direct ACL bypasses
- **Primarily UX/display confusion**: Main risk is users being confused by lookalike module names in UI, which borders on social engineering (out of scope)

The issue represents a **defense-in-depth** failure rather than a critical exploitable vulnerability. It could potentially enable sophisticated phishing attacks if combined with other UX vulnerabilities, but lacks a concrete attack path for the critical/high severity impacts defined in the bug bounty program.

## Likelihood Explanation

**Likelihood: Low**

- Requires attacker to craft custom BCS-encoded transactions (moderate technical barrier)
- Exploitation requires victim to interact with malicious transactions displaying spoofed names
- Limited attack surface since Move smart contracts use byte-level comparisons
- Would primarily affect off-chain systems that display module names without proper validation

## Recommendation

Add proper identifier validation in `verify_module_identifier()`:

```rust
pub fn verify_module_identifier(module: &str) -> anyhow::Result<()> {
    if module.contains("::") {
        Err(format_err!("Identifier should not contain '::' {}", module))
    } else if !Identifier::is_valid(module) {
        Err(format_err!("Invalid Move module name: {}", module))
    } else {
        Ok(())
    }
}
```

This ensures that even BCS-deserialized identifiers are validated against Move's strict ASCII-only requirements, maintaining the documented invariant.

## Proof of Concept

```rust
// Proof of concept showing the validation gap
use aptos_types::transaction::EntryFunction;
use move_core_types::identifier::Identifier;
use move_core_types::language_storage::ModuleId;

// This would pass verify_module_identifier despite having non-ASCII
let invalid_module_name = "ϲoin"; // Greek omicron instead of Latin 'o'
assert!(!Identifier::is_valid(invalid_module_name));
assert!(verify_identifier(invalid_module_name).is_ok()); // Only checks for "::"

// If we could BCS-encode an Identifier with this string (bypassing Identifier::new),
// it would pass post-deserialization validation
```

## Notes

After thorough analysis, while this represents a **validation gap** that should be fixed for defense-in-depth, it does not constitute a **concrete exploitable vulnerability** meeting the high severity bar. The practical impact is limited to potential UX confusion rather than fund loss, consensus violation, or direct ACL bypass. The issue should be addressed to maintain code quality and prevent potential future exploitation vectors, but it is not immediately critical.

### Citations

**File:** third_party/move/move-core/types/src/identifier.rs (L20-23)
```rust
//! Allowed identifiers are currently restricted to ASCII due to unresolved issues with Unicode
//! normalization. See [Rust issue #55467](https://github.com/rust-lang/rust/issues/55467) and the
//! associated RFC for some discussion. Unicode identifiers may eventually be supported once these
//! issues are worked out.
```

**File:** third_party/move/move-core/types/src/identifier.rs (L109-114)
```rust
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, Deserialize)]
#[cfg_attr(
    any(test, feature = "fuzzing"),
    derive(arbitrary::Arbitrary, dearbitrary::Dearbitrary)
)]
pub struct Identifier(Box<str>);
```

**File:** api/types/src/move_types.rs (L1468-1477)
```rust
pub fn verify_identifier(identifier: &str) -> anyhow::Result<()> {
    if identifier.contains("::") {
        Err(format_err!(
            "Identifier should not contain '::' {}",
            identifier
        ))
    } else {
        Ok(())
    }
}
```

**File:** types/src/transaction/script.rs (L152-163)
```rust
    pub fn as_entry_function_payload(&self) -> EntryFunctionPayload {
        EntryFunctionPayload::new(
            self.module.address,
            self.module.name().to_string(),
            self.function.to_string(),
            self.ty_args
                .iter()
                .map(|ty| ty.to_canonical_string())
                .collect(),
            self.args.clone(),
        )
    }
```

**File:** aptos-move/framework/aptos-framework/sources/transaction_context.move (L152-155)
```text
    public fun module_name(payload: &EntryFunctionPayload): String {
        assert!(features::transaction_context_extension_enabled(), error::invalid_state(ETRANSACTION_CONTEXT_EXTENSION_NOT_ENABLED));
        payload.module_name
    }
```

**File:** aptos-move/framework/aptos-framework/sources/account/common_account_abstractions/common_account_abstractions_utils.move (L30-46)
```text
    public(friend) fun entry_function_name(entry_function_payload: &EntryFunctionPayload): vector<u8> {
        let entry_function_name = &mut vector[];
        let addr_str = string_utils::to_string(
            &transaction_context::account_address(entry_function_payload)
        ).bytes();
        // .slice(1) to remove the leading '@' char
        entry_function_name.append(addr_str.slice(1, addr_str.length()));
        entry_function_name.append(b"::");
        entry_function_name.append(
            *transaction_context::module_name(entry_function_payload).bytes()
        );
        entry_function_name.append(b"::");
        entry_function_name.append(
            *transaction_context::function_name(entry_function_payload).bytes()
        );
        *entry_function_name
    }
```
