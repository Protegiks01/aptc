# Audit Report

## Title
JWK Consensus State Corruption: Mismatched Proposal in Finished State Due to Race Condition

## Summary
The JWK consensus manager fails to validate that a received quorum-certified update matches the current proposal when transitioning from `InProgress` to `Finished` state. This allows a race condition where rapid consecutive JWK observations for the same issuer can result in the `Finished` state containing a `my_proposal` that differs from the `quorum_certified` update, causing state corruption and inconsistent validator behavior.

## Finding Description

The vulnerability exists in the `process_quorum_certified_update` function where the state transitions from `InProgress` to `Finished`: [1](#0-0) 

When a quorum-certified update is received, the function only checks that the consensus state is `InProgress` but does **not validate** that the current `my_proposal` matches the `update` being certified. This creates a critical race condition:

**Attack Scenario:**

1. **Time T1**: Validator observes JWK set A for issuer X, transitions to `InProgress` with `my_proposal.observed = A`
2. **Time T2**: Consensus begins via `start_produce(observed=A)`, creating aggregation state with `local_view = A`
3. **Time T3**: Quorum is reached, QC for A is produced and sent to `qc_update_tx` channel
4. **Time T4**: Before main loop processes the QC, issuer X updates JWKs to B
5. **Time T5**: Validator observes B, `process_new_observation` overwrites state to `InProgress` with `my_proposal.observed = B`
6. **Time T6**: Old `QuorumCertProcessGuard` is dropped, aborting consensus for A (but QC already in channel)
7. **Time T7**: Main loop processes QC for A via `process_quorum_certified_update`
8. **Time T8**: Function sees state is `InProgress` (with `my_proposal.observed = B`), transitions to `Finished`
9. **Time T9**: **State corruption**: `Finished` state now has `my_proposal.observed = B` but `quorum_certified.update = A`

The observation aggregation only accepts matching views: [2](#0-1) 

However, this validation occurs during aggregation, not when processing the final QC. Once the QC is produced and queued, there's no re-validation against the current state.

**Exploitation by Malicious OIDC Provider:**

An attacker controlling an OIDC provider (issuer) can deliberately trigger rapid JWK rotations to maximize the probability of this race condition:

1. Rapidly update JWKs served at the provider's configuration URL
2. Validator observers detect changes and trigger new consensus sessions
3. Race window exists between QC production and state updates
4. Multiple validators can enter inconsistent states simultaneously

**Resulting State Corruption:**

When peers request this validator's observation via `process_peer_request`: [3](#0-2) 

The validator responds with `my_proposal = B`, but has already submitted a `ValidatorTransaction` with QC for A. This breaks the invariant that a validator's advertised proposal matches what it certified and submitted.

## Impact Explanation

**Severity: HIGH**

This qualifies as a **Significant Protocol Violation** under the High Severity category because:

1. **State Consistency Violation**: Breaks the critical invariant that `my_proposal` in `Finished` state must equal `quorum_certified.update`. The validator's internal state no longer accurately reflects what was certified.

2. **Consensus Confusion**: Validators in `Finished` state with inconsistent proposals will respond to peer queries with incorrect observations. This can cause:
   - Peers attempting to build QCs for the same issuer to receive conflicting observations
   - Potential for validators to sign multiple different observations for the same issuer/epoch
   - Confusion during state synchronization and recovery

3. **Protocol Integrity**: While not directly causing funds loss or network partition, this violates the deterministic execution and state consistency invariants that underpin validator consensus reliability.

4. **JWK Authentication Impact**: JWKs are used for OIDC authentication. Inconsistent JWK states across validators could lead to authentication inconsistencies, where different validators have different views of valid keys for user authentication.

## Likelihood Explanation

**Likelihood: MEDIUM-HIGH**

The vulnerability is realistic and can occur through:

1. **Natural Occurrence**: Legitimate OIDC providers may perform rapid JWK rotations during key compromise incidents or maintenance windows, naturally triggering the race condition without malicious intent.

2. **Deliberate Exploitation**: An attacker controlling an OIDC provider (either malicious or compromised) can deliberately trigger rapid rotations to exploit this race with high probability.

3. **Race Window**: The channel uses `QueueStyle::KLAST` with size 1, but the race window exists between:
   - QC production completing and pushing to channel
   - New observation arriving and overwriting state
   - Main loop selecting which event to process next via `tokio::select!`

4. **No Attacker Privileges Required**: Exploitation only requires control of an OIDC provider endpoint, not validator access or stake.

## Recommendation

Add validation in `process_quorum_certified_update` to ensure the received QC matches the current proposal:

```rust
pub fn process_quorum_certified_update(&mut self, update: QuorumCertifiedUpdate) -> Result<()> {
    let issuer = update.update.issuer.clone();
    info!(
        epoch = self.epoch_state.epoch,
        issuer = String::from_utf8(issuer.clone()).ok(),
        version = update.update.version,
        "JWKManager processing certified update."
    );
    let state = self.states_by_issuer.entry(issuer.clone()).or_default();
    match &state.consensus_state {
        ConsensusState::InProgress { my_proposal, .. } => {
            // VALIDATION: Ensure the QC matches our current proposal
            if my_proposal.observed != update.update {
                return Err(anyhow!(
                    "qc update mismatch for issuer {:?}: my_proposal version {} != qc version {}",
                    String::from_utf8(issuer.clone()),
                    my_proposal.observed.version,
                    update.update.version
                ));
            }
            
            let txn = ValidatorTransaction::ObservedJWKUpdate(update.clone());
            let vtxn_guard =
                self.vtxn_pool
                    .put(Topic::JWK_CONSENSUS(issuer.clone()), Arc::new(txn), None);
            state.consensus_state = ConsensusState::Finished {
                vtxn_guard,
                my_proposal: my_proposal.clone(),
                quorum_certified: update.clone(),
            };
            info!(
                epoch = self.epoch_state.epoch,
                issuer = String::from_utf8(issuer).ok(),
                version = update.update.version,
                "certified update accepted."
            );
            Ok(())
        },
        _ => Err(anyhow!(
            "qc update not expected for issuer {:?} in state {}",
            String::from_utf8(issuer.clone()),
            state.consensus_state.name()
        )),
    }
}
```

Additionally, consider draining the `qc_update_rx` channel when overwriting state in `process_new_observation` to discard stale QCs.

## Proof of Concept

```rust
#[tokio::test]
async fn test_jwk_manager_state_corruption_race() {
    // Setup validators
    let private_keys: Vec<Arc<PrivateKey>> = (0..4)
        .map(|_| Arc::new(PrivateKey::generate_for_testing()))
        .collect();
    let public_keys: Vec<PublicKey> = private_keys
        .iter()
        .map(|sk| PublicKey::from(sk.as_ref()))
        .collect();
    let addrs: Vec<AccountAddress> = (0..4).map(|_| AccountAddress::random()).collect();
    let validator_consensus_infos: Vec<ValidatorConsensusInfo> = (0..4)
        .map(|i| ValidatorConsensusInfo::new(addrs[i], public_keys[i].clone(), 1))
        .collect();
    let epoch_state = Arc::new(EpochState {
        epoch: 999,
        verifier: ValidatorVerifier::new(validator_consensus_infos).into(),
    });

    let vtxn_pool = VTxnPoolState::default();
    let update_certifier = DummyUpdateCertifier::default();
    let mut jwk_manager = IssuerLevelConsensusManager::new(
        private_keys[0].clone(),
        addrs[0],
        epoch_state.clone(),
        Arc::new(update_certifier),
        vtxn_pool.clone(),
    );

    let issuer = issuer_from_str("https://example.com");
    
    // Initialize with on-chain state version 1
    let initial_jwks = vec![JWK::Unsupported(UnsupportedJWK::new_for_testing("key1", "v1")).into()];
    jwk_manager.reset_with_on_chain_state(AllProvidersJWKs {
        entries: vec![ProviderJWKs {
            issuer: issuer.clone(),
            version: 1,
            jwks: initial_jwks,
        }],
    }).unwrap();

    // Step 1: Observe new JWKs version 2 (observation A)
    let jwks_v2 = vec![JWK::Unsupported(UnsupportedJWK::new_for_testing("key2", "v2")).into()];
    jwk_manager.process_new_observation(issuer.clone(), jwks_v2.clone()).unwrap();
    
    // Verify state is InProgress with version 2
    let state_after_v2 = &jwk_manager.states_by_issuer[&issuer];
    assert!(matches!(state_after_v2.consensus_state, ConsensusState::InProgress { .. }));
    let proposal_v2 = state_after_v2.consensus_state.my_proposal_cloned();
    assert_eq!(proposal_v2.observed.version, 2);

    // Step 2: Simulate QC for version 2 being produced
    let qc_v2 = QuorumCertifiedUpdate {
        update: proposal_v2.observed.clone(),
        multi_sig: create_dummy_multisig(&private_keys, &proposal_v2.observed),
    };

    // Step 3: Before processing QC, observe version 3 (observation B)
    let jwks_v3 = vec![JWK::Unsupported(UnsupportedJWK::new_for_testing("key3", "v3")).into()];
    jwk_manager.process_new_observation(issuer.clone(), jwks_v3.clone()).unwrap();
    
    // State is now InProgress with version 3
    let state_after_v3 = &jwk_manager.states_by_issuer[&issuer];
    let proposal_v3 = state_after_v3.consensus_state.my_proposal_cloned();
    assert_eq!(proposal_v3.observed.version, 3);

    // Step 4: Process the stale QC for version 2
    jwk_manager.process_quorum_certified_update(qc_v2.clone()).unwrap();

    // Step 5: Verify STATE CORRUPTION
    let final_state = &jwk_manager.states_by_issuer[&issuer];
    match &final_state.consensus_state {
        ConsensusState::Finished { my_proposal, quorum_certified, .. } => {
            // BUG: my_proposal is version 3, but quorum_certified is version 2!
            assert_eq!(my_proposal.observed.version, 3, "my_proposal should be v3");
            assert_eq!(quorum_certified.update.version, 2, "quorum_certified should be v2");
            
            // This demonstrates the state corruption
            assert_ne!(
                my_proposal.observed, 
                quorum_certified.update,
                "STATE CORRUPTION: my_proposal differs from certified update"
            );
        },
        _ => panic!("Expected Finished state"),
    }
}

fn create_dummy_multisig(keys: &[Arc<PrivateKey>], payload: &ProviderJWKs) -> AggregateSignature {
    let sigs: Vec<Signature> = keys.iter().map(|k| k.sign(payload).unwrap()).collect();
    let bit_vec = BitVec::from(vec![true; keys.len()]);
    AggregateSignature::new(bit_vec, Some(Signature::aggregate(sigs).unwrap()))
}
```

This test demonstrates that the validator ends up in `Finished` state with `my_proposal.observed.version = 3` but `quorum_certified.update.version = 2`, proving the state corruption vulnerability.

## Notes

The vulnerability specifically affects the JWK consensus subsystem used for OIDC authentication. While not directly causing fund loss, it represents a significant protocol violation that can lead to validator state inconsistencies and consensus confusion. The issue is exploitable by anyone controlling an OIDC provider endpoint and can occur naturally during legitimate key rotation scenarios. The recommended fix adds critical validation to ensure state machine consistency.

### Citations

**File:** crates/aptos-jwk-consensus/src/jwk_manager/mod.rs (L294-320)
```rust
    pub fn process_peer_request(&mut self, rpc_req: IncomingRpcRequest) -> Result<()> {
        let IncomingRpcRequest {
            msg,
            mut response_sender,
            ..
        } = rpc_req;
        match msg {
            JWKConsensusMsg::ObservationRequest(request) => {
                let state = self.states_by_issuer.entry(request.issuer).or_default();
                let response: Result<JWKConsensusMsg> = match &state.consensus_state {
                    ConsensusState::NotStarted => Err(anyhow!("observed update unavailable")),
                    ConsensusState::InProgress { my_proposal, .. }
                    | ConsensusState::Finished { my_proposal, .. } => Ok(
                        JWKConsensusMsg::ObservationResponse(ObservedUpdateResponse {
                            epoch: self.epoch_state.epoch,
                            update: my_proposal.clone(),
                        }),
                    ),
                };
                response_sender.send(response);
                Ok(())
            },
            _ => {
                bail!("unexpected rpc: {}", msg.name());
            },
        }
    }
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager/mod.rs (L323-358)
```rust
    pub fn process_quorum_certified_update(&mut self, update: QuorumCertifiedUpdate) -> Result<()> {
        let issuer = update.update.issuer.clone();
        info!(
            epoch = self.epoch_state.epoch,
            issuer = String::from_utf8(issuer.clone()).ok(),
            version = update.update.version,
            "JWKManager processing certified update."
        );
        let state = self.states_by_issuer.entry(issuer.clone()).or_default();
        match &state.consensus_state {
            ConsensusState::InProgress { my_proposal, .. } => {
                //TODO: counters
                let txn = ValidatorTransaction::ObservedJWKUpdate(update.clone());
                let vtxn_guard =
                    self.vtxn_pool
                        .put(Topic::JWK_CONSENSUS(issuer.clone()), Arc::new(txn), None);
                state.consensus_state = ConsensusState::Finished {
                    vtxn_guard,
                    my_proposal: my_proposal.clone(),
                    quorum_certified: update.clone(),
                };
                info!(
                    epoch = self.epoch_state.epoch,
                    issuer = String::from_utf8(issuer).ok(),
                    version = update.update.version,
                    "certified update accepted."
                );
                Ok(())
            },
            _ => Err(anyhow!(
                "qc update not expected for issuer {:?} in state {}",
                String::from_utf8(issuer.clone()),
                state.consensus_state.name()
            )),
        }
    }
```

**File:** crates/aptos-jwk-consensus/src/observation_aggregation/mod.rs (L82-84)
```rust
            self.local_view == peer_view,
            "adding peer observation failed with mismatched view"
        );
```
