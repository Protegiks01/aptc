# Audit Report

## Title
Missing Hook Invocations in Sequential Execution Error Paths Can Cause State Inconsistency and Node Crashes in Sharded Execution

## Summary
In sequential execution, the transaction commit hook system has critical gaps: (1) `PanicError` failures during success-path materialization skip all hook invocations, creating state tracking inconsistencies, and (2) the `CrossShardCommitSender` hook implementation has `on_execution_aborted` marked as `todo!()`, which will panic and crash validator nodes if sequential fallback execution encounters aborts during sharded block execution.

## Finding Description

The `TransactionCommitHook` interface defines two methods for tracking transaction lifecycle: `on_transaction_committed` for successful transactions and `on_execution_aborted` for failures. [1](#0-0) 

### Issue 1: Missing Hooks for Materialization Errors

In sequential execution, when `execute_transaction` returns `Success` or `SkipRest`, multiple materialization operations can fail with `PanicError`: [2](#0-1) 

The function performs numerous error-prone operations including `before_materialization()`, `apply_output_sequential()`, delayed field materialization, and resource group serialization. [3](#0-2) 

If ANY of these operations fail with `PanicError`, the function returns immediately via the `?` operator WITHOUT calling any hook. The `on_transaction_committed` hook is only called after ALL operations succeed: [4](#0-3) 

In contrast, explicit VM-level errors (Abort, DelayedFieldsCodeInvariantError, SpeculativeExecutionAbortError) explicitly invoke `on_execution_aborted` before returning: [5](#0-4) [6](#0-5) [7](#0-6) 

This creates an inconsistency where some error paths notify hooks while others silently skip notification.

### Issue 2: Unimplemented Hook Method Causes Node Crashes

The `CrossShardCommitSender` implementation used in sharded block execution has `on_execution_aborted` marked as unimplemented: [8](#0-7) 

During sharded execution, if parallel execution fails and falls back to sequential execution, any transaction abort will trigger a call to this unimplemented method, causing a panic and crashing the validator node.

### Issue 3: Parallel vs Sequential Inconsistency

In parallel execution, the `notify_listener` method treats `SpeculativeExecutionAbortError` and `DelayedFieldsCodeInvariantError` as fatal errors that return `PanicError` without calling hooks: [9](#0-8) 

This differs from sequential execution, which explicitly calls `on_execution_aborted` for these same error types, creating non-deterministic hook behavior depending on execution mode.

## Impact Explanation

**High Severity** - This issue qualifies as "significant protocol violations" under the Aptos bug bounty program:

1. **Node Availability**: The unimplemented `on_execution_aborted` in sharded execution can crash validator nodes during sequential fallback, causing validator downtime and potentially affecting network liveness if multiple validators are impacted.

2. **State Inconsistency**: Missing hook invocations break the contract that external systems can rely on hook notifications for all transaction outcomes. For `CrossShardCommitSender`, this means dependent shards may not receive abort notifications, potentially causing:
   - Deadlocks waiting for cross-shard dependencies
   - Incorrect state on dependent shards
   - Non-deterministic execution across shards

3. **Deterministic Execution Violation**: The parallel vs sequential inconsistency means the same block executed in different modes produces different hook invocation patterns, violating the deterministic execution invariant.

## Likelihood Explanation

**High Likelihood**:

1. **Materialization errors occur in practice**: `PanicError` during materialization can be triggered by:
   - Resource group serialization failures (explicit fallback handling exists at line 2321-2408)
   - Delayed field resolution errors
   - State inconsistencies during concurrent operations

2. **Sequential fallback is common**: BlockSTM falls back to sequential execution when parallel execution encounters issues (high incarnation counts, VM errors, etc.)

3. **Sharded execution is production code**: The `CrossShardCommitSender` exists in the codebase for real sharded execution scenarios, making the crash vulnerability immediately exploitable when sharded blocks are used.

## Recommendation

**Fix 1: Ensure hooks are called for ALL error paths in sequential execution**

Add hook invocation before returning from materialization errors:

```rust
// After line 2269, wrap in Result and handle errors
let output_before_guard = match output.before_materialization() {
    Ok(guard) => guard,
    Err(e) => {
        if let Some(commit_hook) = &self.transaction_commit_hook {
            commit_hook.on_execution_aborted(idx as TxnIndex);
        }
        return Err(e.into());
    }
};

// Similarly for all other error-prone operations through line 2491
```

**Fix 2: Implement `on_execution_aborted` for `CrossShardCommitSender`**

Replace the `todo!()` with proper cross-shard abort notification:

```rust
fn on_execution_aborted(&self, txn_idx: TxnIndex) {
    let global_txn_idx = txn_idx + self.index_offset;
    if self.dependent_edges.contains_key(&global_txn_idx) {
        self.send_remote_abort_for_failure(global_txn_idx);
    }
}
```

**Fix 3: Align parallel and sequential hook behavior**

Ensure `SpeculativeExecutionAbortError` and `DelayedFieldsCodeInvariantError` are handled consistently across both execution modes, either by calling hooks in both cases or neither.

## Proof of Concept

**PoC 1: Sequential Execution Missing Hook Call**

```rust
// Test that demonstrates missing hook call on materialization error
#[test]
fn test_sequential_execution_skips_hook_on_materialization_error() {
    // Setup: Create a block executor with a tracking commit hook
    let mut hook_calls = Arc::new(Mutex::new(Vec::new()));
    let hook_calls_clone = hook_calls.clone();
    
    struct TrackingHook {
        calls: Arc<Mutex<Vec<String>>>,
    }
    
    impl TransactionCommitHook for TrackingHook {
        fn on_transaction_committed(&self, txn_idx: TxnIndex, _output: &OnceCell<TransactionOutput>) {
            self.calls.lock().unwrap().push(format!("committed:{}", txn_idx));
        }
        
        fn on_execution_aborted(&self, txn_idx: TxnIndex) {
            self.calls.lock().unwrap().push(format!("aborted:{}", txn_idx));
        }
    }
    
    let executor = BlockExecutor::new(
        config,
        Some(Arc::new(TrackingHook { calls: hook_calls_clone }))
    );
    
    // Create a transaction that will succeed at VM level but fail during materialization
    // (e.g., by causing resource group serialization error)
    let txn = craft_transaction_with_serialization_issue();
    
    let result = executor.execute_transactions_sequential(
        &signature_verified_block,
        &base_view,
        &transaction_slice_metadata,
        &mut module_cache_manager_guard,
        false
    );
    
    // Verify: Execution fails but hook was NOT called
    assert!(result.is_err());
    let calls = hook_calls.lock().unwrap();
    assert!(calls.is_empty(), "Expected no hook calls but got: {:?}", calls);
    // BUG: Hook should have been called with on_execution_aborted
}
```

**PoC 2: Node Crash on Sharded Sequential Fallback**

```rust
// Test that demonstrates node crash when using CrossShardCommitSender
// with sequential execution fallback
#[test]
#[should_panic(expected = "not supported for sharded execution yet")]
fn test_sharded_execution_panics_on_sequential_abort() {
    // Setup: Create executor with CrossShardCommitSender hook
    let cross_shard_sender = CrossShardCommitSender::new(/* params */);
    let executor = BlockExecutor::new(
        config,
        Some(Arc::new(cross_shard_sender))
    );
    
    // Create a transaction that will abort at VM level
    let txn = create_aborting_transaction();
    
    // Execute in sequential mode (simulating parallel â†’ sequential fallback)
    let result = executor.execute_transactions_sequential(
        &signature_verified_block,
        &base_view,
        &transaction_slice_metadata,
        &mut module_cache_manager_guard,
        false
    );
    
    // BUG: This will panic with "not supported for sharded execution yet"
    // instead of gracefully handling the abort
}
```

## Notes

The vulnerability exists because the sequential execution path evolved to handle multiple error types explicitly (VM-level errors) but failed to ensure consistency for all error paths (materialization errors). The parallel execution path has a different approach, creating a critical inconsistency.

The unimplemented `on_execution_aborted` in `CrossShardCommitSender` is particularly severe as it directly causes node crashes, qualifying this as a high-severity issue affecting validator availability.

This issue breaks the **State Consistency** and **Deterministic Execution** invariants by allowing different execution modes to produce different hook notification patterns for the same transactions.

### Citations

**File:** aptos-move/block-executor/src/txn_commit_hook.rs (L11-15)
```rust
pub trait TransactionCommitHook: Send + Sync {
    fn on_transaction_committed(&self, txn_idx: TxnIndex, output: &OnceCell<TransactionOutput>);

    fn on_execution_aborted(&self, txn_idx: TxnIndex);
}
```

**File:** aptos-move/block-executor/src/executor.rs (L2237-2248)
```rust
                ExecutionStatus::Abort(err) => {
                    if let Some(commit_hook) = &self.transaction_commit_hook {
                        commit_hook.on_execution_aborted(idx as TxnIndex);
                    }
                    error!(
                        "Sequential execution FatalVMError by transaction {}",
                        idx as TxnIndex
                    );
                    // Record the status indicating the unrecoverable VM failure.
                    return Err(SequentialBlockExecutionError::ErrorToReturn(
                        BlockExecutionError::FatalVMError(err),
                    ));
```

**File:** aptos-move/block-executor/src/executor.rs (L2250-2257)
```rust
                ExecutionStatus::DelayedFieldsCodeInvariantError(msg) => {
                    if let Some(commit_hook) = &self.transaction_commit_hook {
                        commit_hook.on_execution_aborted(idx as TxnIndex);
                    }
                    alert!("Sequential execution DelayedFieldsCodeInvariantError error by transaction {}: {}", idx as TxnIndex, msg);
                    return Err(SequentialBlockExecutionError::ErrorToReturn(
                        BlockExecutionError::FatalBlockExecutorError(code_invariant_error(msg)),
                    ));
```

**File:** aptos-move/block-executor/src/executor.rs (L2259-2266)
```rust
                ExecutionStatus::SpeculativeExecutionAbortError(msg) => {
                    if let Some(commit_hook) = &self.transaction_commit_hook {
                        commit_hook.on_execution_aborted(idx as TxnIndex);
                    }
                    alert!("Sequential execution SpeculativeExecutionAbortError error by transaction {}: {}", idx as TxnIndex, msg);
                    return Err(SequentialBlockExecutionError::ErrorToReturn(
                        BlockExecutionError::FatalBlockExecutorError(code_invariant_error(msg)),
                    ));
```

**File:** aptos-move/block-executor/src/executor.rs (L2268-2269)
```rust
                ExecutionStatus::Success(mut output) | ExecutionStatus::SkipRest(mut output) => {
                    let output_before_guard = output.before_materialization()?;
```

**File:** aptos-move/block-executor/src/executor.rs (L2413-2442)
```rust
                    Self::apply_output_sequential(
                        idx as TxnIndex,
                        runtime_environment,
                        module_cache_manager_guard.module_cache(),
                        &unsync_map,
                        &output_before_guard,
                        resource_write_set.clone(),
                    )?;

                    // If dynamic change set materialization part (indented for clarity/variable scope):
                    {
                        let finalized_groups = groups_to_finalize!(output_before_guard,)
                            .map(|((group_key, metadata_op), is_read_needing_exchange)| {
                                let (group_ops_iter, group_size) =
                                    unsync_map.finalize_group(&group_key);
                                map_finalized_group::<T>(
                                    group_key,
                                    group_ops_iter.collect(),
                                    group_size,
                                    metadata_op,
                                    is_read_needing_exchange,
                                )
                            })
                            .collect::<Result<Vec<_>, _>>()?;
                        let materialized_finalized_groups =
                            map_id_to_values_in_group_writes(finalized_groups, &latest_view)?;
                        let serialized_groups =
                            serialize_groups::<T>(materialized_finalized_groups).map_err(|_| {
                                SequentialBlockExecutionError::ResourceGroupSerializationError
                            })?;
```

**File:** aptos-move/block-executor/src/executor.rs (L2493-2496)
```rust
                    if let Some(commit_hook) = &self.transaction_commit_hook {
                        commit_hook
                            .on_transaction_committed(idx as TxnIndex, output.committed_output());
                    }
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/cross_shard_client.rs (L149-151)
```rust
    fn on_execution_aborted(&self, _txn_idx: TxnIndex) {
        todo!("on_transaction_aborted not supported for sharded execution yet")
    }
```

**File:** aptos-move/block-executor/src/txn_last_input_output.rs (L429-436)
```rust
            OutputStatusKind::SpeculativeExecutionAbortError
            | OutputStatusKind::DelayedFieldsCodeInvariantError
            | OutputStatusKind::None => {
                return Err(code_invariant_error(format!(
                    "Unexpected output status kind {:?}",
                    output_wrapper.output_status_kind
                )));
            },
```
