# Audit Report

## Title
World-Readable Identity YAML Files Enable Private Key Leakage via Editor Backup Files in Test Environments

## Summary
The `write_yaml` helper function in `crates/aptos-genesis/src/builder.rs` creates identity YAML files containing sensitive validator private keys without setting explicit restrictive permissions. On systems with default umask 022, these files are created with world-readable permissions (644), and text editor backup files inherit these permissions, enabling local attackers to steal consensus and network private keys.

## Finding Description

The Aptos codebase has two distinct code paths for creating validator identity YAML files:

**Secure Path (Production):** [1](#0-0) 

This path uses `write_to_user_only_file` which sets Unix file permissions to 0600 (user-only read/write): [2](#0-1) 

**Vulnerable Path (Test/Development):** [3](#0-2) 

This `write_yaml` function uses `File::create()` without setting explicit permissions, relying on the system's default umask. It is called to write critical identity files: [4](#0-3) 

These identity files contain highly sensitive cryptographic material: [5](#0-4) 

The vulnerable code path is used by: [6](#0-5) 

**Attack Vector - Editor Backup Files:**
1. On systems with default umask 022, files are created with permissions 644 (rw-r--r--)
2. When users edit these files, text editors create backup/temporary files:
   - vim: `.validator-identity.yaml.swp`, `validator-identity.yaml~`
   - emacs: `validator-identity.yaml~`, `#validator-identity.yaml#`
   - nano: `validator-identity.yaml.save`
3. These backup files inherit the world-readable permissions
4. Backup files may persist after editing, even if editors crash
5. Local attacker (different user account) reads these files and obtains private keys

## Impact Explanation

This vulnerability qualifies as **Low Severity** per Aptos bug bounty criteria ("Minor information leaks"). While the compromised keys are critical (consensus private keys, network private keys, account private keys), the impact is limited because:

1. **Scope limitation**: Only affects test/development environments (`aptos-node --test`), not production deployments
2. **Local access requirement**: Attacker must have shell access as a different user on the same system
3. **Existing mitigation**: Production validator deployments use the secure CLI path with proper permissions

However, the leaked keys could enable:
- Impersonation of test validators
- Signing malicious consensus messages in test networks
- Disruption of development/testing infrastructure
- Potential validator slashing if test keys are mistakenly used in production

## Likelihood Explanation

**Medium likelihood** in affected environments:
- Common default umask (022) makes files world-readable by default
- Developers frequently edit configuration files
- Text editors universally create backup files
- Multi-user development systems are common
- Docker containers often run with shared volumes

**Low likelihood** of production impact:
- Production deployments use the secure CLI path with 0600 permissions
- Production systems typically use dedicated user accounts
- Kubernetes secrets provide additional isolation

## Recommendation

Replace the `write_yaml` function with a secure alternative that explicitly sets restrictive permissions:

```rust
#[cfg(unix)]
use std::os::unix::fs::OpenOptionsExt;

fn write_yaml_secure<T: Serialize>(path: &Path, object: &T) -> anyhow::Result<()> {
    let yaml_content = serde_yaml::to_string(object)?;
    
    let mut opts = OpenOptions::new();
    opts.write(true).create(true).truncate(true);
    
    #[cfg(unix)]
    opts.mode(0o600);
    
    let mut file = opts.open(path)?;
    file.write_all(yaml_content.as_bytes())?;
    Ok(())
}
```

Apply this change to: [4](#0-3) 

Alternatively, reuse the existing `write_to_user_only_file` function from the utilities module.

## Proof of Concept

**Reproduction Steps:**

1. Start aptos-node in test mode on a Linux system with default umask 022:
```bash
cargo run -p aptos-node -- --test
```

2. Check file permissions of generated identity files:
```bash
ls -la /tmp/test_dir/0/validator-identity.yaml
# Expected output: -rw-r--r-- (world-readable due to default umask)
```

3. Simulate editor backup file creation:
```bash
cp /tmp/test_dir/0/validator-identity.yaml /tmp/test_dir/0/validator-identity.yaml~
ls -la /tmp/test_dir/0/validator-identity.yaml~
# Backup file inherits world-readable permissions
```

4. As a different user, read the backup file:
```bash
sudo -u otheruser cat /tmp/test_dir/0/validator-identity.yaml~
# Successfully reads consensus_private_key and other sensitive keys
```

**Expected Secure Behavior:**
Files should be created with mode 0600 (rw-------), preventing other users from reading the private keys.

## Notes

While this vulnerability primarily affects test/development environments rather than production deployments, it violates security best practices and defense-in-depth principles. Sensitive cryptographic material should always be protected with explicit restrictive permissions, regardless of the deployment context. The existing secure code path in the CLI tools demonstrates that the codebase authors understand this requirement, but the builder path was overlooked.

### Citations

**File:** crates/aptos/src/genesis/keys.rs (L82-97)
```rust
        write_to_user_only_file(
            private_keys_file.as_path(),
            PRIVATE_KEYS_FILE,
            to_yaml(&private_identity)?.as_bytes(),
        )?;
        write_to_user_only_file(
            public_keys_file.as_path(),
            PUBLIC_KEYS_FILE,
            to_yaml(&public_identity)?.as_bytes(),
        )?;
        write_to_user_only_file(
            validator_file.as_path(),
            VALIDATOR_FILE,
            to_yaml(&validator_blob)?.as_bytes(),
        )?;
        write_to_user_only_file(vfn_file.as_path(), VFN_FILE, to_yaml(&vfn_blob)?.as_bytes())?;
```

**File:** crates/aptos/src/common/utils.rs (L224-229)
```rust
pub fn write_to_user_only_file(path: &Path, name: &str, bytes: &[u8]) -> CliTypedResult<()> {
    let mut opts = OpenOptions::new();
    #[cfg(unix)]
    opts.mode(0o600);
    write_to_file_with_opts(path, name, bytes, &mut opts)
}
```

**File:** crates/aptos-genesis/src/builder.rs (L145-148)
```rust
            write_yaml(val_identity_file.as_path(), &validator_identity)?;
            write_yaml(vfn_identity_file.as_path(), &vfn_identity)?;
            write_yaml(private_identity_file.as_path(), &private_identity)?;
            write_yaml(public_identity_file.as_path(), &public_identity)?;
```

**File:** crates/aptos-genesis/src/builder.rs (L418-421)
```rust
fn write_yaml<T: Serialize>(path: &Path, object: &T) -> anyhow::Result<()> {
    File::create(path)?.write_all(serde_yaml::to_string(object)?.as_bytes())?;
    Ok(())
}
```

**File:** config/src/config/identity_config.rs (L24-37)
```rust
#[derive(Deserialize, Serialize)]
pub struct IdentityBlob {
    /// Optional account address. Used for validators and validator full nodes
    #[serde(skip_serializing_if = "Option::is_none")]
    pub account_address: Option<AccountAddress>,
    /// Optional account key. Only used for validators
    #[serde(skip_serializing_if = "Option::is_none")]
    pub account_private_key: Option<Ed25519PrivateKey>,
    /// Optional consensus key. Only used for validators
    #[serde(skip_serializing_if = "Option::is_none")]
    pub consensus_private_key: Option<bls12381::PrivateKey>,
    /// Network private key. Peer id is derived from this if account address is not present
    pub network_private_key: x25519::PrivateKey,
}
```

**File:** aptos-node/src/lib.rs (L585-616)
```rust
    let builder = aptos_genesis::builder::Builder::new(test_dir, framework.clone())?
        .with_init_config(Some(Arc::new(move |_, config, _| {
            *config = node_config.clone();
        })))
        .with_init_genesis_config(Some(Arc::new(|genesis_config| {
            genesis_config.allow_new_validators = true;
            genesis_config.epoch_duration_secs = EPOCH_LENGTH_SECS;
            genesis_config.recurring_lockup_duration_secs = 7200;

            match env::var("ENABLE_KEYLESS_DEFAULT") {
                Ok(val) if val.as_str() == "1" => {
                    let response = ureq::get("https://api.devnet.aptoslabs.com/v1/accounts/0x1/resource/0x1::keyless_account::Groth16VerificationKey").call();
                    let json: Value = response.into_json().expect("Failed to parse JSON");
                    configure_keyless_with_vk(genesis_config, json).unwrap();
                },
                _ => {},
            };

            if let Ok(url) = env::var("INSTALL_KEYLESS_GROTH16_VK_FROM_URL") {
                let response = ureq::get(&url).call();
                let json: Value = response.into_json().expect("Failed to parse JSON");
                configure_keyless_with_vk(genesis_config, json).unwrap();
            };

            if let Ok(path) = env::var("INSTALL_KEYLESS_GROTH16_VK_FROM_PATH") {
                let file_content = fs::read_to_string(&path).unwrap_or_else(|_| panic!("Failed to read verification key file: {}", path));
                let json: Value = serde_json::from_str(&file_content).expect("Failed to parse JSON");
                configure_keyless_with_vk(genesis_config, json).unwrap();
            };
        })))
        .with_randomize_first_validator_ports(random_ports);
    let (root_key, _genesis, genesis_waypoint, mut validators) = builder.build(rng)?;
```
