# Audit Report

## Title
Out-of-Bounds Panic in DKG Sigma Protocol Verification Causes Network-Wide Validator Crash

## Summary
The `WeightedHomomorphism::msm_terms()` function does not validate that input witness dimensions match the homomorphism's encryption key count before array access, allowing a malicious DKG dealer to craft a transcript with mismatched dimensions that causes all validators to panic during verification, resulting in complete loss of network liveness.

## Finding Description

The vulnerability exists in the DKG sigma protocol verification flow, specifically in how `msm_terms()` processes witness structures without dimension validation.

**Location 1 - Missing Bounds Check:** [1](#0-0) 

The `msm_terms()` function iterates over `input.plaintext_chunks` and accesses `self.eks[i]` at line 237 without validating that `i < self.eks.len()`. If a malicious prover provides a witness with more elements in `plaintext_chunks` than encryption keys exist, this causes an out-of-bounds panic.

**Location 2 - No Pre-Verification Validation:** [2](#0-1) 

During verification at line 124, the function calls `self.msm_terms(&proof.z)` where `proof.z` is a deserialized `WeightedWitness` from the proof. No validation occurs to ensure `proof.z` has correct dimensions before this call.

**Location 3 - Transcript Verification Entry Point:** [3](#0-2) 

When validators verify a DKG transcript, the homomorphism is constructed with the correct number of encryption keys (from actual validator set), but the proof contains an arbitrary witness structure from the attacker.

**Attack Path:**

1. Malicious dealer constructs a `WeightedWitness` where `plaintext_chunks.len() > expected_number_of_players`
2. Dealer creates a sigma protocol proof containing this malformed witness as `z`
3. Dealer broadcasts the DKG transcript to all validators
4. Each validator deserializes the transcript and calls `verify()` 
5. Verification calls `msm_terms(&proof.z)` with the malformed witness
6. At line 237 of `chunked_elgamal.rs`, the code accesses `self.eks[i]` where `i >= self.eks.len()`
7. Rust panics with index out of bounds error
8. **All validators crash simultaneously**, halting consensus

This breaks the **Deterministic Execution** invariant because instead of all validators deterministically rejecting an invalid proof, they all crash with a panic. It also breaks **Consensus Safety** by causing a network-wide outage.

## Impact Explanation

**Critical Severity** per Aptos bug bounty program - **Total loss of liveness/network availability**:

- All validators attempting to verify the malicious DKG transcript will panic and crash
- The panic occurs at the same deterministic point, so all nodes fail together
- DKG cannot proceed, blocking epoch transitions and randomness generation
- Requires emergency intervention (binary patch and restart) to recover
- Attacker only needs ability to submit a DKG transcript (no special privileges)
- Single malicious transcript can halt the entire network

This meets the Critical severity criteria: "Total loss of liveness/network availability" and "Non-recoverable network partition (requires hardfork)" since normal recovery procedures cannot prevent validators from re-panicking when processing the malicious transcript in the ledger history.

## Likelihood Explanation

**High likelihood of exploitation:**

- Attack requires only crafting a malformed witness structure and broadcasting it
- No validator collusion or stake required
- Trivial to construct the malicious input (just add extra elements to `plaintext_chunks`)
- Guaranteed success - all validators will crash deterministically
- Single attack vector can repeatedly halt the network if malicious transcripts are rebroadcast

The attack is easily reproducible and has deterministic effect across all validators, making it a severe availability vulnerability.

## Recommendation

Add dimension validation in `WeightedHomomorphism::msm_terms()` before array access:

```rust
fn msm_terms(&self, input: &Self::Domain) -> Self::CodomainShape<Self::MsmInput> {
    // Validate dimensions match expected encryption key count
    if input.plaintext_chunks.len() != self.eks.len() {
        panic!(
            "Invalid witness dimensions: expected {} players, got {}",
            self.eks.len(),
            input.plaintext_chunks.len()
        );
    }
    
    // Validate randomness dimensions
    // (add appropriate validation based on expected structure)
    
    // Existing code continues...
    let Cs = input
        .plaintext_chunks
        .iter()
        .enumerate()
        .map(|(i, z_i)| {
            chunks_vec_msm_terms::<C>(self.pp, self.eks[i], z_i, &input.plaintext_randomness)
        })
        .collect();
    // ... rest of function
}
```

Additionally, add validation in verification flow before calling `msm_terms()`: [4](#0-3) 

The verifier should validate `proof.z` dimensions match the expected structure derived from public parameters before processing.

## Proof of Concept

```rust
#[test]
#[should_panic(expected = "index out of bounds")]
fn test_malformed_witness_causes_panic() {
    use ark_bls12_381::{Bls12_381, G1Projective};
    use crate::pvss::chunky::chunked_elgamal::{WeightedHomomorphism, WeightedWitness, PublicParameters};
    use crate::Scalar;
    use aptos_crypto::arkworks::random::unsafe_random_points_group;
    use rand::thread_rng;
    
    let mut rng = thread_rng();
    let pp = PublicParameters::<G1Projective>::default();
    
    // Honest setup: 2 players with 2 encryption keys
    let eks: Vec<_> = unsafe_random_points_group(2, &mut rng);
    let hom = WeightedHomomorphism {
        pp: &pp,
        eks: &G1Projective::normalize_batch(&eks),
    };
    
    // Malicious witness: 3 players instead of 2
    let malicious_witness = WeightedWitness {
        plaintext_chunks: vec![
            vec![vec![Scalar(ark_bls12_381::Fr::from(1u64))]],
            vec![vec![Scalar(ark_bls12_381::Fr::from(2u64))]],
            vec![vec![Scalar(ark_bls12_381::Fr::from(3u64))]], // Extra player!
        ],
        plaintext_randomness: vec![vec![Scalar(ark_bls12_381::Fr::from(0u64))]],
    };
    
    // This will panic with "index out of bounds" when accessing self.eks[2]
    let _ = hom.msm_terms(&malicious_witness);
}
```

**Notes**

This vulnerability allows complete denial-of-service of the Aptos validator network through a single malicious DKG transcript. The lack of dimension validation before array access is a critical oversight that violates basic defensive programming practices in consensus-critical code. The deterministic panic across all validators makes recovery particularly challenging, as the malicious transcript would need to be explicitly filtered or the binary patched before validators could resume normal operation.

### Citations

**File:** crates/aptos-dkg/src/pvss/chunky/chunked_elgamal.rs (L229-260)
```rust
    fn msm_terms(&self, input: &Self::Domain) -> Self::CodomainShape<Self::MsmInput> {
        // C_{i,j} = z_{i,j} * G_1 + r_j * ek[i]
        let Cs = input
            .plaintext_chunks
            .iter()
            .enumerate()
            .map(|(i, z_i)| {
                // here `i` is the player's id
                chunks_vec_msm_terms::<C>(self.pp, self.eks[i], z_i, &input.plaintext_randomness)
            })
            .collect();

        // R_j = r_j * H_1
        let Rs = input
            .plaintext_randomness
            .iter()
            .map(|inner_vec| {
                inner_vec
                    .iter()
                    .map(|&r_j| MsmInput {
                        bases: vec![self.pp.H],
                        scalars: vec![r_j.0],
                    })
                    .collect()
            })
            .collect();

        WeightedCodomainShape {
            chunks: Cs,
            randomness: Rs,
        }
    }
```

**File:** crates/aptos-dkg/src/sigma_protocol/traits.rs (L104-133)
```rust
    fn msm_terms_for_verify<Ct: Serialize, H>(
        &self,
        public_statement: &Self::Codomain,
        proof: &Proof<C::ScalarField, H>,
        cntxt: &Ct,
    ) -> Self::MsmInput
    where
        H: homomorphism::Trait<Domain = Self::Domain, Codomain = Self::Codomain>, // Need this because the lifetime was changed
    {
        let prover_first_message = match &proof.first_proof_item {
            FirstProofItem::Commitment(A) => A,
            FirstProofItem::Challenge(_) => {
                panic!("Missing implementation - expected commitment, not challenge")
            },
        };

        let number_of_beta_powers = public_statement.clone().into_iter().count(); // TODO: maybe pass the into_iter version in merge_msm_terms?

        let (c, powers_of_beta) = self.compute_verifier_challenges(public_statement, prover_first_message, cntxt, number_of_beta_powers);

        let msm_terms_for_prover_response = self.msm_terms(&proof.z);

        Self::merge_msm_terms(
            msm_terms_for_prover_response.into_iter().collect(),
            prover_first_message,
            public_statement,
            &powers_of_beta,
            c,
        )
    }
```

**File:** crates/aptos-dkg/src/pvss/chunky/weighted_transcript.rs (L172-190)
```rust
            let hom = hkzg_chunked_elgamal::WeightedHomomorphism::<E>::new(
                lagr_g1,
                pp.pk_range_proof.ck_S.xi_1,
                &pp.pp_elgamal,
                &eks_inner,
            );
            if let Err(err) = hom.verify(
                &TupleCodomainShape(
                    self.sharing_proof.range_proof_commitment.clone(),
                    chunked_elgamal::WeightedCodomainShape {
                        chunks: self.subtrs.Cs.clone(),
                        randomness: self.subtrs.Rs.clone(),
                    },
                ),
                &self.sharing_proof.SoK,
                &sok_cntxt,
            ) {
                bail!("PoK verification failed: {:?}", err);
            }
```
