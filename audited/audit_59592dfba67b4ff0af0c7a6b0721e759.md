# Audit Report

## Title
API Error Messages Leak Internal Database Implementation Details to External Clients

## Summary
Error messages from the storage layer expose internal implementation details including database corruption states, Merkle tree structure information, file paths, and RocksDB internals through public REST API endpoints, allowing attackers to map system architecture and identify potential attack vectors.

## Finding Description

The Aptos REST API exposes detailed error messages from the storage layer to external clients. When database operations fail, internal error messages are converted to strings and returned in HTTP responses without sanitization.

**Attack Path:**

1. External attacker sends request to public endpoint (e.g., `GET /accounts/:address/transactions`) [1](#0-0) 

2. The endpoint calls `get_account_ordered_transactions` which invokes database operations [2](#0-1) 

3. Database errors from `AptosDbError` are converted to API errors via `E::internal_with_code(err, AptosErrorCode::InternalError, ledger_info)` [3](#0-2) 

4. The error is formatted as a string using `format!("{:#}", error)` [4](#0-3) 

**Leaked Information Examples:**

- **Database corruption details**: "DB corruption: Sequence number not continuous. expected: {}, actual: {}" [5](#0-4) 

- **Epoch state internals**: "Last LedgerInfo in epoch must carry next_epoch_state." [6](#0-5) 

- **Merkle tree implementation**: "Jellyfish Merkle tree has cyclic graph inside." [7](#0-6) 

- **RocksDB internals**: All RocksDB errors converted to strings via `rocksdb_err.to_string()` [8](#0-7) 

- **File system details**: IO errors converted via `format!("{}", error)` exposing paths [9](#0-8) 

The `ExecutorError::InternalError` variant wraps these errors and forwards them [10](#0-9)  through conversions from `AptosDbError` [11](#0-10)  and `StateViewError` [12](#0-11) .

## Impact Explanation

This is a **Low Severity** information leakage vulnerability per Aptos Bug Bounty criteria. It does not directly enable fund theft, consensus violations, or availability attacks. However, it provides attackers with:

- Understanding of internal database schema and versioning mechanisms
- Knowledge of Merkle tree implementation details  
- System file paths and directory structure
- Error conditions that reveal architectural weaknesses
- State corruption detection mechanisms

This information aids reconnaissance for more sophisticated attacks but requires additional vulnerabilities to cause actual harm.

## Likelihood Explanation

**High Likelihood**: Any external user can trigger these errors by:
- Querying pruned versions
- Requesting invalid account data
- Triggering database read failures through normal API usage
- Probing various endpoints to collect error messages

No special privileges required - only HTTP access to public API endpoints.

## Recommendation

Sanitize error messages before returning to external clients:

```rust
// In api/src/context.rs
pub fn get_state_value_poem<E: InternalError>(
    &self,
    state_key: &StateKey,
    version: u64,
    ledger_info: &LedgerInfo,
) -> Result<Option<Vec<u8>>, E> {
    self.get_state_value(state_key, version)
        .map_err(|e| {
            // Sanitize: only return generic error without internal details
            E::internal_with_code(
                "Failed to retrieve state value", 
                AptosErrorCode::InternalError, 
                ledger_info
            )
        })
}
```

Apply similar sanitization to all public API error paths. Log detailed errors server-side for debugging while returning generic messages to clients.

## Proof of Concept

```bash
# Trigger error by requesting pruned version
curl -X GET "https://api.mainnet.aptoslabs.com/v1/accounts/0x1/transactions?start=1&limit=1"

# Expected current behavior: Detailed error like
# "Error: Version 1 pruned. Latest available: 50000000"

# Expected after fix: Generic error
# "Error: Requested data not available"
```

## Notes

This vulnerability is classified as Low severity as explicitly indicated in the security question. While it provides valuable reconnaissance information to attackers, it does not directly compromise funds, consensus, or availability - the primary security invariants of the blockchain.

### Citations

**File:** api/src/transactions.rs (L356-387)
```rust
    #[oai(
        path = "/accounts/:address/transactions",
        method = "get",
        operation_id = "get_account_transactions",
        tag = "ApiTags::Transactions"
    )]
    async fn get_accounts_transactions(
        &self,
        accept_type: AcceptType,
        /// Address of account with or without a `0x` prefix
        address: Path<Address>,
        /// Account sequence number to start list of transactions
        ///
        /// If not provided, defaults to showing the latest transactions
        start: Query<Option<U64>>,
        /// Max number of transactions to retrieve.
        ///
        /// If not provided, defaults to default page size
        limit: Query<Option<u16>>,
    ) -> BasicResultWith404<Vec<Transaction>> {
        fail_point_poem("endpoint_get_accounts_transactions")?;
        self.context
            .check_api_output_enabled("Get account transactions", &accept_type)?;
        let page = Page::new(
            start.0.map(|v| v.0),
            limit.0,
            self.context.max_transactions_page_size(),
        );
        let api = self.clone();
        api_spawn_blocking(move || api.list_ordered_txns_by_account(&accept_type, page, address.0))
            .await
    }
```

**File:** api/src/transactions.rs (L1126-1132)
```rust
        let data = self.context.get_account_ordered_transactions(
            address.into(),
            page.start_option(),
            page.limit(&latest_ledger_info)?,
            account.ledger_version,
            &latest_ledger_info,
        )?;
```

**File:** api/src/context.rs (L924-928)
```rust
        let txns = txns_res
            .context("Failed to retrieve account transactions")
            .map_err(|err| {
                E::internal_with_code(err, AptosErrorCode::InternalError, ledger_info)
            })?;
```

**File:** api/types/src/error.rs (L29-37)
```rust
    pub fn new_with_error_code<ErrorType: std::fmt::Display>(
        error: ErrorType,
        error_code: AptosErrorCode,
    ) -> AptosError {
        Self {
            message: format!("{:#}", error),
            error_code,
            vm_error_code: None,
        }
```

**File:** storage/aptosdb/src/event_store/mod.rs (L130-136)
```rust
            if seq != cur_seq {
                let msg = if cur_seq == start_seq_num {
                    "First requested event is probably pruned."
                } else {
                    "DB corruption: Sequence number not continuous."
                };
                db_other_bail!("{} expected: {}, actual: {}", msg, cur_seq, seq);
```

**File:** storage/aptosdb/src/ledger_db/ledger_metadata_db.rs (L148-150)
```rust
                AptosDbError::Other(
                    "Last LedgerInfo in epoch must carry next_epoch_state.".to_string(),
                )
```

**File:** storage/jellyfish-merkle/src/lib.rs (L797-797)
```rust
        db_other_bail!("Jellyfish Merkle tree has cyclic graph inside.");
```

**File:** storage/schemadb/src/lib.rs (L406-406)
```rust
        | ErrorKind::Unknown => AptosDbError::OtherRocksDbError(rocksdb_err.to_string()),
```

**File:** storage/storage-interface/src/errors.rs (L57-60)
```rust
impl From<std::io::Error> for AptosDbError {
    fn from(error: std::io::Error) -> Self {
        Self::IoError(format!("{}", error))
    }
```

**File:** execution/executor-types/src/error.rs (L32-33)
```rust
    #[error("Internal error: {:?}", error)]
    InternalError { error: String },
```

**File:** execution/executor-types/src/error.rs (L53-58)
```rust
impl From<AptosDbError> for ExecutorError {
    fn from(error: AptosDbError) -> Self {
        Self::InternalError {
            error: format!("{}", error),
        }
    }
```

**File:** execution/executor-types/src/error.rs (L61-66)
```rust
impl From<StateViewError> for ExecutorError {
    fn from(error: StateViewError) -> Self {
        Self::InternalError {
            error: format!("{}", error),
        }
    }
```
