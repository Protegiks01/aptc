# Audit Report

## Title
Waypoint Verification Bypass During Bootstrap Allows Consensus Participation with Corrupted State

## Summary
The `verify_waypoint_is_satisfiable()` function in the bootstrapper incorrectly assumes that if local storage has synced past the waypoint version, the waypoint must have already been cryptographically verified. This assumption is violated on node restarts because the `verified_waypoint` flag is not persisted. An attacker who corrupts a node's local storage can bypass waypoint verification, allowing the node to complete bootstrapping and participate in consensus with an incorrect blockchain state, leading to consensus safety violations.

## Finding Description

The bootstrap process relies on waypoint verification as a fundamental trust anchor to ensure nodes sync to the correct blockchain state. The proper waypoint verification process cryptographically validates both the version and hash of a ledger info against the trusted waypoint. [1](#0-0) 

However, the `verify_waypoint_is_satisfiable()` function contains a dangerous early-return path that bypasses this cryptographic verification: [2](#0-1) 

This code assumes that if `latest_ledger_info.ledger_info().version() >= waypoint_version`, the waypoint was already verified. This assumption breaks because:

1. The `verified_waypoint` flag in `VerifiedEpochStates` is initialized as `false` on every node startup: [3](#0-2) 

2. This flag is never persisted to disk - the metadata storage only tracks snapshot sync progress, not waypoint verification status: [4](#0-3) 

3. After marking the waypoint as verified without cryptographic checks, the bootstrapper proceeds to check if it can complete bootstrapping: [5](#0-4) 

4. Once `bootstrapped` is set to `true`, consensus is allowed to execute: [6](#0-5) 

**Attack Path:**
1. Attacker corrupts node's local storage (through storage vulnerability, malicious backup restore, or direct DB manipulation) to contain a fake `LedgerInfo` at version ≥ waypoint version but with an incorrect hash value
2. Node restarts
3. `verify_waypoint_is_satisfiable()` is called during bootstrapping
4. The function sees storage version ≥ waypoint version and sets `verified_waypoint = true` without calling `waypoint.verify()`
5. Node proceeds through remaining bootstrap checks and sets `bootstrapped = true`
6. Consensus checks `is_bootstrapped()` which returns `true`
7. Node participates in consensus with corrupted state, violating consensus safety invariants

## Impact Explanation

This vulnerability constitutes a **Critical Severity** issue under the Aptos bug bounty program criteria for the following reasons:

**Consensus Safety Violation:** The core issue violates the fundamental blockchain invariant that all validators must maintain cryptographically-verified consistent state. A node with corrupted storage can bypass the waypoint verification mechanism - the primary trust anchor designed to prevent exactly this scenario.

**Potential for Chain Forks:** Multiple validators with differently corrupted states could form incompatible views of the blockchain, leading to consensus failures or chain splits. This breaks the consensus safety guarantee that AptosBFT should prevent under < 1/3 Byzantine validators.

**Network Partition Risk:** Corrupted nodes will reject legitimate blocks as invalid while potentially accepting their own incorrect state transitions. This can cause non-recoverable network partitions requiring manual intervention or hard forks to resolve.

**Loss of Funds:** State inconsistencies between nodes can lead to double-spends, missing balances, or incorrect transaction execution, directly enabling theft or loss of user funds.

The vulnerability bypasses a critical security control (waypoint verification) that is specifically designed to prevent untrusted state from being accepted, meeting the definition of "Consensus/Safety violations" in the Critical Severity category.

## Likelihood Explanation

**Likelihood: Medium to High**

The vulnerability requires storage corruption to exploit, which could occur through several realistic scenarios:

1. **Storage Layer Bugs:** Bugs in the storage implementation could allow incorrect data to be committed to disk
2. **Malicious Backup Restoration:** Operators restoring from compromised or malicious backups
3. **Database Corruption:** Hardware failures or filesystem issues causing partial corruption
4. **Direct Database Manipulation:** Attackers with filesystem access modifying RocksDB files
5. **State Sync Vulnerabilities:** Bugs in state synchronization that commit unverified data

The key factor increasing likelihood is that the vulnerability is triggered **automatically on restart** after corruption occurs - no additional attacker action is needed. The node will self-compromise during its normal bootstrap sequence.

Additionally, the non-persistence of the `verified_waypoint` flag means this bypass occurs every time a node restarts after syncing past its waypoint, making it a persistent weakness rather than a one-time issue.

## Recommendation

The fix requires ensuring waypoint verification is cryptographically validated on every restart, not just assumed based on storage state. Two approaches are recommended:

**Approach 1: Always Re-verify Waypoint (Recommended)**

Modify `verify_waypoint_is_satisfiable()` to always perform cryptographic verification when storage contains data at the waypoint version:

```rust
fn verify_waypoint_is_satisfiable(
    &mut self,
    global_data_summary: &GlobalDataSummary,
) -> Result<(), Error> {
    let latest_ledger_info = utils::fetch_latest_synced_ledger_info(self.storage.clone())?;
    let waypoint_version = self.driver_configuration.waypoint.version();
    
    // If storage has synced past waypoint, verify it was correctly verified
    if latest_ledger_info.ledger_info().version() >= waypoint_version {
        // Fetch the exact ledger info at waypoint version from storage
        let waypoint_ledger_info = self.storage
            .get_latest_ledger_info_option(waypoint_version)
            .map_err(|e| Error::StorageError(format!(
                "Failed to get ledger info at waypoint version {}: {:?}",
                waypoint_version, e
            )))?
            .ok_or_else(|| Error::StorageError(format!(
                "No ledger info found at waypoint version {}",
                waypoint_version
            )))?;
        
        // Cryptographically verify the waypoint
        self.driver_configuration.waypoint
            .verify(waypoint_ledger_info.ledger_info())
            .map_err(|e| Error::VerificationError(format!(
                "Waypoint verification failed on restart: {:?}", e
            )))?;
        
        self.verified_epoch_states.set_verified_waypoint(waypoint_version);
        return Ok(());
    }
    
    // Continue with existing network advertisement checks...
}
```

**Approach 2: Persist Waypoint Verification Status**

Add a new metadata key to persist waypoint verification:

```rust
// In metadata_storage.rs
pub enum MetadataKey {
    StateSnapshotSync,
    WaypointVerified, // New field
}

pub enum MetadataValue {
    StateSnapshotSync(StateSnapshotProgress),
    WaypointVerified(WaypointVerificationRecord), // New field
}
```

Then check this persisted value during bootstrap initialization and only skip re-verification if it's confirmed persisted.

**Approach 1 is strongly recommended** as it requires no schema changes and provides defense-in-depth by always re-verifying the critical trust anchor on restart.

## Proof of Concept

Due to the nature of this vulnerability requiring storage manipulation, a complete PoC requires either:

1. A Rust integration test that directly modifies the storage layer to inject a fake LedgerInfo
2. A manual reproduction using database tools to corrupt the RocksDB instance

**Conceptual Rust Test Outline:**

```rust
#[tokio::test]
async fn test_waypoint_bypass_on_restart() {
    // 1. Initialize a bootstrapper with a specific waypoint
    let waypoint = Waypoint::new_any(&legitimate_ledger_info);
    let mut bootstrapper = create_bootstrapper_with_waypoint(waypoint);
    
    // 2. Corrupt storage by inserting a fake ledger info at waypoint version
    // with incorrect hash (this simulates the attack)
    let fake_ledger_info = create_fake_ledger_info(
        waypoint.version(),
        HashValue::random(), // Wrong hash
    );
    storage.save_ledger_info(&fake_ledger_info);
    
    // 3. Ensure state_store version >= waypoint version
    storage.set_state_version(waypoint.version() + 100);
    
    // 4. Create a new bootstrapper (simulating restart)
    let mut bootstrapper = create_bootstrapper_with_waypoint(waypoint);
    
    // 5. Call verify_waypoint_is_satisfiable
    let result = bootstrapper.verify_waypoint_is_satisfiable(&global_summary);
    
    // 6. BUG: This should FAIL but currently PASSES
    assert!(result.is_ok()); // This assertion should fail after fix
    assert!(bootstrapper.verified_epoch_states.verified_waypoint()); // This should be false
    
    // 7. The node will proceed to mark itself as bootstrapped
    // despite having invalid state - consensus safety violation!
}
```

The test demonstrates that a node with corrupted storage will incorrectly mark its waypoint as verified and proceed with bootstrapping, allowing it to participate in consensus with an incorrect blockchain state.

## Notes

This vulnerability is particularly severe because:

1. **Waypoints are the primary trust anchor** - bypassing them defeats the entire security model of state sync
2. **Automatic exploitation** - no ongoing attacker interaction needed after initial corruption
3. **Affects all node types** - validators, full nodes, and light clients that use the bootstrapper
4. **Difficult to detect** - corrupted nodes may appear to function normally until consensus divergence occurs
5. **No recovery mechanism** - once a node is marked as bootstrapped incorrectly, there's no automatic detection or correction

The fix should be prioritized as it protects against multiple attack vectors including storage bugs, malicious operators, and hardware failures.

### Citations

**File:** types/src/waypoint.rs (L62-79)
```rust
    pub fn verify(&self, ledger_info: &LedgerInfo) -> Result<()> {
        ensure!(
            ledger_info.version() == self.version(),
            "Waypoint version mismatch: waypoint version = {}, given version = {}",
            self.version(),
            ledger_info.version()
        );
        let converter = Ledger2WaypointConverter::new(ledger_info);
        ensure!(
            converter.hash() == self.value(),
            format!(
                "Waypoint value mismatch: waypoint value = {}, given value = {}",
                self.value().to_hex(),
                converter.hash().to_hex()
            )
        );
        Ok(())
    }
```

**File:** state-sync/state-sync-driver/src/bootstrapper.rs (L60-68)
```rust
    pub fn new(latest_epoch_state: EpochState) -> Self {
        Self {
            fetched_epoch_ending_ledger_infos: false,
            highest_fetched_epoch_ending_version: 0,
            latest_epoch_state,
            new_epoch_ending_ledger_infos: BTreeMap::new(),
            verified_waypoint: false,
        }
    }
```

**File:** state-sync/state-sync-driver/src/bootstrapper.rs (L483-488)
```rust
        } else if highest_synced_version >= highest_known_ledger_version {
            // Otherwise, if we've already synced to the highest known version, there's nothing to do
            info!(LogSchema::new(LogEntry::Bootstrapper)
                .message(&format!("Highest synced version {} is >= highest known ledger version {}, nothing needs to be done.",
                    highest_synced_version, highest_known_ledger_version)));
            return self.bootstrapping_complete().await;
```

**File:** state-sync/state-sync-driver/src/bootstrapper.rs (L887-891)
```rust
        if latest_ledger_info.ledger_info().version() >= waypoint_version {
            self.verified_epoch_states
                .set_verified_waypoint(waypoint_version);
            return Ok(());
        }
```

**File:** state-sync/state-sync-driver/src/metadata_storage.rs (L252-263)
```rust
    #[derive(Debug, Deserialize, Eq, PartialEq, Serialize)]
    #[repr(u8)]
    pub enum MetadataKey {
        StateSnapshotSync, // A state snapshot sync that was started
    }

    /// A metadata value that can be inserted into the database
    #[derive(Debug, Deserialize, Eq, PartialEq, Serialize)]
    #[repr(u8)]
    pub enum MetadataValue {
        StateSnapshotSync(StateSnapshotProgress), // A state snapshot sync progress marker
    }
```

**File:** state-sync/state-sync-driver/src/driver.rs (L626-630)
```rust
    fn check_if_consensus_or_observer_executing(&self) -> bool {
        self.is_consensus_or_observer_enabled()
            && self.bootstrapper.is_bootstrapped()
            && !self.active_sync_request()
    }
```
