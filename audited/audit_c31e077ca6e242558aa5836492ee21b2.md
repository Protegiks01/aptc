# Audit Report

## Title
Database Credentials Exposed in Node Startup Logs via JSON Serialization

## Summary
The `postgres_uri` field containing sensitive database credentials is logged in plaintext during node startup through the `log_all_configs()` method, which uses JSON serialization instead of the password-redacting Debug trait implementation. This exposes database credentials to anyone with access to node logs.

## Finding Description
The `IndexerConfig` struct implements a custom Debug trait that redacts the password from `postgres_uri` when formatted for debugging. [1](#0-0) 

However, the struct also derives the standard Serialize trait without any custom implementation to redact sensitive fields. [2](#0-1) 

During node startup, the `log_all_configs()` method in NodeConfig serializes the entire configuration to JSON and logs each section. [3](#0-2) 

This method is called at the beginning of node startup. [4](#0-3) 

The JSON serialization uses the derived Serialize trait, which outputs the full `postgres_uri` value including the password in plaintext format `postgresql://user:password@host/database`. The `skip_serializing_if = "Option::is_none"` attribute only prevents serialization when the value is None, but does not redact credentials when present.

**Exploitation Path:**
1. Node operator configures indexer with `postgres_uri` containing credentials
2. Node starts up and calls `setup_environment_and_start_node()`
3. `log_all_configs()` is invoked, serializing NodeConfig to JSON
4. IndexerConfig is serialized with full postgres_uri including password
5. Credentials are logged via `info!()` macro to log files
6. Attacker with access to logs (via log aggregation systems, backup storage, compromised log servers, or filesystem access) extracts credentials

## Impact Explanation
This is a **High Severity** credential exposure vulnerability. While it does not directly impact blockchain consensus or on-chain funds, it exposes database credentials that could enable:

- Unauthorized access to the indexer database containing all indexed blockchain data
- Potential data manipulation or deletion if the database user has write permissions  
- Lateral movement within the infrastructure if credentials are reused
- Compliance violations related to credential management

The vulnerability affects every node operator running the indexer component, as logs are commonly:
- Centralized in log management systems (Splunk, ELK stack, etc.)
- Backed up to cloud storage with broader access permissions
- Accessible to operations teams, support staff, and potentially external vendors
- Retained for extended periods for compliance or debugging purposes

## Likelihood Explanation
This vulnerability has **very high likelihood** of occurring:

- It triggers automatically on every node startup when the indexer is enabled
- No attacker action is required to cause the credential exposure
- Logs are a common attack vector and frequently misconfigured or over-permissioned
- The vulnerability has likely already occurred on existing deployed nodes

The only prerequisite is that the indexer must be enabled with a configured `postgres_uri`.

## Recommendation
Implement a custom Serialize trait for `IndexerConfig` that redacts the password field, similar to the existing Debug implementation:

```rust
impl Serialize for IndexerConfig {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        
        let postgres_uri_redacted = self.postgres_uri.as_ref().map(|u| {
            url::Url::parse(u)
                .ok()
                .and_then(|mut parsed_url| {
                    if parsed_url.password().is_some() {
                        parsed_url.set_password(Some("*")).ok()?;
                    }
                    Some(parsed_url.to_string())
                })
                .unwrap_or_else(|| "*redacted*".to_string())
        });
        
        let mut state = serializer.serialize_struct("IndexerConfig", 14)?;
        state.serialize_field("enabled", &self.enabled)?;
        state.serialize_field("postgres_uri", &postgres_uri_redacted)?;
        state.serialize_field("processor", &self.processor)?;
        // ... serialize remaining fields
        state.end()
    }
}
```

Alternatively, use the `#[serde(serialize_with = "redact_password")]` attribute on the postgres_uri field with a custom serialization function.

## Proof of Concept

**Setup:**
1. Configure a node with indexer enabled in `node.yaml`:
```yaml
indexer:
  enabled: true
  postgres_uri: "postgresql://indexer_user:SecretPassword123@localhost:5432/indexer_db"
  processor: "default_processor"
```

2. Start the node with standard logging configuration

**Expected Vulnerable Output in Logs:**
```
[INFO] Using indexer config: {"enabled":true,"postgres_uri":"postgresql://indexer_user:SecretPassword123@localhost:5432/indexer_db","processor":"default_processor",...}
```

The password `SecretPassword123` is visible in plaintext in the logs, despite the Debug trait implementation attempting to redact it.

**Verification:**
Run `grep -r "postgres_uri.*://" /var/log/aptos/` on the node to find exposed credentials in log files.

## Notes

**Additional Vulnerable Code Paths:**

1. The same `.expect("Invalid postgres uri")` pattern exists in the logger initialization, which could expose credentials in panic messages if URL parsing fails. [5](#0-4) 

2. Similar vulnerability in the Debug trait implementation's panic path. [6](#0-5) 

3. Kubernetes ConfigMaps in test infrastructure may also serialize and store configs with exposed credentials. [7](#0-6) 

The vulnerability is limited to the indexer component and does not directly affect blockchain consensus, validator operations, or on-chain state. However, it represents a significant operational security risk for node operators.

### Citations

**File:** config/src/config/indexer_config.rs (L25-36)
```rust
#[derive(Clone, Default, Deserialize, PartialEq, Eq, Serialize)]
#[serde(default, deny_unknown_fields)]
pub struct IndexerConfig {
    /// Whether the indexer is enabled or not
    /// Alternatively can set the `INDEXER_ENABLED` env var
    #[serde(default)]
    pub enabled: bool,

    /// Postgres database uri, ex: "postgresql://user:pass@localhost/postgres"
    /// Alternatively can set the `INDEXER_DATABASE_URL` env var
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub postgres_uri: Option<String>,
```

**File:** config/src/config/indexer_config.rs (L92-117)
```rust
impl Debug for IndexerConfig {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        let postgres_uri = self.postgres_uri.as_ref().map(|u| {
            let mut parsed_url = url::Url::parse(u).expect("Invalid postgres uri");
            if parsed_url.password().is_some() {
                parsed_url.set_password(Some("*")).unwrap();
            }
            parsed_url.to_string()
        });
        f.debug_struct("IndexerConfig")
            .field("enabled", &self.enabled)
            .field("postgres_uri", &postgres_uri)
            .field("processor", &self.processor)
            .field("starting_version", &self.starting_version)
            .field("skip_migrations", &self.skip_migrations)
            .field("check_chain_id", &self.check_chain_id)
            .field("batch_size", &self.batch_size)
            .field("fetch_tasks", &self.fetch_tasks)
            .field("processor_tasks", &self.processor_tasks)
            .field("emit_every", &self.emit_every)
            .field("gap_lookback_versions", &self.gap_lookback_versions)
            .field("ans_contract_address", &self.ans_contract_address)
            .field("nft_points_contract", &self.nft_points_contract)
            .finish()
    }
}
```

**File:** config/src/config/node_config.rs (L97-111)
```rust
    pub fn log_all_configs(&self) {
        // Parse the node config as serde JSON
        let config_value =
            serde_json::to_value(self).expect("Failed to serialize the node config!");
        let config_map = config_value
            .as_object()
            .expect("Failed to get the config map!");

        // Log each config entry
        for (config_name, config_value) in config_map {
            let config_string =
                serde_json::to_string(config_value).expect("Failed to parse the config value!");
            info!("Using {} config: {}", config_name, config_string);
        }
    }
```

**File:** aptos-node/src/lib.rs (L690-698)
```rust
pub fn setup_environment_and_start_node(
    mut node_config: NodeConfig,
    remote_log_rx: Option<mpsc::Receiver<TelemetryLog>>,
    logger_filter_update_job: Option<LoggerFilterUpdater>,
    api_port_tx: Option<oneshot::Sender<u16>>,
    indexer_grpc_port_tx: Option<oneshot::Sender<u16>>,
) -> anyhow::Result<AptosHandle> {
    // Log the node config at node startup
    node_config.log_all_configs();
```

**File:** aptos-node/src/logger.rs (L91-96)
```rust
    if let Some(u) = &node_config.indexer.postgres_uri {
        let mut parsed_url = url::Url::parse(u).expect("Invalid postgres uri");
        if parsed_url.password().is_some() {
            masked_config = node_config.clone();
            parsed_url.set_password(Some("*")).unwrap();
            masked_config.indexer.postgres_uri = Some(parsed_url.to_string());
```

**File:** testsuite/forge/src/backend/k8s/fullnode.rs (L75-83)
```rust
async fn create_node_config_configmap(
    node_config_config_map_name: String,
    node_config: &OverrideNodeConfig,
) -> Result<ConfigMap> {
    let mut data: BTreeMap<String, String> = BTreeMap::new();
    data.insert(
        FULLNODE_CONFIG_MAP_KEY.to_string(),
        serde_yaml::to_string(&node_config.get_yaml()?)?,
    );
```
