# Audit Report

## Title
Consensus Safety Violation via ExecutionConfig Sanitizer Bypass

## Summary
Setting `skip_config_sanitizer=true` in `NodeStartupConfig` completely bypasses all configuration validation, including critical ExecutionConfig checks that enforce `paranoid_type_verification=true` for mainnet validators. This allows validators to run without essential Move VM runtime type safety checks, leading to consensus divergence when transactions with type safety violations are processed.

## Finding Description

The vulnerability exists in the config sanitization flow that validates node configurations before startup. [1](#0-0) 

When `skip_config_sanitizer` is true, the `NodeConfig::sanitize()` method returns immediately without performing ANY validation, including the critical `ExecutionConfig::sanitize()` check. [2](#0-1) 

This ExecutionConfig sanitizer enforces that mainnet validators MUST have `paranoid_type_verification=true` and `paranoid_hot_potato_verification=true`. These flags control critical runtime type safety checks in the Move VM. [3](#0-2) 

The `paranoid_type_verification` setting maps to the VM's `paranoid_type_checks` configuration, which determines whether runtime type safety validation is performed. [4](#0-3) 

When `paranoid_type_checks=false`, the VM uses `NoRuntimeTypeCheck` instead of `FullRuntimeTypeCheck`. [5](#0-4) 

The `NoRuntimeTypeCheck` implementation completely skips all runtime type safety validation, returning `Ok(())` for all checks.

**Attack Scenario:**

1. A validator operator sets in their config file:
   ```yaml
   node_startup:
     skip_config_sanitizer: true
   execution:
     paranoid_type_verification: false
   ```

2. The node starts successfully, bypassing the sanitizer that would normally reject this configuration for mainnet.

3. A transaction arrives that contains a type safety violation (e.g., a bug in the bytecode verifier allows a type mismatch).

4. **Honest validators** (with paranoid checks enabled):
   - Runtime type checks detect the violation
   - Transaction fails with `EPARANOID_FAILURE` status
   - Transaction is kept as `MiscellaneousError` (with `CHARGE_INVARIANT_VIOLATION` enabled)
   - State remains unchanged

5. **Misconfigured validator** (with paranoid checks disabled):
   - No runtime type checks performed
   - Transaction executes with type safety violation
   - May succeed with incorrect state changes OR fail with different error
   - Different execution outcome

6. **Result:** Validators produce different transaction outcomes and different state roots for the same block â†’ **Consensus safety violation** [6](#0-5) 

The handling of invariant violations differs based on feature flags, but the core issue is that different validators will produce fundamentally different execution results.

## Impact Explanation

This vulnerability breaks **Critical Invariant #1: Deterministic Execution** - "All validators must produce identical state roots for identical blocks."

**Severity: CRITICAL** per Aptos Bug Bounty criteria:
- **Consensus/Safety violations**: Different validators produce different state roots
- **Non-recoverable network partition**: Validators fork onto different chains
- Requires hardfork to resolve if validators diverge

The paranoid type checks exist specifically as a defense-in-depth mechanism to catch bytecode verifier bugs and ensure type safety at runtime. Disabling them removes a critical safety layer that prevents consensus-breaking type violations.

## Likelihood Explanation

**Likelihood: MEDIUM-HIGH**

- **Ease of exploitation**: Trivial - requires only editing a YAML config file
- **Attacker requirements**: Must be a validator operator with access to node configuration
- **Detection**: No warnings or errors when bypass is used
- **Triggering condition**: Requires a transaction that triggers type safety violations, which could occur due to:
  - Bytecode verifier bugs (rare but possible)
  - Novel attack vectors against the Move VM
  - Regression in verification logic

The `skip_config_sanitizer` field exists and defaults to `false`, suggesting it may be used for testing or debugging. However, there are NO safeguards preventing its use on mainnet production validators. [7](#0-6) 

## Recommendation

**Immediate Fix:** Remove the `skip_config_sanitizer` bypass entirely, or add strict safeguards:

```rust
impl ConfigSanitizer for NodeConfig {
    fn sanitize(
        node_config: &NodeConfig,
        node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        // NEVER allow skipping sanitization on mainnet
        if node_config.node_startup.skip_config_sanitizer {
            if let Some(chain_id) = chain_id {
                if chain_id.is_mainnet() {
                    return Err(Error::ConfigSanitizerFailed(
                        "NodeConfig".to_string(),
                        "skip_config_sanitizer cannot be enabled on mainnet nodes!".into(),
                    ));
                }
            }
            // Still log a warning for non-mainnet
            eprintln!("WARNING: Config sanitization is disabled! This is unsafe for production use.");
        }
        
        // Continue with normal sanitization...
```

**Long-term Fix:** 
1. Remove `skip_config_sanitizer` entirely from production builds (use feature flags for debug builds only)
2. Add runtime validation that critical VM safety settings match expected values for the chain
3. Add telemetry/monitoring to detect validators running with non-standard configs

## Proof of Concept

```rust
// Reproduction steps:
// 1. Create two validator nodes with different configs

// Config A (honest_validator.yaml):
// execution:
//   paranoid_type_verification: true  # default

// Config B (malicious_validator.yaml):
// node_startup:
//   skip_config_sanitizer: true
// execution:
//   paranoid_type_verification: false

// 2. Deploy a Move module with a subtle type safety bug that bypasses 
//    the bytecode verifier but triggers runtime paranoid checks

// 3. Submit transaction calling the buggy module

// 4. Observe execution results:
//    - Node A: Transaction fails with EPARANOID_FAILURE, state unchanged
//    - Node B: Transaction succeeds or fails differently, state may change

// 5. Verify state roots diverge:
assert_ne!(node_a.get_state_root(), node_b.get_state_root());
// CONSENSUS VIOLATION DETECTED
```

**Test case demonstrating the bypass:** [8](#0-7) 

This test explicitly demonstrates that setting `skip_config_sanitizer: true` allows invalid mainnet configurations (like `paranoid_hot_potato_verification = false`) to pass validation.

## Notes

The vulnerability requires validator operator access to modify node configuration files, which might be considered an "insider threat." However, the system SHOULD enforce safety-critical settings regardless of operator intentions, especially when those settings can break consensus. The existence of the ExecutionConfig sanitizer indicates the system recognizes these settings are too critical to leave to operator discretion, yet the bypass flag undermines this protection entirely.

### Citations

**File:** config/src/config/config_sanitizer.rs (L40-70)
```rust
    fn sanitize(
        node_config: &NodeConfig,
        node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        // If config sanitization is disabled, don't do anything!
        if node_config.node_startup.skip_config_sanitizer {
            return Ok(());
        }

        // Sanitize all of the sub-configs
        AdminServiceConfig::sanitize(node_config, node_type, chain_id)?;
        ApiConfig::sanitize(node_config, node_type, chain_id)?;
        BaseConfig::sanitize(node_config, node_type, chain_id)?;
        ConsensusConfig::sanitize(node_config, node_type, chain_id)?;
        DagConsensusConfig::sanitize(node_config, node_type, chain_id)?;
        ExecutionConfig::sanitize(node_config, node_type, chain_id)?;
        sanitize_failpoints_config(node_config, node_type, chain_id)?;
        sanitize_fullnode_network_configs(node_config, node_type, chain_id)?;
        IndexerGrpcConfig::sanitize(node_config, node_type, chain_id)?;
        InspectionServiceConfig::sanitize(node_config, node_type, chain_id)?;
        LoggerConfig::sanitize(node_config, node_type, chain_id)?;
        MempoolConfig::sanitize(node_config, node_type, chain_id)?;
        NetbenchConfig::sanitize(node_config, node_type, chain_id)?;
        StateSyncConfig::sanitize(node_config, node_type, chain_id)?;
        StorageConfig::sanitize(node_config, node_type, chain_id)?;
        InternalIndexerDBConfig::sanitize(node_config, node_type, chain_id)?;
        sanitize_validator_network_config(node_config, node_type, chain_id)?;

        Ok(()) // All configs passed validation
    }
```

**File:** config/src/config/config_sanitizer.rs (L212-239)
```rust
    fn test_disable_config_sanitizer() {
        // Create a default node config (with sanitization enabled)
        let mut node_config = NodeConfig::default();

        // Set a bad node config for mainnet
        node_config.execution.paranoid_hot_potato_verification = false;

        // Sanitize the config and verify the sanitizer fails
        let error =
            NodeConfig::sanitize(&node_config, NodeType::Validator, Some(ChainId::mainnet()))
                .unwrap_err();
        assert!(matches!(error, Error::ConfigSanitizerFailed(_, _)));

        // Create a node config with the sanitizer disabled
        let mut node_config = NodeConfig {
            node_startup: NodeStartupConfig {
                skip_config_sanitizer: true,
                ..Default::default()
            },
            ..Default::default()
        };

        // Set a bad node config for mainnet
        node_config.execution.paranoid_hot_potato_verification = false;

        // Sanitize the config and verify the sanitizer passes
        NodeConfig::sanitize(&node_config, NodeType::Validator, Some(ChainId::mainnet())).unwrap();
    }
```

**File:** config/src/config/execution_config.rs (L157-187)
```rust
impl ConfigSanitizer for ExecutionConfig {
    fn sanitize(
        node_config: &NodeConfig,
        _node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();
        let execution_config = &node_config.execution;

        // If this is a mainnet node, ensure that additional verifiers are enabled
        if let Some(chain_id) = chain_id {
            if chain_id.is_mainnet() {
                if !execution_config.paranoid_hot_potato_verification {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name,
                        "paranoid_hot_potato_verification must be enabled for mainnet nodes!"
                            .into(),
                    ));
                }
                if !execution_config.paranoid_type_verification {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name,
                        "paranoid_type_verification must be enabled for mainnet nodes!".into(),
                    ));
                }
            }
        }

        Ok(())
    }
}
```

**File:** aptos-node/src/utils.rs (L52-75)
```rust
/// Sets the Aptos VM configuration based on the node configurations
pub fn set_aptos_vm_configurations(node_config: &NodeConfig) {
    set_layout_caches(node_config.execution.layout_caches_enabled);
    set_paranoid_type_checks(node_config.execution.paranoid_type_verification);
    set_async_runtime_checks(node_config.execution.async_runtime_checks);
    let effective_concurrency_level = if node_config.execution.concurrency_level == 0 {
        ((num_cpus::get() / 2) as u16).clamp(1, DEFAULT_EXECUTION_CONCURRENCY_LEVEL)
    } else {
        node_config.execution.concurrency_level
    };
    AptosVM::set_concurrency_level_once(effective_concurrency_level as usize);
    AptosVM::set_discard_failed_blocks(node_config.execution.discard_failed_blocks);
    AptosVM::set_num_proof_reading_threads_once(
        node_config.execution.num_proof_reading_threads as usize,
    );
    AptosVM::set_blockstm_v2_enabled_once(node_config.execution.blockstm_v2_enabled);

    if node_config
        .execution
        .processed_transactions_detailed_counters
    {
        AptosVM::set_processed_transactions_detailed_counters();
    }
}
```

**File:** third_party/move/move-vm/runtime/src/interpreter.rs (L244-278)
```rust
        let paranoid_type_checks =
            !trace_recorder.is_enabled() && interpreter.vm_config.paranoid_type_checks;
        let optimize_trusted_code =
            !trace_recorder.is_enabled() && interpreter.vm_config.optimize_trusted_code;
        let paranoid_ref_checks = interpreter.vm_config.paranoid_ref_checks;

        let function = Rc::new(function);
        macro_rules! execute_main {
            ($type_check:ty, $ref_check:ty) => {
                interpreter.execute_main::<$type_check, $ref_check>(
                    data_cache,
                    function_caches,
                    gas_meter,
                    traversal_context,
                    extensions,
                    trace_recorder,
                    function,
                    args,
                )
            };
        }

        // Note: we have organized the code below from most-likely config to least-likely config.
        match (
            paranoid_type_checks,
            optimize_trusted_code,
            paranoid_ref_checks,
        ) {
            (true, true, false) => execute_main!(UntrustedOnlyRuntimeTypeCheck, NoRuntimeRefCheck),
            (true, false, false) => execute_main!(FullRuntimeTypeCheck, NoRuntimeRefCheck),
            (true, true, true) => execute_main!(UntrustedOnlyRuntimeTypeCheck, FullRuntimeRefCheck),
            (true, false, true) => execute_main!(FullRuntimeTypeCheck, FullRuntimeRefCheck),
            (false, _, false) => execute_main!(NoRuntimeTypeCheck, NoRuntimeRefCheck),
            (false, _, true) => execute_main!(NoRuntimeTypeCheck, FullRuntimeRefCheck),
        }
```

**File:** third_party/move/move-vm/runtime/src/runtime_type_checks.rs (L220-253)
```rust
impl RuntimeTypeCheck for NoRuntimeTypeCheck {
    #[cfg_attr(feature = "force-inline", inline(always))]
    fn pre_execution_type_stack_transition(
        _frame: &Frame,
        _operand_stack: &mut Stack,
        _instruction: &Instruction,
        _ty_cache: &mut FrameTypeCache,
    ) -> PartialVMResult<()> {
        Ok(())
    }

    #[cfg_attr(feature = "force-inline", inline(always))]
    fn post_execution_type_stack_transition(
        _frame: &Frame,
        _operand_stack: &mut Stack,
        _instruction: &Instruction,
        _ty_cache: &mut FrameTypeCache,
    ) -> PartialVMResult<()> {
        Ok(())
    }

    #[cfg_attr(feature = "force-inline", inline(always))]
    fn should_perform_checks(_for_fun: &Function) -> bool {
        false
    }

    #[cfg_attr(feature = "force-inline", inline(always))]
    fn check_cross_module_regular_call_visibility(
        _caller: &LoadedFunction,
        _callee: &LoadedFunction,
    ) -> PartialVMResult<()> {
        Ok(())
    }
}
```

**File:** types/src/transaction/mod.rs (L1640-1648)
```rust
                if code.status_type() == StatusType::InvariantViolation
                    && features.is_enabled(FeatureFlag::CHARGE_INVARIANT_VIOLATION)
                {
                    Self::Keep(ExecutionStatus::MiscellaneousError(Some(code)))
                } else {
                    Self::Discard(code)
                }
            },
        }
```

**File:** config/src/config/node_startup_config.rs (L6-21)
```rust
#[derive(Clone, Copy, Debug, Deserialize, PartialEq, Eq, Serialize)]
#[serde(default, deny_unknown_fields)]
pub struct NodeStartupConfig {
    pub skip_config_optimizer: bool, // Whether or not to skip the config optimizer at startup
    pub skip_config_sanitizer: bool, // Whether or not to skip the config sanitizer at startup
}

#[allow(clippy::derivable_impls)] // Derive default manually (this is safer than guessing defaults)
impl Default for NodeStartupConfig {
    fn default() -> Self {
        Self {
            skip_config_optimizer: false,
            skip_config_sanitizer: false,
        }
    }
}
```
