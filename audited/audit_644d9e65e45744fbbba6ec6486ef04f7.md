# Audit Report

## Title
Two-Chain Timeout Certificate Verification Failure Due to Signature Update Race Condition

## Summary
The timeout certificate aggregation logic in `TwoChainTimeoutVotes` fails to properly track signature updates when validators send multiple timeout messages with increasing HQC (Highest Quorum Certificate) rounds. This creates an inconsistency where the stored timeout's HQC round does not match the maximum signed HQC round, causing legitimate timeout certificates to fail verification and disrupting consensus liveness.

## Finding Description

The vulnerability exists in the interaction between three components:

1. **No Duplicate Detection**: Unlike vote processing, `insert_round_timeout()` has no duplicate detection mechanism to prevent validators from sending multiple timeout messages for the same round. [1](#0-0) 

2. **Signature Tracking Bug**: The `add_signature()` method uses `or_insert()`, which only records the FIRST signature from each validator and ignores subsequent updates. [2](#0-1) 

3. **Timeout Replacement Logic**: When a timeout with a higher HQC round is received, the entire stored timeout is replaced, but the signature remains at the old HQC round due to `or_insert()`. [3](#0-2) 

**Exploitation Scenario:**

In normal AptosBFT operation, validators may receive new quorum certificates during an ongoing round. When this occurs:

1. Validator A sends `RoundTimeout(round=10, HQC_round=5)` → Signatures: `{A: (5, sig_A)}`
2. Validator B sends `RoundTimeout(round=10, HQC_round=6)` → Stored timeout updated to HQC=6, Signatures: `{A: (5, sig_A), B: (6, sig_B)}`
3. Validator A receives QC for round 8 and sends updated `RoundTimeout(round=10, HQC_round=8)` → Stored timeout updated to HQC=8, but Signatures: `{A: (5, sig_A), B: (6, sig_B)}` (**A's signature NOT updated due to `or_insert()`**)
4. Validator C sends `RoundTimeout(round=10, HQC_round=5)` → Signatures: `{A: (5, sig_A), B: (6, sig_B), C: (5, sig_C)}`

When quorum (2f+1) is reached, `aggregate_signatures()` creates a `TwoChainTimeoutCertificate` with:
- Stored timeout HQC: **8**
- Signature HQC rounds: `[5, 6, 5]`
- Maximum signed HQC: **6**

During verification (when the TC is used in a `ProposalMsg`), the consistency check fails: [4](#0-3) 

The verification fails with: `"Inconsistent hqc round, qc has round 8, highest signed round 6"`

This causes the TC to be rejected even though it was legitimately aggregated from valid timeout votes. [5](#0-4) 

## Impact Explanation

**Medium Severity** per Aptos Bug Bounty criteria: "State inconsistencies requiring intervention"

This vulnerability causes:
1. **Consensus Liveness Degradation**: Legitimate timeout certificates fail verification, preventing round progression
2. **State Inconsistency**: The aggregated TC passes creation but fails verification, creating an inconsistent state
3. **Diagnostic Complexity**: The failure occurs only during TC usage (in proposals), not during aggregation, making debugging difficult
4. **Network Impact**: All nodes attempting to use the malformed TC will encounter verification errors

The issue affects the consensus layer's ability to progress through rounds when timeouts occur, which is critical for liveness under network partitions or slow validators. While not a safety violation, it can cause significant operational disruption requiring manual intervention.

## Likelihood Explanation

**HIGH likelihood** of occurrence:

1. **Natural Trigger**: The bug can manifest during normal operations without malicious behavior. Validators routinely receive new QCs during ongoing rounds and may legitimately send updated timeout information.

2. **Network Conditions**: Common scenarios like network delays, validator catch-up after brief disconnection, or QC propagation timing can trigger this condition.

3. **No Protective Measures**: The code lacks duplicate detection for `RoundTimeout` messages (unlike regular votes which have explicit equivocation checking), making this vulnerability trivially triggerable. [6](#0-5) 

4. **Malicious Amplification**: A malicious validator could deliberately trigger this by sending multiple timeouts with incrementally higher HQC rounds to disrupt TC formation.

## Recommendation

Implement one of two fixes:

**Option 1: Replace `or_insert` with `insert`** (simpler, matches pattern in `PartialSignatures`)
```rust
pub fn add_signature(
    &mut self,
    validator: AccountAddress,
    round: Round,
    signature: bls12381::Signature,
) {
    // Use insert() to update existing signatures instead of or_insert()
    self.signatures.insert(validator, (round, signature));
}
```

**Option 2: Add Duplicate Detection** (more defensive, matches vote handling)

Add duplicate/equivocation detection in `insert_round_timeout()` similar to `insert_vote()`:
```rust
// Track round timeout authors to detect duplicates
author_to_round_timeout: HashMap<Author, TwoChainTimeout>,

// In insert_round_timeout(), before processing:
if let Some(previous_timeout) = self.author_to_round_timeout.get(&round_timeout.author()) {
    if previous_timeout.hqc_round() != timeout.hqc_round() {
        // Validator sent different timeout for same round - equivocation or update
        // Either reject or explicitly handle the update
    }
}
```

**Recommended**: Implement **Option 1** as it's simpler and aligns with existing signature aggregation patterns. The `PartialSignatures` struct in the codebase uses `insert()` rather than `or_insert()`, suggesting this is the intended behavior.

## Proof of Concept

```rust
#[test]
fn test_timeout_signature_update_bug() {
    use aptos_consensus_types::{
        timeout_2chain::{TwoChainTimeout, TwoChainTimeoutWithPartialSignatures},
        quorum_cert::QuorumCert,
        vote_data::VoteData,
    };
    use aptos_types::{
        block_info::BlockInfo,
        ledger_info::{LedgerInfo, LedgerInfoWithVerifiedSignatures},
        aggregate_signature::PartialSignatures,
        validator_verifier::random_validator_verifier,
    };
    use aptos_crypto::hash::CryptoHash;

    let (signers, validators) = random_validator_verifier(4, None, false);
    
    // Create QCs for different rounds
    let create_qc = |round| {
        let vote_data = VoteData::new(BlockInfo::random(round), BlockInfo::random(0));
        let mut li = LedgerInfoWithVerifiedSignatures::new(
            LedgerInfo::new(BlockInfo::empty(), vote_data.hash()),
            PartialSignatures::empty(),
        );
        for signer in &signers[0..3] {
            let sig = signer.sign(li.ledger_info()).unwrap();
            li.add_signature(signer.author(), sig);
        }
        QuorumCert::new(vote_data, li.aggregate_signatures(&validators).unwrap())
    };

    // Validator A sends timeout with HQC round 5
    let timeout_a1 = TwoChainTimeout::new(1, 10, create_qc(5));
    let mut tc = TwoChainTimeoutWithPartialSignatures::new(timeout_a1.clone());
    tc.add(signers[0].author(), timeout_a1.clone(), timeout_a1.sign(&signers[0]).unwrap());

    // Validator B sends timeout with HQC round 6  
    let timeout_b = TwoChainTimeout::new(1, 10, create_qc(6));
    tc.add(signers[1].author(), timeout_b.clone(), timeout_b.sign(&signers[1]).unwrap());
    
    // Validator A sends UPDATED timeout with HQC round 8
    let timeout_a2 = TwoChainTimeout::new(1, 10, create_qc(8));
    tc.add(signers[0].author(), timeout_a2.clone(), timeout_a2.sign(&signers[0]).unwrap());
    
    // Validator C sends timeout with HQC round 5
    let timeout_c = TwoChainTimeout::new(1, 10, create_qc(5));
    tc.add(signers[2].author(), timeout_c.clone(), timeout_c.sign(&signers[2]).unwrap());

    // Now we have quorum - aggregate
    let tc_cert = tc.aggregate_signatures(&validators).unwrap();
    
    // BUG: Stored timeout has HQC=8, but max signed HQC is only 6
    // Verification should fail with "Inconsistent hqc round"
    let verify_result = tc_cert.verify(&validators);
    assert!(verify_result.is_err(), "TC should fail verification due to inconsistent HQC rounds");
    assert!(verify_result.unwrap_err().to_string().contains("Inconsistent hqc round"));
}
```

**Notes:**

This vulnerability represents a correctness bug in the 2-chain timeout certificate aggregation logic that can manifest during normal validator operations or be deliberately triggered. The root cause is the mismatch between the timeout update semantics (which replace the entire timeout object) and the signature tracking semantics (which use `or_insert()` to prevent updates). While all required fields are technically "initialized" at line 73-74 as the security question asks, the subsequent update logic creates an invariant violation that causes verification failures.

### Citations

**File:** consensus/src/pending_votes.rs (L189-271)
```rust
    /// Insert a RoundTimeout and return a TimeoutCertificate if it can be formed
    pub fn insert_round_timeout(
        &mut self,
        round_timeout: &RoundTimeout,
        validator_verifier: &ValidatorVerifier,
    ) -> VoteReceptionResult {
        //
        // Let's check if we can create a TC
        //

        let timeout = round_timeout.two_chain_timeout();
        let signature = round_timeout.signature();

        let validator_voting_power = validator_verifier
            .get_voting_power(&round_timeout.author())
            .unwrap_or(0);
        if validator_voting_power == 0 {
            warn!(
                "Received vote with no voting power, from {}",
                round_timeout.author()
            );
        }
        let cur_epoch = round_timeout.epoch();
        let cur_round = round_timeout.round();

        counters::CONSENSUS_CURRENT_ROUND_TIMEOUT_VOTED_POWER
            .with_label_values(&[&round_timeout.author().to_string()])
            .set(validator_voting_power as f64);
        counters::CONSENSUS_LAST_TIMEOUT_VOTE_EPOCH
            .with_label_values(&[&round_timeout.author().to_string()])
            .set(cur_epoch as i64);
        counters::CONSENSUS_LAST_TIMEOUT_VOTE_ROUND
            .with_label_values(&[&round_timeout.author().to_string()])
            .set(cur_round as i64);

        let two_chain_votes = self
            .maybe_2chain_timeout_votes
            .get_or_insert_with(|| TwoChainTimeoutVotes::new(timeout.clone()));
        two_chain_votes.add(
            round_timeout.author(),
            timeout.clone(),
            signature.clone(),
            round_timeout.reason().clone(),
        );

        let partial_tc = two_chain_votes.partial_2chain_tc_mut();
        let tc_voting_power =
            match validator_verifier.check_voting_power(partial_tc.signers(), true) {
                Ok(_) => {
                    return match partial_tc.aggregate_signatures(validator_verifier) {
                        Ok(tc_with_sig) => {
                            VoteReceptionResult::New2ChainTimeoutCertificate(Arc::new(tc_with_sig))
                        },
                        Err(e) => VoteReceptionResult::ErrorAggregatingTimeoutCertificate(e),
                    };
                },
                Err(VerifyError::TooLittleVotingPower { voting_power, .. }) => voting_power,
                Err(error) => {
                    error!(
                        "MUST_FIX: 2-chain timeout vote received could not be added: {}, vote: {}",
                        error, timeout
                    );
                    return VoteReceptionResult::ErrorAddingVote(error);
                },
            };

        // Echo timeout if receive f+1 timeout message.
        if !self.echo_timeout {
            let f_plus_one = validator_verifier.total_voting_power()
                - validator_verifier.quorum_voting_power()
                + 1;
            if tc_voting_power >= f_plus_one {
                self.echo_timeout = true;
                return VoteReceptionResult::EchoTimeout(tc_voting_power);
            }
        }

        //
        // No TC could be formed, return the TC's voting power
        //

        VoteReceptionResult::VoteAdded(tc_voting_power)
    }
```

**File:** consensus/src/pending_votes.rs (L287-309)
```rust
        if let Some((previously_seen_vote, previous_li_digest)) =
            self.author_to_vote.get(&vote.author())
        {
            // is it the same vote?
            if &li_digest == previous_li_digest {
                // we've already seen an equivalent vote before
                let new_timeout_vote = vote.is_timeout() && !previously_seen_vote.is_timeout();
                if !new_timeout_vote {
                    // it's not a new timeout vote
                    return VoteReceptionResult::DuplicateVote;
                }
            } else {
                // we have seen a different vote for the same round
                error!(
                    SecurityEvent::ConsensusEquivocatingVote,
                    remote_peer = vote.author(),
                    vote = vote,
                    previous_vote = previously_seen_vote
                );

                return VoteReceptionResult::EquivocateVote;
            }
        }
```

**File:** consensus/consensus-types/src/timeout_2chain.rs (L170-181)
```rust
        let signed_hqc = self
            .signatures_with_rounds
            .rounds()
            .iter()
            .max()
            .ok_or_else(|| anyhow::anyhow!("Empty rounds"))?;
        ensure!(
            hqc_round == *signed_hqc,
            "Inconsistent hqc round, qc has round {}, highest signed round {}",
            hqc_round,
            *signed_hqc
        );
```

**File:** consensus/consensus-types/src/timeout_2chain.rs (L242-263)
```rust
    pub fn add(
        &mut self,
        author: Author,
        timeout: TwoChainTimeout,
        signature: bls12381::Signature,
    ) {
        debug_assert_eq!(
            self.timeout.epoch(),
            timeout.epoch(),
            "Timeout should have the same epoch as TimeoutCert"
        );
        debug_assert_eq!(
            self.timeout.round(),
            timeout.round(),
            "Timeout should have the same round as TimeoutCert"
        );
        let hqc_round = timeout.hqc_round();
        if timeout.hqc_round() > self.timeout.hqc_round() {
            self.timeout = timeout;
        }
        self.signatures.add_signature(author, hqc_round, signature);
    }
```

**File:** consensus/consensus-types/src/timeout_2chain.rs (L320-329)
```rust
    pub fn add_signature(
        &mut self,
        validator: AccountAddress,
        round: Round,
        signature: bls12381::Signature,
    ) {
        self.signatures
            .entry(validator)
            .or_insert((round, signature));
    }
```

**File:** consensus/consensus-types/src/proposal_msg.rs (L112-115)
```rust
        // if there is a timeout certificate, verify its signatures
        if let Some(tc) = self.sync_info.highest_2chain_timeout_cert() {
            tc.verify(validator).map_err(|e| format_err!("{:?}", e))?;
        }
```
