# Audit Report

## Title
Missing Progress Validation in Sub-Pruner Initialization Causes Integer Underflow and Node Crash

## Summary
The `get_or_initialize_subpruner_progress()` function does not validate that stored pruner progress values are less than or equal to the current ledger version (metadata_progress). When database corruption or improper backup/restore causes a sub-pruner's stored progress to exceed the metadata progress, this leads to integer underflow during pruning operations, causing validator node crashes or severe performance degradation.

## Finding Description

The pruner subsystem maintains multiple sub-pruners (EventStorePruner, TransactionPruner, etc.) that track their pruning progress independently in the database. During initialization, each sub-pruner calls `get_or_initialize_subpruner_progress()` to retrieve or initialize its progress value. [1](#0-0) 

This function **does not validate** that the stored progress is less than or equal to `metadata_progress` (which represents the current LedgerPrunerProgress). It blindly returns whatever value is stored in the database.

When a sub-pruner is initialized with progress > metadata_progress, it attempts to "catch up" by calling `prune(progress, metadata_progress)`: [2](#0-1) 

In EventStorePruner, this causes a critical integer underflow in `prune_event_indices()`: [3](#0-2) 

At line 202, when `start > end`, the expression `(end - start)` triggers unsigned integer underflow:
- **Debug mode**: Causes immediate panic, crashing the node
- **Release mode**: Wraps to ~u64::MAX, attempting to iterate over billions of versions, exhausting memory and causing the node to hang

This can occur through:
1. **Database corruption**: Hardware failures or bugs writing invalid progress values
2. **Improper backup/restore**: Restoring ledger data from an old backup while keeping newer pruner metadata
3. **Manual database manipulation**: Direct database edits during debugging/recovery
4. **Pruner implementation bugs**: Race conditions or bugs that write future progress values

## Impact Explanation

This is a **High Severity** vulnerability per Aptos bug bounty criteria because it causes **validator node crashes and significant protocol violations**:

1. **Validator Node Crashes**: In debug builds (commonly used during development and testing), the integer underflow causes an immediate panic, crashing the validator
2. **Resource Exhaustion**: In release builds, attempting to iterate over ~u64::MAX versions causes:
   - Out-of-memory errors
   - Node hangs/freezes requiring manual restart
   - Inability to participate in consensus
3. **Network Impact**: Multiple validators experiencing this simultaneously (e.g., after a common backup/restore procedure) could severely impact network liveness
4. **Silent Failure**: The lack of early validation means the database inconsistency goes undetected until pruning begins, making diagnosis difficult

While not directly exploitable by external attackers, this breaks the **State Consistency** invariant and violates **Resource Limits**, causing operational failures that affect network availability.

## Likelihood Explanation

**Likelihood: Medium to High** in the following scenarios:

1. **Database Corruption**: Hardware failures, filesystem corruption, or bugs in database operations can write invalid progress values
2. **Backup/Restore Operations**: Common operational procedure where ledger data and metadata may be restored from different points in time
3. **Disaster Recovery**: After node failures, administrators may attempt manual database repairs or selective restores
4. **Software Bugs**: Race conditions or logic errors in pruner progress tracking could write future versions
5. **Cross-Version Compatibility**: Database format changes between versions could lead to misinterpreted progress values

The vulnerability **will definitely trigger** if the stored progress exceeds metadata_progress, making it a deterministic failure once the precondition is met.

## Recommendation

Add explicit validation in `get_or_initialize_subpruner_progress()` to ensure stored progress never exceeds the expected maximum:

```rust
pub(crate) fn get_or_initialize_subpruner_progress(
    sub_db: &DB,
    progress_key: &DbMetadataKey,
    metadata_progress: Version,
) -> Result<Version> {
    Ok(
        if let Some(v) = sub_db.get::<DbMetadataSchema>(progress_key)? {
            let stored_progress = v.expect_version();
            // VALIDATION: Ensure stored progress is not ahead of metadata progress
            if stored_progress > metadata_progress {
                aptos_logger::error!(
                    progress_key = ?progress_key,
                    stored_progress = stored_progress,
                    metadata_progress = metadata_progress,
                    "Detected invalid sub-pruner progress ahead of metadata progress. \
                     This indicates database corruption or improper restore. \
                     Resetting to metadata_progress."
                );
                // Reset to safe value and persist
                sub_db.put::<DbMetadataSchema>(
                    progress_key,
                    &DbMetadataValue::Version(metadata_progress),
                )?;
                metadata_progress
            } else {
                stored_progress
            }
        } else {
            sub_db.put::<DbMetadataSchema>(
                progress_key,
                &DbMetadataValue::Version(metadata_progress),
            )?;
            metadata_progress
        },
    )
}
```

Additionally, add defensive checks in pruning functions that perform arithmetic on version ranges:

```rust
pub(crate) fn prune_event_indices(
    &self,
    start: Version,
    end: Version,
    mut indices_batch: Option<&mut SchemaBatch>,
) -> Result<Vec<usize>> {
    // Defensive check
    ensure!(
        end >= start,
        "Invalid pruning range: end ({}) < start ({}). This indicates database corruption.",
        end,
        start
    );
    
    let mut ret = Vec::new();
    let mut current_version = start;
    
    for events in self.get_events_by_version_iter(start, (end - start) as usize)? {
        // ... rest of implementation
    }
    
    Ok(ret)
}
```

## Proof of Concept

```rust
#[cfg(test)]
mod test {
    use super::*;
    use aptos_schemadb::DB;
    use aptos_temppath::TempPath;
    use aptos_types::transaction::Version;
    
    #[test]
    #[should_panic(expected = "attempt to subtract with overflow")]
    fn test_pruner_progress_underflow() {
        // Create temporary database
        let tmpdir = TempPath::new();
        let db = DB::open(
            tmpdir.path(),
            "test_db",
            vec![DbMetadataSchema::column_family_name()],
            &Default::default(),
        )
        .unwrap();
        
        // Simulate corrupted state: stored progress is ahead of metadata progress
        let corrupted_progress: Version = 1000;
        let metadata_progress: Version = 500;
        
        // Write corrupted progress to database
        db.put::<DbMetadataSchema>(
            &DbMetadataKey::EventPrunerProgress,
            &DbMetadataValue::Version(corrupted_progress),
        )
        .unwrap();
        
        // This should validate and prevent the underflow, but currently doesn't
        let progress = get_or_initialize_subpruner_progress(
            &db,
            &DbMetadataKey::EventPrunerProgress,
            metadata_progress,
        )
        .unwrap();
        
        // Progress is now 1000, metadata_progress is 500
        assert_eq!(progress, corrupted_progress);
        assert!(progress > metadata_progress);
        
        // This will cause integer underflow: (500 - 1000) as usize
        // In debug mode: panic
        // In release mode: wraps to very large number (~18 quintillion)
        let num_to_iterate = (metadata_progress - progress) as usize;
        
        // This line will never execute in debug due to panic above
        println!("Would attempt to iterate {} versions", num_to_iterate);
    }
}
```

This test demonstrates that when stored progress exceeds metadata_progress, the arithmetic operation `(metadata_progress - progress)` causes integer underflow, leading to node crash in debug mode or attempting to iterate over ~u64::MAX versions in release mode.

## Notes

The vulnerability affects multiple sub-pruners that use `get_or_initialize_subpruner_progress()`:
- EventStorePruner (confirmed vulnerable to underflow)
- TransactionPruner (has validation in get_pruning_candidate_transactions)
- TransactionInfoPruner (safe due to using range operator)
- TransactionAccumulatorPruner (safe due to using range operator)
- WriteSetPruner (safe due to using range operator)
- PersistedAuxiliaryInfoPruner (likely safe)
- TransactionAuxiliaryDataPruner (likely safe)
- State pruners (StateKvShardPruner, StateMerkleShardPruner)

The root cause is the missing validation in the utility function combined with arithmetic operations in some pruners. The fix should be applied at the utility function level to protect all callers.

### Citations

**File:** storage/aptosdb/src/pruner/pruner_utils.rs (L44-60)
```rust
pub(crate) fn get_or_initialize_subpruner_progress(
    sub_db: &DB,
    progress_key: &DbMetadataKey,
    metadata_progress: Version,
) -> Result<Version> {
    Ok(
        if let Some(v) = sub_db.get::<DbMetadataSchema>(progress_key)? {
            v.expect_version()
        } else {
            sub_db.put::<DbMetadataSchema>(
                progress_key,
                &DbMetadataValue::Version(metadata_progress),
            )?;
            metadata_progress
        },
    )
}
```

**File:** storage/aptosdb/src/pruner/ledger_pruner/transaction_pruner.rs (L78-104)
```rust
    pub(in crate::pruner) fn new(
        transaction_store: Arc<TransactionStore>,
        ledger_db: Arc<LedgerDb>,
        metadata_progress: Version,
        internal_indexer_db: Option<InternalIndexerDB>,
    ) -> Result<Self> {
        let progress = get_or_initialize_subpruner_progress(
            ledger_db.transaction_db_raw(),
            &DbMetadataKey::TransactionPrunerProgress,
            metadata_progress,
        )?;

        let myself = TransactionPruner {
            transaction_store,
            ledger_db,
            internal_indexer_db,
        };

        info!(
            progress = progress,
            metadata_progress = metadata_progress,
            "Catching up TransactionPruner."
        );
        myself.prune(progress, metadata_progress)?;

        Ok(myself)
    }
```

**File:** storage/aptosdb/src/ledger_db/event_db.rs (L192-222)
```rust
    pub(crate) fn prune_event_indices(
        &self,
        start: Version,
        end: Version,
        mut indices_batch: Option<&mut SchemaBatch>,
    ) -> Result<Vec<usize>> {
        let mut ret = Vec::new();

        let mut current_version = start;

        for events in self.get_events_by_version_iter(start, (end - start) as usize)? {
            let events = events?;
            ret.push(events.len());

            if let Some(ref mut batch) = indices_batch {
                for event in events {
                    if let ContractEvent::V1(v1) = event {
                        batch.delete::<EventByKeySchema>(&(*v1.key(), v1.sequence_number()))?;
                        batch.delete::<EventByVersionSchema>(&(
                            *v1.key(),
                            current_version,
                            v1.sequence_number(),
                        ))?;
                    }
                }
            }
            current_version += 1;
        }

        Ok(ret)
    }
```
