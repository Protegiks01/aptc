# Audit Report

## Title
Backup Poisoning via Unverified Ledger Info Import in Epoch Ending Restore

## Summary
The epoch ending restore process fails to cryptographically verify the first ledger info when restoring from backups without trusted waypoints. This allows attackers with compromised backup access to inject malicious ledger infos that are blindly imported into the database, causing validator node startup failures or potential consensus violations if waypoint verification is bypassed.

## Finding Description

The vulnerability exists in the epoch ending ledger info restoration logic where cryptographic verification is missing for the initial ledger info when no trusted waypoint is provided.

The verification logic in `preheat_impl()` has two conditional branches: [1](#0-0) 

**The Critical Gap:** The `previous_li` variable is initialized as `None`: [2](#0-1) 

For the first ledger info during restore:
- If no trusted waypoint exists for that version → first branch fails
- Since `previous_li` is `None` → second branch fails
- **No else clause exists** → ledger info is accepted without any cryptographic verification

The unverified ledger info is then added to the list and saved to the database: [3](#0-2) 

Trusted waypoints are optional CLI parameters with empty defaults: [4](#0-3) 

The unverified ledger infos are eventually committed to the database via the restore handler: [5](#0-4) 

**Attack Propagation:** When the validator node starts up, it reads the unverified ledger info from the database to initialize the epoch state: [6](#0-5) 

This calls `get_latest_epoch_state()` which reads the compromised ledger info: [7](#0-6) 

The fake `next_epoch_state` from the unverified ledger info becomes the trusted validator set for the bootstrapper, breaking the chain of trust.

## Impact Explanation

**HIGH Severity (Guaranteed Impact):**
- **Validator Node Unavailability**: When properly configured with a genesis waypoint, the node startup will detect the mismatch during waypoint verification and panic, causing denial of service. The verification occurs here: [8](#0-7) 

- **Silent Database Corruption**: The restore completes without errors, leaving operators unaware that the database contains cryptographically unverified data until node startup fails.

- **Operational Disruption**: Forces complete database wipe and re-restore from clean backup source.

**CRITICAL Severity (Potential Escalation):**
- If waypoint verification is misconfigured or bypassed, the validator would operate with an attacker-controlled validator set, enabling consensus safety violations and potential non-recoverable network partition.

Per Aptos Bug Bounty criteria, this qualifies as **HIGH Severity** ("Validator Node Slowdowns" due to startup DoS) with potential escalation to **CRITICAL** ("Consensus/Safety Violations" and "Non-recoverable Network Partition").

## Likelihood Explanation

**Likelihood: Medium-High**

Factors increasing likelihood:
1. **Optional Security Parameter**: The `--trust-waypoint` flag is optional with no enforcement, warnings, or validation that it was provided
2. **Default Unsafe Behavior**: Empty trusted waypoints is the default, making the unsafe path the default path
3. **Documentation Gap**: CLI help emphasizes "compatibility checking" rather than emphasizing this is a critical security requirement
4. **Realistic Attack Vector**: Compromised backup storage or MitM attacks on backup retrieval are realistic threats for blockchain infrastructure
5. **Human Error**: Operators following incomplete procedures or automation scripts may easily omit the optional flag

Factors limiting likelihood:
1. **Waypoint Verification at Startup**: Properly configured nodes will detect and reject corrupted state (though causing DoS)
2. **Requires Backup Compromise**: Attacker needs write access to backup storage or network position for MitM

## Recommendation

1. **Make Trusted Waypoints Required**: For epoch 0 restores, require at least the genesis waypoint to be provided via `--trust-waypoint`. Fail early with clear error message if omitted.

2. **Add Explicit Verification**: Add an explicit else clause that fails when neither verification method succeeds:
```rust
if let Some(wp_trusted) = self.trusted_waypoints.get(&wp_li.version()) {
    // Verify against trusted waypoint
    ensure!(*wp_trusted == wp_li, "Waypoint mismatch");
} else if let Some(pre_li) = previous_li {
    // Verify signatures using previous epoch state
    pre_li.ledger_info().next_epoch_state()?.verify(&li)?;
} else {
    // NEW: Explicitly fail if no verification possible
    bail!(
        "Cannot verify ledger info at version {} epoch {}: \
        no trusted waypoint provided and no previous epoch state available. \
        Use --trust-waypoint to provide a trusted waypoint for verification.",
        li.ledger_info().version(),
        li.ledger_info().epoch()
    );
}
```

3. **Document Security Requirements**: Update documentation to emphasize that `--trust-waypoint` is a security requirement, not optional for production use.

4. **Add Restore Validation Mode**: Implement a post-restore validation that verifies all restored ledger infos against configured waypoints before the database is considered valid.

## Proof of Concept

While a full PoC requires setting up backup infrastructure, the vulnerability can be demonstrated through code inspection:

1. Create malicious backup with fake epoch 0 ledger info containing attacker-controlled validator set
2. Run restore without `--trust-waypoint`:
   ```bash
   aptos-db-tool restore epoch-ending \
     --epoch-ending-manifest <malicious_manifest> \
     --target-db-dir /path/to/db
     # Note: --trust-waypoint flag omitted
   ```
3. The fake ledger info passes through verification at lines 129-147 without triggering either branch
4. Unverified data is saved to database at line 249
5. Node startup reads compromised epoch state at aptosdb_reader.rs:698
6. Node either:
   - Panics during waypoint verification (DoS) if properly configured
   - Operates with fake validator set (consensus violation) if misconfigured

The vulnerability is evident from the code structure: there is no else clause to handle the case where both verification methods are unavailable, allowing unverified data to proceed to database storage.

### Citations

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L88-88)
```rust
        let mut previous_li: Option<&LedgerInfoWithSignatures> = None;
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L129-147)
```rust
                if let Some(wp_trusted) = self.trusted_waypoints.get(&wp_li.version()) {
                    ensure!(
                        *wp_trusted == wp_li,
                        "Waypoints don't match. In backup: {}, trusted: {}",
                        wp_li,
                        wp_trusted,
                    );
                } else if let Some(pre_li) = previous_li {
                    pre_li
                        .ledger_info()
                        .next_epoch_state()
                        .ok_or_else(|| {
                            anyhow!(
                                "Next epoch state not found from LI at epoch {}.",
                                pre_li.ledger_info().epoch()
                            )
                        })?
                        .verify(&li)?;
                }
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L148-149)
```rust
                ledger_infos.push(li);
                previous_li = ledger_infos.last();
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L248-249)
```rust
            RestoreRunMode::Restore { restore_handler } => {
                restore_handler.save_ledger_infos(&preheat_data.ledger_infos)?;
```

**File:** storage/backup/backup-cli/src/utils/mod.rs (L331-346)
```rust
#[derive(Clone, Default, Parser)]
pub struct TrustedWaypointOpt {
    #[clap(
        long,
        help = "(multiple) When provided, an epoch ending LedgerInfo at the waypoint version will be \
        checked against the hash in the waypoint, but signatures on it are NOT checked. \
        Use this for two purposes: \
        1. set the genesis or the latest waypoint to confirm the backup is compatible. \
        2. set waypoints at versions where writeset transactions were used to overwrite the \
        validator set, so that the signature check is skipped. \
        N.B. LedgerInfos are verified only when restoring / verifying the epoch ending backups, \
        i.e. they are NOT checked at all when doing one-shot restoring of the transaction \
        and state backups."
    )]
    pub trust_waypoint: Vec<Waypoint>,
}
```

**File:** state-sync/state-sync-driver/src/bootstrapper.rs (L132-166)
```rust
    fn verify_waypoint(
        &mut self,
        epoch_ending_ledger_info: &LedgerInfoWithSignatures,
        waypoint: &Waypoint,
    ) -> Result<(), Error> {
        if !self.verified_waypoint {
            // Fetch the waypoint and ledger info versions
            let waypoint_version = waypoint.version();
            let ledger_info = epoch_ending_ledger_info.ledger_info();
            let ledger_info_version = ledger_info.version();

            // Verify we haven't missed the waypoint
            if ledger_info_version > waypoint_version {
                panic!(
                    "Failed to verify the waypoint: ledger info version is too high! Waypoint version: {:?}, ledger info version: {:?}",
                    waypoint_version, ledger_info_version
                );
            }

            // Check if we've found the ledger info corresponding to the waypoint version
            if ledger_info_version == waypoint_version {
                match waypoint.verify(ledger_info) {
                    Ok(()) => self.set_verified_waypoint(waypoint_version),
                    Err(error) => {
                        panic!(
                            "Failed to verify the waypoint: {:?}! Waypoint: {:?}, given ledger info: {:?}",
                            error, waypoint, ledger_info
                        );
                    },
                }
            }
        }

        Ok(())
    }
```

**File:** state-sync/state-sync-driver/src/bootstrapper.rs (L341-344)
```rust
        // Load the latest epoch state from storage
        let latest_epoch_state = utils::fetch_latest_epoch_state(storage.clone())
            .expect("Unable to fetch latest epoch state!");
        let verified_epoch_states = VerifiedEpochStates::new(latest_epoch_state);
```

**File:** storage/aptosdb/src/db/aptosdb_reader.rs (L697-706)
```rust
        gauged_api("get_latest_epoch_state", || {
            let latest_ledger_info = self.ledger_db.metadata_db().get_latest_ledger_info()?;
            match latest_ledger_info.ledger_info().next_epoch_state() {
                Some(epoch_state) => Ok(epoch_state.clone()),
                None => self
                    .ledger_db
                    .metadata_db()
                    .get_epoch_state(latest_ledger_info.ledger_info().epoch()),
            }
        })
```
