# Audit Report

## Title
Dudect Framework False Negative: Incomplete Constant-Time Testing Excludes Known Timing Leak in BLS Scalar Multiplication

## Summary
The dudect-bencher constant-time verification framework used in production validators is configured to deliberately exclude testing scalar multiplication with scalar = 0, despite documented knowledge that "blstrs is faster when the scalar is exactly 0". This creates a false negative where the test passes at validator startup, giving false confidence in constant-time guarantees while a known timing leak exists in the underlying cryptographic implementation.

## Finding Description

The pepper service, which handles critical VUF (Verifiable Unpredictable Function) operations for the keyless account system, performs constant-time verification tests at startup before processing requests. These tests use the dudect-bencher statistical framework to detect timing leaks in BLS12-381 scalar multiplication operations. [1](#0-0) 

However, the test configuration in the blstrs scalar multiplication benchmark deliberately excludes testing with scalar = 0: [2](#0-1) 

This is particularly concerning given the explicit warning comment in the same file: [3](#0-2) 

Notably, the zkcrypto scalar multiplication test uses a different configuration that DOES include testing with 0 bits: [4](#0-3) 

The VUF evaluation function, which uses the VUF private key for scalar multiplication, includes a warning that it must remain constant-time: [5](#0-4) 

The test distribution is also highly skewed, testing only extremely sparse scalars (1-3 bits) against very dense scalars (200 bits), potentially missing timing leaks at intermediate densities: [6](#0-5) 

## Impact Explanation

**Severity Assessment: High**

While this does not constitute a **Critical** vulnerability (no direct loss of funds or consensus violation), it represents a **High severity** issue because:

1. **Security Guarantee Violation**: The constant-time property is explicitly required for cryptographic operations involving private keys to prevent side-channel attacks.

2. **False Confidence**: Production validators believe their cryptographic operations are constant-time verified, but the verification deliberately excludes known problematic cases.

3. **Scope**: This affects the keyless pepper service, which handles sensitive VUF private key operations for account creation and recovery.

However, this does **not** meet Critical severity because:
- Direct exploitation requires causing scalar = 0 in production (astronomically unlikely given key derivation via SHA3-512)
- Remote timing attacks require precise measurement capabilities
- No demonstrated path to funds loss or consensus violation

## Likelihood Explanation

**Likelihood: Low**

The likelihood of actual exploitation is low because:

1. **VUF Private Key Generation**: The VUF private key is derived from SHA3-512 hash of a seed or directly deserialized, making probability of scalar = 0 negligible (2^-256). [7](#0-6) 

2. **Network Constraints**: Remote timing measurement of scalar multiplication operations is extremely challenging in distributed systems.

3. **Verification Step**: The VUF output is verified after evaluation, which would catch fault-injection attempts. [8](#0-7) 

However, the issue remains valid because:
- Testing frameworks should detect ALL timing leaks, not selectively exclude known ones
- Scalar multiplication is used in other contexts (Shamir secret sharing, DKG) where near-zero scalars might occur
- The codebase has explicit functions to exclude zero scalars, indicating awareness of the concern [9](#0-8) 

## Recommendation

1. **Modify the blstrs dudect test to include scalar = 0 testing**, matching the zkcrypto configuration:

```rust
let min_num_bits_left = 0;  // Changed from 1 to 0
let max_num_bits_left = 4;
```

2. **Expand test coverage** to include intermediate scalar densities (e.g., 50, 100, 150 bits set) rather than only extreme cases.

3. **Increase sample size** from N = 5,000 to at least N = 10,000 (matching zkcrypto) or higher for better statistical power.

4. **Document the known timing leak** and either:
   - Fix the underlying blstrs implementation to be constant-time for scalar = 0
   - Add runtime assertions to detect and prevent scalar = 0 in cryptographic operations
   - Accept the risk and document it explicitly

5. **Add continuous monitoring** rather than one-time startup testing.

## Proof of Concept

```rust
// Run this test to demonstrate the false negative
// File: crates/aptos-crypto/src/unit_tests/constant_time_test.rs

#[test]
#[ignore]
fn test_blstrs_scalar_mul_with_zero_scalar() {
    use crate::constant_time::blstrs_scalar_mul;
    use dudect_bencher::{BenchRng, Class, CtRunner};
    use blstrs::{G1Projective, Scalar};
    use group::Group;
    use std::hint::black_box;
    use std::ops::Mul;
    
    let mut runner = CtRunner::new();
    let mut rng = BenchRng::new();
    
    // Test with scalar = 0 vs scalar = 1
    for _ in 0..10_000 {
        let base = G1Projective::generator();
        let choice = rng.gen::<bool>();
        
        if choice {
            // Class Left: scalar = 0
            runner.run_one(Class::Left, || {
                black_box(base.mul(&Scalar::ZERO));
            });
        } else {
            // Class Right: scalar = 1  
            runner.run_one(Class::Right, || {
                black_box(base.mul(&Scalar::ONE));
            });
        }
    }
    
    // This test would likely FAIL (detect timing leak)
    // proving that the current test configuration creates false negatives
}
```

To run:
```bash
cargo test --release -p aptos-crypto test_blstrs_scalar_mul_with_zero_scalar -- --ignored --nocapture
```

## Notes

- The dudect-bencher framework itself is sound; the issue lies in its configuration
- The threshold of ABS_MAX_T = 5 is taken from the dudect paper
- The codebase uses a patched version of dudect-bencher exposing additional functions
- This affects the keyless pepper service which is a critical component for account recovery [10](#0-9) [11](#0-10)

### Citations

**File:** keyless/pepper/service/src/main.rs (L150-154)
```rust
/// The DudeCT statistical test must output a `max_t` value whose absolute value is <= to this.
///
/// Docs here: https://docs.rs/dudect-bencher/latest/dudect_bencher/
/// Original paper here: https://eprint.iacr.org/2016/1123.pdf
const ABS_MAX_T: i64 = 5;
```

**File:** keyless/pepper/service/src/main.rs (L363-392)
```rust
/// Verifies that scalar multiplication is constant time
fn verify_constant_time_scalar_multiplication() {
    // Run the constant time benchmarks for random bases
    let abs_max_t = ctbench::run_bench(
        &BenchName("blstrs_scalar_mul/random_bases"),
        constant_time::blstrs_scalar_mul::run_bench_with_random_bases,
        None,
    )
    .1
    .max_t
    .abs()
    .ceil()
    .to_i64()
    .expect("Floating point arithmetic went awry.");
    assert_le!(abs_max_t, ABS_MAX_T);

    // Run the constant time benchmarks for fixed bases
    let abs_max_t = ctbench::run_bench(
        &BenchName("blstrs_scalar_mul/fixed_bases"),
        constant_time::blstrs_scalar_mul::run_bench_with_fixed_bases,
        None,
    )
    .1
    .max_t
    .abs()
    .ceil()
    .to_i64()
    .expect("Floating point arithmetic went awry.");
    assert_le!(abs_max_t, ABS_MAX_T);
}
```

**File:** crates/aptos-crypto/src/constant_time/blstrs_scalar_mul.rs (L79-90)
```rust
    let min_num_bits_left = 1;
    let max_num_bits_left = 4;
    let num_bits_right = 200; //BIT_SIZE.div_ceil(2) + 1;
    eprintln!();
    eprintln!(
        "# of 1 bits in scalars for \"left\" class is in [{}, {})",
        min_num_bits_left, max_num_bits_left
    );
    eprintln!(
        "# of 1 bits in scalars for \"right\" class is always {}",
        num_bits_right
    );
```

**File:** crates/aptos-crypto/src/constant_time/blstrs_scalar_mul.rs (L101-101)
```rust
            // WARNING: `blstrs` is faster when the scalar is exactly 0!
```

**File:** crates/aptos-crypto/src/constant_time/zkcrypto_scalar_mul.rs (L65-67)
```rust
    let min_num_bits_left = 0;
    let max_num_bits_left = 4;
    let num_bits_right = BIT_SIZE.div_ceil(2) + 1;
```

**File:** keyless/pepper/common/src/vuf/bls12381_g1_bls.rs (L81-87)
```rust
    /// WARNING: This function must remain constant-time w.r.t. to `sk` and `input`.
    fn eval(sk: &Scalar, input: &[u8]) -> anyhow::Result<(Vec<u8>, Vec<u8>)> {
        let input_g1 = Self::hash_to_g1(input);
        let output_g1 = input_g1.mul(sk);
        let output_bytes = output_g1.to_compressed().to_vec();
        Ok((output_bytes, vec![]))
    }
```

**File:** keyless/pepper/service/src/vuf_keypair.rs (L72-76)
```rust
    // Hash the seed to derive the private key
    let mut sha3_hasher = sha3::Sha3_512::new();
    sha3_hasher.update(vuf_private_key_seed);
    let vuf_private_key = scalar_from_uniform_be_bytes(sha3_hasher.finalize().as_slice());

```

**File:** keyless/pepper/service/src/dedicated_handlers/pepper_request.rs (L178-189)
```rust
    // Verify the pepper base output (this ensures we only ever return valid outputs,
    // and protects against various security issues, e.g., fault based side channels).
    vuf::bls12381_g1_bls::Bls12381G1Bls::verify(
        vuf_keypair.vuf_public_key(),
        &input_bytes,
        &pepper_base,
        &vuf_proof,
    )
    .map_err(|error| {
        PepperServiceError::InternalError(format!("VUF verification failed: {}", error))
    })?;

```

**File:** crates/aptos-crypto/src/blstrs/mod.rs (L174-190)
```rust
/// Returns a random `blstrs::Scalar`, optionally restricted to be non-zero.
pub fn random_scalar_internal<R>(rng: &mut R, exclude_zero: bool) -> Scalar
where
    R: rand_core::RngCore + rand::Rng + rand_core::CryptoRng + rand::CryptoRng,
{
    let mut big_uint;

    loop {
        // NOTE(Alin): This uses rejection-sampling (e.g., https://cs.stackexchange.com/a/2578/54866)
        // An alternative would be to sample twice the size of the scalar field and use
        // `random_scalar_from_uniform_bytes`, but that is actually slower (950ns vs 623ns)
        big_uint = rng.gen_biguint_below(&SCALAR_FIELD_ORDER);

        // Some key material cannot be zero since it needs to have an inverse in the scalar field.
        if !exclude_zero || !big_uint.is_zero() {
            break;
        }
```

**File:** Cargo.toml (L961-963)
```text
[patch.crates-io]
# version 0.6 at commit 444eb13579c733089453806743b19f1ea2dce1c0 did not expose 'run_bench_with_bencher' as a public function, which we need
dudect-bencher = { git = "https://github.com/aptos-labs/dudect-bencher", rev = "9515677c83c58884c1a8c764251753269d46fc0e" }
```
