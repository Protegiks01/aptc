# Audit Report

## Title
IP Header Spoofing Allows Bypass of Faucet Rate Limits and Amount Restrictions

## Summary
The Aptos faucet service trusts client-provided HTTP headers (X-Forwarded-For, X-Real-IP) to determine the source IP address without proper validation. When combined with IP allowlist bypass configuration and elevated funding limits (`maximum_amount_with_bypass`), an attacker can spoof their IP to appear as an allowlisted address, bypassing all security checkers and requesting amounts exceeding normal user limits.

## Finding Description
The faucet service uses poem's `RealIp` extractor to determine the client's source IP address for security decisions, including IP allowlist matching. [1](#0-0) 

The `RealIp` extractor automatically parses proxy headers like X-Forwarded-For and X-Real-IP. [2](#0-1) 

This extracted IP is then used by the `IpAllowlistBypasser` to determine if a request should bypass all security checkers. [3](#0-2) 

When a bypasser allows a request through, the `bypass` flag is set to true and passed to the funder. [4](#0-3) 

The funder then uses different maximum amount limits based on this bypass flag. [5](#0-4) 

For `MintFunder`, when `did_bypass_checkers` is true and `maximum_amount_with_bypass` is configured, users can request amounts up to this higher limit. [6](#0-5) 

**Attack Path:**
1. Attacker discovers that the faucet has IP allowlist bypass configured (e.g., for CI infrastructure at `10.0.0.0/8`)
2. Attacker sends HTTP request with spoofed header: `X-Forwarded-For: 10.0.0.5`
3. `RealIp` extractor trusts this header and returns `10.0.0.5` as source IP
4. `IpAllowlistBypasser` matches against allowlist and returns true
5. All security checkers (rate limiting, captcha) are bypassed
6. Attacker can request `maximum_amount_with_bypass` (e.g., 10000 OCTA) instead of `maximum_amount` (e.g., 100 OCTA)
7. Attacker repeats this to drain the faucet

## Impact Explanation
This vulnerability allows **limited funds loss or manipulation** from testnet/devnet faucets, qualifying as **Medium Severity** under the Aptos bug bounty criteria. While the faucet is not a mainnet component, successful exploitation could:

- Drain testnet faucet funds, disrupting developer testing
- Bypass rate limiting to perform resource exhaustion
- Undermine the security controls intended to prevent abuse

The configuration file shows `maximum_amount: 100` vs `maximum_amount_with_bypass: 10000` (100x difference). [7](#0-6) 

## Likelihood Explanation
This vulnerability is **MEDIUM to HIGH likelihood** in specific deployment scenarios:

**Vulnerable deployments:**
- Faucet directly exposed to internet without reverse proxy
- Reverse proxy that doesn't strip client-provided forwarding headers
- Internal network where attackers can reach the faucet directly

**Required conditions:**
- IP allowlist bypass must be configured
- `maximum_amount_with_bypass` must be set higher than `maximum_amount`
- No proper reverse proxy sanitizing headers

The codebase includes HAProxy configurations suggesting proper deployment is expected, but there's no enforcement in the application layer to validate the trustworthiness of the IP source.

## Recommendation
Implement one or more of the following mitigations:

**Option 1: Add trusted proxy configuration**
Add configuration to specify which proxy IPs to trust, and only accept forwarding headers from those sources. Reject client-provided headers when no trusted proxy is in the path.

**Option 2: Add header validation**
Validate that X-Forwarded-For/X-Real-IP headers are only trusted when the direct connection comes from a configured trusted proxy IP range.

**Option 3: Use socket peer address**
For critical security decisions like allowlist matching, use the actual TCP socket peer address instead of trusting HTTP headers.

**Option 4: Add deployment validation**
Add startup checks to warn/fail if IP allowlist bypass is enabled but no reverse proxy configuration is detected.

**Example fix for Option 1:**
Add to `RunConfig`:
```rust
pub struct NetworkConfig {
    pub trusted_proxies: Vec<IpAddr>,
    pub use_peer_address_for_allowlist: bool,
}
```

Modify IP extraction to validate against trusted proxies before accepting forwarding headers.

## Proof of Concept

**Demonstration using curl:**

```bash
# Normal request (blocked or limited to 100 OCTA)
curl -X POST http://faucet:8081/fund \
  -H "Content-Type: application/json" \
  -d '{"address":"0xABCD","amount":10000}'
# Response: Rejected or capped at maximum_amount (100)

# Spoofed request with allowlisted IP
curl -X POST http://faucet:8081/fund \
  -H "Content-Type: application/json" \
  -H "X-Forwarded-For: 10.0.0.5" \
  -d '{"address":"0xABCD","amount":10000}'
# Response: Success, receives full 10000 OCTA (maximum_amount_with_bypass)
```

**Integration test demonstrating the issue:**

```rust
#[tokio::test]
async fn test_ip_spoofing_bypass() {
    // Setup faucet with IP allowlist for 127.0.0.1/32
    // Configure maximum_amount=100, maximum_amount_with_bypass=10000
    
    // Request 1: Normal request from different IP (blocked/limited)
    let resp1 = client.post("/fund")
        .json(&FundRequest { amount: Some(10000), address: Some(addr1) })
        .send().await.unwrap();
    assert!(resp1.funded_amount <= 100);
    
    // Request 2: Same request but with spoofed X-Forwarded-For header
    let resp2 = client.post("/fund")
        .header("X-Forwarded-For", "127.0.0.1")
        .json(&FundRequest { amount: Some(10000), address: Some(addr2) })
        .send().await.unwrap();
    assert_eq!(resp2.funded_amount, 10000); // Bypass successful!
}
```

## Notes
- This vulnerability requires the faucet to be misconfigured or deployed without proper reverse proxy header sanitization
- The test configuration explicitly shows the bypass feature is intentional for CI/testing purposes
- Production deployments should ensure the faucet is behind a properly configured reverse proxy (HAProxy/nginx) that strips untrusted forwarding headers
- The vulnerability is deployment-specific but represents a real security risk for improperly configured faucet instances

### Citations

**File:** crates/aptos-faucet/core/src/endpoints/fund.rs (L108-108)
```rust
        source_ip: RealIp,
```

**File:** crates/aptos-faucet/core/src/endpoints/fund.rs (L244-258)
```rust
        // See if this request meets the criteria to bypass checkers / storage.
        for bypasser in &self.bypassers {
            if bypasser
                .request_can_bypass(checker_data.clone())
                .await
                .map_err(|e| {
                    AptosTapError::new_with_error_code(e, AptosTapErrorCode::BypasserError)
                })?
            {
                info!(
                    "Allowing request from {} to bypass checks / storage",
                    source_ip
                );
                return Ok((checker_data, true, permit));
            }
```

**File:** crates/aptos-faucet/core/src/middleware/log.rs (L25-28)
```rust
    let source_ip = RealIp::from_request(&request, &mut RequestBody::default())
        .await
        .map(|ip| ip.0)
        .unwrap_or(None);
```

**File:** crates/aptos-faucet/core/src/bypasser/ip_allowlist.rs (L26-28)
```rust
    async fn request_can_bypass(&self, data: CheckerData) -> Result<bool> {
        Ok(self.manager.contains_ip(&data.source_ip))
    }
```

**File:** crates/aptos-faucet/core/src/funder/common.rs (L176-185)
```rust
    pub fn get_maximum_amount(
        &self,
        // True if a Bypasser let the request bypass the Checkers.
        did_bypass_checkers: bool,
    ) -> Option<u64> {
        match (self.maximum_amount_with_bypass, did_bypass_checkers) {
            (Some(max), true) => Some(max),
            _ => self.maximum_amount,
        }
    }
```

**File:** crates/aptos-faucet/core/src/funder/mint.rs (L540-550)
```rust
    fn get_amount(&self, amount: Option<u64>, did_bypass_checkers: bool) -> u64 {
        match (
            amount,
            self.txn_config.get_maximum_amount(did_bypass_checkers),
        ) {
            (Some(amount), Some(maximum_amount)) => std::cmp::min(amount, maximum_amount),
            (Some(amount), None) => amount,
            (None, Some(maximum_amount)) => std::cmp::min(self.amount_to_fund, maximum_amount),
            (None, None) => self.amount_to_fund,
        }
    }
```

**File:** crates/aptos-faucet/configs/testing_mint_funder_local_wait_for_txns.yaml (L15-16)
```yaml
  maximum_amount: 100
  maximum_amount_with_bypass: 10000
```
