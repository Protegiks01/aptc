# Audit Report

## Title
Consensus Divergence During OnChainConsensusConfig Schema Upgrades Due to Silent Deserialization Fallback

## Summary
The `validator_txn_enabled()` native function uses `unwrap_or_default()` when deserializing `OnChainConsensusConfig` bytes, causing validators running different code versions during protocol upgrades to interpret the same on-chain configuration differently. This leads to consensus divergence where validators disagree on whether validator transactions are enabled, causing them to reject each other's valid blocks.

## Finding Description

The vulnerability exists in the native function implementation where BCS deserialization failures are silently masked by falling back to a default configuration: [1](#0-0) 

The default configuration returns V4 with validator transactions disabled (V0): [2](#0-1) [3](#0-2) 

**Attack Scenario:**

1. Network runs with validators at code version N (understands OnChainConsensusConfig V1-V4)
2. Governance proposal updates on-chain ConsensusConfig to V5 format with `vtxn: ValidatorTxnConfig::V1` (enabled) via: [4](#0-3) 

3. Proposal passes, V5 config bytes are committed to blockchain storage
4. Validators begin upgrading to code version N+1 (understands V1-V5), but upgrades are staggered
5. Epoch transition occurs, triggering config reload: [5](#0-4) 

6. **Divergence occurs:**
   - **Validators with OLD code (V1-V4)**: BCS deserialization of V5 bytes fails because the enum variant index 4 is unknown → `unwrap_or_default()` falls back to V4 → `vtxn_config = V0` (disabled)
   - **Validators with NEW code (V1-V5)**: BCS deserialization succeeds → `vtxn_config = V1` (enabled)

The V5 variant includes a new `rand_check_enabled` field that causes deserialization to fail on older code: [6](#0-5) 

7. When a proposer running new code creates a block with `BlockType::ProposalExt` containing validator transactions, validators running old code reject it: [7](#0-6) 

8. The same divergence affects the Move-level `validator_txn_enabled()` function called during governance reconfiguration: [8](#0-7) [9](#0-8) 

This causes different nodes to execute different Move code paths (DKG start vs. finish), violating Move VM execution determinism.

## Impact Explanation

**Critical Severity** ($1,000,000 category) per Aptos Bug Bounty:

1. **Consensus Safety Violation**: Validators with different code versions disagree on which blocks are valid, directly violating the fundamental BFT invariant that all honest validators must agree on valid blocks.

2. **Non-recoverable Network Partition**: If >1/3 of validators remain on old code, they will refuse to vote for ProposalExt blocks from new-code validators, preventing quorum formation and halting consensus progression. This requires manual intervention or a hardfork to resolve.

3. **Chain Fork Risk**: If the validator set splits such that both old-code and new-code groups maintain >2/3 stake internally, they could form competing chains with divergent histories.

4. **Move VM Execution Divergence**: Different execution paths in `reconfigure()` mean nodes execute different Move bytecode for the same on-chain state, breaking deterministic execution guarantees.

The vulnerability breaks Consensus Safety Invariant #1 ("All validators must produce identical state roots for identical blocks") and Invariant #2 ("AptosBFT must prevent chain splits under < 1/3 Byzantine").

## Likelihood Explanation

**High Likelihood** - This vulnerability triggers automatically during protocol upgrades that:
1. Add new enum variants to `OnChainConsensusConfig` (e.g., V4→V5 transition)
2. Change validator transaction configuration
3. Occur while validators are at mixed code versions

This is a **natural operational scenario**:
- Protocol upgrades are regular maintenance operations in Aptos
- Validators upgrade at different times based on operator schedules and procedures
- The upgrade window typically spans hours to days
- Governance proposals can update on-chain configs independently of code deployments
- No code-level validation prevents config schema updates before all validators upgrade

The vulnerability requires no attacker intervention - it manifests from normal protocol operations when governance updates the config format before all validators have upgraded their code.

## Recommendation

Replace `unwrap_or_default()` with proper error handling that:
1. **Explicitly fails** when deserialization errors occur (not just when config is missing)
2. **Logs warnings** when using default config due to missing on-chain state
3. **Implements version compatibility checking** before applying config updates
4. **Enforces governance rules** that config schema upgrades cannot occur until minimum validator version thresholds are met

Example fix:

```rust
pub fn validator_txn_enabled(
    _context: &mut SafeNativeContext,
    _ty_args: &[Type],
    mut args: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    let config_bytes = safely_pop_arg!(args, Vec<u8>);
    let config = bcs::from_bytes::<OnChainConsensusConfig>(&config_bytes)
        .map_err(|e| {
            error!("Failed to deserialize OnChainConsensusConfig: {}. This indicates a version mismatch.", e);
            // Return error instead of silently using default
            SafeNativeError::InvariantViolation(...)
        })?;
    Ok(smallvec![Value::bool(config.is_vtxn_enabled())])
}
```

## Proof of Concept

While a complete PoC would require setting up multiple validator nodes at different code versions, the vulnerability can be demonstrated by:

1. Serializing an `OnChainConsensusConfig::V5` with BCS
2. Attempting to deserialize with code that only knows variants V1-V4
3. Observing the BCS deserialization failure and `unwrap_or_default()` fallback
4. Verifying that the default config has `vtxn: ValidatorTxnConfig::V0` (disabled)
5. Showing that `process_proposal()` rejects `BlockType::ProposalExt` when `vtxn_config.enabled()` returns false

The technical analysis confirms that BCS enum deserialization is not forward-compatible, and the `unwrap_or_default()` pattern silently masks version incompatibilities during protocol upgrades.

## Notes

This vulnerability highlights a fundamental design issue with using `unwrap_or_default()` for error handling in consensus-critical code paths. The comment at line 441-442 indicates the default is intended for uninitialized configs, not deserialization failures, suggesting this is a misuse of the pattern rather than intentional behavior.

The vulnerability exists at the code level regardless of operational procedures Aptos may have to coordinate upgrades. Proper error handling and version compatibility checks should be enforced in code, not relied upon through operational discipline alone.

### Citations

**File:** aptos-move/framework/src/natives/consensus_config.rs (L13-21)
```rust
pub fn validator_txn_enabled(
    _context: &mut SafeNativeContext,
    _ty_args: &[Type],
    mut args: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    let config_bytes = safely_pop_arg!(args, Vec<u8>);
    let config = bcs::from_bytes::<OnChainConsensusConfig>(&config_bytes).unwrap_or_default();
    Ok(smallvec![Value::bool(config.is_vtxn_enabled())])
}
```

**File:** types/src/on_chain_config/consensus_config.rs (L147-149)
```rust
    pub fn default_if_missing() -> Self {
        Self::V0
    }
```

**File:** types/src/on_chain_config/consensus_config.rs (L205-213)
```rust
    V5 {
        alg: ConsensusAlgorithmConfig,
        vtxn: ValidatorTxnConfig,
        // Execution pool block window
        window_size: Option<u64>,
        // Whether to check if we can skip generating randomness for blocks
        rand_check_enabled: bool,
    },
}
```

**File:** types/src/on_chain_config/consensus_config.rs (L443-450)
```rust
impl Default for OnChainConsensusConfig {
    fn default() -> Self {
        OnChainConsensusConfig::V4 {
            alg: ConsensusAlgorithmConfig::default_if_missing(),
            vtxn: ValidatorTxnConfig::default_if_missing(),
            window_size: DEFAULT_WINDOW_SIZE,
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/consensus_config.move (L52-56)
```text
    public fun set_for_next_epoch(account: &signer, config: vector<u8>) {
        system_addresses::assert_aptos_framework(account);
        assert!(vector::length(&config) > 0, error::invalid_argument(EINVALID_CONFIG));
        std::config_buffer::upsert<ConsensusConfig>(ConsensusConfig {config});
    }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/consensus_config.move (L71-76)
```text
    public fun validator_txn_enabled(): bool acquires ConsensusConfig {
        let config_bytes = borrow_global<ConsensusConfig>(@aptos_framework).config;
        validator_txn_enabled_internal(config_bytes)
    }

    native fun validator_txn_enabled_internal(config_bytes: vector<u8>): bool;
```

**File:** consensus/src/epoch_manager.rs (L1178-1201)
```rust
        let onchain_consensus_config: anyhow::Result<OnChainConsensusConfig> = payload.get();
        let onchain_execution_config: anyhow::Result<OnChainExecutionConfig> = payload.get();
        let onchain_randomness_config_seq_num: anyhow::Result<RandomnessConfigSeqNum> =
            payload.get();
        let randomness_config_move_struct: anyhow::Result<RandomnessConfigMoveStruct> =
            payload.get();
        let onchain_jwk_consensus_config: anyhow::Result<OnChainJWKConsensusConfig> = payload.get();
        let dkg_state = payload.get::<DKGState>();

        if let Err(error) = &onchain_consensus_config {
            warn!("Failed to read on-chain consensus config {}", error);
        }

        if let Err(error) = &onchain_execution_config {
            warn!("Failed to read on-chain execution config {}", error);
        }

        if let Err(error) = &randomness_config_move_struct {
            warn!("Failed to read on-chain randomness config {}", error);
        }

        self.epoch_state = Some(epoch_state.clone());

        let consensus_config = onchain_consensus_config.unwrap_or_default();
```

**File:** consensus/src/round_manager.rs (L1116-1124)
```rust
        if !self.vtxn_config.enabled()
            && matches!(
                proposal.block_data().block_type(),
                BlockType::ProposalExt(_)
            )
        {
            counters::UNEXPECTED_PROPOSAL_EXT_COUNT.inc();
            bail!("ProposalExt unexpected while the vtxn feature is disabled.");
        }
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L685-692)
```text
    public entry fun reconfigure(aptos_framework: &signer) {
        system_addresses::assert_aptos_framework(aptos_framework);
        if (consensus_config::validator_txn_enabled() && randomness_config::enabled()) {
            reconfiguration_with_dkg::try_start();
        } else {
            reconfiguration_with_dkg::finish(aptos_framework);
        }
    }
```
