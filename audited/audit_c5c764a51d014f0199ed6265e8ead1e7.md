# Audit Report

## Title
Unprotected Memory Allocation in Access Control Error Handling Can Cause Validator Crashes

## Summary
The Move VM's access control error handling performs memory allocations without panic protection during transaction execution. If Out-of-Memory (OOM) occurs during error message construction, the validator process will panic and crash, potentially causing network liveness issues.

## Finding Description

The vulnerability exists in the `check_access()` function which performs resource access control checks during Move VM execution. [1](#0-0) 

When an access control violation is detected, the code constructs an error message using `format!()`, which allocates memory. The `AccessInstance` type's Display implementation performs additional nested allocations: [2](#0-1) 

In Rust, if memory allocation fails, the default allocator will abort the process. There is no `Result`-based error handling for allocation failures.

The critical issue is that **VM execution is not protected by panic handlers**. While the bytecode verifier and deserializer use `catch_unwind` with appropriate `VMState` settings: [3](#0-2) 

The actual VM execution in the interpreter does not set any protective VMState or use `catch_unwind`: [4](#0-3) 

The global panic handler only prevents process termination for `VERIFIER` and `DESERIALIZER` states: [5](#0-4) 

During normal execution, the VMState remains `OTHER` (default), so any panic will trigger `process::exit(12)`, killing the validator.

## Impact Explanation

This qualifies as **High Severity** per Aptos bug bounty criteria: "Validator node slowdowns" and "API crashes." 

If triggered, the impact includes:
- Immediate validator process termination
- Potential consensus liveness degradation if multiple validators crash simultaneously
- Deterministic crashes if the same memory conditions exist across validators executing identical blocks

However, **the exploitability is extremely limited**. An attacker would need to:
1. Cause system-wide memory pressure (difficult without validator access)
2. Time an access control violation to coincide with exhausted memory
3. The error message allocation itself is small (typically <1KB)

## Likelihood Explanation

**Very Low** under normal conditions. While theoretically possible, practical exploitation faces significant barriers:

- Small string allocations rarely fail on modern systems with virtual memory
- An unprivileged attacker cannot reliably control system memory state
- The timing window is unpredictable
- Gas limits prevent unbounded memory consumption within transactions

The issue is more of a **defensive programming gap** than an actively exploitable vulnerability.

## Recommendation

Implement panic protection for VM execution similar to verification/deserialization:

1. **Add VMState::RUNTIME and protect execution**:
   - Set `VMState::RUNTIME` before entering the interpreter
   - Modify crash handler to include `VMState::RUNTIME` in the non-exit condition
   - Wrap execution entry point with `catch_unwind`

2. **Use fallible error construction**:
   - Consider pre-allocated error messages for critical paths
   - Implement a try_with_message() that gracefully degrades if allocation fails

3. **Add memory monitoring**:
   - Implement memory pressure detection
   - Reject new transactions when memory is critically low

## Proof of Concept

```rust
// This is a theoretical demonstration, not a practical exploit
// Requires artificial memory constraints to trigger

#[test]
fn test_oom_during_access_control_error() {
    // 1. Set up a custom allocator with artificial limits
    // 2. Execute a transaction that will violate access control
    // 3. Ensure memory is near exhaustion when error is constructed
    // 4. Observe validator panic instead of graceful error handling
    
    // Note: This cannot be reliably implemented as an actual exploit
    // because controlling memory state from unprivileged transactions
    // is not feasible
}
```

## Notes

While this finding correctly identifies a gap in panic protection during VM execution, it **does not meet the criteria for an actively exploitable vulnerability** due to:
- Extremely low likelihood of triggering OOM during small string allocations
- Lack of attacker control over system memory state  
- No realistic attack vector for unprivileged actors

The issue remains valid as a **defensive programming concern** and should be addressed to improve system robustness under extreme conditions, but it does not constitute a practical security exploit under the bug bounty program's exploitability requirements.

### Citations

**File:** third_party/move/move-vm/runtime/src/access_control.rs (L69-77)
```rust
    pub(crate) fn check_access(&self, access: AccessInstance) -> PartialVMResult<()> {
        for specifier in self.specifier_stack.iter().rev() {
            if !specifier.enables(&access) {
                return Err(PartialVMError::new(StatusCode::ACCESS_DENIED)
                    .with_message(format!("not allowed to perform `{}`", access)));
            }
        }
        Ok(())
    }
```

**File:** third_party/move/move-vm/types/src/loaded_data/runtime_access_specifier.rs (L305-325)
```rust
impl fmt::Display for AccessInstance {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let Self {
            kind,
            resource,
            instance,
            address,
        } = self;
        write!(
            f,
            "{} {}{}(@0x{})",
            kind,
            resource,
            if !instance.is_empty() {
                format!("<{}>", instance.iter().map(|t| t.to_string()).join(","))
            } else {
                "".to_owned()
            },
            address.short_str_lossless()
        )
    }
```

**File:** third_party/move/move-bytecode-verifier/src/verifier.rs (L138-171)
```rust
    let prev_state = move_core_types::state::set_state(VMState::VERIFIER);
    let result = std::panic::catch_unwind(|| {
        // Always needs to run bound checker first as subsequent passes depend on it
        BoundsChecker::verify_module(module).map_err(|e| {
            // We can't point the error at the module, because if bounds-checking
            // failed, we cannot safely index into module's handle to itself.
            e.finish(Location::Undefined)
        })?;
        FeatureVerifier::verify_module(config, module)?;
        LimitsVerifier::verify_module(config, module)?;
        DuplicationChecker::verify_module(module)?;

        signature_v2::verify_module(config, module)?;

        InstructionConsistency::verify_module(module)?;
        constants::verify_module(module)?;
        friends::verify_module(module)?;

        RecursiveStructDefChecker::verify_module(module)?;
        InstantiationLoopChecker::verify_module(module)?;
        CodeUnitVerifier::verify_module(config, module)?;

        // Add the failpoint injection to test the catch_unwind behavior.
        fail::fail_point!("verifier-failpoint-panic");

        script_signature::verify_module(module, no_additional_script_signature_checks)
    })
    .unwrap_or_else(|_| {
        Err(
            PartialVMError::new(StatusCode::VERIFIER_INVARIANT_VIOLATION)
                .finish(Location::Undefined),
        )
    });
    move_core_types::state::set_state(prev_state);
```

**File:** third_party/move/move-vm/runtime/src/interpreter.rs (L215-279)
```rust
    pub(crate) fn entrypoint(
        function: LoadedFunction,
        args: Vec<Value>,
        data_cache: &mut impl MoveVmDataCache,
        function_caches: &mut InterpreterFunctionCaches,
        loader: &LoaderImpl,
        ty_depth_checker: &TypeDepthChecker<LoaderImpl>,
        layout_converter: &LayoutConverter<LoaderImpl>,
        gas_meter: &mut impl GasMeter,
        traversal_context: &mut TraversalContext,
        extensions: &mut NativeContextExtensions,
        trace_recorder: &mut impl TraceRecorder,
    ) -> VMResult<Vec<Value>> {
        let interpreter = InterpreterImpl {
            operand_stack: Stack::new(),
            call_stack: CallStack::new(),
            vm_config: loader.runtime_environment().vm_config(),
            ty_pool: loader.runtime_environment().ty_pool(),
            access_control: AccessControlState::default(),
            reentrancy_checker: ReentrancyChecker::default(),
            loader,
            ty_depth_checker,
            layout_converter,
            ref_state: RefCheckState::new(extensions.get_native_runtime_ref_checks_model()),
        };

        // Tracing and runtime checks (full or partial) are mutually exclusive because if we record
        // the trace, the checks are done after execution via abstract interpretation during trace
        // replay.
        let paranoid_type_checks =
            !trace_recorder.is_enabled() && interpreter.vm_config.paranoid_type_checks;
        let optimize_trusted_code =
            !trace_recorder.is_enabled() && interpreter.vm_config.optimize_trusted_code;
        let paranoid_ref_checks = interpreter.vm_config.paranoid_ref_checks;

        let function = Rc::new(function);
        macro_rules! execute_main {
            ($type_check:ty, $ref_check:ty) => {
                interpreter.execute_main::<$type_check, $ref_check>(
                    data_cache,
                    function_caches,
                    gas_meter,
                    traversal_context,
                    extensions,
                    trace_recorder,
                    function,
                    args,
                )
            };
        }

        // Note: we have organized the code below from most-likely config to least-likely config.
        match (
            paranoid_type_checks,
            optimize_trusted_code,
            paranoid_ref_checks,
        ) {
            (true, true, false) => execute_main!(UntrustedOnlyRuntimeTypeCheck, NoRuntimeRefCheck),
            (true, false, false) => execute_main!(FullRuntimeTypeCheck, NoRuntimeRefCheck),
            (true, true, true) => execute_main!(UntrustedOnlyRuntimeTypeCheck, FullRuntimeRefCheck),
            (true, false, true) => execute_main!(FullRuntimeTypeCheck, FullRuntimeRefCheck),
            (false, _, false) => execute_main!(NoRuntimeTypeCheck, NoRuntimeRefCheck),
            (false, _, true) => execute_main!(NoRuntimeTypeCheck, FullRuntimeRefCheck),
        }
    }
```

**File:** crates/crash-handler/src/lib.rs (L48-57)
```rust
    // Do not kill the process if the panics happened at move-bytecode-verifier.
    // This is safe because the `state::get_state()` uses a thread_local for storing states. Thus the state can only be mutated to VERIFIER by the thread that's running the bytecode verifier.
    //
    // TODO: once `can_unwind` is stable, we should assert it. See https://github.com/rust-lang/rust/issues/92988.
    if state::get_state() == VMState::VERIFIER || state::get_state() == VMState::DESERIALIZER {
        return;
    }

    // Kill the process
    process::exit(12);
```
