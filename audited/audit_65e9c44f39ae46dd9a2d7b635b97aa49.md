# Audit Report

## Title
Bypass of Epoch History Signature Validation in One-Off Transaction Restore Enables Selective History Rewriting

## Summary
The one-off transaction restore functionality and BootstrapDB with `--skip-epoch-endings` flag fail to validate BLS signatures on `LedgerInfoWithSignatures`, allowing an attacker controlling backup storage to restore arbitrary fake transactions at any version, completely bypassing consensus guarantees and enabling selective history rewriting.

## Finding Description

The transaction restore process has a critical validation gap when epoch history verification is disabled. The vulnerability exists in two scenarios:

1. **One-off transaction restore** (always vulnerable)
2. **BootstrapDB with `--skip-epoch-endings` flag** (vulnerable when flag is set)

The attack flow works as follows:

**Step 1: Attacker Prepares Malicious Backup**
An attacker creates a backup containing:
- Fake transactions at arbitrary versions (e.g., versions 1000-2000)
- A self-crafted `LedgerInfoWithSignatures` with invalid/unverified BLS signatures
- A `TransactionAccumulatorRangeProof` that is cryptographically consistent with the fake ledger info
- Frozen subtree hashes derived from the fake proof

**Step 2: Victim Initiates Restore**
When the victim runs one-off transaction restore, the code path proceeds: [1](#0-0) 

This creates a `TransactionRestoreController` with `epoch_history: None`.

**Step 3: Signature Validation is Skipped**
During chunk loading, the critical validation is bypassed: [2](#0-1) 

Since `epoch_history` is `None`, the `verify_ledger_info` call that would validate BLS signatures is completely skipped.

**Step 4: Only Cryptographic Consistency is Checked**
The subsequent verification only validates that the transactions are cryptographically consistent with the (unvalidated) ledger info: [3](#0-2) 

This verify method checks hash consistency but does NOT validate validator signatures on the ledger info.

**Step 5: Fake Frozen Subtrees are Persisted**
The frozen subtrees from the unvalidated range proof are saved to the database: [4](#0-3) [5](#0-4) 

The implementation saves frozen subtrees if they don't exist, without any signature validation of their source.

**Step 6: Fake Transactions are Written to Database**
The transactions are then restored starting at the attacker-chosen version, using the previously saved frozen subtrees to make the accumulator append operation succeed. [6](#0-5) 

**Invariant Violations:**
- **State Consistency**: The database contains transactions that were never committed by network consensus
- **Consensus Safety**: The node's state diverges from the network's agreed-upon history
- **Deterministic Execution**: Different nodes would have different states if restored from malicious backups

## Impact Explanation

This vulnerability constitutes **High Severity** based on the Aptos bug bounty criteria:

1. **Significant Protocol Violations**: The node's database becomes fundamentally inconsistent with blockchain consensus. The restored state contains transactions that were never validated by the validator set.

2. **Validator Node Impact**: If a validator uses this restore method, they would operate on incorrect state, potentially:
   - Signing blocks based on wrong state roots
   - Making incorrect validation decisions
   - Causing consensus issues when their state diverges from other validators

3. **State Inconsistency**: The database violates the core invariant that all transactions must be validated through consensus with BLS signature verification from the validator quorum.

4. **Attack Scope**: While this requires the victim to use one-off restore or the `--skip-epoch-endings` flag, these are legitimate features exposed in the CLI without sufficient warnings about the security implications.

The impact is limited from Critical to High because:
- It requires operator action (choosing the vulnerable restore mode)
- It doesn't directly compromise the live network (only the restoring node)
- It can be detected when the node attempts to sync with the network

However, the potential for database corruption and validator misbehavior if used in production environments is significant.

## Likelihood Explanation

**Likelihood: Medium**

The attack requires:
1. **Attacker Controls Backup Storage**: The attacker must either control the backup storage location or perform a man-in-the-middle attack to modify backup files. This is feasible in scenarios where:
   - Backups are stored on untrusted infrastructure
   - Network connections to backup storage are not properly secured
   - An insider has access to backup systems

2. **Victim Uses Vulnerable Restore Mode**: The victim must either:
   - Use one-off transaction restore (intended for debugging)
   - Use BootstrapDB with `--skip-epoch-endings` flag (marked as "for debugging")

3. **Technical Capability**: The attacker needs basic cryptographic knowledge to:
   - Compute correct Merkle accumulator hashes
   - Create consistent transaction data structures
   - Generate valid BCS serializations

The likelihood is elevated because:
- The CLI exposes these features without clear security warnings
- Operators might use these modes for convenience without understanding the risks
- The `--skip-epoch-endings` flag could be accidentally used in production
- No runtime warnings are shown when epoch validation is disabled

## Recommendation

**Immediate Fixes:**

1. **Add Mandatory Trusted Waypoint Validation**: Even when epoch_history is None, require validation against a trusted waypoint for one-off restore:

```rust
// In LoadedChunk::load
let (range_proof, ledger_info) = storage
    .load_bcs_file::<(TransactionAccumulatorRangeProof, LedgerInfoWithSignatures)>(
        &manifest.proof,
    )
    .await?;

// ALWAYS validate against trusted waypoint or epoch history
if let Some(epoch_history) = epoch_history {
    epoch_history.verify_ledger_info(&ledger_info)?;
} else {
    // Require trusted waypoint for validation
    return Err(anyhow!(
        "Cannot restore transactions without epoch history validation. \
        Please use BootstrapDB mode or provide trusted waypoints."
    ));
}
```

2. **Add CLI Warnings**: Add prominent warnings when using one-off restore:

```rust
// In restore.rs Command::run
match oneoff {
    Oneoff::Transaction { .. } => {
        warn!("⚠️  WARNING: One-off transaction restore does not validate epoch signatures!");
        warn!("⚠️  Only use this for debugging with trusted backup sources.");
        warn!("⚠️  For production, use 'aptos-db-tool restore bootstrap-db' instead.");
        // ... proceed with restore
    },
    // ...
}
```

3. **Enforce Version Continuity**: Add a check in `loaded_chunk_stream` to ensure restoration starts at version 0 or after existing DB state:

```rust
// In TransactionRestoreBatchController::loaded_chunk_stream
.scan(0, |last_chunk_last_version, chunk_res| {
    let res = match &chunk_res {
        Ok(chunk) => {
            if *last_chunk_last_version == 0 && chunk.first_version != 0 {
                // First chunk must start at version 0 unless DB already has data
                let expected_start = self.global_opt.run_mode
                    .get_next_expected_transaction_version()
                    .unwrap_or(0);
                if chunk.first_version != expected_start {
                    return Some(Err(anyhow!(
                        "Invalid restore: first chunk starts at version {}, but DB expects {}",
                        chunk.first_version,
                        expected_start
                    )));
                }
            }
            // ... rest of validation
        }
    };
    future::ready(res)
})
```

4. **Deprecate or Remove Unsafe Modes**: Consider deprecating one-off restore without epoch validation, or requiring explicit `--unsafe` flags with multiple confirmations.

## Proof of Concept

```rust
// Proof of Concept: Restore fake transactions without signature validation
// This demonstrates the vulnerability - DO NOT RUN ON PRODUCTION

use aptos_backup_cli::backup_types::transaction::restore::{
    TransactionRestoreController, TransactionRestoreOpt
};
use aptos_types::{
    transaction::{Transaction, Version},
    ledger_info::LedgerInfo,
};
use aptos_crypto::hash::HashValue;

#[tokio::test]
async fn test_restore_without_epoch_validation() {
    // Step 1: Create fake transactions at version 1000-1010
    let fake_transactions: Vec<Transaction> = (1000..1010)
        .map(|i| create_fake_transaction(i))
        .collect();
    
    // Step 2: Create fake LedgerInfo with invalid signatures
    let fake_ledger_info = create_fake_ledger_info_with_fake_signatures(
        Version(1010),
        HashValue::random(), // Fake accumulator root
    );
    
    // Step 3: Generate consistent range proof
    let fake_range_proof = create_consistent_range_proof(
        &fake_transactions,
        &fake_ledger_info,
    );
    
    // Step 4: Create backup manifest
    let manifest = create_backup_manifest(
        1000, // first_version
        1010, // last_version
        fake_range_proof,
        fake_ledger_info,
    );
    
    // Step 5: Attempt one-off restore (epoch_history=None)
    let controller = TransactionRestoreController::new(
        TransactionRestoreOpt {
            manifest_handle: save_manifest_to_storage(manifest).await,
            replay_from_version: None,
            kv_only_replay: None,
        },
        global_restore_options,
        backup_storage,
        None, // <-- epoch_history is None, signatures NOT validated!
        VerifyExecutionMode::NoVerify,
    );
    
    // Step 6: Run restore - this SUCCEEDS despite fake signatures!
    let result = controller.run().await;
    assert!(result.is_ok(), "Restore succeeded with fake signatures!");
    
    // Step 7: Verify fake transactions are in database
    let db = get_restored_database();
    for version in 1000..1010 {
        let txn = db.get_transaction(version).unwrap();
        // These are FAKE transactions that were never validated by consensus!
        assert_eq!(txn, fake_transactions[(version - 1000) as usize]);
    }
    
    println!("❌ VULNERABILITY CONFIRMED: Fake transactions restored without signature validation!");
}
```

**Notes:**
The vulnerability requires controlling backup storage but is straightforward to exploit once that condition is met. The restored database will contain arbitrary transactions that bypass all consensus validation, breaking the fundamental security guarantees of the blockchain.

### Citations

**File:** storage/db-tool/src/restore.rs (L97-111)
```rust
                    Oneoff::Transaction {
                        storage,
                        opt,
                        global,
                    } => {
                        TransactionRestoreController::new(
                            opt,
                            global.try_into()?,
                            storage.init_storage().await?,
                            None, /* epoch_history */
                            VerifyExecutionMode::NoVerify,
                        )
                        .run()
                        .await?;
                    },
```

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L152-154)
```rust
        if let Some(epoch_history) = epoch_history {
            epoch_history.verify_ledger_info(&ledger_info)?;
        }
```

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L167-167)
```rust
        txn_list_with_proof.verify(ledger_info.ledger_info(), Some(manifest.first_version))?;
```

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L414-419)
```rust
        if let RestoreRunMode::Restore { restore_handler } = self.global_opt.run_mode.as_ref() {
            restore_handler.confirm_or_save_frozen_subtrees(
                first_chunk.manifest.first_version,
                first_chunk.range_proof.left_siblings(),
            )?;
        }
```

**File:** storage/aptosdb/src/backup/restore_utils.rs (L193-213)
```rust
pub(crate) fn save_transactions_impl(
    state_store: Arc<StateStore>,
    ledger_db: Arc<LedgerDb>,
    first_version: Version,
    txns: &[Transaction],
    persisted_aux_info: &[PersistedAuxiliaryInfo],
    txn_infos: &[TransactionInfo],
    events: &[Vec<ContractEvent>],
    write_sets: &[WriteSet],
    ledger_db_batch: &mut LedgerDbSchemaBatches,
    state_kv_batches: &mut ShardedStateKvSchemaBatch,
    kv_replay: bool,
) -> Result<()> {
    for (idx, txn) in txns.iter().enumerate() {
        ledger_db.transaction_db().put_transaction(
            first_version + idx as Version,
            txn,
            /*skip_index=*/ false,
            &mut ledger_db_batch.transaction_db_batches,
        )?;
    }
```

**File:** storage/aptosdb/src/backup/restore_utils.rs (L297-322)
```rust
fn confirm_or_save_frozen_subtrees_impl(
    transaction_accumulator_db: &DB,
    frozen_subtrees: &[HashValue],
    positions: Vec<Position>,
    batch: &mut SchemaBatch,
) -> Result<()> {
    positions
        .iter()
        .zip(frozen_subtrees.iter().rev())
        .map(|(p, h)| {
            if let Some(_h) = transaction_accumulator_db.get::<TransactionAccumulatorSchema>(p)? {
                ensure!(
                        h == &_h,
                        "Frozen subtree root does not match that already in DB. Provided: {}, in db: {}.",
                        h,
                        _h,
                    );
            } else {
                batch.put::<TransactionAccumulatorSchema>(p, h)?;
            }
            Ok(())
        })
        .collect::<Result<Vec<_>>>()?;

    Ok(())
}
```
