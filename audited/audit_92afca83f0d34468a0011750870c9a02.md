# Audit Report

## Title
Consensus Liveness Failure Due to OnChainConsensusConfig Version Deserialization Mismatch During Rolling Upgrades

## Summary
Validators running different code versions during rolling upgrades can disagree on `exclude_round` values when the on-chain consensus config uses a version unknown to older validators, causing BCS deserialization failures and fallback to mismatched default values. This breaks the fundamental consensus invariant that all validators must agree on proposer election, leading to liveness degradation or complete consensus failure.

## Finding Description

The `OnChainConsensusConfig` enum has evolved through versions V1-V5, with each version potentially containing different fields. During epoch transitions, all validators read this config from on-chain state: [1](#0-0) 

The critical vulnerability occurs when validators have mixed code versions during a rolling upgrade. BCS enum deserialization fails when encountering unknown enum discriminants. If the on-chain config is V4 or V5 but a validator only knows V1-V3, deserialization fails and the validator falls back to default: [2](#0-1) 

The default config has `exclude_round = 40`: [3](#0-2) 

Meanwhile, validators with updated code successfully deserialize the on-chain config, which may have a different `exclude_round` value (e.g., 100). This causes validators to disagree on which historical rounds to examine for leader reputation calculation: [4](#0-3) 

When validators disagree on `exclude_round`, they examine different historical windows, calculate different reputation scores, and elect **different proposers for the same round**. The proposer validation check then causes proposal rejections: [5](#0-4) [6](#0-5) 

This breaks **Critical Invariant #2: Consensus Safety** - validators must agree on block proposals to maintain liveness.

## Impact Explanation

**High Severity** - This qualifies under "Validator node slowdowns" and "Significant protocol violations":

1. **Liveness Degradation**: If f+1 to 2f validators have mismatched configs, rounds repeatedly fail as proposals cannot achieve quorum acceptance. Network throughput drops significantly.

2. **Potential Network Partition**: If the validator set splits nearly evenly (e.g., 2f vs 2f+1), one group achieves consensus while the other cannot participate, effectively creating a temporary partition.

3. **Validator Revenue Loss**: Validators with mismatched configs fail to participate in consensus, losing block rewards and potentially facing slashing if their downtime is misinterpreted as malicious behavior.

The issue doesn't cause permanent damage (validators can coordinate upgrades), but during the window of misconfiguration, the network experiences severe consensus disruption affecting all users and applications.

## Likelihood Explanation

**High Likelihood** in production scenarios:

1. **Rolling Upgrades Are Standard Practice**: Blockchain networks regularly perform rolling upgrades to minimize downtime. During the upgrade window (potentially hours), validators run mixed code versions.

2. **Governance Proposal Timing**: If a governance proposal updates the consensus config to V5 before all validators complete their upgrade from code supporting only V1-V4, the vulnerability triggers automatically at the next epoch boundary.

3. **No Safeguards Detected**: The codebase shows no version compatibility checks before applying config updates. The Move governance contract allows any framework signer to update the config: [7](#0-6) 

4. **Complex Coordination**: Coordinating validator upgrades across decentralized networks is challenging. A single validator upgrading late or a governance proposal executing early triggers the vulnerability.

## Recommendation

Implement multi-layered version compatibility safeguards:

**1. Backward-Compatible Deserialization**: Add a version check before attempting BCS deserialization. If the version is unknown, parse the underlying data structure directly rather than failing completely.

**2. Version Compatibility Validation**: Add on-chain checks in the Move consensus config module to prevent config version updates unless a minimum percentage of validators have signaled readiness (via a separate version advertisement mechanism).

**3. Graceful Degradation**: When deserialization fails, instead of falling back to a potentially incompatible default, validators should:
   - Use the last successfully deserialized config from the previous epoch
   - Log critical warnings to operators
   - Enter a safe mode that maintains liveness with minimal functionality

**4. Version Field in Config**: Add an explicit `config_version` field that validators can check before deserialization, allowing them to detect and handle incompatible versions proactively.

Example fix for consensus_config.rs:

```rust
fn deserialize_into_config(bytes: &[u8]) -> Result<Self> {
    let raw_bytes: Vec<u8> = bcs::from_bytes(bytes)?;
    
    // Try deserialization, but handle unknown versions gracefully
    match bcs::from_bytes::<OnChainConsensusConfig>(&raw_bytes) {
        Ok(config) => Ok(config),
        Err(e) => {
            warn!("Failed to deserialize OnChainConsensusConfig: {}. This may indicate a version mismatch.", e);
            // Return an error instead of silently using default
            Err(format_err!("[on-chain config] Incompatible config version detected. Please upgrade validator software."))
        }
    }
}
```

## Proof of Concept

This requires a multi-validator testnet setup which is beyond the scope of this report, but the steps to reproduce are:

1. Deploy a 4-validator testnet with Aptos Core version supporting V1-V4
2. Create an OnChainConsensusConfig V5 with `exclude_round = 100`
3. Submit governance proposal to update consensus config to V5
4. Upgrade 2 validators to code supporting V5
5. Wait for next epoch boundary
6. Observe in logs:
   - Upgraded validators: Successfully deserialize V5, use `exclude_round = 100`
   - Non-upgraded validators: Deserialize fails, use default `exclude_round = 40`
7. Monitor consensus rounds - proposals will be rejected with "not a valid proposer" errors
8. Observe liveness degradation as rounds repeatedly fail to reach quorum

The vulnerability is deterministic and will trigger whenever the described conditions occur.

---

**Notes**

This vulnerability highlights a fundamental challenge in decentralized protocol upgrades: maintaining consensus invariants during version transitions. While the issue requires operational conditions (rolling upgrade + governance action), it's not an "attack" by a malicious actor but rather a **protocol design weakness** that can cause significant production outages. The lack of version compatibility safeguards makes this a High severity issue under the bug bounty program's "Significant protocol violations" category.

### Citations

**File:** consensus/src/epoch_manager.rs (L1178-1201)
```rust
        let onchain_consensus_config: anyhow::Result<OnChainConsensusConfig> = payload.get();
        let onchain_execution_config: anyhow::Result<OnChainExecutionConfig> = payload.get();
        let onchain_randomness_config_seq_num: anyhow::Result<RandomnessConfigSeqNum> =
            payload.get();
        let randomness_config_move_struct: anyhow::Result<RandomnessConfigMoveStruct> =
            payload.get();
        let onchain_jwk_consensus_config: anyhow::Result<OnChainJWKConsensusConfig> = payload.get();
        let dkg_state = payload.get::<DKGState>();

        if let Err(error) = &onchain_consensus_config {
            warn!("Failed to read on-chain consensus config {}", error);
        }

        if let Err(error) = &onchain_execution_config {
            warn!("Failed to read on-chain execution config {}", error);
        }

        if let Err(error) = &randomness_config_move_struct {
            warn!("Failed to read on-chain randomness config {}", error);
        }

        self.epoch_state = Some(epoch_state.clone());

        let consensus_config = onchain_consensus_config.unwrap_or_default();
```

**File:** types/src/on_chain_config/consensus_config.rs (L443-450)
```rust
impl Default for OnChainConsensusConfig {
    fn default() -> Self {
        OnChainConsensusConfig::V4 {
            alg: ConsensusAlgorithmConfig::default_if_missing(),
            vtxn: ValidatorTxnConfig::default_if_missing(),
            window_size: DEFAULT_WINDOW_SIZE,
        }
    }
```

**File:** types/src/on_chain_config/consensus_config.rs (L481-486)
```rust
impl Default for ConsensusConfigV1 {
    fn default() -> Self {
        Self {
            decoupled_execution: true,
            back_pressure_limit: 10,
            exclude_round: 40,
```

**File:** consensus/src/liveness/leader_reputation.rs (L696-701)
```rust
    fn get_valid_proposer_and_voting_power_participation_ratio(
        &self,
        round: Round,
    ) -> (Author, VotingPowerRatio) {
        let target_round = round.saturating_sub(self.exclude_round);
        let (sliding_window, root_hash) = self.backend.get_block_metadata(self.epoch, target_round);
```

**File:** consensus/src/liveness/unequivocal_proposer_election.rs (L46-60)
```rust
    pub fn is_valid_proposal(&self, block: &Block) -> bool {
        block.author().is_some_and(|author| {
            let valid_author = self.is_valid_proposer(author, block.round());
            if !valid_author {
                warn!(
                    SecurityEvent::InvalidConsensusProposal,
                    "Proposal is not from valid author {}, expected {} for round {} and id {}",
                    author,
                    self.get_valid_proposer(block.round()),
                    block.round(),
                    block.id()
                );

                return false;
            }
```

**File:** consensus/src/round_manager.rs (L1195-1200)
```rust
        ensure!(
            self.proposer_election.is_valid_proposal(&proposal),
            "[RoundManager] Proposer {} for block {} is not a valid proposer for this round or created duplicate proposal",
            author,
            proposal,
        );
```

**File:** aptos-move/framework/aptos-framework/sources/configs/consensus_config.move (L52-56)
```text
    public fun set_for_next_epoch(account: &signer, config: vector<u8>) {
        system_addresses::assert_aptos_framework(account);
        assert!(vector::length(&config) > 0, error::invalid_argument(EINVALID_CONFIG));
        std::config_buffer::upsert<ConsensusConfig>(ConsensusConfig {config});
    }
```
