# Audit Report

## Title
Unbounded API Key Length Enables Memory Exhaustion DoS in Transaction Simulation Session

## Summary
The transaction simulation session configuration accepts API keys without any length validation, allowing attackers to inject arbitrarily large strings (potentially hundreds of megabytes) that cause memory exhaustion and HTTP client failures when creating REST client connections to remote nodes.

## Finding Description

The `BaseState::Remote` struct in the transaction simulation session stores an API key without any validation on its length or format. [1](#0-0) 

When this API key is used to create an HTTP client, it is directly formatted into an Authorization header without length checks. [2](#0-1) 

The vulnerability propagates through two attack vectors:

**Attack Vector 1: CLI Injection**  
An attacker can provide an excessively long API key via command-line arguments. [3](#0-2) 

**Attack Vector 2: Config File Manipulation**  
An attacker can create or modify a session's `config.json` file with a multi-megabyte API key string, which gets deserialized without validation when the session is loaded. [4](#0-3) 

When the session attempts to create an HTTP client, the code formats `"Bearer {api_key}"` where `api_key` could be 100+ MB, causing:
- Heap memory exhaustion during string formatting
- HTTP header size limit violations (most servers reject headers >8-16 KB)
- Potential crashes or hangs in the HTTP client library
- Service disruption for all operations requiring remote state access

This breaks **Invariant #9 (Resource Limits)**: All operations must respect gas, storage, and computational limits. The code allows unbounded memory allocation for a user-controlled input.

## Impact Explanation

This vulnerability qualifies as **Medium Severity** under the Aptos Bug Bounty program based on:

1. **API Service Disruption**: Causes failures in the simulation session API when attempting to connect to remote nodes
2. **Resource Exhaustion**: Enables memory exhaustion attacks through unbounded string allocation
3. **Scope Limitation**: Affects developer tools and simulation environments, not production validator nodes or consensus operations

While this can cause "API crashes" (typically High severity), the limited scope to development/testing tools rather than production infrastructure reduces the severity to Medium.

## Likelihood Explanation

**Likelihood: Medium-High**

The vulnerability is easily exploitable because:
- No authentication or special privileges required
- Attackers control the input via CLI arguments or config files
- No technical complexityâ€”simply providing a large string triggers the issue
- Affects any user running simulation sessions with remote state

However, the impact is constrained to development/testing environments rather than production systems, making this a moderate rather than critical risk.

## Recommendation

Add length validation for the API key at the point of configuration:

```rust
// In config.rs
const MAX_API_KEY_LENGTH: usize = 1024; // 1KB should be more than sufficient

pub fn with_remote(node_url: Url, network_version: u64, api_key: Option<String>) -> Result<Self> {
    if let Some(ref key) = api_key {
        if key.len() > MAX_API_KEY_LENGTH {
            anyhow::bail!(
                "API key length ({} bytes) exceeds maximum allowed length ({} bytes)",
                key.len(),
                MAX_API_KEY_LENGTH
            );
        }
    }
    
    Ok(Self {
        base: BaseState::Remote {
            node_url,
            network_version,
            api_key,
        },
        ops: 0,
    })
}
```

Additionally, validate during deserialization using a custom deserializer or post-deserialization check in `Config::load_from_file()`.

## Proof of Concept

```rust
#[test]
fn test_excessive_api_key_length_causes_memory_exhaustion() -> Result<()> {
    let temp_dir = tempfile::tempdir()?;
    let session_path = temp_dir.path();
    
    // Create an API key of 100 MB
    let huge_api_key = "A".repeat(100 * 1024 * 1024);
    
    // Attempt to initialize session with huge API key
    // This will cause excessive memory allocation when formatting "Bearer {api_key}"
    let result = Session::init_with_remote_state(
        session_path,
        Url::parse("https://mainnet.aptoslabs.com")?,
        12345,
        Some(huge_api_key),
    );
    
    // The session creation should ideally fail with validation error
    // Currently, it will succeed but cause issues when making HTTP requests
    
    // Try to load the session - this will attempt to create HTTP client
    // with the massive Authorization header
    let session_result = Session::load(session_path);
    
    // Observe memory usage spike and potential OOM or HTTP client errors
    assert!(session_result.is_ok()); // Currently passes but shouldn't
    
    Ok(())
}
```

**Alternative CLI-based PoC:**
```bash
# Generate a 10MB API key and pass it to the CLI
aptos move sim init \
  --path /tmp/test-session \
  --network mainnet \
  --api-key "$(python3 -c 'print("A"*10000000)')"

# This will create a config with a 10MB API key
# Loading the session will cause memory issues when creating HTTP client
```

## Notes

This vulnerability demonstrates a failure to validate user-controlled input that directly impacts resource consumption. While Rust's memory safety prevents classic buffer overflows, unbounded heap allocations can still cause denial-of-service conditions. The fix should enforce reasonable limits on API key length (1KB is more than sufficient for any legitimate API key) at both configuration creation and deserialization points.

### Citations

**File:** aptos-move/aptos-transaction-simulation-session/src/config.rs (L16-20)
```rust
    Remote {
        node_url: Url,
        network_version: u64,
        api_key: Option<String>,
    },
```

**File:** crates/aptos-rest-client/src/client_builder.rs (L82-88)
```rust
    pub fn api_key(mut self, api_key: &str) -> Result<Self> {
        self.headers.insert(
            header::AUTHORIZATION,
            HeaderValue::from_str(&format!("Bearer {}", api_key))?,
        );
        Ok(self)
    }
```

**File:** crates/aptos/src/move_tool/sim.rs (L34-38)
```rust
    /// API key for connecting to the fullnode.
    ///
    /// It is strongly recommended to specify an API key to avoid rate limiting.
    #[clap(long)]
    api_key: Option<String>,
```

**File:** aptos-move/aptos-transaction-simulation-session/src/session.rs (L206-214)
```rust
            BaseState::Remote {
                node_url,
                network_version,
                api_key,
            } => {
                let mut builder = Client::builder(AptosBaseUrl::Custom(node_url.clone()));
                if let Some(api_key) = api_key {
                    builder = builder.api_key(api_key)?;
                }
```
