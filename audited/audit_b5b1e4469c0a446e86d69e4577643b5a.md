# Audit Report

## Title
Path Traversal Vulnerability in Move CLI Coverage Tool Allows Arbitrary File Read

## Summary
The Move CLI coverage command fails to validate the `source_path` extracted from compiled units before using it to read files. An attacker can exploit this by creating symbolic links in the build artifacts directory, causing the coverage tool to read and display arbitrary files from the filesystem.

## Finding Description

The vulnerability exists in the coverage reporting functionality of the Move CLI tool. When executing coverage analysis, the code follows this flow:

1. At line 62 [1](#0-0) , `reroot_path()` changes the current directory to the package root

2. At line 74 [2](#0-1) , a compiled unit is retrieved from the package

3. At line 75 [3](#0-2) , the `source_path` is extracted directly from the unit **without any validation**

4. At line 94 [4](#0-3) , this unvalidated path is passed to `compute_source_coverage()`

5. At line 401 [5](#0-4) , `fs::read_to_string(file_path)` directly reads the file without any path sanitization or validation

The `source_path` originates from compiled package metadata loaded via `decode_unit()` [6](#0-5) . This function only validates that the path exists using `is_file()` [7](#0-6)  but **does not verify the path is within the package directory** or check for symbolic links.

**Attack Scenario:**
1. Attacker creates or obtains a Move package
2. Compiles it to generate legitimate build artifacts in `build/<package>/`
3. Replaces a source file (e.g., `build/<package>/sources/MyModule.move`) with a symbolic link to a sensitive file (e.g., `~/.ssh/id_rsa`, application config files, or `.env` files containing credentials)
4. Victim runs `move coverage source --module MyModule`
5. The coverage tool follows the symlink and reads the target file
6. File contents are displayed in the coverage output

The vulnerability is enabled by several implementation details:
- `walkdir::WalkDir` uses `follow_links(true)` [8](#0-7)  during file discovery
- `Path::is_file()` returns true for symbolic links pointing to files
- No canonicalization or containment checks are performed on source paths

## Impact Explanation

**Severity: High** (though not blockchain-protocol critical)

This vulnerability allows **arbitrary file read** from the filesystem with the permissions of the user running the coverage command. While this doesn't directly impact blockchain consensus or validator operations, it poses significant security risks:

1. **Credential Theft**: Attackers can read SSH keys, API tokens, wallet private keys, or environment variables containing secrets
2. **Source Code Disclosure**: Private application code or proprietary Move modules can be exfiltrated
3. **Configuration Exposure**: Database credentials, service endpoints, and other sensitive configuration can be stolen
4. **Supply Chain Attack Vector**: Malicious dependencies or tooling could exploit this to steal secrets from developer machines

This falls under **High Severity** per the bug bounty criteria as it represents a significant security violation in the development toolchain, though it affects local developer environments rather than the blockchain network itself.

## Likelihood Explanation

**Likelihood: Medium to High**

The vulnerability is highly likely to be exploited in several realistic scenarios:

1. **Social Engineering**: Attackers distribute "interesting" Move packages asking developers to run coverage analysis
2. **Compromised Dependencies**: A malicious package in the dependency chain modifies build artifacts
3. **Malicious Build Scripts**: Pre/post-build hooks could create symbolic links in the build directory
4. **Insider Threats**: Developers with repository access could plant malicious packages

The attack requires:
- Write access to the build directory (commonly available in development environments)
- OR convincing a user to run coverage on a malicious package

The barrier to exploitation is low - creating a symbolic link is trivial, and developers frequently run coverage tools on third-party code during evaluation or auditing.

## Recommendation

Implement path validation and canonicalization before reading source files:

```rust
// In coverage.rs after line 75:
let source_path = &unit.source_path;

// Add validation:
let canonical_source = source_path.canonicalize()
    .context("Failed to canonicalize source path")?;
let canonical_package = path.canonicalize()?;

// Ensure source is within package directory
if !canonical_source.starts_with(&canonical_package) {
    bail!(
        "Security: source path '{}' is outside package directory",
        source_path.display()
    );
}

// Use canonical_source instead of source_path
let source_coverage = source_coverage_builder.compute_source_coverage(&canonical_source);
```

Additional security measures:
1. Add a `--allow-external-sources` flag (disabled by default) for legitimate out-of-tree source scenarios
2. Log warnings when symbolic links are encountered in build artifacts
3. Consider adding a verification step in `decode_unit()` [9](#0-8)  to detect and reject symbolic links

## Proof of Concept

```bash
#!/bin/bash
# PoC: Arbitrary File Read via Move Coverage Tool

# Step 1: Create a simple Move package
mkdir -p test_package/sources
cd test_package

cat > Move.toml <<EOF
[package]
name = "TestPackage"
version = "1.0.0"

[addresses]
test = "0x1"
EOF

cat > sources/Test.move <<EOF
module test::Test {
    public fun dummy() {}
}
EOF

# Step 2: Compile the package
move build

# Step 3: Replace source with symlink to sensitive file
rm build/TestPackage/sources/Test.move
ln -s ~/.ssh/id_rsa build/TestPackage/sources/Test.move

# Step 4: Run coverage (assuming previous test execution with --coverage)
# This will read and display ~/.ssh/id_rsa contents
move coverage source --module Test

# The private key will be displayed in the coverage output
```

The PoC demonstrates that an attacker with write access to the build directory can exfiltrate arbitrary files by replacing source files with symbolic links before running coverage commands.

### Citations

**File:** third_party/move/tools/move-cli/src/base/coverage.rs (L62-62)
```rust
        let path = reroot_path(path)?;
```

**File:** third_party/move/tools/move-cli/src/base/coverage.rs (L74-74)
```rust
                let unit = package.get_module_by_name_from_root(&module_name)?;
```

**File:** third_party/move/tools/move-cli/src/base/coverage.rs (L75-75)
```rust
                let source_path = &unit.source_path;
```

**File:** third_party/move/tools/move-cli/src/base/coverage.rs (L94-94)
```rust
                let source_coverage = source_coverage_builder.compute_source_coverage(source_path);
```

**File:** third_party/move/tools/move-coverage/src/source_coverage.rs (L401-401)
```rust
        let file_contents = fs::read_to_string(file_path).unwrap();
```

**File:** third_party/move/tools/move-package/src/compilation/compiled_package.rs (L209-237)
```rust
    fn decode_unit(
        &self,
        package_name: Symbol,
        bytecode_path_str: &str,
    ) -> Result<CompiledUnitWithSource> {
        let package_name_opt = Some(package_name);
        let bytecode_path = Path::new(bytecode_path_str);
        let path_to_file = CompiledPackageLayout::path_to_file_after_category(bytecode_path);
        let bytecode_bytes = std::fs::read(bytecode_path)?;
        let source_map = source_map_from_file(
            &self
                .root_path
                .join(CompiledPackageLayout::SourceMaps.path())
                .join(&path_to_file)
                .with_extension(SOURCE_MAP_EXTENSION),
        )?;
        let source_path = self
            .root_path
            .join(CompiledPackageLayout::Sources.path())
            .join(path_to_file)
            .with_extension(MOVE_EXTENSION);
        ensure!(
            source_path.is_file(),
            "Error decoding package: {}. \
            Unable to find corresponding source file for '{}' in package {}",
            self.package.compiled_package_info.package_name,
            bytecode_path_str,
            package_name
        );
```

**File:** third_party/move/move-command-line-common/src/files.rs (L80-81)
```rust
        for entry in walkdir::WalkDir::new(path)
            .follow_links(true)
```
