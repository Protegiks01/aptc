# Audit Report

## Title
State Snapshot Restoration Accepts Unverified LedgerInfo Signatures Allowing Arbitrary State Injection

## Summary
The state snapshot restoration process in `run_impl()` contains a critical vulnerability where validator signatures on the `LedgerInfoWithSignatures` are either not verified at all (when `epoch_history` is `None`) or verification is silently skipped with only a warning (when the epoch is newer than the history). This allows an attacker to craft malicious backups with forged or invalid signatures that will be accepted during restoration, leading to arbitrary state corruption.

## Finding Description
The vulnerability exists in two distinct but related code paths:

**Vulnerability 1: Optional Signature Verification** [1](#0-0) 

The signature verification is wrapped in an optional check. When `epoch_history` is `None`, no signature verification occurs. This happens in two scenarios:

1. **One-off state snapshot restore**: [2](#0-1) 

2. **Full restore with `--skip-epoch-endings` flag**: [3](#0-2) 

**Vulnerability 2: Epoch Too New Bypass**

Even when `epoch_history` is provided, the verification function has a critical bypass: [4](#0-3) 

If the ledger info's epoch is newer than what's in the epoch history, the function returns `Ok()` with only a warning, completely bypassing signature verification. The TODO comment indicates this is a known incomplete implementation.

**Attack Flow**:
1. Attacker crafts a malicious `StateSnapshotBackup` with:
   - Arbitrary state data (modified balances, fake validator set, etc.)
   - A `LedgerInfoWithSignatures` with FORGED or INVALID signatures
   - A valid `TransactionInfoWithProof` (just needs correct Merkle proof structure)

2. Victim runs restoration using either:
   ```bash
   aptos-db-tool restore oneoff state-snapshot --state-manifest <malicious_manifest>
   ```
   or
   ```bash
   aptos-db-tool restore bootstrap-db --skip-epoch-endings
   ```

3. The code path executes:
   - Load manifest and ledger info [5](#0-4) 
   - Verify accumulator proof (NOT signatures) [6](#0-5) 
   - Verify root hash matches [7](#0-6) 
   - **SKIP signature verification** because `epoch_history` is None
   - Restore malicious state to database

4. The node now has corrupted state with attacker-controlled data

**Why This Breaks Security**:
The signature verification that should occur is: [8](#0-7) 

This verifies that the ledger info is signed by 2f+1 validators of the correct epoch. Without this check, the fundamental BFT security guarantee is violated - the attacker doesn't need validator signatures to authorize state.

## Impact Explanation
**Critical Severity** - This vulnerability meets multiple critical impact categories:

1. **State Corruption**: An attacker can inject arbitrary state into a node's database without valid validator signatures, violating the core BFT safety property that only 2f+1 validators can authorize state transitions.

2. **Loss of Funds**: The attacker can craft state with modified account balances, potentially stealing funds or minting tokens by creating a snapshot where their account has higher balances.

3. **Consensus/Safety Violations**: If multiple nodes restore from the same malicious backup, they will have divergent state from the rest of the network, causing permanent consensus failure and requiring manual intervention or hard fork.

4. **Validator Set Manipulation**: The attacker can inject a fake validator set into the restored state, potentially taking over the node's view of consensus if it attempts to participate.

The vulnerability breaks the **Cryptographic Correctness** and **State Consistency** invariants by allowing state restoration without proper signature verification from the validator set.

## Likelihood Explanation
**HIGH Likelihood** - Multiple realistic scenarios enable this attack:

1. **Legitimate Use of Debug Flags**: Operators may use `--skip-epoch-endings` for debugging or faster restores, unaware it disables security checks.

2. **One-off Restore Operations**: Testing, disaster recovery, or maintenance scenarios often use one-off restore commands, which automatically bypass verification.

3. **Social Engineering**: An attacker could provide a "helpful" backup service or convince operators to restore from a compromised backup source.

4. **Compromised Backup Storage**: If backup storage (S3, GCS, etc.) is compromised, attackers can replace legitimate backups with malicious ones.

5. **Insider Threat**: A malicious operator with access to backup infrastructure could inject malicious backups.

The attack requires no validator private keys, no consensus participation, and no exploitation of cryptographic primitives - only user interaction with a malicious backup.

## Recommendation

**Fix 1: Make epoch_history Required**
Remove the optional nature of `epoch_history` and always require signature verification:

```rust
async fn run_impl(self) -> Result<()> {
    // ... existing code ...
    
    let epoch_history = self.epoch_history.as_ref()
        .ok_or_else(|| anyhow!("epoch_history is required for secure state restoration. Do not use --skip-epoch-endings in production."))?;
    epoch_history.verify_ledger_info(&li)?;
    
    // ... rest of function ...
}
```

**Fix 2: Fix the "Epoch Too New" Bypass**
Replace the early return with proper error handling:

```rust
pub fn verify_ledger_info(&self, li_with_sigs: &LedgerInfoWithSignatures) -> Result<()> {
    let epoch = li_with_sigs.ledger_info().epoch();
    ensure!(!self.epoch_endings.is_empty(), "Empty epoch history.");
    
    // Remove the early return - require verification for all epochs
    ensure!(
        epoch <= self.epoch_endings.len() as u64,
        "Epoch {} is newer than epoch history (up to {}). \
         Cannot verify signatures without proper epoch history. \
         Ensure epoch ending backups are complete and up-to-date.",
        epoch,
        self.epoch_endings.len()
    );
    
    // ... rest of verification logic ...
}
```

**Fix 3: Add Explicit Warning in CLI**
Update the CLI help text to clearly indicate security implications:

```rust
#[clap(long, help = "Skip restoring epoch ending info. \
    WARNING: This disables signature verification and should NEVER \
    be used in production or with untrusted backups.")]
pub skip_epoch_endings: bool,
```

## Proof of Concept

```rust
// Proof of Concept: Demonstrate malicious backup restoration without signature verification

use aptos_backup_cli::{
    backup_types::state_snapshot::{
        manifest::{StateSnapshotBackup, StateSnapshotChunk},
        restore::{StateSnapshotRestoreController, StateSnapshotRestoreOpt},
    },
    utils::{GlobalRestoreOptions, RestoreRunMode},
};
use aptos_crypto::HashValue;
use aptos_db::state_restore::StateSnapshotRestoreMode;
use aptos_types::{
    ledger_info::{LedgerInfo, LedgerInfoWithSignatures},
    proof::TransactionInfoWithProof,
    aggregate_signature::AggregateSignature,
};

#[tokio::test]
async fn test_malicious_restore_without_epoch_history() {
    // Step 1: Create a malicious LedgerInfoWithSignatures with INVALID signatures
    let malicious_ledger_info = LedgerInfo::new(
        /* block_info with fake state root */
        BlockInfo::new(
            999, // fake epoch
            0,
            HashValue::random(),
            HashValue::random(), // attacker-controlled state root
            12345, // fake version
            0,
            None,
        ),
        HashValue::zero(),
    );
    
    // Create ledger info with EMPTY/INVALID signatures - no validator signed this!
    let malicious_li_with_sigs = LedgerInfoWithSignatures::new(
        malicious_ledger_info,
        AggregateSignature::empty(), // FORGED - no real validator signatures!
    );
    
    // Step 2: Create valid-looking proof structure (accumulator proof)
    // This will pass the TransactionInfoWithProof::verify() check
    // but doesn't validate signatures!
    let txn_info_with_proof = TransactionInfoWithProof::new(
        /* valid accumulator proof */,
        /* transaction info with malicious state root */,
    );
    
    // Step 3: Create malicious manifest and save to backup storage
    let malicious_manifest = StateSnapshotBackup {
        version: 12345,
        root_hash: /* attacker's state root */,
        chunks: vec![/* state chunks with attacker's data */],
        proof: /* file handle to (txn_info_with_proof, malicious_li_with_sigs) */,
    };
    
    // Step 4: Run restoration with epoch_history = None
    // This is what happens with one-off restore or --skip-epoch-endings
    let controller = StateSnapshotRestoreController::new(
        StateSnapshotRestoreOpt {
            manifest_handle: malicious_manifest_handle,
            version: 12345,
            validate_modules: false,
            restore_mode: StateSnapshotRestoreMode::Default,
        },
        global_opts,
        storage,
        None, // epoch_history = None -> NO SIGNATURE VERIFICATION!
    );
    
    // Step 5: Restoration succeeds despite invalid signatures!
    controller.run().await.expect("Malicious restore succeeded without signature verification!");
    
    // Result: Node database now contains attacker-controlled state
    // with forged balances, fake validator set, or other malicious data
}
```

**Notes**:
- The vulnerability is CONFIRMED through code analysis of three interconnected files
- The TODO comment at [9](#0-8)  explicitly acknowledges this as incomplete implementation
- The warning message claims "node won't be able to start if this data is malicious" but this is FALSE when `epoch_history` is None
- Production deployments using backup restoration are at risk if they use `--skip-epoch-endings` or one-off restore commands with untrusted backup sources
- The only verification performed is Merkle proof validation, not cryptographic signature validation of the validator set

### Citations

**File:** storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs (L123-126)
```rust
        let manifest: StateSnapshotBackup =
            self.storage.load_json_file(&self.manifest_handle).await?;
        let (txn_info_with_proof, li): (TransactionInfoWithProof, LedgerInfoWithSignatures) =
            self.storage.load_bcs_file(&manifest.proof).await?;
```

**File:** storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs (L127-127)
```rust
        txn_info_with_proof.verify(li.ledger_info(), manifest.version)?;
```

**File:** storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs (L131-136)
```rust
        ensure!(
            state_root_hash == manifest.root_hash,
            "Root hash mismatch with that in proof. root hash: {}, expected: {}",
            manifest.root_hash,
            state_root_hash,
        );
```

**File:** storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs (L137-139)
```rust
        if let Some(epoch_history) = self.epoch_history.as_ref() {
            epoch_history.verify_ledger_info(&li)?;
        }
```

**File:** storage/db-tool/src/restore.rs (L88-95)
```rust
                        StateSnapshotRestoreController::new(
                            opt,
                            global.try_into()?,
                            storage.init_storage().await?,
                            None, /* epoch_history */
                        )
                        .run()
                        .await?;
```

**File:** storage/backup/backup-cli/src/coordinators/restore.rs (L219-231)
```rust
        let epoch_history = if !self.skip_epoch_endings {
            Some(Arc::new(
                EpochHistoryRestoreController::new(
                    epoch_handles,
                    self.global_opt.clone(),
                    self.storage.clone(),
                )
                .run()
                .await?,
            ))
        } else {
            None
        };
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L279-287)
```rust
        if epoch > self.epoch_endings.len() as u64 {
            // TODO(aldenhu): fix this from upper level
            warn!(
                epoch = epoch,
                epoch_history_until = self.epoch_endings.len(),
                "Epoch is too new and can't be verified. Previous chunks are verified and node \
                won't be able to start if this data is malicious."
            );
            return Ok(());
```

**File:** types/src/epoch_state.rs (L41-49)
```rust
    fn verify(&self, ledger_info: &LedgerInfoWithSignatures) -> anyhow::Result<()> {
        ensure!(
            self.epoch == ledger_info.ledger_info().epoch(),
            "LedgerInfo has unexpected epoch {}, expected {}",
            ledger_info.ledger_info().epoch(),
            self.epoch
        );
        ledger_info.verify_signatures(&self.verifier)?;
        Ok(())
```
