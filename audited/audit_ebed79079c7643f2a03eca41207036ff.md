# Audit Report

## Title
Resource Exhaustion via Deferred Gas Metering in Table Native Functions (Legacy Path)

## Summary
Disabling incremental gas charging for table native functions at line 301 of `lib.rs` creates a vulnerability in the legacy gas metering path (gas_feature_version < 36) where expensive operations execute before gas limits are enforced, enabling resource exhaustion attacks on validator nodes.

## Finding Description

The table native functions disable incremental gas charging, which bypasses immediate gas limit checks in the legacy metering path. This breaks the fundamental gas metering invariant: **"first charge gas, then execute."** [1](#0-0) 

When `legacy_enable_incremental_gas_charging` is set to `false`, the gas charging logic fails to enforce limits during execution: [2](#0-1) 

The critical flaw is at line 94: the condition `self.legacy_gas_used > self.legacy_gas_budget() && self.legacy_enable_incremental_gas_charging` always evaluates to `false` when incremental charging is disabled, allowing execution to continue even when gas budget is exceeded.

**Attack Path:**

1. Attacker creates a table with `Table<vector<u8>, u64>` (vector keys allowed per table constraints)
2. Crafts transaction with minimal remaining gas (e.g., 2,000 gas units)
3. Calls `table.add(huge_key, value)` where `huge_key` is a 100KB vector

In `native_add_box`:
- Line 394 charges base cost (4,411 gas) but doesn't error despite exceeding budget [3](#0-2) 

- Lines 410-411 perform expensive key serialization **without any gas check** [4](#0-3) 

- Lines 414-415 perform expensive storage I/O **without any gas check** [5](#0-4) 

- Line 438 charges per-byte cost (3,600,000 gas) but still doesn't error [6](#0-5) 

Gas is only checked **after** the native function completes and returns control to the interpreter: [7](#0-6) 

By this point, the node has already performed expensive CPU serialization and storage I/O operations without proper gas compensation.

This vulnerability **only affects networks running gas_feature_version < 36** because the new direct gas meter path bypasses this logic: [8](#0-7) 

The same pattern exists in `native_borrow_box`, `native_contains_box`, and `native_remove_box`, all performing expensive operations before deferred gas charges.

## Impact Explanation

This vulnerability enables **validator node slowdowns**, qualifying as **High Severity** per Aptos bug bounty criteria. 

Attackers can flood the network with transactions that:
- Cost minimal gas to submit (only pay for work done before out-of-gas)
- Force validators to perform expensive work (100KB+ serialization + storage lookups)
- Execute repeatedly as the transactions revert but nodes waste resources

This breaks the **Resource Limits** invariant (#9): "All operations must respect gas, storage, and computational limits." Gas metering should prevent uncompensated computational work, but the deferred charging pattern allows expensive operations to complete before enforcement.

## Likelihood Explanation

**Likelihood: Medium to Low** (depends on deployment configuration)

**Requirements:**
- Network must run with `gas_feature_version < 36` (RELEASE_V1_32)
- Attacker needs only standard transaction submission access
- No special privileges or validator access required

**Complexity:** Low - straightforward transaction construction with large vector keys

If mainnet runs `gas_feature_version >= 36`, this vulnerability is **not exploitable in production** but remains a latent code flaw. Older testnets or networks that haven't upgraded to v1.32+ remain vulnerable.

## Recommendation

**Option 1 (Preferred):** Remove legacy code path entirely once all networks upgrade to gas_feature_version >= 36:

```rust
pub fn charge(&mut self, abstract_amount: impl GasExpression<...>) -> SafeNativeResult<()> {
    let amount = abstract_amount.evaluate(...);
    self.gas_meter()
        .charge_native_execution(amount)
        .map_err(LimitExceededError::from_err)?;
    Ok(())
}
```

**Option 2:** If legacy path must remain, enable incremental charging for table natives:

```rust
pub fn table_natives(table_addr: AccountAddress, builder: &mut SafeNativeBuilder) -> NativeFunctionTable {
    builder.with_incremental_gas_charging(true, |builder| {  // Change false -> true
        builder.make_named_natives([...])
    })
}
```

**Option 3:** Charge per-byte costs **before** expensive operations:

```rust
// In native_add_box
let key_bytes = serialize_key(...)?;
let key_cost = ADD_BOX_PER_BYTE_SERIALIZED * NumBytes::new(key_bytes.len() as u64);
context.charge(key_cost)?;  // Charge BEFORE get_or_create_global_value
let (gv, loaded) = table.get_or_create_global_value(...)?;
```

## Proof of Concept

```move
// test_table_gas_exhaustion.move
#[test_only]
module test_addr::table_gas_exploit {
    use aptos_std::table;
    
    #[test(attacker = @0x42)]
    #[expected_failure(abort_code = OUT_OF_GAS)]  
    fun test_large_key_gas_exhaustion(attacker: &signer) {
        // Requires gas_feature_version < 36 to demonstrate vulnerability
        
        let t = table::new<vector<u8>, u64>();
        
        // Create 100KB vector key
        let huge_key = vector::empty<u8>();
        let i = 0;
        while (i < 100000) {
            vector::push_back(&mut huge_key, 0xFF);
            i = i + 1;
        };
        
        // With minimal gas remaining (simulated), this should:
        // 1. Perform expensive 100KB serialization
        // 2. Perform storage lookup  
        // 3. THEN fail with OUT_OF_GAS
        // Validator has already wasted resources
        table::add(&mut t, huge_key, 42);
        
        table::drop_unchecked(t);
    }
}
```

**Rust Reproduction (for gas_feature_version < 36 environments):**

```rust
// Trace gas charging behavior
let mut context = SafeNativeContext { 
    legacy_enable_incremental_gas_charging: false,
    gas_feature_version: 35, // < RELEASE_V1_32
    // ... other fields
};

// Simulate expensive operation
context.charge(LARGE_AMOUNT)?; // Does NOT error despite exceeding budget
// Expensive work happens here...
// Only fails when native returns and interpreter checks total cost
```

## Notes

- This vulnerability is **code-present but deployment-conditional** based on `gas_feature_version`
- Networks running v1.32+ (gas_feature_version >= 36) are **not affected** due to direct gas meter access
- The design flaw remains in codebase and could affect rollbacks or legacy deployments
- The TODO comment at line 437 ("Figure out a way to charge this earlier") acknowledges the deferred charging issue but doesn't mention the security implication when incremental charging is disabled [9](#0-8)

### Citations

**File:** aptos-move/framework/table-natives/src/lib.rs (L301-301)
```rust
    builder.with_incremental_gas_charging(false, |builder| {
```

**File:** aptos-move/framework/table-natives/src/lib.rs (L394-394)
```rust
    context.charge(ADD_BOX_BASE)?;
```

**File:** aptos-move/framework/table-natives/src/lib.rs (L410-411)
```rust
    let function_value_extension = loader_context.function_value_extension();
    let key_bytes = serialize_key(&function_value_extension, &table.key_layout, &key)?;
```

**File:** aptos-move/framework/table-natives/src/lib.rs (L414-415)
```rust
    let (gv, loaded) =
        table.get_or_create_global_value(&function_value_extension, table_context, key_bytes)?;
```

**File:** aptos-move/framework/table-natives/src/lib.rs (L437-437)
```rust
    // TODO(Gas): Figure out a way to charge this earlier.
```

**File:** aptos-move/framework/table-natives/src/lib.rs (L438-438)
```rust
    context.charge(key_cost)?;
```

**File:** aptos-move/aptos-native-interface/src/context.rs (L92-102)
```rust
            self.legacy_gas_used += amount;
            if self.legacy_gas_used > self.legacy_gas_budget()
                && self.legacy_enable_incremental_gas_charging
            {
                Err(SafeNativeError::LimitExceeded(
                    LimitExceededError::LegacyOutOfGas,
                ))
            } else {
                Ok(())
            }
        }
```

**File:** aptos-move/aptos-native-interface/src/context.rs (L107-109)
```rust
    pub fn has_direct_gas_meter_access_in_native_context(&self) -> bool {
        self.gas_feature_version >= RELEASE_V1_32
    }
```

**File:** third_party/move/move-vm/runtime/src/interpreter.rs (L1115-1115)
```rust
                gas_meter.charge_native_function(cost, Some(return_values.iter()))?;
```
