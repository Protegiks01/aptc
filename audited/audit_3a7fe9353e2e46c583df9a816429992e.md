# Audit Report

## Title
Missing JWK Type Validation in Consensus Allows Unsupported Keys to Block Keyless Authentication

## Summary
The `new_rb_request()` function in per-key JWK consensus mode does not validate that JWKs are of a supported type (RSA) before processing them through consensus. This allows `UnsupportedJWK` entries to be stored on-chain in `ObservedJWKs`, which are then rejected during keyless authentication, causing a denial-of-service for affected users.

## Finding Description

The JWK consensus system in Aptos allows validators to observe JSON Web Keys from approved OIDC providers and reach consensus on storing them on-chain for keyless authentication. However, the system fails to validate JWK types at critical points in the consensus pipeline.

**Flow of the Vulnerability:**

1. **JWK Observation**: Validators fetch JWKs from OIDC providers via `JWKObserver`. When parsing these keys, any non-RSA key (ECDSA, EdDSA, etc.) is converted to an `UnsupportedJWK`: [1](#0-0) 

2. **Consensus Processing**: In per-key mode, `new_rb_request()` converts the payload to a `KeyLevelUpdate` without validating the JWK type: [2](#0-1) 

The conversion accepts both RSA and Unsupported JWKs: [3](#0-2) 

3. **On-Chain Storage**: The Move function `upsert_into_observed_jwks` stores these JWKs without type validation, whether in per-key or per-issuer mode: [4](#0-3) 

4. **Authentication Failure**: When users attempt keyless authentication, `get_jwk_for_authenticator` explicitly rejects `UnsupportedJWK` entries: [5](#0-4) 

**Attack Scenario:**

If an approved OIDC provider migrates from RSA to ECDSA keys (or publishes only ECDSA keys), validators will:
- Observe and parse the ECDSA keys as `UnsupportedJWK`
- Reach consensus on these entries (no validation prevents this)
- Store them on-chain in `ObservedJWKs`
- Cause all users of that provider to fail authentication with "JWK ... is not supported"

This breaks the security guarantee that users can always authenticate if their OIDC provider's JWKs are current and properly signed.

## Impact Explanation

**Medium Severity** - This qualifies as "State inconsistencies requiring intervention" per Aptos bug bounty criteria:

- **User DoS**: Complete loss of keyless authentication for all users of an affected OIDC provider
- **State Bloat**: Unusable `UnsupportedJWK` entries consume on-chain storage indefinitely
- **Resource Waste**: Validators expend CPU, network, and storage resources on keys that will never be usable
- **Recovery Complexity**: Requires either (a) OIDC provider reverting to RSA keys, or (b) Aptos governance intervention to remove the invalid entries

The impact is limited to keyless authentication and does not directly affect consensus safety or cause fund theft, placing it at Medium rather than High/Critical severity.

## Likelihood Explanation

**Medium to High Likelihood**:

- **Realistic Scenario**: OIDC providers do upgrade cryptographic algorithms over time. While many maintain backward compatibility, there is no guarantee
- **No Attacker Required**: This can occur through normal provider operations, not just malicious action
- **Already Happening**: Some OIDC providers publish mixed key sets (RSA + ECDSA), meaning `UnsupportedJWK` entries are likely already being observed
- **Low Barrier**: Does not require validator collusion or privileged access

## Recommendation

Add JWK type validation at the consensus entry point to reject unsupported keys before they enter the consensus pipeline:

```rust
// In per_key.rs
fn new_rb_request(
    epoch: u64,
    payload: &ProviderJWKs,
) -> anyhow::Result<ObservedKeyLevelUpdateRequest> {
    let KeyLevelUpdate { issuer, kid, to_upsert, .. } =
        KeyLevelUpdate::try_from_issuer_level_repr(payload)
            .context("new_rb_request failed with repr translation")?;
    
    // Validate that the JWK is of a supported type
    if let Some(jwk) = &to_upsert {
        match jwk {
            JWK::RSA(_) => {}, // Supported
            JWK::Unsupported(_) => {
                bail!("Unsupported JWK type cannot be processed through consensus");
            }
        }
    }
    
    Ok(ObservedKeyLevelUpdateRequest { epoch, issuer, kid })
}
```

Additionally, add similar validation in per-issuer mode and consider logging/metrics for when unsupported keys are encountered to aid in debugging and future algorithm support planning.

## Proof of Concept

```rust
#[test]
fn test_unsupported_jwk_consensus_validation() {
    use aptos_types::jwks::{ProviderJWKs, jwk::{JWK, JWKMoveStruct}, unsupported::UnsupportedJWK};
    
    // Create a ProviderJWKs with an UnsupportedJWK (e.g., ECDSA key)
    let unsupported_jwk = UnsupportedJWK {
        id: b"test-ecdsa-key".to_vec(),
        payload: b"{\"kty\":\"EC\",\"crv\":\"P-256\"}".to_vec(),
    };
    
    let payload = ProviderJWKs {
        issuer: b"https://test.issuer".to_vec(),
        version: 1,
        jwks: vec![JWKMoveStruct::from(JWK::Unsupported(unsupported_jwk))],
    };
    
    // Attempt to create reliable broadcast request
    let result = PerKeyMode::new_rb_request(0, &payload);
    
    // Currently succeeds (vulnerability)
    assert!(result.is_ok(), "Unsupported JWK should be rejected but was accepted");
    
    // After fix, this should fail with validation error
    // assert!(result.is_err());
    // assert!(result.unwrap_err().to_string().contains("Unsupported JWK type"));
}
```

This test demonstrates that `UnsupportedJWK` entries currently pass through `new_rb_request()` without validation, confirming the vulnerability.

### Citations

**File:** types/src/jwks/jwk/mod.rs (L80-89)
```rust
impl From<serde_json::Value> for JWK {
    fn from(value: serde_json::Value) -> Self {
        match RSA_JWK::try_from(&value) {
            Ok(rsa) => Self::RSA(rsa),
            Err(_) => {
                let unsupported = UnsupportedJWK::from(value);
                Self::Unsupported(unsupported)
            },
        }
    }
```

**File:** crates/aptos-jwk-consensus/src/mode/per_key.rs (L32-40)
```rust
    fn new_rb_request(
        epoch: u64,
        payload: &ProviderJWKs,
    ) -> anyhow::Result<ObservedKeyLevelUpdateRequest> {
        let KeyLevelUpdate { issuer, kid, .. } =
            KeyLevelUpdate::try_from_issuer_level_repr(payload)
                .context("new_rb_request failed with repr translation")?;
        Ok(ObservedKeyLevelUpdateRequest { epoch, issuer, kid })
    }
```

**File:** types/src/jwks/mod.rs (L360-384)
```rust
    pub fn try_from_issuer_level_repr(repr: &ProviderJWKs) -> anyhow::Result<Self> {
        ensure!(
            repr.jwks.len() == 1,
            "wrapped repr of a key-level update should have exactly 1 jwk"
        );
        let jwk =
            JWK::try_from(&repr.jwks[0]).context("try_from_issuer_level_repr failed on JWK")?;
        let base_version = repr
            .version
            .checked_sub(1)
            .context("try_from_issuer_level_repr on version")?;
        Ok(Self {
            issuer: repr.issuer.clone(),
            base_version,
            kid: jwk.id(),
            to_upsert: match jwk {
                JWK::Unsupported(unsupported)
                    if unsupported.payload.as_slice() == DELETE_COMMAND_INDICATOR.as_bytes() =>
                {
                    None
                },
                _ => Some(jwk),
            },
        })
    }
```

**File:** aptos-move/framework/aptos-framework/sources/jwks.move (L479-491)
```text
                vector::for_each(proposed_provider_jwks.jwks, |jwk|{
                    let variant_type_name = *string::bytes(copyable_any::type_name(&jwk.variant));
                    let is_delete = if (variant_type_name == b"0x1::jwks::UnsupportedJWK") {
                        let repr = copyable_any::unpack<UnsupportedJWK>(jwk.variant);
                        &repr.payload == &DELETE_COMMAND_INDICATOR
                    } else {
                        false
                    };
                    if (is_delete) {
                        remove_jwk(&mut cur_issuer_jwks, get_jwk_id(&jwk));
                    } else {
                        upsert_jwk(&mut cur_issuer_jwks, jwk);
                    }
```

**File:** aptos-move/aptos-vm/src/keyless_validation.rs (L140-146)
```rust
        JWK::Unsupported(jwk) => {
            return Err(invalid_signature!(format!(
                "JWK with KID {} and hex-encoded payload {} is not supported",
                jwt_header.kid,
                hex::encode(&jwk.payload)
            )))
        },
```
