# Audit Report

## Title
Source Map and Source Code Manipulation Bypasses Package Verification

## Summary
Attackers can publish Move packages with mismatched bytecode and source code/source maps, completely bypassing the package verification system. The on-chain bytecode can execute malicious logic while the stored source code and source maps point to benign code, deceiving auditors and users.

## Finding Description

The Aptos package publishing and verification system has a critical flaw: there is no cryptographic or structural binding between the published bytecode and the source code/source maps stored in `PackageMetadata`. This breaks the fundamental security guarantee that "what you review is what executes." [1](#0-0) 

When publishing a package via `publish_package_txn`, two separate parameters are passed:
1. `metadata_serialized` - contains `PackageMetadata` including `source` and `source_map` fields
2. `code` - the actual bytecode modules to be published [2](#0-1) 

The `ModuleMetadata` structure stores source code and source maps as compressed byte arrays, but these are never validated against the actual bytecode being published. [3](#0-2) 

The `publish_package` function:
1. Stores the `PackageMetadata` (with source/source_map) directly into `PackageRegistry` without validation
2. Calls `request_publish` with only the module names and bytecode
3. Never checks if the source_map or source in the metadata corresponds to the bytecode [4](#0-3) 

The VM's `validate_publish_request` only validates:
- Bytecode structure and dependencies
- Module names match expected names
- Native function validity
- Resource groups and events

It does NOT receive or validate source maps at all.

**The Verification Gap:** [5](#0-4) 

The `VerifyPackage` command has a critical flaw at line 2064: it creates the package registry with `with_bytecode: false`, meaning it never downloads the actual on-chain bytecode to compare with the locally compiled version. [6](#0-5) 

The `verify()` method only compares metadata fields (name, deps, modules, manifest, etc.) but never compares the actual bytecode that executes on-chain.

**Attack Scenario:**

1. Attacker writes `benign.move` (safe code) and `malicious.move` (steals funds), both defining `module 0xAttacker::Token`
2. Compiles both to get `benign.mv` + `benign.mvsm` and `malicious.mv` + `malicious.mvsm`
3. Publishes with `PackageMetadata` containing `source=benign.move` and `source_map=benign.mvsm`, but `code=[malicious.mv]`
4. Auditors download metadata, see benign source, compile locally, verify metadata matches - âœ“ passes
5. Users execute transactions against the module - malicious.mv executes, funds stolen

## Impact Explanation

**HIGH Severity** - This is a significant protocol violation that undermines the entire package verification and audit system:

- **Audit Bypass**: Auditors reviewing on-chain packages are deceived into thinking malicious code is safe
- **User Trust Violation**: Users deploying "verified" packages unknowingly deploy malicious code
- **Fund Loss Potential**: Malicious bytecode can steal funds while appearing legitimate
- **Ecosystem-Wide Impact**: All packages relying on the verification system are at risk

This meets the HIGH severity criteria for "Significant protocol violations" and could lead to fund loss, warranting up to $50,000 per the bug bounty program.

## Likelihood Explanation

**HIGH Likelihood**:
- Requires no special privileges - any account with code publishing permission can exploit
- Attack is straightforward to execute using standard compilation tools
- No consensus manipulation or validator collusion required
- The verification tool is widely used and trusted by the ecosystem
- Attack is undetectable to standard audit workflows

## Recommendation

Implement bytecode hash verification in the package publishing and verification system:

1. **Publishing Side** - In `publish_package`, compute and store bytecode hashes:
```rust
// In code.move, add to ModuleMetadata:
struct ModuleMetadata has copy, drop, store {
    name: String,
    source: vector<u8>,
    source_map: vector<u8>,
    bytecode_hash: vector<u8>,  // Add SHA256 hash of actual bytecode
    extension: Option<Any>,
}
```

2. **Validation Side** - In `validate_publish_request`, verify the hash:
```rust
// Compare hash of actual bytecode with metadata.bytecode_hash
let actual_hash = sha256(&bytecode);
assert!(actual_hash == metadata.bytecode_hash, "Bytecode mismatch");
```

3. **Verification Tool** - In `VerifyPackage`, download and compare bytecode:
```rust
// Change line 2064 to download bytecode
let registry = CachedPackageRegistry::create(url, self.account, true).await?;

// Add bytecode comparison
for module_name in compiled_metadata.modules {
    let on_chain_bytecode = registry.get_bytecode(&module_name).await?;
    let local_bytecode = /* compile locally */;
    assert!(on_chain_bytecode == local_bytecode, "Bytecode mismatch!");
}
```

## Proof of Concept

```move
// benign.move - Auditor sees this
module 0x42::Token {
    struct Balance has key { value: u64 }
    
    public entry fun transfer(from: &signer, to: address, amount: u64) {
        // Safe transfer logic
    }
}

// malicious.move - Actually published on-chain
module 0x42::Token {
    struct Balance has key { value: u64 }
    
    public entry fun transfer(from: &signer, to: address, amount: u64) {
        // Backdoor: transfer to attacker instead
        let attacker = @0xAttacker;
        // ... malicious logic ...
    }
}
```

Exploitation steps:
```bash
# 1. Compile both versions
aptos move compile --save-metadata --package-dir benign/
aptos move compile --save-metadata --package-dir malicious/

# 2. Create modified package metadata
# - Extract metadata from benign/ (has benign source + source_map)
# - Extract bytecode from malicious/ (has malicious .mv file)

# 3. Publish the mismatched package
aptos move publish \
  --metadata-path benign/build/package-metadata.bcs \
  --bytecode-path malicious/build/Token.mv

# 4. Verify appears to succeed (only checks metadata, not bytecode)
aptos move verify-package --account 0x42
# Output: "Successfully verified source of package"

# 5. But actual on-chain bytecode is malicious!
```

## Notes

This vulnerability exists because the Aptos package system treats source code, source maps, and bytecode as separate artifacts without cryptographic binding. The `source_map` field in `ModuleMetadata` is purely informational metadata that can point to completely different code than what actually executes. The verification system's incomplete validation (comparing only metadata without bytecode) creates a dangerous false sense of security for auditors and users.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/code.move (L58-67)
```text
    struct ModuleMetadata has copy, drop, store {
        /// Name of the module.
        name: String,
        /// Source text, gzipped String. Empty if not provided.
        source: vector<u8>,
        /// Source map, in compressed BCS. Empty if not provided.
        source_map: vector<u8>,
        /// For future extensions.
        extension: Option<Any>,
    }
```

**File:** aptos-move/framework/aptos-framework/sources/code.move (L168-228)
```text
    public fun publish_package(owner: &signer, pack: PackageMetadata, code: vector<vector<u8>>) acquires PackageRegistry {
        check_code_publishing_permission(owner);
        // Disallow incompatible upgrade mode. Governance can decide later if this should be reconsidered.
        assert!(
            pack.upgrade_policy.policy > upgrade_policy_arbitrary().policy,
            error::invalid_argument(EINCOMPATIBLE_POLICY_DISABLED),
        );

        let addr = signer::address_of(owner);
        if (!exists<PackageRegistry>(addr)) {
            move_to(owner, PackageRegistry { packages: vector::empty() })
        };

        // Checks for valid dependencies to other packages
        let allowed_deps = check_dependencies(addr, &pack);

        // Check package against conflicts
        // To avoid prover compiler error on spec
        // the package need to be an immutable variable
        let module_names = get_module_names(&pack);
        let package_immutable = &borrow_global<PackageRegistry>(addr).packages;
        let len = vector::length(package_immutable);
        let index = len;
        let upgrade_number = 0;
        vector::enumerate_ref(package_immutable
        , |i, old| {
            let old: &PackageMetadata = old;
            if (old.name == pack.name) {
                upgrade_number = old.upgrade_number + 1;
                check_upgradability(old, &pack, &module_names);
                index = i;
            } else {
                check_coexistence(old, &module_names)
            };
        });

        // Assign the upgrade counter.
        pack.upgrade_number = upgrade_number;

        let packages = &mut borrow_global_mut<PackageRegistry>(addr).packages;
        // Update registry
        let policy = pack.upgrade_policy;
        if (index < len) {
            *vector::borrow_mut(packages, index) = pack
        } else {
            vector::push_back(packages, pack)
        };

        event::emit(PublishPackage {
            code_address: addr,
            is_upgrade: upgrade_number > 0
        });

        // Request publish
        if (features::code_dependency_check_enabled())
            request_publish_with_allowed_deps(addr, module_names, allowed_deps, code, policy.policy)
        else
        // The new `request_publish_with_allowed_deps` has not yet rolled out, so call downwards
        // compatible code.
            request_publish(addr, module_names, code, policy.policy)
    }
```

**File:** aptos-move/framework/aptos-framework/sources/code.move (L256-258)
```text
    public entry fun publish_package_txn(owner: &signer, metadata_serialized: vector<u8>, code: vector<vector<u8>>)
    acquires PackageRegistry {
        publish_package(owner, util::from_bytes<PackageMetadata>(metadata_serialized), code)
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1680-1739)
```rust
    fn validate_publish_request(
        &self,
        module_storage: &impl AptosModuleStorage,
        traversal_context: &mut TraversalContext,
        gas_meter: &mut impl GasMeter,
        modules: &[CompiledModule],
        mut expected_modules: BTreeSet<String>,
        allowed_deps: Option<BTreeMap<AccountAddress, BTreeSet<String>>>,
    ) -> VMResult<()> {
        self.reject_unstable_bytecode(modules)?;
        native_validation::validate_module_natives(modules)?;

        for m in modules {
            if !expected_modules.remove(m.self_id().name().as_str()) {
                return Err(Self::metadata_validation_error(&format!(
                    "unregistered module: '{}'",
                    m.self_id().name()
                )));
            }
            if let Some(allowed) = &allowed_deps {
                for dep in m.immediate_dependencies() {
                    if !allowed
                        .get(dep.address())
                        .map(|modules| {
                            modules.contains("") || modules.contains(dep.name().as_str())
                        })
                        .unwrap_or(false)
                    {
                        return Err(Self::metadata_validation_error(&format!(
                            "unregistered dependency: '{}'",
                            dep
                        )));
                    }
                }
            }
            verify_module_metadata_for_module_publishing(m, self.features())
                .map_err(|err| Self::metadata_validation_error(&err.to_string()))?;
        }

        resource_groups::validate_resource_groups(
            self.features(),
            module_storage,
            traversal_context,
            gas_meter,
            modules,
        )?;
        event_validation::validate_module_events(
            self.features(),
            module_storage,
            traversal_context,
            modules,
        )?;

        if !expected_modules.is_empty() {
            return Err(Self::metadata_validation_error(
                "not all registered modules published",
            ));
        }
        Ok(())
    }
```

**File:** crates/aptos/src/move_tool/mod.rs (L2048-2083)
```rust
    async fn execute(self) -> CliTypedResult<&'static str> {
        // First build the package locally to get the package metadata
        let build_options = BuildOptions {
            install_dir: self.move_options.output_dir.clone(),
            bytecode_version: fix_bytecode_version(
                self.move_options.bytecode_version,
                self.move_options.language_version,
            ),
            ..self.included_artifacts.build_options(&self.move_options)?
        };
        let pack = BuiltPackage::build(self.move_options.get_package_path()?, build_options)
            .map_err(|e| CliError::MoveCompilationError(format!("{:#}", e)))?;
        let compiled_metadata = pack.extract_metadata()?;

        // Now pull the compiled package
        let url = self.rest_options.url(&self.profile_options)?;
        let registry = CachedPackageRegistry::create(url, self.account, false).await?;
        let package = registry
            .get_package(pack.name())
            .await
            .map_err(|s| CliError::CommandArgumentError(s.to_string()))?;

        // We can't check the arbitrary, because it could change on us
        if package.upgrade_policy() == UpgradePolicy::arbitrary() {
            return Err(CliError::CommandArgumentError(
                "A package with upgrade policy `arbitrary` cannot be downloaded \
                since it is not safe to depend on such packages."
                    .to_owned(),
            ));
        }

        // Verify that the source digest matches
        package.verify(&compiled_metadata)?;

        Ok("Successfully verified source of package")
    }
```

**File:** crates/aptos/src/move_tool/stored_package.rs (L195-243)
```rust
    pub fn verify(&self, package_metadata: &PackageMetadata) -> anyhow::Result<()> {
        let self_metadata = self.metadata;

        if self_metadata.name != package_metadata.name {
            bail!(
                "Package name doesn't match {} : {}",
                package_metadata.name,
                self_metadata.name
            )
        } else if self_metadata.deps != package_metadata.deps {
            bail!(
                "Dependencies don't match {:?} : {:?}",
                package_metadata.deps,
                self_metadata.deps
            )
        } else if self_metadata.modules != package_metadata.modules {
            bail!(
                "Modules don't match {:?} : {:?}",
                package_metadata.modules,
                self_metadata.modules
            )
        } else if self_metadata.manifest != package_metadata.manifest {
            bail!(
                "Manifest doesn't match {:?} : {:?}",
                package_metadata.manifest,
                self_metadata.manifest
            )
        } else if self_metadata.upgrade_policy != package_metadata.upgrade_policy {
            bail!(
                "Upgrade policy doesn't match {:?} : {:?}",
                package_metadata.upgrade_policy,
                self_metadata.upgrade_policy
            )
        } else if self_metadata.extension != package_metadata.extension {
            bail!(
                "Extensions doesn't match {:?} : {:?}",
                package_metadata.extension,
                self_metadata.extension
            )
        } else if self_metadata.source_digest != package_metadata.source_digest {
            bail!(
                "Source digests doesn't match {:?} : {:?}",
                package_metadata.source_digest,
                self_metadata.source_digest
            )
        }

        Ok(())
    }
```
