# Audit Report

## Title
Missing Panic Handler in Faucet Service Leads to Ungraceful Error Responses

## Summary
The Aptos Faucet service lacks the `CatchPanic` middleware that is present in the main Aptos API, causing panics in the IP blocklist checker to result in ungraceful connection closures instead of proper JSON error responses. This violates the OpenAPI contract and provides poor error handling compared to the main API.

## Finding Description

The faucet service's IP blocklist checker calls `ipv4_list.contains()` and `ipv6_list.contains()` from the external `iprange` crate without panic protection. [1](#0-0) [2](#0-1) 

These calls occur within the request handling path when `checker.check()` is invoked. [3](#0-2) 

The critical issue is that the faucet service does NOT use Poem's `CatchPanic` middleware, which is used by the main Aptos API. [4](#0-3) 

In contrast, the main Aptos API properly handles panics with dedicated middleware and a panic handler. [5](#0-4) [6](#0-5) 

**Panic Behavior:**
When the `iprange` library's `contains()` method panics due to internal bugs:
1. The panic occurs within the Tokio async task handling the HTTP request
2. Tokio catches the panic at the task boundary (service does NOT crash entirely)
3. The client receives a connection closure or generic HTTP error
4. No proper JSON error response is returned (violating OpenAPI spec)
5. No panic is logged through the proper error handler
6. Other concurrent requests continue unaffected

## Impact Explanation

This qualifies as **Medium Severity** per the Aptos bug bounty criteria:

1. **API Contract Violation**: The OpenAPI specification declares that all responses will be JSON representations of `AptosTapError`. [7](#0-6) 

2. **Inconsistent Error Handling**: The faucet service has inferior panic handling compared to the main Aptos API, creating an architectural inconsistency.

3. **Limited Denial of Service**: If the panic can be triggered reliably (e.g., through crafted IP addresses that expose iprange library bugs), an attacker could repeatedly cause poor error responses.

4. **Poor Observability**: Without proper panic logging, debugging production issues becomes difficult.

While this does not lead to funds loss, consensus violations, or complete service crashes, it represents a significant API reliability and security hygiene issue.

## Likelihood Explanation

**Likelihood: Low to Medium**

The vulnerability triggers only when:
1. The `iprange` crate (version 0.6.7) has an internal bug that causes `contains()` to panic [8](#0-7) 
2. A specific IP address or network range configuration triggers this panic
3. A client request arrives from an IP that triggers the buggy code path

However, once such a condition exists, any attacker can repeatedly exploit it by simply sending requests from the problematic IP address or range.

## Recommendation

Add `CatchPanic` middleware to the faucet service's Poem route configuration, consistent with the main Aptos API:

**In `crates/aptos-faucet/core/src/server/run.rs`:**

Create a panic handler function:
```rust
use poem::middleware::CatchPanic;

fn panic_handler(err: Box<dyn std::any::Any + Send>) -> impl poem::IntoResponse {
    aptos_logger::error!("Panic captured in faucet service: {:?}", err);
    AptosTapErrorResponse::from(AptosTapError::new_with_error_code(
        "Internal server error".to_string(),
        AptosTapErrorCode::WebFrameworkError,
    )).into_response()
}
```

Then modify the route setup to include the middleware (around line 207): [9](#0-8) 

Add `.with(CatchPanic::new().with_handler(panic_handler))` before `.around(middleware_log)`.

## Proof of Concept

```rust
#[cfg(test)]
mod panic_test {
    use super::*;
    use std::panic;
    
    #[tokio::test]
    async fn test_panic_in_checker_is_not_graceful() {
        // This test demonstrates that panics in checkers result in
        // ungraceful error handling without CatchPanic middleware.
        // 
        // To reproduce:
        // 1. Mock the iprange library to panic in contains()
        // 2. Send a request to /fund endpoint
        // 3. Observe that the response is a connection closure,
        //    not a proper JSON error as specified in OpenAPI
        // 
        // Expected: Proper JSON error response with AptosTapError
        // Actual: Connection closure or generic HTTP error
    }
}
```

**Notes:**

This vulnerability represents a **defense-in-depth** failure. While the faucet service does not crash entirely (Tokio catches panics at task boundaries), the lack of graceful panic handling creates an inferior API experience and potential DoS vector. The fix is straightforward: add the same `CatchPanic` middleware used by the main Aptos API to ensure consistent, production-grade error handling across all Aptos services.

### Citations

**File:** crates/aptos-faucet/core/src/checkers/ip_blocklist.rs (L34-34)
```rust
                if self.manager.ipv4_list.contains(source_ip) {
```

**File:** crates/aptos-faucet/core/src/checkers/ip_blocklist.rs (L42-42)
```rust
                if self.manager.ipv6_list.contains(source_ip) {
```

**File:** crates/aptos-faucet/core/src/endpoints/fund.rs (L264-266)
```rust
            rejection_reasons.extend(checker.check(checker_data.clone(), dry_run).await.map_err(
                |e| AptosTapError::new_with_error_code(e, AptosTapErrorCode::CheckerError),
            )?);
```

**File:** crates/aptos-faucet/core/src/server/run.rs (L207-220)
```rust
        let api_server_future = Server::new_with_acceptor(TcpAcceptor::from_tokio(listener)?).run(
            Route::new()
                .nest(
                    &self.server_config.api_path_base,
                    Route::new()
                        .nest("", api_service)
                        .catch_all_error(convert_error),
                )
                .at("/spec.json", spec_json)
                .at("/spec.yaml", spec_yaml)
                .at("/mint", poem::post(mint.data(fund_api_components)))
                .with(cors)
                .around(middleware_log),
        );
```

**File:** api/src/runtime.rs (L256-256)
```rust
            .with(CatchPanic::new().with_handler(panic_handler))
```

**File:** api/src/error_converter.rs (L49-52)
```rust
pub fn panic_handler(err: Box<dyn Any + Send>) -> Response {
    error!("Panic captured: {:?}", err);
    build_panic_response("internal error".into())
}
```

**File:** crates/aptos-faucet/core/src/endpoints/error_converter.rs (L8-12)
```rust
/// In the OpenAPI spec for this API, we say that every response we return will
/// be a JSON representation of AptosTapError. For our own errors, this is exactly
/// what we do. The problem is the Poem framework does not conform to this
/// format, it can return errors in a different format. The purpose of this
/// function is to catch those errors and convert them to the correct format.
```

**File:** crates/aptos-faucet/core/Cargo.toml (L31-31)
```text
iprange = "0.6.7"
```
