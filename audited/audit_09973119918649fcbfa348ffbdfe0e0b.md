# Audit Report

## Title
Remote Executor Shard Vector Dimension Mismatch Causes Validator Node Panic

## Summary
A malicious or compromised remote executor shard can send execution results with incorrect vector dimensions (mismatched number of rounds), causing the coordinator validator node to panic during result aggregation. This leads to a denial of service attack on the validator's block execution capability.

## Finding Description

The sharded block executor architecture allows execution to be distributed across remote executor shards that communicate over the network. When a remote executor shard completes execution, it sends back results via `send_execution_result()` containing a `Result<Vec<Vec<TransactionOutput>>, VMStatus>`. [1](#0-0) 

The coordinator receives these results over the network and deserializes them without validating the vector dimensions: [2](#0-1) 

The aggregation logic assumes all shards return the same number of rounds as the first shard: [3](#0-2) 

**Attack Path 1 - Fewer Rounds Than Expected:**

When processing results, the aggregator iterates over all shards for `num_rounds` (derived from `sharded_output[0].len()`): [4](#0-3) 

If a malicious shard sends fewer rounds than expected, accessing `shard_output[round]` at line 191 will panic with an index out of bounds error.

**Attack Path 2 - More Rounds Than Expected:**

The aggregator pre-allocates a delta array based on the expected dimensions: [5](#0-4) 

When updating transaction outputs, if a shard has more rounds than expected: [6](#0-5) 

The index calculation `round * num_shards + shard_id` exceeds the allocated array size, causing a panic.

**Exploitation Scenario:**
1. Validator configures remote executor shards on separate machines
2. Attacker compromises a remote executor process (via RCE or other means)
3. Malicious shard receives `ExecuteBlock` command with N sub-blocks
4. Instead of returning N rounds, it returns N-1 or N+1 rounds
5. Coordinator's `aggregate_and_update_total_supply()` panics on dimension mismatch
6. Validator node crashes, preventing block execution

This breaks the **State Consistency** invariant as the validator cannot complete state transitions, and the **Resource Limits** invariant as there's no validation on malformed input dimensions.

## Impact Explanation

This vulnerability qualifies as **High Severity** per the Aptos Bug Bounty program:
- **Validator node crashes**: The panic terminates the block execution thread
- **API crashes**: Execution failures propagate to API endpoints
- **Liveness impact**: Affected validators cannot process blocks until restarted

While remote executor shards are typically controlled by the validator operator, the lack of authentication and validation means:
1. A compromised remote executor process becomes an attack vector
2. Network-based attacks (if no mutual TLS) could inject malformed responses
3. Even bugs in remote executor code could trigger this unintentionally

The impact is limited to individual validators (not network-wide), preventing this from being Critical severity. However, it represents a significant availability vulnerability.

## Likelihood Explanation

**Medium-High Likelihood:**
- Remote executors are used in production deployments for performance optimization
- No authentication visible in the network communication layer
- BCS deserialization accepts any well-formed `Vec<Vec<TransactionOutput>>` structure
- Zero dimension validation before array indexing
- Attack requires compromising a remote executor or network position, but does not require validator operator collusion

The vulnerability can be triggered by:
1. **Malicious actor**: Compromises remote executor host via RCE
2. **Network attacker**: MITM attack if communication lacks authentication
3. **Accidental**: Bug in remote executor implementation

## Recommendation

Add dimension validation when receiving results from remote executor shards:

```rust
fn get_output_from_shards(&self) -> Result<Vec<Vec<Vec<TransactionOutput>>>, VMStatus> {
    trace!("RemoteExecutorClient Waiting for results");
    let mut results = vec![];
    let mut expected_num_rounds: Option<usize> = None;
    
    for (shard_id, rx) in self.result_rxs.iter().enumerate() {
        let received_bytes = rx.recv().unwrap().to_bytes();
        let result: RemoteExecutionResult = bcs::from_bytes(&received_bytes).unwrap();
        let shard_output = result.inner?;
        
        // Validate dimension consistency across all shards
        let num_rounds = shard_output.len();
        match expected_num_rounds {
            None => expected_num_rounds = Some(num_rounds),
            Some(expected) => {
                if num_rounds != expected {
                    return Err(VMStatus::Error(
                        StatusCode::INTERNAL_TYPE_ERROR,
                        Some(format!(
                            "Shard {} returned {} rounds, expected {}",
                            shard_id, num_rounds, expected
                        ))
                    ));
                }
            }
        }
        
        results.push(shard_output);
    }
    Ok(results)
}
```

Additionally:
1. Implement authentication/signing for remote executor communication
2. Add bounds checking before array access in aggregator service
3. Consider adding structural validation in `RemoteExecutionResult` deserialization

## Proof of Concept

```rust
#[test]
fn test_dimension_mismatch_panic() {
    use aptos_types::transaction::TransactionOutput;
    use aptos_vm::sharded_block_executor::sharded_aggregator_service;
    
    // Simulate receiving results from 3 shards
    // Shard 0 and 1 return 2 rounds each
    // Shard 2 (malicious) returns only 1 round
    
    let valid_txn_output = TransactionOutput::new(
        WriteSet::default(),
        vec![],
        0,
        TransactionStatus::Keep(ExecutionStatus::Success),
        TransactionAuxiliaryData::default(),
    );
    
    let mut sharded_output = vec![
        // Shard 0: 2 rounds
        vec![
            vec![valid_txn_output.clone()],
            vec![valid_txn_output.clone()],
        ],
        // Shard 1: 2 rounds
        vec![
            vec![valid_txn_output.clone()],
            vec![valid_txn_output.clone()],
        ],
        // Shard 2 (malicious): only 1 round
        vec![
            vec![valid_txn_output.clone()],
        ],
    ];
    
    let mut global_output = vec![];
    let mock_state_view = MockStateView::new();
    let thread_pool = Arc::new(rayon::ThreadPoolBuilder::new().build().unwrap());
    
    // This will panic at sharded_aggregator_service.rs line 191
    // when accessing shard_output[1] for shard 2 (which only has 1 round)
    sharded_aggregator_service::aggregate_and_update_total_supply(
        &mut sharded_output,
        &mut global_output,
        &mock_state_view,
        thread_pool,
    );
    // Expected: thread panics with "index out of bounds"
}
```

## Notes

This vulnerability is distinct from the local executor implementation where all execution happens in-process and is inherently trusted. The remote executor architecture introduces a network attack surface that lacks proper input validation, enabling denial-of-service attacks against validator nodes.

### Citations

**File:** execution/executor-service/src/remote_cordinator_client.rs (L115-119)
```rust
    fn send_execution_result(&self, result: Result<Vec<Vec<TransactionOutput>>, VMStatus>) {
        let remote_execution_result = RemoteExecutionResult::new(result);
        let output_message = bcs::to_bytes(&remote_execution_result).unwrap();
        self.result_tx.send(Message::new(output_message)).unwrap();
    }
```

**File:** execution/executor-service/src/remote_executor_client.rs (L163-172)
```rust
    fn get_output_from_shards(&self) -> Result<Vec<Vec<Vec<TransactionOutput>>>, VMStatus> {
        trace!("RemoteExecutorClient Waiting for results");
        let mut results = vec![];
        for rx in self.result_rxs.iter() {
            let received_bytes = rx.recv().unwrap().to_bytes();
            let result: RemoteExecutionResult = bcs::from_bytes(&received_bytes).unwrap();
            results.push(result.inner?);
        }
        Ok(results)
    }
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/sharded_aggregator_service.rs (L174-176)
```rust
    let num_shards = sharded_output.len();
    let num_rounds = sharded_output[0].len();

```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/sharded_aggregator_service.rs (L179-179)
```rust
    let mut aggr_total_supply_delta = vec![DeltaU128::default(); num_shards * num_rounds + 1];
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/sharded_aggregator_service.rs (L184-191)
```rust
    for round in 0..num_rounds {
        sharded_output.iter().for_each(|shard_output| {
            let mut curr_delta = DeltaU128::default();
            // Though we expect all the txn_outputs to have total_supply, there can be
            // exceptions like 'block meta' (first txn in the block) and 'chkpt info' (last txn
            // in the block) which may not have total supply. Hence we iterate till we find the
            // last txn with total supply.
            for txn in shard_output[round].iter().rev() {
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/sharded_aggregator_service.rs (L222-224)
```rust
                for (round, txn_outputs) in shard_output.iter_mut().enumerate() {
                    let delta_for_round =
                        aggr_total_supply_delta_ref[round * num_shards + shard_id] + base_val_delta;
```
