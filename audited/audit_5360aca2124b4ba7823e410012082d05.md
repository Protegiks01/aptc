# Audit Report

## Title
Event Inclusion Inconsistency in TransactionsOrOutputs Requests Breaks Event-Based Application Guarantees

## Summary
The `NewTransactionsOrOutputsWithProofRequest` with `include_events=false` exhibits inconsistent behavior: transaction outputs always include events (violating the flag), while transactions correctly exclude them. This creates non-deterministic event delivery that breaks event-based applications relying on the `include_events` contract.

## Finding Description

The state sync system violates the `include_events` flag contract when serving `NewTransactionsOrOutputsWithProofRequest` requests. The storage service attempts to optimize responses by returning transaction outputs when possible, falling back to transactions only when outputs are too large.

**The Critical Inconsistency:**

The `TransactionListWithProof` structure supports optional events via `events: Option<Vec<Vec<ContractEvent>>>`, which can be `None` when `include_events=false`: [1](#0-0) 

However, `TransactionOutputListWithProof` contains `TransactionOutput` objects where events are a non-optional field: [2](#0-1) [3](#0-2) 

**The Flawed Implementation:**

When processing transactions-or-outputs requests, the storage service always fetches events for outputs regardless of the `include_events` flag: [4](#0-3) 

These events are embedded into every `TransactionOutput`: [5](#0-4) 

Meanwhile, the fallback path to transactions correctly respects the flag: [6](#0-5) 

**Production Exploitation Path:**

The continuous syncer explicitly requests data with `include_events=false`: [7](#0-6) 

This request flows through the stream engine: [8](#0-7) 

The storage handler processes it inconsistently: [9](#0-8) 

**State Consistency Violation:**

The verification logic ALWAYS validates events when outputs are received: [10](#0-9) 

This means the client receives and validates events it explicitly requested to exclude, violating the API contract and breaking event-based applications that depend on deterministic event delivery based on the `include_events` flag.

## Impact Explanation

**Severity: MEDIUM** (per Aptos Bug Bounty criteria)

This vulnerability creates **state inconsistencies requiring intervention**:

1. **Event Log Inconsistency**: Applications requesting `include_events=false` receive events non-deterministically based on internal optimization decisions (outputs vs transactions)

2. **Bandwidth Waste**: Events are transmitted over the network when explicitly not requested, wasting bandwidth especially during high-volume continuous syncing

3. **Storage Bloat**: Events may be unnecessarily stored when the application doesn't need them

4. **Application Logic Breakage**: Event-based applications that rely on the `include_events` contract will exhibit non-deterministic behavior - sometimes processing events, sometimes not, for identical requests

5. **Indexer Inconsistency**: Event indexers may inconsistently index events depending on which code path is taken

This breaks the **State Consistency** invariant: clients cannot rely on deterministic data delivery based on request parameters, leading to divergent application states across different nodes or sync attempts.

## Likelihood Explanation

**Likelihood: HIGH**

This vulnerability triggers automatically in production during normal operation:

1. **Always Active**: The continuous syncer uses `include_events=false` by default (line 165 in continuous_syncer.rs)

2. **Optimization Preference**: The storage service preferentially returns outputs (more compact than full transactions), making the buggy path the primary code path

3. **No Attacker Required**: This is not an attack - it's a design flaw that manifests during normal state synchronization

4. **Widespread Impact**: All nodes using continuous syncing with transaction-or-output mode are affected

The fallback to transactions (correct behavior) only occurs when:
- Outputs exceed size limits
- After multiple output reduction attempts fail
- Making inconsistency common but not universal

## Recommendation

**Fix the `include_events` flag handling for transaction outputs:**

Modify `get_transaction_outputs_with_proof_by_size` to accept an `include_events` parameter and conditionally fetch events:

```rust
fn get_transaction_outputs_with_proof_by_size(
    &self,
    proof_version: u64,
    start_version: u64,
    end_version: u64,
    max_response_size: u64,
    include_events: bool,  // Add this parameter
    is_transaction_or_output_request: bool,
    use_size_and_time_aware_chunking: bool,
) -> Result<TransactionDataWithProofResponse, Error> {
    // ... existing setup code ...

    let transaction_events_iterator = if include_events {
        self.storage
            .get_events_iterator(start_version, num_outputs_to_fetch)?
    } else {
        // Return empty event vectors when events not requested
        Box::new(std::iter::repeat_n(
            Ok(vec![]),
            num_outputs_to_fetch as usize,
        ))
    };
    
    // ... rest of implementation ...
}
```

Update all call sites to pass the `include_events` flag:
- Line 816 in `get_transactions_or_outputs_with_proof_by_size`
- Line 1111 in `get_transaction_outputs_with_proof`
- Line 1170 in `get_transaction_data_with_proof`

**Alternative Solution (Structural Fix):**

Redesign `TransactionOutput` to support optional events, similar to `TransactionListWithProof`:

```rust
pub struct TransactionOutput {
    write_set: WriteSet,
    events: Option<Vec<ContractEvent>>,  // Make optional
    gas_used: u64,
    status: TransactionStatus,
    auxiliary_data: TransactionAuxiliaryData,
}
```

This provides better type-level guarantees but requires more extensive changes throughout the codebase.

## Proof of Concept

**Reproduction Steps:**

1. Configure a fullnode with continuous syncing using `ApplyTransactionOutputs` mode
2. Monitor network traffic during sync with `include_events=false`
3. Observe that events are present in `TransactionOutputListWithProof` responses
4. Trigger a size-based fallback (by requesting large version ranges)
5. Observe that fallback `TransactionListWithProof` responses correctly have `events=None`

**Expected Behavior:**
- ALL responses should exclude events when `include_events=false`

**Actual Behavior:**
- Output responses include events (bug)
- Transaction responses correctly exclude events

**Test Case:**

```rust
#[tokio::test]
async fn test_include_events_false_should_exclude_events_from_outputs() {
    let (mock_client, service, storage) = setup_mock_storage_service();
    
    // Request with include_events=false
    let request = DataRequest::GetTransactionsOrOutputsWithProof(
        TransactionsOrOutputsWithProofRequest {
            proof_version: 100,
            start_version: 0,
            end_version: 10,
            include_events: false,  // Explicitly NO events
            max_num_output_reductions: 3,
        }
    );
    
    let response = send_request(mock_client, request).await.unwrap();
    
    // If outputs are returned, verify events are EMPTY
    if let DataResponse::TransactionsOrOutputsWithProof((None, Some(outputs))) = response {
        for (_, output) in &outputs.transactions_and_outputs {
            // This assertion FAILS - events are present despite include_events=false
            assert!(output.events().is_empty(), 
                "Events should be empty when include_events=false");
        }
    }
}
```

This test will fail, demonstrating the vulnerability.

---

**Notes:**

The vulnerability exists in both the new size-aware chunking implementation (line 602-604) and the legacy implementation (line 857-860 calls `get_transaction_outputs` which always includes events). Both code paths violate the `include_events` contract when returning outputs.

### Citations

**File:** types/src/transaction/mod.rs (L1765-1783)
```rust
/// The output of executing a transaction.
#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize)]
pub struct TransactionOutput {
    /// The list of writes this transaction intends to do.
    write_set: WriteSet,

    /// The list of events emitted during this transaction.
    events: Vec<ContractEvent>,

    /// The amount of gas used during execution.
    gas_used: u64,

    /// The execution status. The detailed error info will not be stored here instead will be stored in the auxiliary data.
    status: TransactionStatus,

    /// The transaction auxiliary data that includes detail error info that is not used for calculating the hash
    #[serde(skip)]
    auxiliary_data: TransactionAuxiliaryData,
}
```

**File:** types/src/transaction/mod.rs (L2245-2250)
```rust
pub struct TransactionListWithProof {
    pub transactions: Vec<Transaction>,
    pub events: Option<Vec<Vec<ContractEvent>>>,
    pub first_transaction_version: Option<Version>,
    pub proof: TransactionInfoListWithProof,
}
```

**File:** types/src/transaction/mod.rs (L2508-2512)
```rust
pub struct TransactionOutputListWithProof {
    pub transactions_and_outputs: Vec<(Transaction, TransactionOutput)>,
    pub first_transaction_output_version: Option<Version>,
    pub proof: TransactionInfoListWithProof,
}
```

**File:** types/src/transaction/mod.rs (L2573-2576)
```rust
        self.transactions_and_outputs.par_iter().zip_eq(self.proof.transaction_infos.par_iter())
        .map(|((txn, txn_output), txn_info)| {
            // Check the events against the expected events root hash
            verify_events_against_root_hash(&txn_output.events, txn_info)?;
```

**File:** state-sync/storage-service/server/src/storage.rs (L602-604)
```rust
        let transaction_events_iterator = self
            .storage
            .get_events_iterator(start_version, num_outputs_to_fetch)?;
```

**File:** state-sync/storage-service/server/src/storage.rs (L640-646)
```rust
                    let output = TransactionOutput::new(
                        write_set,
                        events,
                        info.gas_used(),
                        info.status().clone().into(),
                        TransactionAuxiliaryData::None, // Auxiliary data is no longer supported
                    );
```

**File:** state-sync/storage-service/server/src/storage.rs (L832-840)
```rust
        // Otherwise, return as many transactions as possible
        self.get_transactions_with_proof_by_size(
            proof_version,
            start_version,
            end_version,
            include_events,
            max_response_size,
            use_size_and_time_aware_chunking,
        )
```

**File:** state-sync/state-sync-driver/src/continuous_syncer.rs (L161-168)
```rust
                    self.streaming_client
                        .continuously_stream_transactions_or_outputs(
                            highest_synced_version,
                            highest_synced_epoch,
                            false,
                            sync_request_target,
                        )
                        .await?
```

**File:** state-sync/data-streaming-service/src/stream_engine.rs (L702-708)
```rust
            StreamRequest::ContinuouslyStreamTransactionsOrOutputs(request) => {
                NewTransactionsOrOutputsWithProof(NewTransactionsOrOutputsWithProofRequest {
                    known_version,
                    known_epoch,
                    include_events: request.include_events,
                })
            },
```

**File:** state-sync/storage-service/server/src/handler.rs (L423-425)
```rust
            DataRequest::GetTransactionsOrOutputsWithProof(request) => {
                self.get_transactions_or_outputs_with_proof(request)
            },
```
