# Audit Report

## Title
Missing Quorum Signature Verification in Ledger Info Restore Allows Consensus State Corruption

## Summary
The `save_ledger_infos()` function in the restore handler persists ledger infos to the database without validating quorum signatures, allowing an attacker to inject ledger infos with insufficient or invalid validator signatures during backup restoration. This violates the core consensus invariant that all committed ledger infos must contain valid quorum certificates (2f+1 signatures).

## Finding Description

The vulnerability exists across multiple layers of the restore process:

**Layer 1 - Direct Persistence Without Validation:**

The `RestoreHandler::save_ledger_infos()` function directly delegates to `restore_utils::save_ledger_infos()` without any signature verification: [1](#0-0) 

The underlying implementation in `restore_utils::save_ledger_infos()` only checks that the list is not empty before persisting: [2](#0-1) 

The actual persistence in `save_ledger_infos_impl()` iterates through ledger infos and writes them to the database with zero cryptographic validation: [3](#0-2) 

**Layer 2 - Insufficient Validation in Epoch Ending Restore:**

While the epoch ending restore process performs some validation in `preheat_impl()`, it has critical gaps:

For ledger infos with trusted waypoints, only the waypoint is verified (not signatures): [4](#0-3) 

A waypoint is a hash of ledger info **content** (epoch, root_hash, version, timestamp, next_epoch_state) but explicitly **excludes signatures**: [5](#0-4) 

For ledger infos without trusted waypoints, signatures are only verified if a previous ledger info exists: [6](#0-5) 

In `run_impl()`, the first ledger info is only verified if a previous epoch ending ledger info is provided: [7](#0-6) 

**Layer 3 - Consensus Trusts Database Without Re-Verification:**

When consensus starts, it reads the latest ledger info from the database and trusts it implicitly without signature verification: [8](#0-7) 

This unverified ledger info is used to construct the consensus recovery data and initialize the entire consensus state machine.

**Attack Scenarios:**

1. **Malicious Backup with Trusted Waypoints**: An attacker obtains valid ledger info content (matching public waypoints), replaces signatures with invalid/empty ones, and provides this as a backup. The waypoint check passes, but no signature verification occurs.

2. **First Ledger Info Bypass**: When restoring the first ledger info without a previous epoch ending ledger info (fresh node bootstrap), signature verification is completely skipped in both preheat and run phases.

3. **Epoch Boundary Attack**: An attacker provides epoch-ending ledger infos with correct content but signatures from fewer than 2f+1 validators, violating Byzantine fault tolerance guarantees.

## Impact Explanation

**Severity: CRITICAL** (Consensus Safety Violation)

This vulnerability enables multiple critical attack vectors:

1. **Consensus Safety Violation**: The fundamental AptosBFT invariant requires all committed ledger infos to have signatures from at least 2f+1 validators (quorum). By persisting ledger infos without signature verification, an attacker can bypass this requirement entirely.

2. **Chain Fork Potential**: Nodes restored from malicious backups will have different consensus state than honest nodes, potentially causing chain forks when they attempt to participate in consensus.

3. **Epoch Transition Corruption**: If the invalid ledger info is epoch-ending, it contains the validator set for the next epoch. Accepting it without verification could allow an attacker to define a fraudulent validator set.

4. **Trust Boundary Violation**: The storage layer accepts cryptographically unverified consensus-critical data, violating defense-in-depth principles.

Per the Aptos bug bounty program, this qualifies as **Critical Severity** under "Consensus/Safety violations" as it directly undermines the consensus protocol's security guarantees and could lead to network partitions requiring a hardfork to resolve.

## Likelihood Explanation

**Likelihood: MEDIUM-HIGH**

The attack is realistic with the following requirements:

1. **Attacker Capability**: Attacker must be able to provide malicious backup files to victims. This is achievable by:
   - Compromising a backup storage service
   - Social engineering node operators to use attacker-controlled backups
   - MITM attacks on backup downloads (if not properly secured)
   - Insider threats from backup administrators

2. **Victim Action**: Victim must restore their node from the malicious backup. This is a common operational scenario during:
   - New validator node deployment
   - Disaster recovery after data loss
   - Network expansion with new validators
   - Migration to new infrastructure

3. **No Special Privileges Required**: The attack requires no validator private keys, consensus participation, or Byzantine collusionâ€”only the ability to influence the backup source.

The vulnerability is particularly dangerous because:
- Backup restoration is a trusted operation where operators may not expect adversarial input
- The validation gap is not obvious and appears to rely on implicit trust in backup integrity
- Trusted waypoints (often public) make the attack easier by providing a validation bypass path

## Recommendation

Implement mandatory signature verification in `save_ledger_infos()` before persisting to the database. The fix should:

1. **Add signature verification to restore_utils::save_ledger_infos()**:
   - Obtain the appropriate `ValidatorVerifier` for each ledger info's epoch
   - Call `ledger_info.verify_signatures(&validator_verifier)` for each ledger info
   - Reject and fail the restore operation if any signature verification fails

2. **Verify even with trusted waypoints**: Waypoint matching proves content correctness, but signature verification must still occur to ensure quorum consensus.

3. **Handle genesis/first ledger info**: For epoch 0 or genesis ledger infos, ensure appropriate handling (genesis ledger infos are unsigned but should be explicitly validated as such).

**Recommended Code Fix** (conceptual):

```rust
// In restore_utils.rs, modify save_ledger_infos_impl to:
fn save_ledger_infos_impl(
    ledger_metadata_db: &LedgerMetadataDb,
    ledger_infos: &[LedgerInfoWithSignatures],
    batch: &mut SchemaBatch,
    epoch_to_verifier: &HashMap<u64, Arc<ValidatorVerifier>>, // NEW parameter
) -> Result<()> {
    for li in ledger_infos {
        // Verify signatures unless it's genesis
        if li.ledger_info().epoch() > 0 {
            let verifier = epoch_to_verifier.get(&li.ledger_info().epoch())
                .ok_or_else(|| anyhow!("No validator verifier for epoch {}", li.ledger_info().epoch()))?;
            li.verify_signatures(verifier)
                .map_err(|e| anyhow!("Invalid signatures in ledger info: {}", e))?;
        }
        ledger_metadata_db.put_ledger_info(li, batch)?;
    }
    Ok(())
}
```

The validator verifier can be obtained from the previous epoch's epoch state or from trusted sources.

## Proof of Concept

```rust
#[cfg(test)]
mod test {
    use super::*;
    use aptos_crypto::{bls12381, HashValue};
    use aptos_types::{
        aggregate_signature::AggregateSignature,
        block_info::BlockInfo,
        ledger_info::{LedgerInfo, LedgerInfoWithSignatures},
        validator_verifier::ValidatorVerifier,
    };

    #[test]
    fn test_save_ledger_infos_accepts_invalid_signatures() {
        // Create a test database
        let tmpdir = aptos_temppath::TempPath::new();
        let db = AptosDB::new_for_test(&tmpdir);
        let restore_handler = db.get_restore_handler();
        
        // Create a ledger info with EMPTY/INVALID signatures
        let ledger_info = LedgerInfo::new(
            BlockInfo::new(
                1, // epoch
                0, // round
                HashValue::random(),
                HashValue::random(),
                100, // version
                1000000, // timestamp
                None, // no next epoch state
            ),
            HashValue::zero(),
        );
        
        // Create with EMPTY signatures (invalid)
        let invalid_ledger_info_with_sigs = LedgerInfoWithSignatures::new(
            ledger_info,
            AggregateSignature::empty(), // NO SIGNATURES!
        );
        
        // This should FAIL but currently SUCCEEDS
        let result = restore_handler.save_ledger_infos(&[invalid_ledger_info_with_sigs.clone()]);
        
        // VULNERABILITY: The invalid ledger info was saved without signature verification
        assert!(result.is_ok(), "Invalid ledger info was accepted!");
        
        // Verify it's in the database
        let retrieved = db.get_latest_ledger_info().unwrap();
        assert_eq!(retrieved.ledger_info().version(), 100);
        
        // Demonstrate that signatures are invalid (would fail if verified)
        let dummy_verifier = ValidatorVerifier::new(vec![]);
        assert!(retrieved.verify_signatures(&dummy_verifier).is_err(),
                "Signatures should be invalid but were saved anyway");
    }
    
    #[test]
    fn test_consensus_reads_unverified_ledger_info() {
        // Setup database with invalid ledger info (as shown above)
        let tmpdir = aptos_temppath::TempPath::new();
        let db = AptosDB::new_for_test(&tmpdir);
        let restore_handler = db.get_restore_handler();
        
        // Save invalid ledger info
        let invalid_li = create_invalid_ledger_info(); // helper function
        restore_handler.save_ledger_infos(&[invalid_li]).unwrap();
        
        // Simulate consensus startup
        let storage_proxy = StorageWriteProxy::new(&config, Arc::new(db));
        let ledger_recovery = storage_proxy.recover_from_ledger();
        
        // VULNERABILITY: Consensus received invalid ledger info without verification
        // This would corrupt consensus state when used for recovery
        assert_eq!(ledger_recovery.storage_ledger.get_num_voters(), 0,
                   "Consensus initialized with zero signatures!");
    }
}
```

**Notes:**
- The vulnerability violates the invariant that "all committed ledger infos must have valid quorum signatures (2f+1 validators)"
- Signature verification exists in the codebase (`LedgerInfoWithSignatures::verify_signatures`) but is never called during restore
- The consensus layer implicitly trusts all data from storage, creating a critical trust boundary issue
- This is distinct from intentional design for genesis blocks, which are legitimately unsigned but should be explicitly validated as genesis

### Citations

**File:** storage/aptosdb/src/backup/restore_handler.rs (L61-63)
```rust
    pub fn save_ledger_infos(&self, ledger_infos: &[LedgerInfoWithSignatures]) -> Result<()> {
        restore_utils::save_ledger_infos(self.aptosdb.ledger_db.metadata_db(), ledger_infos, None)
    }
```

**File:** storage/aptosdb/src/backup/restore_utils.rs (L41-58)
```rust
pub(crate) fn save_ledger_infos(
    ledger_metadata_db: &LedgerMetadataDb,
    ledger_infos: &[LedgerInfoWithSignatures],
    existing_batch: Option<&mut SchemaBatch>,
) -> Result<()> {
    ensure!(!ledger_infos.is_empty(), "No LedgerInfos to save.");

    if let Some(existing_batch) = existing_batch {
        save_ledger_infos_impl(ledger_metadata_db, ledger_infos, existing_batch)?;
    } else {
        let mut batch = SchemaBatch::new();
        save_ledger_infos_impl(ledger_metadata_db, ledger_infos, &mut batch)?;
        ledger_metadata_db.write_schemas(batch)?;
        update_latest_ledger_info(ledger_metadata_db, ledger_infos)?;
    }

    Ok(())
}
```

**File:** storage/aptosdb/src/backup/restore_utils.rs (L179-190)
```rust
fn save_ledger_infos_impl(
    ledger_metadata_db: &LedgerMetadataDb,
    ledger_infos: &[LedgerInfoWithSignatures],
    batch: &mut SchemaBatch,
) -> Result<()> {
    ledger_infos
        .iter()
        .map(|li| ledger_metadata_db.put_ledger_info(li, batch))
        .collect::<Result<Vec<_>>>()?;

    Ok(())
}
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L129-135)
```rust
                if let Some(wp_trusted) = self.trusted_waypoints.get(&wp_li.version()) {
                    ensure!(
                        *wp_trusted == wp_li,
                        "Waypoints don't match. In backup: {}, trusted: {}",
                        wp_li,
                        wp_trusted,
                    );
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L136-146)
```rust
                } else if let Some(pre_li) = previous_li {
                    pre_li
                        .ledger_info()
                        .next_epoch_state()
                        .ok_or_else(|| {
                            anyhow!(
                                "Next epoch state not found from LI at epoch {}.",
                                pre_li.ledger_info().epoch()
                            )
                        })?
                        .verify(&li)?;
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L228-238)
```rust
            if self
                .controller
                .trusted_waypoints
                .get(&first_li.ledger_info().version())
                .is_none()
            {
                li.next_epoch_state()
                    .ok_or_else(|| {
                        anyhow!("Previous epoch ending LedgerInfo doesn't end an epoch")
                    })?
                    .verify(first_li)?;
```

**File:** types/src/waypoint.rs (L129-148)
```rust
#[derive(Deserialize, Serialize, CryptoHasher, BCSCryptoHash)]
struct Ledger2WaypointConverter {
    epoch: u64,
    root_hash: HashValue,
    version: Version,
    timestamp_usecs: u64,
    next_epoch_state: Option<EpochState>,
}

impl Ledger2WaypointConverter {
    pub fn new(ledger_info: &LedgerInfo) -> Self {
        Self {
            epoch: ledger_info.epoch(),
            root_hash: ledger_info.transaction_accumulator_hash(),
            version: ledger_info.version(),
            timestamp_usecs: ledger_info.timestamp_usecs(),
            next_epoch_state: ledger_info.next_epoch_state().cloned(),
        }
    }
}
```

**File:** consensus/src/persistent_liveness_storage.rs (L511-517)
```rust
    fn recover_from_ledger(&self) -> LedgerRecoveryData {
        let latest_ledger_info = self
            .aptos_db
            .get_latest_ledger_info()
            .expect("Failed to get latest ledger info.");
        LedgerRecoveryData::new(latest_ledger_info)
    }
```
