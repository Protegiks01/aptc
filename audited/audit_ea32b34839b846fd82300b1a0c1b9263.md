# Audit Report

## Title
Insufficient Entropy in PeerId Metric Labels Enabling Collision-Based Metric Aggregation

## Summary
The `connections()` function and related network metrics use `peer_id.short_str()` as a Prometheus label, which truncates the 32-byte PeerId to only 4 bytes (32 bits) of entropy. This enables attackers to generate colliding PeerIds that aggregate metrics across different peers, compromising network observability and potentially masking malicious behavior. [1](#0-0) 

## Finding Description

The vulnerability chain consists of three components:

**1. PeerId Structure and Generation**

PeerId is a type alias for AccountAddress (32 bytes): [2](#0-1) 

PeerIds are derived from x25519 network identity keys: [3](#0-2) 

**2. Short String Truncation**

The `AsShortHexStr` trait implementation only uses the first 4 bytes: [4](#0-3) 

AccountAddress (32 bytes) dereferences to `[u8; 32]`, which implements `AsShortHexStr`: [5](#0-4) 

**3. Widespread Metric Label Usage**

The truncated short string is used as a Prometheus label across all network metrics:
- Connection counts: [1](#0-0) 
- Peer connectivity: [6](#0-5) 
- RPC metrics: [7](#0-6) 
- Network traffic: [8](#0-7) 

**Attack Scenario:**

1. Attacker identifies target validator PeerId (e.g., from public validator set)
2. Attacker generates x25519 key pairs until finding one where `from_identity_public_key(pubkey).short_str()` matches target's first 4 bytes
3. Expected iterations: ~2^32 ≈ 4 billion attempts (feasible with modern hardware in hours/days)
4. Attacker connects to network with colliding PeerId
5. Network accepts connection (authentication validates correct derivation, not uniqueness)
6. Prometheus metrics aggregate attacker's and target's network activity under same label
7. Monitoring systems cannot distinguish between the two peers

## Impact Explanation

This meets **Medium severity** criteria as it creates operational security risks:

1. **Incident Response Degradation**: During security incidents, operators cannot accurately identify which peer is exhibiting malicious behavior when metrics aggregate multiple peers

2. **Attack Obfuscation**: Malicious peers can hide their activity by colliding with legitimate validator metrics, making detection of DoS attacks, resource exhaustion, or protocol violations significantly harder

3. **False Positive/Negative Alerts**: Alerting systems based on per-peer metrics will trigger incorrectly when malicious activity from colliding peer is attributed to legitimate validators

4. **Birthday Paradox**: With validator sets approaching tens of thousands of peers (or including full nodes), natural collisions become statistically likely, degrading monitoring quality even without attacks

While this doesn't directly compromise consensus or funds, it undermines the security monitoring infrastructure that protects against such attacks, meeting the "state inconsistencies requiring intervention" criterion for Medium severity.

## Likelihood Explanation

**High Likelihood** due to:

1. **Computational Feasibility**: Finding a single collision requires ~2^32 hash computations (~4 billion), achievable in hours on commodity hardware
2. **No Protocol Restrictions**: Network accepts any valid peer that correctly derives PeerId from their x25519 key
3. **Multiple Attack Vectors**: 
   - Targeted collision against specific validator
   - Opportunistic collisions against random peers
   - Natural birthday paradox collisions in large networks
4. **Permanent Impact**: Once connected, metrics remain aggregated for duration of connection

## Recommendation

Replace `short_str()` with a longer representation that maintains sufficient entropy:

**Option 1: Use First 16 Bytes (128 bits)**
```rust
// In crates/short-hex-str/src/lib.rs
impl ShortHexStr {
    pub const SOURCE_LENGTH: usize = 16; // Changed from 4
    pub const LENGTH: usize = 32; // 16 bytes * 2 hex chars
}
```

This provides 128 bits of entropy, making collisions astronomically unlikely (2^64 operations for 50% collision probability).

**Option 2: Use Full PeerId String**
```rust
// In network/framework/src/counters.rs
pub fn connections(network_context: &NetworkContext, origin: ConnectionOrigin) -> IntGauge {
    APTOS_CONNECTIONS.with_label_values(&[
        network_context.role().as_str(),
        network_context.network_id().as_str(),
        &network_context.peer_id().to_hex(), // Use full hex instead of short_str()
        origin.as_str(),
    ])
}
```

While this increases label cardinality in Prometheus, modern monitoring systems handle this well, and the security/observability benefits outweigh storage concerns.

## Proof of Concept

```rust
use aptos_crypto::x25519;
use aptos_types::account_address::from_identity_public_key;
use aptos_short_hex_str::AsShortHexStr;

fn main() {
    // Target PeerId to collide with (e.g., a validator)
    let target_keypair = x25519::PrivateKey::generate_for_testing();
    let target_peer_id = from_identity_public_key(target_keypair.public_key());
    let target_short = target_peer_id.short_str();
    
    println!("Target PeerId: {:?}", target_peer_id);
    println!("Target short_str: {}", target_short.as_str());
    
    // Attacker searches for collision
    let mut attempts = 0u64;
    loop {
        attempts += 1;
        let attacker_keypair = x25519::PrivateKey::generate_for_testing();
        let attacker_peer_id = from_identity_public_key(attacker_keypair.public_key());
        let attacker_short = attacker_peer_id.short_str();
        
        if attacker_short.as_str() == target_short.as_str() 
            && attacker_peer_id != target_peer_id {
            println!("\n✓ COLLISION FOUND after {} attempts!", attempts);
            println!("Attacker PeerId: {:?}", attacker_peer_id);
            println!("Attacker short_str: {}", attacker_short.as_str());
            println!("\nBoth PeerIds have same short_str but are different peers!");
            println!("Metrics will aggregate them together in Prometheus.");
            break;
        }
        
        if attempts % 1_000_000 == 0 {
            println!("Attempted {} collisions...", attempts);
        }
    }
}
```

**Expected Runtime**: Hours to days on modern CPU to find a collision with a specific 4-byte target.

## Notes

This vulnerability affects all network-level metrics that use `short_str()` for peer identification. The core protocol security remains intact as actual peer authentication and message handling use the full 32-byte PeerId. However, the degradation of monitoring capabilities represents a genuine security concern for network operators and incident responders.

### Citations

**File:** network/framework/src/counters.rs (L56-63)
```rust
pub fn connections(network_context: &NetworkContext, origin: ConnectionOrigin) -> IntGauge {
    APTOS_CONNECTIONS.with_label_values(&[
        network_context.role().as_str(),
        network_context.network_id().as_str(),
        network_context.peer_id().short_str().as_str(),
        origin.as_str(),
    ])
}
```

**File:** network/framework/src/counters.rs (L95-106)
```rust
pub fn peer_connected(network_context: &NetworkContext, remote_peer_id: &PeerId, v: i64) {
    if network_context.network_id().is_validator_network() {
        APTOS_NETWORK_PEER_CONNECTED
            .with_label_values(&[
                network_context.role().as_str(),
                network_context.network_id().as_str(),
                network_context.peer_id().short_str().as_str(),
                remote_peer_id.short_str().as_str(),
            ])
            .set(v)
    }
}
```

**File:** network/framework/src/counters.rs (L211-225)
```rust
pub fn rpc_messages(
    network_context: &NetworkContext,
    message_type_label: &'static str,
    message_direction_label: &'static str,
    state_label: &'static str,
) -> IntCounter {
    APTOS_NETWORK_RPC_MESSAGES.with_label_values(&[
        network_context.role().as_str(),
        network_context.network_id().as_str(),
        network_context.peer_id().short_str().as_str(),
        message_type_label,
        message_direction_label,
        state_label,
    ])
}
```

**File:** network/framework/src/counters.rs (L567-581)
```rust
pub fn network_application_inbound_traffic(
    network_context: NetworkContext,
    protocol_id: ProtocolId,
    size: u64,
) {
    NETWORK_APPLICATION_INBOUND_METRIC
        .with_label_values(&[
            network_context.role().as_str(),
            network_context.network_id().as_str(),
            network_context.peer_id().short_str().as_str(),
            protocol_id.as_str(),
            "size",
        ])
        .observe(size as f64);
}
```

**File:** types/src/lib.rs (L61-61)
```rust
pub use account_address::AccountAddress as PeerId;
```

**File:** types/src/account_address.rs (L140-146)
```rust
pub fn from_identity_public_key(identity_public_key: x25519::PublicKey) -> AccountAddress {
    let mut array = [0u8; AccountAddress::LENGTH];
    let pubkey_slice = identity_public_key.as_slice();
    // keep only the last 16 bytes
    array.copy_from_slice(&pubkey_slice[x25519::PUBLIC_KEY_SIZE - AccountAddress::LENGTH..]);
    AccountAddress::new(array)
}
```

**File:** crates/short-hex-str/src/lib.rs (L22-43)
```rust
impl ShortHexStr {
    pub const LENGTH: usize = 2 * ShortHexStr::SOURCE_LENGTH;
    pub const SOURCE_LENGTH: usize = 4;

    /// Format a new `ShortHexStr` from a byte slice.
    ///
    /// Returns `Err(InputTooShortError)` if the input byte slice length is less
    /// than `SOURCE_LENGTH` bytes.
    pub fn try_from_bytes(src_bytes: &[u8]) -> Result<ShortHexStr, InputTooShortError> {
        if src_bytes.len() >= ShortHexStr::SOURCE_LENGTH {
            let src_short_bytes = &src_bytes[0..ShortHexStr::SOURCE_LENGTH];
            let mut dest_bytes = [0u8; ShortHexStr::LENGTH];

            // We include a tiny hex encode here instead of using the `hex` crate's
            // `encode_to_slice`, since the compiler seems unable to inline across
            // the crate boundary.
            hex_encode(src_short_bytes, &mut dest_bytes);
            Ok(Self(dest_bytes))
        } else {
            Err(InputTooShortError)
        }
    }
```

**File:** crates/short-hex-str/src/lib.rs (L117-123)
```rust
impl AsShortHexStr for [u8; 32] {
    fn short_str(&self) -> ShortHexStr {
        const_assert!(32 >= ShortHexStr::SOURCE_LENGTH);
        ShortHexStr::try_from_bytes(self)
            .expect("This can never fail since 32 >= ShortHexStr::SOURCE_LENGTH")
    }
}
```
