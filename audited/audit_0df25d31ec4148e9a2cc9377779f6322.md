# Audit Report

## Title
Genesis Validator Limit Bypass Allows Memory Exhaustion Attack

## Summary
The genesis creation process in `GenesisInfo::new()` does not validate the number of validators before BCS serialization, allowing an attacker to specify millions of validators and cause memory exhaustion. While the Move framework enforces a `MAX_VALIDATOR_SET_SIZE` limit of 65,536, this check occurs too late—after expensive memory allocations and account creations have already been performed.

## Finding Description
The vulnerability exists in the genesis creation pipeline across multiple layers:

**Layer 1: No Pre-Serialization Validation** [1](#0-0) 

The `GenesisInfo::new()` function accepts an unbounded `Vec<ValidatorConfiguration>` and converts each to a `Validator` without checking the vector length against `MAX_VALIDATOR_SET_SIZE`.

**Layer 2: Unbounded BCS Serialization** [2](#0-1) 

The `create_and_initialize_validators()` function serializes the entire validator vector using `bcs::to_bytes(validators)` without size validation. For millions of validators (each ~450 bytes), this allocates gigabytes of memory.

**Layer 3: Unmetered Genesis Execution** [3](#0-2) 

Genesis functions execute with `UnmeteredGasMeter`, bypassing all gas limits during account creation and coin minting operations.

**Layer 4: Late Validation Check** [4](#0-3) 

The `MAX_VALIDATOR_SET_SIZE` limit (65,536) is only enforced when validators call `join_validator_set_internal()`. By this point, the system has already:
- Serialized millions of validators
- Deserialized them in the Move VM
- Created 3 accounts per validator (owner, operator, voter)
- Minted stake amounts for each validator

**Attack Vector:**
1. Attacker creates a genesis configuration with 10 million validators
2. Each `Validator` struct (~450 bytes) × 10M = ~4.5 GB memory
3. BCS serialization allocates 4.5 GB in Rust
4. Move VM deserializes the full vector
5. For validators 1-65,536: accounts created, coins minted successfully
6. At validator 65,537: `EVALIDATOR_SET_TOO_LARGE` error, but damage done

The bitvec implementation constraint is documented but not enforced early: [5](#0-4) 

The CLI validation function checks many properties but NOT validator count: [6](#0-5) 

## Impact Explanation
**Severity: Medium** - This meets the "State inconsistencies requiring intervention" criterion:

- **Memory Exhaustion**: Genesis creation with millions of validators causes multi-gigabyte memory allocations, potentially crashing genesis bootstrapping nodes
- **Resource Exhaustion**: Even if memory is sufficient, creating millions of accounts is computationally expensive and time-consuming
- **Network Bootstrap Failure**: A malicious genesis configuration prevents legitimate network initialization, requiring manual intervention and configuration fixes
- **Not Critical** because it only affects genesis creation (one-time operation), not running network operations

The attack requires creating a malicious genesis configuration, which is typically controlled during network setup, but could affect testnets, devnets, or forks where genesis configurations are accepted from external sources.

## Likelihood Explanation
**Likelihood: Low to Medium**

**Factors Increasing Likelihood:**
- Simple to exploit: just provide a large validator array
- No privileged access required for genesis configuration creation
- Genesis configurations may accept external input in some deployment scenarios

**Factors Decreasing Likelihood:**
- Genesis creation is typically a controlled operation
- Production networks validate genesis configurations through governance
- The attack is immediately detectable (process crashes or hangs)

However, for testnets, development environments, or community-run forks, this vulnerability could be exploited if genesis configurations are accepted without thorough validation.

## Recommendation
Add validator count validation before BCS serialization. In `crates/aptos-genesis/src/lib.rs`, modify the `new()` function:

```rust
pub fn new(
    chain_id: ChainId,
    root_key: Ed25519PublicKey,
    configs: Vec<ValidatorConfiguration>,
    framework: ReleaseBundle,
    genesis_config: &GenesisConfiguration,
) -> anyhow::Result<GenesisInfo> {
    // Add validation BEFORE processing
    const MAX_VALIDATOR_SET_SIZE: usize = 65536;
    anyhow::ensure!(
        configs.len() <= MAX_VALIDATOR_SET_SIZE,
        "Genesis validator count {} exceeds maximum {}", 
        configs.len(), 
        MAX_VALIDATOR_SET_SIZE
    );
    
    let mut validators = Vec::new();
    for config in configs {
        validators.push(config.try_into()?)
    }
    // ... rest of function
}
```

Additionally, add validation in `crates/aptos/src/genesis/mod.rs` in the `validate_validators()` function:

```rust
fn validate_validators(
    layout: &Layout,
    validators: &[ValidatorConfiguration],
    // ... other parameters
) -> CliTypedResult<()> {
    // Add at the beginning of the function
    const MAX_VALIDATOR_SET_SIZE: usize = 65536;
    if validators.len() > MAX_VALIDATOR_SET_SIZE {
        return Err(CliError::UnexpectedError(format!(
            "Validator count {} exceeds maximum allowed {}",
            validators.len(),
            MAX_VALIDATOR_SET_SIZE
        )));
    }
    
    let mut errors = vec![];
    // ... rest of validation
}
```

## Proof of Concept

```rust
// File: test_genesis_validator_limit.rs
use aptos_genesis::{GenesisInfo, builder::GenesisConfiguration, config::ValidatorConfiguration};
use aptos_framework::ReleaseBundle;
use aptos_crypto::ed25519::Ed25519PublicKey;
use aptos_types::chain_id::ChainId;

#[test]
#[should_panic(expected = "memory")]
fn test_genesis_memory_exhaustion() {
    // Create a realistic genesis configuration
    let chain_id = ChainId::test();
    let root_key = Ed25519PublicKey::try_from(&[0u8; 32][..]).unwrap();
    let framework = ReleaseBundle::default();
    let genesis_config = GenesisConfiguration::default();
    
    // Create 1 million validators (would cause ~450 MB allocation)
    let mut configs = Vec::new();
    for i in 0..1_000_000 {
        let config = ValidatorConfiguration {
            owner_account_address: format!("0x{:x}", i).parse().unwrap(),
            operator_account_address: format!("0x{:x}", i).parse().unwrap(),
            voter_account_address: format!("0x{:x}", i).parse().unwrap(),
            stake_amount: 1_000_000,
            consensus_public_key: Some(vec![0u8; 48]),
            proof_of_possession: Some(vec![0u8; 96]),
            validator_network_addresses: vec![],
            full_node_network_addresses: vec![],
            // ... other required fields
        };
        configs.push(config);
    }
    
    // This should fail validation but currently doesn't
    // It will attempt to allocate massive memory during BCS serialization
    let genesis_info = GenesisInfo::new(
        chain_id,
        root_key,
        configs,
        framework,
        &genesis_config,
    ).expect("Should fail but doesn't");
    
    // If we reach here, attempt to generate the genesis transaction
    // This will exhaust memory during serialization
    let _genesis = genesis_info.get_genesis();
}
```

The test demonstrates that providing 1 million validators succeeds in `GenesisInfo::new()` but would fail during BCS serialization with memory exhaustion, well before reaching the Move framework's `MAX_VALIDATOR_SET_SIZE` check.

## Notes
This vulnerability specifically affects the genesis creation pathway and would not impact a running network. However, it represents a violation of the "Resource Limits" invariant that states all operations must respect computational limits. The fix is straightforward: validate validator count before expensive operations.

### Citations

**File:** crates/aptos-genesis/src/lib.rs (L86-125)
```rust
    pub fn new(
        chain_id: ChainId,
        root_key: Ed25519PublicKey,
        configs: Vec<ValidatorConfiguration>,
        framework: ReleaseBundle,
        genesis_config: &GenesisConfiguration,
    ) -> anyhow::Result<GenesisInfo> {
        let mut validators = Vec::new();

        for config in configs {
            validators.push(config.try_into()?)
        }

        Ok(GenesisInfo {
            chain_id,
            root_key,
            validators,
            framework,
            genesis: None,
            allow_new_validators: genesis_config.allow_new_validators,
            epoch_duration_secs: genesis_config.epoch_duration_secs,
            is_test: genesis_config.is_test,
            min_stake: genesis_config.min_stake,
            min_voting_threshold: genesis_config.min_voting_threshold,
            max_stake: genesis_config.max_stake,
            recurring_lockup_duration_secs: genesis_config.recurring_lockup_duration_secs,
            required_proposer_stake: genesis_config.required_proposer_stake,
            rewards_apy_percentage: genesis_config.rewards_apy_percentage,
            voting_duration_secs: genesis_config.voting_duration_secs,
            voting_power_increase_limit: genesis_config.voting_power_increase_limit,
            consensus_config: genesis_config.consensus_config.clone(),
            execution_config: genesis_config.execution_config.clone(),
            gas_schedule: genesis_config.gas_schedule.clone(),
            initial_features_override: genesis_config.initial_features_override.clone(),
            randomness_config_override: genesis_config.randomness_config_override.clone(),
            jwk_consensus_config_override: genesis_config.jwk_consensus_config_override.clone(),
            initial_jwks: genesis_config.initial_jwks.clone(),
            keyless_groth16_vk: genesis_config.keyless_groth16_vk.clone(),
        })
    }
```

**File:** aptos-move/vm-genesis/src/lib.rs (L441-471)
```rust
fn exec_function_internal(
    session: &mut SessionExt<impl AptosMoveResolver>,
    module_storage: &impl ModuleStorage,
    traversal_context: &mut TraversalContext,
    module_name: &str,
    function_name: &str,
    ty_args: Vec<TypeTag>,
    args: Vec<Vec<u8>>,
    address: AccountAddress,
) {
    session
        .execute_function_bypass_visibility(
            &ModuleId::new(address, Identifier::new(module_name).unwrap()),
            &Identifier::new(function_name).unwrap(),
            ty_args,
            args,
            &mut UnmeteredGasMeter,
            traversal_context,
            module_storage,
        )
        .unwrap_or_else(|e| {
            panic!(
                "Error calling {}.{}.{}: ({:#x}) {}",
                address,
                module_name,
                function_name,
                e.sub_status().unwrap_or_default(),
                e,
            )
        });
}
```

**File:** aptos-move/vm-genesis/src/lib.rs (L1045-1063)
```rust
fn create_and_initialize_validators(
    session: &mut SessionExt<impl AptosMoveResolver>,
    module_storage: &impl AptosModuleStorage,
    traversal_context: &mut TraversalContext,
    validators: &[Validator],
) {
    let validators_bytes = bcs::to_bytes(validators).expect("Validators can be serialized");
    let mut serialized_values = serialize_values(&vec![MoveValue::Signer(CORE_CODE_ADDRESS)]);
    serialized_values.push(validators_bytes);
    exec_function(
        session,
        module_storage,
        traversal_context,
        GENESIS_MODULE_NAME,
        "create_initialize_validators",
        vec![],
        serialized_values,
    );
}
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1059-1104)
```text
    public(friend) fun join_validator_set_internal(
        operator: &signer,
        pool_address: address
    ) acquires StakePool, ValidatorConfig, ValidatorSet {
        assert_reconfig_not_in_progress();
        assert_stake_pool_exists(pool_address);
        let stake_pool = borrow_global_mut<StakePool>(pool_address);
        assert!(signer::address_of(operator) == stake_pool.operator_address, error::unauthenticated(ENOT_OPERATOR));
        assert!(
            get_validator_state(pool_address) == VALIDATOR_STATUS_INACTIVE,
            error::invalid_state(EALREADY_ACTIVE_VALIDATOR),
        );

        let config = staking_config::get();
        let (minimum_stake, maximum_stake) = staking_config::get_required_stake(&config);
        let voting_power = get_next_epoch_voting_power(stake_pool);
        assert!(voting_power >= minimum_stake, error::invalid_argument(ESTAKE_TOO_LOW));
        assert!(voting_power <= maximum_stake, error::invalid_argument(ESTAKE_TOO_HIGH));

        // Track and validate voting power increase.
        update_voting_power_increase(voting_power);

        // Add validator to pending_active, to be activated in the next epoch.
        let validator_config = borrow_global<ValidatorConfig>(pool_address);
        assert!(!vector::is_empty(&validator_config.consensus_pubkey), error::invalid_argument(EINVALID_PUBLIC_KEY));

        // Validate the current validator set size has not exceeded the limit.
        let validator_set = borrow_global_mut<ValidatorSet>(@aptos_framework);
        vector::push_back(
            &mut validator_set.pending_active,
            generate_validator_info(pool_address, stake_pool, *validator_config)
        );
        let validator_set_size = vector::length(&validator_set.active_validators) + vector::length(
            &validator_set.pending_active
        );
        assert!(validator_set_size <= MAX_VALIDATOR_SET_SIZE, error::invalid_argument(EVALIDATOR_SET_TOO_LARGE));

        if (std::features::module_event_migration_enabled()) {
            event::emit(JoinValidatorSet { pool_address });
        } else {
            event::emit_event(
                &mut stake_pool.join_validator_set_events,
                JoinValidatorSetEvent { pool_address },
            );
        }
    }
```

**File:** crates/aptos-bitvec/src/lib.rs (L18-37)
```rust
// Every u8 is used as a bucket of 8 bits. Total max buckets = 65536 / 8 = 8192.
const BUCKET_SIZE: usize = 8;
const MAX_BUCKETS: usize = 8192;

/// BitVec represents a bit vector that supports 4 operations:
///
/// 1. Marking a position as set.
/// 2. Checking if a position is set.
/// 3. Count set bits.
/// 4. Get the index of the last set bit.
///
/// Internally, it stores a vector of u8's (as `Vec<u8>`).
///
/// * The first 8 positions of the bit vector are encoded in the first element of the vector, the
///   next 8 are encoded in the second element, and so on.
/// * Bits are read from left to right. For instance, in the following bitvec
///   [0b0001_0000, 0b0000_0000, 0b0000_0000, 0b0000_0001], the 3rd and 31st positions are set.
/// * Each bit of a u8 is set to 1 if the position is set and to 0 if it's not.
/// * We only allow setting positions upto u16::MAX. As a result, the size of the inner vector is
///   limited to 8192 (= 65536 / 8).
```

**File:** crates/aptos/src/genesis/mod.rs (L620-875)
```rust
fn validate_validators(
    layout: &Layout,
    validators: &[ValidatorConfiguration],
    initialized_accounts: &BTreeMap<AccountAddress, u64>,
    unique_accounts: &mut BTreeSet<AccountAddress>,
    unique_network_keys: &mut HashSet<x25519::PublicKey>,
    unique_consensus_keys: &mut HashSet<bls12381::PublicKey>,
    unique_consensus_pops: &mut HashSet<bls12381::ProofOfPossession>,
    unique_hosts: &mut HashSet<HostAndPort>,
    seen_owners: &mut BTreeMap<AccountAddress, usize>,
    is_pooled_validator: bool,
) -> CliTypedResult<()> {
    // check accounts for validators
    let mut errors = vec![];

    for (i, validator) in validators.iter().enumerate() {
        let name = if is_pooled_validator {
            format!("Employee Pool #{}", i)
        } else {
            layout.users.get(i).unwrap().to_string()
        };

        if !initialized_accounts.contains_key(&validator.owner_account_address.into()) {
            errors.push(CliError::UnexpectedError(format!(
                "Owner {} in validator {} is not in the balances.yaml file",
                validator.owner_account_address, name
            )));
        }
        if !initialized_accounts.contains_key(&validator.operator_account_address.into()) {
            errors.push(CliError::UnexpectedError(format!(
                "Operator {} in validator {} is not in the balances.yaml file",
                validator.operator_account_address, name
            )));
        }
        if !initialized_accounts.contains_key(&validator.voter_account_address.into()) {
            errors.push(CliError::UnexpectedError(format!(
                "Voter {} in validator {} is not in the balances.yaml file",
                validator.voter_account_address, name
            )));
        }

        let owner_balance = initialized_accounts
            .get(&validator.owner_account_address.into())
            .unwrap();

        if seen_owners.contains_key(&validator.owner_account_address.into()) {
            errors.push(CliError::UnexpectedError(format!(
                "Owner {} in validator {} has been seen before as an owner of validator {}",
                validator.owner_account_address,
                name,
                seen_owners
                    .get(&validator.owner_account_address.into())
                    .unwrap()
            )));
        }
        seen_owners.insert(validator.owner_account_address.into(), i);

        if unique_accounts.contains(&validator.owner_account_address.into()) {
            errors.push(CliError::UnexpectedError(format!(
                "Owner '{}' in validator {} has already been seen elsewhere",
                validator.owner_account_address, name
            )));
        }
        unique_accounts.insert(validator.owner_account_address.into());

        if unique_accounts.contains(&validator.operator_account_address.into()) {
            errors.push(CliError::UnexpectedError(format!(
                "Operator '{}' in validator {} has already been seen elsewhere",
                validator.operator_account_address, name
            )));
        }
        unique_accounts.insert(validator.operator_account_address.into());

        // Pooled validators have a combined balance
        // TODO: Make this field optional but checked
        if !is_pooled_validator && *owner_balance < validator.stake_amount {
            errors.push(CliError::UnexpectedError(format!(
                "Owner {} in validator {} has less in it's balance {} than the stake amount for the validator {}",
                validator.owner_account_address, name, owner_balance, validator.stake_amount
            )));
        }
        if validator.stake_amount < layout.min_stake {
            errors.push(CliError::UnexpectedError(format!(
                "Validator {} has stake {} under the min stake {}",
                name, validator.stake_amount, layout.min_stake
            )));
        }
        if validator.stake_amount > layout.max_stake {
            errors.push(CliError::UnexpectedError(format!(
                "Validator {} has stake {} over the max stake {}",
                name, validator.stake_amount, layout.max_stake
            )));
        }

        // Ensure that the validator is setup correctly if it's joining in genesis
        if validator.join_during_genesis {
            if validator.validator_network_public_key.is_none() {
                errors.push(CliError::UnexpectedError(format!(
                    "Validator {} does not have a validator network public key, though it's joining during genesis",
                    name
                )));
            }
            if !unique_network_keys.insert(validator.validator_network_public_key.unwrap()) {
                errors.push(CliError::UnexpectedError(format!(
                    "Validator {} has a repeated validator network key{}",
                    name,
                    validator.validator_network_public_key.unwrap()
                )));
            }

            if validator.validator_host.is_none() {
                errors.push(CliError::UnexpectedError(format!(
                    "Validator {} does not have a validator host, though it's joining during genesis",
                    name
                )));
            }
            if !unique_hosts.insert(validator.validator_host.as_ref().unwrap().clone()) {
                errors.push(CliError::UnexpectedError(format!(
                    "Validator {} has a repeated validator host {:?}",
                    name,
                    validator.validator_host.as_ref().unwrap()
                )));
            }

            if validator.consensus_public_key.is_none() {
                errors.push(CliError::UnexpectedError(format!(
                    "Validator {} does not have a consensus public key, though it's joining during genesis",
                    name
                )));
            }
            if !unique_consensus_keys
                .insert(validator.consensus_public_key.as_ref().unwrap().clone())
            {
                errors.push(CliError::UnexpectedError(format!(
                    "Validator {} has a repeated a consensus public key {}",
                    name,
                    validator.consensus_public_key.as_ref().unwrap()
                )));
            }

            if validator.proof_of_possession.is_none() {
                errors.push(CliError::UnexpectedError(format!(
                    "Validator {} does not have a consensus proof of possession, though it's joining during genesis",
                    name
                )));
            }
            if !unique_consensus_pops
                .insert(validator.proof_of_possession.as_ref().unwrap().clone())
            {
                errors.push(CliError::UnexpectedError(format!(
                    "Validator {} has a repeated a consensus proof of possessions {}",
                    name,
                    validator.proof_of_possession.as_ref().unwrap()
                )));
            }

            match (
                validator.full_node_host.as_ref(),
                validator.full_node_network_public_key.as_ref(),
            ) {
                (None, None) => {
                    info!("Validator {} does not have a full node setup", name);
                },
                (Some(_), None) | (None, Some(_)) => {
                    errors.push(CliError::UnexpectedError(format!(
                        "Validator {} has a full node host or public key but not both",
                        name
                    )));
                },
                (Some(full_node_host), Some(full_node_network_public_key)) => {
                    // Ensure that the validator and the full node aren't the same
                    let validator_host = validator.validator_host.as_ref().unwrap();
                    let validator_network_public_key =
                        validator.validator_network_public_key.as_ref().unwrap();
                    if validator_host == full_node_host {
                        errors.push(CliError::UnexpectedError(format!(
                            "Validator {} has a validator and a full node host that are the same {:?}",
                            name,
                            validator_host
                        )));
                    }
                    if !unique_hosts.insert(validator.full_node_host.as_ref().unwrap().clone()) {
                        errors.push(CliError::UnexpectedError(format!(
                            "Validator {} has a repeated full node host {:?}",
                            name,
                            validator.full_node_host.as_ref().unwrap()
                        )));
                    }

                    if validator_network_public_key == full_node_network_public_key {
                        errors.push(CliError::UnexpectedError(format!(
                            "Validator {} has a validator and a full node network public key that are the same {}",
                            name,
                            validator_network_public_key
                        )));
                    }
                    if !unique_network_keys.insert(validator.full_node_network_public_key.unwrap())
                    {
                        errors.push(CliError::UnexpectedError(format!(
                            "Validator {} has a repeated full node network key {}",
                            name,
                            validator.full_node_network_public_key.unwrap()
                        )));
                    }
                },
            }
        } else {
            if validator.validator_network_public_key.is_some() {
                errors.push(CliError::UnexpectedError(format!(
                    "Validator {} has a validator network public key, but it is *NOT* joining during genesis",
                    name
                )));
            }
            if validator.validator_host.is_some() {
                errors.push(CliError::UnexpectedError(format!(
                    "Validator {} has a validator host, but it is *NOT* joining during genesis",
                    name
                )));
            }
            if validator.consensus_public_key.is_some() {
                errors.push(CliError::UnexpectedError(format!(
                    "Validator {} has a consensus public key, but it is *NOT* joining during genesis",
                    name
                )));
            }
            if validator.proof_of_possession.is_some() {
                errors.push(CliError::UnexpectedError(format!(
                    "Validator {} has a consensus proof of possession, but it is *NOT* joining during genesis",
                    name
                )));
            }
            if validator.full_node_network_public_key.is_some() {
                errors.push(CliError::UnexpectedError(format!(
                    "Validator {} has a full node public key, but it is *NOT* joining during genesis",
                    name
                )));
            }
            if validator.full_node_host.is_some() {
                errors.push(CliError::UnexpectedError(format!(
                    "Validator {} has a full node host, but it is *NOT* joining during genesis",
                    name
                )));
            }
        }
    }

    if errors.is_empty() {
        Ok(())
    } else {
        eprintln!("{:#?}", errors);

        Err(CliError::UnexpectedError(
            "Failed to validate validators".to_string(),
        ))
    }
}
```
