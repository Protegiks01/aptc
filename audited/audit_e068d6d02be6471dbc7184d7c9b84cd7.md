# Audit Report

## Title
Cache Key Collision Enables Signature Verification Bypass in ProofOfStore

## Summary
The `ProofOfStore::verify()` function uses a shared cache with `BatchInfoExt` as the key, but signature verification operates on generic type `T` which can be either `BatchInfo` or `BatchInfoExt`. Due to BCS serialization differences between these types, signatures valid for `BatchInfo` are cryptographically invalid for `BatchInfoExt::V1{info: BatchInfo}`, yet the cache treats them as identical. This enables Byzantine validators to bypass signature verification, causing consensus disagreement between nodes with different cache states.

## Finding Description
The vulnerability exists in the interaction between `ProofOfStore<T>::verify()` and the shared `ProofCache`. [1](#0-0) 

The cache uses `BatchInfoExt` as both the key type and value container for aggregated signatures. [2](#0-1) 

The verification logic converts `self.info` (type `T`) to `BatchInfoExt` for cache lookup, but verifies signatures against the original `self.info`. When `T` is `BatchInfo`, the conversion wraps it as `BatchInfoExt::V1 { info }`. [3](#0-2) 

**The Attack Flow:**

1. **V1 Message Processing**: When `ProofOfStore<BatchInfo>` is verified, the signature is checked against `BCS(BatchInfo)` (line 642-643). Upon success, the cache stores `BatchInfoExt::V1 { info } â†’ signature` (line 649).

2. **V2 Message Exploitation**: A Byzantine validator crafts `ProofOfStore<BatchInfoExt::V1 { info }>` with the same signature. The cache lookup succeeds (lines 637-640), signature comparison matches, and verification returns `Ok()` without cryptographic validation.

3. **Cryptographic Invalidity**: The signature was created for `BCS(BatchInfo)` but is being accepted for `BCS(BatchInfoExt::V1 { info })`. These serialize differently due to enum discriminants. [4](#0-3) 

`BatchInfo` serializes as a STRUCT (8 fields sequentially), while `BatchInfoExt` serializes as an ENUM with discriminant byte 0 for V1 variant. The signature is cryptographically invalid for the V2 format.

**Both Message Types Use Shared Cache:** [5](#0-4) [6](#0-5) [7](#0-6) 

Both V1 and V2 messages are verified using the same `proof_cache` parameter, enabling the cache collision attack.

## Impact Explanation
This is a **Critical** severity issue matching Aptos bug bounty criteria for "Consensus/Safety Violations."

The vulnerability creates **consensus disagreement** between validators:
- Validators with cached entries accept the invalid V2 proof (cache hit bypasses verification)
- Validators without cache entries reject the invalid V2 proof (cryptographic verification fails)
- Different validators have different views of which batches have valid proofs
- This leads to different block contents and state roots across validators
- Consensus safety is violated without requiring >1/3 Byzantine validators

A single Byzantine validator can:
1. Observe legitimate V1 messages and extract batch information
2. Broadcast V2 messages with cryptographically invalid signatures
3. Cause some validators to accept invalid proofs while others reject them
4. Create persistent consensus disagreement requiring manual intervention

This breaks the core guarantee that honest validators agree on valid proofs, violating AptosBFT consensus safety properties.

## Likelihood Explanation
**HIGH likelihood** - The vulnerability is easily exploitable:

1. **Both message types are actively supported**: The codebase maintains V1/V2 compatibility with both message paths using the shared cache.

2. **Single Byzantine validator sufficient**: Attack requires only one malicious validator within the validator set (well within the <1/3 Byzantine tolerance threshold).

3. **Simple attack vector**: Byzantine validator observes legitimate V1 messages and crafts V2 messages with reused signatures. No complex timing or coordination required.

4. **Shared cache across all processing**: Cache is shared across all consensus message handling, making the attack window continuous.

5. **No sender authorization checks**: [8](#0-7) 

ProofOfStore verification only checks signature validity, not sender authorization. Any validator can broadcast any ProofOfStore message.

## Recommendation
Modify the cache to use the actual signed data type as the key, not a normalized type:

```rust
pub type ProofCache = Cache<(TypeId, BatchInfoExt), AggregateSignature>;

pub fn verify(&self, validator: &ValidatorVerifier, cache: &ProofCache) -> anyhow::Result<()> {
    let batch_info_ext: BatchInfoExt = self.info.clone().into();
    let type_id = TypeId::of::<T>();
    
    if let Some(signature) = cache.get(&(type_id, batch_info_ext.clone())) {
        if signature == self.multi_signature {
            return Ok(());
        }
    }
    
    let result = validator
        .verify_multi_signatures(&self.info, &self.multi_signature)
        .context(format!("Failed to verify ProofOfStore for batch: {:?}", self.info));
    
    if result.is_ok() {
        cache.insert((type_id, batch_info_ext), self.multi_signature.clone());
    }
    result
}
```

Alternatively, verify signatures against the cache key type rather than the original type to ensure consistency.

## Proof of Concept
A Byzantine validator can exploit this by:

1. Observing a legitimate `ConsensusMsg::ProofOfStoreMsg(ProofOfStore<BatchInfo>)` broadcast
2. Extracting the `BatchInfo` and signature from the message
3. Constructing `BatchInfoExt::V1 { info: BatchInfo }` 
4. Broadcasting `ConsensusMsg::ProofOfStoreMsgV2(ProofOfStore<BatchInfoExt::V1>)` with the same signature
5. Validators with cache entries will accept (cache hit), others will reject (verification failure)
6. Consensus disagreement occurs based on cache state

The attack succeeds because the signature valid for `BCS(BatchInfo)` is incorrectly cached and reused for `BCS(BatchInfoExt::V1 { info })`, which has different serialization due to enum discriminant.

## Notes
- This vulnerability requires Byzantine validator privileges but only a single malicious validator (<1/3 threshold)
- The attacker cannot create entirely malicious batches, only replay legitimate batches in invalid message formats
- However, this is sufficient to cause consensus disagreement, which is a critical safety violation
- The vulnerability exists because the cache normalization (converting all types to `BatchInfoExt`) doesn't account for the fact that signatures are verified against the original unnormalized type
- Both V1 and V2 code paths are actively maintained for backward compatibility, making this exploitable in production

### Citations

**File:** consensus/consensus-types/src/proof_of_store.rs (L120-124)
```rust
impl From<BatchInfo> for BatchInfoExt {
    fn from(info: BatchInfo) -> Self {
        Self::V1 { info }
    }
}
```

**File:** consensus/consensus-types/src/proof_of_store.rs (L566-582)
```rust
    pub fn verify(
        &self,
        max_num_proofs: usize,
        validator: &ValidatorVerifier,
        cache: &ProofCache,
    ) -> anyhow::Result<()> {
        ensure!(!self.proofs.is_empty(), "Empty message");
        ensure!(
            self.proofs.len() <= max_num_proofs,
            "Too many proofs: {} > {}",
            self.proofs.len(),
            max_num_proofs
        );
        for proof in &self.proofs {
            proof.verify(validator, cache)?
        }
        Ok(())
```

**File:** consensus/consensus-types/src/proof_of_store.rs (L616-616)
```rust
pub type ProofCache = Cache<BatchInfoExt, AggregateSignature>;
```

**File:** consensus/consensus-types/src/proof_of_store.rs (L635-651)
```rust
    pub fn verify(&self, validator: &ValidatorVerifier, cache: &ProofCache) -> anyhow::Result<()> {
        let batch_info_ext: BatchInfoExt = self.info.clone().into();
        if let Some(signature) = cache.get(&batch_info_ext) {
            if signature == self.multi_signature {
                return Ok(());
            }
        }
        let result = validator
            .verify_multi_signatures(&self.info, &self.multi_signature)
            .context(format!(
                "Failed to verify ProofOfStore for batch: {:?}",
                self.info
            ));
        if result.is_ok() {
            cache.insert(batch_info_ext, self.multi_signature.clone());
        }
        result
```

**File:** testsuite/generate-format/tests/staged/consensus.yaml (L162-188)
```yaml
BatchInfo:
  STRUCT:
    - author:
        TYPENAME: AccountAddress
    - batch_id:
        TYPENAME: BatchId
    - epoch: U64
    - expiration: U64
    - digest:
        TYPENAME: HashValue
    - num_txns: U64
    - num_bytes: U64
    - gas_bucket_start: U64
BatchInfoExt:
  ENUM:
    0:
      V1:
        STRUCT:
          - info:
              TYPENAME: BatchInfo
    1:
      V2:
        STRUCT:
          - info:
              TYPENAME: BatchInfo
          - extra:
              TYPENAME: ExtraBatchInfo
```

**File:** consensus/src/network_interface.rs (L78-78)
```rust
    ProofOfStoreMsg(Box<ProofOfStoreMsg<BatchInfo>>),
```

**File:** consensus/src/network_interface.rs (L102-102)
```rust
    ProofOfStoreMsgV2(Box<ProofOfStoreMsg<BatchInfoExt>>),
```

**File:** consensus/src/round_manager.rs (L212-228)
```rust
            UnverifiedEvent::ProofOfStoreMsg(p) => {
                if !self_message {
                    p.verify(max_num_batches, validator, proof_cache)?;
                    counters::VERIFY_MSG
                        .with_label_values(&["proof_of_store"])
                        .observe(start_time.elapsed().as_secs_f64());
                }
                VerifiedEvent::ProofOfStoreMsg(Box::new((*p).into()))
            },
            UnverifiedEvent::ProofOfStoreMsgV2(p) => {
                if !self_message {
                    p.verify(max_num_batches, validator, proof_cache)?;
                    counters::VERIFY_MSG
                        .with_label_values(&["proof_of_store_v2"])
                        .observe(start_time.elapsed().as_secs_f64());
                }
                VerifiedEvent::ProofOfStoreMsg(p)
```
