# Audit Report

## Title
Keyless Account Lockout During Groth16 Verification Key Rotation Due to Lack of VK Versioning Support

## Summary
The Aptos keyless authentication system stores only a single global Groth16 verification key (VK) on-chain at any time. When governance rotates the VK to a new version, all existing zero-knowledge proofs generated with the old VK become invalid, even if their ephemeral keys have not yet expired. This causes temporary account lockout for legitimate users who must re-authenticate to regain access to their accounts and funds.

## Finding Description
The keyless account system maintains a single `Groth16VerificationKey` resource at `@aptos_framework` [1](#0-0) . When a new VK is queued via `set_groth16_verification_key_for_next_epoch` [2](#0-1)  and applied during epoch transition [3](#0-2) , it completely replaces the old VK.

The VM environment fetches this single global VK from on-chain storage once per block [4](#0-3)  and uses it for ALL keyless signature validations [5](#0-4) . The verification logic always uses this current VK [6](#0-5) , with no mechanism to:
1. Store multiple VK versions simultaneously
2. Track which VK version was active when an account was created
3. Select the appropriate VK version based on when a proof was generated

Test evidence confirms this behavior [7](#0-6) : after VK rotation at line 131-135, old proofs fail with `INVALID_SIGNATURE` (lines 146-147), while new proofs succeed (lines 137-140).

## Impact Explanation
This issue creates **temporary denial of access** to user funds during VK rotation windows, qualifying as **High severity** under the Aptos bug bounty program criteria for "Validator node slowdowns" and "Significant protocol violations."

While the comment acknowledges this behavior [8](#0-7) , it frames the issue as a DoS mitigation feature rather than addressing the user impact. However, this creates a protocol violation where:
- Valid proofs (with non-expired ephemeral keys) are incorrectly rejected
- Users experience unexpected account lockout requiring re-authentication
- No grace period or migration mechanism exists

The impact is NOT Critical severity because:
- Access loss is temporary (users can regenerate proofs)
- No funds are permanently lost or stolen
- Consensus remains intact (all validators use the same VK after epoch transition)

## Likelihood Explanation
**Likelihood: Medium to High**

VK rotation is expected to occur during:
- Security upgrades to the ZK circuit
- Response to discovered vulnerabilities in the proof system
- Regular security maintenance

Each rotation event affects ALL users with active sessions (proofs with unexpired ephemeral keys). Given that ephemeral keys typically expire in 1 hour, any user with a proof generated within 1 hour before rotation will experience lockout.

The issue is deterministic and guaranteed to occur on every VK rotation, making it highly likely to impact users during the protocol's operational lifetime.

## Recommendation
Implement VK versioning support to allow multiple VK versions to coexist on-chain:

1. **Store VK history**: Maintain a mapping of `epoch_number -> Groth16VerificationKey`
2. **Track proof creation epoch**: Include the epoch number in zero-knowledge proofs or ephemeral signatures
3. **Version-aware verification**: Select the appropriate VK version during proof verification based on when the proof was created
4. **Implement grace period**: Support the old VK for a transition period (e.g., 2 epochs) after rotation

```move
// Modified keyless_account.move structure
struct Groth16VerificationKeyHistory has key {
    keys: SmartTable<u64, Groth16VerificationKey>, // epoch -> VK mapping
    current_epoch: u64,
    grace_period_epochs: u64,
}

public fun get_vk_for_epoch(proof_epoch: u64): Option<Groth16VerificationKey> {
    // Return appropriate VK based on proof epoch
    // Support proofs from current epoch and grace period
}
```

## Proof of Concept
The existing test demonstrates the vulnerability [7](#0-6) :

```
Steps to reproduce:
1. Create keyless account with VK1 (lines 108-114)
2. Generate valid proof with 1-hour expiry for VK1 (line 109)
3. Rotate VK to VK2 via governance (lines 131-135)
4. Attempt transaction with old proof for VK1 (lines 142-144)
5. Result: Transaction fails with INVALID_SIGNATURE (lines 146-147)
6. User must re-authenticate to get new proof with VK2
```

This demonstrates that legitimate users with valid, unexpired proofs lose access to their accounts immediately upon VK rotation, requiring forced re-authentication to regain access.

## Notes
While the current behavior is intentional per the warning comment, it creates a user experience issue that rises to protocol violation severity. The lack of VK versioning support means the system cannot gracefully handle security upgrades without disrupting active user sessions. A production-grade keyless authentication system should support backward compatibility during VK transitions to prevent legitimate user lockout.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/keyless_account.move (L32-45)
```text
    /// The 288-byte Groth16 verification key (VK) for the ZK relation that implements keyless accounts
    struct Groth16VerificationKey has key, store, drop {
        /// 32-byte serialization of `alpha * G`, where `G` is the generator of `G1`.
        alpha_g1: vector<u8>,
        /// 64-byte serialization of `alpha * H`, where `H` is the generator of `G2`.
        beta_g2: vector<u8>,
        /// 64-byte serialization of `gamma * H`, where `H` is the generator of `G2`.
        gamma_g2: vector<u8>,
        /// 64-byte serialization of `delta * H`, where `H` is the generator of `G2`.
        delta_g2: vector<u8>,
        /// `\forall i \in {0, ..., \ell}, 64-byte serialization of gamma^{-1} * (beta * a_i + alpha * b_i + c_i) * H`, where
        /// `H` is the generator of `G1` and `\ell` is 1 for the ZK relation.
        gamma_abc_g1: vector<vector<u8>>,
    }
```

**File:** aptos-move/framework/aptos-framework/sources/keyless_account.move (L259-260)
```text
    /// WARNING: To mitigate against DoS attacks, a VK change should be done together with a training wheels PK change,
    /// so that old ZKPs for the old VK cannot be replayed as potentially-valid ZKPs.
```

**File:** aptos-move/framework/aptos-framework/sources/keyless_account.move (L263-266)
```text
    public fun set_groth16_verification_key_for_next_epoch(fx: &signer, vk: Groth16VerificationKey) {
        system_addresses::assert_aptos_framework(fx);
        config_buffer::upsert<Groth16VerificationKey>(vk);
    }
```

**File:** aptos-move/framework/aptos-framework/sources/keyless_account.move (L358-378)
```text
    public(friend) fun on_new_epoch(fx: &signer) acquires Groth16VerificationKey, Configuration {
        system_addresses::assert_aptos_framework(fx);

        if (config_buffer::does_exist<Groth16VerificationKey>()) {
            let vk = config_buffer::extract_v2();
            if (exists<Groth16VerificationKey>(@aptos_framework)) {
                *borrow_global_mut<Groth16VerificationKey>(@aptos_framework) = vk;
            } else {
                move_to(fx, vk);
            }
        };

        if (config_buffer::does_exist<Configuration>()) {
            let config = config_buffer::extract_v2();
            if (exists<Configuration>(@aptos_framework)) {
                *borrow_global_mut<Configuration>(@aptos_framework) = config;
            } else {
                move_to(fx, config);
            }
        };
    }
```

**File:** aptos-move/aptos-vm-environment/src/environment.rs (L289-293)
```rust
        let keyless_pvk =
            Groth16VerificationKey::fetch_keyless_config(state_view).and_then(|(vk, vk_bytes)| {
                sha3_256.update(&vk_bytes);
                vk.try_into().ok()
            });
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1803-1810)
```rust
            keyless_validation::validate_authenticators(
                self.environment().keyless_pvk(),
                self.environment().keyless_configuration(),
                &keyless_authenticators,
                self.features(),
                session.resolver,
                module_storage,
            )?;
```

**File:** aptos-move/aptos-vm/src/keyless_validation.rs (L347-347)
```rust
                        let result = zksig.verify_groth16_proof(public_inputs_hash, pvk.unwrap());
```

**File:** aptos-move/e2e-move-tests/src/tests/keyless_feature_gating.rs (L97-153)
```rust
#[test]
fn test_rotate_vk() {
    let (mut h, recipient, core_resources) = init_feature_gating(
        vec![
            FeatureFlag::CRYPTOGRAPHY_ALGEBRA_NATIVES,
            FeatureFlag::BN254_STRUCTURES,
            FeatureFlag::KEYLESS_ACCOUNTS,
        ],
        vec![],
    );

    // Old proof for old VK
    let (old_sig, pk) = get_sample_groth16_sig_and_pk();
    let account = create_keyless_account(&mut h, pk);
    let transaction =
        spend_keyless_account(&mut h, old_sig.clone(), &account, *recipient.address());
    let output = h.run_raw(transaction);
    assert_success!(output.status().clone());

    // New proof for old VK
    let (new_sig, _) = get_groth16_sig_and_pk_for_upgraded_vk();
    let transaction =
        spend_keyless_account(&mut h, new_sig.clone(), &account, *recipient.address());
    let output = h.run_raw(transaction);
    //println!("TXN status: {:?}", output.status());
    match output.status() {
        TransactionStatus::Discard(sc) => assert_eq!(*sc, StatusCode::INVALID_SIGNATURE),
        TransactionStatus::Keep(es) => {
            panic!("Expected TransactionStatus::Discard, got Keep({:?})", es)
        },
        TransactionStatus::Retry => panic!("Expected TransactionStatus::Discard, got Retry"),
    }

    // Upgrade the VK
    run_upgrade_vk_script(
        &mut h,
        core_resources,
        Groth16VerificationKey::from(get_upgraded_vk()),
    );

    // New proof for new VK
    let transaction = spend_keyless_account(&mut h, new_sig, &account, *recipient.address());
    let output = h.run_raw(transaction);
    assert_success!(output.status().clone());

    // Old proof for old VK
    let transaction = spend_keyless_account(&mut h, old_sig, &account, *recipient.address());
    let output = h.run_raw(transaction);
    // println!("TXN status: {:?}", output.status());
    match output.status() {
        TransactionStatus::Discard(sc) => assert_eq!(*sc, StatusCode::INVALID_SIGNATURE),
        TransactionStatus::Keep(es) => {
            panic!("Expected TransactionStatus::Discard, got Keep({:?})", es)
        },
        TransactionStatus::Retry => panic!("Expected TransactionStatus::Discard, got Retry"),
    }
}
```
