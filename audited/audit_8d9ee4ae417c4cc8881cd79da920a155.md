# Audit Report

## Title
Non-Atomic State Update in Ledger Pruner Progress Persistence Creates State Inconsistency Window

## Summary
The `save_min_readable_version()` function in the ledger pruner manager updates an in-memory atomic value before persisting pruner progress to the database. If the database write fails partway through (across 8 sub-databases), the system enters an inconsistent state where the in-memory version differs from the persisted metadata, and different sub-databases have divergent progress values.

## Finding Description

The vulnerability exists in the `save_min_readable_version()` function: [1](#0-0) 

This function performs a **non-atomic two-phase update**:
1. **Phase 1** (lines 81-82): Updates the in-memory `AtomicVersion` 
2. **Phase 2** (line 88): Persists progress to database via `write_pruner_progress()`

The critical flaw is that `write_pruner_progress()` sequentially writes to 8 separate sub-databases: [2](#0-1) 

If any write fails (e.g., the 5th database write), the system is left in an inconsistent state:
- **In-memory atomic**: Updated to new version V
- **Sub-databases 1-4**: Progress = V (updated)
- **Sub-databases 5-8**: Progress = V-Î” (stale)

This function is invoked during state snapshot finalization (fast sync): [3](#0-2) 

### Consistency Violation

The atomic version is used by query validation: [4](#0-3) 

During the inconsistency window, `get_min_readable_version()` returns the updated value from the atomic: [5](#0-4) 

This causes **false query rejections** for versions that are actually still available in some sub-databases.

### Post-Restart Inconsistency

On restart, the system initializes from database metadata: [6](#0-5) 

This reads only from the `LedgerMetadataDb`: [7](#0-6) [8](#0-7) 

However, sub-pruners may have divergent progress values persisted in their own databases, creating permanent inconsistency until manual intervention.

## Impact Explanation

**Severity: Medium** per Aptos bug bounty criteria - "State inconsistencies requiring intervention"

**Concrete Impacts:**
1. **Query Availability Issues**: False rejections of valid read queries during the inconsistency window
2. **Sub-Database Progress Divergence**: Permanent state inconsistency across 8 sub-databases after partial write failure
3. **Pruning Operation Failures**: Subsequent pruning may attempt to prune already-pruned data or skip unpruned data
4. **Manual Intervention Required**: Database state requires administrative correction to restore consistency

This breaks the **State Consistency** invariant: "State transitions must be atomic and verifiable."

## Likelihood Explanation

**Likelihood: Low to Medium**

**Triggering Conditions:**
- Occurs during fast sync / state snapshot finalization
- Requires database write failure from:
  - Disk I/O errors (hardware issues, filesystem corruption)
  - Disk space exhaustion
  - Node crash/termination during the write sequence
  - Database-level errors (connection loss, timeout)

**Frequency:**
- Fast sync happens during initial node setup and catch-up
- Write failures are relatively rare but not impossible in production environments
- Higher probability in degraded hardware or resource-constrained scenarios

## Recommendation

Implement **atomic batch writes** across all sub-databases using a two-phase commit or single atomic transaction:

```rust
fn save_min_readable_version(&self, min_readable_version: Version) -> Result<()> {
    // First, persist ALL progress to database atomically
    self.ledger_db.write_pruner_progress(min_readable_version)?;
    
    // Only update in-memory state AFTER successful persistence
    self.min_readable_version
        .store(min_readable_version, Ordering::SeqCst);

    PRUNER_VERSIONS
        .with_label_values(&["ledger_pruner", "min_readable"])
        .set(min_readable_version as i64);

    Ok(())
}
```

Additionally, modify `write_pruner_progress()` to use a single atomic transaction:

```rust
pub(crate) fn write_pruner_progress(&self, version: Version) -> Result<()> {
    // Use a single batch for all writes
    let mut batch = SchemaBatch::new();
    
    self.event_db.add_pruner_progress_to_batch(version, &mut batch)?;
    self.persisted_auxiliary_info_db.add_pruner_progress_to_batch(version, &mut batch)?;
    // ... add all other sub-databases to batch ...
    
    // Single atomic write
    self.metadata_db().write_schemas(batch)?;
    
    Ok(())
}
```

## Proof of Concept

```rust
#[test]
fn test_partial_write_failure_inconsistency() {
    // Setup: Create LedgerDb and LedgerPrunerManager
    let ledger_db = create_test_ledger_db();
    let pruner_manager = LedgerPrunerManager::new(ledger_db, config, None);
    
    let initial_version = pruner_manager.get_min_readable_version();
    let new_version = initial_version + 1000;
    
    // Simulate: Inject failure in write_pruner_progress after 4th sub-database write
    inject_write_failure_after_n_calls(4);
    
    // Trigger: Call save_min_readable_version
    let result = pruner_manager.save_min_readable_version(new_version);
    
    // Verify inconsistency:
    assert!(result.is_err(), "Write should fail");
    
    // In-memory atomic is updated (BUG!)
    assert_eq!(pruner_manager.get_min_readable_version(), new_version);
    
    // Sub-databases have divergent state
    assert_eq!(ledger_db.event_db().get_pruner_progress()?, new_version); // Updated
    assert_eq!(ledger_db.transaction_db().get_pruner_progress()?, initial_version); // Stale
    
    // Query validation incorrectly rejects available data
    let query_version = new_version - 500;
    assert!(pruner_manager.error_if_ledger_pruned("test", query_version).is_err(),
            "Query incorrectly rejected as pruned");
}
```

**Notes:**
- This vulnerability requires environmental failure conditions (I/O errors) to manifest
- While the bug is real, exploitation requires specific failure timing during fast sync operations
- Impact is operational (state consistency) rather than security-critical (funds/consensus)
- The issue highlights a violation of atomic state update principles in distributed storage systems

### Citations

**File:** storage/aptosdb/src/pruner/ledger_pruner/ledger_pruner_manager.rs (L48-50)
```rust
    fn get_min_readable_version(&self) -> Version {
        self.min_readable_version.load(Ordering::SeqCst)
    }
```

**File:** storage/aptosdb/src/pruner/ledger_pruner/ledger_pruner_manager.rs (L80-89)
```rust
    fn save_min_readable_version(&self, min_readable_version: Version) -> Result<()> {
        self.min_readable_version
            .store(min_readable_version, Ordering::SeqCst);

        PRUNER_VERSIONS
            .with_label_values(&["ledger_pruner", "min_readable"])
            .set(min_readable_version as i64);

        self.ledger_db.write_pruner_progress(min_readable_version)
    }
```

**File:** storage/aptosdb/src/pruner/ledger_pruner/ledger_pruner_manager.rs (L123-137)
```rust
        let min_readable_version =
            pruner_utils::get_ledger_pruner_progress(&ledger_db).expect("Must succeed.");

        PRUNER_VERSIONS
            .with_label_values(&["ledger_pruner", "min_readable"])
            .set(min_readable_version as i64);

        Self {
            ledger_db,
            prune_window: ledger_pruner_config.prune_window,
            pruner_worker,
            pruning_batch_size: ledger_pruner_config.batch_size,
            latest_version: Arc::new(Mutex::new(min_readable_version)),
            user_pruning_window_offset: ledger_pruner_config.user_pruning_window_offset,
            min_readable_version: AtomicVersion::new(min_readable_version),
```

**File:** storage/aptosdb/src/ledger_db/mod.rs (L373-388)
```rust
    pub(crate) fn write_pruner_progress(&self, version: Version) -> Result<()> {
        info!("Fast sync is done, writing pruner progress {version} for all ledger sub pruners.");
        self.event_db.write_pruner_progress(version)?;
        self.persisted_auxiliary_info_db
            .write_pruner_progress(version)?;
        self.transaction_accumulator_db
            .write_pruner_progress(version)?;
        self.transaction_auxiliary_data_db
            .write_pruner_progress(version)?;
        self.transaction_db.write_pruner_progress(version)?;
        self.transaction_info_db.write_pruner_progress(version)?;
        self.write_set_db.write_pruner_progress(version)?;
        self.ledger_metadata_db.write_pruner_progress(version)?;

        Ok(())
    }
```

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L225-234)
```rust
            self.ledger_pruner.save_min_readable_version(version)?;
            self.state_store
                .state_merkle_pruner
                .save_min_readable_version(version)?;
            self.state_store
                .epoch_snapshot_pruner
                .save_min_readable_version(version)?;
            self.state_store
                .state_kv_pruner
                .save_min_readable_version(version)?;
```

**File:** storage/aptosdb/src/db/aptosdb_internal.rs (L261-271)
```rust
    pub(super) fn error_if_ledger_pruned(&self, data_type: &str, version: Version) -> Result<()> {
        let min_readable_version = self.ledger_pruner.get_min_readable_version();
        ensure!(
            version >= min_readable_version,
            "{} at version {} is pruned, min available version is {}.",
            data_type,
            version,
            min_readable_version
        );
        Ok(())
    }
```

**File:** storage/aptosdb/src/pruner/pruner_utils.rs (L19-21)
```rust
pub(crate) fn get_ledger_pruner_progress(ledger_db: &LedgerDb) -> Result<Version> {
    Ok(ledger_db.metadata_db().get_pruner_progress().unwrap_or(0))
}
```

**File:** storage/aptosdb/src/ledger_db/ledger_metadata_db.rs (L85-88)
```rust
    pub(crate) fn get_pruner_progress(&self) -> Result<Version> {
        get_progress(&self.db, &DbMetadataKey::LedgerPrunerProgress)?
            .ok_or_else(|| AptosDbError::NotFound("No LedgerPrunerProgress in db.".to_string()))
    }
```
