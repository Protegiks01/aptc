# Audit Report

## Title
Missing Validation Test Coverage for DKG DealtPubKey Deserialization Enables Potential Consensus Split via Invalid G2 Points

## Summary
The `DealtPubKey::try_from(&[u8])` function lacks comprehensive test coverage to verify that invalid G2 elliptic curve points are rejected during deserialization. While the implementation uses safe deserialization methods, the absence of tests creates risk that validation bypasses or library bugs could go undetected, potentially allowing invalid cryptographic keys in the consensus-critical DKG protocol.

## Finding Description

The DKG (Distributed Key Generation) `DealtPubKey` deserialization relies on `g2_proj_from_bytes()` to parse BLS12-381 G2 group elements. [1](#0-0) 

The implementation correctly uses `G2Projective::from_compressed()` which should validate subgroup membership. [2](#0-1) 

However, **zero tests exist** to verify rejection of:
1. Points on the curve but not in the prime-order subgroup (low-order points)
2. Valid (Fq2, Fq2) coordinates not satisfying the curve equation  
3. Invalid Fq2 field elements (out of field range)
4. Wrong-sized byte arrays (undersized/oversized)
5. Malformed serialization with incorrect flags

The Move framework's `test_g2affine` function **contains a critical bug** where lines 515-542 test G1 deserialization edge cases instead of G2, despite the function name. [3](#0-2) 

Only G1 has validation tests via `bls12381_validatable_pk` which verifies low-order point rejection. [4](#0-3) 

**Security Impact:**
If the blstrs library has validation bugs or if code is refactored to use unsafe methods, invalid G2 points could be accepted as DealtPubKeys. Since DKG runs during epoch changes and affects consensus, this could cause:
- Different validators accepting/rejecting different keys
- Consensus split if validation behavior differs across nodes  
- Weak cryptographic keys compromising security

## Impact Explanation

This constitutes **Medium severity** per the bug bounty program: "State inconsistencies requiring intervention."

While I cannot prove an exploitable vulnerability exists in the current blstrs implementation, the lack of validation tests for consensus-critical cryptographic operations creates significant risk. The DKG protocol directly impacts validator consensus and any validation inconsistency could lead to network partition or security compromise during epoch transitions.

The issue doesn't meet Critical severity because it requires an underlying library bug to be exploitable, not a direct implementation flaw.

## Likelihood Explanation

**Likelihood: Low to Medium**

Exploitation requires:
1. An undiscovered bug in blstrs `G2Projective::from_compressed()` 
2. Or malicious code change bypassing validation (e.g., using `from_compressed_unchecked`)
3. Ability to submit malicious DKG data during epoch transitions

The README documents the safety-critical requirement: "The G1/G2 group elements in `blstrs` are deserialized safely via calls to `from_[un]compressed` rather than calls to `from_[un]compressed_unchecked` which does not check prime-order subgroup membership." [5](#0-4) 

However, without tests, regressions or library bugs remain undetected.

## Recommendation

Add comprehensive validation tests for `DealtPubKey::try_from(&[u8])` covering all rejection scenarios:

```rust
#[test]
fn test_dealt_pub_key_rejects_low_order_g2_points() {
    // Test low-order G2 point rejection (similar to bls12381_validatable_pk but for G2)
    let low_order_g2_bytes = hex::decode("...").unwrap();
    assert!(DealtPubKey::try_from(low_order_g2_bytes.as_slice()).is_err());
}

#[test]  
fn test_dealt_pub_key_rejects_wrong_sized_inputs() {
    assert!(DealtPubKey::try_from(&[0u8; 95]).is_err());  // undersized
    assert!(DealtPubKey::try_from(&[0u8; 97]).is_err());  // oversized
}

#[test]
fn test_dealt_pub_key_rejects_invalid_field_elements() {
    // Bytes representing coordinates outside Fq2
    let invalid_fq2 = vec![0xffu8; 96];
    assert!(DealtPubKey::try_from(invalid_fq2.as_slice()).is_err());
}

#[test]
fn test_dealt_pub_key_rejects_point_not_on_curve() {
    // Valid Fq2 coordinates but not satisfying y^2 = x^3 + 4(u+1)
    let off_curve_bytes = hex::decode("...").unwrap();
    assert!(DealtPubKey::try_from(off_curve_bytes.as_slice()).is_err());
}
```

**Fix the Move test bug:** Correct `test_g2affine` to test G2 rejection cases instead of G1. [6](#0-5) 

## Proof of Concept

The current lack of tests can be verified by searching the codebase:

```bash
# No tests found for DealtPubKey deserialization
grep -r "DealtPubKey.*try_from\|test.*dealt.*pub" crates/aptos-dkg/tests/

# No tests for g2_proj_from_bytes validation  
grep -r "g2_proj_from_bytes.*test\|test.*g2.*invalid" crates/aptos-crypto/src/

# Move test bug - test_g2affine tests G1 instead of G2 at lines 515-542
# Verify by inspecting the deserialize<G1, ...> calls instead of deserialize<G2, ...>
```

To demonstrate the risk, a test should attempt to deserialize known invalid G2 points and verify rejection, similar to how `bls12381_validatable_pk` tests G1 validation.

**Notes:**

This report focuses on the **test coverage gap** rather than a proven exploitable vulnerability, as I cannot demonstrate that the blstrs library fails to validate properly. The security concern is that without tests, validation failures would go undetected in this consensus-critical code path. The recommendation is to add comprehensive validation tests as a security hardening measure.

### Citations

**File:** crates/aptos-dkg/src/pvss/dealt_pub_key.rs (L52-54)
```rust
            fn try_from(bytes: &[u8]) -> std::result::Result<DealtPubKey, Self::Error> {
                $gt_proj_from_bytes(bytes).map(|g_a| DealtPubKey { g_a })
            }
```

**File:** crates/aptos-crypto/src/blstrs/mod.rs (L115-128)
```rust
pub fn g2_proj_from_bytes(bytes: &[u8]) -> Result<G2Projective, CryptoMaterialError> {
    let slice = match <&[u8; G2_PROJ_NUM_BYTES]>::try_from(bytes) {
        Ok(slice) => slice,
        Err(_) => return Err(CryptoMaterialError::WrongLengthError),
    };

    let a = G2Projective::from_compressed(slice);

    if a.is_some().unwrap_u8() == 1u8 {
        Ok(a.unwrap())
    } else {
        Err(CryptoMaterialError::DeserializationError)
    }
}
```

**File:** aptos-move/framework/aptos-stdlib/sources/cryptography/bls12381_algebra.move (L486-543)
```text
    fun test_g2affine(fx: signer) {
        enable_cryptography_algebra_natives(&fx);

        // Special constants.
        assert!(R_SERIALIZED == order<G2>(), 1);
        let point_at_infinity = zero<G2>();
        let generator = one<G2>();

        // Serialization/deserialization.
        assert!(G2_GENERATOR_SERIALIZED_COMP == serialize<G2, FormatG2Compr>(&generator), 1);
        assert!(G2_GENERATOR_SERIALIZED_UNCOMP == serialize<G2, FormatG2Uncompr>(&generator), 1);
        let generator_from_uncomp = deserialize<G2, FormatG2Uncompr>(&G2_GENERATOR_SERIALIZED_UNCOMP
        ).extract();
        let generator_from_comp = deserialize<G2, FormatG2Compr>(&G2_GENERATOR_SERIALIZED_COMP
        ).extract();
        assert!(eq(&generator, &generator_from_comp), 1);
        assert!(eq(&generator, &generator_from_uncomp), 1);
        assert!(G2_INF_SERIALIZED_UNCOMP == serialize<G2, FormatG2Uncompr>(&point_at_infinity), 1);
        assert!(G2_INF_SERIALIZED_COMP == serialize<G2, FormatG2Compr>(&point_at_infinity), 1);
        let inf_from_uncomp = deserialize<G2, FormatG2Uncompr>(&G2_INF_SERIALIZED_UNCOMP).extract();
        let inf_from_comp = deserialize<G2, FormatG2Compr>(&G2_INF_SERIALIZED_COMP).extract();
        assert!(eq(&point_at_infinity, &inf_from_comp), 1);
        assert!(eq(&point_at_infinity, &inf_from_uncomp), 1);
        let point_7g_from_uncomp = deserialize<G2, FormatG2Uncompr>(&G2_GENERATOR_MUL_BY_7_SERIALIZED_UNCOMP
        ).extract();
        let point_7g_from_comp = deserialize<G2, FormatG2Compr>(&G2_GENERATOR_MUL_BY_7_SERIALIZED_COMP
        ).extract();
        assert!(eq(&point_7g_from_comp, &point_7g_from_uncomp), 1);

        // Deserialization should fail if given a point on the curve but not in the prime-order subgroup.
        assert!(
            deserialize<G1, FormatG1Uncompr>(&x"f037d4ccd5ee751eba1c1fd4c7edbb76d2b04c3a1f3f554827cf37c3acbc2dbb7cdb320a2727c2462d6c55ca1f637707b96eeebc622c1dbe7c56c34f93887c8751b42bd04f29253a82251c192ef27ece373993b663f4360505299c5bd18c890ddd862a6308796bf47e2265073c1f7d81afd69f9497fc1403e2e97a866129b43b672295229c21116d4a99f3e5c2ae720a31f181dbed8a93e15f909c20cf69d11a8879adbbe6890740def19814e6d4ed23fb0dcbd79291655caf48b466ac9cae04").is_none(
            ), 1);
        assert!(
            deserialize<G1, FormatG1Compr>(&x"f037d4ccd5ee751eba1c1fd4c7edbb76d2b04c3a1f3f554827cf37c3acbc2dbb7cdb320a2727c2462d6c55ca1f637707b96eeebc622c1dbe7c56c34f93887c8751b42bd04f29253a82251c192ef27ece373993b663f4360505299c5bd18c890d").is_none(
            ), 1);

        // Deserialization should fail if given a valid point in (Fq2,Fq2) but not on the curve.
        assert!(
            deserialize<G1, FormatG1Uncompr>(&x"f037d4ccd5ee751eba1c1fd4c7edbb76d2b04c3a1f3f554827cf37c3acbc2dbb7cdb320a2727c2462d6c55ca1f637707b96eeebc622c1dbe7c56c34f93887c8751b42bd04f29253a82251c192ef27ece373993b663f4360505299c5bd18c890d000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000").is_none(
            ), 1);

        // Deserialization should fail if given an invalid point (x not in Fq2).
        assert!(
            deserialize<G1, FormatG1Uncompr>(&x"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffdd862a6308796bf47e2265073c1f7d81afd69f9497fc1403e2e97a866129b43b672295229c21116d4a99f3e5c2ae720a31f181dbed8a93e15f909c20cf69d11a8879adbbe6890740def19814e6d4ed23fb0dcbd79291655caf48b466ac9cae04").is_none(
            ), 1);
        assert!(
            deserialize<G1, FormatG1Compr>(&x"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff").is_none(
            ), 1);

        // Deserialization should fail if given a byte array of wrong size.
        assert!(
            deserialize<G1, FormatG1Uncompr>(&x"000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000ab").is_none(
            ), 1);
        assert!(
            deserialize<G1, FormatG1Compr>(&x"000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000ab").is_none(
            ), 1);

```

**File:** crates/aptos-crypto/src/unit_tests/bls12381_test.rs (L337-372)
```rust
fn bls12381_validatable_pk() {
    let mut rng = OsRng;

    // Test that prime-order points pass the validate() call
    let keypair = KeyPair::<PrivateKey, PublicKey>::generate(&mut rng);
    let pk_bytes = keypair.public_key.to_bytes();

    let validatable = Validatable::from_validated(keypair.public_key);

    assert!(validatable.validate().is_ok());
    assert_eq!(validatable.validate().unwrap().to_bytes(), pk_bytes);

    // Test that low-order points don't pass the validate() call
    //
    // Low-order points were sampled from bls12_381 crate (https://github.com/zkcrypto/bls12_381/blob/main/src/g1.rs)
    // - The first point was convereted from projective to affine coordinates and serialized via `point.to_affine().to_compressed()`.
    // - The second point was in affine coordinates and serialized via `a.to_compressed()`.
    let low_order_points = [
        "ae3cd9403b69c20a0d455fd860e977fe6ee7140a7f091f26c860f2caccd3e0a7a7365798ac10df776675b3a67db8faa0",
        "928d4862a40439a67fd76a9c7560e2ff159e770dcf688ff7b2dd165792541c88ee76c82eb77dd6e9e72c89cbf1a56a68",
    ];

    for p in low_order_points {
        let point = hex::decode(p).unwrap();
        assert_eq!(point.len(), PublicKey::LENGTH);

        let pk = PublicKey::try_from(point.as_slice()).unwrap();

        // First, make sure group_check() identifies this point as a low-order point
        assert!(pk.subgroup_check().is_err());

        // Second, make sure our Validatable<PublicKey> implementation agrees with group_check
        let validatable = Validatable::<PublicKey>::from_unvalidated(pk.to_unvalidated());
        assert!(validatable.validate().is_err());
    }
}
```

**File:** crates/aptos-dkg/README.md (L55-58)
```markdown
We (mostly) rely on the `aptos-crypto` `SerializeKey` and `DeserializeKey` derives for safety during deserialization.
Specifically, each cryptographic object (e.g., public key, public parameters, etc) must implement `ValidCryptoMaterial` for serialization and `TryFrom` for deserialization when these derives are used.

The G1/G2 group elements in `blstrs` are deserialized safely via calls to `from_[un]compressed` rather than calls to `from_[un]compressed_unchecked` which does not check prime-order subgroup membership.
```
