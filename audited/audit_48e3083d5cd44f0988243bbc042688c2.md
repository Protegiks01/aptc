# Audit Report

## Title
On-Chain Config Deserialization Failure Causes Validator State Divergence During Network Upgrades

## Summary
During network upgrades, validators running different software versions can deserialize on-chain configurations differently, leading to state divergence and consensus failures. When new config variants are written on-chain before all validators have upgraded, upgraded validators successfully deserialize the new config while non-upgraded validators silently fall back to defaults, causing them to execute blocks with different parameters and produce different state roots. [1](#0-0) 

## Finding Description

The vulnerability exists in the on-chain configuration update mechanism. Both `OnChainConsensusConfig` and `OnChainExecutionConfig` use versioned enum variants (V1, V2, V3, etc.) that are serialized using BCS and stored as raw `vector<u8>` on-chain. [2](#0-1) 

When a governance proposal updates these configs, the Move code only validates that the bytes are non-empty, with no check that the bytes are valid BCS or that all validators can deserialize them: [3](#0-2) 

At epoch boundaries, validators read these configs using double BCS deserialization: [4](#0-3) 

If deserialization fails (e.g., an old validator encounters a V8 variant it doesn't recognize), the error is logged but validators silently fall back to default values rather than halting: [5](#0-4) 

**Attack Scenario:**

1. Network has 70% validators on version N+1 (supporting ExecutionConfig::V8), 30% on version N
2. A governance proposal created with N+1 tooling sets ExecutionConfig to V8
3. Proposal passes with 70% support and writes V8 bytes on-chain
4. At next epoch, validators attempt to read the config:
   - **Upgraded validators (70%)**: Successfully deserialize V8, use new execution parameters (e.g., new transaction shuffler)
   - **Non-upgraded validators (30%)**: Fail to deserialize, fall back to `OnChainExecutionConfig::default_if_missing()` = `Missing`, use old execution parameters
5. Validators execute blocks with different shuffling/gas limit parameters
6. **State roots diverge**, consensus fails, network partitions

This breaks the **Deterministic Execution** invariant: validators produce different state roots for identical blocks.

## Impact Explanation

**Critical Severity** - This vulnerability can cause:

1. **Consensus Safety Violations**: Validators cannot reach agreement on block state roots, leading to consensus failure
2. **Network Partition**: The network splits between upgraded and non-upgraded validators, requiring manual intervention or hard fork to recover
3. **State Inconsistency**: Different validators maintain different canonical state, violating blockchain integrity

The impact qualifies as **Critical** per Aptos bug bounty criteria:
- "Consensus/Safety violations" 
- "Non-recoverable network partition (requires hardfork)"

The vulnerability affects all validators during network upgrades, making it a systemic risk rather than isolated to specific nodes.

## Likelihood Explanation

**High Likelihood** during network upgrades:

1. **Common Scenario**: Network upgrades are routine operations where validators gradually adopt new versions
2. **No Safeguards**: There is no code enforcement that all validators must upgrade before new config variants are used: [6](#0-5) 
3. **Governance Process**: Config updates go through governance which may not coordinate with validator upgrade status
4. **Silent Failures**: Deserialization failures produce warnings, not errors, so the divergence isn't immediately apparent

The vulnerability could trigger through:
- Premature governance proposals during rolling upgrades
- Tooling bugs that serialize unsupported variants
- Miscommunication between governance and validator operators
- Malicious proposals (though governance is considered trusted)

## Recommendation

**Immediate Fixes:**

1. **Add Config Validation**: Validate that config bytes are deserializable before accepting proposals:

```move
// In execution_config.move and consensus_config.move
public fun set_for_next_epoch(account: &signer, config: vector<u8>) {
    system_addresses::assert_aptos_framework(account);
    assert!(vector::length(&config) > 0, error::invalid_argument(EINVALID_CONFIG));
    
    // ADD: Validate deserialization via native function
    assert!(
        validate_execution_config_bytes(config),
        error::invalid_argument(EINVALID_CONFIG)
    );
    
    config_buffer::upsert(ExecutionConfig { config });
}

native fun validate_execution_config_bytes(config_bytes: vector<u8>): bool;
```

2. **Version Coordination Check**: Add a check that config variants are only accepted if all active validators support them:

```rust
// In consensus/src/epoch_manager.rs
async fn start_new_epoch(&mut self, payload: OnChainConfigPayload<P>) {
    // ... existing code ...
    
    let onchain_consensus_config: anyhow::Result<OnChainConsensusConfig> = payload.get();
    
    if let Err(error) = &onchain_consensus_config {
        // CHANGE: Halt instead of continuing with default
        panic!(
            "CRITICAL: Failed to deserialize on-chain consensus config at epoch {}. \
             This indicates the config variant is not supported by this validator version. \
             Error: {}",
            payload.epoch(),
            error
        );
    }
    
    let consensus_config = onchain_consensus_config.unwrap(); // Safe after check
    // ... rest of code ...
}
```

3. **Add Version Compatibility Metadata**: Include minimum required validator version in config updates to prevent premature activation.

## Proof of Concept

**Reproduction Steps:**

1. Start network with all validators on version supporting ExecutionConfig::V1-V7
2. Upgrade 70% of validators to version supporting V8  
3. Submit governance proposal via upgraded validator:
```rust
// Using v8-aware tooling
let execution_config_v8 = OnChainExecutionConfig::V8(ExecutionConfigV8 { 
    // ... new fields ...
});
let bytes = bcs::to_bytes(&bcs::to_bytes(&execution_config_v8)?)?;

// Governance proposal
execution_config::set_for_next_epoch(&framework_signer, bytes);
aptos_governance::reconfigure(&framework_signer);
```
4. At next epoch, observe:
   - Upgraded validators log: "Using ExecutionConfig V8"
   - Non-upgraded validators log: "Failed to read on-chain execution config" and use Missing
5. Execute transaction block - validators produce different state roots
6. Consensus fails with "State root mismatch" errors

**Expected Result**: Network partition between upgraded and non-upgraded validators requiring manual recovery.

---

**Notes:**

This vulnerability is particularly dangerous because:
- It occurs during routine network operations (upgrades)
- The failure mode is silent (warnings, not errors)
- It affects consensus safety, not just liveness
- Recovery requires manual intervention or hard fork
- The issue affects ANY on-chain config update, not just execution/consensus configs

The root cause is insufficient validation at the governance layer combined with overly permissive error handling at the consensus layer.

### Citations

**File:** consensus/src/epoch_manager.rs (L1178-1205)
```rust
        let onchain_consensus_config: anyhow::Result<OnChainConsensusConfig> = payload.get();
        let onchain_execution_config: anyhow::Result<OnChainExecutionConfig> = payload.get();
        let onchain_randomness_config_seq_num: anyhow::Result<RandomnessConfigSeqNum> =
            payload.get();
        let randomness_config_move_struct: anyhow::Result<RandomnessConfigMoveStruct> =
            payload.get();
        let onchain_jwk_consensus_config: anyhow::Result<OnChainJWKConsensusConfig> = payload.get();
        let dkg_state = payload.get::<DKGState>();

        if let Err(error) = &onchain_consensus_config {
            warn!("Failed to read on-chain consensus config {}", error);
        }

        if let Err(error) = &onchain_execution_config {
            warn!("Failed to read on-chain execution config {}", error);
        }

        if let Err(error) = &randomness_config_move_struct {
            warn!("Failed to read on-chain randomness config {}", error);
        }

        self.epoch_state = Some(epoch_state.clone());

        let consensus_config = onchain_consensus_config.unwrap_or_default();
        let execution_config = onchain_execution_config
            .unwrap_or_else(|_| OnChainExecutionConfig::default_if_missing());
        let onchain_randomness_config_seq_num = onchain_randomness_config_seq_num
            .unwrap_or_else(|_| RandomnessConfigSeqNum::default_if_missing());
```

**File:** types/src/on_chain_config/execution_config.rs (L10-24)
```rust
/// The on-chain execution config, in order to be able to add fields, we use enum to wrap the actual struct.
#[derive(Clone, Debug, Deserialize, PartialEq, Eq, Serialize)]
pub enum OnChainExecutionConfig {
    V1(ExecutionConfigV1),
    V2(ExecutionConfigV2),
    V3(ExecutionConfigV3),
    /// To maintain backwards compatibility on replay, we must ensure that any new features resolve
    /// to previous behavior (before OnChainExecutionConfig was registered) in case of Missing.
    Missing,
    // Reminder: Add V4 and future versions here, after Missing (order matters for enums).
    V4(ExecutionConfigV4),
    V5(ExecutionConfigV5),
    V6(ExecutionConfigV6),
    V7(ExecutionConfigV7),
}
```

**File:** types/src/on_chain_config/execution_config.rs (L169-173)
```rust
    fn deserialize_into_config(bytes: &[u8]) -> Result<Self> {
        let raw_bytes: Vec<u8> = bcs::from_bytes(bytes)?;
        bcs::from_bytes(&raw_bytes)
            .map_err(|e| format_err!("[on-chain config] Failed to deserialize into config: {}", e))
    }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/execution_config.move (L48-52)
```text
    public fun set_for_next_epoch(account: &signer, config: vector<u8>) {
        system_addresses::assert_aptos_framework(account);
        assert!(vector::length(&config) > 0, error::invalid_argument(EINVALID_CONFIG));
        config_buffer::upsert(ExecutionConfig { config });
    }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/consensus_config.move (L52-56)
```text
    public fun set_for_next_epoch(account: &signer, config: vector<u8>) {
        system_addresses::assert_aptos_framework(account);
        assert!(vector::length(&config) > 0, error::invalid_argument(EINVALID_CONFIG));
        std::config_buffer::upsert<ConsensusConfig>(ConsensusConfig {config});
    }
```
