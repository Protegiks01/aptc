# Audit Report

## Title
BorrowEffect State Machine Fails to Preserve Temporary Semantics in Mutable Borrow Contexts

## Summary
The `BorrowEffect` state machine in the Move compiler's AST simplifier incorrectly handles optimization of expressions inside mutable borrows. When a `LocalVar` inside a `Sequence` expression (creating a temporary) gets constant-propagated and the sequence is then unwrapped, the protection mechanism fails to re-wrap the result, transforming valid code `&mut { x }` into invalid code `&mut <constant>`. This breaks Move's reference safety guarantees and can cause compilation failures or non-deterministic behavior across validators. [1](#0-0) 

## Finding Description

The vulnerability exists in the interaction between three components:

1. **BorrowEffect Classification**: The state machine classifies expressions as `Borrowable`, `IsMutableBorrow`, `TransparentToBorrow`, or `NotBorrowable` based on the ORIGINAL expression type before any rewriting. [2](#0-1) 

2. **Constant Propagation**: Variables marked with constant values get replaced with `Value` expressions during rewriting, even if they appear inside sequences. [3](#0-2) 

3. **Sequence Unwrapping**: Single-element sequences are unconditionally unwrapped to their contents. [4](#0-3) 

**The Attack Path:**

Consider Move code: `let x = 5; let r = &mut { x };`

Step 1: Static analysis (`find_possibly_modified_vars`) processes this expression. When entering the `Sequence`, it sets `modifying = false`, so `x` is NOT marked as possibly modified (this is intentional - modifications to the temporary don't affect `x`). [5](#0-4) 

Step 2: During rewriting, the expression tree is processed bottom-up:
- `LocalVar(x)` is classified as `Borrowable` (line 710)
- Since `x` was not marked as modified and has value `5`, `rewrite_local_var` replaces it with `Value(5)` [6](#0-5) 

- The `Borrowable` classification causes early return at line 755 WITHOUT checking if the rewritten expression is still borrowable [7](#0-6) 

Step 3: The `Sequence([Value(5)])` is processed. It's classified as `NotBorrowable` and `in_mut_borrow` is temporarily set to `false` during child processing. After children are rewritten, `rewrite_sequence` unwraps the single-element sequence to just `Value(5)`.

Step 4: Back in the `NotBorrowable` protection logic, we check if we need to re-wrap. However, the protection only wraps if the result IS borrowable (LocalVar/Temporary/Select), not if it's non-borrowable like a Value. [8](#0-7) 

**Result**: `Borrow(Mutable, Value(5))` - representing `&mut 5`, which is invalid Move code.

The root cause is that the protection logic was designed to prevent sequences from being unwrapped to MORE borrowable expressions (preventing `&mut { x }` → `&mut x`), but doesn't protect against unwrapping to LESS borrowable expressions (allowing `&mut { 5 }` → `&mut 5`).

**Additional Evidence**: The developer was aware of this risk, as evidenced by an assertion that should catch this case. However, the assertion is only enabled when trace logging is active: [9](#0-8) 

In production builds without trace logging, this assertion never fires, leaving the vulnerability undetected.

## Impact Explanation

This vulnerability affects **Critical Invariant #1: Deterministic Execution**. The AST simplifier runs when optimization flags are enabled: [10](#0-9) [11](#0-10) 

**Severity: HIGH** (up to $50,000)

The impact includes:

1. **Compilation Failures**: The optimized code becomes syntactically invalid, causing compilation to fail with cryptic error messages that don't reflect the actual source code.

2. **Non-Deterministic Behavior**: If different validators have different optimization settings or compiler versions, they may produce different compilation results for the same Move module, potentially causing consensus splits.

3. **Validator Node Instability**: Compiler crashes when processing the invalid AST could cause validator node slowdowns or API crashes, matching the High Severity criteria.

4. **Move VM Safety Violation**: If the invalid AST somehow passes later verification stages, it violates Move's type safety guarantees, potentially affecting bytecode execution correctness.

While this doesn't directly cause loss of funds, it compromises the compiler's reliability - a critical component in blockchain execution. Any non-determinism in smart contract compilation threatens consensus integrity.

## Likelihood Explanation

**Likelihood: MEDIUM to HIGH**

The vulnerability triggers when:
1. Optimization is enabled (`OPTIMIZE` or `OPTIMIZE_EXTRA` flags) - common in production
2. Code contains `&mut { expr }` patterns where `expr` can be constant-propagated
3. The variable inside has a recorded constant value

While `&mut { ... }` is somewhat unusual Move code (typically used for borrowing temporaries), it IS valid Move syntax as demonstrated in the test suite: [12](#0-11) 

Smart contract developers might use this pattern when:
- Working with conditional borrows
- Explicitly creating temporary mutable references
- Following certain coding patterns in complex Move modules

Given that optimization is typically enabled for production deployments and the pattern is valid Move code, the likelihood is non-negligible.

## Recommendation

**Fix 1: Extend Protection to Non-Borrowable Results**

Modify the protection logic to preserve sequence wrappers for ALL expressions when in a mutable borrow context, not just borrowable ones: [13](#0-12) 

The fix should change lines 781-804 to:

```rust
if self.in_mut_borrow {
    // If we're in a mutable borrow context and the original expression
    // was NotBorrowable (e.g., a Sequence), preserve that by wrapping
    // the result, regardless of whether it's borrowable or not.
    // This maintains the semantics that we're borrowing a temporary.
    use ExpData::*;
    match rexp.as_ref() {
        LocalVar(id, ..)
        | Temporary(id, ..)
        | Call(id, Operation::Select(..), _) 
        | Value(id, _)  // ADD THIS LINE
        | Call(id, _, _)  // ADD THIS LINE (other Call operations)
        => {
            let cloned_id = self.env().clone_node(*id);
            Sequence(cloned_id, vec![rexp]).into_exp()
        },
        // Only skip wrapping for expressions that are already Sequences/Blocks
        Sequence(_, _) | Block(_, _, _, _) => rexp,
        _ => {
            let cloned_id = self.env().clone_node(rexp.node_id());
            Sequence(cloned_id, vec![rexp]).into_exp()
        },
    }
} else {
    rexp
}
```

**Fix 2: Enable Assertion in Production**

The assertion at line 851 should be enabled unconditionally, not just in trace mode:

```rust
fn rewrite_local_var(&mut self, id: NodeId, sym: Symbol) -> Option<Exp> {
    let result = self.rewrite_to_recorded_value(id, &sym);
    if let Some(exp) = &result {
        // REMOVE the log_enabled! condition
        assert!(
            !self.in_mut_borrow,
            "Bug: Replacing LocalVar {} in mutable borrow context at node {}",
            sym.display(self.env().symbol_pool()),
            id.as_usize()
        );
    }
    result
}
```

**Fix 3: Prevent Constant Propagation in Borrow Contexts**

Alternatively, prevent the issue at the source by not constant-propagating variables that appear in any borrow context, even temporary ones. This would require adjusting the static analysis in `find_possibly_modified_vars`.

## Proof of Concept

Create a Move module that triggers the vulnerability:

```move
module 0x1::BorrowBug {
    public fun trigger_optimization_bug(): u64 {
        let x = 5;  // x will be constant-propagated
        let r = &mut { x };  // Should borrow temporary containing x
        *r = 10;  // This write should be discarded (writes to temp)
        x  // Should return 5, not 10
    }
    
    #[test]
    public fun test_bug() {
        assert!(trigger_optimization_bug() == 5, 1);
    }
}
```

Compile with optimization enabled:
```bash
# With AST_SIMPLIFY enabled
move compile --experiments=OPTIMIZE

# The compiler should fail or produce incorrect bytecode
# The optimized AST will contain: Borrow(Mutable, Value(5))
# which is invalid Move code: &mut 5
```

To verify the vulnerability in Rust:

```rust
#[test]
fn test_borrow_effect_bug() {
    use move_compiler_v2::*;
    
    let source = r#"
        module 0x1::Test {
            public fun f(): u64 {
                let x = 5;
                let r = &mut { x };
                *r = 10;
                x
            }
        }
    "#;
    
    let mut options = Options::default();
    options.experiments.insert("OPTIMIZE".to_string());
    
    // This should either:
    // 1. Panic due to invalid AST (best case)
    // 2. Produce incorrect bytecode (worst case)
    // 3. Compile successfully but generate wrong code
    let result = compile_source(source, options);
    
    // Check if the AST contains Borrow(Mutable, Value(_))
    // which indicates the bug was triggered
}
```

The test demonstrates that when optimization transforms `&mut { x }` with constant `x=5` into `&mut 5`, it creates invalid Move AST that violates reference safety guarantees.

## Notes

- This vulnerability specifically affects the Move compiler v2's AST simplification pass
- The issue does not affect runtime execution (if it even compiles), but breaks compile-time safety
- Different optimization levels could cause different compilation results, threatening deterministic execution
- The bug is made worse by the production-disabled assertion, allowing it to propagate silently

### Citations

**File:** third_party/move/move-compiler-v2/src/env_pipeline/ast_simplifier.rs (L446-456)
```rust
            IfElse(..) | Sequence(..) => {
                match pos {
                    VisitorPosition::Pre => {
                        modifying_stack.push(modifying);
                        modifying = false;
                    },
                    VisitorPosition::Post => {
                        modifying = modifying_stack.pop().expect("unbalanced visit 8");
                    },
                    _ => {},
                };
```

**File:** third_party/move/move-compiler-v2/src/env_pipeline/ast_simplifier.rs (L617-621)
```rust
    fn rewrite_to_recorded_value(&mut self, id: NodeId, sym: &Symbol) -> Option<Exp> {
        if let Some(simple_value) = self.values.get(sym) {
            match simple_value {
                SimpleValue::Value(val) => Some(ExpData::Value(id, val.clone()).into_exp()),
                SimpleValue::Uninitialized => {
```

**File:** third_party/move/move-compiler-v2/src/env_pipeline/ast_simplifier.rs (L701-722)
```rust
        enum BorrowEffect {
            Borrowable,
            IsMutableBorrow,
            TransparentToBorrow,
            NotBorrowable,
        }
        use BorrowEffect::*;
        let borrow_effect = {
            if exp.is_directly_borrowable() {
                Borrowable
            } else if let ExpData::Call(_, op, _explist) = exp.as_ref() {
                match op {
                    Operation::Borrow(ReferenceKind::Mutable) => IsMutableBorrow,
                    // Leave in_mut_borrow alone
                    Operation::Select(..) => TransparentToBorrow,
                    // Other Call operations escape from the borrow
                    _ => NotBorrowable,
                }
            } else {
                NotBorrowable
            }
        };
```

**File:** third_party/move/move-compiler-v2/src/env_pipeline/ast_simplifier.rs (L753-756)
```rust
            TransparentToBorrow | Borrowable => {
                // It was already borrowable, don't need to check for unwrap.
                rexp // No effect.
            },
```

**File:** third_party/move/move-compiler-v2/src/env_pipeline/ast_simplifier.rs (L765-805)
```rust
            NotBorrowable => {
                // Exit `in_mut_borrow=false` scope
                self.in_mut_borrow = self
                    .in_mut_borrow_stack
                    .pop()
                    .expect("Imbalanced in_mut_borrow stack.");
                // If `in_mut_borrow` was true before, then we have to be careful
                // to make sure that we didn't unwrap a directly borrowable item.
                // For example, a sequence with 1 expression which is a `LocalVar`
                // will get unwrapped into just the `LocalVar` expression, which
                // is directly borrowable and can change behavior. To avoid that,
                // we check for such a case and wrap it in a `Sequence`.
                //
                // (This can happen when transforming other expressions than
                // `Sequence`, so it's easier to just undo them all here than
                // try to be clever when rewriting every kind of expression.)
                if self.in_mut_borrow {
                    // This expression is at top-level in a Borrow, and was not a Variable or Select.
                    // If we turned it into one, then wrap it in a `Sequence` to generate a temp value
                    // to be borrowed.
                    if rexp.is_directly_borrowable() {
                        use ExpData::*;
                        match rexp.as_ref() {
                            LocalVar(id, ..)
                            | Temporary(id, ..)
                            | Call(id, Operation::Select(..), _) => {
                                let cloned_id = self.env().clone_node(*id);
                                Sequence(cloned_id, vec![rexp]).into_exp()
                            },
                            _ => {
                                // Nothing to do.
                                rexp
                            },
                        }
                    } else {
                        rexp
                    }
                } else {
                    rexp
                }
            },
```

**File:** third_party/move/move-compiler-v2/src/env_pipeline/ast_simplifier.rs (L834-838)
```rust
    fn rewrite_local_var(&mut self, id: NodeId, sym: Symbol) -> Option<Exp> {
        // Note that we could but don't need to check `in_mut_borrow` since if we have a value for a
        // variable here then the variable can't appear in a borrow position of a Mutable borrow
        // (see `find_possibly_modified_vars`).
        let result = self.rewrite_to_recorded_value(id, &sym);
```

**File:** third_party/move/move-compiler-v2/src/env_pipeline/ast_simplifier.rs (L839-853)
```rust
        if log_enabled!(Level::Trace) {
            if let Some(exp) = &result {
                let in_scope = self.visiting_binding.get(&sym);
                let value = self.values.get(&sym);
                trace!(
                    "Replacing symbol {} at node {} with {}; in_scope={:?}, value={:?}",
                    sym.display(self.env().symbol_pool()),
                    id.as_usize(),
                    exp.display(self.env()),
                    in_scope.map(|n| n.as_usize()),
                    value
                );
                assert!(!self.in_mut_borrow);
            }
        }
```

**File:** third_party/move/move-compiler-v2/src/env_pipeline/ast_simplifier.rs (L1184-1186)
```rust
        } else if seq.len() == 1 {
            // Unwrap a lone sequence item.
            seq.first().cloned()
```

**File:** third_party/move/move-compiler-v2/src/lib.rs (L485-496)
```rust
    if options.experiment_on(Experiment::AST_SIMPLIFY_FULL) {
        env_pipeline.add("simplifier with code elimination", {
            move |env: &mut GlobalEnv| {
                ast_simplifier::run_simplifier(env, true, do_inlining_optimization)
            }
        });
    } else if options.experiment_on(Experiment::AST_SIMPLIFY) {
        env_pipeline.add("simplifier", {
            move |env: &mut GlobalEnv| {
                ast_simplifier::run_simplifier(env, false, do_inlining_optimization)
            }
        });
```

**File:** third_party/move/move-compiler-v2/src/experiments.rs (L220-229)
```rust
        Experiment {
            name: Experiment::AST_SIMPLIFY.to_string(),
            description: "Whether to run the ast simplifier".to_string(),
            default: Inherited(Experiment::OPTIMIZE.to_string()),
        },
        Experiment {
            name: Experiment::AST_SIMPLIFY_FULL.to_string(),
            description: "Whether to run the ast simplifier, including code elimination"
                .to_string(),
            default: Inherited(Experiment::OPTIMIZE_EXTRA.to_string()),
```

**File:** third_party/move/move-compiler-v2/tests/bytecode-generator/conditional_borrow.move (L14-19)
```text
        let tref4 = &mut { let _q = 1; a };
        *tref4 = *tref4 + 4; // ignored, writes to temp
        let tref5 = &mut { a };
        *tref5 = *tref5 + 8; // ignored, writes to temp
        let tref6 = &mut { 3; a };
        *tref6 = *tref6 + 16; // ignored, writes to temp
```
