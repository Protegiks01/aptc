# Audit Report

## Title
Silent Failure in Consensus Key Rotation Due to Improper Error Handling in SafetyRules Initialization

## Summary
The SafetyRules initialization process silently suppresses errors when loading overriding consensus keys during validator startup through improper use of `.unwrap_or_default()`. This causes validators to appear operational but lack the new consensus key needed after on-chain key rotation, resulting in validator downtime, loss of staking rewards, and potential network liveness issues.

## Finding Description

The vulnerability exists in the `storage()` function within the SafetyRules initialization path. When a validator operator performs consensus key rotation, they configure new key file paths in `overriding_identity_paths` and restart the validator to load these keys into secure storage. [1](#0-0) 

The critical flaw is that any error from `overriding_identity_blobs()` is silently converted to an empty vector by `.unwrap_or_default()`, with no error logging whatsoever. The `overriding_identity_blobs()` function properly returns a `Result` type that can fail when: [2](#0-1) 

File loading failures occur through `IdentityBlob::from_file()`: [3](#0-2) 

**Attack Flow:**
1. Validator operator generates new consensus key and adds file path to `overriding_identity_paths` config
2. Validator restarts, triggering `SafetyRulesManager::new()` â†’ `storage()`
3. File loading fails (permission denied, file not found, corrupt YAML) - error silently suppressed
4. For-loop at lines 81-98 processes empty vector, storing no keys
5. Validator continues running, appearing healthy with only the old key
6. Operator submits on-chain key rotation transaction (succeeds as transaction is valid)
7. At next epoch boundary, `guarded_initialize()` attempts key reconciliation: [4](#0-3) 

8. It calls `consensus_sk_by_pk(expected_key)` to load the new key: [5](#0-4) 

9. Key lookup fails because it was never stored (due to silent failure at step 3)
10. Validator returns `Error::ValidatorKeyNotFound` and cannot participate in consensus
11. Validator goes offline, losing staking rewards

The expected workflow is demonstrated in the smoke test: [6](#0-5) 

## Impact Explanation

This vulnerability meets **High Severity** criteria per Aptos bug bounty program:

**Primary Impact - Validator Node Failures (HIGH):**
- Validators go offline immediately when epoch transition activates the rotated key
- Complete loss of consensus participation capability
- Explicitly listed as HIGH severity: "Validator node slowdowns/failures"

**Secondary Impacts:**
- **Economic Loss**: Validators lose all staking rewards during downtime and may face penalties
- **Network Liveness Risk**: If multiple validator operators experience this simultaneously during coordinated key rotations, it could impact consensus quorum
- **Silent Failure**: Zero indication of failure until epoch transition - by then on-chain rotation is committed and irreversible

The severity is amplified because:
1. No warning exists that key loading failed
2. Validator health checks pass until epoch transition
3. On-chain rotation cannot be reverted once committed
4. Recovery requires manual diagnosis and validator restart with correct configuration
5. Window between restart and key rotation creates false confidence

## Likelihood Explanation

**Likelihood: Medium to High**

This vulnerability triggers through common operational scenarios without requiring any attacker action:

**Realistic Trigger Scenarios:**
1. **File System Issues**: Permission denied (incorrect file ownership after deployment), file not found (wrong path), disk I/O errors
2. **Configuration Errors**: Typo in file path, relative vs absolute path confusion, missing directory
3. **YAML Corruption**: Incomplete file write during deployment, syntax errors, encoding issues
4. **Deployment Race Conditions**: Config updated but file not yet synced across infrastructure
5. **Container/Orchestration Issues**: Volume mount failures, secret injection timing in Kubernetes

**High Probability Contexts:**
- Routine consensus key rotations (recommended security best practice)
- Emergency key rotations after suspected compromise (time pressure increases error likelihood)
- Validator infrastructure migrations
- Automated deployment pipelines with imperfect file synchronization
- Multi-region deployments with replication delays

**No Attacker Required**: Normal operational errors during legitimate security operations trigger this vulnerability. The complexity of validator infrastructure (secure storage, file systems, orchestration) makes such errors realistic.

## Recommendation

Replace `.unwrap_or_default()` with explicit error handling that logs and either panics or returns an error:

```rust
// In consensus/safety-rules/src/safety_rules_manager.rs, lines 81-84
let timer = Instant::now();
let overriding_blobs = config
    .initial_safety_rules_config
    .overriding_identity_blobs()
    .expect("Failed to load overriding identity blobs - check file paths and permissions");

for blob in overriding_blobs {
    if let Some(sk) = blob.consensus_private_key {
        let pk_hex = hex::encode(PublicKey::from(&sk).to_bytes());
        let storage_key = format!("{}_{}", CONSENSUS_KEY, pk_hex);
        match storage.internal_store().set(storage_key.as_str(), sk) {
            Ok(_) => {
                info!("Setting {storage_key} succeeded.");
            },
            Err(e) => {
                error!("Setting {storage_key} failed with internal store set error: {e}");
                // Consider panicking here as well since missing keys will cause failure later
            },
        }
    }
}
```

Alternative: Add validation after restart that verifies all configured overriding keys are present in storage before allowing the validator to proceed.

## Proof of Concept

While a full PoC would require a running validator node, the vulnerability can be validated through code inspection:

1. Configure `overriding_identity_paths` with a non-existent file path
2. Restart validator - it will start successfully (silent failure)
3. Submit on-chain key rotation transaction
4. Wait for epoch transition
5. Observe validator fail with `ValidatorKeyNotFound` error

The code path is deterministic: `.unwrap_or_default()` at line 84 will always suppress errors and return an empty vector, preventing key storage, which will cause `consensus_sk_by_pk()` to fail during epoch initialization.

## Notes

- The related `identity_blob()` function properly uses `.expect()` for error handling, demonstrating inconsistent error handling patterns within the same codebase
- The only logging occurs when keys are successfully stored (line 91) or when storage operations fail (line 94), but there is no logging when `overriding_identity_blobs()` itself fails
- This is distinct from network DoS attacks - it's an operational reliability bug in the key rotation workflow that affects individual validators through configuration/deployment errors

### Citations

**File:** consensus/safety-rules/src/safety_rules_manager.rs (L81-84)
```rust
        for blob in config
            .initial_safety_rules_config
            .overriding_identity_blobs()
            .unwrap_or_default()
```

**File:** config/src/config/safety_rules_config.rs (L170-187)
```rust
    pub fn overriding_identity_blobs(&self) -> anyhow::Result<Vec<IdentityBlob>> {
        match self {
            InitialSafetyRulesConfig::FromFile {
                overriding_identity_paths,
                ..
            } => {
                let mut blobs = vec![];
                for path in overriding_identity_paths {
                    let blob = IdentityBlob::from_file(path)?;
                    blobs.push(blob);
                }
                Ok(blobs)
            },
            InitialSafetyRulesConfig::None => {
                bail!("loading overriding identity blobs failed with missing initial safety rules config")
            },
        }
    }
```

**File:** config/src/config/identity_config.rs (L40-42)
```rust
    pub fn from_file(path: &Path) -> anyhow::Result<IdentityBlob> {
        Ok(serde_yaml::from_str(&fs::read_to_string(path)?)?)
    }
```

**File:** consensus/safety-rules/src/safety_rules.rs (L312-344)
```rust
        let author = self.persistent_storage.author()?;
        let expected_key = epoch_state.verifier.get_public_key(&author);
        let initialize_result = match expected_key {
            None => Err(Error::ValidatorNotInSet(author.to_string())),
            Some(expected_key) => {
                let current_key = self.signer().ok().map(|s| s.public_key());
                if current_key == Some(expected_key.clone()) {
                    info!(
                        SafetyLogSchema::new(LogEntry::KeyReconciliation, LogEvent::Success),
                        "in set",
                    );
                    Ok(())
                } else {
                    // Try to export the consensus key directly from storage.
                    match self.persistent_storage.consensus_sk_by_pk(expected_key) {
                        Ok(consensus_key) => {
                            self.validator_signer =
                                Some(ValidatorSigner::new(author, Arc::new(consensus_key)));
                            Ok(())
                        },
                        Err(Error::SecureStorageMissingDataError(error)) => {
                            Err(Error::ValidatorKeyNotFound(error))
                        },
                        Err(error) => Err(error),
                    }
                }
            },
        };
        initialize_result.inspect_err(|error| {
            info!(SafetyLogSchema::new(LogEntry::KeyReconciliation, LogEvent::Error).error(error),);
            self.validator_signer = None;
        })
    }
```

**File:** consensus/safety-rules/src/persistent_safety_storage.rs (L106-132)
```rust
    pub fn consensus_sk_by_pk(
        &self,
        pk: bls12381::PublicKey,
    ) -> Result<bls12381::PrivateKey, Error> {
        let _timer = counters::start_timer("get", CONSENSUS_KEY);
        let pk_hex = hex::encode(pk.to_bytes());
        let explicit_storage_key = format!("{}_{}", CONSENSUS_KEY, pk_hex);
        let explicit_sk = self
            .internal_store
            .get::<bls12381::PrivateKey>(explicit_storage_key.as_str())
            .map(|v| v.value);
        let default_sk = self.default_consensus_sk();
        let key = match (explicit_sk, default_sk) {
            (Ok(sk_0), _) => sk_0,
            (Err(_), Ok(sk_1)) => sk_1,
            (Err(_), Err(_)) => {
                return Err(Error::ValidatorKeyNotFound("not found!".to_string()));
            },
        };
        if key.public_key() != pk {
            return Err(Error::SecureStorageMissingDataError(format!(
                "Incorrect sk saved for {:?} the expected pk",
                pk
            )));
        }
        Ok(key)
    }
```

**File:** testsuite/smoke-test/src/consensus_key_rotation.rs (L67-116)
```rust
            let new_identity_path = PathBuf::from(
                format!(
                    "/tmp/{}-new-validator-identity.yaml",
                    thread_rng().r#gen::<u64>()
                )
                .as_str(),
            );
            info!(
                "Generating and writing new validator identity to {:?}.",
                new_identity_path
            );
            let new_sk = bls12381::PrivateKey::generate(&mut thread_rng());
            let pop = bls12381::ProofOfPossession::create(&new_sk);
            let new_pk = bls12381::PublicKey::from(&new_sk);
            let mut validator_identity_blob = validator
                .config()
                .consensus
                .safety_rules
                .initial_safety_rules_config
                .identity_blob()
                .unwrap();
            validator_identity_blob.consensus_private_key = Some(new_sk);
            let operator_addr = validator_identity_blob.account_address.unwrap();

            Write::write_all(
                &mut File::create(&new_identity_path).unwrap(),
                serde_yaml::to_string(&validator_identity_blob)
                    .unwrap()
                    .as_bytes(),
            )
            .unwrap();

            info!("Updating the node config accordingly.");
            let config_path = validator.config_path();
            let mut validator_override_config =
                OverrideNodeConfig::load_config(config_path.clone()).unwrap();
            validator_override_config
                .override_config_mut()
                .consensus
                .safety_rules
                .initial_safety_rules_config
                .overriding_identity_blob_paths_mut()
                .push(new_identity_path);
            validator_override_config.save_config(config_path).unwrap();

            info!("Restarting the node.");
            validator.start().unwrap();
            info!("Let it bake for 5 secs.");
            tokio::time::sleep(Duration::from_secs(5)).await;
            (operator_addr, new_pk, pop, operator_idx)
```
