# Audit Report

## Title
Unbounded Memory Growth in TapCaptchaChecker Enables Denial-of-Service Attack on Faucet Service

## Summary
The `TapCaptchaChecker` implementation contains an unbounded in-memory `HashMap` that stores captcha challenges without any cleanup mechanism, size limits, or time-to-live (TTL). An attacker can exploit the unprotected `/request_captcha` endpoint to request millions of captcha challenges without solving them, causing the HashMap to grow indefinitely until the faucet service runs out of memory and crashes.

## Finding Description

The vulnerability exists in the captcha challenge management system of the Aptos Faucet service. The developers have explicitly documented this issue in a warning comment [1](#0-0) , but the vulnerability remains unmitigated in the production code.

The `CaptchaManager` struct stores all captcha challenges in an unbounded HashMap [2](#0-1) . When the `/request_captcha` endpoint is called [3](#0-2) , it invokes `create_challenge()` which generates a new captcha and inserts it into the HashMap [4](#0-3) .

**Critical Issues:**

1. **No Rate Limiting**: The `/request_captcha` endpoint has no rate limiting or authentication requirements. The `CaptchaApi` is initialized separately from the checker infrastructure [5](#0-4) , meaning it bypasses all rate limiting mechanisms that are only applied to the `/fund` endpoint [6](#0-5) .

2. **No Cleanup Mechanism**: Captcha entries are only removed when a user provides the **correct** answer [7](#0-6) . If the answer is incorrect or never provided, the entry remains in memory forever. The `TapCaptchaChecker` does not implement any periodic cleanup tasks (the default `spawn_periodic_tasks` implementation does nothing [8](#0-7) ).

3. **No Size Limits**: There are no bounds on the HashMap size, no maximum number of outstanding challenges, and no time-based expiration.

**Attack Path:**
1. Attacker sends millions of HTTP GET requests to `/request_captcha`
2. Each request creates a new HashMap entry via `self.challenges.insert(key, name)`
3. HashMap grows unbounded as no entries are removed
4. Server memory exhaustion leads to Out-of-Memory crash
5. Faucet service becomes unavailable, preventing legitimate users from obtaining test tokens

This breaks the **Resource Limits** invariant: "All operations must respect gas, storage, and computational limits."

## Impact Explanation

**Severity: CRITICAL**

This vulnerability qualifies as **Critical** severity under the Aptos Bug Bounty program criteria for "Total loss of liveness/network availability":

- **Complete Service Disruption**: An attacker can render the faucet service completely unavailable, preventing all users from obtaining test tokens needed for testnet/devnet operations.

- **Trivial Exploitation**: The attack requires no special privileges, authentication, or technical sophistication—just sending HTTP requests.

- **Cascading Effects**: Without access to test tokens, developers cannot test applications on testnet/devnet, validator operators cannot set up nodes, and the entire developer ecosystem is disrupted.

- **Infrastructure Impact**: While this doesn't directly affect mainnet consensus or validator nodes, the faucet is critical infrastructure for test networks and developer onboarding.

The vulnerability enables a resource exhaustion attack that violates the documented invariant requiring all operations to respect computational and memory limits.

## Likelihood Explanation

**Likelihood: HIGH**

This vulnerability is highly likely to be exploited for the following reasons:

1. **Zero Attack Complexity**: Exploitation requires only basic HTTP requests—no authentication, no cryptographic operations, no complex timing.

2. **Public Endpoint**: The `/request_captcha` endpoint is publicly accessible on all faucet deployments.

3. **No Detection Required**: An attacker doesn't need to discover or reverse-engineer anything—the vulnerability is explicitly documented in the source code comments.

4. **Low Resource Requirements**: An attacker can generate millions of requests using simple scripts or tools like `curl` in a loop or basic DDoS tools.

5. **Immediate Impact**: Unlike vulnerabilities requiring specific conditions or race conditions, this attack has deterministic, immediate impact.

6. **Developer Awareness**: The warning comment indicates developers are aware of the issue but haven't prioritized fixing it, suggesting it may remain exploitable for extended periods.

## Recommendation

Implement a multi-layered defense strategy:

**1. Add Rate Limiting to `/request_captcha` Endpoint**
Integrate the existing rate limiting infrastructure with the `CaptchaApi` by passing checkers to it, similar to how `FundApi` is configured.

**2. Implement Time-Based Expiration**
Add TTL (time-to-live) tracking to captcha challenges:
```rust
pub struct CaptchaManager {
    challenges: HashMap<u32, CaptchaChallenge>,
}

struct CaptchaChallenge {
    value: String,
    created_at: u64, // Unix timestamp
}
```

**3. Add Periodic Cleanup Task**
Implement `spawn_periodic_tasks` for `TapCaptchaChecker` to remove expired challenges:
```rust
impl CheckerTrait for TapCaptchaChecker {
    fn spawn_periodic_tasks(&self, join_set: &mut JoinSet<anyhow::Result<()>>) {
        let captcha_manager = self.captcha_manager.clone();
        join_set.spawn(async move {
            loop {
                tokio::time::sleep(Duration::from_secs(300)).await; // Clean every 5 minutes
                captcha_manager.lock().await.cleanup_expired(3600); // Remove entries older than 1 hour
            }
        });
    }
}
```

**4. Implement Size Limits**
Add a maximum capacity check in `create_challenge()`:
```rust
const MAX_CHALLENGES: usize = 10_000;

pub fn create_challenge(&mut self) -> Result<(u32, Vec<u8>)> {
    if self.challenges.len() >= MAX_CHALLENGES {
        bail!("Maximum number of outstanding captcha challenges reached");
    }
    // ... rest of implementation
}
```

**5. Remove on Failed Attempts**
Remove challenges after a configurable number of failed attempts to prevent accumulation from automated solvers.

## Proof of Concept

```bash
#!/bin/bash
# Simple PoC demonstrating unbounded memory growth

FAUCET_URL="http://localhost:8081" # Adjust to your faucet URL

echo "Starting captcha challenge spam attack..."
echo "This will continuously request captcha challenges without solving them"
echo "Monitor faucet service memory usage to observe unbounded growth"

# Request 1 million captcha challenges
for i in {1..1000000}; do
    curl -s "$FAUCET_URL/request_captcha" > /dev/null &
    
    # Display progress every 1000 requests
    if [ $((i % 1000)) -eq 0 ]; then
        echo "Sent $i captcha requests..."
    fi
    
    # Throttle to avoid overwhelming local network (remove for real attack)
    if [ $((i % 100)) -eq 0 ]; then
        sleep 0.1
    fi
done

wait
echo "Attack complete. Check faucet service memory usage."
```

**Expected Result**: After several thousand to tens of thousands of requests (depending on available memory), the faucet service will crash with an OOM error, making it unavailable for all users.

**Monitoring Command** (to observe memory growth):
```bash
while true; do
    ps aux | grep aptos-faucet | grep -v grep | awk '{print $6 " KB"}';
    sleep 5;
done
```

## Notes

This vulnerability demonstrates a critical gap in the faucet's defense-in-depth strategy. While rate limiting exists for the `/fund` endpoint, the `/request_captcha` endpoint—which feeds into the same in-memory data structure—has no such protection. The explicit warning comment in the source code confirms this is a known issue that has not been addressed, making it a high-priority security remediation target.

### Citations

**File:** crates/aptos-faucet/core/src/checkers/tap_captcha.rs (L4-6)
```rust
//! Warning: This could be attacked and cause the server to OOM because we
//! don't throw out captchas info if it has been sitting there for too long /
//! the map grows too large.
```

**File:** crates/aptos-faucet/core/src/checkers/tap_captcha.rs (L125-131)
```rust
#[derive(Debug, Default)]
pub struct CaptchaManager {
    /// When a challenge is created, we return to the client the captcha itself
    /// and a random key they must make the second request with. This is a map
    /// from that random key to the value of the captcha.
    challenges: HashMap<u32, String>,
}
```

**File:** crates/aptos-faucet/core/src/checkers/tap_captcha.rs (L142-162)
```rust
    pub fn create_challenge(&mut self) -> Result<(u32, Vec<u8>)> {
        // Generate a random key.
        let key = rand::thread_rng().gen_range(0, u32::MAX - 1);

        // Generate a captcha.
        let (name, image) = Captcha::new()
            .add_chars(5)
            .apply_filter(Noise::new(0.4))
            .apply_filter(Wave::new(4.0, 6.0).vertical())
            .apply_filter(Wave::new(3.0, 2.0).horizontal())
            .apply_filter(Grid::new(10, 6))
            .apply_filter(Dots::new(8))
            .as_tuple()
            .context("Failed to generate captcha")?;

        // Store the captcha information.
        self.challenges.insert(key, name);

        // Return (key, <captcha as base64>).
        Ok((key, image))
    }
```

**File:** crates/aptos-faucet/core/src/checkers/tap_captcha.rs (L165-177)
```rust
    pub fn check_challenge(&mut self, key: u32, value: &str) -> Result<bool> {
        match self.challenges.get(&key) {
            Some(captcha) => {
                if captcha == value {
                    self.challenges.remove(&key);
                    Ok(true)
                } else {
                    Ok(false)
                }
            },
            None => bail!("Captcha key unknown: {}", key),
        }
    }
```

**File:** crates/aptos-faucet/core/src/endpoints/captcha.rs (L40-58)
```rust
    async fn request_captcha(&self) -> Result<Response<Binary<Vec<u8>>>, AptosTapErrorResponse> {
        if !self.enabled {
            return Err(AptosTapError::new(
                "The CaptchaChecker is not enabled".to_string(),
                AptosTapErrorCode::EndpointNotEnabled,
            )
            .into());
        }
        let mut captcha_manager = self.captcha_manager.lock().await;
        let (key, image) = match captcha_manager.create_challenge() {
            Ok((key, image)) => (key, image),
            Err(e) => {
                return Err(
                    AptosTapError::new_with_error_code(e, AptosTapErrorCode::CheckerError).into(),
                );
            },
        };
        Ok(Response::new(Binary(image)).header(CAPTCHA_KEY, key))
    }
```

**File:** crates/aptos-faucet/core/src/server/run.rs (L145-152)
```rust
        // Using those, build the fund API components.
        let fund_api_components = Arc::new(FundApiComponents {
            bypassers,
            checkers,
            funder,
            return_rejections_early: self.handler_config.return_rejections_early,
            concurrent_requests_semaphore,
        });
```

**File:** crates/aptos-faucet/core/src/server/run.rs (L158-169)
```rust
        // Build the CaptchaApi.
        let mut tap_captcha_api_enabled = false;
        for checker in &self.checker_configs {
            if let CheckerConfig::TapCaptcha(_) = checker {
                tap_captcha_api_enabled = true;
                break;
            }
        }
        let captcha_api = CaptchaApi {
            enabled: tap_captcha_api_enabled,
            captcha_manager,
        };
```

**File:** crates/aptos-faucet/core/src/checkers/mod.rs (L76-76)
```rust
    fn spawn_periodic_tasks(&self, _join_set: &mut JoinSet<anyhow::Result<()>>) {}
```
