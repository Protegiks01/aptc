# Audit Report

## Title
Resource Group Initialization Race Condition Leading to Consensus Safety Violation

## Summary
A race condition exists in the parallel block executor's resource group initialization logic that allows concurrent transactions to observe inconsistent base values from storage. When multiple transactions concurrently access an uninitialized resource group, one transaction may incorrectly mark existing resources as deleted while another reads actual storage values, leading to non-deterministic execution and potential consensus splits across validators.

## Finding Description

The vulnerability occurs in the double-read pattern for uninitialized resource groups. The initialization process has a critical race window between two separate data structures (`group_sizes` and `values`) being updated non-atomically.

**Step 1:** Transaction A reads resource group G[tag T], gets `Uninitialized`, and begins initialization by calling `initialize_mvhashmap_base_group_contents`. [1](#0-0) 

**Step 2:** Inside `set_raw_base_values`, Transaction A calls `entry().or_default()` which creates the `group_sizes` entry, making the group appear "initialized" to other transactions. [2](#0-1)  The size entry is then inserted at line 173, but individual tag values are written later in a loop. [3](#0-2) 

**Step 3:** The code explicitly acknowledges non-atomic access between these data structures. [4](#0-3)  A TODO comment further acknowledges the need for initialization logic overhaul. [5](#0-4) 

**Step 4:** Transaction B concurrently reads the same resource. It checks `group_sizes.contains_key()` which returns true (the entry exists), but when fetching data from values, it gets `Uninitialized` because Transaction A hasn't written the values yet. [6](#0-5) 

**Step 5:** The `convert_tagged_data` function converts this to `TagNotFound` instead of `Uninitialized` when the group appears initialized. [7](#0-6) 

**Step 6:** Transaction B handles `TagNotFound` by setting an empty/deletion value as the base value. [8](#0-7) 

**Step 7:** When Transaction A attempts to set the actual base value from storage as `RawFromStorage`, it encounters the `Exchanged` deletion value already written by Transaction B. The logic gives precedence to `Exchanged` values and does nothing. [9](#0-8) 

**Result:** Transaction A's actual storage value is permanently discarded. The resource is read as non-existent when it actually exists in storage. Different timing across validator nodes leads to different execution results.

## Impact Explanation

This is a **Critical Severity** vulnerability because it causes:

1. **Consensus Safety Violation**: Different validators executing the same block can observe different base values for the same resource group read due to race timing. This leads to divergent state roots, breaking the fundamental consensus safety guarantee that all validators must produce identical results for identical inputs.

2. **Deterministic Execution Invariant Broken**: Aptos's core invariant that "all validators must produce identical state roots for identical blocks" is violated. Execution results become timing-dependent rather than deterministic.

3. **State Inconsistency**: Resources that exist in storage are incorrectly read as deleted/non-existent, causing incorrect state transitions affecting balance checks, ownership verification, and access control.

4. **Chain Halt or Fork Risk**: When validators observe different state roots, consensus cannot proceed, potentially requiring manual intervention or hard fork to resolve.

This aligns with the **Consensus/Safety Violations (Critical)** category in the Aptos bug bounty program, which covers scenarios where different validators commit different blocks or produce different state roots.

## Likelihood Explanation

**Likelihood: HIGH**

This race condition can occur during normal operation:

1. **Trigger Condition**: Multiple transactions in a block concurrently accessing a resource group for the first time
2. **Common Scenarios**: High-throughput blocks with parallel execution enabled, multiple transactions accessing the same account's resources, concurrent NFT or token operations
3. **No Special Privileges Required**: Any transaction sender can trigger this through normal transaction submission
4. **Race Window**: The window exists between creating the `group_sizes` entry and writing individual tag values (several operations providing interleaving opportunity)

The parallel block executor is specifically designed for high concurrency, making this race likely under normal load conditions.

## Recommendation

Implement atomic initialization of resource groups by holding the DashMap entry lock throughout the entire initialization process, including all individual tag value writes. Alternatively, redesign the initialization logic to use a single atomic operation that sets both the group metadata and all tag values simultaneously.

Consider using a dedicated initialization flag or state machine that prevents concurrent reads until initialization is fully complete.

## Proof of Concept

A concrete PoC would require setting up a parallel execution environment with precise timing control to trigger the race condition between two transactions accessing the same uninitialized resource group. The vulnerability is architecturally present in the code as demonstrated by the citations above, particularly the explicit acknowledgment of non-atomic access and the TODO comment indicating planned refactoring of initialization logic.

## Notes

The code comments explicitly acknowledge this non-atomic access pattern and its potential issues. The TODO at line 451 in `versioned_group_data.rs` states "TODO(BlockSTMv2): complete overhaul of initialization logic," indicating developers are aware of problems in this area. This race condition affects the execution layer critical for all blockchain operations including asset transfers, staking, governance, and smart contract execution.

### Citations

**File:** aptos-move/block-executor/src/view.rs (L815-827)
```rust
                Err(TagNotFound) => {
                    // TagNotFound means group was initialized (o.w. Uninitialized branch
                    // would be visited), but the tag didn't exist. So record an empty resource
                    // as a base value, and do continue to retry the read.
                    self.versioned_map
                        .group_data()
                        .update_tagged_base_value_with_layout(
                            group_key.clone(),
                            resource_tag.clone(),
                            TransactionWrite::from_state_value(None),
                            None,
                        );
                    continue;
```

**File:** aptos-move/block-executor/src/view.rs (L1505-1506)
```rust
        if matches!(group_read, GroupReadResult::Uninitialized) {
            self.initialize_mvhashmap_base_group_contents(group_key)?;
```

**File:** aptos-move/mvhashmap/src/versioned_group_data.rs (L155-157)
```rust
        let mut group_sizes = self.group_sizes.entry(group_key.clone()).or_default();

        // Currently the size & value are written while holding the sizes lock.
```

**File:** aptos-move/mvhashmap/src/versioned_group_data.rs (L173-182)
```rust
            entry.insert(SizeEntry::new(SizeAndDependencies::from_size(group_size)));

            let mut superset_tags = self.group_tags.entry(group_key.clone()).or_default();
            for (tag, value) in base_values.into_iter() {
                superset_tags.insert(tag.clone());
                self.values.set_base_value(
                    (group_key.clone(), tag),
                    ValueWithLayout::RawFromStorage(Arc::new(value)),
                );
            }
```

**File:** aptos-move/mvhashmap/src/versioned_group_data.rs (L423-428)
```rust
        // We are accessing group_sizes and values non-atomically, hence the order matters.
        // It is important that initialization check happens before fetch data below. O.w.
        // we could incorrectly get a TagNotFound error (do not find data, but then find
        // size initialized in between the calls). In fact, we always write size after data,
        // and sometimes (e.g. during initialization) even hold the sizes lock during writes.
        // It is fine to observe initialized = false, but find data, in convert_tagged_data.
```

**File:** aptos-move/mvhashmap/src/versioned_group_data.rs (L429-432)
```rust
        let initialized = self.group_sizes.contains_key(group_key);

        let data_value = self.values.fetch_data_no_record(&key_ref, txn_idx);
        self.convert_tagged_data(data_value, initialized)
```

**File:** aptos-move/mvhashmap/src/versioned_group_data.rs (L451-451)
```rust
        // TODO(BlockSTMv2): complete overhaul of initialization logic.
```

**File:** aptos-move/mvhashmap/src/versioned_group_data.rs (L683-687)
```rust
            Err(MVDataError::Uninitialized) => Err(if initialized {
                MVGroupError::TagNotFound
            } else {
                MVGroupError::Uninitialized
            }),
```

**File:** aptos-move/mvhashmap/src/versioned_data.rs (L586-588)
```rust
                        (Exchanged(_, _), RawFromStorage(_)) => {
                            // Stored value contains more info, nothing to do.
                        },
```
