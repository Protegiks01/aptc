# Audit Report

## Title
Round Number Attack: Malicious Peers Can Fill Pending Block Store with High-Round Blocks to Evict Legitimate Blocks

## Summary
An attacker can send consensus observer nodes malicious ordered blocks with extremely high round numbers (close to `u64::MAX`). These blocks bypass validation checks and get inserted into the pending block store's BTreeMap. When garbage collection triggers, it removes blocks with the lowest rounds first, causing legitimate blocks to be evicted while the attacker's high-round blocks persist indefinitely. This leads to memory exhaustion and denial of service on consensus observer nodes.

## Finding Description

The consensus observer's pending block management system uses a BTreeMap keyed by `(epoch, round)` to store blocks awaiting payloads. [1](#0-0) 

The `Round` type is defined as `u64`, allowing values from 0 to 18,446,744,073,709,551,615. [2](#0-1) 

When a network peer sends an `OrderedBlock` message to a consensus observer node, the only structural validation performed is `verify_ordered_blocks()`, which checks that blocks are non-empty, properly chained, and that the last block ID matches the proof block ID. [3](#0-2)  Critically, this validation does **not** check if round numbers are reasonable or within any bounds.

After passing this validation, blocks are checked to see if they are "out of date" by comparing their epoch/round against the last ordered block. [4](#0-3)  This check only prevents blocks with rounds that are too LOW, not too HIGH.

If payloads for the block don't exist, the block is inserted into the pending block store without any cryptographic proof verification. [5](#0-4) 

The garbage collection mechanism removes blocks when the store exceeds `max_num_pending_blocks` by using `pop_first()`, which removes entries with the LOWEST `(epoch, round)` keys from the BTreeMap. [6](#0-5) 

**Attack Path:**
1. Attacker crafts `OrderedBlock` messages with current epoch and rounds like `u64::MAX - 1000`, `u64::MAX - 999`, etc.
2. Blocks have valid parent chain relationships but reference non-existent payloads
3. Messages pass `verify_ordered_blocks()` (no round sanity check)
4. Blocks are not considered "out of date" (high rounds > current round)
5. Blocks get inserted with keys like `(current_epoch, u64::MAX - i)` at the END of the BTreeMap
6. Since payloads never arrive, blocks remain in pending store indefinitely
7. Cryptographic proof verification never occurs (only happens during `process_ordered_block` when payloads exist)
8. When legitimate blocks arrive and trigger GC, the GC removes blocks from the BEGINNING of the BTreeMap (lowest rounds)
9. Legitimate blocks are evicted while attacker's high-round blocks survive

## Impact Explanation

This vulnerability qualifies as **Medium Severity** under the Aptos bug bounty program for the following reasons:

1. **State Inconsistencies Requiring Intervention**: The pending block store becomes corrupted with useless high-round blocks, preventing proper buffering of legitimate pending blocks. Node operators may need to restart nodes or manually clear state.

2. **Validator Node Slowdowns**: Consensus observer nodes (which can run on validators and VFNs) experience degraded performance as memory fills with malicious blocks and legitimate blocks cannot be buffered properly. [7](#0-6) 

3. **Resource Exhaustion**: The attack can fill memory with up to `max_num_pending_blocks` (default 150, up to 300 on test networks) entries containing useless high-round blocks. [8](#0-7)  Each entry can contain multiple pipelined blocks, significantly amplifying memory consumption.

This does not reach Critical severity because it only affects consensus observer nodes, not the core consensus protocol itself. However, it can cause operational disruptions and degrade network performance.

## Likelihood Explanation

This vulnerability has **HIGH likelihood** of exploitation:

1. **Low Attack Complexity**: Any network peer can send `OrderedBlock` messages to consensus observer nodes. No authentication or special privileges required beyond network connectivity. [9](#0-8) 

2. **No Cryptographic Requirements**: Attacker doesn't need valid signatures or quorum certificates since proof verification only happens after payloads arrive (which they never will for attack blocks).

3. **No Rate Limiting**: The code shows no evidence of per-peer rate limiting or reputation-based filtering for this attack vector.

4. **Deterministic Effect**: The attack reliably causes the intended effect due to the deterministic BTreeMap ordering and GC strategy.

5. **Wide Attack Surface**: Consensus observers are enabled by default on validators (publisher) and VFNs (observer + publisher), making many nodes potential targets. [10](#0-9) 

## Recommendation

Implement round number sanity checks before inserting blocks into the pending block store. Add validation that rejects blocks with rounds that are unreasonably far ahead of the current consensus state:

```rust
// In process_ordered_block_message, after verify_ordered_blocks() passes
// and before checking if block is out of date:

// Define maximum allowed round gap (e.g., 1000 rounds ahead)
const MAX_ROUND_AHEAD: Round = 1000;

// Get the current consensus round
let last_ordered_block = self.observer_block_data.lock().get_last_ordered_block();

// Check if any block in the ordered block has an unreasonably high round
let first_block_round = first_block.round();
if first_block_round > last_ordered_block.round().saturating_add(MAX_ROUND_AHEAD) {
    warn!(
        LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
            "Rejecting ordered block with suspiciously high round: {:?}, current round: {:?}, from peer: {:?}",
            first_block_round,
            last_ordered_block.round(),
            peer_network_id
        ))
    );
    increment_invalid_message_counter(&peer_network_id, metrics::ORDERED_BLOCK_LABEL);
    return;
}
```

Additionally, consider implementing:
1. Per-peer rate limiting on ordered block messages
2. Peer reputation system that penalizes peers sending invalid blocks
3. Change GC strategy to also consider block timestamps or implement LRU eviction
4. Add monitoring alerts when pending block store fills with blocks having anomalous round numbers

## Proof of Concept

```rust
// This PoC demonstrates the attack. Add to consensus_observer tests.

#[tokio::test]
async fn test_round_number_attack() {
    // Setup: Create a consensus observer with pending block store
    let consensus_observer_config = ConsensusObserverConfig {
        max_num_pending_blocks: 10,
        observer_enabled: true,
        ..Default::default()
    };
    
    let mut consensus_observer = create_consensus_observer(consensus_observer_config);
    
    // Step 1: Attacker sends blocks with extremely high round numbers
    let current_epoch = 1;
    let current_round = 100;
    let attack_round_base = u64::MAX - 100;
    
    // Send 10 malicious blocks with rounds close to u64::MAX
    for i in 0..10 {
        let attack_round = attack_round_base + i;
        
        // Create malicious ordered block with high round
        let malicious_block = create_ordered_block_with_round(
            current_epoch, 
            attack_round,
            HashValue::random()
        );
        
        // Send to consensus observer (will pass verify_ordered_blocks)
        consensus_observer.process_ordered_block_message(
            PeerNetworkId::random(),
            Instant::now(),
            malicious_block,
        ).await;
    }
    
    // Verify malicious blocks are in pending store
    let pending_store = consensus_observer.observer_block_data.lock();
    assert_eq!(pending_store.blocks_without_payloads.len(), 10);
    
    // Step 2: Now send legitimate blocks with normal round numbers
    for i in 0..10 {
        let legitimate_round = current_round + i;
        
        let legitimate_block = create_ordered_block_with_round(
            current_epoch,
            legitimate_round,
            HashValue::random()
        );
        
        consensus_observer.process_ordered_block_message(
            PeerNetworkId::random(),
            Instant::now(),
            legitimate_block,
        ).await;
    }
    
    // Step 3: Verify that legitimate blocks were evicted (GC removed them)
    // while attacker's high-round blocks remain
    let pending_store = consensus_observer.observer_block_data.lock();
    
    // Check that the store still has max_num_pending_blocks entries
    assert_eq!(pending_store.blocks_without_payloads.len(), 10);
    
    // Verify all remaining blocks have high round numbers (attacker's blocks)
    for ((_epoch, round), _block) in pending_store.blocks_without_payloads.iter() {
        assert!(*round > u64::MAX - 200, 
            "Legitimate blocks were evicted, attacker blocks remain");
    }
    
    // Verify none of the legitimate blocks remain
    for i in 0..10 {
        let legitimate_round = current_round + i;
        assert!(!pending_store.blocks_without_payloads.contains_key(
            &(current_epoch, legitimate_round)
        ), "Legitimate block should have been evicted");
    }
}
```

**Notes**

The vulnerability exists in the consensus observer component, which is a supporting system for validators and full nodes to efficiently track consensus without participating directly. While this doesn't compromise consensus safety itself, it represents a serious operational security issue that can degrade network performance and cause resource exhaustion on critical infrastructure nodes.

The attack leverages the combination of: (1) insufficient input validation on round numbers, (2) insertion of unverified blocks into memory, and (3) a garbage collection strategy that assumes normal round number progression. An attacker can exploit this to conduct targeted DoS attacks against consensus observer nodes with minimal resources and no special privileges.

### Citations

**File:** consensus/src/consensus_observer/observer/pending_blocks.rs (L67-67)
```rust
    blocks_without_payloads: BTreeMap<(u64, Round), Arc<PendingBlockWithMetadata>>,
```

**File:** consensus/src/consensus_observer/observer/pending_blocks.rs (L177-194)
```rust
        for _ in 0..num_blocks_to_remove {
            if let Some((oldest_epoch_round, pending_block)) =
                self.blocks_without_payloads.pop_first()
            {
                // Log a warning message for the removed block
                warn!(
                    LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                        "The pending block store is too large: {:?} blocks. Removing the block for the oldest epoch and round: {:?}",
                        num_pending_blocks, oldest_epoch_round
                    ))
                );

                // Remove the block from the hash store
                let first_block = pending_block.ordered_block().first_block();
                self.blocks_without_payloads_by_hash
                    .remove(&first_block.id());
            }
        }
```

**File:** types/src/block_info.rs (L16-16)
```rust
pub type Round = u64;
```

**File:** consensus/src/consensus_observer/network/observer_message.rs (L227-265)
```rust
    pub fn verify_ordered_blocks(&self) -> Result<(), Error> {
        // Verify that we have at least one ordered block
        if self.blocks.is_empty() {
            return Err(Error::InvalidMessageError(
                "Received empty ordered block!".to_string(),
            ));
        }

        // Verify the last block ID matches the ordered proof block ID
        if self.last_block().id() != self.proof_block_info().id() {
            return Err(Error::InvalidMessageError(
                format!(
                    "Last ordered block ID does not match the ordered proof ID! Number of blocks: {:?}, Last ordered block ID: {:?}, Ordered proof ID: {:?}",
                    self.blocks.len(),
                    self.last_block().id(),
                    self.proof_block_info().id()
                )
            ));
        }

        // Verify the blocks are correctly chained together (from the last block to the first)
        let mut expected_parent_id = None;
        for block in self.blocks.iter().rev() {
            if let Some(expected_parent_id) = expected_parent_id {
                if block.id() != expected_parent_id {
                    return Err(Error::InvalidMessageError(
                        format!(
                            "Block parent ID does not match the expected parent ID! Block ID: {:?}, Expected parent ID: {:?}",
                            block.id(),
                            expected_parent_id
                        )
                    ));
                }
            }

            expected_parent_id = Some(block.parent_id());
        }

        Ok(())
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L678-680)
```rust
        let last_ordered_block = self.observer_block_data.lock().get_last_ordered_block();
        let block_out_of_date =
            first_block_epoch_round <= (last_ordered_block.epoch(), last_ordered_block.round());
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L706-713)
```rust
        if self.all_payloads_exist(pending_block_with_metadata.ordered_block().blocks()) {
            self.process_ordered_block(pending_block_with_metadata)
                .await;
        } else {
            self.observer_block_data
                .lock()
                .insert_pending_block(pending_block_with_metadata);
        }
```

**File:** config/src/config/consensus_observer_config.rs (L12-14)
```rust
const ENABLE_ON_VALIDATORS: bool = true;
const ENABLE_ON_VALIDATOR_FULLNODES: bool = true;
const ENABLE_ON_PUBLIC_FULLNODES: bool = false;
```

**File:** config/src/config/consensus_observer_config.rs (L72-72)
```rust
            max_num_pending_blocks: 150, // 150 blocks (sufficient for existing production networks)
```

**File:** config/src/config/consensus_observer_config.rs (L112-127)
```rust
            NodeType::Validator => {
                if ENABLE_ON_VALIDATORS && !publisher_manually_set {
                    // Only enable the publisher for validators
                    consensus_observer_config.publisher_enabled = true;
                    modified_config = true;
                }
            },
            NodeType::ValidatorFullnode => {
                if ENABLE_ON_VALIDATOR_FULLNODES
                    && !observer_manually_set
                    && !publisher_manually_set
                {
                    // Enable both the observer and the publisher for VFNs
                    consensus_observer_config.observer_enabled = true;
                    consensus_observer_config.publisher_enabled = true;
                    modified_config = true;
```

**File:** consensus/src/consensus_observer/network/network_handler.rs (L169-191)
```rust
    fn handle_observer_message(
        &mut self,
        peer_network_id: PeerNetworkId,
        message: ConsensusObserverDirectSend,
    ) {
        // Drop the message if the observer is not enabled
        if !self.consensus_observer_config.observer_enabled {
            return;
        }

        // Create the consensus observer message
        let network_message = ConsensusObserverNetworkMessage::new(peer_network_id, message);

        // Send the message to the consensus observer
        if let Err(error) = self.observer_message_sender.push((), network_message) {
            error!(
                LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                    "Failed to forward the observer message to the consensus observer! Error: {:?}",
                    error
                ))
            );
        }
    }
```
