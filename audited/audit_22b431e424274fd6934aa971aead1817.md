# Audit Report

## Title
Partial Notification Failure Leading to Cross-Component State Inconsistency in State Sync Driver

## Summary
The state sync driver's commit notification handler uses sequential notification calls with early-return error handling, allowing partial notification success. If the storage service notification succeeds but mempool notification fails, the system enters an inconsistent state where storage advertises committed data while mempool continues broadcasting those already-committed transactions.

## Finding Description
The vulnerability exists in the commit notification flow orchestrated by `CommitNotification::handle_transaction_notification`. [1](#0-0) 

The function performs three sequential notifications using the `?` operator for early return on errors:

1. **Storage service notification** (line 97-99) - Informs storage service of new committed version
2. **Mempool notification** (line 102-104) - Tells mempool to remove committed transactions  
3. **Event subscription notification** (line 107-109) - Updates event subscribers

This breaks the **State Consistency** invariant because if notification 1 succeeds but notification 2 fails, the storage service believes version X is committed and updates its cached summary to advertise this to peers [2](#0-1) , while mempool never receives the commit notification and continues holding those transactions. [3](#0-2) 

The notification errors are defined as: [4](#0-3) 

When failures occur, only error logging happens with no retry or rollback: [5](#0-4) 

**Failure scenarios:**
- Channel send failures when mempool or storage service listener is dropped
- Channel full/blocked during high load
- Component restart/crash between notifications

## Impact Explanation
This constitutes **Medium Severity** per the bug bounty criteria ("State inconsistencies requiring intervention"):

1. **Resource Waste**: Mempool continues broadcasting committed transactions, wasting network bandwidth and peer CPU cycles
2. **Component Confusion**: Storage service advertises data availability that mempool contradicts through transaction rebroadcasts
3. **Operational Complexity**: Operators must manually intervene to reconcile component states
4. **Peer Confusion**: Other nodes receive already-committed transactions from mempool, attempt resubmission, face rejection

However, this does NOT threaten:
- Blockchain state integrity (committed data remains committed)
- Consensus safety (all validators commit identical transactions)
- Fund security (no theft or loss possible)

## Likelihood Explanation
**Likelihood: Medium to Low**

Can occur naturally during:
- Component restarts or crashes
- High transaction load causing channel saturation
- Resource exhaustion scenarios
- Race conditions during node startup/shutdown

However, an **external unprivileged attacker cannot reliably trigger** this without resource exhaustion attacks (which are explicitly out of scope per bug bounty rules). The failure requires timing between notification calls or component-level failures.

## Recommendation
Implement atomic notification delivery with one of these approaches:

**Option 1: Collect all results before committing any**
```rust
// Attempt all notifications
let storage_result = storage_service_notification_handler
    .notify_storage_service_of_committed_transactions(latest_synced_version)
    .await;
    
let mempool_result = mempool_notification_handler
    .notify_mempool_of_committed_transactions(transactions.clone(), blockchain_timestamp_usecs)
    .await;
    
let event_result = event_subscription_service
    .lock()
    .notify_events(latest_synced_version, events.clone());

// Only proceed if ALL succeed
storage_result?;
mempool_result?;
event_result?;
```

**Option 2: Implement compensating transactions on partial failure**
If storage notification succeeds but mempool fails, send a rollback notification to storage service.

**Option 3: Add retry logic with exponential backoff**
Store failed notifications and retry them periodically until success.

## Proof of Concept

```rust
// Test case demonstrating partial notification failure
#[tokio::test]
async fn test_partial_notification_failure() {
    // Setup: Create notifiers where mempool channel is closed but storage is open
    let (storage_notifier, _storage_listener) = 
        new_storage_service_notifier_listener_pair();
    let (mempool_notifier, mut mempool_listener) = 
        new_mempool_notifier_listener_pair(1);
    
    // Drop mempool listener to cause notification failure
    drop(mempool_listener);
    
    // Simulate commit notification
    let events = vec![];
    let transactions = vec![create_test_transaction()];
    let version = 100;
    let ledger_info = create_test_ledger_info(version);
    
    // This will succeed for storage but fail for mempool
    let result = CommitNotification::handle_transaction_notification(
        events,
        transactions,
        version,
        ledger_info,
        MempoolNotificationHandler::new(mempool_notifier),
        Arc::new(Mutex::new(EventSubscriptionService::new())),
        StorageServiceNotificationHandler::new(storage_notifier),
    ).await;
    
    // Verify: Error returned, storage notified, mempool NOT notified
    assert!(result.is_err());
    assert!(matches!(result.unwrap_err(), Error::NotifyMempoolError(_)));
    
    // Storage service has been notified and updated its cache
    // Mempool still holds the "committed" transactions
    // System is in inconsistent state
}
```

**Note**: This is a **reliability and consistency bug** rather than a directly exploitable security vulnerability. While it violates state consistency at the component level and warrants fixing, it does not meet the strict criteria for Critical or High severity security vulnerabilities as it cannot be reliably exploited by external attackers and does not compromise blockchain safety, consensus, or fund security.

### Citations

**File:** state-sync/state-sync-driver/src/notification_handlers.rs (L75-112)
```rust
    pub async fn handle_transaction_notification<
        M: MempoolNotificationSender,
        S: StorageServiceNotificationSender,
    >(
        events: Vec<ContractEvent>,
        transactions: Vec<Transaction>,
        latest_synced_version: Version,
        latest_synced_ledger_info: LedgerInfoWithSignatures,
        mut mempool_notification_handler: MempoolNotificationHandler<M>,
        event_subscription_service: Arc<Mutex<EventSubscriptionService>>,
        mut storage_service_notification_handler: StorageServiceNotificationHandler<S>,
    ) -> Result<(), Error> {
        // Log the highest synced version and timestamp
        let blockchain_timestamp_usecs = latest_synced_ledger_info.ledger_info().timestamp_usecs();
        debug!(
            LogSchema::new(LogEntry::NotificationHandler).message(&format!(
                "Notifying the storage service, mempool and the event subscription service of version: {:?} and timestamp: {:?}.",
                latest_synced_version, blockchain_timestamp_usecs
            ))
        );

        // Notify the storage service of the committed transactions
        storage_service_notification_handler
            .notify_storage_service_of_committed_transactions(latest_synced_version)
            .await?;

        // Notify mempool of the committed transactions
        mempool_notification_handler
            .notify_mempool_of_committed_transactions(transactions, blockchain_timestamp_usecs)
            .await?;

        // Notify the event subscription service of the events
        event_subscription_service
            .lock()
            .notify_events(latest_synced_version, events)?;

        Ok(())
    }
```

**File:** state-sync/storage-service/server/src/lib.rs (L199-214)
```rust
                    notification = storage_service_listener.select_next_some() => {
                        trace!(LogSchema::new(LogEntry::ReceivedCommitNotification)
                            .message(&format!(
                                "Received commit notification for highest synced version: {:?}.",
                                notification.highest_synced_version
                            ))
                        );

                        // Refresh the cache because of a commit notification
                        refresh_cached_storage_summary(
                            cached_storage_server_summary.clone(),
                            storage.clone(),
                            config,
                            cache_update_notifiers.clone(),
                        )
                    },
```

**File:** mempool/src/shared_mempool/coordinator.rs (L229-265)
```rust
fn handle_commit_notification<TransactionValidator>(
    mempool: &Arc<Mutex<CoreMempool>>,
    mempool_validator: &Arc<RwLock<TransactionValidator>>,
    use_case_history: &Arc<Mutex<UseCaseHistory>>,
    msg: MempoolCommitNotification,
    num_committed_txns_received_since_peers_updated: &Arc<AtomicU64>,
) where
    TransactionValidator: TransactionValidation,
{
    debug!(
        block_timestamp_usecs = msg.block_timestamp_usecs,
        num_committed_txns = msg.transactions.len(),
        LogSchema::event_log(LogEntry::StateSyncCommit, LogEvent::Received),
    );

    // Process and time committed user transactions.
    let start_time = Instant::now();
    counters::mempool_service_transactions(
        counters::COMMIT_STATE_SYNC_LABEL,
        msg.transactions.len(),
    );
    num_committed_txns_received_since_peers_updated
        .fetch_add(msg.transactions.len() as u64, Ordering::Relaxed);
    process_committed_transactions(
        mempool,
        use_case_history,
        msg.transactions,
        msg.block_timestamp_usecs,
    );
    mempool_validator.write().notify_commit();
    let latency = start_time.elapsed();
    counters::mempool_service_latency(
        counters::COMMIT_STATE_SYNC_LABEL,
        counters::REQUEST_SUCCESS_LABEL,
        latency,
    );
}
```

**File:** state-sync/state-sync-driver/src/error.rs (L35-38)
```rust
    #[error("Failed to notify mempool of the new commit: {0}")]
    NotifyMempoolError(String),
    #[error("Failed to notify the storage service of the new commit: {0}")]
    NotifyStorageServiceError(String),
```

**File:** state-sync/state-sync-driver/src/utils.rs (L355-370)
```rust
    // Handle the commit notification
    if let Err(error) = CommitNotification::handle_transaction_notification(
        committed_transactions.events,
        committed_transactions.transactions,
        latest_synced_version,
        latest_synced_ledger_info,
        mempool_notification_handler,
        event_subscription_service,
        storage_service_notification_handler,
    )
    .await
    {
        error!(LogSchema::new(LogEntry::SynchronizerNotification)
            .error(&error)
            .message("Failed to handle a transaction commit notification!"));
    }
```
