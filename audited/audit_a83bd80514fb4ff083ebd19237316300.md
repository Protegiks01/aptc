# Audit Report

## Title
Git Repository Cache Poisoning via Canonicalization Collision in Move Package Resolver

## Summary
The `CanonicalGitIdentity` implementation uses `trim_end_matches(".git")` which removes **all** consecutive `.git` suffixes from repository paths, causing semantically different Git repositories to hash to the same canonical identity. This enables cache poisoning attacks where an attacker's malicious repository (e.g., `evil.git.git`) collides with a legitimate repository (e.g., `evil.git`), allowing malicious Move code to be injected into victim builds.

## Finding Description

The canonicalization logic in `CanonicalGitIdentity::new()` contains a critical flaw in how it normalizes Git repository URLs: [1](#0-0) 

The `trim_end_matches(".git")` method removes **all** consecutive occurrences of the `.git` pattern at the end of the string, not just one. This means:
- `https://github.com/foo/bar.git.git` → canonicalizes to `github.com/foo/bar`
- `https://github.com/foo/bar.git` → canonicalizes to `github.com/foo/bar`

Both URLs produce identical `CanonicalGitIdentity` values despite referencing different repositories.

The canonical identity is used as the cache directory key: [2](#0-1) 

When a cached repository already exists, the system attempts to update it by fetching from the stored origin remote: [3](#0-2) 

**Attack Scenario:**
1. Attacker creates malicious repository: `https://github.com/victim/package.git.git`
2. Attacker publishes a popular Move package depending on this malicious repository
3. When someone builds the attacker's package, `package.git.git` gets cloned to cache directory `github.com/victim/package`
4. The cached repo's origin is set to `https://github.com/victim/package.git.git`
5. Victim creates a legitimate Move package depending on `https://github.com/victim/package.git`
6. When victim builds, the resolver finds cache directory `github.com/victim/package` already exists
7. It opens the existing repo and fetches from "origin" which points to the **malicious** `package.git.git` repository
8. Victim unknowingly compiles and deploys malicious Move modules

The `PackageIdentity` uses the canonical identity in package resolution: [4](#0-3) 

## Impact Explanation

**Severity: HIGH**

This vulnerability enables supply chain attacks against Move package developers building applications for the Aptos blockchain. While the bug exists in development tooling rather than the core consensus/execution layer, the security implications are severe:

1. **Malicious Code Injection**: Attackers can inject arbitrary Move code into victim builds through cache poisoning
2. **Smart Contract Compromise**: Poisoned packages could lead to deployment of malicious smart contracts on Aptos
3. **Fund Theft Potential**: If malicious contracts are deployed, they could steal user funds
4. **Governance Manipulation**: Malicious modules could manipulate on-chain governance if they gain sufficient privileges
5. **Persistent Attack**: Once the cache is poisoned, all subsequent builds reuse the malicious code until cache is cleared

This qualifies as **High Severity** under the Aptos bug bounty program as it represents a "Significant protocol violation" that could lead to compromised smart contract deployments affecting the blockchain's security.

## Likelihood Explanation

**Likelihood: MEDIUM**

The attack is feasible but requires specific conditions:

**Attacker Requirements:**
- Create a Git repository with naming like `target.git.git` 
- Convince users to build packages depending on this repository (e.g., by publishing popular tooling)
- Target repositories with similar base names (e.g., targeting `target.git`)

**Victim Requirements:**
- Build a Move package depending on a repository with a name that collides when canonicalized
- Not notice the cache reusing the wrong repository
- Deploy the resulting code without thorough review

The likelihood is elevated because:
- Repository names ending in `.git` are common convention on GitHub
- Developers often trust their dependency resolution systems
- The attack is persistent once executed
- Cache directories are typically shared across projects on a developer's machine

## Recommendation

Replace `trim_end_matches(".git")` with a single-occurrence removal to prevent over-trimming:

```rust
impl CanonicalGitIdentity {
    pub fn new(git_url: &Url) -> Result<Self> {
        let host = git_url
            .host_str()
            .ok_or_else(|| anyhow!("invalid git URL, unable to extract host: {}", git_url))?
            .to_ascii_lowercase();

        let port = match git_url.port() {
            Some(port) => match (git_url.scheme(), port) {
                ("http", 80) | ("https", 443) | ("ssh", 22) => "".to_string(),
                _ => format!(":{}", port),
            },
            None => "".to_string(),
        };

        let path = git_url.path().to_ascii_lowercase();
        let path = path.trim_end_matches("/");
        
        // Remove only ONE .git suffix if present
        let path = if path.ends_with(".git") {
            &path[..path.len() - 4]
        } else {
            path
        };

        Ok(Self(format!("{}{}{}", host, port, path)))
    }
}
```

Additionally, consider validating that the cached repository's origin URL matches the requested URL before reusing the cache, or use a hash of the full URL as the cache key.

## Proof of Concept

**Reproduction Steps:**

1. Create two Git repositories:
   - Repository A: `https://github.com/test/malicious.git.git` (contains malicious Move code)
   - Repository B: `https://github.com/test/malicious.git` (legitimate code)

2. Create a Move package `attacker_package` with dependency on Repository A:
   ```toml
   [dependencies]
   MaliciousPackage = { git = "https://github.com/test/malicious.git.git", rev = "main" }
   ```

3. Build `attacker_package`:
   ```bash
   aptos move compile --package-dir attacker_package
   ```
   This caches Repository A at: `{cache}/git/repos/github.com%2Ftest%2Fmalicious`

4. Create victim's Move package with dependency on Repository B:
   ```toml
   [dependencies]
   LegitimatePackage = { git = "https://github.com/test/malicious.git", rev = "main" }
   ```

5. Build victim's package:
   ```bash
   aptos move compile --package-dir victim_package
   ```

6. Observe that victim's build uses code from Repository A (malicious) instead of Repository B (legitimate).

**Verification:**
Examine the cached repository:
```bash
cd {cache}/git/repos/github.com%2Ftest%2Fmalicious
git remote -v
# Will show: origin  https://github.com/test/malicious.git.git (fetch)
```

The victim's build incorrectly fetches from the malicious `.git.git` repository due to canonicalization collision.

---

**Notes:**
- This vulnerability affects Move package development tooling, not the core Aptos blockchain runtime
- Validators are not directly affected as they don't use the package resolver during consensus
- The impact is realized when developers unknowingly deploy compromised smart contracts
- The attack is persistent and difficult to detect without inspecting the Git cache directly

### Citations

**File:** third_party/move/tools/move-package-cache/src/canonical.rs (L34-35)
```rust
        let path = git_url.path().to_ascii_lowercase();
        let path = path.trim_end_matches("/").trim_end_matches(".git");
```

**File:** third_party/move/tools/move-package-cache/src/package_cache.rs (L97-99)
```rust
        let repo_dir_name = percent_encode_for_filename(&CanonicalGitIdentity::new(git_url)?);
        let repos_path = self.root.join("git").join("repos");
        let repo_path = repos_path.join(&repo_dir_name);
```

**File:** third_party/move/tools/move-package-cache/src/package_cache.rs (L137-153)
```rust
        let repo = if repo_path.exists() {
            // If the repo already exists, update it.
            self.listener.on_repo_update_start(git_url.as_str());

            let repo = Repository::open_bare(&repo_path)?;
            {
                let mut remote = repo.find_remote("origin")?;
                // Fetch all remote branches and map them to local remote-tracking branches
                // - refs/heads/*: fetch all remote branches
                // - refs/remotes/origin/*: store them as local remote-tracking branches under origin/
                remote
                    .fetch(
                        &["refs/heads/*:refs/remotes/origin/*"],
                        Some(&mut fetch_options),
                        None,
                    )
                    .map_err(|err| anyhow!("Failed to update git repo at {}: {}", git_url, err))?;
```

**File:** third_party/move/tools/move-package-resolver/src/resolver.rs (L401-408)
```rust
            let identity = PackageIdentity {
                name: dep_name.to_string(),
                location: SourceLocation::Git {
                    repo: CanonicalGitIdentity::new(&url)?,
                    commit_id,
                    subdir: normalized_subdir,
                },
            };
```
