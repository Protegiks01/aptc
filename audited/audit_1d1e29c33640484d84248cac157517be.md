# Audit Report

## Title
Storage ID Collision in Token Ownership V2 Indexer Causes Data Loss for Multiple Fungible Asset Stores

## Summary
The Aptos indexer incorrectly sets `storage_id` to the fungible asset metadata address instead of the `FungibleStore` object address when processing fungible token v2 ownerships. This causes primary key collisions when a single owner possesses multiple `FungibleStore` objects for the same fungible asset, resulting in database records being silently overwritten and token ownership data being permanently lost in the indexer.

## Finding Description
The vulnerability exists in the indexer's token ownership processing logic. The `current_token_ownerships_v2` table uses a composite primary key consisting of `(token_data_id, property_version_v1, owner_address, storage_id)`. [1](#0-0) 

When processing fungible token v2 stores, the `get_ft_v2_from_write_resource` function incorrectly assigns the `storage_id` field: [2](#0-1) 

The bug is on line 384, where `storage_id` is set to `token_data_id.clone()` (the metadata address), when it should be set to `resource.address` (the actual `FungibleStore` object address).

The Aptos Move framework explicitly supports creating multiple `FungibleStore` objects for the same fungible asset: [3](#0-2) 

**Attack Scenario:**
1. User creates `FungibleStore1` at address `0xSTORE1` for fungible asset with metadata at `0xMETA`, depositing 1000 tokens
2. Indexer records: PK = `(0xMETA, 0, 0xUSER, 0xMETA)`, amount = 1000
3. User creates `FungibleStore2` at address `0xSTORE2` for the same fungible asset `0xMETA`, depositing 2000 tokens  
4. Indexer attempts to record: PK = `(0xMETA, 0, 0xUSER, 0xMETA)`, amount = 2000
5. **Primary key collision!** The upsert operation overwrites the first record [4](#0-3) 

The `on_conflict` clause on line 778 causes the second record to overwrite the first, permanently losing `FungibleStore1`'s ownership data from the indexer.

## Impact Explanation
This is a **Medium Severity** vulnerability per the bug bounty criteria: "State inconsistencies requiring intervention."

While the actual on-chain state remains correct (the blockchain knows about both stores), the indexer—which serves as the primary query interface for applications—loses critical ownership data. This causes:

1. **Incorrect Balance Display**: Applications querying the indexer will show only partial token holdings (2000 instead of 3000 in the example)
2. **Lost Ownership Records**: The first `FungibleStore` becomes invisible to indexer-dependent applications
3. **User Confusion**: Users may believe they've lost tokens when the indexer shows reduced balances
4. **Application Failures**: DApps relying on complete ownership data will make incorrect decisions
5. **Data Integrity Violation**: The indexer's state diverges from blockchain state, breaking the invariant that indexer data must accurately reflect on-chain state

## Likelihood Explanation
**High Likelihood** - This will occur automatically whenever:
- Any user creates multiple `FungibleStore` objects for the same fungible asset (explicitly supported by the framework)
- Developers build applications that isolate fungible assets using separate stores (the documented use case)
- DeFi protocols implement multi-store architectures for accounting or security purposes

No special privileges or complex attack setup is required—this is triggered through normal, intended use of the fungible asset framework.

## Recommendation
Change line 384 in `v2_token_ownerships.rs` to use the `FungibleStore` object address as the `storage_id`:

```rust
// BEFORE (line 384):
let storage_id = token_data_id.clone();

// AFTER:
let storage_id = resource.address.clone();
```

This ensures each `FungibleStore` object is uniquely identified by its object address in the database, preventing collisions. The same fix should be applied to line 396 in the same function for consistency.

Additionally, after deploying the fix, the indexer should be re-synced from genesis or a checkpoint to correct any existing corrupted data.

## Proof of Concept

```move
// File: test_multiple_stores.move
// This Move script demonstrates creating multiple FungibleStore objects
// for the same fungible asset, which triggers the indexer bug

#[test_only]
module test_addr::multiple_stores_test {
    use aptos_framework::fungible_asset;
    use aptos_framework::object::{Self, Object};
    use aptos_framework::primary_fungible_store;
    use std::string;
    use std::signer;

    #[test(creator = @0x123)]
    public fun test_multiple_stores_same_asset(creator: &signer) {
        // Step 1: Create a fungible asset
        let constructor_ref = &object::create_named_object(creator, b"TEST_FA");
        let fa_metadata = fungible_asset::add_fungibility(
            constructor_ref,
            option::none(), // unlimited supply
            string::utf8(b"Test Token"),
            string::utf8(b"TEST"),
            8,
            string::utf8(b""),
            string::utf8(b"")
        );

        // Step 2: Create first FungibleStore
        let store1_constructor = &object::create_object(signer::address_of(creator));
        let store1 = fungible_asset::create_store(store1_constructor, fa_metadata);
        // Mint 1000 tokens to store1
        // (mint operations omitted for brevity)

        // Step 3: Create second FungibleStore for the SAME fungible asset
        let store2_constructor = &object::create_object(signer::address_of(creator));
        let store2 = fungible_asset::create_store(store2_constructor, fa_metadata);
        // Mint 2000 tokens to store2
        // (mint operations omitted for brevity)

        // At this point:
        // - Both stores exist on-chain with correct balances
        // - Both have the same metadata (fa_metadata address)
        // - Both are owned by the same address (creator)
        // - The indexer will process both WriteResource events
        // - BUG: storage_id for both = fa_metadata address
        // - Result: Second record overwrites first in current_token_ownerships_v2
        // - Indexer loses track of store1
    }
}
```

**Expected Indexer Behavior (Buggy):**
- After processing store1: 1 row in `current_token_ownerships_v2` with PK `(fa_metadata, 0, creator, fa_metadata)`
- After processing store2: Still 1 row (overwrites previous), losing store1 data

**Correct Indexer Behavior (After Fix):**
- After processing store1: 1 row with PK `(fa_metadata, 0, creator, store1_addr)`
- After processing store2: 2 rows, one with PK `(fa_metadata, 0, creator, store1_addr)` and another with PK `(fa_metadata, 0, creator, store2_addr)`

## Notes
- This vulnerability only affects the **indexer service**, not the on-chain state or consensus
- The actual blockchain state remains correct; only the indexer's database is corrupted
- NFT ownerships are not affected as they correctly use `storage_id = token_data_id` (since NFT address equals token_data_id)
- V1 token ownerships use `storage_id = table_handle` and are not affected by this bug
- A similar pattern may exist in other indexer code paths processing fungible assets and should be audited

### Citations

**File:** crates/indexer/src/schema.rs (L401-423)
```rust
diesel::table! {
    current_token_ownerships_v2 (token_data_id, property_version_v1, owner_address, storage_id) {
        #[max_length = 66]
        token_data_id -> Varchar,
        property_version_v1 -> Numeric,
        #[max_length = 66]
        owner_address -> Varchar,
        #[max_length = 66]
        storage_id -> Varchar,
        amount -> Numeric,
        #[max_length = 66]
        table_type_v1 -> Nullable<Varchar>,
        token_properties_mutated_v1 -> Nullable<Jsonb>,
        is_soulbound_v2 -> Nullable<Bool>,
        #[max_length = 10]
        token_standard -> Varchar,
        is_fungible_v2 -> Nullable<Bool>,
        last_transaction_version -> Int8,
        last_transaction_timestamp -> Timestamp,
        inserted_at -> Timestamp,
        non_transferrable_by_owner -> Nullable<Bool>,
    }
}
```

**File:** crates/indexer/src/models/token_models/v2_token_ownerships.rs (L383-384)
```rust
                let token_data_id = inner.metadata.get_reference_address();
                let storage_id = token_data_id.clone();
```

**File:** aptos-move/framework/aptos-framework/sources/fungible_asset.move (L878-903)
```text
    /// Allow an object to hold a store for fungible assets.
    /// Applications can use this to create multiple stores for isolating fungible assets for different purposes.
    public fun create_store<T: key>(
        constructor_ref: &ConstructorRef, metadata: Object<T>
    ): Object<FungibleStore> {
        let store_obj = &constructor_ref.generate_signer();
        move_to(
            store_obj,
            FungibleStore { metadata: metadata.convert(), balance: 0, frozen: false }
        );

        if (is_untransferable(metadata)) {
            constructor_ref.set_untransferable();
        };

        if (default_to_concurrent_fungible_balance()) {
            move_to(
                store_obj,
                ConcurrentFungibleBalance {
                    balance: aggregator_v2::create_unbounded_aggregator()
                }
            );
        };

        constructor_ref.object_from_constructor_ref<FungibleStore>()
    }
```

**File:** crates/indexer/src/processors/token_processor.rs (L762-796)
```rust
fn insert_current_token_ownerships_v2(
    conn: &mut PgConnection,
    items_to_insert: &[CurrentTokenOwnershipV2],
) -> Result<(), diesel::result::Error> {
    use schema::current_token_ownerships_v2::dsl::*;

    let chunks = get_chunks(
        items_to_insert.len(),
        CurrentTokenOwnershipV2::field_count(),
    );

    for (start_ind, end_ind) in chunks {
        execute_with_better_error(
            conn,
            diesel::insert_into(schema::current_token_ownerships_v2::table)
                .values(&items_to_insert[start_ind..end_ind])
                .on_conflict((token_data_id, property_version_v1, owner_address, storage_id))
                .do_update()
                .set((
                    amount.eq(excluded(amount)),
                    table_type_v1.eq(excluded(table_type_v1)),
                    token_properties_mutated_v1.eq(excluded(token_properties_mutated_v1)),
                    is_soulbound_v2.eq(excluded(is_soulbound_v2)),
                    token_standard.eq(excluded(token_standard)),
                    is_fungible_v2.eq(excluded(is_fungible_v2)),
                    last_transaction_version.eq(excluded(last_transaction_version)),
                    last_transaction_timestamp.eq(excluded(last_transaction_timestamp)),
                    inserted_at.eq(excluded(inserted_at)),
                    non_transferrable_by_owner.eq(excluded(non_transferrable_by_owner)),
                )),
            Some(" WHERE current_token_ownerships_v2.last_transaction_version <= excluded.last_transaction_version "),
        )?;
    }
    Ok(())
}
```
