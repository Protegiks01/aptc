# Audit Report

## Title
Critical Division-by-Zero Panic in Leader Election Caused by Zero-Weight Configuration

## Summary
Setting all three weight parameters (`active_weight`, `inactive_weight`, `failed_weight`) in `ProposerAndVoterConfig` to zero causes a division-by-zero panic in the leader election algorithm, resulting in total consensus failure and network-wide deadlock requiring a hardfork to recover.

## Finding Description

The `ProposerAndVoterConfig` struct defines three weight parameters that control validator selection during leader election. [1](#0-0) 

When governance updates the consensus configuration, the Move module only validates that the configuration bytes are non-empty, without any semantic validation of the weight values. [2](#0-1) 

These weights are directly passed to `ProposerAndVoterHeuristic` without validation in the Rust code. [3](#0-2) 

The `get_weights()` function assigns each validator one of the three weight values based on their performance history. [4](#0-3) 

When all three weights are zero, every validator receives a weight of 0. These weights are then multiplied by voting power and passed to `choose_index()`. [5](#0-4) 

The `choose_index()` function sums all weights to compute `total_weight`, then calls `next_in_range(state, total_weight)`. [6](#0-5) 

Inside `next_in_range()`, the function performs a modulo operation with `total_weight` as the divisor. When `total_weight` is 0, this causes a division-by-zero panic. [7](#0-6) 

**Attack Path:**
1. Governance calls `consensus_config::set_for_next_epoch()` with a serialized `OnChainConsensusConfig` where `ProposerAndVoterConfig` has all weights set to 0
2. Configuration passes validation (only checks non-empty bytes)
3. On epoch transition, the new configuration becomes active
4. When any validator attempts to elect a leader for any round, the `choose_index()` function panics with division-by-zero
5. All validator nodes crash and cannot make progress
6. The network deadlocks completely

## Impact Explanation

This vulnerability qualifies as **CRITICAL** severity under the Aptos bug bounty program criteria:

- **Total loss of liveness/network availability**: All validator nodes panic when attempting leader election, preventing any blocks from being proposed or committed
- **Non-recoverable network partition (requires hardfork)**: Once the malicious configuration is activated, the network cannot recover through normal consensus mechanisms. Validator nodes continuously panic on startup, requiring a coordinated hardfork with code changes to bypass or fix the configuration

Every validator node in the network is affected, resulting in complete network halt. No blocks can be proposed, no transactions can be processed, and the blockchain effectively stops functioning.

## Likelihood Explanation

**Likelihood: Medium**

While this requires governance access (a privileged role), the vulnerability is exploitable through:
- **Accidental misconfiguration**: Governance participants could mistakenly set weights to 0 during testing or experimentation
- **Malicious governance proposal**: A compromised or malicious governance actor could intentionally brick the network
- **No safeguards**: The complete absence of validation makes this trivial to trigger

The attack requires only a single governance proposal to pass, with no complex setup or timing requirements. The impact is immediate and catastrophic upon epoch transition.

## Recommendation

Add validation to prevent all weights from being zero simultaneously. Implement checks at both the Move and Rust layers:

**Move Layer Validation** (in `consensus_config.move`):
Add a native validation function that deserializes and checks the configuration semantics before accepting it.

**Rust Layer Validation** (in `proposer_election.rs`):
Add a defensive check in `choose_index()`:

```rust
pub(crate) fn choose_index(mut weights: Vec<u128>, state: Vec<u8>) -> usize {
    let mut total_weight = 0;
    for w in &mut weights {
        total_weight = total_weight
            .checked_add(w)
            .expect("Total stake shouldn't exceed u128::MAX");
        *w = total_weight;
    }
    
    // DEFENSIVE CHECK: Prevent division by zero
    assert!(total_weight > 0, "Total weight must be positive for leader election");
    
    let chosen_weight = next_in_range(state, total_weight);
    weights
        .binary_search_by(|w| {
            if *w <= chosen_weight {
                Ordering::Less
            } else {
                Ordering::Greater
            }
        })
        .expect_err("Comparison never returns equals, so it's always guaranteed to be error")
}
```

**Configuration Validation** (in `epoch_manager.rs`):
Add validation when creating the heuristic to ensure at least one weight is non-zero.

## Proof of Concept

```rust
#[test]
#[should_panic(expected = "attempt to calculate the remainder with a divisor of zero")]
fn test_zero_weights_cause_panic() {
    use crate::liveness::proposer_election::choose_index;
    
    // Simulate the scenario where all validators have zero weight
    // This happens when active_weight = inactive_weight = failed_weight = 0
    let all_zero_weights = vec![0u128; 10];  // 10 validators, all with weight 0
    let state = vec![1, 2, 3, 4];  // arbitrary seed
    
    // This will panic with division by zero inside next_in_range()
    choose_index(all_zero_weights, state);
}
```

To reproduce:
1. Add this test to `consensus/src/liveness/proposer_election.rs`
2. Run `cargo test test_zero_weights_cause_panic`
3. The test will panic with "attempt to calculate the remainder with a divisor of zero"

This demonstrates that setting all three weights to zero in `ProposerAndVoterConfig` directly causes a panic in the leader election logic, proving the vulnerability.

## Notes

The vulnerability exists because there is a missing invariant check: **at least one weight parameter must be non-zero for leader election to function**. The default configuration sets sensible values (1000, 10, 1), but nothing prevents governance from setting all weights to zero. This represents a gap between the trusted governance role and the actual system requirements - even trusted actors should not be able to accidentally brick the entire network with a single configuration error.

### Citations

**File:** types/src/on_chain_config/consensus_config.rs (L552-575)
```rust
#[derive(Clone, Copy, Debug, Deserialize, Eq, PartialEq, Serialize)]
pub struct ProposerAndVoterConfig {
    // Selection weight for active validators with proposer failures below threshold
    pub active_weight: u64,
    // Selection weight for inactive validators with proposer failures below threshold
    pub inactive_weight: u64,
    // Selection weight for validators with proposer failures above threshold
    pub failed_weight: u64,
    // Thresholed of failures in the rounds validator was selected to be proposer
    // integer values representing percentages, i.e. 12 is 12%.
    pub failure_threshold_percent: u32,
    // Window into history considered for proposer statistics, multiplier
    // on top of number of validators
    pub proposer_window_num_validators_multiplier: usize,
    // Window into history considered for votre statistics, multiplier
    // on top of number of validators
    pub voter_window_num_validators_multiplier: usize,
    // Flag whether to use voting power as multiplier to the weights
    pub weight_by_voting_power: bool,
    // Flag whether to use history from previous epoch (0 if not),
    // representing a number of historical epochs (beyond the current one)
    // to consider.
    pub use_history_from_previous_epoch_max_count: u32,
}
```

**File:** aptos-move/framework/aptos-framework/sources/configs/consensus_config.move (L52-56)
```text
    public fun set_for_next_epoch(account: &signer, config: vector<u8>) {
        system_addresses::assert_aptos_framework(account);
        assert!(vector::length(&config) > 0, error::invalid_argument(EINVALID_CONFIG));
        std::config_buffer::upsert<ConsensusConfig>(ConsensusConfig {config});
    }
```

**File:** consensus/src/epoch_manager.rs (L318-328)
```rust
                        let heuristic: Box<dyn ReputationHeuristic> =
                            Box::new(ProposerAndVoterHeuristic::new(
                                self.author,
                                proposer_and_voter_config.active_weight,
                                proposer_and_voter_config.inactive_weight,
                                proposer_and_voter_config.failed_weight,
                                proposer_and_voter_config.failure_threshold_percent,
                                voter_window_size,
                                proposer_window_size,
                                leader_reputation_type.use_reputation_window_from_stale_end(),
                            ));
```

**File:** consensus/src/liveness/leader_reputation.rs (L521-552)
```rust
impl ReputationHeuristic for ProposerAndVoterHeuristic {
    fn get_weights(
        &self,
        epoch: u64,
        epoch_to_candidates: &HashMap<u64, Vec<Author>>,
        history: &[NewBlockEvent],
    ) -> Vec<u64> {
        assert!(epoch_to_candidates.contains_key(&epoch));

        let (votes, proposals, failed_proposals) =
            self.aggregation
                .get_aggregated_metrics(epoch_to_candidates, history, &self.author);

        epoch_to_candidates[&epoch]
            .iter()
            .map(|author| {
                let cur_votes = *votes.get(author).unwrap_or(&0);
                let cur_proposals = *proposals.get(author).unwrap_or(&0);
                let cur_failed_proposals = *failed_proposals.get(author).unwrap_or(&0);

                if cur_failed_proposals * 100
                    > (cur_proposals + cur_failed_proposals) * self.failure_threshold_percent
                {
                    self.failed_weight
                } else if cur_proposals > 0 || cur_votes > 0 {
                    self.active_weight
                } else {
                    self.inactive_weight
                }
            })
            .collect()
    }
```

**File:** consensus/src/liveness/leader_reputation.rs (L711-732)
```rust
        let stake_weights: Vec<u128> = weights
            .iter_mut()
            .enumerate()
            .map(|(i, w)| *w as u128 * self.voting_powers[i] as u128)
            .collect();

        let state = if self.use_root_hash {
            [
                root_hash.to_vec(),
                self.epoch.to_le_bytes().to_vec(),
                round.to_le_bytes().to_vec(),
            ]
            .concat()
        } else {
            [
                self.epoch.to_le_bytes().to_vec(),
                round.to_le_bytes().to_vec(),
            ]
            .concat()
        };

        let chosen_index = choose_index(stake_weights, state);
```

**File:** consensus/src/liveness/proposer_election.rs (L39-46)
```rust
fn next_in_range(state: Vec<u8>, max: u128) -> u128 {
    // hash = SHA-3-256(state)
    let hash = aptos_crypto::HashValue::sha3_256_of(&state).to_vec();
    let mut temp = [0u8; 16];
    copy_slice_to_vec(&hash[..16], &mut temp).expect("next failed");
    // return hash[0..16]
    u128::from_le_bytes(temp) % max
}
```

**File:** consensus/src/liveness/proposer_election.rs (L49-59)
```rust
pub(crate) fn choose_index(mut weights: Vec<u128>, state: Vec<u8>) -> usize {
    let mut total_weight = 0;
    // Create cumulative weights vector
    // Since we own the vector, we can safely modify it in place
    for w in &mut weights {
        total_weight = total_weight
            .checked_add(w)
            .expect("Total stake shouldn't exceed u128::MAX");
        *w = total_weight;
    }
    let chosen_weight = next_in_range(state, total_weight);
```
