# Audit Report

## Title
Division by Zero Panic in Mempool Due to Unconfigured Sender Buckets Causing Node-Wide Denial of Service

## Summary
When `num_sender_buckets` is set to 0 in the mempool configuration, the `sender_bucket()` function performs a modulo operation by zero, causing an immediate panic that crashes the mempool and renders the node unable to process any transactions. This vulnerability can be triggered by any transaction submission and affects all transaction processing paths.

## Finding Description

The security question correctly identifies that `PeerSyncState::new()` creates an empty `HashMap` when called with `num_sender_buckets=0`, causing peer sync updates to fail silently. [1](#0-0) 

However, the **critical vulnerability** is far more severe: the `sender_bucket()` function performs division by zero, causing a panic before any peer sync operations occur. [2](#0-1) 

When `num_sender_buckets` is 0, the modulo operation `% num_sender_buckets` triggers a division by zero panic. This function is invoked in multiple critical transaction processing paths:

1. **Transaction readiness processing**: [3](#0-2) 

2. **Bucket metrics retrieval**: [4](#0-3) 

3. **Transaction removal from indexes**: [5](#0-4) 

The configuration system lacks validation to prevent this misconfiguration. The `ConfigSanitizer` implementation explicitly has a TODO comment indicating missing validation: [6](#0-5) 

The default value is 4, but the configuration can be set to any u8 value including 0: [7](#0-6) 

**Attack Path:**
1. Node operator sets `num_sender_buckets: 0` in mempool configuration (accidentally or via malicious config injection)
2. Node starts successfully (no validation during initialization)
3. Any transaction is submitted to the node
4. Transaction processing invokes `sender_bucket()` 
5. Division by zero panic occurs
6. Mempool crashes, node becomes unable to process transactions

This breaks the **Resource Limits** invariant (#9) by allowing a configuration that bypasses normal operation safeguards, and violates the **Transaction Validation** invariant (#7) by preventing transaction processing entirely.

## Impact Explanation

**High Severity** - This vulnerability causes validator node crashes and complete denial of service:

- **Validator Node Crashes**: Any validator with this misconfiguration will crash when attempting to process transactions, resulting in immediate liveness failure for that validator
- **Network Availability Impact**: If multiple validators are affected simultaneously (e.g., through a coordinated misconfiguration or compromised deployment pipeline), the network could experience significant degradation or consensus stalls
- **Significant Protocol Violation**: The mempool becomes completely non-functional, preventing the node from participating in consensus

Per the Aptos Bug Bounty criteria, this qualifies as **High Severity** due to "Validator node slowdowns" and "Significant protocol violations." 

If this affects enough validators to cause consensus disruption, it could escalate to **Critical Severity** due to "Total loss of liveness/network availability."

## Likelihood Explanation

**Medium-to-High Likelihood:**

- **Configuration Error Scenario**: Node operators could accidentally set `num_sender_buckets: 0` during configuration, especially given the lack of validation or documentation warnings
- **Deployment Pipeline Attack**: An attacker who gains access to configuration management systems could inject this value across multiple nodes
- **Zero Protection**: The complete absence of validation (explicit TODO comment) makes this vulnerability immediately exploitable upon misconfiguration
- **Immediate Trigger**: Any transaction submission immediately triggers the panic, making the vulnerability deterministic once the configuration is applied

The vulnerability requires configuration-level access but no special privileges or exploitation techniques beyond setting a config value to 0.

## Recommendation

Implement mandatory validation in the `MempoolConfig::sanitize()` function to ensure `num_sender_buckets` is always greater than zero:

```rust
impl ConfigSanitizer for MempoolConfig {
    fn sanitize(
        _node_config: &NodeConfig,
        _node_type: NodeType,
        _chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        if self.num_sender_buckets == 0 {
            return Err(Error::ConfigSanitizer(
                "num_sender_buckets must be greater than 0".to_string()
            ));
        }
        // Add other validations as needed
        Ok(())
    }
}
```

Additionally, add a defensive check in the `sender_bucket()` function itself:

```rust
pub fn sender_bucket(
    address: &AccountAddress,
    num_sender_buckets: MempoolSenderBucket,
) -> MempoolSenderBucket {
    assert!(num_sender_buckets > 0, "num_sender_buckets must be greater than 0");
    address.as_ref()[address.as_ref().len() - 1] as MempoolSenderBucket % num_sender_buckets
}
```

## Proof of Concept

**Configuration File PoC** (`config.yaml`):
```yaml
mempool:
  num_sender_buckets: 0  # Trigger division by zero
  capacity: 1000000
  # ... other config values
```

**Rust Test PoC**:
```rust
#[test]
#[should_panic(expected = "attempt to calculate the remainder with a divisor of zero")]
fn test_sender_bucket_zero_division() {
    use aptos_types::account_address::AccountAddress;
    use crate::core_mempool::transaction_store::sender_bucket;
    
    let address = AccountAddress::random();
    let num_sender_buckets = 0u8;
    
    // This will panic with division by zero
    let _ = sender_bucket(&address, num_sender_buckets);
}
```

**Execution Steps:**
1. Start an Aptos node with `num_sender_buckets: 0` in mempool configuration
2. Submit any transaction via API: `aptos move run --function-id 0x1::aptos_account::transfer ...`
3. Observe node crash with panic: `thread 'main' panicked at 'attempt to calculate the remainder with a divisor of zero'`
4. Node mempool becomes permanently non-functional until configuration is corrected and node is restarted

**Notes**

This vulnerability demonstrates a critical gap in configuration validation that allows a misconfiguration to cause immediate and complete node failure. While the original question focused on the silent failure aspect of `PeerSyncState` updates, the division by zero panic is the primary security concern as it completely disables the node before any peer synchronization can occur. The lack of validation in the `ConfigSanitizer` (marked with a TODO comment) directly enables this vulnerability.

### Citations

**File:** mempool/src/shared_mempool/types.rs (L263-275)
```rust
    pub fn new(num_broadcast_buckets: usize, num_sender_buckets: MempoolSenderBucket) -> Self {
        let mut timelines = HashMap::new();
        for i in 0..num_sender_buckets {
            timelines.insert(
                i as MempoolSenderBucket,
                MultiBucketTimelineIndexIds::new(num_broadcast_buckets),
            );
        }
        PeerSyncState {
            timelines,
            broadcast_info: BroadcastInfo::new(),
        }
    }
```

**File:** mempool/src/core_mempool/transaction_store.rs (L42-47)
```rust
pub fn sender_bucket(
    address: &AccountAddress,
    num_sender_buckets: MempoolSenderBucket,
) -> MempoolSenderBucket {
    address.as_ref()[address.as_ref().len() - 1] as MempoolSenderBucket % num_sender_buckets
}
```

**File:** mempool/src/core_mempool/transaction_store.rs (L215-215)
```rust
        let sender_bucket = sender_bucket(sender, self.num_sender_buckets);
```

**File:** mempool/src/core_mempool/transaction_store.rs (L554-554)
```rust
                let sender_bucket = sender_bucket(address, self.num_sender_buckets);
```

**File:** mempool/src/core_mempool/transaction_store.rs (L744-744)
```rust
        let sender_bucket = sender_bucket(&txn.get_sender(), self.num_sender_buckets);
```

**File:** config/src/config/mempool_config.rs (L97-97)
```rust
    pub num_sender_buckets: u8,
```

**File:** config/src/config/mempool_config.rs (L176-183)
```rust
impl ConfigSanitizer for MempoolConfig {
    fn sanitize(
        _node_config: &NodeConfig,
        _node_type: NodeType,
        _chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        Ok(()) // TODO: add reasonable verifications
    }
```
