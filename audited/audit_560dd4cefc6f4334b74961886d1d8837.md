# Audit Report

## Title
Division by Zero in Proposer Election Causes Validator Crash with All-Zero Voting Powers

## Summary
The `choose_index()` function in the proposer election mechanism lacks validation for all-zero weights, causing a division by zero panic that crashes validator nodes when all validators have zero voting power.

## Finding Description

The vulnerability exists in the proposer election logic where validators with zero voting power can remain in the active validator set under specific configurations, leading to a panic when selecting a proposer. [1](#0-0) 

The `choose_index()` function computes `total_weight` by summing all weights. When all weights are zero, `total_weight` becomes 0. [2](#0-1) 

The `next_in_range()` function performs modulo operation `% max` where `max = total_weight`. When `max = 0`, this causes a division by zero panic in Rust.

The stake weights are calculated by multiplying reputation weights with validator voting powers: [3](#0-2) 

If all validators have zero voting power (`voting_powers[i] = 0`), then all `stake_weights` become zero regardless of reputation weights.

The critical gap exists in the staking configuration validation: [4](#0-3) 

The validation allows `minimum_stake = 0`, and during epoch reconfiguration: [5](#0-4) 

Validators with zero voting power pass the check `voting_power >= minimum_stake` when `minimum_stake = 0`, remaining in the active set.

The Move framework explicitly handles the possibility of zero total voting power: [6](#0-5) 

However, the Rust consensus code does not handle this edge case, creating a mismatch between what the Move layer allows and what the consensus layer can handle.

## Impact Explanation

**Critical Severity** - This issue causes complete loss of network liveness:
- All validators attempting proposer election will panic and crash
- Network becomes completely unavailable, unable to produce blocks
- Requires emergency intervention or hard fork to recover
- Meets "Total loss of liveness/network availability" criteria per bug bounty

## Likelihood Explanation

**Low Likelihood in Production Networks**, but possible through:

1. **Genesis Misconfiguration**: If `minimum_stake = 0` at genesis with validators having zero initial stake
2. **Governance Configuration Error**: Governance proposal setting `minimum_stake = 0` combined with validators having zero stake

While unlikely in a properly configured production network, this represents a critical defensive programming failure that should be fixed to prevent catastrophic failure in edge cases that the Move framework explicitly allows.

## Recommendation

Add validation in `choose_index()` to handle zero total weight:

```rust
pub(crate) fn choose_index(mut weights: Vec<u128>, state: Vec<u8>) -> usize {
    assert!(!weights.is_empty(), "Cannot choose from empty weights vector");
    
    let mut total_weight = 0;
    for w in &mut weights {
        total_weight = total_weight
            .checked_add(w)
            .expect("Total stake shouldn't exceed u128::MAX");
        *w = total_weight;
    }
    
    assert!(total_weight > 0, "Cannot choose with all-zero weights");
    
    let chosen_weight = next_in_range(state, total_weight);
    weights
        .binary_search_by(|w| {
            if *w <= chosen_weight {
                Ordering::Less
            } else {
                Ordering::Greater
            }
        })
        .expect_err("Comparison never returns equals, so it's always guaranteed to be error")
}
```

Additionally, add validation in `LeaderReputation::new()` to prevent construction with all-zero voting powers, and add a check in `stake.move` to ensure at least one validator has non-zero voting power before completing epoch transition.

## Proof of Concept

```rust
#[test]
#[should_panic(expected = "divide by zero")]
fn test_choose_index_all_zero_weights() {
    let weights = vec![0u128, 0u128, 0u128];
    let state = vec![1u8, 2u8, 3u8];
    choose_index(weights, state);
}

#[test]
#[should_panic(expected = "Cannot choose from empty weights vector")]
fn test_choose_index_empty_weights() {
    let weights = vec![];
    let state = vec![1u8, 2u8, 3u8];
    choose_index(weights, state);
}
```

**Notes:**

While this is a valid code-level bug causing a panic, its exploitability as a security vulnerability is limited because triggering it requires either genesis misconfiguration or governance control to set `minimum_stake = 0`. An unprivileged attacker cannot directly cause all validators to have zero voting power. This is primarily a defensive programming issue that should be fixed to ensure the consensus layer can handle all states that the Move layer permits.

### Citations

**File:** consensus/src/liveness/proposer_election.rs (L39-46)
```rust
fn next_in_range(state: Vec<u8>, max: u128) -> u128 {
    // hash = SHA-3-256(state)
    let hash = aptos_crypto::HashValue::sha3_256_of(&state).to_vec();
    let mut temp = [0u8; 16];
    copy_slice_to_vec(&hash[..16], &mut temp).expect("next failed");
    // return hash[0..16]
    u128::from_le_bytes(temp) % max
}
```

**File:** consensus/src/liveness/proposer_election.rs (L49-69)
```rust
pub(crate) fn choose_index(mut weights: Vec<u128>, state: Vec<u8>) -> usize {
    let mut total_weight = 0;
    // Create cumulative weights vector
    // Since we own the vector, we can safely modify it in place
    for w in &mut weights {
        total_weight = total_weight
            .checked_add(w)
            .expect("Total stake shouldn't exceed u128::MAX");
        *w = total_weight;
    }
    let chosen_weight = next_in_range(state, total_weight);
    weights
        .binary_search_by(|w| {
            if *w <= chosen_weight {
                Ordering::Less
            } else {
                Ordering::Greater
            }
        })
        .expect_err("Comparison never returns equals, so it's always guaranteed to be error")
}
```

**File:** consensus/src/liveness/leader_reputation.rs (L711-732)
```rust
        let stake_weights: Vec<u128> = weights
            .iter_mut()
            .enumerate()
            .map(|(i, w)| *w as u128 * self.voting_powers[i] as u128)
            .collect();

        let state = if self.use_root_hash {
            [
                root_hash.to_vec(),
                self.epoch.to_le_bytes().to_vec(),
                round.to_le_bytes().to_vec(),
            ]
            .concat()
        } else {
            [
                self.epoch.to_le_bytes().to_vec(),
                round.to_le_bytes().to_vec(),
            ]
            .concat()
        };

        let chosen_index = choose_index(stake_weights, state);
```

**File:** aptos-move/framework/aptos-framework/sources/configs/staking_config.move (L372-374)
```text
    fun validate_required_stake(minimum_stake: u64, maximum_stake: u64) {
        assert!(minimum_stake <= maximum_stake && maximum_stake > 0, error::invalid_argument(EINVALID_STAKE_RANGE));
    }
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1390-1398)
```text
            // A validator needs at least the min stake required to join the validator set.
            if (new_validator_info.voting_power >= minimum_stake) {
                spec {
                    assume total_voting_power + new_validator_info.voting_power <= MAX_U128;
                };
                total_voting_power = total_voting_power + (new_validator_info.voting_power as u128);
                vector::push_back(&mut next_epoch_validators, new_validator_info);
            };
            i = i + 1;
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1863-1869)
```text
        // Only validator voting power increase if the current validator set's voting power > 0.
        if (validator_set.total_voting_power > 0) {
            assert!(
                validator_set.total_joining_power <= validator_set.total_voting_power * voting_power_increase_limit / 100,
                error::invalid_argument(EVOTING_POWER_INCREASE_EXCEEDS_LIMIT),
            );
        }
```
