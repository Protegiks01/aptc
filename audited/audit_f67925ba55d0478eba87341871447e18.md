# Audit Report

## Title
Missing Authentication in GetDataServiceForRequest Exposes Internal Service Topology

## Summary
The `GetDataServiceForRequest` RPC method in the Indexer gRPC Manager service lacks authentication checks, allowing unauthenticated attackers to query and obtain internal data service addresses, exposing the infrastructure topology.

## Finding Description

The `GrpcManagerService::get_data_service_for_request` method processes requests without any authentication or authorization checks. [1](#0-0) 

The method directly extracts the request parameters and returns data service addresses to any caller. The implementation immediately proceeds to service selection logic without validating the caller's identity or authorization: [2](#0-1) 

The response contains sensitive infrastructure information - the network address of internal data services: [3](#0-2) 

The GrpcManager server is configured without any authentication interceptor or middleware: [4](#0-3) 

While the codebase defines authentication headers such as `GRPC_AUTH_TOKEN_HEADER` and `GRPC_API_GATEWAY_API_KEY_HEADER`: [5](#0-4) 

These headers are never checked by the GrpcManager service. The Gateway component that calls this endpoint also does not pass any authentication credentials: [6](#0-5) 

An attacker can send a gRPC request to the GrpcManager service and receive back the addresses of live or historical data services, revealing the internal network topology without any authentication.

## Impact Explanation

This vulnerability falls under **High Severity** per the Aptos bug bounty criteria as it represents a "Significant protocol violation" in the indexer infrastructure's security model. The exposed information includes:

1. **Service Discovery**: Internal data service addresses (both live and historical)
2. **Infrastructure Mapping**: Number and location of backend services
3. **Load Information**: Stream counts revealing service utilization

While this does not directly affect consensus, state integrity, or funds (as the indexer-grpc is auxiliary infrastructure), it violates the principle of least privilege and defense-in-depth. An attacker gaining service topology knowledge could:
- Target specific data services directly if they're network-accessible
- Perform reconnaissance for further attacks
- Identify high-load services for potential DoS attempts

## Likelihood Explanation

**Likelihood: HIGH**

The vulnerability is trivially exploitable:
- No special tools or knowledge required beyond standard gRPC clients
- No authentication credentials needed
- The endpoint is designed to be called by the Gateway, so it must be network-accessible
- The attack can be automated and scaled

The only limiting factor is whether the GrpcManager service port is exposed to external networks. However, since the Gateway must reach it, it requires network accessibility, making exploitation feasible for any attacker with network access to the infrastructure.

## Recommendation

Implement authentication and authorization checks in the `get_data_service_for_request` method. Options include:

1. **Add gRPC Interceptor**: Implement a server-side interceptor that validates authentication tokens before allowing requests to reach the service methods.

2. **Service-Level Authentication**: Add authentication checks within the method:

```rust
async fn get_data_service_for_request(
    &self,
    request: Request<GetDataServiceForRequestRequest>,
) -> Result<Response<GetDataServiceForRequestResponse>, Status> {
    // Validate authentication token from request metadata
    let token = request
        .metadata()
        .get(GRPC_AUTH_TOKEN_HEADER)
        .ok_or_else(|| Status::unauthenticated("Missing authentication token"))?;
    
    // Verify token is in whitelist or validate via auth service
    if !self.auth_service.validate_token(token) {
        return Err(Status::permission_denied("Invalid authentication token"));
    }
    
    // Continue with existing logic...
}
```

3. **Network-Level Controls**: If the GrpcManager is intended for internal use only, implement strict network policies (VPC isolation, security groups, network policies) to ensure it's not accessible from untrusted networks.

4. **Gateway Integration**: Ensure the Gateway passes authentication credentials when calling GetDataServiceForRequest, and validate those credentials server-side.

## Proof of Concept

```rust
// PoC: Unauthenticated request to GetDataServiceForRequest
use aptos_protos::indexer::v1::{
    grpc_manager_client::GrpcManagerClient,
    GetDataServiceForRequestRequest,
    GetTransactionsRequest,
};

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Connect to GrpcManager without any authentication
    let mut client = GrpcManagerClient::connect("http://[grpc-manager-address]:50051").await?;
    
    // Create request with arbitrary starting version
    let user_request = GetTransactionsRequest {
        starting_version: Some(1000),
        transactions_count: None,
        batch_size: None,
        transaction_filter: None,
    };
    
    let request = tonic::Request::new(GetDataServiceForRequestRequest {
        user_request: Some(user_request),
    });
    
    // No authentication headers set - request should be rejected but isn't
    let response = client.get_data_service_for_request(request).await?;
    
    // Successfully receives internal service address without authentication
    println!("Exposed data service address: {}", response.into_inner().data_service_address);
    
    Ok(())
}
```

**Notes:**
- This vulnerability is in the indexer-grpc auxiliary infrastructure, not the core blockchain consensus or state management systems
- It does not directly impact validator operations, consensus safety, state integrity, or fund security
- The severity is based on information disclosure and defense-in-depth principles
- Exploitation requires network access to the GrpcManager service, which depends on deployment configuration

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/service.rs (L148-196)
```rust
    async fn get_data_service_for_request(
        &self,
        request: Request<GetDataServiceForRequestRequest>,
    ) -> Result<Response<GetDataServiceForRequestResponse>, Status> {
        let request = request.into_inner();

        if request.user_request.is_none()
            || request
                .user_request
                .as_ref()
                .unwrap()
                .starting_version
                .is_none()
        {
            let candidates = self.metadata_manager.get_live_data_services_info();
            if let Some(candidate) = candidates.iter().next() {
                let data_service_address = candidate.0.clone();
                return Ok(Response::new(GetDataServiceForRequestResponse {
                    data_service_address,
                }));
            } else {
                return Err(Status::internal(
                    "Cannot find a data service instance to serve the provided request.",
                ));
            }
        }

        let starting_version = request.user_request.unwrap().starting_version();

        let data_service_address =
            // TODO(grao): Use a simple strategy for now. Consider to make it smarter in the
            // future.
            if let Some(address) = self.pick_live_data_service(starting_version) {
                COUNTER.with_label_values(&["live_data_service_picked"]).inc();
                address
            } else if let Some(address) = self.pick_historical_data_service(starting_version).await {
                COUNTER.with_label_values(&["historical_data_service_picked"]).inc();
                address
            } else {
                COUNTER.with_label_values(&["failed_to_pick_data_service"]).inc();
                return Err(Status::internal(
                    "Cannot find a data service instance to serve the provided request.",
                ));
            };

        Ok(Response::new(GetDataServiceForRequestResponse {
            data_service_address,
        }))
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/grpc_manager.rs (L92-100)
```rust
        let service = GrpcManagerServer::new(GrpcManagerService::new(
            self.chain_id,
            self.metadata_manager.clone(),
            self.data_manager.clone(),
        ))
        .send_compressed(CompressionEncoding::Zstd)
        .accept_compressed(CompressionEncoding::Zstd)
        .max_encoding_message_size(MAX_MESSAGE_SIZE)
        .max_decoding_message_size(MAX_MESSAGE_SIZE);
```

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/constants.rs (L13-17)
```rust
pub const GRPC_AUTH_TOKEN_HEADER: &str = "x-aptos-data-authorization";
// GRPC request metadata key for the request name. This is used to identify the
// data destination.
pub const GRPC_REQUEST_NAME_HEADER: &str = "x-aptos-request-name";
pub const GRPC_API_GATEWAY_API_KEY_HEADER: &str = "authorization";
```

**File:** ecosystem/indexer-grpc/indexer-grpc-gateway/src/gateway.rs (L138-147)
```rust
    let mut client = GrpcManagerClient::connect(config.grpc_manager_address.to_string())
        .await
        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;
    let grpc_manager_request =
        tonic::Request::new(GetDataServiceForRequestRequest { user_request });
    let response: GetDataServiceForRequestResponse = client
        .get_data_service_for_request(grpc_manager_request)
        .await
        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?
        .into_inner();
```
