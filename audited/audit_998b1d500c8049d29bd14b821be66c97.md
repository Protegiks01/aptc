# Audit Report

## Title
DKG Chunky PVSS Transcript Inner Dimension Validation Bypass Causes Consensus Node Crash

## Summary
The `verify()` function in the chunky weighted PVSS transcript implementation only validates outer array dimensions but fails to check inner dimension consistency between `Cs` and `Vs` arrays. This allows a malicious validator to craft a transcript that passes verification but causes validator nodes to panic during transcript aggregation, resulting in consensus failure.

## Finding Description

The vulnerability exists in the transcript verification logic that validates multi-dimensional array structures without checking per-player dimension consistency.

**Data Structure:**

The transcript contains two multi-dimensional arrays: [1](#0-0) 

- `Cs: Vec<Vec<Vec<E::G1>>>` - 3D array where `Cs[player][weight_index][chunk]`
- `Vs: Vec<Vec<E::G2>>` - 2D array where `Vs[player][weight_index]`

**Expected Invariant:**
For each player `i`, both `Cs[i].len()` and `Vs[i].len()` should equal `weight[i]`.

**Insufficient Validation:**

The verification only checks outer dimensions: [2](#0-1) 

These checks ensure `Cs.len() == Vs.len() == num_players`, but do NOT validate that `Cs[i].len() == Vs[i].len()` for each player `i`.

Additional validation only checks the total flattened count: [3](#0-2) 

This ensures total ciphertext count equals total weight, but allows arbitrary distribution across players (e.g., player 0 could have all ciphertexts while player 1 has none, as long as the total matches).

**Exploitation During Aggregation:**

When transcripts are aggregated, the code iterates using `Vs[i].len()` and directly accesses `Cs[i][j]`: [4](#0-3) 

The `debug_assert` checks are only enforced in debug builds: [5](#0-4) 

If `Cs[i].len() < Vs[i].len()`, accessing `self.Cs[i][j]` when `j >= Cs[i].len()` causes an index out of bounds panic.

**Attack Path:**

1. Malicious validator crafts transcript with mismatched inner dimensions (e.g., `Cs[0].len() = 1` but `Vs[0].len() = 2`)
2. Adjusts other players' dimensions so total flattened count still equals `sc.get_total_weight()`
3. Transcript passes `verify()` since only outer dimensions and total count are checked
4. Honest nodes receive and verify the transcript - it passes all checks
5. During DKG consensus aggregation via `TranscriptAggregationState::add()`: [6](#0-5) 

6. When `aggregate_transcripts()` is called: [7](#0-6) 

7. The `.expect()` propagates the panic from `aggregate_with()`, crashing the validator node

## Impact Explanation

**Critical Severity** - This meets the Critical impact category of "Total Loss of Liveness/Network Availability":

1. **Consensus Liveness Violation**: Validators attempting to aggregate transcripts crash, preventing consensus progress. If enough validators crash, the network cannot reach quorum.

2. **Total Network Halt**: A single malicious transcript broadcast to the network causes all honest validators attempting to aggregate it to crash, halting DKG and preventing epoch transitions.

3. **Non-Recoverable Without Intervention**: Once the malicious transcript enters the aggregation state, validators will continuously crash when attempting to process it. Recovery requires manual intervention to remove the malicious transcript or restart nodes with patched code.

The attack requires no special privileges beyond being a validator during DKG, and the impact affects the entire validator set simultaneously. This clearly meets the Aptos bug bounty Critical severity definition: "Network halts due to protocol bug, all validators unable to progress."

## Likelihood Explanation

**High Likelihood:**

- **Low Complexity**: Crafting the malicious transcript only requires understanding the expected data structure and deliberately mismatching inner dimensions while maintaining correct outer dimensions and total counts.

- **No Special Access Required**: Any validator participating in DKG can submit such a transcript. No collusion or majority stake is needed.

- **Deterministic Exploitation**: Once the malicious transcript is created, the exploitation is guaranteed - all nodes attempting aggregation will crash.

- **Direct Attack Surface**: DKG transcript submission is a normal protocol operation, making detection difficult without the fix.

The only barrier is that the attacker must be part of the validator set during a DKG session, which is achievable through normal stake-based participation.

## Recommendation

Add per-player dimension consistency validation in the `verify()` function. After the existing outer dimension checks, add:

```rust
// Validate per-player dimension consistency
for i in 0..sc.get_total_num_players() {
    let expected_weight = sc.get_player_weight(&sc.get_player(i));
    if self.subtrs.Cs[i].len() != expected_weight {
        bail!(
            "Player {} has {} ciphertext arrays but weight is {}",
            i,
            self.subtrs.Cs[i].len(),
            expected_weight
        );
    }
    if self.subtrs.Vs[i].len() != expected_weight {
        bail!(
            "Player {} has {} commitment arrays but weight is {}",
            i,
            self.subtrs.Vs[i].len(),
            expected_weight
        );
    }
}
```

This ensures that for each player, both `Cs[i].len()` and `Vs[i].len()` equal their assigned weight, preventing the index out of bounds panic during aggregation.

## Proof of Concept

A complete PoC would require:
1. Setting up a DKG test environment with multiple validators
2. Crafting a transcript where `Cs[0].len() = 1` but `Vs[0].len() = 2`, adjusting other players' dimensions to maintain correct total weight
3. Submitting the transcript and observing validator crashes during aggregation

The vulnerability is evident from the code structure - the verification logic allows the malicious transcript structure, and the aggregation logic deterministically panics when accessing the out-of-bounds index.

### Citations

**File:** crates/aptos-dkg/src/pvss/chunky/weighted_transcript.rs (L84-87)
```rust
    pub Vs: Vec<Vec<E::G2>>,
    /// First chunked ElGamal component: C[i][j] = s_{i,j} * G + r_j * ek_i. Here s_i = \sum_j s_{i,j} * B^j // TODO: change notation because B is not a group element?
    #[serde(serialize_with = "ark_se", deserialize_with = "ark_de")]
    pub Cs: Vec<Vec<Vec<E::G1>>>, // TODO: maybe make this and the other fields affine? The verifier will have to do it anyway... and we are trying to speed that up
```

**File:** crates/aptos-dkg/src/pvss/chunky/weighted_transcript.rs (L140-152)
```rust
        if self.subtrs.Cs.len() != sc.get_total_num_players() {
            bail!(
                "Expected {} arrays of chunked ciphertexts, but got {}",
                sc.get_total_num_players(),
                self.subtrs.Cs.len()
            );
        }
        if self.subtrs.Vs.len() != sc.get_total_num_players() {
            bail!(
                "Expected {} arrays of commitment elements, but got {}",
                sc.get_total_num_players(),
                self.subtrs.Vs.len()
            );
```

**File:** crates/aptos-dkg/src/pvss/chunky/weighted_transcript.rs (L247-252)
```rust
        let Cs_flat: Vec<_> = self.subtrs.Cs.iter().flatten().cloned().collect();
        assert_eq!(
            Cs_flat.len(),
            sc.get_total_weight(),
            "Number of ciphertexts does not equal number of weights"
        ); // TODO what if zero weight?
```

**File:** crates/aptos-dkg/src/pvss/chunky/weighted_transcript.rs (L388-392)
```rust
        debug_assert_eq!(self.Cs.len(), sc.get_total_num_players());
        debug_assert_eq!(self.Vs.len(), sc.get_total_num_players());
        debug_assert_eq!(self.Cs.len(), other.Cs.len());
        debug_assert_eq!(self.Rs.len(), other.Rs.len());
        debug_assert_eq!(self.Vs.len(), other.Vs.len());
```

**File:** crates/aptos-dkg/src/pvss/chunky/weighted_transcript.rs (L397-405)
```rust
        for i in 0..sc.get_total_num_players() {
            for j in 0..self.Vs[i].len() {
                // Aggregate the V_{i,j}s
                self.Vs[i][j] += other.Vs[i][j];
                for k in 0..self.Cs[i][j].len() {
                    // Aggregate the C_{i,j,k}s
                    self.Cs[i][j][k] += other.Cs[i][j][k];
                }
            }
```

**File:** dkg/src/transcript_aggregation/mod.rs (L118-118)
```rust
            S::aggregate_transcripts(&self.dkg_pub_params, agg_trx, transcript);
```

**File:** types/src/dkg/real_dkg/mod.rs (L408-411)
```rust
        accumulator
            .main
            .aggregate_with(&params.pvss_config.wconfig, &element.main)
            .expect("Transcript aggregation failed");
```
