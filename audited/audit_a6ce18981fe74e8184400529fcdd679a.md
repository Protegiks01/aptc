# Audit Report

## Title
Transaction Filter Bypass via Multisig Transactions with Empty Payloads

## Summary
The transaction filter's `matches_entry_function()` function returns `false` for multisig transactions with `None` payloads due to `unwrap_or(false)`, allowing attackers to bypass mempool and consensus filters by submitting multisig transactions with empty payloads while the actual blocked entry function payload is stored on-chain.

## Finding Description

The vulnerability exists in the transaction filtering logic for multisig transactions. When a transaction filter is configured to deny specific entry functions, the filter checks the transaction's payload to determine if it should be blocked. However, for multisig transactions, the implementation has a critical flaw. [1](#0-0) 

When a multisig transaction has `transaction_payload: None`, the `unwrap_or(false)` returns `false`, meaning the entry function matcher does not match this transaction. Since the filter rule requires ALL matchers to match for the rule to apply, the Deny rule fails to trigger, and the transaction is allowed through by default. [2](#0-1) 

The filter is applied in both mempool and consensus contexts: [3](#0-2) [4](#0-3) 

**Attack Flow:**

1. **On-chain Transaction Creation**: Attacker creates a multisig transaction on-chain with the full payload that calls a blocked entry function: [5](#0-4) 

The filter checks if `create_transaction` itself is blocked (it's not), so this passes. The blocked entry function payload is now stored on-chain.

2. **Filter Bypass**: Attacker submits a `SignedTransaction` with `TransactionPayload::Multisig` where `transaction_payload = None`. The filter checks this transaction, and because the payload is `None`, returns `false` from the matcher, allowing the transaction through.

3. **Prologue Validation**: During validation, the empty payload bypasses the payload mismatch check because the validation only occurs when the provided payload is non-empty: [6](#0-5) [7](#0-6) 

Since `!vector::is_empty(&payload)` is `false` when the payload is empty, the validation check is skipped.

4. **Execution with On-chain Payload**: During execution, the VM retrieves the actual payload from on-chain storage: [8](#0-7) 

The stored payload (containing the blocked entry function) is returned and executed, bypassing the filter.

This breaks the **Transaction Validation** invariant: filters are security controls that must be enforced consistently to protect against execution of malicious or vulnerable contracts.

## Impact Explanation

This is a **High Severity** vulnerability as it constitutes a significant protocol violation:

- **Security Control Bypass**: Transaction filters are critical security mechanisms used by node operators to prevent execution of known vulnerable or malicious smart contracts. This bypass completely undermines their effectiveness.

- **Operator Intent Violation**: When operators configure filters to block specific entry functions (e.g., to mitigate a zero-day vulnerability in a deployed contract), they expect these filters to be comprehensive. This bypass allows attackers to execute the exact code that operators intended to block.

- **Network-Wide Impact**: Both mempool filters and consensus filters can be bypassed, affecting the entire network's ability to enforce security policies.

- **Real-World Scenario**: If a critical vulnerability is discovered in a popular protocol, operators may deploy filters as an emergency measure while a fix is being developed. This bypass would allow continued exploitation during that window.

The impact does not reach Critical severity as it does not directly cause loss of funds, consensus violations, or network partition. However, it enables attackers to bypass intended security controls, which could facilitate other attacks.

## Likelihood Explanation

**High Likelihood:**

- **Low Complexity**: The attack requires only standard multisig account functionality - no special privileges or complex setup.

- **No Special Requirements**: Any user who is an owner of a multisig account can execute this attack. Multisig accounts are a standard feature widely used in the Aptos ecosystem.

- **Deterministic**: The vulnerability is in the code logic, not a race condition or timing-dependent issue. It will work reliably every time.

- **Clear Motivation**: When filters are deployed (usually in response to security incidents), attackers have strong incentive to find bypasses.

- **Easy Discovery**: The vulnerability is evident from reading the filter matching logic - the `unwrap_or(false)` pattern is a clear indicator.

## Recommendation

Modify the `matches_entry_function()` function to check the on-chain stored payload when a multisig transaction has `None` payload. This would require:

1. Adding state access capability to the filter matching logic
2. Retrieving the stored payload from the multisig account resource
3. Checking the stored payload against the filter rules

Alternatively, enhance the filter to match multisig transactions by their multisig address and require operators to filter at that level when concerned about specific multisig accounts.

## Proof of Concept

A complete PoC would require:
1. Creating a multisig account
2. Calling `create_transaction` with a blocked entry function payload
3. Configuring a filter to deny that specific entry function
4. Submitting an execution transaction with empty payload
5. Verifying that the filter doesn't block it but the blocked function executes

The vulnerability is evident from the code structure shown in the citations above.

## Notes

This vulnerability demonstrates a gap between the filter's design (checking submitted payloads) and its intended purpose (blocking specific code execution). The filter system was designed to inspect transaction payloads at submission time, but multisig transactions with on-chain stored payloads decouple submission from execution payload, creating this bypass vector.

### Citations

**File:** crates/aptos-transaction-filters/src/transaction_filter.rs (L158-166)
```rust
    fn matches(&self, signed_transaction: &SignedTransaction) -> bool {
        let transaction_matchers = match self {
            TransactionRule::Allow(matchers) => matchers,
            TransactionRule::Deny(matchers) => matchers,
        };
        transaction_matchers
            .iter()
            .all(|matcher| matcher.matches(signed_transaction))
    }
```

**File:** crates/aptos-transaction-filters/src/transaction_filter.rs (L342-350)
```rust
        TransactionPayload::Multisig(multisig) => multisig
            .transaction_payload
            .as_ref()
            .map(|payload| match payload {
                MultisigTransactionPayload::EntryFunction(entry_function) => {
                    compare_entry_function(entry_function, address, module_name, function)
                },
            })
            .unwrap_or(false),
```

**File:** mempool/src/shared_mempool/tasks.rs (L408-437)
```rust
fn filter_transactions(
    transaction_filter_config: &TransactionFilterConfig,
    transactions: Vec<(
        SignedTransaction,
        Option<u64>,
        Option<BroadcastPeerPriority>,
    )>,
    statuses: &mut Vec<(SignedTransaction, (MempoolStatus, Option<StatusCode>))>,
) -> Vec<(
    SignedTransaction,
    Option<u64>,
    Option<BroadcastPeerPriority>,
)> {
    // If the filter is not enabled, return early
    if !transaction_filter_config.is_enabled() {
        return transactions;
    }

    // Start the filter processing timer
    let transaction_filter_timer = counters::PROCESS_TXN_BREAKDOWN_LATENCY
        .with_label_values(&[counters::FILTER_TRANSACTIONS_LABEL])
        .start_timer();

    // Filter the transactions and update the statuses accordingly
    let transactions = transactions
        .into_iter()
        .filter_map(|(transaction, account_sequence_number, priority)| {
            if transaction_filter_config
                .transaction_filter()
                .allows_transaction(&transaction)
```

**File:** consensus/src/block_preparer.rs (L91-98)
```rust
            let filtered_txns = filter_block_transactions(
                txn_filter_config,
                block_id,
                block_author,
                block_epoch,
                block_timestamp_usecs,
                txns,
            );
```

**File:** aptos-move/framework/aptos-framework/sources/multisig_account.move (L393-404)
```text
    public fun get_next_transaction_payload(
        multisig_account: address, provided_payload: vector<u8>): vector<u8> acquires MultisigAccount {
        let multisig_account_resource = borrow_global<MultisigAccount>(multisig_account);
        let sequence_number = multisig_account_resource.last_executed_sequence_number + 1;
        let transaction = table::borrow(&multisig_account_resource.transactions, sequence_number);

        if (option::is_some(&transaction.payload)) {
            *option::borrow(&transaction.payload)
        } else {
            provided_payload
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/multisig_account.move (L954-973)
```text
    public entry fun create_transaction(
        owner: &signer,
        multisig_account: address,
        payload: vector<u8>,
    ) acquires MultisigAccount {
        assert!(vector::length(&payload) > 0, error::invalid_argument(EPAYLOAD_CANNOT_BE_EMPTY));

        assert_multisig_account_exists(multisig_account);
        assert_is_owner(owner, multisig_account);

        let creator = address_of(owner);
        let transaction = MultisigTransaction {
            payload: option::some(payload),
            payload_hash: option::none<vector<u8>>(),
            votes: simple_map::create<address, bool>(),
            creator,
            creation_time_secs: now_seconds(),
        };
        add_transaction(creator, multisig_account, transaction);
    }
```

**File:** aptos-move/framework/aptos-framework/sources/multisig_account.move (L1173-1182)
```text
        if (features::abort_if_multisig_payload_mismatch_enabled()
            && option::is_some(&transaction.payload)
            && !vector::is_empty(&payload)
        ) {
            let stored_payload = option::borrow(&transaction.payload);
            assert!(
                payload == *stored_payload,
                error::invalid_argument(EPAYLOAD_DOES_NOT_MATCH),
            );
        }
```

**File:** aptos-move/aptos-vm/src/transaction_validation.rs (L416-422)
```rust
        TransactionExecutableRef::Empty => {
            if features.is_abort_if_multisig_payload_mismatch_enabled() {
                vec![]
            } else {
                bcs::to_bytes::<Vec<u8>>(&vec![]).map_err(|_| unreachable_error.clone())?
            }
        },
```
