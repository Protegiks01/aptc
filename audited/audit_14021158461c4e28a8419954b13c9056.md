# Audit Report

## Title
State Restoration Corruption: Unvalidated StateStorageUsage Deserialization Breaks Storage Gas Economics and Node Liveness

## Summary
During state restoration from backups, corrupted `StateStorageUsage` data can pass deserialization without validation, leading to incorrect storage gas calculations that break blockchain economics and eventually cause node failure. The lack of validation allows invalid usage values (items/bytes counts) to be restored, which then directly affects the on-chain storage gas pricing mechanism.

## Finding Description

The vulnerability exists in the deserialization and usage of `StateStorageUsage` during backup restoration. The `StateStorageUsage` enum uses automatic serde serialization without validation: [1](#0-0) 

During state restoration, `StateSnapshotProgress` (which contains `StateStorageUsage`) is deserialized from backup data and stored without validation: [2](#0-1) 

The restoration process accumulates usage values and persists them: [3](#0-2) 

**Attack Path:**

1. **Backup Corruption**: A backup file contains corrupted `StateStorageUsage` values in `StateSnapshotProgress` (e.g., `items=100, bytes=10000` instead of correct `items=1000000, bytes=10000000000`)

2. **Unvalidated Deserialization**: During restoration, the corrupted data deserializes successfully with no validation checks

3. **Usage Stored**: The final corrupted usage is written to the ledger database: [4](#0-3) 

4. **Gas Calculation Impact**: When the node starts and processes the first block, the on-chain state storage module reads this corrupted usage via native function: [5](#0-4) 

5. **Storage Gas Manipulation**: The corrupted usage is used to calculate storage gas costs at epoch boundaries: [6](#0-5) 

Since the usage appears artificially low, the utilization ratio becomes incorrect, and gas costs for storage operations are set to near-minimum values, enabling state bloat attacks.

6. **Node Failure**: Eventually, when a state snapshot commit occurs, the consistency check detects the mismatch between stored usage and actual Jellyfish Merkle Tree leaf count: [7](#0-6) 

The node crashes with error: "State item count inconsistent, X from ledger db and Y from state tree."

## Impact Explanation

This is a **HIGH severity** vulnerability per Aptos bug bounty criteria for the following reasons:

1. **Significant Protocol Violations**: Breaks the storage gas pricing mechanism, a core protocol invariant that ensures economic sustainability by dynamically adjusting gas costs based on actual state utilization.

2. **Storage Economics Broken**: If corrupted usage shows artificially low values, attackers can spam the chain with state bloat at minimal gas costs, potentially filling state storage and degrading performance across the entire network.

3. **Node Liveness Failure**: The node eventually fails the consistency check and cannot proceed, causing a denial of service. If multiple nodes restore from the same corrupted backup, this could affect network availability.

4. **State Consistency Violation**: Breaks the critical invariant that state metadata must accurately reflect actual state, which is fundamental to proper chain operation.

## Likelihood Explanation

**Likelihood: Medium-High**

This vulnerability can occur through:

1. **Accidental Corruption**: Storage bit flips, disk errors, or network transmission errors during backup storage/transfer could corrupt the serialized `StateStorageUsage` values while leaving the structure valid for deserialization.

2. **Malicious Backup Providers**: In scenarios where nodes restore from third-party backup services, a compromised or malicious backup provider could intentionally corrupt usage values.

3. **Restoration Interruption**: If restoration is interrupted mid-process and resumes from corrupted progress data, the accumulated usage will be incorrect.

The attack is **highly feasible** because:
- No validation checks exist during deserialization
- Serde's automatic derivation accepts any structurally valid data
- The corruption would not be detected until after restoration completes and normal operation begins
- Multiple nodes could be affected if they all restore from the same corrupted backup source

## Recommendation

Implement validation during `StateStorageUsage` deserialization and after state restoration:

**1. Add custom deserialization with validation:**

```rust
// In types/src/state_store/state_storage_usage.rs
impl StateStorageUsage {
    /// Validates that usage values are reasonable
    pub fn validate(&self) -> Result<(), &'static str> {
        match self {
            Self::Tracked { items, bytes } => {
                // Ensure bytes is proportional to items
                if *items > 0 && *bytes < *items {
                    return Err("Invalid usage: bytes less than items count");
                }
                // Add upper bound check based on known chain limits
                const MAX_STATE_ITEMS: usize = 1_000_000_000; // Adjust based on actual limits
                if *items > MAX_STATE_ITEMS {
                    return Err("Invalid usage: items count exceeds maximum");
                }
                Ok(())
            }
            Self::Untracked => Ok(()),
        }
    }
}
```

**2. Validate during restoration completion:**

```rust
// In storage/aptosdb/src/state_restore/mod.rs
pub fn finish(self) -> Result<()> {
    let progress = self.db.get_progress(self.version)?;
    let usage = progress.map_or(StateStorageUsage::zero(), |p| p.usage);
    
    // Validate usage before finalizing
    usage.validate()
        .map_err(|e| anyhow!("Invalid state usage during restoration: {}", e))?;
    
    self.db.kv_finish(self.version, usage)
}
```

**3. Validate against JMT leaf count after restoration:**

```rust
// Add validation after restoration completes
fn validate_restored_usage(&self, version: Version) -> Result<()> {
    let usage = self.ledger_db.metadata_db().get_usage(version)?;
    let leaf_count = self.state_merkle_db
        .metadata_db()
        .get::<JellyfishMerkleNodeSchema>(&NodeKey::new_empty_path(version))?
        .ok_or_else(|| anyhow!("Root node missing at version {}", version))?
        .leaf_count();
    
    ensure!(
        usage.items() == leaf_count,
        "Restored usage inconsistent: {} items in metadata but {} leaves in tree",
        usage.items(),
        leaf_count
    );
    
    Ok(())
}
```

## Proof of Concept

```rust
#[cfg(test)]
mod state_corruption_test {
    use super::*;
    use aptos_types::state_store::state_storage_usage::StateStorageUsage;
    use aptos_db_indexer_schemas::metadata::StateSnapshotProgress;
    use aptos_crypto::HashValue;
    
    #[test]
    fn test_corrupted_usage_deserialization() {
        // Create a corrupted StateStorageUsage with impossibly low values
        let corrupted_usage = StateStorageUsage::new(10, 100);
        
        // Create StateSnapshotProgress with corrupted usage
        let corrupted_progress = StateSnapshotProgress::new(
            HashValue::zero(),
            corrupted_usage
        );
        
        // Serialize and deserialize (simulating backup/restore)
        let serialized = bcs::to_bytes(&corrupted_progress).unwrap();
        let deserialized: StateSnapshotProgress = bcs::from_bytes(&serialized).unwrap();
        
        // Verify corrupted values pass through without validation
        assert_eq!(deserialized.usage.items(), 10);
        assert_eq!(deserialized.usage.bytes(), 100);
        
        // This would later cause issues when:
        // 1. Gas costs are calculated using these low values
        // 2. Actual state has much more items, causing consistency check failure
    }
    
    #[test]
    fn test_usage_affects_gas_calculation() {
        // Demonstrate how corrupted usage would affect storage gas
        let normal_usage = StateStorageUsage::new(1_000_000, 10_000_000_000);
        let corrupted_usage = StateStorageUsage::new(100, 10_000);
        
        // In practice, these would be passed to storage_gas::on_reconfig()
        // which calculates gas costs based on utilization ratio
        // Corrupted low usage → low utilization ratio → minimal gas costs
        // This enables state bloat attack at minimal cost
        
        println!("Normal usage: {} items, {} bytes", 
                 normal_usage.items(), normal_usage.bytes());
        println!("Corrupted usage: {} items, {} bytes", 
                 corrupted_usage.items(), corrupted_usage.bytes());
    }
}
```

## Notes

**Critical Invariants Broken:**
1. **State Consistency**: The stored `StateStorageUsage` metadata does not match actual state tree leaf count
2. **Resource Limits**: Storage gas costs calculated incorrectly, breaking economic sustainability
3. **Deterministic Execution**: Different nodes restoring from different backups could have different usage values, though they would eventually fail consistency checks

**Additional Context:**
- The consistency check `check_usage_consistency()` only runs during normal operation state commits, not during restoration itself, creating a window where corrupted usage affects gas calculations
- The issue is amplified by the fact that `StateStorageUsage` directly feeds into on-chain storage gas pricing via the native function interface
- While the node eventually detects the inconsistency and fails, the period between restoration and detection allows exploitation of incorrect gas costs

### Citations

**File:** types/src/state_store/state_storage_usage.rs (L6-11)
```rust
#[derive(Copy, Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
#[cfg_attr(any(test, feature = "fuzzing"), derive(proptest_derive::Arbitrary))]
pub enum StateStorageUsage {
    Tracked { items: usize, bytes: usize },
    Untracked,
}
```

**File:** storage/indexer_schemas/src/metadata.rs (L44-54)
```rust
#[derive(Clone, Copy, Debug, Deserialize, Eq, PartialEq, Serialize)]
#[cfg_attr(any(test, feature = "fuzzing"), derive(proptest_derive::Arbitrary))]
pub struct StateSnapshotProgress {
    pub key_hash: HashValue,
    pub usage: StateStorageUsage,
}

impl StateSnapshotProgress {
    pub fn new(key_hash: HashValue, usage: StateStorageUsage) -> Self {
        Self { key_hash, usage }
    }
```

**File:** storage/aptosdb/src/state_restore/mod.rs (L88-127)
```rust
    pub fn add_chunk(&mut self, mut chunk: Vec<(K, V)>) -> Result<()> {
        // load progress
        let progress_opt = self.db.get_progress(self.version)?;

        // skip overlaps
        if let Some(progress) = progress_opt {
            let idx = chunk
                .iter()
                .position(|(k, _v)| CryptoHash::hash(k) > progress.key_hash)
                .unwrap_or(chunk.len());
            chunk = chunk.split_off(idx);
        }

        // quit if all skipped
        if chunk.is_empty() {
            return Ok(());
        }

        // save
        let mut usage = progress_opt.map_or(StateStorageUsage::zero(), |p| p.usage);
        let (last_key, _last_value) = chunk.last().unwrap();
        let last_key_hash = CryptoHash::hash(last_key);

        // In case of TreeOnly Restore, we only restore the usage of KV without actually writing KV into DB
        for (k, v) in chunk.iter() {
            usage.add_item(k.key_size() + v.value_size());
        }

        // prepare the sharded kv batch
        let kv_batch: StateValueBatch<K, Option<V>> = chunk
            .into_iter()
            .map(|(k, v)| ((k, self.version), Some(v)))
            .collect();

        self.db.write_kv_batch(
            self.version,
            &kv_batch,
            StateSnapshotProgress::new(last_key_hash, usage),
        )
    }
```

**File:** storage/aptosdb/src/state_store/mod.rs (L1281-1282)
```rust
    fn kv_finish(&self, version: Version, usage: StateStorageUsage) -> Result<()> {
        self.ledger_db.metadata_db().put_usage(version, usage)?;
```

**File:** aptos-move/framework/src/natives/state_storage.rs (L59-79)
```rust
fn native_get_usage(
    context: &mut SafeNativeContext,
    _ty_args: &[Type],
    _args: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    assert!(_ty_args.is_empty());
    assert!(_args.is_empty());

    context.charge(STATE_STORAGE_GET_USAGE_BASE_COST)?;

    let ctx = context.extensions().get::<NativeStateStorageContext>();
    let usage = ctx.resolver.get_usage().map_err(|err| {
        PartialVMError::new(StatusCode::VM_EXTENSION_ERROR)
            .with_message(format!("Failed to get state storage usage: {}", err))
    })?;

    Ok(smallvec![Value::struct_(Struct::pack(vec![
        Value::u64(usage.items() as u64),
        Value::u64(usage.bytes() as u64),
    ]))])
}
```

**File:** aptos-move/framework/aptos-framework/sources/storage_gas.move (L524-532)
```text
        let (items, bytes) = state_storage::current_items_and_bytes();
        let gas_config = borrow_global<StorageGasConfig>(@aptos_framework);
        let gas = borrow_global_mut<StorageGas>(@aptos_framework);
        gas.per_item_read = calculate_read_gas(&gas_config.item_config, items);
        gas.per_item_create = calculate_create_gas(&gas_config.item_config, items);
        gas.per_item_write = calculate_write_gas(&gas_config.item_config, items);
        gas.per_byte_read = calculate_read_gas(&gas_config.byte_config, bytes);
        gas.per_byte_create = calculate_create_gas(&gas_config.byte_config, bytes);
        gas.per_byte_write = calculate_write_gas(&gas_config.byte_config, bytes);
```

**File:** storage/aptosdb/src/state_store/state_merkle_batch_committer.rs (L150-155)
```rust
        ensure!(
            usage_from_ledger_db.items() == leaf_count_from_jmt,
            "State item count inconsistent, {} from ledger db and {} from state tree.",
            usage_from_ledger_db.items(),
            leaf_count_from_jmt,
        );
```
