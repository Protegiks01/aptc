# Audit Report

## Title
Resource Exhaustion in Move IR Compiler VecPack/VecUnpack Instruction Parsing

## Summary
The Move IR compiler fails to validate the `num` parameter of `vec_pack_N` and `vec_unpack_N` instructions during compilation, allowing an attacker to provide arbitrarily large values that cause resource exhaustion before bytecode verification can reject the invalid input.

## Finding Description

The Move IR compiler processes vector pack/unpack instructions through three stages: lexing, compilation, and verification. A critical validation gap exists between compilation and verification.

**Stage 1 - Lexing (No Bounds Check):**
The lexer parses instruction names like `vec_pack_18446744073709551615` and extracts the numeric suffix as a `u64` with no upper bound validation. [1](#0-0) 

The `Builtin` enum stores this value as a `u64`: [2](#0-1) 

**Stage 2 - Compilation (Resource Exhaustion):**
During bytecode generation, the compiler enters a tight loop that iterates `num` times to pop/push stack elements without any bounds checking: [3](#0-2) 

The same issue exists for `VecUnpack`: [4](#0-3) 

**Stage 3 - Verification (Too Late):**
The bytecode verifier checks that `num ≤ u16::MAX` (65535), but this check occurs AFTER compilation completes: [5](#0-4) 

**Exploitation Flow:**
The compilation flow confirms verification happens after compilation: [6](#0-5) 

An attacker creates malicious Move IR code:
```
module 0x1.Exploit {
    public test() {
    label entry:
        vec_pack_1000000000000000<u64>()
        return;
    }
}
```

When compiled, the compiler attempts to loop 1 quadrillion times, causing the process to hang indefinitely.

## Impact Explanation

This vulnerability does NOT meet the Aptos bug bounty severity criteria for the following reasons:

1. **No Production Impact**: The Move IR compiler is a development/testing tool, not part of the production blockchain infrastructure. End users submit Move source code or pre-compiled bytecode, never Move IR.

2. **No Critical Invariants Broken**: The listed critical invariants (consensus safety, deterministic execution, state consistency, governance integrity, etc.) all relate to runtime blockchain operations. This is a compilation-time issue that doesn't affect on-chain operations.

3. **Limited Attack Surface**: The IR compiler would only be vulnerable if:
   - A development tool/IDE processes untrusted IR input
   - A compilation service exposes the IR compiler (unlikely)
   - Not applicable to validator nodes or blockchain operations

4. **Severity Classification**: Under the bug bounty criteria:
   - **NOT Critical**: No funds loss, consensus violations, network partition, or liveness impact
   - **NOT High**: No validator slowdowns, API crashes, or protocol violations  
   - **NOT Medium**: No funds loss or state inconsistencies requiring intervention
   - **Potentially Low**: Development tool DoS (outside stated scope)

## Likelihood Explanation

While technically exploitable, the likelihood of real-world impact is extremely low because the Move IR compiler is not exposed to untrusted input in production Aptos systems. It serves as an internal testing tool rather than a user-facing compilation interface.

## Recommendation

Despite limited production impact, the fix is straightforward and should be implemented for defense-in-depth:

Add early validation in the lexer or parser to reject `num` values exceeding `u16::MAX`:

```rust
// In lexer.rs, lines 284-288
if let Some(stripped) = name.strip_prefix("vec_pack_") {
    match stripped.parse::<u64>() {
        Ok(num) if num <= u16::MAX as u64 => (Tok::VecPack(num), len),
        Ok(_) => return Err(ParseError::InvalidToken {
            location: current_token_loc(self),
            message: "VecPack argument exceeds maximum (65535)".to_string(),
        }),
        Err(_) => (Tok::NameBeginTyValue, len + 1),
    }
}
```

Apply the same fix for `vec_unpack_` on lines 289-293.

## Proof of Concept

Create file `exploit.mvir`:
```
module 0x1.Exploit {
    public test() {
    label entry:
        vec_pack_10000000000<u64>()
        return;
    }
}
```

Compile:
```bash
cargo run --bin move-ir-compiler -- -m exploit.mvir
```

**Expected Result**: Compiler hangs in the loop at `compiler.rs:1438-1440`, consuming CPU until killed.

**After Fix**: Compiler immediately rejects with "VecPack argument exceeds maximum (65535)" error during parsing.

---

## Notes

While this is a legitimate implementation bug causing resource exhaustion during compilation, it **does not meet the validation criteria** for a valid Aptos bug bounty submission because:

1. ✗ Impact does not meet Critical/High/Medium severity thresholds defined by the program
2. ✗ Does not affect production blockchain components (consensus, execution, storage, governance, staking)
3. ✗ Does not break any of the 10 documented critical invariants
4. ✗ Limited to development tooling, not protocol-level vulnerability

The Move IR compiler is an internal testing tool, and this vulnerability would only matter if the IR compiler were exposed to process untrusted input in a production context, which is not the case in Aptos architecture.

### Citations

**File:** third_party/move/move-ir-compiler/move-ir-to-bytecode/syntax/src/lexer.rs (L284-288)
```rust
                                if let Some(stripped) = name.strip_prefix("vec_pack_") {
                                    match stripped.parse::<u64>() {
                                        Ok(num) => (Tok::VecPack(num), len),
                                        Err(_) => (Tok::NameBeginTyValue, len + 1),
                                    }
```

**File:** third_party/move/move-ir/types/src/ast.rs (L416-416)
```rust
    VecPack(Vec<Type>, u64),
```

**File:** third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs (L1433-1442)
```rust
                Builtin::VecPack(tys, num) => {
                    let tokens = compile_types(context, function_frame.type_parameters(), &tys)?;
                    let type_actuals_id = context.signature_index(Signature(tokens))?;
                    push_instr!(call.loc, Bytecode::VecPack(type_actuals_id, num));

                    for _ in 0..num {
                        function_frame.pop()?;
                    }
                    function_frame.push()?; // push the return value
                },
```

**File:** third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs (L1485-1494)
```rust
                Builtin::VecUnpack(tys, num) => {
                    let tokens = compile_types(context, function_frame.type_parameters(), &tys)?;
                    let type_actuals_id = context.signature_index(Signature(tokens))?;
                    push_instr!(call.loc, Bytecode::VecUnpack(type_actuals_id, num));

                    function_frame.pop()?; // pop the vector ref
                    for _ in 0..num {
                        function_frame.push()?;
                    }
                },
```

**File:** third_party/move/move-bytecode-verifier/src/instruction_consistency.rs (L137-143)
```rust
                VecPack(_, num) | VecUnpack(_, num) => {
                    if *num > u16::MAX as u64 {
                        return Err(PartialVMError::new(StatusCode::CONSTRAINT_NOT_SATISFIED)
                            .at_code_offset(self.current_function(), offset as CodeOffset)
                            .with_message("VecPack/VecUnpack argument out of range".to_string()));
                    }
                },
```

**File:** third_party/move/move-ir-compiler/src/unit_tests/testutils.rs (L48-67)
```rust
fn compile_module_string_impl(
    code: &str,
    deps: Vec<CompiledModule>,
) -> Result<(CompiledModule, Option<VMError>)> {
    let module = parse_module(code).unwrap();
    let compiled_module = compile_module(module, &deps)?.0;

    let mut serialized_module = Vec::<u8>::new();
    compiled_module.serialize(&mut serialized_module)?;
    let deserialized_module = CompiledModule::deserialize(&serialized_module)
        .map_err(|e| e.finish(Location::Undefined).into_vm_status())?;
    assert_eq!(compiled_module, deserialized_module);

    // Always return a CompiledModule because some callers explicitly care about unverified
    // modules.
    Ok(match verify_module(&compiled_module) {
        Ok(_) => (compiled_module, None),
        Err(error) => (compiled_module, Some(error)),
    })
}
```
