# Audit Report

## Title
Credential Disclosure Through Debug Trait Implementation in NFT Metadata Crawler Configuration

## Summary
The `ParserConfig` struct derives the `Debug` trait while containing sensitive credential fields (`google_application_credentials` and `ipfs_auth_key`). During service startup, the entire configuration is logged using Debug formatting, exposing these credentials in plain text to log files, log aggregation services, and monitoring systems.

## Finding Description

The vulnerability exists in the NFT Metadata Crawler service configuration handling. The `ParserConfig` struct is defined with automatic `Debug` trait derivation: [1](#0-0) 

This struct contains two sensitive credential fields:
- `google_application_credentials: Option<String>` - Path or content of Google Cloud credentials
- `ipfs_auth_key: Option<String>` - Authentication key for IPFS services

The security breach occurs during service initialization when the entire configuration is logged: [2](#0-1) 

The `NFTMetadataCrawlerConfig` struct (which also derives `Debug`) contains a `ServerConfig` enum that includes `Parser(ParserConfig)`: [3](#0-2) [4](#0-3) 

When the service starts and executes the logging statement with `{:?}` formatting, Rust's Debug trait recursively formats all nested structures, exposing the sensitive credentials in plain text to:
- Standard output/error streams
- Log files on disk
- Centralized log aggregation systems (Splunk, ELK, etc.)
- Cloud logging services (CloudWatch, Stackdriver, etc.)
- Container orchestration logs (Kubernetes, Docker)

## Impact Explanation

This vulnerability qualifies as **Medium Severity** under the Aptos Bug Bounty program criteria:

**Information Disclosure Impact:**
- Exposed Google Cloud credentials can be used to access, modify, or delete NFT metadata stored in GCS buckets
- Leaked IPFS authentication keys enable unauthorized access to IPFS authenticated endpoints
- Attackers gaining log access can extract these credentials and perform unauthorized operations

**Attack Scenarios:**
1. **Log Aggregation Compromise**: If an attacker compromises a log aggregation service or gains unauthorized access to centralized logs, they immediately obtain valid credentials
2. **Insider Threat**: System administrators, DevOps personnel, or support staff with log access can extract credentials
3. **Misconfigured Log Permissions**: Incorrectly configured log file permissions or container log exports expose credentials
4. **Supply Chain Attack**: Compromised monitoring tools or log forwarding agents can exfiltrate credentials

**Potential Damages:**
- Unauthorized manipulation of NFT metadata affecting user assets
- Financial costs from unauthorized GCS usage
- Data exfiltration from storage buckets
- Reputational damage from compromised NFT metadata integrity

## Likelihood Explanation

**Likelihood: HIGH**

This vulnerability triggers automatically on every service startup without requiring any attacker action. The exposure occurs during normal operations when:

1. The NFT Metadata Crawler service initializes
2. The configuration is loaded from YAML/environment
3. The startup logging executes (line 88 of config.rs)
4. Credentials are written to logs in plain text

**Exploitation Complexity: LOW**
- No special permissions needed beyond log access
- No timing requirements or race conditions
- No complex attack chains required
- Credentials remain in logs until log rotation/deletion

**Access Vectors:**
- DevOps/infrastructure teams routinely access logs for debugging
- Log aggregation services centralize sensitive data
- Container logs are often exported to shared storage
- Compliance auditing may archive logs with credentials

## Recommendation

**Immediate Fix**: Implement custom `Debug` trait that redacts sensitive fields:

```rust
use std::fmt;

impl fmt::Debug for ParserConfig {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("ParserConfig")
            .field("google_application_credentials", &"[REDACTED]")
            .field("bucket", &self.bucket)
            .field("cdn_prefix", &self.cdn_prefix)
            .field("ipfs_prefix", &self.ipfs_prefix)
            .field("ipfs_auth_key", &"[REDACTED]")
            .field("max_file_size_bytes", &self.max_file_size_bytes)
            .field("image_quality", &self.image_quality)
            .field("max_image_dimensions", &self.max_image_dimensions)
            .field("max_num_parse_retries", &self.max_num_parse_retries)
            .field("ack_parsed_uris", &self.ack_parsed_uris)
            .field("uri_blacklist", &self.uri_blacklist)
            .finish()
    }
}
```

**Additional Mitigations:**
1. Remove the automatic `#[derive(Debug)]` from `ParserConfig`
2. Audit all other configuration structs for similar credential exposure
3. Implement secrets management solution (HashiCorp Vault, AWS Secrets Manager)
4. Add automated scanning for credential patterns in logs
5. Rotate all potentially exposed credentials immediately upon deploying the fix

## Proof of Concept

**Reproduction Steps:**

1. Create a configuration file `config.yaml`:
```yaml
database_url: "postgresql://localhost/nft"
server_port: 8080
server_config:
  type: Parser
  google_application_credentials: "/path/to/secret-key.json"
  bucket: "nft-bucket"
  cdn_prefix: "https://cdn.example.com/"
  ipfs_prefix: "https://ipfs.io/ipfs/"
  ipfs_auth_key: "secret-ipfs-key-12345"
  max_file_size_bytes: 10485760
  image_quality: 80
  max_image_dimensions: 1024
  max_num_parse_retries: 3
  ack_parsed_uris: true
  uri_blacklist: []
```

2. Start the NFT Metadata Crawler service:
```bash
cargo run --bin aptos-nft-metadata-crawler -- --config-path config.yaml
```

3. Observe the logs on startup - they will contain:
```
INFO [NFT Metadata Crawler] Starting with config: NFTMetadataCrawlerConfig { 
  database_url: "postgresql://localhost/nft", 
  server_port: 8080, 
  server_config: Parser(ParserConfig { 
    google_application_credentials: Some("/path/to/secret-key.json"), 
    bucket: "nft-bucket", 
    cdn_prefix: "https://cdn.example.com/", 
    ipfs_prefix: "https://ipfs.io/ipfs/", 
    ipfs_auth_key: Some("secret-ipfs-key-12345"), 
    ...
  })
}
```

The credentials `"/path/to/secret-key.json"` and `"secret-ipfs-key-12345"` are exposed in plain text.

**Verification**: Check any log output destination (stdout, log files, log aggregation systems) for the presence of these credential values.

## Notes

This vulnerability affects the NFT Metadata Crawler service, which is part of the Aptos ecosystem infrastructure rather than the core blockchain consensus or Move VM. However, it represents a significant operational security risk for any deployment of this service. The automatic Debug trait derivation is a common Rust anti-pattern when dealing with sensitive configuration data, and similar issues should be audited across the entire codebase.

### Citations

**File:** ecosystem/nft-metadata-crawler/src/parser/config.rs (L10-30)
```rust
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ParserConfig {
    pub google_application_credentials: Option<String>,
    pub bucket: String,
    pub cdn_prefix: String,
    pub ipfs_prefix: String,
    pub ipfs_auth_key: Option<String>,
    #[serde(default = "ParserConfig::default_max_file_size_bytes")]
    pub max_file_size_bytes: u32,
    #[serde(default = "ParserConfig::default_image_quality")]
    pub image_quality: u8, // Quality up to 100
    #[serde(default = "ParserConfig::default_max_image_dimensions")]
    pub max_image_dimensions: u32,
    #[serde(default = "ParserConfig::default_max_num_parse_retries")]
    pub max_num_parse_retries: i32,
    #[serde(default)]
    pub ack_parsed_uris: bool,
    #[serde(default)]
    pub uri_blacklist: Vec<String>,
}
```

**File:** ecosystem/nft-metadata-crawler/src/config.rs (L30-37)
```rust
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(tag = "type")]
pub enum ServerConfig {
    Parser(ParserConfig),
    AssetUploaderWorker(AssetUploaderWorkerConfig),
    AssetUploaderApi,
    AssetUploaderThrottler(AssetUploaderThrottlerConfig),
}
```

**File:** ecosystem/nft-metadata-crawler/src/config.rs (L40-46)
```rust
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct NFTMetadataCrawlerConfig {
    pub database_url: String,
    pub server_port: u16,
    pub server_config: ServerConfig,
}
```

**File:** ecosystem/nft-metadata-crawler/src/config.rs (L88-88)
```rust
        info!("[NFT Metadata Crawler] Starting with config: {:?}", self);
```
