# Audit Report

## Title
Missing EventFilter Validation Allows Wildcard Event Matching in Indexer gRPC Service

## Summary
The `EventFilter` struct contains validation logic that checks if at least one filter field is set, but this validation is never called in the actual request processing path. This allows clients to send an empty `EventFilter` (both `struct_type` and `data_substring_filter` set to `None`) which matches all blockchain events, potentially causing excessive data transfer and server resource consumption.

## Finding Description
The vulnerability exists in the indexer gRPC service's filter validation logic. The `EventFilter` struct implements a `validate_state()` method that enforces the invariant "at least one of data_substring_filter or struct_type must be set": [1](#0-0) 

However, when filters are received via gRPC requests, they are converted from protobuf to Rust types without ever calling this validation: [2](#0-1) [3](#0-2) 

The conversion from protobuf simply copies the fields without validation: [4](#0-3) 

When an empty `EventFilter` is used in the `matches()` method, both conditional checks are skipped (since both fields are `None`), causing the filter to return `true` for ALL events: [5](#0-4) 

This wildcard matching propagates to the transaction level, where any transaction containing at least one event will match: [6](#0-5) 

**Attack Path:**
1. Attacker sends a gRPC `GetTransactionsRequest` with an `EventFilter` where both fields are `None`
2. The filter passes protobuf deserialization and size validation
3. Content validation (`is_valid()`) is never called
4. The filter is used in streaming without validation
5. Every event in every transaction matches the filter
6. Server processes and returns all transaction data containing events, up to batch limits

## Impact Explanation
This issue falls under **Low Severity** based on the following analysis:

**Why NOT Higher Severity:**
- **Not consensus-affecting**: The indexer gRPC service is separate from core consensus/execution components
- **Public data by design**: All blockchain transaction and event data is inherently public and queryable
- **Bounded resource consumption**: Batch size limits (20MB per batch, 10,000 transactions default) prevent unbounded resource exhaustion
- **No fund loss**: This is a read-only service that cannot affect on-chain state or funds

**Why Low Severity:**
- **Minor information leak**: While all data is public, the filter is intended to reduce bandwidth and prevent unintended full data exposure
- **Non-critical implementation bug**: The validation code exists but is dead code, indicating a gap between design intent and implementation
- **Resource inefficiency**: Forces server to process more data than necessary, though bounded by limits

The primary impact is inefficient resource usage and potential confusion about filter behavior, not a critical security breach.

## Likelihood Explanation
**Likelihood: High**

This vulnerability is trivially exploitable:
- Any client can send gRPC requests to the indexer service
- No authentication or special permissions required
- Crafting an empty `EventFilter` requires simply omitting both fields in the protobuf message
- The bug affects all indexer gRPC service deployments

However, the **actual harm** from exploitation is limited by architectural constraints (batch size limits, public data model).

## Recommendation
Enforce validation by calling `is_valid()` after filter construction. Modify the `parse_transaction_filter` function to validate filter content:

```rust
pub fn parse_transaction_filter(
    proto_filter: aptos_protos::indexer::v1::BooleanTransactionFilter,
    max_filter_size_bytes: usize,
) -> Result<BooleanTransactionFilter, Status> {
    let filter = BooleanTransactionFilter::new_from_proto(proto_filter, Some(max_filter_size_bytes))
        .map_err(|e| Status::invalid_argument(format!("Invalid transaction_filter: {e:?}.")))?;
    
    // Add validation check
    filter.is_valid()
        .map_err(|e| Status::invalid_argument(format!("Invalid transaction_filter: {e:?}.")))?;
    
    Ok(filter)
}
```

This ensures the validation logic in `EventFilter::validate_state()` is actually enforced before the filter is used.

## Proof of Concept
```rust
#[cfg(test)]
mod test {
    use super::*;
    use aptos_transaction_filter::filters::EventFilterBuilder;
    use aptos_protos::indexer::v1;
    
    #[test]
    fn test_empty_event_filter_validation_bypass() {
        // Create an empty EventFilter via protobuf (bypassing validation)
        let proto_filter = v1::EventFilter {
            struct_type: None,
            data_substring_filter: None,
        };
        
        // Convert to Rust type (validation is NOT called)
        let event_filter: EventFilter = proto_filter.into();
        
        // Attempting to validate should fail
        let validation_result = event_filter.is_valid();
        assert!(validation_result.is_err());
        assert!(validation_result.unwrap_err().to_string().contains("At least one of data or struct_type must be set"));
        
        // But the filter was already created and can be used!
        // Create a mock event
        let mock_event = Event {
            r#type: Some(MoveType { content: None }),
            data: "test_data".to_string(),
            ..Default::default()
        };
        
        // Empty filter matches ALL events (wildcard behavior)
        assert!(event_filter.matches(&mock_event));
    }
    
    #[test]
    fn test_proper_validation_with_builder() {
        // Using the builder pattern correctly enforces validation
        let result = EventFilterBuilder::default().build();
        
        // This should fail validation
        assert!(result.is_err());
    }
}
```

**Notes:**
- This vulnerability exists in the indexer gRPC service layer, which is architecturally separate from core blockchain consensus and execution
- The security impact is limited because: (1) all blockchain data is public by design, (2) batch size limits bound resource consumption, and (3) the indexer doesn't affect validator operations or on-chain state
- The root cause is dead validation code - the validation logic exists but is never invoked in the actual request processing path
- Similar validation bypass issues may exist for other filter types (`UserTransactionFilter`, `TransactionRootFilter`) since they follow the same pattern

### Citations

**File:** ecosystem/indexer-grpc/transaction-filter/src/filters/event.rs (L44-52)
```rust
impl From<aptos_protos::indexer::v1::EventFilter> for EventFilter {
    fn from(proto_filter: aptos_protos::indexer::v1::EventFilter) -> Self {
        Self {
            data_substring_filter: proto_filter.data_substring_filter,
            struct_type: proto_filter.struct_type.map(|f| f.into()),
            data_substring_finder: OnceCell::new(),
        }
    }
}
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/filters/event.rs (L65-73)
```rust
    fn validate_state(&self) -> Result<(), FilterError> {
        if self.data_substring_filter.is_none() && self.struct_type.is_none() {
            return Err(Error::msg("At least one of data or struct_type must be set").into());
        };

        self.data_substring_filter.is_valid()?;
        self.struct_type.is_valid()?;
        Ok(())
    }
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/filters/event.rs (L76-99)
```rust
    fn matches(&self, item: &Event) -> bool {
        if let Some(struct_type_filter) = &self.struct_type {
            if let Some(Content::Struct(struct_tag)) =
                &item.r#type.as_ref().and_then(|t| t.content.as_ref())
            {
                if !struct_type_filter.matches(struct_tag) {
                    return false;
                }
            } else {
                return false;
            }
        }

        if let Some(data_substring_filter) = self.data_substring_filter.as_ref() {
            let finder = self
                .data_substring_finder
                .get_or_init(|| Finder::new(data_substring_filter).into_owned());
            if finder.find(item.data.as_bytes()).is_none() {
                return false;
            }
        }

        true
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/filter_utils.rs (L9-15)
```rust
pub fn parse_transaction_filter(
    proto_filter: aptos_protos::indexer::v1::BooleanTransactionFilter,
    max_filter_size_bytes: usize,
) -> Result<BooleanTransactionFilter, Status> {
    BooleanTransactionFilter::new_from_proto(proto_filter, Some(max_filter_size_bytes))
        .map_err(|e| Status::invalid_argument(format!("Invalid transaction_filter: {e:?}.")))
}
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/boolean_transaction_filter.rs (L94-127)
```rust
    pub fn new_from_proto(
        proto_filter: aptos_protos::indexer::v1::BooleanTransactionFilter,
        max_filter_size: Option<usize>,
    ) -> Result<Self> {
        if let Some(max_filter_size) = max_filter_size {
            ensure!(
                proto_filter.encoded_len() <= max_filter_size,
                format!(
                    "Filter is too complicated. Max size: {} bytes, Actual size: {} bytes",
                    max_filter_size,
                    proto_filter.encoded_len()
                )
            );
        }
        Ok(
            match proto_filter
                .filter
                .ok_or(anyhow!("Oneof is not set in BooleanTransactionFilter."))?
            {
                aptos_protos::indexer::v1::boolean_transaction_filter::Filter::ApiFilter(
                    api_filter,
                ) => TryInto::<APIFilter>::try_into(api_filter)?.into(),
                aptos_protos::indexer::v1::boolean_transaction_filter::Filter::LogicalAnd(
                    logical_and,
                ) => BooleanTransactionFilter::And(logical_and.try_into()?),
                aptos_protos::indexer::v1::boolean_transaction_filter::Filter::LogicalOr(
                    logical_or,
                ) => BooleanTransactionFilter::Or(logical_or.try_into()?),
                aptos_protos::indexer::v1::boolean_transaction_filter::Filter::LogicalNot(
                    logical_not,
                ) => BooleanTransactionFilter::Not(logical_not.try_into()?),
            },
        )
    }
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/boolean_transaction_filter.rs (L467-481)
```rust
            APIFilter::EventFilter(events_filter) => {
                if let Some(txn_data) = &txn.txn_data {
                    let events = match txn_data {
                        TxnData::BlockMetadata(bm) => &bm.events,
                        TxnData::Genesis(g) => &g.events,
                        TxnData::StateCheckpoint(_) => return false,
                        TxnData::User(u) => &u.events,
                        TxnData::Validator(_) => return false,
                        TxnData::BlockEpilogue(_) => return false,
                    };
                    events_filter.matches_vec(events)
                } else {
                    false
                }
            },
```
