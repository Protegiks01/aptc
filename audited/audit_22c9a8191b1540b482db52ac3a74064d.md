# Audit Report

## Title
CLI REST Client Accepts Insecure HTTP Endpoints Without Warning, Enabling Man-in-the-Middle Attacks and Data Spoofing

## Summary
The Aptos CLI's REST client initialization in `rest_options.client()` accepts both HTTP and HTTPS URLs without validation or warning, allowing malicious configurations to redirect API calls to attacker-controlled servers. While TLS certificate validation works correctly for HTTPS connections, the lack of HTTP/HTTPS enforcement and endpoint authenticity verification creates a security risk where users can be tricked into using insecure or malicious endpoints.

## Finding Description

The vulnerability exists in the REST client initialization flow: [1](#0-0) 

This calls the `RestOptions::client()` method: [2](#0-1) 

The URL is obtained from either command-line argument or profile configuration: [3](#0-2) 

The underlying HTTP client is built using reqwest's default configuration: [4](#0-3) 

**The Security Issues:**

1. **No HTTP/HTTPS Enforcement**: The CLI accepts `http://` URLs without warning. During profile initialization, any valid URL is accepted: [5](#0-4) 

2. **No Endpoint Authenticity Verification**: There is no validation that the endpoint is a legitimate Aptos node. Users can configure arbitrary URLs pointing to attacker-controlled servers.

3. **TLS Validation Works BUT**: While reqwest properly validates TLS certificates for HTTPS (using system root certificates), this doesn't prevent attacks where:
   - HTTP is used (no encryption at all)
   - HTTPS with valid certificates for attacker's own domain (e.g., `https://fake-aptos-api.com`)

**Attack Scenarios:**

**Scenario 1 - HTTP Man-in-the-Middle:**
1. Attacker tricks user via malicious documentation to configure: `aptos init --rest-url http://api.attacker.com`
2. User runs: `aptos account list --account 0x1`
3. All queries transmitted in cleartext over HTTP
4. Attacker logs queries and returns fake blockchain data

**Scenario 2 - HTTPS with Malicious Endpoint:**
1. Attacker modifies `.aptos/config.yaml` (via malware or social engineering)
2. Sets `rest_url: https://fake-aptos.com` (attacker owns domain with valid TLS cert)
3. User unknowingly queries malicious endpoint
4. Attacker returns spoofed account balances, fake transaction data
5. User makes financial decisions based on fake data → potential funds loss

## Impact Explanation

This qualifies as **Medium Severity** per Aptos bug bounty criteria:

- **Privacy Breach**: All user queries (account addresses, transaction lookups) logged by attacker
- **Data Integrity Compromise**: Fake blockchain data can mislead users about account balances, transaction status
- **Potential Funds Loss**: Users may send funds based on spoofed data (e.g., fake balance showing funds never arrived)
- **Limited Scope**: Only affects CLI users who are misconfigured, not validator nodes or consensus

This does NOT qualify as Critical/High because:
- Does not affect consensus protocol or validator operations
- Requires user misconfiguration (not automatic exploitation)
- Does not directly cause funds theft (indirect through user decisions)
- Only impacts individual CLI users, not the network

## Likelihood Explanation

**Likelihood: Medium**

**Factors Increasing Likelihood:**
- Many users follow online tutorials that could be compromised
- Config file tampering possible via malware
- Users may not understand HTTP vs HTTPS security implications
- No visual indicators or warnings about insecure connections
- Local development practices (using HTTP) may normalize insecure usage

**Factors Decreasing Likelihood:**
- Requires explicit user action to configure malicious endpoint
- Official documentation likely uses HTTPS URLs
- Users need to run `aptos init` or manually edit config
- Sophisticated users likely notice unusual endpoints

## Recommendation

Implement multiple defense layers:

**1. Add HTTPS enforcement for remote endpoints:**

```rust
pub fn url(&self, profile: &ProfileOptions) -> CliTypedResult<reqwest::Url> {
    let url = if let Some(ref url) = self.url {
        url.clone()
    } else if let Some(Some(url_str)) = CliConfig::load_profile(
        profile.profile_name(),
        ConfigSearchMode::CurrentDirAndParents,
    )?
    .map(|p| p.rest_url)
    {
        reqwest::Url::parse(&url_str)
            .map_err(|err| CliError::UnableToParse("Rest URL", err.to_string()))?
    } else {
        return Err(CliError::CommandArgumentError("No rest url given...".to_string()));
    };

    // Add security validation
    if url.scheme() == "http" 
        && !is_localhost(&url) 
        && !self.allow_insecure_http {
        return Err(CliError::CommandArgumentError(
            format!(
                "Insecure HTTP URL detected: {}. Use HTTPS for remote endpoints or add --allow-insecure-http flag",
                url
            )
        ));
    }

    Ok(url)
}

fn is_localhost(url: &reqwest::Url) -> bool {
    if let Some(host) = url.host_str() {
        host == "localhost" || host == "127.0.0.1" || host == "::1"
    } else {
        false
    }
}
```

**2. Add `allow_insecure_http` flag to RestOptions:**

```rust
pub struct RestOptions {
    #[clap(long)]
    pub(crate) url: Option<reqwest::Url>,
    
    #[clap(long, default_value_t = DEFAULT_EXPIRATION_SECS)]
    pub connection_timeout_secs: u64,
    
    #[clap(long, env)]
    pub node_api_key: Option<String>,
    
    /// Allow HTTP connections (insecure, for local development only)
    #[clap(long)]
    pub allow_insecure_http: bool,
}
```

**3. Add warning during `aptos init` for non-HTTPS URLs:**

```rust
// In init.rs after URL parsing
if let Some(url) = reqwest::Url::parse(input).ok() {
    if url.scheme() == "http" && !is_localhost(&url) {
        eprintln!("⚠️  WARNING: Using insecure HTTP connection to remote endpoint!");
        eprintln!("   Your queries and responses will be transmitted in cleartext.");
        eprintln!("   Use HTTPS endpoints for production: https://...");
    }
}
```

## Proof of Concept

**Step 1: Configure malicious endpoint**
```bash
# Create malicious config
mkdir -p .aptos
cat > .aptos/config.yaml << EOF
profiles:
  default:
    rest_url: "http://malicious-server.com:8080"
    account: "0x1"
EOF
```

**Step 2: Run CLI command**
```bash
# This will send cleartext request to attacker server
aptos account list --account 0x1
```

**Step 3: Attacker receives cleartext request**
```
# On attacker's server (malicious-server.com:8080)
GET /v1/accounts/0x1/resources HTTP/1.1
Host: malicious-server.com:8080
X-Aptos-Client: aptos-cli/2.x.x
# Full query visible in cleartext
```

**Step 4: Attacker returns spoofed data**
```json
{
  "data": {
    "authentication_key": "0x...",
    "sequence_number": "999",
    "coin_register_events": {...}
  }
}
```

The CLI will display this fake data to the user without any indication that the endpoint is potentially malicious.

## Notes

While TLS certificate validation is implemented correctly (via reqwest's default behavior), the acceptance of HTTP URLs and lack of endpoint authenticity verification creates a medium-severity security risk. The vulnerability is amplified by the fact that users may not understand the security implications of their endpoint configuration choices, and there are no visual indicators or warnings to alert them to potentially insecure or malicious connections.

### Citations

**File:** crates/aptos/src/account/list.rs (L89-89)
```rust
        let client = self.rest_options.client(&self.profile_options)?;
```

**File:** crates/aptos/src/common/types.rs (L1132-1146)
```rust
    pub fn url(&self, profile: &ProfileOptions) -> CliTypedResult<reqwest::Url> {
        if let Some(ref url) = self.url {
            Ok(url.clone())
        } else if let Some(Some(url)) = CliConfig::load_profile(
            profile.profile_name(),
            ConfigSearchMode::CurrentDirAndParents,
        )?
        .map(|p| p.rest_url)
        {
            reqwest::Url::parse(&url)
                .map_err(|err| CliError::UnableToParse("Rest URL", err.to_string()))
        } else {
            Err(CliError::CommandArgumentError("No rest url given.  Please add --url or add a rest_url to the .aptos/config.yaml for the current profile".to_string()))
        }
    }
```

**File:** crates/aptos/src/common/types.rs (L1148-1156)
```rust
    pub fn client(&self, profile: &ProfileOptions) -> CliTypedResult<Client> {
        let mut client = Client::builder(AptosBaseUrl::Custom(self.url(profile)?))
            .timeout(Duration::from_secs(self.connection_timeout_secs))
            .header(aptos_api_types::X_APTOS_CLIENT, X_APTOS_CLIENT_VALUE)?;
        if let Some(node_api_key) = &self.node_api_key {
            client = client.api_key(node_api_key)?;
        }
        Ok(client.build())
    }
```

**File:** crates/aptos-rest-client/src/client_builder.rs (L95-109)
```rust
    pub fn build(self) -> Client {
        let version_path_base = get_version_path_with_base(self.base_url.clone());

        Client {
            inner: self
                .reqwest_builder
                .default_headers(self.headers)
                .timeout(self.timeout)
                .cookie_store(true)
                .build()
                .unwrap(),
            base_url: self.base_url,
            version_path_base,
        }
    }
```

**File:** crates/aptos/src/common/init.rs (L404-407)
```rust
                    reqwest::Url::parse(input)
                        .map_err(|err| CliError::UnableToParse("Rest Endpoint", err.to_string()))?
                        .to_string(),
                )
```
