# Audit Report

## Title
Block Metadata Desynchronization After Database Truncation Causes API to Return Wrong Block Information

## Summary
The database truncation logic fails to delete `BlockInfoSchema` and `BlockByVersionSchema` entries during rollback operations. This causes stale block metadata to persist after crash recovery, leading to API queries returning NewBlockEvents from different blocks than requested when storage sharding is enabled.

## Finding Description

When an Aptos node crashes and restarts, the `sync_commit_progress` function is called to ensure database consistency by truncating uncommitted data. [1](#0-0)  However, the truncation process has a critical flaw in the block metadata cleanup.

The two affected schemas store block metadata mappings:
- `BlockInfoSchema`: Maps block height to BlockInfo (containing first_version, epoch, round, proposer, timestamp) [2](#0-1) 
- `BlockByVersionSchema`: Maps version to block height [3](#0-2) 

During truncation, the `truncate_ledger_db_single_batch` function deletes various schemas but **completely omits** BlockInfoSchema and BlockByVersionSchema. [4](#0-3) 

The imports confirm these schemas are not referenced in the truncation code. [5](#0-4) 

The `delete_per_version_data` function only cleans up specific version-keyed schemas, and BlockByVersionSchema (which uses Version as key) is **not included** in this list. [6](#0-5) 

**Vulnerability Trigger:**

This vulnerability is triggered when `enable_storage_sharding` is enabled (which defaults to `true` in production). [7](#0-6)  When sharding is enabled, the `skip_index_and_usage` flag is set to `true`, [8](#0-7)  causing the API to retrieve BlockInfo directly from BlockInfoSchema instead of from event stores. [9](#0-8) 

**Attack Scenario:**

1. Node has committed blocks up to version 1000, with block height 51 containing versions 996-1000
2. Node crashes, database truncates to version 989 via `sync_commit_progress`
3. BlockInfoSchema[51] = {first_version: 996} remains in database (NOT deleted)
4. Blockchain re-executes with different blocks due to non-determinism in block boundaries; version 996 now belongs to block 50
5. API call `get_block_info_by_height(51)` retrieves stale BlockInfo{first_version: 996} from height 51
6. The `to_api_block_info` function fetches NewBlockEvent at version 996 [10](#0-9) 
7. Returns NewBlockEvent from the **new** block 50, not the queried block 51
8. API consumer receives inconsistent data where queried block height (51) does not match the returned NewBlockEvent.height (50)

## Impact Explanation

This is a **MEDIUM severity** vulnerability per Aptos bug bounty criteria as it causes "State inconsistencies requiring manual intervention."

**Concrete Impacts:**
1. **API Data Corruption**: REST API endpoints `/blocks/by_height/{height}` return wrong block metadata
2. **Indexer Failures**: Blockchain indexers relying on block height queries will index incorrect data, potentially corrupting their databases
3. **Timestamp Query Errors**: Functions depending on correct block metadata may return wrong versions
4. **External Service Issues**: Third-party services using block info may make incorrect decisions based on inconsistent data

**Affected Systems:**
- All nodes with storage sharding enabled (production default) that experience crashes requiring truncation
- External services querying block info by height
- Third-party indexers and analytics tools

This does NOT directly cause fund loss, consensus breaks, or network halts, placing it in MEDIUM rather than HIGH severity.

## Likelihood Explanation

**Likelihood: HIGH**

This vulnerability triggers automatically in normal operations:
- Database truncation occurs during every node restart after an incomplete commit (crashes, power failures, etc.)
- No attacker action required - it's a deterministic bug
- Affects all nodes running Aptos with default storage configuration
- The `sync_commit_progress` function is explicitly called during StateStore initialization for all non-test environments [11](#0-10) 

## Recommendation

Modify `truncate_ledger_db_single_batch` to include deletion of BlockInfoSchema and BlockByVersionSchema entries:

1. Import the missing schemas in `storage/aptosdb/src/utils/truncation_helper.rs`
2. Add a new deletion function `delete_block_metadata` that removes entries from both schemas for block heights whose first_version is >= start_version
3. Call this function in `truncate_ledger_db_single_batch` before updating the ledger commit progress

Additionally, add BlockByVersionSchema to the `delete_per_version_data` function since it uses Version as its key.

## Proof of Concept

A proof of concept would require:
1. Setting up an Aptos node with storage sharding enabled
2. Committing several blocks
3. Forcibly terminating the node during a commit
4. Restarting and observing the API return inconsistent block metadata

The vulnerability can be verified by examining the truncation code and confirming that BlockInfoSchema and BlockByVersionSchema are not included in any deletion logic.

### Citations

**File:** storage/aptosdb/src/state_store/mod.rs (L353-359)
```rust
        if !hack_for_tests && !empty_buffered_state_for_restore {
            Self::sync_commit_progress(
                Arc::clone(&ledger_db),
                Arc::clone(&state_kv_db),
                Arc::clone(&state_merkle_db),
                /*crash_if_difference_is_too_large=*/ true,
            );
```

**File:** storage/aptosdb/src/state_store/mod.rs (L410-449)
```rust
    pub fn sync_commit_progress(
        ledger_db: Arc<LedgerDb>,
        state_kv_db: Arc<StateKvDb>,
        state_merkle_db: Arc<StateMerkleDb>,
        crash_if_difference_is_too_large: bool,
    ) {
        let ledger_metadata_db = ledger_db.metadata_db();
        if let Some(overall_commit_progress) = ledger_metadata_db
            .get_synced_version()
            .expect("DB read failed.")
        {
            info!(
                overall_commit_progress = overall_commit_progress,
                "Start syncing databases..."
            );
            let ledger_commit_progress = ledger_metadata_db
                .get_ledger_commit_progress()
                .expect("Failed to read ledger commit progress.");
            assert_ge!(ledger_commit_progress, overall_commit_progress);

            let state_kv_commit_progress = state_kv_db
                .metadata_db()
                .get::<DbMetadataSchema>(&DbMetadataKey::StateKvCommitProgress)
                .expect("Failed to read state K/V commit progress.")
                .expect("State K/V commit progress cannot be None.")
                .expect_version();
            assert_ge!(state_kv_commit_progress, overall_commit_progress);

            // LedgerCommitProgress was not guaranteed to commit after all ledger changes finish,
            // have to attempt truncating every column family.
            info!(
                ledger_commit_progress = ledger_commit_progress,
                "Attempt ledger truncation...",
            );
            let difference = ledger_commit_progress - overall_commit_progress;
            if crash_if_difference_is_too_large {
                assert_le!(difference, MAX_COMMIT_PROGRESS_DIFFERENCE);
            }
            truncate_ledger_db(ledger_db.clone(), overall_commit_progress)
                .expect("Failed to truncate ledger db.");
```

**File:** storage/aptosdb/src/schema/block_info/mod.rs (L22-25)
```rust
type Key = BlockHeight;
type Value = BlockInfo;

define_schema!(BlockInfoSchema, Key, Value, BLOCK_INFO_CF_NAME);
```

**File:** storage/aptosdb/src/schema/block_by_version/mod.rs (L22-25)
```rust
type Key = Version;
type Value = BlockHeight;

define_schema!(BlockByVersionSchema, Key, Value, BLOCK_BY_VERSION_CF_NAME);
```

**File:** storage/aptosdb/src/utils/truncation_helper.rs (L11-29)
```rust
    schema::{
        db_metadata::{DbMetadataKey, DbMetadataSchema, DbMetadataValue},
        epoch_by_version::EpochByVersionSchema,
        jellyfish_merkle_node::JellyfishMerkleNodeSchema,
        ledger_info::LedgerInfoSchema,
        stale_node_index::StaleNodeIndexSchema,
        stale_node_index_cross_epoch::StaleNodeIndexCrossEpochSchema,
        stale_state_value_index::StaleStateValueIndexSchema,
        stale_state_value_index_by_key_hash::StaleStateValueIndexByKeyHashSchema,
        state_value::StateValueSchema,
        state_value_by_key_hash::StateValueByKeyHashSchema,
        transaction::TransactionSchema,
        transaction_accumulator::TransactionAccumulatorSchema,
        transaction_accumulator_root_hash::TransactionAccumulatorRootHashSchema,
        transaction_info::TransactionInfoSchema,
        transaction_summaries_by_account::TransactionSummariesByAccountSchema,
        version_data::VersionDataSchema,
        write_set::WriteSetSchema,
    },
```

**File:** storage/aptosdb/src/utils/truncation_helper.rs (L325-361)
```rust
fn truncate_ledger_db_single_batch(
    ledger_db: &LedgerDb,
    transaction_store: &TransactionStore,
    start_version: Version,
) -> Result<()> {
    let mut batch = LedgerDbSchemaBatches::new();

    delete_transaction_index_data(
        ledger_db,
        transaction_store,
        start_version,
        &mut batch.transaction_db_batches,
    )?;
    delete_per_epoch_data(
        &ledger_db.metadata_db_arc(),
        start_version,
        &mut batch.ledger_metadata_db_batches,
    )?;
    delete_per_version_data(ledger_db, start_version, &mut batch)?;

    delete_event_data(ledger_db, start_version, &mut batch.event_db_batches)?;

    truncate_transaction_accumulator(
        ledger_db.transaction_accumulator_db_raw(),
        start_version,
        &mut batch.transaction_accumulator_db_batches,
    )?;

    let mut progress_batch = SchemaBatch::new();
    progress_batch.put::<DbMetadataSchema>(
        &DbMetadataKey::LedgerCommitProgress,
        &DbMetadataValue::Version(start_version - 1),
    )?;
    ledger_db.metadata_db().write_schemas(progress_batch)?;

    ledger_db.write_schemas(batch)
}
```

**File:** storage/aptosdb/src/utils/truncation_helper.rs (L430-462)
```rust
fn delete_per_version_data(
    ledger_db: &LedgerDb,
    start_version: Version,
    batch: &mut LedgerDbSchemaBatches,
) -> Result<()> {
    delete_per_version_data_impl::<TransactionAccumulatorRootHashSchema>(
        ledger_db.transaction_accumulator_db_raw(),
        start_version,
        &mut batch.transaction_accumulator_db_batches,
    )?;
    delete_per_version_data_impl::<TransactionInfoSchema>(
        ledger_db.transaction_info_db_raw(),
        start_version,
        &mut batch.transaction_info_db_batches,
    )?;
    delete_transactions_and_transaction_summary_data(
        ledger_db.transaction_db(),
        start_version,
        &mut batch.transaction_db_batches,
    )?;
    delete_per_version_data_impl::<VersionDataSchema>(
        &ledger_db.metadata_db_arc(),
        start_version,
        &mut batch.ledger_metadata_db_batches,
    )?;
    delete_per_version_data_impl::<WriteSetSchema>(
        ledger_db.write_set_db_raw(),
        start_version,
        &mut batch.write_set_db_batches,
    )?;

    Ok(())
}
```

**File:** config/src/config/storage_config.rs (L233-233)
```rust
            enable_storage_sharding: true,
```

**File:** storage/aptosdb/src/db/aptosdb_internal.rs (L148-160)
```rust
        let mut myself = Self::new_with_dbs(
            ledger_db,
            hot_state_merkle_db,
            state_merkle_db,
            state_kv_db,
            pruner_config,
            buffered_state_target_items,
            readonly,
            empty_buffered_state_for_restore,
            rocksdb_configs.enable_storage_sharding,
            internal_indexer_db,
            hot_state_config,
        );
```

**File:** storage/aptosdb/src/db/aptosdb_internal.rs (L317-338)
```rust
    pub(super) fn get_raw_block_info_by_height(&self, block_height: u64) -> Result<BlockInfo> {
        if !self.skip_index_and_usage {
            let (first_version, new_block_event) = self.event_store.get_event_by_key(
                &new_block_event_key(),
                block_height,
                self.ensure_synced_version()?,
            )?;
            let new_block_event = bcs::from_bytes(new_block_event.event_data())?;
            Ok(BlockInfo::from_new_block_event(
                first_version,
                &new_block_event,
            ))
        } else {
            Ok(self
                .ledger_db
                .metadata_db()
                .get_block_info(block_height)?
                .ok_or_else(|| {
                    AptosDbError::NotFound(format!("BlockInfo not found at height {block_height}"))
                })?)
        }
    }
```

**File:** storage/aptosdb/src/db/aptosdb_internal.rs (L374-405)
```rust
    pub(super) fn to_api_block_info(
        &self,
        block_height: u64,
        block_info: BlockInfo,
    ) -> Result<(Version, Version, NewBlockEvent)> {
        // N.b. Must use committed_version because if synced version is used, we won't be able
        // to tell the end of the latest block.
        let committed_version = self.get_latest_ledger_info_version()?;
        ensure!(
            block_info.first_version() <= committed_version,
            "block first version {} > committed version {committed_version}",
            block_info.first_version(),
        );

        // TODO(grao): Consider return BlockInfo instead of NewBlockEvent.
        let new_block_event = self
            .ledger_db
            .event_db()
            .expect_new_block_event(block_info.first_version())?;

        let last_version = match self.get_raw_block_info_by_height(block_height + 1) {
            Ok(next_block_info) => next_block_info.first_version() - 1,
            Err(AptosDbError::NotFound(..)) => committed_version,
            Err(err) => return Err(err),
        };

        Ok((
            block_info.first_version(),
            last_version,
            bcs::from_bytes(new_block_event.event_data())?,
        ))
    }
```
