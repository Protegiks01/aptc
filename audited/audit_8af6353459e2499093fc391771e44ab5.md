# Audit Report

## Title
Missing Cryptographic Verification Allows Silent Backup Tampering During State Restoration

## Summary
The backup restoration system lacks mandatory cryptographic signature verification when restoring state snapshots with the `--skip-epoch-endings` flag and without trusted waypoints. This allows an attacker with write access to backup storage to inject arbitrary malicious state that will be silently accepted and restored to the database, leading to consensus divergence, fund manipulation, and complete state corruption.

## Finding Description

The vulnerability exists in the state snapshot restoration process where backup data integrity relies solely on Merkle proof consistency checks rather than cryptographic signatures. [1](#0-0) 

When `open_for_read` is called to read backup data, it simply spawns a command and returns raw bytes with no checksum or signature verification on the file itself.

The core issue manifests in the state snapshot restoration flow: [2](#0-1) 

At line 123-124, the manifest is loaded as JSON without any signature verification. At line 125-126, the proof file (containing `LedgerInfoWithSignatures`) is loaded from a FileHandle specified in the manifest. Critically, at lines 137-139, signature verification via `epoch_history.verify_ledger_info(&li)?` only executes if `epoch_history` is present.

The `epoch_history` is set to `None` when restoration is performed with the `--skip-epoch-endings` flag: [3](#0-2) 

Furthermore, the documentation explicitly states that LedgerInfo signatures are NOT verified during state snapshot restoration: [4](#0-3) 

**Attack Scenario:**

1. Attacker gains write access to backup storage (S3, filesystem, etc.)
2. Attacker creates malicious backup files:
   - `manifest.json`: Points to attacker-controlled proof and chunk files, contains fake `root_hash`
   - `fake_proof.bcs`: Contains `TransactionInfoWithProof` and `LedgerInfoWithSignatures` with invalid/no signatures
   - `chunk_N.blobs`: Contains malicious state data (e.g., modified account balances)
   - `chunk_N.proof`: Contains `SparseMerkleRangeProof` mathematically consistent with malicious blobs and fake root_hash

3. Victim runs restore command with `--skip-epoch-endings` flag (documented as "used for debugging" but available in production)

4. Restoration proceeds:
   - Manifest loaded without verification
   - Proof file loaded from attacker-controlled location
   - `txn_info_with_proof.verify()` passes (checks internal consistency between attacker-controlled proof and LedgerInfo)
   - Root hash check passes (attacker made them consistent)
   - **Epoch history verification SKIPPED** (line 137-139)
   - Chunk data verified against fake Merkle proofs (all internally consistent)
   - Malicious state committed to database

5. Result: Validator now has corrupted state with arbitrary account balances, resources, and Move modules

This violates the **State Consistency** invariant (state transitions must be verifiable via cryptographic proofs) and the **Deterministic Execution** invariant (different validators could restore different malicious states, causing consensus divergence).

## Impact Explanation

**Critical Severity** - This vulnerability meets multiple Critical impact categories from the Aptos bug bounty:

1. **Consensus/Safety Violations**: If different validators restore different tampered backups, they will have divergent state roots for the same version, causing irrecoverable consensus failure and chain halt.

2. **Loss of Funds**: An attacker can modify account balances in the backup, causing minting of new tokens or theft of existing funds when the malicious state is restored.

3. **State Manipulation**: Complete control over the state tree allows manipulation of validator sets, governance proposals, Move modules, and all on-chain data.

4. **Non-recoverable network partition**: If even one validator restores corrupted state, the network may require a hard fork to recover, as the corrupted validator will be unable to reach consensus with honest validators.

The vulnerability is particularly severe because:
- The tampered backup appears legitimate (all Merkle proofs verify)
- No warnings or errors are generated during restoration
- Detection requires comparing state roots across multiple nodes
- Recovery requires identifying the attack, re-syncing from genesis or trusted snapshot

## Likelihood Explanation

**Likelihood: Medium to High**

The attack is feasible when:
1. Attacker has write access to backup storage (cloud storage compromise, insider threat, misconfigured permissions)
2. Operators use `--skip-epoch-endings` flag (documented feature, may be used for faster recovery)
3. No trusted waypoints are provided (optional parameter)

Contributing factors increasing likelihood:
- Backup storage is often less secured than validator nodes themselves
- Cloud storage misconfigurations are common (exposed S3 buckets)
- The `--skip-epoch-endings` flag exists and is documented for use
- No warnings are displayed when restoring without cryptographic verification
- Operators may skip epoch ending restore for performance reasons during disaster recovery

The attack requires no validator-level access, no protocol-level exploit, and no cryptographic breaks - only write access to backup storage.

## Recommendation

Implement mandatory cryptographic verification for all backup restorations:

1. **Require epoch history verification OR trusted waypoints**: Modify the restoration logic to fail if neither verification method is available:

```rust
// In state_snapshot/restore.rs, after line 139:
if self.epoch_history.is_none() && !self.trusted_waypoints.contains_key(&manifest.version) {
    return Err(anyhow!(
        "Backup restoration requires either epoch history verification or a trusted waypoint \
        for version {}. Use --trust-waypoint or restore epoch endings to verify signatures.",
        manifest.version
    ));
}
```

2. **Add manifest signatures**: Sign manifest files at creation time and verify signatures before loading:
   - Include a `manifest_signature` field signed by the backup creator
   - Verify the signature before parsing manifest contents
   - Reject unsigned manifests in production environments

3. **Add file checksums to manifests**: Include SHA256 checksums for all referenced files in the manifest and verify them before deserialization:
   - Add `checksum` field to `StateSnapshotChunk` structure
   - Compute and verify checksums when reading blob/proof files
   - Detect tampering before attempting Merkle verification

4. **Remove or restrict --skip-epoch-endings flag**: Since this flag bypasses critical security checks, either:
   - Remove it entirely from production builds
   - Require explicit confirmation and additional authentication
   - Only allow it with mandatory trusted waypoints

5. **Add integrity warnings**: Display prominent warnings when restoration is performed without full cryptographic verification.

## Proof of Concept

**Attack Simulation Steps:**

```bash
# Step 1: Attacker creates malicious backup structure
mkdir -p /malicious_backup/state_snapshot

# Step 2: Create fake manifest with modified root_hash
cat > /malicious_backup/state_snapshot/manifest.json <<EOF
{
  "version": 1000000,
  "epoch": 10,
  "root_hash": "0x1234...fake_hash...",
  "chunks": [{
    "first_idx": 0,
    "last_idx": 999,
    "first_key": "0x00...",
    "last_key": "0xff...",
    "blobs": "/malicious_backup/chunk_0.blobs",
    "proof": "/malicious_backup/chunk_0.proof"
  }],
  "proof": "/malicious_backup/txn_proof.bcs"
}
EOF

# Step 3: Create fake proof file with unsigned/invalid LedgerInfo
# (Contains TransactionInfoWithProof + LedgerInfoWithSignatures)
# No valid validator signatures required if --skip-epoch-endings is used

# Step 4: Create malicious state data
# chunk_0.blobs contains BCS-encoded (StateKey, StateValue) pairs
# with modified account balances, e.g., attacker account has 1B APT

# Step 5: Create consistent Merkle proof for the fake data
# chunk_0.proof contains SparseMerkleRangeProof that proves
# the malicious chunk adds up to the fake root_hash

# Step 6: Victim runs restore (thinking it's a legitimate backup)
aptos-db-tool backup restore \
  --target-db-dir /var/aptos/db \
  --storage local-fs \
  --local-fs-dir /malicious_backup \
  --skip-epoch-endings \
  --target-version 1000000

# Result: Malicious state is restored with NO cryptographic verification
# The database now contains corrupted state with manipulated balances
# Validator will diverge from network consensus on next block
```

**Verification:**
After restoration, query the database to confirm the malicious state was accepted:
```bash
# Check if attacker's account has inflated balance
aptos account show --account 0xattacker_address

# Compare state root hash with other validators
# Will differ if different malicious backups were used
```

---

**Notes:**

The fundamental security flaw is that the backup system treats Merkle proof verification as sufficient for integrity, but Merkle proofs only verify internal mathematical consistency, not authenticity. Without cryptographic signatures from known validators, an attacker can create an entirely fabricated but internally consistent backup that passes all verification checks. The `--skip-epoch-endings` flag was likely intended for debugging but creates a production-ready attack vector when combined with the optional nature of trusted waypoints.

### Citations

**File:** storage/backup/backup-cli/src/storage/command_adapter/mod.rs (L114-124)
```rust
    async fn open_for_read(
        &self,
        file_handle: &FileHandleRef,
    ) -> Result<Box<dyn AsyncRead + Send + Unpin>> {
        let child = self
            .cmd(&self.config.commands.open_for_read, vec![
                EnvVar::file_handle(file_handle.to_string()),
            ])
            .spawn()?;
        Ok(Box::new(child.into_data_source()))
    }
```

**File:** storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs (L123-139)
```rust
        let manifest: StateSnapshotBackup =
            self.storage.load_json_file(&self.manifest_handle).await?;
        let (txn_info_with_proof, li): (TransactionInfoWithProof, LedgerInfoWithSignatures) =
            self.storage.load_bcs_file(&manifest.proof).await?;
        txn_info_with_proof.verify(li.ledger_info(), manifest.version)?;
        let state_root_hash = txn_info_with_proof
            .transaction_info()
            .ensure_state_checkpoint_hash()?;
        ensure!(
            state_root_hash == manifest.root_hash,
            "Root hash mismatch with that in proof. root hash: {}, expected: {}",
            manifest.root_hash,
            state_root_hash,
        );
        if let Some(epoch_history) = self.epoch_history.as_ref() {
            epoch_history.verify_ledger_info(&li)?;
        }
```

**File:** storage/backup/backup-cli/src/coordinators/restore.rs (L219-231)
```rust
        let epoch_history = if !self.skip_epoch_endings {
            Some(Arc::new(
                EpochHistoryRestoreController::new(
                    epoch_handles,
                    self.global_opt.clone(),
                    self.storage.clone(),
                )
                .run()
                .await?,
            ))
        } else {
            None
        };
```

**File:** storage/backup/backup-cli/src/utils/mod.rs (L332-346)
```rust
pub struct TrustedWaypointOpt {
    #[clap(
        long,
        help = "(multiple) When provided, an epoch ending LedgerInfo at the waypoint version will be \
        checked against the hash in the waypoint, but signatures on it are NOT checked. \
        Use this for two purposes: \
        1. set the genesis or the latest waypoint to confirm the backup is compatible. \
        2. set waypoints at versions where writeset transactions were used to overwrite the \
        validator set, so that the signature check is skipped. \
        N.B. LedgerInfos are verified only when restoring / verifying the epoch ending backups, \
        i.e. they are NOT checked at all when doing one-shot restoring of the transaction \
        and state backups."
    )]
    pub trust_waypoint: Vec<Waypoint>,
}
```
