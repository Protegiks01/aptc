# Audit Report

## Title
Server-Side Request Forgery (SSRF) in Move Package Git Dependency Resolution

## Summary
The Move package dependency resolution system accepts arbitrary URLs for git dependencies without validation, allowing attackers to trigger Server-Side Request Forgery (SSRF) attacks against internal network resources including cloud metadata services when the package build system processes malicious Move.toml manifests.

## Finding Description
The `GitInfo` struct stores a `git_url` field that is parsed directly from user-controlled Move.toml manifest files without any URL validation or sanitization. [1](#0-0) 

When parsing dependencies from Move.toml, the git URL is extracted as a plain string and stored directly into GitInfo. [2](#0-1) 

During dependency resolution, this unvalidated URL is passed directly to the git command-line tool. [3](#0-2) 

The `git::clone` function then executes the git command with the attacker-controlled URL without any validation. [4](#0-3) 

**Attack Flow:**
1. Attacker creates a Move package with a malicious Move.toml containing:
   ```toml
   [dependencies]
   MaliciousDep = { git = "http://169.254.169.254/latest/meta-data/", rev = "main", subdir = "" }
   ```

2. When a victim (developer, CI/CD system, or package registry) attempts to build this package or any package depending on it, the system executes:
   ```
   git clone http://169.254.169.254/latest/meta-data/ <local_path>
   ```

3. The git command makes an HTTP GET request to the internal metadata service, potentially exposing:
   - AWS EC2 instance metadata (IAM credentials, instance identity documents)
   - GCP metadata server (service account tokens, VM attributes)
   - Azure Instance Metadata Service (access tokens, VM information)
   - Internal HTTP APIs and services
   - Internal network topology through error messages

## Impact Explanation
This vulnerability affects the **Move package build tooling infrastructure** rather than runtime blockchain consensus. The impact severity depends on the operational context:

**High Impact Scenarios:**
- **CI/CD Pipeline Compromise**: Automated build systems processing untrusted packages could leak cloud credentials, enabling full infrastructure compromise
- **Developer Machine Exploitation**: Developers building malicious packages could have their cloud credentials stolen
- **Package Registry Infrastructure**: Systems that automatically process uploaded packages could be exploited for internal network reconnaissance

**Potential Consequences:**
- Theft of cloud IAM credentials from metadata services
- Access to internal APIs and services not exposed to the internet
- Internal network scanning and reconnaissance
- Information disclosure through build logs and error messages

While this does not directly affect on-chain consensus or validator runtime security, it represents a **supply chain attack vector** that could compromise the infrastructure used to develop, build, and deploy Aptos components and Move packages.

According to traditional security classifications, SSRF vulnerabilities allowing access to cloud metadata services are typically rated as **High Severity** due to the potential for credential theft and lateral movement.

## Likelihood Explanation
**Likelihood: High**

The attack has low barriers to execution:
- **No authentication required**: Anyone can create a Move package with a malicious Move.toml
- **Common attack vector**: Developers regularly build third-party packages and dependencies
- **Widespread exposure**: CI/CD systems, package registries, and developer environments all process Move.toml files
- **Social engineering**: Attackers can distribute malicious packages through repositories, social media, or by compromising legitimate dependencies

The vulnerability will trigger automatically whenever the build system processes a package with a malicious git dependency, requiring no user interaction beyond the normal build process.

## Recommendation
Implement URL validation and allowlisting for git dependencies:

```rust
// In manifest_parser.rs, add validation in parse_dependency():
fn validate_git_url(url: &str) -> Result<()> {
    let parsed = url::Url::parse(url)
        .context("Invalid git URL format")?;
    
    // Only allow standard git protocols
    match parsed.scheme() {
        "https" | "git" | "ssh" => {},
        scheme => bail!("Unsupported git URL scheme '{}'. Only https://, git://, and ssh:// are allowed", scheme),
    }
    
    // Block private IP ranges
    if let Some(host) = parsed.host_str() {
        // Block localhost
        if host == "localhost" || host == "127.0.0.1" || host == "::1" {
            bail!("Git URLs pointing to localhost are not allowed");
        }
        
        // Block link-local addresses (169.254.0.0/16)
        if host.starts_with("169.254.") {
            bail!("Git URLs pointing to link-local addresses are not allowed");
        }
        
        // Block private IP ranges (10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16)
        if let Ok(ip) = host.parse::<std::net::IpAddr>() {
            if ip.is_loopback() || ip.is_unspecified() {
                bail!("Git URLs pointing to loopback or unspecified addresses are not allowed");
            }
            // Additional private IP checks for IPv4
            if let std::net::IpAddr::V4(ipv4) = ip {
                let octets = ipv4.octets();
                if octets[0] == 10 
                    || (octets[0] == 172 && octets[1] >= 16 && octets[1] <= 31)
                    || (octets[0] == 192 && octets[1] == 168) {
                    bail!("Git URLs pointing to private IP addresses are not allowed");
                }
            }
        }
    }
    
    Ok(())
}

// Call this in parse_dependency() before creating GitInfo:
let git_url = git.as_str()
    .ok_or_else(|| anyhow::anyhow!("Git URL not a string"))?;
validate_git_url(git_url)?;  // Add this line
```

Additionally, consider:
1. Implementing an allowlist of trusted git hosting providers (GitHub, GitLab, etc.)
2. Adding a configuration option to restrict git dependencies to specific domains
3. Running git operations in sandboxed environments with restricted network access
4. Logging all git clone operations for security monitoring

## Proof of Concept

**Step 1**: Create a malicious Move package with the following Move.toml:

```toml
[package]
name = "MaliciousPackage"
version = "1.0.0"

[dependencies]
# This will trigger SSRF to AWS metadata service
AWSMetadataExfil = { git = "http://169.254.169.254/latest/meta-data/iam/security-credentials/", rev = "main", subdir = "" }

[addresses]
test = "0x1"
```

**Step 2**: Attempt to build the package:
```bash
aptos move compile --package-dir ./MaliciousPackage
```

**Expected Result**: The system will execute:
```
git clone http://169.254.169.254/latest/meta-data/iam/security-credentials/ <cache_path>
```

This will cause git to make an HTTP GET request to the AWS metadata service. If running on an EC2 instance, this could leak IAM credentials. On other systems, it will demonstrate the SSRF by attempting the connection and returning an error that confirms the HTTP request was made.

**To verify the vulnerability without exploitation**, add logging to the `clone` function or use a network monitoring tool (tcpdump, Wireshark) to observe the HTTP request being made to the specified internal address.

## Notes

This vulnerability affects the **Move package build tooling** infrastructure, not the runtime blockchain consensus or validator operations. However, it represents a critical **supply chain security risk** for the Aptos ecosystem:

1. **Developer Workstations**: Developers building Move packages could have their cloud credentials stolen
2. **CI/CD Pipelines**: Automated build systems could be compromised, leading to infrastructure takeover
3. **Package Registries**: Systems that process uploaded packages could leak internal network information

The severity classification depends on whether the Aptos bug bounty program considers build tooling and supply chain security in scope. Traditional security classifications would rate SSRF with metadata service access as **High Severity** due to the potential for credential theft and lateral movement in cloud environments.

The vulnerability is present in the core Move package tooling used throughout the Aptos ecosystem and should be addressed to protect developers, infrastructure operators, and automated systems from supply chain attacks.

### Citations

**File:** third_party/move/tools/move-package/src/source_package/parsed_manifest.rs (L90-101)
```rust
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct GitInfo {
    /// The git clone url to download from
    pub git_url: Symbol,
    /// The git revision, AKA, a commit SHA
    pub git_rev: Symbol,
    /// The path under this repo where the move package can be found -- e.g.,
    /// 'language/move-stdlib`
    pub subdir: PathBuf,
    /// Where the git repo is downloaded to.
    pub download_to: PathBuf,
}
```

**File:** third_party/move/tools/move-package/src/source_package/manifest_parser.rs (L365-381)
```rust
                    let git_url = git
                        .as_str()
                        .ok_or_else(|| anyhow::anyhow!("Git URL not a string"))?;
                    let local_path = git_repo_cache_path(git_url, rev_name.as_str());
                    let subdir = PathBuf::from(match table.remove("subdir") {
                        None => "".to_string(),
                        Some(path) => path
                            .as_str()
                            .ok_or_else(|| format_err!("'subdir' not a string"))?
                            .to_string(),
                    });
                    git_info = Some(PM::GitInfo {
                        git_url: Symbol::from(git_url),
                        git_rev: rev_name,
                        subdir: subdir.clone(),
                        download_to: local_path.clone(),
                    });
```

**File:** third_party/move/tools/move-package/src/resolution/resolution_graph.rs (L557-576)
```rust
        if let Some(git_info) = &dep.git_info {
            let git_url = git_info.git_url.as_str();
            let git_rev = git_info.git_rev.as_str();
            let git_path = &git_info.download_to.display().to_string();

            // If there is no cached dependency, download it
            if !git_info.download_to.exists() {
                writeln!(
                    writer,
                    "{} {}",
                    "FETCHING GIT DEPENDENCY".bold().green(),
                    git_url,
                )?;

                // Confirm git is available.
                git::confirm_git_available()?;

                // If the cached folder does not exist, download and clone accordingly
                git::clone(git_url, git_path, dep_name)?;
                git::checkout(git_path, git_rev, dep_name)?;
```

**File:** third_party/move/tools/move-package/src/resolution/git.rs (L27-44)
```rust
pub(crate) fn clone(url: &str, target_path: &str, dep_name: PackageName) -> anyhow::Result<()> {
    let status = Command::new("git")
        .args(["clone", url, target_path])
        .stdout(Stdio::null())
        .stderr(Stdio::null())
        .status()
        .map_err(|_| {
            anyhow::anyhow!("Failed to clone Git repository for package '{}'", dep_name)
        })?;
    if !status.success() {
        return Err(anyhow::anyhow!(
            "Failed to clone Git repository for package '{}' | Exit status: {}",
            dep_name,
            status
        ));
    }
    Ok(())
}
```
