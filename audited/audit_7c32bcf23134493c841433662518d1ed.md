# Audit Report

## Title
Asynchronous Aggregation Failure Can Cause Permanent Liveness Failure in Secret Sharing

## Summary
The `SecretShareStore::add_share()` function returns a boolean indicating that a decision has been made based on reaching the weight threshold, but the actual cryptographic aggregation happens asynchronously. If this async aggregation fails, no secret key is produced, yet the state remains "Decided" with no recovery mechanism, causing blocks to be permanently stuck and resulting in a liveness failure.

## Finding Description
The vulnerability exists in the secret sharing consensus subsystem where the return value of `add_share()` is inconsistent with the actual state of secret key production. [1](#0-0) 

When `add_share()` is called, it adds the share and calls `try_aggregate()`, then returns whether a decision has been made by checking `has_decision()`. The issue is that the state transitions to "Decided" as soon as the threshold is reached, before the cryptographic aggregation completes: [2](#0-1) 

The actual aggregation happens asynchronously in a spawned blocking task: [3](#0-2) 

If the aggregation fails (line 62-68), it only logs a warning and does not produce a key. However, the state has already been marked as "Decided" and the reliable broadcast has already stopped requesting shares based on the return value: [4](#0-3) [5](#0-4) 

Once in the "Decided" state, no more shares can be added: [6](#0-5) 

Blocks wait indefinitely for the secret key that never arrives: [7](#0-6) [8](#0-7) 

The aggregation can fail during reconstruction if there are issues with the cryptographic operations: [9](#0-8) 

## Impact Explanation
This issue qualifies as **Medium Severity** under the Aptos bug bounty criteria for "State inconsistencies requiring intervention". When the async aggregation fails:

1. Blocks become permanently stuck in the queue waiting for a secret key
2. Consensus cannot progress past that round
3. No timeout or recovery mechanism exists to unstuck the blocks
4. Manual intervention would be required to recover the network
5. This violates the **State Consistency** invariant requiring atomic state transitions

The main event loop shows no timeout handling: [10](#0-9) 

## Likelihood Explanation
While this requires an internal cryptographic failure rather than direct attacker action, the likelihood is **non-negligible** because:

1. Network conditions could cause incomplete share sets
2. Edge cases in weighted threshold reconstruction could trigger failures
3. The cryptographic library could encounter internal errors
4. Configuration mismatches between components could cause reconstruction failures
5. The architecture assumes aggregation will always succeed once threshold is met, which is an unsafe assumption

The issue represents a **Time-Of-Check-Time-Of-Use (TOCTOU) race condition** where the check (threshold reached) is separated from the use (actual aggregation), and the use can fail asynchronously without updating the checked state.

## Recommendation
The system should not mark aggregation as complete until the cryptographic operation succeeds. Two possible fixes:

**Option 1**: Make aggregation synchronous before changing state:
```rust
pub fn try_aggregate(
    self,
    secret_share_config: &SecretShareConfig,
    metadata: SecretShareMetadata,
    decision_tx: Sender<SecretSharedKey>,
) -> Either<Self, SecretShare> {
    if self.total_weight < secret_share_config.threshold() {
        return Either::Left(self);
    }
    
    // Perform aggregation synchronously first
    let maybe_key = SecretShare::aggregate(self.shares.values(), &secret_share_config);
    match maybe_key {
        Ok(key) => {
            let self_share = self.get_self_share().expect("...");
            let dec_key = SecretSharedKey::new(metadata, key);
            let _ = decision_tx.unbounded_send(dec_key);
            Either::Right(self_share)
        },
        Err(e) => {
            // Aggregation failed, stay in pending state
            warn!("Aggregation error: {e}");
            Either::Left(self)
        }
    }
}
```

**Option 2**: Add a recovery mechanism to retry with more shares if aggregation fails, by reverting to PendingDecision state and allowing more shares to be added.

## Proof of Concept
```rust
// Simulation showing the race condition
#[test]
fn test_aggregation_failure_causes_stuck_block() {
    // Setup validator with secret share store
    let (decision_tx, mut decision_rx) = unbounded();
    let mut store = SecretShareStore::new(epoch, author, config, decision_tx);
    
    // Simulate receiving shares that reach threshold
    for i in 0..threshold {
        let share = create_valid_share(validator_i, round);
        let has_decision = store.add_share(share).unwrap();
        
        if i == threshold - 1 {
            // Last share triggers aggregation
            assert!(has_decision); // State is "Decided"
        }
    }
    
    // Simulate aggregation failure (e.g., by corrupting internal state)
    // The spawned task fails but state remains "Decided"
    
    // Try to receive the key - it never arrives
    tokio::time::timeout(Duration::from_secs(5), decision_rx.next())
        .await
        .expect_err("Key should timeout - never received");
    
    // Try to add more shares - they are ignored
    let extra_share = create_valid_share(validator_x, round);
    store.add_share(extra_share).unwrap();
    // Still no key arrives
    
    // Block is now permanently stuck
}
```

## Notes
This vulnerability specifically affects the consensus liveness guarantee. The architectural flaw is the optimistic assumption that once a threshold is reached, aggregation will succeed. The async nature of the aggregation combined with the immediate state change creates a window where failures are not recoverable. This breaks the invariant that "Decided" state implies successful key production.

### Citations

**File:** consensus/src/rand/secret_sharing/secret_share_store.rs (L38-72)
```rust
    pub fn try_aggregate(
        self,
        secret_share_config: &SecretShareConfig,
        metadata: SecretShareMetadata,
        decision_tx: Sender<SecretSharedKey>,
    ) -> Either<Self, SecretShare> {
        if self.total_weight < secret_share_config.threshold() {
            return Either::Left(self);
        }
        observe_block(
            metadata.timestamp,
            BlockStage::SECRET_SHARING_ADD_ENOUGH_SHARE,
        );
        let dec_config = secret_share_config.clone();
        let self_share = self
            .get_self_share()
            .expect("Aggregated item should have self share");
        tokio::task::spawn_blocking(move || {
            let maybe_key = SecretShare::aggregate(self.shares.values(), &dec_config);
            match maybe_key {
                Ok(key) => {
                    let dec_key = SecretSharedKey::new(metadata, key);
                    let _ = decision_tx.unbounded_send(dec_key);
                },
                Err(e) => {
                    warn!(
                        epoch = metadata.epoch,
                        round = metadata.round,
                        "Aggregation error: {e}"
                    );
                },
            }
        });
        Either::Right(self_share)
    }
```

**File:** consensus/src/rand/secret_sharing/secret_share_store.rs (L126-127)
```rust
            SecretShareItem::Decided { .. } => Ok(()),
        }
```

**File:** consensus/src/rand/secret_sharing/secret_share_store.rs (L130-154)
```rust
    fn try_aggregate(
        &mut self,
        secret_share_config: &SecretShareConfig,
        decision_tx: Sender<SecretSharedKey>,
    ) {
        let item = std::mem::replace(self, Self::new(Author::ONE));
        let new_item = match item {
            SecretShareItem::PendingDecision {
                share_aggregator,
                metadata,
            } => match share_aggregator.try_aggregate(
                secret_share_config,
                metadata.clone(),
                decision_tx,
            ) {
                Either::Left(share_aggregator) => Self::PendingDecision {
                    metadata,
                    share_aggregator,
                },
                Either::Right(self_share) => Self::Decided { self_share },
            },
            item @ (SecretShareItem::Decided { .. } | SecretShareItem::PendingMetadata(_)) => item,
        };
        let _ = std::mem::replace(self, new_item);
    }
```

**File:** consensus/src/rand/secret_sharing/secret_share_store.rs (L259-275)
```rust
    pub fn add_share(&mut self, share: SecretShare) -> anyhow::Result<bool> {
        let weight = self.secret_share_config.get_peer_weight(share.author());
        let metadata = share.metadata();
        ensure!(metadata.epoch == self.epoch, "Share from different epoch");
        ensure!(
            metadata.round <= self.highest_known_round + FUTURE_ROUNDS_TO_ACCEPT,
            "Share from future round"
        );

        let item = self
            .secret_share_map
            .entry(metadata.round)
            .or_insert_with(|| SecretShareItem::new(self.self_author));
        item.add_share(share, weight)?;
        item.try_aggregate(&self.secret_share_config, self.decision_tx.clone());
        Ok(item.has_decision())
    }
```

**File:** consensus/src/rand/secret_sharing/reliable_broadcast_state.rs (L44-60)
```rust
    fn add(&self, peer: Author, share: Self::Response) -> anyhow::Result<Option<()>> {
        ensure!(share.author() == &peer, "Author does not match");
        ensure!(
            share.metadata() == &self.secret_share_metadata,
            "Metadata does not match: local {:?}, received {:?}",
            self.secret_share_metadata,
            share.metadata()
        );
        share.verify(&self.secret_share_config)?;
        info!(LogSchema::new(LogEvent::ReceiveReactiveSecretShare)
            .epoch(share.epoch())
            .round(share.metadata().round)
            .remote_peer(*share.author()));
        let mut store = self.secret_share_store.lock();
        let aggregated = store.add_share(share)?.then_some(());
        Ok(aggregated)
    }
```

**File:** crates/reliable-broadcast/src/lib.rs (L186-189)
```rust
                            Ok(may_be_aggragated) => {
                                if let Some(aggregated) = may_be_aggragated {
                                    return Ok(aggregated);
                                }
```

**File:** consensus/src/rand/secret_sharing/block_queue.rs (L60-77)
```rust
    pub fn is_fully_secret_shared(&self) -> bool {
        self.pending_secret_key_rounds.is_empty()
    }

    pub fn set_secret_shared_key(&mut self, round: Round, key: SecretSharedKey) {
        let offset = self.offset(round);
        if self.pending_secret_key_rounds.contains(&round) {
            observe_block(
                self.blocks()[offset].timestamp_usecs(),
                BlockStage::SECRET_SHARING_ADD_DECISION,
            );
            let block = &self.blocks_mut()[offset];
            if let Some(tx) = block.pipeline_tx().lock().as_mut() {
                tx.secret_shared_key_tx.take().map(|tx| tx.send(Some(key)));
            }
            self.pending_secret_key_rounds.remove(&round);
        }
    }
```

**File:** consensus/src/rand/secret_sharing/block_queue.rs (L112-126)
```rust
    pub fn dequeue_ready_prefix(&mut self) -> Vec<OrderedBlocks> {
        let mut ready_prefix = vec![];
        while let Some((_starting_round, item)) = self.queue.first_key_value() {
            if item.is_fully_secret_shared() {
                let (_, item) = self.queue.pop_first().expect("First key must exist");
                for block in item.blocks() {
                    observe_block(block.timestamp_usecs(), BlockStage::SECRET_SHARING_READY);
                }
                let QueueItem { ordered_blocks, .. } = item;
                ready_prefix.push(ordered_blocks);
            } else {
                break;
            }
        }
        ready_prefix
```

**File:** crates/aptos-crypto/src/arkworks/shamir.rs (L313-318)
```rust
        if shares.len() < sc.t {
            Err(anyhow!(
                "Incorrect number of shares provided, received {} but expected at least {}",
                shares.len(),
                sc.t
            ))
```

**File:** consensus/src/rand/secret_sharing/secret_share_manager.rs (L352-377)
```rust
        let mut interval = tokio::time::interval(Duration::from_millis(5000));
        while !self.stop {
            tokio::select! {
                Some(blocks) = incoming_blocks.next() => {
                    self.process_incoming_blocks(blocks).await;
                }
                Some(reset) = reset_rx.next() => {
                    while matches!(incoming_blocks.try_next(), Ok(Some(_))) {}
                    self.process_reset(reset);
                }
                Some(secret_shared_key) = self.decision_rx.next() => {
                    self.process_aggregated_key(secret_shared_key);
                }
                Some(request) = verified_msg_rx.next() => {
                    self.handle_incoming_msg(request);
                }
                _ = interval.tick().fuse() => {
                    self.observe_queue();
                },
            }
            let maybe_ready_blocks = self.block_queue.dequeue_ready_prefix();
            if !maybe_ready_blocks.is_empty() {
                self.process_ready_blocks(maybe_ready_blocks);
            }
        }
        info!("SecretShareManager stopped");
```
