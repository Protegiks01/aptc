# Audit Report

## Title
Byzantine Validators Can Spoof Timeout Reasons to Falsely Blame and Exclude Honest Validators from OptQS

## Summary
Byzantine validators can attach false timeout reasons to valid timeout signatures, allowing them to falsely blame honest validators for payload unavailability. This causes honest validators to be excluded from Optimistic Quorum Store (OptQS) proposals, degrading network performance and potentially impacting liveness.

## Finding Description

The vulnerability exists because timeout reasons in the AptosBFT consensus protocol are not cryptographically signed, allowing Byzantine validators to lie about why a round timed out. [1](#0-0) 

When a validator times out, it computes a `RoundTimeoutReason` based on local state. However, when this timeout is broadcast to other validators, only the `TwoChainTimeout` structure is cryptographically signed, not the attached reason: [2](#0-1) 

The signature verification only checks the timeout's signing format (epoch, round, hqc_round), not the reason field: [3](#0-2) 

Byzantine validators can exploit this by:
1. Creating valid timeout signatures for legitimate timeouts
2. Attaching false `RoundTimeoutReason::PayloadUnavailable { missing_authors }` with a bitvec identifying honest validators
3. Broadcasting these spoofed timeout messages

When timeout votes are aggregated, the system selects the timeout reason with the most voting power (requiring only **f+1** threshold): [4](#0-3) 

The f+1 threshold is enforced by checking with `check_super_majority = false`: [5](#0-4) 

Once f+1 Byzantine validators report the same false `PayloadUnavailable` reason with specific honest validators in the `missing_authors` bitvec, those honest validators are:

1. Added to the aggregated timeout reason
2. Recorded by the `ExponentialWindowFailureTracker`: [6](#0-5) 

3. Excluded from future OptQS batch pulling: [7](#0-6) 

4. Filtered out when pulling batches: [8](#0-7) 

## Impact Explanation

This vulnerability falls under **Medium Severity** ($10,000) per the Aptos bug bounty criteria as it causes:

1. **Performance degradation**: Excluding honest validators from OptQS reduces the available batch pool, lowering transaction throughput
2. **State inconsistencies**: False metrics and reputation damage to honest validators 
3. **Potential liveness impact**: If enough validators are excluded, proposal generation may be significantly delayed

The impact is limited because:
- It does not break consensus safety (no double-spending or chain splits)
- It does not cause permanent state corruption requiring hard fork
- The exclusion is temporary and resets after successful rounds
- The system can still function, albeit with degraded performance

However, repeated coordinated attacks could cause sustained performance degradation and operational issues.

## Likelihood Explanation

**Likelihood: Medium to High**

Attack requirements:
- Only f+1 Byzantine validators (by voting power) needed to coordinate
- Under standard BFT assumptions (f < n/3), this is realistic
- No additional cryptographic resources required
- Attack can be executed during any timeout round

The attack is stealthy because:
- False timeout reasons look like legitimate diagnostic information
- No cryptographic verification failures occur
- Metrics appear normal except for the false blame assignment

Byzantine validators have strong incentives to execute this attack:
- Degrade competitors' reputations
- Reduce competition for transaction fees
- Cause operational issues for specific validators

## Recommendation

**Option 1: Include timeout reason in the signed data**

Modify the `TimeoutSigningRepr` to include a hash of the timeout reason:

```rust
// In consensus/consensus-types/src/timeout_2chain.rs
#[derive(Serialize, Deserialize, Debug, CryptoHasher, BCSCryptoHash)]
pub struct TimeoutSigningRepr {
    pub epoch: u64,
    pub round: Round,
    pub hqc_round: Round,
    pub reason_hash: HashValue, // Add this field
}
```

Update `signing_format()` to include the reason:

```rust
pub fn signing_format(&self, reason: &RoundTimeoutReason) -> TimeoutSigningRepr {
    TimeoutSigningRepr {
        epoch: self.epoch(),
        round: self.round(),
        hqc_round: self.hqc_round(),
        reason_hash: CryptoHash::hash(reason),
    }
}
```

**Option 2: Require 2f+1 threshold for timeout reason aggregation**

Change the aggregation logic to require quorum (2f+1) instead of minority (f+1):

```rust
// In consensus/src/pending_votes.rs, line 128
.filter(|(_, voting_power)| {
    verifier
        .check_aggregated_voting_power(*voting_power, true) // Change to true
        .is_ok()
})
```

This prevents f+1 Byzantine validators from controlling the aggregated reason, though it may result in more "Unknown" timeout reasons.

**Option 3: Cross-validate timeout reasons**

Add validation logic that checks if the claimed timeout reason is plausible based on available information (e.g., verify that missing_authors actually failed to provide batches).

**Recommended approach**: Implement Option 1 (sign the timeout reason) as it provides the strongest guarantee and prevents any spoofing. This requires a protocol upgrade but fully addresses the vulnerability.

## Proof of Concept

```rust
#[cfg(test)]
mod timeout_reason_spoofing_test {
    use super::*;
    use aptos_bitvec::BitVec;
    use aptos_consensus_types::round_timeout::{RoundTimeout, RoundTimeoutReason};
    use aptos_consensus_types::timeout_2chain::TwoChainTimeout;
    use aptos_types::validator_verifier::random_validator_verifier;
    
    #[tokio::test]
    async fn test_byzantine_validators_spoof_timeout_reason() {
        // Setup: 4 validators where validator 0 is Byzantine
        let (signers, verifier) = random_validator_verifier(4, None, false);
        let byzantine_signer = &signers[0];
        let honest_validator_idx = 1; // Target honest validator 1
        
        let epoch = 1;
        let round = 10;
        let qc = create_test_qc(epoch, round - 1, &verifier);
        
        // Byzantine validator creates a valid timeout signature
        let timeout = TwoChainTimeout::new(epoch, round, qc);
        let signature = byzantine_signer.sign(&timeout.signing_format()).unwrap();
        
        // But attaches a FALSE timeout reason blaming honest validator 1
        let mut missing_authors_bitvec = BitVec::with_num_bits(verifier.len() as u16);
        missing_authors_bitvec.set(honest_validator_idx); // Falsely blame validator 1
        
        let false_reason = RoundTimeoutReason::PayloadUnavailable {
            missing_authors: missing_authors_bitvec,
        };
        
        let malicious_timeout = RoundTimeout::new(
            timeout.clone(),
            byzantine_signer.author(),
            false_reason, // FALSE REASON - validator 1 did nothing wrong!
            signature,
        );
        
        // The timeout PASSES verification despite the false reason
        assert!(malicious_timeout.verify(&verifier).is_ok());
        
        // If f+1 Byzantine validators do this, honest validator 1 gets excluded from OptQS
        // This demonstrates the vulnerability: signature verification succeeds even with
        // false timeout reasons because the reason is NOT part of what's signed
    }
}
```

## Notes

This vulnerability is inherent in the current design where timeout reasons are treated as diagnostic metadata rather than consensus-critical data. While timeout reasons don't affect consensus safety, they do affect performance optimization decisions (OptQS exclusion), making them a valid attack vector for Byzantine validators seeking to degrade network performance or harm specific validators' reputations.

The vulnerability requires Byzantine validator coordination (f+1 validators), which is within the standard BFT threat model. The impact is classified as Medium because it affects performance and operational metrics but does not break consensus safety guarantees.

### Citations

**File:** consensus/src/round_manager.rs (L968-983)
```rust
    fn compute_timeout_reason(&self, round: Round) -> RoundTimeoutReason {
        if self.round_state().vote_sent().is_some() {
            return RoundTimeoutReason::NoQC;
        }

        match self.block_store.get_block_for_round(round) {
            None => RoundTimeoutReason::ProposalNotReceived,
            Some(block) => {
                if let Err(missing_authors) = self.block_store.check_payload(block.block()) {
                    RoundTimeoutReason::PayloadUnavailable { missing_authors }
                } else {
                    RoundTimeoutReason::Unknown
                }
            },
        }
    }
```

**File:** consensus/consensus-types/src/timeout_2chain.rs (L66-72)
```rust
    pub fn signing_format(&self) -> TimeoutSigningRepr {
        TimeoutSigningRepr {
            epoch: self.epoch(),
            round: self.round(),
            hqc_round: self.hqc_round(),
        }
    }
```

**File:** consensus/consensus-types/src/round_timeout.rs (L97-107)
```rust
    pub fn verify(&self, validator: &ValidatorVerifier) -> anyhow::Result<()> {
        self.timeout.verify(validator)?;
        validator
            .verify(
                self.author(),
                &self.timeout.signing_format(),
                &self.signature,
            )
            .context("Failed to verify 2-chain timeout signature")?;
        Ok(())
    }
```

**File:** consensus/src/pending_votes.rs (L119-153)
```rust
        // The aggregated timeout reason is the reason with the most voting power received from
        // at least f+1 peers by voting power. If such voting power does not exist, then the
        // reason is unknown.

        reason_voting_power
            .into_iter()
            .max_by_key(|(_, voting_power)| *voting_power)
            .filter(|(_, voting_power)| {
                verifier
                    .check_aggregated_voting_power(*voting_power, false)
                    .is_ok()
            })
            .map(|(reason, _)| {
                // If the aggregated reason is due to unavailable payload, we will compute the
                // aggregated missing authors bitvec counting batch authors that have been reported
                // missing by minority peers.
                if matches!(reason, RoundTimeoutReason::PayloadUnavailable { .. }) {
                    let mut aggregated_bitvec = BitVec::with_num_bits(verifier.len() as u16);
                    for (author_idx, voting_power) in missing_batch_authors {
                        if verifier
                            .check_aggregated_voting_power(voting_power, false)
                            .is_ok()
                        {
                            aggregated_bitvec.set(author_idx as u16);
                        }
                    }
                    RoundTimeoutReason::PayloadUnavailable {
                        missing_authors: aggregated_bitvec,
                    }
                } else {
                    reason
                }
            })
            .unwrap_or(RoundTimeoutReason::Unknown)
    }
```

**File:** types/src/validator_verifier.rs (L462-480)
```rust
    pub fn check_aggregated_voting_power(
        &self,
        aggregated_voting_power: u128,
        check_super_majority: bool,
    ) -> std::result::Result<u128, VerifyError> {
        let target = if check_super_majority {
            self.quorum_voting_power
        } else {
            self.total_voting_power - self.quorum_voting_power + 1
        };

        if aggregated_voting_power < target {
            return Err(VerifyError::TooLittleVotingPower {
                voting_power: aggregated_voting_power,
                expected_voting_power: target,
            });
        }
        Ok(aggregated_voting_power)
    }
```

**File:** consensus/src/liveness/proposal_status_tracker.rs (L65-78)
```rust
    fn compute_failure_window(&mut self) {
        self.last_consecutive_success_count = self.last_consecutive_statuses_matching(|reason| {
            !matches!(
                reason,
                NewRoundReason::Timeout(RoundTimeoutReason::PayloadUnavailable { .. })
            )
        });
        if self.last_consecutive_success_count == 0 {
            self.window *= 2;
            self.window = self.window.min(self.max_window);
        } else if self.last_consecutive_success_count == self.past_round_statuses.len() {
            self.window = 2;
        }
    }
```

**File:** consensus/src/liveness/proposal_status_tracker.rs (L80-98)
```rust
    fn get_exclude_authors(&self) -> HashSet<Author> {
        let mut exclude_authors = HashSet::new();

        let limit = self.window;
        for round_reason in self.past_round_statuses.iter().rev().take(limit) {
            if let NewRoundReason::Timeout(RoundTimeoutReason::PayloadUnavailable {
                missing_authors,
            }) = round_reason
            {
                for author_idx in missing_authors.iter_ones() {
                    if let Some(author) = self.ordered_authors.get(author_idx) {
                        exclude_authors.insert(*author);
                    }
                }
            }
        }

        exclude_authors
    }
```

**File:** consensus/src/quorum_store/batch_proof_queue.rs (L596-600)
```rust
        for (_, batches) in self
            .author_to_batches
            .iter()
            .filter(|(author, _)| !exclude_authors.contains(author))
        {
```
