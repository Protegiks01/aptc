# Audit Report

## Title
Inspection Service Exposes Sensitive Validator State Without Application-Level Access Controls

## Summary
The InspectionServiceConfig enables an HTTP service on port 9101 that exposes sensitive validator state including consensus metrics, network topology, peer information, and system details without any application-level authentication or authorization mechanisms, relying solely on network-level security controls.

## Finding Description
The inspection service configured at [1](#0-0)  exposes multiple endpoints containing sensitive validator information without implementing any application-level access controls.

By default, the InspectionServiceConfig enables the following endpoints: [2](#0-1) 

The service binds to all network interfaces (0.0.0.0) and serves unauthenticated HTTP requests: [3](#0-2) 

**Sensitive information exposed includes:**

1. **Metrics endpoints** (always exposed, no configuration flag):
   - Consensus state (current round, committed rounds, voting power)
   - Validator proposals and votes [4](#0-3) 

2. **Peer information** (enabled by default):
   - Complete network topology
   - Connected peer IDs and IP addresses
   - Trusted validator set [5](#0-4) 

3. **Identity information** (enabled by default):
   - Validator and fullnode peer IDs [6](#0-5) 

4. **System information** (enabled by default):
   - Build version and git commit
   - Operating system details [7](#0-6) 

The service implementation contains zero authentication checks - no bearer tokens, API keys, IP whitelisting, or any other access control mechanism at the application layer.

## Impact Explanation
This represents a **defense-in-depth failure** rather than a direct critical vulnerability. While the infrastructure deployments include network-level protections (Kubernetes NetworkPolicy, HAProxy IP blocking, cloud security groups), the complete absence of application-level access controls creates risk:

1. **Information Disclosure**: Attackers who can reach port 9101 (through network misconfiguration, compromised cluster access, or exposed services) can:
   - Map the entire validator network topology
   - Identify exact software versions for targeted exploits
   - Monitor consensus participation and timing
   - Correlate peer IDs with on-chain validator identities

2. **Attack Surface Expansion**: The exposed information enables:
   - Targeted DoS attacks based on network topology
   - Exploitation of version-specific vulnerabilities
   - Timing attacks based on consensus state monitoring
   - Social engineering via validator de-anonymization

However, **exploitation requires network-level access**, which the deployment infrastructure is designed to prevent. This does not meet **Critical** or **High** severity as it doesn't directly enable consensus violations or fund loss. It falls between **Medium** (state inconsistencies) and **Low** (minor information leaks) severity.

## Likelihood Explanation
**Likelihood is LOW under proper deployment** but **HIGH if network security is misconfigured:**

- The provided Kubernetes NetworkPolicy and cloud security group configurations are designed to restrict access to port 9101
- However, deployment misconfigurations are common in production environments
- The service's binding to `0.0.0.0` means any network security failure immediately exposes all endpoints
- Zero application-level controls means there's no fallback protection

The design philosophy assumes network security will be correctly implemented and maintained, which violates defense-in-depth principles.

## Recommendation
Implement application-level access controls for the inspection service:

1. **Add authentication**: Require API tokens or mTLS certificates for all endpoints
2. **Implement authorization**: Use role-based access control to limit endpoint access
3. **Bind to localhost by default**: Change default address from `0.0.0.0` to `127.0.0.1`
4. **Add rate limiting**: Prevent information gathering via repeated requests
5. **Audit logging**: Log all access attempts for security monitoring

**Code fix example for InspectionServiceConfig:**

```rust
pub struct InspectionServiceConfig {
    pub address: String,  // Change default to "127.0.0.1"
    pub port: u16,
    pub expose_configuration: bool,
    pub expose_identity_information: bool,
    pub expose_peer_information: bool,
    pub expose_system_information: bool,
    pub require_authentication: bool,  // NEW: require bearer tokens
    pub api_key_hash: Option<String>,  // NEW: hashed API key
}
```

## Proof of Concept
```bash
# If port 9101 is network-accessible (misconfigured deployment):

# 1. Enumerate all available endpoints
curl http://<validator-ip>:9101/

# 2. Extract validator peer IDs and network topology
curl http://<validator-ip>:9101/identity_information
curl http://<validator-ip>:9101/peer_information

# 3. Monitor consensus state in real-time
while true; do
  curl http://<validator-ip>:9101/metrics | grep "aptos_consensus_last_committed_round"
  sleep 1
done

# 4. Identify software version for targeted exploits
curl http://<validator-ip>:9101/system_information | jq '.git_hash'

# No authentication required for any of these requests
```

**Notes**

While this represents a legitimate security concern from a defense-in-depth perspective, the **strict validation requirement** reveals this is a **design decision** rather than a code vulnerability:

1. The infrastructure code explicitly implements network-level security controls
2. The ConfigSanitizer only restricts configuration exposure, indicating other endpoints are considered acceptable within a protected network
3. Exploitation requires network-level access that violates the intended deployment architecture

Under the "extremely high bar" standard and "ruthlessly skeptical" approach required, this is better classified as a **security hardening recommendation** rather than an exploitable vulnerability, as it cannot be exploited without first bypassing the network-level security controls that are integral to the system's deployment architecture.

### Citations

**File:** config/src/config/node_config.rs (L65-65)
```rust
    pub inspection_service: InspectionServiceConfig,
```

**File:** config/src/config/inspection_service_config.rs (L26-36)
```rust
impl Default for InspectionServiceConfig {
    fn default() -> InspectionServiceConfig {
        InspectionServiceConfig {
            address: "0.0.0.0".to_string(),
            port: 9101,
            expose_configuration: false,
            expose_identity_information: true,
            expose_peer_information: true,
            expose_system_information: true,
        }
    }
```

**File:** crates/aptos-inspection-service/src/server/mod.rs (L104-169)
```rust
async fn serve_requests(
    req: Request<Body>,
    node_config: NodeConfig,
    aptos_data_client: AptosDataClient,
    peers_and_metadata: Arc<PeersAndMetadata>,
) -> Result<Response<Body>, hyper::Error> {
    // Process the request and get the response components
    let (status_code, body, content_type) = match req.uri().path() {
        CONFIGURATION_PATH => {
            // /configuration
            // Exposes the node configuration
            configuration::handle_configuration_request(&node_config)
        },
        CONSENSUS_HEALTH_CHECK_PATH => {
            // /consensus_health_check
            // Exposes the consensus health check
            metrics::handle_consensus_health_check(&node_config).await
        },
        FORGE_METRICS_PATH => {
            // /forge_metrics
            // Exposes forge encoded metrics
            metrics::handle_forge_metrics()
        },
        IDENTITY_INFORMATION_PATH => {
            // /identity_information
            // Exposes the identity information of the node
            identity_information::handle_identity_information_request(&node_config)
        },
        INDEX_PATH => {
            // /
            // Exposes the index and list of available endpoints
            index::handle_index_request()
        },
        JSON_METRICS_PATH => {
            // /json_metrics
            // Exposes JSON encoded metrics
            metrics::handle_json_metrics_request()
        },
        METRICS_PATH => {
            // /metrics
            // Exposes text encoded metrics
            metrics::handle_metrics_request()
        },
        PEER_INFORMATION_PATH => {
            // /peer_information
            // Exposes the peer information
            peer_information::handle_peer_information_request(
                &node_config,
                aptos_data_client,
                peers_and_metadata,
            )
        },
        SYSTEM_INFORMATION_PATH => {
            // /system_information
            // Exposes the system and build information
            system_information::handle_system_information_request(node_config)
        },
        _ => {
            // Handle the invalid path
            (
                StatusCode::NOT_FOUND,
                Body::from(INVALID_ENDPOINT_MESSAGE),
                CONTENT_TYPE_TEXT.into(),
            )
        },
    };
```

**File:** consensus/src/counters.rs (L79-95)
```rust
pub static LAST_COMMITTED_ROUND: Lazy<IntGauge> = Lazy::new(|| {
    register_int_gauge!(
        "aptos_consensus_last_committed_round",
        "This counter is set to the round of the highest committed block."
    )
    .unwrap()
});

/// The counter corresponds to the round of the highest committed opt block.
pub static LAST_COMMITTED_OPT_BLOCK_ROUND: Lazy<IntGauge> = Lazy::new(|| {
    register_int_gauge!(
        "aptos_consensus_last_committed_opt_block_round",
        "The counter corresponds to the round of the highest committed opt block."
    )
    .unwrap()
});

```

**File:** crates/aptos-inspection-service/src/server/peer_information.rs (L13-38)
```rust
use hyper::{Body, StatusCode};
use std::{collections::BTreeMap, ops::Deref, sync::Arc};

// The message to display when the peer information endpoint is disabled
pub const PEER_INFO_DISABLED_MESSAGE: &str =
    "This endpoint is disabled! Enable it in the node config at inspection_service.expose_peer_information: true";

/// Handles a new peer information request
pub fn handle_peer_information_request(
    node_config: &NodeConfig,
    aptos_data_client: AptosDataClient,
    peers_and_metadata: Arc<PeersAndMetadata>,
) -> (StatusCode, Body, String) {
    // Only return peer information if the endpoint is enabled
    let (status_code, body) = if node_config.inspection_service.expose_peer_information {
        let peer_information = get_peer_information(aptos_data_client, peers_and_metadata);
        (StatusCode::OK, Body::from(peer_information))
    } else {
        (
            StatusCode::FORBIDDEN,
            Body::from(PEER_INFO_DISABLED_MESSAGE),
        )
    };

    (status_code, body, CONTENT_TYPE_TEXT.into())
}
```

**File:** crates/aptos-inspection-service/src/server/identity_information.rs (L13-26)
```rust
pub fn handle_identity_information_request(node_config: &NodeConfig) -> (StatusCode, Body, String) {
    // Only return identity information if the endpoint is enabled
    let (status_code, body) = if node_config.inspection_service.expose_identity_information {
        let identity_information = get_identity_information(node_config);
        (StatusCode::OK, Body::from(identity_information))
    } else {
        (
            StatusCode::FORBIDDEN,
            Body::from(IDENTITY_INFO_DISABLED_MESSAGE),
        )
    };

    (status_code, body, CONTENT_TYPE_TEXT.into())
}
```

**File:** crates/aptos-inspection-service/src/server/system_information.rs (L14-28)
```rust
pub fn handle_system_information_request(node_config: NodeConfig) -> (StatusCode, Body, String) {
    // Only return system information if the endpoint is enabled
    if node_config.inspection_service.expose_system_information {
        (
            StatusCode::OK,
            Body::from(get_system_information_json()),
            CONTENT_TYPE_JSON.into(),
        )
    } else {
        (
            StatusCode::FORBIDDEN,
            Body::from(SYS_INFO_DISABLED_MESSAGE),
            CONTENT_TYPE_TEXT.into(),
        )
    }
```
