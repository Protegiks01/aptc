# Audit Report

## Title
DKG Node Crash Due to Panic in ReliableBroadcast with Empty Validator Set

## Summary
When a `ValidatorSet` with zero validators is processed during epoch transition in the DKG (Distributed Key Generation) subsystem, the node will crash with a panic in `ReliableBroadcast::broadcast()`. The panic occurs at an `unreachable!()` macro when the broadcast loop has no validators to send messages to.

## Finding Description

The vulnerability manifests through the following execution path:

1. **ValidatorSet Extraction**: In `epoch_manager.rs`, a `ValidatorSet` is extracted from the on-chain configuration payload without validating it contains at least one validator. [1](#0-0) 

2. **EpochState Creation**: An `EpochState` is created with the potentially empty validator set, converting it to a `ValidatorVerifier` with zero validators and zero quorum voting power. [2](#0-1) 

3. **ValidatorVerifier Behavior**: When `ValidatorVerifier` is constructed with an empty validator list, it sets `quorum_voting_power` to 0 but does not reject the empty configuration. [3](#0-2) 

4. **ReliableBroadcast Construction**: An empty validator list is passed to `ReliableBroadcast::new()` via `get_ordered_account_addresses()`. [4](#0-3) 

5. **DKG Initialization**: When a `DKGStartEvent` arrives, `setup_deal_broadcast` is invoked. [5](#0-4) 

6. **Broadcast Invocation**: The `AggTranscriptProducer` calls `rb.broadcast()` to collect DKG transcripts from validators. [6](#0-5) 

7. **Panic Trigger**: With an empty `receivers` list, the `tokio::select!` loop in `ReliableBroadcast::multicast()` has no futures to poll. Both `rpc_futures` and `aggregate_futures` are empty, causing the else branch to execute `unreachable!("Should aggregate with all responses")`, which panics. [7](#0-6) 

**Invariant Violation**: This breaks the availability invariant—DKG nodes must gracefully handle configuration errors rather than crashing with unexpected panics.

## Impact Explanation

**Severity: High** - This qualifies as "Validator node crashes" per the bug bounty criteria.

If an empty `ValidatorSet` configuration reaches the DKG subsystem:
- All validator nodes attempting to participate in DKG will crash simultaneously
- The crash is deterministic and will repeat on restart until the configuration is corrected
- Recovery requires manual intervention or a hardfork to restore a valid validator set
- The DKG process cannot complete, blocking randomness generation and potentially stalling the chain

The `ELAST_VALIDATOR` error code exists in `stake.move` but is never used, suggesting this edge case was considered but protective checks were not fully implemented. [8](#0-7) 

## Likelihood Explanation

**Likelihood: Low** - While the panic path is confirmed, achieving an empty validator set on-chain is unlikely under normal operation:

- The blockchain requires at least one validator to produce blocks
- Validator set management should have safeguards (though the unused `ELAST_VALIDATOR` error suggests incomplete implementation)
- This would likely only occur through:
  - A critical bug in validator set management during epoch transitions
  - A sophisticated governance attack removing all validators
  - A catastrophic operational failure

However, defensive programming principles dictate that this edge case should be handled gracefully rather than causing unexpected panics.

## Recommendation

Add explicit validation for empty validator sets at multiple defensive layers:

**Layer 1 - Epoch Manager**: Validate validator set before creating `EpochState`:
```rust
// In epoch_manager.rs, after line 160:
let validator_count = (&validator_set).into_iter().count();
ensure!(
    validator_count > 0,
    "ValidatorSet must contain at least one validator, found {}",
    validator_count
);
```

**Layer 2 - ReliableBroadcast**: Handle empty validator lists gracefully:
```rust
// In reliable-broadcast/src/lib.rs, in multicast():
if receivers.is_empty() {
    return Err(anyhow::anyhow!(
        "Cannot broadcast to empty validator set"
    ));
}
```

**Layer 3 - Move Contract**: Implement the `ELAST_VALIDATOR` check in `stake.move` to prevent on-chain removal of the last validator.

## Proof of Concept

```rust
// Rust test demonstrating the panic
#[tokio::test]
#[should_panic(expected = "Should aggregate with all responses")]
async fn test_empty_validator_set_panic() {
    use aptos_types::validator_verifier::ValidatorVerifier;
    use aptos_reliable_broadcast::ReliableBroadcast;
    
    // Create empty validator verifier
    let verifier = ValidatorVerifier::new(vec![]);
    let validators = verifier.get_ordered_account_addresses(); // Empty vec
    
    // Create ReliableBroadcast with empty validator list
    let rb = ReliableBroadcast::new(
        AccountAddress::random(),
        validators, // Empty!
        Arc::new(mock_network_sender()),
        std::iter::repeat(Duration::from_secs(1)),
        TimeService::mock(),
        Duration::from_secs(30),
        BoundedExecutor::new(8, tokio::runtime::Handle::current()),
    );
    
    // Attempt broadcast - this will panic
    rb.broadcast(mock_message(), mock_aggregation_state()).await.unwrap();
}
```

## Notes

While this is a confirmed panic with a clear code path, its real-world exploitability is limited by the prerequisite of having an empty `ValidatorSet` on-chain—a condition that would cause broader system failures before reaching this code. This represents a defensive programming gap rather than a directly exploitable attack vector by unprivileged actors. The fix should be implemented for robustness, but the likelihood of exploitation in production is low.

### Citations

**File:** dkg/src/epoch_manager.rs (L158-160)
```rust
        let validator_set: ValidatorSet = payload
            .get()
            .expect("failed to get ValidatorSet from payload");
```

**File:** dkg/src/epoch_manager.rs (L162-163)
```rust
        let epoch_state = Arc::new(EpochState::new(payload.epoch(), (&validator_set).into()));
        self.epoch_state = Some(epoch_state.clone());
```

**File:** dkg/src/epoch_manager.rs (L208-220)
```rust
            let rb = ReliableBroadcast::new(
                self.my_addr,
                epoch_state.verifier.get_ordered_account_addresses(),
                Arc::new(network_sender),
                ExponentialBackoff::from_millis(self.rb_config.backoff_policy_base_ms)
                    .factor(self.rb_config.backoff_policy_factor)
                    .max_delay(Duration::from_millis(
                        self.rb_config.backoff_policy_max_delay_ms,
                    )),
                aptos_time_service::TimeService::real(),
                Duration::from_millis(self.rb_config.rpc_timeout_ms),
                BoundedExecutor::new(8, tokio::runtime::Handle::current()),
            );
```

**File:** types/src/validator_verifier.rs (L206-214)
```rust
    pub fn new(validator_infos: Vec<ValidatorConsensusInfo>) -> Self {
        let total_voting_power = sum_voting_power(&validator_infos);
        let quorum_voting_power = if validator_infos.is_empty() {
            0
        } else {
            total_voting_power * 2 / 3 + 1
        };
        Self::build_index(validator_infos, quorum_voting_power, total_voting_power)
    }
```

**File:** dkg/src/dkg_manager/mod.rs (L427-451)
```rust
    async fn process_dkg_start_event(&mut self, event: DKGStartEvent) -> Result<()> {
        info!(
            epoch = self.epoch_state.epoch,
            my_addr = self.my_addr,
            "[DKG] Processing DKGStart event."
        );
        fail_point!("dkg::process_dkg_start_event");
        let DKGStartEvent {
            session_metadata,
            start_time_us,
        } = event;
        ensure!(
            matches!(&self.state, InnerState::NotStarted),
            "[DKG] dkg already started"
        );
        if self.epoch_state.epoch != session_metadata.dealer_epoch {
            warn!(
                "[DKG] event (from epoch {}) not for current epoch ({}), ignoring",
                session_metadata.dealer_epoch, self.epoch_state.epoch
            );
            return Ok(());
        }
        self.setup_deal_broadcast(start_time_us, &session_metadata)
            .await
    }
```

**File:** dkg/src/agg_trx_producer.rs (L64-67)
```rust
            let agg_trx = rb
                .broadcast(req, agg_state)
                .await
                .expect("broadcast cannot fail");
```

**File:** crates/reliable-broadcast/src/lib.rs (L167-204)
```rust
            loop {
                tokio::select! {
                    Some((receiver, result)) = rpc_futures.next() => {
                        let aggregating = aggregating.clone();
                        let future = executor.spawn(async move {
                            (
                                    receiver,
                                    result
                                        .and_then(|msg| {
                                            msg.try_into().map_err(|e| anyhow::anyhow!("{:?}", e))
                                        })
                                        .and_then(|ack| aggregating.add(receiver, ack)),
                            )
                        }).await;
                        aggregate_futures.push(future);
                    },
                    Some(result) = aggregate_futures.next() => {
                        let (receiver, result) = result.expect("spawned task must succeed");
                        match result {
                            Ok(may_be_aggragated) => {
                                if let Some(aggregated) = may_be_aggragated {
                                    return Ok(aggregated);
                                }
                            },
                            Err(e) => {
                                log_rpc_failure(e, receiver);

                                let backoff_strategy = backoff_policies
                                    .get_mut(&receiver)
                                    .expect("should be present");
                                let duration = backoff_strategy.next().expect("should produce value");
                                rpc_futures
                                    .push(send_message(receiver, Some(duration)));
                            },
                        }
                    },
                    else => unreachable!("Should aggregate with all responses")
                }
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L58-58)
```text
    const ELAST_VALIDATOR: u64 = 6;
```
