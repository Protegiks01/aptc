# Audit Report

## Title
Validator Node Panic from Concurrent BlockExecutor Database Lock Contention When Observer and Consensus Both Enabled

## Summary
The consensus observer creates a separate `BlockExecutor` instance using `aptos_db.clone()`, which shares the same underlying database with the validator's consensus `BlockExecutor`. If both consensus and observer are enabled on the same validator node (through manual configuration), concurrent commit operations will trigger a panic due to lock contention in AptosDB's commit functions, causing the validator node to crash.

## Finding Description
The vulnerability exists in the initialization of execution clients for both consensus and consensus observer:

**Regular Consensus BlockExecutor Creation:** [1](#0-0) 

**Consensus Observer BlockExecutor Creation:** [2](#0-1) 

The `DbReaderWriter::clone()` operation only clones Arc references, meaning both BlockExecutor instances share the same underlying AptosDB: [3](#0-2) 

When both components attempt to commit blocks concurrently, they call AptosDB's commit functions which use `try_lock().expect()`:

**Pre-commit Lock:** [4](#0-3) 

**Commit Lock:** [5](#0-4) 

If either lock is already held, `try_lock()` returns an error and `.expect()` causes the entire process to **panic**, crashing the validator node.

**Configuration Allowing Both:**
By default, validators have `observer_enabled=false`, but the system has no validation preventing manual configuration of `observer_enabled=true`: [6](#0-5) 

Both components are initialized during node startup without mutual exclusion checks: [7](#0-6) 

## Impact Explanation
This qualifies as **High Severity** per the Aptos bug bounty criteria for "API crashes" and "Validator node slowdowns." When triggered, the panic causes immediate validator termination, resulting in:
- Loss of validator liveness and participation in consensus
- Potential network disruption if multiple validators are affected
- Violation of availability invariants

However, **this vulnerability requires validator operator access to manually configure `observer_enabled=true`**, which reduces its severity from what would otherwise be a critical availability issue.

## Likelihood Explanation
**Likelihood: Low to Medium**

The vulnerability requires:
1. Validator operator access to modify node configuration
2. Manual setting of `observer_enabled=true` (contrary to defaults)
3. Concurrent block commits from both consensus paths

While not the default configuration, this could occur through:
- Accidental misconfiguration by operators
- Copy-paste errors from fullnode configurations
- Configuration management system errors
- Potential future automatic configuration changes

The lack of defensive validation means this latent bug could manifest unexpectedly.

## Recommendation
Add validation to prevent both consensus and observer from running simultaneously on the same node with the same database instance:

```rust
// In consensus/src/consensus_provider.rs or aptos-node/src/consensus.rs
pub fn validate_consensus_observer_config(
    node_config: &NodeConfig,
    has_consensus_network: bool,
) -> Result<(), Error> {
    if has_consensus_network && node_config.consensus_observer.observer_enabled {
        return Err(Error::new(
            "Cannot enable consensus_observer.observer_enabled=true on a validator node. \
             Validators must use publisher_enabled=true instead."
        ));
    }
    Ok(())
}
```

Call this validation during node startup before creating either component. Alternatively, modify AptosDB's commit functions to use regular locks with proper error handling instead of panicking.

## Proof of Concept

```rust
// Reproduction test (conceptual - would need integration test harness)
#[tokio::test]
async fn test_concurrent_consensus_and_observer_panic() {
    // Setup: Create a validator node config with both enabled
    let mut node_config = NodeConfig::default();
    node_config.consensus_observer.observer_enabled = true; // Manually enable
    node_config.consensus_observer.publisher_enabled = true;
    
    // Create shared database
    let db_rw = create_test_db();
    
    // Create both BlockExecutors sharing the same DB
    let consensus_executor = Arc::new(BlockExecutor::new(db_rw.clone()));
    let observer_executor = Arc::new(BlockExecutor::new(db_rw.clone()));
    
    // Simulate concurrent commits
    let consensus_handle = tokio::spawn(async move {
        consensus_executor.commit_ledger(/* ... */).await
    });
    
    let observer_handle = tokio::spawn(async move {
        observer_executor.commit_ledger(/* ... */).await
    });
    
    // Expected: One of these will panic with "Concurrent committing detected."
    let results = tokio::join!(consensus_handle, observer_handle);
    assert!(results.0.is_err() || results.1.is_err()); // At least one panicked
}
```

## Notes
While this is a legitimate code-level vulnerability representing a defensive programming failure, it does **not meet the strict exploitability criterion** of "unprivileged attacker with no validator insider access required" from the validation checklist. Validator operators are listed as trusted roles, and triggering this requires manual configuration changes accessible only to the operator.

The root issue is the absence of configuration validation - a properly defensive system should detect and prevent this invalid configuration at startup rather than allowing it to cause runtime panics.

### Citations

**File:** consensus/src/consensus_provider.rs (L65-66)
```rust
    let execution_proxy = ExecutionProxy::new(
        Arc::new(BlockExecutor::<AptosVMBlockExecutor>::new(aptos_db)),
```

**File:** consensus/src/consensus_provider.rs (L158-159)
```rust
        let execution_proxy = ExecutionProxy::new(
            Arc::new(BlockExecutor::<AptosVMBlockExecutor>::new(aptos_db.clone())),
```

**File:** storage/storage-interface/src/lib.rs (L657-661)
```rust
#[derive(Clone)]
pub struct DbReaderWriter {
    pub reader: Arc<dyn DbReader>,
    pub writer: Arc<dyn DbWriter>,
}
```

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L50-53)
```rust
            let _lock = self
                .pre_commit_lock
                .try_lock()
                .expect("Concurrent committing detected.");
```

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L89-92)
```rust
            let _lock = self
                .commit_lock
                .try_lock()
                .expect("Concurrent committing detected.");
```

**File:** config/src/config/consensus_observer_config.rs (L112-118)
```rust
            NodeType::Validator => {
                if ENABLE_ON_VALIDATORS && !publisher_manually_set {
                    // Only enable the publisher for validators
                    consensus_observer_config.publisher_enabled = true;
                    modified_config = true;
                }
            },
```

**File:** aptos-node/src/lib.rs (L829-851)
```rust
    // Create the consensus observer and publisher (if enabled)
    let (consensus_observer_runtime, consensus_publisher_runtime, consensus_publisher) =
        consensus::create_consensus_observer_and_publisher(
            &node_config,
            consensus_observer_network_interfaces,
            consensus_notifier.clone(),
            consensus_to_mempool_sender.clone(),
            db_rw.clone(),
            consensus_observer_reconfig_subscription,
        );

    // Create the consensus runtime (if enabled)
    let consensus_runtime = consensus::create_consensus_runtime(
        &node_config,
        db_rw.clone(),
        consensus_reconfig_subscription,
        consensus_network_interfaces,
        consensus_notifier.clone(),
        consensus_to_mempool_sender.clone(),
        vtxn_pool,
        consensus_publisher.clone(),
        &mut admin_service,
    );
```
