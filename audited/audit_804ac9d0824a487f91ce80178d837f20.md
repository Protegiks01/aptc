# Audit Report

## Title
Empty Validator Set Vulnerability via Minimum Stake Filtering in Epoch Transition

## Summary
The `on_new_epoch()` function in the staking module can result in an empty validator set if all validators' voting power drops below the minimum stake threshold, causing total network halt. Additionally, if `total_voting_power` reaches zero, the voting power increase limit is bypassed, allowing unlimited validators to join in a single epoch.

## Finding Description

The epoch change mechanism's `verify()` function [1](#0-0)  does not enforce Sybil resistance directlyâ€”it only validates cryptographic signatures and epoch chain integrity. Sybil resistance is delegated to the staking layer.

However, a critical flaw exists in the validator set management during epoch transitions. In `on_new_epoch()` [2](#0-1) , validators are filtered based on minimum stake requirements, but there is **no check ensuring at least one validator remains active**.

The filtering logic [3](#0-2)  removes validators with `voting_power < minimum_stake`, but if ALL validators fall below this threshold, the `next_epoch_validators` vector remains empty and `total_voting_power` becomes 0.

Critically, the voting power increase limit enforcement [4](#0-3)  contains a conditional bypass at line 1864: when `total_voting_power == 0`, the limit check is entirely skipped, allowing unlimited voting power to join in a single epoch.

While explicit validator leaving is protected by `ELAST_VALIDATOR` check [5](#0-4) , the automatic filtering in `on_new_epoch()` has no equivalent protection.

The formal specifications [6](#0-5)  require `on_new_epoch` to not abort, but do not require a non-empty validator set. The validator set validity check [7](#0-6)  verifies initialization and indices but not set size.

## Impact Explanation

**Critical Severity** - This vulnerability can cause:

1. **Total Loss of Liveness**: With zero validators, the network cannot produce blocks or reach consensus, requiring emergency intervention or hard fork to recover.

2. **Consensus Safety Violation**: If the network somehow continues operating, the voting power increase limit bypass allows an attacker to immediately join with unlimited voting power, potentially exceeding 1/3 or 2/3 thresholds needed to compromise BFT safety guarantees.

This meets the Critical severity criteria: "Total loss of liveness/network availability" and "Consensus/Safety violations."

## Likelihood Explanation

**Medium to Low Likelihood** - Requires specific conditions:

- All validators' stake must simultaneously drop below `minimum_stake` through coordinated unlocking, governance-increased minimum stake threshold, or exploitation of other stake calculation bugs
- More likely in testnets or early network stages with few validators
- Natural economic incentives discourage validators from reducing stake below minimum
- However, configuration errors or governance attacks could trigger this state

The vulnerability exists in production code and has severe consequences, but requires unusual circumstances to trigger.

## Recommendation

Add a check in `on_new_epoch()` to ensure at least one validator remains active after filtering:

```move
// After line 1399, before line 1401:
assert!(
    vector::length(&next_epoch_validators) > 0,
    error::invalid_state(ELAST_VALIDATOR)
);
```

Additionally, consider removing the bypass in `update_voting_power_increase()` or adding explicit genesis handling:

```move
// Replace lines 1864-1869 with:
if (validator_set.total_voting_power > 0) {
    assert!(
        validator_set.total_joining_power <= validator_set.total_voting_power * voting_power_increase_limit / 100,
        error::invalid_argument(EVOTING_POWER_INCREASE_EXCEEDS_LIMIT),
    );
} else {
    // Only allow during genesis/recovery with governance approval
    assert!(chain_status::is_genesis(), error::invalid_state(EZERO_VALIDATORS));
}
```

## Proof of Concept

```move
#[test(aptos_framework = @aptos_framework)]
#[expected_failure(abort_code = 0x10006, location = aptos_framework::stake)]
public entry fun test_empty_validator_set_scenario(
    aptos_framework: &signer,
) {
    // Setup: Initialize network with validators at exactly minimum stake
    initialize_for_test(aptos_framework);
    
    // Create validator with minimum stake
    let (sk, pk, pop) = generate_identity();
    initialize_test_validator(&pk, &pop, validator1, minimum_stake, true, true);
    
    // Governance increases minimum_stake threshold
    staking_config::update_required_stake(
        aptos_framework,
        minimum_stake * 2,  // Double the requirement
        maximum_stake
    );
    
    // Trigger epoch transition
    // Expected: on_new_epoch filters out all validators
    // Result: empty validator set, total_voting_power = 0
    // Network halts or voting power limit bypassed
    end_epoch();
    
    // Verify validator set is empty
    let validator_set = borrow_global<ValidatorSet>(@aptos_framework);
    assert!(vector::length(&validator_set.active_validators) == 0, 1);
    assert!(validator_set.total_voting_power == 0, 2);
}
```

### Citations

**File:** types/src/epoch_change.rs (L66-118)
```rust
    pub fn verify(&self, verifier: &dyn Verifier) -> Result<&LedgerInfoWithSignatures> {
        ensure!(
            !self.ledger_info_with_sigs.is_empty(),
            "The EpochChangeProof is empty"
        );
        ensure!(
            !verifier
                .is_ledger_info_stale(self.ledger_info_with_sigs.last().unwrap().ledger_info()),
            "The EpochChangeProof is stale as our verifier is already ahead \
             of the entire EpochChangeProof"
        );
        let mut verifier_ref = verifier;

        for ledger_info_with_sigs in self
            .ledger_info_with_sigs
            .iter()
            // Skip any stale ledger infos in the proof prefix. Note that with
            // the assertion above, we are guaranteed there is at least one
            // non-stale ledger info in the proof.
            //
            // It's useful to skip these stale ledger infos to better allow for
            // concurrent client requests.
            //
            // For example, suppose the following:
            //
            // 1. My current trusted state is at epoch 5.
            // 2. I make two concurrent requests to two validators A and B, who
            //    live at epochs 9 and 11 respectively.
            //
            // If A's response returns first, I will ratchet my trusted state
            // to epoch 9. When B's response returns, I will still be able to
            // ratchet forward to 11 even though B's EpochChangeProof
            // includes a bunch of stale ledger infos (for epochs 5, 6, 7, 8).
            //
            // Of course, if B's response returns first, we will reject A's
            // response as it's completely stale.
            .skip_while(|&ledger_info_with_sigs| {
                verifier.is_ledger_info_stale(ledger_info_with_sigs.ledger_info())
            })
        {
            // Try to verify each (epoch -> epoch + 1) jump in the EpochChangeProof.
            verifier_ref.verify(ledger_info_with_sigs)?;
            // While the original verification could've been via waypoints,
            // all the next epoch changes are verified using the (already
            // trusted) validator sets.
            verifier_ref = ledger_info_with_sigs
                .ledger_info()
                .next_epoch_state()
                .ok_or_else(|| format_err!("LedgerInfo doesn't carry a ValidatorSet"))?;
        }

        Ok(self.ledger_info_with_sigs.last().unwrap())
    }
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1255-1255)
```text
            assert!(vector::length(&validator_set.active_validators) > 0, error::invalid_state(ELAST_VALIDATOR));
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1372-1403)
```text
        let next_epoch_validators = vector::empty();
        let (minimum_stake, _) = staking_config::get_required_stake(&config);
        let vlen = vector::length(&validator_set.active_validators);
        let total_voting_power = 0;
        let i = 0;
        while ({
            spec {
                invariant spec_validators_are_initialized(next_epoch_validators);
                invariant i <= vlen;
            };
            i < vlen
        }) {
            let old_validator_info = vector::borrow_mut(&mut validator_set.active_validators, i);
            let pool_address = old_validator_info.addr;
            let validator_config = borrow_global<ValidatorConfig>(pool_address);
            let stake_pool = borrow_global<StakePool>(pool_address);
            let new_validator_info = generate_validator_info(pool_address, stake_pool, *validator_config);

            // A validator needs at least the min stake required to join the validator set.
            if (new_validator_info.voting_power >= minimum_stake) {
                spec {
                    assume total_voting_power + new_validator_info.voting_power <= MAX_U128;
                };
                total_voting_power = total_voting_power + (new_validator_info.voting_power as u128);
                vector::push_back(&mut next_epoch_validators, new_validator_info);
            };
            i = i + 1;
        };

        validator_set.active_validators = next_epoch_validators;
        validator_set.total_voting_power = total_voting_power;
        validator_set.total_joining_power = 0;
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1857-1870)
```text
    fun update_voting_power_increase(increase_amount: u64) acquires ValidatorSet {
        let validator_set = borrow_global_mut<ValidatorSet>(@aptos_framework);
        let voting_power_increase_limit =
            (staking_config::get_voting_power_increase_limit(&staking_config::get()) as u128);
        validator_set.total_joining_power = validator_set.total_joining_power + (increase_amount as u128);

        // Only validator voting power increase if the current validator set's voting power > 0.
        if (validator_set.total_voting_power > 0) {
            assert!(
                validator_set.total_joining_power <= validator_set.total_voting_power * voting_power_increase_limit / 100,
                error::invalid_argument(EVOTING_POWER_INCREASE_EXCEEDS_LIMIT),
            );
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/stake.spec.move (L29-37)
```text
    /// No.: 4
    /// Requirement: During each epoch, the following operations should be consistently performed without aborting: rewards
    /// distribution, validator activation/deactivation, updates to validator sets and voting power, and renewal of
    /// lockups.
    /// Criticality: Low
    /// Implementation: The on_new_epoch function is triggered at each epoch boundary to perform distribution of the
    /// transaction fee, updates to active/inactive stakes, updates to pending active/inactive validators and adjusts
    /// voting power of the validators without aborting.
    /// Enforcement: Formally verified via [high-level-req-4](on_new_epoch). This also requires a manual review to verify the state updates of the stake pool.
```

**File:** aptos-move/framework/aptos-framework/sources/stake.spec.move (L108-115)
```text
    spec fun validator_set_is_valid_impl(validator_set: ValidatorSet): bool {
        spec_validators_are_initialized(validator_set.active_validators) &&
            spec_validators_are_initialized(validator_set.pending_inactive) &&
            spec_validators_are_initialized(validator_set.pending_active) &&
            spec_validator_indices_are_valid(validator_set.active_validators) &&
            spec_validator_indices_are_valid(validator_set.pending_inactive)
            && spec_validator_indices_active_pending_inactive(validator_set)
    }
```
