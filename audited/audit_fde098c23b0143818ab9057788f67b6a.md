# Audit Report

## Title
State Transition Vulnerability: Stale JWKs Persist When OIDC Provider Re-Added With Different Config URL

## Summary
The JWK consensus module contains a state transition vulnerability where removing an OIDC provider with `keep_observed_jwks=true` and re-adding it with a different `config_url` creates a persistent state inconsistency. Old JWKs remain in `ObservedJWKs` indefinitely if the new config URL is unreachable, allowing potentially compromised or rotated keys to remain valid.

## Finding Description

The vulnerability exists in the state transition logic between `SupportedOIDCProviders` and `ObservedJWKs` resources. The attack sequence exploits the `keep_observed_jwks` flag behavior:

**Step 1: Initial Provider Setup**
A governance proposal calls `upsert_oidc_provider_for_next_epoch()` to add a provider with config_url_A. [1](#0-0) 

Validators spawn JWK observers that fetch JWKs from config_url_A and store them in `ObservedJWKs`. [2](#0-1) 

**Step 2: Remove Provider With Preserved JWKs**
The Rust code generates a removal operation that calls `remove_oidc_provider_for_next_epoch()` but does NOT call `remove_issuer_from_observed_jwks()` when `keep_observed_jwks=true`. [3](#0-2) 

This removes the provider from `SupportedOIDCProviders` while leaving JWKs in `ObservedJWKs`. [4](#0-3) 

**Step 3: Re-Add Provider With Different Config URL**
The provider is upserted again with config_url_B. [1](#0-0) 

At epoch transition, validators initialize their state with existing `ObservedJWKs` (containing old JWKs from config_url_A). [5](#0-4) 

Validators spawn observers for config_url_B. [2](#0-1) 

**Step 4: Observer Fetch Failures Persist Stale State**
When JWK observers fail to fetch from config_url_B (unreachable, errors, malformed responses), they record metrics but do NOT push any observation. [6](#0-5) 

The consensus manager only triggers updates when observed JWKs differ from on-chain JWKs. [7](#0-6) 

Without successful fetches from config_url_B, old JWKs from config_url_A remain in `ObservedJWKs` indefinitely, despite `SupportedOIDCProviders` indicating config_url_B as the source.

**Security Guarantees Broken:**
1. **State Consistency Invariant**: `SupportedOIDCProviders.config_url` no longer matches the source of JWKs in `ObservedJWKs`
2. **JWK Rotation Integrity**: Rotated/revoked keys remain usable through stale JWKs
3. **Configuration Accuracy**: Applications expect JWKs from config_url_B but receive JWKs from config_url_A via `PatchedJWKs`

## Impact Explanation

This qualifies as **High Severity** per Aptos bug bounty criteria for "Significant protocol violations":

1. **Protocol Integrity Violation**: Creates persistent mismatch between provider configuration and actual JWK data, violating the fundamental assumption that `ObservedJWKs` reflects the current `SupportedOIDCProviders` state

2. **Stale Key Persistence**: Allows keys that should have been rotated out (due to compromise, expiration, or policy changes) to remain valid indefinitely

3. **Validator Resource Waste**: Validators continuously retry fetching from unreachable config_url_B while serving stale JWKs, causing operational inefficiency

4. **Authentication Bypass Potential**: Applications relying on JWK rotation for security (e.g., revoking compromised keys) are bypassed when stale JWKs persist

The vulnerability does not directly cause fund loss or consensus safety violations, but creates significant state inconsistencies requiring manual intervention to resolve.

## Likelihood Explanation

**Likelihood: Medium-High**

**Attacker Requirements:**
- Governance participation rights (obtainable by acquiring tokens)
- Ability to propose and pass governance proposals (requires voting power or convincing legitimate voters)
- Control over a domain/URL to set as malicious config_url, or ability to propose legitimate-looking but unreachable URLs

**Attack Complexity:**
The attack is straightforward to execute once governance access is obtained:
1. Single governance proposal for initial provider upsert
2. Single governance proposal for removal with `keep_observed_jwks=true`
3. Single governance proposal for re-upsert with unreachable config_url

**Realistic Scenarios:**
1. **Malicious Governance Participant**: Actor with sufficient voting power exploits this for persistence of compromised keys
2. **Accidental Misconfiguration**: Legitimate governance action updates provider URL, but new URL is misconfigured/unreachable, causing unintended stale JWK persistence
3. **Targeted Attack on Provider**: Attacker compromises provider keys, governance rotates provider URL to new domain, but attacker causes new URL to be unreachable, preserving compromised keys

## Recommendation

**Immediate Fix:**
Modify `remove_oidc_provider_for_next_epoch()` to enforce atomic cleanup of associated `ObservedJWKs` when removing a provider, regardless of `keep_observed_jwks` flag. Alternatively, implement validation in `upsert_oidc_provider_for_next_epoch()` to detect and clear stale `ObservedJWKs` when config_url changes.

**Recommended Code Changes:**

In `aptos-move/framework/aptos-framework/sources/jwks.move`, modify `upsert_oidc_provider_for_next_epoch()`:

```move
public fun upsert_oidc_provider_for_next_epoch(fx: &signer, name: vector<u8>, config_url: vector<u8>): Option<vector<u8>> acquires SupportedOIDCProviders, ObservedJWKs {
    system_addresses::assert_aptos_framework(fx);

    let provider_set = if (config_buffer::does_exist<SupportedOIDCProviders>()) {
        config_buffer::extract_v2<SupportedOIDCProviders>()
    } else {
        *borrow_global<SupportedOIDCProviders>(@aptos_framework)
    };

    let old_config_url = remove_oidc_provider_internal(&mut provider_set, name);
    
    // NEW: If config_url changed, clear observed JWKs to prevent stale state
    if (option::is_some(&old_config_url)) {
        let prev_url = option::borrow(&old_config_url);
        if (prev_url != &config_url) {
            let observed_jwks = borrow_global_mut<ObservedJWKs>(@aptos_framework);
            remove_issuer(&mut observed_jwks.jwks, name);
        }
    };
    
    vector::push_back(&mut provider_set.providers, OIDCProvider { name, config_url });
    config_buffer::upsert(provider_set);
    old_config_url
}
```

**Long-term Solution:**
Implement versioning or checksums linking `SupportedOIDCProviders` entries to their corresponding `ObservedJWKs` entries to detect and prevent state drift.

## Proof of Concept

```move
#[test(framework = @aptos_framework)]
fun test_stale_jwks_on_provider_re_add(framework: &signer) acquires SupportedOIDCProviders, ObservedJWKs, PatchedJWKs, Patches {
    // Setup
    initialize_for_test(framework);
    features::change_feature_flags_for_testing(framework, vector[], vector[features::get_jwk_consensus_per_key_mode_feature()]);
    
    // Step 1: Add provider with config_url_A
    upsert_oidc_provider_for_next_epoch(framework, b"victim.com", b"https://victim.com/config_A");
    
    // Simulate validators observing JWKs from config_A
    let jwk_from_config_a = new_rsa_jwk(
        utf8(b"key_id_123"),
        utf8(b"RS256"),
        utf8(b"AQAB"),
        utf8(b"original_key_data")
    );
    upsert_into_observed_jwks(framework, vector[
        ProviderJWKs {
            issuer: b"victim.com",
            version: 1,
            jwks: vector[jwk_from_config_a],
        }
    ]);
    
    // Step 2: Remove provider with keep_observed_jwks=true
    remove_oidc_provider_for_next_epoch(framework, b"victim.com");
    // Observed JWKs NOT removed (simulating keep_observed_jwks=true)
    
    // Step 3: Re-add provider with different config_url_B
    upsert_oidc_provider_for_next_epoch(framework, b"victim.com", b"https://attacker.com/unreachable");
    
    // Step 4: Verify stale JWKs persist
    // Without successful fetch from config_url_B, old JWKs remain
    let jwk_retrieved = get_patched_jwk(b"victim.com", b"key_id_123");
    assert!(jwk_retrieved == jwk_from_config_a, 1); // OLD JWK still valid!
    
    // Verify provider config shows new URL
    let provider_set = borrow_global<SupportedOIDCProviders>(@aptos_framework);
    let (found, idx) = vector::find(&provider_set.providers, |p| {
        let provider: &OIDCProvider = p;
        provider.name == b"victim.com"
    });
    assert!(found, 2);
    let provider = vector::borrow(&provider_set.providers, idx);
    assert!(provider.config_url == b"https://attacker.com/unreachable", 3);
    
    // STATE INCONSISTENCY: Config URL points to config_B, but JWKs are from config_A
}
```

## Notes

This vulnerability represents a fundamental flaw in the state transition logic between `SupportedOIDCProviders` and `ObservedJWKs`. The `keep_observed_jwks` flag was likely designed for gradual migration scenarios, but the implementation fails to handle provider re-addition with changed config URLs. The persistence mechanism in JWK observers (silent failure on fetch errors) amplifies this issue by never updating stale state when new config URLs are unreachable.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/jwks.move (L317-330)
```text
    public fun upsert_oidc_provider_for_next_epoch(fx: &signer, name: vector<u8>, config_url: vector<u8>): Option<vector<u8>> acquires SupportedOIDCProviders {
        system_addresses::assert_aptos_framework(fx);

        let provider_set = if (config_buffer::does_exist<SupportedOIDCProviders>()) {
            config_buffer::extract_v2<SupportedOIDCProviders>()
        } else {
            *borrow_global<SupportedOIDCProviders>(@aptos_framework)
        };

        let old_config_url = remove_oidc_provider_internal(&mut provider_set, name);
        vector::push_back(&mut provider_set.providers, OIDCProvider { name, config_url });
        config_buffer::upsert(provider_set);
        old_config_url
    }
```

**File:** aptos-move/framework/aptos-framework/sources/jwks.move (L352-363)
```text
    public fun remove_oidc_provider_for_next_epoch(fx: &signer, name: vector<u8>): Option<vector<u8>> acquires SupportedOIDCProviders {
        system_addresses::assert_aptos_framework(fx);

        let provider_set = if (config_buffer::does_exist<SupportedOIDCProviders>()) {
            config_buffer::extract_v2<SupportedOIDCProviders>()
        } else {
            *borrow_global<SupportedOIDCProviders>(@aptos_framework)
        };
        let ret = remove_oidc_provider_internal(&mut provider_set, name);
        config_buffer::upsert(provider_set);
        ret
    }
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager/mod.rs (L108-134)
```rust
        this.jwk_observers = oidc_providers
            .unwrap_or_default()
            .into_provider_vec()
            .into_iter()
            .filter_map(|provider| {
                let OIDCProvider { name, config_url } = provider;
                let maybe_issuer = String::from_utf8(name);
                let maybe_config_url = String::from_utf8(config_url);
                match (maybe_issuer, maybe_config_url) {
                    (Ok(issuer), Ok(config_url)) => Some(JWKObserver::spawn(
                        this.epoch_state.epoch,
                        this.my_addr,
                        issuer,
                        config_url,
                        Duration::from_secs(10),
                        local_observation_tx.clone(),
                    )),
                    (maybe_issuer, maybe_config_url) => {
                        warn!(
                            "unable to spawn observer, issuer={:?}, config_url={:?}",
                            maybe_issuer, maybe_config_url
                        );
                        None
                    },
                }
            })
            .collect();
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager/mod.rs (L194-196)
```rust
        let state = self.states_by_issuer.entry(issuer.clone()).or_default();
        state.observed = Some(jwks.clone());
        if state.observed.as_ref() != state.on_chain.as_ref().map(ProviderJWKs::jwks) {
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager/mod.rs (L231-292)
```rust
    pub fn reset_with_on_chain_state(&mut self, on_chain_state: AllProvidersJWKs) -> Result<()> {
        info!(
            epoch = self.epoch_state.epoch,
            "reset_with_on_chain_state starting."
        );
        let onchain_issuer_set: HashSet<Issuer> = on_chain_state
            .entries
            .iter()
            .map(|entry| entry.issuer.clone())
            .collect();
        let local_issuer_set: HashSet<Issuer> = self.states_by_issuer.keys().cloned().collect();

        for issuer in local_issuer_set.difference(&onchain_issuer_set) {
            info!(
                epoch = self.epoch_state.epoch,
                op = "delete",
                issuer = issuer.clone(),
                "reset_with_on_chain_state"
            );
        }

        self.states_by_issuer
            .retain(|issuer, _| onchain_issuer_set.contains(issuer));
        for on_chain_provider_jwks in on_chain_state.entries {
            let issuer = on_chain_provider_jwks.issuer.clone();
            let locally_cached = self
                .states_by_issuer
                .get(&on_chain_provider_jwks.issuer)
                .and_then(|s| s.on_chain.as_ref());
            if locally_cached == Some(&on_chain_provider_jwks) {
                // The on-chain update did not touch this provider.
                // The corresponding local state does not have to be reset.
                info!(
                    epoch = self.epoch_state.epoch,
                    op = "no-op",
                    issuer = issuer,
                    "reset_with_on_chain_state"
                );
            } else {
                let old_value = self.states_by_issuer.insert(
                    on_chain_provider_jwks.issuer.clone(),
                    PerProviderState::new(on_chain_provider_jwks),
                );
                let op = if old_value.is_some() {
                    "update"
                } else {
                    "insert"
                };
                info!(
                    epoch = self.epoch_state.epoch,
                    op = op,
                    issuer = issuer,
                    "reset_with_on_chain_state"
                );
            }
        }
        info!(
            epoch = self.epoch_state.epoch,
            "reset_with_on_chain_state finished."
        );
        Ok(())
    }
```

**File:** aptos-move/aptos-release-builder/src/components/oidc_providers.rs (L61-79)
```rust
        OidcProviderOp::Remove {
            issuer,
            keep_observed_jwks,
        } => {
            emitln!(
                writer,
                "jwks::remove_oidc_provider_for_next_epoch({}, b\"{}\");",
                signer_arg,
                issuer
            );
            if !keep_observed_jwks {
                emitln!(
                    writer,
                    "jwks::remove_issuer_from_observed_jwks({}, b\"{}\");",
                    signer_arg,
                    issuer
                );
            }
        },
```

**File:** crates/aptos-jwk-consensus/src/jwk_observer.rs (L77-83)
```rust
                    if let Ok(mut jwks) = result {
                        OBSERVATION_SECONDS.with_label_values(&[issuer.as_str(), "ok"]).observe(secs);
                        jwks.sort();
                        let _ = observation_tx.push((), (issuer.as_bytes().to_vec(), jwks));
                    } else {
                        OBSERVATION_SECONDS.with_label_values(&[issuer.as_str(), "err"]).observe(secs);
                    }
```
