# Audit Report

## Title
Epoch History Validation Bypass in Oneoff Transaction Restore Allows Database Corruption by Privileged Operators

## Summary
The `db-tool restore oneoff transaction` command hardcodes `epoch_history = None` and `VerifyExecutionMode::NoVerify`, creating a dual bypass that allows restoration of transactions from invalid epochs without cryptographic validation of validator signatures or execution verification. However, this is an operator-level administrative tool vulnerability, not exploitable by unprivileged attackers.

## Finding Description

The `Command::run()` function in the `Oneoff::Transaction` branch passes two critical security bypasses: [1](#0-0) 

**Bypass #1: Epoch History Validation Skipped**

When `epoch_history` is `None`, the critical validator signature verification is bypassed: [2](#0-1) 

The `EpochHistory::verify_ledger_info()` method performs the essential security check that ledger infos are cryptographically signed by legitimate validators from the previous epoch: [3](#0-2) 

**Bypass #2: Execution Verification Skipped**

When `VerifyExecutionMode::NoVerify` is used, transaction re-execution is skipped: [4](#0-3) 

The `should_verify()` method returns `false` for `NoVerify`: [5](#0-4) 

**Combined Impact:**

An attacker with operator access could:
1. Create a malicious backup with fake ledger infos (unsigned by real validators)
2. Create fake transactions with arbitrary state changes
3. Use `db-tool restore oneoff transaction` to populate a database
4. The database would contain invalid state never committed by the real Aptos network

In contrast, the proper `RestoreCoordinator` path creates and validates epoch history: [6](#0-5) 

## Impact Explanation

**This does NOT meet Critical/High/Medium severity criteria** because:

1. **Requires privileged operator access**: The vulnerability requires filesystem access to run the `db-tool` command, which is an administrative tool restricted to node operators.

2. **Outside threat model**: According to the trust model, "validator operators" are trusted roles. The attack requires either:
   - Malicious insider (operator with admin access)
   - Compromised operator credentials
   - Social engineering to trick operator into running malicious restore

3. **Excluded attack vectors**: The bug bounty rules explicitly exclude "Social engineering, phishing, or key theft" from scope.

While this violates the **Consensus Safety** and **State Consistency** invariants, it only affects nodes where an operator has been compromised or deceived, not the broader network.

## Likelihood Explanation

**Likelihood: Low**

The attack requires:
- Admin/filesystem access to the target node
- Ability to run the `db-tool` command
- Control over the backup source parameter
- Successfully deceiving or compromising a node operator
- The victim node operator choosing the `oneoff transaction` command instead of the proper `BootstrapDB` coordinator

This is not exploitable by external attackers, unprivileged users, or through network protocols.

## Recommendation

**1. Add Epoch History Requirement (Breaking Change):**
Remove the ability to restore without epoch history validation. Require operators to provide epoch ending backups:

```rust
Transaction {
    storage,
    opt,
    global,
} => {
    // Require epoch history for security
    ensure!(
        !global.trusted_waypoints.is_empty(),
        "Transaction restore requires trusted waypoints for epoch verification"
    );
    
    let epoch_handles = /* load from metadata */;
    let epoch_history = Some(Arc::new(
        EpochHistoryRestoreController::new(
            epoch_handles,
            global.clone(),
            storage.clone(),
        )
        .run()
        .await?
    ));
    
    TransactionRestoreController::new(
        opt,
        global.try_into()?,
        storage.init_storage().await?,
        epoch_history,  // Now required
        VerifyExecutionMode::NoVerify,  // Can keep for performance
    )
    .run()
    .await?;
}
```

**2. Add Security Warning (Minimal Change):**
If maintaining backward compatibility for debugging, add prominent warnings:

```rust
Transaction { ... } => {
    warn!("⚠️  SECURITY WARNING: Oneoff transaction restore bypasses epoch validation!");
    warn!("⚠️  Only use this for testing/debugging with trusted backup sources!");
    warn!("⚠️  For production restores, use 'bootstrap-db' command instead.");
    
    // existing code...
}
```

**3. Require Explicit Unsafe Flag:**
Force operators to acknowledge the security implications:

```rust
#[derive(Parser)]
pub struct TransactionRestoreOpt {
    // existing fields...
    
    #[clap(long, help = "UNSAFE: Skip epoch validation (testing only)")]
    pub skip_epoch_validation: bool,
}
```

## Proof of Concept

This vulnerability cannot be demonstrated with a traditional PoC because it requires:
1. Operator-level filesystem access
2. Ability to run administrative `db-tool` commands
3. A malicious backup source under attacker control

**Conceptual Attack Steps:**

```bash
# Attacker creates malicious backup with fake ledger info and transactions
# (Requires understanding of Aptos backup format and cryptographic structures)

# Attacker tricks operator into running (via social engineering):
aptos-db-tool restore oneoff transaction \
  --transaction-manifest malicious_backup/manifest.json \
  --local-fs-dir malicious_backup/ \
  --target-db-dir /var/aptos/db

# Result: Database populated with unverified, potentially malicious state
# Node starting with this DB would have corrupted state
```

**Verification that proper path has protection:**

```bash
# Proper restore command uses RestoreCoordinator which creates epoch_history:
aptos-db-tool restore bootstrap-db \
  --metadata-cache-dir backup_metadata/ \
  --local-fs-dir backup/ \
  --target-db-dir /var/aptos/db
  
# This path DOES validate epoch history (line 219-231 of restore.rs)
```

---

**Final Assessment:** While the dual bypass exists and represents poor security hygiene, this is **NOT a valid Critical/High/Medium severity vulnerability** under the Aptos bug bounty program because it requires operator-level privileged access, which is explicitly in the trusted role category. The issue is better classified as a security hardening opportunity rather than an exploitable vulnerability.

### Citations

**File:** storage/db-tool/src/restore.rs (L97-111)
```rust
                    Oneoff::Transaction {
                        storage,
                        opt,
                        global,
                    } => {
                        TransactionRestoreController::new(
                            opt,
                            global.try_into()?,
                            storage.init_storage().await?,
                            None, /* epoch_history */
                            VerifyExecutionMode::NoVerify,
                        )
                        .run()
                        .await?;
                    },
```

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L152-154)
```rust
        if let Some(epoch_history) = epoch_history {
            epoch_history.verify_ledger_info(&ledger_info)?;
        }
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L276-312)
```rust
    pub fn verify_ledger_info(&self, li_with_sigs: &LedgerInfoWithSignatures) -> Result<()> {
        let epoch = li_with_sigs.ledger_info().epoch();
        ensure!(!self.epoch_endings.is_empty(), "Empty epoch history.",);
        if epoch > self.epoch_endings.len() as u64 {
            // TODO(aldenhu): fix this from upper level
            warn!(
                epoch = epoch,
                epoch_history_until = self.epoch_endings.len(),
                "Epoch is too new and can't be verified. Previous chunks are verified and node \
                won't be able to start if this data is malicious."
            );
            return Ok(());
        }
        if epoch == 0 {
            ensure!(
                li_with_sigs.ledger_info() == &self.epoch_endings[0],
                "Genesis epoch LedgerInfo info doesn't match.",
            );
        } else if let Some(wp_trusted) = self
            .trusted_waypoints
            .get(&li_with_sigs.ledger_info().version())
        {
            let wp_li = Waypoint::new_any(li_with_sigs.ledger_info());
            ensure!(
                *wp_trusted == wp_li,
                "Waypoints don't match. In backup: {}, trusted: {}",
                wp_li,
                wp_trusted,
            );
        } else {
            self.epoch_endings[epoch as usize - 1]
                .next_epoch_state()
                .ok_or_else(|| anyhow!("Shouldn't contain non- epoch bumping LIs."))?
                .verify(li_with_sigs)?;
        };
        Ok(())
    }
```

**File:** execution/executor/src/chunk_executor/mod.rs (L562-575)
```rust
            let next_begin = if verify_execution_mode.should_verify() {
                self.verify_execution(
                    transactions,
                    persisted_aux_info,
                    transaction_infos,
                    write_sets,
                    event_vecs,
                    batch_begin,
                    batch_end,
                    verify_execution_mode,
                )?
            } else {
                batch_end
            };
```

**File:** execution/executor-types/src/lib.rs (L240-242)
```rust
    pub fn should_verify(&self) -> bool {
        !matches!(self, Self::NoVerify)
    }
```

**File:** storage/backup/backup-cli/src/coordinators/restore.rs (L219-231)
```rust
        let epoch_history = if !self.skip_epoch_endings {
            Some(Arc::new(
                EpochHistoryRestoreController::new(
                    epoch_handles,
                    self.global_opt.clone(),
                    self.storage.clone(),
                )
                .run()
                .await?,
            ))
        } else {
            None
        };
```
