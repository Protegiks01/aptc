# Audit Report

## Title
Missing Minimum Validator Count Enforcement During Epoch Transitions Enables Network Halt Attack

## Summary
The epoch transition logic in `stake.move` filters validators based on minimum stake requirements but fails to enforce that at least one validator remains after filtering. Combined with the lack of validation in `epoch_change.rs`, this allows the network to transition to an epoch with zero validators, causing permanent network halt requiring a hardfork to recover.

## Finding Description

The Aptos blockchain performs validator set updates during epoch transitions. The vulnerability exists across multiple layers:

**Layer 1 - Move Framework (stake.move):**
During epoch transitions, the `on_new_epoch()` function filters validators based on minimum stake requirements. [1](#0-0) 

The code iterates through all active validators and only includes those meeting the minimum stake threshold in `next_epoch_validators`. However, it never validates that this vector is non-empty before setting it as the new active validator set.

**Comparison with existing protection:**
The codebase DOES protect against voluntary removal of the last validator in `leave_validator_set_internal()`: [2](#0-1) 

This check uses the `ELAST_VALIDATOR` error code defined at: [3](#0-2) 

However, this protection is **absent** from the automatic filtering in `on_new_epoch()`, creating an asymmetric vulnerability.

**Layer 2 - Rust Epoch Change Verification:**
The `verify()` function in `epoch_change.rs` extracts the next epoch state without validating validator count: [4](#0-3) 

**Layer 3 - ValidatorVerifier Construction:**
The `ValidatorVerifier::new()` constructor explicitly allows empty validator sets: [5](#0-4) 

When the validator set is empty, it sets `quorum_voting_power` to 0, creating a degenerate state.

**Layer 4 - EpochState Creation:**
The system provides an `empty()` constructor that creates epochs with zero validators: [6](#0-5) 

**Attack Path:**
1. Attacker manipulates the staking system so all validators fall below `minimum_stake` (via governance attack to raise minimum_stake, or through coordinated stake withdrawals/slashing)
2. During the next epoch transition, `on_new_epoch()` filters out all validators
3. The empty `next_epoch_validators` vector becomes the new `active_validators`
4. This empty ValidatorSet is converted to an EpochState with zero validators
5. The epoch change proof is verified without checking validator count
6. The network transitions to an epoch where no validator can propose blocks
7. Network enters permanent halt - no blocks can be produced, no transactions can be processed

## Impact Explanation

This vulnerability meets **CRITICAL severity** criteria per the Aptos bug bounty program:

- **Total loss of liveness/network availability**: With zero validators, no blocks can be proposed or committed. The network cannot process any transactions.
- **Non-recoverable network partition (requires hardfork)**: Recovery requires emergency intervention and a hardfork to restore a valid validator set, as there is no on-chain mechanism to recover from this state.
- **Consensus/Safety violations**: The fundamental invariant that consensus requires â‰¥1 validator is violated.

This breaks the following critical invariants:
- **Consensus Safety**: Cannot maintain BFT consensus with 0 validators
- **Deterministic Execution**: Network cannot execute any blocks
- **State Consistency**: Network cannot commit state transitions

The impact affects **all nodes** in the network simultaneously and is **permanent** without manual intervention.

## Likelihood Explanation

**Likelihood: MEDIUM to HIGH**

The vulnerability can be triggered through several realistic scenarios:

1. **Governance Attack**: An attacker with sufficient governance voting power could propose and pass a change to increase `minimum_stake` above all current validators' stakes through the staking configuration.

2. **Coordinated Stake Manipulation**: If validators experience mass slashing events or coordinated stake withdrawals that push all validators below the minimum threshold.

3. **Configuration Error**: Administrative error in setting staking parameters during an upgrade.

The attack does not require:
- Validator collusion or insider access
- Breaking cryptographic primitives
- Complex multi-step exploitation

The barrier to exploitation depends on governance controls and staking dynamics, but the vulnerability is inherent in the code logic and will trigger automatically once conditions are met.

## Recommendation

Add a minimum validator count check in the `on_new_epoch()` function before updating the active validator set:

```move
// After line 1399 in stake.move, before line 1401:
assert!(
    vector::length(&next_epoch_validators) > 0, 
    error::invalid_state(ELAST_VALIDATOR)
);

validator_set.active_validators = next_epoch_validators;
```

Additionally, add validation in the Rust epoch change verification:

```rust
// In epoch_change.rs verify() function, after line 114:
let next_verifier = ledger_info_with_sigs
    .ledger_info()
    .next_epoch_state()
    .ok_or_else(|| format_err!("LedgerInfo doesn't carry a ValidatorSet"))?;

ensure!(
    !next_verifier.verifier.is_empty(),
    "Next epoch validator set cannot be empty"
);

verifier_ref = next_verifier;
```

This defense-in-depth approach ensures validation at both the Move framework level (where validators are filtered) and the Rust level (where epoch changes are verified).

## Proof of Concept

```move
#[test(aptos_framework = @aptos_framework)]
fun test_empty_validator_set_epoch_transition(aptos_framework: &signer) {
    use aptos_framework::stake;
    use aptos_framework::staking_config;
    use aptos_framework::reconfiguration;
    
    // Initialize with multiple validators
    initialize_test_validators(aptos_framework, 3);
    
    // Set minimum stake to a very high value that exceeds all validators
    let new_config = staking_config::get();
    staking_config::update_required_stake(
        aptos_framework,
        1000000000000000, // Extremely high minimum
        1000000000000000
    );
    
    // Trigger epoch change - this will filter out all validators
    // because none meet the new minimum stake requirement
    reconfiguration::reconfigure();
    
    // At this point, the active validator set should be empty
    // but the code does not prevent this, causing network halt
    let validator_set = stake::get_validator_set();
    assert!(vector::length(&validator_set.active_validators) == 0, 0);
    
    // Network is now permanently halted - no validators can propose blocks
}
```

**Note**: This test demonstrates the vulnerability logic. The actual execution would require proper test harness setup with the Aptos framework initialization, but the core issue is that `on_new_epoch()` allows `next_epoch_validators` to be empty.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L58-58)
```text
    const ELAST_VALIDATOR: u64 = 6;
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1255-1255)
```text
            assert!(vector::length(&validator_set.active_validators) > 0, error::invalid_state(ELAST_VALIDATOR));
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1390-1401)
```text
            // A validator needs at least the min stake required to join the validator set.
            if (new_validator_info.voting_power >= minimum_stake) {
                spec {
                    assume total_voting_power + new_validator_info.voting_power <= MAX_U128;
                };
                total_voting_power = total_voting_power + (new_validator_info.voting_power as u128);
                vector::push_back(&mut next_epoch_validators, new_validator_info);
            };
            i = i + 1;
        };

        validator_set.active_validators = next_epoch_validators;
```

**File:** types/src/epoch_change.rs (L111-114)
```rust
            verifier_ref = ledger_info_with_sigs
                .ledger_info()
                .next_epoch_state()
                .ok_or_else(|| format_err!("LedgerInfo doesn't carry a ValidatorSet"))?;
```

**File:** types/src/validator_verifier.rs (L206-214)
```rust
    pub fn new(validator_infos: Vec<ValidatorConsensusInfo>) -> Self {
        let total_voting_power = sum_voting_power(&validator_infos);
        let quorum_voting_power = if validator_infos.is_empty() {
            0
        } else {
            total_voting_power * 2 / 3 + 1
        };
        Self::build_index(validator_infos, quorum_voting_power, total_voting_power)
    }
```

**File:** types/src/epoch_state.rs (L32-37)
```rust
    pub fn empty() -> Self {
        Self {
            epoch: 0,
            verifier: Arc::new(ValidatorVerifier::new(vec![])),
        }
    }
```
