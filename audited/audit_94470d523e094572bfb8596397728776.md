# Audit Report

## Title
State Corruption via Unvalidated Ledger Info in Backup Restoration Without Trusted Waypoints

## Summary
The state snapshot restoration process in `RestoreHandler::get_state_restore_receiver()` accepts arbitrary version and root hash pairs when restoring from backups if the operator does not provide trusted waypoints or uses the `--skip-epoch-endings` flag. This allows an attacker who can provide malicious backup files to corrupt the Jellyfish Merkle tree with arbitrary state data, breaking consensus safety.

## Finding Description

The vulnerability exists in the backup restoration validation chain across multiple components:

1. **Missing Trust Anchor Validation**: [1](#0-0) 

   When restoring epoch history, if no trusted waypoint exists for a given version, the code falls back to verifying signatures using the previous epoch's validator set. However, for epoch 0 (genesis), when `previous_li` is None and no trusted waypoint exists, **no validation occurs at all**.

2. **Optional Epoch History Verification**: [2](#0-1) 

   The ledger info verification is conditional on `epoch_history` being present. When `--skip-epoch-endings` is used, this validation is completely bypassed.

3. **Empty Trusted Waypoints Accepted**: [3](#0-2) 

   The system allows empty trusted waypoint lists without warning, creating an insecure default configuration.

4. **Direct State Restoration**: [4](#0-3) 

   The function directly creates `StateSnapshotRestore` with caller-provided version and root hash without internal validation.

**Attack Path:**

1. Attacker crafts malicious backup files containing:
   - Fabricated genesis LedgerInfo with attacker-controlled validator set
   - Subsequent epoch endings signed by attacker's validators  
   - State snapshot manifest with arbitrary `version` and `root_hash`
   - TransactionInfoWithProof with matching state root hash
   - Malicious state chunks with valid proofs against the fake root

2. Victim restores using one of these unsafe configurations:
   - `--skip-epoch-endings` flag (bypasses all epoch validation)
   - No `--trust-waypoint` arguments (epoch 0 accepts without verification)

3. Validation flow accepts malicious data:
   - [5](#0-4) 
     Transaction info proof verification passes (internally consistent)
   - Epoch history either skipped or rooted in unverified genesis
   - [6](#0-5) 
     JellyfishMerkleRestore accepts the fabricated root hash
   - Malicious state chunks restore to database

## Impact Explanation

**Severity: Critical** (per Aptos Bug Bounty criteria)

This vulnerability enables:

- **Consensus Safety Violation**: Different nodes restoring from attacker-provided backups will have different state roots, breaking the fundamental invariant that all validators must produce identical state for identical blocks.

- **State Consistency Violation**: The Jellyfish Merkle tree is corrupted with arbitrary attacker-controlled data, invalidating all state proofs and breaking atomic state transitions.

- **Non-Recoverable Network Partition**: Nodes with corrupted state cannot sync with honest nodes, requiring manual intervention or hard fork to recover.

This meets the "Critical" severity criteria for "Consensus/Safety violations" and "Non-recoverable network partition (requires hardfork)".

## Likelihood Explanation

**Likelihood: Medium-High**

Exploitation requires:
- Victim to restore from backups (common during node setup/recovery)
- Attacker ability to provide backup files (via compromised storage, malicious backup service, or social engineering)
- Victim to not configure trusted waypoints (current default behavior)

The attack is highly likely because:
1. The CLI provides no warning about the security requirement for trusted waypoints
2. [7](#0-6) 
   The `--skip-epoch-endings` flag is documented as "used for debugging" but is accessible in production
3. Node operators commonly restore from third-party backup services
4. No validation enforces that at least genesis waypoint is trusted

## Recommendation

**Immediate fixes:**

1. **Require Genesis Waypoint**: Enforce that at minimum, epoch 0 must have a trusted waypoint:

```rust
// In TrustedWaypointOpt::verify()
pub fn verify(self) -> Result<HashMap<Version, Waypoint>> {
    let mut trusted_waypoints = HashMap::new();
    for w in self.trust_waypoint {
        trusted_waypoints.insert(w.version(), w)...
    }
    
    // NEW: Require at least genesis waypoint
    ensure!(
        !trusted_waypoints.is_empty(),
        "At least one trusted waypoint (genesis) must be provided for secure restoration"
    );
    
    Ok(trusted_waypoints)
}
```

2. **Fail Unsafe on Unverified LedgerInfo**: Reject epoch history if genesis cannot be verified:

```rust
// In EpochEndingRestoreController::preheat_impl()
if let Some(wp_trusted) = self.trusted_waypoints.get(&wp_li.version()) {
    ensure!(*wp_trusted == wp_li, ...);
} else if let Some(pre_li) = previous_li {
    pre_li.ledger_info().next_epoch_state()...verify(&li)?;
} else {
    // NEW: Fail if no trust anchor exists
    bail!(
        "Cannot verify LedgerInfo at epoch {} without trusted waypoint or previous epoch",
        li.ledger_info().epoch()
    );
}
```

3. **Remove or Restrict `--skip-epoch-endings`**: Either remove this flag entirely or require explicit confirmation with security warnings.

4. **Add CLI Warnings**: Display prominent warnings when restoring without adequate trusted waypoints.

## Proof of Concept

**Setup malicious backup:**
```bash
# Create fabricated genesis with attacker-controlled validator set
# Generate malicious state snapshot with arbitrary root hash
# Create valid proofs that internally verify but represent fake state
```

**Restore without protection:**
```bash
# Vulnerable restore command (no trusted waypoints)
aptos-db-tool restore \
  --target-db-dir /tmp/corrupted_db \
  --metadata-cache-dir /tmp/malicious_backup/metadata \
  state-snapshot \
  --state-manifest /tmp/malicious_backup/state.manifest \
  --state-into-version 1000000

# OR with skip-epoch-endings
aptos-db-tool restore \
  --target-db-dir /tmp/corrupted_db \
  --skip-epoch-endings \
  ...
```

**Result**: Database contains attacker-controlled state with arbitrary balances, validator sets, or governance state, while all internal proofs validate successfully.

## Notes

The root cause is the absence of mandatory trust anchors for backup restoration. While the code correctly implements signature verification chains, it fails to enforce that these chains must be rooted in a trusted source. The optional nature of `epoch_history` verification and the acceptance of empty `trusted_waypoints` creates an insecure default that operators may unknowingly rely upon.

### Citations

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L129-146)
```rust
                if let Some(wp_trusted) = self.trusted_waypoints.get(&wp_li.version()) {
                    ensure!(
                        *wp_trusted == wp_li,
                        "Waypoints don't match. In backup: {}, trusted: {}",
                        wp_li,
                        wp_trusted,
                    );
                } else if let Some(pre_li) = previous_li {
                    pre_li
                        .ledger_info()
                        .next_epoch_state()
                        .ok_or_else(|| {
                            anyhow!(
                                "Next epoch state not found from LI at epoch {}.",
                                pre_li.ledger_info().epoch()
                            )
                        })?
                        .verify(&li)?;
```

**File:** storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs (L127-136)
```rust
        txn_info_with_proof.verify(li.ledger_info(), manifest.version)?;
        let state_root_hash = txn_info_with_proof
            .transaction_info()
            .ensure_state_checkpoint_hash()?;
        ensure!(
            state_root_hash == manifest.root_hash,
            "Root hash mismatch with that in proof. root hash: {}, expected: {}",
            manifest.root_hash,
            state_root_hash,
        );
```

**File:** storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs (L137-139)
```rust
        if let Some(epoch_history) = self.epoch_history.as_ref() {
            epoch_history.verify_ledger_info(&li)?;
        }
```

**File:** storage/backup/backup-cli/src/utils/mod.rs (L348-362)
```rust
impl TrustedWaypointOpt {
    pub fn verify(self) -> Result<HashMap<Version, Waypoint>> {
        let mut trusted_waypoints = HashMap::new();
        for w in self.trust_waypoint {
            trusted_waypoints
                .insert(w.version(), w)
                .map_or(Ok(()), |w| {
                    Err(AptosDbError::Other(format!(
                        "Duplicated waypoints at version {}",
                        w.version()
                    )))
                })?;
        }
        Ok(trusted_waypoints)
    }
```

**File:** storage/aptosdb/src/backup/restore_handler.rs (L41-55)
```rust
    pub fn get_state_restore_receiver(
        &self,
        version: Version,
        expected_root_hash: HashValue,
        restore_mode: StateSnapshotRestoreMode,
    ) -> Result<StateSnapshotRestore<StateKey, StateValue>> {
        StateSnapshotRestore::new(
            &self.state_store.state_merkle_db,
            &self.state_store,
            version,
            expected_root_hash,
            true, /* async_commit */
            restore_mode,
        )
    }
```

**File:** storage/jellyfish-merkle/src/restore/mod.rs (L189-235)
```rust
    pub fn new<D: 'static + TreeReader<K> + TreeWriter<K>>(
        store: Arc<D>,
        version: Version,
        expected_root_hash: HashValue,
        async_commit: bool,
    ) -> Result<Self> {
        let tree_reader = Arc::clone(&store);
        let (finished, partial_nodes, previous_leaf) = if let Some(root_node) =
            tree_reader.get_node_option(&NodeKey::new_empty_path(version), "restore")?
        {
            info!("Previous restore is complete, checking root hash.");
            ensure!(
                root_node.hash() == expected_root_hash,
                "Previous completed restore has root hash {}, expecting {}",
                root_node.hash(),
                expected_root_hash,
            );
            (true, vec![], None)
        } else if let Some((node_key, leaf_node)) = tree_reader.get_rightmost_leaf(version)? {
            // If the system crashed in the middle of the previous restoration attempt, we need
            // to recover the partial nodes to the state right before the crash.
            (
                false,
                Self::recover_partial_nodes(tree_reader.as_ref(), version, node_key)?,
                Some(leaf_node),
            )
        } else {
            (
                false,
                vec![InternalInfo::new_empty(NodeKey::new_empty_path(version))],
                None,
            )
        };

        Ok(Self {
            store,
            version,
            partial_nodes,
            frozen_nodes: HashMap::new(),
            previous_leaf,
            num_keys_received: 0,
            expected_root_hash,
            finished,
            async_commit,
            async_commit_result: None,
        })
    }
```

**File:** storage/backup/backup-cli/src/coordinators/restore.rs (L42-43)
```rust
    #[clap(long, help = "Skip restoring epoch ending info, used for debugging.")]
    pub skip_epoch_endings: bool,
```
