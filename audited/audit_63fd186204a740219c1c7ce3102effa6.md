# Audit Report

## Title
Cache Worker DoS via Empty TransactionsOutput and Malformed BATCH_END Messages

## Summary
The cache worker component crashes when receiving `TransactionsOutput` messages with zero transactions, and accepts malformed `BATCH_END` signals with negative transaction counts due to integer underflow. A malicious fullnode can exploit these issues to cause persistent denial of service to indexer cache workers, preventing transaction data from being cached and served to downstream clients.

## Finding Description

The vulnerability exists in two related code paths within the cache worker:

**Issue 1: Crash on Empty TransactionsOutput**

The `process_transactions_from_node_response` function unconditionally calls `.first()` and `.last()` on the transactions vector without validating it's non-empty: [1](#0-0) 

When a malicious fullnode sends a `TransactionsOutput` with an empty transactions vector (which is valid per the protobuf deserialization that uses `.unwrap_or_default()`): [2](#0-1) 

The `.context()` call converts `None` to an error, causing the worker to break the stream loop and disconnect: [3](#0-2) 

**Issue 2: Integer Underflow in BATCH_END Processing**

The BATCH_END handler calculates `num_of_transactions` using unchecked arithmetic: [4](#0-3) 

When a malicious fullnode sends `end_version = start_version - 1`, the subtraction underflows in release builds (production):
- `99u64 - 100u64 = u64::MAX` (wraps to 18446744073709551615)
- `u64::MAX + 1 = 0` (wraps to 0)

This creates `num_of_transactions = 0`, which passes the validation check: [5](#0-4) 

The check `current_version != start_version + 0` evaluates to `false` (since both equal `current_version`), allowing the empty batch to be accepted. The Lua script in cache updates succeeds because `latest_version + 0 == current_version`: [6](#0-5) 

**Attack Scenario:**
1. Cache worker connects to malicious fullnode requesting transactions from version X
2. Malicious fullnode sends `INIT` with `start_version = X`
3. Malicious fullnode repeatedly sends:
   - Option A: `TransactionsOutput` with 0 transactions → worker crashes and reconnects (infinite loop)
   - Option B: `BATCH_END` with `start_version = X`, `end_version = X - 1` → worker accepts empty batch and waits for next (infinite loop)
4. Worker never processes legitimate transactions, cache remains stale

**Invariant Broken:**
The protocol specification requires batches to contain at least one transaction and `end_version ≥ start_version`: [7](#0-6) 

The code violates this by accepting empty batches and lacking validation.

## Impact Explanation

**Medium Severity** - This vulnerability causes persistent denial of service to the indexer cache infrastructure:

1. **Cache Worker Unavailability**: Malicious fullnodes can prevent cache workers from processing and caching transaction data
2. **Downstream Service Disruption**: Applications relying on the cache for transaction data will experience degraded performance or failures
3. **Resource Exhaustion**: Infinite crash/reconnect loops consume worker resources
4. **Data Staleness**: Cache remains at old versions, preventing clients from accessing recent transaction data

While this doesn't directly affect consensus or validator operations, it disrupts critical indexer infrastructure that many ecosystem services depend on for blockchain data access. This aligns with **Medium severity** per the bug bounty criteria: "State inconsistencies requiring intervention" - the cache state becomes inconsistent with the actual blockchain state.

## Likelihood Explanation

**High Likelihood** of occurrence:

1. **Attacker Requirements**: Only requires ability to run a malicious fullnode or perform MITM attack on fullnode connections
2. **Complexity**: Low - simply sending malformed protobuf messages
3. **Detection**: Difficult to distinguish from network issues or legitimate empty responses during filtering
4. **Persistence**: Attack can be sustained indefinitely without additional resources

The cache worker actively connects to fullnodes without strong validation of message contents, making this easily exploitable.

## Recommendation

Add validation to reject empty transactions and malformed batch signals:

```rust
// In process_transactions_from_node_response, Response::Data handler:
Response::Data(data) => {
    // Validate non-empty
    if data.transactions.is_empty() {
        return Err(anyhow::anyhow!("Received empty TransactionsOutput"));
    }
    
    let transaction_len = data.transactions.len();
    // ... rest of processing
}

// In process_transactions_from_node_response, Response::Status handler:
StatusType::BatchEnd => {
    let start_version = status.start_version;
    let end_version = status
        .end_version
        .expect("TransactionsFromNodeResponse status end_version is None");
    
    // Validate end_version >= start_version
    if end_version < start_version {
        return Err(anyhow::anyhow!(
            "Invalid BATCH_END: end_version ({}) < start_version ({})",
            end_version, start_version
        ));
    }
    
    let num_of_transactions = end_version - start_version + 1;
    // ... rest of processing
}
```

Additionally, consider adding the same validation to the data manager for consistency: [8](#0-7) 

## Proof of Concept

```rust
// Malicious fullnode simulation sending empty TransactionsOutput
use aptos_protos::internal::fullnode::v1::{
    TransactionsFromNodeResponse, TransactionsOutput,
    transactions_from_node_response::Response,
    StreamStatus, stream_status::StatusType,
};

// Test 1: Empty TransactionsOutput causes crash
let malicious_response = TransactionsFromNodeResponse {
    chain_id: 1,
    response: Some(Response::Data(TransactionsOutput {
        transactions: vec![], // Empty vector - will crash cache worker
    })),
};

// Test 2: Malformed BATCH_END with underflow
let malicious_batch_end = TransactionsFromNodeResponse {
    chain_id: 1,
    response: Some(Response::Status(StreamStatus {
        r#type: StatusType::BatchEnd as i32,
        start_version: 100,
        end_version: Some(99), // end_version < start_version causes underflow to 0
    })),
};

// When cache worker processes these:
// - malicious_response triggers error at .first().context()
// - malicious_batch_end calculates num_of_transactions = 99 - 100 + 1 = 0 (after wrap)
//   and passes validation, accepting an empty batch
```

**Notes:**
- This vulnerability affects the indexer infrastructure layer, not core blockchain consensus
- The data manager component handles empty data differently (accepts without crash), showing inconsistent validation across consumers
- Production deployments use release builds where integer overflow wraps rather than panics, making Issue 2 exploitable
- Mitigation can be deployed without consensus changes as this is off-chain infrastructure

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-cache-worker/src/worker.rs (L195-200)
```rust
                    let start_version = status.start_version;
                    let num_of_transactions = status
                        .end_version
                        .expect("TransactionsFromNodeResponse status end_version is None")
                        - start_version
                        + 1;
```

**File:** ecosystem/indexer-grpc/indexer-grpc-cache-worker/src/worker.rs (L214-222)
```rust
                let first_transaction = data
                    .transactions
                    .first()
                    .context("There were unexpectedly no transactions in the response")?;
                let first_transaction_version = first_transaction.version;
                let last_transaction = data
                    .transactions
                    .last()
                    .context("There were unexpectedly no transactions in the response")?;
```

**File:** ecosystem/indexer-grpc/indexer-grpc-cache-worker/src/worker.rs (L433-447)
```rust
                    if current_version != start_version + num_of_transactions {
                        error!(
                            current_version = current_version,
                            actual_current_version = start_version + num_of_transactions,
                            "[Indexer Cache] End signal received with wrong version."
                        );
                        ERROR_COUNT
                            .with_label_values(&["data_end_wrong_version"])
                            .inc();
                        break;
                    }
                    cache_operator
                        .update_cache_latest_version(transaction_count, current_version)
                        .await
                        .context("Failed to update the latest version in the cache")?;
```

**File:** ecosystem/indexer-grpc/indexer-grpc-cache-worker/src/worker.rs (L465-474)
```rust
            Err(e) => {
                error!(
                    start_version = current_version,
                    chain_id = fullnode_chain_id,
                    service_type = SERVICE_TYPE,
                    "[Indexer Cache] Process transactions from fullnode failed: {}",
                    e
                );
                ERROR_COUNT.with_label_values(&["response_error"]).inc();
                break;
```

**File:** protos/rust/src/pb/aptos.internal.fullnode.v1.serde.rs (L702-704)
```rust
                Ok(TransactionsOutput {
                    transactions: transactions__.unwrap_or_default(),
                })
```

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/cache_operator.rs (L44-48)
```rust
        if tonumber(latest_version) + num_of_versions < current_version then
            return 2
        elseif tonumber(latest_version) + num_of_versions == current_version then
            redis.call("SET", KEYS[1], current_version)
            return 0
```

**File:** protos/rust/src/pb/aptos.internal.fullnode.v1.rs (L6-11)
```rust
// Transaction data is transferred via 1 stream with batches until terminated.
// One stream consists:
//   StreamStatus: INIT with version x
//   loop k:
//     TransactionOutput data(size n)
//     StreamStatus: BATCH_END with version x + (k + 1) * n - 1
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/data_manager.rs (L261-266)
```rust
                                Response::Data(data) => {
                                    trace!(
                                        "Putting data into cache, {} transaction(s).",
                                        data.transactions.len()
                                    );
                                    self.cache.write().await.put_transactions(data.transactions);
```
