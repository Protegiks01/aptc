# Audit Report

## Title
BCS Serialization Failure Cost Bypass with Lazy Loading Enabled

## Summary
When lazy loading is enabled (default in Aptos), BCS serialization operations that fail during type layout construction do not charge the configured failure cost of 3676 gas units. An attacker can exploit this to consume validator CPU resources by repeatedly triggering type layout construction failures without paying adequate gas, potentially causing validator node slowdowns.

## Finding Description

The BCS native functions (`to_bytes`, `serialized_size`) are designed to charge a failure cost when serialization fails. However, the Aptos framework implementation contains a critical gas charging bypass when lazy loading is enabled. [1](#0-0) 

The code explicitly bypasses the failure cost when lazy loading is enabled, with a comment acknowledging: "Note that makes it possible to fail on constructing a very deep / large layout and not be charged."

The failure cost is configured at 3676 internal gas units: [2](#0-1) 

Type layout construction can process up to 512 nodes before failing (the `layout_max_size` limit): [3](#0-2) 

The layout construction process performs recursive pattern matching, memory allocations, and type processing for each node without charging gas for this computational work: [4](#0-3) 

**Attack Path:**
1. Attacker crafts a deeply nested struct type (e.g., structs containing structs recursively)
2. Attacker calls `bcs::to_bytes()` on a value of this type in a transaction
3. The VM constructs the type layout, processing up to 512 type nodes recursively
4. Construction fails when `layout_max_size` (512) or `layout_max_depth` (128) is exceeded
5. With lazy loading enabled, error propagates directly without charging `BCS_TO_BYTES_FAILURE` (3676 gas)
6. Attacker has consumed validator CPU resources processing 512 nodes while only paying for transaction prologue and Move bytecode execution
7. Attacker repeats this attack across multiple transactions to amplify resource consumption

The existing test demonstrates this behavior is intentional but exploitable: [5](#0-4) 

Additionally, there's a TODO comment acknowledging layout construction gas charging is incomplete: [6](#0-5) 

## Impact Explanation

This vulnerability enables a **gas metering bypass** that breaks the "Resource Limits" invariant: "All operations must respect gas, storage, and computational limits."

**High Severity** - Validator node slowdowns: An attacker can systematically trigger expensive type layout construction operations (processing up to 512 nodes) without paying the failure cost (3676 gas units). Processing 512 type nodes involves hundreds of pattern matches, recursive calls, and memory allocations - computational work worth thousands of gas units that remains unmetered.

While each individual transaction's impact is bounded by `layout_max_size`, an attacker sending many such transactions can:
- Consume disproportionate validator CPU resources relative to gas paid
- Slow down block processing and transaction execution
- Degrade overall network performance for legitimate users

The gas discrepancy (3676 units not charged per failed serialization) is significant when multiplied across many transactions.

## Likelihood Explanation

**High Likelihood:**
- Lazy loading is enabled by default in production Aptos configurations
- Creating deeply nested types is straightforward in Move (as demonstrated by the test)
- Any transaction sender can trigger this without special permissions
- The attack requires only basic Move programming knowledge
- Existing test infrastructure already demonstrates feasibility

## Recommendation

Implement proper gas charging for type layout construction computational work. Two approaches:

**Option 1 (Preferred):** Charge gas proportional to nodes processed during layout construction:
```rust
fn native_to_bytes(
    context: &mut SafeNativeContext,
    ty_args: &[Type],
    mut args: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    // ... existing code ...
    
    let layout = match context.type_to_type_layout(arg_type) {
        Ok(layout) => layout,
        Err(_) => {
            // Charge failure cost even with lazy loading
            context.charge(BCS_TO_BYTES_FAILURE)?;
            return Err(SafeNativeError::Abort {
                abort_code: NFE_BCS_SERIALIZATION_FAILURE,
            });
        },
    };
    // ... rest of function ...
}
```

**Option 2:** Introduce a per-type-node gas charge during layout construction in `ty_layout_converter.rs`:
```rust
fn check_depth_and_increment_count(
    &self,
    gas_meter: &mut impl DependencyGasMeter,
    node_count: &mut u64,
    depth: u64,
) -> PartialVMResult<()> {
    // Charge gas for processing this node
    gas_meter.charge_dependency(
        DependencyKind::TypeNode,
        &AccountAddress::ZERO,
        ident_str!("type_layout"),
        NumBytes::new(1),
    )?;
    
    // ... existing validation logic ...
}
```

## Proof of Concept

The vulnerability can be demonstrated using the existing test infrastructure. The following Move code triggers the issue: [7](#0-6) 

To demonstrate the gas bypass:

```rust
#[test]
fn test_bcs_failure_gas_bypass() {
    let mut h = MoveHarness::new_with_lazy_loading(true);
    
    let acc = h.new_account_at(AccountAddress::from_hex_literal("0xbeef").unwrap());
    h.publish_package(&acc, &common::test_dir_path("type_too_large.data/type_too_large"));
    
    // Measure gas for failed BCS serialization
    let result = h.run_entry_function(
        &acc,
        str::parse("0xbeef::test::run").unwrap(),
        vec![],
        vec![],
    );
    
    // With lazy loading: TOO_MANY_TYPE_NODES error, but no BCS_TO_BYTES_FAILURE charged
    // The 3676 gas units for failure cost are bypassed
    // Yet computational work of processing ~512 type nodes was performed
}
```

An attacker could deploy multiple such modules with different deeply nested types and call them repeatedly to amplify the resource consumption attack.

---

**Notes:**
This vulnerability represents a conscious design tradeoff (acknowledged in code comments) that prioritizes avoiding out-of-gas/dependency-limit conflicts over complete gas charging. However, this tradeoff creates an exploitable gas metering bypass that violates the resource limits invariant and enables validator slowdown attacks.

### Citations

**File:** aptos-move/framework/move-stdlib/src/natives/bcs.rs (L67-89)
```rust
    let layout = if context.get_feature_flags().is_lazy_loading_enabled() {
        // With lazy loading, propagate the error directly. This is because errors here are likely
        // from metering, so we should not remap them in any way. Note that makes it possible to
        // fail on constructing a very deep / large layout and not be charged, but this is already
        // the case for regular execution, so we keep it simple. Also, charging more gas after
        // out-of-gas failure in layout construction does not make any sense.
        //
        // Example:
        //   - Constructing layout runs into dependency limit.
        //   - We cannot do `context.charge(BCS_TO_BYTES_FAILURE)?;` because then we can end up in
        //     the state where out of gas and dependency limit are hit at the same time.
        context.type_to_type_layout(arg_type)?
    } else {
        match context.type_to_type_layout(arg_type) {
            Ok(layout) => layout,
            Err(_) => {
                context.charge(BCS_TO_BYTES_FAILURE)?;
                return Err(SafeNativeError::Abort {
                    abort_code: NFE_BCS_SERIALIZATION_FAILURE,
                });
            },
        }
    };
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/move_stdlib.rs (L21-21)
```rust
        [bcs_to_bytes_failure: InternalGas, "bcs.to_bytes.failure", 3676],
```

**File:** third_party/move/move-vm/runtime/src/config.rs (L69-69)
```rust
            layout_max_size: 512,
```

**File:** third_party/move/move-vm/runtime/src/storage/ty_layout_converter.rs (L198-222)
```rust
        &self,
        node_count: &mut u64,
        depth: u64,
    ) -> PartialVMResult<()> {
        let max_count = self.vm_config().layout_max_size;
        if *node_count > max_count || *node_count == max_count && self.is_lazy_loading_enabled() {
            return Err(
                PartialVMError::new(StatusCode::TOO_MANY_TYPE_NODES).with_message(format!(
                    "Number of type nodes when constructing type layout exceeded the maximum of {}",
                    max_count
                )),
            );
        }
        *node_count += 1;

        if depth > self.vm_config().layout_max_depth {
            return Err(
                PartialVMError::new(StatusCode::VM_MAX_VALUE_DEPTH_REACHED).with_message(format!(
                    "Depth of a layout exceeded the maximum of {} during construction",
                    self.vm_config().layout_max_depth
                )),
            );
        }
        Ok(())
    }
```

**File:** aptos-move/e2e-move-tests/src/tests/type_too_large.rs (L31-43)
```rust
    // With lazy loading, layout construction errors with too many type nodes and the error is
    // propagated. Without lazy loading, the error happens inside the serializer and is remapped
    // to serialization failure error code (legacy behaviour).
    if enable_lazy_loading {
        assert!(matches!(
            result,
            TransactionStatus::Keep(ExecutionStatus::MiscellaneousError(Some(
                StatusCode::TOO_MANY_TYPE_NODES
            )))
        ));
    } else {
        assert_abort!(result, 0x1C5);
    }
```

**File:** aptos-move/framework/src/natives/util.rs (L38-38)
```rust
    // TODO(Gas): charge for getting the layout
```

**File:** aptos-move/e2e-move-tests/src/tests/type_too_large.data/type_too_large/sources/test.move (L1-73)
```text
module 0xbeef::test {

    struct A0 has drop { a: u64 }
    struct A1 has drop { a: A0, b: A0 }
    struct A2 has drop { a: A1, b: A1 }
    struct A3 has drop { a: A2, b: A2 }
    struct A4 has drop { a: A3, b: A3 }
    struct A5 has drop { a: A4, b: A4 }
    struct A6 has drop { a: A5, b: A5 }
    struct A7 has drop { a: A6, b: A6 }
    struct A8 has drop { a: A7, b: A7 }
    struct A9 has drop { a: A8, b: A8 }
    struct A10 has drop { a: A9, b: A9 }
    struct A11 has drop { a: A10, b: A10 }
    struct A12 has drop { a: A11, b: A11 }
    struct A13 has drop { a: A12, b: A12 }
    struct A14 has drop { a: A13, b: A13 }
    struct A15 has drop { a: A14, b: A14 }
    struct A16 has drop { a: A15, b: A15 }
    struct A17 has drop { a: A16, b: A16 }
    struct A18 has drop { a: A17, b: A17 }
    struct A19 has drop { a: A18, b: A18 }
    struct A20 has drop { a: A19, b: A19 }
    struct A21 has drop { a: A20, b: A20 }
    struct A22 has drop { a: A21, b: A21 }
    struct A23 has drop { a: A22, b: A22 }
    struct A24 has drop { a: A23, b: A23 }
    struct A25 has drop { a: A24, b: A24 }
    struct A26 has drop { a: A25, b: A25 }
    struct A27 has drop { a: A26, b: A26 }
    struct A28 has drop { a: A27, b: A27 }
    struct A29 has drop { a: A28, b: A28 }
    struct A30 has drop { a: A29, b: A29 }
    struct A31 has drop { a: A30, b: A30 }
    struct A32 has drop { a: A31, b: A31 }
    struct A33 has drop { a: A32, b: A32 }
    struct A34 has drop { a: A33, b: A33 }
    struct A35 has drop { a: A34, b: A34 }
    struct A36 has drop { a: A35, b: A35 }
    struct A37 has drop { a: A36, b: A36 }
    struct A38 has drop { a: A37, b: A37 }
    struct A39 has drop { a: A38, b: A38 }
    struct A40 has drop { a: A39, b: A39 }
    struct A41 has drop { a: A40, b: A40 }
    struct A42 has drop { a: A41, b: A41 }
    struct A43 has drop { a: A42, b: A42 }
    struct A44 has drop { a: A43, b: A43 }
    struct A45 has drop { a: A44, b: A44 }
    struct A46 has drop { a: A45, b: A45 }
    struct A47 has drop { a: A46, b: A46 }
    struct A48 has drop { a: A47, b: A47 }
    struct A49 has drop { a: A48, b: A48 }
    struct A50 has drop { a: A49, b: A49 }
    struct A51 has drop { a: A50, b: A50 }
    struct A52 has drop { a: A51, b: A51 }
    struct A53 has drop { a: A52, b: A52 }
    struct A54 has drop { a: A53, b: A53 }
    struct A55 has drop { a: A54, b: A54 }
    struct A56 has drop { a: A55, b: A55 }
    struct A57 has drop { a: A56, b: A56 }
    struct A58 has drop { a: A57, b: A57 }
    struct A59 has drop { a: A58, b: A58 }
    struct A60 has drop { a: A59, b: A59 }
    struct A61 has drop { a: A60, b: A60 }
    struct A62 has drop { a: A61, b: A61 }
    struct A63 has drop { a: A62, b: A62 }

    use std::bcs; use std::vector;

    public entry fun run() {
      bcs::to_bytes<vector<A63>>(&vector::empty());
    }
}
```
