# Audit Report

## Title
Missing Type Argument Validation in TransactionComposer Causes Denial of Service via Panic

## Summary
The `add_batched_call` method in `TransactionComposer` fails to validate that the number of type arguments matches the function's type parameter count before attempting type instantiation. When a generic function is called with empty or insufficient type arguments, the code panics with an index out-of-bounds error, causing a denial of service for any application using this library.

## Finding Description
The vulnerability exists in the transaction composition logic that processes Move function calls with type parameters. The code path is: [1](#0-0) 

When `add_batched_call` is invoked with a generic function but empty `ty_args`:

1. The function imports the call and obtains the `FunctionHandle` 
2. Type arguments are processed into a `type_arguments` vector (which may be empty)
3. The code validates function argument count but **never validates type argument count** against `func.type_parameters.len()`
4. At line 259, `ty.instantiate(&type_arguments)` is called on parameter types
5. For generic functions, parameter signatures contain `TypeParameter(idx)` tokens
6. The `instantiate` method attempts direct array indexing: [2](#0-1) 

7. When `type_arguments` is empty but `TypeParameter(0)` exists in the signature, this causes an **index out of bounds panic**

This panic occurs before the bytecode verifier (which would properly catch the mismatch) runs at: [3](#0-2) 

The script-composer library is exposed via WASM bindings, indicating browser/web usage where untrusted input could trigger this crash: [4](#0-3) 

## Impact Explanation
This qualifies as **High Severity** under the "API crashes" category from the Aptos bug bounty program. While script-composer is client-side tooling rather than blockchain infrastructure, it has WASM bindings suggesting deployment in web services and APIs. An attacker can crash any service using this library by submitting transaction composition requests with generic functions and empty type arguments. This affects SDKs, wallets, and developer tooling.

The impact is limited to client-side availability—it does not affect blockchain consensus, validator operations, or state integrity. However, it represents a clear denial-of-service vector against production services.

## Likelihood Explanation
The likelihood is **high**. The exploit requires no special privileges—any user of the library can trigger it. The vulnerability occurs during normal API usage with invalid (but syntactically plausible) input. Given that generic functions are common in Move (as demonstrated in test cases at lines 565, 604, 616), developers may inadvertently or maliciously provide empty type arguments.

## Recommendation
Add type argument validation before type instantiation:

```rust
let func = script.function_handle_at(call_idx);
if func.type_parameters.len() != type_arguments.len() {
    bail!(
        "Function {}::{} type argument count mismatch: expected {}, got {}",
        module,
        function,
        func.type_parameters.len(),
        type_arguments.len()
    );
}
```

This check should be inserted at line 247, immediately after obtaining the function handle and before the parameter type instantiation at line 259.

## Proof of Concept
```rust
#[test]
#[should_panic(expected = "index out of bounds")]
fn test_empty_type_args_panic() {
    use crate::TransactionComposer;
    use move_core_types::{account_address::AccountAddress, language_storage::ModuleId};
    use move_binary_format::CompiledModule;
    use std::str::FromStr;
    
    // Assume we have loaded a module with a generic function like:
    // public fun id<T>(t: T): T { t }
    
    let mut composer = TransactionComposer::single_signer();
    
    // Load the test module containing generic functions
    // (In real scenario, this would load aptos-move/script-composer/src/tests/test_modules)
    
    // This call will panic when trying to instantiate TypeParameter(0) with empty type_arguments
    composer.add_batched_call(
        "0x1::batched_execution".to_string(),
        "id".to_string(),
        vec![], // Empty type arguments for a generic function!
        vec![/* some argument */]
    ).unwrap(); // Panic occurs here
}
```

## Notes
This vulnerability specifically affects the script-composer client library and does not impact blockchain consensus, Move VM execution within validators, or state management. The issue manifests as a process crash in applications using the library, not as a blockchain-level security failure.

### Citations

**File:** aptos-move/script-composer/src/builder.rs (L151-168)
```rust
    #[wasm_bindgen(js_name = add_batched_call)]
    pub fn add_batched_call_wasm(
        &mut self,
        module: String,
        function: String,
        ty_args: Vec<String>,
        args: Vec<CallArgumentWasm>,
    ) -> Result<Vec<CallArgumentWasm>, JsValue> {
        self.add_batched_call(
            module,
            function,
            ty_args,
            args.into_iter().map(|a| a.into()).collect(),
        )
        .map_err(|err| JsValue::from(format!("{:?}", err)))
        .map(|results| results.into_iter().map(|a| a.into()).collect())
    }
}
```

**File:** aptos-move/script-composer/src/builder.rs (L216-262)
```rust
    pub fn add_batched_call(
        &mut self,
        module: String,
        function: String,
        ty_args: Vec<String>,
        args: Vec<CallArgument>,
    ) -> anyhow::Result<Vec<CallArgument>> {
        let ty_args = ty_args
            .iter()
            .map(|s| TypeTag::from_str(s))
            .collect::<anyhow::Result<Vec<_>>>()?;
        let module = ModuleId::from_str(&module)?;
        let function = Identifier::new(function)?;
        let call_idx = LOADED_MODULES.with(|modules| match modules.borrow().get(&module) {
            Some(module_ref) => self
                .builder
                .import_call_by_name(function.as_ident_str(), module_ref)
                .map_err(|err| anyhow!("Cannot import module {}: {:?}", module, err)),
            None => Err(anyhow!("Module {} is not yet loaded", module)),
        })?;

        let type_arguments = LOADED_MODULES.with(|modules| {
            ty_args
                .iter()
                .map(|ty| import_type_tag(&mut self.builder, ty, &modules.borrow()))
                .collect::<PartialVMResult<Vec<_>>>()
        })?;

        let mut arguments = vec![];
        let expected_args_ty = {
            let script = self.builder.as_script();
            let func = script.function_handle_at(call_idx);
            if script.signature_at(func.parameters).0.len() != args.len() {
                bail!(
                    "Function {}::{} argument call size mismatch",
                    module,
                    function
                );
            }
            script
                .signature_at(func.parameters)
                .0
                .iter()
                .map(|ty| ty.instantiate(&type_arguments))
                .collect::<Vec<_>>()
        };

```

**File:** aptos-move/script-composer/src/builder.rs (L408-408)
```rust
        move_bytecode_verifier::verify_script(&script).map_err(|err| anyhow!("{:?}", err))?;
```

**File:** third_party/move/move-binary-format/src/file_format.rs (L1312-1312)
```rust
            TypeParameter(idx) => subst_mapping[*idx as usize].clone(),
```
