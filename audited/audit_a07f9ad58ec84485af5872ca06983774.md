# Audit Report

## Title
Missing Gas Parameter Validation Allows Governance to Brick Network via Zero gas_unit_scaling_factor

## Summary
The gas schedule update mechanism in `gas_schedule.move` lacks validation of individual parameter values, allowing a malicious or compromised governance to set `gas_unit_scaling_factor` to 0. This causes a critical inconsistency: the raw value (0) is used directly in storage fee calculations making storage free, while the `scaling_factor()` function returns 1 to avoid division by zero, causing 1000x incorrect gas unit conversions that brick the network.

## Finding Description

The `gas_schedule.move` module contains TODO comments explicitly stating that gas parameter validation should be implemented but is missing: [1](#0-0) 

The `set_for_next_epoch()` function only validates that the feature version doesn't decrease and the blob is non-empty, with no checks on individual parameter values: [2](#0-1) 

When `gas_unit_scaling_factor` is set to 0 through a governance proposal, two critical code paths handle it inconsistently:

**Path 1 - Storage Fee Calculation (uses raw value):**
The `charge_storage_fee()` function directly uses the raw `gas_unit_scaling_factor` value: [3](#0-2) 

With value 0, this makes ALL storage operations free: `gas_consumed = (storage_fee * 0) / gas_unit_price = 0`

**Path 2 - Gas Unit Conversion (uses scaling_factor() returning 1):**
The `scaling_factor()` function intentionally returns 1 when the raw value is 0: [4](#0-3) 

This is used in gas unit conversions: [5](#0-4) 

With the normal value of 1,000,000, a transaction with max_gas_amount=1,000,000 Gas gets 1 trillion internal gas units. With scaling_factor returning 1, it gets only 1 million internal units (1000x less).

**Attack Path:**
1. Malicious actor gains governance voting power or compromises governance
2. Submits proposal with gas schedule blob containing `gas_unit_scaling_factor: 0`
3. Proposal passes and gets applied via `set_for_next_epoch()` and `on_new_epoch()`
4. Network experiences dual failure:
   - All storage operations cost 0 gas (enables unlimited storage spam)
   - All transactions receive 1000x less internal gas (cannot execute, network DoS)

## Impact Explanation

**Critical Severity** under Aptos bug bounty criteria:

1. **Total loss of liveness/network availability**: With 1000x less internal gas, virtually no legitimate transactions can execute successfully. The network becomes completely unusable.

2. **Resource exhaustion via free storage**: Storage operations cost zero gas, allowing attackers to spam the chain with unlimited state writes, exhausting storage resources.

3. **Non-recoverable without governance intervention**: Requires another governance proposal to restore correct gas parameters, but with the network unable to process transactions due to gas starvation, this creates a deadlock scenario.

This breaks the **Resource Limits** and **Move VM Safety** invariants - operations no longer respect gas limits, and gas metering is fundamentally broken.

## Likelihood Explanation

**Likelihood: Low-to-Medium**

While this requires governance-level access (stake-based voting power), several factors increase likelihood:

1. **No technical barriers**: Once governance access is obtained, there are zero validation checks preventing this
2. **Governance compromise vectors**: Could occur via voting logic bugs, economic manipulation, or compromised validator keys
3. **Accidental misconfiguration**: Even non-malicious governance mistakes could trigger this due to missing validation
4. **Precedent exists**: The TODO comments indicate developers knew validation was needed but didn't implement it

The trust model states governance participants are trusted, but this represents a defense-in-depth failure - systems should have guardrails even for privileged operations.

## Recommendation

**Immediate Fix**: Add validation to gas schedule update functions:

```rust
// In gas_schedule.move
public fun set_for_next_epoch(aptos_framework: &signer, gas_schedule_blob: vector<u8>) acquires GasScheduleV2 {
    system_addresses::assert_aptos_framework(aptos_framework);
    assert!(!vector::is_empty(&gas_schedule_blob), error::invalid_argument(EINVALID_GAS_SCHEDULE));
    
    let new_gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
    
    // ADD VALIDATION HERE
    validate_gas_schedule(&new_gas_schedule);
    
    if (exists<GasScheduleV2>(@aptos_framework)) {
        let cur_gas_schedule = borrow_global<GasScheduleV2>(@aptos_framework);
        assert!(
            new_gas_schedule.feature_version >= cur_gas_schedule.feature_version,
            error::invalid_argument(EINVALID_GAS_FEATURE_VERSION)
        );
    };
    config_buffer::upsert(new_gas_schedule);
}

// Add validation function
fun validate_gas_schedule(schedule: &GasScheduleV2) {
    // Validate gas_unit_scaling_factor is non-zero and reasonable
    let gas_unit_scaling_factor = find_entry(schedule, b"txn.gas_unit_scaling_factor");
    assert!(gas_unit_scaling_factor > 0, error::invalid_argument(EINVALID_GAS_SCHEDULE));
    assert!(gas_unit_scaling_factor >= 1000, error::invalid_argument(EINVALID_GAS_SCHEDULE));
    assert!(gas_unit_scaling_factor <= 10_000_000_000, error::invalid_argument(EINVALID_GAS_SCHEDULE));
    
    // Add other critical parameter validations
    // - minimum gas prices must be > 0
    // - maximum values must be >= minimum values
    // - reasonable bounds on all parameters
}
```

## Proof of Concept

```move
#[test_only]
module aptos_framework::gas_schedule_attack_test {
    use aptos_framework::gas_schedule;
    use aptos_framework::aptos_governance;
    use std::bcs;
    
    #[test(framework = @aptos_framework)]
    fun test_zero_scaling_factor_attack(framework: signer) {
        // Setup: Initialize gas schedule normally
        gas_schedule::initialize(&framework, /* normal blob */);
        
        // Attack: Create malicious gas schedule with scaling_factor = 0
        let malicious_schedule = GasScheduleV2 {
            feature_version: 1,
            entries: vector[
                GasEntry { key: utf8(b"txn.gas_unit_scaling_factor"), val: 0 },
                // ... other entries
            ],
        };
        
        let malicious_blob = bcs::to_bytes(&malicious_schedule);
        
        // This should fail with proper validation but currently succeeds
        gas_schedule::set_for_next_epoch(&framework, malicious_blob);
        
        // Result: Network would be bricked on next epoch
        // - Storage operations cost 0 gas
        // - Transaction gas conversions use 1 instead of 1,000,000
        // - No transactions can execute successfully
    }
}
```

**Notes**

This vulnerability represents a critical defense-in-depth failure. While exploitation requires governance-level access (considered "trusted" in the threat model), the complete absence of validation for critical gas parameters creates severe risk:

1. **Governance compromise** could occur through various vectors (voting bugs, economic attacks, key compromise)
2. **Accidental misconfiguration** by legitimate governance could trigger the same impact
3. **The developers knew this was needed** (evidenced by TODO comments) but never implemented it

The inconsistency between using the raw value for storage fees versus the `scaling_factor()` wrapper for conversions creates a particularly dangerous edge case that would completely break network operation.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L47-47)
```text
        // TODO(Gas): check if gas schedule is consistent
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L91-103)
```text
    public fun set_for_next_epoch(aptos_framework: &signer, gas_schedule_blob: vector<u8>) acquires GasScheduleV2 {
        system_addresses::assert_aptos_framework(aptos_framework);
        assert!(!vector::is_empty(&gas_schedule_blob), error::invalid_argument(EINVALID_GAS_SCHEDULE));
        let new_gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
        if (exists<GasScheduleV2>(@aptos_framework)) {
            let cur_gas_schedule = borrow_global<GasScheduleV2>(@aptos_framework);
            assert!(
                new_gas_schedule.feature_version >= cur_gas_schedule.feature_version,
                error::invalid_argument(EINVALID_GAS_FEATURE_VERSION)
            );
        };
        config_buffer::upsert(new_gas_schedule);
    }
```

**File:** aptos-move/aptos-gas-meter/src/algebra.rs (L260-263)
```rust
        let gas_consumed_internal = div_ceil(
            (u64::from(amount) as u128) * (u64::from(txn_params.gas_unit_scaling_factor) as u128),
            u64::from(gas_unit_price) as u128,
        );
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L293-298)
```rust
    pub fn scaling_factor(&self) -> GasScalingFactor {
        match u64::from(self.gas_unit_scaling_factor) {
            0 => 1.into(),
            x => x.into(),
        }
    }
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L313-317)
```rust
impl ToUnitWithParams<TransactionGasParameters, InternalGasUnit> for GasUnit {
    fn multiplier(params: &TransactionGasParameters) -> u64 {
        params.scaling_factor().into()
    }
}
```
