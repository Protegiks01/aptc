# Audit Report

## Title
Unvalidated LedgerInfo Gossip Amplification Leading to Network-Wide Metrics Poisoning

## Summary
The Aptos state sync data client accepts and propagates `StorageServerSummary` messages containing unvalidated `LedgerInfoWithSignatures` without cryptographic verification. Malicious peers can advertise arbitrarily high version numbers and invalid signatures, which are then aggregated into the `GlobalDataSummary` and amplified across honest nodes through metrics and monitoring systems, causing resource waste and operational confusion.

## Finding Description

The vulnerability exists in the gossip-like polling mechanism where nodes query peers for their storage availability. The attack flow is:

**Step 1: Malicious Advertisement**
A malicious peer responds to `GetStorageServerSummary` RPC requests with a crafted `StorageServerSummary` containing:
- A `synced_ledger_info` field with a fake `LedgerInfoWithSignatures`
- Extremely high version numbers (e.g., 999,999,999)
- Invalid or missing BLS signatures
- Fake epoch states

**Step 2: Unvalidated Collection**
When honest nodes poll this malicious peer, the response is accepted without signature verification: [1](#0-0) 

The storage summary is directly passed to `update_peer_storage_summary()` with no cryptographic validation.

**Step 3: Unvalidated Aggregation**
The malicious `synced_ledger_info` is cloned and added to the global summary without verification: [2](#0-1) 

The `calculate_global_data_summary()` method aggregates all peer advertisements without validating signatures: [3](#0-2) 

**Step 4: Amplification Through Metrics**
The unvalidated data is used by the latency monitor to track network progress: [4](#0-3) 

The `highest_synced_ledger_info()` method returns the highest version without signature verification: [5](#0-4) 

**Step 5: Network-Wide Impact**
- Honest nodes expose inflated metrics via monitoring endpoints
- Other nodes query these metrics and incorporate false data
- Operators see false sync progress indicators
- Nodes waste resources attempting to fetch non-existent high-version data

**Critical Difference from Actual Data Validation**
When actual transaction/output data is received, signatures ARE verified: [6](#0-5) [7](#0-6) 

However, this validation only occurs for payload data, NOT for the storage summaries that populate `GlobalDataSummary`.

**Broken Invariant**: "Cryptographic Correctness: BLS signatures, VRF, and hash operations must be secure" - The system accepts and propagates `LedgerInfoWithSignatures` without verifying the aggregated BLS signatures, violating the fundamental requirement that all ledger info must be cryptographically verified before use.

## Impact Explanation

This qualifies as **HIGH severity** per the Aptos bug bounty criteria:

1. **Validator node slowdowns**: Nodes waste CPU/network resources attempting to sync to advertised versions that don't exist. When requests fail, they retry with other peers, creating cascading resource consumption.

2. **Significant protocol violations**: The state sync protocol's security model assumes that advertised data summaries reflect genuine validator commitments verified by quorum signatures. By accepting unverified ledger infos, the protocol violates this fundamental assumption.

3. **Operational Impact**:
   - Network-wide metrics pollution affecting all connected nodes
   - False progress indicators misleading operators
   - Incorrect peer selection decisions based on fake availability data
   - Amplification effect as honest nodes re-advertise the poisoned global summary

4. **Attack Scalability**: A single malicious peer can poison the global view of ALL honest nodes that poll it, and this false data propagates through the network via metrics aggregation.

The impact does not reach Critical severity because:
- No direct fund loss or theft
- No consensus safety violation (actual block commits still require valid signatures)
- No permanent network partition

## Likelihood Explanation

**Likelihood: HIGH**

1. **Low Attack Complexity**: Any peer can send malicious `StorageServerSummary` responses. No special privileges, validator status, or stake required.

2. **No Authentication Barrier**: The polling mechanism accepts responses from any connected peer without prior trust establishment.

3. **Amplification Built-In**: The honest node's periodic polling (every few milliseconds) continuously re-incorporates malicious data, and the global summary is shared across the network.

4. **Difficult Detection**: The attack is subtle - nodes don't immediately crash or show obvious failures. The poisoned metrics gradually degrade network operations without clear attribution.

5. **Cost to Attacker**: Near-zero. The malicious peer simply needs to respond to RPC requests with fake data. No computational work, stake, or resources required.

## Recommendation

Add cryptographic verification of `LedgerInfoWithSignatures` before incorporating storage summaries into the global data summary. The verification should use the appropriate validator set for the claimed epoch.

**Proposed Fix Location**: `state-sync/aptos-data-client/src/peer_states.rs`

Modify the `calculate_global_data_summary()` method to:

1. Maintain access to the current `ValidatorVerifier` or `EpochState`
2. Before adding `synced_ledger_info` to `advertised_data.synced_ledger_infos`, verify signatures
3. If verification fails, skip that peer's data and optionally penalize the peer via `update_score_error()`

Alternative locations for verification:
- In `update_summary()` when the storage summary is first stored
- In `poll_peer()` immediately after receiving the response

The fix should ensure that only cryptographically valid ledger infos signed by legitimate validator quorums are included in the global data summary.

## Proof of Concept

```rust
#[tokio::test]
async fn test_malicious_storage_summary_amplification() {
    use aptos_data_client::AptosDataClient;
    use aptos_storage_service_types::responses::{
        StorageServerSummary, DataSummary, ProtocolMetadata
    };
    use aptos_types::ledger_info::{LedgerInfo, LedgerInfoWithSignatures};
    use aptos_crypto::bls12381;
    
    // Setup: Create a data client and mock network
    let (data_client, _) = AptosDataClient::new(/* ... config ... */);
    
    // Create a malicious peer
    let malicious_peer = PeerNetworkId::random();
    
    // Craft a fake LedgerInfoWithSignatures with high version but invalid signatures
    let fake_ledger_info = LedgerInfo::new(
        BlockInfo::new(
            999, // fake epoch  
            0,   // round
            HashValue::zero(),
            HashValue::zero(),
            999_999_999, // fake high version
            0, // timestamp
            None, // no epoch state
        ),
        HashValue::zero(),
    );
    
    // Create empty/invalid signature (this would fail verification)
    let fake_signatures = bls12381::Signature::dummy_signature();
    let malicious_ledger_info = LedgerInfoWithSignatures::new(
        fake_ledger_info,
        AggregateSignature::empty(), // Invalid signature
    );
    
    // Craft malicious StorageServerSummary
    let malicious_summary = StorageServerSummary {
        protocol_metadata: ProtocolMetadata::default(),
        data_summary: DataSummary {
            synced_ledger_info: Some(malicious_ledger_info.clone()),
            epoch_ending_ledger_infos: None,
            states: None,
            transactions: None,
            transaction_outputs: None,
        },
    };
    
    // Simulate honest node receiving this malicious summary
    data_client.update_peer_storage_summary(malicious_peer, malicious_summary);
    data_client.update_global_summary_cache().unwrap();
    
    // Verify the vulnerability: malicious data is in GlobalDataSummary
    let global_summary = data_client.get_global_data_summary();
    let highest = global_summary.advertised_data.highest_synced_ledger_info();
    
    // BUG: The fake high version (999,999,999) is now in the global summary
    // without signature verification
    assert_eq!(highest.unwrap().ledger_info().version(), 999_999_999);
    
    // This demonstrates that unvalidated malicious data has been
    // accepted and would be propagated to other nodes via metrics
}
```

**Notes**
The vulnerability enables a low-cost, high-impact attack where malicious peers can poison network-wide monitoring and metrics systems. While actual consensus safety is preserved through signature verification during block commits, the operational integrity of the network is compromised. This creates opportunities for:

1. Masking real synchronization issues by showing fake progress
2. Resource exhaustion attacks by causing nodes to chase non-existent data
3. Operational confusion preventing timely incident response
4. Potential cascading failures if automated systems make decisions based on poisoned metrics

The fix requires adding signature verification before accepting storage summaries into the trusted global data view, ensuring that only cryptographically valid commitments from legitimate validator quorums are propagated through the network.

### Citations

**File:** state-sync/aptos-data-client/src/poller.rs (L410-439)
```rust
        // Fetch the storage summary for the peer and stop the timer
        let request_timeout = data_summary_poller.data_client_config.response_timeout_ms;
        let result: crate::error::Result<StorageServerSummary> = data_summary_poller
            .data_client
            .send_request_to_peer_and_decode(peer, storage_request, request_timeout)
            .await
            .map(Response::into_payload);

        // Mark the in-flight poll as now complete
        data_summary_poller.in_flight_request_complete(&peer);

        // Check the storage summary response
        let storage_summary = match result {
            Ok(storage_summary) => storage_summary,
            Err(error) => {
                warn!(
                    (LogSchema::new(LogEntry::StorageSummaryResponse)
                        .event(LogEvent::PeerPollingError)
                        .message("Error encountered when polling peer!")
                        .error(&error)
                        .peer(&peer))
                );
                return;
            },
        };

        // Update the summary for the peer
        data_summary_poller
            .data_client
            .update_peer_storage_summary(peer, storage_summary);
```

**File:** state-sync/aptos-data-client/src/peer_states.rs (L338-408)
```rust
    /// Calculates a global data summary using all known storage summaries
    pub fn calculate_global_data_summary(&self) -> GlobalDataSummary {
        // Gather all storage summaries, but exclude peers that are ignored
        let storage_summaries: Vec<StorageServerSummary> = self
            .peer_to_state
            .iter()
            .filter_map(|peer_state| {
                peer_state
                    .value()
                    .get_storage_summary_if_not_ignored()
                    .cloned()
            })
            .collect();

        // If we have no peers, return an empty global summary
        if storage_summaries.is_empty() {
            return GlobalDataSummary::empty();
        }

        // Calculate the global data summary using the advertised peer data
        let mut advertised_data = AdvertisedData::empty();
        let mut max_epoch_chunk_sizes = vec![];
        let mut max_state_chunk_sizes = vec![];
        let mut max_transaction_chunk_sizes = vec![];
        let mut max_transaction_output_chunk_sizes = vec![];
        for summary in storage_summaries {
            // Collect aggregate data advertisements
            if let Some(epoch_ending_ledger_infos) = summary.data_summary.epoch_ending_ledger_infos
            {
                advertised_data
                    .epoch_ending_ledger_infos
                    .push(epoch_ending_ledger_infos);
            }
            if let Some(states) = summary.data_summary.states {
                advertised_data.states.push(states);
            }
            if let Some(synced_ledger_info) = summary.data_summary.synced_ledger_info.as_ref() {
                advertised_data
                    .synced_ledger_infos
                    .push(synced_ledger_info.clone());
            }
            if let Some(transactions) = summary.data_summary.transactions {
                advertised_data.transactions.push(transactions);
            }
            if let Some(transaction_outputs) = summary.data_summary.transaction_outputs {
                advertised_data
                    .transaction_outputs
                    .push(transaction_outputs);
            }

            // Collect preferred max chunk sizes
            max_epoch_chunk_sizes.push(summary.protocol_metadata.max_epoch_chunk_size);
            max_state_chunk_sizes.push(summary.protocol_metadata.max_state_chunk_size);
            max_transaction_chunk_sizes.push(summary.protocol_metadata.max_transaction_chunk_size);
            max_transaction_output_chunk_sizes
                .push(summary.protocol_metadata.max_transaction_output_chunk_size);
        }

        // Calculate optimal chunk sizes based on the advertised data
        let optimal_chunk_sizes = calculate_optimal_chunk_sizes(
            &self.data_client_config,
            max_epoch_chunk_sizes,
            max_state_chunk_sizes,
            max_transaction_chunk_sizes,
            max_transaction_output_chunk_sizes,
        );
        GlobalDataSummary {
            advertised_data,
            optimal_chunk_sizes,
        }
    }
```

**File:** state-sync/aptos-data-client/src/latency_monitor.rs (L127-141)
```rust
            let advertised_data = &self.data_client.get_global_data_summary().advertised_data;
            let highest_advertised_version = match advertised_data.highest_synced_ledger_info() {
                Some(ledger_info) => ledger_info.ledger_info().version(),
                None => {
                    sample!(
                        SampleRate::Duration(Duration::from_secs(LATENCY_MONITOR_LOG_FREQ_SECS)),
                        warn!(
                            (LogSchema::new(LogEntry::LatencyMonitor)
                                .event(LogEvent::AggregateSummary)
                                .message("Unable to get the highest advertised version!"))
                        );
                    );
                    continue; // Continue to the next round
                },
            };
```

**File:** state-sync/aptos-data-client/src/global_summary.rs (L183-198)
```rust
    /// Returns the highest synced ledger info advertised in the network
    pub fn highest_synced_ledger_info(&self) -> Option<LedgerInfoWithSignatures> {
        let highest_synced_position = self
            .synced_ledger_infos
            .iter()
            .map(|ledger_info_with_sigs| ledger_info_with_sigs.ledger_info().version())
            .position_max();

        if let Some(highest_synced_position) = highest_synced_position {
            self.synced_ledger_infos
                .get(highest_synced_position)
                .cloned()
        } else {
            None
        }
    }
```

**File:** state-sync/state-sync-driver/src/continuous_syncer.rs (L453-455)
```rust
        if let Err(error) = self
            .get_speculative_stream_state()?
            .verify_ledger_info_with_signatures(ledger_info_with_signatures)
```

**File:** state-sync/state-sync-driver/src/utils.rs (L101-110)
```rust
    pub fn verify_ledger_info_with_signatures(
        &mut self,
        ledger_info_with_signatures: &LedgerInfoWithSignatures,
    ) -> Result<(), Error> {
        self.epoch_state
            .verify(ledger_info_with_signatures)
            .map_err(|error| {
                Error::VerificationError(format!("Ledger info failed verification: {:?}", error))
            })
    }
```
