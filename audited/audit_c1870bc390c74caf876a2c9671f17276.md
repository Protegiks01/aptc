# Audit Report

## Title
Consensus Divergence via Silent Error Swallowing in ConfigStorage Implementation

## Summary
The `ResourceResolver` trait's informal error handling specification allows implementations to silently convert storage errors into `None`, causing validators experiencing storage issues to process transactions with default feature flags while healthy validators use on-chain feature flags, leading to consensus divergence.

## Finding Description

The `ResourceResolver` trait provides informal guidance about error handling but does not enforce it at the type level: [1](#0-0) 

The critical flaw emerges in the `ConfigStorage` trait implementations used to fetch consensus-critical on-chain configurations. Two implementations silently swallow storage errors:

**Implementation 1 - StateView-based ConfigStorage:** [2](#0-1) 

**Implementation 2 - StorageAdapter ConfigStorage:** [3](#0-2) 

Both use `.ok()?` which converts `Err(STORAGE_ERROR)` to `None`. The vulnerability manifests when fetching the `Features` configuration during transaction execution: [4](#0-3) 

When a storage error occurs, `.unwrap_or_default()` returns default feature flags instead of propagating the error. Different validators with different storage health will use different feature flags.

The `CHARGE_INVARIANT_VIOLATION` feature flag (enabled on mainnet by default) controls whether `STORAGE_ERROR` causes transactions to be kept or discarded: [5](#0-4) [6](#0-5) 

**Attack Scenario:**
1. Governance updates on-chain features to differ from defaults (e.g., disabling `CHARGE_INVARIANT_VIOLATION`)
2. Some validators experience storage corruption/errors when reading state
3. Healthy validators fetch actual on-chain features (feature disabled)
4. Unhealthy validators get default features via error swallowing (feature enabled)
5. Transaction encounters `STORAGE_ERROR` during execution
6. Healthy validators: Discard transaction (feature disabled)
7. Unhealthy validators: Keep transaction and charge gas (feature enabled)
8. Validators produce different transaction sets → different state roots → **consensus breaks**

## Impact Explanation

**High Severity** - This vulnerability causes consensus divergence, breaking the "Deterministic Execution" invariant. All validators must produce identical state roots for identical blocks, but this bug allows validators with different storage health to process transactions differently. This leads to:

- **Consensus safety violation**: Validators commit different blocks
- **Chain halt**: Network cannot reach consensus on state root
- **Requires hard fork**: Manual intervention needed to recover
- Affects the most critical system component (consensus)

This meets the Aptos bug bounty **Critical Severity** criteria for "Consensus/Safety violations" as it can cause "Non-recoverable network partition (requires hardfork)".

## Likelihood Explanation

**High Likelihood** - Storage errors occur naturally in production systems:
- Disk corruption from hardware failures
- Network issues during state sync
- Database inconsistencies from crashes
- Resource exhaustion (disk full, memory pressure)

The vulnerability is triggered without attacker intervention - normal operational issues suffice. The only requirement is that on-chain feature flags differ from default values, which happens regularly through governance proposals.

## Recommendation

**Option 1 - Propagate Errors (Preferred):**
Change `ConfigStorage` to return `Result` instead of `Option`, forcing callers to explicitly handle errors:

```rust
pub trait ConfigStorage {
    fn fetch_config_bytes(&self, state_key: &StateKey) -> Result<Option<Bytes>, StateViewError>;
}

impl<E: ExecutorView> ConfigStorage for StorageAdapter<'_, E> {
    fn fetch_config_bytes(&self, state_key: &StateKey) -> Result<Option<Bytes>, StateViewError> {
        self.executor_view.get_resource_bytes(state_key, None)
            .map_err(|e| StateViewError::Other(format!("Storage error: {:?}", e)))
    }
}

impl<S: StateView> AsMoveResolver<S> for S {
    fn as_move_resolver(&self) -> StorageAdapter<'_, S> {
        let features = Features::fetch_config(self)
            .expect("Critical: Failed to fetch Features config from storage");
        // ... rest of initialization
    }
}
```

**Option 2 - Halt on Config Errors:**
Treat config fetch errors as fatal:

```rust
impl<S: StateView> AsMoveResolver<S> for S {
    fn as_move_resolver(&self) -> StorageAdapter<'_, S> {
        let features = Features::fetch_config(self)
            .unwrap_or_else(|| {
                panic!("FATAL: Cannot fetch Features config - storage error detected");
            });
        // ... rest
    }
}
```

Add explicit error documentation to `ResourceResolver` trait specifying that implementations MUST return `Err(STORAGE_ERROR)` for storage failures and MUST NOT silently convert errors to `Ok(None)`.

## Proof of Concept

```rust
// Integration test demonstrating consensus divergence
#[test]
fn test_consensus_divergence_via_storage_error() {
    use aptos_types::on_chain_config::Features;
    use move_core_types::vm_status::StatusCode;
    
    // Simulate two validators
    let mut validator_healthy = create_test_state_view();
    let mut validator_corrupted = create_corrupted_state_view(); // Returns storage errors
    
    // Both start with same on-chain feature config
    let on_chain_features = create_custom_features(vec![
        (FeatureFlag::CHARGE_INVARIANT_VIOLATION, false) // Disabled on-chain
    ]);
    validator_healthy.set_resource(CORE_CODE_ADDRESS, Features::struct_tag(), on_chain_features);
    validator_corrupted.set_storage_error(CORE_CODE_ADDRESS, Features::struct_tag()); // Simulate error
    
    // Create transaction that will encounter STORAGE_ERROR
    let txn = create_transaction_causing_storage_error();
    
    // Execute on healthy validator
    let result_healthy = execute_transaction(&validator_healthy, txn.clone());
    assert_eq!(result_healthy.status(), TransactionStatus::Discard(StatusCode::STORAGE_ERROR));
    
    // Execute on corrupted validator (falls back to default features)
    let result_corrupted = execute_transaction(&validator_corrupted, txn);
    assert_eq!(result_corrupted.status(), TransactionStatus::Keep(ExecutionStatus::MiscellaneousError(Some(StatusCode::STORAGE_ERROR))));
    
    // Validators have different transaction sets -> CONSENSUS DIVERGENCE
    assert_ne!(result_healthy.status(), result_corrupted.status());
    println!("CONSENSUS DIVERGENCE DETECTED: Different validators processed transaction differently!");
}
```

## Notes

The root cause is the mismatch between the informal trait documentation ("return `Err(..)` for storage errors") and actual implementations that convert errors to `None`. This violates the fail-fast principle and creates non-deterministic behavior across validators. The vulnerability is exacerbated by using `.unwrap_or_default()` for critical consensus parameters, which masks storage failures as normal "config not found" scenarios.

### Citations

**File:** third_party/move/move-vm/types/src/resolver.rs (L16-24)
```rust
/// A persistent storage backend that can resolve resources by address + type
/// Storage backends should return
///   - Ok(Some(..)) if the data exists
///   - Ok(None)     if the data does not exist
///   - Err(..)      only when something really wrong happens, for example
///                    - invariants are broken and observable from the storage side
///                      (this is not currently possible as ModuleId and StructTag
///                       are always structurally valid)
///                    - storage encounters internal error
```

**File:** types/src/on_chain_config/mod.rs (L204-210)
```rust
impl<S: StateView> ConfigStorage for S {
    fn fetch_config_bytes(&self, state_key: &StateKey) -> Option<Bytes> {
        self.get_state_value(state_key)
            .ok()?
            .map(|s| s.bytes().clone())
    }
}
```

**File:** aptos-move/aptos-vm/src/data_cache.rs (L253-259)
```rust
impl<E: ExecutorView> ConfigStorage for StorageAdapter<'_, E> {
    fn fetch_config_bytes(&self, state_key: &StateKey) -> Option<Bytes> {
        self.executor_view
            .get_resource_bytes(state_key, None)
            .ok()?
    }
}
```

**File:** aptos-move/aptos-vm/src/data_cache.rs (L266-278)
```rust
impl<S: StateView> AsMoveResolver<S> for S {
    fn as_move_resolver(&self) -> StorageAdapter<'_, S> {
        let features = Features::fetch_config(self).unwrap_or_default();
        let gas_feature_version = get_gas_feature_version(self);
        let resource_group_adapter = ResourceGroupAdapter::new(
            None,
            self,
            gas_feature_version,
            features.is_resource_groups_split_in_vm_change_set_enabled(),
        );
        StorageAdapter::new(self, resource_group_adapter)
    }
}
```

**File:** types/src/transaction/mod.rs (L1639-1647)
```rust
            Err(code) => {
                if code.status_type() == StatusType::InvariantViolation
                    && features.is_enabled(FeatureFlag::CHARGE_INVARIANT_VIOLATION)
                {
                    Self::Keep(ExecutionStatus::MiscellaneousError(Some(code)))
                } else {
                    Self::Discard(code)
                }
            },
```

**File:** types/src/on_chain_config/aptos_features.rs (L194-194)
```rust
            FeatureFlag::CHARGE_INVARIANT_VIOLATION,
```
