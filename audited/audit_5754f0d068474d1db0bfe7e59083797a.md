# Audit Report

## Title
Schema Inconsistency Between OrderedTransactionByAccountSchema and TransactionSummariesByAccountSchema for Nonce-Based Transactions

## Summary
The storage layer uses two different indexing schemas for account transactions that become inconsistent when nonce-based transactions (orderless transactions) are enabled. Transactions using `ReplayProtector::Nonce` are indexed in `TransactionSummariesByAccountSchema` but not in `OrderedTransactionByAccountSchema`, causing the same transaction to appear in one schema but not the other.

## Finding Description

The transaction storage system maintains two separate indexes for account transactions with different key structures:

1. **OrderedTransactionByAccountSchema**: Maps `(AccountAddress, SequenceNumber) → Version`
2. **TransactionSummariesByAccountSchema**: Maps `(AccountAddress, Version) → IndexedTransactionSummary`

The critical inconsistency occurs in the `put_transaction` function where these schemas are populated: [1](#0-0) 

The `OrderedTransactionByAccountSchema` is only written when:
- `skip_index` is false (storage sharding disabled)
- AND the transaction uses `ReplayProtector::SequenceNumber` [2](#0-1) 

The `TransactionSummariesByAccountSchema` is written for ALL signed user transactions, regardless of the replay protector type.

When the `ORDERLESS_TRANSACTIONS` feature flag is enabled: [3](#0-2) 

Nonce-based transactions are allowed to execute. The `ReplayProtector` enum supports two variants: [4](#0-3) 

This creates a schema inconsistency where:
- `get_account_transaction_summaries_iter()` returns ALL user transactions including nonce-based ones
- `get_account_ordered_transaction_version()` and related APIs miss nonce-based transactions [5](#0-4) [6](#0-5) 

## Impact Explanation

This issue falls under **Medium Severity** as it creates "State inconsistencies requiring intervention" per the Aptos bug bounty criteria. The impacts include:

1. **API Inconsistency**: Different query APIs return different results for the same account's transaction history
2. **Incomplete Audit Trails**: Off-chain indexers and monitoring systems using `OrderedTransactionByAccountSchema` will miss nonce-based transactions
3. **Data Availability Gap**: Historical transaction queries through sequence-number-based APIs are incomplete when orderless transactions are used

While this doesn't directly cause fund loss, consensus violations, or node crashes, it creates data inconsistencies that require intervention to reconcile and could affect security monitoring systems that rely on complete transaction history.

## Likelihood Explanation

**Likelihood: Low to Medium**

The inconsistency only manifests when:
1. The `ORDERLESS_TRANSACTIONS` feature flag is enabled through on-chain governance
2. Users submit transactions with `ReplayProtector::Nonce` instead of `ReplayProtector::SequenceNumber`

Currently, there's code checking for this feature flag, and nonce-based transactions are rejected when the feature is disabled. However, once enabled, the schema inconsistency becomes active for all nonce-based transactions.

## Recommendation

The codebase should ensure schema consistency by either:

**Option 1**: Also index nonce-based transactions in `OrderedTransactionByAccountSchema` using the nonce value:
```rust
if let Some(txn) = transaction.try_as_signed_user_txn() {
    match txn.replay_protector() {
        ReplayProtector::SequenceNumber(seq_num) => {
            batch.put::<OrderedTransactionByAccountSchema>(
                &(txn.sender(), seq_num),
                &version,
            )?;
        },
        ReplayProtector::Nonce(nonce) => {
            batch.put::<OrderedTransactionByAccountSchema>(
                &(txn.sender(), nonce),
                &version,
            )?;
        },
    }
}
```

**Option 2**: Extend the mitigation already in place for sharding to also block ordered transaction APIs when orderless transactions are enabled: [7](#0-6) 

Add additional checks:
```rust
ensure!(
    !self.state_kv_db.enabled_sharding(),
    "This API is not supported with sharded DB"
);
ensure!(
    !features.is_orderless_txns_enabled(),
    "This API is not supported when orderless transactions are enabled"
);
```

## Proof of Concept

```rust
// Rust test demonstrating the inconsistency
#[test]
fn test_nonce_transaction_schema_inconsistency() {
    // Setup: Enable ORDERLESS_TRANSACTIONS feature flag
    // Create a signed transaction with ReplayProtector::Nonce
    let sender = AccountAddress::random();
    let nonce = 42u64;
    let version = 100u64;
    
    // Create transaction with nonce-based replay protector
    let raw_txn = create_raw_transaction_with_nonce(sender, nonce);
    let signed_txn = sign_transaction(raw_txn);
    
    // Commit transaction to storage
    transaction_db.put_transaction(version, &Transaction::UserTransaction(signed_txn), false, &mut batch);
    db.write_schemas(batch);
    
    // Query OrderedTransactionByAccountSchema - should return None
    let ordered_result = transaction_store.get_account_ordered_transaction_version(
        sender, nonce, version
    );
    assert!(ordered_result.is_ok());
    assert!(ordered_result.unwrap().is_none()); // NOT FOUND
    
    // Query TransactionSummariesByAccountSchema - should return Some
    let summary_iter = transaction_store.get_account_transaction_summaries_iter(
        sender, Some(version), None, 10, version
    );
    assert!(summary_iter.is_ok());
    let summaries: Vec<_> = summary_iter.unwrap().collect();
    assert!(!summaries.is_empty()); // FOUND
    
    // Inconsistency: Same transaction appears in one schema but not the other
}
```

## Notes

The code already has a partial mitigation for the `skip_index` scenario where it explicitly disallows ordered transaction APIs when storage sharding is enabled. However, this mitigation doesn't extend to the nonce-based transaction case, leaving a schema consistency gap when the `ORDERLESS_TRANSACTIONS` feature is enabled.

### Citations

**File:** storage/aptosdb/src/ledger_db/transaction_db.rs (L137-145)
```rust
        if !skip_index {
            if let Some(txn) = transaction.try_as_signed_user_txn() {
                if let ReplayProtector::SequenceNumber(seq_num) = txn.replay_protector() {
                    batch.put::<OrderedTransactionByAccountSchema>(
                        &(txn.sender(), seq_num),
                        &version,
                    )?;
                }
            }
```

**File:** storage/aptosdb/src/ledger_db/transaction_db.rs (L150-161)
```rust
        if let Some(signed_txn) = transaction.try_as_signed_user_txn() {
            let txn_summary = IndexedTransactionSummary::V1 {
                sender: signed_txn.sender(),
                replay_protector: signed_txn.replay_protector(),
                version,
                transaction_hash,
            };
            batch.put::<TransactionSummariesByAccountSchema>(
                &(signed_txn.sender(), version),
                &txn_summary,
            )?;
        }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1923-1930)
```rust
        if !self.features().is_orderless_txns_enabled() {
            if let ReplayProtector::Nonce(_) = transaction.replay_protector() {
                return Err(VMStatus::error(
                    StatusCode::FEATURE_UNDER_GATING,
                    Some("Orderless transactions are not yet supported".to_string()),
                ));
            }
        }
```

**File:** types/src/transaction/mod.rs (L113-116)
```rust
pub enum ReplayProtector {
    Nonce(u64),
    SequenceNumber(u64),
}
```

**File:** storage/aptosdb/src/transaction_store/mod.rs (L36-52)
```rust
    pub fn get_account_ordered_transaction_version(
        &self,
        address: AccountAddress,
        sequence_number: u64,
        ledger_version: Version,
    ) -> Result<Option<Version>> {
        if let Some(version) =
            self.ledger_db
                .transaction_db_raw()
                .get::<OrderedTransactionByAccountSchema>(&(address, sequence_number))?
        {
            if version <= ledger_version {
                return Ok(Some(version));
            }
        }
        Ok(None)
    }
```

**File:** storage/aptosdb/src/transaction_store/mod.rs (L83-140)
```rust
    pub fn get_account_transaction_summaries_iter(
        &self,
        address: AccountAddress,
        start_version: Option<u64>,
        end_version: Option<u64>,
        limit: u64,
        ledger_version: Version,
    ) -> Result<AccountTransactionSummariesIter<'_>> {
        // Question[Orderless]: When start version is specified, we are current scanning forward from start version.
        // When start version is not specified we are scanning backward, so as to return the most recent transactions.
        // This doesn't seem to be a good design. Should we instead let the API take scan direction as input?
        if start_version.is_some() {
            let mut iter = self
                .ledger_db
                .transaction_db_raw()
                .iter::<TransactionSummariesByAccountSchema>()?;
            iter.seek(&(address, start_version.unwrap()))?;
            Ok(AccountTransactionSummariesIter::new(
                iter,
                address,
                start_version,
                end_version,
                limit,
                ScanDirection::Forward,
                ledger_version,
            ))
        } else if end_version.is_some() {
            let mut iter = self
                .ledger_db
                .transaction_db_raw()
                .rev_iter::<TransactionSummariesByAccountSchema>()?;
            iter.seek_for_prev(&(address, end_version.unwrap()))?;
            Ok(AccountTransactionSummariesIter::new(
                iter,
                address,
                start_version,
                end_version,
                limit,
                ScanDirection::Backward,
                ledger_version,
            ))
        } else {
            let mut iter = self
                .ledger_db
                .transaction_db_raw()
                .rev_iter::<TransactionSummariesByAccountSchema>()?;
            iter.seek_for_prev(&(address, u64::MAX))?;
            Ok(AccountTransactionSummariesIter::new(
                iter,
                address,
                start_version,
                Some(u64::MAX),
                limit,
                ScanDirection::Backward,
                ledger_version,
            ))
        }
    }
```

**File:** storage/aptosdb/src/db/aptosdb_reader.rs (L150-162)
```rust
        gauged_api("get_account_transaction", || {
            ensure!(
                !self.state_kv_db.enabled_sharding(),
                "This API is not supported with sharded DB"
            );
            self.transaction_store
                .get_account_ordered_transaction_version(address, seq_num, ledger_version)?
                .map(|txn_version| {
                    self.get_transaction_with_proof(txn_version, ledger_version, include_events)
                })
                .transpose()
        })
    }
```
