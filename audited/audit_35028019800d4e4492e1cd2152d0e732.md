# Audit Report

## Title
ChainId Deserialization Bypasses Validation Allowing Invalid Chain ID Value Zero

## Summary
The `ChainId` type uses the default BCS deserialization implementation which bypasses the constructor's validation requiring `id > 0`. If malformed BCS bytes representing chain_id=0 are present in on-chain storage, deserialization will succeed and create an invalid `ChainId(0)`, violating the documented invariant and potentially causing complete chain halt.

## Finding Description

The `ChainId` struct enforces a critical invariant through its constructor that chain ID must be greater than zero: [1](#0-0) 

However, the `ChainId` struct derives `Deserialize`, which means BCS deserialization bypasses this validation: [2](#0-1) 

The `ChainId` type implements `OnChainConfig` using the default `deserialize_into_config` method: [3](#0-2) 

This default implementation performs only BCS deserialization without validation: [4](#0-3) 

**Exploitation Scenario:**

If malformed on-chain storage contains BCS bytes `0x00` (representing chain_id=0), either through:
1. A governance proposal adding a chain_id update function without proper validation
2. A framework upgrade bug that allows invalid state
3. A storage-layer vulnerability

Then when nodes fetch the ChainId configuration: [5](#0-4) 

The deserialization succeeds with `ChainId(0)`, which then propagates to transaction validation where the prologue checks: [6](#0-5) 

Since `chain_id::get()` returns 0, only transactions with `chain_id=0` would pass validation. However, all legitimate transactions use chain_id values 1-5 (mainnet, testnet, etc.), causing **complete chain halt** as no valid transactions can be processed.

## Impact Explanation

**Critical Severity** - This meets the "Non-recoverable network partition (requires hardfork)" category because:

1. **Total Loss of Liveness**: All validators would reject legitimate transactions since the prologue validation would fail for any transaction with chain_id â‰  0
2. **Consensus Remains Safe**: All validators would agree on rejecting transactions (no safety violation), but the chain cannot make progress
3. **Requires Hardfork**: Cannot be fixed through normal governance since governance transactions also require valid chain_id validation
4. **Network-Wide Impact**: Affects all nodes uniformly

The code explicitly documents that chain_id=0 is "reserved for accidental initialization": [7](#0-6) 

## Likelihood Explanation

**Medium Likelihood** - Requires one of:
1. Governance proposal that adds chain_id update functionality without proper validation
2. Framework upgrade with validation bug
3. Separate storage manipulation vulnerability

While not directly exploitable by external attackers, this represents a **defense-in-depth failure**. The deserialization layer should validate invariants even if upstream code is expected to prevent invalid data.

## Recommendation

Override `deserialize_into_config` for `ChainId` to validate the invariant:

```rust
impl OnChainConfig for ChainId {
    const MODULE_IDENTIFIER: &'static str = "chain_id";
    const TYPE_IDENTIFIER: &'static str = "ChainId";
    
    fn deserialize_into_config(bytes: &[u8]) -> Result<Self> {
        let chain_id = Self::deserialize_default_impl(bytes)?;
        ensure!(
            chain_id.id() > 0,
            "[on-chain config] Invalid chain ID: cannot be 0"
        );
        Ok(chain_id)
    }
}
```

This ensures that even if malformed bytes reach storage through any mechanism, deserialization will fail safely rather than creating an invalid state.

## Proof of Concept

```rust
#[test]
fn test_chainid_deserialization_bypass() {
    use bcs;
    use types::chain_id::ChainId;
    
    // BCS bytes representing u8 value 0
    let malformed_bytes = vec![0x00];
    
    // This should fail but succeeds, creating ChainId(0)
    let result: Result<ChainId, _> = bcs::from_bytes(&malformed_bytes);
    assert!(result.is_ok());
    
    let chain_id = result.unwrap();
    assert_eq!(chain_id.id(), 0); // Invalid value!
    
    // Compare to constructor which enforces validation
    // This panics: ChainId::new(0)
}

#[test]
#[should_panic(expected = "cannot have chain ID with 0")]
fn test_chainid_new_rejects_zero() {
    ChainId::new(0);
}
```

The PoC demonstrates that BCS deserialization succeeds with chain_id=0, while the constructor correctly rejects it, proving the validation bypass.

## Notes

This vulnerability represents a **defense-in-depth weakness** rather than a directly exploitable attack. The primary security boundary is preventing malformed data from being written to storage in the first place. However, robust systems should validate invariants at multiple layers, including deserialization, to provide resilience against upstream bugs or governance mistakes.

The Move framework's chain_id module currently only allows initialization during genesis and provides no update mechanism, which limits current exploitability. However, future framework evolution could introduce update capabilities, making this validation gap more critical.

### Citations

**File:** types/src/chain_id.rs (L14-16)
```rust
    /// Users might accidentally initialize the ChainId field to 0, hence reserving ChainId 0 for accidental
    /// initialization.
    /// MAINNET is the Aptos mainnet production chain and is reserved for 1
```

**File:** types/src/chain_id.rs (L75-76)
```rust
#[derive(Clone, Copy, Deserialize, Eq, Hash, PartialEq, Serialize)]
pub struct ChainId(u8);
```

**File:** types/src/chain_id.rs (L182-186)
```rust
impl ChainId {
    pub fn new(id: u8) -> Self {
        assert!(id > 0, "cannot have chain ID with 0");
        Self(id)
    }
```

**File:** types/src/on_chain_config/chain_id.rs (L6-9)
```rust
impl OnChainConfig for ChainId {
    const MODULE_IDENTIFIER: &'static str = "chain_id";
    const TYPE_IDENTIFIER: &'static str = "ChainId";
}
```

**File:** types/src/on_chain_config/mod.rs (L162-173)
```rust
    fn deserialize_default_impl(bytes: &[u8]) -> Result<Self> {
        bcs::from_bytes::<Self>(bytes)
            .map_err(|e| format_err!("[on-chain config] Failed to deserialize into config: {}", e))
    }

    // Function for deserializing bytes to `Self`
    // It will by default try one round of BCS deserialization directly to `Self`
    // The implementation for the concrete type should override this function if this
    // logic needs to be customized
    fn deserialize_into_config(bytes: &[u8]) -> Result<Self> {
        Self::deserialize_default_impl(bytes)
    }
```

**File:** aptos-move/aptos-vm-environment/src/environment.rs (L223-224)
```rust
        let chain_id = fetch_config_and_update_hash::<ChainId>(&mut sha3_256, state_view)
            .unwrap_or_else(ChainId::test);
```

**File:** aptos-move/framework/aptos-framework/sources/transaction_validation.move (L143-143)
```text
        assert!(chain_id::get() == chain_id, error::invalid_argument(PROLOGUE_EBAD_CHAIN_ID));
```
