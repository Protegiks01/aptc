# Audit Report

## Title
Consensus Observer QC Verification Bypass Allows Execution with Invalid Parent Blocks

## Summary
The consensus observer's `get_parent_pipeline_futs` function uses unverified quorum certificate (QC) data to determine block parent relationships, allowing malicious consensus publishers to cause observers to execute blocks with incorrect parents, breaking consensus safety.

## Finding Description

The consensus observer receives `OrderedBlock` messages from consensus publishers containing blocks and an `ordered_proof`. While the system validates the `ordered_proof` (a `LedgerInfoWithSignatures` proving the blocks were ordered), it **never validates the quorum certificates embedded within individual blocks**. [1](#0-0) 

In the vulnerable function above, when determining a block's parent for execution pipeline construction, the code directly extracts `block.quorum_cert().certified_block().round()` without any prior cryptographic verification of the QC. This round value is then used to lookup the parent block from the ordered block store.

The validation flow shows the gap: [2](#0-1) 

Only `verify_ordered_proof` is called, which validates the outer proof: [3](#0-2) 

The `verify_ordered_blocks` method also fails to validate individual QCs: [4](#0-3) 

Note the comment at line 226 explicitly states this validation "does not check the ordered proof" - but critically, it also doesn't check individual block QCs either.

In contrast, the proper QC validation method exists and is used in normal consensus: [5](#0-4) 

This `verify()` method performs cryptographic signature verification, but is never invoked in the consensus observer code path. The normal consensus flow does call it: [6](#0-5) 

**Attack Path:**
1. Malicious consensus publisher crafts an `OrderedBlock` with a valid `ordered_proof` (legitimately obtained from consensus)
2. Individual blocks within contain forged QCs with manipulated `certified_block` rounds pointing to arbitrary parent blocks
3. Observer validates only the `ordered_proof`, accepts the blocks
4. When `finalize_ordered_block` calls `get_parent_pipeline_futs`, the forged QC round is used to lookup the parent
5. Observer executes blocks with incorrect parents, diverging from validators
6. State inconsistency across the network violates consensus safety

## Impact Explanation

This is a **Critical** severity vulnerability under Aptos bug bounty criteria as it represents a **Consensus/Safety violation**. The AptosBFT consensus protocol's safety guarantee requires that all honest nodes agree on the same chain of blocks. By allowing observers to execute blocks with different parents than validators:

- **Deterministic Execution Invariant Broken**: Observers produce different state roots than validators for the same nominal block sequence
- **Consensus Safety Violated**: Network splits into inconsistent views of chain state
- **Potential Fund Loss**: State divergence can lead to double-spending or incorrect balance calculations on observer nodes serving user queries

This breaks the fundamental requirement that "All validators must produce identical state roots for identical blocks" and enables scenarios where observer nodes serving RPC requests show different blockchain states than the canonical validator consensus.

## Likelihood Explanation

**High Likelihood** - The vulnerability is easily exploitable:

- **No special privileges required**: Any node can become a consensus publisher by being selected or by exploiting publisher selection logic
- **Simple attack vector**: Requires only modifying QC data in network messages
- **No cryptographic breaking needed**: Bypasses validation rather than breaking cryptography
- **Automatic propagation**: Once an observer accepts invalid blocks, it will serve incorrect data to all connected clients

The attack succeeds whenever an observer connects to a malicious publisher, which could happen through:
- Compromised validator nodes acting as publishers
- Network manipulation directing observers to malicious publishers
- Exploitation of publisher subscription/selection logic

## Recommendation

Add QC signature verification before using QC data in `get_parent_pipeline_futs`. The fix should validate each block's QC before trusting its certified block information:

```rust
pub fn get_parent_pipeline_futs(
    &self,
    block: &PipelinedBlock,
    pipeline_builder: &PipelineBuilder,
    epoch_state: &EpochState,
) -> Result<Option<PipelineFutures>, Error> {
    // Verify the quorum certificate before using it
    block.quorum_cert().verify(&epoch_state.verifier)
        .map_err(|e| Error::InvalidMessageError(format!(
            "Failed to verify block QC: {:?}", e
        )))?;
    
    if let Some(last_ordered_block) = self
        .ordered_block_store
        .get_ordered_block(block.epoch(), block.quorum_cert().certified_block().round())
    {
        Ok(last_ordered_block.last_block().pipeline_futs())
    } else {
        Ok(Some(pipeline_builder.build_root(
            StateComputeResult::new_dummy(), 
            self.root.clone()
        )))
    }
}
```

Additionally, validate all block QCs when `OrderedBlock` is received, before insertion into stores:

```rust
// In process_ordered_block, after verify_ordered_proof:
for block in ordered_block.blocks() {
    block.quorum_cert().verify(&epoch_state.verifier)
        .map_err(|e| Error::InvalidMessageError(format!(
            "Block QC verification failed: {:?}", e
        )))?;
}
```

## Proof of Concept

```rust
// This PoC demonstrates how a malicious publisher can send blocks with forged QCs
// that pass ordered_proof validation but point to incorrect parents

#[tokio::test]
async fn test_qc_verification_bypass() {
    use aptos_consensus_types::{
        block::{Block, block_test_utils::certificate_for_genesis},
        block_data::{BlockData, BlockType},
        quorum_cert::QuorumCert,
    };
    use aptos_types::{
        block_info::BlockInfo,
        aggregate_signature::AggregateSignature,
        ledger_info::{LedgerInfo, LedgerInfoWithSignatures},
    };
    
    // Create epoch state with validator verifier
    let epoch_state = create_test_epoch_state();
    
    // Create legitimate root block
    let root_qc = certificate_for_genesis();
    let root_block_info = root_qc.certified_block().clone();
    
    // Create a legitimate block B1 at round 1
    let block_1 = create_test_block(1, root_qc.clone());
    
    // Create a legitimate block B2 at round 2  
    let qc_1 = create_valid_qc_for_block(&block_1, &epoch_state);
    let block_2 = create_test_block(2, qc_1);
    
    // ATTACK: Create block B3 with FORGED QC claiming parent is round 100 (doesn't exist)
    let mut forged_qc_data = QuorumCert::dummy();
    // Modify the certified_block to point to non-existent round 100
    let fake_parent = BlockInfo::new(
        epoch_state.epoch, 
        100, // Non-existent round!
        HashValue::random(),
        HashValue::random(),
        0, 0, None
    );
    let forged_qc = QuorumCert::new(
        VoteData::new(fake_parent.clone(), fake_parent),
        LedgerInfoWithSignatures::new(
            LedgerInfo::dummy(),
            AggregateSignature::empty() // Invalid signature
        )
    );
    
    let malicious_block_3 = Block::new_for_testing(
        HashValue::random(),
        BlockData::new_for_testing(
            epoch_state.epoch,
            3,
            timestamp(),
            forged_qc, // Using forged QC!
            BlockType::Proposal,
        ),
        None
    );
    
    // Create legitimate ordered_proof for blocks 1,2,3
    let ordered_proof = create_valid_ledger_info_for_blocks(
        vec![&block_1, &block_2, &malicious_block_3],
        &epoch_state
    );
    
    // Create OrderedBlock message
    let ordered_block = OrderedBlock::new(
        vec![
            Arc::new(PipelinedBlock::new_ordered(block_1, OrderedBlockWindow::empty())),
            Arc::new(PipelinedBlock::new_ordered(block_2, OrderedBlockWindow::empty())),
            Arc::new(PipelinedBlock::new_ordered(malicious_block_3, OrderedBlockWindow::empty())),
        ],
        ordered_proof
    );
    
    // VULNERABILITY: ordered_block.verify_ordered_proof() will PASS
    // because the outer proof is valid
    assert!(ordered_block.verify_ordered_proof(&epoch_state).is_ok());
    
    // But when get_parent_pipeline_futs is called on malicious_block_3,
    // it will try to find parent at round 100 which doesn't exist,
    // causing either:
    // 1. Wrong parent to be used if round 100 happens to exist
    // 2. Execution to proceed with root as parent (incorrect)
    
    // The forged QC should fail verification:
    assert!(malicious_block_3.quorum_cert().verify(&epoch_state.verifier).is_err());
    
    // But currently, this verification is NEVER CALLED in the observer path!
}
```

**Notes:**

The vulnerability exists because the consensus observer architecture assumes publishers are honest. However, defense-in-depth principles require cryptographic verification of all consensus-critical data, even from semi-trusted sources. The QC contains the cryptographic proof that 2f+1 validators agreed on a block's parent relationship - this must be verified before trusting the relationship for execution ordering.

### Citations

**File:** consensus/src/consensus_observer/observer/block_data.rs (L164-179)
```rust
    pub fn get_parent_pipeline_futs(
        &self,
        block: &PipelinedBlock,
        pipeline_builder: &PipelineBuilder,
    ) -> Option<PipelineFutures> {
        if let Some(last_ordered_block) = self
            .ordered_block_store
            .get_ordered_block(block.epoch(), block.quorum_cert().certified_block().round())
        {
            // Return the parent block's pipeline futures
            last_ordered_block.last_block().pipeline_futs()
        } else {
            // Return the root block's pipeline futures
            Some(pipeline_builder.build_root(StateComputeResult::new_dummy(), self.root.clone()))
        }
    }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L727-742)
```rust
        // Verify the ordered block proof
        let epoch_state = self.get_epoch_state();
        if ordered_block.proof_block_info().epoch() == epoch_state.epoch {
            if let Err(error) = ordered_block.verify_ordered_proof(&epoch_state) {
                // Log the error and update the invalid message counter
                error!(
                    LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                        "Failed to verify ordered proof! Ignoring: {:?}, from peer: {:?}. Error: {:?}",
                        ordered_block.proof_block_info(),
                        peer_network_id,
                        error
                    ))
                );
                increment_invalid_message_counter(&peer_network_id, metrics::ORDERED_BLOCK_LABEL);
                return;
            }
```

**File:** consensus/src/consensus_observer/network/observer_message.rs (L225-266)
```rust
    /// Verifies the ordered blocks and returns an error if the data is invalid.
    /// Note: this does not check the ordered proof.
    pub fn verify_ordered_blocks(&self) -> Result<(), Error> {
        // Verify that we have at least one ordered block
        if self.blocks.is_empty() {
            return Err(Error::InvalidMessageError(
                "Received empty ordered block!".to_string(),
            ));
        }

        // Verify the last block ID matches the ordered proof block ID
        if self.last_block().id() != self.proof_block_info().id() {
            return Err(Error::InvalidMessageError(
                format!(
                    "Last ordered block ID does not match the ordered proof ID! Number of blocks: {:?}, Last ordered block ID: {:?}, Ordered proof ID: {:?}",
                    self.blocks.len(),
                    self.last_block().id(),
                    self.proof_block_info().id()
                )
            ));
        }

        // Verify the blocks are correctly chained together (from the last block to the first)
        let mut expected_parent_id = None;
        for block in self.blocks.iter().rev() {
            if let Some(expected_parent_id) = expected_parent_id {
                if block.id() != expected_parent_id {
                    return Err(Error::InvalidMessageError(
                        format!(
                            "Block parent ID does not match the expected parent ID! Block ID: {:?}, Expected parent ID: {:?}",
                            block.id(),
                            expected_parent_id
                        )
                    ));
                }
            }

            expected_parent_id = Some(block.parent_id());
        }

        Ok(())
    }
```

**File:** consensus/src/consensus_observer/network/observer_message.rs (L268-277)
```rust
    /// Verifies the ordered proof and returns an error if the proof is invalid
    pub fn verify_ordered_proof(&self, epoch_state: &EpochState) -> Result<(), Error> {
        epoch_state.verify(&self.ordered_proof).map_err(|error| {
            Error::InvalidMessageError(format!(
                "Failed to verify ordered proof ledger info: {:?}, Error: {:?}",
                self.proof_block_info(),
                error
            ))
        })
    }
```

**File:** consensus/consensus-types/src/quorum_cert.rs (L119-148)
```rust
    pub fn verify(&self, validator: &ValidatorVerifier) -> anyhow::Result<()> {
        let vote_hash = self.vote_data.hash();
        ensure!(
            self.ledger_info().ledger_info().consensus_data_hash() == vote_hash,
            "Quorum Cert's hash mismatch LedgerInfo"
        );
        // Genesis's QC is implicitly agreed upon, it doesn't have real signatures.
        // If someone sends us a QC on a fake genesis, it'll fail to insert into BlockStore
        // because of the round constraint.
        if self.certified_block().round() == 0 {
            ensure!(
                self.parent_block() == self.certified_block(),
                "Genesis QC has inconsistent parent block with certified block"
            );
            ensure!(
                self.certified_block() == self.ledger_info().ledger_info().commit_info(),
                "Genesis QC has inconsistent commit block with certified block"
            );
            ensure!(
                self.ledger_info().get_num_voters() == 0,
                "Genesis QC should not carry signatures"
            );
            return Ok(());
        }
        self.ledger_info()
            .verify_signatures(validator)
            .context("Fail to verify QuorumCert")?;
        self.vote_data.verify()?;
        Ok(())
    }
```

**File:** consensus/src/round_manager.rs (L886-896)
```rust
            // Some information in SyncInfo is ahead of what we have locally.
            // First verify the SyncInfo (didn't verify it in the yet).
            sync_info.verify(&self.epoch_state.verifier).map_err(|e| {
                error!(
                    SecurityEvent::InvalidSyncInfoMsg,
                    sync_info = sync_info,
                    remote_peer = author,
                    error = ?e,
                );
                VerifyError::from(e)
            })?;
```
