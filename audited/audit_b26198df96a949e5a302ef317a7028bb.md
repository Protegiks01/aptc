# Audit Report

## Title
Missing Validator Readiness Validation Before Language Version Activation Leading to Potential Consensus Split

## Summary
The Aptos blockchain lacks validation to ensure all validators support a new bytecode version before it is activated through governance. When feature flags enabling new bytecode versions (e.g., `VM_BINARY_FORMAT_V10`) are activated via `features::change_feature_flags_for_next_epoch()`, there is no mechanism to verify that all validators have upgraded their node software to support the new version. This can cause validators running different software versions to disagree on transaction execution results, breaking the deterministic execution invariant and potentially causing a consensus split.

## Finding Description
The Aptos governance system allows activation of new Move bytecode versions through feature flags without validating validator readiness: [1](#0-0) [2](#0-1) 

Language versions V2_4 and V2_5 are marked as unstable and map to newer bytecode versions. When governance activates the corresponding bytecode version feature flags, the process is: [3](#0-2) 

The feature changes are applied at epoch boundaries: [4](#0-3) [5](#0-4) 

Once activated, all validators read the updated `Features` on-chain config, which determines the maximum supported bytecode version: [6](#0-5) 

This maximum version is used to configure the VM's deserializer: [7](#0-6) 

**The vulnerability:** If validators are running mixed software versions (some supporting VERSION_10, others only supporting VERSION_9), and governance activates `VM_BINARY_FORMAT_V10`, validators will disagree on execution results:

1. **Upgraded validators**: Successfully deserialize and execute bytecode using VERSION_10 instructions
2. **Non-upgraded validators**: Fail to deserialize or execute VERSION_10 bytecode because their software implementation lacks support for new opcodes, even though the on-chain config indicates it should be supported

This violates the **Deterministic Execution** invariant: "All validators must produce identical state roots for identical blocks."

## Impact Explanation
This issue qualifies as **Critical Severity** under the Aptos Bug Bounty program as it can cause:

- **Consensus/Safety violations**: Validators will produce different execution results for the same transactions, leading to different state roots
- **Non-recoverable network partition**: Validators on different software versions cannot reach consensus, potentially requiring a hardfork to resolve
- **Total loss of liveness**: If enough validators are running old software, the network may be unable to achieve quorum on blocks containing new bytecode

The impact affects the core consensus safety guarantee of the blockchain, making this a critical vulnerability.

## Likelihood Explanation
While this requires governance approval and operational coordination failures, the likelihood is **moderate** because:

1. **No technical safeguard exists**: The code has no validation mechanism to prevent this scenario
2. **Governance proposals can pass quickly**: On testnets or in emergency situations, proposals might be rushed without ensuring all validators upgrade
3. **Validators may upgrade asynchronously**: Validators operated by different entities may upgrade on different schedules
4. **Silent failures are possible**: The system doesn't warn operators that a feature flag activation requires software upgrades

The attack doesn't require malicious intentâ€”it can occur through operational negligence or miscommunication during routine upgrades.

## Recommendation
Implement validator version checking before feature flag activation:

1. **Add validator version reporting**: Require validators to report their supported bytecode version as part of their validator info
2. **Add pre-activation validation**: Before applying pending feature flags in `features::on_new_epoch()`, verify that a supermajority (e.g., 2/3) of validators by stake support the new bytecode version
3. **Add governance proposal validation**: When submitting proposals to enable bytecode version feature flags, check that sufficient validators are ready

Example implementation approach in `features.move`:

```move
// Add validation before applying pending features
public(friend) fun on_new_epoch(framework: &signer) acquires Features, PendingFeatures {
    ensure_framework_signer(framework);
    if (exists<PendingFeatures>(@std)) {
        let pending = &PendingFeatures[@std];
        // Validate that validators support the new bytecode version
        // before activating it
        validate_validator_support(pending.features);
        
        let PendingFeatures { features } = move_from<PendingFeatures>(@std);
        if (exists<Features>(@std)) {
            Features[@std].features = features;
        } else {
            move_to(framework, Features { features })
        }
    }
}
```

## Proof of Concept
This vulnerability requires a multi-validator environment to demonstrate. Here's a conceptual test scenario:

```rust
// Conceptual PoC - requires custom testnet setup
#[test]
fn test_bytecode_version_consensus_split() {
    // Setup: Create testnet with 4 validators
    // - 2 validators running software supporting VERSION_10
    // - 2 validators running software supporting only VERSION_9
    
    // Step 1: Submit governance proposal to enable VM_BINARY_FORMAT_V10
    submit_governance_proposal(enable_feature(VM_BINARY_FORMAT_V10));
    
    // Step 2: Wait for epoch change (proposal activates)
    force_epoch_change();
    
    // Step 3: Publish module using VERSION_10 bytecode
    let module_v10 = compile_module_with_version(VERSION_10);
    submit_transaction(publish_module(module_v10));
    
    // Expected: Validators disagree on execution result
    // - V10-capable validators: Transaction succeeds
    // - V9-only validators: Transaction fails during deserialization
    // Result: Consensus split, no quorum achieved
    
    assert!(consensus_split_detected());
}
```

## Notes
The system relies on social/operational coordination rather than technical enforcement. While Aptos likely has operational procedures for coordinating validator upgrades, the absence of code-level validation represents a critical gap in the safety architecture. The compatibility tests demonstrate upgrade patterns but don't enforce pre-activation validation: [8](#0-7) 

This finding addresses the specific security question: there is definitively **no proper validation** that all validators support a new version before activation through governance.

### Citations

**File:** third_party/move/move-model/src/metadata.rs (L17-21)
```rust
pub const LATEST_LANGUAGE_VERSION_VALUE: LanguageVersion = LanguageVersion::V2_5;

/// Only stable versions are allowed on production networks
pub const LATEST_STABLE_LANGUAGE_VERSION_VALUE: LanguageVersion = LanguageVersion::V2_3;
pub const LATEST_STABLE_LANGUAGE_VERSION: &str = LATEST_STABLE_LANGUAGE_VERSION_VALUE.to_str();
```

**File:** third_party/move/move-model/src/metadata.rs (L286-294)
```rust
    /// Whether the language version is unstable. An unstable version
    /// should not be allowed on production networks.
    pub const fn unstable(self) -> bool {
        use LanguageVersion::*;
        match self {
            V1 | V2_0 | V2_1 | V2_2 | V2_3 => false,
            V2_4 | V2_5 => true,
        }
    }
```

**File:** aptos-move/framework/move-stdlib/sources/configs/features.move (L805-828)
```text
    public fun change_feature_flags_for_next_epoch(
        framework: &signer,
        enable: vector<u64>,
        disable: vector<u64>
    ) acquires PendingFeatures, Features {
        assert!(signer::address_of(framework) == @std, error::permission_denied(EFRAMEWORK_SIGNER_NEEDED));

        // Figure out the baseline feature vec that the diff will be applied to.
        let new_feature_vec = if (exists<PendingFeatures>(@std)) {
            // If there is a buffered feature vec, use it as the baseline.
            let PendingFeatures { features } = move_from<PendingFeatures>(@std);
            features
        } else if (exists<Features>(@std)) {
            // Otherwise, use the currently effective feature flag vec as the baseline, if it exists.
            Features[@std].features
        } else {
            // Otherwise, use an empty feature vec.
            vector[]
        };

        // Apply the diff and save it to the buffer.
        apply_diff(&mut new_feature_vec, enable, disable);
        move_to(framework, PendingFeatures { features: new_feature_vec });
    }
```

**File:** aptos-move/framework/move-stdlib/sources/configs/features.move (L834-844)
```text
    public fun on_new_epoch(framework: &signer) acquires Features, PendingFeatures {
        ensure_framework_signer(framework);
        if (exists<PendingFeatures>(@std)) {
            let PendingFeatures { features } = move_from<PendingFeatures>(@std);
            if (exists<Features>(@std)) {
                Features[@std].features = features;
            } else {
                move_to(framework, Features { features })
            }
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/reconfiguration_with_dkg.move (L46-61)
```text
    public(friend) fun finish(framework: &signer) {
        system_addresses::assert_aptos_framework(framework);
        dkg::try_clear_incomplete_session(framework);
        consensus_config::on_new_epoch(framework);
        execution_config::on_new_epoch(framework);
        gas_schedule::on_new_epoch(framework);
        std::version::on_new_epoch(framework);
        features::on_new_epoch(framework);
        jwk_consensus_config::on_new_epoch(framework);
        jwks::on_new_epoch(framework);
        keyless_account::on_new_epoch(framework);
        randomness_config_seqnum::on_new_epoch(framework);
        randomness_config::on_new_epoch(framework);
        randomness_api_v0_config::on_new_epoch(framework);
        reconfiguration::reconfigure();
    }
```

**File:** types/src/on_chain_config/aptos_features.rs (L485-499)
```rust
    pub fn get_max_binary_format_version(&self) -> u32 {
        if self.is_enabled(FeatureFlag::VM_BINARY_FORMAT_V10) {
            file_format_common::VERSION_10
        } else if self.is_enabled(FeatureFlag::VM_BINARY_FORMAT_V9) {
            file_format_common::VERSION_9
        } else if self.is_enabled(FeatureFlag::VM_BINARY_FORMAT_V8) {
            file_format_common::VERSION_8
        } else if self.is_enabled(FeatureFlag::VM_BINARY_FORMAT_V7) {
            file_format_common::VERSION_7
        } else if self.is_enabled(FeatureFlag::VM_BINARY_FORMAT_V6) {
            file_format_common::VERSION_6
        } else {
            file_format_common::VERSION_5
        }
    }
```

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L137-142)
```rust
pub fn aptos_prod_deserializer_config(features: &Features) -> DeserializerConfig {
    DeserializerConfig::new(
        features.get_max_binary_format_version(),
        features.get_max_identifier_size(),
    )
}
```

**File:** testsuite/testcases/src/compatibility_test.rs (L1-50)
```rust
// Copyright (c) Aptos Foundation
// Licensed pursuant to the Innovation-Enabling Source Code License, available at https://github.com/aptos-labs/aptos-core/blob/main/LICENSE

use crate::{batch_update_gradually, generate_traffic};
use anyhow::bail;
use aptos_forge::{NetworkContextSynchronizer, NetworkTest, Result, SwarmExt, Test};
use async_trait::async_trait;
use log::info;
use std::ops::DerefMut;
use tokio::time::Duration;

pub struct SimpleValidatorUpgrade;

impl SimpleValidatorUpgrade {
    pub const EPOCH_DURATION_SECS: u64 = 30;
}

impl Test for SimpleValidatorUpgrade {
    fn name(&self) -> &'static str {
        "compatibility::simple-validator-upgrade"
    }
}

#[async_trait]
impl NetworkTest for SimpleValidatorUpgrade {
    async fn run<'a>(&self, ctxa: NetworkContextSynchronizer<'a>) -> Result<()> {
        let upgrade_wait_for_healthy = true;
        let upgrade_node_delay = Duration::from_secs(20);
        let upgrade_max_wait = Duration::from_secs(40);

        let epoch_duration = Duration::from_secs(Self::EPOCH_DURATION_SECS);

        // Get the different versions we're testing with
        let (old_version, new_version) = {
            let mut versions = ctxa
                .ctx
                .lock()
                .await
                .swarm
                .read()
                .await
                .versions()
                .collect::<Vec<_>>();
            versions.sort();
            if versions.len() != 2 {
                bail!("exactly two different versions needed to run compat test");
            }

            (versions[0].clone(), versions[1].clone())
        };
```
