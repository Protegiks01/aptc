# Audit Report

## Title
ConsensusDB Lacks Schema Versioning Leading to Node Crash on Restart After Upgrades

## Summary
ConsensusDB does not implement schema version tracking or compatibility checking. When consensus data structures (Block, QuorumCert, Vote, etc.) undergo serialization format changes between software versions, validator nodes panic on restart when attempting to deserialize previously stored data, causing loss of consensus participation.

## Finding Description
The ConsensusDB implementation stores consensus-critical data (blocks, quorum certificates, votes, timeout certificates) using BCS (Binary Canonical Serialization) without any schema version metadata. [1](#0-0) 

When a validator node restarts, it attempts to recover consensus state by deserializing all stored data. [2](#0-1) 

The deserialization process uses `.expect()` which panics on failure rather than gracefully handling version mismatches. This affects:

1. **Last vote deserialization** - Critical for safety properties
2. **Highest 2-chain timeout certificate** - Critical for liveness
3. **Stored blocks** - Deserialized via BCS without version checks [3](#0-2) 

The consensus types like `BlockData` have no `#[serde(default)]` attributes on their fields, making them incompatible with schema evolution: [4](#0-3) 

Evidence of schema evolution exists - a deprecated column family "ordered_anchor_id" shows that database schema changes have occurred: [5](#0-4) 

## Impact Explanation
**High Severity** - This issue causes validator node crashes during rolling upgrades when:
- New required fields are added to BlockData, Block, QuorumCert, or related types
- Enum variant orders change in BlockType
- Field types are modified

During a network-wide rolling upgrade:
1. Validators restart with new binary versions
2. Deserialization of old ConsensusDB data fails
3. Nodes panic and cannot participate in consensus
4. If enough validators fail simultaneously, the network loses liveness
5. Manual intervention is required to clear ConsensusDB, losing safety-critical voting history

This breaks the **Consensus Safety** invariant (validators must maintain voting history) and **State Consistency** invariant (atomic state recovery on restart).

## Likelihood Explanation
**High likelihood** during version upgrades if:
- Developers add new fields to consensus types without backward compatibility annotations
- Rolling upgrades proceed faster than testing can detect incompatibilities
- Multiple validators restart within the same upgrade window

The existence of a deprecated CF and multiple BlockType variants (Proposal, ProposalExt, OptimisticProposal, DAGBlock) suggests schema evolution is ongoing: [6](#0-5) 

## Recommendation
Implement schema versioning for ConsensusDB:

1. **Add schema version metadata**: Store a version number in a dedicated CF when ConsensusDB is created/upgraded
2. **Version compatibility checks**: On startup, verify stored version is compatible with current code version
3. **Migration paths**: Implement migration logic for supported version transitions
4. **Graceful degradation**: If incompatible version detected, clear ConsensusDB and recover from ledger instead of panicking
5. **Backward-compatible types**: Add `#[serde(default)]` to optional fields in consensus types

Example version handling:
```rust
const CONSENSUS_DB_VERSION: u64 = 1;

impl ConsensusDB {
    pub fn new<P: AsRef<Path> + Clone>(db_root_path: P) -> Self {
        // ... existing code ...
        let db = Self { db };
        
        // Check/initialize version
        match db.get_version()? {
            None => db.set_version(CONSENSUS_DB_VERSION)?,
            Some(v) if v != CONSENSUS_DB_VERSION => {
                warn!("ConsensusDB version mismatch, clearing database");
                db.clear()?;
                db.set_version(CONSENSUS_DB_VERSION)?;
            },
            _ => {},
        }
        db
    }
}
```

## Proof of Concept
To reproduce:
1. Create a ConsensusDB with current schema
2. Store blocks using current Block/BlockData types
3. Modify BlockData to add a new required field (e.g., `new_field: u64`)
4. Attempt to restart and deserialize - node will panic with "unable to deserialize"

The panic occurs at: [7](#0-6) 

---

## Notes
While this vulnerability requires a software version upgrade scenario rather than direct external exploitation, it poses a critical operational risk during network upgrades. The lack of schema versioning violates consensus safety guarantees by preventing nodes from recovering their voting history, potentially leading to equivocation if validators restart without proper state recovery. This is particularly dangerous during coordinated upgrades when multiple validators may fail simultaneously.

### Citations

**File:** consensus/src/consensusdb/mod.rs (L51-78)
```rust
    pub fn new<P: AsRef<Path> + Clone>(db_root_path: P) -> Self {
        let column_families = vec![
            /* UNUSED CF = */ DEFAULT_COLUMN_FAMILY_NAME,
            BLOCK_CF_NAME,
            QC_CF_NAME,
            SINGLE_ENTRY_CF_NAME,
            NODE_CF_NAME,
            CERTIFIED_NODE_CF_NAME,
            DAG_VOTE_CF_NAME,
            "ordered_anchor_id", // deprecated CF
        ];

        let path = db_root_path.as_ref().join(CONSENSUS_DB_NAME);
        let instant = Instant::now();
        let mut opts = Options::default();
        opts.create_if_missing(true);
        opts.create_missing_column_families(true);
        let db = DB::open(path.clone(), "consensus", column_families, &opts)
            .expect("ConsensusDB open failed; unable to continue");

        info!(
            "Opened ConsensusDB at {:?} in {} ms",
            path,
            instant.elapsed().as_millis()
        );

        Self { db }
    }
```

**File:** consensus/src/persistent_liveness_storage.rs (L519-532)
```rust
    fn start(&self, order_vote_enabled: bool, window_size: Option<u64>) -> LivenessStorageData {
        info!("Start consensus recovery.");
        let raw_data = self
            .db
            .get_data()
            .expect("unable to recover consensus data");

        let last_vote = raw_data
            .0
            .map(|bytes| bcs::from_bytes(&bytes[..]).expect("unable to deserialize last vote"));

        let highest_2chain_timeout_cert = raw_data.1.map(|b| {
            bcs::from_bytes(&b).expect("unable to deserialize highest 2-chain timeout cert")
        });
```

**File:** consensus/src/consensusdb/schema/block/mod.rs (L35-43)
```rust
impl ValueCodec<BlockSchema> for Block {
    fn encode_value(&self) -> Result<Vec<u8>> {
        Ok(bcs::to_bytes(&self)?)
    }

    fn decode_value(data: &[u8]) -> Result<Self> {
        Ok(bcs::from_bytes(data)?)
    }
}
```

**File:** consensus/consensus-types/src/block_data.rs (L26-70)
```rust
#[derive(Deserialize, Serialize, Clone, Debug, PartialEq, Eq)]
pub enum BlockType {
    Proposal {
        /// T of the block (e.g. one or more transaction(s)
        payload: Payload,
        /// Author of the block that can be validated by the author's public key and the signature
        author: Author,
        /// Failed authors from the parent's block to this block.
        /// I.e. the list of consecutive proposers from the
        /// immediately preceeding rounds that didn't produce a successful block.
        failed_authors: Vec<(Round, Author)>,
    },
    /// NIL blocks don't have authors or signatures: they're generated upon timeouts to fill in the
    /// gaps in the rounds.
    NilBlock {
        /// Failed authors from the parent's block to this block (including this block)
        /// I.e. the list of consecutive proposers from the
        /// immediately preceeding rounds that didn't produce a successful block.
        failed_authors: Vec<(Round, Author)>,
    },
    /// A genesis block is the first committed block in any epoch that is identically constructed on
    /// all validators by any (potentially different) LedgerInfo that justifies the epoch change
    /// from the previous epoch.  The genesis block is used as the first root block of the
    /// BlockTree for all epochs.
    Genesis,

    /// Proposal with extensions (e.g. system transactions).
    ProposalExt(ProposalExt),

    /// Optimistic proposal.
    OptimisticProposal(OptBlockBody),

    /// A virtual block that's constructed by nodes from DAG, this is purely a local thing so
    /// we hide it from serde
    #[serde(skip_deserializing)]
    DAGBlock {
        author: Author,
        failed_authors: Vec<(Round, Author)>,
        validator_txns: Vec<ValidatorTransaction>,
        payload: Payload,
        node_digests: Vec<HashValue>,
        parent_block_id: HashValue,
        parents_bitvec: BitVec,
    },
}
```

**File:** consensus/consensus-types/src/block_data.rs (L72-103)
```rust
#[derive(Deserialize, Serialize, Clone, Debug, PartialEq, Eq, CryptoHasher)]
/// Block has the core data of a consensus block that should be persistent when necessary.
/// Each block must know the id of its parent and keep the QuorurmCertificate to that parent.
pub struct BlockData {
    /// Epoch number corresponds to the set of validators that are active for this block.
    epoch: u64,
    /// The round of a block is an internal monotonically increasing counter used by Consensus
    /// protocol.
    round: Round,
    /// The approximate physical time a block is proposed by a proposer.  This timestamp is used
    /// for
    /// * Time-dependent logic in smart contracts (the current time of execution)
    /// * Clients determining if they are relatively up-to-date with respect to the block chain.
    ///
    /// It makes the following guarantees:
    ///   1. Time Monotonicity: Time is monotonically increasing in the block chain.
    ///      (i.e. If H1 < H2, H1.Time < H2.Time).
    ///   2. If a block of transactions B is agreed on with timestamp T, then at least
    ///      f+1 honest validators think that T is in the past. An honest validator will
    ///      only vote on a block when its own clock >= timestamp T.
    ///   3. If a block of transactions B has a QC with timestamp T, an honest validator
    ///      will not serve such a block to other validators until its own clock >= timestamp T.
    ///   4. Current: an honest validator is not issuing blocks with a timestamp in the
    ///       future. Currently we consider a block is malicious if it was issued more
    ///       that 5 minutes in the future.
    timestamp_usecs: u64,
    /// Contains the quorum certified ancestor and whether the quorum certified ancestor was
    /// voted on successfully
    quorum_cert: QuorumCert,
    /// If a block is a real proposal, contains its author and signature.
    block_type: BlockType,
}
```
