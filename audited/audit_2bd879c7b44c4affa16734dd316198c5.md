# Audit Report

## Title
Type Parameter Bypass in MoveStructTagFilter Allows Matching of Unintended Generic Struct Instances

## Summary
The `MoveStructTagFilter` in the Aptos indexer gRPC transaction filtering system does not validate generic type parameters when matching Move struct tags. This allows attackers to bypass filters intended for specific generic struct instances (e.g., `Coin<AptosCoin>`) by creating structs with the same base name but different type parameters (e.g., `Coin<MaliciousCoin>`). [1](#0-0) 

## Finding Description
Move supports generic types using type parameters, which is fundamental to the Aptos framework's design. The `Coin` struct, for example, uses a phantom type parameter to distinguish different coin types: [2](#0-1) 

However, the `MoveStructTagFilter` proto definition only includes three fields (`address`, `module`, `name`) and completely omits the `generic_type_params` field that exists in `MoveStructTag`: [3](#0-2) 

The matching logic in the transaction filter implementation only checks these three fields: [4](#0-3) 

This means a filter configured to match `0x1::coin::Coin<0x1::aptos_coin::AptosCoin>` will also incorrectly match `0x1::coin::Coin<0xAttacker::malicious_coin::MaliciousCoin>`, as both have the same address (`0x1`), module (`coin`), and name (`Coin`).

**Attack Scenario:**
1. Attacker deploys a malicious coin module `MaliciousCoin`
2. User configures indexer filter to track only `Coin<AptosCoin>` events for their portfolio tracker
3. Attacker creates `Coin<MaliciousCoin>` events with the same struct name
4. User's application receives and processes these malicious events
5. Application makes incorrect financial decisions based on mixed legitimate/malicious data

## Impact Explanation
This vulnerability falls under **Medium Severity** as defined by the Aptos bug bounty program. While it doesn't directly compromise blockchain consensus or cause immediate loss of funds at the protocol level, it can lead to:

- **State inconsistencies in dependent applications**: Applications relying on filtered indexer data may process events from unintended generic type instances
- **Limited funds loss**: Trading bots, portfolio trackers, or DeFi applications making decisions based on filtered events could execute incorrect transactions
- **Data integrity violations**: Indexer databases may contain mixed data from different generic instances under the same filter

The issue requires intervention at the application level to distinguish between intended and unintended matches, fitting the Medium severity category of "State inconsistencies requiring intervention."

## Likelihood Explanation
This vulnerability has **HIGH likelihood** of exploitation because:

1. **No special privileges required**: Any user can create Move modules with generic structs sharing common base names
2. **Generic types are pervasive**: The Aptos framework extensively uses generics (`Coin<T>`, `Option<T>`, `Table<K,V>`)
3. **Filters are commonly used**: Applications frequently filter events by struct type for indexing and monitoring
4. **Easy to trigger**: Simply deploying a module with a generic struct matching a common name triggers the issue
5. **Hard to detect**: Users may not notice they're receiving extra events unless they carefully validate type parameters

## Recommendation
Add support for matching generic type parameters in the `MoveStructTagFilter`. This requires:

1. **Extend the proto definition** to include type parameters:
```protobuf
message MoveStructTagFilter {
  optional string address = 1;
  optional string module = 2;
  optional string name = 3;
  repeated MoveTypeFilter generic_type_params = 4;  // NEW
}

message MoveTypeFilter {
  // Define filtering logic for MoveType
  oneof type {
    MoveStructTagFilter struct = 1;
    // Add cases for primitives, vectors, references
  }
}
```

2. **Update the Rust implementation** to recursively match type parameters:
```rust
fn matches(&self, struct_tag: &MoveStructTag) -> bool {
    self.get_standardized_address()
        .matches(&standardize_address(&struct_tag.address))
        && self.module.matches(&struct_tag.module)
        && self.name.matches(&struct_tag.name)
        && self.generic_type_params.matches_vec(&struct_tag.generic_type_params)  // NEW
}
```

3. **Maintain backward compatibility**: If `generic_type_params` filter is `None`, match any type parameters (existing behavior). If specified, enforce exact matching.

## Proof of Concept
```rust
// File: ecosystem/indexer-grpc/transaction-filter/tests/type_param_bypass_test.rs

use aptos_protos::transaction::v1::{MoveStructTag, MoveType, move_type::Content};
use aptos_transaction_filter::{MoveStructTagFilter, traits::Filterable};

#[test]
fn test_type_parameter_bypass() {
    // Create a filter intended to match Coin<AptosCoin> only
    let filter = MoveStructTagFilter {
        address: Some("0x1".to_string()),
        module: Some("coin".to_string()),
        name: Some("Coin".to_string()),
        standardized_address: Default::default(),
    };

    // This should match (intended case)
    let aptos_coin_tag = MoveStructTag {
        address: "0x1".to_string(),
        module: "coin".to_string(),
        name: "Coin".to_string(),
        generic_type_params: vec![create_aptos_coin_type()],
    };
    assert!(filter.matches(&aptos_coin_tag));

    // This ALSO matches but SHOULD NOT (vulnerability)
    let malicious_coin_tag = MoveStructTag {
        address: "0x1".to_string(),
        module: "coin".to_string(),
        name: "Coin".to_string(),
        generic_type_params: vec![create_malicious_coin_type()],
    };
    
    // VULNERABILITY: This assertion passes, but it should fail
    // The filter matches Coin<MaliciousCoin> when it should only match Coin<AptosCoin>
    assert!(filter.matches(&malicious_coin_tag), 
        "VULNERABILITY: Filter matches Coin with wrong type parameter!");
}

fn create_aptos_coin_type() -> MoveType {
    MoveType {
        content: Some(Content::Struct(MoveStructTag {
            address: "0x1".to_string(),
            module: "aptos_coin".to_string(),
            name: "AptosCoin".to_string(),
            generic_type_params: vec![],
        })),
    }
}

fn create_malicious_coin_type() -> MoveType {
    MoveType {
        content: Some(Content::Struct(MoveStructTag {
            address: "0xAttacker".to_string(),
            module: "malicious_coin".to_string(),
            name: "MaliciousCoin".to_string(),
            generic_type_params: vec![],
        })),
    }
}
```

## Notes
This vulnerability is specific to the indexer filtering layer and does not affect blockchain consensus or the Move VM execution layer. However, it breaks the security guarantee that filters provide precise control over which events are delivered to clients. Applications depending on accurate filtering for financial decisions or access control may be impacted.

### Citations

**File:** protos/proto/aptos/indexer/v1/filter.proto (L39-43)
```text
message MoveStructTagFilter {
  optional string address = 1;
  optional string module = 2;
  optional string name = 3;
}
```

**File:** aptos-move/framework/aptos-framework/sources/coin.move (L132-135)
```text
    struct Coin<phantom CoinType> has store {
        /// Amount of coin this address has.
        value: u64
    }
```

**File:** protos/rust/src/pb/aptos.transaction.v1.rs (L903-912)
```rust
pub struct MoveStructTag {
    #[prost(string, tag="1")]
    pub address: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub module: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, repeated, tag="4")]
    pub generic_type_params: ::prost::alloc::vec::Vec<MoveType>,
}
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/filters/move_module.rs (L84-89)
```rust
    fn matches(&self, struct_tag: &MoveStructTag) -> bool {
        self.get_standardized_address()
            .matches(&standardize_address(&struct_tag.address))
            && self.module.matches(&struct_tag.module)
            && self.name.matches(&struct_tag.name)
    }
```
