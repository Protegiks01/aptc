# Audit Report

## Title
Missing Validation on `gas_unit_scaling_factor` Enables Network-Wide DoS via Governance Misconfiguration

## Summary
The gas schedule update mechanism lacks validation checks on the `gas_unit_scaling_factor` parameter, allowing governance proposals to set arbitrarily low values that make all transactions prohibitively expensive, causing a network-wide denial of service.

## Finding Description

The Aptos blockchain uses a `gas_unit_scaling_factor` to convert between user-facing gas units and internal gas units. This parameter is stored on-chain in `GasScheduleV2` and can be updated via governance proposals. [1](#0-0) 

The conversion from `GasUnit` to `InternalGasUnit` multiplies by this scaling factor: [2](#0-1) 

When checking if a transaction has sufficient gas, the system converts internal gas back to gas units by dividing by the scaling factor: [3](#0-2) 

**The Critical Issue**: The governance update functions accept any non-decreasing feature version but perform NO validation on the actual gas parameter values: [4](#0-3) 

The only protection is that a scaling factor of 0 gets converted to 1: [5](#0-4) 

**Attack Scenario (Accidental or Malicious)**:
1. A governance proposal sets `gas_unit_scaling_factor` to 1 (instead of the standard 1,000,000)
2. The proposal passes governance voting and is applied at the next epoch
3. For the same internal gas consumption, users now need 1,000,000× more gas units
4. Since `gas_unit_price` is in "fee per gas unit," users must pay 1,000,000× more APT
5. A minimal transaction costing 0.000003 APT now costs 3 APT, making the network unusable

**Example Calculation**:
- Normal: `min_transaction_gas_units = 2,760,000 InternalGas ÷ 1,000,000 = 2.76 Gas` → 2.76 × 100 = 276 octas
- Attack: `min_transaction_gas_units = 2,760,000 InternalGas ÷ 1 = 2,760,000 Gas` → 2,760,000 × 100 = 276,000,000 octas (2.76 APT)

This breaks the **Resource Limits** invariant: "All operations must respect gas, storage, and computational limits" by making legitimate operations economically impossible.

## Impact Explanation

**Critical Severity** - This qualifies as "Total loss of liveness/network availability" per the Aptos bug bounty criteria:

- **Network-wide DoS**: All users unable to submit affordable transactions
- **Consensus continues but network unusable**: Validators can still produce blocks, but no user transactions can be processed economically
- **Recovery requires governance action**: Fixing requires another proposal, but if transactions are too expensive, users cannot afford to vote
- **Potential hardfork required**: If governance cannot recover due to transaction costs, network may require emergency intervention

The vulnerability creates a scenario where even trusted governance participants (through human error or compromise) can render the entire network unusable without any technical safeguards to prevent or detect the misconfiguration before it takes effect.

## Likelihood Explanation

**Medium-to-High Likelihood**:

- **Human Error**: Proposal generation scripts could have bugs or typos (e.g., forgetting to add zeros: typing "1" instead of "1000000")
- **No Pre-Execution Validation**: The gas schedule update functions check only feature version, not parameter sanity
- **No Simulation Safeguards**: There's no requirement to simulate the impact before applying
- **Governance Compromise**: While governance is trusted, compromise scenarios (key theft, malicious insider) are not impossible
- **Historical Precedent**: Similar parameter misconfiguration bugs have affected other blockchains (e.g., Ethereum gas price incidents)

The lack of any validation makes this a "one typo away" scenario.

## Recommendation

Add validation checks in the gas schedule update functions to enforce reasonable bounds on critical parameters:

```rust
// In gas_schedule.move, add validation function
public fun validate_gas_schedule(schedule: &GasScheduleV2): bool {
    // Extract gas_unit_scaling_factor from entries
    let i = 0;
    let len = vector::length(&schedule.entries);
    while (i < len) {
        let entry = vector::borrow(&schedule.entries, i);
        if (entry.key == utf8(b"txn.gas_unit_scaling_factor")) {
            // Enforce reasonable bounds: between 100,000 and 10,000,000
            assert!(entry.val >= 100000 && entry.val <= 10000000, 
                   error::invalid_argument(EINVALID_GAS_PARAMETER));
            return true
        };
        i = i + 1;
    };
    false
}

public fun set_for_next_epoch(aptos_framework: &signer, gas_schedule_blob: vector<u8>) acquires GasScheduleV2 {
    system_addresses::assert_aptos_framework(aptos_framework);
    assert!(!vector::is_empty(&gas_schedule_blob), error::invalid_argument(EINVALID_GAS_SCHEDULE));
    let new_gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
    
    // ADD THIS VALIDATION
    assert!(validate_gas_schedule(&new_gas_schedule), 
           error::invalid_argument(EINVALID_GAS_SCHEDULE));
    
    if (exists<GasScheduleV2>(@aptos_framework)) {
        let cur_gas_schedule = borrow_global<GasScheduleV2>(@aptos_framework);
        assert!(
            new_gas_schedule.feature_version >= cur_gas_schedule.feature_version,
            error::invalid_argument(EINVALID_GAS_FEATURE_VERSION)
        );
    };
    config_buffer::upsert(new_gas_schedule);
}
```

Additionally:
1. Add similar validation for other critical gas parameters (max_price_per_gas_unit, min_price_per_gas_unit, etc.)
2. Implement simulation/testing requirements for gas schedule updates before governance voting
3. Add monitoring/alerting for unusual gas parameter values

## Proof of Concept

```rust
// Test demonstrating the vulnerability
// File: aptos-move/framework/aptos-framework/sources/configs/gas_schedule_test.move

#[test_only]
module aptos_framework::gas_schedule_vulnerability_test {
    use aptos_framework::gas_schedule;
    use std::vector;
    
    #[test(framework = @0x1)]
    fun test_low_scaling_factor_causes_overpricing(framework: signer) {
        // Create a malicious gas schedule with scaling_factor = 1
        let malicious_schedule = create_gas_schedule_with_scaling_factor(1);
        let malicious_blob = bcs::to_bytes(&malicious_schedule);
        
        // This SHOULD fail with validation error, but currently succeeds
        gas_schedule::set_for_next_epoch(&framework, malicious_blob);
        
        // After epoch transition, all transactions would require 1,000,000x more gas units
        // A transaction that normally costs 3 Gas now costs 3,000,000 Gas
        // At 100 octas per Gas, this is 300,000,000 octas = 3 APT instead of 0.000003 APT
        
        // Network becomes unusable due to prohibitive transaction costs
    }
    
    fun create_gas_schedule_with_scaling_factor(factor: u64): GasScheduleV2 {
        let entries = vector::empty<GasEntry>();
        // ... populate with normal values except scaling_factor = factor
        GasScheduleV2 { feature_version: 20, entries }
    }
}
```

**Notes**

This vulnerability represents a critical gap in governance safeguards. While governance is considered trusted, the lack of technical validation means a single human error or compromised governance account can render the entire network unusable. The fix is straightforward: add bounds checking on critical gas parameters before accepting governance updates. The standard `gas_unit_scaling_factor` value is 1,000,000, and reasonable bounds would be ±1 order of magnitude (100,000 to 10,000,000) to allow for adjustments while preventing catastrophic misconfigurations.

### Citations

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L83-86)
```rust
            gas_unit_scaling_factor: GasScalingFactor,
            "gas_unit_scaling_factor",
            GAS_SCALING_FACTOR
        ],
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L293-298)
```rust
    pub fn scaling_factor(&self) -> GasScalingFactor {
        match u64::from(self.gas_unit_scaling_factor) {
            0 => 1.into(),
            x => x.into(),
        }
    }
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L313-317)
```rust
impl ToUnitWithParams<TransactionGasParameters, InternalGasUnit> for GasUnit {
    fn multiplier(params: &TransactionGasParameters) -> u64 {
        params.scaling_factor().into()
    }
}
```

**File:** aptos-move/aptos-vm/src/gas.rs (L154-158)
```rust
    let intrinsic_gas = txn_gas_params
        .calculate_intrinsic_gas(raw_bytes_len)
        .evaluate(gas_feature_version, &gas_params.vm);
    let total_rounded: Gas =
        (intrinsic_gas + keyless + slh_dsa_sha2_128s).to_unit_round_up_with_params(txn_gas_params);
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L91-103)
```text
    public fun set_for_next_epoch(aptos_framework: &signer, gas_schedule_blob: vector<u8>) acquires GasScheduleV2 {
        system_addresses::assert_aptos_framework(aptos_framework);
        assert!(!vector::is_empty(&gas_schedule_blob), error::invalid_argument(EINVALID_GAS_SCHEDULE));
        let new_gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
        if (exists<GasScheduleV2>(@aptos_framework)) {
            let cur_gas_schedule = borrow_global<GasScheduleV2>(@aptos_framework);
            assert!(
                new_gas_schedule.feature_version >= cur_gas_schedule.feature_version,
                error::invalid_argument(EINVALID_GAS_FEATURE_VERSION)
            );
        };
        config_buffer::upsert(new_gas_schedule);
    }
```
