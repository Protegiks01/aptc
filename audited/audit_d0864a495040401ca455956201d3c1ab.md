# Audit Report

## Title
Unauthenticated Backup Service API Exposes All Historical Blockchain Data Including Decrypted Private Transaction Payloads

## Summary
The backup service API endpoint lacks authentication and authorization controls, allowing any network peer with access to port 6186 to extract all historical blockchain transactions. Production fullnode configurations explicitly bind this service to `0.0.0.0:6186`, exposing it on all network interfaces without authentication. This enables unauthorized bulk extraction of sensitive data, including decrypted payloads from encrypted transactions that users expected to remain private.

## Finding Description

The `BackupHandler::get_transaction_iter()` function provides direct access to all historical transactions without any authentication or authorization checks: [1](#0-0) 

This function is exposed via an HTTP API in the backup service with no authentication middleware: [2](#0-1) 

The backup service starts an unauthenticated HTTP server using warp: [3](#0-2) 

While the default configuration binds to localhost for security: [4](#0-3) 

Production fullnode deployments explicitly override this to bind on all network interfaces: [5](#0-4) 

The Kubernetes deployment exposes this port as an internal service: [6](#0-5) 

**Attack Path:**
1. Attacker gains network access to the fullnode (e.g., compromised pod in Kubernetes cluster, misconfigured network policy, or cloud networking misconfiguration)
2. Attacker sends HTTP GET request: `GET http://<fullnode-ip>:6186/transactions/0/1000000`
3. Service returns tuple of `(Transaction, PersistedAuxiliaryInfo, TransactionInfo, Vec<ContractEvent>, WriteSet)` for all requested transactions
4. For transactions with encrypted payloads, the data includes the `EncryptedPayload::Decrypted` variant containing both ciphertext AND plaintext executable

The `EncryptedPayload` type stores decrypted transaction data alongside the original ciphertext: [7](#0-6) 

This means transactions that users submitted with encryption for privacy are stored post-execution with their plaintext visible, and the backup service exposes this decrypted data without authentication.

## Impact Explanation

**Medium Severity** - This qualifies as an information disclosure vulnerability with moderate impact:

1. **Privacy Violation**: Users submitting encrypted transactions expect privacy, but their decrypted payloads are accessible to unauthorized parties through this unauthenticated endpoint

2. **Bulk Data Extraction**: Unlike normal blockchain transparency where nodes must sync the entire chain, this API allows targeted bulk extraction of specific transaction ranges without authentication or rate limiting

3. **No Audit Trail**: The lack of authentication means there's no logging of who accessed what data, preventing detection of data exfiltration attempts

4. **Configuration Dependency**: Security relies entirely on network isolation, but production configurations explicitly bind to `0.0.0.0:6186`, increasing attack surface

5. **Defense-in-Depth Failure**: Even internal services should implement authentication as a security layer against network compromise or misconfiguration

While blockchain data is generally public, the combination of unauthenticated access, production configuration exposing all interfaces, and inclusion of decrypted "private" transaction data constitutes a legitimate security concern beyond normal blockchain transparency.

## Likelihood Explanation

**Medium-High Likelihood** due to:

1. **Production Configuration**: The official fullnode Helm chart explicitly sets `backup_service_address: "0.0.0.0:6186"`, making this the default for deployed nodes

2. **Attack Prerequisites**: 
   - Attacker needs network access to port 6186
   - In Kubernetes: any compromised pod in the cluster can access the service
   - In cloud deployments: VPC/network misconfiguration could expose the port
   - No special privileges or cryptographic keys required

3. **Ease of Exploitation**: Simple HTTP GET request with no authentication challenges

4. **Common Scenarios**:
   - Misconfigured cloud security groups
   - Compromised monitoring/logging pods with cluster access
   - Insider threats from cluster operators
   - Network policy misconfigurations

## Recommendation

Implement authentication and authorization for the backup service API:

**Option 1: API Key Authentication**
```rust
// In storage/backup/backup-service/src/lib.rs
pub fn start_backup_service(
    address: SocketAddr, 
    db: Arc<AptosDB>,
    api_key: Option<String>,  // Add API key parameter
) -> Runtime {
    let backup_handler = db.get_backup_handler();
    let routes = get_routes(backup_handler);
    
    // Add authentication middleware
    let routes = if let Some(key) = api_key {
        routes.and(warp::header::exact("Authorization", key.as_str()))
            .boxed()
    } else {
        routes
    };
    
    // ... rest of implementation
}
```

**Option 2: mTLS (Mutual TLS)**
- Require client certificates for all backup service connections
- Validate certificates against a trusted CA
- Provides strong authentication and encryption

**Option 3: Network Policy Enforcement**
- Add explicit Kubernetes NetworkPolicy restricting backup service access
- Only allow specific backup coordinator pods to access port 6186
- Document security implications of changing `backup_service_address`

**Configuration Enhancement**
```yaml
# In fullnode-base.yaml, add security warning
storage:
  backup_service_address: "127.0.0.1:6186"  # Change default back to localhost
  # SECURITY WARNING: Binding to 0.0.0.0 exposes all blockchain data without authentication.
  # Only use when protected by network policies or authentication proxy.
```

**Documentation Addition**
Add to `storage/README.md`:
```markdown
## Backup Service Security

⚠️ **SECURITY NOTICE**: The backup service provides unauthenticated access to all 
historical blockchain data. By default it binds to localhost (127.0.0.1:6186). 

If you need to expose it on other interfaces:
- Implement authentication at the network layer (mTLS, API gateway)
- Use Kubernetes NetworkPolicies to restrict access
- Never expose port 6186 to untrusted networks
- Monitor access logs for unauthorized usage
```

## Proof of Concept

**Step 1: Deploy a fullnode with default configuration**
```bash
# Using the default Helm chart
helm install fullnode aptos/fullnode --set backup.enable=true
```

**Step 2: From another pod in the cluster, access the backup service**
```bash
# Get fullnode service IP
FULLNODE_IP=$(kubectl get svc <fullnode-service> -o jsonpath='{.spec.clusterIP}')

# Extract first 100 transactions without authentication
curl "http://${FULLNODE_IP}:6186/transactions/0/100" > transactions.bcs

# Decode BCS-encoded response to see transaction data
# All transaction details including decrypted payloads are exposed
```

**Step 3: Demonstrate lack of authentication**
```bash
# No authentication headers required
curl -v "http://${FULLNODE_IP}:6186/transactions/0/1" 
# Returns: 200 OK with transaction data

# No rate limiting
for i in {1..1000}; do
  curl "http://${FULLNODE_IP}:6186/transactions/$((i*1000))/1000" &
done
# All requests succeed, enabling bulk data extraction
```

**Rust Test to Verify Lack of Authentication:**
```rust
#[tokio::test]
async fn test_backup_service_no_auth() {
    use aptos_config::utils::get_available_port;
    use std::net::{IpAddr, Ipv4Addr, SocketAddr};
    
    let tmpdir = TempPath::new();
    let db = Arc::new(AptosDB::new_for_test(&tmpdir));
    let port = get_available_port();
    let addr = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(0, 0, 0, 0)), port);
    
    let _rt = start_backup_service(addr, db);
    
    // Unauthenticated request should fail but succeeds
    let client = reqwest::Client::new();
    let resp = client
        .get(format!("http://127.0.0.1:{}/transactions/0/10", port))
        .send()
        .await
        .unwrap();
    
    // BUG: Returns 200 OK without any authentication
    assert_eq!(resp.status(), 200);  
    // EXPECTED: Should return 401 Unauthorized
}
```

**Notes**

This vulnerability represents a defense-in-depth failure where security relies entirely on network isolation. While Aptos blockchain data is generally public, the combination of factors makes this a legitimate security concern:

1. **Encrypted Transactions**: The `EncryptedPayload::Decrypted` variant stored in the ledger contains plaintext that users expected to remain confidential
2. **Ease of Bulk Extraction**: Unlike syncing a full node, this API enables targeted extraction of specific transaction ranges
3. **Production Exposure**: The official deployment configuration binds to all interfaces, contradicting the documented default of localhost-only
4. **Zero Authentication**: No authentication, authorization, rate limiting, or audit logging

The recommended fix is to add authentication (API keys or mTLS) while maintaining the network isolation as a secondary control. This provides defense-in-depth against network misconfiguration or compromise.

### Citations

**File:** storage/aptosdb/src/backup/backup_handler.rs (L41-109)
```rust
    pub fn get_transaction_iter(
        &self,
        start_version: Version,
        num_transactions: usize,
    ) -> Result<
        impl Iterator<
                Item = Result<(
                    Transaction,
                    PersistedAuxiliaryInfo,
                    TransactionInfo,
                    Vec<ContractEvent>,
                    WriteSet,
                )>,
            > + '_,
    > {
        let txn_iter = self
            .ledger_db
            .transaction_db()
            .get_transaction_iter(start_version, num_transactions)?;
        let mut txn_info_iter = self
            .ledger_db
            .transaction_info_db()
            .get_transaction_info_iter(start_version, num_transactions)?;
        let mut event_vec_iter = self
            .ledger_db
            .event_db()
            .get_events_by_version_iter(start_version, num_transactions)?;
        let mut write_set_iter = self
            .ledger_db
            .write_set_db()
            .get_write_set_iter(start_version, num_transactions)?;
        let mut persisted_aux_info_iter = self
            .ledger_db
            .persisted_auxiliary_info_db()
            .get_persisted_auxiliary_info_iter(start_version, num_transactions)?;

        let zipped = txn_iter.enumerate().map(move |(idx, txn_res)| {
            let version = start_version + idx as u64; // overflow is impossible since it's check upon txn_iter construction.

            let txn = txn_res?;
            let txn_info = txn_info_iter.next().ok_or_else(|| {
                AptosDbError::NotFound(format!(
                    "TransactionInfo not found when Transaction exists, version {}",
                    version
                ))
            })??;
            let event_vec = event_vec_iter.next().ok_or_else(|| {
                AptosDbError::NotFound(format!(
                    "Events not found when Transaction exists., version {}",
                    version
                ))
            })??;
            let write_set = write_set_iter.next().ok_or_else(|| {
                AptosDbError::NotFound(format!(
                    "WriteSet not found when Transaction exists, version {}",
                    version
                ))
            })??;
            let persisted_aux_info = persisted_aux_info_iter.next().ok_or_else(|| {
                AptosDbError::NotFound(format!(
                    "PersistedAuxiliaryInfo not found when Transaction exists, version {}",
                    version
                ))
            })??;
            BACKUP_TXN_VERSION.set(version as i64);
            Ok((txn, persisted_aux_info, txn_info, event_vec, write_set))
        });
        Ok(zipped)
    }
```

**File:** storage/backup/backup-service/src/handlers/mod.rs (L101-110)
```rust
    // GET transactions/<start_version>/<num_transactions>
    let bh = backup_handler.clone();
    let transactions = warp::path!(Version / usize)
        .map(move |start_version, num_transactions| {
            reply_with_bytes_sender(&bh, TRANSACTIONS, move |bh, sender| {
                bh.get_transaction_iter(start_version, num_transactions)?
                    .try_for_each(|record_res| sender.send_size_prefixed_bcs_bytes(record_res?))
            })
        })
        .recover(handle_rejection);
```

**File:** storage/backup/backup-service/src/lib.rs (L12-30)
```rust
pub fn start_backup_service(address: SocketAddr, db: Arc<AptosDB>) -> Runtime {
    let backup_handler = db.get_backup_handler();
    let routes = get_routes(backup_handler);

    let runtime = aptos_runtimes::spawn_named_runtime("backup".into(), None);

    // Ensure that we actually bind to the socket first before spawning the
    // server tasks. This helps in tests to prevent races where a client attempts
    // to make a request before the server task is actually listening on the
    // socket.
    //
    // Note: we need to enter the runtime context first to actually bind, since
    //       tokio TcpListener can only be bound inside a tokio context.
    let _guard = runtime.enter();
    let server = warp::serve(routes).bind(address);
    runtime.handle().spawn(server);
    info!("Backup service spawned.");
    runtime
}
```

**File:** config/src/config/storage_config.rs (L433-436)
```rust
impl Default for StorageConfig {
    fn default() -> StorageConfig {
        StorageConfig {
            backup_service_address: SocketAddr::new(IpAddr::V4(Ipv4Addr::LOCALHOST), 6186),
```

**File:** terraform/helm/fullnode/files/fullnode-base.yaml (L67-68)
```yaml
storage:
  backup_service_address: "0.0.0.0:6186"
```

**File:** terraform/helm/fullnode/templates/service.yaml (L53-54)
```yaml
  - name: backup
    port: 6186
```

**File:** types/src/transaction/encrypted_payload.rs (L54-64)
```rust
    Decrypted {
        ciphertext: Ciphertext,
        extra_config: TransactionExtraConfig,
        payload_hash: HashValue,
        eval_proof: EvalProof,

        // decrypted things
        executable: TransactionExecutable,
        decryption_nonce: u64,
    },
}
```
