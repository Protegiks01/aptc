# Audit Report

## Title
Premature Vote Garbage Collection Due to Desynchronization Between `highest_ordered_cert` and `ordered_root` Leading to Consensus Liveness Failure

## Summary
The `garbage_collect()` function in `pending_order_votes.rs` uses `highest_ordered_cert().round()` to determine which votes to delete, but `highest_ordered_cert` can be updated independently from `ordered_root` (the actual execution state). When a node processes a SyncInfo message from an ahead peer, `highest_ordered_cert` gets updated before blocks are successfully sent for execution. If execution fails or is on a different fork, `garbage_collect()` will permanently delete pending votes using the incorrectly advanced `highest_ordered_cert` value, causing consensus liveness failure for intermediate rounds that still need those votes.

## Finding Description
The vulnerability arises from a critical desynchronization in the consensus layer where two different round tracking mechanisms serve different purposes but are conflated during garbage collection:

1. **`ordered_root`**: The actual round of blocks that have been sent to execution [1](#0-0) 

2. **`highest_ordered_cert`**: Metadata tracking the highest ordered certificate seen from peers [2](#0-1) 

The developers themselves questioned this design with a comment: "Question: We are updating highest_ordered_cert but not highest_ordered_root. Is that fine?" [2](#0-1) 

**Attack Path:**

1. A validator node is at `ordered_root` = round 10, with pending order votes being collected for round 11 in `pending_order_votes`.

2. The node receives a valid `SyncInfo` message from an ahead peer with `highest_quorum_cert` at round 100, properly signed by a quorum of validators.

3. The `sync_up()` function verifies the SyncInfo cryptographically [3](#0-2) , and calls `add_certs()`.

4. Inside `add_certs()`, the `insert_quorum_cert()` function is called [4](#0-3) .

5. The `insert_quorum_cert()` flow eventually calls `insert_single_quorum_cert()` which updates `highest_ordered_cert` to round 100 [5](#0-4)  via `block_tree.insert_quorum_cert()` [2](#0-1) .

6. Subsequently, `send_for_execution()` is called to update `ordered_root`, but it can fail if:
   - The block path from current `ordered_root` to the new block doesn't exist (fork scenario) [6](#0-5) 
   - The block is missing from the store [7](#0-6) 
   - Round validation fails [8](#0-7) 

7. Even if `send_for_execution()` fails, `highest_ordered_cert` remains updated to round 100, while `ordered_root` stays at round 10.

8. On the next round event, `garbage_collect()` is called with `sync_info().highest_ordered_round()` which returns 100 [9](#0-8) [10](#0-9) .

9. The `garbage_collect()` function permanently deletes ALL votes with rounds â‰¤ 100 [11](#0-10) , including the pending votes for round 11.

10. **Liveness Failure**: The node's actual execution state is at round 10, but it has lost the votes needed to certify round 11. The node cannot form an order certificate for round 11 and consensus cannot progress.

## Impact Explanation
This is a **High Severity** vulnerability according to the Aptos bug bounty criteria:

- **Significant protocol violation**: The consensus protocol requires that votes be available for blocks that need to be ordered. Prematurely deleting these votes violates this requirement.

- **Validator node issues**: Affected nodes experience liveness failures where they cannot progress past a certain round, even though the network as a whole may continue (other nodes may not be affected depending on their sync state).

- **Network availability degradation**: If multiple nodes are affected simultaneously (e.g., after a network partition heals and nodes sync), this could cause significant consensus disruption.

The impact does not reach Critical severity because:
- It doesn't directly cause fund loss or theft
- It doesn't create a permanent network-wide partition (affected nodes could potentially recover via full state sync)
- It doesn't violate consensus safety (no double-spending or chain splits)

However, it's more severe than Medium because it directly affects core consensus functionality and can cause validator nodes to become non-functional for consensus participation.

## Likelihood Explanation
**Likelihood: Medium to High**

This vulnerability is likely to occur in production because:

1. **Normal network operations trigger it**: SyncInfo messages with ahead certificates are regularly exchanged during normal peer-to-peer synchronization, especially after network partitions or when nodes are catching up.

2. **No malicious intent required**: This can happen naturally when:
   - A node briefly lags behind and receives valid SyncInfo from ahead peers
   - Network partitions cause fork scenarios where different branches exist temporarily
   - Nodes restart and sync with the network

3. **Race condition window**: There's a window between when `highest_ordered_cert` is updated and when `ordered_root` is updated (or fails to update), during which `garbage_collect()` can be triggered.

4. **Visible in code comments**: The developers' own comment questioning the design indicates this was a known uncertainty [2](#0-1) .

5. **Fork scenarios are realistic**: In a distributed consensus system, temporary forks can occur legitimately due to network delays, making the path_from_ordered_root failure scenario realistic.

## Recommendation

**Primary Fix**: Synchronize `garbage_collect()` to use the actual `ordered_root` round instead of `highest_ordered_cert` round:

```rust
// In consensus/src/round_manager.rs, line 467:
// Change from:
self.pending_order_votes
    .garbage_collect(self.block_store.sync_info().highest_ordered_round());

// To:
self.pending_order_votes
    .garbage_collect(self.block_store.ordered_root().round());
```

**Alternative Fix**: Ensure `highest_ordered_cert` and `ordered_root` are always updated atomically:

```rust
// In consensus/src/block_storage/block_tree.rs, modify insert_quorum_cert():
pub(super) fn insert_quorum_cert(&mut self, qc: QuorumCert) -> anyhow::Result<()> {
    // ... existing code ...
    
    // Remove the premature update of highest_ordered_cert
    // Only update it when send_for_execution() succeeds
    // Delete lines 380-383
    
    Ok(())
}
```

Then ensure `highest_ordered_cert` is only updated in `send_for_execution()` path where both are updated together [12](#0-11) .

**Additional Safety**: Add bounds checking in `garbage_collect()`:

```rust
// In consensus/src/pending_order_votes.rs:
pub fn garbage_collect(&mut self, highest_ordered_round: u64, ordered_root_round: u64) {
    // Only GC if highest_ordered_round is reasonably close to ordered_root
    let safe_gc_round = std::cmp::min(highest_ordered_round, ordered_root_round + 100);
    self.li_digest_to_votes
        .retain(|_, (_, status)| match status {
            OrderVoteStatus::EnoughVotes(li_with_sig) => {
                li_with_sig.ledger_info().round() > safe_gc_round
            },
            OrderVoteStatus::NotEnoughVotes(sig_aggregator) => {
                sig_aggregator.data().round() > safe_gc_round
            },
        });
}
```

## Proof of Concept

```rust
// Add to consensus/src/round_manager_tests/ or as integration test

#[tokio::test]
async fn test_premature_vote_gc_liveness_failure() {
    use consensus_types::{quorum_cert::QuorumCert, sync_info::SyncInfo};
    use aptos_types::{block_info::BlockInfo, validator_verifier::random_validator_verifier};
    
    // Setup: Node at ordered_root round 10
    let (signers, verifier) = random_validator_verifier(4, Some(2), false);
    let mut round_manager = /* initialize round manager at round 10 */;
    
    // Add pending order vote for round 11
    let round_11_li = LedgerInfo::new(
        BlockInfo::new(1, 0, HashValue::random(), HashValue::random(), 11, 0, None),
        HashValue::random(),
    );
    let order_vote_11 = OrderVote::new_with_signature(
        signers[0].author(),
        round_11_li.clone(),
        signers[0].sign(&round_11_li).unwrap(),
    );
    
    // Verify vote is added
    let qc_dummy = QuorumCert::dummy();
    let result = round_manager.pending_order_votes.insert_order_vote(
        &order_vote_11,
        &verifier,
        Some(qc_dummy.clone()),
    );
    assert!(matches!(result, OrderVoteReceptionResult::VoteAdded(_)));
    
    // Attack: Receive SyncInfo with HQC at round 100 (on different fork)
    let round_100_qc = /* create valid QC for round 100 on fork */;
    let sync_info = SyncInfo::new(
        round_100_qc,
        /* highest_ordered_cert at round 100 */,
        None,
    );
    
    // Process sync - this updates highest_ordered_cert but send_for_execution fails
    // due to fork (path_from_ordered_root returns None)
    let _ = round_manager.sync_up(&sync_info, author).await;
    // Note: This may error, but highest_ordered_cert is already updated
    
    // Trigger new round event which calls garbage_collect
    round_manager.process_new_round_event(NewRoundEvent { /* round 12 */ }).await;
    
    // Verify: Votes for round 11 are deleted
    assert!(!round_manager.pending_order_votes.has_enough_order_votes(&round_11_li));
    assert!(!round_manager.pending_order_votes.exists(&round_11_li.hash()));
    
    // Demonstrate liveness failure: Cannot add more votes for round 11
    let order_vote_11_from_validator2 = OrderVote::new_with_signature(
        signers[1].author(),
        round_11_li.clone(),
        signers[1].sign(&round_11_li).unwrap(),
    );
    
    // This vote would be rejected because round 11 < highest_ordered_round (100)
    // or cannot be added because the entry was deleted
    let result = round_manager.pending_order_votes.insert_order_vote(
        &order_vote_11_from_validator2,
        &verifier,
        None,
    );
    // Node cannot form certificate for round 11 - liveness failure
    assert!(node_cannot_progress_past_round_10);
}
```

**Notes:**
- The vulnerability exists in the production codebase as evidenced by the developer comment questioning the design.
- The issue affects core consensus functionality and can realistically occur during normal network operations.
- The fix is straightforward: ensure garbage collection uses the actual execution state (`ordered_root`) rather than metadata (`highest_ordered_cert`).

### Citations

**File:** consensus/src/block_storage/block_tree.rs (L380-383)
```rust
        if self.highest_ordered_cert.commit_info().round() < qc.commit_info().round() {
            // Question: We are updating highest_ordered_cert but not highest_ordered_root. Is that fine?
            self.highest_ordered_cert = Arc::new(qc.into_wrapped_ledger_info());
        }
```

**File:** consensus/src/block_storage/block_tree.rs (L436-439)
```rust
    pub(super) fn update_ordered_root(&mut self, root_id: HashValue) {
        assert!(self.block_exists(&root_id));
        self.ordered_root_id = root_id;
    }
```

**File:** consensus/src/round_manager.rs (L466-467)
```rust
        self.pending_order_votes
            .garbage_collect(self.block_store.sync_info().highest_ordered_round());
```

**File:** consensus/src/round_manager.rs (L888-896)
```rust
            sync_info.verify(&self.epoch_state.verifier).map_err(|e| {
                error!(
                    SecurityEvent::InvalidSyncInfoMsg,
                    sync_info = sync_info,
                    remote_peer = author,
                    error = ?e,
                );
                VerifyError::from(e)
            })?;
```

**File:** consensus/src/block_storage/sync_manager.rs (L144-145)
```rust
        self.insert_quorum_cert(sync_info.highest_quorum_cert(), &mut retriever)
            .await?;
```

**File:** consensus/src/block_storage/block_store.rs (L317-319)
```rust
        let block_to_commit = self
            .get_block(block_id_to_commit)
            .ok_or_else(|| format_err!("Committed block id not found"))?;
```

**File:** consensus/src/block_storage/block_store.rs (L322-325)
```rust
        ensure!(
            block_to_commit.round() > self.ordered_root().round(),
            "Committed block round lower than root"
        );
```

**File:** consensus/src/block_storage/block_store.rs (L327-331)
```rust
        let blocks_to_commit = self
            .path_from_ordered_root(block_id_to_commit)
            .unwrap_or_default();

        assert!(!blocks_to_commit.is_empty());
```

**File:** consensus/src/block_storage/block_store.rs (L338-341)
```rust
        self.inner.write().update_ordered_root(block_to_commit.id());
        self.inner
            .write()
            .insert_ordered_cert(finality_proof_clone.clone());
```

**File:** consensus/src/block_storage/block_store.rs (L555-555)
```rust
        self.inner.write().insert_quorum_cert(qc)
```

**File:** consensus/consensus-types/src/sync_info.rs (L125-127)
```rust
    pub fn highest_ordered_round(&self) -> Round {
        self.highest_ordered_cert().commit_info().round()
    }
```

**File:** consensus/src/pending_order_votes.rs (L160-169)
```rust
    pub fn garbage_collect(&mut self, highest_ordered_round: u64) {
        self.li_digest_to_votes
            .retain(|_, (_, status)| match status {
                OrderVoteStatus::EnoughVotes(li_with_sig) => {
                    li_with_sig.ledger_info().round() > highest_ordered_round
                },
                OrderVoteStatus::NotEnoughVotes(sig_aggregator) => {
                    sig_aggregator.data().round() > highest_ordered_round
                },
            });
```
