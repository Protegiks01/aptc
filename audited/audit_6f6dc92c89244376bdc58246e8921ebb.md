# Audit Report

## Title
Validator Address Grinding Enables Permanent Proposer Monopoly in FixedProposer Mode

## Summary

The `choose_leader()` function in the consensus layer selects the validator with the minimum `AccountAddress` value when `FixedProposer` mode is enabled. Since validators can grind their account addresses during setup (by generating millions of key pairs and selecting the one yielding the smallest address), a malicious actor can ensure they are always selected as the fixed proposer, completely centralizing block production power. [1](#0-0) 

## Finding Description

The vulnerability stems from a fundamental design flaw in how the fixed proposer is selected:

1. **Grindable Selection Criteria**: The `choose_leader()` function selects the proposer by finding the minimum `AccountAddress` value among all validators. [1](#0-0) 

2. **Address Generation is Controllable**: Validator account addresses are derived from Ed25519 public keys via the authentication key mechanism. [2](#0-1)  An attacker can:
   - Generate millions of Ed25519 key pairs
   - Compute the resulting `AccountAddress` for each via `AuthenticationKey::ed25519()`
   - Select the key pair producing the smallest address
   - Use that account to become a validator

3. **Lexicographic Ordering**: `AccountAddress` derives `Ord` and compares byte-by-byte, making address grinding computationally feasible. [3](#0-2) 

4. **FixedProposer is a Valid Configuration**: While the default consensus mode is `LeaderReputation`, `FixedProposer` remains a valid on-chain configuration option that can be activated through governance proposals. [4](#0-3) [5](#0-4) 

5. **Activation in Consensus**: When `FixedProposer` mode is active, the epoch manager calls `choose_leader()` with all validator addresses and uses the result as the sole proposer. [6](#0-5) 

**Attack Path:**
1. Attacker generates ~2^40 Ed25519 key pairs offline
2. Computes `AccountAddress` for each via `AuthenticationKey::ed25519(pubkey).account_address()`
3. Selects the key pair yielding the smallest address (e.g., starting with many zero bytes)
4. Creates a validator account using this ground address
5. Stakes the required amount and joins the validator set [7](#0-6) 
6. Either waits for or influences a governance proposal to change consensus config to `FixedProposer`
7. Once active, becomes the permanent proposer for all blocks

## Impact Explanation

**Severity: HIGH** (up to $50,000 per Aptos Bug Bounty criteria for "Significant protocol violations")

**Consensus Centralization:**
- A single validator controls all block proposal rights
- Other validators can only vote, not propose
- Violates the distributed nature of the consensus protocol
- Creates a single point of failure for liveness

**Liveness Risk:**
- If the fixed proposer goes offline, the network cannot produce blocks
- Normal rotation mechanisms are bypassed
- Could lead to "Total loss of liveness/network availability" (Critical severity) if the attacker's node fails

**Security Degradation:**
- Reduces Byzantine fault tolerance to a centralized model
- The comment "As it is just a tmp hack function, pick the min PeerId to be a proposer" indicates this was never intended for production use but remains exploitable

## Likelihood Explanation

**Likelihood: Medium-High (conditional on FixedProposer activation)**

**Favorable Factors:**
- Address grinding is computationally feasible (similar to Bitcoin vanity address generation)
- Becoming a validator only requires meeting standard stake requirements
- `FixedProposer` is a valid on-chain configuration accessible via governance

**Mitigating Factors:**
- Current default is `LeaderReputation`, not `FixedProposer`
- Activating `FixedProposer` requires a governance proposal to pass
- The vulnerability is conditional on a configuration change

**Risk Assessment:**
Even if unlikely to be exploited immediately, this represents a **latent design flaw** that:
- Could be triggered during emergency governance actions
- Makes `FixedProposer` mode permanently unsafe to use
- Violates the principle of unpredictable/ungrindable leader selection

## Recommendation

**Immediate Fix: Remove or Redesign `choose_leader()`**

1. **Option 1: Remove FixedProposer Mode Entirely**
   - Deprecate `ProposerElectionType::FixedProposer` from valid configurations
   - Remove the `choose_leader()` function
   - Force all networks to use rotation-based or reputation-based leader election

2. **Option 2: Use Ungrindable Selection Criteria**
   Replace address-based selection with validator index or consensus public key hash:

```rust
// Instead of choosing by minimum AccountAddress (grindable),
// choose by minimum consensus public key hash (not grindable during validator setup)
pub fn choose_leader(validators: Vec<ValidatorConsensusInfo>) -> Author {
    validators.into_iter()
        .min_by_key(|v| {
            // Hash of consensus public key is not grindable since 
            // it must match on-chain ValidatorConfig
            CryptoHash::hash(&v.public_key)
        })
        .expect("No validators found")
        .address
}
```

3. **Option 3: Use Deterministic Random Selection**
   Use a VRF or hash-based selection seeded with block height:

```rust
pub fn choose_leader(validators: Vec<Author>, seed: &[u8]) -> Author {
    let hash = CryptoHash::hash(&(seed, &validators));
    let index = u64::from_le_bytes(hash.as_ref()[0..8].try_into().unwrap()) 
        as usize % validators.len();
    validators[index]
}
```

**Additional Hardening:**
- Add validation in consensus config changes to warn/prevent FixedProposer activation
- Document that FixedProposer mode is unsafe and should never be used in production

## Proof of Concept

**Rust Test Demonstrating Address Grinding:**

```rust
#[test]
fn test_address_grinding_attack() {
    use aptos_crypto::ed25519::{Ed25519PrivateKey, Ed25519PublicKey};
    use aptos_types::account_address::AccountAddress;
    use aptos_types::transaction::authenticator::AuthenticationKey;
    use rand::rngs::OsRng;
    
    // Simulate grinding for small address
    let mut min_address = AccountAddress::MAX_ADDRESS;
    let mut best_key: Option<Ed25519PublicKey> = None;
    
    // In real attack, this would run for millions/billions of iterations
    for _ in 0..10000 {
        let private_key = Ed25519PrivateKey::generate(&mut OsRng);
        let public_key = private_key.public_key();
        let address = AuthenticationKey::ed25519(&public_key).account_address();
        
        if address < min_address {
            min_address = address;
            best_key = Some(public_key);
        }
    }
    
    println!("Found address: {:?}", min_address);
    assert!(best_key.is_some(), "Should find at least one key");
}

#[test]
fn test_choose_leader_selects_minimum() {
    use consensus::liveness::rotating_proposer_election::choose_leader;
    use aptos_types::account_address::AccountAddress;
    
    let addr1 = AccountAddress::from_hex_literal("0x1").unwrap();
    let addr2 = AccountAddress::from_hex_literal("0x2").unwrap();
    let addr3 = AccountAddress::from_hex_literal("0xff").unwrap();
    
    let peers = vec![addr3, addr1, addr2]; // Deliberately unordered
    let leader = choose_leader(peers);
    
    assert_eq!(leader, addr1, "Should select minimum address");
}
```

**Impact Demonstration:**
With sufficient iterations (~2^40), an attacker can find an address starting with many zero bytes (e.g., `0x0000000000000000...0001`), virtually guaranteeing selection as the fixed proposer ahead of any naturally-generated validator addresses.

---

**Notes:**

This vulnerability exists as a design flaw even if `FixedProposer` mode is never activated in production. The presence of exploitable code paths that can be enabled through governance represents a latent security risk that should be remediated to prevent future incidents.

### Citations

**File:** consensus/src/liveness/rotating_proposer_election.rs (L20-23)
```rust
pub fn choose_leader(peers: Vec<Author>) -> Author {
    // As it is just a tmp hack function, pick the min PeerId to be a proposer.
    peers.into_iter().min().expect("No trusted peers found!")
}
```

**File:** types/src/account_address.rs (L131-133)
```rust
pub fn from_public_key(public_key: &Ed25519PublicKey) -> AccountAddress {
    AuthenticationKey::ed25519(public_key).account_address()
}
```

**File:** third_party/move/move-core/types/src/account_address.rs (L11-18)
```rust
/// A struct that represents an account address.
#[derive(Ord, PartialOrd, Eq, PartialEq, Hash, Clone, Copy)]
#[cfg_attr(any(test, feature = "fuzzing"), derive(proptest_derive::Arbitrary))]
#[cfg_attr(
    any(test, feature = "fuzzing"),
    derive(arbitrary::Arbitrary, dearbitrary::Dearbitrary)
)]
pub struct AccountAddress([u8; AccountAddress::LENGTH]);
```

**File:** types/src/on_chain_config/consensus_config.rs (L510-523)
```rust
pub enum ProposerElectionType {
    // Choose the smallest PeerId as the proposer
    // with specified param contiguous_rounds
    FixedProposer(u32),
    // Round robin rotation of proposers
    // with specified param contiguous_rounds
    RotatingProposer(u32),
    // Committed history based proposer election
    LeaderReputation(LeaderReputationType),
    // Pre-specified proposers for each round,
    // or default proposer if round proposer not
    // specified
    RoundProposer(HashMap<Round, AccountAddress>),
}
```

**File:** aptos-move/framework/aptos-framework/sources/configs/consensus_config.move (L46-56)
```text
    /// This can be called by on-chain governance to update on-chain consensus configs for the next epoch.
    /// Example usage:
    /// ```
    /// aptos_framework::consensus_config::set_for_next_epoch(&framework_signer, some_config_bytes);
    /// aptos_framework::aptos_governance::reconfigure(&framework_signer);
    /// ```
    public fun set_for_next_epoch(account: &signer, config: vector<u8>) {
        system_addresses::assert_aptos_framework(account);
        assert!(vector::length(&config) > 0, error::invalid_argument(EINVALID_CONFIG));
        std::config_buffer::upsert<ConsensusConfig>(ConsensusConfig {config});
    }
```

**File:** consensus/src/epoch_manager.rs (L300-304)
```rust
            // We don't really have a fixed proposer!
            ProposerElectionType::FixedProposer(contiguous_rounds) => {
                let proposer = choose_leader(proposers);
                Arc::new(RotatingProposer::new(vec![proposer], *contiguous_rounds))
            },
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L670-692)
```text
    public entry fun initialize_validator(
        account: &signer,
        consensus_pubkey: vector<u8>,
        proof_of_possession: vector<u8>,
        network_addresses: vector<u8>,
        fullnode_addresses: vector<u8>,
    ) acquires AllowedValidators {
        check_stake_permission(account);
        // Checks the public key has a valid proof-of-possession to prevent rogue-key attacks.
        let pubkey_from_pop = &bls12381::public_key_from_bytes_with_pop(
            consensus_pubkey,
            &proof_of_possession_from_bytes(proof_of_possession)
        );
        assert!(option::is_some(pubkey_from_pop), error::invalid_argument(EINVALID_PUBLIC_KEY));

        initialize_owner(account);
        move_to(account, ValidatorConfig {
            consensus_pubkey,
            network_addresses,
            fullnode_addresses,
            validator_index: 0,
        });
    }
```
