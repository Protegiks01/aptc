# Audit Report

## Title
Consensus Private Key Exfiltration via Unrestricted export_private_key() in OnDiskStorage Backend

## Summary
The `export_private_key()` method in the CryptoStorage interface allows unrestricted export of consensus private keys when validators use OnDiskStorage backends. A compromised validator process can exploit this to exfiltrate consensus keys, enabling attackers to sign conflicting blocks and break AptosBFT safety guarantees.

## Finding Description

The vulnerability exists in the interaction between multiple components in the secure storage subsystem:

**Component 1: Consensus Key Storage**
Consensus private keys are stored in secure storage under the key name "consensus" (CONSENSUS_KEY constant). [1](#0-0) 

The PersistentSafetyStorage component stores consensus keys using the KVStorage interface: [2](#0-1) 

**Component 2: CryptoKVStorage Blanket Implementation**
The CryptoKVStorage trait provides a blanket implementation of the CryptoStorage trait for any KVStorage backend. Critically, the `export_private_key()` method simply calls `self.get(name)` without any additional access controls: [3](#0-2) 

**Component 3: OnDiskStorage Implementation**
OnDiskStorage implements CryptoKVStorage, automatically gaining the unrestricted export capability: [4](#0-3) 

OnDiskStorage persists keys to disk in JSON format with no encryption or access controls beyond filesystem permissions: [5](#0-4) 

**Component 4: Missing Configuration Enforcement**
The SafetyRulesConfig sanitizer only prohibits InMemoryStorage for mainnet validators, but does NOT prohibit OnDiskStorage: [6](#0-5) 

**Attack Path:**
1. Validator misconfigures to use OnDiskStorage backend (allowed by sanitizer)
2. Malicious code compromises the validator process (e.g., via dependency vulnerability, supply chain attack, or insider threat)
3. Attacker reads the node configuration to determine storage backend and file path
4. Attacker instantiates a new Storage object from the SecureBackend configuration: [7](#0-6) 
5. Attacker calls `storage.export_private_key("consensus")` which retrieves the BLS consensus private key from the JSON file
6. Attacker exfiltrates the key and uses it to sign conflicting blocks, violating BFT safety

This breaks the **Consensus Safety** invariant: "AptosBFT must prevent double-spending and chain splits under < 1/3 Byzantine"

## Impact Explanation

This vulnerability meets **Critical Severity** criteria per Aptos bug bounty guidelines:

**Consensus/Safety Violations:** An attacker with the consensus private key can sign multiple conflicting blocks for the same round, causing:
- Equivocation that breaks BFT safety guarantees
- Potential chain splits if different validators commit different blocks  
- Loss of Byzantine fault tolerance (single compromised key acts as multiple Byzantine validators)
- Network-wide consensus failure requiring manual intervention or hard fork

**Direct Impact on Invariant:** Violates invariant #2: "Consensus Safety: AptosBFT must prevent double-spending and chain splits under < 1/3 Byzantine". A single compromised consensus key enables the attacker to violate safety even without controlling 1/3 of stake.

**Cascading Effects:**
- Breaks deterministic execution (invariant #1) as different validators may execute different blocks
- Compromises cryptographic correctness (invariant #10) by exposing private key material
- Undermines entire validator trust model

## Likelihood Explanation

**Likelihood: Medium to High**

**Factors Increasing Likelihood:**
1. **Misconfiguration Risk:** OnDiskStorage is NOT prohibited by the config sanitizer for mainnet validators, only InMemoryStorage is checked
2. **Documentation Ambiguity:** While code comments state "should not be used in production", there's no runtime enforcement
3. **Operational Convenience:** Validators may use OnDiskStorage during testing/staging and accidentally promote to production
4. **Attack Surface:** Compromising a validator process is achievable via: supply chain attacks on dependencies, zero-days in Rust crates, container escapes, privileged access misuse, or insider threats

**Factors Decreasing Likelihood:**
1. Best practices recommend VaultStorage for production
2. Requires compromise of the validator process (not remotely exploitable)
3. Most production validators likely use VaultStorage with proper RBAC

However, even a **single** compromised validator key is sufficient to break consensus safety, making this a high-impact scenario despite moderate likelihood.

## Recommendation

**Immediate Fix: Enforce Storage Backend Restrictions**

Update the SafetyRulesConfig sanitizer to explicitly prohibit OnDiskStorage for production validators:

```rust
// In config/src/config/safety_rules_config.rs, update sanitize() method:

// Verify that the secure backend is appropriate for mainnet validators
if chain_id.is_mainnet() && node_type.is_validator() {
    match &safety_rules_config.backend {
        SecureBackend::InMemoryStorage => {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "The secure backend should not be set to in memory storage in mainnet!".to_string(),
            ));
        },
        SecureBackend::OnDiskStorage(_) => {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "OnDiskStorage is not secure for production use. Use VaultStorage for mainnet validators.".to_string(),
            ));
        },
        SecureBackend::Vault(_) => {}, // OK for production
    }
}
```

**Additional Defense-in-Depth Measures:**

1. **Remove export_private_key() from Production Interface:** Create a restricted CryptoStorage interface for SafetyRules that only exposes signing operations, not key export
2. **Key Material Protection:** Implement memory protection for key material (e.g., using secrecy crate, zeroize on drop)
3. **Audit Logging:** Log all export_private_key() calls with caller context for forensic analysis
4. **Runtime Validation:** Add runtime checks to prevent OnDiskStorage instantiation when running as mainnet validator

## Proof of Concept

```rust
// Proof of Concept: Consensus Key Exfiltration from OnDiskStorage
// This demonstrates how a compromised validator process can export consensus keys

use aptos_config::config::{SecureBackend, OnDiskStorageConfig};
use aptos_secure_storage::{Storage, CryptoStorage};
use aptos_crypto::bls12381::PrivateKey;
use std::path::PathBuf;

fn exploit_consensus_key_export() {
    // Step 1: Attacker reads validator config to find storage backend
    // (In real attack, this would parse the actual config file)
    let storage_backend = SecureBackend::OnDiskStorage(OnDiskStorageConfig {
        path: PathBuf::from("/opt/aptos/data/secure_storage.json"),
        namespace: None,
        data_dir: PathBuf::from("/opt/aptos/data"),
    });
    
    // Step 2: Create Storage instance from config
    let storage: Storage = (&storage_backend).into();
    
    // Step 3: Export consensus private key (NO ACCESS CONTROLS)
    // The CONSENSUS_KEY constant is "consensus"
    match storage.export_private_key("consensus") {
        Ok(consensus_key) => {
            // Step 4: Attacker now has the consensus private key
            println!("CRITICAL: Consensus key exfiltrated!");
            println!("Public key: {:?}", consensus_key.public_key());
            
            // Step 5: Attacker can now sign conflicting blocks
            // Breaking BFT safety by creating equivocations
            // (signing multiple blocks at the same round/height)
            
            // This violates AptosBFT safety guarantees and can cause:
            // - Chain splits
            // - Double-spending
            // - Loss of consensus finality
        },
        Err(e) => {
            println!("Export failed (expected for VaultStorage): {:?}", e);
        }
    }
}

// To demonstrate:
// 1. Configure a validator with OnDiskStorage backend
// 2. Initialize consensus key in storage
// 3. Simulate process compromise by running this code
// 4. Observe successful key export with no authentication required
```

**Testing Steps:**
1. Create a test validator node with OnDiskStorage configuration
2. Initialize SafetyRules with a consensus key
3. Run the exploit code within the validator process context
4. Verify that the consensus private key is successfully exported
5. Demonstrate that the exported key can sign valid consensus messages
6. Show that the config sanitizer allows this configuration for non-InMemory backends

**Expected Result:** The consensus key is successfully exported from OnDiskStorage without any authentication or authorization checks, proving the vulnerability is exploitable in production configurations that use OnDiskStorage.

## Notes

**Scope Clarification:** This vulnerability specifically affects validators using OnDiskStorage backends. VaultStorage deployments have proper access control via Vault's policy system, requiring explicit "Export" capability permissions. [8](#0-7) 

**Real-World Impact:** While VaultStorage is the recommended production backend, the lack of enforcement means validators CAN deploy with OnDiskStorage on mainnet, creating this attack surface. The vulnerability becomes critical during the validator process lifetime if the process is compromised through any vector (dependency vulnerabilities, container escapes, insider threats, etc.).

**Defense Depends on Configuration:** The security of consensus keys currently relies entirely on proper backend selection, with no runtime enforcement or validation that production validators are using secure storage.

### Citations

**File:** config/global-constants/src/lib.rs (L12-12)
```rust
pub const CONSENSUS_KEY: &str = "consensus";
```

**File:** consensus/safety-rules/src/persistent_safety_storage.rs (L63-81)
```rust
    fn initialize_keys_and_accounts(
        internal_store: &mut Storage,
        author: Author,
        consensus_private_key: bls12381::PrivateKey,
    ) -> Result<(), Error> {
        let result = internal_store.set(CONSENSUS_KEY, consensus_private_key);
        // Attempting to re-initialize existing storage. This can happen in environments like
        // forge. Rather than be rigid here, leave it up to the developer to detect
        // inconsistencies or why they did not reset storage between rounds. Do not repeat the
        // checks again below, because it is just too strange to have a partially configured
        // storage.
        if let Err(aptos_secure_storage::Error::KeyAlreadyExists(_)) = result {
            warn!("Attempted to re-initialize existing storage");
            return Ok(());
        }

        internal_store.set(OWNER_ACCOUNT, author)?;
        Ok(())
    }
```

**File:** secure/storage/src/crypto_kv_storage.rs (L18-28)
```rust
impl<T: CryptoKVStorage> CryptoStorage for T {
    fn create_key(&mut self, name: &str) -> Result<Ed25519PublicKey, Error> {
        // Generate and store the new named key pair
        let (private_key, public_key) = new_ed25519_key_pair();
        self.import_private_key(name, private_key)?;
        Ok(public_key)
    }

    fn export_private_key(&self, name: &str) -> Result<Ed25519PrivateKey, Error> {
        self.get(name).map(|v| v.value)
    }
```

**File:** secure/storage/src/on_disk.rs (L16-27)
```rust
/// OnDiskStorage represents a key value store that is persisted to the local filesystem and is
/// intended for single threads (or must be wrapped by a Arc<RwLock<>>). This provides no permission
/// checks and simply offers a proof of concept to unblock building of applications without more
/// complex data stores. Internally, it reads and writes all data to a file, which means that it
/// must make copies of all key material which violates the code base. It violates it because
/// the anticipation is that data stores would securely handle key material. This should not be used
/// in production.
pub struct OnDiskStorage {
    file_path: PathBuf,
    temp_path: TempPath,
    time_service: TimeService,
}
```

**File:** secure/storage/src/on_disk.rs (L101-101)
```rust
impl CryptoKVStorage for OnDiskStorage {}
```

**File:** config/src/config/safety_rules_config.rs (L86-96)
```rust
            // Verify that the secure backend is appropriate for mainnet validators
            if chain_id.is_mainnet()
                && node_type.is_validator()
                && safety_rules_config.backend.is_in_memory()
            {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "The secure backend should not be set to in memory storage in mainnet!"
                        .to_string(),
                ));
            }
```

**File:** config/src/config/secure_backend_config.rs (L162-195)
```rust
impl From<&SecureBackend> for Storage {
    fn from(backend: &SecureBackend) -> Self {
        match backend {
            SecureBackend::InMemoryStorage => Storage::from(InMemoryStorage::new()),
            SecureBackend::OnDiskStorage(config) => {
                let storage = Storage::from(OnDiskStorage::new(config.path()));
                if let Some(namespace) = &config.namespace {
                    Storage::from(Namespaced::new(namespace, Box::new(storage)))
                } else {
                    storage
                }
            },
            SecureBackend::Vault(config) => {
                let storage = Storage::from(VaultStorage::new(
                    config.server.clone(),
                    config.token.read_token().expect("Unable to read token"),
                    config
                        .ca_certificate
                        .as_ref()
                        .map(|_| config.ca_certificate().unwrap()),
                    config.renew_ttl_secs,
                    config.disable_cas.map_or_else(|| true, |disable| !disable),
                    config.connection_timeout_ms,
                    config.response_timeout_ms,
                ));
                if let Some(namespace) = &config.namespace {
                    Storage::from(Namespaced::new(namespace, Box::new(storage)))
                } else {
                    storage
                }
            },
        }
    }
}
```

**File:** secure/storage/src/vault.rs (L385-390)
```rust
                match capability {
                    Capability::Export => {
                        let export_capability = vec![vault::Capability::Read];
                        let export_policy = format!("transit/export/signing-key/{}", key);
                        vault_policy.add_policy(&export_policy, export_capability);
                    },
```
