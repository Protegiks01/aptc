# Audit Report

## Title
Integer Underflow and DoS in DKG Schnorr Proof-of-Knowledge Batch Verification

## Summary
The `pok_batch_verify()` function in the DKG Schnorr implementation fails to validate that the input `poks` vector is non-empty before performing arithmetic operations, leading to an integer underflow vulnerability. When processing an empty `poks` vector (n=0), the function attempts to compute `0..(n-1)` which causes a panic in debug builds or wraps to iterate `0..usize::MAX` times in release builds, effectively hanging the validator node. This can be exploited by submitting a malicious DKG transcript to cause validator DoS and consensus disruption.

## Finding Description

The vulnerability exists in the `pok_batch_verify()` function which performs batch verification of Schnorr proofs-of-knowledge for DKG transcripts. [1](#0-0) 

When `poks` is an empty vector, line 77 sets `n = 0`. The function then proceeds without validation to line 84, which attempts to create a range `0..(n-1)`. Since `n` is of type `usize`, the subtraction `0 - 1` causes:
- **Debug builds**: Immediate panic due to integer underflow
- **Release builds**: Wraps to `usize::MAX`, creating range `0..18446744073709551615`, causing the validator to hang

Even if this underflow were somehow avoided, the function would proceed to line 104 with only one element in `bases` (the generator `g`) and one element in `exps` (the negation of `last_exp` which equals `Scalar::ZERO`). The multi-exponentiation check would compute `g^0 = identity` and compare it to `identity`, which always passes, trivially accepting empty proofs.

**Attack Path:**

1. Attacker crafts a malicious DKG `Transcript` structure with `soks = []` (empty vector) and `V[W] = identity` (or `V[sc.n] = identity` for unweighted)

2. The transcript is serialized and submitted as part of a DKG transaction

3. During transaction processing, the transcript is deserialized: [2](#0-1) 

4. Verification is triggered: [3](#0-2) 

5. This calls the weighted transcript's verify method: [4](#0-3) 

6. Which calls `batch_verify_soks`: [5](#0-4) 

7. In `batch_verify_soks`, the empty `soks` vector results in `c = identity`. The check `c.ne(pk)` at line 62 passes only if `pk == identity`: [6](#0-5) 

8. The function constructs an empty `poks` vector and calls the vulnerable `pok_batch_verify`: [7](#0-6) 

9. The validator node crashes (debug) or hangs (release) at the integer underflow

## Impact Explanation

**Severity: HIGH**

This vulnerability enables a Denial-of-Service attack against validator nodes processing DKG transactions. The impact includes:

1. **Validator Node Crashes/Hangs**: Any validator processing the malicious DKG transcript will either crash (debug builds) or hang indefinitely (release builds), making them unavailable for consensus participation

2. **Consensus Disruption**: If multiple validators process the same malicious transcript simultaneously, it could temporarily reduce the active validator set below the 2/3 threshold required for consensus, causing network liveness failures

3. **DKG Protocol Compromise**: The vulnerability bypasses cryptographic verification of proofs-of-knowledge, potentially allowing invalid DKG results to be accepted if the underflow is somehow mitigated

This meets the **HIGH severity** criteria from the Aptos bug bounty program: "Validator node slowdowns" and "API crashes" that significantly impact protocol operation.

## Likelihood Explanation

**Likelihood: HIGH**

The vulnerability is highly likely to be exploitable because:

1. **No Authentication Required**: Any network participant can submit DKG transactions during epoch transitions

2. **Simple Exploit Construction**: The attacker only needs to craft a transcript with empty `soks` and `V[W] = identity`, both trivially achievable through direct structure manipulation before serialization

3. **No Semantic Validation**: The deserialization path only performs BCS decoding and point validation, with no checks that `soks` is non-empty or that `V[W]` is a valid non-identity public key: [8](#0-7) 

4. **Deterministic Impact**: Every validator processing the malicious transcript will be affected identically

5. **Timing Vulnerability**: Epoch transitions are predictable events when DKG transactions are processed, giving attackers a clear exploitation window

## Recommendation

Add explicit validation to reject empty proof vectors before performing any arithmetic operations:

```rust
pub fn pok_batch_verify<'a, Gr>(
    poks: &Vec<(Gr, PoK<Gr>)>,
    g: &Gr,
    gamma: &Scalar,
) -> anyhow::Result<()>
where
    Gr: Serialize + Group + Mul<&'a Scalar> + HasMultiExp,
{
    let n = poks.len();
    
    // Add validation to reject empty proof vectors
    if n == 0 {
        bail!("Cannot verify empty batch of Schnorr proofs");
    }
    
    let mut exps = Vec::with_capacity(2 * n + 1);
    let mut bases = Vec::with_capacity(2 * n + 1);

    // Rest of function unchanged...
}
```

Additionally, add validation in `batch_verify_soks` to reject empty `soks` and identity `pk`:

```rust
pub fn batch_verify_soks<Gr, A>(
    soks: &[SoK<Gr>],
    pk_base: &Gr,
    pk: &Gr,
    spks: &[bls12381::PublicKey],
    aux: &[A],
    tau: &Scalar,
) -> anyhow::Result<()>
where
    Gr: Serialize + HasMultiExp + Display + Copy + Group + for<'a> Mul<&'a Scalar>,
    A: Serialize + Clone,
{
    // Add validation
    if soks.is_empty() {
        bail!("Cannot verify empty set of signatures-of-knowledge");
    }
    
    if pk.is_identity().into() {
        bail!("Public key cannot be the identity element");
    }
    
    // Rest of validation unchanged...
}
```

## Proof of Concept

```rust
#[cfg(test)]
mod exploit_tests {
    use super::*;
    use blstrs::{G1Projective, Scalar};
    use group::Group;
    use aptos_crypto::blstrs::random_scalar;
    use rand::thread_rng;

    #[test]
    #[should_panic(expected = "attempt to subtract with overflow")]
    fn test_empty_poks_causes_underflow() {
        // This test demonstrates the integer underflow panic in debug mode
        let mut rng = thread_rng();
        let g = G1Projective::generator();
        let gamma = random_scalar(&mut rng);
        
        // Empty poks vector triggers the vulnerability
        let poks: Vec<(G1Projective, PoK<G1Projective>)> = vec![];
        
        // This will panic with "attempt to subtract with overflow" in debug mode
        // or hang indefinitely in release mode
        let _ = pok_batch_verify(&poks, &g, &gamma);
    }

    #[test]
    fn test_malicious_dkg_transcript() {
        use crate::pvss::das::weighted_protocol::Transcript;
        use aptos_crypto::CryptoMaterialError;
        
        // Craft malicious transcript with empty soks and identity pk
        let malicious_transcript = Transcript {
            soks: vec![], // Empty - triggers vulnerability
            R: vec![G1Projective::identity()],
            R_hat: vec![G2Projective::identity()],
            V: vec![G1Projective::identity(); 2], // V[W] = identity
            V_hat: vec![G2Projective::identity(); 2],
            C: vec![G1Projective::identity()],
        };
        
        // Serialize the malicious transcript
        let bytes = bcs::to_bytes(&malicious_transcript).unwrap();
        
        // Deserialize - this should succeed (no semantic validation)
        let deserialized = Transcript::try_from(bytes.as_slice());
        assert!(deserialized.is_ok());
        
        // Attempting to verify will cause crash/hang
        // (commented out to prevent test suite hang)
        // let sc = WeightedConfigBlstrs::new(1, vec![1]);
        // let pp = das::PublicParameters::default_with_bls_base();
        // let _ = deserialized.unwrap().verify(&sc, &pp, &[], &[], &[]);
    }
}
```

**Notes:**
- The vulnerability exists in both weighted and unweighted DKG transcript implementations, as both use the same `pok_batch_verify` function
- The issue also affects the BLS signature aggregation at line 96-100 in `batch_verify_soks`, which returns an error for empty vectors, but this check comes AFTER the vulnerable `pok_batch_verify` call
- Release builds using overflow checks (`overflow-checks = true` in Cargo.toml) would also panic, but standard release builds would hang
- The vulnerability breaks the **Cryptographic Correctness** invariant: empty proof vectors should never pass verification

### Citations

**File:** crates/aptos-dkg/src/pvss/schnorr.rs (L77-86)
```rust
    let n = poks.len();
    let mut exps = Vec::with_capacity(2 * n + 1);
    let mut bases = Vec::with_capacity(2 * n + 1);

    // Compute \gamma_i = \gamma^i, for all i \in [0, n]
    let mut gammas = Vec::with_capacity(n);
    gammas.push(Scalar::ONE);
    for _ in 0..(n - 1) {
        gammas.push(gammas.last().unwrap().mul(gamma));
    }
```

**File:** aptos-move/aptos-vm/src/validator_txns/dkg.rs (L106-109)
```rust
        let transcript = bcs::from_bytes::<<DefaultDKG as DKGTrait>::Transcript>(
            dkg_node.transcript_bytes.as_slice(),
        )
        .map_err(|_| Expected(TranscriptDeserializationFailed))?;
```

**File:** aptos-move/aptos-vm/src/validator_txns/dkg.rs (L111-112)
```rust
        DefaultDKG::verify_transcript(&pub_params, &transcript)
            .map_err(|_| Expected(TranscriptVerificationFailed))?;
```

**File:** types/src/dkg/real_dkg/mod.rs (L368-374)
```rust
        trx.main.verify(
            &params.pvss_config.wconfig,
            &params.pvss_config.pp,
            &spks,
            &all_eks,
            &aux,
        )?;
```

**File:** crates/aptos-dkg/src/pvss/das/weighted_protocol.rs (L82-89)
```rust
impl TryFrom<&[u8]> for Transcript {
    type Error = CryptoMaterialError;

    fn try_from(bytes: &[u8]) -> Result<Self, Self::Error> {
        // NOTE: The `serde` implementation in `blstrs` already performs the necessary point validation
        // by ultimately calling `GroupEncoding::from_bytes`.
        bcs::from_bytes::<Transcript>(bytes).map_err(|_| CryptoMaterialError::DeserializationError)
    }
```

**File:** crates/aptos-dkg/src/pvss/das/weighted_protocol.rs (L302-309)
```rust
        batch_verify_soks::<G1Projective, A>(
            self.soks.as_slice(),
            g_1,
            &self.V[W],
            spks,
            auxs,
            sok_vrfy_challenge,
        )?;
```

**File:** crates/aptos-dkg/src/pvss/contribution.rs (L56-68)
```rust
    // First, the PoKs
    let mut c = Gr::identity();
    for (_, c_i, _, _) in soks {
        c.add_assign(c_i)
    }

    if c.ne(pk) {
        bail!(
            "The PoK does not correspond to the dealt secret. Expected {} but got {}",
            pk,
            c
        );
    }
```

**File:** crates/aptos-dkg/src/pvss/contribution.rs (L70-76)
```rust
    let poks = soks
        .iter()
        .map(|(_, c, _, pok)| (*c, *pok))
        .collect::<Vec<(Gr, schnorr::PoK<Gr>)>>();

    // TODO(Performance): 128-bit exponents instead of powers of tau
    schnorr::pok_batch_verify::<Gr>(&poks, pk_base, &tau)?;
```
