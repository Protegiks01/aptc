# Audit Report

## Title
UTF-8 Boundary Panic in Logger Causes Validator Node Crash

## Summary
The `aptos_logger` crate contains a critical vulnerability where malformed UTF-8 strings can cause a panic when truncated at non-character boundaries, leading to complete validator node shutdown. An attacker can exploit this by submitting transactions or triggering events that log multi-byte UTF-8 characters positioned to cause truncation at invalid byte positions.

## Finding Description

The vulnerability exists in the `TruncatedLogString::new()` function which truncates log messages and field values to prevent excessive memory usage. [1](#0-0) 

The critical flaw is that `String::truncate()` panics if called at a position that is not on a UTF-8 character boundary. When logging data containing multi-byte UTF-8 characters (emoji, Chinese characters, etc.), if the string length causes truncation at exactly 10,240 bytes (the default `RUST_LOG_FIELD_MAX_LEN`), and this position falls within a multi-byte character sequence, the function will panic.

**Attack Path:**

1. Attacker submits a transaction or triggers any event that causes data to be logged
2. The payload contains multi-byte UTF-8 characters strategically positioned so truncation occurs mid-character (e.g., 10,237 ASCII chars + a 4-byte UTF-8 character like "ð•³")
3. During `LogEntry::new()`, the message or field values are processed through `TruncatedLogString::from()` [2](#0-1) 
4. The `truncate()` call panics in the LoggerService thread [3](#0-2) 
5. The global panic handler catches this and attempts to log/flush [4](#0-3) 
6. The panic handler exits the entire validator node process [5](#0-4) 

This breaks the **network availability invariant** - validators must remain operational to maintain consensus and network liveness.

## Impact Explanation

This vulnerability qualifies as **Critical Severity** under the Aptos Bug Bounty program criteria:

- **Total loss of liveness/network availability**: A single crafted transaction can crash an entire validator node, causing complete unavailability
- **Non-recoverable network partition**: If multiple validators are attacked simultaneously, the network could experience liveness failures requiring manual intervention
- **Consensus disruption**: Loss of validators reduces the validator set's ability to reach consensus

The crash is deterministic and repeatable, allowing an attacker to keep validators offline indefinitely through repeated attacks.

## Likelihood Explanation

**Likelihood: HIGH**

- **Attack Complexity**: Low - requires only crafting a string with specific UTF-8 character placement
- **Attacker Requirements**: Minimal - any transaction sender or network peer can trigger logging
- **Detectability**: Low - the attack appears as a normal transaction until the node crashes
- **Attack Vector**: Multiple entry points - transaction payloads, error messages, network peer data, any logged user input

The vulnerability is in a core logging component used throughout the entire codebase, making it widely exploitable across multiple attack surfaces.

## Recommendation

Replace the unsafe `truncate()` call with UTF-8-aware truncation that respects character boundaries:

```rust
fn new(s: String) -> Self {
    let mut truncated = s;
    
    if truncated.len() > RUST_LOG_FIELD_MAX_LEN.saturating_add(Self::TRUNCATION_SUFFIX.len()) {
        let mut truncate_at = *RUST_LOG_FIELD_MAX_LEN;
        
        // Find the nearest valid UTF-8 character boundary at or before truncate_at
        while truncate_at > 0 && !truncated.is_char_boundary(truncate_at) {
            truncate_at -= 1;
        }
        
        truncated.truncate(truncate_at);
        truncated.push_str(Self::TRUNCATION_SUFFIX);
    }
    TruncatedLogString(truncated)
}
```

This uses Rust's `is_char_boundary()` method to ensure truncation only occurs at valid UTF-8 boundaries.

## Proof of Concept

```rust
#[test]
#[should_panic(expected = "byte index 10240 is not a char boundary")]
fn test_utf8_boundary_panic() {
    use aptos_logger::aptos_logger::TruncatedLogString;
    
    // Create a string that will be truncated at byte 10,240
    // Use 10,237 ASCII characters + one 4-byte UTF-8 character (ð•³)
    let mut malicious_string = "A".repeat(10237);
    malicious_string.push('ð•³'); // U+1D573, 4 bytes in UTF-8: F0 9D 95 B3
    malicious_string.push_str("BBBBBBBBBB"); // Ensure length > 10,240 + 12
    
    // This will panic when truncating at byte 10,240, which is in the middle
    // of the 4-byte UTF-8 sequence for 'ð•³'
    let _ = TruncatedLogString::from(malicious_string);
}

#[test]
fn test_validator_crash_via_logging() {
    use aptos_logger::{info, Logger};
    
    // Initialize async logger (as used in production)
    Logger::builder()
        .is_async(true)
        .level(aptos_logger::Level::Info)
        .build();
    
    // Simulate attacker's malicious transaction data being logged
    let malicious_data = {
        let mut s = "A".repeat(10237);
        s.push('ð•³'); // 4-byte UTF-8 character
        s.push_str(&"B".repeat(1000));
        s
    };
    
    // This log will crash the logger service thread, which will trigger
    // the panic handler and exit the entire process
    info!(transaction_data = %malicious_data, "Processing transaction");
    
    // In production, the process would exit with code 12 at this point
}
```

**Notes:**

The vulnerability stems from an incorrect assumption that `String::truncate()` is safe for any byte position. Rust strings are UTF-8 encoded, and truncation must occur at character boundaries. The fix requires checking `is_char_boundary()` before truncation, a pattern used correctly elsewhere in the Aptos codebase. [6](#0-5) 

This issue affects all Aptos validator nodes and fullnodes running the affected logger code, making it a systemic availability vulnerability requiring immediate patching.

### Citations

**File:** crates/aptos-logger/src/aptos_logger.rs (L64-72)
```rust
    fn new(s: String) -> Self {
        let mut truncated = s;

        if truncated.len() > RUST_LOG_FIELD_MAX_LEN.saturating_add(Self::TRUNCATION_SUFFIX.len()) {
            truncated.truncate(*RUST_LOG_FIELD_MAX_LEN);
            truncated.push_str(Self::TRUNCATION_SUFFIX);
        }
        TruncatedLogString(truncated)
    }
```

**File:** crates/aptos-logger/src/aptos_logger.rs (L170-175)
```rust
                    Value::Debug(d) => serde_json::Value::String(
                        TruncatedLogString::from(format!("{:?}", d)).into(),
                    ),
                    Value::Display(d) => {
                        serde_json::Value::String(TruncatedLogString::from(d.to_string()).into())
                    },
```

**File:** crates/aptos-logger/src/aptos_logger.rs (L461-461)
```rust
            thread::spawn(move || service.run());
```

**File:** crates/crash-handler/src/lib.rs (L40-46)
```rust
    error!("{}", crash_info);
    // TODO / HACK ALARM: Write crash info synchronously via eprintln! to ensure it is written before the process exits which error! doesn't guarantee.
    // This is a workaround until https://github.com/aptos-labs/aptos-core/issues/2038 is resolved.
    eprintln!("{}", crash_info);

    // Wait till the logs have been flushed
    aptos_logger::flush();
```

**File:** crates/crash-handler/src/lib.rs (L56-57)
```rust
    // Kill the process
    process::exit(12);
```

**File:** aptos-move/framework/move-stdlib/src/natives/string.rs (L77-86)
```rust
        std::str::from_utf8_unchecked(s_ref.as_slice()).is_char_boundary(i as usize)
    };

    Ok(smallvec![Value::bool(ok)])
}

/***************************************************************************************************
 * native fun internal_sub_string
 *
 *   gas cost: base_cost + unit_cost * sub_string_length_in_bytes
```
