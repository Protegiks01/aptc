# Audit Report

## Title
Validator Fee Under-Distribution Due to Storage Refund Asymmetry in Fee Distribution Calculation

## Summary
The fee distribution calculation in `gen_block_epilogue` excludes the gross storage fee from distributable gas units but fails to account for storage refunds, causing validators to receive less transaction fees than intended when transactions delete storage. This breaks the validator reward calculation invariant and can be exploited to systematically reduce validator compensation.

## Finding Description

The Aptos fee system has an asymmetry between how transaction fees are burned versus how they are distributed to validators:

**Fee Burning (Correct):** [1](#0-0) 

The epilogue correctly calculates the net burn amount as:
- `burn_amount = transaction_fee_amount - storage_fee_refunded`
- `burn_amount = (total_charge_gas_units × gas_price) - storage_fee_refund_octas`

**Fee Distribution (Incorrect):** [2](#0-1) 

The distribution calculation subtracts only the GROSS storage fee, not accounting for refunds:
- `gas_unit_available_to_distribute = total_gas_unit - (storage_fee_used ÷ gas_price)`
- This should be: `total_gas_unit - ((storage_fee_used - storage_fee_refund) ÷ gas_price)`

**Root Cause:** [3](#0-2) 

The `FeeStatement` struct documents that `storage_fee_refund_octas` is excluded from `total_charge_gas_units`, but the distribution logic at [4](#0-3)  only subtracts gross storage fees, not net storage fees after refunds.

**Mathematical Example:**
- `gas_price` = 100 octas/unit
- `gas_price_to_burn` = 50 octas/unit  
- `total_charge_gas_units` = 800 (includes 300 units from storage fee)
- `storage_fee_octas` = 30,000
- `storage_fee_refund_octas` = 10,000

**User Net Payment:** 800 × 100 - 10,000 = 70,000 octas

**Current (Incorrect) Distribution:**
- Available units = 800 - 300 = 500
- Fee distributed = 500 × 50 = 25,000 octas

**Correct Distribution:**
- Net storage = (30,000 - 10,000) ÷ 100 = 200 units
- Available units = 800 - 200 = 600
- Fee distributed = 600 × 50 = 30,000 octas

**Validator Loss:** 5,000 octas (16.7% underpayment)

The validator fees are minted at epoch end via [5](#0-4) , so this under-distribution directly reduces validator compensation.

## Impact Explanation

**Severity: Medium** per Aptos bug bounty criteria - "Limited funds loss or manipulation"

1. **Validator Reward Manipulation:** Validators systematically receive less fees than economically intended when transactions involve storage deletions
2. **Economic Incentive Distortion:** Over time, this creates unfair compensation where validators processing transactions with storage refunds earn less
3. **Exploitability:** Any user can deliberately maximize storage refunds (create then delete resources/table entries) to reduce validator rewards
4. **Cumulative Impact:** The effect compounds across all transactions with storage refunds in each epoch

While not critical (no consensus break or total loss), this violates the **Staking Security** invariant: "Validator rewards and penalties must be calculated correctly."

## Likelihood Explanation

**High Likelihood:**

1. **Natural Occurrence:** Storage refunds happen organically when users delete resources, table entries, or clean up state - no malicious intent required
2. **Common Operations:** Many DeFi protocols involve position closures, order cancellations, and state cleanup that trigger refunds
3. **Automatic Effect:** Every transaction with non-zero `storage_fee_refund_octas` triggers the bug
4. **No Access Requirements:** Any transaction sender can trigger this, no special privileges needed
5. **Feature Enabled:** Storage deletion refunds are an active feature in the Aptos framework

## Recommendation

Modify the fee distribution calculation in `executor.rs` to account for net storage fees after refunds: [6](#0-5) 

**Current Code:**
```rust
let gas_unit_available_to_distribute = total_gas_unit
    .saturating_sub(fee_statement.storage_fee_used().div_ceil(gas_price));
```

**Fixed Code:**
```rust
// Calculate net storage fee after refunds
let net_storage_fee_octas = fee_statement.storage_fee_used()
    .saturating_sub(fee_statement.storage_fee_refund());
let net_storage_fee_gas_units = net_storage_fee_octas.div_ceil(gas_price);

let gas_unit_available_to_distribute = total_gas_unit
    .saturating_sub(net_storage_fee_gas_units);
```

This ensures the distributable amount reflects the net storage deposit (gross deposit minus refunds), aligning with the burn calculation logic.

## Proof of Concept

**Move Test Scenario:**

```move
#[test(framework = @aptos_framework, validator = @0x123, user = @0x456)]
public fun test_storage_refund_fee_distribution(
    framework: &signer,
    validator: &signer, 
    user: &signer
) {
    // Setup: Initialize validator and staking
    // Create resource with storage fee
    move_to(user, TestResource { value: 100 });
    
    // Execute transaction that deletes the resource
    // This generates storage_fee_refund_octas
    let resource = move_from<TestResource>(signer::address_of(user));
    destroy(resource);
    
    // Verify: Check validator's pending transaction fees
    // Expected: Should include fees from net storage (gross - refund)
    // Actual: Will be lower due to gross storage fee deduction
    let pending_fee = stake::get_pending_fee(validator_index);
    
    // The test would fail showing validators receive less than:
    // (execution_gas + io_gas + net_storage_gas) * (gas_price - burn_price)
}
```

**Rust Reproduction:**

Create a transaction with:
1. `storage_fee_octas` = 30,000
2. `storage_fee_refund_octas` = 10,000  
3. `gas_price` = 100
4. Observe `FeeDistribution` has 500 gas units available instead of 600
5. Validators receive 25,000 octas instead of 30,000 octas

The discrepancy is directly observable in the `FeeDistribution` struct passed to the block epilogue transaction at [7](#0-6) .

### Citations

**File:** aptos-move/framework/aptos-framework/sources/transaction_validation.move (L840-856)
```text
            if (transaction_fee_amount > storage_fee_refunded) {
                let burn_amount = transaction_fee_amount - storage_fee_refunded;
                transaction_fee::burn_fee(gas_payer_address, burn_amount);
                permissioned_signer::check_permission_consume(
                    &gas_payer,
                    (burn_amount as u256),
                    GasPermission {}
                );
            } else if (transaction_fee_amount < storage_fee_refunded) {
                let mint_amount = storage_fee_refunded - transaction_fee_amount;
                transaction_fee::mint_and_refund(gas_payer_address, mint_amount);
                permissioned_signer::increase_limit(
                    &gas_payer,
                    (mint_amount as u256),
                    GasPermission {}
                );
            };
```

**File:** aptos-move/block-executor/src/executor.rs (L2058-2065)
```rust
                    // Total gas unit here includes the storage fee (deposit), which is not
                    // available for distribution. Only the execution gas and IO gas are available
                    // to distribute. Note here we deliberately NOT use the execution gas and IO
                    // gas value from the fee statement, because they might round up during the
                    // calculation and the sum of them could be larger than the actual value we
                    // burn. Instead we use the total amount (which is the total we've burnt)
                    // minus the storage deposit (round up), to avoid over distribution.
                    // We burn a fix amount of gas per gas unit.
```

**File:** aptos-move/block-executor/src/executor.rs (L2068-2073)
```rust
                        let gas_unit_available_to_distribute = total_gas_unit
                            .saturating_sub(fee_statement.storage_fee_used().div_ceil(gas_price));
                        if gas_unit_available_to_distribute > 0 {
                            let fee_to_distribute =
                                gas_unit_available_to_distribute * (gas_price - gas_price_to_burn);
                            *amount.entry(proposer_index).or_insert(0) += fee_to_distribute;
```

**File:** aptos-move/block-executor/src/executor.rs (L2079-2083)
```rust
        Ok(T::block_epilogue_v1(
            block_id,
            block_end_info,
            FeeDistribution::new(amount),
        ))
```

**File:** types/src/fee_statement.rs (L22-24)
```rust
///    - storage deletion refund: `storage_fee_refund_octas`, this is not included in `gas_used` or
///      `total_charge_gas_units`, the net charge / refund is calculated by
///      `total_charge_gas_units` * `gas_unit_price` - `storage_fee_refund_octas`.
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L616-635)
```text
    public(friend) fun record_fee(
        vm: &signer,
        fee_distribution_validator_indices: vector<u64>,
        fee_amounts_octa: vector<u64>,
    ) acquires PendingTransactionFee {
        // Operational constraint: can only be invoked by the VM.
        system_addresses::assert_vm(vm);

        assert!(fee_distribution_validator_indices.length() == fee_amounts_octa.length());

        let num_validators_to_distribute = fee_distribution_validator_indices.length();
        let pending_fee = borrow_global_mut<PendingTransactionFee>(@aptos_framework);
        let i = 0;
        while (i < num_validators_to_distribute) {
            let validator_index = fee_distribution_validator_indices[i];
            let fee_octa = fee_amounts_octa[i];
            pending_fee.pending_fee_by_validator.borrow_mut(&validator_index).add(fee_octa);
            i = i + 1;
        }
    }
```
