# Audit Report

## Title
Inspection Service Exposes Validator Peer IDs with IP Addresses Enabling Operator De-anonymization

## Summary
The Aptos inspection service exposes validator peer IDs alongside their actual connection IP addresses through publicly accessible HTTP endpoints that are enabled by default. Since validator peer IDs are derived from their on-chain account addresses, attackers can correlate on-chain validator identities with real-world network locations and potentially identify individual operators, violating operator privacy guarantees.

## Finding Description

The inspection service provides two endpoints that, when combined, create a critical privacy vulnerability:

**1. Default Configuration Exposure**

The inspection service is configured to bind to all network interfaces (`0.0.0.0`) on port 9101 by default, with identity and peer information endpoints enabled: [1](#0-0) 

**2. Missing Sanitizer Protection**

The configuration sanitizer only validates that mainnet validators don't expose the configuration endpoint, but does NOT restrict `expose_identity_information` or `expose_peer_information`: [2](#0-1) 

**3. Peer ID Exposure via Identity Endpoint**

The `/identity_information` endpoint exposes the validator's own peer ID for both validator and fullnode networks: [3](#0-2) 

**4. Connection Metadata Exposure**

The `/peer_information` endpoint exposes connection metadata for all connected peers, including their network addresses: [4](#0-3) 

**5. IP Address in Connection Metadata**

The `ConnectionMetadata` structure contains the `addr` field of type `NetworkAddress` which stores the actual network address used for connections: [5](#0-4) 

**6. Network Address Contains IP Information**

The `NetworkAddress` type is a stack of protocols that includes `Ip4` and `Ip6` variants containing actual IP addresses: [6](#0-5) 

**7. Peer ID Equals Account Address for Validators**

For validator networks, the peer ID is directly derived from the validator's on-chain account address: [7](#0-6) 

**8. Peer ID Derivation from x25519 Public Key**

While peer IDs for network identity are derived from x25519 public keys (last 16 bytes), the critical issue is that for validators in the validator network, the peer_id is set to match their account_address: [8](#0-7) 

## Attack Path

1. **Discovery Phase**: Attacker scans for open port 9101 on known validator IP addresses or discovers them through network reconnaissance
2. **Identity Correlation**: Attacker queries `http://<validator-ip>:9101/identity_information` to obtain the validator's peer ID
3. **Peer Mapping**: Attacker queries `http://<validator-ip>:9101/peer_information` to obtain:
   - List of all connected peers with their peer IDs
   - Connection metadata containing actual IP addresses of connected peers
4. **On-Chain Linkage**: Since `peer_id = account_address` for validator networks, attacker correlates peer IDs with on-chain validator identities
5. **Physical Location Mapping**: Using IP addresses, attacker performs:
   - Geolocation services to determine physical locations
   - WHOIS lookups to identify ISPs, data centers, or hosting providers
   - ASN analysis to determine network ownership
6. **Operator Identification**: Attacker builds a comprehensive map linking:
   - On-chain validator accounts → Peer IDs → IP addresses → Physical locations → Potential operator identities

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos bug bounty program because it enables:

1. **Operator Privacy Violation**: Breaks the pseudonymity assumption of blockchain networks by enabling correlation of on-chain identities with real-world locations
2. **Targeted Attack Enablement**: Exposes validator infrastructure details that could facilitate:
   - Network-level DDoS attacks targeting specific validators
   - Physical security threats if locations can be identified
   - Social engineering attacks against identified operators
3. **Regulatory/Compliance Risks**: In jurisdictions with data protection regulations, exposing operator identities without consent may create legal liability
4. **Validator Participation Disincentive**: Privacy concerns may deter potential validators from participating in the network

While this does not directly impact consensus safety or cause fund loss, it represents a **significant protocol violation** of operator privacy expectations and could indirectly affect network security by enabling targeted attacks.

## Likelihood Explanation

**Likelihood: HIGH**

- **Exploitability**: Trivial - requires only HTTP GET requests to publicly accessible endpoints
- **Default Configuration**: Both endpoints are enabled by default on all network interfaces
- **No Authentication**: Inspection service requires no authentication or authorization
- **Mainnet Exposure**: No sanitizer prevents this on mainnet validators
- **Immediate Impact**: Attackers can immediately begin mapping the validator network

The attack requires no special privileges, no validator collusion, and no sophisticated tools - only basic network scanning and HTTP client capabilities.

## Recommendation

**Immediate Mitigation:**

1. **Update Default Configuration**: Bind inspection service to localhost by default:
```rust
address: "127.0.0.1".to_string(),  // Change from "0.0.0.0"
expose_identity_information: false,  // Disable by default
expose_peer_information: false,      // Disable by default
```

2. **Add Sanitizer Protection**: Extend the sanitizer to enforce privacy for mainnet validators:
```rust
impl ConfigSanitizer for InspectionServiceConfig {
    fn sanitize(
        node_config: &NodeConfig,
        node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();
        let inspection_service_config = &node_config.inspection_service;

        if let Some(chain_id) = chain_id {
            if node_type.is_validator() && chain_id.is_mainnet() {
                // Existing check for configuration
                if inspection_service_config.expose_configuration {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name,
                        "Mainnet validators should not expose the node configuration!".to_string(),
                    ));
                }
                
                // NEW: Add checks for identity and peer information
                if inspection_service_config.expose_identity_information {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name,
                        "Mainnet validators should not expose identity information!".to_string(),
                    ));
                }
                
                if inspection_service_config.expose_peer_information {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name,
                        "Mainnet validators should not expose peer information!".to_string(),
                    ));
                }
            }
        }

        Ok(())
    }
}
```

3. **Add Authentication**: Implement authentication/authorization for sensitive endpoints
4. **Redact Sensitive Data**: If endpoints must be exposed, redact IP addresses from connection metadata

## Proof of Concept

**Prerequisites:**
- Access to an Aptos validator node with default inspection service configuration
- Network connectivity to the validator's inspection service port (9101)

**Attack Steps:**

```bash
# Step 1: Discover validator inspection service
curl http://<validator-ip>:9101/

# Step 2: Query validator's own peer ID
curl http://<validator-ip>:9101/identity_information
# Output includes: "Validator network (validator), peer ID: 0xabcd..."

# Step 3: Query connected peers with IP addresses
curl http://<validator-ip>:9101/peer_information
# Output includes connection metadata with peer IDs and IP addresses:
# "Connection metadata for each peer:
#     - Peer: validator:0x1234, connection state: Connected, 
#       connection metadata: {"addr":"/ip4/203.0.113.42/tcp/6180/..."}"

# Step 4: Correlate peer_id with on-chain validator set
# Query blockchain API:
curl https://fullnode.mainnet.aptoslabs.com/v1/accounts/0x1/resource/0x1::stake::ValidatorSet

# Step 5: Map peer_id (0x1234) to account_address in validator set
# Step 6: Use IP address (203.0.113.42) for geolocation
curl https://ipapi.co/203.0.113.42/json/

# Result: Complete mapping of validator identity to physical location
```

**Expected Result**: Successful correlation of on-chain validator account addresses with real-world IP addresses and geographic locations, demonstrating the privacy vulnerability.

## Notes

This vulnerability affects **all Aptos validator nodes** running with default configuration on mainnet. The issue is particularly concerning because:

1. Validators may not be aware that these endpoints are publicly accessible by default
2. The configuration optimizer only enables these endpoints for non-mainnet chains, but they're already enabled by default
3. No warning or documentation clearly indicates the privacy implications of exposing these endpoints

The fix should be deployed urgently for mainnet validators, and operators should be notified to update their configurations immediately.

### Citations

**File:** config/src/config/inspection_service_config.rs (L26-36)
```rust
impl Default for InspectionServiceConfig {
    fn default() -> InspectionServiceConfig {
        InspectionServiceConfig {
            address: "0.0.0.0".to_string(),
            port: 9101,
            expose_configuration: false,
            expose_identity_information: true,
            expose_peer_information: true,
            expose_system_information: true,
        }
    }
```

**File:** config/src/config/inspection_service_config.rs (L45-68)
```rust
impl ConfigSanitizer for InspectionServiceConfig {
    fn sanitize(
        node_config: &NodeConfig,
        node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();
        let inspection_service_config = &node_config.inspection_service;

        // Verify that mainnet validators do not expose the configuration
        if let Some(chain_id) = chain_id {
            if node_type.is_validator()
                && chain_id.is_mainnet()
                && inspection_service_config.expose_configuration
            {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "Mainnet validators should not expose the node configuration!".to_string(),
                ));
            }
        }

        Ok(())
    }
```

**File:** crates/aptos-inspection-service/src/server/identity_information.rs (L29-51)
```rust
fn get_identity_information(node_config: &NodeConfig) -> String {
    let mut identity_information = Vec::<String>::new();
    identity_information.push("Identity Information:".into());

    // If the validator network is configured, fetch the identity information
    if let Some(validator_network) = &node_config.validator_network {
        identity_information.push(format!(
            "\t- Validator network ({}), peer ID: {}",
            validator_network.network_id,
            validator_network.peer_id()
        ));
    }

    // For each fullnode network, fetch the identity information
    for fullnode_network in &node_config.full_node_networks {
        identity_information.push(format!(
            "\t- Fullnode network ({}), peer ID: {}",
            fullnode_network.network_id,
            fullnode_network.peer_id()
        ));
    }

    identity_information.join("\n") // Separate each entry with a newline to construct the output
```

**File:** crates/aptos-inspection-service/src/server/peer_information.rs (L148-167)
```rust
/// Displays connection metadata for each peer
fn display_peer_connection_metadata(
    peer_information_output: &mut Vec<String>,
    all_peers: &Vec<PeerNetworkId>,
    peers_and_metadata: &PeersAndMetadata,
) {
    peer_information_output.push("Connection metadata for each peer:".into());

    // Fetch and display the connection metadata for each peer
    for peer in all_peers {
        if let Ok(peer_metadata) = peers_and_metadata.get_metadata_for_peer(*peer) {
            let connection_metadata = peer_metadata.get_connection_metadata();
            peer_information_output.push(format!(
                "\t- Peer: {}, connection state: {:?}, connection metadata: {}",
                peer,
                peer_metadata.get_connection_state(),
                serde_json::to_string(&connection_metadata).unwrap_or_default()
            ));
        }
    }
```

**File:** network/framework/src/transport/mod.rs (L98-108)
```rust
/// Metadata associated with an established and fully upgraded connection.
#[derive(Clone, Deserialize, Eq, PartialEq, Serialize)]
pub struct ConnectionMetadata {
    pub remote_peer_id: PeerId,
    pub connection_id: ConnectionId,
    pub addr: NetworkAddress,
    pub origin: ConnectionOrigin,
    pub messaging_protocol: MessagingProtocolVersion,
    pub application_protocols: ProtocolIdSet,
    pub role: PeerRole,
}
```

**File:** types/src/network_address/mod.rs (L110-127)
```rust
/// A single protocol in the [`NetworkAddress`] protocol stack.
#[derive(Clone, Debug, Eq, Hash, PartialEq, Deserialize, Serialize)]
#[cfg_attr(any(test, feature = "fuzzing"), derive(Arbitrary))]
pub enum Protocol {
    Ip4(Ipv4Addr),
    Ip6(Ipv6Addr),
    Dns(DnsName),
    Dns4(DnsName),
    Dns6(DnsName),
    Tcp(u16),
    Memory(u16),
    // human-readable x25519::PublicKey is lower-case hex encoded
    NoiseIK(x25519::PublicKey),
    // TODO(philiphayes): use actual handshake::MessagingProtocolVersion. we
    // probably need to move network wire into its own crate to avoid circular
    // dependency b/w network and types.
    Handshake(u8),
}
```

**File:** network/discovery/src/validator_set.rs (L107-149)
```rust
/// Extracts a set of ConnectivityRequests from a ValidatorSet which are appropriate for a network with type role.
pub(crate) fn extract_validator_set_updates(
    network_context: NetworkContext,
    node_set: ValidatorSet,
) -> PeerSet {
    let is_validator = network_context.network_id().is_validator_network();

    // Decode addresses while ignoring bad addresses
    node_set
        .into_iter()
        .map(|info| {
            let peer_id = *info.account_address();
            let config = info.into_config();

            let addrs = if is_validator {
                config
                    .validator_network_addresses()
                    .map_err(anyhow::Error::from)
            } else {
                config
                    .fullnode_network_addresses()
                    .map_err(anyhow::Error::from)
            }
            .map_err(|err| {
                inc_by_with_context(&DISCOVERY_COUNTS, &network_context, "read_failure", 1);

                warn!(
                    NetworkSchema::new(&network_context),
                    "OnChainDiscovery: Failed to parse any network address: peer: {}, err: {}",
                    peer_id,
                    err
                )
            })
            .unwrap_or_default();

            let peer_role = if is_validator {
                PeerRole::Validator
            } else {
                PeerRole::ValidatorFullNode
            };
            (peer_id, Peer::from_addrs(peer_role, addrs))
        })
        .collect()
```

**File:** types/src/account_address.rs (L140-146)
```rust
pub fn from_identity_public_key(identity_public_key: x25519::PublicKey) -> AccountAddress {
    let mut array = [0u8; AccountAddress::LENGTH];
    let pubkey_slice = identity_public_key.as_slice();
    // keep only the last 16 bytes
    array.copy_from_slice(&pubkey_slice[x25519::PUBLIC_KEY_SIZE - AccountAddress::LENGTH..]);
    AccountAddress::new(array)
}
```
