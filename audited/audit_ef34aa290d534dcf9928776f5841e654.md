# Audit Report

## Title
Unbounded Memory Allocation in Admin Service Block Dump Endpoint Enables Denial of Service Against Validator Nodes

## Summary
The `dump_blocks_bcs()` function in the admin service allocates unbounded memory when dumping all consensus blocks without size limits, allowing unauthenticated attackers on testnet/devnet (or misconfigured mainnet nodes) to trigger out-of-memory (OOM) crashes of validator nodes through a single HTTP request.

## Finding Description

The vulnerability exists in the admin service's consensus block dump functionality. When an attacker sends a request to `/debug/consensus/block?bcs=true`, the system loads ALL blocks from the consensus database into memory without any size limits or pagination.

**Attack Flow:**

1. **Unauthenticated Access**: On testnet/devnet, the admin service is enabled by default with no authentication. [1](#0-0) 

2. **Authentication Bypass**: If `authentication_configs` is empty (the default), all requests are automatically authenticated. [2](#0-1) 

3. **Endpoint Access**: The attacker accesses `/debug/consensus/block?bcs=true`, which routes to `dump_blocks_bcs()`. [3](#0-2) 

4. **Unbounded Memory Allocation**: The function performs the following without size checks:
   - Loads ALL blocks from consensus database [4](#0-3) 
   - Extracts transactions from each block [5](#0-4) 
   - **Clones** all transactions into a vector, doubling memory usage [6](#0-5) 
   - Serializes the entire vector with BCS, creating another copy [7](#0-6) 

5. **Memory Calculation**: With maximum configuration values:
   - Each block can contain up to 10,000 transactions [8](#0-7) 
   - During high load or network issues, consensus DB can retain 100+ blocks before pruning [9](#0-8) 
   - Average transaction size: ~1KB
   - Total memory: 100+ blocks × 10,000 txns × 1KB × 2 (cloning) = **2GB+ per request**

6. **No Rate Limiting**: There is no rate limiting on admin service endpoints, allowing repeated requests to exhaust memory completely.

This breaks the **Resource Limits invariant**: "All operations must respect gas, storage, and computational limits."

## Impact Explanation

**Severity: HIGH** (per Aptos Bug Bounty Program)

This vulnerability qualifies as **HIGH severity** because it enables:

1. **Validator Node Crashes**: Repeated requests cause OOM crashes, taking validators offline
2. **Network Liveness Impact**: If multiple validators are targeted simultaneously, consensus can be disrupted
3. **Zero Prerequisites**: On testnet/devnet, requires only network access with no authentication

The impact matches the HIGH severity criteria: "Validator node slowdowns" and "API crashes". While not directly causing consensus safety violations or fund loss, it significantly affects network availability and validator operations.

On mainnet, the admin service is disabled by default, reducing impact. However, misconfiguration (enabling without authentication) would make mainnet nodes vulnerable, potentially elevating this to **CRITICAL severity** due to the non-recoverable network partition risk.

## Likelihood Explanation

**Likelihood: HIGH on testnet/devnet, MEDIUM on mainnet**

**Testnet/Devnet:**
- Admin service enabled by default [10](#0-9) 
- No authentication required by default
- Trivial to exploit: single HTTP GET request
- No special knowledge or resources needed

**Mainnet:**
- Admin service disabled by default, reducing likelihood
- Requires operator misconfiguration (enabling without authentication)
- Config sanitizer enforces authentication on mainnet [11](#0-10) 

## Recommendation

Implement the following protections in `dump_blocks_bcs()`:

1. **Add Size Limits**: Implement maximum transaction count and memory limits
2. **Add Pagination**: Support block range queries instead of dumping all blocks
3. **Enforce Authentication**: Remove the authentication bypass for empty configs
4. **Add Rate Limiting**: Implement per-IP rate limiting on admin endpoints

**Proposed Fix for `dump_blocks_bcs()`:**

```rust
fn dump_blocks_bcs(
    consensus_db: &dyn PersistentLivenessStorage,
    quorum_store_db: &dyn QuorumStoreStorage,
    block_id: Option<HashValue>,
) -> anyhow::Result<Vec<u8>> {
    const MAX_TRANSACTIONS: usize = 100_000; // Add hard limit
    const MAX_BLOCKS: usize = 100; // Limit blocks processed
    
    let all_batches = quorum_store_db.get_all_batches()?;
    let (_, _, blocks, _) = consensus_db.consensus_db().get_data()?;
    
    let mut all_txns = Vec::new();
    let mut blocks_processed = 0;
    
    for block in blocks {
        if blocks_processed >= MAX_BLOCKS {
            bail!("Maximum block limit ({}) reached", MAX_BLOCKS);
        }
        
        let id = block.id();
        if block_id.is_none() || id == block_id.unwrap() {
            match extract_txns_from_block(&block, &all_batches) {
                Ok(txns) => {
                    if all_txns.len() + txns.len() > MAX_TRANSACTIONS {
                        bail!("Maximum transaction limit ({}) reached", MAX_TRANSACTIONS);
                    }
                    all_txns.extend(txns.into_iter().cloned().map(Transaction::UserTransaction));
                },
                Err(e) => bail!("Failed to extract txns from block ({id:?}): {e:?}."),
            };
            blocks_processed += 1;
        }
    }
    
    bcs::to_bytes(&all_txns).map_err(Error::msg)
}
```

Additionally, fix the authentication bypass:

```rust
// In mod.rs serve_requests function, replace lines 154-156:
let mut authenticated = false;
// Remove: if context.config.authentication_configs.is_empty() { authenticated = true; }
// Instead: require explicit authentication configuration
```

## Proof of Concept

**Rust Test Reproduction:**

```rust
#[tokio::test]
async fn test_oom_via_block_dump() {
    // Setup: Create consensus DB with many blocks containing many transactions
    let temp_dir = TempPath::new();
    let consensus_db = Arc::new(ConsensusDB::new(&temp_dir));
    let quorum_store_db = Arc::new(QuorumStoreDB::new(&temp_dir));
    
    // Populate with 200 blocks, each with 10,000 transactions
    for i in 0..200 {
        let mut block_txns = Vec::new();
        for j in 0..10000 {
            block_txns.push(create_test_transaction(i, j));
        }
        let block = create_test_block(i, block_txns);
        consensus_db.save_blocks_and_quorum_certificates(vec![block], vec![]).unwrap();
    }
    
    // Attack: Request dump of all blocks
    let request = Request::builder()
        .uri("/debug/consensus/block?bcs=true")
        .body(Body::empty())
        .unwrap();
    
    // This will allocate 200 * 10,000 * 1KB * 2 = ~4GB of memory
    let response = handle_dump_block_request(
        request,
        consensus_db,
        quorum_store_db,
    ).await;
    
    // Node crashes with OOM before reaching this point
}
```

**Manual Testing (Testnet/Devnet):**

```bash
# Find validator node admin service port (default 9102)
curl "http://validator-node:9102/debug/consensus/block?bcs=true"

# Monitor memory usage on validator node
# Repeat request to trigger OOM crash
for i in {1..10}; do
    curl "http://validator-node:9102/debug/consensus/block?bcs=true" &
done
```

## Notes

This vulnerability is particularly concerning because:

1. **Default Configuration Vulnerability**: The design decision to allow unauthenticated access when `authentication_configs` is empty creates a security-by-configuration problem that developers may not be aware of.

2. **Production Impact**: While mainnet has protections, testnet/devnet nodes are production systems used for development and testing, and their disruption has real consequences.

3. **Cascading Failures**: If multiple validators are targeted simultaneously, the network could experience consensus liveness issues until nodes recover.

4. **Debug Endpoint in Production**: Debug/admin endpoints should never be exposed without strong authentication and rate limiting, regardless of the network type.

### Citations

**File:** config/src/config/admin_service_config.rs (L41-50)
```rust
impl Default for AdminServiceConfig {
    fn default() -> Self {
        Self {
            enabled: None,
            address: "0.0.0.0".to_string(),
            port: 9102,
            authentication_configs: vec![],
            malloc_stats_max_len: 2 * 1024 * 1024,
        }
    }
```

**File:** config/src/config/admin_service_config.rs (L67-76)
```rust
        if node_config.admin_service.enabled == Some(true) {
            if let Some(chain_id) = chain_id {
                if chain_id.is_mainnet()
                    && node_config.admin_service.authentication_configs.is_empty()
                {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name,
                        "Must enable authentication for AdminService on mainnet.".into(),
                    ));
                }
```

**File:** config/src/config/admin_service_config.rs (L93-100)
```rust
        if node_config.admin_service.enabled.is_none() {
            // Only enable the admin service if the chain is not mainnet
            let admin_service_enabled = if let Some(chain_id) = chain_id {
                !chain_id.is_mainnet()
            } else {
                false // We cannot determine the chain ID, so we disable the admin service
            };
            node_config.admin_service.enabled = Some(admin_service_enabled);
```

**File:** crates/aptos-admin-service/src/server/mod.rs (L154-156)
```rust
        let mut authenticated = false;
        if context.config.authentication_configs.is_empty() {
            authenticated = true;
```

**File:** crates/aptos-admin-service/src/server/mod.rs (L216-228)
```rust
            (hyper::Method::GET, "/debug/consensus/block") => {
                let consensus_db = context.consensus_db.read().clone();
                let quorum_store_db = context.quorum_store_db.read().clone();
                if let Some(consensus_db) = consensus_db
                    && let Some(quorum_store_db) = quorum_store_db
                {
                    consensus::handle_dump_block_request(req, consensus_db, quorum_store_db).await
                } else {
                    Ok(reply_with_status(
                        StatusCode::NOT_FOUND,
                        "Consensus db and/or quorum store db is not available.",
                    ))
                }
```

**File:** crates/aptos-admin-service/src/server/consensus/mod.rs (L224-224)
```rust
    let (_, _, blocks, _) = consensus_db.consensus_db().get_data()?;
```

**File:** crates/aptos-admin-service/src/server/consensus/mod.rs (L230-233)
```rust
            match extract_txns_from_block(&block, &all_batches) {
                Ok(txns) => {
                    all_txns.extend(txns.into_iter().cloned().map(Transaction::UserTransaction));
                },
```

**File:** crates/aptos-admin-service/src/server/consensus/mod.rs (L239-239)
```rust
    bcs::to_bytes(&all_txns).map_err(Error::msg)
```

**File:** config/src/config/consensus_config.rs (L23-24)
```rust
pub(crate) static MAX_RECEIVING_BLOCK_TXNS: Lazy<u64> =
    Lazy::new(|| 10000.max(2 * MAX_SENDING_BLOCK_TXNS));
```

**File:** config/src/config/consensus_config.rs (L232-232)
```rust
            max_pruned_blocks_in_mem: 100,
```
