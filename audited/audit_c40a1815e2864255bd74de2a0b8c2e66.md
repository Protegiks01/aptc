# Audit Report

## Title
Malicious Peer Response Type Mismatches Bypass Peer Scoring System in State Sync

## Summary
Critical data streaming errors indicating malicious peer behavior (specifically response type mismatches) fail to trigger peer penalization, allowing malicious peers to repeatedly send invalid responses without consequence. The peer scoring system is bypassed because `notify_bad_response` is never called when `transform_client_response_into_notification` fails, and these errors are ultimately misclassified as generic `UnexpectedError` at the driver level. [1](#0-0) 

## Finding Description
The Aptos state sync system uses a peer scoring mechanism to track malicious or unreliable peers. When peers send responses with incorrect payload types (e.g., sending `StateValuesWithProof` when `TransactionsWithProof` was requested), this should be classified as potentially malicious behavior and trigger peer penalization. However, a critical gap exists in the error handling path.

When the data streaming service receives a response from a peer, it processes it through `send_data_notification_to_client`, which calls `transform_client_response_into_notification` to validate the response type. If the response type doesn't match the request, errors like `Error::AptosDataClientResponseIsInvalid` or `Error::UnexpectedErrorEncountered` are returned: [2](#0-1) [3](#0-2) 

The vulnerability occurs in `send_data_notification_to_client` where the `response_context` (containing the callback to penalize peers) is extracted but never used if an error occurs: [4](#0-3) 

When `transform_client_response_into_notification` fails (line 777-781 with `?`), the function returns immediately without calling `notify_bad_response`. Compare this to successful error handling at line 706 where sanity check failures properly trigger feedback: [5](#0-4) 

The peer scoring system distinguishes between `NotUseful` (0.95 multiplier) and `Malicious` (0.8 multiplier) errors, with peers ignored below a threshold of 25.0: [6](#0-5) 

Without proper feedback, malicious peers sending wrong response types maintain their score and continue to be selected for data requests.

**Attack Path:**
1. Malicious peer registers with the network as a data provider
2. When queried for transactions, it sends state values instead
3. `create_missing_epoch_ending_ledger_infos_request` or similar functions detect type mismatch and return `AptosDataClientResponseIsInvalid`
4. Error propagates through `send_data_notification_to_client` → `process_data_responses` → `update_progress_of_data_stream`
5. Error is caught and logged in `check_progress_of_all_data_streams` but NO feedback provided
6. Request is retried, potentially selecting same malicious peer again
7. Node wastes CPU, bandwidth, and time processing invalid responses
8. Legitimate state sync progress slows down

## Impact Explanation
This vulnerability meets **High Severity** criteria per the Aptos bug bounty program under "Validator node slowdowns." 

Malicious peers can repeatedly send mismatched response types, causing validators to:
- Waste computational resources validating invalid responses
- Consume network bandwidth downloading wrong data
- Experience delayed state synchronization
- Retry requests multiple times before succeeding

Since the peer scoring system fails to penalize these peers, they remain eligible for selection, creating a persistent performance degradation attack vector. This is particularly critical during:
- Fast sync/bootstrapping operations where nodes need to quickly catch up
- Epoch transitions requiring rapid state verification
- Network partitions where peer selection becomes limited

The impact scales with the number of malicious peers in the network, potentially causing significant degradation in state sync performance across multiple validator nodes.

## Likelihood Explanation
**Likelihood: High**

This vulnerability is highly likely to be exploited because:
1. **Low barrier to entry**: Any network peer can become a data provider
2. **Easy to execute**: Simply returning wrong payload types requires minimal effort
3. **Difficult to detect**: Errors are logged as generic issues without attribution
4. **No cost to attacker**: Malicious peer maintains good score and continues receiving requests
5. **Repeated exploitation**: Attack can be sustained indefinitely without consequence

The attack requires no special privileges, insider access, or complex setup. A malicious actor can deploy multiple peers exhibiting this behavior to maximize impact across the network.

## Recommendation
Add proper error handling to call `notify_bad_response` when `transform_client_response_into_notification` fails. Modify `send_data_notification_to_client` to:

```rust
async fn send_data_notification_to_client(
    &mut self,
    data_client_request: &DataClientRequest,
    data_client_response: Response<ResponsePayload>,
) -> Result<(), Error> {
    let (response_context, response_payload) = data_client_response.into_parts();

    // Create a new data notification
    match self
        .stream_engine
        .transform_client_response_into_notification(
            data_client_request,
            response_payload,
            self.notification_id_generator.clone(),
        ) {
        Ok(Some(data_notification)) => {
            // Existing success path...
            // Update metrics, save context, send notification
            Ok(())
        },
        Ok(None) => Ok(()), // Request was satisfied by previous chunk
        Err(error) => {
            // NEW: Provide feedback for type mismatches and invalid responses
            if matches!(error, Error::AptosDataClientResponseIsInvalid(_) | 
                              Error::UnexpectedErrorEncountered(_)) {
                self.notify_bad_response(&response_context, ResponseError::InvalidPayloadDataType);
            }
            Err(error)
        }
    }
}
```

Additionally, update the error conversion in state-sync-driver to preserve error semantics:
- `AptosDataClientResponseIsInvalid` → `InvalidPayload` (not `UnexpectedError`)
- Ensure verification-related errors map to `VerificationError`

## Proof of Concept

```rust
// Integration test demonstrating the vulnerability
#[tokio::test]
async fn test_malicious_peer_type_mismatch_not_penalized() {
    // Setup: Create data client with mock malicious peer
    let (mut mock_peer, peer_id) = create_mock_peer();
    let data_client = create_test_data_client(vec![mock_peer.clone()]);
    let mut data_stream = create_test_data_stream(data_client);
    
    // Initial peer score should be STARTING_SCORE (50.0)
    let initial_score = get_peer_score(&peer_id);
    assert_eq!(initial_score, 50.0);
    
    // Step 1: Request transactions from peer
    let request = DataClientRequest::TransactionsWithProof(
        TransactionsWithProofRequest {
            start_version: 0,
            end_version: 100,
            proof_version: 100,
            include_events: false,
        }
    );
    
    // Step 2: Malicious peer sends StateValuesWithProof instead
    mock_peer.configure_response(ResponsePayload::StateValuesWithProof(
        create_dummy_state_values()
    ));
    
    // Step 3: Process the response
    let result = data_stream.process_data_responses(&global_summary).await;
    assert!(result.is_err()); // Request fails due to type mismatch
    
    // Step 4: VULNERABILITY - Peer score should decrease but doesn't
    let final_score = get_peer_score(&peer_id);
    assert_eq!(final_score, 50.0); // Score unchanged!
    
    // Step 5: Verify peer still eligible for selection
    let selected_peer = data_client.choose_peer_for_request(&request);
    assert_eq!(selected_peer.peer_id, peer_id); // Malicious peer still selected!
    
    // Expected behavior: Score should be ~47.5 (50.0 * 0.95) after NOT_USEFUL penalty
    // or ~40.0 (50.0 * 0.8) after MALICIOUS penalty
}
```

**Notes**

This vulnerability represents a gap in the defense-in-depth strategy for malicious peer handling. While the feedback mechanism exists and is used in some error paths (sanity check failures), it's missing for response type mismatches that occur during transformation. This allows malicious peers to evade detection and maintain their reputation while degrading network performance.

The issue is exacerbated by the generic error classification at the driver level, where all streaming service errors become `UnexpectedError`, losing important context about the nature of the failure. Proper error classification throughout the stack is essential for security monitoring and incident response.

### Citations

**File:** state-sync/state-sync-driver/src/error.rs (L89-93)
```rust
impl From<aptos_data_streaming_service::error::Error> for Error {
    fn from(error: aptos_data_streaming_service::error::Error) -> Self {
        Error::UnexpectedError(error.to_string())
    }
}
```

**File:** state-sync/data-streaming-service/src/data_stream.rs (L695-708)
```rust
    /// Handles a client response that failed sanity checks
    fn handle_sanity_check_failure(
        &mut self,
        data_client_request: &DataClientRequest,
        response_context: &ResponseContext,
    ) -> Result<(), Error> {
        error!(LogSchema::new(LogEntry::ReceivedDataResponse)
            .stream_id(self.data_stream_id)
            .event(LogEvent::Error)
            .message("Encountered a client response that failed the sanity checks!"));

        self.notify_bad_response(response_context, ResponseError::InvalidPayloadDataType);
        self.resend_data_client_request(data_client_request)
    }
```

**File:** state-sync/data-streaming-service/src/data_stream.rs (L766-782)
```rust
    /// Sends a data notification to the client along the stream
    async fn send_data_notification_to_client(
        &mut self,
        data_client_request: &DataClientRequest,
        data_client_response: Response<ResponsePayload>,
    ) -> Result<(), Error> {
        let (response_context, response_payload) = data_client_response.into_parts();

        // Create a new data notification
        if let Some(data_notification) = self
            .stream_engine
            .transform_client_response_into_notification(
                data_client_request,
                response_payload,
                self.notification_id_generator.clone(),
            )?
        {
```

**File:** state-sync/data-streaming-service/src/data_stream.rs (L1097-1101)
```rust
        payload => Err(Error::AptosDataClientResponseIsInvalid(format!(
            "Invalid response payload found for epoch ending ledger info request: {:?}",
            payload
        ))),
    }
```

**File:** state-sync/data-streaming-service/src/stream_engine.rs (L49-56)
```rust
macro_rules! invalid_response_type {
    ($client_response:expr) => {
        return Err(Error::UnexpectedErrorEncountered(format!(
            "The client response is type mismatched: {:?}",
            $client_response
        )))
    };
}
```

**File:** state-sync/aptos-data-client/src/peer_states.rs (L32-63)
```rust
/// Scores for peer rankings based on preferences and behavior.
const MAX_SCORE: f64 = 100.0;
const MIN_SCORE: f64 = 0.0;
const STARTING_SCORE: f64 = 50.0;
/// Add this score on a successful response.
const SUCCESSFUL_RESPONSE_DELTA: f64 = 1.0;
/// Not necessarily a malicious response, but not super useful.
const NOT_USEFUL_MULTIPLIER: f64 = 0.95;
/// Likely to be a malicious response.
const MALICIOUS_MULTIPLIER: f64 = 0.8;
/// Ignore a peer when their score dips below this threshold.
const IGNORE_PEER_THRESHOLD: f64 = 25.0;

pub enum ErrorType {
    /// A response or error that's not actively malicious but also doesn't help
    /// us make progress, e.g., timeouts, remote errors, invalid data, etc...
    NotUseful,
    /// A response or error that appears to be actively hindering progress or
    /// attempting to deceive us, e.g., invalid proof.
    Malicious,
}

impl From<ResponseError> for ErrorType {
    fn from(error: ResponseError) -> Self {
        match error {
            ResponseError::InvalidData | ResponseError::InvalidPayloadDataType => {
                ErrorType::NotUseful
            },
            ResponseError::ProofVerificationError => ErrorType::Malicious,
        }
    }
}
```
